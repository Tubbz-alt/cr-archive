<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/provider/certpath/RevocationChecker.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.provider.certpath;
  27 
  28 import java.io.IOException;
  29 import java.math.BigInteger;
  30 import java.net.URI;
  31 import java.net.URISyntaxException;
  32 import java.security.AccessController;
  33 import java.security.InvalidAlgorithmParameterException;
  34 import java.security.NoSuchAlgorithmException;
  35 import java.security.PrivilegedAction;
  36 import java.security.PublicKey;
  37 import java.security.Security;
  38 import java.security.cert.CertPathValidatorException.BasicReason;
  39 import java.security.cert.Extension;
  40 import java.security.cert.*;
  41 import java.util.*;
  42 import javax.security.auth.x500.X500Principal;
  43 
  44 import static sun.security.provider.certpath.OCSP.*;
  45 import static sun.security.provider.certpath.PKIX.*;
  46 import sun.security.x509.*;
  47 import static sun.security.x509.PKIXExtensions.*;
  48 import sun.security.util.Debug;
<a name="1" id="anc1"></a><span class="line-added">  49 import sun.security.util.KnownOIDs;</span>
  50 
  51 class RevocationChecker extends PKIXRevocationChecker {
  52 
  53     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
  54 
  55     private TrustAnchor anchor;
  56     private ValidatorParams params;
  57     private boolean onlyEE;
  58     private boolean softFail;
  59     private boolean crlDP;
  60     private URI responderURI;
  61     private X509Certificate responderCert;
  62     private List&lt;CertStore&gt; certStores;
  63     private Map&lt;X509Certificate, byte[]&gt; ocspResponses;
  64     private List&lt;Extension&gt; ocspExtensions;
  65     private final boolean legacy;
  66     private LinkedList&lt;CertPathValidatorException&gt; softFailExceptions =
  67         new LinkedList&lt;&gt;();
  68 
  69     // state variables
  70     private OCSPResponse.IssuerInfo issuerInfo;
  71     private PublicKey prevPubKey;
  72     private boolean crlSignFlag;
  73     private int certIndex;
  74 
  75     private enum Mode { PREFER_OCSP, PREFER_CRLS, ONLY_CRLS, ONLY_OCSP };
  76     private Mode mode = Mode.PREFER_OCSP;
  77 
  78     private static class RevocationProperties {
  79         boolean onlyEE;
  80         boolean ocspEnabled;
  81         boolean crlDPEnabled;
  82         String ocspUrl;
  83         String ocspSubject;
  84         String ocspIssuer;
  85         String ocspSerial;
  86     }
  87 
  88     RevocationChecker() {
  89         legacy = false;
  90     }
  91 
  92     RevocationChecker(TrustAnchor anchor, ValidatorParams params)
  93         throws CertPathValidatorException
  94     {
  95         legacy = true;
  96         init(anchor, params);
  97     }
  98 
  99     void init(TrustAnchor anchor, ValidatorParams params)
 100         throws CertPathValidatorException
 101     {
 102         RevocationProperties rp = getRevocationProperties();
 103         URI uri = getOcspResponder();
 104         responderURI = (uri == null) ? toURI(rp.ocspUrl) : uri;
 105         X509Certificate cert = getOcspResponderCert();
 106         responderCert = (cert == null)
 107                         ? getResponderCert(rp, params.trustAnchors(),
 108                                            params.certStores())
 109                         : cert;
 110         Set&lt;Option&gt; options = getOptions();
 111         for (Option option : options) {
 112             switch (option) {
 113             case ONLY_END_ENTITY:
 114             case PREFER_CRLS:
 115             case SOFT_FAIL:
 116             case NO_FALLBACK:
 117                 break;
 118             default:
 119                 throw new CertPathValidatorException(
 120                     &quot;Unrecognized revocation parameter option: &quot; + option);
 121             }
 122         }
 123         softFail = options.contains(Option.SOFT_FAIL);
 124 
 125         // set mode, only end entity flag
 126         if (legacy) {
 127             mode = (rp.ocspEnabled) ? Mode.PREFER_OCSP : Mode.ONLY_CRLS;
 128             onlyEE = rp.onlyEE;
 129         } else {
 130             if (options.contains(Option.NO_FALLBACK)) {
 131                 if (options.contains(Option.PREFER_CRLS)) {
 132                     mode = Mode.ONLY_CRLS;
 133                 } else {
 134                     mode = Mode.ONLY_OCSP;
 135                 }
 136             } else if (options.contains(Option.PREFER_CRLS)) {
 137                 mode = Mode.PREFER_CRLS;
 138             }
 139             onlyEE = options.contains(Option.ONLY_END_ENTITY);
 140         }
 141         if (legacy) {
 142             crlDP = rp.crlDPEnabled;
 143         } else {
 144             crlDP = true;
 145         }
 146         ocspResponses = getOcspResponses();
 147         ocspExtensions = getOcspExtensions();
 148 
 149         this.anchor = anchor;
 150         this.params = params;
 151         this.certStores = new ArrayList&lt;&gt;(params.certStores());
 152         try {
 153             this.certStores.add(CertStore.getInstance(&quot;Collection&quot;,
 154                 new CollectionCertStoreParameters(params.certificates())));
 155         } catch (InvalidAlgorithmParameterException |
 156                  NoSuchAlgorithmException e) {
 157             // should never occur but not necessarily fatal, so log it,
 158             // ignore and continue
 159             if (debug != null) {
 160                 debug.println(&quot;RevocationChecker: &quot; +
 161                               &quot;error creating Collection CertStore: &quot; + e);
 162             }
 163         }
 164     }
 165 
 166     private static URI toURI(String uriString)
 167         throws CertPathValidatorException
 168     {
 169         try {
 170             if (uriString != null) {
 171                 return new URI(uriString);
 172             }
 173             return null;
 174         } catch (URISyntaxException e) {
 175             throw new CertPathValidatorException(
 176                 &quot;cannot parse ocsp.responderURL property&quot;, e);
 177         }
 178     }
 179 
 180     private static RevocationProperties getRevocationProperties() {
 181         return AccessController.doPrivileged(
 182             new PrivilegedAction&lt;RevocationProperties&gt;() {
 183                 public RevocationProperties run() {
 184                     RevocationProperties rp = new RevocationProperties();
 185                     String onlyEE = Security.getProperty(
 186                         &quot;com.sun.security.onlyCheckRevocationOfEECert&quot;);
 187                     rp.onlyEE = onlyEE != null
 188                                 &amp;&amp; onlyEE.equalsIgnoreCase(&quot;true&quot;);
 189                     String ocspEnabled = Security.getProperty(&quot;ocsp.enable&quot;);
 190                     rp.ocspEnabled = ocspEnabled != null
 191                                      &amp;&amp; ocspEnabled.equalsIgnoreCase(&quot;true&quot;);
 192                     rp.ocspUrl = Security.getProperty(&quot;ocsp.responderURL&quot;);
 193                     rp.ocspSubject
 194                         = Security.getProperty(&quot;ocsp.responderCertSubjectName&quot;);
 195                     rp.ocspIssuer
 196                         = Security.getProperty(&quot;ocsp.responderCertIssuerName&quot;);
 197                     rp.ocspSerial
 198                         = Security.getProperty(&quot;ocsp.responderCertSerialNumber&quot;);
 199                     rp.crlDPEnabled
 200                         = Boolean.getBoolean(&quot;com.sun.security.enableCRLDP&quot;);
 201                     return rp;
 202                 }
 203             }
 204         );
 205     }
 206 
 207     private static X509Certificate getResponderCert(RevocationProperties rp,
 208                                                     Set&lt;TrustAnchor&gt; anchors,
 209                                                     List&lt;CertStore&gt; stores)
 210         throws CertPathValidatorException
 211     {
 212         if (rp.ocspSubject != null) {
 213             return getResponderCert(rp.ocspSubject, anchors, stores);
 214         } else if (rp.ocspIssuer != null &amp;&amp; rp.ocspSerial != null) {
 215             return getResponderCert(rp.ocspIssuer, rp.ocspSerial,
 216                                     anchors, stores);
 217         } else if (rp.ocspIssuer != null || rp.ocspSerial != null) {
 218             throw new CertPathValidatorException(
 219                 &quot;Must specify both ocsp.responderCertIssuerName and &quot; +
 220                 &quot;ocsp.responderCertSerialNumber properties&quot;);
 221         }
 222         return null;
 223     }
 224 
 225     private static X509Certificate getResponderCert(String subject,
 226                                                     Set&lt;TrustAnchor&gt; anchors,
 227                                                     List&lt;CertStore&gt; stores)
 228         throws CertPathValidatorException
 229     {
 230         X509CertSelector sel = new X509CertSelector();
 231         try {
 232             sel.setSubject(new X500Principal(subject));
 233         } catch (IllegalArgumentException e) {
 234             throw new CertPathValidatorException(
 235                 &quot;cannot parse ocsp.responderCertSubjectName property&quot;, e);
 236         }
 237         return getResponderCert(sel, anchors, stores);
 238     }
 239 
 240     private static X509Certificate getResponderCert(String issuer,
 241                                                     String serial,
 242                                                     Set&lt;TrustAnchor&gt; anchors,
 243                                                     List&lt;CertStore&gt; stores)
 244         throws CertPathValidatorException
 245     {
 246         X509CertSelector sel = new X509CertSelector();
 247         try {
 248             sel.setIssuer(new X500Principal(issuer));
 249         } catch (IllegalArgumentException e) {
 250             throw new CertPathValidatorException(
 251                 &quot;cannot parse ocsp.responderCertIssuerName property&quot;, e);
 252         }
 253         try {
 254             sel.setSerialNumber(new BigInteger(stripOutSeparators(serial), 16));
 255         } catch (NumberFormatException e) {
 256             throw new CertPathValidatorException(
 257                 &quot;cannot parse ocsp.responderCertSerialNumber property&quot;, e);
 258         }
 259         return getResponderCert(sel, anchors, stores);
 260     }
 261 
 262     private static X509Certificate getResponderCert(X509CertSelector sel,
 263                                                     Set&lt;TrustAnchor&gt; anchors,
 264                                                     List&lt;CertStore&gt; stores)
 265         throws CertPathValidatorException
 266     {
 267         // first check TrustAnchors
 268         for (TrustAnchor anchor : anchors) {
 269             X509Certificate cert = anchor.getTrustedCert();
 270             if (cert == null) {
 271                 continue;
 272             }
 273             if (sel.match(cert)) {
 274                 return cert;
 275             }
 276         }
 277         // now check CertStores
 278         for (CertStore store : stores) {
 279             try {
 280                 Collection&lt;? extends Certificate&gt; certs =
 281                     store.getCertificates(sel);
 282                 if (!certs.isEmpty()) {
 283                     return (X509Certificate)certs.iterator().next();
 284                 }
 285             } catch (CertStoreException e) {
 286                 // ignore and try next CertStore
 287                 if (debug != null) {
 288                     debug.println(&quot;CertStore exception:&quot; + e);
 289                 }
 290                 continue;
 291             }
 292         }
 293         throw new CertPathValidatorException(
 294             &quot;Cannot find the responder&#39;s certificate &quot; +
 295             &quot;(set using the OCSP security properties).&quot;);
 296     }
 297 
 298     @Override
 299     public void init(boolean forward) throws CertPathValidatorException {
 300         if (forward) {
 301             throw new
 302                 CertPathValidatorException(&quot;forward checking not supported&quot;);
 303         }
 304         if (anchor != null) {
 305             issuerInfo = new OCSPResponse.IssuerInfo(anchor);
 306             prevPubKey = issuerInfo.getPublicKey();
 307 
 308         }
 309         crlSignFlag = true;
 310         if (params != null &amp;&amp; params.certPath() != null) {
 311             certIndex = params.certPath().getCertificates().size() - 1;
 312         } else {
 313             certIndex = -1;
 314         }
 315         softFailExceptions.clear();
 316     }
 317 
 318     @Override
 319     public boolean isForwardCheckingSupported() {
 320         return false;
 321     }
 322 
 323     @Override
 324     public Set&lt;String&gt; getSupportedExtensions() {
 325         return null;
 326     }
 327 
 328     @Override
 329     public List&lt;CertPathValidatorException&gt; getSoftFailExceptions() {
 330         return Collections.unmodifiableList(softFailExceptions);
 331     }
 332 
 333     @Override
 334     public void check(Certificate cert, Collection&lt;String&gt; unresolvedCritExts)
 335         throws CertPathValidatorException
 336     {
 337         check((X509Certificate)cert, unresolvedCritExts,
 338               prevPubKey, crlSignFlag);
 339     }
 340 
 341     private void check(X509Certificate xcert,
 342                        Collection&lt;String&gt; unresolvedCritExts,
 343                        PublicKey pubKey, boolean crlSignFlag)
 344         throws CertPathValidatorException
 345     {
 346         if (debug != null) {
 347             debug.println(&quot;RevocationChecker.check: checking cert&quot; +
 348                 &quot;\n  SN: &quot; + Debug.toHexString(xcert.getSerialNumber()) +
 349                 &quot;\n  Subject: &quot; + xcert.getSubjectX500Principal() +
 350                 &quot;\n  Issuer: &quot; + xcert.getIssuerX500Principal());
 351         }
 352         try {
 353             if (onlyEE &amp;&amp; xcert.getBasicConstraints() != -1) {
 354                 if (debug != null) {
 355                     debug.println(&quot;Skipping revocation check; cert is not &quot; +
 356                                   &quot;an end entity cert&quot;);
 357                 }
 358                 return;
 359             }
 360             switch (mode) {
 361                 case PREFER_OCSP:
 362                 case ONLY_OCSP:
 363                     checkOCSP(xcert, unresolvedCritExts);
 364                     break;
 365                 case PREFER_CRLS:
 366                 case ONLY_CRLS:
 367                     checkCRLs(xcert, unresolvedCritExts, null,
 368                               pubKey, crlSignFlag);
 369                     break;
 370             }
 371         } catch (CertPathValidatorException e) {
 372             if (e.getReason() == BasicReason.REVOKED) {
 373                 throw e;
 374             }
 375             boolean eSoftFail = isSoftFailException(e);
 376             if (eSoftFail) {
 377                 if (mode == Mode.ONLY_OCSP || mode == Mode.ONLY_CRLS) {
 378                     return;
 379                 }
 380             } else {
 381                 if (mode == Mode.ONLY_OCSP || mode == Mode.ONLY_CRLS) {
 382                     throw e;
 383                 }
 384             }
 385             CertPathValidatorException cause = e;
 386             // Otherwise, failover
 387             if (debug != null) {
 388                 debug.println(&quot;RevocationChecker.check() &quot; + e.getMessage());
 389                 debug.println(&quot;RevocationChecker.check() preparing to failover&quot;);
 390             }
 391             try {
 392                 switch (mode) {
 393                     case PREFER_OCSP:
 394                         checkCRLs(xcert, unresolvedCritExts, null,
 395                                   pubKey, crlSignFlag);
 396                         break;
 397                     case PREFER_CRLS:
 398                         checkOCSP(xcert, unresolvedCritExts);
 399                         break;
 400                 }
 401             } catch (CertPathValidatorException x) {
 402                 if (debug != null) {
 403                     debug.println(&quot;RevocationChecker.check() failover failed&quot;);
 404                     debug.println(&quot;RevocationChecker.check() &quot; + x.getMessage());
 405                 }
 406                 if (x.getReason() == BasicReason.REVOKED) {
 407                     throw x;
 408                 }
 409                 if (!isSoftFailException(x)) {
 410                     cause.addSuppressed(x);
 411                     throw cause;
 412                 } else {
 413                     // only pass if both exceptions were soft failures
 414                     if (!eSoftFail) {
 415                         throw cause;
 416                     }
 417                 }
 418             }
 419         } finally {
 420             updateState(xcert);
 421         }
 422     }
 423 
 424     private boolean isSoftFailException(CertPathValidatorException e) {
 425         if (softFail &amp;&amp;
 426             e.getReason() == BasicReason.UNDETERMINED_REVOCATION_STATUS)
 427         {
 428             // recreate exception with correct index
 429             CertPathValidatorException e2 = new CertPathValidatorException(
 430                 e.getMessage(), e.getCause(), params.certPath(), certIndex,
 431                 e.getReason());
 432             softFailExceptions.addFirst(e2);
 433             return true;
 434         }
 435         return false;
 436     }
 437 
 438     private void updateState(X509Certificate cert)
 439         throws CertPathValidatorException
 440     {
 441         issuerInfo = new OCSPResponse.IssuerInfo(anchor, cert);
 442 
 443         // Make new public key if parameters are missing
 444         PublicKey pubKey = cert.getPublicKey();
 445         if (PKIX.isDSAPublicKeyWithoutParams(pubKey)) {
 446             // pubKey needs to inherit DSA parameters from prev key
 447             pubKey = BasicChecker.makeInheritedParamsKey(pubKey, prevPubKey);
 448         }
 449         prevPubKey = pubKey;
 450         crlSignFlag = certCanSignCrl(cert);
 451         if (certIndex &gt; 0) {
 452             certIndex--;
 453         }
 454     }
 455 
 456     // Maximum clock skew in milliseconds (15 minutes) allowed when checking
 457     // validity of CRLs
 458     private static final long MAX_CLOCK_SKEW = 900000;
 459     private void checkCRLs(X509Certificate cert,
 460                            Collection&lt;String&gt; unresolvedCritExts,
 461                            Set&lt;X509Certificate&gt; stackedCerts,
 462                            PublicKey pubKey, boolean signFlag)
 463         throws CertPathValidatorException
 464     {
 465         checkCRLs(cert, pubKey, null, signFlag, true,
 466                   stackedCerts, params.trustAnchors());
 467     }
 468 
 469     static boolean isCausedByNetworkIssue(String type, CertStoreException cse) {
 470         boolean result;
 471         Throwable t = cse.getCause();
 472 
 473         switch (type) {
 474             case &quot;LDAP&quot;:
 475                 if (t != null) {
 476                     // These two exception classes are inside java.naming module
 477                     String cn = t.getClass().getName();
 478                     result = (cn.equals(&quot;javax.naming.ServiceUnavailableException&quot;) ||
 479                         cn.equals(&quot;javax.naming.CommunicationException&quot;));
 480                 } else {
 481                     result = false;
 482                 }
 483                 break;
 484             case &quot;SSLServer&quot;:
 485                 result = (t != null &amp;&amp; t instanceof IOException);
 486                 break;
 487             case &quot;URI&quot;:
 488                 result = (t != null &amp;&amp; t instanceof IOException);
 489                 break;
 490             default:
 491                 // we don&#39;t know about any other remote CertStore types
 492                 return false;
 493         }
 494         return result;
 495     }
 496 
 497     private void checkCRLs(X509Certificate cert, PublicKey prevKey,
 498                            X509Certificate prevCert, boolean signFlag,
 499                            boolean allowSeparateKey,
 500                            Set&lt;X509Certificate&gt; stackedCerts,
 501                            Set&lt;TrustAnchor&gt; anchors)
 502         throws CertPathValidatorException
 503     {
 504         if (debug != null) {
 505             debug.println(&quot;RevocationChecker.checkCRLs()&quot; +
 506                           &quot; ---checking revocation status ...&quot;);
 507         }
 508 
 509         // Reject circular dependencies - RFC 5280 is not explicit on how
 510         // to handle this, but does suggest that they can be a security
 511         // risk and can create unresolvable dependencies
 512         if (stackedCerts != null &amp;&amp; stackedCerts.contains(cert)) {
 513             if (debug != null) {
 514                 debug.println(&quot;RevocationChecker.checkCRLs()&quot; +
 515                               &quot; circular dependency&quot;);
 516             }
 517             throw new CertPathValidatorException
 518                  (&quot;Could not determine revocation status&quot;, null, null, -1,
 519                   BasicReason.UNDETERMINED_REVOCATION_STATUS);
 520         }
 521 
 522         Set&lt;X509CRL&gt; possibleCRLs = new HashSet&lt;&gt;();
 523         Set&lt;X509CRL&gt; approvedCRLs = new HashSet&lt;&gt;();
 524         X509CRLSelector sel = new X509CRLSelector();
 525         sel.setCertificateChecking(cert);
 526         CertPathHelper.setDateAndTime(sel, params.date(), MAX_CLOCK_SKEW);
 527 
 528         // First, check user-specified CertStores
 529         CertPathValidatorException networkFailureException = null;
 530         for (CertStore store : certStores) {
 531             try {
 532                 for (CRL crl : store.getCRLs(sel)) {
 533                     possibleCRLs.add((X509CRL)crl);
 534                 }
 535             } catch (CertStoreException e) {
 536                 if (debug != null) {
 537                     debug.println(&quot;RevocationChecker.checkCRLs() &quot; +
 538                                   &quot;CertStoreException: &quot; + e.getMessage());
 539                 }
 540                 if (networkFailureException == null &amp;&amp;
 541                     isCausedByNetworkIssue(store.getType(),e)) {
 542                     // save this exception, we may need to throw it later
 543                     networkFailureException = new CertPathValidatorException(
 544                         &quot;Unable to determine revocation status due to &quot; +
 545                         &quot;network error&quot;, e, null, -1,
 546                         BasicReason.UNDETERMINED_REVOCATION_STATUS);
 547                 }
 548             }
 549         }
 550 
 551         if (debug != null) {
 552             debug.println(&quot;RevocationChecker.checkCRLs() &quot; +
 553                           &quot;possible crls.size() = &quot; + possibleCRLs.size());
 554         }
 555         boolean[] reasonsMask = new boolean[9];
 556         if (!possibleCRLs.isEmpty()) {
 557             // Now that we have a list of possible CRLs, see which ones can
 558             // be approved
 559             approvedCRLs.addAll(verifyPossibleCRLs(possibleCRLs, cert, prevKey,
 560                                                    signFlag, reasonsMask,
 561                                                    anchors));
 562         }
 563 
 564         if (debug != null) {
 565             debug.println(&quot;RevocationChecker.checkCRLs() &quot; +
 566                           &quot;approved crls.size() = &quot; + approvedCRLs.size());
 567         }
 568 
 569         // make sure that we have at least one CRL that _could_ cover
 570         // the certificate in question and all reasons are covered
 571         if (!approvedCRLs.isEmpty() &amp;&amp;
 572             Arrays.equals(reasonsMask, ALL_REASONS))
 573         {
 574             checkApprovedCRLs(cert, approvedCRLs);
 575         } else {
 576             // Check Distribution Points
 577             // all CRLs returned by the DP Fetcher have also been verified
 578             try {
 579                 if (crlDP) {
 580                     approvedCRLs.addAll(DistributionPointFetcher.getCRLs(
 581                                         sel, signFlag, prevKey, prevCert,
 582                                         params.sigProvider(), certStores,
 583                                         reasonsMask, anchors, null, params.variant()));
 584                 }
 585             } catch (CertStoreException e) {
 586                 if (e instanceof CertStoreTypeException) {
 587                     CertStoreTypeException cste = (CertStoreTypeException)e;
 588                     if (isCausedByNetworkIssue(cste.getType(), e)) {
 589                         throw new CertPathValidatorException(
 590                             &quot;Unable to determine revocation status due to &quot; +
 591                             &quot;network error&quot;, e, null, -1,
 592                             BasicReason.UNDETERMINED_REVOCATION_STATUS);
 593                     }
 594                 }
 595                 throw new CertPathValidatorException(e);
 596             }
 597             if (!approvedCRLs.isEmpty() &amp;&amp;
 598                 Arrays.equals(reasonsMask, ALL_REASONS))
 599             {
 600                 checkApprovedCRLs(cert, approvedCRLs);
 601             } else {
 602                 if (allowSeparateKey) {
 603                     try {
 604                         verifyWithSeparateSigningKey(cert, prevKey, signFlag,
 605                                                      stackedCerts);
 606                         return;
 607                     } catch (CertPathValidatorException cpve) {
 608                         if (networkFailureException != null) {
 609                             // if a network issue previously prevented us from
 610                             // retrieving a CRL from one of the user-specified
 611                             // CertStores, throw it now so it can be handled
 612                             // appropriately
 613                             throw networkFailureException;
 614                         }
 615                         throw cpve;
 616                     }
 617                 } else {
 618                     if (networkFailureException != null) {
 619                         // if a network issue previously prevented us from
 620                         // retrieving a CRL from one of the user-specified
 621                         // CertStores, throw it now so it can be handled
 622                         // appropriately
 623                         throw networkFailureException;
 624                     }
 625                     throw new CertPathValidatorException(
 626                         &quot;Could not determine revocation status&quot;, null, null, -1,
 627                         BasicReason.UNDETERMINED_REVOCATION_STATUS);
 628                 }
 629             }
 630         }
 631     }
 632 
 633     private void checkApprovedCRLs(X509Certificate cert,
 634                                    Set&lt;X509CRL&gt; approvedCRLs)
 635         throws CertPathValidatorException
 636     {
 637         // See if the cert is in the set of approved crls.
 638         if (debug != null) {
 639             BigInteger sn = cert.getSerialNumber();
 640             debug.println(&quot;RevocationChecker.checkApprovedCRLs() &quot; +
 641                           &quot;starting the final sweep...&quot;);
 642             debug.println(&quot;RevocationChecker.checkApprovedCRLs()&quot; +
 643                           &quot; cert SN: &quot; + sn.toString());
 644         }
 645 
 646         CRLReason reasonCode = CRLReason.UNSPECIFIED;
 647         X509CRLEntryImpl entry = null;
 648         for (X509CRL crl : approvedCRLs) {
 649             X509CRLEntry e = crl.getRevokedCertificate(cert);
 650             if (e != null) {
 651                 try {
 652                     entry = X509CRLEntryImpl.toImpl(e);
 653                 } catch (CRLException ce) {
 654                     throw new CertPathValidatorException(ce);
 655                 }
 656                 if (debug != null) {
 657                     debug.println(&quot;RevocationChecker.checkApprovedCRLs()&quot;
 658                         + &quot; CRL entry: &quot; + entry.toString());
 659                 }
 660 
 661                 /*
 662                  * Abort CRL validation and throw exception if there are any
 663                  * unrecognized critical CRL entry extensions (see section
 664                  * 5.3 of RFC 5280).
 665                  */
 666                 Set&lt;String&gt; unresCritExts = entry.getCriticalExtensionOIDs();
 667                 if (unresCritExts != null &amp;&amp; !unresCritExts.isEmpty()) {
 668                     /* remove any that we will process */
 669                     unresCritExts.remove(ReasonCode_Id.toString());
 670                     unresCritExts.remove(CertificateIssuer_Id.toString());
 671                     if (!unresCritExts.isEmpty()) {
 672                         throw new CertPathValidatorException(
 673                             &quot;Unrecognized critical extension(s) in revoked &quot; +
 674                             &quot;CRL entry&quot;);
 675                     }
 676                 }
 677 
 678                 reasonCode = entry.getRevocationReason();
 679                 if (reasonCode == null) {
 680                     reasonCode = CRLReason.UNSPECIFIED;
 681                 }
 682                 Date revocationDate = entry.getRevocationDate();
 683                 if (revocationDate.before(params.date())) {
 684                     Throwable t = new CertificateRevokedException(
 685                         revocationDate, reasonCode,
 686                         crl.getIssuerX500Principal(), entry.getExtensions());
 687                     throw new CertPathValidatorException(
 688                         t.getMessage(), t, null, -1, BasicReason.REVOKED);
 689                 }
 690             }
 691         }
 692     }
 693 
 694     private void checkOCSP(X509Certificate cert,
 695                            Collection&lt;String&gt; unresolvedCritExts)
 696         throws CertPathValidatorException
 697     {
 698         X509CertImpl currCert = null;
 699         try {
 700             currCert = X509CertImpl.toImpl(cert);
 701         } catch (CertificateException ce) {
 702             throw new CertPathValidatorException(ce);
 703         }
 704 
 705         // The algorithm constraints of the OCSP trusted responder certificate
 706         // does not need to be checked in this code. The constraints will be
 707         // checked when the responder&#39;s certificate is validated.
 708 
 709         OCSPResponse response = null;
 710         CertId certId = null;
 711         try {
 712             certId = new CertId(issuerInfo.getName(), issuerInfo.getPublicKey(),
 713                     currCert.getSerialNumberObject());
 714 
 715             // check if there is a cached OCSP response available
 716             byte[] responseBytes = ocspResponses.get(cert);
 717             if (responseBytes != null) {
 718                 if (debug != null) {
 719                     debug.println(&quot;Found cached OCSP response&quot;);
 720                 }
 721                 response = new OCSPResponse(responseBytes);
 722 
 723                 // verify the response
 724                 byte[] nonce = null;
 725                 for (Extension ext : ocspExtensions) {
<a name="2" id="anc2"></a><span class="line-modified"> 726                     if (ext.getId().equals(KnownOIDs.OCSPNonceExt.value())) {</span>
 727                         nonce = ext.getValue();
 728                     }
 729                 }
 730                 response.verify(Collections.singletonList(certId), issuerInfo,
 731                         responderCert, params.date(), nonce, params.variant());
 732 
 733             } else {
 734                 URI responderURI = (this.responderURI != null)
 735                                    ? this.responderURI
 736                                    : OCSP.getResponderURI(currCert);
 737                 if (responderURI == null) {
 738                     throw new CertPathValidatorException(
 739                         &quot;Certificate does not specify OCSP responder&quot;, null,
 740                         null, -1);
 741                 }
 742 
 743                 response = OCSP.check(Collections.singletonList(certId),
 744                         responderURI, issuerInfo, responderCert, null,
 745                         ocspExtensions, params.variant());
 746             }
 747         } catch (IOException e) {
 748             throw new CertPathValidatorException(
 749                 &quot;Unable to determine revocation status due to network error&quot;,
 750                 e, null, -1, BasicReason.UNDETERMINED_REVOCATION_STATUS);
 751         }
 752 
 753         RevocationStatus rs =
 754             (RevocationStatus)response.getSingleResponse(certId);
 755         RevocationStatus.CertStatus certStatus = rs.getCertStatus();
 756         if (certStatus == RevocationStatus.CertStatus.REVOKED) {
 757             Date revocationTime = rs.getRevocationTime();
 758             if (revocationTime.before(params.date())) {
 759                 Throwable t = new CertificateRevokedException(
 760                     revocationTime, rs.getRevocationReason(),
 761                     response.getSignerCertificate().getSubjectX500Principal(),
 762                     rs.getSingleExtensions());
 763                 throw new CertPathValidatorException(t.getMessage(), t, null,
 764                                                      -1, BasicReason.REVOKED);
 765             }
 766         } else if (certStatus == RevocationStatus.CertStatus.UNKNOWN) {
 767             throw new CertPathValidatorException(
 768                 &quot;Certificate&#39;s revocation status is unknown&quot;, null,
 769                 params.certPath(), -1,
 770                 BasicReason.UNDETERMINED_REVOCATION_STATUS);
 771         }
 772     }
 773 
 774     /*
 775      * Removes any non-hexadecimal characters from a string.
 776      */
 777     private static final String HEX_DIGITS = &quot;0123456789ABCDEFabcdef&quot;;
 778     private static String stripOutSeparators(String value) {
 779         char[] chars = value.toCharArray();
 780         StringBuilder hexNumber = new StringBuilder();
 781         for (int i = 0; i &lt; chars.length; i++) {
 782             if (HEX_DIGITS.indexOf(chars[i]) != -1) {
 783                 hexNumber.append(chars[i]);
 784             }
 785         }
 786         return hexNumber.toString();
 787     }
 788 
 789     /**
 790      * Checks that a cert can be used to verify a CRL.
 791      *
 792      * @param cert an X509Certificate to check
 793      * @return a boolean specifying if the cert is allowed to vouch for the
 794      *         validity of a CRL
 795      */
 796     static boolean certCanSignCrl(X509Certificate cert) {
 797         // if the cert doesn&#39;t include the key usage ext, or
 798         // the key usage ext asserts cRLSigning, return true,
 799         // otherwise return false.
 800         boolean[] keyUsage = cert.getKeyUsage();
 801         if (keyUsage != null) {
 802             return keyUsage[6];
 803         }
 804         return false;
 805     }
 806 
 807     /**
 808      * Internal method that verifies a set of possible_crls,
 809      * and sees if each is approved, based on the cert.
 810      *
 811      * @param crls a set of possible CRLs to test for acceptability
 812      * @param cert the certificate whose revocation status is being checked
 813      * @param signFlag &lt;code&gt;true&lt;/code&gt; if prevKey was trusted to sign CRLs
 814      * @param prevKey the public key of the issuer of cert
 815      * @param reasonsMask the reason code mask
 816      * @param trustAnchors a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;TrustAnchor&lt;/code&gt;s&gt;
 817      * @return a collection of approved crls (or an empty collection)
 818      */
 819     private static final boolean[] ALL_REASONS =
 820         {true, true, true, true, true, true, true, true, true};
 821     private Collection&lt;X509CRL&gt; verifyPossibleCRLs(Set&lt;X509CRL&gt; crls,
 822                                                    X509Certificate cert,
 823                                                    PublicKey prevKey,
 824                                                    boolean signFlag,
 825                                                    boolean[] reasonsMask,
 826                                                    Set&lt;TrustAnchor&gt; anchors)
 827         throws CertPathValidatorException
 828     {
 829         try {
 830             X509CertImpl certImpl = X509CertImpl.toImpl(cert);
 831             if (debug != null) {
 832                 debug.println(&quot;RevocationChecker.verifyPossibleCRLs: &quot; +
 833                               &quot;Checking CRLDPs for &quot;
 834                               + certImpl.getSubjectX500Principal());
 835             }
 836             CRLDistributionPointsExtension ext =
 837                 certImpl.getCRLDistributionPointsExtension();
 838             List&lt;DistributionPoint&gt; points = null;
 839             if (ext == null) {
 840                 // assume a DP with reasons and CRLIssuer fields omitted
 841                 // and a DP name of the cert issuer.
 842                 // TODO add issuerAltName too
 843                 X500Name certIssuer = (X500Name)certImpl.getIssuerDN();
 844                 DistributionPoint point = new DistributionPoint(
 845                      new GeneralNames().add(new GeneralName(certIssuer)),
 846                      null, null);
 847                 points = Collections.singletonList(point);
 848             } else {
 849                 points = ext.get(CRLDistributionPointsExtension.POINTS);
 850             }
 851             Set&lt;X509CRL&gt; results = new HashSet&lt;&gt;();
 852             for (DistributionPoint point : points) {
 853                 for (X509CRL crl : crls) {
 854                     if (DistributionPointFetcher.verifyCRL(
 855                             certImpl, point, crl, reasonsMask, signFlag,
 856                             prevKey, null, params.sigProvider(), anchors,
 857                             certStores, params.date(), params.variant()))
 858                     {
 859                         results.add(crl);
 860                     }
 861                 }
 862                 if (Arrays.equals(reasonsMask, ALL_REASONS))
 863                     break;
 864             }
 865             return results;
 866         } catch (CertificateException | CRLException | IOException e) {
 867             if (debug != null) {
 868                 debug.println(&quot;Exception while verifying CRL: &quot;+e.getMessage());
 869                 e.printStackTrace();
 870             }
 871             return Collections.emptySet();
 872         }
 873     }
 874 
 875     /**
 876      * We have a cert whose revocation status couldn&#39;t be verified by
 877      * a CRL issued by the cert that issued the CRL. See if we can
 878      * find a valid CRL issued by a separate key that can verify the
 879      * revocation status of this certificate.
 880      * &lt;p&gt;
 881      * Note that this does not provide support for indirect CRLs,
 882      * only CRLs signed with a different key (but the same issuer
 883      * name) as the certificate being checked.
 884      *
 885      * @param cert the &lt;code&gt;X509Certificate&lt;/code&gt; to be checked
 886      * @param prevKey the &lt;code&gt;PublicKey&lt;/code&gt; that failed
 887      * @param signFlag &lt;code&gt;true&lt;/code&gt; if that key was trusted to sign CRLs
 888      * @param stackedCerts a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;X509Certificate&lt;/code&gt;s
 889      *                     whose revocation status depends on the
 890      *                     non-revoked status of this cert. To avoid
 891      *                     circular dependencies, we assume they&#39;re
 892      *                     revoked while checking the revocation
 893      *                     status of this cert.
 894      * @throws CertPathValidatorException if the cert&#39;s revocation status
 895      *         cannot be verified successfully with another key
 896      */
 897     private void verifyWithSeparateSigningKey(X509Certificate cert,
 898                                               PublicKey prevKey,
 899                                               boolean signFlag,
 900                                               Set&lt;X509Certificate&gt; stackedCerts)
 901         throws CertPathValidatorException
 902     {
 903         String msg = &quot;revocation status&quot;;
 904         if (debug != null) {
 905             debug.println(
 906                 &quot;RevocationChecker.verifyWithSeparateSigningKey()&quot; +
 907                 &quot; ---checking &quot; + msg + &quot;...&quot;);
 908         }
 909 
 910         // Reject circular dependencies - RFC 5280 is not explicit on how
 911         // to handle this, but does suggest that they can be a security
 912         // risk and can create unresolvable dependencies
 913         if ((stackedCerts != null) &amp;&amp; stackedCerts.contains(cert)) {
 914             if (debug != null) {
 915                 debug.println(
 916                     &quot;RevocationChecker.verifyWithSeparateSigningKey()&quot; +
 917                     &quot; circular dependency&quot;);
 918             }
 919             throw new CertPathValidatorException
 920                 (&quot;Could not determine revocation status&quot;, null, null, -1,
 921                  BasicReason.UNDETERMINED_REVOCATION_STATUS);
 922         }
 923 
 924         // Try to find another key that might be able to sign
 925         // CRLs vouching for this cert.
 926         // If prevKey wasn&#39;t trusted, maybe we just didn&#39;t have the right
 927         // path to it. Don&#39;t rule that key out.
 928         if (!signFlag) {
 929             buildToNewKey(cert, null, stackedCerts);
 930         } else {
 931             buildToNewKey(cert, prevKey, stackedCerts);
 932         }
 933     }
 934 
 935     /**
 936      * Tries to find a CertPath that establishes a key that can be
 937      * used to verify the revocation status of a given certificate.
 938      * Ignores keys that have previously been tried. Throws a
 939      * CertPathValidatorException if no such key could be found.
 940      *
 941      * @param currCert the &lt;code&gt;X509Certificate&lt;/code&gt; to be checked
 942      * @param prevKey the &lt;code&gt;PublicKey&lt;/code&gt; of the certificate whose key
 943      *    cannot be used to vouch for the CRL and should be ignored
 944      * @param stackedCerts a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;X509Certificate&lt;/code&gt;s&gt;
 945      *                     whose revocation status depends on the
 946      *                     establishment of this path.
 947      * @throws CertPathValidatorException on failure
 948      */
 949     private static final boolean [] CRL_SIGN_USAGE =
 950         { false, false, false, false, false, false, true };
 951     private void buildToNewKey(X509Certificate currCert,
 952                                PublicKey prevKey,
 953                                Set&lt;X509Certificate&gt; stackedCerts)
 954         throws CertPathValidatorException
 955     {
 956 
 957         if (debug != null) {
 958             debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +
 959                           &quot; starting work&quot;);
 960         }
 961         Set&lt;PublicKey&gt; badKeys = new HashSet&lt;&gt;();
 962         if (prevKey != null) {
 963             badKeys.add(prevKey);
 964         }
 965         X509CertSelector certSel = new RejectKeySelector(badKeys);
 966         certSel.setSubject(currCert.getIssuerX500Principal());
 967         certSel.setKeyUsage(CRL_SIGN_USAGE);
 968 
 969         Set&lt;TrustAnchor&gt; newAnchors = anchor == null ?
 970                                       params.trustAnchors() :
 971                                       Collections.singleton(anchor);
 972 
 973         PKIXBuilderParameters builderParams;
 974         try {
 975             builderParams = new PKIXBuilderParameters(newAnchors, certSel);
 976         } catch (InvalidAlgorithmParameterException iape) {
 977             throw new RuntimeException(iape); // should never occur
 978         }
 979         builderParams.setInitialPolicies(params.initialPolicies());
 980         builderParams.setCertStores(certStores);
 981         builderParams.setExplicitPolicyRequired
 982             (params.explicitPolicyRequired());
 983         builderParams.setPolicyMappingInhibited
 984             (params.policyMappingInhibited());
 985         builderParams.setAnyPolicyInhibited(params.anyPolicyInhibited());
 986         // Policy qualifiers must be rejected, since we don&#39;t have
 987         // any way to convey them back to the application.
 988         // That&#39;s the default, so no need to write code.
 989         builderParams.setDate(params.date());
 990         builderParams.setCertPathCheckers(params.certPathCheckers());
 991         builderParams.setSigProvider(params.sigProvider());
 992 
 993         // Skip revocation during this build to detect circular
 994         // references. But check revocation afterwards, using the
 995         // key (or any other that works).
 996         builderParams.setRevocationEnabled(false);
 997 
 998         // check for AuthorityInformationAccess extension
 999         if (Builder.USE_AIA == true) {
1000             X509CertImpl currCertImpl = null;
1001             try {
1002                 currCertImpl = X509CertImpl.toImpl(currCert);
1003             } catch (CertificateException ce) {
1004                 // ignore but log it
1005                 if (debug != null) {
1006                     debug.println(&quot;RevocationChecker.buildToNewKey: &quot; +
1007                                   &quot;error decoding cert: &quot; + ce);
1008                 }
1009             }
1010             AuthorityInfoAccessExtension aiaExt = null;
1011             if (currCertImpl != null) {
1012                 aiaExt = currCertImpl.getAuthorityInfoAccessExtension();
1013             }
1014             if (aiaExt != null) {
1015                 List&lt;AccessDescription&gt; adList = aiaExt.getAccessDescriptions();
1016                 if (adList != null) {
1017                     for (AccessDescription ad : adList) {
1018                         CertStore cs = URICertStore.getInstance(ad);
1019                         if (cs != null) {
1020                             if (debug != null) {
1021                                 debug.println(&quot;adding AIAext CertStore&quot;);
1022                             }
1023                             builderParams.addCertStore(cs);
1024                         }
1025                     }
1026                 }
1027             }
1028         }
1029 
1030         CertPathBuilder builder = null;
1031         try {
1032             builder = CertPathBuilder.getInstance(&quot;PKIX&quot;);
1033         } catch (NoSuchAlgorithmException nsae) {
1034             throw new CertPathValidatorException(nsae);
1035         }
1036         while (true) {
1037             try {
1038                 if (debug != null) {
1039                     debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +
1040                                   &quot; about to try build ...&quot;);
1041                 }
1042                 PKIXCertPathBuilderResult cpbr =
1043                     (PKIXCertPathBuilderResult)builder.build(builderParams);
1044 
1045                 if (debug != null) {
1046                     debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +
1047                                   &quot; about to check revocation ...&quot;);
1048                 }
1049                 // Now check revocation of all certs in path, assuming that
1050                 // the stackedCerts are revoked.
1051                 if (stackedCerts == null) {
1052                     stackedCerts = new HashSet&lt;X509Certificate&gt;();
1053                 }
1054                 stackedCerts.add(currCert);
1055                 TrustAnchor ta = cpbr.getTrustAnchor();
1056                 PublicKey prevKey2 = ta.getCAPublicKey();
1057                 if (prevKey2 == null) {
1058                     prevKey2 = ta.getTrustedCert().getPublicKey();
1059                 }
1060                 boolean signFlag = true;
1061                 List&lt;? extends Certificate&gt; cpList =
1062                     cpbr.getCertPath().getCertificates();
1063                 try {
1064                     for (int i = cpList.size() - 1; i &gt;= 0; i--) {
1065                         X509Certificate cert = (X509Certificate) cpList.get(i);
1066 
1067                         if (debug != null) {
1068                             debug.println(&quot;RevocationChecker.buildToNewKey()&quot;
1069                                     + &quot; index &quot; + i + &quot; checking &quot;
1070                                     + cert);
1071                         }
1072                         checkCRLs(cert, prevKey2, null, signFlag, true,
1073                                 stackedCerts, newAnchors);
1074                         signFlag = certCanSignCrl(cert);
1075                         prevKey2 = cert.getPublicKey();
1076                     }
1077                 } catch (CertPathValidatorException cpve) {
1078                     // ignore it and try to get another key
1079                     badKeys.add(cpbr.getPublicKey());
1080                     continue;
1081                 }
1082 
1083                 if (debug != null) {
1084                     debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +
1085                                   &quot; got key &quot; + cpbr.getPublicKey());
1086                 }
1087                 // Now check revocation on the current cert using that key and
1088                 // the corresponding certificate.
1089                 // If it doesn&#39;t check out, try to find a different key.
1090                 // And if we can&#39;t find a key, then return false.
1091                 PublicKey newKey = cpbr.getPublicKey();
1092                 X509Certificate newCert = cpList.isEmpty() ?
1093                     null : (X509Certificate) cpList.get(0);
1094                 try {
1095                     checkCRLs(currCert, newKey, newCert,
1096                               true, false, null, params.trustAnchors());
1097                     // If that passed, the cert is OK!
1098                     return;
1099                 } catch (CertPathValidatorException cpve) {
1100                     // If it is revoked, rethrow exception
1101                     if (cpve.getReason() == BasicReason.REVOKED) {
1102                         throw cpve;
1103                     }
1104                     // Otherwise, ignore the exception and
1105                     // try to get another key.
1106                 }
1107                 badKeys.add(newKey);
1108             } catch (InvalidAlgorithmParameterException iape) {
1109                 throw new CertPathValidatorException(iape);
1110             } catch (CertPathBuilderException cpbe) {
1111                 throw new CertPathValidatorException
1112                     (&quot;Could not determine revocation status&quot;, null, null,
1113                      -1, BasicReason.UNDETERMINED_REVOCATION_STATUS);
1114             }
1115         }
1116     }
1117 
1118     /*
1119      * This inner class extends the X509CertSelector to add an additional
1120      * check to make sure the subject public key isn&#39;t on a particular list.
1121      * This class is used by buildToNewKey() to make sure the builder doesn&#39;t
1122      * end up with a CertPath to a public key that has already been rejected.
1123      */
1124     private static class RejectKeySelector extends X509CertSelector {
1125         private final Set&lt;PublicKey&gt; badKeySet;
1126 
1127         /**
1128          * Creates a new &lt;code&gt;RejectKeySelector&lt;/code&gt;.
1129          *
1130          * @param badPublicKeys a &lt;code&gt;Set&lt;/code&gt; of
1131          *                      &lt;code&gt;PublicKey&lt;/code&gt;s that
1132          *                      should be rejected (or &lt;code&gt;null&lt;/code&gt;
1133          *                      if no such check should be done)
1134          */
1135         RejectKeySelector(Set&lt;PublicKey&gt; badPublicKeys) {
1136             this.badKeySet = badPublicKeys;
1137         }
1138 
1139         /**
1140          * Decides whether a &lt;code&gt;Certificate&lt;/code&gt; should be selected.
1141          *
1142          * @param cert the &lt;code&gt;Certificate&lt;/code&gt; to be checked
1143          * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Certificate&lt;/code&gt; should be
1144          *         selected, &lt;code&gt;false&lt;/code&gt; otherwise
1145          */
1146         @Override
1147         public boolean match(Certificate cert) {
1148             if (!super.match(cert))
1149                 return(false);
1150 
1151             if (badKeySet.contains(cert.getPublicKey())) {
1152                 if (debug != null)
1153                     debug.println(&quot;RejectKeySelector.match: bad key&quot;);
1154                 return false;
1155             }
1156 
1157             if (debug != null)
1158                 debug.println(&quot;RejectKeySelector.match: returning true&quot;);
1159             return true;
1160         }
1161 
1162         /**
1163          * Return a printable representation of the &lt;code&gt;CertSelector&lt;/code&gt;.
1164          *
1165          * @return a &lt;code&gt;String&lt;/code&gt; describing the contents of the
1166          *         &lt;code&gt;CertSelector&lt;/code&gt;
1167          */
1168         @Override
1169         public String toString() {
1170             StringBuilder sb = new StringBuilder();
1171             sb.append(&quot;RejectKeySelector: [\n&quot;);
1172             sb.append(super.toString());
1173             sb.append(badKeySet);
1174             sb.append(&quot;]&quot;);
1175             return sb.toString();
1176         }
1177     }
1178 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
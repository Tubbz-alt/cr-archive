<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/pkcs/PKCS9Attribute.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.pkcs;
 27 
 28 import java.io.IOException;
 29 import java.io.OutputStream;
 30 import java.security.cert.CertificateException;
 31 import java.util.Locale;
 32 import java.util.Date;
 33 import java.util.HashMap;
 34 import sun.security.x509.CertificateExtensions;
<a name="1" id="anc1"></a><span class="line-modified"> 35 import sun.security.util.Debug;</span>
<span class="line-removed"> 36 import sun.security.util.DerEncoder;</span>
<span class="line-removed"> 37 import sun.security.util.DerValue;</span>
<span class="line-removed"> 38 import sun.security.util.DerInputStream;</span>
<span class="line-removed"> 39 import sun.security.util.DerOutputStream;</span>
<span class="line-removed"> 40 import sun.security.util.ObjectIdentifier;</span>
<span class="line-removed"> 41 import sun.security.util.HexDumpEncoder;</span>
 42 
 43 /**
 44  * Class supporting any PKCS9 attributes.
 45  * Supports DER decoding/encoding and access to attribute values.
 46  *
 47  * &lt;a name=&quot;classTable&quot;&gt;&lt;h3&gt;Type/Class Table&lt;/h3&gt;&lt;/a&gt;
 48  * The following table shows the correspondence between
 49  * PKCS9 attribute types and value component classes.
 50  * For types not listed here, its name is the OID
 51  * in string form, its value is a (single-valued)
 52  * byte array that is the SET&#39;s encoding.
 53  *
 54  * &lt;TABLE BORDER CELLPADDING=8 ALIGN=CENTER&gt;
 55  *
 56  * &lt;TR&gt;
 57  * &lt;TH&gt;Object Identifier&lt;/TH&gt;
 58  * &lt;TH&gt;Attribute Name&lt;/TH&gt;
 59  * &lt;TH&gt;Type&lt;/TH&gt;
 60  * &lt;TH&gt;Value Class&lt;/TH&gt;
 61  * &lt;/TR&gt;
 62  *
 63  * &lt;TR&gt;
 64  * &lt;TD&gt;1.2.840.113549.1.9.1&lt;/TD&gt;
 65  * &lt;TD&gt;EmailAddress&lt;/TD&gt;
 66  * &lt;TD&gt;Multi-valued&lt;/TD&gt;
 67  * &lt;TD&gt;&lt;code&gt;String[]&lt;/code&gt;&lt;/TD&gt;
 68  * &lt;/TR&gt;
 69  *
 70  * &lt;TR&gt;
 71  * &lt;TD&gt;1.2.840.113549.1.9.2&lt;/TD&gt;
 72  * &lt;TD&gt;UnstructuredName&lt;/TD&gt;
 73  * &lt;TD&gt;Multi-valued&lt;/TD&gt;
 74  * &lt;TD&gt;&lt;code&gt;String[]&lt;/code&gt;&lt;/TD&gt;
 75  * &lt;/TR&gt;
 76  *
 77  * &lt;TR&gt;
 78  * &lt;TD&gt;1.2.840.113549.1.9.3&lt;/TD&gt;
 79  * &lt;TD&gt;ContentType&lt;/TD&gt;
 80  * &lt;TD&gt;Single-valued&lt;/TD&gt;
 81  * &lt;TD&gt;&lt;code&gt;ObjectIdentifier&lt;/code&gt;&lt;/TD&gt;
 82  * &lt;/TR&gt;
 83  *
 84  * &lt;TR&gt;
 85  * &lt;TD&gt;1.2.840.113549.1.9.4&lt;/TD&gt;
 86  * &lt;TD&gt;MessageDigest&lt;/TD&gt;
 87  * &lt;TD&gt;Single-valued&lt;/TD&gt;
 88  * &lt;TD&gt;&lt;code&gt;byte[]&lt;/code&gt;&lt;/TD&gt;
 89  * &lt;/TR&gt;
 90  *
 91  * &lt;TR&gt;
 92  * &lt;TD&gt;1.2.840.113549.1.9.5&lt;/TD&gt;
 93  * &lt;TD&gt;SigningTime&lt;/TD&gt;
 94  * &lt;TD&gt;Single-valued&lt;/TD&gt;
 95  * &lt;TD&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/TD&gt;
 96  * &lt;/TR&gt;
 97  *
 98  * &lt;TR&gt;
 99  * &lt;TD&gt;1.2.840.113549.1.9.6&lt;/TD&gt;
100  * &lt;TD&gt;Countersignature&lt;/TD&gt;
101  * &lt;TD&gt;Multi-valued&lt;/TD&gt;
102  * &lt;TD&gt;&lt;code&gt;SignerInfo[]&lt;/code&gt;&lt;/TD&gt;
103  * &lt;/TR&gt;
104  *
105  * &lt;TR&gt;
106  * &lt;TD&gt;1.2.840.113549.1.9.7&lt;/TD&gt;
107  * &lt;TD&gt;ChallengePassword&lt;/TD&gt;
108  * &lt;TD&gt;Single-valued&lt;/TD&gt;
109  * &lt;TD&gt;&lt;code&gt;String&lt;/code&gt;&lt;/TD&gt;
110  * &lt;/TR&gt;
111  *
112  * &lt;TR&gt;
113  * &lt;TD&gt;1.2.840.113549.1.9.8&lt;/TD&gt;
114  * &lt;TD&gt;UnstructuredAddress&lt;/TD&gt;
115  * &lt;TD&gt;Single-valued&lt;/TD&gt;
116  * &lt;TD&gt;&lt;code&gt;String&lt;/code&gt;&lt;/TD&gt;
117  * &lt;/TR&gt;
118  *
119  * &lt;TR&gt;
120  * &lt;TD&gt;1.2.840.113549.1.9.9&lt;/TD&gt;
121  * &lt;TD&gt;ExtendedCertificateAttributes&lt;/TD&gt;
122  * &lt;TD&gt;Multi-valued&lt;/TD&gt;
123  * &lt;TD&gt;(not supported)&lt;/TD&gt;
124  * &lt;/TR&gt;
125  *
126  * &lt;TR&gt;
127  * &lt;TD&gt;1.2.840.113549.1.9.10&lt;/TD&gt;
128  * &lt;TD&gt;IssuerAndSerialNumber&lt;/TD&gt;
129  * &lt;TD&gt;Single-valued&lt;/TD&gt;
130  * &lt;TD&gt;(not supported)&lt;/TD&gt;
131  * &lt;/TR&gt;
132  *
133  * &lt;TR&gt;
134  * &lt;TD&gt;1.2.840.113549.1.9.{11,12}&lt;/TD&gt;
135  * &lt;TD&gt;RSA DSI proprietary&lt;/TD&gt;
136  * &lt;TD&gt;Single-valued&lt;/TD&gt;
137  * &lt;TD&gt;(not supported)&lt;/TD&gt;
138  * &lt;/TR&gt;
139  *
140  * &lt;TR&gt;
141  * &lt;TD&gt;1.2.840.113549.1.9.13&lt;/TD&gt;
142  * &lt;TD&gt;S/MIME unused assignment&lt;/TD&gt;
143  * &lt;TD&gt;Single-valued&lt;/TD&gt;
144  * &lt;TD&gt;(not supported)&lt;/TD&gt;
145  * &lt;/TR&gt;
146  *
147  * &lt;TR&gt;
148  * &lt;TD&gt;1.2.840.113549.1.9.14&lt;/TD&gt;
149  * &lt;TD&gt;ExtensionRequest&lt;/TD&gt;
150  * &lt;TD&gt;Single-valued&lt;/TD&gt;
151  * &lt;TD&gt;CertificateExtensions&lt;/TD&gt;
152  * &lt;/TR&gt;
153  *
154  * &lt;TR&gt;
155  * &lt;TD&gt;1.2.840.113549.1.9.15&lt;/TD&gt;
156  * &lt;TD&gt;SMIMECapability&lt;/TD&gt;
157  * &lt;TD&gt;Single-valued&lt;/TD&gt;
158  * &lt;TD&gt;(not supported)&lt;/TD&gt;
159  * &lt;/TR&gt;
160  *
161  * &lt;TR&gt;
162  * &lt;TD&gt;1.2.840.113549.1.9.16.2.12&lt;/TD&gt;
163  * &lt;TD&gt;SigningCertificate&lt;/TD&gt;
164  * &lt;TD&gt;Single-valued&lt;/TD&gt;
165  * &lt;TD&gt;SigningCertificateInfo&lt;/TD&gt;
166  * &lt;/TR&gt;
167  *
168  * &lt;TR&gt;
169  * &lt;TD&gt;1.2.840.113549.1.9.16.2.14&lt;/TD&gt;
170  * &lt;TD&gt;SignatureTimestampToken&lt;/TD&gt;
171  * &lt;TD&gt;Single-valued&lt;/TD&gt;
172  * &lt;TD&gt;byte[]&lt;/TD&gt;
173  * &lt;/TR&gt;
174  *
175  * &lt;/TABLE&gt;
176  *
177  * @author Douglas Hoover
178  */
179 public class PKCS9Attribute implements DerEncoder {
180 
181     /* Are we debugging ? */
182     private static final Debug debug = Debug.getInstance(&quot;jar&quot;);
183 
184     /**
185      * Array of attribute OIDs defined in PKCS9, by number.
186      */
187     static final ObjectIdentifier[] PKCS9_OIDS = new ObjectIdentifier[18];
188 
189     private static final Class&lt;?&gt; BYTE_ARRAY_CLASS;
190 
<a name="2" id="anc2"></a><span class="line-modified">191     static {   // static initializer for PKCS9_OIDS</span>
<span class="line-modified">192         for (int i = 1; i &lt; PKCS9_OIDS.length - 2; i++) {</span>
<span class="line-modified">193             PKCS9_OIDS[i] = ObjectIdentifier.of(&quot;1.2.840.113549.1.9.&quot; + i);</span>
<span class="line-modified">194         }</span>
<span class="line-modified">195         // Initialize SigningCertificate and SignatureTimestampToken</span>
<span class="line-removed">196         // separately (because their values are out of sequence)</span>
<span class="line-removed">197         PKCS9_OIDS[PKCS9_OIDS.length - 2] =</span>
<span class="line-removed">198             ObjectIdentifier.of(&quot;1.2.840.113549.1.9.16.2.12&quot;);</span>
<span class="line-removed">199         PKCS9_OIDS[PKCS9_OIDS.length - 1] =</span>
<span class="line-removed">200             ObjectIdentifier.of(&quot;1.2.840.113549.1.9.16.2.14&quot;);</span>
<span class="line-removed">201 </span>
202         try {
203             BYTE_ARRAY_CLASS = Class.forName(&quot;[B&quot;);
204         } catch (ClassNotFoundException e) {
205             throw new ExceptionInInitializerError(e.toString());
206         }
207     }
208 
<a name="3" id="anc3"></a><span class="line-modified">209     // first element [0] not used</span>
<span class="line-modified">210     public static final ObjectIdentifier EMAIL_ADDRESS_OID = PKCS9_OIDS[1];</span>
<span class="line-modified">211     public static final ObjectIdentifier UNSTRUCTURED_NAME_OID = PKCS9_OIDS[2];</span>
<span class="line-modified">212     public static final ObjectIdentifier CONTENT_TYPE_OID = PKCS9_OIDS[3];</span>
<span class="line-modified">213     public static final ObjectIdentifier MESSAGE_DIGEST_OID = PKCS9_OIDS[4];</span>
<span class="line-modified">214     public static final ObjectIdentifier SIGNING_TIME_OID = PKCS9_OIDS[5];</span>
<span class="line-modified">215     public static final ObjectIdentifier COUNTERSIGNATURE_OID = PKCS9_OIDS[6];</span>
<span class="line-modified">216     public static final ObjectIdentifier CHALLENGE_PASSWORD_OID = PKCS9_OIDS[7];</span>
<span class="line-modified">217     public static final ObjectIdentifier UNSTRUCTURED_ADDRESS_OID = PKCS9_OIDS[8];</span>
<span class="line-modified">218     public static final ObjectIdentifier EXTENDED_CERTIFICATE_ATTRIBUTES_OID</span>
<span class="line-modified">219                                          = PKCS9_OIDS[9];</span>
<span class="line-modified">220     public static final ObjectIdentifier ISSUER_SERIALNUMBER_OID = PKCS9_OIDS[10];</span>










221     // [11], [12] are RSA DSI proprietary
222     // [13] ==&gt; signingDescription, S/MIME, not used anymore
<a name="4" id="anc4"></a><span class="line-modified">223     public static final ObjectIdentifier EXTENSION_REQUEST_OID = PKCS9_OIDS[14];</span>
<span class="line-modified">224     public static final ObjectIdentifier SMIME_CAPABILITY_OID = PKCS9_OIDS[15];</span>
<span class="line-modified">225     public static final ObjectIdentifier SIGNING_CERTIFICATE_OID = PKCS9_OIDS[16];</span>

226     public static final ObjectIdentifier SIGNATURE_TIMESTAMP_TOKEN_OID =
<a name="5" id="anc5"></a><span class="line-modified">227                                 PKCS9_OIDS[17];</span>
<span class="line-modified">228     public static final String EMAIL_ADDRESS_STR = &quot;EmailAddress&quot;;</span>
<span class="line-removed">229     public static final String UNSTRUCTURED_NAME_STR = &quot;UnstructuredName&quot;;</span>
<span class="line-removed">230     public static final String CONTENT_TYPE_STR = &quot;ContentType&quot;;</span>
<span class="line-removed">231     public static final String MESSAGE_DIGEST_STR = &quot;MessageDigest&quot;;</span>
<span class="line-removed">232     public static final String SIGNING_TIME_STR = &quot;SigningTime&quot;;</span>
<span class="line-removed">233     public static final String COUNTERSIGNATURE_STR = &quot;Countersignature&quot;;</span>
<span class="line-removed">234     public static final String CHALLENGE_PASSWORD_STR = &quot;ChallengePassword&quot;;</span>
<span class="line-removed">235     public static final String UNSTRUCTURED_ADDRESS_STR = &quot;UnstructuredAddress&quot;;</span>
<span class="line-removed">236     public static final String EXTENDED_CERTIFICATE_ATTRIBUTES_STR =</span>
<span class="line-removed">237                                &quot;ExtendedCertificateAttributes&quot;;</span>
<span class="line-removed">238     public static final String ISSUER_SERIALNUMBER_STR = &quot;IssuerAndSerialNumber&quot;;</span>
<span class="line-removed">239     // [11], [12] are RSA DSI proprietary</span>
<span class="line-removed">240     private static final String RSA_PROPRIETARY_STR = &quot;RSAProprietary&quot;;</span>
<span class="line-removed">241     // [13] ==&gt; signingDescription, S/MIME, not used anymore</span>
<span class="line-removed">242     private static final String SMIME_SIGNING_DESC_STR = &quot;SMIMESigningDesc&quot;;</span>
<span class="line-removed">243     public static final String EXTENSION_REQUEST_STR = &quot;ExtensionRequest&quot;;</span>
<span class="line-removed">244     public static final String SMIME_CAPABILITY_STR = &quot;SMIMECapability&quot;;</span>
<span class="line-removed">245     public static final String SIGNING_CERTIFICATE_STR = &quot;SigningCertificate&quot;;</span>
<span class="line-removed">246     public static final String SIGNATURE_TIMESTAMP_TOKEN_STR =</span>
<span class="line-removed">247                                 &quot;SignatureTimestampToken&quot;;</span>
<span class="line-removed">248 </span>
<span class="line-removed">249     /**</span>
<span class="line-removed">250      * HashMap mapping names and variant names of supported</span>
<span class="line-removed">251      * attributes to their OIDs. This table contains all name forms</span>
<span class="line-removed">252      * that occur in PKCS9, in lower case.</span>
<span class="line-removed">253      */</span>
<span class="line-removed">254     private static final HashMap&lt;String, ObjectIdentifier&gt; NAME_OID_TABLE =</span>
<span class="line-removed">255         new HashMap&lt;String, ObjectIdentifier&gt;(17);</span>
<span class="line-removed">256 </span>
<span class="line-removed">257     static { // static initializer for PCKS9_NAMES</span>
<span class="line-removed">258         NAME_OID_TABLE.put(&quot;emailaddress&quot;, PKCS9_OIDS[1]);</span>
<span class="line-removed">259         NAME_OID_TABLE.put(&quot;unstructuredname&quot;, PKCS9_OIDS[2]);</span>
<span class="line-removed">260         NAME_OID_TABLE.put(&quot;contenttype&quot;, PKCS9_OIDS[3]);</span>
<span class="line-removed">261         NAME_OID_TABLE.put(&quot;messagedigest&quot;, PKCS9_OIDS[4]);</span>
<span class="line-removed">262         NAME_OID_TABLE.put(&quot;signingtime&quot;, PKCS9_OIDS[5]);</span>
<span class="line-removed">263         NAME_OID_TABLE.put(&quot;countersignature&quot;, PKCS9_OIDS[6]);</span>
<span class="line-removed">264         NAME_OID_TABLE.put(&quot;challengepassword&quot;, PKCS9_OIDS[7]);</span>
<span class="line-removed">265         NAME_OID_TABLE.put(&quot;unstructuredaddress&quot;, PKCS9_OIDS[8]);</span>
<span class="line-removed">266         NAME_OID_TABLE.put(&quot;extendedcertificateattributes&quot;, PKCS9_OIDS[9]);</span>
<span class="line-removed">267         NAME_OID_TABLE.put(&quot;issuerandserialnumber&quot;, PKCS9_OIDS[10]);</span>
<span class="line-removed">268         NAME_OID_TABLE.put(&quot;rsaproprietary&quot;, PKCS9_OIDS[11]);</span>
<span class="line-removed">269         NAME_OID_TABLE.put(&quot;rsaproprietary&quot;, PKCS9_OIDS[12]);</span>
<span class="line-removed">270         NAME_OID_TABLE.put(&quot;signingdescription&quot;, PKCS9_OIDS[13]);</span>
<span class="line-removed">271         NAME_OID_TABLE.put(&quot;extensionrequest&quot;, PKCS9_OIDS[14]);</span>
<span class="line-removed">272         NAME_OID_TABLE.put(&quot;smimecapability&quot;, PKCS9_OIDS[15]);</span>
<span class="line-removed">273         NAME_OID_TABLE.put(&quot;signingcertificate&quot;, PKCS9_OIDS[16]);</span>
<span class="line-removed">274         NAME_OID_TABLE.put(&quot;signaturetimestamptoken&quot;, PKCS9_OIDS[17]);</span>
<span class="line-removed">275     };</span>
<span class="line-removed">276 </span>
<span class="line-removed">277     /**</span>
<span class="line-removed">278      * HashMap mapping attribute OIDs defined in PKCS9 to the</span>
<span class="line-removed">279      * corresponding attribute value type.</span>
<span class="line-removed">280      */</span>
<span class="line-removed">281     private static final HashMap&lt;ObjectIdentifier, String&gt; OID_NAME_TABLE =</span>
<span class="line-removed">282         new HashMap&lt;ObjectIdentifier, String&gt;(17);</span>
<span class="line-removed">283     static {</span>
<span class="line-removed">284         OID_NAME_TABLE.put(PKCS9_OIDS[1], EMAIL_ADDRESS_STR);</span>
<span class="line-removed">285         OID_NAME_TABLE.put(PKCS9_OIDS[2], UNSTRUCTURED_NAME_STR);</span>
<span class="line-removed">286         OID_NAME_TABLE.put(PKCS9_OIDS[3], CONTENT_TYPE_STR);</span>
<span class="line-removed">287         OID_NAME_TABLE.put(PKCS9_OIDS[4], MESSAGE_DIGEST_STR);</span>
<span class="line-removed">288         OID_NAME_TABLE.put(PKCS9_OIDS[5], SIGNING_TIME_STR);</span>
<span class="line-removed">289         OID_NAME_TABLE.put(PKCS9_OIDS[6], COUNTERSIGNATURE_STR);</span>
<span class="line-removed">290         OID_NAME_TABLE.put(PKCS9_OIDS[7], CHALLENGE_PASSWORD_STR);</span>
<span class="line-removed">291         OID_NAME_TABLE.put(PKCS9_OIDS[8], UNSTRUCTURED_ADDRESS_STR);</span>
<span class="line-removed">292         OID_NAME_TABLE.put(PKCS9_OIDS[9], EXTENDED_CERTIFICATE_ATTRIBUTES_STR);</span>
<span class="line-removed">293         OID_NAME_TABLE.put(PKCS9_OIDS[10], ISSUER_SERIALNUMBER_STR);</span>
<span class="line-removed">294         OID_NAME_TABLE.put(PKCS9_OIDS[11], RSA_PROPRIETARY_STR);</span>
<span class="line-removed">295         OID_NAME_TABLE.put(PKCS9_OIDS[12], RSA_PROPRIETARY_STR);</span>
<span class="line-removed">296         OID_NAME_TABLE.put(PKCS9_OIDS[13], SMIME_SIGNING_DESC_STR);</span>
<span class="line-removed">297         OID_NAME_TABLE.put(PKCS9_OIDS[14], EXTENSION_REQUEST_STR);</span>
<span class="line-removed">298         OID_NAME_TABLE.put(PKCS9_OIDS[15], SMIME_CAPABILITY_STR);</span>
<span class="line-removed">299         OID_NAME_TABLE.put(PKCS9_OIDS[16], SIGNING_CERTIFICATE_STR);</span>
<span class="line-removed">300         OID_NAME_TABLE.put(PKCS9_OIDS[17], SIGNATURE_TIMESTAMP_TOKEN_STR);</span>
<span class="line-removed">301     }</span>
302 
303     /**
304      * Acceptable ASN.1 tags for DER encodings of values of PKCS9
305      * attributes, by index in &lt;code&gt;PKCS9_OIDS&lt;/code&gt;.
306      * Sets of acceptable tags are represented as arrays.
307      */
308     private static final Byte[][] PKCS9_VALUE_TAGS = {
309         null,
310         {DerValue.tag_IA5String},   // EMailAddress
311         {DerValue.tag_IA5String,   // UnstructuredName
312          DerValue.tag_PrintableString},
313         {DerValue.tag_ObjectId},    // ContentType
314         {DerValue.tag_OctetString}, // MessageDigest
315         {DerValue.tag_UtcTime},     // SigningTime
316         {DerValue.tag_Sequence},    // Countersignature
317         {DerValue.tag_PrintableString,
318          DerValue.tag_T61String,
319          DerValue.tag_BMPString,
320          DerValue.tag_UniversalString,
321          DerValue.tag_UTF8String},   // ChallengePassword
322         {DerValue.tag_PrintableString,
323          DerValue.tag_T61String},   // UnstructuredAddress
324         {DerValue.tag_SetOf},       // ExtendedCertificateAttributes
325         {DerValue.tag_Sequence},    // issuerAndSerialNumber
326         null,
327         null,
328         null,
329         {DerValue.tag_Sequence},    // extensionRequest
330         {DerValue.tag_Sequence},    // SMIMECapability
331         {DerValue.tag_Sequence},    // SigningCertificate
332         {DerValue.tag_Sequence}     // SignatureTimestampToken
333     };
334 
335     private static final Class&lt;?&gt;[] VALUE_CLASSES = new Class&lt;?&gt;[18];
336 
337     static {
338         try {
339             Class&lt;?&gt; str = Class.forName(&quot;[Ljava.lang.String;&quot;);
340 
341             VALUE_CLASSES[0] = null;  // not used
342             VALUE_CLASSES[1] = str;   // EMailAddress
343             VALUE_CLASSES[2] = str;   // UnstructuredName
344             VALUE_CLASSES[3] =        // ContentType
345                 Class.forName(&quot;sun.security.util.ObjectIdentifier&quot;);
346             VALUE_CLASSES[4] = BYTE_ARRAY_CLASS; // MessageDigest (byte[])
347             VALUE_CLASSES[5] = Class.forName(&quot;java.util.Date&quot;); // SigningTime
348             VALUE_CLASSES[6] =        // Countersignature
349                 Class.forName(&quot;[Lsun.security.pkcs.SignerInfo;&quot;);
350             VALUE_CLASSES[7] =        // ChallengePassword
351                 Class.forName(&quot;java.lang.String&quot;);
352             VALUE_CLASSES[8] = str;   // UnstructuredAddress
353             VALUE_CLASSES[9] = null;  // ExtendedCertificateAttributes
354             VALUE_CLASSES[10] = null;  // IssuerAndSerialNumber
355             VALUE_CLASSES[11] = null;  // not used
356             VALUE_CLASSES[12] = null;  // not used
357             VALUE_CLASSES[13] = null;  // not used
358             VALUE_CLASSES[14] =        // ExtensionRequest
359                 Class.forName(&quot;sun.security.x509.CertificateExtensions&quot;);
360             VALUE_CLASSES[15] = null;  // not supported yet
361             VALUE_CLASSES[16] = null;  // not supported yet
362             VALUE_CLASSES[17] = BYTE_ARRAY_CLASS;  // SignatureTimestampToken
363         } catch (ClassNotFoundException e) {
364             throw new ExceptionInInitializerError(e.toString());
365         }
366     }
367 
368     /**
369      * Array indicating which PKCS9 attributes are single-valued,
370      * by index in &lt;code&gt;PKCS9_OIDS&lt;/code&gt;.
371      */
372     private static final boolean[] SINGLE_VALUED = {
373       false,
374       false,   // EMailAddress
375       false,   // UnstructuredName
376       true,    // ContentType
377       true,    // MessageDigest
378       true,    // SigningTime
379       false,   // Countersignature
380       true,    // ChallengePassword
381       false,   // UnstructuredAddress
382       false,   // ExtendedCertificateAttributes
383       true,    // IssuerAndSerialNumber - not supported yet
384       false,   // not used
385       false,   // not used
386       false,   // not used
387       true,    // ExtensionRequest
388       true,    // SMIMECapability - not supported yet
389       true,    // SigningCertificate
390       true     // SignatureTimestampToken
391     };
392 
393     /**
394      * The OID of this attribute.
395      */
396     private ObjectIdentifier oid;
397 
398     /**
399      * The index of the OID of this attribute in &lt;code&gt;PKCS9_OIDS&lt;/code&gt;,
400      * or -1 if it&#39;s unknown.
401      */
402     private int index;
403 
404     /**
405      * Value set of this attribute.  Its class is given by
406      * &lt;code&gt;VALUE_CLASSES[index]&lt;/code&gt;. The SET itself
407      * as byte[] if unknown.
408      */
409     private Object value;
410 
411     /**
412      * Construct an attribute object from the attribute&#39;s OID and
413      * value.  If the attribute is single-valued, provide only one
414      * value.  If the attribute is multi-valued, provide an array
415      * containing all the values.
416      * Arrays of length zero are accepted, though probably useless.
417      *
418      * &lt;P&gt; The
419      * &lt;a href=#classTable&gt;table&lt;/a&gt; gives the class that &lt;code&gt;value&lt;/code&gt;
420      * must have for a given attribute.
421      *
422      * @exception IllegalArgumentException
423      * if the &lt;code&gt;value&lt;/code&gt; has the wrong type.
424      */
425     public PKCS9Attribute(ObjectIdentifier oid, Object value)
426     throws IllegalArgumentException {
427         init(oid, value);
428     }
429 
<a name="6" id="anc6"></a><span class="line-removed">430     /**</span>
<span class="line-removed">431      * Construct an attribute object from the attribute&#39;s name and</span>
<span class="line-removed">432      * value.  If the attribute is single-valued, provide only one</span>
<span class="line-removed">433      * value.  If the attribute is multi-valued, provide an array</span>
<span class="line-removed">434      * containing all the values.</span>
<span class="line-removed">435      * Arrays of length zero are accepted, though probably useless.</span>
<span class="line-removed">436      *</span>
<span class="line-removed">437      * &lt;P&gt; The</span>
<span class="line-removed">438      * &lt;a href=#classTable&gt;table&lt;/a&gt; gives the class that &lt;code&gt;value&lt;/code&gt;</span>
<span class="line-removed">439      * must have for a given attribute. Reasonable variants of these</span>
<span class="line-removed">440      * attributes are accepted; in particular, case does not matter.</span>
<span class="line-removed">441      *</span>
<span class="line-removed">442      * @exception IllegalArgumentException</span>
<span class="line-removed">443      * if the &lt;code&gt;name&lt;/code&gt; is not recognized or the</span>
<span class="line-removed">444      * &lt;code&gt;value&lt;/code&gt; has the wrong type.</span>
<span class="line-removed">445      */</span>
<span class="line-removed">446     public PKCS9Attribute(String name, Object value)</span>
<span class="line-removed">447     throws IllegalArgumentException {</span>
<span class="line-removed">448         ObjectIdentifier oid = getOID(name);</span>
<span class="line-removed">449 </span>
<span class="line-removed">450         if (oid == null)</span>
<span class="line-removed">451             throw new IllegalArgumentException(</span>
<span class="line-removed">452                        &quot;Unrecognized attribute name &quot; + name +</span>
<span class="line-removed">453                        &quot; constructing PKCS9Attribute.&quot;);</span>
<span class="line-removed">454 </span>
<span class="line-removed">455         init(oid, value);</span>
<span class="line-removed">456     }</span>
<span class="line-removed">457 </span>
458     private void init(ObjectIdentifier oid, Object value)
459         throws IllegalArgumentException {
460 
461         this.oid = oid;
462         index = indexOf(oid, PKCS9_OIDS, 1);
463         Class&lt;?&gt; clazz = index == -1 ? BYTE_ARRAY_CLASS: VALUE_CLASSES[index];
464         if (!clazz.isInstance(value)) {
465                 throw new IllegalArgumentException(
466                            &quot;Wrong value class &quot; +
467                            &quot; for attribute &quot; + oid +
468                            &quot; constructing PKCS9Attribute; was &quot; +
469                            value.getClass().toString() + &quot;, should be &quot; +
470                            clazz.toString());
471         }
472         this.value = value;
473     }
474 
475 
476     /**
477      * Construct a PKCS9Attribute from its encoding on an input
478      * stream.
479      *
480      * @param derVal the DerValue representing the DER encoding of the attribute.
481      * @exception IOException on parsing error.
482      */
483     public PKCS9Attribute(DerValue derVal) throws IOException {
484 
485         DerInputStream derIn = new DerInputStream(derVal.toByteArray());
486         DerValue[] val =  derIn.getSequence(2);
487 
488         if (derIn.available() != 0)
489             throw new IOException(&quot;Excess data parsing PKCS9Attribute&quot;);
490 
491         if (val.length != 2)
492             throw new IOException(&quot;PKCS9Attribute doesn&#39;t have two components&quot;);
493 
494         // get the oid
495         oid = val[0].getOID();
496         byte[] content = val[1].toByteArray();
497         DerValue[] elems = new DerInputStream(content).getSet(1);
498 
499         index = indexOf(oid, PKCS9_OIDS, 1);
500         if (index == -1) {
501             if (debug != null) {
502                 debug.println(&quot;Unsupported signer attribute: &quot; + oid);
503             }
504             value = content;
505             return;
506         }
507 
508         // check single valued have only one value
509         if (SINGLE_VALUED[index] &amp;&amp; elems.length &gt; 1)
510             throwSingleValuedException();
511 
512         // check for illegal element tags
513         Byte tag;
514         for (DerValue elem : elems) {
515             tag = elem.tag;
516             if (indexOf(tag, PKCS9_VALUE_TAGS[index], 0) == -1)
517                 throwTagException(tag);
518         }
519 
520         switch (index) {
521         case 1:     // email address
522         case 2:     // unstructured name
523         case 8:     // unstructured address
524             { // open scope
525                 String[] values = new String[elems.length];
526 
527                 for (int i=0; i &lt; elems.length; i++)
528                     values[i] = elems[i].getAsString();
529                 value = values;
530             } // close scope
531             break;
532 
533         case 3:     // content type
534             value = elems[0].getOID();
535             break;
536 
537         case 4:     // message digest
538             value = elems[0].getOctetString();
539             break;
540 
541         case 5:     // signing time
542             value = (new DerInputStream(elems[0].toByteArray())).getUTCTime();
543             break;
544 
545         case 6:     // countersignature
546             { // open scope
547                 SignerInfo[] values = new SignerInfo[elems.length];
548                 for (int i=0; i &lt; elems.length; i++)
549                     values[i] =
550                         new SignerInfo(elems[i].toDerInputStream());
551                 value = values;
552             } // close scope
553             break;
554 
555         case 7:     // challenge password
556             value = elems[0].getAsString();
557             break;
558 
559         case 9:     // extended-certificate attribute -- not supported
560             throw new IOException(&quot;PKCS9 extended-certificate &quot; +
561                                   &quot;attribute not supported.&quot;);
562             // break unnecessary
563         case 10:    // issuerAndserialNumber attribute -- not supported
564             throw new IOException(&quot;PKCS9 IssuerAndSerialNumber&quot; +
565                                   &quot;attribute not supported.&quot;);
566             // break unnecessary
567         case 11:    // RSA DSI proprietary
568         case 12:    // RSA DSI proprietary
569             throw new IOException(&quot;PKCS9 RSA DSI attributes&quot; +
570                                   &quot;11 and 12, not supported.&quot;);
571             // break unnecessary
572         case 13:    // S/MIME unused attribute
573             throw new IOException(&quot;PKCS9 attribute #13 not supported.&quot;);
574             // break unnecessary
575 
576         case 14:     // ExtensionRequest
577             value = new CertificateExtensions(
578                        new DerInputStream(elems[0].toByteArray()));
579             break;
580 
581         case 15:     // SMIME-capability attribute -- not supported
582             throw new IOException(&quot;PKCS9 SMIMECapability &quot; +
583                                   &quot;attribute not supported.&quot;);
584             // break unnecessary
585         case 16:     // SigningCertificate attribute
586             value = new SigningCertificateInfo(elems[0].toByteArray());
587             break;
588 
589         case 17:     // SignatureTimestampToken attribute
590             value = elems[0].toByteArray();
591             break;
592         default: // can&#39;t happen
593         }
594     }
595 
596     /**
597      * Write the DER encoding of this attribute to an output stream.
598      *
599      * &lt;P&gt; N.B.: This method always encodes values of
600      * ChallengePassword and UnstructuredAddress attributes as ASN.1
601      * &lt;code&gt;PrintableString&lt;/code&gt;s, without checking whether they
602      * should be encoded as &lt;code&gt;T61String&lt;/code&gt;s.
603      */
604     @Override
605     public void derEncode(OutputStream out) throws IOException {
606         DerOutputStream temp = new DerOutputStream();
607         temp.putOID(oid);
608         switch (index) {
609         case -1:    // Unknown
610             temp.write((byte[])value);
611             break;
612         case 1:     // email address
613         case 2:     // unstructured name
614             { // open scope
615                 String[] values = (String[]) value;
616                 DerOutputStream[] temps = new
617                     DerOutputStream[values.length];
618 
619                 for (int i=0; i &lt; values.length; i++) {
620                     temps[i] = new DerOutputStream();
621                     temps[i].putIA5String( values[i]);
622                 }
623                 temp.putOrderedSetOf(DerValue.tag_Set, temps);
624             } // close scope
625             break;
626 
627         case 3:     // content type
628             {
629                 DerOutputStream temp2 = new DerOutputStream();
630                 temp2.putOID((ObjectIdentifier) value);
631                 temp.write(DerValue.tag_Set, temp2.toByteArray());
632             }
633             break;
634 
635         case 4:     // message digest
636             {
637                 DerOutputStream temp2 = new DerOutputStream();
638                 temp2.putOctetString((byte[]) value);
639                 temp.write(DerValue.tag_Set, temp2.toByteArray());
640             }
641             break;
642 
643         case 5:     // signing time
644             {
645                 DerOutputStream temp2 = new DerOutputStream();
646                 temp2.putUTCTime((Date) value);
647                 temp.write(DerValue.tag_Set, temp2.toByteArray());
648             }
649             break;
650 
651         case 6:     // countersignature
652             temp.putOrderedSetOf(DerValue.tag_Set, (DerEncoder[]) value);
653             break;
654 
655         case 7:     // challenge password
656             {
657                 DerOutputStream temp2 = new DerOutputStream();
658                 temp2.putPrintableString((String) value);
659                 temp.write(DerValue.tag_Set, temp2.toByteArray());
660             }
661             break;
662 
663         case 8:     // unstructured address
664             { // open scope
665                 String[] values = (String[]) value;
666                 DerOutputStream[] temps = new
667                     DerOutputStream[values.length];
668 
669                 for (int i=0; i &lt; values.length; i++) {
670                     temps[i] = new DerOutputStream();
671                     temps[i].putPrintableString(values[i]);
672                 }
673                 temp.putOrderedSetOf(DerValue.tag_Set, temps);
674             } // close scope
675             break;
676 
677         case 9:     // extended-certificate attribute -- not supported
678             throw new IOException(&quot;PKCS9 extended-certificate &quot; +
679                                   &quot;attribute not supported.&quot;);
680             // break unnecessary
681         case 10:    // issuerAndserialNumber attribute -- not supported
682             throw new IOException(&quot;PKCS9 IssuerAndSerialNumber&quot; +
683                                   &quot;attribute not supported.&quot;);
684             // break unnecessary
685         case 11:    // RSA DSI proprietary
686         case 12:    // RSA DSI proprietary
687             throw new IOException(&quot;PKCS9 RSA DSI attributes&quot; +
688                                   &quot;11 and 12, not supported.&quot;);
689             // break unnecessary
690         case 13:    // S/MIME unused attribute
691             throw new IOException(&quot;PKCS9 attribute #13 not supported.&quot;);
692             // break unnecessary
693 
694         case 14:     // ExtensionRequest
695             {
696                 DerOutputStream temp2 = new DerOutputStream();
697                 CertificateExtensions exts = (CertificateExtensions)value;
698                 try {
699                     exts.encode(temp2, true);
700                 } catch (CertificateException ex) {
701                     throw new IOException(ex.toString());
702                 }
703                 temp.write(DerValue.tag_Set, temp2.toByteArray());
704             }
705             break;
706         case 15:    // SMIMECapability
707             throw new IOException(&quot;PKCS9 attribute #15 not supported.&quot;);
708             // break unnecessary
709 
710         case 16:    // SigningCertificate
711             throw new IOException(
712                 &quot;PKCS9 SigningCertificate attribute not supported.&quot;);
713             // break unnecessary
714 
715         case 17:    // SignatureTimestampToken
716             temp.write(DerValue.tag_Set, (byte[])value);
717             break;
718 
719         default: // can&#39;t happen
720         }
721 
722         DerOutputStream derOut = new DerOutputStream();
723         derOut.write(DerValue.tag_Sequence, temp.toByteArray());
724 
725         out.write(derOut.toByteArray());
726 
727     }
728 
729     /**
730      * Returns if the attribute is known. Unknown attributes can be created
731      * from DER encoding with unknown OIDs.
732      */
733     public boolean isKnown() {
734         return index != -1;
735     }
736 
737     /**
738      * Get the value of this attribute.  If the attribute is
739      * single-valued, return just the one value.  If the attribute is
740      * multi-valued, return an array containing all the values.
741      * It is possible for this array to be of length 0.
742      *
743      * &lt;P&gt; The
744      * &lt;a href=#classTable&gt;table&lt;/a&gt; gives the class of the value returned,
745      * depending on the type of this attribute.
746      */
747     public Object getValue() {
748         return value;
749     }
750 
751     /**
752      * Show whether this attribute is single-valued.
753      */
754     public boolean isSingleValued() {
755         return index == -1 || SINGLE_VALUED[index];
756     }
757 
758     /**
759      *  Return the OID of this attribute.
760      */
761     public ObjectIdentifier getOID() {
762         return oid;
763     }
764 
765     /**
766      *  Return the name of this attribute.
767      */
768     public String getName() {
<a name="7" id="anc7"></a><span class="line-modified">769         return index == -1 ?</span>
<span class="line-modified">770                 oid.toString() :</span>
<span class="line-modified">771                 OID_NAME_TABLE.get(PKCS9_OIDS[index]);</span>
772     }
773 
774     /**
775      * Return the OID for a given attribute name or null if we don&#39;t recognize
776      * the name.
777      */
778     public static ObjectIdentifier getOID(String name) {
<a name="8" id="anc8"></a><span class="line-modified">779         return NAME_OID_TABLE.get(name.toLowerCase(Locale.ENGLISH));</span>





780     }
781 
782     /**
783      * Return the attribute name for a given OID or null if we don&#39;t recognize
784      * the oid.
785      */
786     public static String getName(ObjectIdentifier oid) {
<a name="9" id="anc9"></a><span class="line-modified">787         return OID_NAME_TABLE.get(oid);</span>
788     }
789 
790     /**
791      * Returns a string representation of this attribute.
792      */
793     @Override
794     public String toString() {
795         StringBuilder sb = new StringBuilder(100);
796 
797         sb.append(&quot;[&quot;);
798 
799         if (index == -1) {
800             sb.append(oid.toString());
801         } else {
<a name="10" id="anc10"></a><span class="line-modified">802             sb.append(OID_NAME_TABLE.get(PKCS9_OIDS[index]));</span>
803         }
804         sb.append(&quot;: &quot;);
805 
806         if (index == -1 || SINGLE_VALUED[index]) {
807             if (value instanceof byte[]) { // special case for octet string
808                 HexDumpEncoder hexDump = new HexDumpEncoder();
809                 sb.append(hexDump.encodeBuffer((byte[]) value));
810             } else {
811                 sb.append(value.toString());
812             }
813             sb.append(&quot;]&quot;);
814             return sb.toString();
815         } else { // multi-valued
816             boolean first = true;
817             Object[] values = (Object[]) value;
818 
819             for (Object curVal : values) {
820                 if (first)
821                     first = false;
822                 else
823                     sb.append(&quot;, &quot;);
824                 sb.append(curVal.toString());
825             }
826             return sb.toString();
827         }
828     }
829 
830     /**
831      * Beginning the search at &lt;code&gt;start&lt;/code&gt;, find the first
832      * index &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;a[i] = obj&lt;/code&gt;.
833      *
834      * @return the index, if found, and -1 otherwise.
835      */
836     static int indexOf(Object obj, Object[] a, int start) {
837         for (int i=start; i &lt; a.length; i++) {
838             if (obj.equals(a[i])) return i;
839         }
840         return -1;
841     }
842 
843     /**
844      * Throw an exception when there are multiple values for
845      * a single-valued attribute.
846      */
847     private void throwSingleValuedException() throws IOException {
848         throw new IOException(&quot;Single-value attribute &quot; +
849                               oid + &quot; (&quot; + getName() + &quot;)&quot; +
850                               &quot; has multiple values.&quot;);
851     }
852 
853     /**
854      * Throw an exception when the tag on a value encoding is
855      * wrong for the attribute whose value it is. This method
856      * will only be called for known tags.
857      */
858     private void throwTagException(Byte tag)
859     throws IOException {
860         Byte[] expectedTags = PKCS9_VALUE_TAGS[index];
861         StringBuilder msg = new StringBuilder(100);
862         msg.append(&quot;Value of attribute &quot;);
863         msg.append(oid.toString());
864         msg.append(&quot; (&quot;);
865         msg.append(getName());
866         msg.append(&quot;) has wrong tag: &quot;);
867         msg.append(tag.toString());
868         msg.append(&quot;.  Expected tags: &quot;);
869 
870         msg.append(expectedTags[0].toString());
871 
872         for (int i = 1; i &lt; expectedTags.length; i++) {
873             msg.append(&quot;, &quot;);
874             msg.append(expectedTags[i].toString());
875         }
876         msg.append(&quot;.&quot;);
877         throw new IOException(msg.toString());
878     }
879 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/provider/KeyProtector.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider;
 27 
 28 import java.io.IOException;
 29 import java.security.Key;
 30 import java.security.KeyStoreException;
 31 import java.security.MessageDigest;
 32 import java.security.NoSuchAlgorithmException;
 33 import java.security.SecureRandom;
 34 import java.security.UnrecoverableKeyException;
 35 import java.util.*;
 36 
 37 import sun.security.pkcs.PKCS8Key;
 38 import sun.security.pkcs.EncryptedPrivateKeyInfo;
 39 import sun.security.x509.AlgorithmId;
 40 import sun.security.util.ObjectIdentifier;
<a name="2" id="anc2"></a><span class="line-added"> 41 import sun.security.util.KnownOIDs;</span>
 42 import sun.security.util.DerValue;
 43 
 44 /**
 45  * This is an implementation of a Sun proprietary, exportable algorithm
 46  * intended for use when protecting (or recovering the cleartext version of)
 47  * sensitive keys.
 48  * This algorithm is not intended as a general purpose cipher.
 49  *
 50  * This is how the algorithm works for key protection:
 51  *
 52  * p - user password
 53  * s - random salt
 54  * X - xor key
 55  * P - to-be-protected key
 56  * Y - protected key
 57  * R - what gets stored in the keystore
 58  *
 59  * Step 1:
 60  * Take the user&#39;s password, append a random salt (of fixed size) to it,
 61  * and hash it: d1 = digest(p, s)
 62  * Store d1 in X.
 63  *
 64  * Step 2:
 65  * Take the user&#39;s password, append the digest result from the previous step,
 66  * and hash it: dn = digest(p, dn-1).
 67  * Store dn in X (append it to the previously stored digests).
 68  * Repeat this step until the length of X matches the length of the private key
 69  * P.
 70  *
 71  * Step 3:
 72  * XOR X and P, and store the result in Y: Y = X XOR P.
 73  *
 74  * Step 4:
 75  * Store s, Y, and digest(p, P) in the result buffer R:
 76  * R = s + Y + digest(p, P), where &quot;+&quot; denotes concatenation.
 77  * (NOTE: digest(p, P) is stored in the result buffer, so that when the key is
 78  * recovered, we can check if the recovered key indeed matches the original
 79  * key.) R is stored in the keystore.
 80  *
 81  * The protected key is recovered as follows:
 82  *
 83  * Step1 and Step2 are the same as above, except that the salt is not randomly
 84  * generated, but taken from the result R of step 4 (the first length(s)
 85  * bytes).
 86  *
 87  * Step 3 (XOR operation) yields the plaintext key.
 88  *
 89  * Then concatenate the password with the recovered key, and compare with the
 90  * last length(digest(p, P)) bytes of R. If they match, the recovered key is
 91  * indeed the same key as the original key.
 92  *
 93  * @author Jan Luehe
 94  *
 95  *
 96  * @see java.security.KeyStore
 97  * @see JavaKeyStore
 98  * @see KeyTool
 99  *
100  * @since 1.2
101  */
102 
103 final class KeyProtector {
104 
105     private static final int SALT_LEN = 20; // the salt length
106     private static final String DIGEST_ALG = &quot;SHA&quot;;
107     private static final int DIGEST_LEN = 20;
108 
<a name="3" id="anc3"></a>


109     // The password used for protecting/recovering keys passed through this
110     // key protector. We store it as a byte array, so that we can digest it.
111     private byte[] passwdBytes;
112 
113     private MessageDigest md;
114 
115 
116     /**
117      * Creates an instance of this class, and initializes it with the given
118      * password.
119      */
120     public KeyProtector(byte[] passwordBytes)
121         throws NoSuchAlgorithmException
122     {
123         if (passwordBytes == null) {
124            throw new IllegalArgumentException(&quot;password can&#39;t be null&quot;);
125         }
126         md = MessageDigest.getInstance(DIGEST_ALG);
127         this.passwdBytes = passwordBytes;
128     }
129 
130     /*
131      * Protects the given plaintext key, using the password provided at
132      * construction time.
133      */
134     public byte[] protect(Key key) throws KeyStoreException
135     {
136         int i;
137         int numRounds;
138         byte[] digest;
139         int xorOffset; // offset in xorKey where next digest will be stored
140         int encrKeyOffset = 0;
141 
142         if (key == null) {
143             throw new IllegalArgumentException(&quot;plaintext key can&#39;t be null&quot;);
144         }
145 
146         if (!&quot;PKCS#8&quot;.equalsIgnoreCase(key.getFormat())) {
147             throw new KeyStoreException(
148                 &quot;Cannot get key bytes, not PKCS#8 encoded&quot;);
149         }
150 
151         byte[] plainKey = key.getEncoded();
152         if (plainKey == null) {
153             throw new KeyStoreException(
154                 &quot;Cannot get key bytes, encoding not supported&quot;);
155         }
156 
157         // Determine the number of digest rounds
158         numRounds = plainKey.length / DIGEST_LEN;
159         if ((plainKey.length % DIGEST_LEN) != 0)
160             numRounds++;
161 
162         // Create a random salt
163         byte[] salt = new byte[SALT_LEN];
164         SecureRandom random = new SecureRandom();
165         random.nextBytes(salt);
166 
167         // Set up the byte array which will be XORed with &quot;plainKey&quot;
168         byte[] xorKey = new byte[plainKey.length];
169 
170         // Compute the digests, and store them in &quot;xorKey&quot;
171         for (i = 0, xorOffset = 0, digest = salt;
172              i &lt; numRounds;
173              i++, xorOffset += DIGEST_LEN) {
174             md.update(passwdBytes);
175             md.update(digest);
176             digest = md.digest();
177             md.reset();
178             // Copy the digest into &quot;xorKey&quot;
179             if (i &lt; numRounds - 1) {
180                 System.arraycopy(digest, 0, xorKey, xorOffset,
181                                  digest.length);
182             } else {
183                 System.arraycopy(digest, 0, xorKey, xorOffset,
184                                  xorKey.length - xorOffset);
185             }
186         }
187 
188         // XOR &quot;plainKey&quot; with &quot;xorKey&quot;, and store the result in &quot;tmpKey&quot;
189         byte[] tmpKey = new byte[plainKey.length];
190         for (i = 0; i &lt; tmpKey.length; i++) {
191             tmpKey[i] = (byte)(plainKey[i] ^ xorKey[i]);
192         }
193 
194         // Store salt and &quot;tmpKey&quot; in &quot;encrKey&quot;
195         byte[] encrKey = new byte[salt.length + tmpKey.length + DIGEST_LEN];
196         System.arraycopy(salt, 0, encrKey, encrKeyOffset, salt.length);
197         encrKeyOffset += salt.length;
198         System.arraycopy(tmpKey, 0, encrKey, encrKeyOffset, tmpKey.length);
199         encrKeyOffset += tmpKey.length;
200 
201         // Append digest(password, plainKey) as an integrity check to &quot;encrKey&quot;
202         md.update(passwdBytes);
203         Arrays.fill(passwdBytes, (byte)0x00);
204         passwdBytes = null;
205         md.update(plainKey);
206         digest = md.digest();
207         md.reset();
208         System.arraycopy(digest, 0, encrKey, encrKeyOffset, digest.length);
209 
210         // wrap the protected private key in a PKCS#8-style
211         // EncryptedPrivateKeyInfo, and returns its encoding
212         AlgorithmId encrAlg;
213         try {
<a name="4" id="anc4"></a><span class="line-modified">214             encrAlg = new AlgorithmId(ObjectIdentifier.of</span>
<span class="line-added">215                     (KnownOIDs.JAVASOFT_JDKKeyProtector));</span>
216             return new EncryptedPrivateKeyInfo(encrAlg,encrKey).getEncoded();
217         } catch (IOException ioe) {
218             throw new KeyStoreException(ioe.getMessage());
219         }
220     }
221 
222     /*
223      * Recovers the plaintext version of the given key (in protected format),
224      * using the password provided at construction time.
225      */
226     public Key recover(EncryptedPrivateKeyInfo encrInfo)
227         throws UnrecoverableKeyException
228     {
229         int i;
230         byte[] digest;
231         int numRounds;
232         int xorOffset; // offset in xorKey where next digest will be stored
233         int encrKeyLen; // the length of the encrpyted key
234 
235         // do we support the algorithm?
236         AlgorithmId encrAlg = encrInfo.getAlgorithm();
<a name="5" id="anc5"></a><span class="line-modified">237         if (!(encrAlg.getOID().toString().equals</span>
<span class="line-added">238                 (KnownOIDs.JAVASOFT_JDKKeyProtector.value()))) {</span>
239             throw new UnrecoverableKeyException(&quot;Unsupported key protection &quot;
240                                                 + &quot;algorithm&quot;);
241         }
242 
243         byte[] protectedKey = encrInfo.getEncryptedData();
244 
245         /*
246          * Get the salt associated with this key (the first SALT_LEN bytes of
247          * &lt;code&gt;protectedKey&lt;/code&gt;)
248          */
249         byte[] salt = new byte[SALT_LEN];
250         System.arraycopy(protectedKey, 0, salt, 0, SALT_LEN);
251 
252         // Determine the number of digest rounds
253         encrKeyLen = protectedKey.length - SALT_LEN - DIGEST_LEN;
254         numRounds = encrKeyLen / DIGEST_LEN;
255         if ((encrKeyLen % DIGEST_LEN) != 0) numRounds++;
256 
257         // Get the encrypted key portion and store it in &quot;encrKey&quot;
258         byte[] encrKey = new byte[encrKeyLen];
259         System.arraycopy(protectedKey, SALT_LEN, encrKey, 0, encrKeyLen);
260 
261         // Set up the byte array which will be XORed with &quot;encrKey&quot;
262         byte[] xorKey = new byte[encrKey.length];
263 
264         // Compute the digests, and store them in &quot;xorKey&quot;
265         for (i = 0, xorOffset = 0, digest = salt;
266              i &lt; numRounds;
267              i++, xorOffset += DIGEST_LEN) {
268             md.update(passwdBytes);
269             md.update(digest);
270             digest = md.digest();
271             md.reset();
272             // Copy the digest into &quot;xorKey&quot;
273             if (i &lt; numRounds - 1) {
274                 System.arraycopy(digest, 0, xorKey, xorOffset,
275                                  digest.length);
276             } else {
277                 System.arraycopy(digest, 0, xorKey, xorOffset,
278                                  xorKey.length - xorOffset);
279             }
280         }
281 
282         // XOR &quot;encrKey&quot; with &quot;xorKey&quot;, and store the result in &quot;plainKey&quot;
283         byte[] plainKey = new byte[encrKey.length];
284         for (i = 0; i &lt; plainKey.length; i++) {
285             plainKey[i] = (byte)(encrKey[i] ^ xorKey[i]);
286         }
287 
288         /*
289          * Check the integrity of the recovered key by concatenating it with
290          * the password, digesting the concatenation, and comparing the
291          * result of the digest operation with the digest provided at the end
292          * of &lt;code&gt;protectedKey&lt;/code&gt;. If the two digest values are
293          * different, throw an exception.
294          */
295         md.update(passwdBytes);
296         Arrays.fill(passwdBytes, (byte)0x00);
297         passwdBytes = null;
298         md.update(plainKey);
299         digest = md.digest();
300         md.reset();
301         for (i = 0; i &lt; digest.length; i++) {
302             if (digest[i] != protectedKey[SALT_LEN + encrKeyLen + i]) {
303                 throw new UnrecoverableKeyException(&quot;Cannot recover key&quot;);
304             }
305         }
306 
307         // The parseKey() method of PKCS8Key parses the key
308         // algorithm and instantiates the appropriate key factory,
309         // which in turn parses the key material.
310         try {
311             return PKCS8Key.parseKey(new DerValue(plainKey));
312         } catch (IOException ioe) {
313             throw new UnrecoverableKeyException(ioe.getMessage());
314         }
315     }
316 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
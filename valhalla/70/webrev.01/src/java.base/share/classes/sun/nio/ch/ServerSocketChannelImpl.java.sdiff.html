<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SelectorProviderImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.net.InetSocketAddress;

 31 import java.net.ServerSocket;
 32 import java.net.SocketAddress;
 33 import java.net.SocketOption;
 34 import java.net.SocketTimeoutException;

 35 import java.net.StandardSocketOptions;
 36 import java.nio.channels.AlreadyBoundException;
 37 import java.nio.channels.AsynchronousCloseException;
 38 import java.nio.channels.ClosedChannelException;
 39 import java.nio.channels.IllegalBlockingModeException;
 40 import java.nio.channels.NotYetBoundException;
 41 import java.nio.channels.SelectionKey;
 42 import java.nio.channels.ServerSocketChannel;
 43 import java.nio.channels.SocketChannel;
 44 import java.nio.channels.spi.SelectorProvider;
 45 import java.util.Collections;
 46 import java.util.HashSet;
 47 import java.util.Objects;
 48 import java.util.Set;
 49 import java.util.concurrent.locks.ReentrantLock;
 50 
 51 import sun.net.NetHooks;
 52 import sun.net.ext.ExtendedSocketOptions;
 53 
 54 /**
 55  * An implementation of ServerSocketChannels
 56  */
 57 
 58 class ServerSocketChannelImpl
 59     extends ServerSocketChannel
 60     implements SelChImpl
 61 {
 62     // Used to make native close and configure calls
 63     private static final NativeDispatcher nd = new SocketDispatcher();
 64 



 65     // Our file descriptor
 66     private final FileDescriptor fd;
 67     private final int fdVal;
 68 
 69     // Lock held by thread currently blocked on this channel
 70     private final ReentrantLock acceptLock = new ReentrantLock();
 71 
 72     // Lock held by any thread that modifies the state fields declared below
 73     // DO NOT invoke a blocking I/O operation while holding this lock!
 74     private final Object stateLock = new Object();
 75 
 76     // -- The following fields are protected by stateLock
 77 
 78     // Channel state, increases monotonically
 79     private static final int ST_INUSE = 0;
 80     private static final int ST_CLOSING = 1;
 81     private static final int ST_CLOSED = 2;
 82     private int state;
 83 
 84     // ID of native thread currently blocked in this channel, for signalling
 85     private long thread;
 86 
 87     // Binding
 88     private InetSocketAddress localAddress; // null =&gt; unbound
 89 
 90     // set true when exclusive binding is on and SO_REUSEADDR is emulated
 91     private boolean isReuseAddress;
 92 
 93     // Our socket adaptor, if any
 94     private ServerSocket socket;
 95 
 96     // -- End of fields protected by stateLock
 97 
<span class="line-removed"> 98 </span>
 99     ServerSocketChannelImpl(SelectorProvider sp) {






100         super(sp);
<span class="line-modified">101         this.fd = Net.serverSocket(true);</span>











102         this.fdVal = IOUtil.fdVal(fd);
103     }
104 
105     ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
106         throws IOException
107     {
108         super(sp);




109         this.fd =  fd;
110         this.fdVal = IOUtil.fdVal(fd);

111         if (bound) {
112             synchronized (stateLock) {
113                 localAddress = Net.localAddress(fd);
114             }
115         }
116     }
117 
118     // @throws ClosedChannelException if channel is closed
119     private void ensureOpen() throws ClosedChannelException {
120         if (!isOpen())
121             throw new ClosedChannelException();
122     }
123 
124     @Override
125     public ServerSocket socket() {
126         synchronized (stateLock) {
127             if (socket == null)
128                 socket = ServerSocketAdaptor.create(this);
129             return socket;
130         }
</pre>
<hr />
<pre>
193             set.add(StandardSocketOptions.SO_REUSEADDR);
194             if (Net.isReusePortAvailable()) {
195                 set.add(StandardSocketOptions.SO_REUSEPORT);
196             }
197             set.addAll(ExtendedSocketOptions.serverSocketOptions());
198             return Collections.unmodifiableSet(set);
199         }
200     }
201 
202     @Override
203     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
204         return DefaultOptionsHolder.defaultOptions;
205     }
206 
207     @Override
208     public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {
209         synchronized (stateLock) {
210             ensureOpen();
211             if (localAddress != null)
212                 throw new AlreadyBoundException();
<span class="line-modified">213             InetSocketAddress isa = (local == null)</span>
<span class="line-modified">214                                     ? new InetSocketAddress(0)</span>
<span class="line-modified">215                                     : Net.checkAddress(local);</span>



216             SecurityManager sm = System.getSecurityManager();
217             if (sm != null)
218                 sm.checkListen(isa.getPort());
219             NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
<span class="line-modified">220             Net.bind(fd, isa.getAddress(), isa.getPort());</span>
221             Net.listen(fd, backlog &lt; 1 ? 50 : backlog);
222             localAddress = Net.localAddress(fd);
223         }
224         return this;
225     }
226 
227     /**
228      * Marks the beginning of an I/O operation that might block.
229      *
230      * @throws ClosedChannelException if the channel is closed
231      * @throws NotYetBoundException if the channel&#39;s socket has not been bound yet
232      */
233     private void begin(boolean blocking) throws ClosedChannelException {
234         if (blocking)
235             begin();  // set blocker to close channel if interrupted
236         synchronized (stateLock) {
237             ensureOpen();
238             if (localAddress == null)
239                 throw new NotYetBoundException();
240             if (blocking)
</pre>
<hr />
<pre>
341         } finally {
342             acceptLock.unlock();
343         }
344 
345         assert n &gt; 0;
346         return finishAccept(newfd, isaa[0]);
347     }
348 
349     private SocketChannel finishAccept(FileDescriptor newfd, InetSocketAddress isa)
350         throws IOException
351     {
352         try {
353             // newly accepted socket is initially in blocking mode
354             IOUtil.configureBlocking(newfd, true);
355 
356             // check permitted to accept connections from the remote address
357             SecurityManager sm = System.getSecurityManager();
358             if (sm != null) {
359                 sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());
360             }
<span class="line-modified">361             return new SocketChannelImpl(provider(), newfd, isa);</span>
362         } catch (Exception e) {
363             nd.close(newfd);
364             throw e;
365         }
366     }
367 
368     @Override
369     protected void implConfigureBlocking(boolean block) throws IOException {
370         acceptLock.lock();
371         try {
372             lockedConfigureBlocking(block);
373         } finally {
374             acceptLock.unlock();
375         }
376     }
377 
378     /**
379      * Adjust the blocking. acceptLock must already be held.
380      */
381     private void lockedConfigureBlocking(boolean block) throws IOException {
</pre>
</td>
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.net.InetSocketAddress;
<span class="line-added"> 31 import java.net.ProtocolFamily;</span>
 32 import java.net.ServerSocket;
 33 import java.net.SocketAddress;
 34 import java.net.SocketOption;
 35 import java.net.SocketTimeoutException;
<span class="line-added"> 36 import java.net.StandardProtocolFamily;</span>
 37 import java.net.StandardSocketOptions;
 38 import java.nio.channels.AlreadyBoundException;
 39 import java.nio.channels.AsynchronousCloseException;
 40 import java.nio.channels.ClosedChannelException;
 41 import java.nio.channels.IllegalBlockingModeException;
 42 import java.nio.channels.NotYetBoundException;
 43 import java.nio.channels.SelectionKey;
 44 import java.nio.channels.ServerSocketChannel;
 45 import java.nio.channels.SocketChannel;
 46 import java.nio.channels.spi.SelectorProvider;
 47 import java.util.Collections;
 48 import java.util.HashSet;
 49 import java.util.Objects;
 50 import java.util.Set;
 51 import java.util.concurrent.locks.ReentrantLock;
 52 
 53 import sun.net.NetHooks;
 54 import sun.net.ext.ExtendedSocketOptions;
 55 
 56 /**
 57  * An implementation of ServerSocketChannels
 58  */
 59 
 60 class ServerSocketChannelImpl
 61     extends ServerSocketChannel
 62     implements SelChImpl
 63 {
 64     // Used to make native close and configure calls
 65     private static final NativeDispatcher nd = new SocketDispatcher();
 66 
<span class="line-added"> 67     // The protocol family of the socket</span>
<span class="line-added"> 68     private final ProtocolFamily family;</span>
<span class="line-added"> 69 </span>
 70     // Our file descriptor
 71     private final FileDescriptor fd;
 72     private final int fdVal;
 73 
 74     // Lock held by thread currently blocked on this channel
 75     private final ReentrantLock acceptLock = new ReentrantLock();
 76 
 77     // Lock held by any thread that modifies the state fields declared below
 78     // DO NOT invoke a blocking I/O operation while holding this lock!
 79     private final Object stateLock = new Object();
 80 
 81     // -- The following fields are protected by stateLock
 82 
 83     // Channel state, increases monotonically
 84     private static final int ST_INUSE = 0;
 85     private static final int ST_CLOSING = 1;
 86     private static final int ST_CLOSED = 2;
 87     private int state;
 88 
 89     // ID of native thread currently blocked in this channel, for signalling
 90     private long thread;
 91 
 92     // Binding
 93     private InetSocketAddress localAddress; // null =&gt; unbound
 94 
 95     // set true when exclusive binding is on and SO_REUSEADDR is emulated
 96     private boolean isReuseAddress;
 97 
 98     // Our socket adaptor, if any
 99     private ServerSocket socket;
100 
101     // -- End of fields protected by stateLock
102 

103     ServerSocketChannelImpl(SelectorProvider sp) {
<span class="line-added">104         this(sp, Net.isIPv6Available()</span>
<span class="line-added">105                 ? StandardProtocolFamily.INET6</span>
<span class="line-added">106                 : StandardProtocolFamily.INET);</span>
<span class="line-added">107     }</span>
<span class="line-added">108 </span>
<span class="line-added">109     ServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family) {</span>
110         super(sp);
<span class="line-modified">111         Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);</span>
<span class="line-added">112 </span>
<span class="line-added">113         if ((family != StandardProtocolFamily.INET) &amp;&amp;</span>
<span class="line-added">114                 (family != StandardProtocolFamily.INET6)) {</span>
<span class="line-added">115             throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);</span>
<span class="line-added">116         }</span>
<span class="line-added">117         if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.isIPv6Available()) {</span>
<span class="line-added">118             throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);</span>
<span class="line-added">119         }</span>
<span class="line-added">120 </span>
<span class="line-added">121         this.family = family;</span>
<span class="line-added">122         this.fd = Net.serverSocket(family, true);</span>
123         this.fdVal = IOUtil.fdVal(fd);
124     }
125 
126     ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
127         throws IOException
128     {
129         super(sp);
<span class="line-added">130 </span>
<span class="line-added">131         this.family = Net.isIPv6Available()</span>
<span class="line-added">132                 ? StandardProtocolFamily.INET6</span>
<span class="line-added">133                 : StandardProtocolFamily.INET;</span>
134         this.fd =  fd;
135         this.fdVal = IOUtil.fdVal(fd);
<span class="line-added">136 </span>
137         if (bound) {
138             synchronized (stateLock) {
139                 localAddress = Net.localAddress(fd);
140             }
141         }
142     }
143 
144     // @throws ClosedChannelException if channel is closed
145     private void ensureOpen() throws ClosedChannelException {
146         if (!isOpen())
147             throw new ClosedChannelException();
148     }
149 
150     @Override
151     public ServerSocket socket() {
152         synchronized (stateLock) {
153             if (socket == null)
154                 socket = ServerSocketAdaptor.create(this);
155             return socket;
156         }
</pre>
<hr />
<pre>
219             set.add(StandardSocketOptions.SO_REUSEADDR);
220             if (Net.isReusePortAvailable()) {
221                 set.add(StandardSocketOptions.SO_REUSEPORT);
222             }
223             set.addAll(ExtendedSocketOptions.serverSocketOptions());
224             return Collections.unmodifiableSet(set);
225         }
226     }
227 
228     @Override
229     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
230         return DefaultOptionsHolder.defaultOptions;
231     }
232 
233     @Override
234     public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {
235         synchronized (stateLock) {
236             ensureOpen();
237             if (localAddress != null)
238                 throw new AlreadyBoundException();
<span class="line-modified">239             InetSocketAddress isa;</span>
<span class="line-modified">240             if (local == null) {</span>
<span class="line-modified">241                 isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);</span>
<span class="line-added">242             } else {</span>
<span class="line-added">243                 isa = Net.checkAddress(local, family);</span>
<span class="line-added">244             }</span>
245             SecurityManager sm = System.getSecurityManager();
246             if (sm != null)
247                 sm.checkListen(isa.getPort());
248             NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
<span class="line-modified">249             Net.bind(family, fd, isa.getAddress(), isa.getPort());</span>
250             Net.listen(fd, backlog &lt; 1 ? 50 : backlog);
251             localAddress = Net.localAddress(fd);
252         }
253         return this;
254     }
255 
256     /**
257      * Marks the beginning of an I/O operation that might block.
258      *
259      * @throws ClosedChannelException if the channel is closed
260      * @throws NotYetBoundException if the channel&#39;s socket has not been bound yet
261      */
262     private void begin(boolean blocking) throws ClosedChannelException {
263         if (blocking)
264             begin();  // set blocker to close channel if interrupted
265         synchronized (stateLock) {
266             ensureOpen();
267             if (localAddress == null)
268                 throw new NotYetBoundException();
269             if (blocking)
</pre>
<hr />
<pre>
370         } finally {
371             acceptLock.unlock();
372         }
373 
374         assert n &gt; 0;
375         return finishAccept(newfd, isaa[0]);
376     }
377 
378     private SocketChannel finishAccept(FileDescriptor newfd, InetSocketAddress isa)
379         throws IOException
380     {
381         try {
382             // newly accepted socket is initially in blocking mode
383             IOUtil.configureBlocking(newfd, true);
384 
385             // check permitted to accept connections from the remote address
386             SecurityManager sm = System.getSecurityManager();
387             if (sm != null) {
388                 sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());
389             }
<span class="line-modified">390             return new SocketChannelImpl(provider(), family, newfd, isa);</span>
391         } catch (Exception e) {
392             nd.close(newfd);
393             throw e;
394         }
395     }
396 
397     @Override
398     protected void implConfigureBlocking(boolean block) throws IOException {
399         acceptLock.lock();
400         try {
401             lockedConfigureBlocking(block);
402         } finally {
403             acceptLock.unlock();
404         }
405     }
406 
407     /**
408      * Adjust the blocking. acceptLock must already be held.
409      */
410     private void lockedConfigureBlocking(boolean block) throws IOException {
</pre>
</td>
</tr>
</table>
<center><a href="SelectorProviderImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
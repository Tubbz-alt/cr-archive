<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.net.InetSocketAddress;
<a name="1" id="anc1"></a><span class="line-added"> 31 import java.net.ProtocolFamily;</span>
 32 import java.net.ServerSocket;
 33 import java.net.SocketAddress;
 34 import java.net.SocketOption;
 35 import java.net.SocketTimeoutException;
<a name="2" id="anc2"></a><span class="line-added"> 36 import java.net.StandardProtocolFamily;</span>
 37 import java.net.StandardSocketOptions;
 38 import java.nio.channels.AlreadyBoundException;
 39 import java.nio.channels.AsynchronousCloseException;
 40 import java.nio.channels.ClosedChannelException;
 41 import java.nio.channels.IllegalBlockingModeException;
 42 import java.nio.channels.NotYetBoundException;
 43 import java.nio.channels.SelectionKey;
 44 import java.nio.channels.ServerSocketChannel;
 45 import java.nio.channels.SocketChannel;
 46 import java.nio.channels.spi.SelectorProvider;
 47 import java.util.Collections;
 48 import java.util.HashSet;
 49 import java.util.Objects;
 50 import java.util.Set;
 51 import java.util.concurrent.locks.ReentrantLock;
 52 
 53 import sun.net.NetHooks;
 54 import sun.net.ext.ExtendedSocketOptions;
 55 
 56 /**
 57  * An implementation of ServerSocketChannels
 58  */
 59 
 60 class ServerSocketChannelImpl
 61     extends ServerSocketChannel
 62     implements SelChImpl
 63 {
 64     // Used to make native close and configure calls
 65     private static final NativeDispatcher nd = new SocketDispatcher();
 66 
<a name="3" id="anc3"></a><span class="line-added"> 67     // The protocol family of the socket</span>
<span class="line-added"> 68     private final ProtocolFamily family;</span>
<span class="line-added"> 69 </span>
 70     // Our file descriptor
 71     private final FileDescriptor fd;
 72     private final int fdVal;
 73 
 74     // Lock held by thread currently blocked on this channel
 75     private final ReentrantLock acceptLock = new ReentrantLock();
 76 
 77     // Lock held by any thread that modifies the state fields declared below
 78     // DO NOT invoke a blocking I/O operation while holding this lock!
 79     private final Object stateLock = new Object();
 80 
 81     // -- The following fields are protected by stateLock
 82 
 83     // Channel state, increases monotonically
 84     private static final int ST_INUSE = 0;
 85     private static final int ST_CLOSING = 1;
 86     private static final int ST_CLOSED = 2;
 87     private int state;
 88 
 89     // ID of native thread currently blocked in this channel, for signalling
 90     private long thread;
 91 
 92     // Binding
 93     private InetSocketAddress localAddress; // null =&gt; unbound
 94 
 95     // set true when exclusive binding is on and SO_REUSEADDR is emulated
 96     private boolean isReuseAddress;
 97 
 98     // Our socket adaptor, if any
 99     private ServerSocket socket;
100 
101     // -- End of fields protected by stateLock
102 
<a name="4" id="anc4"></a>
103     ServerSocketChannelImpl(SelectorProvider sp) {
<a name="5" id="anc5"></a><span class="line-added">104         this(sp, Net.isIPv6Available()</span>
<span class="line-added">105                 ? StandardProtocolFamily.INET6</span>
<span class="line-added">106                 : StandardProtocolFamily.INET);</span>
<span class="line-added">107     }</span>
<span class="line-added">108 </span>
<span class="line-added">109     ServerSocketChannelImpl(SelectorProvider sp, ProtocolFamily family) {</span>
110         super(sp);
<a name="6" id="anc6"></a><span class="line-modified">111         Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);</span>
<span class="line-added">112 </span>
<span class="line-added">113         if ((family != StandardProtocolFamily.INET) &amp;&amp;</span>
<span class="line-added">114                 (family != StandardProtocolFamily.INET6)) {</span>
<span class="line-added">115             throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);</span>
<span class="line-added">116         }</span>
<span class="line-added">117         if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.isIPv6Available()) {</span>
<span class="line-added">118             throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);</span>
<span class="line-added">119         }</span>
<span class="line-added">120 </span>
<span class="line-added">121         this.family = family;</span>
<span class="line-added">122         this.fd = Net.serverSocket(family, true);</span>
123         this.fdVal = IOUtil.fdVal(fd);
124     }
125 
126     ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
127         throws IOException
128     {
129         super(sp);
<a name="7" id="anc7"></a><span class="line-added">130 </span>
<span class="line-added">131         this.family = Net.isIPv6Available()</span>
<span class="line-added">132                 ? StandardProtocolFamily.INET6</span>
<span class="line-added">133                 : StandardProtocolFamily.INET;</span>
134         this.fd =  fd;
135         this.fdVal = IOUtil.fdVal(fd);
<a name="8" id="anc8"></a><span class="line-added">136 </span>
137         if (bound) {
138             synchronized (stateLock) {
139                 localAddress = Net.localAddress(fd);
140             }
141         }
142     }
143 
144     // @throws ClosedChannelException if channel is closed
145     private void ensureOpen() throws ClosedChannelException {
146         if (!isOpen())
147             throw new ClosedChannelException();
148     }
149 
150     @Override
151     public ServerSocket socket() {
152         synchronized (stateLock) {
153             if (socket == null)
154                 socket = ServerSocketAdaptor.create(this);
155             return socket;
156         }
157     }
158 
159     @Override
160     public SocketAddress getLocalAddress() throws IOException {
161         synchronized (stateLock) {
162             ensureOpen();
163             return (localAddress == null)
164                     ? null
165                     : Net.getRevealedLocalAddress(localAddress);
166         }
167     }
168 
169     @Override
170     public &lt;T&gt; ServerSocketChannel setOption(SocketOption&lt;T&gt; name, T value)
171         throws IOException
172     {
173         Objects.requireNonNull(name);
174         if (!supportedOptions().contains(name))
175             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
176         if (!name.type().isInstance(value))
177             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);
178 
179         synchronized (stateLock) {
180             ensureOpen();
181 
182             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
183                 // SO_REUSEADDR emulated when using exclusive bind
184                 isReuseAddress = (Boolean)value;
185             } else {
186                 // no options that require special handling
187                 Net.setSocketOption(fd, Net.UNSPEC, name, value);
188             }
189             return this;
190         }
191     }
192 
193     @Override
194     @SuppressWarnings(&quot;unchecked&quot;)
195     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
196         throws IOException
197     {
198         Objects.requireNonNull(name);
199         if (!supportedOptions().contains(name))
200             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
201 
202         synchronized (stateLock) {
203             ensureOpen();
204             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
205                 // SO_REUSEADDR emulated when using exclusive bind
206                 return (T)Boolean.valueOf(isReuseAddress);
207             }
208             // no options that require special handling
209             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);
210         }
211     }
212 
213     private static class DefaultOptionsHolder {
214         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
215 
216         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
217             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
218             set.add(StandardSocketOptions.SO_RCVBUF);
219             set.add(StandardSocketOptions.SO_REUSEADDR);
220             if (Net.isReusePortAvailable()) {
221                 set.add(StandardSocketOptions.SO_REUSEPORT);
222             }
223             set.addAll(ExtendedSocketOptions.serverSocketOptions());
224             return Collections.unmodifiableSet(set);
225         }
226     }
227 
228     @Override
229     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
230         return DefaultOptionsHolder.defaultOptions;
231     }
232 
233     @Override
234     public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {
235         synchronized (stateLock) {
236             ensureOpen();
237             if (localAddress != null)
238                 throw new AlreadyBoundException();
<a name="9" id="anc9"></a><span class="line-modified">239             InetSocketAddress isa;</span>
<span class="line-modified">240             if (local == null) {</span>
<span class="line-modified">241                 isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);</span>
<span class="line-added">242             } else {</span>
<span class="line-added">243                 isa = Net.checkAddress(local, family);</span>
<span class="line-added">244             }</span>
245             SecurityManager sm = System.getSecurityManager();
246             if (sm != null)
247                 sm.checkListen(isa.getPort());
248             NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
<a name="10" id="anc10"></a><span class="line-modified">249             Net.bind(family, fd, isa.getAddress(), isa.getPort());</span>
250             Net.listen(fd, backlog &lt; 1 ? 50 : backlog);
251             localAddress = Net.localAddress(fd);
252         }
253         return this;
254     }
255 
256     /**
257      * Marks the beginning of an I/O operation that might block.
258      *
259      * @throws ClosedChannelException if the channel is closed
260      * @throws NotYetBoundException if the channel&#39;s socket has not been bound yet
261      */
262     private void begin(boolean blocking) throws ClosedChannelException {
263         if (blocking)
264             begin();  // set blocker to close channel if interrupted
265         synchronized (stateLock) {
266             ensureOpen();
267             if (localAddress == null)
268                 throw new NotYetBoundException();
269             if (blocking)
270                 thread = NativeThread.current();
271         }
272     }
273 
274     /**
275      * Marks the end of an I/O operation that may have blocked.
276      *
277      * @throws AsynchronousCloseException if the channel was closed due to this
278      * thread being interrupted on a blocking I/O operation.
279      */
280     private void end(boolean blocking, boolean completed)
281         throws AsynchronousCloseException
282     {
283         if (blocking) {
284             synchronized (stateLock) {
285                 thread = 0;
286                 if (state == ST_CLOSING) {
287                     tryFinishClose();
288                 }
289             }
290             end(completed);
291         }
292     }
293 
294     @Override
295     public SocketChannel accept() throws IOException {
296         int n = 0;
297         FileDescriptor newfd = new FileDescriptor();
298         InetSocketAddress[] isaa = new InetSocketAddress[1];
299 
300         acceptLock.lock();
301         try {
302             boolean blocking = isBlocking();
303             try {
304                 begin(blocking);
305                 n = Net.accept(this.fd, newfd, isaa);
306                 if (blocking) {
307                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
308                         park(Net.POLLIN);
309                         n = Net.accept(this.fd, newfd, isaa);
310                     }
311                 }
312             } finally {
313                 end(blocking, n &gt; 0);
314                 assert IOStatus.check(n);
315             }
316         } finally {
317             acceptLock.unlock();
318         }
319 
320         if (n &gt; 0) {
321             return finishAccept(newfd, isaa[0]);
322         } else {
323             return null;
324         }
325     }
326 
327     /**
328      * Accepts a new connection with a given timeout. This method requires the
329      * channel to be configured in blocking mode.
330      *
331      * @apiNote This method is for use by the socket adaptor.
332      *
333      * @param nanos the timeout, in nanoseconds
334      * @throws IllegalBlockingModeException if the channel is configured non-blocking
335      * @throws SocketTimeoutException if the timeout expires
336      */
337     SocketChannel blockingAccept(long nanos) throws IOException {
338         int n = 0;
339         FileDescriptor newfd = new FileDescriptor();
340         InetSocketAddress[] isaa = new InetSocketAddress[1];
341 
342         acceptLock.lock();
343         try {
344             // check that channel is configured blocking
345             if (!isBlocking())
346                 throw new IllegalBlockingModeException();
347 
348             try {
349                 begin(true);
350                 // change socket to non-blocking
351                 lockedConfigureBlocking(false);
352                 try {
353                     long startNanos = System.nanoTime();
354                     n = Net.accept(fd, newfd, isaa);
355                     while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {
356                         long remainingNanos = nanos - (System.nanoTime() - startNanos);
357                         if (remainingNanos &lt;= 0) {
358                             throw new SocketTimeoutException(&quot;Accept timed out&quot;);
359                         }
360                         park(Net.POLLIN, remainingNanos);
361                         n = Net.accept(fd, newfd, isaa);
362                     }
363                 } finally {
364                     // restore socket to blocking mode (if channel is open)
365                     tryLockedConfigureBlocking(true);
366                 }
367             } finally {
368                 end(true, n &gt; 0);
369             }
370         } finally {
371             acceptLock.unlock();
372         }
373 
374         assert n &gt; 0;
375         return finishAccept(newfd, isaa[0]);
376     }
377 
378     private SocketChannel finishAccept(FileDescriptor newfd, InetSocketAddress isa)
379         throws IOException
380     {
381         try {
382             // newly accepted socket is initially in blocking mode
383             IOUtil.configureBlocking(newfd, true);
384 
385             // check permitted to accept connections from the remote address
386             SecurityManager sm = System.getSecurityManager();
387             if (sm != null) {
388                 sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());
389             }
<a name="11" id="anc11"></a><span class="line-modified">390             return new SocketChannelImpl(provider(), family, newfd, isa);</span>
391         } catch (Exception e) {
392             nd.close(newfd);
393             throw e;
394         }
395     }
396 
397     @Override
398     protected void implConfigureBlocking(boolean block) throws IOException {
399         acceptLock.lock();
400         try {
401             lockedConfigureBlocking(block);
402         } finally {
403             acceptLock.unlock();
404         }
405     }
406 
407     /**
408      * Adjust the blocking. acceptLock must already be held.
409      */
410     private void lockedConfigureBlocking(boolean block) throws IOException {
411         assert acceptLock.isHeldByCurrentThread();
412         synchronized (stateLock) {
413             ensureOpen();
414             IOUtil.configureBlocking(fd, block);
415         }
416     }
417 
418     /**
419      * Adjusts the blocking mode if the channel is open. acceptLock must already
420      * be held.
421      *
422      * @return {@code true} if the blocking mode was adjusted, {@code false} if
423      *         the blocking mode was not adjusted because the channel is closed
424      */
425     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {
426         assert acceptLock.isHeldByCurrentThread();
427         synchronized (stateLock) {
428             if (isOpen()) {
429                 IOUtil.configureBlocking(fd, block);
430                 return true;
431             } else {
432                 return false;
433             }
434         }
435     }
436 
437     /**
438      * Closes the socket if there are no accept in progress and the channel is
439      * not registered with a Selector.
440      */
441     private boolean tryClose() throws IOException {
442         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;
443         if ((thread == 0) &amp;&amp; !isRegistered()) {
444             state = ST_CLOSED;
445             nd.close(fd);
446             return true;
447         } else {
448             return false;
449         }
450     }
451 
452     /**
453      * Invokes tryClose to attempt to close the socket.
454      *
455      * This method is used for deferred closing by I/O and Selector operations.
456      */
457     private void tryFinishClose() {
458         try {
459             tryClose();
460         } catch (IOException ignore) { }
461     }
462 
463     /**
464      * Closes this channel when configured in blocking mode.
465      *
466      * If there is an accept in progress then the socket is pre-closed and the
467      * accept thread is signalled, in which case the final close is deferred
468      * until the accept aborts.
469      */
470     private void implCloseBlockingMode() throws IOException {
471         synchronized (stateLock) {
472             assert state &lt; ST_CLOSING;
473             state = ST_CLOSING;
474             if (!tryClose()) {
475                 long th = thread;
476                 if (th != 0) {
477                     nd.preClose(fd);
478                     NativeThread.signal(th);
479                 }
480             }
481         }
482     }
483 
484     /**
485      * Closes this channel when configured in non-blocking mode.
486      *
487      * If the channel is registered with a Selector then the close is deferred
488      * until the channel is flushed from all Selectors.
489      */
490     private void implCloseNonBlockingMode() throws IOException {
491         synchronized (stateLock) {
492             assert state &lt; ST_CLOSING;
493             state = ST_CLOSING;
494         }
495         // wait for any accept to complete before trying to close
496         acceptLock.lock();
497         acceptLock.unlock();
498         synchronized (stateLock) {
499             if (state == ST_CLOSING) {
500                 tryClose();
501             }
502         }
503     }
504 
505     /**
506      * Invoked by implCloseChannel to close the channel.
507      */
508     @Override
509     protected void implCloseSelectableChannel() throws IOException {
510         assert !isOpen();
511         if (isBlocking()) {
512             implCloseBlockingMode();
513         } else {
514             implCloseNonBlockingMode();
515         }
516     }
517 
518     @Override
519     public void kill() {
520         synchronized (stateLock) {
521             if (state == ST_CLOSING) {
522                 tryFinishClose();
523             }
524         }
525     }
526 
527     /**
528      * Returns true if channel&#39;s socket is bound
529      */
530     boolean isBound() {
531         synchronized (stateLock) {
532             return localAddress != null;
533         }
534     }
535 
536     /**
537      * Returns the local address, or null if not bound
538      */
539     InetSocketAddress localAddress() {
540         synchronized (stateLock) {
541             return localAddress;
542         }
543     }
544 
545     /**
546      * Translates native poll revent set into a ready operation set
547      */
548     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
549         int intOps = ski.nioInterestOps();
550         int oldOps = ski.nioReadyOps();
551         int newOps = initialOps;
552 
553         if ((ops &amp; Net.POLLNVAL) != 0) {
554             // This should only happen if this channel is pre-closed while a
555             // selection operation is in progress
556             // ## Throw an error if this channel has not been pre-closed
557             return false;
558         }
559 
560         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
561             newOps = intOps;
562             ski.nioReadyOps(newOps);
563             return (newOps &amp; ~oldOps) != 0;
564         }
565 
566         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
567             ((intOps &amp; SelectionKey.OP_ACCEPT) != 0))
568                 newOps |= SelectionKey.OP_ACCEPT;
569 
570         ski.nioReadyOps(newOps);
571         return (newOps &amp; ~oldOps) != 0;
572     }
573 
574     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
575         return translateReadyOps(ops, ski.nioReadyOps(), ski);
576     }
577 
578     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
579         return translateReadyOps(ops, 0, ski);
580     }
581 
582     /**
583      * Translates an interest operation set into a native poll event set
584      */
585     public int translateInterestOps(int ops) {
586         int newOps = 0;
587         if ((ops &amp; SelectionKey.OP_ACCEPT) != 0)
588             newOps |= Net.POLLIN;
589         return newOps;
590     }
591 
592     public FileDescriptor getFD() {
593         return fd;
594     }
595 
596     public int getFDVal() {
597         return fdVal;
598     }
599 
600     public String toString() {
601         StringBuilder sb = new StringBuilder();
602         sb.append(this.getClass().getName());
603         sb.append(&#39;[&#39;);
604         if (!isOpen()) {
605             sb.append(&quot;closed&quot;);
606         } else {
607             synchronized (stateLock) {
608                 InetSocketAddress addr = localAddress;
609                 if (addr == null) {
610                     sb.append(&quot;unbound&quot;);
611                 } else {
612                     sb.append(Net.getRevealedLocalAddressAsString(addr));
613                 }
614             }
615         }
616         sb.append(&#39;]&#39;);
617         return sb.toString();
618     }
619 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
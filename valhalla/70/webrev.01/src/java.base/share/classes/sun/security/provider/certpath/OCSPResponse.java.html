<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/provider/certpath/OCSPResponse.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.provider.certpath;
  27 
  28 import java.io.*;
  29 import java.security.*;
  30 import java.security.cert.CertificateException;
  31 import java.security.cert.CertificateParsingException;
  32 import java.security.cert.CertPathValidatorException;
  33 import java.security.cert.CertPathValidatorException.BasicReason;
  34 import java.security.cert.CRLReason;
  35 import java.security.cert.TrustAnchor;
  36 import java.security.cert.X509Certificate;
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.Collections;
  40 import java.util.Date;
  41 import java.util.HashMap;
  42 import java.util.List;
  43 import java.util.Map;
  44 import java.util.Set;
  45 import javax.security.auth.x500.X500Principal;
  46 
  47 import sun.security.util.HexDumpEncoder;
  48 import sun.security.action.GetIntegerAction;
  49 import sun.security.x509.*;
  50 import sun.security.util.*;
  51 
  52 /**
  53  * This class is used to process an OCSP response.
  54  * The OCSP Response is defined
  55  * in RFC 2560 and the ASN.1 encoding is as follows:
  56  * &lt;pre&gt;
  57  *
  58  *  OCSPResponse ::= SEQUENCE {
  59  *      responseStatus         OCSPResponseStatus,
  60  *      responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
  61  *
  62  *   OCSPResponseStatus ::= ENUMERATED {
  63  *       successful            (0),  --Response has valid confirmations
  64  *       malformedRequest      (1),  --Illegal confirmation request
  65  *       internalError         (2),  --Internal error in issuer
  66  *       tryLater              (3),  --Try again later
  67  *                                   --(4) is not used
  68  *       sigRequired           (5),  --Must sign the request
  69  *       unauthorized          (6)   --Request unauthorized
  70  *   }
  71  *
  72  *   ResponseBytes ::=       SEQUENCE {
  73  *       responseType   OBJECT IDENTIFIER,
  74  *       response       OCTET STRING }
  75  *
  76  *   BasicOCSPResponse       ::= SEQUENCE {
  77  *      tbsResponseData      ResponseData,
  78  *      signatureAlgorithm   AlgorithmIdentifier,
  79  *      signature            BIT STRING,
  80  *      certs                [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }
  81  *
  82  *   The value for signature SHALL be computed on the hash of the DER
  83  *   encoding ResponseData.
  84  *
  85  *   ResponseData ::= SEQUENCE {
  86  *      version              [0] EXPLICIT Version DEFAULT v1,
  87  *      responderID              ResponderID,
  88  *      producedAt               GeneralizedTime,
  89  *      responses                SEQUENCE OF SingleResponse,
  90  *      responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
  91  *
  92  *   ResponderID ::= CHOICE {
  93  *      byName               [1] Name,
  94  *      byKey                [2] KeyHash }
  95  *
  96  *   KeyHash ::= OCTET STRING -- SHA-1 hash of responder&#39;s public key
  97  *   (excluding the tag and length fields)
  98  *
  99  *   SingleResponse ::= SEQUENCE {
 100  *      certID                       CertID,
 101  *      certStatus                   CertStatus,
 102  *      thisUpdate                   GeneralizedTime,
 103  *      nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
 104  *      singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
 105  *
 106  *   CertStatus ::= CHOICE {
 107  *       good        [0]     IMPLICIT NULL,
 108  *       revoked     [1]     IMPLICIT RevokedInfo,
 109  *       unknown     [2]     IMPLICIT UnknownInfo }
 110  *
 111  *   RevokedInfo ::= SEQUENCE {
 112  *       revocationTime              GeneralizedTime,
 113  *       revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
 114  *
 115  *   UnknownInfo ::= NULL -- this can be replaced with an enumeration
 116  *
 117  * &lt;/pre&gt;
 118  *
 119  * @author      Ram Marti
 120  */
 121 
 122 public final class OCSPResponse {
 123 
 124     public enum ResponseStatus {
 125         SUCCESSFUL,            // Response has valid confirmations
 126         MALFORMED_REQUEST,     // Illegal request
 127         INTERNAL_ERROR,        // Internal error in responder
 128         TRY_LATER,             // Try again later
 129         UNUSED,                // is not used
 130         SIG_REQUIRED,          // Must sign the request
 131         UNAUTHORIZED           // Request unauthorized
 132     };
 133     private static final ResponseStatus[] rsvalues = ResponseStatus.values();
 134 
 135     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
 136     private static final boolean dump = debug != null &amp;&amp; Debug.isOn(&quot;ocsp&quot;);
 137     private static final ObjectIdentifier OCSP_BASIC_RESPONSE_OID =
 138         ObjectIdentifier.of(KnownOIDs.OCSPBasicResponse);
 139     private static final int CERT_STATUS_GOOD = 0;
 140     private static final int CERT_STATUS_REVOKED = 1;
 141     private static final int CERT_STATUS_UNKNOWN = 2;
 142 
 143     // ResponderID CHOICE tags
 144     private static final int NAME_TAG = 1;
 145     private static final int KEY_TAG = 2;
 146 
 147     // Default maximum clock skew in milliseconds (15 minutes)
 148     // allowed when checking validity of OCSP responses
 149     private static final int DEFAULT_MAX_CLOCK_SKEW = 900000;
 150 
 151     /**
 152      * Integer value indicating the maximum allowable clock skew,
 153      * in milliseconds, to be used for the OCSP check.
 154      */
 155     private static final int MAX_CLOCK_SKEW = initializeClockSkew();
 156 
 157     /**
 158      * Initialize the maximum allowable clock skew by getting the OCSP
 159      * clock skew system property. If the property has not been set, or if its
 160      * value is negative, set the skew to the default.
 161      */
 162     private static int initializeClockSkew() {
 163         Integer tmp = java.security.AccessController.doPrivileged(
 164                 new GetIntegerAction(&quot;com.sun.security.ocsp.clockSkew&quot;));
 165         if (tmp == null || tmp &lt; 0) {
 166             return DEFAULT_MAX_CLOCK_SKEW;
 167         }
 168         // Convert to milliseconds, as the system property will be
 169         // specified in seconds
 170         return tmp * 1000;
 171     }
 172 
 173     // an array of all of the CRLReasons (used in SingleResponse)
 174     private static final CRLReason[] values = CRLReason.values();
 175 
 176     private final ResponseStatus responseStatus;
 177     private final Map&lt;CertId, SingleResponse&gt; singleResponseMap;
 178     private final AlgorithmId sigAlgId;
 179     private final byte[] signature;
 180     private final byte[] tbsResponseData;
 181     private final byte[] responseNonce;
 182     private List&lt;X509CertImpl&gt; certs;
 183     private X509CertImpl signerCert = null;
 184     private final ResponderId respId;
 185     private Date producedAtDate = null;
 186     private final Map&lt;String, java.security.cert.Extension&gt; responseExtensions;
 187 
 188     /*
 189      * Create an OCSP response from its ASN.1 DER encoding.
 190      *
 191      * @param bytes The DER-encoded bytes for an OCSP response
 192      */
 193     public OCSPResponse(byte[] bytes) throws IOException {
 194         if (dump) {
 195             HexDumpEncoder hexEnc = new HexDumpEncoder();
 196             debug.println(&quot;OCSPResponse bytes...\n\n&quot; +
 197                 hexEnc.encode(bytes) + &quot;\n&quot;);
 198         }
 199         DerValue der = new DerValue(bytes);
 200         if (der.tag != DerValue.tag_Sequence) {
 201             throw new IOException(&quot;Bad encoding in OCSP response: &quot; +
 202                 &quot;expected ASN.1 SEQUENCE tag.&quot;);
 203         }
 204         DerInputStream derIn = der.getData();
 205 
 206         // responseStatus
 207         int status = derIn.getEnumerated();
 208         if (status &gt;= 0 &amp;&amp; status &lt; rsvalues.length) {
 209             responseStatus = rsvalues[status];
 210         } else {
 211             // unspecified responseStatus
 212             throw new IOException(&quot;Unknown OCSPResponse status: &quot; + status);
 213         }
 214         if (debug != null) {
 215             debug.println(&quot;OCSP response status: &quot; + responseStatus);
 216         }
 217         if (responseStatus != ResponseStatus.SUCCESSFUL) {
 218             // no need to continue, responseBytes are not set.
 219             singleResponseMap = Collections.emptyMap();
 220             certs = new ArrayList&lt;X509CertImpl&gt;();
 221             sigAlgId = null;
 222             signature = null;
 223             tbsResponseData = null;
 224             responseNonce = null;
 225             responseExtensions = Collections.emptyMap();
 226             respId = null;
 227             return;
 228         }
 229 
 230         // responseBytes
 231         der = derIn.getDerValue();
 232         if (!der.isContextSpecific((byte)0)) {
 233             throw new IOException(&quot;Bad encoding in responseBytes element &quot; +
 234                 &quot;of OCSP response: expected ASN.1 context specific tag 0.&quot;);
 235         }
 236         DerValue tmp = der.data.getDerValue();
 237         if (tmp.tag != DerValue.tag_Sequence) {
 238             throw new IOException(&quot;Bad encoding in responseBytes element &quot; +
 239                 &quot;of OCSP response: expected ASN.1 SEQUENCE tag.&quot;);
 240         }
 241 
 242         // responseType
 243         derIn = tmp.data;
 244         ObjectIdentifier responseType = derIn.getOID();
 245         if (responseType.equals((Object)OCSP_BASIC_RESPONSE_OID)) {
 246             if (debug != null) {
 247                 debug.println(&quot;OCSP response type: basic&quot;);
 248             }
 249         } else {
 250             if (debug != null) {
 251                 debug.println(&quot;OCSP response type: &quot; + responseType);
 252             }
 253             throw new IOException(&quot;Unsupported OCSP response type: &quot; +
 254                                   responseType);
 255         }
 256 
 257         // BasicOCSPResponse
 258         DerInputStream basicOCSPResponse =
 259             new DerInputStream(derIn.getOctetString());
 260 
 261         DerValue[] seqTmp = basicOCSPResponse.getSequence(2);
 262         if (seqTmp.length &lt; 3) {
 263             throw new IOException(&quot;Unexpected BasicOCSPResponse value&quot;);
 264         }
 265 
 266         DerValue responseData = seqTmp[0];
 267 
 268         // Need the DER encoded ResponseData to verify the signature later
 269         tbsResponseData = seqTmp[0].toByteArray();
 270 
 271         // tbsResponseData
 272         if (responseData.tag != DerValue.tag_Sequence) {
 273             throw new IOException(&quot;Bad encoding in tbsResponseData &quot; +
 274                 &quot;element of OCSP response: expected ASN.1 SEQUENCE tag.&quot;);
 275         }
 276         DerInputStream seqDerIn = responseData.data;
 277         DerValue seq = seqDerIn.getDerValue();
 278 
 279         // version
 280         if (seq.isContextSpecific((byte)0)) {
 281             // seq[0] is version
 282             if (seq.isConstructed() &amp;&amp; seq.isContextSpecific()) {
 283                 //System.out.println (&quot;version is available&quot;);
 284                 seq = seq.data.getDerValue();
 285                 int version = seq.getInteger();
 286                 if (seq.data.available() != 0) {
 287                     throw new IOException(&quot;Bad encoding in version &quot; +
 288                         &quot; element of OCSP response: bad format&quot;);
 289                 }
 290                 seq = seqDerIn.getDerValue();
 291             }
 292         }
 293 
 294         // responderID
 295         respId = new ResponderId(seq.toByteArray());
 296         if (debug != null) {
 297             debug.println(&quot;Responder ID: &quot; + respId);
 298         }
 299 
 300         // producedAt
 301         seq = seqDerIn.getDerValue();
 302         producedAtDate = seq.getGeneralizedTime();
 303         if (debug != null) {
 304             debug.println(&quot;OCSP response produced at: &quot; + producedAtDate);
 305         }
 306 
 307         // responses
 308         DerValue[] singleResponseDer = seqDerIn.getSequence(1);
 309         singleResponseMap = new HashMap&lt;&gt;(singleResponseDer.length);
 310         if (debug != null) {
 311             debug.println(&quot;OCSP number of SingleResponses: &quot;
 312                           + singleResponseDer.length);
 313         }
 314         for (DerValue srDer : singleResponseDer) {
 315             SingleResponse singleResponse = new SingleResponse(srDer);
 316             singleResponseMap.put(singleResponse.getCertId(), singleResponse);
 317         }
 318 
 319         // responseExtensions
 320         Map&lt;String, java.security.cert.Extension&gt; tmpExtMap = new HashMap&lt;&gt;();
 321         if (seqDerIn.available() &gt; 0) {
 322             seq = seqDerIn.getDerValue();
 323             if (seq.isContextSpecific((byte)1)) {
 324                 tmpExtMap = parseExtensions(seq);
 325             }
 326         }
 327         responseExtensions = tmpExtMap;
 328 
 329         // Attach the nonce value if found in the extension map
 330         Extension nonceExt = (Extension)tmpExtMap.get(
 331                 PKIXExtensions.OCSPNonce_Id.toString());
 332         responseNonce = (nonceExt != null) ?
 333                 nonceExt.getExtensionValue() : null;
 334         if (debug != null &amp;&amp; responseNonce != null) {
 335             debug.println(&quot;Response nonce: &quot; + Arrays.toString(responseNonce));
 336         }
 337 
 338         // signatureAlgorithmId
 339         sigAlgId = AlgorithmId.parse(seqTmp[1]);
 340 
 341         // signature
 342         signature = seqTmp[2].getBitString();
 343 
 344         // if seq[3] is available , then it is a sequence of certificates
 345         if (seqTmp.length &gt; 3) {
 346             // certs are available
 347             DerValue seqCert = seqTmp[3];
 348             if (!seqCert.isContextSpecific((byte)0)) {
 349                 throw new IOException(&quot;Bad encoding in certs element of &quot; +
 350                     &quot;OCSP response: expected ASN.1 context specific tag 0.&quot;);
 351             }
 352             DerValue[] derCerts = seqCert.getData().getSequence(3);
 353             certs = new ArrayList&lt;X509CertImpl&gt;(derCerts.length);
 354             try {
 355                 for (int i = 0; i &lt; derCerts.length; i++) {
 356                     X509CertImpl cert =
 357                         new X509CertImpl(derCerts[i].toByteArray());
 358                     certs.add(cert);
 359 
 360                     if (debug != null) {
 361                         debug.println(&quot;OCSP response cert #&quot; + (i + 1) + &quot;: &quot; +
 362                             cert.getSubjectX500Principal());
 363                     }
 364                 }
 365             } catch (CertificateException ce) {
 366                 throw new IOException(&quot;Bad encoding in X509 Certificate&quot;, ce);
 367             }
 368         } else {
 369             certs = new ArrayList&lt;X509CertImpl&gt;();
 370         }
 371     }
 372 
 373     void verify(List&lt;CertId&gt; certIds, IssuerInfo issuerInfo,
 374             X509Certificate responderCert, Date date, byte[] nonce,
 375             String variant)
 376         throws CertPathValidatorException
 377     {
 378         switch (responseStatus) {
 379             case SUCCESSFUL:
 380                 break;
 381             case TRY_LATER:
 382             case INTERNAL_ERROR:
 383                 throw new CertPathValidatorException(
 384                     &quot;OCSP response error: &quot; + responseStatus, null, null, -1,
 385                     BasicReason.UNDETERMINED_REVOCATION_STATUS);
 386             case UNAUTHORIZED:
 387             default:
 388                 throw new CertPathValidatorException(&quot;OCSP response error: &quot; +
 389                                                      responseStatus);
 390         }
 391 
 392         // Check that the response includes a response for all of the
 393         // certs that were supplied in the request
 394         for (CertId certId : certIds) {
 395             SingleResponse sr = getSingleResponse(certId);
 396             if (sr == null) {
 397                 if (debug != null) {
 398                     debug.println(&quot;No response found for CertId: &quot; + certId);
 399                 }
 400                 throw new CertPathValidatorException(
 401                     &quot;OCSP response does not include a response for a &quot; +
 402                     &quot;certificate supplied in the OCSP request&quot;);
 403             }
 404             if (debug != null) {
 405                 debug.println(&quot;Status of certificate (with serial number &quot; +
 406                     certId.getSerialNumber() + &quot;) is: &quot; + sr.getCertStatus());
 407             }
 408         }
 409 
 410         // Locate the signer cert
 411         if (signerCert == null) {
 412             // Add the Issuing CA cert and/or Trusted Responder cert to the list
 413             // of certs from the OCSP response
 414             try {
 415                 if (issuerInfo.getCertificate() != null) {
 416                     certs.add(X509CertImpl.toImpl(issuerInfo.getCertificate()));
 417                 }
 418                 if (responderCert != null) {
 419                     certs.add(X509CertImpl.toImpl(responderCert));
 420                 }
 421             } catch (CertificateException ce) {
 422                 throw new CertPathValidatorException(
 423                     &quot;Invalid issuer or trusted responder certificate&quot;, ce);
 424             }
 425 
 426             if (respId.getType() == ResponderId.Type.BY_NAME) {
 427                 X500Principal rName = respId.getResponderName();
 428                 for (X509CertImpl cert : certs) {
 429                     if (cert.getSubjectX500Principal().equals(rName)) {
 430                         signerCert = cert;
 431                         break;
 432                     }
 433                 }
 434             } else if (respId.getType() == ResponderId.Type.BY_KEY) {
 435                 KeyIdentifier ridKeyId = respId.getKeyIdentifier();
 436                 for (X509CertImpl cert : certs) {
 437                     // Match responder&#39;s key identifier against the cert&#39;s SKID
 438                     // This will match if the SKID is encoded using the 160-bit
 439                     // SHA-1 hash method as defined in RFC 5280.
 440                     KeyIdentifier certKeyId = cert.getSubjectKeyId();
 441                     if (certKeyId != null &amp;&amp; ridKeyId.equals(certKeyId)) {
 442                         signerCert = cert;
 443                         break;
 444                     } else {
 445                         // The certificate does not have a SKID or may have
 446                         // been using a different algorithm (ex: see RFC 7093).
 447                         // Check if the responder&#39;s key identifier matches
 448                         // against a newly generated key identifier of the
 449                         // cert&#39;s public key using the 160-bit SHA-1 method.
 450                         try {
 451                             certKeyId = new KeyIdentifier(cert.getPublicKey());
 452                         } catch (IOException e) {
 453                             // ignore
 454                         }
 455                         if (ridKeyId.equals(certKeyId)) {
 456                             signerCert = cert;
 457                             break;
 458                         }
 459                     }
 460                 }
 461             }
 462         }
 463 
 464         // Check whether the signer cert returned by the responder is trusted
 465         if (signerCert != null) {
 466             // Check if the response is signed by the issuing CA
 467             if (signerCert.getSubjectX500Principal().equals(
 468                     issuerInfo.getName()) &amp;&amp;
 469                     signerCert.getPublicKey().equals(
 470                             issuerInfo.getPublicKey())) {
 471                 if (debug != null) {
 472                     debug.println(&quot;OCSP response is signed by the target&#39;s &quot; +
 473                         &quot;Issuing CA&quot;);
 474                 }
 475                 // cert is trusted, now verify the signed response
 476 
 477             // Check if the response is signed by a trusted responder
 478             } else if (signerCert.equals(responderCert)) {
 479                 if (debug != null) {
 480                     debug.println(&quot;OCSP response is signed by a Trusted &quot; +
 481                         &quot;Responder&quot;);
 482                 }
 483                 // cert is trusted, now verify the signed response
 484 
 485             // Check if the response is signed by an authorized responder
 486             } else if (signerCert.getIssuerX500Principal().equals(
 487                     issuerInfo.getName())) {
 488 
 489                 // Check for the OCSPSigning key purpose
 490                 try {
 491                     List&lt;String&gt; keyPurposes = signerCert.getExtendedKeyUsage();
 492                     if (keyPurposes == null ||
 493                         !keyPurposes.contains(KnownOIDs.OCSPSigning.value())) {
 494                         throw new CertPathValidatorException(
 495                             &quot;Responder&#39;s certificate not valid for signing &quot; +
 496                             &quot;OCSP responses&quot;);
 497                     }
 498                 } catch (CertificateParsingException cpe) {
 499                     // assume cert is not valid for signing
 500                     throw new CertPathValidatorException(
 501                         &quot;Responder&#39;s certificate not valid for signing &quot; +
 502                         &quot;OCSP responses&quot;, cpe);
 503                 }
 504 
 505                 // Check algorithm constraints specified in security property
 506                 // &quot;jdk.certpath.disabledAlgorithms&quot;.
 507                 AlgorithmChecker algChecker =
 508                         new AlgorithmChecker(issuerInfo.getAnchor(), date,
 509                                 variant);
 510                 algChecker.init(false);
 511                 algChecker.check(signerCert, Collections.&lt;String&gt;emptySet());
 512 
 513                 // check the validity
 514                 try {
 515                     if (date == null) {
 516                         signerCert.checkValidity();
 517                     } else {
 518                         signerCert.checkValidity(date);
 519                     }
 520                 } catch (CertificateException e) {
 521                     throw new CertPathValidatorException(
 522                         &quot;Responder&#39;s certificate not within the &quot; +
 523                         &quot;validity period&quot;, e);
 524                 }
 525 
 526                 // check for revocation
 527                 //
 528                 // A CA may specify that an OCSP client can trust a
 529                 // responder for the lifetime of the responder&#39;s
 530                 // certificate. The CA does so by including the
 531                 // extension id-pkix-ocsp-nocheck.
 532                 //
 533                 Extension noCheck =
 534                     signerCert.getExtension(PKIXExtensions.OCSPNoCheck_Id);
 535                 if (noCheck != null) {
 536                     if (debug != null) {
 537                         debug.println(&quot;Responder&#39;s certificate includes &quot; +
 538                             &quot;the extension id-pkix-ocsp-nocheck.&quot;);
 539                     }
 540                 } else {
 541                     // we should do the revocation checking of the
 542                     // authorized responder in a future update.
 543                 }
 544 
 545                 // verify the signature
 546                 try {
 547                     signerCert.verify(issuerInfo.getPublicKey());
 548                     if (debug != null) {
 549                         debug.println(&quot;OCSP response is signed by an &quot; +
 550                             &quot;Authorized Responder&quot;);
 551                     }
 552                     // cert is trusted, now verify the signed response
 553 
 554                 } catch (GeneralSecurityException e) {
 555                     signerCert = null;
 556                 }
 557             } else {
 558                 throw new CertPathValidatorException(
 559                     &quot;Responder&#39;s certificate is not authorized to sign &quot; +
 560                     &quot;OCSP responses&quot;);
 561             }
 562         }
 563 
 564         // Confirm that the signed response was generated using the public
 565         // key from the trusted responder cert
 566         if (signerCert != null) {
 567             // Check algorithm constraints specified in security property
 568             // &quot;jdk.certpath.disabledAlgorithms&quot;.
 569             AlgorithmChecker.check(signerCert.getPublicKey(), sigAlgId, variant);
 570 
 571             if (!verifySignature(signerCert)) {
 572                 throw new CertPathValidatorException(
 573                     &quot;Error verifying OCSP Response&#39;s signature&quot;);
 574             }
 575         } else {
 576             // Need responder&#39;s cert in order to verify the signature
 577             throw new CertPathValidatorException(
 578                 &quot;Unable to verify OCSP Response&#39;s signature&quot;);
 579         }
 580 
 581         if (nonce != null) {
 582             if (responseNonce != null &amp;&amp; !Arrays.equals(nonce, responseNonce)) {
 583                 throw new CertPathValidatorException(&quot;Nonces don&#39;t match&quot;);
 584             }
 585         }
 586 
 587         // Check freshness of OCSPResponse
 588         long now = (date == null) ? System.currentTimeMillis() : date.getTime();
 589         Date nowPlusSkew = new Date(now + MAX_CLOCK_SKEW);
 590         Date nowMinusSkew = new Date(now - MAX_CLOCK_SKEW);
 591         for (SingleResponse sr : singleResponseMap.values()) {
 592             if (debug != null) {
 593                 String until = &quot;&quot;;
 594                 if (sr.nextUpdate != null) {
 595                     until = &quot; until &quot; + sr.nextUpdate;
 596                 }
 597                 debug.println(&quot;OCSP response validity interval is from &quot; +
 598                         sr.thisUpdate + until);
 599                 debug.println(&quot;Checking validity of OCSP response on &quot; +
 600                         new Date(now) + &quot; with allowed interval between &quot; +
 601                         nowMinusSkew + &quot; and &quot; + nowPlusSkew);
 602             }
 603 
 604             // Check that the test date is within the validity interval:
 605             //   [ thisUpdate - MAX_CLOCK_SKEW,
 606             //     MAX(thisUpdate, nextUpdate) + MAX_CLOCK_SKEW ]
 607             if (nowPlusSkew.before(sr.thisUpdate) ||
 608                     nowMinusSkew.after(
 609                     sr.nextUpdate != null ? sr.nextUpdate : sr.thisUpdate))
 610             {
 611                 throw new CertPathValidatorException(
 612                                       &quot;Response is unreliable: its validity &quot; +
 613                                       &quot;interval is out-of-date&quot;);
 614             }
 615         }
 616     }
 617 
 618     /**
 619      * Returns the OCSP ResponseStatus.
 620      *
 621      * @return the {@code ResponseStatus} for this OCSP response
 622      */
 623     public ResponseStatus getResponseStatus() {
 624         return responseStatus;
 625     }
 626 
 627     /*
 628      * Verify the signature of the OCSP response.
 629      */
 630     private boolean verifySignature(X509Certificate cert)
 631         throws CertPathValidatorException {
 632 
 633         try {
 634             Signature respSignature = Signature.getInstance(sigAlgId.getName());
 635             respSignature.initVerify(cert.getPublicKey());
 636             respSignature.update(tbsResponseData);
 637 
 638             if (respSignature.verify(signature)) {
 639                 if (debug != null) {
 640                     debug.println(&quot;Verified signature of OCSP Response&quot;);
 641                 }
 642                 return true;
 643 
 644             } else {
 645                 if (debug != null) {
 646                     debug.println(
 647                         &quot;Error verifying signature of OCSP Response&quot;);
 648                 }
 649                 return false;
 650             }
 651         } catch (InvalidKeyException | NoSuchAlgorithmException |
 652                  SignatureException e)
 653         {
 654             throw new CertPathValidatorException(e);
 655         }
 656     }
 657 
 658     /**
 659      * Returns the SingleResponse of the specified CertId, or null if
 660      * there is no response for that CertId.
 661      *
 662      * @param certId the {@code CertId} for a {@code SingleResponse} to be
 663      * searched for in the OCSP response.
 664      *
 665      * @return the {@code SingleResponse} for the provided {@code CertId},
 666      * or {@code null} if it is not found.
 667      */
 668     public SingleResponse getSingleResponse(CertId certId) {
 669         return singleResponseMap.get(certId);
 670     }
 671 
 672     /**
 673      * Return a set of all CertIds in this {@code OCSPResponse}
 674      *
 675      * @return an unmodifiable set containing every {@code CertId} in this
 676      *      response.
 677      */
 678     public Set&lt;CertId&gt; getCertIds() {
 679         return Collections.unmodifiableSet(singleResponseMap.keySet());
 680     }
 681 
 682     /*
 683      * Returns the certificate for the authority that signed the OCSP response.
 684      */
 685     X509Certificate getSignerCertificate() {
 686         return signerCert; // set in verify()
 687     }
 688 
 689     /**
 690      * Get the {@code ResponderId} from this {@code OCSPResponse}
 691      *
 692      * @return the {@code ResponderId} from this response or {@code null}
 693      *      if no responder ID is in the body of the response (e.g. a
 694      *      response with a status other than SUCCESS.
 695      */
 696     public ResponderId getResponderId() {
 697         return respId;
 698     }
 699 
 700     /**
 701      * Provide a String representation of an OCSPResponse
 702      *
 703      * @return a human-readable representation of the OCSPResponse
 704      */
 705     @Override
 706     public String toString() {
 707         StringBuilder sb = new StringBuilder();
 708         sb.append(&quot;OCSP Response:\n&quot;);
 709         sb.append(&quot;Response Status: &quot;).append(responseStatus).append(&quot;\n&quot;);
 710         sb.append(&quot;Responder ID: &quot;).append(respId).append(&quot;\n&quot;);
 711         sb.append(&quot;Produced at: &quot;).append(producedAtDate).append(&quot;\n&quot;);
 712         int count = singleResponseMap.size();
 713         sb.append(count).append(count == 1 ?
 714                 &quot; response:\n&quot; : &quot; responses:\n&quot;);
 715         for (SingleResponse sr : singleResponseMap.values()) {
 716             sb.append(sr).append(&quot;\n&quot;);
 717         }
 718         if (responseExtensions != null &amp;&amp; responseExtensions.size() &gt; 0) {
 719             count = responseExtensions.size();
 720             sb.append(count).append(count == 1 ?
 721                     &quot; extension:\n&quot; : &quot; extensions:\n&quot;);
 722             for (String extId : responseExtensions.keySet()) {
 723                 sb.append(responseExtensions.get(extId)).append(&quot;\n&quot;);
 724             }
 725         }
 726 
 727         return sb.toString();
 728     }
 729 
 730     /**
 731      * Build a String-Extension map from DER encoded data.
 732      * @param derVal A {@code DerValue} object built from a SEQUENCE of
 733      *      extensions
 734      *
 735      * @return a {@code Map} using the OID in string form as the keys.  If no
 736      *      extensions are found or an empty SEQUENCE is passed in, then
 737      *      an empty {@code Map} will be returned.
 738      *
 739      * @throws IOException if any decoding errors occur.
 740      */
 741     private static Map&lt;String, java.security.cert.Extension&gt;
 742         parseExtensions(DerValue derVal) throws IOException {
 743         DerValue[] extDer = derVal.data.getSequence(3);
 744         Map&lt;String, java.security.cert.Extension&gt; extMap =
 745                 new HashMap&lt;&gt;(extDer.length);
 746 
 747         for (DerValue extDerVal : extDer) {
 748             Extension ext = new Extension(extDerVal);
 749             if (debug != null) {
 750                 debug.println(&quot;Extension: &quot; + ext);
 751             }
 752             // We don&#39;t support any extensions yet. Therefore, if it
 753             // is critical we must throw an exception because we
 754             // don&#39;t know how to process it.
 755             if (ext.isCritical()) {
 756                 throw new IOException(&quot;Unsupported OCSP critical extension: &quot; +
 757                         ext.getExtensionId());
 758             }
 759             extMap.put(ext.getId(), ext);
 760         }
 761 
 762         return extMap;
 763     }
 764 
 765     /*
 766      * A class representing a single OCSP response.
 767      */
 768     public static final class SingleResponse implements OCSP.RevocationStatus {
 769         private final CertId certId;
 770         private final CertStatus certStatus;
 771         private final Date thisUpdate;
 772         private final Date nextUpdate;
 773         private final Date revocationTime;
 774         private final CRLReason revocationReason;
 775         private final Map&lt;String, java.security.cert.Extension&gt; singleExtensions;
 776 
 777         private SingleResponse(DerValue der) throws IOException {
 778             if (der.tag != DerValue.tag_Sequence) {
 779                 throw new IOException(&quot;Bad ASN.1 encoding in SingleResponse&quot;);
 780             }
 781             DerInputStream tmp = der.data;
 782 
 783             certId = new CertId(tmp.getDerValue().data);
 784             DerValue derVal = tmp.getDerValue();
 785             short tag = (byte)(derVal.tag &amp; 0x1f);
 786             if (tag ==  CERT_STATUS_REVOKED) {
 787                 certStatus = CertStatus.REVOKED;
 788                 revocationTime = derVal.data.getGeneralizedTime();
 789                 if (derVal.data.available() != 0) {
 790                     DerValue dv = derVal.data.getDerValue();
 791                     tag = (byte)(dv.tag &amp; 0x1f);
 792                     if (tag == 0) {
 793                         int reason = dv.data.getEnumerated();
 794                         // if reason out-of-range just leave as UNSPECIFIED
 795                         if (reason &gt;= 0 &amp;&amp; reason &lt; values.length) {
 796                             revocationReason = values[reason];
 797                         } else {
 798                             revocationReason = CRLReason.UNSPECIFIED;
 799                         }
 800                     } else {
 801                         revocationReason = CRLReason.UNSPECIFIED;
 802                     }
 803                 } else {
 804                     revocationReason = CRLReason.UNSPECIFIED;
 805                 }
 806                 // RevokedInfo
 807                 if (debug != null) {
 808                     debug.println(&quot;Revocation time: &quot; + revocationTime);
 809                     debug.println(&quot;Revocation reason: &quot; + revocationReason);
 810                 }
 811             } else {
 812                 revocationTime = null;
 813                 revocationReason = null;
 814                 if (tag == CERT_STATUS_GOOD) {
 815                     certStatus = CertStatus.GOOD;
 816                 } else if (tag == CERT_STATUS_UNKNOWN) {
 817                     certStatus = CertStatus.UNKNOWN;
 818                 } else {
 819                     throw new IOException(&quot;Invalid certificate status&quot;);
 820                 }
 821             }
 822 
 823             thisUpdate = tmp.getGeneralizedTime();
 824             if (debug != null) {
 825                 debug.println(&quot;thisUpdate: &quot; + thisUpdate);
 826             }
 827 
 828             // Parse optional fields like nextUpdate and singleExtensions
 829             Date tmpNextUpdate = null;
 830             Map&lt;String, java.security.cert.Extension&gt; tmpMap = null;
 831 
 832             // Check for the first optional item, it could be nextUpdate
 833             // [CONTEXT 0] or singleExtensions [CONTEXT 1]
 834             if (tmp.available() &gt; 0) {
 835                 derVal = tmp.getDerValue();
 836 
 837                 // nextUpdate processing
 838                 if (derVal.isContextSpecific((byte)0)) {
 839                     tmpNextUpdate = derVal.data.getGeneralizedTime();
 840                     if (debug != null) {
 841                         debug.println(&quot;nextUpdate: &quot; + tmpNextUpdate);
 842                     }
 843 
 844                     // If more data exists in the singleResponse, it
 845                     // can only be singleExtensions.  Get this DER value
 846                     // for processing in the next block
 847                     derVal = tmp.available() &gt; 0 ? tmp.getDerValue() : null;
 848                 }
 849 
 850                 // singleExtensions processing
 851                 if (derVal != null) {
 852                     if (derVal.isContextSpecific((byte)1)) {
 853                         tmpMap = parseExtensions(derVal);
 854 
 855                         // There should not be any other items in the
 856                         // singleResponse at this point.
 857                         if (tmp.available() &gt; 0) {
 858                             throw new IOException(tmp.available() +
 859                                 &quot; bytes of additional data in singleResponse&quot;);
 860                         }
 861                     } else {
 862                         // Unknown item in the singleResponse
 863                         throw new IOException(&quot;Unsupported singleResponse &quot; +
 864                             &quot;item, tag = &quot; + String.format(&quot;%02X&quot;, derVal.tag));
 865                     }
 866                 }
 867             }
 868 
 869             nextUpdate = tmpNextUpdate;
 870             singleExtensions = (tmpMap != null) ? tmpMap :
 871                     Collections.emptyMap();
 872             if (debug != null) {
 873                 for (java.security.cert.Extension ext :
 874                         singleExtensions.values()) {
 875                    debug.println(&quot;singleExtension: &quot; + ext);
 876                 }
 877             }
 878         }
 879 
 880         /*
 881          * Return the certificate&#39;s revocation status code
 882          */
 883         @Override
 884         public CertStatus getCertStatus() {
 885             return certStatus;
 886         }
 887 
 888         /**
 889          * Get the Cert ID that this SingleResponse is for.
 890          *
 891          * @return the {@code CertId} for this {@code SingleResponse}
 892          */
 893         public CertId getCertId() {
 894             return certId;
 895         }
 896 
 897         /**
 898          * Get the {@code thisUpdate} field from this {@code SingleResponse}.
 899          *
 900          * @return a {@link Date} object containing the thisUpdate date
 901          */
 902         public Date getThisUpdate() {
 903             return (thisUpdate != null ? (Date) thisUpdate.clone() : null);
 904         }
 905 
 906         /**
 907          * Get the {@code nextUpdate} field from this {@code SingleResponse}.
 908          *
 909          * @return a {@link Date} object containing the nexUpdate date or
 910          * {@code null} if a nextUpdate field is not present in the response.
 911          */
 912         public Date getNextUpdate() {
 913             return (nextUpdate != null ? (Date) nextUpdate.clone() : null);
 914         }
 915 
 916         /**
 917          * Get the {@code revocationTime} field from this
 918          * {@code SingleResponse}.
 919          *
 920          * @return a {@link Date} object containing the revocationTime date or
 921          * {@code null} if the {@code SingleResponse} does not have a status
 922          * of {@code REVOKED}.
 923          */
 924         @Override
 925         public Date getRevocationTime() {
 926             return (revocationTime != null ? (Date) revocationTime.clone() :
 927                     null);
 928         }
 929 
 930         /**
 931          * Get the {@code revocationReason} field for the
 932          * {@code SingleResponse}.
 933          *
 934          * @return a {@link CRLReason} containing the revocation reason, or
 935          * {@code null} if a revocation reason was not provided or the
 936          * response status is not {@code REVOKED}.
 937          */
 938         @Override
 939         public CRLReason getRevocationReason() {
 940             return revocationReason;
 941         }
 942 
 943         /**
 944          * Get the {@code singleExtensions} for this {@code SingleResponse}.
 945          *
 946          * @return a {@link Map} of {@link Extension} objects, keyed by
 947          * their OID value in string form.
 948          */
 949         @Override
 950         public Map&lt;String, java.security.cert.Extension&gt; getSingleExtensions() {
 951             return Collections.unmodifiableMap(singleExtensions);
 952         }
 953 
 954         /**
 955          * Construct a string representation of a single OCSP response.
 956          */
 957         @Override public String toString() {
 958             StringBuilder sb = new StringBuilder();
 959             sb.append(&quot;SingleResponse:\n&quot;);
 960             sb.append(certId);
 961             sb.append(&quot;\nCertStatus: &quot;).append(certStatus).append(&quot;\n&quot;);
 962             if (certStatus == CertStatus.REVOKED) {
 963                 sb.append(&quot;revocationTime is &quot;);
 964                 sb.append(revocationTime).append(&quot;\n&quot;);
 965                 sb.append(&quot;revocationReason is &quot;);
 966                 sb.append(revocationReason).append(&quot;\n&quot;);
 967             }
 968             sb.append(&quot;thisUpdate is &quot;).append(thisUpdate).append(&quot;\n&quot;);
 969             if (nextUpdate != null) {
 970                 sb.append(&quot;nextUpdate is &quot;).append(nextUpdate).append(&quot;\n&quot;);
 971             }
 972             for (java.security.cert.Extension ext : singleExtensions.values()) {
 973                 sb.append(&quot;singleExtension: &quot;);
 974                 sb.append(ext.toString()).append(&quot;\n&quot;);
 975             }
 976             return sb.toString();
 977         }
 978     }
 979 
 980     /**
 981      * Helper class that allows consumers to pass in issuer information.  This
 982      * will always consist of the issuer&#39;s name and public key, but may also
 983      * contain a certificate if the originating data is in that form.  The
 984      * trust anchor for the certificate chain will be included for certpath
 985      * disabled algorithm checking.
 986      */
 987     static final class IssuerInfo {
 988         private final TrustAnchor anchor;
 989         private final X509Certificate certificate;
 990         private final X500Principal name;
 991         private final PublicKey pubKey;
 992 
 993         IssuerInfo(TrustAnchor anchor) {
 994             this(anchor, (anchor != null) ? anchor.getTrustedCert() : null);
 995         }
 996 
 997         IssuerInfo(X509Certificate issuerCert) {
 998             this(null, issuerCert);
 999         }
1000 
1001         IssuerInfo(TrustAnchor anchor, X509Certificate issuerCert) {
1002             if (anchor == null &amp;&amp; issuerCert == null) {
1003                 throw new NullPointerException(&quot;TrustAnchor and issuerCert &quot; +
1004                         &quot;cannot be null&quot;);
1005             }
1006             this.anchor = anchor;
1007             if (issuerCert != null) {
1008                 name = issuerCert.getSubjectX500Principal();
1009                 pubKey = issuerCert.getPublicKey();
1010                 certificate = issuerCert;
1011             } else {
1012                 name = anchor.getCA();
1013                 pubKey = anchor.getCAPublicKey();
1014                 certificate = anchor.getTrustedCert();
1015             }
1016         }
1017 
1018         /**
1019          * Get the certificate in this IssuerInfo if present.
1020          *
1021          * @return the {@code X509Certificate} used to create this IssuerInfo
1022          * object, or {@code null} if a certificate was not used in its
1023          * creation.
1024          */
1025         X509Certificate getCertificate() {
1026             return certificate;
1027         }
1028 
1029         /**
1030          * Get the name of this issuer.
1031          *
1032          * @return an {@code X500Principal} corresponding to this issuer&#39;s
1033          * name.  If derived from an issuer&#39;s {@code X509Certificate} this
1034          * would be equivalent to the certificate subject name.
1035          */
1036         X500Principal getName() {
1037             return name;
1038         }
1039 
1040         /**
1041          * Get the public key for this issuer.
1042          *
1043          * @return a {@code PublicKey} for this issuer.
1044          */
1045         PublicKey getPublicKey() {
1046             return pubKey;
1047         }
1048 
1049         /**
1050          * Get the TrustAnchor for the certificate chain.
1051          *
1052          * @return a {@code TrustAnchor}.
1053          */
1054         TrustAnchor getAnchor() {
1055             return anchor;
1056         }
1057 
1058         /**
1059          * Create a string representation of this IssuerInfo.
1060          *
1061          * @return a {@code String} form of this IssuerInfo object.
1062          */
1063         @Override
1064         public String toString() {
1065             StringBuilder sb = new StringBuilder();
1066             sb.append(&quot;Issuer Info:\n&quot;);
1067             sb.append(&quot;Name: &quot;).append(name.toString()).append(&quot;\n&quot;);
1068             sb.append(&quot;Public Key:\n&quot;).append(pubKey.toString()).append(&quot;\n&quot;);
1069             return sb.toString();
1070         }
1071     }
1072 }
    </pre>
  </body>
</html>
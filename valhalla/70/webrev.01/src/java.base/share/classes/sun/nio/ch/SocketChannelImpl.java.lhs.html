<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.net.InetAddress;
<a name="1" id="anc1"></a>
  31 import java.net.InetSocketAddress;
  32 import java.net.ProtocolFamily;
  33 import java.net.Socket;
  34 import java.net.SocketAddress;
  35 import java.net.SocketException;
  36 import java.net.SocketOption;
  37 import java.net.SocketTimeoutException;
  38 import java.net.StandardProtocolFamily;
  39 import java.net.StandardSocketOptions;
  40 import java.nio.ByteBuffer;
  41 import java.nio.channels.AlreadyBoundException;
  42 import java.nio.channels.AlreadyConnectedException;
  43 import java.nio.channels.AsynchronousCloseException;
  44 import java.nio.channels.ClosedChannelException;
  45 import java.nio.channels.ConnectionPendingException;
  46 import java.nio.channels.IllegalBlockingModeException;
  47 import java.nio.channels.NoConnectionPendingException;
  48 import java.nio.channels.NotYetConnectedException;
  49 import java.nio.channels.SelectionKey;
  50 import java.nio.channels.SocketChannel;
  51 import java.nio.channels.spi.SelectorProvider;
  52 import java.util.Collections;
  53 import java.util.HashSet;
  54 import java.util.Objects;
  55 import java.util.Set;
  56 import java.util.concurrent.locks.ReentrantLock;
  57 
  58 import sun.net.ConnectionResetException;
  59 import sun.net.NetHooks;
  60 import sun.net.ext.ExtendedSocketOptions;
  61 import sun.net.util.SocketExceptions;
  62 
  63 /**
  64  * An implementation of SocketChannels
  65  */
  66 
  67 class SocketChannelImpl
  68     extends SocketChannel
  69     implements SelChImpl
  70 {
  71     // Used to make native read and write calls
  72     private static final NativeDispatcher nd = new SocketDispatcher();
  73 
<a name="2" id="anc2"></a>


  74     // Our file descriptor object
  75     private final FileDescriptor fd;
  76     private final int fdVal;
  77 
  78     // Lock held by current reading or connecting thread
  79     private final ReentrantLock readLock = new ReentrantLock();
  80 
  81     // Lock held by current writing or connecting thread
  82     private final ReentrantLock writeLock = new ReentrantLock();
  83 
  84     // Lock held by any thread that modifies the state fields declared below
  85     // DO NOT invoke a blocking I/O operation while holding this lock!
  86     private final Object stateLock = new Object();
  87 
  88     // Input/Output closed
  89     private volatile boolean isInputClosed;
  90     private volatile boolean isOutputClosed;
  91 
  92     // Connection reset protected by readLock
  93     private boolean connectionReset;
  94 
  95     // -- The following fields are protected by stateLock
  96 
  97     // set true when exclusive binding is on and SO_REUSEADDR is emulated
  98     private boolean isReuseAddress;
  99 
 100     // State, increases monotonically
 101     private static final int ST_UNCONNECTED = 0;
 102     private static final int ST_CONNECTIONPENDING = 1;
 103     private static final int ST_CONNECTED = 2;
 104     private static final int ST_CLOSING = 3;
 105     private static final int ST_CLOSED = 4;
 106     private volatile int state;  // need stateLock to change
 107 
 108     // IDs of native threads doing reads and writes, for signalling
 109     private long readerThread;
 110     private long writerThread;
 111 
 112     // Binding
 113     private InetSocketAddress localAddress;
 114     private InetSocketAddress remoteAddress;
 115 
 116     // Socket adaptor, created on demand
 117     private Socket socket;
 118 
 119     // -- End of fields protected by stateLock
 120 
<a name="3" id="anc3"></a><span class="line-removed"> 121 </span>
 122     // Constructor for normal connecting sockets
 123     //
 124     SocketChannelImpl(SelectorProvider sp) throws IOException {
<a name="4" id="anc4"></a>





 125         super(sp);
<a name="5" id="anc5"></a><span class="line-modified"> 126         this.fd = Net.socket(true);</span>









 127         this.fdVal = IOUtil.fdVal(fd);
 128     }
 129 
 130     SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
 131         throws IOException
 132     {
 133         super(sp);
<a name="6" id="anc6"></a>


 134         this.fd = fd;
 135         this.fdVal = IOUtil.fdVal(fd);
<a name="7" id="anc7"></a>
 136         if (bound) {
 137             synchronized (stateLock) {
 138                 this.localAddress = Net.localAddress(fd);
 139             }
 140         }
 141     }
 142 
 143     // Constructor for sockets obtained from server sockets
 144     //
<a name="8" id="anc8"></a><span class="line-modified"> 145     SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, InetSocketAddress isa)</span>



 146         throws IOException
 147     {
 148         super(sp);
<a name="9" id="anc9"></a>
 149         this.fd = fd;
 150         this.fdVal = IOUtil.fdVal(fd);
 151         synchronized (stateLock) {
 152             this.localAddress = Net.localAddress(fd);
 153             this.remoteAddress = isa;
 154             this.state = ST_CONNECTED;
 155         }
 156     }
 157 
 158     /**
 159      * Checks that the channel is open.
 160      *
 161      * @throws ClosedChannelException if channel is closed (or closing)
 162      */
 163     private void ensureOpen() throws ClosedChannelException {
 164         if (!isOpen())
 165             throw new ClosedChannelException();
 166     }
 167 
 168     /**
 169      * Checks that the channel is open and connected.
 170      *
 171      * @apiNote This method uses the &quot;state&quot; field to check if the channel is
 172      * open. It should never be used in conjuncion with isOpen or ensureOpen
 173      * as these methods check AbstractInterruptibleChannel&#39;s closed field - that
 174      * field is set before implCloseSelectableChannel is called and so before
 175      * the state is changed.
 176      *
 177      * @throws ClosedChannelException if channel is closed (or closing)
 178      * @throws NotYetConnectedException if open and not connected
 179      */
 180     private void ensureOpenAndConnected() throws ClosedChannelException {
 181         int state = this.state;
 182         if (state &lt; ST_CONNECTED) {
 183             throw new NotYetConnectedException();
 184         } else if (state &gt; ST_CONNECTED) {
 185             throw new ClosedChannelException();
 186         }
 187     }
 188 
 189     @Override
 190     public Socket socket() {
 191         synchronized (stateLock) {
 192             if (socket == null)
 193                 socket = SocketAdaptor.create(this);
 194             return socket;
 195         }
 196     }
 197 
 198     @Override
 199     public SocketAddress getLocalAddress() throws IOException {
 200         synchronized (stateLock) {
 201             ensureOpen();
 202             return Net.getRevealedLocalAddress(localAddress);
 203         }
 204     }
 205 
 206     @Override
 207     public SocketAddress getRemoteAddress() throws IOException {
 208         synchronized (stateLock) {
 209             ensureOpen();
 210             return remoteAddress;
 211         }
 212     }
 213 
 214     @Override
 215     public &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value)
 216         throws IOException
 217     {
 218         Objects.requireNonNull(name);
 219         if (!supportedOptions().contains(name))
 220             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 221         if (!name.type().isInstance(value))
 222             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);
 223 
 224         synchronized (stateLock) {
 225             ensureOpen();
 226 
 227             if (name == StandardSocketOptions.IP_TOS) {
<a name="10" id="anc10"></a><span class="line-removed"> 228                 ProtocolFamily family = Net.isIPv6Available() ?</span>
<span class="line-removed"> 229                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;</span>
 230                 Net.setSocketOption(fd, family, name, value);
 231                 return this;
 232             }
 233 
 234             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 235                 // SO_REUSEADDR emulated when using exclusive bind
 236                 isReuseAddress = (Boolean)value;
 237                 return this;
 238             }
 239 
 240             // no options that require special handling
 241             Net.setSocketOption(fd, name, value);
 242             return this;
 243         }
 244     }
 245 
 246     @Override
 247     @SuppressWarnings(&quot;unchecked&quot;)
 248     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 249         throws IOException
 250     {
 251         Objects.requireNonNull(name);
 252         if (!supportedOptions().contains(name))
 253             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 254 
 255         synchronized (stateLock) {
 256             ensureOpen();
 257 
 258             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 259                 // SO_REUSEADDR emulated when using exclusive bind
 260                 return (T)Boolean.valueOf(isReuseAddress);
 261             }
 262 
<a name="11" id="anc11"></a><span class="line-modified"> 263             // special handling for IP_TOS: always return 0 when IPv6</span>
 264             if (name == StandardSocketOptions.IP_TOS) {
<a name="12" id="anc12"></a><span class="line-removed"> 265                 ProtocolFamily family = Net.isIPv6Available() ?</span>
<span class="line-removed"> 266                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;</span>
 267                 return (T) Net.getSocketOption(fd, family, name);
 268             }
 269 
 270             // no options that require special handling
 271             return (T) Net.getSocketOption(fd, name);
 272         }
 273     }
 274 
 275     private static class DefaultOptionsHolder {
 276         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 277 
 278         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 279             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 280             set.add(StandardSocketOptions.SO_SNDBUF);
 281             set.add(StandardSocketOptions.SO_RCVBUF);
 282             set.add(StandardSocketOptions.SO_KEEPALIVE);
 283             set.add(StandardSocketOptions.SO_REUSEADDR);
 284             if (Net.isReusePortAvailable()) {
 285                 set.add(StandardSocketOptions.SO_REUSEPORT);
 286             }
 287             set.add(StandardSocketOptions.SO_LINGER);
 288             set.add(StandardSocketOptions.TCP_NODELAY);
 289             // additional options required by socket adaptor
 290             set.add(StandardSocketOptions.IP_TOS);
 291             set.add(ExtendedSocketOption.SO_OOBINLINE);
 292             set.addAll(ExtendedSocketOptions.clientSocketOptions());
 293             return Collections.unmodifiableSet(set);
 294         }
 295     }
 296 
 297     @Override
 298     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 299         return DefaultOptionsHolder.defaultOptions;
 300     }
 301 
 302     /**
 303      * Marks the beginning of a read operation that might block.
 304      *
 305      * @throws ClosedChannelException if the channel is closed
 306      * @throws NotYetConnectedException if the channel is not yet connected
 307      */
 308     private void beginRead(boolean blocking) throws ClosedChannelException {
 309         if (blocking) {
 310             // set hook for Thread.interrupt
 311             begin();
 312 
 313             synchronized (stateLock) {
 314                 ensureOpenAndConnected();
 315                 // record thread so it can be signalled if needed
 316                 readerThread = NativeThread.current();
 317             }
 318         } else {
 319             ensureOpenAndConnected();
 320         }
 321     }
 322 
 323     /**
 324      * Marks the end of a read operation that may have blocked.
 325      *
 326      * @throws AsynchronousCloseException if the channel was closed due to this
 327      * thread being interrupted on a blocking read operation.
 328      */
 329     private void endRead(boolean blocking, boolean completed)
 330         throws AsynchronousCloseException
 331     {
 332         if (blocking) {
 333             synchronized (stateLock) {
 334                 readerThread = 0;
 335                 if (state == ST_CLOSING) {
 336                     tryFinishClose();
 337                 }
 338             }
 339             // remove hook for Thread.interrupt
 340             end(completed);
 341         }
 342     }
 343 
 344     private void throwConnectionReset() throws SocketException {
 345         throw new SocketException(&quot;Connection reset&quot;);
 346     }
 347 
 348     @Override
 349     public int read(ByteBuffer buf) throws IOException {
 350         Objects.requireNonNull(buf);
 351 
 352         readLock.lock();
 353         try {
 354             boolean blocking = isBlocking();
 355             int n = 0;
 356             try {
 357                 beginRead(blocking);
 358 
 359                 // check if connection has been reset
 360                 if (connectionReset)
 361                     throwConnectionReset();
 362 
 363                 // check if input is shutdown
 364                 if (isInputClosed)
 365                     return IOStatus.EOF;
 366 
 367                 n = IOUtil.read(fd, buf, -1, nd);
 368                 if (blocking) {
 369                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 370                         park(Net.POLLIN);
 371                         n = IOUtil.read(fd, buf, -1, nd);
 372                     }
 373                 }
 374             } catch (ConnectionResetException e) {
 375                 connectionReset = true;
 376                 throwConnectionReset();
 377             } finally {
 378                 endRead(blocking, n &gt; 0);
 379                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 380                     return IOStatus.EOF;
 381             }
 382             return IOStatus.normalize(n);
 383         } finally {
 384             readLock.unlock();
 385         }
 386     }
 387 
 388     @Override
 389     public long read(ByteBuffer[] dsts, int offset, int length)
 390         throws IOException
 391     {
 392         Objects.checkFromIndexSize(offset, length, dsts.length);
 393 
 394         readLock.lock();
 395         try {
 396             boolean blocking = isBlocking();
 397             long n = 0;
 398             try {
 399                 beginRead(blocking);
 400 
 401                 // check if connection has been reset
 402                 if (connectionReset)
 403                     throwConnectionReset();
 404 
 405                 // check if input is shutdown
 406                 if (isInputClosed)
 407                     return IOStatus.EOF;
 408 
 409                 n = IOUtil.read(fd, dsts, offset, length, nd);
 410                 if (blocking) {
 411                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 412                         park(Net.POLLIN);
 413                         n = IOUtil.read(fd, dsts, offset, length, nd);
 414                     }
 415                 }
 416             } catch (ConnectionResetException e) {
 417                 connectionReset = true;
 418                 throwConnectionReset();
 419             } finally {
 420                 endRead(blocking, n &gt; 0);
 421                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 422                     return IOStatus.EOF;
 423             }
 424             return IOStatus.normalize(n);
 425         } finally {
 426             readLock.unlock();
 427         }
 428     }
 429 
 430     /**
 431      * Marks the beginning of a write operation that might block.
 432      *
 433      * @throws ClosedChannelException if the channel is closed or output shutdown
 434      * @throws NotYetConnectedException if the channel is not yet connected
 435      */
 436     private void beginWrite(boolean blocking) throws ClosedChannelException {
 437         if (blocking) {
 438             // set hook for Thread.interrupt
 439             begin();
 440 
 441             synchronized (stateLock) {
 442                 ensureOpenAndConnected();
 443                 if (isOutputClosed)
 444                     throw new ClosedChannelException();
 445                 // record thread so it can be signalled if needed
 446                 writerThread = NativeThread.current();
 447             }
 448         } else {
 449             ensureOpenAndConnected();
 450         }
 451     }
 452 
 453     /**
 454      * Marks the end of a write operation that may have blocked.
 455      *
 456      * @throws AsynchronousCloseException if the channel was closed due to this
 457      * thread being interrupted on a blocking write operation.
 458      */
 459     private void endWrite(boolean blocking, boolean completed)
 460         throws AsynchronousCloseException
 461     {
 462         if (blocking) {
 463             synchronized (stateLock) {
 464                 writerThread = 0;
 465                 if (state == ST_CLOSING) {
 466                     tryFinishClose();
 467                 }
 468             }
 469             // remove hook for Thread.interrupt
 470             end(completed);
 471         }
 472     }
 473 
 474     @Override
 475     public int write(ByteBuffer buf) throws IOException {
 476         Objects.requireNonNull(buf);
 477 
 478         writeLock.lock();
 479         try {
 480             boolean blocking = isBlocking();
 481             int n = 0;
 482             try {
 483                 beginWrite(blocking);
 484                 n = IOUtil.write(fd, buf, -1, nd);
 485                 if (blocking) {
 486                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 487                         park(Net.POLLOUT);
 488                         n = IOUtil.write(fd, buf, -1, nd);
 489                     }
 490                 }
 491             } finally {
 492                 endWrite(blocking, n &gt; 0);
 493                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 494                     throw new AsynchronousCloseException();
 495             }
 496             return IOStatus.normalize(n);
 497         } finally {
 498             writeLock.unlock();
 499         }
 500     }
 501 
 502     @Override
 503     public long write(ByteBuffer[] srcs, int offset, int length)
 504         throws IOException
 505     {
 506         Objects.checkFromIndexSize(offset, length, srcs.length);
 507 
 508         writeLock.lock();
 509         try {
 510             boolean blocking = isBlocking();
 511             long n = 0;
 512             try {
 513                 beginWrite(blocking);
 514                 n = IOUtil.write(fd, srcs, offset, length, nd);
 515                 if (blocking) {
 516                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 517                         park(Net.POLLOUT);
 518                         n = IOUtil.write(fd, srcs, offset, length, nd);
 519                     }
 520                 }
 521             } finally {
 522                 endWrite(blocking, n &gt; 0);
 523                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 524                     throw new AsynchronousCloseException();
 525             }
 526             return IOStatus.normalize(n);
 527         } finally {
 528             writeLock.unlock();
 529         }
 530     }
 531 
 532     /**
 533      * Writes a byte of out of band data.
 534      */
 535     int sendOutOfBandData(byte b) throws IOException {
 536         writeLock.lock();
 537         try {
 538             boolean blocking = isBlocking();
 539             int n = 0;
 540             try {
 541                 beginWrite(blocking);
 542                 if (blocking) {
 543                     do {
 544                         n = Net.sendOOB(fd, b);
 545                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());
 546                 } else {
 547                     n = Net.sendOOB(fd, b);
 548                 }
 549             } finally {
 550                 endWrite(blocking, n &gt; 0);
 551                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 552                     throw new AsynchronousCloseException();
 553             }
 554             return IOStatus.normalize(n);
 555         } finally {
 556             writeLock.unlock();
 557         }
 558     }
 559 
 560     @Override
 561     protected void implConfigureBlocking(boolean block) throws IOException {
 562         readLock.lock();
 563         try {
 564             writeLock.lock();
 565             try {
 566                 lockedConfigureBlocking(block);
 567             } finally {
 568                 writeLock.unlock();
 569             }
 570         } finally {
 571             readLock.unlock();
 572         }
 573     }
 574 
 575     /**
 576      * Adjusts the blocking mode. readLock or writeLock must already be held.
 577      */
 578     private void lockedConfigureBlocking(boolean block) throws IOException {
 579         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();
 580         synchronized (stateLock) {
 581             ensureOpen();
 582             IOUtil.configureBlocking(fd, block);
 583         }
 584     }
 585 
 586     /**
 587      * Adjusts the blocking mode if the channel is open. readLock or writeLock
 588      * must already be held.
 589      *
 590      * @return {@code true} if the blocking mode was adjusted, {@code false} if
 591      *         the blocking mode was not adjusted because the channel is closed
 592      */
 593     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {
 594         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();
 595         synchronized (stateLock) {
 596             if (isOpen()) {
 597                 IOUtil.configureBlocking(fd, block);
 598                 return true;
 599             } else {
 600                 return false;
 601             }
 602         }
 603     }
 604 
 605     /**
 606      * Returns the local address, or null if not bound
 607      */
 608     InetSocketAddress localAddress() {
 609         synchronized (stateLock) {
 610             return localAddress;
 611         }
 612     }
 613 
 614     /**
 615      * Returns the remote address, or null if not connected
 616      */
 617     InetSocketAddress remoteAddress() {
 618         synchronized (stateLock) {
 619             return remoteAddress;
 620         }
 621     }
 622 
 623     @Override
 624     public SocketChannel bind(SocketAddress local) throws IOException {
 625         readLock.lock();
 626         try {
 627             writeLock.lock();
 628             try {
 629                 synchronized (stateLock) {
 630                     ensureOpen();
 631                     if (state == ST_CONNECTIONPENDING)
 632                         throw new ConnectionPendingException();
 633                     if (localAddress != null)
 634                         throw new AlreadyBoundException();
<a name="13" id="anc13"></a><span class="line-modified"> 635                     InetSocketAddress isa = (local == null) ?</span>
<span class="line-modified"> 636                         new InetSocketAddress(0) : Net.checkAddress(local);</span>




 637                     SecurityManager sm = System.getSecurityManager();
 638                     if (sm != null) {
 639                         sm.checkListen(isa.getPort());
 640                     }
 641                     NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
<a name="14" id="anc14"></a><span class="line-modified"> 642                     Net.bind(fd, isa.getAddress(), isa.getPort());</span>
 643                     localAddress = Net.localAddress(fd);
 644                 }
 645             } finally {
 646                 writeLock.unlock();
 647             }
 648         } finally {
 649             readLock.unlock();
 650         }
 651         return this;
 652     }
 653 
 654     @Override
 655     public boolean isConnected() {
 656         return (state == ST_CONNECTED);
 657     }
 658 
 659     @Override
 660     public boolean isConnectionPending() {
 661         return (state == ST_CONNECTIONPENDING);
 662     }
 663 
 664     /**
 665      * Marks the beginning of a connect operation that might block.
 666      * @param blocking true if configured blocking
 667      * @param isa the remote address
 668      * @throws ClosedChannelException if the channel is closed
 669      * @throws AlreadyConnectedException if already connected
 670      * @throws ConnectionPendingException is a connection is pending
 671      * @throws IOException if the pre-connect hook fails
 672      */
 673     private void beginConnect(boolean blocking, InetSocketAddress isa)
 674         throws IOException
 675     {
 676         if (blocking) {
 677             // set hook for Thread.interrupt
 678             begin();
 679         }
 680         synchronized (stateLock) {
 681             ensureOpen();
 682             int state = this.state;
 683             if (state == ST_CONNECTED)
 684                 throw new AlreadyConnectedException();
 685             if (state == ST_CONNECTIONPENDING)
 686                 throw new ConnectionPendingException();
 687             assert state == ST_UNCONNECTED;
 688             this.state = ST_CONNECTIONPENDING;
 689 
 690             if (localAddress == null)
 691                 NetHooks.beforeTcpConnect(fd, isa.getAddress(), isa.getPort());
 692             remoteAddress = isa;
 693 
 694             if (blocking) {
 695                 // record thread so it can be signalled if needed
 696                 readerThread = NativeThread.current();
 697             }
 698         }
 699     }
 700 
 701     /**
 702      * Marks the end of a connect operation that may have blocked.
 703      *
 704      * @throws AsynchronousCloseException if the channel was closed due to this
 705      * thread being interrupted on a blocking connect operation.
 706      * @throws IOException if completed and unable to obtain the local address
 707      */
 708     private void endConnect(boolean blocking, boolean completed)
 709         throws IOException
 710     {
 711         endRead(blocking, completed);
 712 
 713         if (completed) {
 714             synchronized (stateLock) {
 715                 if (state == ST_CONNECTIONPENDING) {
 716                     localAddress = Net.localAddress(fd);
 717                     state = ST_CONNECTED;
 718                 }
 719             }
 720         }
 721     }
 722 
 723     /**
 724      * Checks the remote address to which this channel is to be connected.
 725      */
<a name="15" id="anc15"></a><span class="line-modified"> 726     private InetSocketAddress checkRemote(SocketAddress sa) throws IOException {</span>
<span class="line-modified"> 727         InetSocketAddress isa = Net.checkAddress(sa);</span>
 728         SecurityManager sm = System.getSecurityManager();
 729         if (sm != null) {
 730             sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());
 731         }
<a name="16" id="anc16"></a><span class="line-modified"> 732         if (isa.getAddress().isAnyLocalAddress()) {</span>
<span class="line-modified"> 733             return new InetSocketAddress(InetAddress.getLocalHost(), isa.getPort());</span>







 734         } else {
 735             return isa;
 736         }
 737     }
 738 
 739     @Override
 740     public boolean connect(SocketAddress remote) throws IOException {
 741         InetSocketAddress isa = checkRemote(remote);
 742         try {
 743             readLock.lock();
 744             try {
 745                 writeLock.lock();
 746                 try {
 747                     boolean blocking = isBlocking();
 748                     boolean connected = false;
 749                     try {
 750                         beginConnect(blocking, isa);
<a name="17" id="anc17"></a><span class="line-modified"> 751                         int n = Net.connect(fd, isa.getAddress(), isa.getPort());</span>



 752                         if (n &gt; 0) {
 753                             connected = true;
 754                         } else if (blocking) {
 755                             assert IOStatus.okayToRetry(n);
 756                             boolean polled = false;
 757                             while (!polled &amp;&amp; isOpen()) {
 758                                 park(Net.POLLOUT);
 759                                 polled = Net.pollConnectNow(fd);
 760                             }
 761                             connected = polled &amp;&amp; isOpen();
 762                         }
 763                     } finally {
 764                         endConnect(blocking, connected);
 765                     }
 766                     return connected;
 767                 } finally {
 768                     writeLock.unlock();
 769                 }
 770             } finally {
 771                 readLock.unlock();
 772             }
 773         } catch (IOException ioe) {
 774             // connect failed, close the channel
 775             close();
 776             throw SocketExceptions.of(ioe, isa);
 777         }
 778     }
 779 
 780     /**
 781      * Marks the beginning of a finishConnect operation that might block.
 782      *
 783      * @throws ClosedChannelException if the channel is closed
 784      * @throws NoConnectionPendingException if no connection is pending
 785      */
 786     private void beginFinishConnect(boolean blocking) throws ClosedChannelException {
 787         if (blocking) {
 788             // set hook for Thread.interrupt
 789             begin();
 790         }
 791         synchronized (stateLock) {
 792             ensureOpen();
 793             if (state != ST_CONNECTIONPENDING)
 794                 throw new NoConnectionPendingException();
 795             if (blocking) {
 796                 // record thread so it can be signalled if needed
 797                 readerThread = NativeThread.current();
 798             }
 799         }
 800     }
 801 
 802     /**
 803      * Marks the end of a finishConnect operation that may have blocked.
 804      *
 805      * @throws AsynchronousCloseException if the channel was closed due to this
 806      * thread being interrupted on a blocking connect operation.
 807      * @throws IOException if completed and unable to obtain the local address
 808      */
 809     private void endFinishConnect(boolean blocking, boolean completed)
 810         throws IOException
 811     {
 812         endRead(blocking, completed);
 813 
 814         if (completed) {
 815             synchronized (stateLock) {
 816                 if (state == ST_CONNECTIONPENDING) {
 817                     localAddress = Net.localAddress(fd);
 818                     state = ST_CONNECTED;
 819                 }
 820             }
 821         }
 822     }
 823 
 824     @Override
 825     public boolean finishConnect() throws IOException {
 826         try {
 827             readLock.lock();
 828             try {
 829                 writeLock.lock();
 830                 try {
 831                     // no-op if already connected
 832                     if (isConnected())
 833                         return true;
 834 
 835                     boolean blocking = isBlocking();
 836                     boolean connected = false;
 837                     try {
 838                         beginFinishConnect(blocking);
 839                         boolean polled = Net.pollConnectNow(fd);
 840                         if (blocking) {
 841                             while (!polled &amp;&amp; isOpen()) {
 842                                 park(Net.POLLOUT);
 843                                 polled = Net.pollConnectNow(fd);
 844                             }
 845                         }
 846                         connected = polled &amp;&amp; isOpen();
 847                     } finally {
 848                         endFinishConnect(blocking, connected);
 849                     }
 850                     assert (blocking &amp;&amp; connected) ^ !blocking;
 851                     return connected;
 852                 } finally {
 853                     writeLock.unlock();
 854                 }
 855             } finally {
 856                 readLock.unlock();
 857             }
 858         } catch (IOException ioe) {
 859             // connect failed, close the channel
 860             close();
 861             throw SocketExceptions.of(ioe, remoteAddress);
 862         }
 863     }
 864 
 865     /**
 866      * Closes the socket if there are no I/O operations in progress and the
 867      * channel is not registered with a Selector.
 868      */
 869     private boolean tryClose() throws IOException {
 870         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;
 871         if ((readerThread == 0) &amp;&amp; (writerThread == 0) &amp;&amp; !isRegistered()) {
 872             state = ST_CLOSED;
 873             nd.close(fd);
 874             return true;
 875         } else {
 876             return false;
 877         }
 878     }
 879 
 880     /**
 881      * Invokes tryClose to attempt to close the socket.
 882      *
 883      * This method is used for deferred closing by I/O and Selector operations.
 884      */
 885     private void tryFinishClose() {
 886         try {
 887             tryClose();
 888         } catch (IOException ignore) { }
 889     }
 890 
 891     /**
 892      * Closes this channel when configured in blocking mode.
 893      *
 894      * If there is an I/O operation in progress then the socket is pre-closed
 895      * and the I/O threads signalled, in which case the final close is deferred
 896      * until all I/O operations complete.
 897      *
 898      * Note that a channel configured blocking may be registered with a Selector
 899      * This arises when a key is canceled and the channel configured to blocking
 900      * mode before the key is flushed from the Selector.
 901      */
 902     private void implCloseBlockingMode() throws IOException {
 903         synchronized (stateLock) {
 904             assert state &lt; ST_CLOSING;
 905             state = ST_CLOSING;
 906             if (!tryClose()) {
 907                 long reader = readerThread;
 908                 long writer = writerThread;
 909                 if (reader != 0 || writer != 0) {
 910                     nd.preClose(fd);
 911                     if (reader != 0)
 912                         NativeThread.signal(reader);
 913                     if (writer != 0)
 914                         NativeThread.signal(writer);
 915                 }
 916             }
 917         }
 918     }
 919 
 920     /**
 921      * Closes this channel when configured in non-blocking mode.
 922      *
 923      * If the channel is registered with a Selector then the close is deferred
 924      * until the channel is flushed from all Selectors.
 925      *
 926      * If the socket is connected and the channel is registered with a Selector
 927      * then the socket is shutdown for writing so that the peer reads EOF. In
 928      * addition, if SO_LINGER is set to a non-zero value then it is disabled so
 929      * that the deferred close does not wait.
 930      */
 931     private void implCloseNonBlockingMode() throws IOException {
 932         boolean connected;
 933         synchronized (stateLock) {
 934             assert state &lt; ST_CLOSING;
 935             connected = (state == ST_CONNECTED);
 936             state = ST_CLOSING;
 937         }
 938 
 939         // wait for any read/write operations to complete
 940         readLock.lock();
 941         readLock.unlock();
 942         writeLock.lock();
 943         writeLock.unlock();
 944 
 945         // if the socket cannot be closed because it&#39;s registered with a Selector
 946         // then shutdown the socket for writing.
 947         synchronized (stateLock) {
 948             if (state == ST_CLOSING &amp;&amp; !tryClose() &amp;&amp; connected &amp;&amp; isRegistered()) {
 949                 try {
 950                     SocketOption&lt;Integer&gt; opt = StandardSocketOptions.SO_LINGER;
 951                     int interval = (int) Net.getSocketOption(fd, Net.UNSPEC, opt);
 952                     if (interval != 0) {
 953                         if (interval &gt; 0) {
 954                             // disable SO_LINGER
 955                             Net.setSocketOption(fd, Net.UNSPEC, opt, -1);
 956                         }
 957                         Net.shutdown(fd, Net.SHUT_WR);
 958                     }
 959                 } catch (IOException ignore) { }
 960             }
 961         }
 962     }
 963 
 964     /**
 965      * Invoked by implCloseChannel to close the channel.
 966      */
 967     @Override
 968     protected void implCloseSelectableChannel() throws IOException {
 969         assert !isOpen();
 970         if (isBlocking()) {
 971             implCloseBlockingMode();
 972         } else {
 973             implCloseNonBlockingMode();
 974         }
 975     }
 976 
 977     @Override
 978     public void kill() {
 979         synchronized (stateLock) {
 980             if (state == ST_CLOSING) {
 981                 tryFinishClose();
 982             }
 983         }
 984     }
 985 
 986     @Override
 987     public SocketChannel shutdownInput() throws IOException {
 988         synchronized (stateLock) {
 989             ensureOpen();
 990             if (!isConnected())
 991                 throw new NotYetConnectedException();
 992             if (!isInputClosed) {
 993                 Net.shutdown(fd, Net.SHUT_RD);
 994                 long thread = readerThread;
 995                 if (thread != 0)
 996                     NativeThread.signal(thread);
 997                 isInputClosed = true;
 998             }
 999             return this;
1000         }
1001     }
1002 
1003     @Override
1004     public SocketChannel shutdownOutput() throws IOException {
1005         synchronized (stateLock) {
1006             ensureOpen();
1007             if (!isConnected())
1008                 throw new NotYetConnectedException();
1009             if (!isOutputClosed) {
1010                 Net.shutdown(fd, Net.SHUT_WR);
1011                 long thread = writerThread;
1012                 if (thread != 0)
1013                     NativeThread.signal(thread);
1014                 isOutputClosed = true;
1015             }
1016             return this;
1017         }
1018     }
1019 
1020     boolean isInputOpen() {
1021         return !isInputClosed;
1022     }
1023 
1024     boolean isOutputOpen() {
1025         return !isOutputClosed;
1026     }
1027 
1028     /**
1029      * Waits for a connection attempt to finish with a timeout
1030      * @throws SocketTimeoutException if the connect timeout elapses
1031      */
1032     private boolean finishTimedConnect(long nanos) throws IOException {
1033         long startNanos = System.nanoTime();
1034         boolean polled = Net.pollConnectNow(fd);
1035         while (!polled &amp;&amp; isOpen()) {
1036             long remainingNanos = nanos - (System.nanoTime() - startNanos);
1037             if (remainingNanos &lt;= 0) {
1038                 throw new SocketTimeoutException(&quot;Connect timed out&quot;);
1039             }
1040             park(Net.POLLOUT, remainingNanos);
1041             polled = Net.pollConnectNow(fd);
1042         }
1043         return polled &amp;&amp; isOpen();
1044     }
1045 
1046     /**
1047      * Attempts to establish a connection to the given socket address with a
1048      * timeout. Closes the socket if connection cannot be established.
1049      *
1050      * @apiNote This method is for use by the socket adaptor.
1051      *
1052      * @throws IllegalBlockingModeException if the channel is non-blocking
1053      * @throws SocketTimeoutException if the read timeout elapses
1054      */
1055     void blockingConnect(SocketAddress remote, long nanos) throws IOException {
1056         InetSocketAddress isa = checkRemote(remote);
1057         try {
1058             readLock.lock();
1059             try {
1060                 writeLock.lock();
1061                 try {
1062                     if (!isBlocking())
1063                         throw new IllegalBlockingModeException();
1064                     boolean connected = false;
1065                     try {
1066                         beginConnect(true, isa);
1067                         // change socket to non-blocking
1068                         lockedConfigureBlocking(false);
1069                         try {
1070                             int n = Net.connect(fd, isa.getAddress(), isa.getPort());
1071                             connected = (n &gt; 0) ? true : finishTimedConnect(nanos);
1072                         } finally {
1073                             // restore socket to blocking mode (if channel is open)
1074                             tryLockedConfigureBlocking(true);
1075                         }
1076                     } finally {
1077                         endConnect(true, connected);
1078                     }
1079                 } finally {
1080                     writeLock.unlock();
1081                 }
1082             } finally {
1083                 readLock.unlock();
1084             }
1085         } catch (IOException ioe) {
1086             // connect failed, close the channel
1087             close();
1088             throw SocketExceptions.of(ioe, isa);
1089         }
1090     }
1091 
1092     /**
1093      * Attempts to read bytes from the socket into the given byte array.
1094      */
1095     private int tryRead(byte[] b, int off, int len) throws IOException {
1096         ByteBuffer dst = Util.getTemporaryDirectBuffer(len);
1097         assert dst.position() == 0;
1098         try {
1099             int n = nd.read(fd, ((DirectBuffer)dst).address(), len);
1100             if (n &gt; 0) {
1101                 dst.get(b, off, n);
1102             }
1103             return n;
1104         } finally{
1105             Util.offerFirstTemporaryDirectBuffer(dst);
1106         }
1107     }
1108 
1109     /**
1110      * Reads bytes from the socket into the given byte array with a timeout.
1111      * @throws SocketTimeoutException if the read timeout elapses
1112      */
1113     private int timedRead(byte[] b, int off, int len, long nanos) throws IOException {
1114         long startNanos = System.nanoTime();
1115         int n = tryRead(b, off, len);
1116         while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {
1117             long remainingNanos = nanos - (System.nanoTime() - startNanos);
1118             if (remainingNanos &lt;= 0) {
1119                 throw new SocketTimeoutException(&quot;Read timed out&quot;);
1120             }
1121             park(Net.POLLIN, remainingNanos);
1122             n = tryRead(b, off, len);
1123         }
1124         return n;
1125     }
1126 
1127     /**
1128      * Reads bytes from the socket into the given byte array.
1129      *
1130      * @apiNote This method is for use by the socket adaptor.
1131      *
1132      * @throws IllegalBlockingModeException if the channel is non-blocking
1133      * @throws SocketTimeoutException if the read timeout elapses
1134      */
1135     int blockingRead(byte[] b, int off, int len, long nanos) throws IOException {
1136         Objects.checkFromIndexSize(off, len, b.length);
1137         if (len == 0) {
1138             // nothing to do
1139             return 0;
1140         }
1141 
1142         readLock.lock();
1143         try {
1144             // check that channel is configured blocking
1145             if (!isBlocking())
1146                 throw new IllegalBlockingModeException();
1147 
1148             int n = 0;
1149             try {
1150                 beginRead(true);
1151 
1152                 // check if connection has been reset
1153                 if (connectionReset)
1154                     throwConnectionReset();
1155 
1156                 // check if input is shutdown
1157                 if (isInputClosed)
1158                     return IOStatus.EOF;
1159 
1160                 if (nanos &gt; 0) {
1161                     // change socket to non-blocking
1162                     lockedConfigureBlocking(false);
1163                     try {
1164                         n = timedRead(b, off, len, nanos);
1165                     } finally {
1166                         // restore socket to blocking mode (if channel is open)
1167                         tryLockedConfigureBlocking(true);
1168                     }
1169                 } else {
1170                     // read, no timeout
1171                     n = tryRead(b, off, len);
1172                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
1173                         park(Net.POLLIN);
1174                         n = tryRead(b, off, len);
1175                     }
1176                 }
1177             } catch (ConnectionResetException e) {
1178                 connectionReset = true;
1179                 throwConnectionReset();
1180             } finally {
1181                 endRead(true, n &gt; 0);
1182                 if (n &lt;= 0 &amp;&amp; isInputClosed)
1183                     return IOStatus.EOF;
1184             }
1185             assert n &gt; 0 || n == -1;
1186             return n;
1187         } finally {
1188             readLock.unlock();
1189         }
1190     }
1191 
1192     /**
1193      * Attempts to write a sequence of bytes to the socket from the given
1194      * byte array.
1195      */
1196     private int tryWrite(byte[] b, int off, int len) throws IOException {
1197         ByteBuffer src = Util.getTemporaryDirectBuffer(len);
1198         assert src.position() == 0;
1199         try {
1200             src.put(b, off, len);
1201             return nd.write(fd, ((DirectBuffer)src).address(), len);
1202         } finally {
1203             Util.offerFirstTemporaryDirectBuffer(src);
1204         }
1205     }
1206 
1207     /**
1208      * Writes a sequence of bytes to the socket from the given byte array.
1209      *
1210      * @apiNote This method is for use by the socket adaptor.
1211      */
1212     void blockingWriteFully(byte[] b, int off, int len) throws IOException {
1213         Objects.checkFromIndexSize(off, len, b.length);
1214         if (len == 0) {
1215             // nothing to do
1216             return;
1217         }
1218 
1219         writeLock.lock();
1220         try {
1221             // check that channel is configured blocking
1222             if (!isBlocking())
1223                 throw new IllegalBlockingModeException();
1224 
1225             // loop until all bytes have been written
1226             int pos = off;
1227             int end = off + len;
1228             beginWrite(true);
1229             try {
1230                 while (pos &lt; end &amp;&amp; isOpen()) {
1231                     int size = end - pos;
1232                     int n = tryWrite(b, pos, size);
1233                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
1234                         park(Net.POLLOUT);
1235                         n = tryWrite(b, pos, size);
1236                     }
1237                     if (n &gt; 0) {
1238                         pos += n;
1239                     }
1240                 }
1241             } finally {
1242                 endWrite(true, pos &gt;= end);
1243             }
1244         } finally {
1245             writeLock.unlock();
1246         }
1247     }
1248 
1249     /**
1250      * Return the number of bytes in the socket input buffer.
1251      */
1252     int available() throws IOException {
1253         synchronized (stateLock) {
1254             ensureOpenAndConnected();
1255             if (isInputClosed) {
1256                 return 0;
1257             } else {
1258                 return Net.available(fd);
1259             }
1260         }
1261     }
1262 
1263     /**
1264      * Translates native poll revent ops into a ready operation ops
1265      */
1266     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1267         int intOps = ski.nioInterestOps();
1268         int oldOps = ski.nioReadyOps();
1269         int newOps = initialOps;
1270 
1271         if ((ops &amp; Net.POLLNVAL) != 0) {
1272             // This should only happen if this channel is pre-closed while a
1273             // selection operation is in progress
1274             // ## Throw an error if this channel has not been pre-closed
1275             return false;
1276         }
1277 
1278         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1279             newOps = intOps;
1280             ski.nioReadyOps(newOps);
1281             return (newOps &amp; ~oldOps) != 0;
1282         }
1283 
1284         boolean connected = isConnected();
1285         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
1286             ((intOps &amp; SelectionKey.OP_READ) != 0) &amp;&amp; connected)
1287             newOps |= SelectionKey.OP_READ;
1288 
1289         if (((ops &amp; Net.POLLCONN) != 0) &amp;&amp;
1290             ((intOps &amp; SelectionKey.OP_CONNECT) != 0) &amp;&amp; isConnectionPending())
1291             newOps |= SelectionKey.OP_CONNECT;
1292 
1293         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
1294             ((intOps &amp; SelectionKey.OP_WRITE) != 0) &amp;&amp; connected)
1295             newOps |= SelectionKey.OP_WRITE;
1296 
1297         ski.nioReadyOps(newOps);
1298         return (newOps &amp; ~oldOps) != 0;
1299     }
1300 
1301     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
1302         return translateReadyOps(ops, ski.nioReadyOps(), ski);
1303     }
1304 
1305     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
1306         return translateReadyOps(ops, 0, ski);
1307     }
1308 
1309     /**
1310      * Translates an interest operation set into a native poll event set
1311      */
1312     public int translateInterestOps(int ops) {
1313         int newOps = 0;
1314         if ((ops &amp; SelectionKey.OP_READ) != 0)
1315             newOps |= Net.POLLIN;
1316         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
1317             newOps |= Net.POLLOUT;
1318         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
1319             newOps |= Net.POLLCONN;
1320         return newOps;
1321     }
1322 
1323     public FileDescriptor getFD() {
1324         return fd;
1325     }
1326 
1327     public int getFDVal() {
1328         return fdVal;
1329     }
1330 
1331     @Override
1332     public String toString() {
1333         StringBuilder sb = new StringBuilder();
1334         sb.append(this.getClass().getSuperclass().getName());
1335         sb.append(&#39;[&#39;);
1336         if (!isOpen())
1337             sb.append(&quot;closed&quot;);
1338         else {
1339             synchronized (stateLock) {
1340                 switch (state) {
1341                 case ST_UNCONNECTED:
1342                     sb.append(&quot;unconnected&quot;);
1343                     break;
1344                 case ST_CONNECTIONPENDING:
1345                     sb.append(&quot;connection-pending&quot;);
1346                     break;
1347                 case ST_CONNECTED:
1348                     sb.append(&quot;connected&quot;);
1349                     if (isInputClosed)
1350                         sb.append(&quot; ishut&quot;);
1351                     if (isOutputClosed)
1352                         sb.append(&quot; oshut&quot;);
1353                     break;
1354                 }
1355                 InetSocketAddress addr = localAddress();
1356                 if (addr != null) {
1357                     sb.append(&quot; local=&quot;);
1358                     sb.append(Net.getRevealedLocalAddressAsString(addr));
1359                 }
1360                 if (remoteAddress() != null) {
1361                     sb.append(&quot; remote=&quot;);
1362                     sb.append(remoteAddress().toString());
1363                 }
1364             }
1365         }
1366         sb.append(&#39;]&#39;);
1367         return sb.toString();
1368     }
1369 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
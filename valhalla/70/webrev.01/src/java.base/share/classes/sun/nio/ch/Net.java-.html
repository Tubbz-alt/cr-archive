<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/nio/ch/Net.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.net.Inet4Address;
 31 import java.net.Inet6Address;
 32 import java.net.InetAddress;
 33 import java.net.InetSocketAddress;
 34 import java.net.NetworkInterface;
 35 import java.net.ProtocolFamily;
 36 import java.net.SocketAddress;
 37 import java.net.SocketException;
 38 import java.net.SocketOption;
 39 import java.net.StandardProtocolFamily;
 40 import java.net.StandardSocketOptions;
 41 import java.net.UnknownHostException;
 42 import java.nio.channels.AlreadyBoundException;
 43 import java.nio.channels.ClosedChannelException;
 44 import java.nio.channels.NotYetBoundException;
 45 import java.nio.channels.NotYetConnectedException;
 46 import java.nio.channels.UnresolvedAddressException;
 47 import java.nio.channels.UnsupportedAddressTypeException;
 48 import java.security.AccessController;
 49 import java.security.PrivilegedAction;
 50 import java.util.Enumeration;
 51 
 52 import sun.net.ext.ExtendedSocketOptions;
 53 import sun.net.util.IPAddressUtil;
 54 import sun.security.action.GetPropertyAction;
 55 
 56 public class Net {
 57 
 58     private Net() { }
 59 
 60     // unspecified protocol family
 61     static final ProtocolFamily UNSPEC = new ProtocolFamily() {
 62         public String name() {
 63             return &quot;UNSPEC&quot;;
 64         }
 65     };
 66 
 67     // set to true if exclusive binding is on for Windows
 68     private static final boolean exclusiveBind;
 69 
 70     // set to true if the fast tcp loopback should be enabled on Windows
 71     private static final boolean fastLoopback;
 72 
 73     // -- Miscellaneous utilities --
 74 
 75     private static volatile boolean checkedIPv6;
 76     private static volatile boolean isIPv6Available;
 77     private static volatile boolean checkedReusePort;
 78     private static volatile boolean isReusePortAvailable;
 79 
 80     /**
 81      * Tells whether dual-IPv4/IPv6 sockets should be used.
 82      */
 83     static boolean isIPv6Available() {
 84         if (!checkedIPv6) {
 85             isIPv6Available = isIPv6Available0();
 86             checkedIPv6 = true;
 87         }
 88         return isIPv6Available;
 89     }
 90 
 91     /**
 92      * Tells whether SO_REUSEPORT is supported.
 93      */
 94     static boolean isReusePortAvailable() {
 95         if (!checkedReusePort) {
 96             isReusePortAvailable = isReusePortAvailable0();
 97             checkedReusePort = true;
 98         }
 99         return isReusePortAvailable;
100     }
101 
102     /**
103      * Returns true if exclusive binding is on
104      */
105     static boolean useExclusiveBind() {
106         return exclusiveBind;
107     }
108 
109     /**
110      * Tells whether both IPV6_XXX and IP_XXX socket options should be set on
111      * IPv6 sockets. On some kernels, both IPV6_XXX and IP_XXX socket options
112      * need to be set so that the settings are effective for IPv4 multicast
113      * datagrams sent using the socket.
114      */
115     static boolean shouldSetBothIPv4AndIPv6Options() {
116         return shouldSetBothIPv4AndIPv6Options0();
117     }
118 
119     /**
120      * Tells whether IPv6 sockets can join IPv4 multicast groups
121      */
122     static boolean canIPv6SocketJoinIPv4Group() {
123         return canIPv6SocketJoinIPv4Group0();
124     }
125 
126     /**
127      * Tells whether {@link #join6} can be used to join an IPv4
128      * multicast group (IPv4 group as IPv4-mapped IPv6 address)
129      */
130     static boolean canJoin6WithIPv4Group() {
131         return canJoin6WithIPv4Group0();
132     }
133 
134     /**
135      * Tells whether IPV6_XXX socket options should be used on an IPv6 socket
136      * that is bound to an IPv4 address.
137      */
138     static boolean canUseIPv6OptionsWithIPv4LocalAddress() {
139         return canUseIPv6OptionsWithIPv4LocalAddress0();
140     }
141 
142     public static InetSocketAddress checkAddress(SocketAddress sa) {
143         if (sa == null)
144             throw new NullPointerException();
145         if (!(sa instanceof InetSocketAddress))
146             throw new UnsupportedAddressTypeException(); // ## needs arg
147         InetSocketAddress isa = (InetSocketAddress)sa;
148         if (isa.isUnresolved())
149             throw new UnresolvedAddressException(); // ## needs arg
150         InetAddress addr = isa.getAddress();
151         if (!(addr instanceof Inet4Address || addr instanceof Inet6Address))
152             throw new IllegalArgumentException(&quot;Invalid address type&quot;);
153         return isa;
154     }
155 
156     static InetSocketAddress checkAddress(SocketAddress sa, ProtocolFamily family) {
157         InetSocketAddress isa = checkAddress(sa);
158         if (family == StandardProtocolFamily.INET) {
159             InetAddress addr = isa.getAddress();
160             if (!(addr instanceof Inet4Address))
161                 throw new UnsupportedAddressTypeException();
162         }
163         return isa;
164     }
165 
166     static InetSocketAddress asInetSocketAddress(SocketAddress sa) {
167         if (!(sa instanceof InetSocketAddress))
168             throw new UnsupportedAddressTypeException();
169         return (InetSocketAddress)sa;
170     }
171 
172     static void translateToSocketException(Exception x)
173         throws SocketException
174     {
175         if (x instanceof SocketException)
176             throw (SocketException)x;
177         Exception nx = x;
178         if (x instanceof ClosedChannelException)
179             nx = new SocketException(&quot;Socket is closed&quot;);
180         else if (x instanceof NotYetConnectedException)
181             nx = new SocketException(&quot;Socket is not connected&quot;);
182         else if (x instanceof AlreadyBoundException)
183             nx = new SocketException(&quot;Already bound&quot;);
184         else if (x instanceof NotYetBoundException)
185             nx = new SocketException(&quot;Socket is not bound yet&quot;);
186         else if (x instanceof UnsupportedAddressTypeException)
187             nx = new SocketException(&quot;Unsupported address type&quot;);
188         else if (x instanceof UnresolvedAddressException) {
189             nx = new SocketException(&quot;Unresolved address&quot;);
190         }
191         if (nx != x)
192             nx.initCause(x);
193 
194         if (nx instanceof SocketException)
195             throw (SocketException)nx;
196         else if (nx instanceof RuntimeException)
197             throw (RuntimeException)nx;
198         else
199             throw new Error(&quot;Untranslated exception&quot;, nx);
200     }
201 
202     static void translateException(Exception x,
203                                    boolean unknownHostForUnresolved)
204         throws IOException
205     {
206         if (x instanceof IOException)
207             throw (IOException)x;
208         // Throw UnknownHostException from here since it cannot
209         // be thrown as a SocketException
210         if (unknownHostForUnresolved &amp;&amp;
211             (x instanceof UnresolvedAddressException))
212         {
213              throw new UnknownHostException();
214         }
215         translateToSocketException(x);
216     }
217 
218     static void translateException(Exception x)
219         throws IOException
220     {
221         translateException(x, false);
222     }
223 
224     /**
225      * Returns the local address after performing a SecurityManager#checkConnect.
226      */
227     static InetSocketAddress getRevealedLocalAddress(InetSocketAddress addr) {
228         SecurityManager sm = System.getSecurityManager();
229         if (addr == null || sm == null)
230             return addr;
231 
232         try{
233             sm.checkConnect(addr.getAddress().getHostAddress(), -1);
234             // Security check passed
235         } catch (SecurityException e) {
236             // Return loopback address only if security check fails
237             addr = getLoopbackAddress(addr.getPort());
238         }
239         return addr;
240     }
241 
242     static String getRevealedLocalAddressAsString(InetSocketAddress addr) {
243         return System.getSecurityManager() == null ? addr.toString() :
244                 getLoopbackAddress(addr.getPort()).toString();
245     }
246 
247     private static InetSocketAddress getLoopbackAddress(int port) {
248         return new InetSocketAddress(InetAddress.getLoopbackAddress(),
249                                      port);
250     }
251 
252     /**
253      * Returns any IPv4 address of the given network interface, or
254      * null if the interface does not have any IPv4 addresses.
255      */
256     static Inet4Address anyInet4Address(final NetworkInterface interf) {
257         return AccessController.doPrivileged(new PrivilegedAction&lt;Inet4Address&gt;() {
258             public Inet4Address run() {
259                 Enumeration&lt;InetAddress&gt; addrs = interf.getInetAddresses();
260                 while (addrs.hasMoreElements()) {
261                     InetAddress addr = addrs.nextElement();
262                     if (addr instanceof Inet4Address) {
263                         return (Inet4Address)addr;
264                     }
265                 }
266                 return null;
267             }
268         });
269     }
270 
271     /**
272      * Returns an IPv4 address as an int.
273      */
274     static int inet4AsInt(InetAddress ia) {
275         if (ia instanceof Inet4Address) {
276             byte[] addr = ia.getAddress();
277             int address  = addr[3] &amp; 0xFF;
278             address |= ((addr[2] &lt;&lt; 8) &amp; 0xFF00);
279             address |= ((addr[1] &lt;&lt; 16) &amp; 0xFF0000);
280             address |= ((addr[0] &lt;&lt; 24) &amp; 0xFF000000);
281             return address;
282         }
283         throw new AssertionError(&quot;Should not reach here&quot;);
284     }
285 
286     /**
287      * Returns an InetAddress from the given IPv4 address
288      * represented as an int.
289      */
290     static InetAddress inet4FromInt(int address) {
291         byte[] addr = new byte[4];
292         addr[0] = (byte) ((address &gt;&gt;&gt; 24) &amp; 0xFF);
293         addr[1] = (byte) ((address &gt;&gt;&gt; 16) &amp; 0xFF);
294         addr[2] = (byte) ((address &gt;&gt;&gt; 8) &amp; 0xFF);
295         addr[3] = (byte) (address &amp; 0xFF);
296         try {
297             return InetAddress.getByAddress(addr);
298         } catch (UnknownHostException uhe) {
299             throw new AssertionError(&quot;Should not reach here&quot;);
300         }
301     }
302 
303     /**
304      * Returns an IPv6 address as a byte array
305      */
306     static byte[] inet6AsByteArray(InetAddress ia) {
307         if (ia instanceof Inet6Address) {
308             return ia.getAddress();
309         }
310 
311         // need to construct IPv4-mapped address
312         if (ia instanceof Inet4Address) {
313             byte[] ip4address = ia.getAddress();
314             byte[] address = new byte[16];
315             address[10] = (byte)0xff;
316             address[11] = (byte)0xff;
317             address[12] = ip4address[0];
318             address[13] = ip4address[1];
319             address[14] = ip4address[2];
320             address[15] = ip4address[3];
321             return address;
322         }
323 
324         throw new AssertionError(&quot;Should not reach here&quot;);
325     }
326 
327     // -- Socket options
328 
329     static final ExtendedSocketOptions extendedOptions =
330             ExtendedSocketOptions.getInstance();
331 
332     static void setSocketOption(FileDescriptor fd, SocketOption&lt;?&gt; name, Object value)
333         throws IOException
334     {
335         setSocketOption(fd, Net.UNSPEC, name, value);
336     }
337 
338     static void setSocketOption(FileDescriptor fd, ProtocolFamily family,
339                                 SocketOption&lt;?&gt; name, Object value)
340         throws IOException
341     {
342         if (value == null)
343             throw new IllegalArgumentException(&quot;Invalid option value&quot;);
344 
345         // only simple values supported by this method
346         Class&lt;?&gt; type = name.type();
347 
348         if (extendedOptions.isOptionSupported(name)) {
349             extendedOptions.setOption(fd, name, value);
350             return;
351         }
352 
353         if (type != Integer.class &amp;&amp; type != Boolean.class)
354             throw new AssertionError(&quot;Should not reach here&quot;);
355 
356         // special handling
357         if (name == StandardSocketOptions.SO_RCVBUF ||
358             name == StandardSocketOptions.SO_SNDBUF)
359         {
360             int i = ((Integer)value).intValue();
361             if (i &lt; 0)
362                 throw new IllegalArgumentException(&quot;Invalid send/receive buffer size&quot;);
363         }
364         if (name == StandardSocketOptions.SO_LINGER) {
365             int i = ((Integer)value).intValue();
366             if (i &lt; 0)
367                 value = Integer.valueOf(-1);
368             if (i &gt; 65535)
369                 value = Integer.valueOf(65535);
370         }
371         if (name == StandardSocketOptions.IP_TOS) {
372             int i = ((Integer)value).intValue();
373             if (i &lt; 0 || i &gt; 255)
374                 throw new IllegalArgumentException(&quot;Invalid IP_TOS value&quot;);
375         }
376         if (name == StandardSocketOptions.IP_MULTICAST_TTL) {
377             int i = ((Integer)value).intValue();
378             if (i &lt; 0 || i &gt; 255)
379                 throw new IllegalArgumentException(&quot;Invalid TTL/hop value&quot;);
380         }
381 
382         // map option name to platform level/name
383         OptionKey key = SocketOptionRegistry.findOption(name, family);
384         if (key == null)
385             throw new AssertionError(&quot;Option not found&quot;);
386 
387         int arg;
388         if (type == Integer.class) {
389             arg = ((Integer)value).intValue();
390         } else {
391             boolean b = ((Boolean)value).booleanValue();
392             arg = (b) ? 1 : 0;
393         }
394 
395         boolean mayNeedConversion = (family == UNSPEC);
396         boolean isIPv6 = (family == StandardProtocolFamily.INET6);
397         setIntOption0(fd, mayNeedConversion, key.level(), key.name(), arg, isIPv6);
398     }
399 
400     static Object getSocketOption(FileDescriptor fd, SocketOption&lt;?&gt; name)
401         throws IOException
402     {
403         return getSocketOption(fd, Net.UNSPEC, name);
404     }
405 
406     static Object getSocketOption(FileDescriptor fd, ProtocolFamily family, SocketOption&lt;?&gt; name)
407         throws IOException
408     {
409         Class&lt;?&gt; type = name.type();
410 
411         if (extendedOptions.isOptionSupported(name)) {
412             return extendedOptions.getOption(fd, name);
413         }
414 
415         // only simple values supported by this method
416         if (type != Integer.class &amp;&amp; type != Boolean.class)
417             throw new AssertionError(&quot;Should not reach here&quot;);
418 
419         // map option name to platform level/name
420         OptionKey key = SocketOptionRegistry.findOption(name, family);
421         if (key == null)
422             throw new AssertionError(&quot;Option not found&quot;);
423 
424         boolean mayNeedConversion = (family == UNSPEC);
425         int value = getIntOption0(fd, mayNeedConversion, key.level(), key.name());
426 
427         if (type == Integer.class) {
428             return Integer.valueOf(value);
429         } else {
430             return (value == 0) ? Boolean.FALSE : Boolean.TRUE;
431         }
432     }
433 
434     public static boolean isFastTcpLoopbackRequested() {
435         String loopbackProp = GetPropertyAction
436                 .privilegedGetProperty(&quot;jdk.net.useFastTcpLoopback&quot;, &quot;false&quot;);
437         return loopbackProp.isEmpty() ? true : Boolean.parseBoolean(loopbackProp);
438     }
439 
440     // -- Socket operations --
441 
442     private static native boolean isIPv6Available0();
443 
444     private static native boolean isReusePortAvailable0();
445 
446     /*
447      * Returns 1 for Windows and -1 for Solaris/Linux/Mac OS
448      */
449     private static native int isExclusiveBindAvailable();
450 
451     private static native boolean shouldSetBothIPv4AndIPv6Options0();
452 
453     private static native boolean canIPv6SocketJoinIPv4Group0();
454 
455     private static native boolean canJoin6WithIPv4Group0();
456 
457     private static native boolean canUseIPv6OptionsWithIPv4LocalAddress0();
458 
459     static FileDescriptor socket(boolean stream) throws IOException {
460         return socket(UNSPEC, stream);
461     }
462 
463     static FileDescriptor socket(ProtocolFamily family, boolean stream) throws IOException {
464         boolean preferIPv6 = isIPv6Available() &amp;&amp;
465             (family != StandardProtocolFamily.INET);
466         return IOUtil.newFD(socket0(preferIPv6, stream, false, fastLoopback));
467     }
468 
469     static FileDescriptor serverSocket(boolean stream) {
470         return IOUtil.newFD(socket0(isIPv6Available(), stream, true, fastLoopback));
471     }
472 
473     // Due to oddities SO_REUSEADDR on windows reuse is ignored
474     private static native int socket0(boolean preferIPv6, boolean stream, boolean reuse,
475                                       boolean fastLoopback);
476 
477     public static void bind(FileDescriptor fd, InetAddress addr, int port)
478         throws IOException
479     {
480         bind(UNSPEC, fd, addr, port);
481     }
482 
483     static void bind(ProtocolFamily family, FileDescriptor fd,
484                      InetAddress addr, int port) throws IOException
485     {
486         boolean preferIPv6 = isIPv6Available() &amp;&amp;
487             (family != StandardProtocolFamily.INET);
488         if (addr.isLinkLocalAddress()) {
489             addr = IPAddressUtil.toScopedAddress(addr);
490         }
491         bind0(fd, preferIPv6, exclusiveBind, addr, port);
492     }
493 
494     private static native void bind0(FileDescriptor fd, boolean preferIPv6,
495                                      boolean useExclBind, InetAddress addr,
496                                      int port)
497         throws IOException;
498 
499     static native void listen(FileDescriptor fd, int backlog) throws IOException;
500 
501     static int connect(FileDescriptor fd, InetAddress remote, int remotePort)
502         throws IOException
503     {
504         return connect(UNSPEC, fd, remote, remotePort);
505     }
506 
507     static int connect(ProtocolFamily family, FileDescriptor fd, InetAddress remote, int remotePort)
508         throws IOException
509     {
510         if (remote.isLinkLocalAddress()) {
511             remote = IPAddressUtil.toScopedAddress(remote);
512         }
513         boolean preferIPv6 = isIPv6Available() &amp;&amp;
514             (family != StandardProtocolFamily.INET);
515         return connect0(preferIPv6, fd, remote, remotePort);
516     }
517 
518     private static native int connect0(boolean preferIPv6,
519                                        FileDescriptor fd,
520                                        InetAddress remote,
521                                        int remotePort)
522         throws IOException;
523 
524     public static native int accept(FileDescriptor fd,
525                                     FileDescriptor newfd,
526                                     InetSocketAddress[] isaa)
527         throws IOException;
528 
529     public static final int SHUT_RD = 0;
530     public static final int SHUT_WR = 1;
531     public static final int SHUT_RDWR = 2;
532 
533     static native void shutdown(FileDescriptor fd, int how) throws IOException;
534 
535     private static native int localPort(FileDescriptor fd)
536         throws IOException;
537 
538     private static native InetAddress localInetAddress(FileDescriptor fd)
539         throws IOException;
540 
541     public static InetSocketAddress localAddress(FileDescriptor fd)
542         throws IOException
543     {
544         return new InetSocketAddress(localInetAddress(fd), localPort(fd));
545     }
546 
547     private static native int remotePort(FileDescriptor fd)
548         throws IOException;
549 
550     private static native InetAddress remoteInetAddress(FileDescriptor fd)
551         throws IOException;
552 
553     static InetSocketAddress remoteAddress(FileDescriptor fd)
554         throws IOException
555     {
556         return new InetSocketAddress(remoteInetAddress(fd), remotePort(fd));
557     }
558 
559     private static native int getIntOption0(FileDescriptor fd, boolean mayNeedConversion,
560                                             int level, int opt)
561         throws IOException;
562 
563     private static native void setIntOption0(FileDescriptor fd, boolean mayNeedConversion,
564                                              int level, int opt, int arg, boolean isIPv6)
565         throws IOException;
566 
567     /**
568      * Polls a file descriptor for events.
569      * @param timeout the timeout to wait; 0 to not wait, -1 to wait indefinitely
570      * @return the polled events or 0 if no events are polled
571      */
572     static native int poll(FileDescriptor fd, int events, long timeout)
573         throws IOException;
574 
575     /**
576      * Performs a non-blocking poll of a file descriptor.
577      * @return the polled events or 0 if no events are polled
578      */
579     static int pollNow(FileDescriptor fd, int events) throws IOException {
580         return poll(fd, events, 0);
581     }
582 
583     /**
584      * Polls a connecting socket to test if the connection has been established.
585      *
586      * @apiNote This method is public to allow it be used by code in jdk.sctp.
587      *
588      * @param timeout the timeout to wait; 0 to not wait, -1 to wait indefinitely
589      * @return true if connected
590      */
591     public static native boolean pollConnect(FileDescriptor fd, long timeout)
592         throws IOException;
593 
594     /**
595      * Performs a non-blocking poll of a connecting socket to test if the
596      * connection has been established.
597      *
598      * @return true if connected
599      */
600     static boolean pollConnectNow(FileDescriptor fd) throws IOException {
601         return pollConnect(fd, 0);
602     }
603 
604     /**
605      * Return the number of bytes in the socket input buffer.
606      */
607     static native int available(FileDescriptor fd) throws IOException;
608 
609     /**
610      * Send one byte of urgent data (MSG_OOB) on the socket.
611      */
612     static native int sendOOB(FileDescriptor fd, byte data) throws IOException;
613 
614 
615     // -- Multicast support --
616 
617     /**
618      * Join IPv4 multicast group
619      */
620     static int join4(FileDescriptor fd, int group, int interf, int source)
621         throws IOException
622     {
623         return joinOrDrop4(true, fd, group, interf, source);
624     }
625 
626     /**
627      * Drop membership of IPv4 multicast group
628      */
629     static void drop4(FileDescriptor fd, int group, int interf, int source)
630         throws IOException
631     {
632         joinOrDrop4(false, fd, group, interf, source);
633     }
634 
635     private static native int joinOrDrop4(boolean join, FileDescriptor fd, int group, int interf, int source)
636         throws IOException;
637 
638     /**
639      * Block IPv4 source
640      */
641     static int block4(FileDescriptor fd, int group, int interf, int source)
642         throws IOException
643     {
644         return blockOrUnblock4(true, fd, group, interf, source);
645     }
646 
647     /**
648      * Unblock IPv6 source
649      */
650     static void unblock4(FileDescriptor fd, int group, int interf, int source)
651         throws IOException
652     {
653         blockOrUnblock4(false, fd, group, interf, source);
654     }
655 
656     private static native int blockOrUnblock4(boolean block, FileDescriptor fd, int group,
657                                               int interf, int source)
658         throws IOException;
659 
660     /**
661      * Join IPv6 multicast group
662      */
663     static int join6(FileDescriptor fd, byte[] group, int index, byte[] source)
664         throws IOException
665     {
666         return joinOrDrop6(true, fd, group, index, source);
667     }
668 
669     /**
670      * Drop membership of IPv6 multicast group
671      */
672     static void drop6(FileDescriptor fd, byte[] group, int index, byte[] source)
673         throws IOException
674     {
675         joinOrDrop6(false, fd, group, index, source);
676     }
677 
678     private static native int joinOrDrop6(boolean join, FileDescriptor fd, byte[] group, int index, byte[] source)
679         throws IOException;
680 
681     /**
682      * Block IPv6 source
683      */
684     static int block6(FileDescriptor fd, byte[] group, int index, byte[] source)
685         throws IOException
686     {
687         return blockOrUnblock6(true, fd, group, index, source);
688     }
689 
690     /**
691      * Unblock IPv6 source
692      */
693     static void unblock6(FileDescriptor fd, byte[] group, int index, byte[] source)
694         throws IOException
695     {
696         blockOrUnblock6(false, fd, group, index, source);
697     }
698 
699     static native int blockOrUnblock6(boolean block, FileDescriptor fd, byte[] group, int index, byte[] source)
700         throws IOException;
701 
702     static native void setInterface4(FileDescriptor fd, int interf) throws IOException;
703 
704     static native int getInterface4(FileDescriptor fd) throws IOException;
705 
706     static native void setInterface6(FileDescriptor fd, int index) throws IOException;
707 
708     static native int getInterface6(FileDescriptor fd) throws IOException;
709 
710     private static native void initIDs();
711 
712     /**
713      * Event masks for the various poll system calls.
714      * They will be set platform dependent in the static initializer below.
715      */
716     public static final short POLLIN;
717     public static final short POLLOUT;
718     public static final short POLLERR;
719     public static final short POLLHUP;
720     public static final short POLLNVAL;
721     public static final short POLLCONN;
722 
723     static native short pollinValue();
724     static native short polloutValue();
725     static native short pollerrValue();
726     static native short pollhupValue();
727     static native short pollnvalValue();
728     static native short pollconnValue();
729 
730     static {
731         IOUtil.load();
732         initIDs();
733 
734         POLLIN     = pollinValue();
735         POLLOUT    = polloutValue();
736         POLLERR    = pollerrValue();
737         POLLHUP    = pollhupValue();
738         POLLNVAL   = pollnvalValue();
739         POLLCONN   = pollconnValue();
740     }
741 
742     static {
743         int availLevel = isExclusiveBindAvailable();
744         if (availLevel &gt;= 0) {
745             String exclBindProp = GetPropertyAction
746                     .privilegedGetProperty(&quot;sun.net.useExclusiveBind&quot;);
747             if (exclBindProp != null) {
748                 exclusiveBind = exclBindProp.isEmpty() ?
749                         true : Boolean.parseBoolean(exclBindProp);
750             } else if (availLevel == 1) {
751                 exclusiveBind = true;
752             } else {
753                 exclusiveBind = false;
754             }
755         } else {
756             exclusiveBind = false;
757         }
758 
759         fastLoopback = isFastTcpLoopbackRequested();
760     }
761 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.net.InetAddress;
<a name="1" id="anc1"></a><span class="line-added">  31 import java.net.Inet4Address;</span>
  32 import java.net.InetSocketAddress;
  33 import java.net.ProtocolFamily;
  34 import java.net.Socket;
  35 import java.net.SocketAddress;
  36 import java.net.SocketException;
  37 import java.net.SocketOption;
  38 import java.net.SocketTimeoutException;
  39 import java.net.StandardProtocolFamily;
  40 import java.net.StandardSocketOptions;
  41 import java.nio.ByteBuffer;
  42 import java.nio.channels.AlreadyBoundException;
  43 import java.nio.channels.AlreadyConnectedException;
  44 import java.nio.channels.AsynchronousCloseException;
  45 import java.nio.channels.ClosedChannelException;
  46 import java.nio.channels.ConnectionPendingException;
  47 import java.nio.channels.IllegalBlockingModeException;
  48 import java.nio.channels.NoConnectionPendingException;
  49 import java.nio.channels.NotYetConnectedException;
  50 import java.nio.channels.SelectionKey;
  51 import java.nio.channels.SocketChannel;
  52 import java.nio.channels.spi.SelectorProvider;
  53 import java.util.Collections;
  54 import java.util.HashSet;
  55 import java.util.Objects;
  56 import java.util.Set;
  57 import java.util.concurrent.locks.ReentrantLock;
  58 
  59 import sun.net.ConnectionResetException;
  60 import sun.net.NetHooks;
  61 import sun.net.ext.ExtendedSocketOptions;
  62 import sun.net.util.SocketExceptions;
  63 
  64 /**
  65  * An implementation of SocketChannels
  66  */
  67 
  68 class SocketChannelImpl
  69     extends SocketChannel
  70     implements SelChImpl
  71 {
  72     // Used to make native read and write calls
  73     private static final NativeDispatcher nd = new SocketDispatcher();
  74 
<a name="2" id="anc2"></a><span class="line-added">  75     // The protocol family of the socket</span>
<span class="line-added">  76     private final ProtocolFamily family;</span>
<span class="line-added">  77 </span>
  78     // Our file descriptor object
  79     private final FileDescriptor fd;
  80     private final int fdVal;
  81 
  82     // Lock held by current reading or connecting thread
  83     private final ReentrantLock readLock = new ReentrantLock();
  84 
  85     // Lock held by current writing or connecting thread
  86     private final ReentrantLock writeLock = new ReentrantLock();
  87 
  88     // Lock held by any thread that modifies the state fields declared below
  89     // DO NOT invoke a blocking I/O operation while holding this lock!
  90     private final Object stateLock = new Object();
  91 
  92     // Input/Output closed
  93     private volatile boolean isInputClosed;
  94     private volatile boolean isOutputClosed;
  95 
  96     // Connection reset protected by readLock
  97     private boolean connectionReset;
  98 
  99     // -- The following fields are protected by stateLock
 100 
 101     // set true when exclusive binding is on and SO_REUSEADDR is emulated
 102     private boolean isReuseAddress;
 103 
 104     // State, increases monotonically
 105     private static final int ST_UNCONNECTED = 0;
 106     private static final int ST_CONNECTIONPENDING = 1;
 107     private static final int ST_CONNECTED = 2;
 108     private static final int ST_CLOSING = 3;
 109     private static final int ST_CLOSED = 4;
 110     private volatile int state;  // need stateLock to change
 111 
 112     // IDs of native threads doing reads and writes, for signalling
 113     private long readerThread;
 114     private long writerThread;
 115 
 116     // Binding
 117     private InetSocketAddress localAddress;
 118     private InetSocketAddress remoteAddress;
 119 
 120     // Socket adaptor, created on demand
 121     private Socket socket;
 122 
 123     // -- End of fields protected by stateLock
 124 
<a name="3" id="anc3"></a>
 125     // Constructor for normal connecting sockets
 126     //
 127     SocketChannelImpl(SelectorProvider sp) throws IOException {
<a name="4" id="anc4"></a><span class="line-added"> 128         this(sp, Net.isIPv6Available()</span>
<span class="line-added"> 129                 ? StandardProtocolFamily.INET6</span>
<span class="line-added"> 130                 : StandardProtocolFamily.INET);</span>
<span class="line-added"> 131     }</span>
<span class="line-added"> 132 </span>
<span class="line-added"> 133     SocketChannelImpl(SelectorProvider sp, ProtocolFamily family) throws IOException {</span>
 134         super(sp);
<a name="5" id="anc5"></a><span class="line-modified"> 135         Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);</span>
<span class="line-added"> 136         if ((family != StandardProtocolFamily.INET) &amp;&amp;</span>
<span class="line-added"> 137                 (family != StandardProtocolFamily.INET6)) {</span>
<span class="line-added"> 138             throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);</span>
<span class="line-added"> 139         }</span>
<span class="line-added"> 140         if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.isIPv6Available()) {</span>
<span class="line-added"> 141             throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);</span>
<span class="line-added"> 142         }</span>
<span class="line-added"> 143         this.family = family;</span>
<span class="line-added"> 144         this.fd = Net.socket(family, true);</span>
 145         this.fdVal = IOUtil.fdVal(fd);
 146     }
 147 
 148     SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
 149         throws IOException
 150     {
 151         super(sp);
<a name="6" id="anc6"></a><span class="line-added"> 152         this.family = Net.isIPv6Available()</span>
<span class="line-added"> 153                 ? StandardProtocolFamily.INET6</span>
<span class="line-added"> 154                 : StandardProtocolFamily.INET;</span>
 155         this.fd = fd;
 156         this.fdVal = IOUtil.fdVal(fd);
<a name="7" id="anc7"></a><span class="line-added"> 157 </span>
 158         if (bound) {
 159             synchronized (stateLock) {
 160                 this.localAddress = Net.localAddress(fd);
 161             }
 162         }
 163     }
 164 
 165     // Constructor for sockets obtained from server sockets
 166     //
<a name="8" id="anc8"></a><span class="line-modified"> 167     SocketChannelImpl(SelectorProvider sp,</span>
<span class="line-added"> 168                       ProtocolFamily family,</span>
<span class="line-added"> 169                       FileDescriptor fd,</span>
<span class="line-added"> 170                       InetSocketAddress isa)</span>
 171         throws IOException
 172     {
 173         super(sp);
<a name="9" id="anc9"></a><span class="line-added"> 174         this.family = family;</span>
 175         this.fd = fd;
 176         this.fdVal = IOUtil.fdVal(fd);
 177         synchronized (stateLock) {
 178             this.localAddress = Net.localAddress(fd);
 179             this.remoteAddress = isa;
 180             this.state = ST_CONNECTED;
 181         }
 182     }
 183 
 184     /**
 185      * Checks that the channel is open.
 186      *
 187      * @throws ClosedChannelException if channel is closed (or closing)
 188      */
 189     private void ensureOpen() throws ClosedChannelException {
 190         if (!isOpen())
 191             throw new ClosedChannelException();
 192     }
 193 
 194     /**
 195      * Checks that the channel is open and connected.
 196      *
 197      * @apiNote This method uses the &quot;state&quot; field to check if the channel is
 198      * open. It should never be used in conjuncion with isOpen or ensureOpen
 199      * as these methods check AbstractInterruptibleChannel&#39;s closed field - that
 200      * field is set before implCloseSelectableChannel is called and so before
 201      * the state is changed.
 202      *
 203      * @throws ClosedChannelException if channel is closed (or closing)
 204      * @throws NotYetConnectedException if open and not connected
 205      */
 206     private void ensureOpenAndConnected() throws ClosedChannelException {
 207         int state = this.state;
 208         if (state &lt; ST_CONNECTED) {
 209             throw new NotYetConnectedException();
 210         } else if (state &gt; ST_CONNECTED) {
 211             throw new ClosedChannelException();
 212         }
 213     }
 214 
 215     @Override
 216     public Socket socket() {
 217         synchronized (stateLock) {
 218             if (socket == null)
 219                 socket = SocketAdaptor.create(this);
 220             return socket;
 221         }
 222     }
 223 
 224     @Override
 225     public SocketAddress getLocalAddress() throws IOException {
 226         synchronized (stateLock) {
 227             ensureOpen();
 228             return Net.getRevealedLocalAddress(localAddress);
 229         }
 230     }
 231 
 232     @Override
 233     public SocketAddress getRemoteAddress() throws IOException {
 234         synchronized (stateLock) {
 235             ensureOpen();
 236             return remoteAddress;
 237         }
 238     }
 239 
 240     @Override
 241     public &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value)
 242         throws IOException
 243     {
 244         Objects.requireNonNull(name);
 245         if (!supportedOptions().contains(name))
 246             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 247         if (!name.type().isInstance(value))
 248             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);
 249 
 250         synchronized (stateLock) {
 251             ensureOpen();
 252 
 253             if (name == StandardSocketOptions.IP_TOS) {
<a name="10" id="anc10"></a>

 254                 Net.setSocketOption(fd, family, name, value);
 255                 return this;
 256             }
 257 
 258             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 259                 // SO_REUSEADDR emulated when using exclusive bind
 260                 isReuseAddress = (Boolean)value;
 261                 return this;
 262             }
 263 
 264             // no options that require special handling
 265             Net.setSocketOption(fd, name, value);
 266             return this;
 267         }
 268     }
 269 
 270     @Override
 271     @SuppressWarnings(&quot;unchecked&quot;)
 272     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 273         throws IOException
 274     {
 275         Objects.requireNonNull(name);
 276         if (!supportedOptions().contains(name))
 277             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 278 
 279         synchronized (stateLock) {
 280             ensureOpen();
 281 
 282             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 283                 // SO_REUSEADDR emulated when using exclusive bind
 284                 return (T)Boolean.valueOf(isReuseAddress);
 285             }
 286 
<a name="11" id="anc11"></a><span class="line-modified"> 287             // special handling for IP_TOS</span>
 288             if (name == StandardSocketOptions.IP_TOS) {
<a name="12" id="anc12"></a>

 289                 return (T) Net.getSocketOption(fd, family, name);
 290             }
 291 
 292             // no options that require special handling
 293             return (T) Net.getSocketOption(fd, name);
 294         }
 295     }
 296 
 297     private static class DefaultOptionsHolder {
 298         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 299 
 300         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 301             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 302             set.add(StandardSocketOptions.SO_SNDBUF);
 303             set.add(StandardSocketOptions.SO_RCVBUF);
 304             set.add(StandardSocketOptions.SO_KEEPALIVE);
 305             set.add(StandardSocketOptions.SO_REUSEADDR);
 306             if (Net.isReusePortAvailable()) {
 307                 set.add(StandardSocketOptions.SO_REUSEPORT);
 308             }
 309             set.add(StandardSocketOptions.SO_LINGER);
 310             set.add(StandardSocketOptions.TCP_NODELAY);
 311             // additional options required by socket adaptor
 312             set.add(StandardSocketOptions.IP_TOS);
 313             set.add(ExtendedSocketOption.SO_OOBINLINE);
 314             set.addAll(ExtendedSocketOptions.clientSocketOptions());
 315             return Collections.unmodifiableSet(set);
 316         }
 317     }
 318 
 319     @Override
 320     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 321         return DefaultOptionsHolder.defaultOptions;
 322     }
 323 
 324     /**
 325      * Marks the beginning of a read operation that might block.
 326      *
 327      * @throws ClosedChannelException if the channel is closed
 328      * @throws NotYetConnectedException if the channel is not yet connected
 329      */
 330     private void beginRead(boolean blocking) throws ClosedChannelException {
 331         if (blocking) {
 332             // set hook for Thread.interrupt
 333             begin();
 334 
 335             synchronized (stateLock) {
 336                 ensureOpenAndConnected();
 337                 // record thread so it can be signalled if needed
 338                 readerThread = NativeThread.current();
 339             }
 340         } else {
 341             ensureOpenAndConnected();
 342         }
 343     }
 344 
 345     /**
 346      * Marks the end of a read operation that may have blocked.
 347      *
 348      * @throws AsynchronousCloseException if the channel was closed due to this
 349      * thread being interrupted on a blocking read operation.
 350      */
 351     private void endRead(boolean blocking, boolean completed)
 352         throws AsynchronousCloseException
 353     {
 354         if (blocking) {
 355             synchronized (stateLock) {
 356                 readerThread = 0;
 357                 if (state == ST_CLOSING) {
 358                     tryFinishClose();
 359                 }
 360             }
 361             // remove hook for Thread.interrupt
 362             end(completed);
 363         }
 364     }
 365 
 366     private void throwConnectionReset() throws SocketException {
 367         throw new SocketException(&quot;Connection reset&quot;);
 368     }
 369 
 370     @Override
 371     public int read(ByteBuffer buf) throws IOException {
 372         Objects.requireNonNull(buf);
 373 
 374         readLock.lock();
 375         try {
 376             boolean blocking = isBlocking();
 377             int n = 0;
 378             try {
 379                 beginRead(blocking);
 380 
 381                 // check if connection has been reset
 382                 if (connectionReset)
 383                     throwConnectionReset();
 384 
 385                 // check if input is shutdown
 386                 if (isInputClosed)
 387                     return IOStatus.EOF;
 388 
 389                 n = IOUtil.read(fd, buf, -1, nd);
 390                 if (blocking) {
 391                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 392                         park(Net.POLLIN);
 393                         n = IOUtil.read(fd, buf, -1, nd);
 394                     }
 395                 }
 396             } catch (ConnectionResetException e) {
 397                 connectionReset = true;
 398                 throwConnectionReset();
 399             } finally {
 400                 endRead(blocking, n &gt; 0);
 401                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 402                     return IOStatus.EOF;
 403             }
 404             return IOStatus.normalize(n);
 405         } finally {
 406             readLock.unlock();
 407         }
 408     }
 409 
 410     @Override
 411     public long read(ByteBuffer[] dsts, int offset, int length)
 412         throws IOException
 413     {
 414         Objects.checkFromIndexSize(offset, length, dsts.length);
 415 
 416         readLock.lock();
 417         try {
 418             boolean blocking = isBlocking();
 419             long n = 0;
 420             try {
 421                 beginRead(blocking);
 422 
 423                 // check if connection has been reset
 424                 if (connectionReset)
 425                     throwConnectionReset();
 426 
 427                 // check if input is shutdown
 428                 if (isInputClosed)
 429                     return IOStatus.EOF;
 430 
 431                 n = IOUtil.read(fd, dsts, offset, length, nd);
 432                 if (blocking) {
 433                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 434                         park(Net.POLLIN);
 435                         n = IOUtil.read(fd, dsts, offset, length, nd);
 436                     }
 437                 }
 438             } catch (ConnectionResetException e) {
 439                 connectionReset = true;
 440                 throwConnectionReset();
 441             } finally {
 442                 endRead(blocking, n &gt; 0);
 443                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 444                     return IOStatus.EOF;
 445             }
 446             return IOStatus.normalize(n);
 447         } finally {
 448             readLock.unlock();
 449         }
 450     }
 451 
 452     /**
 453      * Marks the beginning of a write operation that might block.
 454      *
 455      * @throws ClosedChannelException if the channel is closed or output shutdown
 456      * @throws NotYetConnectedException if the channel is not yet connected
 457      */
 458     private void beginWrite(boolean blocking) throws ClosedChannelException {
 459         if (blocking) {
 460             // set hook for Thread.interrupt
 461             begin();
 462 
 463             synchronized (stateLock) {
 464                 ensureOpenAndConnected();
 465                 if (isOutputClosed)
 466                     throw new ClosedChannelException();
 467                 // record thread so it can be signalled if needed
 468                 writerThread = NativeThread.current();
 469             }
 470         } else {
 471             ensureOpenAndConnected();
 472         }
 473     }
 474 
 475     /**
 476      * Marks the end of a write operation that may have blocked.
 477      *
 478      * @throws AsynchronousCloseException if the channel was closed due to this
 479      * thread being interrupted on a blocking write operation.
 480      */
 481     private void endWrite(boolean blocking, boolean completed)
 482         throws AsynchronousCloseException
 483     {
 484         if (blocking) {
 485             synchronized (stateLock) {
 486                 writerThread = 0;
 487                 if (state == ST_CLOSING) {
 488                     tryFinishClose();
 489                 }
 490             }
 491             // remove hook for Thread.interrupt
 492             end(completed);
 493         }
 494     }
 495 
 496     @Override
 497     public int write(ByteBuffer buf) throws IOException {
 498         Objects.requireNonNull(buf);
 499 
 500         writeLock.lock();
 501         try {
 502             boolean blocking = isBlocking();
 503             int n = 0;
 504             try {
 505                 beginWrite(blocking);
 506                 n = IOUtil.write(fd, buf, -1, nd);
 507                 if (blocking) {
 508                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 509                         park(Net.POLLOUT);
 510                         n = IOUtil.write(fd, buf, -1, nd);
 511                     }
 512                 }
 513             } finally {
 514                 endWrite(blocking, n &gt; 0);
 515                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 516                     throw new AsynchronousCloseException();
 517             }
 518             return IOStatus.normalize(n);
 519         } finally {
 520             writeLock.unlock();
 521         }
 522     }
 523 
 524     @Override
 525     public long write(ByteBuffer[] srcs, int offset, int length)
 526         throws IOException
 527     {
 528         Objects.checkFromIndexSize(offset, length, srcs.length);
 529 
 530         writeLock.lock();
 531         try {
 532             boolean blocking = isBlocking();
 533             long n = 0;
 534             try {
 535                 beginWrite(blocking);
 536                 n = IOUtil.write(fd, srcs, offset, length, nd);
 537                 if (blocking) {
 538                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 539                         park(Net.POLLOUT);
 540                         n = IOUtil.write(fd, srcs, offset, length, nd);
 541                     }
 542                 }
 543             } finally {
 544                 endWrite(blocking, n &gt; 0);
 545                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 546                     throw new AsynchronousCloseException();
 547             }
 548             return IOStatus.normalize(n);
 549         } finally {
 550             writeLock.unlock();
 551         }
 552     }
 553 
 554     /**
 555      * Writes a byte of out of band data.
 556      */
 557     int sendOutOfBandData(byte b) throws IOException {
 558         writeLock.lock();
 559         try {
 560             boolean blocking = isBlocking();
 561             int n = 0;
 562             try {
 563                 beginWrite(blocking);
 564                 if (blocking) {
 565                     do {
 566                         n = Net.sendOOB(fd, b);
 567                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());
 568                 } else {
 569                     n = Net.sendOOB(fd, b);
 570                 }
 571             } finally {
 572                 endWrite(blocking, n &gt; 0);
 573                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 574                     throw new AsynchronousCloseException();
 575             }
 576             return IOStatus.normalize(n);
 577         } finally {
 578             writeLock.unlock();
 579         }
 580     }
 581 
 582     @Override
 583     protected void implConfigureBlocking(boolean block) throws IOException {
 584         readLock.lock();
 585         try {
 586             writeLock.lock();
 587             try {
 588                 lockedConfigureBlocking(block);
 589             } finally {
 590                 writeLock.unlock();
 591             }
 592         } finally {
 593             readLock.unlock();
 594         }
 595     }
 596 
 597     /**
 598      * Adjusts the blocking mode. readLock or writeLock must already be held.
 599      */
 600     private void lockedConfigureBlocking(boolean block) throws IOException {
 601         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();
 602         synchronized (stateLock) {
 603             ensureOpen();
 604             IOUtil.configureBlocking(fd, block);
 605         }
 606     }
 607 
 608     /**
 609      * Adjusts the blocking mode if the channel is open. readLock or writeLock
 610      * must already be held.
 611      *
 612      * @return {@code true} if the blocking mode was adjusted, {@code false} if
 613      *         the blocking mode was not adjusted because the channel is closed
 614      */
 615     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {
 616         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();
 617         synchronized (stateLock) {
 618             if (isOpen()) {
 619                 IOUtil.configureBlocking(fd, block);
 620                 return true;
 621             } else {
 622                 return false;
 623             }
 624         }
 625     }
 626 
 627     /**
 628      * Returns the local address, or null if not bound
 629      */
 630     InetSocketAddress localAddress() {
 631         synchronized (stateLock) {
 632             return localAddress;
 633         }
 634     }
 635 
 636     /**
 637      * Returns the remote address, or null if not connected
 638      */
 639     InetSocketAddress remoteAddress() {
 640         synchronized (stateLock) {
 641             return remoteAddress;
 642         }
 643     }
 644 
 645     @Override
 646     public SocketChannel bind(SocketAddress local) throws IOException {
 647         readLock.lock();
 648         try {
 649             writeLock.lock();
 650             try {
 651                 synchronized (stateLock) {
 652                     ensureOpen();
 653                     if (state == ST_CONNECTIONPENDING)
 654                         throw new ConnectionPendingException();
 655                     if (localAddress != null)
 656                         throw new AlreadyBoundException();
<a name="13" id="anc13"></a><span class="line-modified"> 657                     InetSocketAddress isa;</span>
<span class="line-modified"> 658                     if (local == null) {</span>
<span class="line-added"> 659                         isa = new InetSocketAddress(Net.anyLocalAddress(family), 0);</span>
<span class="line-added"> 660                     } else {</span>
<span class="line-added"> 661                         isa = Net.checkAddress(local, family);</span>
<span class="line-added"> 662                     }</span>
 663                     SecurityManager sm = System.getSecurityManager();
 664                     if (sm != null) {
 665                         sm.checkListen(isa.getPort());
 666                     }
 667                     NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
<a name="14" id="anc14"></a><span class="line-modified"> 668                     Net.bind(family, fd, isa.getAddress(), isa.getPort());</span>
 669                     localAddress = Net.localAddress(fd);
 670                 }
 671             } finally {
 672                 writeLock.unlock();
 673             }
 674         } finally {
 675             readLock.unlock();
 676         }
 677         return this;
 678     }
 679 
 680     @Override
 681     public boolean isConnected() {
 682         return (state == ST_CONNECTED);
 683     }
 684 
 685     @Override
 686     public boolean isConnectionPending() {
 687         return (state == ST_CONNECTIONPENDING);
 688     }
 689 
 690     /**
 691      * Marks the beginning of a connect operation that might block.
 692      * @param blocking true if configured blocking
 693      * @param isa the remote address
 694      * @throws ClosedChannelException if the channel is closed
 695      * @throws AlreadyConnectedException if already connected
 696      * @throws ConnectionPendingException is a connection is pending
 697      * @throws IOException if the pre-connect hook fails
 698      */
 699     private void beginConnect(boolean blocking, InetSocketAddress isa)
 700         throws IOException
 701     {
 702         if (blocking) {
 703             // set hook for Thread.interrupt
 704             begin();
 705         }
 706         synchronized (stateLock) {
 707             ensureOpen();
 708             int state = this.state;
 709             if (state == ST_CONNECTED)
 710                 throw new AlreadyConnectedException();
 711             if (state == ST_CONNECTIONPENDING)
 712                 throw new ConnectionPendingException();
 713             assert state == ST_UNCONNECTED;
 714             this.state = ST_CONNECTIONPENDING;
 715 
 716             if (localAddress == null)
 717                 NetHooks.beforeTcpConnect(fd, isa.getAddress(), isa.getPort());
 718             remoteAddress = isa;
 719 
 720             if (blocking) {
 721                 // record thread so it can be signalled if needed
 722                 readerThread = NativeThread.current();
 723             }
 724         }
 725     }
 726 
 727     /**
 728      * Marks the end of a connect operation that may have blocked.
 729      *
 730      * @throws AsynchronousCloseException if the channel was closed due to this
 731      * thread being interrupted on a blocking connect operation.
 732      * @throws IOException if completed and unable to obtain the local address
 733      */
 734     private void endConnect(boolean blocking, boolean completed)
 735         throws IOException
 736     {
 737         endRead(blocking, completed);
 738 
 739         if (completed) {
 740             synchronized (stateLock) {
 741                 if (state == ST_CONNECTIONPENDING) {
 742                     localAddress = Net.localAddress(fd);
 743                     state = ST_CONNECTED;
 744                 }
 745             }
 746         }
 747     }
 748 
 749     /**
 750      * Checks the remote address to which this channel is to be connected.
 751      */
<a name="15" id="anc15"></a><span class="line-modified"> 752     private InetSocketAddress checkRemote(SocketAddress sa) {</span>
<span class="line-modified"> 753         InetSocketAddress isa = Net.checkAddress(sa, family);</span>
 754         SecurityManager sm = System.getSecurityManager();
 755         if (sm != null) {
 756             sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());
 757         }
<a name="16" id="anc16"></a><span class="line-modified"> 758         InetAddress address = isa.getAddress();</span>
<span class="line-modified"> 759         if (address.isAnyLocalAddress()) {</span>
<span class="line-added"> 760             int port = isa.getPort();</span>
<span class="line-added"> 761             if (address instanceof Inet4Address) {</span>
<span class="line-added"> 762                 return new InetSocketAddress(Net.inet4LoopbackAddress(), port);</span>
<span class="line-added"> 763             } else {</span>
<span class="line-added"> 764                 assert family == StandardProtocolFamily.INET6;</span>
<span class="line-added"> 765                 return new InetSocketAddress(Net.inet6LoopbackAddress(), port);</span>
<span class="line-added"> 766             }</span>
 767         } else {
 768             return isa;
 769         }
 770     }
 771 
 772     @Override
 773     public boolean connect(SocketAddress remote) throws IOException {
 774         InetSocketAddress isa = checkRemote(remote);
 775         try {
 776             readLock.lock();
 777             try {
 778                 writeLock.lock();
 779                 try {
 780                     boolean blocking = isBlocking();
 781                     boolean connected = false;
 782                     try {
 783                         beginConnect(blocking, isa);
<a name="17" id="anc17"></a><span class="line-modified"> 784                         int n = Net.connect(family,</span>
<span class="line-added"> 785                                             fd,</span>
<span class="line-added"> 786                                             isa.getAddress(),</span>
<span class="line-added"> 787                                             isa.getPort());</span>
 788                         if (n &gt; 0) {
 789                             connected = true;
 790                         } else if (blocking) {
 791                             assert IOStatus.okayToRetry(n);
 792                             boolean polled = false;
 793                             while (!polled &amp;&amp; isOpen()) {
 794                                 park(Net.POLLOUT);
 795                                 polled = Net.pollConnectNow(fd);
 796                             }
 797                             connected = polled &amp;&amp; isOpen();
 798                         }
 799                     } finally {
 800                         endConnect(blocking, connected);
 801                     }
 802                     return connected;
 803                 } finally {
 804                     writeLock.unlock();
 805                 }
 806             } finally {
 807                 readLock.unlock();
 808             }
 809         } catch (IOException ioe) {
 810             // connect failed, close the channel
 811             close();
 812             throw SocketExceptions.of(ioe, isa);
 813         }
 814     }
 815 
 816     /**
 817      * Marks the beginning of a finishConnect operation that might block.
 818      *
 819      * @throws ClosedChannelException if the channel is closed
 820      * @throws NoConnectionPendingException if no connection is pending
 821      */
 822     private void beginFinishConnect(boolean blocking) throws ClosedChannelException {
 823         if (blocking) {
 824             // set hook for Thread.interrupt
 825             begin();
 826         }
 827         synchronized (stateLock) {
 828             ensureOpen();
 829             if (state != ST_CONNECTIONPENDING)
 830                 throw new NoConnectionPendingException();
 831             if (blocking) {
 832                 // record thread so it can be signalled if needed
 833                 readerThread = NativeThread.current();
 834             }
 835         }
 836     }
 837 
 838     /**
 839      * Marks the end of a finishConnect operation that may have blocked.
 840      *
 841      * @throws AsynchronousCloseException if the channel was closed due to this
 842      * thread being interrupted on a blocking connect operation.
 843      * @throws IOException if completed and unable to obtain the local address
 844      */
 845     private void endFinishConnect(boolean blocking, boolean completed)
 846         throws IOException
 847     {
 848         endRead(blocking, completed);
 849 
 850         if (completed) {
 851             synchronized (stateLock) {
 852                 if (state == ST_CONNECTIONPENDING) {
 853                     localAddress = Net.localAddress(fd);
 854                     state = ST_CONNECTED;
 855                 }
 856             }
 857         }
 858     }
 859 
 860     @Override
 861     public boolean finishConnect() throws IOException {
 862         try {
 863             readLock.lock();
 864             try {
 865                 writeLock.lock();
 866                 try {
 867                     // no-op if already connected
 868                     if (isConnected())
 869                         return true;
 870 
 871                     boolean blocking = isBlocking();
 872                     boolean connected = false;
 873                     try {
 874                         beginFinishConnect(blocking);
 875                         boolean polled = Net.pollConnectNow(fd);
 876                         if (blocking) {
 877                             while (!polled &amp;&amp; isOpen()) {
 878                                 park(Net.POLLOUT);
 879                                 polled = Net.pollConnectNow(fd);
 880                             }
 881                         }
 882                         connected = polled &amp;&amp; isOpen();
 883                     } finally {
 884                         endFinishConnect(blocking, connected);
 885                     }
 886                     assert (blocking &amp;&amp; connected) ^ !blocking;
 887                     return connected;
 888                 } finally {
 889                     writeLock.unlock();
 890                 }
 891             } finally {
 892                 readLock.unlock();
 893             }
 894         } catch (IOException ioe) {
 895             // connect failed, close the channel
 896             close();
 897             throw SocketExceptions.of(ioe, remoteAddress);
 898         }
 899     }
 900 
 901     /**
 902      * Closes the socket if there are no I/O operations in progress and the
 903      * channel is not registered with a Selector.
 904      */
 905     private boolean tryClose() throws IOException {
 906         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;
 907         if ((readerThread == 0) &amp;&amp; (writerThread == 0) &amp;&amp; !isRegistered()) {
 908             state = ST_CLOSED;
 909             nd.close(fd);
 910             return true;
 911         } else {
 912             return false;
 913         }
 914     }
 915 
 916     /**
 917      * Invokes tryClose to attempt to close the socket.
 918      *
 919      * This method is used for deferred closing by I/O and Selector operations.
 920      */
 921     private void tryFinishClose() {
 922         try {
 923             tryClose();
 924         } catch (IOException ignore) { }
 925     }
 926 
 927     /**
 928      * Closes this channel when configured in blocking mode.
 929      *
 930      * If there is an I/O operation in progress then the socket is pre-closed
 931      * and the I/O threads signalled, in which case the final close is deferred
 932      * until all I/O operations complete.
 933      *
 934      * Note that a channel configured blocking may be registered with a Selector
 935      * This arises when a key is canceled and the channel configured to blocking
 936      * mode before the key is flushed from the Selector.
 937      */
 938     private void implCloseBlockingMode() throws IOException {
 939         synchronized (stateLock) {
 940             assert state &lt; ST_CLOSING;
 941             state = ST_CLOSING;
 942             if (!tryClose()) {
 943                 long reader = readerThread;
 944                 long writer = writerThread;
 945                 if (reader != 0 || writer != 0) {
 946                     nd.preClose(fd);
 947                     if (reader != 0)
 948                         NativeThread.signal(reader);
 949                     if (writer != 0)
 950                         NativeThread.signal(writer);
 951                 }
 952             }
 953         }
 954     }
 955 
 956     /**
 957      * Closes this channel when configured in non-blocking mode.
 958      *
 959      * If the channel is registered with a Selector then the close is deferred
 960      * until the channel is flushed from all Selectors.
 961      *
 962      * If the socket is connected and the channel is registered with a Selector
 963      * then the socket is shutdown for writing so that the peer reads EOF. In
 964      * addition, if SO_LINGER is set to a non-zero value then it is disabled so
 965      * that the deferred close does not wait.
 966      */
 967     private void implCloseNonBlockingMode() throws IOException {
 968         boolean connected;
 969         synchronized (stateLock) {
 970             assert state &lt; ST_CLOSING;
 971             connected = (state == ST_CONNECTED);
 972             state = ST_CLOSING;
 973         }
 974 
 975         // wait for any read/write operations to complete
 976         readLock.lock();
 977         readLock.unlock();
 978         writeLock.lock();
 979         writeLock.unlock();
 980 
 981         // if the socket cannot be closed because it&#39;s registered with a Selector
 982         // then shutdown the socket for writing.
 983         synchronized (stateLock) {
 984             if (state == ST_CLOSING &amp;&amp; !tryClose() &amp;&amp; connected &amp;&amp; isRegistered()) {
 985                 try {
 986                     SocketOption&lt;Integer&gt; opt = StandardSocketOptions.SO_LINGER;
 987                     int interval = (int) Net.getSocketOption(fd, Net.UNSPEC, opt);
 988                     if (interval != 0) {
 989                         if (interval &gt; 0) {
 990                             // disable SO_LINGER
 991                             Net.setSocketOption(fd, Net.UNSPEC, opt, -1);
 992                         }
 993                         Net.shutdown(fd, Net.SHUT_WR);
 994                     }
 995                 } catch (IOException ignore) { }
 996             }
 997         }
 998     }
 999 
1000     /**
1001      * Invoked by implCloseChannel to close the channel.
1002      */
1003     @Override
1004     protected void implCloseSelectableChannel() throws IOException {
1005         assert !isOpen();
1006         if (isBlocking()) {
1007             implCloseBlockingMode();
1008         } else {
1009             implCloseNonBlockingMode();
1010         }
1011     }
1012 
1013     @Override
1014     public void kill() {
1015         synchronized (stateLock) {
1016             if (state == ST_CLOSING) {
1017                 tryFinishClose();
1018             }
1019         }
1020     }
1021 
1022     @Override
1023     public SocketChannel shutdownInput() throws IOException {
1024         synchronized (stateLock) {
1025             ensureOpen();
1026             if (!isConnected())
1027                 throw new NotYetConnectedException();
1028             if (!isInputClosed) {
1029                 Net.shutdown(fd, Net.SHUT_RD);
1030                 long thread = readerThread;
1031                 if (thread != 0)
1032                     NativeThread.signal(thread);
1033                 isInputClosed = true;
1034             }
1035             return this;
1036         }
1037     }
1038 
1039     @Override
1040     public SocketChannel shutdownOutput() throws IOException {
1041         synchronized (stateLock) {
1042             ensureOpen();
1043             if (!isConnected())
1044                 throw new NotYetConnectedException();
1045             if (!isOutputClosed) {
1046                 Net.shutdown(fd, Net.SHUT_WR);
1047                 long thread = writerThread;
1048                 if (thread != 0)
1049                     NativeThread.signal(thread);
1050                 isOutputClosed = true;
1051             }
1052             return this;
1053         }
1054     }
1055 
1056     boolean isInputOpen() {
1057         return !isInputClosed;
1058     }
1059 
1060     boolean isOutputOpen() {
1061         return !isOutputClosed;
1062     }
1063 
1064     /**
1065      * Waits for a connection attempt to finish with a timeout
1066      * @throws SocketTimeoutException if the connect timeout elapses
1067      */
1068     private boolean finishTimedConnect(long nanos) throws IOException {
1069         long startNanos = System.nanoTime();
1070         boolean polled = Net.pollConnectNow(fd);
1071         while (!polled &amp;&amp; isOpen()) {
1072             long remainingNanos = nanos - (System.nanoTime() - startNanos);
1073             if (remainingNanos &lt;= 0) {
1074                 throw new SocketTimeoutException(&quot;Connect timed out&quot;);
1075             }
1076             park(Net.POLLOUT, remainingNanos);
1077             polled = Net.pollConnectNow(fd);
1078         }
1079         return polled &amp;&amp; isOpen();
1080     }
1081 
1082     /**
1083      * Attempts to establish a connection to the given socket address with a
1084      * timeout. Closes the socket if connection cannot be established.
1085      *
1086      * @apiNote This method is for use by the socket adaptor.
1087      *
1088      * @throws IllegalBlockingModeException if the channel is non-blocking
1089      * @throws SocketTimeoutException if the read timeout elapses
1090      */
1091     void blockingConnect(SocketAddress remote, long nanos) throws IOException {
1092         InetSocketAddress isa = checkRemote(remote);
1093         try {
1094             readLock.lock();
1095             try {
1096                 writeLock.lock();
1097                 try {
1098                     if (!isBlocking())
1099                         throw new IllegalBlockingModeException();
1100                     boolean connected = false;
1101                     try {
1102                         beginConnect(true, isa);
1103                         // change socket to non-blocking
1104                         lockedConfigureBlocking(false);
1105                         try {
1106                             int n = Net.connect(fd, isa.getAddress(), isa.getPort());
1107                             connected = (n &gt; 0) ? true : finishTimedConnect(nanos);
1108                         } finally {
1109                             // restore socket to blocking mode (if channel is open)
1110                             tryLockedConfigureBlocking(true);
1111                         }
1112                     } finally {
1113                         endConnect(true, connected);
1114                     }
1115                 } finally {
1116                     writeLock.unlock();
1117                 }
1118             } finally {
1119                 readLock.unlock();
1120             }
1121         } catch (IOException ioe) {
1122             // connect failed, close the channel
1123             close();
1124             throw SocketExceptions.of(ioe, isa);
1125         }
1126     }
1127 
1128     /**
1129      * Attempts to read bytes from the socket into the given byte array.
1130      */
1131     private int tryRead(byte[] b, int off, int len) throws IOException {
1132         ByteBuffer dst = Util.getTemporaryDirectBuffer(len);
1133         assert dst.position() == 0;
1134         try {
1135             int n = nd.read(fd, ((DirectBuffer)dst).address(), len);
1136             if (n &gt; 0) {
1137                 dst.get(b, off, n);
1138             }
1139             return n;
1140         } finally{
1141             Util.offerFirstTemporaryDirectBuffer(dst);
1142         }
1143     }
1144 
1145     /**
1146      * Reads bytes from the socket into the given byte array with a timeout.
1147      * @throws SocketTimeoutException if the read timeout elapses
1148      */
1149     private int timedRead(byte[] b, int off, int len, long nanos) throws IOException {
1150         long startNanos = System.nanoTime();
1151         int n = tryRead(b, off, len);
1152         while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {
1153             long remainingNanos = nanos - (System.nanoTime() - startNanos);
1154             if (remainingNanos &lt;= 0) {
1155                 throw new SocketTimeoutException(&quot;Read timed out&quot;);
1156             }
1157             park(Net.POLLIN, remainingNanos);
1158             n = tryRead(b, off, len);
1159         }
1160         return n;
1161     }
1162 
1163     /**
1164      * Reads bytes from the socket into the given byte array.
1165      *
1166      * @apiNote This method is for use by the socket adaptor.
1167      *
1168      * @throws IllegalBlockingModeException if the channel is non-blocking
1169      * @throws SocketTimeoutException if the read timeout elapses
1170      */
1171     int blockingRead(byte[] b, int off, int len, long nanos) throws IOException {
1172         Objects.checkFromIndexSize(off, len, b.length);
1173         if (len == 0) {
1174             // nothing to do
1175             return 0;
1176         }
1177 
1178         readLock.lock();
1179         try {
1180             // check that channel is configured blocking
1181             if (!isBlocking())
1182                 throw new IllegalBlockingModeException();
1183 
1184             int n = 0;
1185             try {
1186                 beginRead(true);
1187 
1188                 // check if connection has been reset
1189                 if (connectionReset)
1190                     throwConnectionReset();
1191 
1192                 // check if input is shutdown
1193                 if (isInputClosed)
1194                     return IOStatus.EOF;
1195 
1196                 if (nanos &gt; 0) {
1197                     // change socket to non-blocking
1198                     lockedConfigureBlocking(false);
1199                     try {
1200                         n = timedRead(b, off, len, nanos);
1201                     } finally {
1202                         // restore socket to blocking mode (if channel is open)
1203                         tryLockedConfigureBlocking(true);
1204                     }
1205                 } else {
1206                     // read, no timeout
1207                     n = tryRead(b, off, len);
1208                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
1209                         park(Net.POLLIN);
1210                         n = tryRead(b, off, len);
1211                     }
1212                 }
1213             } catch (ConnectionResetException e) {
1214                 connectionReset = true;
1215                 throwConnectionReset();
1216             } finally {
1217                 endRead(true, n &gt; 0);
1218                 if (n &lt;= 0 &amp;&amp; isInputClosed)
1219                     return IOStatus.EOF;
1220             }
1221             assert n &gt; 0 || n == -1;
1222             return n;
1223         } finally {
1224             readLock.unlock();
1225         }
1226     }
1227 
1228     /**
1229      * Attempts to write a sequence of bytes to the socket from the given
1230      * byte array.
1231      */
1232     private int tryWrite(byte[] b, int off, int len) throws IOException {
1233         ByteBuffer src = Util.getTemporaryDirectBuffer(len);
1234         assert src.position() == 0;
1235         try {
1236             src.put(b, off, len);
1237             return nd.write(fd, ((DirectBuffer)src).address(), len);
1238         } finally {
1239             Util.offerFirstTemporaryDirectBuffer(src);
1240         }
1241     }
1242 
1243     /**
1244      * Writes a sequence of bytes to the socket from the given byte array.
1245      *
1246      * @apiNote This method is for use by the socket adaptor.
1247      */
1248     void blockingWriteFully(byte[] b, int off, int len) throws IOException {
1249         Objects.checkFromIndexSize(off, len, b.length);
1250         if (len == 0) {
1251             // nothing to do
1252             return;
1253         }
1254 
1255         writeLock.lock();
1256         try {
1257             // check that channel is configured blocking
1258             if (!isBlocking())
1259                 throw new IllegalBlockingModeException();
1260 
1261             // loop until all bytes have been written
1262             int pos = off;
1263             int end = off + len;
1264             beginWrite(true);
1265             try {
1266                 while (pos &lt; end &amp;&amp; isOpen()) {
1267                     int size = end - pos;
1268                     int n = tryWrite(b, pos, size);
1269                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
1270                         park(Net.POLLOUT);
1271                         n = tryWrite(b, pos, size);
1272                     }
1273                     if (n &gt; 0) {
1274                         pos += n;
1275                     }
1276                 }
1277             } finally {
1278                 endWrite(true, pos &gt;= end);
1279             }
1280         } finally {
1281             writeLock.unlock();
1282         }
1283     }
1284 
1285     /**
1286      * Return the number of bytes in the socket input buffer.
1287      */
1288     int available() throws IOException {
1289         synchronized (stateLock) {
1290             ensureOpenAndConnected();
1291             if (isInputClosed) {
1292                 return 0;
1293             } else {
1294                 return Net.available(fd);
1295             }
1296         }
1297     }
1298 
1299     /**
1300      * Translates native poll revent ops into a ready operation ops
1301      */
1302     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1303         int intOps = ski.nioInterestOps();
1304         int oldOps = ski.nioReadyOps();
1305         int newOps = initialOps;
1306 
1307         if ((ops &amp; Net.POLLNVAL) != 0) {
1308             // This should only happen if this channel is pre-closed while a
1309             // selection operation is in progress
1310             // ## Throw an error if this channel has not been pre-closed
1311             return false;
1312         }
1313 
1314         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1315             newOps = intOps;
1316             ski.nioReadyOps(newOps);
1317             return (newOps &amp; ~oldOps) != 0;
1318         }
1319 
1320         boolean connected = isConnected();
1321         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
1322             ((intOps &amp; SelectionKey.OP_READ) != 0) &amp;&amp; connected)
1323             newOps |= SelectionKey.OP_READ;
1324 
1325         if (((ops &amp; Net.POLLCONN) != 0) &amp;&amp;
1326             ((intOps &amp; SelectionKey.OP_CONNECT) != 0) &amp;&amp; isConnectionPending())
1327             newOps |= SelectionKey.OP_CONNECT;
1328 
1329         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
1330             ((intOps &amp; SelectionKey.OP_WRITE) != 0) &amp;&amp; connected)
1331             newOps |= SelectionKey.OP_WRITE;
1332 
1333         ski.nioReadyOps(newOps);
1334         return (newOps &amp; ~oldOps) != 0;
1335     }
1336 
1337     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
1338         return translateReadyOps(ops, ski.nioReadyOps(), ski);
1339     }
1340 
1341     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
1342         return translateReadyOps(ops, 0, ski);
1343     }
1344 
1345     /**
1346      * Translates an interest operation set into a native poll event set
1347      */
1348     public int translateInterestOps(int ops) {
1349         int newOps = 0;
1350         if ((ops &amp; SelectionKey.OP_READ) != 0)
1351             newOps |= Net.POLLIN;
1352         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
1353             newOps |= Net.POLLOUT;
1354         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
1355             newOps |= Net.POLLCONN;
1356         return newOps;
1357     }
1358 
1359     public FileDescriptor getFD() {
1360         return fd;
1361     }
1362 
1363     public int getFDVal() {
1364         return fdVal;
1365     }
1366 
1367     @Override
1368     public String toString() {
1369         StringBuilder sb = new StringBuilder();
1370         sb.append(this.getClass().getSuperclass().getName());
1371         sb.append(&#39;[&#39;);
1372         if (!isOpen())
1373             sb.append(&quot;closed&quot;);
1374         else {
1375             synchronized (stateLock) {
1376                 switch (state) {
1377                 case ST_UNCONNECTED:
1378                     sb.append(&quot;unconnected&quot;);
1379                     break;
1380                 case ST_CONNECTIONPENDING:
1381                     sb.append(&quot;connection-pending&quot;);
1382                     break;
1383                 case ST_CONNECTED:
1384                     sb.append(&quot;connected&quot;);
1385                     if (isInputClosed)
1386                         sb.append(&quot; ishut&quot;);
1387                     if (isOutputClosed)
1388                         sb.append(&quot; oshut&quot;);
1389                     break;
1390                 }
1391                 InetSocketAddress addr = localAddress();
1392                 if (addr != null) {
1393                     sb.append(&quot; local=&quot;);
1394                     sb.append(Net.getRevealedLocalAddressAsString(addr));
1395                 }
1396                 if (remoteAddress() != null) {
1397                     sb.append(&quot; remote=&quot;);
1398                     sb.append(remoteAddress().toString());
1399                 }
1400             }
1401         }
1402         sb.append(&#39;]&#39;);
1403         return sb.toString();
1404     }
1405 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
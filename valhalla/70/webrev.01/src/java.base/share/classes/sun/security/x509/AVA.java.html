<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/x509/AVA.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.ByteArrayOutputStream;
  29 import java.io.IOException;
  30 import java.io.OutputStream;
  31 import java.io.Reader;
  32 import java.security.AccessController;
  33 import java.text.Normalizer;
  34 import java.util.*;
  35 
  36 import static java.nio.charset.StandardCharsets.UTF_8;
  37 
  38 import sun.security.action.GetBooleanAction;
  39 import sun.security.util.*;
  40 import sun.security.pkcs.PKCS9Attribute;
  41 
  42 
  43 /**
  44  * X.500 Attribute-Value-Assertion (AVA):  an attribute, as identified by
  45  * some attribute ID, has some particular value.  Values are as a rule ASN.1
  46  * printable strings.  A conventional set of type IDs is recognized when
  47  * parsing (and generating) RFC 1779, 2253 or 4514 syntax strings.
  48  *
  49  * &lt;P&gt;AVAs are components of X.500 relative names.  Think of them as being
  50  * individual fields of a database record.  The attribute ID is how you
  51  * identify the field, and the value is part of a particular record.
  52  * &lt;p&gt;
  53  * Note that instances of this class are immutable.
  54  *
  55  * @see X500Name
  56  * @see RDN
  57  *
  58  *
  59  * @author David Brownell
  60  * @author Amit Kapoor
  61  * @author Hemma Prafullchandra
  62  */
  63 public class AVA implements DerEncoder {
  64 
  65     private static final Debug debug = Debug.getInstance(&quot;x509&quot;, &quot;\t[AVA]&quot;);
  66     // See CR 6391482: if enabled this flag preserves the old but incorrect
  67     // PrintableString encoding for DomainComponent. It may need to be set to
  68     // avoid breaking preexisting certificates generated with sun.security APIs.
  69     private static final boolean PRESERVE_OLD_DC_ENCODING = GetBooleanAction
  70             .privilegedGetProperty(&quot;com.sun.security.preserveOldDCEncoding&quot;);
  71 
  72     /**
  73      * DEFAULT format allows both RFC1779 and RFC2253 syntax and
  74      * additional keywords.
  75      */
  76     static final int DEFAULT = 1;
  77     /**
  78      * RFC1779 specifies format according to RFC1779.
  79      */
  80     static final int RFC1779 = 2;
  81     /**
  82      * RFC2253 specifies format according to RFC2253.
  83      */
  84     static final int RFC2253 = 3;
  85 
  86     // currently not private, accessed directly from RDN
  87     final ObjectIdentifier oid;
  88     final DerValue value;
  89 
  90     /*
  91      * If the value has any of these characters in it, it must be quoted.
  92      * Backslash and quote characters must also be individually escaped.
  93      * Leading and trailing spaces, also multiple internal spaces, also
  94      * call for quoting the whole string.
  95      */
  96     private static final String specialChars1779 = &quot;,=\n+&lt;&gt;#;\\\&quot;&quot;;
  97 
  98     /*
  99      * In RFC2253, if the value has any of these characters in it, it
 100      * must be quoted by a preceding \.
 101      */
 102     private static final String specialChars2253 = &quot;,=+&lt;&gt;#;\\\&quot;&quot;;
 103 
 104     /*
 105      * includes special chars from RFC1779 and RFC2253, as well as &#39; &#39; from
 106      * RFC 4514.
 107      */
 108     private static final String specialCharsDefault = &quot;,=\n+&lt;&gt;#;\\\&quot; &quot;;
 109     private static final String escapedDefault = &quot;,+&lt;&gt;;\&quot;&quot;;
 110 
 111     /*
 112      * Values that aren&#39;t printable strings are emitted as BER-encoded
 113      * hex data.
 114      */
 115     private static final String hexDigits = &quot;0123456789ABCDEF&quot;;
 116 
 117     public AVA(ObjectIdentifier type, DerValue val) {
 118         if ((type == null) || (val == null)) {
 119             throw new NullPointerException();
 120         }
 121         oid = type;
 122         value = val;
 123     }
 124 
 125     /**
 126      * Parse an RFC 1779, 2253 or 4514 style AVA string:  CN=fee fie foe fum
 127      * or perhaps with quotes.  Not all defined AVA tags are supported;
 128      * of current note are X.400 related ones (PRMD, ADMD, etc).
 129      *
 130      * This terminates at unescaped AVA separators (&quot;+&quot;) or RDN
 131      * separators (&quot;,&quot;, &quot;;&quot;), and removes cosmetic whitespace at the end of
 132      * values.
 133      */
 134     AVA(Reader in) throws IOException {
 135         this(in, DEFAULT);
 136     }
 137 
 138     /**
 139      * Parse an RFC 1779, 2253 or 4514 style AVA string:  CN=fee fie foe fum
 140      * or perhaps with quotes. Additional keywords can be specified in the
 141      * keyword/OID map.
 142      *
 143      * This terminates at unescaped AVA separators (&quot;+&quot;) or RDN
 144      * separators (&quot;,&quot;, &quot;;&quot;), and removes cosmetic whitespace at the end of
 145      * values.
 146      */
 147     AVA(Reader in, Map&lt;String, String&gt; keywordMap) throws IOException {
 148         this(in, DEFAULT, keywordMap);
 149     }
 150 
 151     /**
 152      * Parse an AVA string formatted according to format.
 153      */
 154     AVA(Reader in, int format) throws IOException {
 155         this(in, format, Collections.&lt;String, String&gt;emptyMap());
 156     }
 157 
 158     /**
 159      * Parse an AVA string formatted according to format.
 160      *
 161      * @param in Reader containing AVA String
 162      * @param format parsing format
 163      * @param keywordMap a Map where a keyword String maps to a corresponding
 164      *   OID String. Each AVA keyword will be mapped to the corresponding OID.
 165      *   If an entry does not exist, it will fallback to the builtin
 166      *   keyword/OID mapping.
 167      * @throws IOException if the AVA String is not valid in the specified
 168      *   format or an OID String from the keywordMap is improperly formatted
 169      */
 170     AVA(Reader in, int format, Map&lt;String, String&gt; keywordMap)
 171         throws IOException {
 172         // assume format is one of DEFAULT or RFC2253
 173 
 174         StringBuilder   temp = new StringBuilder();
 175         int             c;
 176 
 177         /*
 178          * First get the keyword indicating the attribute&#39;s type,
 179          * and map it to the appropriate OID.
 180          */
 181         while (true) {
 182             c = readChar(in, &quot;Incorrect AVA format&quot;);
 183             if (c == &#39;=&#39;) {
 184                 break;
 185             }
 186             temp.append((char)c);
 187         }
 188 
 189         oid = AVAKeyword.getOID(temp.toString(), format, keywordMap);
 190 
 191         /*
 192          * Now parse the value.  &quot;#hex&quot;, a quoted string, or a string
 193          * terminated by &quot;+&quot;, &quot;,&quot;, &quot;;&quot;.  Whitespace before or after
 194          * the value is stripped away unless format is RFC2253.
 195          */
 196         temp.setLength(0);
 197         if (format == RFC2253) {
 198             // read next character
 199             c = in.read();
 200             if (c == &#39; &#39;) {
 201                 throw new IOException(&quot;Incorrect AVA RFC2253 format - &quot; +
 202                                       &quot;leading space must be escaped&quot;);
 203             }
 204         } else {
 205             // read next character skipping whitespace
 206             do {
 207                 c = in.read();
 208             } while ((c == &#39; &#39;) || (c == &#39;\n&#39;));
 209         }
 210         if (c == -1) {
 211             // empty value
 212             value = new DerValue(&quot;&quot;);
 213             return;
 214         }
 215 
 216         if (c == &#39;#&#39;) {
 217             value = parseHexString(in, format);
 218         } else if ((c == &#39;&quot;&#39;) &amp;&amp; (format != RFC2253)) {
 219             value = parseQuotedString(in, temp);
 220         } else {
 221             value = parseString(in, c, format, temp);
 222         }
 223     }
 224 
 225     /**
 226      * Get the ObjectIdentifier of this AVA.
 227      */
 228     public ObjectIdentifier getObjectIdentifier() {
 229         return oid;
 230     }
 231 
 232     /**
 233      * Get the value of this AVA as a DerValue.
 234      */
 235     public DerValue getDerValue() {
 236         return value;
 237     }
 238 
 239     /**
 240      * Get the value of this AVA as a String.
 241      *
 242      * @exception RuntimeException if we could not obtain the string form
 243      *    (should not occur)
 244      */
 245     public String getValueString() {
 246         try {
 247             String s = value.getAsString();
 248             if (s == null) {
 249                 throw new RuntimeException(&quot;AVA string is null&quot;);
 250             }
 251             return s;
 252         } catch (IOException e) {
 253             // should not occur
 254             throw new RuntimeException(&quot;AVA error: &quot; + e, e);
 255         }
 256     }
 257 
 258     private static DerValue parseHexString
 259         (Reader in, int format) throws IOException {
 260 
 261         int c;
 262         ByteArrayOutputStream baos = new ByteArrayOutputStream();
 263         byte b = 0;
 264         int cNdx = 0;
 265         while (true) {
 266             c = in.read();
 267 
 268             if (isTerminator(c, format)) {
 269                 break;
 270             }
 271 
 272             int cVal = hexDigits.indexOf(Character.toUpperCase((char)c));
 273 
 274             if (cVal == -1) {
 275                 throw new IOException(&quot;AVA parse, invalid hex &quot; +
 276                                               &quot;digit: &quot;+ (char)c);
 277             }
 278 
 279             if ((cNdx % 2) == 1) {
 280                 b = (byte)((b * 16) + (byte)(cVal));
 281                 baos.write(b);
 282             } else {
 283                 b = (byte)(cVal);
 284             }
 285             cNdx++;
 286         }
 287 
 288         // throw exception if no hex digits
 289         if (cNdx == 0) {
 290             throw new IOException(&quot;AVA parse, zero hex digits&quot;);
 291         }
 292 
 293         // throw exception if odd number of hex digits
 294         if (cNdx % 2 == 1) {
 295             throw new IOException(&quot;AVA parse, odd number of hex digits&quot;);
 296         }
 297 
 298         return new DerValue(baos.toByteArray());
 299     }
 300 
 301     private DerValue parseQuotedString
 302         (Reader in, StringBuilder temp) throws IOException {
 303 
 304         // RFC1779 specifies that an entire RDN may be enclosed in double
 305         // quotes. In this case the syntax is any sequence of
 306         // backslash-specialChar, backslash-backslash,
 307         // backslash-doublequote, or character other than backslash or
 308         // doublequote.
 309         int c = readChar(in, &quot;Quoted string did not end in quote&quot;);
 310 
 311         List&lt;Byte&gt; embeddedHex = new ArrayList&lt;&gt;();
 312         boolean isPrintableString = true;
 313         while (c != &#39;&quot;&#39;) {
 314             if (c == &#39;\\&#39;) {
 315                 c = readChar(in, &quot;Quoted string did not end in quote&quot;);
 316 
 317                 // check for embedded hex pairs
 318                 Byte hexByte = null;
 319                 if ((hexByte = getEmbeddedHexPair(c, in)) != null) {
 320 
 321                     // always encode AVAs with embedded hex as UTF8
 322                     isPrintableString = false;
 323 
 324                     // append consecutive embedded hex
 325                     // as single string later
 326                     embeddedHex.add(hexByte);
 327                     c = in.read();
 328                     continue;
 329                 }
 330 
 331                 if (specialChars1779.indexOf((char)c) &lt; 0) {
 332                     throw new IOException
 333                         (&quot;Invalid escaped character in AVA: &quot; +
 334                         (char)c);
 335                 }
 336             }
 337 
 338             // add embedded hex bytes before next char
 339             if (embeddedHex.size() &gt; 0) {
 340                 String hexString = getEmbeddedHexString(embeddedHex);
 341                 temp.append(hexString);
 342                 embeddedHex.clear();
 343             }
 344 
 345             // check for non-PrintableString chars
 346             isPrintableString &amp;= DerValue.isPrintableStringChar((char)c);
 347             temp.append((char)c);
 348             c = readChar(in, &quot;Quoted string did not end in quote&quot;);
 349         }
 350 
 351         // add trailing embedded hex bytes
 352         if (embeddedHex.size() &gt; 0) {
 353             String hexString = getEmbeddedHexString(embeddedHex);
 354             temp.append(hexString);
 355             embeddedHex.clear();
 356         }
 357 
 358         do {
 359             c = in.read();
 360         } while ((c == &#39;\n&#39;) || (c == &#39; &#39;));
 361         if (c != -1) {
 362             throw new IOException(&quot;AVA had characters other than &quot;
 363                     + &quot;whitespace after terminating quote&quot;);
 364         }
 365 
 366         // encode as PrintableString unless value contains
 367         // non-PrintableString chars
 368         if (this.oid.equals(PKCS9Attribute.EMAIL_ADDRESS_OID) ||
 369             (this.oid.equals(X500Name.DOMAIN_COMPONENT_OID) &amp;&amp;
 370                 PRESERVE_OLD_DC_ENCODING == false)) {
 371             // EmailAddress and DomainComponent must be IA5String
 372             return new DerValue(DerValue.tag_IA5String,
 373                                         temp.toString().trim());
 374         } else if (isPrintableString) {
 375             return new DerValue(temp.toString().trim());
 376         } else {
 377             return new DerValue(DerValue.tag_UTF8String,
 378                                         temp.toString().trim());
 379         }
 380     }
 381 
 382     private DerValue parseString
 383         (Reader in, int c, int format, StringBuilder temp) throws IOException {
 384 
 385         List&lt;Byte&gt; embeddedHex = new ArrayList&lt;&gt;();
 386         boolean isPrintableString = true;
 387         boolean escape = false;
 388         boolean leadingChar = true;
 389         int spaceCount = 0;
 390         do {
 391             escape = false;
 392             if (c == &#39;\\&#39;) {
 393                 escape = true;
 394                 c = readChar(in, &quot;Invalid trailing backslash&quot;);
 395 
 396                 // check for embedded hex pairs
 397                 Byte hexByte = null;
 398                 if ((hexByte = getEmbeddedHexPair(c, in)) != null) {
 399 
 400                     // always encode AVAs with embedded hex as UTF8
 401                     isPrintableString = false;
 402 
 403                     // append consecutive embedded hex
 404                     // as single string later
 405                     embeddedHex.add(hexByte);
 406                     c = in.read();
 407                     leadingChar = false;
 408                     continue;
 409                 }
 410 
 411                 // check if character was improperly escaped
 412                 if (format == DEFAULT &amp;&amp;
 413                        specialCharsDefault.indexOf((char)c) == -1) {
 414                     throw new IOException
 415                         (&quot;Invalid escaped character in AVA: &#39;&quot; +
 416                         (char)c + &quot;&#39;&quot;);
 417                 } else if (format == RFC2253) {
 418                     if (c == &#39; &#39;) {
 419                         // only leading/trailing space can be escaped
 420                         if (!leadingChar &amp;&amp; !trailingSpace(in)) {
 421                             throw new IOException
 422                                     (&quot;Invalid escaped space character &quot; +
 423                                     &quot;in AVA.  Only a leading or trailing &quot; +
 424                                     &quot;space character can be escaped.&quot;);
 425                         }
 426                     } else if (c == &#39;#&#39;) {
 427                         // only leading &#39;#&#39; can be escaped
 428                         if (!leadingChar) {
 429                             throw new IOException
 430                                 (&quot;Invalid escaped &#39;#&#39; character in AVA.  &quot; +
 431                                 &quot;Only a leading &#39;#&#39; can be escaped.&quot;);
 432                         }
 433                     } else if (specialChars2253.indexOf((char)c) == -1) {
 434                         throw new IOException
 435                                 (&quot;Invalid escaped character in AVA: &#39;&quot; +
 436                                 (char)c + &quot;&#39;&quot;);
 437                     }
 438                 }
 439             } else {
 440                 // check if character should have been escaped
 441                 if (format == RFC2253) {
 442                     if (specialChars2253.indexOf((char)c) != -1) {
 443                         throw new IOException
 444                                 (&quot;Character &#39;&quot; + (char)c +
 445                                  &quot;&#39; in AVA appears without escape&quot;);
 446                     }
 447                 } else if (escapedDefault.indexOf((char)c) != -1) {
 448                     throw new IOException
 449                             (&quot;Character &#39;&quot; + (char)c +
 450                             &quot;&#39; in AVA appears without escape&quot;);
 451                 }
 452             }
 453 
 454             // add embedded hex bytes before next char
 455             if (embeddedHex.size() &gt; 0) {
 456                 // add space(s) before embedded hex bytes
 457                 for (int i = 0; i &lt; spaceCount; i++) {
 458                     temp.append(&#39; &#39;);
 459                 }
 460                 spaceCount = 0;
 461 
 462                 String hexString = getEmbeddedHexString(embeddedHex);
 463                 temp.append(hexString);
 464                 embeddedHex.clear();
 465             }
 466 
 467             // check for non-PrintableString chars
 468             isPrintableString &amp;= DerValue.isPrintableStringChar((char)c);
 469             if (c == &#39; &#39; &amp;&amp; escape == false) {
 470                 // do not add non-escaped spaces yet
 471                 // (non-escaped trailing spaces are ignored)
 472                 spaceCount++;
 473             } else {
 474                 // add space(s)
 475                 for (int i = 0; i &lt; spaceCount; i++) {
 476                     temp.append(&#39; &#39;);
 477                 }
 478                 spaceCount = 0;
 479                 temp.append((char)c);
 480             }
 481             c = in.read();
 482             leadingChar = false;
 483         } while (isTerminator(c, format) == false);
 484 
 485         if (format == RFC2253 &amp;&amp; spaceCount &gt; 0) {
 486             throw new IOException(&quot;Incorrect AVA RFC2253 format - &quot; +
 487                                         &quot;trailing space must be escaped&quot;);
 488         }
 489 
 490         // add trailing embedded hex bytes
 491         if (embeddedHex.size() &gt; 0) {
 492             String hexString = getEmbeddedHexString(embeddedHex);
 493             temp.append(hexString);
 494             embeddedHex.clear();
 495         }
 496 
 497         // encode as PrintableString unless value contains
 498         // non-PrintableString chars
 499         if (this.oid.equals(PKCS9Attribute.EMAIL_ADDRESS_OID) ||
 500             (this.oid.equals(X500Name.DOMAIN_COMPONENT_OID) &amp;&amp;
 501                 PRESERVE_OLD_DC_ENCODING == false)) {
 502             // EmailAddress and DomainComponent must be IA5String
 503             return new DerValue(DerValue.tag_IA5String, temp.toString());
 504         } else if (isPrintableString) {
 505             return new DerValue(temp.toString());
 506         } else {
 507             return new DerValue(DerValue.tag_UTF8String, temp.toString());
 508         }
 509     }
 510 
 511     private static Byte getEmbeddedHexPair(int c1, Reader in)
 512         throws IOException {
 513 
 514         if (hexDigits.indexOf(Character.toUpperCase((char)c1)) &gt;= 0) {
 515             int c2 = readChar(in, &quot;unexpected EOF - &quot; +
 516                         &quot;escaped hex value must include two valid digits&quot;);
 517 
 518             if (hexDigits.indexOf(Character.toUpperCase((char)c2)) &gt;= 0) {
 519                 int hi = Character.digit((char)c1, 16);
 520                 int lo = Character.digit((char)c2, 16);
 521                 return (byte)((hi&lt;&lt;4) + lo);
 522             } else {
 523                 throw new IOException
 524                         (&quot;escaped hex value must include two valid digits&quot;);
 525             }
 526         }
 527         return null;
 528     }
 529 
 530     private static String getEmbeddedHexString(List&lt;Byte&gt; hexList) {
 531         int n = hexList.size();
 532         byte[] hexBytes = new byte[n];
 533         for (int i = 0; i &lt; n; i++) {
 534             hexBytes[i] = hexList.get(i).byteValue();
 535         }
 536         return new String(hexBytes, UTF_8);
 537     }
 538 
 539     private static boolean isTerminator(int ch, int format) {
 540         switch (ch) {
 541         case -1:
 542         case &#39;+&#39;:
 543         case &#39;,&#39;:
 544             return true;
 545         case &#39;;&#39;:
 546             return format != RFC2253;
 547         default:
 548             return false;
 549         }
 550     }
 551 
 552     private static int readChar(Reader in, String errMsg) throws IOException {
 553         int c = in.read();
 554         if (c == -1) {
 555             throw new IOException(errMsg);
 556         }
 557         return c;
 558     }
 559 
 560     private static boolean trailingSpace(Reader in) throws IOException {
 561 
 562         boolean trailing = false;
 563 
 564         if (!in.markSupported()) {
 565             // oh well
 566             return true;
 567         } else {
 568             // make readAheadLimit huge -
 569             // in practice, AVA was passed a StringReader from X500Name,
 570             // and StringReader ignores readAheadLimit anyways
 571             in.mark(9999);
 572             while (true) {
 573                 int nextChar = in.read();
 574                 if (nextChar == -1) {
 575                     trailing = true;
 576                     break;
 577                 } else if (nextChar == &#39; &#39;) {
 578                     continue;
 579                 } else if (nextChar == &#39;\\&#39;) {
 580                     int followingChar = in.read();
 581                     if (followingChar != &#39; &#39;) {
 582                         trailing = false;
 583                         break;
 584                     }
 585                 } else {
 586                     trailing = false;
 587                     break;
 588                 }
 589             }
 590 
 591             in.reset();
 592             return trailing;
 593         }
 594     }
 595 
 596     AVA(DerValue derval) throws IOException {
 597         // Individual attribute value assertions are SEQUENCE of two values.
 598         // That&#39;d be a &quot;struct&quot; outside of ASN.1.
 599         if (derval.tag != DerValue.tag_Sequence) {
 600             throw new IOException(&quot;AVA not a sequence&quot;);
 601         }
 602         oid = derval.data.getOID();
 603         value = derval.data.getDerValue();
 604 
 605         if (derval.data.available() != 0) {
 606             throw new IOException(&quot;AVA, extra bytes = &quot;
 607                 + derval.data.available());
 608         }
 609     }
 610 
 611     AVA(DerInputStream in) throws IOException {
 612         this(in.getDerValue());
 613     }
 614 
 615     public boolean equals(Object obj) {
 616         if (this == obj) {
 617             return true;
 618         }
 619         if (obj instanceof AVA == false) {
 620             return false;
 621         }
 622         AVA other = (AVA)obj;
 623         return this.toRFC2253CanonicalString().equals
 624                                 (other.toRFC2253CanonicalString());
 625     }
 626 
 627     /**
 628      * Returns a hashcode for this AVA.
 629      *
 630      * @return a hashcode for this AVA.
 631      */
 632     public int hashCode() {
 633         return toRFC2253CanonicalString().hashCode();
 634     }
 635 
 636     /*
 637      * AVAs are encoded as a SEQUENCE of two elements.
 638      */
 639     public void encode(DerOutputStream out) throws IOException {
 640         derEncode(out);
 641     }
 642 
 643     /**
 644      * DER encode this object onto an output stream.
 645      * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
 646      *
 647      * @param out
 648      * the output stream on which to write the DER encoding.
 649      *
 650      * @exception IOException on encoding error.
 651      */
 652     public void derEncode(OutputStream out) throws IOException {
 653         DerOutputStream         tmp = new DerOutputStream();
 654         DerOutputStream         tmp2 = new DerOutputStream();
 655 
 656         tmp.putOID(oid);
 657         value.encode(tmp);
 658         tmp2.write(DerValue.tag_Sequence, tmp);
 659         out.write(tmp2.toByteArray());
 660     }
 661 
 662     private String toKeyword(int format, Map&lt;String, String&gt; oidMap) {
 663         return AVAKeyword.getKeyword(oid, format, oidMap);
 664     }
 665 
 666     /**
 667      * Returns a printable form of this attribute, using RFC 1779
 668      * syntax for individual attribute/value assertions.
 669      */
 670     public String toString() {
 671         return toKeywordValueString
 672             (toKeyword(DEFAULT, Collections.&lt;String, String&gt;emptyMap()));
 673     }
 674 
 675     /**
 676      * Returns a printable form of this attribute, using RFC 1779
 677      * syntax for individual attribute/value assertions. It only
 678      * emits standardised keywords.
 679      */
 680     public String toRFC1779String() {
 681         return toRFC1779String(Collections.&lt;String, String&gt;emptyMap());
 682     }
 683 
 684     /**
 685      * Returns a printable form of this attribute, using RFC 1779
 686      * syntax for individual attribute/value assertions. It
 687      * emits standardised keywords, as well as keywords contained in the
 688      * OID/keyword map.
 689      */
 690     public String toRFC1779String(Map&lt;String, String&gt; oidMap) {
 691         return toKeywordValueString(toKeyword(RFC1779, oidMap));
 692     }
 693 
 694     /**
 695      * Returns a printable form of this attribute, using RFC 2253
 696      * syntax for individual attribute/value assertions. It only
 697      * emits standardised keywords.
 698      */
 699     public String toRFC2253String() {
 700         return toRFC2253String(Collections.&lt;String, String&gt;emptyMap());
 701     }
 702 
 703     /**
 704      * Returns a printable form of this attribute, using RFC 2253
 705      * syntax for individual attribute/value assertions. It
 706      * emits standardised keywords, as well as keywords contained in the
 707      * OID/keyword map.
 708      */
 709     public String toRFC2253String(Map&lt;String, String&gt; oidMap) {
 710         /*
 711          * Section 2.3: The AttributeTypeAndValue is encoded as the string
 712          * representation of the AttributeType, followed by an equals character
 713          * (&#39;=&#39; ASCII 61), followed by the string representation of the
 714          * AttributeValue. The encoding of the AttributeValue is given in
 715          * section 2.4.
 716          */
 717         StringBuilder typeAndValue = new StringBuilder(100);
 718         typeAndValue.append(toKeyword(RFC2253, oidMap));
 719         typeAndValue.append(&#39;=&#39;);
 720 
 721         /*
 722          * Section 2.4: Converting an AttributeValue from ASN.1 to a String.
 723          * If the AttributeValue is of a type which does not have a string
 724          * representation defined for it, then it is simply encoded as an
 725          * octothorpe character (&#39;#&#39; ASCII 35) followed by the hexadecimal
 726          * representation of each of the bytes of the BER encoding of the X.500
 727          * AttributeValue.  This form SHOULD be used if the AttributeType is of
 728          * the dotted-decimal form.
 729          */
 730         if ((typeAndValue.charAt(0) &gt;= &#39;0&#39; &amp;&amp; typeAndValue.charAt(0) &lt;= &#39;9&#39;) ||
 731             !isDerString(value, false))
 732         {
 733             byte[] data = null;
 734             try {
 735                 data = value.toByteArray();
 736             } catch (IOException ie) {
 737                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 738             }
 739             typeAndValue.append(&#39;#&#39;);
 740             for (int j = 0; j &lt; data.length; j++) {
 741                 byte b = data[j];
 742                 typeAndValue.append(Character.forDigit(0xF &amp; (b &gt;&gt;&gt; 4), 16));
 743                 typeAndValue.append(Character.forDigit(0xF &amp; b, 16));
 744             }
 745         } else {
 746             /*
 747              * 2.4 (cont): Otherwise, if the AttributeValue is of a type which
 748              * has a string representation, the value is converted first to a
 749              * UTF-8 string according to its syntax specification.
 750              *
 751              * NOTE: this implementation only emits DirectoryStrings of the
 752              * types returned by isDerString().
 753              */
 754             String valStr = null;
 755             try {
 756                 valStr = new String(value.getDataBytes(), UTF_8);
 757             } catch (IOException ie) {
 758                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 759             }
 760 
 761             /*
 762              * 2.4 (cont): If the UTF-8 string does not have any of the
 763              * following characters which need escaping, then that string can be
 764              * used as the string representation of the value.
 765              *
 766              *   o   a space or &quot;#&quot; character occurring at the beginning of the
 767              *       string
 768              *   o   a space character occurring at the end of the string
 769              *   o   one of the characters &quot;,&quot;, &quot;+&quot;, &quot;&quot;&quot;, &quot;\&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; or &quot;;&quot;
 770              *
 771              * Implementations MAY escape other characters.
 772              *
 773              * NOTE: this implementation also recognizes &quot;=&quot; and &quot;#&quot; as
 774              * characters which need escaping, and null which is escaped as
 775              * &#39;\00&#39; (see RFC 4514).
 776              *
 777              * If a character to be escaped is one of the list shown above, then
 778              * it is prefixed by a backslash (&#39;\&#39; ASCII 92).
 779              *
 780              * Otherwise the character to be escaped is replaced by a backslash
 781              * and two hex digits, which form a single byte in the code of the
 782              * character.
 783              */
 784             final String escapees = &quot;,=+&lt;&gt;#;\&quot;\\&quot;;
 785             StringBuilder sbuffer = new StringBuilder();
 786 
 787             for (int i = 0; i &lt; valStr.length(); i++) {
 788                 char c = valStr.charAt(i);
 789                 if (DerValue.isPrintableStringChar(c) ||
 790                     escapees.indexOf(c) &gt;= 0) {
 791 
 792                     // escape escapees
 793                     if (escapees.indexOf(c) &gt;= 0) {
 794                         sbuffer.append(&#39;\\&#39;);
 795                     }
 796 
 797                     // append printable/escaped char
 798                     sbuffer.append(c);
 799 
 800                 } else if (c == &#39;\u0000&#39;) {
 801                     // escape null character
 802                     sbuffer.append(&quot;\\00&quot;);
 803 
 804                 } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
 805 
 806                     // embed non-printable/non-escaped char
 807                     // as escaped hex pairs for debugging
 808                     byte[] valueBytes = Character.toString(c).getBytes(UTF_8);
 809                     for (int j = 0; j &lt; valueBytes.length; j++) {
 810                         sbuffer.append(&#39;\\&#39;);
 811                         char hexChar = Character.forDigit
 812                                 (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16);
 813                         sbuffer.append(Character.toUpperCase(hexChar));
 814                         hexChar = Character.forDigit
 815                                 (0xF &amp; (valueBytes[j]), 16);
 816                         sbuffer.append(Character.toUpperCase(hexChar));
 817                     }
 818                 } else {
 819 
 820                     // append non-printable/non-escaped char
 821                     sbuffer.append(c);
 822                 }
 823             }
 824 
 825             char[] chars = sbuffer.toString().toCharArray();
 826             sbuffer = new StringBuilder();
 827 
 828             // Find leading and trailing whitespace.
 829             int lead;   // index of first char that is not leading whitespace
 830             for (lead = 0; lead &lt; chars.length; lead++) {
 831                 if (chars[lead] != &#39; &#39; &amp;&amp; chars[lead] != &#39;\r&#39;) {
 832                     break;
 833                 }
 834             }
 835             int trail;  // index of last char that is not trailing whitespace
 836             for (trail = chars.length - 1; trail &gt;= 0; trail--) {
 837                 if (chars[trail] != &#39; &#39; &amp;&amp; chars[trail] != &#39;\r&#39;) {
 838                     break;
 839                 }
 840             }
 841 
 842             // escape leading and trailing whitespace
 843             for (int i = 0; i &lt; chars.length; i++) {
 844                 char c = chars[i];
 845                 if (i &lt; lead || i &gt; trail) {
 846                     sbuffer.append(&#39;\\&#39;);
 847                 }
 848                 sbuffer.append(c);
 849             }
 850             typeAndValue.append(sbuffer);
 851         }
 852         return typeAndValue.toString();
 853     }
 854 
 855     public String toRFC2253CanonicalString() {
 856         /*
 857          * Section 2.3: The AttributeTypeAndValue is encoded as the string
 858          * representation of the AttributeType, followed by an equals character
 859          * (&#39;=&#39; ASCII 61), followed by the string representation of the
 860          * AttributeValue. The encoding of the AttributeValue is given in
 861          * section 2.4.
 862          */
 863         StringBuilder typeAndValue = new StringBuilder(40);
 864         typeAndValue.append
 865             (toKeyword(RFC2253, Collections.&lt;String, String&gt;emptyMap()));
 866         typeAndValue.append(&#39;=&#39;);
 867 
 868         /*
 869          * Section 2.4: Converting an AttributeValue from ASN.1 to a String.
 870          * If the AttributeValue is of a type which does not have a string
 871          * representation defined for it, then it is simply encoded as an
 872          * octothorpe character (&#39;#&#39; ASCII 35) followed by the hexadecimal
 873          * representation of each of the bytes of the BER encoding of the X.500
 874          * AttributeValue.  This form SHOULD be used if the AttributeType is of
 875          * the dotted-decimal form.
 876          */
 877         if ((typeAndValue.charAt(0) &gt;= &#39;0&#39; &amp;&amp; typeAndValue.charAt(0) &lt;= &#39;9&#39;) ||
 878             !isDerString(value, true))
 879         {
 880             byte[] data = null;
 881             try {
 882                 data = value.toByteArray();
 883             } catch (IOException ie) {
 884                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 885             }
 886             typeAndValue.append(&#39;#&#39;);
 887             for (int j = 0; j &lt; data.length; j++) {
 888                 byte b = data[j];
 889                 typeAndValue.append(Character.forDigit(0xF &amp; (b &gt;&gt;&gt; 4), 16));
 890                 typeAndValue.append(Character.forDigit(0xF &amp; b, 16));
 891             }
 892         } else {
 893             /*
 894              * 2.4 (cont): Otherwise, if the AttributeValue is of a type which
 895              * has a string representation, the value is converted first to a
 896              * UTF-8 string according to its syntax specification.
 897              *
 898              * NOTE: this implementation only emits DirectoryStrings of the
 899              * types returned by isDerString().
 900              */
 901             String valStr = null;
 902             try {
 903                 valStr = new String(value.getDataBytes(), UTF_8);
 904             } catch (IOException ie) {
 905                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 906             }
 907 
 908             /*
 909              * 2.4 (cont): If the UTF-8 string does not have any of the
 910              * following characters which need escaping, then that string can be
 911              * used as the string representation of the value.
 912              *
 913              *   o   a space or &quot;#&quot; character occurring at the beginning of the
 914              *       string
 915              *   o   a space character occurring at the end of the string
 916              *
 917              *   o   one of the characters &quot;,&quot;, &quot;+&quot;, &quot;&quot;&quot;, &quot;\&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; or &quot;;&quot;
 918              *
 919              * If a character to be escaped is one of the list shown above, then
 920              * it is prefixed by a backslash (&#39;\&#39; ASCII 92).
 921              *
 922              * Otherwise the character to be escaped is replaced by a backslash
 923              * and two hex digits, which form a single byte in the code of the
 924              * character.
 925              */
 926             final String escapees = &quot;,+&lt;&gt;;\&quot;\\&quot;;
 927             StringBuilder sbuffer = new StringBuilder();
 928             boolean previousWhite = false;
 929 
 930             for (int i = 0; i &lt; valStr.length(); i++) {
 931                 char c = valStr.charAt(i);
 932 
 933                 if (DerValue.isPrintableStringChar(c) ||
 934                     escapees.indexOf(c) &gt;= 0 ||
 935                     (i == 0 &amp;&amp; c == &#39;#&#39;)) {
 936 
 937                     // escape leading &#39;#&#39; and escapees
 938                     if ((i == 0 &amp;&amp; c == &#39;#&#39;) || escapees.indexOf(c) &gt;= 0) {
 939                         sbuffer.append(&#39;\\&#39;);
 940                     }
 941 
 942                     // convert multiple whitespace to single whitespace
 943                     if (!Character.isWhitespace(c)) {
 944                         previousWhite = false;
 945                         sbuffer.append(c);
 946                     } else {
 947                         if (previousWhite == false) {
 948                             // add single whitespace
 949                             previousWhite = true;
 950                             sbuffer.append(c);
 951                         } else {
 952                             // ignore subsequent consecutive whitespace
 953                             continue;
 954                         }
 955                     }
 956 
 957                 } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
 958 
 959                     // embed non-printable/non-escaped char
 960                     // as escaped hex pairs for debugging
 961 
 962                     previousWhite = false;
 963 
 964                     byte[] valueBytes = Character.toString(c).getBytes(UTF_8);
 965                     for (int j = 0; j &lt; valueBytes.length; j++) {
 966                         sbuffer.append(&#39;\\&#39;);
 967                         sbuffer.append(Character.forDigit
 968                                         (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16));
 969                         sbuffer.append(Character.forDigit
 970                                         (0xF &amp; (valueBytes[j]), 16));
 971                     }
 972                 } else {
 973 
 974                     // append non-printable/non-escaped char
 975 
 976                     previousWhite = false;
 977                     sbuffer.append(c);
 978                 }
 979             }
 980 
 981             // remove leading and trailing whitespace from value
 982             typeAndValue.append(sbuffer.toString().trim());
 983         }
 984 
 985         String canon = typeAndValue.toString();
 986         canon = canon.toUpperCase(Locale.US).toLowerCase(Locale.US);
 987         return Normalizer.normalize(canon, Normalizer.Form.NFKD);
 988     }
 989 
 990     /*
 991      * Return true if DerValue can be represented as a String.
 992      */
 993     private static boolean isDerString(DerValue value, boolean canonical) {
 994         if (canonical) {
 995             switch (value.tag) {
 996                 case DerValue.tag_PrintableString:
 997                 case DerValue.tag_UTF8String:
 998                     return true;
 999                 default:
1000                     return false;
1001             }
1002         } else {
1003             switch (value.tag) {
1004                 case DerValue.tag_PrintableString:
1005                 case DerValue.tag_T61String:
1006                 case DerValue.tag_IA5String:
1007                 case DerValue.tag_GeneralString:
1008                 case DerValue.tag_BMPString:
1009                 case DerValue.tag_UTF8String:
1010                     return true;
1011                 default:
1012                     return false;
1013             }
1014         }
1015     }
1016 
1017     boolean hasRFC2253Keyword() {
1018         return AVAKeyword.hasKeyword(oid, RFC2253);
1019     }
1020 
1021     private String toKeywordValueString(String keyword) {
1022         /*
1023          * Construct the value with as little copying and garbage
1024          * production as practical.  First the keyword (mandatory),
1025          * then the equals sign, finally the value.
1026          */
1027         StringBuilder   retval = new StringBuilder(40);
1028 
1029         retval.append(keyword);
1030         retval.append(&#39;=&#39;);
1031 
1032         try {
1033             String valStr = value.getAsString();
1034 
1035             if (valStr == null) {
1036 
1037                 // RFC 1779 specifies that attribute values associated
1038                 // with non-standard keyword attributes may be represented
1039                 // using the hex format below.  This will be used only
1040                 // when the value is not a string type
1041 
1042                 byte[] data = value.toByteArray();
1043 
1044                 retval.append(&#39;#&#39;);
1045                 for (int i = 0; i &lt; data.length; i++) {
1046                     retval.append(hexDigits.charAt((data [i] &gt;&gt; 4) &amp; 0x0f));
1047                     retval.append(hexDigits.charAt(data [i] &amp; 0x0f));
1048                 }
1049 
1050             } else {
1051 
1052                 boolean quoteNeeded = false;
1053                 StringBuilder sbuffer = new StringBuilder();
1054                 boolean previousWhite = false;
1055                 final String escapees = &quot;,+=\n&lt;&gt;#;\\\&quot;&quot;;
1056 
1057                 /*
1058                  * Special characters (e.g. AVA list separators) cause strings
1059                  * to need quoting, or at least escaping.  So do leading or
1060                  * trailing spaces, and multiple internal spaces.
1061                  */
1062                 int length = valStr.length();
1063                 boolean alreadyQuoted =
1064                     (length &gt; 1 &amp;&amp; valStr.charAt(0) == &#39;\&quot;&#39;
1065                      &amp;&amp; valStr.charAt(length - 1) == &#39;\&quot;&#39;);
1066 
1067                 for (int i = 0; i &lt; length; i++) {
1068                     char c = valStr.charAt(i);
1069                     if (alreadyQuoted &amp;&amp; (i == 0 || i == length - 1)) {
1070                         sbuffer.append(c);
1071                         continue;
1072                     }
1073                     if (DerValue.isPrintableStringChar(c) ||
1074                         escapees.indexOf(c) &gt;= 0) {
1075 
1076                         // quote if leading whitespace or special chars
1077                         if (!quoteNeeded &amp;&amp;
1078                             ((i == 0 &amp;&amp; (c == &#39; &#39; || c == &#39;\n&#39;)) ||
1079                                 escapees.indexOf(c) &gt;= 0)) {
1080                             quoteNeeded = true;
1081                         }
1082 
1083                         // quote if multiple internal whitespace
1084                         if (!(c == &#39; &#39; || c == &#39;\n&#39;)) {
1085                             // escape &#39;&quot;&#39; and &#39;\&#39;
1086                             if (c == &#39;&quot;&#39; || c == &#39;\\&#39;) {
1087                                 sbuffer.append(&#39;\\&#39;);
1088                             }
1089                             previousWhite = false;
1090                         } else {
1091                             if (!quoteNeeded &amp;&amp; previousWhite) {
1092                                 quoteNeeded = true;
1093                             }
1094                             previousWhite = true;
1095                         }
1096 
1097                         sbuffer.append(c);
1098 
1099                     } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
1100 
1101                         // embed non-printable/non-escaped char
1102                         // as escaped hex pairs for debugging
1103 
1104                         previousWhite = false;
1105 
1106                         // embed escaped hex pairs
1107                         byte[] valueBytes =
1108                                 Character.toString(c).getBytes(UTF_8);
1109                         for (int j = 0; j &lt; valueBytes.length; j++) {
1110                             sbuffer.append(&#39;\\&#39;);
1111                             char hexChar = Character.forDigit
1112                                         (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16);
1113                             sbuffer.append(Character.toUpperCase(hexChar));
1114                             hexChar = Character.forDigit
1115                                         (0xF &amp; (valueBytes[j]), 16);
1116                             sbuffer.append(Character.toUpperCase(hexChar));
1117                         }
1118                     } else {
1119 
1120                         // append non-printable/non-escaped char
1121 
1122                         previousWhite = false;
1123                         sbuffer.append(c);
1124                     }
1125                 }
1126 
1127                 // quote if trailing whitespace
1128                 if (sbuffer.length() &gt; 0) {
1129                     char trailChar = sbuffer.charAt(sbuffer.length() - 1);
1130                     if (trailChar == &#39; &#39; || trailChar == &#39;\n&#39;) {
1131                         quoteNeeded = true;
1132                     }
1133                 }
1134 
1135                 // Emit the string ... quote it if needed
1136                 // if string is already quoted, don&#39;t re-quote
1137                 if (!alreadyQuoted &amp;&amp; quoteNeeded) {
1138                     retval.append(&#39;\&quot;&#39;)
1139                         .append(sbuffer)
1140                         .append(&#39;\&quot;&#39;);
1141                 } else {
1142                     retval.append(sbuffer);
1143                 }
1144             }
1145         } catch (IOException e) {
1146             throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
1147         }
1148 
1149         return retval.toString();
1150     }
1151 
1152 }
1153 
1154 /**
1155  * Helper class that allows conversion from String to ObjectIdentifier and
1156  * vice versa according to RFC1779, RFC2253, and an augmented version of
1157  * those standards.
1158  */
1159 class AVAKeyword {
1160 
1161     private static final Map&lt;ObjectIdentifier,AVAKeyword&gt; oidMap;
1162     private static final Map&lt;String,AVAKeyword&gt; keywordMap;
1163 
1164     private String keyword;
1165     private ObjectIdentifier oid;
1166     private boolean rfc1779Compliant, rfc2253Compliant;
1167 
1168     private AVAKeyword(String keyword, ObjectIdentifier oid,
1169                boolean rfc1779Compliant, boolean rfc2253Compliant) {
1170         this.keyword = keyword;
1171         this.oid = oid;
1172         this.rfc1779Compliant = rfc1779Compliant;
1173         this.rfc2253Compliant = rfc2253Compliant;
1174 
1175         // register it
1176         oidMap.put(oid, this);
1177         keywordMap.put(keyword, this);
1178     }
1179 
1180     private boolean isCompliant(int standard) {
1181         switch (standard) {
1182         case AVA.RFC1779:
1183             return rfc1779Compliant;
1184         case AVA.RFC2253:
1185             return rfc2253Compliant;
1186         case AVA.DEFAULT:
1187             return true;
1188         default:
1189             // should not occur, internal error
1190             throw new IllegalArgumentException(&quot;Invalid standard &quot; + standard);
1191         }
1192     }
1193 
1194     /**
1195      * Get an object identifier representing the specified keyword (or
1196      * string encoded object identifier) in the given standard.
1197      *
1198      * @param keywordMap a Map where a keyword String maps to a corresponding
1199      *   OID String. Each AVA keyword will be mapped to the corresponding OID.
1200      *   If an entry does not exist, it will fallback to the builtin
1201      *   keyword/OID mapping.
1202      * @throws IOException If the keyword is not valid in the specified standard
1203      *   or the OID String to which a keyword maps to is improperly formatted.
1204      */
1205     static ObjectIdentifier getOID
1206         (String keyword, int standard, Map&lt;String, String&gt; extraKeywordMap)
1207             throws IOException {
1208 
1209         keyword = keyword.toUpperCase(Locale.ENGLISH);
1210         if (standard == AVA.RFC2253) {
1211             if (keyword.startsWith(&quot; &quot;) || keyword.endsWith(&quot; &quot;)) {
1212                 throw new IOException(&quot;Invalid leading or trailing space &quot; +
1213                         &quot;in keyword \&quot;&quot; + keyword + &quot;\&quot;&quot;);
1214             }
1215         } else {
1216             keyword = keyword.trim();
1217         }
1218 
1219         // check user-specified keyword map first, then fallback to built-in
1220         // map
1221         String oidString = extraKeywordMap.get(keyword);
1222         if (oidString == null) {
1223             AVAKeyword ak = keywordMap.get(keyword);
1224             if ((ak != null) &amp;&amp; ak.isCompliant(standard)) {
1225                 return ak.oid;
1226             }
1227         } else {
1228             return ObjectIdentifier.of(oidString);
1229         }
1230 
1231         // no keyword found, check if OID string
1232         if (standard == AVA.DEFAULT &amp;&amp; keyword.startsWith(&quot;OID.&quot;)) {
1233             keyword = keyword.substring(4);
1234         }
1235 
1236         boolean number = false;
1237         if (!keyword.isEmpty()) {
1238             char ch = keyword.charAt(0);
1239             if ((ch &gt;= &#39;0&#39;) &amp;&amp; (ch &lt;= &#39;9&#39;)) {
1240                 number = true;
1241             }
1242         }
1243         if (number == false) {
1244             throw new IOException(&quot;Invalid keyword \&quot;&quot; + keyword + &quot;\&quot;&quot;);
1245         }
1246         return ObjectIdentifier.of(keyword);
1247     }
1248 
1249     /**
1250      * Get a keyword for the given ObjectIdentifier according to standard.
1251      * If no keyword is available, the ObjectIdentifier is encoded as a
1252      * String.
1253      */
1254     static String getKeyword(ObjectIdentifier oid, int standard) {
1255         return getKeyword
1256             (oid, standard, Collections.&lt;String, String&gt;emptyMap());
1257     }
1258 
1259     /**
1260      * Get a keyword for the given ObjectIdentifier according to standard.
1261      * Checks the extraOidMap for a keyword first, then falls back to the
1262      * builtin/default set. If no keyword is available, the ObjectIdentifier
1263      * is encoded as a String.
1264      */
1265     static String getKeyword
1266         (ObjectIdentifier oid, int standard, Map&lt;String, String&gt; extraOidMap) {
1267 
1268         // check extraOidMap first, then fallback to built-in map
1269         String oidString = oid.toString();
1270         String keywordString = extraOidMap.get(oidString);
1271         if (keywordString == null) {
1272             AVAKeyword ak = oidMap.get(oid);
1273             if ((ak != null) &amp;&amp; ak.isCompliant(standard)) {
1274                 return ak.keyword;
1275             }
1276         } else {
1277             if (keywordString.isEmpty()) {
1278                 throw new IllegalArgumentException(&quot;keyword cannot be empty&quot;);
1279             }
1280             keywordString = keywordString.trim();
1281             char c = keywordString.charAt(0);
1282             if (c &lt; 65 || c &gt; 122 || (c &gt; 90 &amp;&amp; c &lt; 97)) {
1283                 throw new IllegalArgumentException
1284                     (&quot;keyword does not start with letter&quot;);
1285             }
1286             for (int i=1; i&lt;keywordString.length(); i++) {
1287                 c = keywordString.charAt(i);
1288                 if ((c &lt; 65 || c &gt; 122 || (c &gt; 90 &amp;&amp; c &lt; 97)) &amp;&amp;
1289                     (c &lt; 48 || c &gt; 57) &amp;&amp; c != &#39;_&#39;) {
1290                     throw new IllegalArgumentException
1291                     (&quot;keyword character is not a letter, digit, or underscore&quot;);
1292                 }
1293             }
1294             return keywordString;
1295         }
1296         // no compliant keyword, use OID
1297         if (standard == AVA.RFC2253) {
1298             return oidString;
1299         } else {
1300             return &quot;OID.&quot; + oidString;
1301         }
1302     }
1303 
1304     /**
1305      * Test if oid has an associated keyword in standard.
1306      */
1307     static boolean hasKeyword(ObjectIdentifier oid, int standard) {
1308         AVAKeyword ak = oidMap.get(oid);
1309         if (ak == null) {
1310             return false;
1311         }
1312         return ak.isCompliant(standard);
1313     }
1314 
1315     static {
1316         oidMap = new HashMap&lt;ObjectIdentifier,AVAKeyword&gt;();
1317         keywordMap = new HashMap&lt;String,AVAKeyword&gt;();
1318 
1319         // NOTE if multiple keywords are available for one OID, order
1320         // is significant!! Preferred *LAST*.
1321         new AVAKeyword(&quot;CN&quot;,           X500Name.commonName_oid,   true,  true);
1322         new AVAKeyword(&quot;C&quot;,            X500Name.countryName_oid,  true,  true);
1323         new AVAKeyword(&quot;L&quot;,            X500Name.localityName_oid, true,  true);
1324         new AVAKeyword(&quot;S&quot;,            X500Name.stateName_oid,    false, false);
1325         new AVAKeyword(&quot;ST&quot;,           X500Name.stateName_oid,    true,  true);
1326         new AVAKeyword(&quot;O&quot;,            X500Name.orgName_oid,      true,  true);
1327         new AVAKeyword(&quot;OU&quot;,           X500Name.orgUnitName_oid,  true,  true);
1328         new AVAKeyword(&quot;T&quot;,            X500Name.title_oid,        false, false);
1329         new AVAKeyword(&quot;IP&quot;,           X500Name.ipAddress_oid,    false, false);
1330         new AVAKeyword(&quot;STREET&quot;,       X500Name.streetAddress_oid,true,  true);
1331         new AVAKeyword(&quot;DC&quot;,           X500Name.DOMAIN_COMPONENT_OID,
1332                                                                   false, true);
1333         new AVAKeyword(&quot;DNQUALIFIER&quot;,  X500Name.DNQUALIFIER_OID,  false, false);
1334         new AVAKeyword(&quot;DNQ&quot;,          X500Name.DNQUALIFIER_OID,  false, false);
1335         new AVAKeyword(&quot;SURNAME&quot;,      X500Name.SURNAME_OID,      false, false);
1336         new AVAKeyword(&quot;GIVENNAME&quot;,    X500Name.GIVENNAME_OID,    false, false);
1337         new AVAKeyword(&quot;INITIALS&quot;,     X500Name.INITIALS_OID,     false, false);
1338         new AVAKeyword(&quot;GENERATION&quot;,   X500Name.GENERATIONQUALIFIER_OID,
1339                                                                   false, false);
1340         new AVAKeyword(&quot;EMAIL&quot;, PKCS9Attribute.EMAIL_ADDRESS_OID, false, false);
1341         new AVAKeyword(&quot;EMAILADDRESS&quot;, PKCS9Attribute.EMAIL_ADDRESS_OID,
1342                                                                   false, false);
1343         new AVAKeyword(&quot;UID&quot;,          X500Name.userid_oid,       false, true);
1344         new AVAKeyword(&quot;SERIALNUMBER&quot;, X500Name.SERIALNUMBER_OID, false, false);
1345     }
1346 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/com/sun/crypto/provider/KeyProtector.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DHPublicKey.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OAEPParameters.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/com/sun/crypto/provider/KeyProtector.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 import java.security.Provider;
 32 import java.security.KeyFactory;
 33 import java.security.MessageDigest;
 34 import java.security.GeneralSecurityException;
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.UnrecoverableKeyException;
 37 import java.security.AlgorithmParameters;
 38 import java.security.spec.InvalidParameterSpecException;
 39 import java.security.spec.PKCS8EncodedKeySpec;
 40 import java.util.Arrays;
 41 
 42 import javax.crypto.Cipher;
 43 import javax.crypto.CipherSpi;
 44 import javax.crypto.SecretKey;
 45 import javax.crypto.SealedObject;
 46 import javax.crypto.spec.*;
 47 import javax.security.auth.DestroyFailedException;
 48 
 49 import sun.security.x509.AlgorithmId;
 50 import sun.security.util.ObjectIdentifier;

 51 import sun.security.util.SecurityProperties;
 52 
 53 /**
 54  * This class implements a protection mechanism for private keys. In JCE, we
 55  * use a stronger protection mechanism than in the JDK, because we can use
 56  * the &lt;code&gt;Cipher&lt;/code&gt; class.
 57  * Private keys are protected using the JCE mechanism, and are recovered using
 58  * either the JDK or JCE mechanism, depending on how the key has been
 59  * protected. This allows us to parse Sun&#39;s keystore implementation that ships
 60  * with JDK 1.2.
 61  *
 62  * @author Jan Luehe
 63  *
 64  *
 65  * @see JceKeyStore
 66  */
 67 
 68 final class KeyProtector {
 69 
<span class="line-removed"> 70     // defined by SunSoft (SKI project)</span>
<span class="line-removed"> 71     private static final String PBE_WITH_MD5_AND_DES3_CBC_OID</span>
<span class="line-removed"> 72             = &quot;1.3.6.1.4.1.42.2.19.1&quot;;</span>
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74     // JavaSoft proprietary key-protection algorithm (used to protect private</span>
<span class="line-removed"> 75     // keys in the keystore implementation that comes with JDK 1.2)</span>
<span class="line-removed"> 76     private static final String KEY_PROTECTOR_OID = &quot;1.3.6.1.4.1.42.2.17.1.1&quot;;</span>
<span class="line-removed"> 77 </span>
 78     private static final int MAX_ITERATION_COUNT = 5000000;
 79     private static final int MIN_ITERATION_COUNT = 10000;
 80     private static final int DEFAULT_ITERATION_COUNT = 200000;
 81     private static final int SALT_LEN = 20; // the salt length
 82     private static final int DIGEST_LEN = 20;
 83     private static final int ITERATION_COUNT;
 84 
 85     // the password used for protecting/recovering keys passed through this
 86     // key protector
 87     private char[] password;
 88 
 89     /**
 90      * {@systemProperty jdk.jceks.iterationCount} property indicating the
 91      * number of iterations for password-based encryption (PBE) in JCEKS
 92      * keystores. Values in the range 10000 to 5000000 are considered valid.
 93      * If the value is out of this range, or is not a number, or is
 94      * unspecified; a default of 200000 is used.
 95      */
 96     static {
 97         int iterationCount = DEFAULT_ITERATION_COUNT;
</pre>
<hr />
<pre>
137         try {
138             sKey = new PBEKey(pbeKeySpec, &quot;PBEWithMD5AndTripleDES&quot;, false);
139             // encrypt private key
140             cipher = new PBEWithMD5AndTripleDESCipher();
141             cipher.engineInit(Cipher.ENCRYPT_MODE, sKey, pbeSpec, null);
142         } finally {
143             pbeKeySpec.clearPassword();
144             if (sKey != null) sKey.destroy();
145         }
146         byte[] plain = key.getEncoded();
147         byte[] encrKey = cipher.engineDoFinal(plain, 0, plain.length);
148         Arrays.fill(plain, (byte) 0x00);
149 
150         // wrap encrypted private key in EncryptedPrivateKeyInfo
151         // (as defined in PKCS#8)
152         AlgorithmParameters pbeParams =
153             AlgorithmParameters.getInstance(&quot;PBE&quot;, SunJCE.getInstance());
154         pbeParams.init(pbeSpec);
155 
156         AlgorithmId encrAlg = new AlgorithmId
<span class="line-modified">157             (new ObjectIdentifier(PBE_WITH_MD5_AND_DES3_CBC_OID), pbeParams);</span>

158         return new EncryptedPrivateKeyInfo(encrAlg,encrKey).getEncoded();
159     }
160 
161     /*
162      * Recovers the cleartext version of the given key (in protected format),
163      * using the password provided at construction time.
164      */
165     Key recover(EncryptedPrivateKeyInfo encrInfo)
166         throws UnrecoverableKeyException, NoSuchAlgorithmException
167     {
168         byte[] plain = null;
169         SecretKey sKey = null;
170         try {
171             String encrAlg = encrInfo.getAlgorithm().getOID().toString();
<span class="line-modified">172             if (!encrAlg.equals(PBE_WITH_MD5_AND_DES3_CBC_OID)</span>
<span class="line-modified">173                 &amp;&amp; !encrAlg.equals(KEY_PROTECTOR_OID)) {</span>
174                 throw new UnrecoverableKeyException(&quot;Unsupported encryption &quot;
175                                                     + &quot;algorithm&quot;);
176             }
177 
<span class="line-modified">178             if (encrAlg.equals(KEY_PROTECTOR_OID)) {</span>
179                 // JDK 1.2 style recovery
180                 plain = recover(encrInfo.getEncryptedData());
181             } else {
182                 byte[] encodedParams =
183                     encrInfo.getAlgorithm().getEncodedParams();
184 
185                 // parse the PBE parameters into the corresponding spec
186                 AlgorithmParameters pbeParams =
187                     AlgorithmParameters.getInstance(&quot;PBE&quot;);
188                 pbeParams.init(encodedParams);
189                 PBEParameterSpec pbeSpec =
190                         pbeParams.getParameterSpec(PBEParameterSpec.class);
191                 if (pbeSpec.getIterationCount() &gt; MAX_ITERATION_COUNT) {
192                     throw new IOException(&quot;PBE iteration count too large&quot;);
193                 }
194 
195                 // create PBE key from password
196                 PBEKeySpec pbeKeySpec = new PBEKeySpec(this.password);
197                 sKey = new PBEKey(pbeKeySpec, &quot;PBEWithMD5AndTripleDES&quot;, false);
198                 pbeKeySpec.clearPassword();
</pre>
</td>
<td>
<hr />
<pre>
 31 import java.security.Provider;
 32 import java.security.KeyFactory;
 33 import java.security.MessageDigest;
 34 import java.security.GeneralSecurityException;
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.UnrecoverableKeyException;
 37 import java.security.AlgorithmParameters;
 38 import java.security.spec.InvalidParameterSpecException;
 39 import java.security.spec.PKCS8EncodedKeySpec;
 40 import java.util.Arrays;
 41 
 42 import javax.crypto.Cipher;
 43 import javax.crypto.CipherSpi;
 44 import javax.crypto.SecretKey;
 45 import javax.crypto.SealedObject;
 46 import javax.crypto.spec.*;
 47 import javax.security.auth.DestroyFailedException;
 48 
 49 import sun.security.x509.AlgorithmId;
 50 import sun.security.util.ObjectIdentifier;
<span class="line-added"> 51 import sun.security.util.KnownOIDs;</span>
 52 import sun.security.util.SecurityProperties;
 53 
 54 /**
 55  * This class implements a protection mechanism for private keys. In JCE, we
 56  * use a stronger protection mechanism than in the JDK, because we can use
 57  * the &lt;code&gt;Cipher&lt;/code&gt; class.
 58  * Private keys are protected using the JCE mechanism, and are recovered using
 59  * either the JDK or JCE mechanism, depending on how the key has been
 60  * protected. This allows us to parse Sun&#39;s keystore implementation that ships
 61  * with JDK 1.2.
 62  *
 63  * @author Jan Luehe
 64  *
 65  *
 66  * @see JceKeyStore
 67  */
 68 
 69 final class KeyProtector {
 70 








 71     private static final int MAX_ITERATION_COUNT = 5000000;
 72     private static final int MIN_ITERATION_COUNT = 10000;
 73     private static final int DEFAULT_ITERATION_COUNT = 200000;
 74     private static final int SALT_LEN = 20; // the salt length
 75     private static final int DIGEST_LEN = 20;
 76     private static final int ITERATION_COUNT;
 77 
 78     // the password used for protecting/recovering keys passed through this
 79     // key protector
 80     private char[] password;
 81 
 82     /**
 83      * {@systemProperty jdk.jceks.iterationCount} property indicating the
 84      * number of iterations for password-based encryption (PBE) in JCEKS
 85      * keystores. Values in the range 10000 to 5000000 are considered valid.
 86      * If the value is out of this range, or is not a number, or is
 87      * unspecified; a default of 200000 is used.
 88      */
 89     static {
 90         int iterationCount = DEFAULT_ITERATION_COUNT;
</pre>
<hr />
<pre>
130         try {
131             sKey = new PBEKey(pbeKeySpec, &quot;PBEWithMD5AndTripleDES&quot;, false);
132             // encrypt private key
133             cipher = new PBEWithMD5AndTripleDESCipher();
134             cipher.engineInit(Cipher.ENCRYPT_MODE, sKey, pbeSpec, null);
135         } finally {
136             pbeKeySpec.clearPassword();
137             if (sKey != null) sKey.destroy();
138         }
139         byte[] plain = key.getEncoded();
140         byte[] encrKey = cipher.engineDoFinal(plain, 0, plain.length);
141         Arrays.fill(plain, (byte) 0x00);
142 
143         // wrap encrypted private key in EncryptedPrivateKeyInfo
144         // (as defined in PKCS#8)
145         AlgorithmParameters pbeParams =
146             AlgorithmParameters.getInstance(&quot;PBE&quot;, SunJCE.getInstance());
147         pbeParams.init(pbeSpec);
148 
149         AlgorithmId encrAlg = new AlgorithmId
<span class="line-modified">150             (ObjectIdentifier.of(KnownOIDs.JAVASOFT_JCEKeyProtector),</span>
<span class="line-added">151              pbeParams);</span>
152         return new EncryptedPrivateKeyInfo(encrAlg,encrKey).getEncoded();
153     }
154 
155     /*
156      * Recovers the cleartext version of the given key (in protected format),
157      * using the password provided at construction time.
158      */
159     Key recover(EncryptedPrivateKeyInfo encrInfo)
160         throws UnrecoverableKeyException, NoSuchAlgorithmException
161     {
162         byte[] plain = null;
163         SecretKey sKey = null;
164         try {
165             String encrAlg = encrInfo.getAlgorithm().getOID().toString();
<span class="line-modified">166             if (!encrAlg.equals(KnownOIDs.JAVASOFT_JCEKeyProtector.value())</span>
<span class="line-modified">167                 &amp;&amp; !encrAlg.equals(KnownOIDs.JAVASOFT_JDKKeyProtector.value())) {</span>
168                 throw new UnrecoverableKeyException(&quot;Unsupported encryption &quot;
169                                                     + &quot;algorithm&quot;);
170             }
171 
<span class="line-modified">172             if (encrAlg.equals(KnownOIDs.JAVASOFT_JDKKeyProtector.value())) {</span>
173                 // JDK 1.2 style recovery
174                 plain = recover(encrInfo.getEncryptedData());
175             } else {
176                 byte[] encodedParams =
177                     encrInfo.getAlgorithm().getEncodedParams();
178 
179                 // parse the PBE parameters into the corresponding spec
180                 AlgorithmParameters pbeParams =
181                     AlgorithmParameters.getInstance(&quot;PBE&quot;);
182                 pbeParams.init(encodedParams);
183                 PBEParameterSpec pbeSpec =
184                         pbeParams.getParameterSpec(PBEParameterSpec.class);
185                 if (pbeSpec.getIterationCount() &gt; MAX_ITERATION_COUNT) {
186                     throw new IOException(&quot;PBE iteration count too large&quot;);
187                 }
188 
189                 // create PBE key from password
190                 PBEKeySpec pbeKeySpec = new PBEKeySpec(this.password);
191                 sKey = new PBEKey(pbeKeySpec, &quot;PBEWithMD5AndTripleDES&quot;, false);
192                 pbeKeySpec.clearPassword();
</pre>
</td>
</tr>
</table>
<center><a href="DHPublicKey.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OAEPParameters.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/main/CommandLine.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.main;
 27 
 28 import java.io.IOException;
 29 import java.io.Reader;
 30 import java.nio.charset.Charset;
 31 import java.nio.file.Files;
 32 import java.nio.file.Paths;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.List;
 36 
 37 /**
 38  * Various utility methods for processing Java tool command line arguments.
 39  *
 40  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 41  *  If you write code that depends on this, you do so at your own risk.
 42  *  This code and its internal interfaces are subject to change or
 43  *  deletion without notice.&lt;/b&gt;
 44  */
 45 public class CommandLine {
 46     /**
 47      * Process Win32-style command files for the specified command line
 48      * arguments and return the resulting arguments. A command file argument
 49      * is of the form &#39;@file&#39; where &#39;file&#39; is the name of the file whose
 50      * contents are to be parsed for additional arguments. The contents of
 51      * the command file are parsed using StreamTokenizer and the original
 52      * &#39;@file&#39; argument replaced with the resulting tokens. Recursive command
 53      * files are not supported. The &#39;@&#39; character itself can be quoted with
 54      * the sequence &#39;@@&#39;.
 55      * @param args the arguments that may contain @files
 56      * @return the arguments, with @files expanded
 57      * @throws IOException if there is a problem reading any of the @files
 58      */
<a name="1" id="anc1"></a><span class="line-modified"> 59     public static List&lt;String&gt; parse(List&lt;String&gt; args) throws IOException {</span>
 60         List&lt;String&gt; newArgs = new ArrayList&lt;&gt;();
<a name="2" id="anc2"></a><span class="line-modified"> 61         appendParsedCommandArgs(newArgs, args);</span>
<span class="line-modified"> 62         return newArgs;</span>
 63     }
 64 
 65     private static void appendParsedCommandArgs(List&lt;String&gt; newArgs, List&lt;String&gt; args) throws IOException {
 66         for (String arg : args) {
 67             if (arg.length() &gt; 1 &amp;&amp; arg.charAt(0) == &#39;@&#39;) {
 68                 arg = arg.substring(1);
 69                 if (arg.charAt(0) == &#39;@&#39;) {
 70                     newArgs.add(arg);
 71                 } else {
 72                     loadCmdFile(arg, newArgs);
 73                 }
 74             } else {
 75                 newArgs.add(arg);
 76             }
 77         }
 78     }
 79 
 80     /**
 81      * Process the given environment variable and appends any Win32-style
 82      * command files for the specified command line arguments and return
 83      * the resulting arguments. A command file argument
 84      * is of the form &#39;@file&#39; where &#39;file&#39; is the name of the file whose
 85      * contents are to be parsed for additional arguments. The contents of
 86      * the command file are parsed using StreamTokenizer and the original
 87      * &#39;@file&#39; argument replaced with the resulting tokens. Recursive command
 88      * files are not supported. The &#39;@&#39; character itself can be quoted with
 89      * the sequence &#39;@@&#39;.
 90      * @param envVariable the env variable to process
 91      * @param args the arguments that may contain @files
 92      * @return the arguments, with environment variable&#39;s content and expansion of @files
 93      * @throws IOException if there is a problem reading any of the @files
 94      * @throws com.sun.tools.javac.main.CommandLine.UnmatchedQuote
 95      */
 96     public static List&lt;String&gt; parse(String envVariable, List&lt;String&gt; args)
 97             throws IOException, UnmatchedQuote {
 98 
 99         List&lt;String&gt; inArgs = new ArrayList&lt;&gt;();
100         appendParsedEnvVariables(inArgs, envVariable);
101         inArgs.addAll(args);
102         List&lt;String&gt; newArgs = new ArrayList&lt;&gt;();
103         appendParsedCommandArgs(newArgs, inArgs);
104         return newArgs;
105     }
106 
<a name="3" id="anc3"></a>




















107     private static void loadCmdFile(String name, List&lt;String&gt; args) throws IOException {
108         try (Reader r = Files.newBufferedReader(Paths.get(name), Charset.defaultCharset())) {
109             Tokenizer t = new Tokenizer(r);
110             String s;
111             while ((s = t.nextToken()) != null) {
112                 args.add(s);
113             }
114         }
115     }
116 
117     public static class Tokenizer {
118         private final Reader in;
119         private int ch;
120 
121         public Tokenizer(Reader in) throws IOException {
122             this.in = in;
123             ch = in.read();
124         }
125 
126         public String nextToken() throws IOException {
127             skipWhite();
128             if (ch == -1) {
129                 return null;
130             }
131 
132             StringBuilder sb = new StringBuilder();
133             char quoteChar = 0;
134 
135             while (ch != -1) {
136                 switch (ch) {
137                     case &#39; &#39;:
138                     case &#39;\t&#39;:
139                     case &#39;\f&#39;:
140                         if (quoteChar == 0) {
141                             return sb.toString();
142                         }
143                         sb.append((char) ch);
144                         break;
145 
146                     case &#39;\n&#39;:
147                     case &#39;\r&#39;:
148                         return sb.toString();
149 
150                     case &#39;\&#39;&#39;:
151                     case &#39;&quot;&#39;:
152                         if (quoteChar == 0) {
153                             quoteChar = (char) ch;
154                         } else if (quoteChar == ch) {
155                             quoteChar = 0;
156                         } else {
157                             sb.append((char) ch);
158                         }
159                         break;
160 
161                     case &#39;\\&#39;:
162                         if (quoteChar != 0) {
163                             ch = in.read();
164                             switch (ch) {
165                                 case &#39;\n&#39;:
166                                 case &#39;\r&#39;:
167                                     while (ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39; || ch == &#39;\f&#39;) {
168                                         ch = in.read();
169                                     }
170                                     continue;
171 
172                                 case &#39;n&#39;:
173                                     ch = &#39;\n&#39;;
174                                     break;
175                                 case &#39;r&#39;:
176                                     ch = &#39;\r&#39;;
177                                     break;
178                                 case &#39;t&#39;:
179                                     ch = &#39;\t&#39;;
180                                     break;
181                                 case &#39;f&#39;:
182                                     ch = &#39;\f&#39;;
183                                     break;
184                             }
185                         }
186                         sb.append((char) ch);
187                         break;
188 
189                     default:
190                         sb.append((char) ch);
191                 }
192 
193                 ch = in.read();
194             }
195 
196             return sb.toString();
197         }
198 
199         void skipWhite() throws IOException {
200             while (ch != -1) {
201                 switch (ch) {
202                     case &#39; &#39;:
203                     case &#39;\t&#39;:
204                     case &#39;\n&#39;:
205                     case &#39;\r&#39;:
206                     case &#39;\f&#39;:
207                         break;
208 
209                     case &#39;#&#39;:
210                         ch = in.read();
211                         while (ch != &#39;\n&#39; &amp;&amp; ch != &#39;\r&#39; &amp;&amp; ch != -1) {
212                             ch = in.read();
213                         }
214                         break;
215 
216                     default:
217                         return;
218                 }
219 
220                 ch = in.read();
221             }
222         }
223     }
224 
225     @SuppressWarnings(&quot;fallthrough&quot;)
226     private static void appendParsedEnvVariables(List&lt;String&gt; newArgs, String envVariable)
227             throws UnmatchedQuote {
228 
229         if (envVariable == null) {
230             return;
231         }
232         String in = System.getenv(envVariable);
233         if (in == null || in.trim().isEmpty()) {
234             return;
235         }
236 
237         final char NUL = (char)0;
238         final int len = in.length();
239 
240         int pos = 0;
241         StringBuilder sb = new StringBuilder();
242         char quote = NUL;
243         char ch;
244 
245         loop:
246         while (pos &lt; len) {
247             ch = in.charAt(pos);
248             switch (ch) {
249                 case &#39;\&quot;&#39;: case &#39;\&#39;&#39;:
250                     if (quote == NUL) {
251                         quote = ch;
252                     } else if (quote == ch) {
253                         quote = NUL;
254                     } else {
255                         sb.append(ch);
256                     }
257                     pos++;
258                     break;
259                 case &#39;\f&#39;: case &#39;\n&#39;: case &#39;\r&#39;: case &#39;\t&#39;: case &#39; &#39;:
260                     if (quote == NUL) {
261                         newArgs.add(sb.toString());
262                         sb.setLength(0);
263                         while (ch == &#39;\f&#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39; || ch == &#39; &#39;) {
264                             pos++;
265                             if (pos &gt;= len) {
266                                 break loop;
267                             }
268                             ch = in.charAt(pos);
269                         }
270                         break;
271                     }
272                     // fall through
273                 default:
274                     sb.append(ch);
275                     pos++;
276             }
277         }
278         if (sb.length() != 0) {
279             newArgs.add(sb.toString());
280         }
281         if (quote != NUL) {
282             throw new UnmatchedQuote(envVariable);
283         }
284     }
285 
286     public static class UnmatchedQuote extends Exception {
287         private static final long serialVersionUID = 0;
288 
289         public final String variableName;
290 
291         UnmatchedQuote(String variable) {
292             this.variableName = variable;
293         }
294     }
295 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
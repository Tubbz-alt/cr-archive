<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/main/Arguments.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.main;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.EnumSet;
 35 import java.util.HashSet;
 36 import java.util.Iterator;
 37 import java.util.LinkedHashMap;
 38 import java.util.LinkedHashSet;
 39 import java.util.Map;
 40 import java.util.Set;
 41 import java.util.function.Predicate;
 42 import java.util.regex.Matcher;
 43 import java.util.regex.Pattern;
 44 import java.util.stream.Stream;
 45 
 46 import javax.lang.model.SourceVersion;
 47 import javax.tools.JavaFileManager;
 48 import javax.tools.JavaFileManager.Location;
 49 import javax.tools.JavaFileObject;
 50 import javax.tools.JavaFileObject.Kind;
 51 import javax.tools.StandardJavaFileManager;
 52 import javax.tools.StandardLocation;
 53 
 54 import com.sun.tools.doclint.DocLint;
 55 import com.sun.tools.javac.code.Lint.LintCategory;
 56 import com.sun.tools.javac.code.Source;
 57 import com.sun.tools.javac.file.BaseFileManager;
 58 import com.sun.tools.javac.file.JavacFileManager;
 59 import com.sun.tools.javac.jvm.Profile;
 60 import com.sun.tools.javac.jvm.Target;
 61 import com.sun.tools.javac.main.OptionHelper.GrumpyHelper;
 62 import com.sun.tools.javac.platform.PlatformDescription;
 63 import com.sun.tools.javac.platform.PlatformUtils;
 64 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 65 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 66 import com.sun.tools.javac.util.Context;
 67 import com.sun.tools.javac.util.JCDiagnostic;
 68 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticInfo;
 69 import com.sun.tools.javac.util.List;
 70 import com.sun.tools.javac.util.ListBuffer;
 71 import com.sun.tools.javac.util.Log;
 72 import com.sun.tools.javac.util.Log.PrefixKind;
 73 import com.sun.tools.javac.util.Log.WriterKind;
 74 import com.sun.tools.javac.util.Options;
 75 import com.sun.tools.javac.util.PropagatedException;
 76 
 77 /**
 78  * Shared option and argument handling for command line and API usage of javac.
 79  */
 80 public class Arguments {
 81 
 82     /**
 83      * The context key for the arguments.
 84      */
 85     public static final Context.Key&lt;Arguments&gt; argsKey = new Context.Key&lt;&gt;();
 86 
 87     private String ownName;
 88     private Set&lt;String&gt; classNames;
 89     private Set&lt;Path&gt; files;
 90     private Map&lt;Option, String&gt; deferredFileManagerOptions;
 91     private Set&lt;JavaFileObject&gt; fileObjects;
 92     private boolean emptyAllowed;
 93     private final Options options;
 94 
 95     private JavaFileManager fileManager;
 96     private final Log log;
 97     private final Context context;
 98 
 99     private enum ErrorMode { ILLEGAL_ARGUMENT, ILLEGAL_STATE, LOG };
100     private ErrorMode errorMode;
101     private boolean errors;
102 
103     /**
104      * Gets the Arguments instance for this context.
105      *
106      * @param context the content
107      * @return the Arguments instance for this context.
108      */
109     public static Arguments instance(Context context) {
110         Arguments instance = context.get(argsKey);
111         if (instance == null) {
112             instance = new Arguments(context);
113         }
114         return instance;
115     }
116 
117     protected Arguments(Context context) {
118         context.put(argsKey, this);
119         options = Options.instance(context);
120         log = Log.instance(context);
121         this.context = context;
122 
123         // Ideally, we could init this here and update/configure it as
124         // needed, but right now, initializing a file manager triggers
125         // initialization of other items in the context, such as Lint
126         // and FSInfo, which should not be initialized until after
127         // processArgs
128         //        fileManager = context.get(JavaFileManager.class);
129     }
130 
131     private final OptionHelper cmdLineHelper = new OptionHelper() {
132         @Override
133         public String get(Option option) {
134             return options.get(option);
135         }
136 
137         @Override
138         public void put(String name, String value) {
139             options.put(name, value);
140         }
141 
142         @Override
143         public void remove(String name) {
144             options.remove(name);
145         }
146 
147         @Override
148         public boolean handleFileManagerOption(Option option, String value) {
149             options.put(option, value);
150             deferredFileManagerOptions.put(option, value);
151             return true;
152         }
153 
154         @Override
155         public Log getLog() {
156             return log;
157         }
158 
159         @Override
160         public String getOwnName() {
161             return ownName;
162         }
163 
164         @Override
165         public void addFile(Path p) {
166             files.add(p);
167         }
168 
169         @Override
170         public void addClassName(String s) {
171             classNames.add(s);
172         }
173 
174     };
175 
176     /**
177      * Initializes this Args instance with a set of command line args.
178      * The args will be processed in conjunction with the full set of
179      * command line options, including -help, -version etc.
180      * The args may also contain class names and filenames.
181      * Any errors during this call, and later during validate, will be reported
182      * to the log.
183      * @param ownName the name of this tool; used to prefix messages
184      * @param args the args to be processed
185      */
186     public void init(String ownName, Iterable&lt;String&gt; args) {
187         this.ownName = ownName;
188         errorMode = ErrorMode.LOG;
189         files = new LinkedHashSet&lt;&gt;();
190         deferredFileManagerOptions = new LinkedHashMap&lt;&gt;();
191         fileObjects = null;
192         classNames = new LinkedHashSet&lt;&gt;();
193         processArgs(args, Option.getJavaCompilerOptions(), cmdLineHelper, true, false);
194         if (errors) {
195             log.printLines(PrefixKind.JAVAC, &quot;msg.usage&quot;, ownName);
196         }
197     }
198 
199     private final OptionHelper apiHelper = new GrumpyHelper(null) {
200         @Override
201         public String get(Option option) {
202             return options.get(option);
203         }
204 
205         @Override
206         public void put(String name, String value) {
207             options.put(name, value);
208         }
209 
210         @Override
211         public void remove(String name) {
212             options.remove(name);
213         }
214 
215         @Override
216         public Log getLog() {
217             return Arguments.this.log;
218         }
219     };
220 
221     /**
222      * Initializes this Args instance with the parameters for a JavacTask.
223      * The options will be processed in conjunction with the restricted set
224      * of tool options, which does not include -help, -version, etc,
225      * nor does it include classes and filenames, which should be specified
226      * separately.
227      * File manager options are handled directly by the file manager.
228      * Any errors found while processing individual args will be reported
229      * via IllegalArgumentException.
230      * Any subsequent errors during validate will be reported via IllegalStateException.
231      * @param ownName the name of this tool; used to prefix messages
232      * @param options the options to be processed
233      * @param classNames the classes to be subject to annotation processing
234      * @param files the files to be compiled
235      */
236     public void init(String ownName,
237             Iterable&lt;String&gt; options,
238             Iterable&lt;String&gt; classNames,
239             Iterable&lt;? extends JavaFileObject&gt; files) {
240         this.ownName = ownName;
241         this.classNames = toSet(classNames);
242         this.fileObjects = toSet(files);
243         this.files = null;
244         errorMode = ErrorMode.ILLEGAL_ARGUMENT;
245         if (options != null) {
246             processArgs(toList(options), Option.getJavacToolOptions(), apiHelper, false, true);
247         }
248         errorMode = ErrorMode.ILLEGAL_STATE;
249     }
250 
251     /**
252      * Minimal initialization for tools, like javadoc,
253      * to be able to process javac options for themselves,
254      * and then call validate.
255      * @param ownName  the name of this tool; used to prefix messages
256      */
257     public void init(String ownName) {
258         this.ownName = ownName;
259         errorMode = ErrorMode.LOG;
260     }
261 
262     /**
263      * Gets the files to be compiled.
264      * @return the files to be compiled
265      */
266     public Set&lt;JavaFileObject&gt; getFileObjects() {
267         if (fileObjects == null) {
268             fileObjects = new LinkedHashSet&lt;&gt;();
269         }
270         if (files != null) {
271             JavacFileManager jfm = (JavacFileManager) getFileManager();
272             for (JavaFileObject fo: jfm.getJavaFileObjectsFromPaths(files))
273                 fileObjects.add(fo);
274         }
275         return fileObjects;
276     }
277 
278     /**
279      * Gets the classes to be subject to annotation processing.
280      * @return the classes to be subject to annotation processing
281      */
282     public Set&lt;String&gt; getClassNames() {
283         return classNames;
284     }
285 
286     /**
287      * Handles the {@code --release} option.
288      *
289      * @param additionalOptions a predicate to handle additional options implied by the
290      * {@code --release} option. The predicate should return true if all the additional
291      * options were processed successfully.
292      * @return true if successful, false otherwise
293      */
294     public boolean handleReleaseOptions(Predicate&lt;Iterable&lt;String&gt;&gt; additionalOptions) {
295         String platformString = options.get(Option.RELEASE);
296 
297         checkOptionAllowed(platformString == null,
298                 option -&gt; reportDiag(Errors.ReleaseBootclasspathConflict(option)),
299                 Option.BOOT_CLASS_PATH, Option.XBOOTCLASSPATH, Option.XBOOTCLASSPATH_APPEND,
300                 Option.XBOOTCLASSPATH_PREPEND,
301                 Option.ENDORSEDDIRS, Option.DJAVA_ENDORSED_DIRS,
302                 Option.EXTDIRS, Option.DJAVA_EXT_DIRS,
303                 Option.SOURCE, Option.TARGET,
304                 Option.SYSTEM, Option.UPGRADE_MODULE_PATH);
305 
306         if (platformString != null) {
307             PlatformDescription platformDescription =
308                     PlatformUtils.lookupPlatformDescription(platformString);
309 
310             if (platformDescription == null) {
311                 reportDiag(Errors.UnsupportedReleaseVersion(platformString));
312                 return false;
313             }
314 
315             options.put(Option.SOURCE, platformDescription.getSourceVersion());
316             options.put(Option.TARGET, platformDescription.getTargetVersion());
317 
318             context.put(PlatformDescription.class, platformDescription);
319 
320             if (!additionalOptions.test(platformDescription.getAdditionalOptions()))
321                 return false;
322 
323             JavaFileManager platformFM = platformDescription.getFileManager();
324             DelegatingJavaFileManager.installReleaseFileManager(context,
325                                                                 platformFM,
326                                                                 getFileManager());
327         }
328 
329         return true;
330     }
331 
332     /**
333      * Processes strings containing options and operands.
334      * @param args the strings to be processed
335      * @param allowableOpts the set of option declarations that are applicable
336      * @param helper a help for use by Option.process
337      * @param allowOperands whether or not to check for files and classes
338      * @param checkFileManager whether or not to check if the file manager can handle
339      *      options which are not recognized by any of allowableOpts
340      * @return true if all the strings were successfully processed; false otherwise
341      * @throws IllegalArgumentException if a problem occurs and errorMode is set to
342      *      ILLEGAL_ARGUMENT
343      */
344     private boolean processArgs(Iterable&lt;String&gt; args,
345             Set&lt;Option&gt; allowableOpts, OptionHelper helper,
346             boolean allowOperands, boolean checkFileManager) {
347         if (!doProcessArgs(args, allowableOpts, helper, allowOperands, checkFileManager))
348             return false;
349 
350         if (!handleReleaseOptions(extra -&gt; doProcessArgs(extra, allowableOpts, helper, allowOperands, checkFileManager)))
351             return false;
352 
353         options.notifyListeners();
354 
355         return true;
356     }
357 
358     private boolean doProcessArgs(Iterable&lt;String&gt; args,
359             Set&lt;Option&gt; allowableOpts, OptionHelper helper,
360             boolean allowOperands, boolean checkFileManager) {
361         JavaFileManager fm = checkFileManager ? getFileManager() : null;
362         Iterator&lt;String&gt; argIter = args.iterator();
363         while (argIter.hasNext()) {
364             String arg = argIter.next();
365             if (arg.isEmpty()) {
366                 reportDiag(Errors.InvalidFlag(arg));
367                 return false;
368             }
369 
370             Option option = null;
371 
372             // first, check the provided set of javac options
373             if (arg.startsWith(&quot;-&quot;)) {
374                 option = Option.lookup(arg, allowableOpts);
375             } else if (allowOperands &amp;&amp; Option.SOURCEFILE.matches(arg)) {
376                 option = Option.SOURCEFILE;
377             }
378 
379             if (option != null) {
380                 try {
381                     option.handleOption(helper, arg, argIter);
382                 } catch (Option.InvalidValueException e) {
383                     error(e);
384                     return false;
385                 }
386                 continue;
387             }
388 
389             // check file manager option
390             if (fm != null &amp;&amp; fm.handleOption(arg, argIter)) {
391                 continue;
392             }
393 
394             // none of the above
395             reportDiag(Errors.InvalidFlag(arg));
396             return false;
397         }
398 
399         return true;
400     }
401 
402     /**
403      * Validates the overall consistency of the options and operands
404      * processed by processOptions.
405      * @return true if all args are successfully validated; false otherwise.
406      * @throws IllegalStateException if a problem is found and errorMode is set to
407      *      ILLEGAL_STATE
408      */
409     public boolean validate() {
410         JavaFileManager fm = getFileManager();
411         if (options.isSet(Option.MODULE)) {
412             if (!fm.hasLocation(StandardLocation.CLASS_OUTPUT)) {
413                 log.error(Errors.OutputDirMustBeSpecifiedWithDashMOption);
414             } else if (!fm.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {
415                 log.error(Errors.ModulesourcepathMustBeSpecifiedWithDashMOption);
416             } else {
417                 java.util.List&lt;String&gt; modules = Arrays.asList(options.get(Option.MODULE).split(&quot;,&quot;));
418                 try {
419                     for (String module : modules) {
420                         Location sourceLoc = fm.getLocationForModule(StandardLocation.MODULE_SOURCE_PATH, module);
421                         if (sourceLoc == null) {
422                             log.error(Errors.ModuleNotFoundInModuleSourcePath(module));
423                         } else {
424                             Location classLoc = fm.getLocationForModule(StandardLocation.CLASS_OUTPUT, module);
425 
426                             for (JavaFileObject file : fm.list(sourceLoc, &quot;&quot;, EnumSet.of(JavaFileObject.Kind.SOURCE), true)) {
427                                 String className = fm.inferBinaryName(sourceLoc, file);
428                                 JavaFileObject classFile = fm.getJavaFileForInput(classLoc, className, Kind.CLASS);
429 
430                                 if (classFile == null || classFile.getLastModified() &lt; file.getLastModified()) {
431                                     if (fileObjects == null)
432                                         fileObjects = new HashSet&lt;&gt;();
433                                     fileObjects.add(file);
434                                 }
435                             }
436                         }
437                     }
438                 } catch (IOException ex) {
439                     log.printLines(PrefixKind.JAVAC, &quot;msg.io&quot;);
440                     ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
441                     return false;
442                 }
443             }
444         }
445 
446         if (isEmpty()) {
447             // It is allowed to compile nothing if just asking for help or version info.
448             // But also note that none of these options are supported in API mode.
449             if (options.isSet(Option.HELP)
450                     || options.isSet(Option.X)
451                     || options.isSet(Option.VERSION)
452                     || options.isSet(Option.FULLVERSION)
453                     || options.isSet(Option.MODULE)) {
454                 return true;
455             }
456 
457             if (!emptyAllowed) {
458                 if (!errors) {
459                     if (JavaCompiler.explicitAnnotationProcessingRequested(options)) {
460                         reportDiag(Errors.NoSourceFilesClasses);
461                     } else {
462                         reportDiag(Errors.NoSourceFiles);
463                     }
464                 }
465                 return false;
466             }
467         }
468 
469         if (!checkDirectory(Option.D)) {
470             return false;
471         }
472         if (!checkDirectory(Option.S)) {
473             return false;
474         }
475         if (!checkDirectory(Option.H)) {
476             return false;
477         }
478 
479         // The following checks are to help avoid accidental confusion between
480         // directories of modules and exploded module directories.
481         if (fm instanceof StandardJavaFileManager) {
482             StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;
483             if (sfm.hasLocation(StandardLocation.CLASS_OUTPUT)) {
484                 Path outDir = sfm.getLocationAsPaths(StandardLocation.CLASS_OUTPUT).iterator().next();
485                 if (sfm.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {
486                     // multi-module mode
487                     if (Files.exists(outDir.resolve(&quot;module-info.class&quot;))) {
488                         log.error(Errors.MultiModuleOutdirCannotBeExplodedModule(outDir));
489                     }
490                 } else {
491                     // single-module or legacy mode
492                     boolean lintPaths = options.isUnset(Option.XLINT_CUSTOM,
493                             &quot;-&quot; + LintCategory.PATH.option);
494                     if (lintPaths) {
495                         Path outDirParent = outDir.getParent();
496                         if (outDirParent != null &amp;&amp; Files.exists(outDirParent.resolve(&quot;module-info.class&quot;))) {
497                             log.warning(LintCategory.PATH, Warnings.OutdirIsInExplodedModule(outDir));
498                         }
499                     }
500                 }
501             }
502         }
503 
504 
505         String sourceString = options.get(Option.SOURCE);
506         Source source = (sourceString != null)
507                 ? Source.lookup(sourceString)
508                 : Source.DEFAULT;
509         String targetString = options.get(Option.TARGET);
510         Target target = (targetString != null)
511                 ? Target.lookup(targetString)
512                 : Target.DEFAULT;
513 
514         // We don&#39;t check source/target consistency for CLDC, as J2ME
515         // profiles are not aligned with J2SE targets; moreover, a
516         // single CLDC target may have many profiles.  In addition,
517         // this is needed for the continued functioning of the JSR14
518         // prototype.
519         if (Character.isDigit(target.name.charAt(0))) {
520             if (target.compareTo(source.requiredTarget()) &lt; 0) {
521                 if (targetString != null) {
522                     if (sourceString == null) {
523                         reportDiag(Warnings.TargetDefaultSourceConflict(targetString, source.requiredTarget()));
524                     } else {
525                         reportDiag(Warnings.SourceTargetConflict(sourceString, source.requiredTarget()));
526                     }
527                     return false;
528                 } else {
529                     target = source.requiredTarget();
530                     options.put(&quot;-target&quot;, target.name);
531                 }
532             }
533         }
534 
535         if (options.isSet(Option.PREVIEW)) {
536             if (sourceString == null) {
537                 //enable-preview must be used with explicit -source or --release
538                 report(Errors.PreviewWithoutSourceOrRelease);
539                 return false;
540             } else if (source != Source.DEFAULT) {
541                 //enable-preview must be used with latest source version
542                 report(Errors.PreviewNotLatest(sourceString, Source.DEFAULT));
543                 return false;
544             }
545         }
546 
547         String profileString = options.get(Option.PROFILE);
548         if (profileString != null) {
549             Profile profile = Profile.lookup(profileString);
550             if (!profile.isValid(target)) {
551                 reportDiag(Warnings.ProfileTargetConflict(profile, target));
552             }
553 
554             // This check is only effective in command line mode,
555             // where the file manager options are added to options
556             if (options.get(Option.BOOT_CLASS_PATH) != null) {
557                 reportDiag(Errors.ProfileBootclasspathConflict);
558             }
559         }
560 
561         if (options.isSet(Option.SOURCE_PATH) &amp;&amp; options.isSet(Option.MODULE_SOURCE_PATH)) {
562             reportDiag(Errors.SourcepathModulesourcepathConflict);
563         }
564 
565         boolean lintOptions = options.isUnset(Option.XLINT_CUSTOM, &quot;-&quot; + LintCategory.OPTIONS.option);
566         if (lintOptions &amp;&amp; source.compareTo(Source.DEFAULT) &lt; 0 &amp;&amp; !options.isSet(Option.RELEASE)) {
567             if (fm instanceof BaseFileManager) {
568                 if (source.compareTo(Source.JDK8) &lt;= 0) {
569                     if (((BaseFileManager) fm).isDefaultBootClassPath())
570                         log.warning(LintCategory.OPTIONS, Warnings.SourceNoBootclasspath(source.name));
571                 } else {
572                     if (((BaseFileManager) fm).isDefaultSystemModulesPath())
573                         log.warning(LintCategory.OPTIONS, Warnings.SourceNoSystemModulesPath(source.name));
574                 }
575             }
576         }
577 
578         boolean obsoleteOptionFound = false;
579 
580         if (source.compareTo(Source.MIN) &lt; 0) {
581             log.error(Errors.OptionRemovedSource(source.name, Source.MIN.name));
582         } else if (source == Source.MIN &amp;&amp; lintOptions) {
583             log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteSource(source.name));
584             obsoleteOptionFound = true;
585         }
586 
587         if (target.compareTo(Target.MIN) &lt; 0) {
588             log.error(Errors.OptionRemovedTarget(target, Target.MIN));
589         } else if (target == Target.MIN &amp;&amp; lintOptions) {
590             log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteTarget(target));
591             obsoleteOptionFound = true;
592         }
593 
594         final Target t = target;
595         checkOptionAllowed(t.compareTo(Target.JDK1_8) &lt;= 0,
596                 option -&gt; reportDiag(Errors.OptionNotAllowedWithTarget(option, t)),
597                 Option.BOOT_CLASS_PATH,
598                 Option.XBOOTCLASSPATH_PREPEND, Option.XBOOTCLASSPATH, Option.XBOOTCLASSPATH_APPEND,
599                 Option.ENDORSEDDIRS, Option.DJAVA_ENDORSED_DIRS,
600                 Option.EXTDIRS, Option.DJAVA_EXT_DIRS,
601                 Option.PROFILE);
602 
603         checkOptionAllowed(t.compareTo(Target.JDK1_9) &gt;= 0,
604                 option -&gt; reportDiag(Errors.OptionNotAllowedWithTarget(option, t)),
605                 Option.MODULE_SOURCE_PATH, Option.UPGRADE_MODULE_PATH,
606                 Option.SYSTEM, Option.MODULE_PATH, Option.ADD_MODULES,
607                 Option.ADD_EXPORTS, Option.ADD_OPENS, Option.ADD_READS,
608                 Option.LIMIT_MODULES,
609                 Option.PATCH_MODULE);
610 
611         if (lintOptions &amp;&amp; options.isSet(Option.PARAMETERS) &amp;&amp; !target.hasMethodParameters()) {
612             log.warning(Warnings.OptionParametersUnsupported(target, Target.JDK1_8));
613         }
614 
615         if (fm.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {
616             if (!options.isSet(Option.PROC, &quot;only&quot;)
617                     &amp;&amp; !fm.hasLocation(StandardLocation.CLASS_OUTPUT)) {
618                 log.error(Errors.NoOutputDir);
619             }
620         }
621 
622         if (fm.hasLocation(StandardLocation.ANNOTATION_PROCESSOR_MODULE_PATH) &amp;&amp;
623             fm.hasLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH)) {
624             log.error(Errors.ProcessorpathNoProcessormodulepath);
625         }
626 
627         if (obsoleteOptionFound &amp;&amp; lintOptions) {
628             log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteSuppression);
629         }
630 
631         SourceVersion sv = Source.toSourceVersion(source);
632         validateAddExports(sv);
633         validateAddModules(sv);
634         validateAddReads(sv);
635         validateLimitModules(sv);
636         validateDefaultModuleForCreatedFiles(sv);
637 
638         if (lintOptions &amp;&amp; options.isSet(Option.ADD_OPENS)) {
639             log.warning(LintCategory.OPTIONS, Warnings.AddopensIgnored);
640         }
641 
642         return !errors &amp;&amp; (log.nerrors == 0);
643     }
644 
645     private void validateAddExports(SourceVersion sv) {
646         String addExports = options.get(Option.ADD_EXPORTS);
647         if (addExports != null) {
648             // Each entry must be of the form sourceModule/sourcePackage=target-list where
649             // target-list is a comma separated list of module or ALL-UNNAMED.
650             // Empty items in the target-list are ignored.
651             // There must be at least one item in the list; this is handled in Option.ADD_EXPORTS.
652             Pattern p = Option.ADD_EXPORTS.getPattern();
653             for (String e : addExports.split(&quot;\0&quot;)) {
654                 Matcher m = p.matcher(e);
655                 if (m.matches()) {
656                     String sourceModuleName = m.group(1);
657                     if (!SourceVersion.isName(sourceModuleName, sv)) {
658                         // syntactically invalid source name:  e.g. --add-exports m!/p1=m2
659                         log.warning(Warnings.BadNameForOption(Option.ADD_EXPORTS, sourceModuleName));
660                     }
661                     String sourcePackageName = m.group(2);
662                     if (!SourceVersion.isName(sourcePackageName, sv)) {
663                         // syntactically invalid source name:  e.g. --add-exports m1/p!=m2
664                         log.warning(Warnings.BadNameForOption(Option.ADD_EXPORTS, sourcePackageName));
665                     }
666 
667                     String targetNames = m.group(3);
668                     for (String targetName : targetNames.split(&quot;,&quot;)) {
669                         switch (targetName) {
670                             case &quot;&quot;:
671                             case &quot;ALL-UNNAMED&quot;:
672                                 break;
673 
674                             default:
675                                 if (!SourceVersion.isName(targetName, sv)) {
676                                     // syntactically invalid target name:  e.g. --add-exports m1/p1=m!
677                                     log.warning(Warnings.BadNameForOption(Option.ADD_EXPORTS, targetName));
678                                 }
679                                 break;
680                         }
681                     }
682                 }
683             }
684         }
685     }
686 
687     private void validateAddReads(SourceVersion sv) {
688         String addReads = options.get(Option.ADD_READS);
689         if (addReads != null) {
690             // Each entry must be of the form source=target-list where target-list is a
691             // comma-separated list of module or ALL-UNNAMED.
692             // Empty items in the target list are ignored.
693             // There must be at least one item in the list; this is handled in Option.ADD_READS.
694             Pattern p = Option.ADD_READS.getPattern();
695             for (String e : addReads.split(&quot;\0&quot;)) {
696                 Matcher m = p.matcher(e);
697                 if (m.matches()) {
698                     String sourceName = m.group(1);
699                     if (!SourceVersion.isName(sourceName, sv)) {
700                         // syntactically invalid source name:  e.g. --add-reads m!=m2
701                         log.warning(Warnings.BadNameForOption(Option.ADD_READS, sourceName));
702                     }
703 
704                     String targetNames = m.group(2);
705                     for (String targetName : targetNames.split(&quot;,&quot;, -1)) {
706                         switch (targetName) {
707                             case &quot;&quot;:
708                             case &quot;ALL-UNNAMED&quot;:
709                                 break;
710 
711                             default:
712                                 if (!SourceVersion.isName(targetName, sv)) {
713                                     // syntactically invalid target name:  e.g. --add-reads m1=m!
714                                     log.warning(Warnings.BadNameForOption(Option.ADD_READS, targetName));
715                                 }
716                                 break;
717                         }
718                     }
719                 }
720             }
721         }
722     }
723 
724     private void validateAddModules(SourceVersion sv) {
725         String addModules = options.get(Option.ADD_MODULES);
726         if (addModules != null) {
727             // Each entry must be of the form target-list where target-list is a
728             // comma separated list of module names, or ALL-DEFAULT, ALL-SYSTEM,
729             // or ALL-MODULE_PATH.
730             // Empty items in the target list are ignored.
731             // There must be at least one item in the list; this is handled in Option.ADD_MODULES.
732             for (String moduleName : addModules.split(&quot;,&quot;)) {
733                 switch (moduleName) {
734                     case &quot;&quot;:
735                     case &quot;ALL-SYSTEM&quot;:
736                     case &quot;ALL-MODULE-PATH&quot;:
737                         break;
738 
739                     default:
740                         if (!SourceVersion.isName(moduleName, sv)) {
741                             // syntactically invalid module name:  e.g. --add-modules m1,m!
742                             log.error(Errors.BadNameForOption(Option.ADD_MODULES, moduleName));
743                         }
744                         break;
745                 }
746             }
747         }
748     }
749 
750     private void validateLimitModules(SourceVersion sv) {
751         String limitModules = options.get(Option.LIMIT_MODULES);
752         if (limitModules != null) {
753             // Each entry must be of the form target-list where target-list is a
754             // comma separated list of module names, or ALL-DEFAULT, ALL-SYSTEM,
755             // or ALL-MODULE_PATH.
756             // Empty items in the target list are ignored.
757             // There must be at least one item in the list; this is handled in Option.LIMIT_EXPORTS.
758             for (String moduleName : limitModules.split(&quot;,&quot;)) {
759                 switch (moduleName) {
760                     case &quot;&quot;:
761                         break;
762 
763                     default:
764                         if (!SourceVersion.isName(moduleName, sv)) {
765                             // syntactically invalid module name:  e.g. --limit-modules m1,m!
766                             log.error(Errors.BadNameForOption(Option.LIMIT_MODULES, moduleName));
767                         }
768                         break;
769                 }
770             }
771         }
772     }
773 
774     private void validateDefaultModuleForCreatedFiles(SourceVersion sv) {
775         String moduleName = options.get(Option.DEFAULT_MODULE_FOR_CREATED_FILES);
776         if (moduleName != null) {
777             if (!SourceVersion.isName(moduleName, sv)) {
778                 // syntactically invalid module name:  e.g. --default-module-for-created-files m!
779                 log.error(Errors.BadNameForOption(Option.DEFAULT_MODULE_FOR_CREATED_FILES,
780                                                   moduleName));
781             }
782         }
783     }
784 
785     /**
786      * Returns true if there are no files or classes specified for use.
787      * @return true if there are no files or classes specified for use
788      */
789     public boolean isEmpty() {
790         return ((files == null) || files.isEmpty())
791                 &amp;&amp; ((fileObjects == null) || fileObjects.isEmpty())
792                 &amp;&amp; (classNames == null || classNames.isEmpty());
793     }
794 
795     public void allowEmpty() {
796         this.emptyAllowed = true;
797     }
798 
799     /**
800      * Gets the file manager options which may have been deferred
801      * during processArgs.
802      * @return the deferred file manager options
803      */
804     public Map&lt;Option, String&gt; getDeferredFileManagerOptions() {
805         return deferredFileManagerOptions;
806     }
807 
808     /**
809      * Gets any options specifying plugins to be run.
810      * @return options for plugins
811      */
812     public Set&lt;List&lt;String&gt;&gt; getPluginOpts() {
813         String plugins = options.get(Option.PLUGIN);
814         if (plugins == null)
815             return Collections.emptySet();
816 
817         Set&lt;List&lt;String&gt;&gt; pluginOpts = new LinkedHashSet&lt;&gt;();
818         for (String plugin: plugins.split(&quot;\\x00&quot;)) {
819             pluginOpts.add(List.from(plugin.split(&quot;\\s+&quot;)));
820         }
821         return Collections.unmodifiableSet(pluginOpts);
822     }
823 
824     /**
825      * Gets any options specifying how doclint should be run.
826      * An empty list is returned if no doclint options are specified
827      * or if the only doclint option is -Xdoclint:none.
828      * @return options for doclint
829      */
830     public List&lt;String&gt; getDocLintOpts() {
831         String xdoclint = options.get(Option.XDOCLINT);
832         String xdoclintCustom = options.get(Option.XDOCLINT_CUSTOM);
833         if (xdoclint == null &amp;&amp; xdoclintCustom == null)
834             return List.nil();
835 
836         Set&lt;String&gt; doclintOpts = new LinkedHashSet&lt;&gt;();
837         if (xdoclint != null)
838             doclintOpts.add(DocLint.XMSGS_OPTION);
839         if (xdoclintCustom != null) {
840             for (String s: xdoclintCustom.split(&quot;\\s+&quot;)) {
841                 if (s.isEmpty())
842                     continue;
843                 doclintOpts.add(DocLint.XMSGS_CUSTOM_PREFIX + s);
844             }
845         }
846 
847         if (doclintOpts.equals(Collections.singleton(DocLint.XMSGS_CUSTOM_PREFIX + &quot;none&quot;)))
848             return List.nil();
849 
850         String checkPackages = options.get(Option.XDOCLINT_PACKAGE);
851         if (checkPackages != null) {
852             doclintOpts.add(DocLint.XCHECK_PACKAGE + checkPackages);
853         }
854 
855         String format = options.get(Option.DOCLINT_FORMAT);
856         if (format != null) {
857             doclintOpts.add(DocLint.XHTML_VERSION_PREFIX + format);
858         }
859 
860         return List.from(doclintOpts.toArray(new String[doclintOpts.size()]));
861     }
862 
863     private boolean checkDirectory(Option option) {
864         String value = options.get(option);
865         if (value == null) {
866             return true;
867         }
868         Path file = Paths.get(value);
869         if (Files.exists(file) &amp;&amp; !Files.isDirectory(file)) {
870             reportDiag(Errors.FileNotDirectory(value));
871             return false;
872         }
873         return true;
874     }
875 
876     private interface ErrorReporter {
877         void report(Option o);
878     }
879 
880     void checkOptionAllowed(boolean allowed, ErrorReporter r, Option... opts) {
881         if (!allowed) {
882             Stream.of(opts)
883                   .filter(options :: isSet)
884                   .forEach(r :: report);
885         }
886     }
887 
888     void reportDiag(DiagnosticInfo diag) {
889         errors = true;
890         switch (errorMode) {
891             case ILLEGAL_ARGUMENT: {
892                 String msg = log.localize(diag);
893                 throw new PropagatedException(new IllegalArgumentException(msg));
894             }
895             case ILLEGAL_STATE: {
896                 String msg = log.localize(diag);
897                 throw new PropagatedException(new IllegalStateException(msg));
898             }
899             case LOG:
900                 report(diag);
901         }
902     }
903 
904     void error(Option.InvalidValueException f) {
905         String msg = f.getMessage();
906         errors = true;
907         switch (errorMode) {
908             case ILLEGAL_ARGUMENT: {
909                 throw new PropagatedException(new IllegalArgumentException(msg, f.getCause()));
910             }
911             case ILLEGAL_STATE: {
912                 throw new PropagatedException(new IllegalStateException(msg, f.getCause()));
913             }
914             case LOG:
915                 log.printRawLines(msg);
916         }
917     }
918 
919     private void report(DiagnosticInfo diag) {
920         // Would be good to have support for -XDrawDiagnostics here
921         if (diag instanceof JCDiagnostic.Error) {
922             log.error((JCDiagnostic.Error)diag);
923         } else if (diag instanceof JCDiagnostic.Warning){
924             log.warning((JCDiagnostic.Warning)diag);
925         }
926     }
927 
928     private JavaFileManager getFileManager() {
929         if (fileManager == null)
930             fileManager = context.get(JavaFileManager.class);
931         return fileManager;
932     }
933 
934     &lt;T&gt; ListBuffer&lt;T&gt; toList(Iterable&lt;? extends T&gt; items) {
935         ListBuffer&lt;T&gt; list = new ListBuffer&lt;&gt;();
936         if (items != null) {
937             for (T item : items) {
938                 list.add(item);
939             }
940         }
941         return list;
942     }
943 
944     &lt;T&gt; Set&lt;T&gt; toSet(Iterable&lt;? extends T&gt; items) {
945         Set&lt;T&gt; set = new LinkedHashSet&lt;&gt;();
946         if (items != null) {
947             for (T item : items) {
948                 set.add(item);
949             }
950         }
951         return set;
952     }
953 }
    </pre>
  </body>
</html>
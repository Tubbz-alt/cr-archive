<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.compiler/share/classes/javax/lang/model/SourceVersion.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.lang.model;
 27 
 28 import java.util.Collections;
 29 import java.util.Set;
 30 import java.util.HashSet;
 31 
 32 /**
 33  * Source versions of the Java&amp;trade; programming language.
 34  *
 35  * See the appropriate edition of
 36  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
 37  * for information about a particular source version.
 38  *
 39  * &lt;p&gt;Note that additional source version constants will be added to
 40  * model future releases of the language.
 41  *
 42  * @author Joseph D. Darcy
 43  * @author Scott Seligman
 44  * @author Peter von der Ah&amp;eacute;
 45  * @since 1.6
 46  */
 47 public enum SourceVersion {
 48     /*
 49      * Summary of language evolution
 50      * 1.1: nested classes
 51      * 1.2: strictfp
 52      * 1.3: no changes
 53      * 1.4: assert
 54      * 1.5: annotations, generics, autoboxing, var-args...
 55      * 1.6: no changes
 56      * 1.7: diamond syntax, try-with-resources, etc.
 57      * 1.8: lambda expressions and default methods
 58      *   9: modules, small cleanups to 1.7 and 1.8 changes
 59      *  10: local-variable type inference (var)
 60      *  11: local-variable syntax for lambda parameters
 61      *  12: no changes (switch expressions in preview)
 62      *  13: no changes (switch expressions and text blocks in preview)
 63      *  14: switch expressions (pattern matching and records in
 64      *      preview, text blocks in preview again)
 65      *  15: text blocks (records and pattern matching in preview again)
 66      */
 67 
 68     /**
 69      * The original version.
 70      *
 71      * The language described in
 72      * &lt;cite&gt;The Java&amp;trade; Language Specification, First Edition&lt;/cite&gt;.
 73      */
 74     RELEASE_0,
 75 
 76     /**
 77      * The version recognized by the Java Platform 1.1.
 78      *
 79      * The language is {@code RELEASE_0} augmented with nested classes as described in the 1.1 update to
 80      * &lt;cite&gt;The Java&amp;trade; Language Specification, First Edition&lt;/cite&gt;.
 81      */
 82     RELEASE_1,
 83 
 84     /**
 85      * The version recognized by the Java 2 Platform, Standard Edition,
 86      * v 1.2.
 87      *
 88      * The language described in
 89      * &lt;cite&gt;The Java&amp;trade; Language Specification,
 90      * Second Edition&lt;/cite&gt;, which includes the {@code
 91      * strictfp} modifier.
 92      */
 93     RELEASE_2,
 94 
 95     /**
 96      * The version recognized by the Java 2 Platform, Standard Edition,
 97      * v 1.3.
 98      *
 99      * No major changes from {@code RELEASE_2}.
100      */
101     RELEASE_3,
102 
103     /**
104      * The version recognized by the Java 2 Platform, Standard Edition,
105      * v 1.4.
106      *
107      * Added a simple assertion facility.
108      */
109     RELEASE_4,
110 
111     /**
112      * The version recognized by the Java 2 Platform, Standard
113      * Edition 5.0.
114      *
115      * The language described in
116      * &lt;cite&gt;The Java&amp;trade; Language Specification,
117      * Third Edition&lt;/cite&gt;.  First release to support
118      * generics, annotations, autoboxing, var-args, enhanced {@code
119      * for} loop, and hexadecimal floating-point literals.
120      */
121     RELEASE_5,
122 
123     /**
124      * The version recognized by the Java Platform, Standard Edition
125      * 6.
126      *
127      * No major changes from {@code RELEASE_5}.
128      */
129     RELEASE_6,
130 
131     /**
132      * The version recognized by the Java Platform, Standard Edition
133      * 7.
134      *
135      * Additions in this release include, diamond syntax for
136      * constructors, {@code try}-with-resources, strings in switch,
137      * binary literals, and multi-catch.
138      * @since 1.7
139      */
140     RELEASE_7,
141 
142     /**
143      * The version recognized by the Java Platform, Standard Edition
144      * 8.
145      *
146      * Additions in this release include lambda expressions and default methods.
147      * @since 1.8
148      */
149     RELEASE_8,
150 
151     /**
152      * The version recognized by the Java Platform, Standard Edition
153      * 9.
154      *
155      * Additions in this release include modules and removal of a
156      * single underscore from the set of legal identifier names.
157      *
158      * @since 9
159      */
160      RELEASE_9,
161 
162     /**
163      * The version recognized by the Java Platform, Standard Edition
164      * 10.
165      *
166      * Additions in this release include local-variable type inference
167      * ({@code var}).
168      *
169      * @since 10
170      */
171      RELEASE_10,
172 
173     /**
174      * The version recognized by the Java Platform, Standard Edition
175      * 11.
176      *
177      * Additions in this release include local-variable syntax for
178      * lambda parameters.
179      *
180      * @since 11
181      */
182      RELEASE_11,
183 
184     /**
185      * The version recognized by the Java Platform, Standard Edition
186      * 12.
187      *
188      * @since 12
189      */
190      RELEASE_12,
191 
192     /**
193      * The version recognized by the Java Platform, Standard Edition
194      * 13.
195      *
196      * @since 13
197      */
198      RELEASE_13,
199 
200     /**
201      * The version recognized by the Java Platform, Standard Edition
202      * 14.
203      *
204      * Additions in this release include switch expressions.
205      *
206      * @since 14
207      */
208     RELEASE_14,
209 
210     /**
211      * The version recognized by the Java Platform, Standard Edition
212      * 15.
213      *
214      * Additions in this release include text blocks.
215      *
216      * @since 15
217      */
218      RELEASE_15;
219 
220     // Note that when adding constants for newer releases, the
221     // behavior of latest() and latestSupported() must be updated too.
222 
223     /**
224      * Returns the latest source version that can be modeled.
225      *
226      * @return the latest source version that can be modeled
227      */
228     public static SourceVersion latest() {
229         return RELEASE_15;
230     }
231 
232     private static final SourceVersion latestSupported = getLatestSupported();
233 
234     /*
235      * The integer version to enum constant mapping implemented by
236      * this method assumes the JEP 322: &quot;Time-Based Release
237      * Versioning&quot; scheme is in effect. This scheme began in JDK
238      * 10. If the JDK versioning scheme is revised, this method may
239      * need to be updated accordingly.
240      */
241     private static SourceVersion getLatestSupported() {
242         int intVersion = Runtime.version().feature();
243         return (intVersion &gt;= 11) ?
244             valueOf(&quot;RELEASE_&quot; + Math.min(15, intVersion)):
245             RELEASE_10;
246     }
247 
248     /**
249      * Returns the latest source version fully supported by the
250      * current execution environment.  {@code RELEASE_9} or later must
251      * be returned.
252      *
253      * @apiNote This method is included alongside {@link latest} to
254      * allow identification of situations where the language model API
255      * is running on a platform version different than the latest
256      * version modeled by the API. One way that sort of situation can
257      * occur is if an IDE or similar tool is using the API to model
258      * source version &lt;i&gt;N&lt;/i&gt; while running on platform version
259      * (&lt;i&gt;N&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1). Running in this configuration is
260      * supported by the API. Running an API on platform versions
261      * earlier than (&lt;i&gt;N&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1) or later than &lt;i&gt;N&lt;/i&gt;
262      * may or may not work as an implementation detail. If an
263      * annotation processor was generating code to run under the
264      * current execution environment, the processor should only use
265      * platform features up to the {@code latestSupported} release,
266      * which may be earlier than the {@code latest} release.
267      *
268      * @return the latest source version that is fully supported
269      */
270     public static SourceVersion latestSupported() {
271         return latestSupported;
272     }
273 
274     /**
275      * Returns whether or not {@code name} is a syntactically valid
276      * identifier (simple name) or keyword in the latest source
277      * version.  The method returns {@code true} if the name consists
278      * of an initial character for which {@link
279      * Character#isJavaIdentifierStart(int)} returns {@code true},
280      * followed only by characters for which {@link
281      * Character#isJavaIdentifierPart(int)} returns {@code true}.
282      * This pattern matches regular identifiers, keywords, restricted
283      * keywords, restricted identifiers and the literals {@code &quot;true&quot;},
284      * {@code &quot;false&quot;}, {@code &quot;null&quot;}.
285      *
286      * The method returns {@code false} for all other strings.
287      *
288      * @param name the string to check
289      * @return {@code true} if this string is a
290      * syntactically valid identifier or keyword, {@code false}
291      * otherwise.
292      *
293      * @jls 3.8 Identifiers
294      */
295     public static boolean isIdentifier(CharSequence name) {
296         String id = name.toString();
297 
298         if (id.length() == 0) {
299             return false;
300         }
301         int cp = id.codePointAt(0);
302         if (!Character.isJavaIdentifierStart(cp)) {
303             return false;
304         }
305         for (int i = Character.charCount(cp);
306                 i &lt; id.length();
307                 i += Character.charCount(cp)) {
308             cp = id.codePointAt(i);
309             if (!Character.isJavaIdentifierPart(cp)) {
310                 return false;
311             }
312         }
313         return true;
314     }
315 
316     /**
317      * Returns whether or not {@code name} is a syntactically valid
318      * qualified name in the latest source version.
319      *
320      * Syntactically, a qualified name is a sequence of identifiers
321      * separated by period characters (&quot;{@code .}&quot;). This method
322      * splits the input string into period-separated segments and
323      * applies checks to each segment in turn.
324      *
325      * Unlike {@link #isIdentifier isIdentifier}, this method returns
326      * {@code false} for keywords, boolean literals, and the null
327      * literal in any segment.
328      *
329      * This method returns {@code true} for &lt;i&gt;restricted
330      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;.
331      *
332      * @param name the string to check
333      * @return {@code true} if this string is a
334      * syntactically valid name, {@code false} otherwise.
335      * @jls 3.9 Keywords
336      * @jls 6.2 Names and Identifiers
337      */
338     public static boolean isName(CharSequence name) {
339         return isName(name, latest());
340     }
341 
342     /**
343      * Returns whether or not {@code name} is a syntactically valid
344      * qualified name in the given source version.
345      *
346      * Syntactically, a qualified name is a sequence of identifiers
347      * separated by period characters (&quot;{@code .}&quot;). This method
348      * splits the input string into period-separated segments and
349      * applies checks to each segment in turn.
350      *
351      * Unlike {@link #isIdentifier isIdentifier}, this method returns
352      * {@code false} for keywords, boolean literals, and the null
353      * literal in any segment.
354      *
355      * This method returns {@code true} for &lt;i&gt;restricted
356      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;.
357      *
358      * @param name the string to check
359      * @param version the version to use
360      * @return {@code true} if this string is a
361      * syntactically valid name, {@code false} otherwise.
362      * @jls 3.9 Keywords
363      * @jls 6.2 Names and Identifiers
364      * @since 9
365      */
366     public static boolean isName(CharSequence name, SourceVersion version) {
367         String id = name.toString();
368 
369         for(String s : id.split(&quot;\\.&quot;, -1)) {
370             if (!isIdentifier(s) || isKeyword(s, version))
371                 return false;
372         }
373         return true;
374     }
375 
376     /**
377      * Returns whether or not {@code s} is a keyword, boolean literal,
378      * or null literal in the latest source version.
379      * This method returns {@code false} for &lt;i&gt;restricted
380      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;.
381      *
382      * @param s the string to check
383      * @return {@code true} if {@code s} is a keyword, or boolean
384      * literal, or null literal, {@code false} otherwise.
385      * @jls 3.9 Keywords
386      * @jls 3.10.3 Boolean Literals
387      * @jls 3.10.7 The Null Literal
388      */
389     public static boolean isKeyword(CharSequence s) {
390         return isKeyword(s, latest());
391     }
392 
393     /**
394      * Returns whether or not {@code s} is a keyword, boolean literal,
395      * or null literal in the given source version.
396      * This method returns {@code false} for &lt;i&gt;restricted
397      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;.
398      *
399      * @param s the string to check
400      * @param version the version to use
401      * @return {@code true} if {@code s} is a keyword, or boolean
402      * literal, or null literal, {@code false} otherwise.
403      * @jls 3.9 Keywords
404      * @jls 3.10.3 Boolean Literals
405      * @jls 3.10.7 The Null Literal
406      * @since 9
407      */
408     public static boolean isKeyword(CharSequence s, SourceVersion version) {
409         String id = s.toString();
410         switch(id) {
411             // A trip through history
412         case &quot;strictfp&quot;:
413             return version.compareTo(RELEASE_2) &gt;= 0;
414 
415         case &quot;assert&quot;:
416             return version.compareTo(RELEASE_4) &gt;= 0;
417 
418         case &quot;enum&quot;:
419             return version.compareTo(RELEASE_5) &gt;= 0;
420 
421         case &quot;_&quot;:
422             return version.compareTo(RELEASE_9) &gt;= 0;
423 
424             // Keywords common across versions
425 
426             // Modifiers
427         case &quot;public&quot;:    case &quot;protected&quot;: case &quot;private&quot;:
428         case &quot;abstract&quot;:  case &quot;static&quot;:    case &quot;final&quot;:
429         case &quot;transient&quot;: case &quot;volatile&quot;:  case &quot;synchronized&quot;:
430         case &quot;native&quot;:
431 
432             // Declarations
433         case &quot;class&quot;:     case &quot;interface&quot;: case &quot;extends&quot;:
434         case &quot;package&quot;:   case &quot;throws&quot;:    case &quot;implements&quot;:
435 
436             // Primitive types and void
437         case &quot;boolean&quot;:   case &quot;byte&quot;:      case &quot;char&quot;:
438         case &quot;short&quot;:     case &quot;int&quot;:       case &quot;long&quot;:
439         case &quot;float&quot;:     case &quot;double&quot;:
440         case &quot;void&quot;:
441 
442             // Control flow
443         case &quot;if&quot;:      case &quot;else&quot;:
444         case &quot;try&quot;:     case &quot;catch&quot;:    case &quot;finally&quot;:
445         case &quot;do&quot;:      case &quot;while&quot;:
446         case &quot;for&quot;:     case &quot;continue&quot;:
447         case &quot;switch&quot;:  case &quot;case&quot;:     case &quot;default&quot;:
448         case &quot;break&quot;:   case &quot;throw&quot;:    case &quot;return&quot;:
449 
450             // Other keywords
451         case  &quot;this&quot;:   case &quot;new&quot;:      case &quot;super&quot;:
452         case &quot;import&quot;:  case &quot;instanceof&quot;:
453 
454             // Forbidden!
455         case &quot;goto&quot;:        case &quot;const&quot;:
456 
457             // literals
458         case &quot;null&quot;:         case &quot;true&quot;:       case &quot;false&quot;:
459             return true;
460 
461         default:
462             return false;
463         }
464     }
465 }
    </pre>
  </body>
</html>
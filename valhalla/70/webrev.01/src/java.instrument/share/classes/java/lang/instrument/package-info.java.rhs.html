<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.instrument/share/classes/java/lang/instrument/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Copyright 2003 Wily Technology, Inc.
 28  */
 29 
 30 /**
 31  * Provides services that allow Java programming language agents to instrument
 32  * programs running on the JVM. The mechanism for instrumentation is modification
 33  * of the byte-codes of methods.
 34  *
<a name="2" id="anc2"></a>






 35  * &lt;p&gt; An agent is deployed as a JAR file. An attribute in the JAR file manifest
 36  * specifies the agent class which will be loaded to start the agent. Agents can
 37  * be started in several ways:
 38  *
 39  * &lt;ol&gt;
 40  *   &lt;li&gt;&lt;p&gt; For implementations that support a command-line interface, an agent
 41  *   can be started by specifying an option on the command-line. &lt;/p&gt;&lt;/li&gt;
 42  *
 43  *   &lt;li&gt;&lt;p&gt; An implementation may support a mechanism to start agents some time
 44  *   after the VM has started. For example, an implementation may provide a
 45  *   mechanism that allows a tool to &lt;i&gt;attach&lt;/i&gt; to a running application, and
 46  *   initiate the loading of the tool&#39;s agent into the running application. &lt;/p&gt;&lt;/li&gt;
 47  *
 48  *   &lt;li&gt;&lt;p&gt; An agent may be packaged with an application in an executable JAR
 49  *   file.&lt;/p&gt;&lt;/li&gt;
 50  * &lt;/ol&gt;
 51  *
<a name="3" id="anc3"></a><span class="line-modified"> 52  * &lt;p&gt; Agents can transform classes in arbitrary ways at load time, transform</span>
<span class="line-added"> 53  * modules, or transform the bytecode of methods of already loaded classes.</span>
<span class="line-added"> 54  * Developers or administrators that deploy agents, deploy applications that</span>
<span class="line-added"> 55  * package an agent with the application, or use tools that load agents into a</span>
<span class="line-added"> 56  * running application, are responsible for verifying the trustworthiness of each</span>
<span class="line-added"> 57  * agent including the content and structure of the agent JAR file.</span>
 58  *
<a name="4" id="anc4"></a><span class="line-added"> 59  * &lt;p&gt; The three ways to start an agent are described below.</span>
 60  *
 61  * &lt;h2&gt;Starting an Agent from the Command-Line Interface&lt;/h2&gt;
 62  *
 63  * &lt;p&gt; Where an implementation provides a means to start agents from the
 64  * command-line interface, an agent is started by adding the following option
 65  * to the command-line:
 66  *
 67  * &lt;blockquote&gt;{@code
 68  *     -javaagent:&lt;jarpath&gt;[=&lt;options&gt;]
 69  * }&lt;/blockquote&gt;
 70  *
 71  * where &lt;i&gt;{@code &lt;jarpath&gt;}&lt;/i&gt; is the path to the agent JAR file and
 72  * &lt;i&gt;{@code &lt;options&gt;}&lt;/i&gt; is the agent options.
 73  *
 74  * &lt;p&gt; The manifest of the agent JAR file must contain the attribute {@code
 75  * Premain-Class} in its main manifest. The value of this attribute is the
 76  * name of the &lt;i&gt;agent class&lt;/i&gt;. The agent class must implement a public
 77  * static {@code premain} method similar in principle to the {@code main}
 78  * application entry point. After the Java Virtual Machine (JVM) has
 79  * initialized, the {@code premain} method will be called, then the real
 80  * application {@code main} method. The {@code premain} method must return
 81  * in order for the startup to proceed.
 82  *
 83  * &lt;p&gt; The {@code premain} method has one of two possible signatures. The
 84  * JVM first attempts to invoke the following method on the agent class:
 85  *
 86  * &lt;blockquote&gt;{@code
 87  *     public static void premain(String agentArgs, Instrumentation inst)
 88  * }&lt;/blockquote&gt;
 89  *
 90  * &lt;p&gt; If the agent class does not implement this method then the JVM will
 91  * attempt to invoke:
 92  * &lt;blockquote&gt;{@code
 93  *     public static void premain(String agentArgs)
 94  * }&lt;/blockquote&gt;
 95 
 96  * &lt;p&gt; The agent class may also have an {@code agentmain} method for use when
 97  * the agent is started after VM startup (see below). When the agent is started
 98  * using a command-line option, the {@code agentmain} method is not invoked.
 99  *
100  * &lt;p&gt; Each agent is passed its agent options via the {@code agentArgs} parameter.
101  * The agent options are passed as a single string, any additional parsing
102  * should be performed by the agent itself.
103  *
104  * &lt;p&gt; If the agent cannot be started (for example, because the agent class
105  * cannot be loaded, or because the agent class does not have an appropriate
106  * {@code premain} method), the JVM will abort. If a {@code premain} method
107  * throws an uncaught exception, the JVM will abort.
108  *
109  * &lt;p&gt; An implementation is not required to provide a way to start agents
110  * from the command-line interface. When it does, then it supports the
111  * {@code -javaagent} option as specified above. The {@code -javaagent} option
112  * may be used multiple times on the same command-line, thus starting multiple
113  * agents. The {@code premain} methods will be called in the order that the
114  * agents are specified on the command line. More than one agent may use the
115  * same &lt;i&gt;{@code &lt;jarpath&gt;}&lt;/i&gt;.
116  *
117  * &lt;p&gt; There are no modeling restrictions on what the agent {@code premain}
118  * method may do. Anything application {@code main} can do, including creating
119  * threads, is legal from {@code premain}.
120  *
121  *
122  * &lt;h2&gt;Starting an Agent After VM Startup&lt;/h2&gt;
123  *
124  * &lt;p&gt; An implementation may provide a mechanism to start agents sometime after
125  * the the VM has started. The details as to how this is initiated are
126  * implementation specific but typically the application has already started and
127  * its {@code main} method has already been invoked. In cases where an
128  * implementation supports the starting of agents after the VM has started the
129  * following applies:
130  *
131  * &lt;ol&gt;
132  *
133  *   &lt;li&gt;&lt;p&gt; The manifest of the agent JAR must contain the attribute {@code
134  *   Agent-Class} in its main manfiest. The value of this attribute is the name
135  *   of the &lt;i&gt;agent class&lt;/i&gt;. &lt;/p&gt;&lt;/li&gt;
136  *
137  *   &lt;li&gt;&lt;p&gt; The agent class must implement a public static {@code agentmain}
138  *   method. &lt;/p&gt;&lt;/li&gt;
139  *
140  * &lt;/ol&gt;
141  *
142  * &lt;p&gt; The {@code agentmain} method has one of two possible signatures. The JVM
143  * first attempts to invoke the following method on the agent class:
144  *
145  * &lt;blockquote&gt;{@code
146  *     public static void agentmain(String agentArgs, Instrumentation inst)
147  * }&lt;/blockquote&gt;
148  *
149  * &lt;p&gt; If the agent class does not implement this method then the JVM will
150  * attempt to invoke:
151  *
152  * &lt;blockquote&gt;{@code
153  *     public static void agentmain(String agentArgs)
154  * }&lt;/blockquote&gt;
155  *
156  * &lt;p&gt; The agent class may also have a {@code premain} method for use when the
157  * agent is started using a command-line option. When the agent is started after
158  * VM startup the {@code premain} method is not invoked.
159  *
160  * &lt;p&gt; The agent is passed its agent options via the {@code agentArgs}
161  * parameter. The agent options are passed as a single string, any additional
162  * parsing should be performed by the agent itself.
163  *
164  * &lt;p&gt; The {@code agentmain} method should do any necessary initialization
165  * required to start the agent. When startup is complete the method should
166  * return. If the agent cannot be started (for example, because the agent class
167  * cannot be loaded, or because the agent class does not have a conformant
168  * {@code agentmain} method), the JVM will not abort. If the {@code agentmain}
169  * method throws an uncaught exception it will be ignored (but may be logged
170  * by the JVM for troubleshooting purposes).
171  *
172  *
173  * &lt;h2&gt;Including an Agent in an Executable JAR file&lt;/h2&gt;
174  *
175  * &lt;p&gt; The JAR File Specification defines manifest attributes for standalone
176  * applications that are packaged as &lt;em&gt;executable JAR files&lt;/em&gt;. If an
177  * implementation supports a mechanism to start an application as an executable
178  * JAR then the main manifest may include the {@code Launcher-Agent-Class}
179  * attribute to specify the class name of an agent to start before the application
180  * {@code main} method is invoked. The Java virtual machine attempts to
181  * invoke the following method on the agent class:
182  *
183  * &lt;blockquote&gt;{@code
184  *     public static void agentmain(String agentArgs, Instrumentation inst)
185  * }&lt;/blockquote&gt;
186  *
187  * &lt;p&gt; If the agent class does not implement this method then the JVM will
188  * attempt to invoke:
189  *
190  * &lt;blockquote&gt;{@code
191  *     public static void agentmain(String agentArgs)
192  * }&lt;/blockquote&gt;
193  *
194  * &lt;p&gt; The value of the {@code agentArgs} parameter is always the empty string.
195  *
196  * &lt;p&gt; The {@code agentmain} method should do any necessary initialization
197  * required to start the agent and return. If the agent cannot be started, for
198  * example the agent class cannot be loaded, the agent class does not define a
199  * conformant {@code agentmain} method, or the {@code agentmain} method throws
200  * an uncaught exception or error, the JVM will abort.
201  *
202  *
203  * &lt;h2&gt; Loading agent classes and the modules/classes available to the agent
204  * class &lt;/h2&gt;
205  *
206  * &lt;p&gt; Classes loaded from the agent JAR file are loaded by the
207  * {@linkplain ClassLoader#getSystemClassLoader() system class loader} and are
208  * members of the system class loader&#39;s {@linkplain ClassLoader#getUnnamedModule()
209  * unnamed module}. The system class loader typically defines the class containing
210  * the application {@code main} method too.
211  *
212  * &lt;p&gt; The classes visible to the agent class are the classes visible to the system
213  * class loader and minimally include:
214  *
215  * &lt;ul&gt;
216  *
217  *   &lt;li&gt;&lt;p&gt; The classes in packages exported by the modules in the {@linkplain
218  *   ModuleLayer#boot() boot layer}. Whether the boot layer contains all platform
219  *   modules or not will depend on the initial module or how the application was
220  *   started. &lt;/p&gt;&lt;/li&gt;
221  *
222  *   &lt;li&gt;&lt;p&gt; The classes that can be defined by the system class loader (typically
223  *   the class path) to be members of its unnamed module. &lt;/p&gt;&lt;/li&gt;
224  *
225  *   &lt;li&gt;&lt;p&gt; Any classes that the agent arranges to be defined by the bootstrap
226  *   class loader to be members of its unnamed module. &lt;/p&gt;&lt;/li&gt;
227  *
228  * &lt;/ul&gt;
229  *
230  * &lt;p&gt; If agent classes need to link to classes in platform (or other) modules
231  * that are not in the boot layer then the application may need to be started in
232  * a way that ensures that these modules are in the boot layer. In the JDK
233  * implementation for example, the {@code --add-modules} command line option can
234  * be used to add modules to the set of root modules to resolve at startup. &lt;/p&gt;
235  *
236  * &lt;p&gt; Supporting classes that the agent arranges to be loaded by the bootstrap
237  * class loader (by means of {@link Instrumentation#appendToBootstrapClassLoaderSearch
238  * appendToBootstrapClassLoaderSearch} or the {@code Boot-Class-Path} attribute
239  * specified below), must link only to classes defined to the bootstrap class loader.
240  * There is no guarantee that all platform classes can be defined by the boot
241  * class loader.
242  *
243  * &lt;p&gt; If a custom system class loader is configured (by means of the system property
244  * {@code java.system.class.loader} as specified in the {@link
245  * ClassLoader#getSystemClassLoader() getSystemClassLoader} method) then it must
246  * define the {@code appendToClassPathForInstrumentation} method as specified in
247  * {@link Instrumentation#appendToSystemClassLoaderSearch appendToSystemClassLoaderSearch}.
248  * In other words, a custom system class loader must support the mechanism to
249  * add an agent JAR file to the system class loader search.
250  *
251  * &lt;h2&gt;Manifest Attributes&lt;/h2&gt;
252  *
253  * &lt;p&gt; The following manifest attributes are defined for an agent JAR file:
254  *
255  * &lt;blockquote&gt;&lt;dl&gt;
256  *
257  * &lt;dt&gt;{@code Premain-Class}&lt;/dt&gt;
258  * &lt;dd&gt; When an agent is specified at JVM launch time this attribute specifies
259  * the agent class. That is, the class containing the {@code premain} method.
260  * When an agent is specified at JVM launch time this attribute is required. If
261  * the attribute is not present the JVM will abort. Note: this is a class name,
262  * not a file name or path. &lt;/dd&gt;
263  *
264  * &lt;dt&gt;{@code Agent-Class}&lt;/dt&gt;
265  * &lt;dd&gt; If an implementation supports a mechanism to start agents sometime after
266  * the VM has started then this attribute specifies the agent class. That is,
267  * the class containing the {@code agentmain} method. This attribute is required
268  * if it is not present the agent will not be started. Note: this is a class name,
269  * not a file name or path. &lt;/dd&gt;
270  *
271  * &lt;dt&gt;{@code Launcher-Agent-Class}&lt;/dt&gt;
272  * &lt;dd&gt; If an implementation supports a mechanism to start an application as an
273  * executable JAR then the main manifest may include this attribute to specify
274  * the class name of an agent to start before the application {@code main}
275  * method is invoked. &lt;/dd&gt;
276  *
277  * &lt;dt&gt;{@code Boot-Class-Path}&lt;/dt&gt;
278  * &lt;dd&gt; A list of paths to be searched by the bootstrap class loader. Paths
279  * represent directories or libraries (commonly referred to as JAR or zip
280  * libraries on many platforms). These paths are searched by the bootstrap class
281  * loader after the platform specific mechanisms of locating a class have failed.
282  * Paths are searched in the order listed. Paths in the list are separated by one
283  * or more spaces. A path takes the syntax of the path component of a hierarchical
284  * URI. The path is absolute if it begins with a slash character (&#39;/&#39;), otherwise
285  * it is relative. A relative path is resolved against the absolute path of the
286  * agent JAR file. Malformed and non-existent paths are ignored. When an agent is
287  * started sometime after the VM has started then paths that do not represent a
288  * JAR file are ignored. This attribute is optional. &lt;/dd&gt;
289  *
290  * &lt;dt&gt;{@code Can-Redefine-Classes}&lt;/dt&gt;
291  * &lt;dd&gt; Boolean ({@code true} or {@code false}, case irrelevant). Is the ability
292  * to redefine classes needed by this agent. Values other than {@code true} are
293  * considered {@code false}. This attribute is optional, the default is {@code
294  * false}. &lt;/dd&gt;
295  *
296  * &lt;dt&gt;{@code Can-Retransform-Classes}&lt;/dt&gt;
297  * &lt;dd&gt; Boolean ({@code true} or {@code false}, case irrelevant). Is the ability
298  * to retransform classes needed by this agent. Values other than {@code true}
299  * are considered {@code false}. This attribute is optional, the default is
300  * {@code false}. &lt;/dd&gt;
301  *
302  * &lt;dt&gt;{@code Can-Set-Native-Method-Prefix}&lt;/dt&gt;
303  * &lt;dd&gt; Boolean ({@code true} or {@code false}, case irrelevant). Is the ability
304  * to set native method prefix needed by this agent. Values other than {@code
305  * true} are considered {@code false}. This attribute is optional, the default
306  * is {@code false}. &lt;/dd&gt;
307  *
308  * &lt;/dl&gt;&lt;/blockquote&gt;
309  *
310  * &lt;p&gt; An agent JAR file may have both the {@code Premain-Class} and {@code
311  * Agent-Class} attributes present in the manifest. When the agent is started
312  * on the command-line using the {@code -javaagent} option then the {@code
313  * Premain-Class} attribute specifies the name of the agent class and the {@code
314  * Agent-Class} attribute is ignored. Similarly, if the agent is started sometime
315  * after the VM has started, then the {@code Agent-Class} attribute specifies
316  * the name of the agent class (the value of {@code Premain-Class} attribute is
317  * ignored).
318  *
319  *
320  * &lt;h2&gt;Instrumenting code in modules&lt;/h2&gt;
321  *
322  * &lt;p&gt; As an aid to agents that deploy supporting classes on the search path of
323  * the bootstrap class loader, or the search path of the class loader that loads
324  * the main agent class, the Java virtual machine arranges for the module of
325  * transformed classes to read the unnamed module of both class loaders.
326  *
327  * @since 1.5
328  * @revised 1.6
329  * @revised 9
330  */
331 
332 package java.lang.instrument;
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
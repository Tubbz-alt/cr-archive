<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.jpackage/windows/native/applauncher/WinLauncher.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;io.h&gt;
 27 #include &lt;fcntl.h&gt;
 28 #include &lt;windows.h&gt;
 29 
 30 #include &quot;AppLauncher.h&quot;
 31 #include &quot;JvmLauncher.h&quot;
 32 #include &quot;Log.h&quot;
 33 #include &quot;Dll.h&quot;
 34 #include &quot;Toolbox.h&quot;
 35 #include &quot;FileUtils.h&quot;
 36 #include &quot;UniqueHandle.h&quot;
 37 #include &quot;ErrorHandling.h&quot;
 38 #include &quot;WinSysInfo.h&quot;
 39 #include &quot;WinErrorHandling.h&quot;
 40 
 41 
 42 // AllowSetForegroundWindow
 43 #pragma comment(lib, &quot;user32&quot;)
 44 
 45 
 46 namespace {
 47 
 48 std::unique_ptr&lt;Dll&gt; loadDllWithAlteredPATH(const tstring&amp; dllFullPath) {
 49     LOG_TRACE_FUNCTION();
 50 
 51     const tstring vanillaPathEnvVariable = SysInfo::getEnvVariable(_T(&quot;PATH&quot;));
 52 
 53     tstring pathEnvVariable = vanillaPathEnvVariable
 54             + _T(&quot;;&quot;)
 55             + FileUtils::dirname(dllFullPath);
 56 
 57     SysInfo::setEnvVariable(_T(&quot;PATH&quot;), pathEnvVariable);
 58 
 59     LOG_TRACE(tstrings::any() &lt;&lt; &quot;New value of PATH: &quot; &lt;&lt; pathEnvVariable);
 60 
 61     // Schedule restore of PATH after attempt to load the given dll
 62     const auto resetPATH = runAtEndOfScope([&amp;vanillaPathEnvVariable]() -&gt; void {
 63         SysInfo::setEnvVariable(_T(&quot;PATH&quot;), vanillaPathEnvVariable);
 64     });
 65 
 66     return std::unique_ptr&lt;Dll&gt;(new Dll(dllFullPath));
 67 }
 68 
 69 std::unique_ptr&lt;Dll&gt; loadDllWithAddDllDirectory(const tstring&amp; dllFullPath) {
 70     LOG_TRACE_FUNCTION();
 71 
 72     const tstring dirPath = FileUtils::dirname(dllFullPath);
 73 
 74     typedef DLL_DIRECTORY_COOKIE(WINAPI *AddDllDirectoryFunc)(PCWSTR);
 75 
 76     DllFunction&lt;AddDllDirectoryFunc&gt; _AddDllDirectory(
 77             Dll(&quot;kernel32.dll&quot;, Dll::System()), &quot;AddDllDirectory&quot;);
 78 
 79     AddDllDirectoryFunc func = _AddDllDirectory;
 80     DLL_DIRECTORY_COOKIE res = func(dirPath.c_str());
 81     if (!res) {
 82         JP_THROW(SysError(tstrings::any()
 83                 &lt;&lt; &quot;AddDllDirectory(&quot; &lt;&lt; dirPath &lt;&lt; &quot;) failed&quot;, func));
 84     }
 85 
 86     LOG_TRACE(tstrings::any() &lt;&lt; &quot;AddDllDirectory(&quot; &lt;&lt; dirPath &lt;&lt; &quot;): OK&quot;);
 87 
 88     // Important: use LOAD_LIBRARY_SEARCH_DEFAULT_DIRS flag,
 89     // but not LOAD_LIBRARY_SEARCH_USER_DIRS!
 90     HMODULE dllHandle = LoadLibraryEx(dllFullPath.c_str(), NULL,
 91             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
 92 
 93     LOG_TRACE(tstrings::any() &lt;&lt; &quot;LoadLibraryEx(&quot; &lt;&lt; dllFullPath
 94             &lt;&lt; &quot;, LOAD_LIBRARY_SEARCH_DEFAULT_DIRS): &quot; &lt;&lt; dllHandle);
 95 
 96     const auto freeDll = runAtEndOfScope([&amp;dllHandle]() -&gt; void {
 97         Dll::freeLibrary(dllHandle);
 98     });
 99 
100     return std::unique_ptr&lt;Dll&gt;(new Dll(dllFullPath));
101 }
102 
103 void launchApp() {
104     // [RT-31061] otherwise UI can be left in back of other windows.
105     ::AllowSetForegroundWindow(ASFW_ANY);
106 
107     const tstring launcherPath = SysInfo::getProcessModulePath();
108     const tstring appImageRoot = FileUtils::dirname(launcherPath);
109 
110     std::unique_ptr&lt;Jvm&gt; jvm(AppLauncher()
111         .setImageRoot(appImageRoot)
112         .addJvmLibName(_T(&quot;bin\\jli.dll&quot;))
113         .setAppDir(FileUtils::mkpath() &lt;&lt; appImageRoot &lt;&lt; _T(&quot;app&quot;))
114         .setDefaultRuntimePath(FileUtils::mkpath() &lt;&lt; appImageRoot
115                 &lt;&lt; _T(&quot;runtime&quot;))
116         .createJvmLauncher());
117 
118     std::unique_ptr&lt;Dll&gt; jvmDll;
119     try {
120         // Try load JVM DLL.
121         jvmDll = std::unique_ptr&lt;Dll&gt;(new Dll(jvm-&gt;getPath()));
122     } catch (const std::exception&amp;) {
123         // JVM DLL load failed, though it exists in file system.
124         try {
125             // Try adjust the DLL search paths with AddDllDirectory() WINAPI CALL
126             jvmDll = loadDllWithAddDllDirectory(jvm-&gt;getPath());
127         } catch (const std::exception&amp;) {
128             // AddDllDirectory() didn&#39;t work. Try altering PATH environment
129             // variable as the last resort.
130             jvmDll = loadDllWithAlteredPATH(jvm-&gt;getPath());
131         }
132     }
133 
134     jvm-&gt;launch();
135 }
136 
137 } // namespace
138 
<a name="1" id="anc1"></a><span class="line-removed">139 </span>
140 #ifndef JP_LAUNCHERW
141 
<a name="2" id="anc2"></a><span class="line-modified">142 int APIENTRY wmain() {</span>
143     return AppLauncher::launch(std::nothrow, launchApp);
144 }
145 
146 #else
147 
148 namespace {
149 
150 class LastErrorGuiLogAppender : public LogAppender {
151 public:
152     virtual void append(const LogEvent&amp; v) {
153         JP_TRY;
154 
155         const std::wstring msg = (tstrings::any()
156                 &lt;&lt; AppLauncher::lastErrorMsg()).wstr();
157         MessageBox(0, msg.c_str(),
158             FileUtils::basename(SysInfo::getProcessModulePath()).c_str(),
159             MB_ICONERROR | MB_OK);
160 
161         JP_CATCH_ALL;
162     }
163 };
164 
165 
166 class Console {
167 public:
168     Console() {
169         if (!AttachConsole(ATTACH_PARENT_PROCESS)) {
170             // Failed to connect to parent&#39;s console. Create our own.
171             if (!AllocConsole()) {
172                 // We already have a console, no need to redirect std I/O.
173                 return;
174             }
175         }
176 
177         stdoutChannel = std::unique_ptr&lt;Channel&gt;(new Channel(stdout));
178         stderrChannel = std::unique_ptr&lt;Channel&gt;(new Channel(stderr));
179     }
180 
181     struct FileCloser {
182         typedef FILE* pointer;
183 
184         void operator()(pointer h) {
185             ::fclose(h);
186         }
187     };
188 
189     typedef std::unique_ptr&lt;
190         FileCloser::pointer,
191         FileCloser
192     &gt; UniqueFILEHandle;
193 
194 private:
195     class Channel {
196     public:
197         Channel(FILE* stdFILEHandle): stdFILEHandle(stdFILEHandle) {
198             const char* stdFileName = &quot;CONOUT$&quot;;
199             const char* openMode = &quot;w&quot;;
200             if (stdFILEHandle == stdin) {
201                 stdFileName = &quot;CONIN$&quot;;
202                 openMode = &quot;r&quot;;
203             }
204 
205             FILE* fp = 0;
206             freopen_s(&amp;fp, stdFileName, openMode, stdFILEHandle);
207 
208             fileHandle = UniqueFILEHandle(fp);
209 
210             std::ios_base::sync_with_stdio();
211         }
212 
213         virtual ~Channel() {
214             JP_TRY;
215 
216             FILE* fp = 0;
217             fileHandle = UniqueFILEHandle(fp);
218             std::ios_base::sync_with_stdio();
219 
220             JP_CATCH_ALL;
221         }
222 
223     private:
224         UniqueFILEHandle fileHandle;
225         FILE *stdFILEHandle;
226     };
227 
228     std::unique_ptr&lt;Channel&gt; stdoutChannel;
229     std::unique_ptr&lt;Channel&gt; stderrChannel;
230 };
231 
232 
233 void launchAppW() {
234     std::unique_ptr&lt;Console&gt; console;
235     if (AppLauncher::isWithLogging()) {
236         console = std::unique_ptr&lt;Console&gt;(new Console());
237     }
238 
239     launchApp();
240 }
241 
242 } // namespace
243 
244 
<a name="3" id="anc3"></a><span class="line-modified">245 int APIENTRY wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int) {</span>
246     LastErrorGuiLogAppender lastErrorLogAppender;
247     TeeLogAppender logAppender(&amp;AppLauncher::defaultLastErrorLogAppender(),
248             &amp;lastErrorLogAppender);
249     return AppLauncher::launch(std::nothrow, launchAppW, &amp;logAppender);
250 }
251 
252 #endif
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/langtools/src/classes/build/tools/symbolgenerator/CreateSymbols.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../build.xml.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TransitiveDependencies.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/langtools/src/classes/build/tools/symbolgenerator/CreateSymbols.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.symbolgenerator;
  27 
  28 import build.tools.symbolgenerator.CreateSymbols
  29                                   .ModuleHeaderDescription
  30                                   .ProvidesDescription;
  31 import build.tools.symbolgenerator.CreateSymbols
  32                                   .ModuleHeaderDescription
  33                                   .RequiresDescription;
  34 import java.io.BufferedInputStream;
  35 import java.io.BufferedReader;

  36 import java.io.ByteArrayInputStream;
  37 import java.io.ByteArrayOutputStream;
  38 import java.io.File;

  39 import java.io.IOException;
  40 import java.io.InputStream;
  41 import java.io.OutputStream;
  42 import java.io.StringWriter;
  43 import java.io.Writer;
  44 import java.nio.file.Files;
  45 import java.nio.file.FileVisitResult;
  46 import java.nio.file.FileVisitor;
  47 import java.nio.file.Path;
  48 import java.nio.file.Paths;
  49 import java.nio.file.attribute.BasicFileAttributes;
  50 import java.util.stream.Stream;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.Calendar;
  54 import java.util.Collection;
  55 import java.util.Collections;

  56 import java.util.EnumSet;
  57 import java.util.HashMap;
  58 import java.util.HashSet;
  59 import java.util.Iterator;
  60 import java.util.LinkedHashMap;
  61 import java.util.List;
  62 import java.util.Locale;
  63 import java.util.Map;
  64 import java.util.Map.Entry;
  65 import java.util.Objects;
  66 import java.util.Set;
  67 import java.util.TimeZone;


  68 import java.util.function.Function;
  69 import java.util.function.Predicate;
  70 import java.util.regex.Matcher;
  71 import java.util.regex.Pattern;
  72 import java.util.stream.Collectors;


  73 
  74 import javax.tools.JavaFileManager;
  75 import javax.tools.JavaFileManager.Location;
  76 import javax.tools.JavaFileObject;
  77 import javax.tools.JavaFileObject.Kind;
  78 import javax.tools.StandardLocation;
  79 
  80 import com.sun.source.util.JavacTask;
  81 import com.sun.tools.classfile.AccessFlags;
  82 import com.sun.tools.classfile.Annotation;
  83 import com.sun.tools.classfile.Annotation.Annotation_element_value;
  84 import com.sun.tools.classfile.Annotation.Array_element_value;
  85 import com.sun.tools.classfile.Annotation.Class_element_value;
  86 import com.sun.tools.classfile.Annotation.Enum_element_value;
  87 import com.sun.tools.classfile.Annotation.Primitive_element_value;
  88 import com.sun.tools.classfile.Annotation.element_value;
  89 import com.sun.tools.classfile.Annotation.element_value_pair;
  90 import com.sun.tools.classfile.AnnotationDefault_attribute;
  91 import com.sun.tools.classfile.Attribute;
  92 import com.sun.tools.classfile.Attributes;
</pre>
<hr />
<pre>
 192  * &lt;diff-against-platformN&gt; should be N + 1. If F &lt; N, then &lt;diff-against-platformN&gt; should be N - 1.
 193  * If N is a custom/specialized sub-version of another platform N&#39;, then &lt;diff-against-platformN&gt; should be N&#39;.
 194  *
 195  * To generate the .sym.txt files for OpenJDK 7 and 8:
 196  *     &lt;jdk-7&gt;/bin/java build.tools.symbolgenerator.Probe OpenJDK7.classes
 197  *     &lt;jdk-8&gt;/bin/java build.tools.symbolgenerator.Probe OpenJDK8.classes
 198  *     java build.tools.symbolgenerator.CreateSymbols build-description make/data/symbols $TOPDIR make/data/symbols/include.list
 199  *                                                    8 OpenJDK8.classes &#39;&lt;none&gt;&#39;
 200  *                                                    7 OpenJDK7.classes 8
 201  *
 202  * Note: the versions are expected to be a single character.
 203  *
 204  */
 205 public class CreateSymbols {
 206 
 207     //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;ct.sym construction&quot;&gt;
 208     /**Create sig files for ct.sym reading the classes description from the directory that contains
 209      * {@code ctDescriptionFile}, using the file as a recipe to create the sigfiles.
 210      */
 211     @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified"> 212     public void createSymbols(String ctDescriptionFileExtra, String ctDescriptionFile, String ctSymLocation) throws IOException {</span>

 213         LoadDescriptions data = load(ctDescriptionFileExtra != null ? Paths.get(ctDescriptionFileExtra)
 214                                                                     : null,
 215                                      Paths.get(ctDescriptionFile), null);
 216 
 217         splitHeaders(data.classes);
 218 
 219         Map&lt;String, Map&lt;Character, String&gt;&gt; package2Version2Module = new HashMap&lt;&gt;();

 220 
 221         for (ModuleDescription md : data.modules.values()) {
 222             for (ModuleHeaderDescription mhd : md.header) {
 223                 List&lt;String&gt; versionsList =
 224                         Collections.singletonList(mhd.versions);
<span class="line-modified"> 225                 writeModulesForVersions(ctSymLocation,</span>
 226                                         md,
 227                                         mhd,
 228                                         versionsList);
 229                 mhd.exports.stream().forEach(pkg -&gt; {
 230                     for (char v : mhd.versions.toCharArray()) {
 231                         package2Version2Module.computeIfAbsent(pkg, dummy -&gt; new HashMap&lt;&gt;()).put(v, md.name);
 232                     }
 233                 });
 234             }
 235         }
 236 
 237         for (ClassDescription classDescription : data.classes) {
 238             Map&lt;Character, String&gt; version2Module = package2Version2Module.getOrDefault(classDescription.packge().replace(&#39;.&#39;, &#39;/&#39;), Collections.emptyMap());
 239             for (ClassHeaderDescription header : classDescription.header) {
 240                 Set&lt;String&gt; jointVersions = new HashSet&lt;&gt;();
 241                 jointVersions.add(header.versions);
 242                 limitJointVersion(jointVersions, classDescription.fields);
 243                 limitJointVersion(jointVersions, classDescription.methods);
 244                 Map&lt;String, StringBuilder&gt; module2Versions = new HashMap&lt;&gt;();
 245                 for (char v : header.versions.toCharArray()) {
 246                     String module = version2Module.get(v);
 247                     if (module == null) {
 248                         if (v &gt;= &#39;9&#39;) {
 249                             throw new AssertionError(&quot;No module for &quot; + classDescription.name +
 250                                                      &quot; and version &quot; + v);
 251                         }
 252                         module = version2Module.get(&#39;9&#39;);
 253                         if (module == null) {
 254                             module = &quot;java.base&quot;;
 255                         }
 256                     }
 257                     module2Versions.computeIfAbsent(module, dummy -&gt; new StringBuilder()).append(v);
 258                 }
 259                 for (Entry&lt;String, StringBuilder&gt; e : module2Versions.entrySet()) {
 260                     Set&lt;String&gt; currentVersions = new HashSet&lt;&gt;(jointVersions);
 261                     limitJointVersion(currentVersions, e.getValue().toString());
 262                     currentVersions = currentVersions.stream().filter(vers -&gt; !disjoint(vers, e.getValue().toString())).collect(Collectors.toSet());
<span class="line-modified"> 263                     writeClassesForVersions(ctSymLocation, classDescription, header, e.getKey(), currentVersions);</span>



















 264                 }
 265             }
 266         }
 267     }
 268 







 269     public static String EXTENSION = &quot;.sig&quot;;
 270 
 271     LoadDescriptions load(Path ctDescriptionWithExtraContent, Path ctDescriptionOpen, String deletePlatform) throws IOException {
 272         Map&lt;String, PlatformInput&gt; platforms = new LinkedHashMap&lt;&gt;();
 273 
 274         if (ctDescriptionWithExtraContent != null &amp;&amp; Files.isRegularFile(ctDescriptionWithExtraContent)) {
 275             try (LineBasedReader reader = new LineBasedReader(ctDescriptionWithExtraContent)) {
 276                 while (reader.hasNext()) {
 277                     switch (reader.lineKey) {
 278                         case &quot;generate&quot;:
 279                             //ignore
 280                             reader.moveNext();
 281                             break;
 282                         case &quot;platform&quot;:
 283                             PlatformInput platform = PlatformInput.load(ctDescriptionWithExtraContent,
 284                                                                         reader);
 285                             if (!platform.version.equals(deletePlatform))
 286                                 platforms.put(platform.version, platform);
 287                             reader.moveNext();
 288                             break;
</pre>
<hr />
<pre>
 414         Map&lt;String, ModuleDescription&gt; moduleList = new HashMap&lt;&gt;();
 415 
 416         for (ModuleDescription desc : modules.values()) {
 417             Iterator&lt;ModuleHeaderDescription&gt; mhdIt = desc.header.iterator();
 418 
 419             while (mhdIt.hasNext()) {
 420                 ModuleHeaderDescription mhd = mhdIt.next();
 421 
 422                 mhd.versions = reduce(mhd.versions, generatePlatforms);
 423                 if (mhd.versions.isEmpty())
 424                     mhdIt.remove();
 425             }
 426 
 427             if (desc.header.isEmpty()) {
 428                 continue;
 429             }
 430 
 431             moduleList.put(desc.name, desc);
 432         }
 433 
<span class="line-modified"> 434         return new LoadDescriptions(result, moduleList, new ArrayList&lt;&gt;(platforms.values()));</span>


 435     }
 436 
 437     static final class LoadDescriptions {
 438         public final ClassList classes;
 439         public final Map&lt;String, ModuleDescription&gt; modules;
 440         public final List&lt;PlatformInput&gt; versions;
 441 
 442         public LoadDescriptions(ClassList classes,
 443                                 Map&lt;String, ModuleDescription&gt;  modules,
 444                                 List&lt;PlatformInput&gt; versions) {
 445             this.classes = classes;
 446             this.modules = modules;
 447             this.versions = versions;
 448         }
 449 
 450     }
 451 
 452     static final class LineBasedReader implements AutoCloseable {
 453         private final BufferedReader input;
 454         public String lineKey;
</pre>
<hr />
<pre>
 647             }
 648         }
 649     }
 650 
 651     private static boolean containsAll(String versions, String subVersions) {
 652         for (char c : subVersions.toCharArray()) {
 653             if (versions.indexOf(c) == (-1))
 654                 return false;
 655         }
 656         return true;
 657     }
 658 
 659     private static boolean disjoint(String version1, String version2) {
 660         for (char c : version2.toCharArray()) {
 661             if (version1.indexOf(c) != (-1))
 662                 return false;
 663         }
 664         return true;
 665     }
 666 
<span class="line-modified"> 667     void writeClassesForVersions(String ctSymLocation,</span>
 668                                  ClassDescription classDescription,
 669                                  ClassHeaderDescription header,
 670                                  String module,
 671                                  Iterable&lt;String&gt; versions)
 672             throws IOException {
 673         for (String ver : versions) {
<span class="line-modified"> 674             writeClass(ctSymLocation, classDescription, header, module, ver);</span>
 675         }
 676     }
 677 
<span class="line-modified"> 678     void writeModulesForVersions(String ctSymLocation,</span>
 679                                  ModuleDescription moduleDescription,
 680                                  ModuleHeaderDescription header,
 681                                  Iterable&lt;String&gt; versions)
 682             throws IOException {
 683         for (String ver : versions) {
<span class="line-modified"> 684             writeModule(ctSymLocation, moduleDescription, header, ver);</span>
 685         }
 686     }
 687 
 688     //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Class Writing&quot;&gt;
<span class="line-modified"> 689     void writeModule(String ctSymLocation,</span>
 690                     ModuleDescription moduleDescription,
 691                     ModuleHeaderDescription header,
 692                     String version) throws IOException {
 693         List&lt;CPInfo&gt; constantPool = new ArrayList&lt;&gt;();
 694         constantPool.add(null);
 695         int currentClass = addClass(constantPool, &quot;module-info&quot;);
 696         int superclass = 0;
 697         int[] interfaces = new int[0];
 698         AccessFlags flags = new AccessFlags(header.flags);
 699         Map&lt;String, Attribute&gt; attributesMap = new HashMap&lt;&gt;();
 700         addAttributes(moduleDescription, header, constantPool, attributesMap);
 701         Attributes attributes = new Attributes(attributesMap);
 702         CPInfo[] cpData = constantPool.toArray(new CPInfo[constantPool.size()]);
 703         ConstantPool cp = new ConstantPool(cpData);
 704         ClassFile classFile = new ClassFile(0xCAFEBABE,
 705                 Target.DEFAULT.minorVersion,
 706                 Target.DEFAULT.majorVersion,
 707                 cp,
 708                 flags,
 709                 currentClass,
 710                 superclass,
 711                 interfaces,
 712                 new Field[0],
 713                 new Method[0],
 714                 attributes);
 715 
<span class="line-modified"> 716         Path outputClassFile = Paths.get(ctSymLocation,</span>
<span class="line-removed"> 717                                          version,</span>
<span class="line-removed"> 718                                          moduleDescription.name,</span>
<span class="line-removed"> 719                                          &quot;module-info&quot; + EXTENSION);</span>
<span class="line-removed"> 720 </span>
<span class="line-removed"> 721         Files.createDirectories(outputClassFile.getParent());</span>
<span class="line-removed"> 722 </span>
<span class="line-removed"> 723         try (OutputStream out = Files.newOutputStream(outputClassFile)) {</span>
<span class="line-removed"> 724             ClassWriter w = new ClassWriter();</span>
<span class="line-removed"> 725 </span>
<span class="line-removed"> 726             w.write(classFile, out);</span>
<span class="line-removed"> 727         }</span>
 728     }
 729 
<span class="line-modified"> 730     void writeClass(String ctSymLocation,</span>
 731                     ClassDescription classDescription,
 732                     ClassHeaderDescription header,
 733                     String module,
 734                     String version) throws IOException {
 735         List&lt;CPInfo&gt; constantPool = new ArrayList&lt;&gt;();
 736         constantPool.add(null);
 737         List&lt;Method&gt; methods = new ArrayList&lt;&gt;();
 738         for (MethodDescription methDesc : classDescription.methods) {
 739             if (disjoint(methDesc.versions, version))
 740                 continue;
 741             Descriptor descriptor = new Descriptor(addString(constantPool, methDesc.descriptor));
 742             //TODO: LinkedHashMap to avoid param annotations vs. Signature problem in javac&#39;s ClassReader:
 743             Map&lt;String, Attribute&gt; attributesMap = new LinkedHashMap&lt;&gt;();
 744             addAttributes(methDesc, constantPool, attributesMap);
 745             Attributes attributes = new Attributes(attributesMap);
 746             AccessFlags flags = new AccessFlags(methDesc.flags);
 747             int nameString = addString(constantPool, methDesc.name);
 748             methods.add(new Method(flags, nameString, descriptor, attributes));
 749         }
 750         List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
 766         for (String intf : header.implementsAttr) {
 767             interfaces[i++] = addClass(constantPool, intf);
 768         }
 769         AccessFlags flags = new AccessFlags(header.flags);
 770         Map&lt;String, Attribute&gt; attributesMap = new HashMap&lt;&gt;();
 771         addAttributes(header, constantPool, attributesMap);
 772         Attributes attributes = new Attributes(attributesMap);
 773         ConstantPool cp = new ConstantPool(constantPool.toArray(new CPInfo[constantPool.size()]));
 774         ClassFile classFile = new ClassFile(0xCAFEBABE,
 775                 Target.DEFAULT.minorVersion,
 776                 Target.DEFAULT.majorVersion,
 777                 cp,
 778                 flags,
 779                 currentClass,
 780                 superclass,
 781                 interfaces,
 782                 fields.toArray(new Field[0]),
 783                 methods.toArray(new Method[0]),
 784                 attributes);
 785 
<span class="line-modified"> 786         Path outputClassFile = Paths.get(ctSymLocation, version);</span>

 787 
<span class="line-modified"> 788         if (module != null) {</span>
<span class="line-modified"> 789             outputClassFile = outputClassFile.resolve(module);</span>
<span class="line-modified"> 790         }</span>








 791 
<span class="line-modified"> 792         outputClassFile = outputClassFile.resolve(classDescription.name + EXTENSION);</span>





 793 
<span class="line-modified"> 794         Files.createDirectories(outputClassFile.getParent());</span>




 795 
<span class="line-modified"> 796         try (OutputStream out = Files.newOutputStream(outputClassFile)) {</span>
<span class="line-modified"> 797             ClassWriter w = new ClassWriter();</span>

 798 
<span class="line-modified"> 799             w.write(classFile, out);</span>


 800         }

 801     }
 802 
 803     private void addAttributes(ModuleDescription md,
 804                                ModuleHeaderDescription header,
 805                                List&lt;CPInfo&gt; cp,
 806                                Map&lt;String, Attribute&gt; attributes) {
 807         addGenericAttributes(header, cp, attributes);
 808         if (header.moduleResolution != null) {
 809             int attrIdx = addString(cp, Attribute.ModuleResolution);
 810             final ModuleResolution_attribute resIdx =
 811                     new ModuleResolution_attribute(attrIdx,
 812                                                    header.moduleResolution);
 813             attributes.put(Attribute.ModuleResolution, resIdx);
 814         }
 815         if (header.moduleTarget != null) {
 816             int attrIdx = addString(cp, Attribute.ModuleTarget);
 817             int targetIdx = addString(cp, header.moduleTarget);
 818             attributes.put(Attribute.ModuleTarget,
 819                            new ModuleTarget_attribute(attrIdx, targetIdx));
 820         }
</pre>
<hr />
<pre>
3710 
3711                 new CreateSymbols().createBaseLine(versions,
3712                                                    excludeList,
3713                                                    descDest,
3714                                                    args);
3715                 break;
3716             }
3717             case &quot;build-description-incremental&quot;: {
3718                 if (args.length != 3) {
3719                     help();
3720                     return ;
3721                 }
3722 
3723                 new CreateSymbols().createIncrementalBaseLine(args[1], args[2], args);
3724                 break;
3725             }
3726             case &quot;build-ctsym&quot;:
3727                 String ctDescriptionFileExtra;
3728                 String ctDescriptionFile;
3729                 String ctSymLocation;



3730 
<span class="line-modified">3731                 if (args.length == 3) {</span>
3732                     ctDescriptionFileExtra = null;
3733                     ctDescriptionFile = args[1];
3734                     ctSymLocation = args[2];
<span class="line-modified">3735                 } else if (args.length == 4) {</span>



3736                     ctDescriptionFileExtra = args[1];
3737                     ctDescriptionFile = args[2];
3738                     ctSymLocation = args[3];



3739                 } else {
3740                     help();
3741                     return ;
3742                 }
3743 





3744                 new CreateSymbols().createSymbols(ctDescriptionFileExtra,
3745                                                   ctDescriptionFile,
<span class="line-modified">3746                                                   ctSymLocation);</span>



3747                 break;
3748         }
3749     }
3750 
3751 }
</pre>
</td>
<td>
<hr />
<pre>
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.symbolgenerator;
  27 
  28 import build.tools.symbolgenerator.CreateSymbols
  29                                   .ModuleHeaderDescription
  30                                   .ProvidesDescription;
  31 import build.tools.symbolgenerator.CreateSymbols
  32                                   .ModuleHeaderDescription
  33                                   .RequiresDescription;
  34 import java.io.BufferedInputStream;
  35 import java.io.BufferedReader;
<span class="line-added">  36 import java.io.BufferedOutputStream;</span>
  37 import java.io.ByteArrayInputStream;
  38 import java.io.ByteArrayOutputStream;
  39 import java.io.File;
<span class="line-added">  40 import java.io.FileOutputStream;</span>
  41 import java.io.IOException;
  42 import java.io.InputStream;
  43 import java.io.OutputStream;
  44 import java.io.StringWriter;
  45 import java.io.Writer;
  46 import java.nio.file.Files;
  47 import java.nio.file.FileVisitResult;
  48 import java.nio.file.FileVisitor;
  49 import java.nio.file.Path;
  50 import java.nio.file.Paths;
  51 import java.nio.file.attribute.BasicFileAttributes;
  52 import java.util.stream.Stream;
  53 import java.util.ArrayList;
  54 import java.util.Arrays;
  55 import java.util.Calendar;
  56 import java.util.Collection;
  57 import java.util.Collections;
<span class="line-added">  58 import java.util.Comparator;</span>
  59 import java.util.EnumSet;
  60 import java.util.HashMap;
  61 import java.util.HashSet;
  62 import java.util.Iterator;
  63 import java.util.LinkedHashMap;
  64 import java.util.List;
  65 import java.util.Locale;
  66 import java.util.Map;
  67 import java.util.Map.Entry;
  68 import java.util.Objects;
  69 import java.util.Set;
  70 import java.util.TimeZone;
<span class="line-added">  71 import java.util.TreeMap;</span>
<span class="line-added">  72 import java.util.TreeSet;</span>
  73 import java.util.function.Function;
  74 import java.util.function.Predicate;
  75 import java.util.regex.Matcher;
  76 import java.util.regex.Pattern;
  77 import java.util.stream.Collectors;
<span class="line-added">  78 import java.util.zip.ZipEntry;</span>
<span class="line-added">  79 import java.util.zip.ZipOutputStream;</span>
  80 
  81 import javax.tools.JavaFileManager;
  82 import javax.tools.JavaFileManager.Location;
  83 import javax.tools.JavaFileObject;
  84 import javax.tools.JavaFileObject.Kind;
  85 import javax.tools.StandardLocation;
  86 
  87 import com.sun.source.util.JavacTask;
  88 import com.sun.tools.classfile.AccessFlags;
  89 import com.sun.tools.classfile.Annotation;
  90 import com.sun.tools.classfile.Annotation.Annotation_element_value;
  91 import com.sun.tools.classfile.Annotation.Array_element_value;
  92 import com.sun.tools.classfile.Annotation.Class_element_value;
  93 import com.sun.tools.classfile.Annotation.Enum_element_value;
  94 import com.sun.tools.classfile.Annotation.Primitive_element_value;
  95 import com.sun.tools.classfile.Annotation.element_value;
  96 import com.sun.tools.classfile.Annotation.element_value_pair;
  97 import com.sun.tools.classfile.AnnotationDefault_attribute;
  98 import com.sun.tools.classfile.Attribute;
  99 import com.sun.tools.classfile.Attributes;
</pre>
<hr />
<pre>
 199  * &lt;diff-against-platformN&gt; should be N + 1. If F &lt; N, then &lt;diff-against-platformN&gt; should be N - 1.
 200  * If N is a custom/specialized sub-version of another platform N&#39;, then &lt;diff-against-platformN&gt; should be N&#39;.
 201  *
 202  * To generate the .sym.txt files for OpenJDK 7 and 8:
 203  *     &lt;jdk-7&gt;/bin/java build.tools.symbolgenerator.Probe OpenJDK7.classes
 204  *     &lt;jdk-8&gt;/bin/java build.tools.symbolgenerator.Probe OpenJDK8.classes
 205  *     java build.tools.symbolgenerator.CreateSymbols build-description make/data/symbols $TOPDIR make/data/symbols/include.list
 206  *                                                    8 OpenJDK8.classes &#39;&lt;none&gt;&#39;
 207  *                                                    7 OpenJDK7.classes 8
 208  *
 209  * Note: the versions are expected to be a single character.
 210  *
 211  */
 212 public class CreateSymbols {
 213 
 214     //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;ct.sym construction&quot;&gt;
 215     /**Create sig files for ct.sym reading the classes description from the directory that contains
 216      * {@code ctDescriptionFile}, using the file as a recipe to create the sigfiles.
 217      */
 218     @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified"> 219     public void createSymbols(String ctDescriptionFileExtra, String ctDescriptionFile, String ctSymLocation,</span>
<span class="line-added"> 220                               long timestamp, String currentVersion, String systemModules) throws IOException {</span>
 221         LoadDescriptions data = load(ctDescriptionFileExtra != null ? Paths.get(ctDescriptionFileExtra)
 222                                                                     : null,
 223                                      Paths.get(ctDescriptionFile), null);
 224 
 225         splitHeaders(data.classes);
 226 
 227         Map&lt;String, Map&lt;Character, String&gt;&gt; package2Version2Module = new HashMap&lt;&gt;();
<span class="line-added"> 228         Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData = new TreeMap&lt;&gt;();</span>
 229 
 230         for (ModuleDescription md : data.modules.values()) {
 231             for (ModuleHeaderDescription mhd : md.header) {
 232                 List&lt;String&gt; versionsList =
 233                         Collections.singletonList(mhd.versions);
<span class="line-modified"> 234                 writeModulesForVersions(directory2FileData,</span>
 235                                         md,
 236                                         mhd,
 237                                         versionsList);
 238                 mhd.exports.stream().forEach(pkg -&gt; {
 239                     for (char v : mhd.versions.toCharArray()) {
 240                         package2Version2Module.computeIfAbsent(pkg, dummy -&gt; new HashMap&lt;&gt;()).put(v, md.name);
 241                     }
 242                 });
 243             }
 244         }
 245 
 246         for (ClassDescription classDescription : data.classes) {
 247             Map&lt;Character, String&gt; version2Module = package2Version2Module.getOrDefault(classDescription.packge().replace(&#39;.&#39;, &#39;/&#39;), Collections.emptyMap());
 248             for (ClassHeaderDescription header : classDescription.header) {
 249                 Set&lt;String&gt; jointVersions = new HashSet&lt;&gt;();
 250                 jointVersions.add(header.versions);
 251                 limitJointVersion(jointVersions, classDescription.fields);
 252                 limitJointVersion(jointVersions, classDescription.methods);
 253                 Map&lt;String, StringBuilder&gt; module2Versions = new HashMap&lt;&gt;();
 254                 for (char v : header.versions.toCharArray()) {
 255                     String module = version2Module.get(v);
 256                     if (module == null) {
 257                         if (v &gt;= &#39;9&#39;) {
 258                             throw new AssertionError(&quot;No module for &quot; + classDescription.name +
 259                                                      &quot; and version &quot; + v);
 260                         }
 261                         module = version2Module.get(&#39;9&#39;);
 262                         if (module == null) {
 263                             module = &quot;java.base&quot;;
 264                         }
 265                     }
 266                     module2Versions.computeIfAbsent(module, dummy -&gt; new StringBuilder()).append(v);
 267                 }
 268                 for (Entry&lt;String, StringBuilder&gt; e : module2Versions.entrySet()) {
 269                     Set&lt;String&gt; currentVersions = new HashSet&lt;&gt;(jointVersions);
 270                     limitJointVersion(currentVersions, e.getValue().toString());
 271                     currentVersions = currentVersions.stream().filter(vers -&gt; !disjoint(vers, e.getValue().toString())).collect(Collectors.toSet());
<span class="line-modified"> 272                     writeClassesForVersions(directory2FileData, classDescription, header, e.getKey(), currentVersions);</span>
<span class="line-added"> 273                 }</span>
<span class="line-added"> 274             }</span>
<span class="line-added"> 275         }</span>
<span class="line-added"> 276 </span>
<span class="line-added"> 277         currentVersion = Integer.toString(Integer.parseInt(currentVersion), Character.MAX_RADIX);</span>
<span class="line-added"> 278         currentVersion = currentVersion.toUpperCase(Locale.ROOT);</span>
<span class="line-added"> 279 </span>
<span class="line-added"> 280         openDirectory(directory2FileData, currentVersion + &quot;/&quot;)</span>
<span class="line-added"> 281                 .add(new FileData(currentVersion + &quot;/system-modules&quot;,</span>
<span class="line-added"> 282                                   Files.readAllBytes(Paths.get(systemModules))));</span>
<span class="line-added"> 283 </span>
<span class="line-added"> 284         try (OutputStream fos = new FileOutputStream(ctSymLocation);</span>
<span class="line-added"> 285              OutputStream bos = new BufferedOutputStream(fos);</span>
<span class="line-added"> 286              ZipOutputStream jos = new ZipOutputStream(bos)) {</span>
<span class="line-added"> 287             for (Entry&lt;String, Set&lt;FileData&gt;&gt; e : directory2FileData.entrySet()) {</span>
<span class="line-added"> 288                 jos.putNextEntry(createZipEntry(e.getKey(), timestamp));</span>
<span class="line-added"> 289                 for (FileData fd : e.getValue()) {</span>
<span class="line-added"> 290                     jos.putNextEntry(createZipEntry(fd.fileName, timestamp));</span>
<span class="line-added"> 291                     jos.write(fd.fileData);</span>
 292                 }
 293             }
 294         }
 295     }
 296 
<span class="line-added"> 297     private ZipEntry createZipEntry(String name, long timestamp) {</span>
<span class="line-added"> 298         ZipEntry ze = new ZipEntry(name);</span>
<span class="line-added"> 299 </span>
<span class="line-added"> 300         ze.setTime(timestamp);</span>
<span class="line-added"> 301         return ze;</span>
<span class="line-added"> 302     }</span>
<span class="line-added"> 303 </span>
 304     public static String EXTENSION = &quot;.sig&quot;;
 305 
 306     LoadDescriptions load(Path ctDescriptionWithExtraContent, Path ctDescriptionOpen, String deletePlatform) throws IOException {
 307         Map&lt;String, PlatformInput&gt; platforms = new LinkedHashMap&lt;&gt;();
 308 
 309         if (ctDescriptionWithExtraContent != null &amp;&amp; Files.isRegularFile(ctDescriptionWithExtraContent)) {
 310             try (LineBasedReader reader = new LineBasedReader(ctDescriptionWithExtraContent)) {
 311                 while (reader.hasNext()) {
 312                     switch (reader.lineKey) {
 313                         case &quot;generate&quot;:
 314                             //ignore
 315                             reader.moveNext();
 316                             break;
 317                         case &quot;platform&quot;:
 318                             PlatformInput platform = PlatformInput.load(ctDescriptionWithExtraContent,
 319                                                                         reader);
 320                             if (!platform.version.equals(deletePlatform))
 321                                 platforms.put(platform.version, platform);
 322                             reader.moveNext();
 323                             break;
</pre>
<hr />
<pre>
 449         Map&lt;String, ModuleDescription&gt; moduleList = new HashMap&lt;&gt;();
 450 
 451         for (ModuleDescription desc : modules.values()) {
 452             Iterator&lt;ModuleHeaderDescription&gt; mhdIt = desc.header.iterator();
 453 
 454             while (mhdIt.hasNext()) {
 455                 ModuleHeaderDescription mhd = mhdIt.next();
 456 
 457                 mhd.versions = reduce(mhd.versions, generatePlatforms);
 458                 if (mhd.versions.isEmpty())
 459                     mhdIt.remove();
 460             }
 461 
 462             if (desc.header.isEmpty()) {
 463                 continue;
 464             }
 465 
 466             moduleList.put(desc.name, desc);
 467         }
 468 
<span class="line-modified"> 469         return new LoadDescriptions(result,</span>
<span class="line-added"> 470                                     moduleList,</span>
<span class="line-added"> 471                                     new ArrayList&lt;&gt;(platforms.values()));</span>
 472     }
 473 
 474     static final class LoadDescriptions {
 475         public final ClassList classes;
 476         public final Map&lt;String, ModuleDescription&gt; modules;
 477         public final List&lt;PlatformInput&gt; versions;
 478 
 479         public LoadDescriptions(ClassList classes,
 480                                 Map&lt;String, ModuleDescription&gt;  modules,
 481                                 List&lt;PlatformInput&gt; versions) {
 482             this.classes = classes;
 483             this.modules = modules;
 484             this.versions = versions;
 485         }
 486 
 487     }
 488 
 489     static final class LineBasedReader implements AutoCloseable {
 490         private final BufferedReader input;
 491         public String lineKey;
</pre>
<hr />
<pre>
 684             }
 685         }
 686     }
 687 
 688     private static boolean containsAll(String versions, String subVersions) {
 689         for (char c : subVersions.toCharArray()) {
 690             if (versions.indexOf(c) == (-1))
 691                 return false;
 692         }
 693         return true;
 694     }
 695 
 696     private static boolean disjoint(String version1, String version2) {
 697         for (char c : version2.toCharArray()) {
 698             if (version1.indexOf(c) != (-1))
 699                 return false;
 700         }
 701         return true;
 702     }
 703 
<span class="line-modified"> 704     void writeClassesForVersions(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,</span>
 705                                  ClassDescription classDescription,
 706                                  ClassHeaderDescription header,
 707                                  String module,
 708                                  Iterable&lt;String&gt; versions)
 709             throws IOException {
 710         for (String ver : versions) {
<span class="line-modified"> 711             writeClass(directory2FileData, classDescription, header, module, ver);</span>
 712         }
 713     }
 714 
<span class="line-modified"> 715     void writeModulesForVersions(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,</span>
 716                                  ModuleDescription moduleDescription,
 717                                  ModuleHeaderDescription header,
 718                                  Iterable&lt;String&gt; versions)
 719             throws IOException {
 720         for (String ver : versions) {
<span class="line-modified"> 721             writeModule(directory2FileData, moduleDescription, header, ver);</span>
 722         }
 723     }
 724 
 725     //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Class Writing&quot;&gt;
<span class="line-modified"> 726     void writeModule(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,</span>
 727                     ModuleDescription moduleDescription,
 728                     ModuleHeaderDescription header,
 729                     String version) throws IOException {
 730         List&lt;CPInfo&gt; constantPool = new ArrayList&lt;&gt;();
 731         constantPool.add(null);
 732         int currentClass = addClass(constantPool, &quot;module-info&quot;);
 733         int superclass = 0;
 734         int[] interfaces = new int[0];
 735         AccessFlags flags = new AccessFlags(header.flags);
 736         Map&lt;String, Attribute&gt; attributesMap = new HashMap&lt;&gt;();
 737         addAttributes(moduleDescription, header, constantPool, attributesMap);
 738         Attributes attributes = new Attributes(attributesMap);
 739         CPInfo[] cpData = constantPool.toArray(new CPInfo[constantPool.size()]);
 740         ConstantPool cp = new ConstantPool(cpData);
 741         ClassFile classFile = new ClassFile(0xCAFEBABE,
 742                 Target.DEFAULT.minorVersion,
 743                 Target.DEFAULT.majorVersion,
 744                 cp,
 745                 flags,
 746                 currentClass,
 747                 superclass,
 748                 interfaces,
 749                 new Field[0],
 750                 new Method[0],
 751                 attributes);
 752 
<span class="line-modified"> 753         doWrite(directory2FileData, version, moduleDescription.name, &quot;module-info&quot; + EXTENSION, classFile);</span>











 754     }
 755 
<span class="line-modified"> 756     void writeClass(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,</span>
 757                     ClassDescription classDescription,
 758                     ClassHeaderDescription header,
 759                     String module,
 760                     String version) throws IOException {
 761         List&lt;CPInfo&gt; constantPool = new ArrayList&lt;&gt;();
 762         constantPool.add(null);
 763         List&lt;Method&gt; methods = new ArrayList&lt;&gt;();
 764         for (MethodDescription methDesc : classDescription.methods) {
 765             if (disjoint(methDesc.versions, version))
 766                 continue;
 767             Descriptor descriptor = new Descriptor(addString(constantPool, methDesc.descriptor));
 768             //TODO: LinkedHashMap to avoid param annotations vs. Signature problem in javac&#39;s ClassReader:
 769             Map&lt;String, Attribute&gt; attributesMap = new LinkedHashMap&lt;&gt;();
 770             addAttributes(methDesc, constantPool, attributesMap);
 771             Attributes attributes = new Attributes(attributesMap);
 772             AccessFlags flags = new AccessFlags(methDesc.flags);
 773             int nameString = addString(constantPool, methDesc.name);
 774             methods.add(new Method(flags, nameString, descriptor, attributes));
 775         }
 776         List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
 792         for (String intf : header.implementsAttr) {
 793             interfaces[i++] = addClass(constantPool, intf);
 794         }
 795         AccessFlags flags = new AccessFlags(header.flags);
 796         Map&lt;String, Attribute&gt; attributesMap = new HashMap&lt;&gt;();
 797         addAttributes(header, constantPool, attributesMap);
 798         Attributes attributes = new Attributes(attributesMap);
 799         ConstantPool cp = new ConstantPool(constantPool.toArray(new CPInfo[constantPool.size()]));
 800         ClassFile classFile = new ClassFile(0xCAFEBABE,
 801                 Target.DEFAULT.minorVersion,
 802                 Target.DEFAULT.majorVersion,
 803                 cp,
 804                 flags,
 805                 currentClass,
 806                 superclass,
 807                 interfaces,
 808                 fields.toArray(new Field[0]),
 809                 methods.toArray(new Method[0]),
 810                 attributes);
 811 
<span class="line-modified"> 812         doWrite(directory2FileData, version, module, classDescription.name + EXTENSION, classFile);</span>
<span class="line-added"> 813     }</span>
 814 
<span class="line-modified"> 815     private void doWrite(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,</span>
<span class="line-modified"> 816                          String version,</span>
<span class="line-modified"> 817                          String moduleName,</span>
<span class="line-added"> 818                          String fileName,</span>
<span class="line-added"> 819                          ClassFile classFile) throws IOException {</span>
<span class="line-added"> 820         int lastSlash = fileName.lastIndexOf(&#39;/&#39;);</span>
<span class="line-added"> 821         String pack = lastSlash != (-1) ? fileName.substring(0, lastSlash + 1) : &quot;/&quot;;</span>
<span class="line-added"> 822         String directory = version + &quot;/&quot; + moduleName + &quot;/&quot; + pack;</span>
<span class="line-added"> 823         String fullFileName = version + &quot;/&quot; + moduleName + &quot;/&quot; + fileName;</span>
<span class="line-added"> 824         try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {</span>
<span class="line-added"> 825             ClassWriter w = new ClassWriter();</span>
 826 
<span class="line-modified"> 827             w.write(classFile, out);</span>
<span class="line-added"> 828 </span>
<span class="line-added"> 829             openDirectory(directory2FileData, directory)</span>
<span class="line-added"> 830                 .add(new FileData(fullFileName, out.toByteArray()));</span>
<span class="line-added"> 831         }</span>
<span class="line-added"> 832     }</span>
 833 
<span class="line-modified"> 834     private Set&lt;FileData&gt; openDirectory(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,</span>
<span class="line-added"> 835                                String directory) {</span>
<span class="line-added"> 836         Comparator&lt;FileData&gt; fileCompare = (fd1, fd2) -&gt; fd1.fileName.compareTo(fd2.fileName);</span>
<span class="line-added"> 837         return directory2FileData.computeIfAbsent(directory, d -&gt; new TreeSet&lt;&gt;(fileCompare));</span>
<span class="line-added"> 838     }</span>
 839 
<span class="line-modified"> 840     private static class FileData {</span>
<span class="line-modified"> 841         public final String fileName;</span>
<span class="line-added"> 842         public final byte[] fileData;</span>
 843 
<span class="line-modified"> 844         public FileData(String fileName, byte[] fileData) {</span>
<span class="line-added"> 845             this.fileName = fileName;</span>
<span class="line-added"> 846             this.fileData = fileData;</span>
 847         }
<span class="line-added"> 848 </span>
 849     }
 850 
 851     private void addAttributes(ModuleDescription md,
 852                                ModuleHeaderDescription header,
 853                                List&lt;CPInfo&gt; cp,
 854                                Map&lt;String, Attribute&gt; attributes) {
 855         addGenericAttributes(header, cp, attributes);
 856         if (header.moduleResolution != null) {
 857             int attrIdx = addString(cp, Attribute.ModuleResolution);
 858             final ModuleResolution_attribute resIdx =
 859                     new ModuleResolution_attribute(attrIdx,
 860                                                    header.moduleResolution);
 861             attributes.put(Attribute.ModuleResolution, resIdx);
 862         }
 863         if (header.moduleTarget != null) {
 864             int attrIdx = addString(cp, Attribute.ModuleTarget);
 865             int targetIdx = addString(cp, header.moduleTarget);
 866             attributes.put(Attribute.ModuleTarget,
 867                            new ModuleTarget_attribute(attrIdx, targetIdx));
 868         }
</pre>
<hr />
<pre>
3758 
3759                 new CreateSymbols().createBaseLine(versions,
3760                                                    excludeList,
3761                                                    descDest,
3762                                                    args);
3763                 break;
3764             }
3765             case &quot;build-description-incremental&quot;: {
3766                 if (args.length != 3) {
3767                     help();
3768                     return ;
3769                 }
3770 
3771                 new CreateSymbols().createIncrementalBaseLine(args[1], args[2], args);
3772                 break;
3773             }
3774             case &quot;build-ctsym&quot;:
3775                 String ctDescriptionFileExtra;
3776                 String ctDescriptionFile;
3777                 String ctSymLocation;
<span class="line-added">3778                 String timestampSpec;</span>
<span class="line-added">3779                 String currentVersion;</span>
<span class="line-added">3780                 String systemModules;</span>
3781 
<span class="line-modified">3782                 if (args.length == 6) {</span>
3783                     ctDescriptionFileExtra = null;
3784                     ctDescriptionFile = args[1];
3785                     ctSymLocation = args[2];
<span class="line-modified">3786                     timestampSpec = args[3];</span>
<span class="line-added">3787                     currentVersion = args[4];</span>
<span class="line-added">3788                     systemModules = args[5];</span>
<span class="line-added">3789                 } else if (args.length == 7) {</span>
3790                     ctDescriptionFileExtra = args[1];
3791                     ctDescriptionFile = args[2];
3792                     ctSymLocation = args[3];
<span class="line-added">3793                     timestampSpec = args[4];</span>
<span class="line-added">3794                     currentVersion = args[5];</span>
<span class="line-added">3795                     systemModules = args[6];</span>
3796                 } else {
3797                     help();
3798                     return ;
3799                 }
3800 
<span class="line-added">3801                 long timestamp = Long.parseLong(timestampSpec);</span>
<span class="line-added">3802 </span>
<span class="line-added">3803                 //SOURCE_DATE_EPOCH is in seconds, convert to milliseconds:</span>
<span class="line-added">3804                 timestamp *= 1000;</span>
<span class="line-added">3805 </span>
3806                 new CreateSymbols().createSymbols(ctDescriptionFileExtra,
3807                                                   ctDescriptionFile,
<span class="line-modified">3808                                                   ctSymLocation,</span>
<span class="line-added">3809                                                   timestamp,</span>
<span class="line-added">3810                                                   currentVersion,</span>
<span class="line-added">3811                                                   systemModules);</span>
3812                 break;
3813         }
3814     }
3815 
3816 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../build.xml.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TransitiveDependencies.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
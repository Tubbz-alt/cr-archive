<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/jdk/src/classes/build/tools/intpoly/FieldGen.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../generateemojidata/GenerateEmojiData.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../langtools/build.xml.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/intpoly/FieldGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
<span class="line-removed"> 24 </span>
 25 /*
 26  * This file is used to generated optimized finite field implementations.
 27  */
 28 package build.tools.intpoly;
 29 
 30 import java.io.*;
 31 import java.math.BigInteger;
 32 import java.nio.file.Files;
 33 import java.nio.file.Path;
 34 import java.util.*;
 35 
 36 public class FieldGen {
 37 
 38     static FieldParams Curve25519 = new FieldParams(
 39             &quot;IntegerPolynomial25519&quot;, 26, 10, 1, 255,
 40             Arrays.asList(
 41                     new Term(0, -19)
 42             ),
 43             Curve25519CrSequence(), simpleSmallCrSequence(10)
 44     );
</pre>
<hr />
<pre>
153     }
154 
155     static FieldParams O256 = new FieldParams(
156             &quot;P256OrderField&quot;, 26, 10, 1, 256,
157             &quot;FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551&quot;,
158             orderFieldCrSequence(10), orderFieldSmallCrSequence(10)
159     );
160 
161     static FieldParams O384 = new FieldParams(
162             &quot;P384OrderField&quot;, 28, 14, 1, 384,
163             &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973&quot;,
164             orderFieldCrSequence(14), orderFieldSmallCrSequence(14)
165     );
166 
167     static FieldParams O521 = new FieldParams(
168             &quot;P521OrderField&quot;, 28, 19, 1, 521,
169             &quot;01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409&quot;,
170             o521crSequence(19), orderFieldSmallCrSequence(19)
171     );
172 













173     private static List&lt;CarryReduce&gt; o521crSequence(int numLimbs) {
174 
175         // split the full reduce in half, with a carry in between
176         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
177         result.addAll(fullCarry(2 * numLimbs));
178         for (int i = 2 * numLimbs - 1; i &gt;= numLimbs + numLimbs / 2; i--) {
179             result.add(new Reduce(i));
180         }
181         // carry
182         for (int i = numLimbs; i &lt; numLimbs + numLimbs / 2 - 1; i++) {
183             result.add(new Carry(i));
184         }
185         // rest of reduce
186         for (int i = numLimbs + numLimbs / 2 - 1; i &gt;= numLimbs; i--) {
187             result.add(new Reduce(i));
188         }
189         result.addAll(orderFieldSmallCrSequence(numLimbs));
190 
191         return result;
192     }
</pre>
<hr />
<pre>
195         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
196         result.addAll(fullCarry(2 * numLimbs));
197         result.add(new Reduce(2 * numLimbs - 1));
198         result.addAll(fullReduce(numLimbs));
199         result.addAll(fullCarry(numLimbs + 1));
200         result.add(new Reduce(numLimbs));
201         result.addAll(fullCarry(numLimbs));
202 
203         return result;
204     }
205 
206     private static List&lt;CarryReduce&gt; orderFieldSmallCrSequence(int numLimbs) {
207         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
208         result.addAll(fullCarry(numLimbs + 1));
209         result.add(new Reduce(numLimbs));
210         result.addAll(fullCarry(numLimbs));
211         return result;
212     }
213 
214     static final FieldParams[] ALL_FIELDS = {
<span class="line-modified">215             P256, P384, P521, O256, O384, O521,</span>

216     };
217 
218     public static class Term {
219         private final int power;
220         private final int coefficient;
221 
222         public Term(int power, int coefficient) {
223             this.power = power;
224             this.coefficient = coefficient;
225         }
226 
227         public int getPower() {
228             return power;
229         }
230 
231         public int getCoefficient() {
232             return coefficient;
233         }
234 
235         public BigInteger getValue() {
</pre>
<hr />
<pre>
305 
306         public FieldParams(String className, int bitsPerLimb, int numLimbs,
307                 int maxAdds, int power,
308                 String term, List&lt;CarryReduce&gt; crSequence,
309                 List&lt;CarryReduce&gt; smallCrSequence) {
310             this.className = className;
311             this.bitsPerLimb = bitsPerLimb;
312             this.numLimbs = numLimbs;
313             this.maxAdds = maxAdds;
314             this.power = power;
315             this.crSequence = crSequence;
316             this.smallCrSequence = smallCrSequence;
317 
318             terms = buildTerms(BigInteger.ONE.shiftLeft(power)
319                     .subtract(new BigInteger(term, 16)));
320         }
321 
322         private Iterable&lt;Term&gt; buildTerms(BigInteger sub) {
323             // split a large subtrahend into smaller terms
324             // that are aligned with limbs





325             List&lt;Term&gt; result = new ArrayList&lt;Term&gt;();
326             BigInteger mod = BigInteger.valueOf(1 &lt;&lt; bitsPerLimb);
327             int termIndex = 0;
328             while (!sub.equals(BigInteger.ZERO)) {
329                 int coef = sub.mod(mod).intValue();
330                 boolean plusOne = false;
331                 if (coef &gt; (1 &lt;&lt; (bitsPerLimb - 1))) {
332                     coef = coef - (1 &lt;&lt; bitsPerLimb);
333                     plusOne = true;
334                 }



335                 if (coef != 0) {
336                     int pow = termIndex * bitsPerLimb;
337                     result.add(new Term(pow, -coef));
338                 }
339                 sub = sub.shiftRight(bitsPerLimb);
340                 if (plusOne) {
341                     sub = sub.add(BigInteger.ONE);
342                 }
343                 ++termIndex;
344             }
345             return result;
346         }
347 
348         public String getClassName() {
349             return className;
350         }
351 
352         public int getBitsPerLimb() {
353             return bitsPerLimb;
354         }
</pre>
<hr />
<pre>
602         result.appendLine(&quot;private static final int NUM_LIMBS = &quot;
603                 + params.getNumLimbs() + &quot;;&quot;);
604         result.appendLine(&quot;private static final int MAX_ADDS = &quot;
605                 + params.getMaxAdds() + &quot;;&quot;);
606         result.appendLine(
607                 &quot;public static final BigInteger MODULUS = evaluateModulus();&quot;);
608         result.appendLine(&quot;private static final long CARRY_ADD = 1 &lt;&lt; &quot;
609                 + (params.getBitsPerLimb() - 1) + &quot;;&quot;);
610         if (params.getBitsPerLimb() * params.getNumLimbs() != params.getPower()) {
611             result.appendLine(&quot;private static final int LIMB_MASK = -1 &quot;
612                     + &quot;&gt;&gt;&gt; (64 - BITS_PER_LIMB);&quot;);
613         }
614         int termIndex = 0;
615 
616         result.appendLine(&quot;public &quot; + params.getClassName() + &quot;() {&quot;);
617         result.appendLine();
618         result.appendLine(&quot;    super(BITS_PER_LIMB, NUM_LIMBS, MAX_ADDS, MODULUS);&quot;);
619         result.appendLine();
620         result.appendLine(&quot;}&quot;);
621 








622         result.appendLine(&quot;private static BigInteger evaluateModulus() {&quot;);
623         result.incrIndent();
624         result.appendLine(&quot;BigInteger result = BigInteger.valueOf(2).pow(&quot;
625                 + params.getPower() + &quot;);&quot;);
626         for (Term t : params.getTerms()) {
627             boolean subtract = false;
628             int coefValue = t.getCoefficient();
629             if (coefValue &lt; 0) {
630                 coefValue = 0 - coefValue;
631                 subtract = true;
632             }
633             String coefExpr = &quot;BigInteger.valueOf(&quot; + coefValue + &quot;)&quot;;
634             String powExpr = &quot;BigInteger.valueOf(2).pow(&quot; + t.getPower() + &quot;)&quot;;
635             String termExpr = &quot;ERROR&quot;;
636             if (t.getPower() == 0) {
637                 termExpr = coefExpr;
638             } else if (coefValue == 1) {
639                 termExpr = powExpr;
640             } else {
641                 termExpr = powExpr + &quot;.multiply(&quot; + coefExpr + &quot;)&quot;;
642             }
643             if (subtract) {
644                 result.appendLine(&quot;result = result.subtract(&quot; + termExpr + &quot;);&quot;);
645             } else {
646                 result.appendLine(&quot;result = result.add(&quot; + termExpr + &quot;);&quot;);
647             }
648         }
649         result.appendLine(&quot;return result;&quot;);
650         result.decrIndent();
651         result.appendLine(&quot;}&quot;);
652 



































653         result.appendLine(&quot;@Override&quot;);
654         result.appendLine(&quot;protected void finalCarryReduceLast(long[] limbs) {&quot;);
655         result.incrIndent();
656         int extraBits = params.getBitsPerLimb() * params.getNumLimbs()
657                 - params.getPower();
658         int highBits = params.getBitsPerLimb() - extraBits;
659         result.appendLine(&quot;long c = limbs[&quot; + (params.getNumLimbs() - 1)
660                 + &quot;] &gt;&gt; &quot; + highBits + &quot;;&quot;);
661         result.appendLine(&quot;limbs[&quot; + (params.getNumLimbs() - 1) + &quot;] -= c &lt;&lt; &quot;
662                 + highBits + &quot;;&quot;);
663         for (Term t : params.getTerms()) {
664             int reduceBits = params.getPower() + extraBits - t.getPower();
665             int negatedCoefficient = -1 * t.getCoefficient();
666             modReduceInBits(result, params, true, &quot;limbs&quot;, params.getNumLimbs(),
667                     reduceBits, negatedCoefficient, &quot;c&quot;);
668         }
669         result.decrIndent();
670         result.appendLine(&quot;}&quot;);
671 
672         // full carry/reduce sequence
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 

 24 /*
 25  * This file is used to generated optimized finite field implementations.
 26  */
 27 package build.tools.intpoly;
 28 
 29 import java.io.*;
 30 import java.math.BigInteger;
 31 import java.nio.file.Files;
 32 import java.nio.file.Path;
 33 import java.util.*;
 34 
 35 public class FieldGen {
 36 
 37     static FieldParams Curve25519 = new FieldParams(
 38             &quot;IntegerPolynomial25519&quot;, 26, 10, 1, 255,
 39             Arrays.asList(
 40                     new Term(0, -19)
 41             ),
 42             Curve25519CrSequence(), simpleSmallCrSequence(10)
 43     );
</pre>
<hr />
<pre>
152     }
153 
154     static FieldParams O256 = new FieldParams(
155             &quot;P256OrderField&quot;, 26, 10, 1, 256,
156             &quot;FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551&quot;,
157             orderFieldCrSequence(10), orderFieldSmallCrSequence(10)
158     );
159 
160     static FieldParams O384 = new FieldParams(
161             &quot;P384OrderField&quot;, 28, 14, 1, 384,
162             &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973&quot;,
163             orderFieldCrSequence(14), orderFieldSmallCrSequence(14)
164     );
165 
166     static FieldParams O521 = new FieldParams(
167             &quot;P521OrderField&quot;, 28, 19, 1, 521,
168             &quot;01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409&quot;,
169             o521crSequence(19), orderFieldSmallCrSequence(19)
170     );
171 
<span class="line-added">172     static FieldParams O25519 = new FieldParams(</span>
<span class="line-added">173             &quot;Curve25519OrderField&quot;, 26, 10, 1, 252,</span>
<span class="line-added">174             &quot;1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed&quot;,</span>
<span class="line-added">175             orderFieldCrSequence(10), orderFieldSmallCrSequence(10)</span>
<span class="line-added">176     );</span>
<span class="line-added">177 </span>
<span class="line-added">178     static FieldParams O448 = new FieldParams(</span>
<span class="line-added">179             &quot;Curve448OrderField&quot;, 28, 16, 1, 446,</span>
<span class="line-added">180             &quot;3fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3&quot;,</span>
<span class="line-added">181             //&quot;ffffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3&quot;,</span>
<span class="line-added">182             orderFieldCrSequence(16), orderFieldSmallCrSequence(16)</span>
<span class="line-added">183     );</span>
<span class="line-added">184 </span>
185     private static List&lt;CarryReduce&gt; o521crSequence(int numLimbs) {
186 
187         // split the full reduce in half, with a carry in between
188         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
189         result.addAll(fullCarry(2 * numLimbs));
190         for (int i = 2 * numLimbs - 1; i &gt;= numLimbs + numLimbs / 2; i--) {
191             result.add(new Reduce(i));
192         }
193         // carry
194         for (int i = numLimbs; i &lt; numLimbs + numLimbs / 2 - 1; i++) {
195             result.add(new Carry(i));
196         }
197         // rest of reduce
198         for (int i = numLimbs + numLimbs / 2 - 1; i &gt;= numLimbs; i--) {
199             result.add(new Reduce(i));
200         }
201         result.addAll(orderFieldSmallCrSequence(numLimbs));
202 
203         return result;
204     }
</pre>
<hr />
<pre>
207         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
208         result.addAll(fullCarry(2 * numLimbs));
209         result.add(new Reduce(2 * numLimbs - 1));
210         result.addAll(fullReduce(numLimbs));
211         result.addAll(fullCarry(numLimbs + 1));
212         result.add(new Reduce(numLimbs));
213         result.addAll(fullCarry(numLimbs));
214 
215         return result;
216     }
217 
218     private static List&lt;CarryReduce&gt; orderFieldSmallCrSequence(int numLimbs) {
219         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
220         result.addAll(fullCarry(numLimbs + 1));
221         result.add(new Reduce(numLimbs));
222         result.addAll(fullCarry(numLimbs));
223         return result;
224     }
225 
226     static final FieldParams[] ALL_FIELDS = {
<span class="line-modified">227             Curve25519, Curve448,</span>
<span class="line-added">228             P256, P384, P521, O256, O384, O521, O25519, O448</span>
229     };
230 
231     public static class Term {
232         private final int power;
233         private final int coefficient;
234 
235         public Term(int power, int coefficient) {
236             this.power = power;
237             this.coefficient = coefficient;
238         }
239 
240         public int getPower() {
241             return power;
242         }
243 
244         public int getCoefficient() {
245             return coefficient;
246         }
247 
248         public BigInteger getValue() {
</pre>
<hr />
<pre>
318 
319         public FieldParams(String className, int bitsPerLimb, int numLimbs,
320                 int maxAdds, int power,
321                 String term, List&lt;CarryReduce&gt; crSequence,
322                 List&lt;CarryReduce&gt; smallCrSequence) {
323             this.className = className;
324             this.bitsPerLimb = bitsPerLimb;
325             this.numLimbs = numLimbs;
326             this.maxAdds = maxAdds;
327             this.power = power;
328             this.crSequence = crSequence;
329             this.smallCrSequence = smallCrSequence;
330 
331             terms = buildTerms(BigInteger.ONE.shiftLeft(power)
332                     .subtract(new BigInteger(term, 16)));
333         }
334 
335         private Iterable&lt;Term&gt; buildTerms(BigInteger sub) {
336             // split a large subtrahend into smaller terms
337             // that are aligned with limbs
<span class="line-added">338             boolean negate = false;</span>
<span class="line-added">339             if (sub.compareTo(BigInteger.ZERO) &lt; 0) {</span>
<span class="line-added">340                 negate = true;</span>
<span class="line-added">341                 sub = sub.negate();</span>
<span class="line-added">342             }</span>
343             List&lt;Term&gt; result = new ArrayList&lt;Term&gt;();
344             BigInteger mod = BigInteger.valueOf(1 &lt;&lt; bitsPerLimb);
345             int termIndex = 0;
346             while (!sub.equals(BigInteger.ZERO)) {
347                 int coef = sub.mod(mod).intValue();
348                 boolean plusOne = false;
349                 if (coef &gt; (1 &lt;&lt; (bitsPerLimb - 1))) {
350                     coef = coef - (1 &lt;&lt; bitsPerLimb);
351                     plusOne = true;
352                 }
<span class="line-added">353                 if (negate) {</span>
<span class="line-added">354                     coef = 0 - coef;</span>
<span class="line-added">355                 }</span>
356                 if (coef != 0) {
357                     int pow = termIndex * bitsPerLimb;
358                     result.add(new Term(pow, -coef));
359                 }
360                 sub = sub.shiftRight(bitsPerLimb);
361                 if (plusOne) {
362                     sub = sub.add(BigInteger.ONE);
363                 }
364                 ++termIndex;
365             }
366             return result;
367         }
368 
369         public String getClassName() {
370             return className;
371         }
372 
373         public int getBitsPerLimb() {
374             return bitsPerLimb;
375         }
</pre>
<hr />
<pre>
623         result.appendLine(&quot;private static final int NUM_LIMBS = &quot;
624                 + params.getNumLimbs() + &quot;;&quot;);
625         result.appendLine(&quot;private static final int MAX_ADDS = &quot;
626                 + params.getMaxAdds() + &quot;;&quot;);
627         result.appendLine(
628                 &quot;public static final BigInteger MODULUS = evaluateModulus();&quot;);
629         result.appendLine(&quot;private static final long CARRY_ADD = 1 &lt;&lt; &quot;
630                 + (params.getBitsPerLimb() - 1) + &quot;;&quot;);
631         if (params.getBitsPerLimb() * params.getNumLimbs() != params.getPower()) {
632             result.appendLine(&quot;private static final int LIMB_MASK = -1 &quot;
633                     + &quot;&gt;&gt;&gt; (64 - BITS_PER_LIMB);&quot;);
634         }
635         int termIndex = 0;
636 
637         result.appendLine(&quot;public &quot; + params.getClassName() + &quot;() {&quot;);
638         result.appendLine();
639         result.appendLine(&quot;    super(BITS_PER_LIMB, NUM_LIMBS, MAX_ADDS, MODULUS);&quot;);
640         result.appendLine();
641         result.appendLine(&quot;}&quot;);
642 
<span class="line-added">643         StringBuilder coqTerms = new StringBuilder(&quot;//&quot;);</span>
<span class="line-added">644         for (Term t : params.getTerms()) {</span>
<span class="line-added">645             coqTerms.append(&quot;(&quot; + t.getPower() + &quot;%nat,&quot;);</span>
<span class="line-added">646             coqTerms.append(t.getCoefficient() + &quot;)::&quot;);</span>
<span class="line-added">647         }</span>
<span class="line-added">648         coqTerms.append(&quot;nil.&quot;);</span>
<span class="line-added">649         result.appendLine(coqTerms.toString());</span>
<span class="line-added">650 </span>
651         result.appendLine(&quot;private static BigInteger evaluateModulus() {&quot;);
652         result.incrIndent();
653         result.appendLine(&quot;BigInteger result = BigInteger.valueOf(2).pow(&quot;
654                 + params.getPower() + &quot;);&quot;);
655         for (Term t : params.getTerms()) {
656             boolean subtract = false;
657             int coefValue = t.getCoefficient();
658             if (coefValue &lt; 0) {
659                 coefValue = 0 - coefValue;
660                 subtract = true;
661             }
662             String coefExpr = &quot;BigInteger.valueOf(&quot; + coefValue + &quot;)&quot;;
663             String powExpr = &quot;BigInteger.valueOf(2).pow(&quot; + t.getPower() + &quot;)&quot;;
664             String termExpr = &quot;ERROR&quot;;
665             if (t.getPower() == 0) {
666                 termExpr = coefExpr;
667             } else if (coefValue == 1) {
668                 termExpr = powExpr;
669             } else {
670                 termExpr = powExpr + &quot;.multiply(&quot; + coefExpr + &quot;)&quot;;
671             }
672             if (subtract) {
673                 result.appendLine(&quot;result = result.subtract(&quot; + termExpr + &quot;);&quot;);
674             } else {
675                 result.appendLine(&quot;result = result.add(&quot; + termExpr + &quot;);&quot;);
676             }
677         }
678         result.appendLine(&quot;return result;&quot;);
679         result.decrIndent();
680         result.appendLine(&quot;}&quot;);
681 
<span class="line-added">682         result.appendLine(&quot;@Override&quot;);</span>
<span class="line-added">683         result.appendLine(&quot;protected void reduceIn(long[] limbs, long v, int i) {&quot;);</span>
<span class="line-added">684         result.incrIndent();</span>
<span class="line-added">685         String c = &quot;v&quot;;</span>
<span class="line-added">686         for (Term t : params.getTerms()) {</span>
<span class="line-added">687             int reduceBits = params.getPower() - t.getPower();</span>
<span class="line-added">688             int coefficient = -1 * t.getCoefficient();</span>
<span class="line-added">689 </span>
<span class="line-added">690             String x = coefficient + &quot; * &quot; + c;</span>
<span class="line-added">691             String accOp = &quot;+=&quot;;</span>
<span class="line-added">692             String temp = null;</span>
<span class="line-added">693             if (coefficient == 1) {</span>
<span class="line-added">694                 x = c;</span>
<span class="line-added">695             } else if (coefficient == -1) {</span>
<span class="line-added">696                 x = c;</span>
<span class="line-added">697                 accOp = &quot;-=&quot;;</span>
<span class="line-added">698             } else {</span>
<span class="line-added">699                 temp = result.getTemporary(&quot;long&quot;, x);</span>
<span class="line-added">700                 x = temp;</span>
<span class="line-added">701             }</span>
<span class="line-added">702 </span>
<span class="line-added">703             if (reduceBits % params.getBitsPerLimb() == 0) {</span>
<span class="line-added">704                 int pos = reduceBits / params.getBitsPerLimb();</span>
<span class="line-added">705                 result.appendLine(&quot;limbs[i - &quot; + pos + &quot;] &quot; + accOp + &quot; &quot; + x + &quot;;&quot;);</span>
<span class="line-added">706             } else {</span>
<span class="line-added">707                 int secondPos = reduceBits / params.getBitsPerLimb();</span>
<span class="line-added">708                 int bitOffset = (secondPos + 1) * params.getBitsPerLimb() - reduceBits;</span>
<span class="line-added">709                 int rightBitOffset = params.getBitsPerLimb() - bitOffset;</span>
<span class="line-added">710                 result.appendLine(&quot;limbs[i - &quot; + (secondPos + 1) + &quot;] &quot; + accOp + &quot; (&quot; + x + &quot; &lt;&lt; &quot; + bitOffset + &quot;) &amp; LIMB_MASK;&quot;);</span>
<span class="line-added">711                 result.appendLine(&quot;limbs[i - &quot; + secondPos + &quot;] &quot; + accOp + &quot; &quot; + x + &quot; &gt;&gt; &quot; + rightBitOffset + &quot;;&quot;);</span>
<span class="line-added">712             }</span>
<span class="line-added">713         }</span>
<span class="line-added">714         result.decrIndent();</span>
<span class="line-added">715         result.appendLine(&quot;}&quot;);</span>
<span class="line-added">716 </span>
717         result.appendLine(&quot;@Override&quot;);
718         result.appendLine(&quot;protected void finalCarryReduceLast(long[] limbs) {&quot;);
719         result.incrIndent();
720         int extraBits = params.getBitsPerLimb() * params.getNumLimbs()
721                 - params.getPower();
722         int highBits = params.getBitsPerLimb() - extraBits;
723         result.appendLine(&quot;long c = limbs[&quot; + (params.getNumLimbs() - 1)
724                 + &quot;] &gt;&gt; &quot; + highBits + &quot;;&quot;);
725         result.appendLine(&quot;limbs[&quot; + (params.getNumLimbs() - 1) + &quot;] -= c &lt;&lt; &quot;
726                 + highBits + &quot;;&quot;);
727         for (Term t : params.getTerms()) {
728             int reduceBits = params.getPower() + extraBits - t.getPower();
729             int negatedCoefficient = -1 * t.getCoefficient();
730             modReduceInBits(result, params, true, &quot;limbs&quot;, params.getNumLimbs(),
731                     reduceBits, negatedCoefficient, &quot;c&quot;);
732         }
733         result.decrIndent();
734         result.appendLine(&quot;}&quot;);
735 
736         // full carry/reduce sequence
</pre>
</td>
</tr>
</table>
<center><a href="../generateemojidata/GenerateEmojiData.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../langtools/build.xml.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
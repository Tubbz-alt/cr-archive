<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New make/jdk/src/classes/build/tools/intpoly/FieldGen.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * This file is used to generated optimized finite field implementations.
 26  */
 27 package build.tools.intpoly;
 28 
 29 import java.io.*;
 30 import java.math.BigInteger;
 31 import java.nio.file.Files;
 32 import java.nio.file.Path;
 33 import java.util.*;
 34 
 35 public class FieldGen {
 36 
 37     static FieldParams Curve25519 = new FieldParams(
 38             &quot;IntegerPolynomial25519&quot;, 26, 10, 1, 255,
 39             Arrays.asList(
 40                     new Term(0, -19)
 41             ),
 42             Curve25519CrSequence(), simpleSmallCrSequence(10)
 43     );
 44 
 45     private static List&lt;CarryReduce&gt; Curve25519CrSequence() {
 46         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
 47 
 48         // reduce(7,2)
 49         result.add(new Reduce(17));
 50         result.add(new Reduce(18));
 51 
 52         // carry(8,2)
 53         result.add(new Carry(8));
 54         result.add(new Carry(9));
 55 
 56         // reduce(0,7)
 57         for (int i = 10; i &lt; 17; i++) {
 58             result.add(new Reduce(i));
 59         }
 60 
 61         // carry(0,9)
 62         result.addAll(fullCarry(10));
 63 
 64         return result;
 65     }
 66 
 67     static FieldParams Curve448 = new FieldParams(
 68             &quot;IntegerPolynomial448&quot;, 28, 16, 1, 448,
 69             Arrays.asList(
 70                     new Term(224, -1),
 71                     new Term(0, -1)
 72             ),
 73             Curve448CrSequence(), simpleSmallCrSequence(16)
 74     );
 75 
 76     private static List&lt;CarryReduce&gt; Curve448CrSequence() {
 77         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
 78 
 79         // reduce(8, 7)
 80         for (int i = 24; i &lt; 31; i++) {
 81             result.add(new Reduce(i));
 82         }
 83         // reduce(4, 4)
 84         for (int i = 20; i &lt; 24; i++) {
 85             result.add(new Reduce(i));
 86         }
 87 
 88         //carry(14, 2)
 89         result.add(new Carry(14));
 90         result.add(new Carry(15));
 91 
 92         // reduce(0, 4)
 93         for (int i = 16; i &lt; 20; i++) {
 94             result.add(new Reduce(i));
 95         }
 96 
 97         // carry(0, 15)
 98         result.addAll(fullCarry(16));
 99 
100         return result;
101     }
102 
103     static FieldParams P256 = new FieldParams(
104             &quot;IntegerPolynomialP256&quot;, 26, 10, 2, 256,
105             Arrays.asList(
106                     new Term(224, -1),
107                     new Term(192, 1),
108                     new Term(96, 1),
109                     new Term(0, -1)
110             ),
111             P256CrSequence(), simpleSmallCrSequence(10)
112     );
113 
114     private static List&lt;CarryReduce&gt; P256CrSequence() {
115         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
116         result.addAll(fullReduce(10));
117         result.addAll(simpleSmallCrSequence(10));
118         return result;
119     }
120 
121     static FieldParams P384 = new FieldParams(
122             &quot;IntegerPolynomialP384&quot;, 28, 14, 2, 384,
123             Arrays.asList(
124                     new Term(128, -1),
125                     new Term(96, -1),
126                     new Term(32, 1),
127                     new Term(0, -1)
128             ),
129             P384CrSequence(), simpleSmallCrSequence(14)
130     );
131 
132     private static List&lt;CarryReduce&gt; P384CrSequence() {
133         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
134         result.addAll(fullReduce(14));
135         result.addAll(simpleSmallCrSequence(14));
136         return result;
137     }
138 
139     static FieldParams P521 = new FieldParams(
140             &quot;IntegerPolynomialP521&quot;, 28, 19, 2, 521,
141             Arrays.asList(
142                     new Term(0, -1)
143             ),
144             P521CrSequence(), simpleSmallCrSequence(19)
145     );
146 
147     private static List&lt;CarryReduce&gt; P521CrSequence() {
148         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
149         result.addAll(fullReduce(19));
150         result.addAll(simpleSmallCrSequence(19));
151         return result;
152     }
153 
154     static FieldParams O256 = new FieldParams(
155             &quot;P256OrderField&quot;, 26, 10, 1, 256,
156             &quot;FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551&quot;,
157             orderFieldCrSequence(10), orderFieldSmallCrSequence(10)
158     );
159 
160     static FieldParams O384 = new FieldParams(
161             &quot;P384OrderField&quot;, 28, 14, 1, 384,
162             &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973&quot;,
163             orderFieldCrSequence(14), orderFieldSmallCrSequence(14)
164     );
165 
166     static FieldParams O521 = new FieldParams(
167             &quot;P521OrderField&quot;, 28, 19, 1, 521,
168             &quot;01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409&quot;,
169             o521crSequence(19), orderFieldSmallCrSequence(19)
170     );
171 
172     static FieldParams O25519 = new FieldParams(
173             &quot;Curve25519OrderField&quot;, 26, 10, 1, 252,
174             &quot;1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed&quot;,
175             orderFieldCrSequence(10), orderFieldSmallCrSequence(10)
176     );
177 
178     static FieldParams O448 = new FieldParams(
179             &quot;Curve448OrderField&quot;, 28, 16, 1, 446,
180             &quot;3fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3&quot;,
181             //&quot;ffffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3&quot;,
182             orderFieldCrSequence(16), orderFieldSmallCrSequence(16)
183     );
184 
185     private static List&lt;CarryReduce&gt; o521crSequence(int numLimbs) {
186 
187         // split the full reduce in half, with a carry in between
188         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
189         result.addAll(fullCarry(2 * numLimbs));
190         for (int i = 2 * numLimbs - 1; i &gt;= numLimbs + numLimbs / 2; i--) {
191             result.add(new Reduce(i));
192         }
193         // carry
194         for (int i = numLimbs; i &lt; numLimbs + numLimbs / 2 - 1; i++) {
195             result.add(new Carry(i));
196         }
197         // rest of reduce
198         for (int i = numLimbs + numLimbs / 2 - 1; i &gt;= numLimbs; i--) {
199             result.add(new Reduce(i));
200         }
201         result.addAll(orderFieldSmallCrSequence(numLimbs));
202 
203         return result;
204     }
205 
206     private static List&lt;CarryReduce&gt; orderFieldCrSequence(int numLimbs) {
207         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
208         result.addAll(fullCarry(2 * numLimbs));
209         result.add(new Reduce(2 * numLimbs - 1));
210         result.addAll(fullReduce(numLimbs));
211         result.addAll(fullCarry(numLimbs + 1));
212         result.add(new Reduce(numLimbs));
213         result.addAll(fullCarry(numLimbs));
214 
215         return result;
216     }
217 
218     private static List&lt;CarryReduce&gt; orderFieldSmallCrSequence(int numLimbs) {
219         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
220         result.addAll(fullCarry(numLimbs + 1));
221         result.add(new Reduce(numLimbs));
222         result.addAll(fullCarry(numLimbs));
223         return result;
224     }
225 
226     static final FieldParams[] ALL_FIELDS = {
227             Curve25519, Curve448,
228             P256, P384, P521, O256, O384, O521, O25519, O448
229     };
230 
231     public static class Term {
232         private final int power;
233         private final int coefficient;
234 
235         public Term(int power, int coefficient) {
236             this.power = power;
237             this.coefficient = coefficient;
238         }
239 
240         public int getPower() {
241             return power;
242         }
243 
244         public int getCoefficient() {
245             return coefficient;
246         }
247 
248         public BigInteger getValue() {
249             return BigInteger.valueOf(2).pow(power)
250                     .multiply(BigInteger.valueOf(coefficient));
251         }
252 
253         public String toString() {
254             return &quot;2^&quot; + power + &quot; * &quot; + coefficient;
255         }
256     }
257 
258     static abstract class CarryReduce {
259         private final int index;
260 
261         protected CarryReduce(int index) {
262             this.index = index;
263         }
264 
265         public int getIndex() {
266             return index;
267         }
268 
269         public abstract void write(CodeBuffer out, FieldParams params,
270                 String prefix, Iterable&lt;CarryReduce&gt; remaining);
271     }
272 
273     static class Carry extends CarryReduce {
274         public Carry(int index) {
275             super(index);
276         }
277 
278         public void write(CodeBuffer out, FieldParams params, String prefix,
279                 Iterable&lt;CarryReduce&gt; remaining) {
280             carry(out, params, prefix, getIndex());
281         }
282     }
283 
284     static class Reduce extends CarryReduce {
285         public Reduce(int index) {
286             super(index);
287         }
288 
289         public void write(CodeBuffer out, FieldParams params, String prefix,
290                 Iterable&lt;CarryReduce&gt; remaining) {
291             reduce(out, params, prefix, getIndex(), remaining);
292         }
293     }
294 
295     static class FieldParams {
296         private final String className;
297         private final int bitsPerLimb;
298         private final int numLimbs;
299         private final int maxAdds;
300         private final int power;
301         private final Iterable&lt;Term&gt; terms;
302         private final List&lt;CarryReduce&gt; crSequence;
303         private final List&lt;CarryReduce&gt; smallCrSequence;
304 
305         public FieldParams(String className, int bitsPerLimb, int numLimbs,
306                 int maxAdds, int power,
307                 Iterable&lt;Term&gt; terms, List&lt;CarryReduce&gt; crSequence,
308                 List&lt;CarryReduce&gt; smallCrSequence) {
309             this.className = className;
310             this.bitsPerLimb = bitsPerLimb;
311             this.numLimbs = numLimbs;
312             this.maxAdds = maxAdds;
313             this.power = power;
314             this.terms = terms;
315             this.crSequence = crSequence;
316             this.smallCrSequence = smallCrSequence;
317         }
318 
319         public FieldParams(String className, int bitsPerLimb, int numLimbs,
320                 int maxAdds, int power,
321                 String term, List&lt;CarryReduce&gt; crSequence,
322                 List&lt;CarryReduce&gt; smallCrSequence) {
323             this.className = className;
324             this.bitsPerLimb = bitsPerLimb;
325             this.numLimbs = numLimbs;
326             this.maxAdds = maxAdds;
327             this.power = power;
328             this.crSequence = crSequence;
329             this.smallCrSequence = smallCrSequence;
330 
331             terms = buildTerms(BigInteger.ONE.shiftLeft(power)
332                     .subtract(new BigInteger(term, 16)));
333         }
334 
335         private Iterable&lt;Term&gt; buildTerms(BigInteger sub) {
336             // split a large subtrahend into smaller terms
337             // that are aligned with limbs
338             boolean negate = false;
339             if (sub.compareTo(BigInteger.ZERO) &lt; 0) {
340                 negate = true;
341                 sub = sub.negate();
342             }
343             List&lt;Term&gt; result = new ArrayList&lt;Term&gt;();
344             BigInteger mod = BigInteger.valueOf(1 &lt;&lt; bitsPerLimb);
345             int termIndex = 0;
346             while (!sub.equals(BigInteger.ZERO)) {
347                 int coef = sub.mod(mod).intValue();
348                 boolean plusOne = false;
349                 if (coef &gt; (1 &lt;&lt; (bitsPerLimb - 1))) {
350                     coef = coef - (1 &lt;&lt; bitsPerLimb);
351                     plusOne = true;
352                 }
353                 if (negate) {
354                     coef = 0 - coef;
355                 }
356                 if (coef != 0) {
357                     int pow = termIndex * bitsPerLimb;
358                     result.add(new Term(pow, -coef));
359                 }
360                 sub = sub.shiftRight(bitsPerLimb);
361                 if (plusOne) {
362                     sub = sub.add(BigInteger.ONE);
363                 }
364                 ++termIndex;
365             }
366             return result;
367         }
368 
369         public String getClassName() {
370             return className;
371         }
372 
373         public int getBitsPerLimb() {
374             return bitsPerLimb;
375         }
376 
377         public int getNumLimbs() {
378             return numLimbs;
379         }
380 
381         public int getMaxAdds() {
382             return maxAdds;
383         }
384 
385         public int getPower() {
386             return power;
387         }
388 
389         public Iterable&lt;Term&gt; getTerms() {
390             return terms;
391         }
392 
393         public List&lt;CarryReduce&gt; getCrSequence() {
394             return crSequence;
395         }
396 
397         public List&lt;CarryReduce&gt; getSmallCrSequence() {
398             return smallCrSequence;
399         }
400     }
401 
402     static Collection&lt;Carry&gt; fullCarry(int numLimbs) {
403         List&lt;Carry&gt; result = new ArrayList&lt;Carry&gt;();
404         for (int i = 0; i &lt; numLimbs - 1; i++) {
405             result.add(new Carry(i));
406         }
407         return result;
408     }
409 
410     static Collection&lt;Reduce&gt; fullReduce(int numLimbs) {
411         List&lt;Reduce&gt; result = new ArrayList&lt;Reduce&gt;();
412         for (int i = numLimbs - 2; i &gt;= 0; i--) {
413             result.add(new Reduce(i + numLimbs));
414         }
415         return result;
416     }
417 
418     static List&lt;CarryReduce&gt; simpleCrSequence(int numLimbs) {
419         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
420         for (int i = 0; i &lt; 4; i++) {
421             result.addAll(fullCarry(2 * numLimbs - 1));
422             result.addAll(fullReduce(numLimbs));
423         }
424 
425         return result;
426     }
427 
428     static List&lt;CarryReduce&gt; simpleSmallCrSequence(int numLimbs) {
429         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
430         // carry a few positions at the end
431         for (int i = numLimbs - 2; i &lt; numLimbs; i++) {
432             result.add(new Carry(i));
433         }
434         // this carries out a single value that must be reduced back in
435         result.add(new Reduce(numLimbs));
436         // finish with a full carry
437         result.addAll(fullCarry(numLimbs));
438         return result;
439     }
440 
441     private final String packageName;
442     private final String parentName;
443 
444     private final Path headerPath;
445     private final Path destPath;
446 
447     public FieldGen(String packageName, String parentName,
448             Path headerPath, Path destRoot) throws IOException {
449         this.packageName = packageName;
450         this.parentName = parentName;
451         this.headerPath = headerPath;
452         this.destPath = destRoot.resolve(packageName.replace(&quot;.&quot;, &quot;/&quot;));
453         Files.createDirectories(destPath);
454     }
455 
456     // args: header.txt destpath
457     public static void main(String[] args) throws Exception {
458 
459         FieldGen gen = new FieldGen(
460                 &quot;sun.security.util.math.intpoly&quot;,
461                 &quot;IntegerPolynomial&quot;,
462                 Path.of(args[0]),
463                 Path.of(args[1]));
464         for (FieldParams p : ALL_FIELDS) {
465             System.out.println(p.className);
466             System.out.println(p.terms);
467             System.out.println();
468             gen.generateFile(p);
469         }
470     }
471 
472     private void generateFile(FieldParams params) throws IOException {
473         String text = generate(params);
474         String fileName = params.getClassName() + &quot;.java&quot;;
475         PrintWriter out = new PrintWriter(Files.newBufferedWriter(
476                 destPath.resolve(fileName)));
477         out.println(text);
478         out.close();
479     }
480 
481     static class CodeBuffer {
482 
483         private int nextTemporary = 0;
484         private Set&lt;String&gt; temporaries = new HashSet&lt;String&gt;();
485         private StringBuffer buffer = new StringBuffer();
486         private int indent = 0;
487         private Class&lt;?&gt; lastCR;
488         private int lastCrCount = 0;
489         private int crMethodBreakCount = 0;
490         private int crNumLimbs = 0;
491 
492         public void incrIndent() {
493             indent++;
494         }
495 
496         public void decrIndent() {
497             indent--;
498         }
499 
500         public void newTempScope() {
501             nextTemporary = 0;
502             temporaries.clear();
503         }
504 
505         public void appendLine(String s) {
506             appendIndent();
507             buffer.append(s + &quot;\n&quot;);
508         }
509 
510         public void appendLine() {
511             buffer.append(&quot;\n&quot;);
512         }
513 
514         public String toString() {
515             return buffer.toString();
516         }
517 
518         public void startCrSequence(int numLimbs) {
519             this.crNumLimbs = numLimbs;
520             lastCrCount = 0;
521             crMethodBreakCount = 0;
522             lastCR = null;
523         }
524 
525         /*
526          * Record a carry/reduce of the specified type. This method is used to
527          * break up large carry/reduce sequences into multiple methods to make
528          * JIT/optimization easier
529          */
530         public void record(Class&lt;?&gt; type) {
531             if (type == lastCR) {
532                 lastCrCount++;
533             } else {
534 
535                 if (lastCrCount &gt;= 8) {
536                     insertCrMethodBreak();
537                 }
538 
539                 lastCR = type;
540                 lastCrCount = 0;
541             }
542         }
543 
544         private void insertCrMethodBreak() {
545 
546             appendLine();
547 
548             // call the new method
549             appendIndent();
550             append(&quot;carryReduce&quot; + crMethodBreakCount + &quot;(r&quot;);
551             for (int i = 0; i &lt; crNumLimbs; i++) {
552                 append(&quot;, c&quot; + i);
553             }
554             // temporaries are not live between operations, no need to send
555             append(&quot;);\n&quot;);
556 
557             decrIndent();
558             appendLine(&quot;}&quot;);
559 
560             // make the method
561             appendIndent();
562             append(&quot;void carryReduce&quot; + crMethodBreakCount + &quot;(long[] r&quot;);
563             for (int i = 0; i &lt; crNumLimbs; i++) {
564                 append(&quot;, long c&quot; + i);
565             }
566             append(&quot;) {\n&quot;);
567             incrIndent();
568             // declare temporaries
569             for (String temp : temporaries) {
570                 appendLine(&quot;long &quot; + temp + &quot;;&quot;);
571             }
572             append(&quot;\n&quot;);
573 
574             crMethodBreakCount++;
575         }
576 
577         public String getTemporary(String type, String value) {
578             Iterator&lt;String&gt; iter = temporaries.iterator();
579             if (iter.hasNext()) {
580                 String result = iter.next();
581                 iter.remove();
582                 appendLine(result + &quot; = &quot; + value + &quot;;&quot;);
583                 return result;
584             } else {
585                 String result = &quot;t&quot; + (nextTemporary++);
586                 appendLine(type + &quot; &quot; + result + &quot; = &quot; + value + &quot;;&quot;);
587                 return result;
588             }
589         }
590 
591         public void freeTemporary(String temp) {
592             temporaries.add(temp);
593         }
594 
595         public void appendIndent() {
596             for (int i = 0; i &lt; indent; i++) {
597                 buffer.append(&quot;    &quot;);
598             }
599         }
600 
601         public void append(String s) {
602             buffer.append(s);
603         }
604     }
605 
606     private String generate(FieldParams params) throws IOException {
607         CodeBuffer result = new CodeBuffer();
608         String header = readHeader();
609         result.appendLine(header);
610 
611         if (packageName != null) {
612             result.appendLine(&quot;package &quot; + packageName + &quot;;&quot;);
613             result.appendLine();
614         }
615         result.appendLine(&quot;import java.math.BigInteger;&quot;);
616 
617         result.appendLine(&quot;public class &quot; + params.getClassName()
618                 + &quot; extends &quot; + this.parentName + &quot; {&quot;);
619         result.incrIndent();
620 
621         result.appendLine(&quot;private static final int BITS_PER_LIMB = &quot;
622                 + params.getBitsPerLimb() + &quot;;&quot;);
623         result.appendLine(&quot;private static final int NUM_LIMBS = &quot;
624                 + params.getNumLimbs() + &quot;;&quot;);
625         result.appendLine(&quot;private static final int MAX_ADDS = &quot;
626                 + params.getMaxAdds() + &quot;;&quot;);
627         result.appendLine(
628                 &quot;public static final BigInteger MODULUS = evaluateModulus();&quot;);
629         result.appendLine(&quot;private static final long CARRY_ADD = 1 &lt;&lt; &quot;
630                 + (params.getBitsPerLimb() - 1) + &quot;;&quot;);
631         if (params.getBitsPerLimb() * params.getNumLimbs() != params.getPower()) {
632             result.appendLine(&quot;private static final int LIMB_MASK = -1 &quot;
633                     + &quot;&gt;&gt;&gt; (64 - BITS_PER_LIMB);&quot;);
634         }
635         int termIndex = 0;
636 
637         result.appendLine(&quot;public &quot; + params.getClassName() + &quot;() {&quot;);
638         result.appendLine();
639         result.appendLine(&quot;    super(BITS_PER_LIMB, NUM_LIMBS, MAX_ADDS, MODULUS);&quot;);
640         result.appendLine();
641         result.appendLine(&quot;}&quot;);
642 
643         StringBuilder coqTerms = new StringBuilder(&quot;//&quot;);
644         for (Term t : params.getTerms()) {
645             coqTerms.append(&quot;(&quot; + t.getPower() + &quot;%nat,&quot;);
646             coqTerms.append(t.getCoefficient() + &quot;)::&quot;);
647         }
648         coqTerms.append(&quot;nil.&quot;);
649         result.appendLine(coqTerms.toString());
650 
651         result.appendLine(&quot;private static BigInteger evaluateModulus() {&quot;);
652         result.incrIndent();
653         result.appendLine(&quot;BigInteger result = BigInteger.valueOf(2).pow(&quot;
654                 + params.getPower() + &quot;);&quot;);
655         for (Term t : params.getTerms()) {
656             boolean subtract = false;
657             int coefValue = t.getCoefficient();
658             if (coefValue &lt; 0) {
659                 coefValue = 0 - coefValue;
660                 subtract = true;
661             }
662             String coefExpr = &quot;BigInteger.valueOf(&quot; + coefValue + &quot;)&quot;;
663             String powExpr = &quot;BigInteger.valueOf(2).pow(&quot; + t.getPower() + &quot;)&quot;;
664             String termExpr = &quot;ERROR&quot;;
665             if (t.getPower() == 0) {
666                 termExpr = coefExpr;
667             } else if (coefValue == 1) {
668                 termExpr = powExpr;
669             } else {
670                 termExpr = powExpr + &quot;.multiply(&quot; + coefExpr + &quot;)&quot;;
671             }
672             if (subtract) {
673                 result.appendLine(&quot;result = result.subtract(&quot; + termExpr + &quot;);&quot;);
674             } else {
675                 result.appendLine(&quot;result = result.add(&quot; + termExpr + &quot;);&quot;);
676             }
677         }
678         result.appendLine(&quot;return result;&quot;);
679         result.decrIndent();
680         result.appendLine(&quot;}&quot;);
681 
682         result.appendLine(&quot;@Override&quot;);
683         result.appendLine(&quot;protected void reduceIn(long[] limbs, long v, int i) {&quot;);
684         result.incrIndent();
685         String c = &quot;v&quot;;
686         for (Term t : params.getTerms()) {
687             int reduceBits = params.getPower() - t.getPower();
688             int coefficient = -1 * t.getCoefficient();
689 
690             String x = coefficient + &quot; * &quot; + c;
691             String accOp = &quot;+=&quot;;
692             String temp = null;
693             if (coefficient == 1) {
694                 x = c;
695             } else if (coefficient == -1) {
696                 x = c;
697                 accOp = &quot;-=&quot;;
698             } else {
699                 temp = result.getTemporary(&quot;long&quot;, x);
700                 x = temp;
701             }
702 
703             if (reduceBits % params.getBitsPerLimb() == 0) {
704                 int pos = reduceBits / params.getBitsPerLimb();
705                 result.appendLine(&quot;limbs[i - &quot; + pos + &quot;] &quot; + accOp + &quot; &quot; + x + &quot;;&quot;);
706             } else {
707                 int secondPos = reduceBits / params.getBitsPerLimb();
708                 int bitOffset = (secondPos + 1) * params.getBitsPerLimb() - reduceBits;
709                 int rightBitOffset = params.getBitsPerLimb() - bitOffset;
710                 result.appendLine(&quot;limbs[i - &quot; + (secondPos + 1) + &quot;] &quot; + accOp + &quot; (&quot; + x + &quot; &lt;&lt; &quot; + bitOffset + &quot;) &amp; LIMB_MASK;&quot;);
711                 result.appendLine(&quot;limbs[i - &quot; + secondPos + &quot;] &quot; + accOp + &quot; &quot; + x + &quot; &gt;&gt; &quot; + rightBitOffset + &quot;;&quot;);
712             }
713         }
714         result.decrIndent();
715         result.appendLine(&quot;}&quot;);
716 
717         result.appendLine(&quot;@Override&quot;);
718         result.appendLine(&quot;protected void finalCarryReduceLast(long[] limbs) {&quot;);
719         result.incrIndent();
720         int extraBits = params.getBitsPerLimb() * params.getNumLimbs()
721                 - params.getPower();
722         int highBits = params.getBitsPerLimb() - extraBits;
723         result.appendLine(&quot;long c = limbs[&quot; + (params.getNumLimbs() - 1)
724                 + &quot;] &gt;&gt; &quot; + highBits + &quot;;&quot;);
725         result.appendLine(&quot;limbs[&quot; + (params.getNumLimbs() - 1) + &quot;] -= c &lt;&lt; &quot;
726                 + highBits + &quot;;&quot;);
727         for (Term t : params.getTerms()) {
728             int reduceBits = params.getPower() + extraBits - t.getPower();
729             int negatedCoefficient = -1 * t.getCoefficient();
730             modReduceInBits(result, params, true, &quot;limbs&quot;, params.getNumLimbs(),
731                     reduceBits, negatedCoefficient, &quot;c&quot;);
732         }
733         result.decrIndent();
734         result.appendLine(&quot;}&quot;);
735 
736         // full carry/reduce sequence
737         result.appendIndent();
738         result.append(&quot;private void carryReduce(long[] r, &quot;);
739         for (int i = 0; i &lt; 2 * params.getNumLimbs() - 1; i++) {
740             result.append(&quot;long c&quot; + i);
741             if (i &lt; 2 * params.getNumLimbs() - 2) {
742                 result.append(&quot;, &quot;);
743             }
744         }
745         result.append(&quot;) {\n&quot;);
746         result.newTempScope();
747         result.incrIndent();
748         result.appendLine(&quot;long c&quot; + (2 * params.getNumLimbs() - 1) + &quot; = 0;&quot;);
749         write(result, params.getCrSequence(), params, &quot;c&quot;,
750                 2 * params.getNumLimbs());
751         result.appendLine();
752         for (int i = 0; i &lt; params.getNumLimbs(); i++) {
753             result.appendLine(&quot;r[&quot; + i + &quot;] = c&quot; + i + &quot;;&quot;);
754         }
755         result.decrIndent();
756         result.appendLine(&quot;}&quot;);
757 
758         // small carry/reduce sequence
759         result.appendIndent();
760         result.append(&quot;private void carryReduce(long[] r, &quot;);
761         for (int i = 0; i &lt; params.getNumLimbs(); i++) {
762             result.append(&quot;long c&quot; + i);
763             if (i &lt; params.getNumLimbs() - 1) {
764                 result.append(&quot;, &quot;);
765             }
766         }
767         result.append(&quot;) {\n&quot;);
768         result.newTempScope();
769         result.incrIndent();
770         result.appendLine(&quot;long c&quot; + params.getNumLimbs() + &quot; = 0;&quot;);
771         write(result, params.getSmallCrSequence(), params,
772                 &quot;c&quot;, params.getNumLimbs() + 1);
773         result.appendLine();
774         for (int i = 0; i &lt; params.getNumLimbs(); i++) {
775             result.appendLine(&quot;r[&quot; + i + &quot;] = c&quot; + i + &quot;;&quot;);
776         }
777         result.decrIndent();
778         result.appendLine(&quot;}&quot;);
779 
780         result.appendLine(&quot;@Override&quot;);
781         result.appendLine(&quot;protected void mult(long[] a, long[] b, long[] r) {&quot;);
782         result.incrIndent();
783         for (int i = 0; i &lt; 2 * params.getNumLimbs() - 1; i++) {
784             result.appendIndent();
785             result.append(&quot;long c&quot; + i + &quot; = &quot;);
786             int startJ = Math.max(i + 1 - params.getNumLimbs(), 0);
787             int endJ = Math.min(params.getNumLimbs(), i + 1);
788             for (int j = startJ; j &lt; endJ; j++) {
789                 int bIndex = i - j;
790                 result.append(&quot;(a[&quot; + j + &quot;] * b[&quot; + bIndex + &quot;])&quot;);
791                 if (j &lt; endJ - 1) {
792                     result.append(&quot; + &quot;);
793                 }
794             }
795             result.append(&quot;;\n&quot;);
796         }
797         result.appendLine();
798         result.appendIndent();
799         result.append(&quot;carryReduce(r, &quot;);
800         for (int i = 0; i &lt; 2 * params.getNumLimbs() - 1; i++) {
801             result.append(&quot;c&quot; + i);
802             if (i &lt; 2 * params.getNumLimbs() - 2) {
803                 result.append(&quot;, &quot;);
804             }
805         }
806         result.append(&quot;);\n&quot;);
807         result.decrIndent();
808         result.appendLine(&quot;}&quot;);
809 
810         result.appendLine(&quot;@Override&quot;);
811         result.appendLine(&quot;protected void reduce(long[] a) {&quot;);
812         result.incrIndent();
813         result.appendIndent();
814         result.append(&quot;carryReduce(a, &quot;);
815         for (int i = 0; i &lt; params.getNumLimbs(); i++) {
816             result.append(&quot;a[&quot; + i + &quot;]&quot;);
817             if (i &lt; params.getNumLimbs() - 1) {
818                 result.append(&quot;, &quot;);
819             }
820         }
821         result.append(&quot;);\n&quot;);
822         result.decrIndent();
823         result.appendLine(&quot;}&quot;);
824 
825         result.appendLine(&quot;@Override&quot;);
826         result.appendLine(&quot;protected void square(long[] a, long[] r) {&quot;);
827         result.incrIndent();
828         for (int i = 0; i &lt; 2 * params.getNumLimbs() - 1; i++) {
829             result.appendIndent();
830             result.append(&quot;long c&quot; + i + &quot; = &quot;);
831             int startJ = Math.max(i + 1 - params.getNumLimbs(), 0);
832             int endJ = Math.min(params.getNumLimbs(), i + 1);
833             int jDiff = endJ - startJ;
834             if (jDiff &gt; 1) {
835                 result.append(&quot;2 * (&quot;);
836             }
837             for (int j = 0; j &lt; jDiff / 2; j++) {
838                 int aIndex = j + startJ;
839                 int bIndex = i - aIndex;
840                 result.append(&quot;(a[&quot; + aIndex + &quot;] * a[&quot; + bIndex + &quot;])&quot;);
841                 if (j &lt; (jDiff / 2) - 1) {
842                     result.append(&quot; + &quot;);
843                 }
844             }
845             if (jDiff &gt; 1) {
846                 result.append(&quot;)&quot;);
847             }
848             if (jDiff % 2 == 1) {
849                 int aIndex = i / 2;
850                 if (jDiff &gt; 1) {
851                     result.append(&quot; + &quot;);
852                 }
853                 result.append(&quot;(a[&quot; + aIndex + &quot;] * a[&quot; + aIndex + &quot;])&quot;);
854             }
855             result.append(&quot;;\n&quot;);
856         }
857         result.appendLine();
858         result.appendIndent();
859         result.append(&quot;carryReduce(r, &quot;);
860         for (int i = 0; i &lt; 2 * params.getNumLimbs() - 1; i++) {
861             result.append(&quot;c&quot; + i);
862             if (i &lt; 2 * params.getNumLimbs() - 2) {
863                 result.append(&quot;, &quot;);
864             }
865         }
866         result.append(&quot;);\n&quot;);
867         result.decrIndent();
868         result.appendLine(&quot;}&quot;);
869 
870         result.decrIndent();
871         result.appendLine(&quot;}&quot;); // end class
872 
873         return result.toString();
874     }
875 
876     private static void write(CodeBuffer out, List&lt;CarryReduce&gt; sequence,
877             FieldParams params, String prefix, int numLimbs) {
878 
879         out.startCrSequence(numLimbs);
880         for (int i = 0; i &lt; sequence.size(); i++) {
881             CarryReduce cr = sequence.get(i);
882             Iterator&lt;CarryReduce&gt; remainingIter = sequence.listIterator(i + 1);
883             List&lt;CarryReduce&gt; remaining = new ArrayList&lt;CarryReduce&gt;();
884             remainingIter.forEachRemaining(remaining::add);
885             cr.write(out, params, prefix, remaining);
886         }
887     }
888 
889     private static void reduce(CodeBuffer out, FieldParams params,
890             String prefix, int index, Iterable&lt;CarryReduce&gt; remaining) {
891 
892         out.record(Reduce.class);
893 
894         out.appendLine(&quot;//reduce from position &quot; + index);
895         String reduceFrom = indexedExpr(false, prefix, index);
896         boolean referenced = false;
897         for (CarryReduce cr : remaining) {
898             if (cr.index == index) {
899                 referenced = true;
900             }
901         }
902         for (Term t : params.getTerms()) {
903             int reduceBits = params.getPower() - t.getPower();
904             int negatedCoefficient = -1 * t.getCoefficient();
905             modReduceInBits(out, params, false, prefix, index, reduceBits,
906                     negatedCoefficient, reduceFrom);
907         }
908         if (referenced) {
909             out.appendLine(reduceFrom + &quot; = 0;&quot;);
910         }
911     }
912 
913     private static void carry(CodeBuffer out, FieldParams params,
914             String prefix, int index) {
915 
916         out.record(Carry.class);
917 
918         out.appendLine(&quot;//carry from position &quot; + index);
919         String carryFrom = prefix + index;
920         String carryTo = prefix + (index + 1);
921         String carry = &quot;(&quot; + carryFrom + &quot; + CARRY_ADD) &gt;&gt; &quot;
922                 + params.getBitsPerLimb();
923         String temp = out.getTemporary(&quot;long&quot;, carry);
924         out.appendLine(carryFrom + &quot; -= (&quot; + temp + &quot; &lt;&lt; &quot;
925                 + params.getBitsPerLimb() + &quot;);&quot;);
926         out.appendLine(carryTo + &quot; += &quot; + temp + &quot;;&quot;);
927         out.freeTemporary(temp);
928     }
929 
930     private static String indexedExpr(
931             boolean isArray, String prefix, int index) {
932         String result = prefix + index;
933         if (isArray) {
934             result = prefix + &quot;[&quot; + index + &quot;]&quot;;
935         }
936         return result;
937     }
938 
939     private static void modReduceInBits(CodeBuffer result, FieldParams params,
940             boolean isArray, String prefix, int index, int reduceBits,
941             int coefficient, String c) {
942 
943         String x = coefficient + &quot; * &quot; + c;
944         String accOp = &quot;+=&quot;;
945         String temp = null;
946         if (coefficient == 1) {
947             x = c;
948         } else if (coefficient == -1) {
949             x = c;
950             accOp = &quot;-=&quot;;
951         } else {
952             temp = result.getTemporary(&quot;long&quot;, x);
953             x = temp;
954         }
955 
956         if (reduceBits % params.getBitsPerLimb() == 0) {
957             int pos = reduceBits / params.getBitsPerLimb();
958             result.appendLine(indexedExpr(isArray, prefix, (index - pos))
959                     + &quot; &quot; + accOp + &quot; &quot; + x + &quot;;&quot;);
960         } else {
961             int secondPos = reduceBits / params.getBitsPerLimb();
962             int bitOffset = (secondPos + 1) * params.getBitsPerLimb()
963                     - reduceBits;
964             int rightBitOffset = params.getBitsPerLimb() - bitOffset;
965             result.appendLine(indexedExpr(isArray, prefix,
966                     (index - (secondPos + 1))) + &quot; &quot; + accOp
967                     + &quot; (&quot; + x + &quot; &lt;&lt; &quot; + bitOffset + &quot;) &amp; LIMB_MASK;&quot;);
968             result.appendLine(indexedExpr(isArray, prefix,
969                     (index - secondPos)) + &quot; &quot; + accOp + &quot; &quot; + x
970                     + &quot; &gt;&gt; &quot; + rightBitOffset + &quot;;&quot;);
971         }
972 
973         if (temp != null) {
974             result.freeTemporary(temp);
975         }
976     }
977 
978     private String readHeader() throws IOException {
979         BufferedReader reader
980                 = Files.newBufferedReader(headerPath);
981         StringBuffer result = new StringBuffer();
982         reader.lines().forEach(s -&gt; result.append(s + &quot;\n&quot;));
983         return result.toString();
984     }
985 }
    </pre>
  </body>
</html>
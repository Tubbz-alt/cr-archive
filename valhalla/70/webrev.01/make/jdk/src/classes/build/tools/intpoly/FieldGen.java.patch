diff a/make/jdk/src/classes/build/tools/intpoly/FieldGen.java b/make/jdk/src/classes/build/tools/intpoly/FieldGen.java
--- a/make/jdk/src/classes/build/tools/intpoly/FieldGen.java
+++ b/make/jdk/src/classes/build/tools/intpoly/FieldGen.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -19,11 +19,10 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-
 /*
  * This file is used to generated optimized finite field implementations.
  */
 package build.tools.intpoly;
 
@@ -168,10 +167,23 @@
             "P521OrderField", 28, 19, 1, 521,
             "01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409",
             o521crSequence(19), orderFieldSmallCrSequence(19)
     );
 
+    static FieldParams O25519 = new FieldParams(
+            "Curve25519OrderField", 26, 10, 1, 252,
+            "1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed",
+            orderFieldCrSequence(10), orderFieldSmallCrSequence(10)
+    );
+
+    static FieldParams O448 = new FieldParams(
+            "Curve448OrderField", 28, 16, 1, 446,
+            "3fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3",
+            //"ffffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3",
+            orderFieldCrSequence(16), orderFieldSmallCrSequence(16)
+    );
+
     private static List<CarryReduce> o521crSequence(int numLimbs) {
 
         // split the full reduce in half, with a carry in between
         List<CarryReduce> result = new ArrayList<CarryReduce>();
         result.addAll(fullCarry(2 * numLimbs));
@@ -210,11 +222,12 @@
         result.addAll(fullCarry(numLimbs));
         return result;
     }
 
     static final FieldParams[] ALL_FIELDS = {
-            P256, P384, P521, O256, O384, O521,
+            Curve25519, Curve448,
+            P256, P384, P521, O256, O384, O521, O25519, O448
     };
 
     public static class Term {
         private final int power;
         private final int coefficient;
@@ -320,20 +333,28 @@
         }
 
         private Iterable<Term> buildTerms(BigInteger sub) {
             // split a large subtrahend into smaller terms
             // that are aligned with limbs
+            boolean negate = false;
+            if (sub.compareTo(BigInteger.ZERO) < 0) {
+                negate = true;
+                sub = sub.negate();
+            }
             List<Term> result = new ArrayList<Term>();
             BigInteger mod = BigInteger.valueOf(1 << bitsPerLimb);
             int termIndex = 0;
             while (!sub.equals(BigInteger.ZERO)) {
                 int coef = sub.mod(mod).intValue();
                 boolean plusOne = false;
                 if (coef > (1 << (bitsPerLimb - 1))) {
                     coef = coef - (1 << bitsPerLimb);
                     plusOne = true;
                 }
+                if (negate) {
+                    coef = 0 - coef;
+                }
                 if (coef != 0) {
                     int pow = termIndex * bitsPerLimb;
                     result.add(new Term(pow, -coef));
                 }
                 sub = sub.shiftRight(bitsPerLimb);
@@ -617,10 +638,18 @@
         result.appendLine();
         result.appendLine("    super(BITS_PER_LIMB, NUM_LIMBS, MAX_ADDS, MODULUS);");
         result.appendLine();
         result.appendLine("}");
 
+        StringBuilder coqTerms = new StringBuilder("//");
+        for (Term t : params.getTerms()) {
+            coqTerms.append("(" + t.getPower() + "%nat,");
+            coqTerms.append(t.getCoefficient() + ")::");
+        }
+        coqTerms.append("nil.");
+        result.appendLine(coqTerms.toString());
+
         result.appendLine("private static BigInteger evaluateModulus() {");
         result.incrIndent();
         result.appendLine("BigInteger result = BigInteger.valueOf(2).pow("
                 + params.getPower() + ");");
         for (Term t : params.getTerms()) {
@@ -648,10 +677,45 @@
         }
         result.appendLine("return result;");
         result.decrIndent();
         result.appendLine("}");
 
+        result.appendLine("@Override");
+        result.appendLine("protected void reduceIn(long[] limbs, long v, int i) {");
+        result.incrIndent();
+        String c = "v";
+        for (Term t : params.getTerms()) {
+            int reduceBits = params.getPower() - t.getPower();
+            int coefficient = -1 * t.getCoefficient();
+
+            String x = coefficient + " * " + c;
+            String accOp = "+=";
+            String temp = null;
+            if (coefficient == 1) {
+                x = c;
+            } else if (coefficient == -1) {
+                x = c;
+                accOp = "-=";
+            } else {
+                temp = result.getTemporary("long", x);
+                x = temp;
+            }
+
+            if (reduceBits % params.getBitsPerLimb() == 0) {
+                int pos = reduceBits / params.getBitsPerLimb();
+                result.appendLine("limbs[i - " + pos + "] " + accOp + " " + x + ";");
+            } else {
+                int secondPos = reduceBits / params.getBitsPerLimb();
+                int bitOffset = (secondPos + 1) * params.getBitsPerLimb() - reduceBits;
+                int rightBitOffset = params.getBitsPerLimb() - bitOffset;
+                result.appendLine("limbs[i - " + (secondPos + 1) + "] " + accOp + " (" + x + " << " + bitOffset + ") & LIMB_MASK;");
+                result.appendLine("limbs[i - " + secondPos + "] " + accOp + " " + x + " >> " + rightBitOffset + ";");
+            }
+        }
+        result.decrIndent();
+        result.appendLine("}");
+
         result.appendLine("@Override");
         result.appendLine("protected void finalCarryReduceLast(long[] limbs) {");
         result.incrIndent();
         int extraBits = params.getBitsPerLimb() * params.getNumLimbs()
                 - params.getPower();

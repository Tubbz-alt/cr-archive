<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/nio/channels/etc/OpenAndConnect.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import jdk.test.lib.NetworkConfiguration;
 25 import jdk.test.lib.net.IPSupport;
 26 import org.testng.annotations.BeforeTest;
 27 import org.testng.annotations.DataProvider;
 28 import org.testng.annotations.Test;
 29 
 30 import java.io.IOException;
 31 import java.net.*;
 32 import java.nio.channels.*;
 33 import java.util.Arrays;
 34 import java.util.List;
 35 import java.util.LinkedList;
 36 
 37 import static java.lang.System.getProperty;
 38 import static java.lang.System.out;
 39 import static java.net.StandardProtocolFamily.INET;
 40 import static java.net.StandardProtocolFamily.INET6;
 41 import static jdk.test.lib.net.IPSupport.*;
 42 
 43 /*
 44  * @test
 45  * @summary Test SocketChannel, ServerSocketChannel and DatagramChannel
 46  *          open() and connect(), taking into consideration combinations of
 47  *          protocol families (INET, INET6, default),
 48  *          addresses (Inet4Address, Inet6Address).
 49  * @library /test/lib
 50  * @build jdk.test.lib.NetworkConfiguration
 51  * @run testng/othervm OpenAndConnect
 52  */
 53 
 54 
 55 public class OpenAndConnect {
 56     static final Inet4Address IA4ANYLOCAL;
 57     static final Inet6Address IA6ANYLOCAL;
 58     static final Inet4Address IA4LOOPBACK;
 59     static final Inet6Address IA6LOOPBACK;
 60     static Inet4Address IA4LOCAL = null;
 61     static Inet6Address IA6LOCAL = null;
 62     static InetAddress DONT_BIND;
 63 
 64     static {
 65         try {
 66             IA4ANYLOCAL = (Inet4Address) InetAddress.getByName(&quot;0.0.0.0&quot;);
 67             IA6ANYLOCAL = (Inet6Address) InetAddress.getByName(&quot;::0&quot;);
 68             IA4LOOPBACK = (Inet4Address) InetAddress.getByName(&quot;127.0.0.1&quot;);
 69             IA6LOOPBACK = (Inet6Address) InetAddress.getByName(&quot;::1&quot;);
 70 
 71             // Special value to tell test not to call bind (address is not used)
 72             DONT_BIND = (Inet4Address) InetAddress.getByName(&quot;127.0.0.3&quot;);
 73 
 74             initAddrs();
 75         } catch (Exception e) {
 76             throw new RuntimeException(&quot;Could not initialize addresses&quot;, e);
 77         }
 78     }
 79 
 80     @BeforeTest()
 81     public void setup() {
 82         NetworkConfiguration.printSystemConfiguration(out);
 83         IPSupport.printPlatformSupport(out);
 84         throwSkippedExceptionIfNonOperational();
 85 
 86         out.println(&quot;IA4LOCAL:    &quot; + IA4LOCAL);
 87         out.println(&quot;IA6LOCAL:    &quot; + IA6LOCAL);
 88         out.println(&quot;IA4ANYLOCAL: &quot; + IA4ANYLOCAL);
 89         out.println(&quot;IA6ANYLOCAL: &quot; + IA6ANYLOCAL);
 90         out.println(&quot;IA4LOOPBACK: &quot; + IA4LOOPBACK);
 91         out.println(&quot;IA6LOOPBACK: &quot; + IA6LOOPBACK);
 92     }
 93 
 94     @DataProvider(name = &quot;openConnect&quot;)
 95     public Object[][] openConnect() {
 96         LinkedList&lt;Object[]&gt;  l = new LinkedList&lt;&gt;();
 97         l.addAll(openConnectGenTests);
 98         if (IA4LOCAL != null) {
 99             l.addAll(openConnectV4LocalTests);
100         }
101         if (IA6LOCAL != null) {
102             l.addAll(openConnectV6LocalTests);
103         }
104         return l.toArray(new Object[][]{});
105     }
106 
107     //            +----- sfam is server/first socket family
108     //            |
109     //            |       +------ saddr is bind address for server/first socket
110     //            |       |
111     //            |       |              +---- cfam is family for client/second socket
112     //            |       |              |
113     //            |       |              |        +---- caddr is address client/second
114     //            |       |              |        |     socket binds to. When the server
115     //            |       |              |        |     has bound to a wildcard address
116     //            |       |              |        |     this is address used for connect
117     //            |       |              |        |     also.
118     //            |       |              |        |
119     //            |       |              |        |
120     //            |       |              |        |
121     //            |       |              |        |
122     //            +       +              +        +
123     //      {   sfam,   saddr,         cfam,    caddr,      }
124 
125     public static List&lt;Object[]&gt; openConnectGenTests =
126         Arrays.asList(new Object[][] {
127             {   INET,   IA4LOOPBACK,   INET,    IA4LOOPBACK },
128             {   INET,   IA4LOOPBACK,   null,    IA4LOOPBACK },
129             {   INET,   IA4ANYLOCAL,   null,    IA4LOOPBACK },
130             {   INET,   IA4ANYLOCAL,   INET,    IA4LOOPBACK },
131             {   INET6,  IA6ANYLOCAL,   null,    IA6LOOPBACK },
132             {   INET6,  IA6ANYLOCAL,   INET6,   IA6LOOPBACK },
133             {   INET6,  IA6LOOPBACK,   INET6,   IA6LOOPBACK },
134             {   null,   IA4LOOPBACK,   INET,    IA4ANYLOCAL },
135             {   null,   IA4LOOPBACK,   INET,    IA4LOOPBACK },
136             {   null,   IA4LOOPBACK,   INET,    null        },
137             {   null,   IA4LOOPBACK,   INET6,   IA6ANYLOCAL },
138             {   null,   IA6LOOPBACK,   INET6,   IA6ANYLOCAL },
139             {   null,   IA6LOOPBACK,   INET6,   IA6LOOPBACK },
140             {   null,   IA6LOOPBACK,   INET6,   DONT_BIND   },
141             {   null,   IA4LOOPBACK,   INET6,   DONT_BIND   },
142             {   null,   IA4LOOPBACK,   INET6,   null        },
143             {   null,   IA6LOOPBACK,   INET6,   null        },
144             {   null,   IA4LOOPBACK,   null,    IA6ANYLOCAL },
145             {   null,   IA6LOOPBACK,   null,    IA6ANYLOCAL },
146             {   null,   IA6LOOPBACK,   null,    IA6LOOPBACK },
147             {   null,   IA4LOOPBACK,   null,    null        },
148             {   null,   IA6LOOPBACK,   null,    null        },
149             {   null,   IA6ANYLOCAL,   null,    IA6LOCAL    },
150             {   null,   IA6ANYLOCAL,   null,    IA6LOOPBACK },
151             {   null,   IA6ANYLOCAL,   INET6,   IA6LOCAL    },
152             {   null,   IA6ANYLOCAL,   INET6,   IA6LOOPBACK },
153             {   INET6,  IA6LOOPBACK,   INET6,   IA6LOOPBACK }
154         });
155 
156     // Additional tests for when an IPv4 local address or V6
157     // local address is available
158 
159     public List&lt;Object[]&gt;  openConnectV4LocalTests =
160         Arrays.asList(new Object[][] {
161             {   INET,   IA4LOCAL,      INET,    IA4LOCAL    },
162             {   INET,   IA4LOCAL,      null,    IA4LOCAL    },
163             {   INET,   IA4LOCAL,      null,    DONT_BIND   },
164             {   INET,   IA4ANYLOCAL,   INET,    IA4LOCAL    },
165             {   INET,   IA4ANYLOCAL,   null,    IA4LOCAL    },
166             {   null,   IA4LOCAL,      INET,    IA4ANYLOCAL },
167             {   null,   IA4LOCAL,      INET,    IA4LOCAL    },
168             {   null,   IA4LOCAL,      INET,    null        },
169             {   null,   IA4LOCAL,      INET6,   IA6ANYLOCAL },
170             {   null,   IA4LOCAL,      INET6,   null        },
171             {   null,   IA4LOCAL,      null,    IA6ANYLOCAL }
172         });
173 
174     public List&lt;Object[]&gt; openConnectV6LocalTests =
175         Arrays.asList(new Object[][] {
176             {   INET6,  IA6ANYLOCAL,   null,    IA6LOCAL    },
177             {   INET6,  IA6ANYLOCAL,   INET6,   IA6LOCAL    },
178             {   INET6,  IA6LOCAL,      INET6,   IA6LOCAL    },
179             {   INET6,  IA6LOCAL,      null,    IA6LOCAL    },
180             {   INET6,  IA6LOCAL,      null,    DONT_BIND   },
181             {   null,   IA6LOCAL,      INET6,   IA6LOCAL    },
182             {   null,   IA6LOCAL,      INET6,   IA6ANYLOCAL },
183             {   null,   IA6LOCAL,      null,    IA6ANYLOCAL },
184             {   null,   IA6LOCAL,      null,    IA6LOCAL    },
185             {   null,   IA6LOCAL,      INET6,   null        },
186             {   null,   IA6LOCAL,      null,    null        },
187             {   null,   IA4LOCAL,      null,    null        },
188             {   INET6,  IA6LOCAL,      INET6,   IA6LOCAL    }
189         });
190 
191 
192     /**
193      * If the destination address is the wildcard, it is replaced by the alternate
194      * using the port number from destination. Otherwise destination is returned.
195      * Only used by dcOpenAndConnect
196      */
197     static InetSocketAddress getDestinationAddress(SocketAddress destination, InetAddress alternate) {
198         InetSocketAddress isa = (InetSocketAddress)destination;
199         if (isa.getAddress().isAnyLocalAddress())
200             return new InetSocketAddress(alternate, isa.getPort());
201         else
202             return isa;
203     }
204 
205     @Test(dataProvider = &quot;openConnect&quot;)
206     public void scOpenAndConnect(ProtocolFamily sfam,
207                                  InetAddress saddr,
208                                  ProtocolFamily cfam,
209                                  InetAddress caddr) throws IOException
210     {
211         out.printf(&quot;scOpenAndConnect: server bind: %s client bind: %s\n&quot;, saddr, caddr);
212         try (ServerSocketChannel ssc = openSSC(sfam)) {
213             ssc.bind(getSocketAddress(saddr));
214             InetSocketAddress ssa = (InetSocketAddress)ssc.getLocalAddress();
215             ssa = getDestinationAddress(ssa, caddr);
216             out.println(ssa);
217             try (SocketChannel csc = openSC(cfam)) {
218                 if (caddr != DONT_BIND) {
219                     csc.bind(getSocketAddress(caddr));
220                 }
221                 csc.connect(ssa);
222             }
223         }
224     }
225 
226     @Test(dataProvider = &quot;openConnect&quot;)
227     public void dcOpenAndConnect(ProtocolFamily sfam,
228                                  InetAddress saddr,
229                                  ProtocolFamily cfam,
230                                  InetAddress caddr) throws IOException
231     {
232         try (DatagramChannel sdc = openDC(sfam)) {
233             sdc.bind(getSocketAddress(saddr));
234             SocketAddress ssa = sdc.socket().getLocalSocketAddress();
235             ssa = getDestinationAddress(ssa, caddr);
236             out.println(ssa);
237             try (DatagramChannel dc = openDC(cfam)) {
238                 if (caddr != DONT_BIND) {
239                     dc.bind(getSocketAddress(caddr));
240                 }
241                 dc.connect(ssa);
242             }
243         }
244     }
245 
246     // Helper methods
247 
248     private static SocketChannel openSC(ProtocolFamily fam) throws IOException {
249         return fam == null ? SocketChannel.open() : SocketChannel.open(fam);
250     }
251 
252     private static ServerSocketChannel openSSC(ProtocolFamily fam)
253             throws IOException {
254         return fam == null ? ServerSocketChannel.open()
255                 : ServerSocketChannel.open(fam);
256     }
257 
258     private static DatagramChannel openDC(ProtocolFamily fam)
259             throws IOException {
260         return fam == null ? DatagramChannel.open()
261                 : DatagramChannel.open(fam);
262     }
263 
264     private static SocketAddress getSocketAddress(InetAddress ia) {
265         return ia == null ? null : new InetSocketAddress(ia, 0);
266     }
267 
268     private static void initAddrs() throws IOException {
269 
270         NetworkConfiguration cfg = NetworkConfiguration.probe();
271 
272         IA4LOCAL = cfg.ip4Addresses()
273                 .filter(a -&gt; !a.isLoopbackAddress())
274                 .findFirst()
275                 .orElse(null);
276 
277         IA6LOCAL = cfg.ip6Addresses()
278                 .filter(a -&gt; !a.isLoopbackAddress())
279                 .findFirst()
280                 .orElse(null);
281     }
282 }
    </pre>
  </body>
</html>
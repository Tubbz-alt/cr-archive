<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/MulticastSocket/SetOutgoingIf.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4742177 8241786
 27  * @library /test/lib
 28  * @run main/othervm SetOutgoingIf
 29  * @run main/othervm -Djdk.net.usePlainDatagramSocketImpl SetOutgoingIf
 30  * @summary Re-test IPv6 (and specifically MulticastSocket) with latest Linux &amp; USAGI code
 31  */
 32 import java.io.IOException;
 33 import java.net.*;
 34 import java.util.*;
 35 import java.util.concurrent.ConcurrentHashMap;
 36 import jdk.test.lib.NetworkConfiguration;
 37 
 38 
 39 public class SetOutgoingIf implements AutoCloseable {
 40     private static String osname;
 41     private final MulticastSocket SOCKET;
 42     private final int PORT;
 43     private final Map&lt;NetIf, MulticastSender&gt; sendersMap = new ConcurrentHashMap&lt;&gt;();
 44     private SetOutgoingIf() {
 45         try {
 46             SOCKET = new MulticastSocket();
 47             PORT = SOCKET.getLocalPort();
 48         } catch (IOException io) {
 49             throw new ExceptionInInitializerError(io);
 50         }
 51     }
 52 
 53     static boolean isWindows() {
 54         if (osname == null)
 55             osname = System.getProperty(&quot;os.name&quot;);
 56         return osname.contains(&quot;Windows&quot;);
 57     }
 58 
 59     static boolean isMacOS() {
 60         return System.getProperty(&quot;os.name&quot;).contains(&quot;OS X&quot;);
 61     }
 62 
 63     private static boolean hasIPv6() throws Exception {
 64         return NetworkConfiguration.probe()
 65                 .ip6Addresses()
 66                 .findAny()
 67                 .isPresent();
 68     }
 69 
 70     public static void main(String[] args) throws Exception {
 71         try (var test = new SetOutgoingIf()) {
 72             test.run();
 73         }
 74     }
 75 
 76     @Override
 77     public void close() {
 78         try {
 79             SOCKET.close();
 80         } finally {
 81             sendersMap.values().stream().forEach(MulticastSender::close);
 82         }
 83     }
 84 
 85     public void run() throws Exception {
 86         if (isWindows()) {
 87             System.out.println(&quot;The test only run on non-Windows OS. Bye.&quot;);
 88             return;
 89         }
 90 
 91         if (!hasIPv6()) {
 92             System.out.println(&quot;No IPv6 available. Bye.&quot;);
 93             return;
 94         }
 95 
 96         // We need 2 or more network interfaces to run the test
 97         //
 98         List&lt;NetIf&gt; netIfs = new ArrayList&lt;NetIf&gt;();
 99         int index = 1;
100         for (NetworkInterface nic : Collections.list(NetworkInterface.getNetworkInterfaces())) {
101             // we should use only network interfaces with multicast support which are in &quot;up&quot; state
102             if (!nic.isLoopback() &amp;&amp; nic.supportsMulticast() &amp;&amp; nic.isUp() &amp;&amp; !isTestExcludedInterface(nic)) {
103                 NetIf netIf = NetIf.create(nic);
104 
105                 // now determine what (if any) type of addresses are assigned to this interface
106                 for (InetAddress addr : Collections.list(nic.getInetAddresses())) {
107                     if (addr.isAnyLocalAddress())
108                         continue;
109 
110                     System.out.println(&quot;    addr &quot; + addr);
111                     if (addr instanceof Inet4Address) {
112                         netIf.ipv4Address(true);
113                     } else if (addr instanceof Inet6Address) {
114                         netIf.ipv6Address(true);
115                     }
116                 }
117                 if (netIf.ipv4Address() || netIf.ipv6Address()) {
118                     netIf.index(index++);
119                     netIfs.add(netIf);
120                     debug(&quot;Using: &quot; + nic);
121                 }
122             } else {
123                 System.out.println(&quot;Ignore NetworkInterface nic == &quot; + nic);
124             }
125         }
126         Collections.reverse(netIfs);
127         if (netIfs.size() &lt;= 1) {
128             System.out.println(&quot;Need 2 or more network interfaces to run. Bye.&quot;);
129             return;
130         }
131 
132         System.out.println(&quot;Using PORT: &quot; + PORT);
133 
134         // We will send packets to one ipv4, and one ipv6
135         // multicast group using each network interface :-
136         //      224.1.1.1        --|
137         //      ff02::1:1        --|--&gt; using network interface #1
138         //      224.1.2.1        --|
139         //      ff02::1:2        --|--&gt; using network interface #2
140         // and so on.
141         //
142         for (NetIf netIf : netIfs) {
143             int NetIfIndex = netIf.index();
144             List&lt;InetAddress&gt; groups = new ArrayList&lt;InetAddress&gt;();
145 
146             if (netIf.ipv4Address()) {
147                 InetAddress groupv4 = InetAddress.getByName(&quot;224.1.&quot; + NetIfIndex + &quot;.1&quot;);
148                 groups.add(groupv4);
149             }
150             if (netIf.ipv6Address()) {
151                 InetAddress groupv6 = InetAddress.getByName(&quot;ff02::1:&quot; + NetIfIndex);
152                 groups.add(groupv6);
153             }
154 
155             debug(&quot;Adding &quot; + groups + &quot; groups for &quot; + netIf.nic().getName());
156             netIf.groups(groups);
157 
158             // use a separated thread to send to those 2 groups
159             var multicastSender = new MulticastSender(netIf, groups, PORT);
160             sendersMap.put(netIf, multicastSender);
161             Thread sender = new Thread(multicastSender);
162             sender.setDaemon(true); // we want sender to stop when main thread exits
163             sender.start();
164         }
165 
166         // try to receive on each group, then check if the packet comes
167         // from the expected network interface
168         //
169         byte[] buf = new byte[1024];
170         for (NetIf netIf : netIfs) {
171             NetworkInterface nic = netIf.nic();
172             for (InetAddress group : netIf.groups()) {
173                 try (MulticastSocket mcastsock = new MulticastSocket(PORT)) {
174                     mcastsock.setSoTimeout(5000);   // 5 second
175                     DatagramPacket packet = new DatagramPacket(buf, 0, buf.length);
176 
177                     // the interface supports the IP multicast group
178                     debug(&quot;Joining &quot; + group + &quot; on &quot; + nic.getName());
179                     mcastsock.joinGroup(new InetSocketAddress(group, PORT), nic);
180 
181                     try {
182                         mcastsock.receive(packet);
183                         debug(&quot;received packet on &quot; + packet.getAddress());
184                     } catch (Exception e) {
185                         // test failed if any exception
186                         throw new RuntimeException(e);
187                     }
188 
189                     // now check which network interface this packet comes from
190                     NetworkInterface from = NetworkInterface.getByInetAddress(packet.getAddress());
191                     NetworkInterface shouldbe = nic;
192                     if (from != null) {
193                         if (!from.equals(shouldbe)) {
194                             System.out.println(&quot;Packets on group &quot;
195                                     + group + &quot; should come from &quot;
196                                     + shouldbe.getName() + &quot;, but came from &quot;
197                                     + from.getName());
198                         }
199                     }
200 
201                     mcastsock.leaveGroup(new InetSocketAddress(group, PORT), nic);
202                 }
203             }
204         }
205     }
206 
207     private static boolean isTestExcludedInterface(NetworkInterface nif) {
208        return !NetworkConfiguration.isTestable(nif)
209                || isMacOS() &amp;&amp; nif.getName().startsWith(&quot;utun&quot;)
210                || !NetworkConfiguration.hasNonLinkLocalAddress(nif);
211     }
212 
213     private static boolean debug = true;
214 
215     static void debug(String message) {
216         if (debug)
217             System.out.println(message);
218     }
219 }
220 
221 class MulticastSender implements Runnable, AutoCloseable {
222     private final NetIf netIf;
223     private final List&lt;InetAddress&gt; groups;
224     private final int port;
225     private volatile boolean closed;
226     private long count;
227 
228     public MulticastSender(NetIf netIf,
229                   List&lt;InetAddress&gt; groups,
230                   int port) {
231         this.netIf = netIf;
232         this.groups = groups;
233         this.port = port;
234     }
235 
236     @Override
237     public void close() {
238         closed = true;
239     }
240 
241     public void run() {
242         var nic = netIf.nic();
243         try (MulticastSocket mcastsock = new MulticastSocket()) {
244             mcastsock.setNetworkInterface(nic);
245             List&lt;DatagramPacket&gt; packets = new LinkedList&lt;DatagramPacket&gt;();
246 
247             byte[] buf = &quot;hello world&quot;.getBytes();
248             for (InetAddress group : groups) {
249                 packets.add(new DatagramPacket(buf, buf.length, new InetSocketAddress(group, port)));
250             }
251 
252             while (!closed) {
253                 for (DatagramPacket packet : packets) {
254                     mcastsock.send(packet);
255                     count++;
256                 }
257                 System.out.printf(&quot;Sent %d packets from %s\n&quot;, count, nic.getName());
258                 Thread.sleep(1000);   // sleep 1 second
259             }
260         } catch (Exception e) {
261             if (!closed) {
262                 System.err.println(&quot;Unexpected exception for MulticastSender(&quot;
263                         + nic.getName() + &quot;): &quot; + e);
264                 e.printStackTrace();
265                 throw new RuntimeException(e);
266             }
267         } finally {
268             System.out.printf(&quot;Sent %d packets from %s\n&quot;, count, nic.getName());
269         }
270     }
271 }
272 
273 @SuppressWarnings(&quot;unchecked&quot;)
274 class NetIf {
275     private boolean ipv4Address; //false
276     private boolean ipv6Address; //false
277     private int index;
278     List&lt;InetAddress&gt; groups = Collections.EMPTY_LIST;
279     private final NetworkInterface nic;
280 
281     private NetIf(NetworkInterface nic) {
282         this.nic = nic;
283     }
284 
285     static NetIf create(NetworkInterface nic) {
286         return new NetIf(nic);
287     }
288 
289     NetworkInterface nic() {
290         return nic;
291     }
292 
293     boolean ipv4Address() {
294         return ipv4Address;
295     }
296 
297     void ipv4Address(boolean ipv4Address) {
298         this.ipv4Address = ipv4Address;
299     }
300 
301     boolean ipv6Address() {
302         return ipv6Address;
303     }
304 
305     void ipv6Address(boolean ipv6Address) {
306         this.ipv6Address = ipv6Address;
307     }
308 
309     int index() {
310         return index;
311     }
312 
313     void index(int index) {
314         this.index = index;
315     }
316 
317     List&lt;InetAddress&gt; groups() {
318         return groups;
319     }
320 
321     void groups(List&lt;InetAddress&gt; groups) {
322         this.groups = groups;
323     }
324 }
    </pre>
  </body>
</html>
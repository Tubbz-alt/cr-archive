<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/net/SocketOption/AfterClose.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8224477
 27  * @summary Ensures that IOException is thrown after the socket is closed
 28  * @run testng AfterClose
 29  * @run testng/othervm -Djdk.net.usePlainSocketImpl AfterClose
 30  */
 31 
 32 import java.io.IOException;
 33 import java.lang.reflect.Field;
 34 import java.lang.reflect.Method;
 35 import java.net.DatagramSocket;
 36 import java.net.MulticastSocket;
 37 import java.net.NetworkInterface;
 38 import java.net.ServerSocket;
 39 import java.net.Socket;
 40 import java.net.SocketException;
 41 import java.net.SocketOption;
 42 import java.nio.channels.DatagramChannel;
 43 import java.nio.channels.ServerSocketChannel;
 44 import java.nio.channels.SocketChannel;
 45 import java.util.ArrayList;
 46 import java.util.Arrays;
 47 import java.util.HashMap;
 48 import java.util.List;
 49 import java.util.Map;
 50 import java.util.stream.Collectors;
 51 import org.testng.annotations.DataProvider;
 52 import org.testng.annotations.Test;
 53 import static java.lang.Boolean.*;
 54 import static java.net.StandardSocketOptions.*;
 55 import static org.testng.Assert.expectThrows;
 56 
 57 public class AfterClose {
 58 
 59     static final Class&lt;IOException&gt; IOE = IOException.class;
 60 
 61     static Map&lt;SocketOption&lt;?&gt;,List&lt;Object&gt;&gt; OPTION_VALUES_MAP = optionValueMap();
 62 
 63     static boolean supportsMulticast(NetworkInterface ni) {
 64         try {
 65             return ni.supportsMulticast();
 66         } catch (SocketException e) {
 67             return false;
 68         }
 69     }
 70 
 71     static List&lt;Object&gt; listNetworkInterfaces() {
 72         try {
 73             return NetworkInterface.networkInterfaces()
 74                     .filter(AfterClose::supportsMulticast)
 75                     .collect(Collectors.toList());
 76         } catch (Exception e) { }
 77         return List.of();
 78     }
 79 
 80     static Map&lt;SocketOption&lt;?&gt;,List&lt;Object&gt;&gt; optionValueMap() {
 81         Map&lt;SocketOption&lt;?&gt;,List&lt;Object&gt;&gt; map = new HashMap&lt;&gt;();
 82         map.put(IP_MULTICAST_IF,   listNetworkInterfaces() );
 83         map.put(IP_MULTICAST_LOOP, listOf(TRUE, FALSE) );
 84         map.put(IP_MULTICAST_TTL,  listOf(0, 100, 255) );
 85         map.put(IP_TOS,            listOf(0, 101, 255) );
 86         map.put(SO_BROADCAST,      listOf(TRUE, FALSE) );
 87         map.put(SO_KEEPALIVE,      listOf(TRUE, FALSE) );
 88         map.put(SO_LINGER,         listOf(0, 5, 15)    );
 89         map.put(SO_RCVBUF,         listOf(1, 100, 1000));
 90         map.put(SO_REUSEADDR,      listOf(TRUE, FALSE) );
 91         map.put(SO_REUSEPORT,      listOf(TRUE, FALSE) );
 92         map.put(SO_SNDBUF,         listOf(1, 100, 1000));
 93         map.put(TCP_NODELAY,       listOf(TRUE, FALSE) );
 94         // extended options
 95         try {
 96             Class&lt;?&gt; c = Class.forName(&quot;jdk.net.ExtendedSocketOptions&quot;);
 97             Field field = c.getField(&quot;SO_FLOW_SLA&quot;);
 98             map.put((SocketOption&lt;?&gt;)field.get(null), listOf(createSocketFlow()));
 99             field = c.getField(&quot;TCP_QUICKACK&quot;);
100             map.put((SocketOption&lt;?&gt;)field.get(null), listOf(TRUE, FALSE));
101             field = c.getField(&quot;TCP_KEEPIDLE&quot;);
102             map.put((SocketOption&lt;?&gt;)field.get(null), listOf(10, 100));
103             field = c.getField(&quot;TCP_KEEPINTERVAL&quot;);
104             map.put((SocketOption&lt;?&gt;)field.get(null), listOf(10, 100));
105             field = c.getField(&quot;TCP_KEEPCOUNT&quot;);
106             map.put((SocketOption&lt;?&gt;)field.get(null), listOf(10, 100));
107         } catch (ClassNotFoundException e) {
108             // ignore, jdk.net module not present
109         } catch (ReflectiveOperationException e) {
110             throw new AssertionError(e);
111         }
112         return map;
113     }
114 
115     // -- Socket
116 
117     @DataProvider(name = &quot;socketOptionValues&quot;)
118     public Object[][] socketOptionValues() throws Exception {
119         try (Socket s = new Socket()) {
120             return s.supportedOptions().stream()
121                     .map(so -&gt; new Object[] {so, OPTION_VALUES_MAP.get(so)})
122                     .toArray(Object[][]::new);
123         }
124     }
125 
126     @Test(dataProvider = &quot;socketOptionValues&quot;)
127     public &lt;T&gt; void closedSocketImplUncreated(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
128         throws IOException
129     {
130         Socket socket = createClosedSocketImplUncreated();
131         for (int i=0; i&lt;3; i++); {
132             for (T value : values) {
133                 expectThrows(IOE, () -&gt; socket.setOption(option, value));
134                 expectThrows(IOE, () -&gt; socket.getOption(option));
135             }
136         }
137     }
138 
139     @Test(dataProvider = &quot;socketOptionValues&quot;)
140     public &lt;T&gt; void closedSocketImplCreated(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
141         throws IOException
142     {
143         Socket socket = createClosedSocketImplCreated();
144         for (int i=0; i&lt;3; i++); {
145             for (T value : values) {
146                 expectThrows(IOE, () -&gt; socket.setOption(option, value));
147                 expectThrows(IOE, () -&gt; socket.getOption(option));
148             }
149         }
150     }
151 
152     @Test(dataProvider = &quot;socketOptionValues&quot;)
153     public &lt;T&gt; void closedSocketAdapter(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
154         throws IOException
155     {
156         Socket socket = createClosedSocketFromAdapter();
157         for (int i=0; i&lt;3; i++); {
158             for (T value : values) {
159                 expectThrows(IOE, () -&gt; socket.setOption(option, value));
160                 expectThrows(IOE, () -&gt; socket.getOption(option));
161             }
162         }
163     }
164 
165     // -- ServerSocket
166 
167     @DataProvider(name = &quot;serverSocketOptionValues&quot;)
168     public Object[][] serverSocketOptionValues() throws Exception {
169         try (ServerSocket ss = new ServerSocket()) {
170             return ss.supportedOptions().stream()
171                      .map(so -&gt; new Object[] {so, OPTION_VALUES_MAP.get(so)})
172                      .toArray(Object[][]::new);
173         }
174     }
175 
176     @Test(dataProvider = &quot;serverSocketOptionValues&quot;)
177     public &lt;T&gt; void closedServerSocketImplUncreated(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
178         throws IOException
179     {
180         ServerSocket serverSocket = createClosedServerSocketImplUncreated();
181         for (int i=0; i&lt;3; i++); {
182             for (T value : values) {
183                 expectThrows(IOE, () -&gt; serverSocket.setOption(option, value));
184                 expectThrows(IOE, () -&gt; serverSocket.getOption(option));
185             }
186         }
187     }
188 
189     @Test(dataProvider = &quot;serverSocketOptionValues&quot;)
190     public &lt;T&gt; void closedServerSocketImplCreated(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
191         throws IOException
192     {
193         ServerSocket serverSocket = createClosedServerSocketImplCreated();
194         for (int i=0; i&lt;3; i++); {
195             for (T value : values) {
196                 expectThrows(IOE, () -&gt; serverSocket.setOption(option, value));
197                 expectThrows(IOE, () -&gt; serverSocket.getOption(option));
198             }
199         }
200     }
201 
202     @Test(dataProvider = &quot;serverSocketOptionValues&quot;)
203     public &lt;T&gt; void closedServerSocketAdapter(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
204         throws IOException
205     {
206         if (option == IP_TOS)
207             return;  // SSC does not support IP_TOS
208 
209         ServerSocket serverSocket = createClosedServerSocketFromAdapter();
210         for (int i=0; i&lt;3; i++); {
211             for (T value : values) {
212                 expectThrows(IOE, () -&gt; serverSocket.setOption(option, value));
213                 expectThrows(IOE, () -&gt; serverSocket.getOption(option));
214             }
215         }
216     }
217 
218     // -- DatagramSocket
219 
220     @DataProvider(name = &quot;datagramSocketOptionValues&quot;)
221     public Object[][] datagramSocketOptionValues() throws Exception {
222         try (DatagramSocket ds = new DatagramSocket()) {
223             return ds.supportedOptions().stream()
224                      .map(so -&gt; new Object[] {so, OPTION_VALUES_MAP.get(so)})
225                      .toArray(Object[][]::new);
226         }
227     }
228 
229     @Test(dataProvider = &quot;datagramSocketOptionValues&quot;)
230     public &lt;T&gt; void closedUnboundDatagramSocket(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
231         throws IOException
232     {
233         DatagramSocket datagramSocket = createClosedUnboundDatagramSocket();
234         for (int i=0; i&lt;3; i++); {
235             for (T value : values) {
236                 expectThrows(IOE, () -&gt; datagramSocket.setOption(option, value));
237                 expectThrows(IOE, () -&gt; datagramSocket.getOption(option));
238             }
239         }
240     }
241 
242     @Test(dataProvider = &quot;datagramSocketOptionValues&quot;)
243     public &lt;T&gt; void closedBoundDatagramSocket(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
244         throws IOException
245     {
246         DatagramSocket datagramSocket = createClosedBoundDatagramSocket();
247         for (int i=0; i&lt;3; i++); {
248             for (T value : values) {
249                 expectThrows(IOE, () -&gt; datagramSocket.setOption(option, value));
250                 expectThrows(IOE, () -&gt; datagramSocket.getOption(option));
251             }
252         }
253     }
254 
255     @Test(dataProvider = &quot;datagramSocketOptionValues&quot;)
256     public &lt;T&gt; void closedDatagramAdapter(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
257         throws IOException
258     {
259         DatagramSocket datagramSocket = createClosedBoundDatagramSocket();
260         for (int i=0; i&lt;3; i++); {
261             for (T value : values) {
262                 expectThrows(IOE, () -&gt; datagramSocket.setOption(option, value));
263                 expectThrows(IOE, () -&gt; datagramSocket.getOption(option));
264             }
265         }
266     }
267 
268     // -- MulticastSocket
269 
270     @DataProvider(name = &quot;multicastSocketOptionValues&quot;)
271     public Object[][] multicastSocketOptionValues() throws Exception {
272         try (MulticastSocket ms = new MulticastSocket()) {
273             return ms.supportedOptions().stream()
274                      .map(so -&gt; new Object[] {so, OPTION_VALUES_MAP.get(so)})
275                      .toArray(Object[][]::new);
276         }
277     }
278 
279     @Test(dataProvider = &quot;multicastSocketOptionValues&quot;)
280     public &lt;T&gt; void closedUnboundMulticastSocket(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
281         throws IOException
282     {
283         MulticastSocket multicastSocket = createClosedUnboundMulticastSocket();
284         for (int i=0; i&lt;3; i++); {
285             for (T value : values) {
286                 expectThrows(IOE, () -&gt; multicastSocket.setOption(option, value));
287                 expectThrows(IOE, () -&gt; multicastSocket.getOption(option));
288             }
289         }
290     }
291 
292     @Test(dataProvider = &quot;multicastSocketOptionValues&quot;)
293     public &lt;T&gt; void closedBoundMulticastSocket(SocketOption&lt;T&gt; option, List&lt;T&gt; values)
294         throws IOException
295     {
296         MulticastSocket multicastSocket = createClosedBoundMulticastSocket();
297         for (int i=0; i&lt;3; i++); {
298             for (T value : values) {
299                 expectThrows(IOE, () -&gt; multicastSocket.setOption(option, value));
300                 expectThrows(IOE, () -&gt; multicastSocket.getOption(option));
301             }
302         }
303     }
304 
305     // --
306 
307     static List&lt;Object&gt; listOf(Object... objs) {
308         List&lt;Object&gt; l = new ArrayList&lt;&gt;();
309         Arrays.stream(objs).forEachOrdered(l::add);
310         return l;
311     }
312 
313     // Returns a closed Socket that has an impl whose `create` method has NOT been invoked.
314     static Socket createClosedSocketImplUncreated() throws IOException {
315         Socket s = new Socket();
316         s.close();
317         return s;
318     }
319 
320     // Returns a closed Socket that has an impl whose `create` method has been invoked.
321     static Socket createClosedSocketImplCreated() throws IOException {
322         Socket s = new Socket();
323         s.bind(null);  // binding causes impl::create to be invoked
324         s.close();
325         return s;
326     }
327 
328     // Returns a closed Socket created from a SocketChannel&#39;s adapter.
329     static Socket createClosedSocketFromAdapter() throws IOException {
330         SocketChannel sc = SocketChannel.open();
331         sc.close();
332         return sc.socket();
333     }
334 
335     // Returns a closed ServerSocket that has an impl whose `create` method has NOT been invoked.
336     static ServerSocket createClosedServerSocketImplUncreated() throws IOException {
337         ServerSocket ss = new ServerSocket();
338         ss.close();
339         return ss;
340     }
341 
342     // Returns a closed ServerSocket that has an impl whose `create` method has been invoked.
343     static ServerSocket createClosedServerSocketImplCreated() throws IOException {
344         ServerSocket ss = new ServerSocket();
345         ss.bind(null);  // binding causes impl::create to be invoked
346         ss.close();
347         return ss;
348     }
349 
350     // Returns a closed ServerSocket created from a ServerSocketChannel&#39;s adapter.
351     static ServerSocket createClosedServerSocketFromAdapter() throws IOException {
352         ServerSocketChannel ssc = ServerSocketChannel.open();
353         ssc.close();
354         return ssc.socket();
355     }
356 
357     // Returns a closed unbound DatagramSocket.
358     static DatagramSocket createClosedUnboundDatagramSocket() throws IOException {
359         DatagramSocket ds = new DatagramSocket(null);
360         assert ds.isBound() == false;
361         ds.close();
362         return ds;
363     }
364 
365     // Returns a closed bound DatagramSocket.
366     static DatagramSocket createClosedBoundDatagramSocket() throws IOException {
367         DatagramSocket ds = new DatagramSocket();
368         assert ds.isBound() == true;
369         ds.close();
370         return ds;
371     }
372 
373     // Returns a closed DatagramSocket that created from a DatagramChannel&#39;s adapter.
374     static DatagramSocket createClosedDatagramSocketFromAdapter() throws IOException {
375         DatagramChannel dc = DatagramChannel.open();
376         dc.close();
377         return dc.socket();
378     }
379 
380     // Returns a closed unbound MulticastSocket.
381     static MulticastSocket createClosedUnboundMulticastSocket() throws IOException {
382         MulticastSocket ms = new MulticastSocket(null);
383         assert ms.isBound() == false;
384         ms.close();
385         return ms;
386     }
387 
388     // Returns a closed bound MulticastSocket.
389     static MulticastSocket createClosedBoundMulticastSocket() throws IOException {
390         MulticastSocket ms = new MulticastSocket();
391         assert ms.isBound() == true;
392         ms.close();
393         return ms;
394     }
395 
396     static Object createSocketFlow() {
397         try {
398             Class&lt;?&gt; c = Class.forName(&quot;jdk.net.SocketFlow&quot;);
399             Method method = c.getDeclaredMethod(&quot;create&quot;);
400             return method.invoke(null);
401         } catch (ReflectiveOperationException e) {
402             throw new AssertionError(e);
403         }
404     }
405 }
    </pre>
  </body>
</html>
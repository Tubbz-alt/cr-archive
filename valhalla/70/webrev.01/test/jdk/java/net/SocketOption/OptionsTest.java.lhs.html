<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/SocketOption/OptionsTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8036979 8072384 8044773 8225214 8233296 8234083
 27  * @library /test/lib
 28  * @requires !vm.graal.enabled
 29  * @run main/othervm -Xcheck:jni OptionsTest
 30  * @run main/othervm -Djdk.net.usePlainSocketImpl OptionsTest
<a name="1" id="anc1"></a>
 31  * @run main/othervm -Xcheck:jni -Djava.net.preferIPv4Stack=true OptionsTest
 32  * @run main/othervm --limit-modules=java.base OptionsTest
 33  */
 34 
 35 import java.lang.reflect.Method;
 36 import java.net.*;
 37 import java.util.*;
 38 import jdk.test.lib.net.IPSupport;
 39 
 40 public class OptionsTest {
 41 
 42     static class Test&lt;T&gt; {
 43         final SocketOption&lt;T&gt; option;
 44         final T value;
 45         Test(SocketOption&lt;T&gt; option, T value) {
 46             this.option = option;
 47             this.value = value;
 48         }
 49         static &lt;T&gt; Test&lt;T&gt; create(SocketOption&lt;T&gt; option, T value) {
 50             return new Test&lt;T&gt;(option, value);
 51         }
 52 
 53     }
 54 
 55     // The tests set the option using the new API, read back the set value
 56     // which could be different, and then use the legacy get API to check
 57     // these values are the same
 58 
 59     static Test&lt;?&gt;[] socketTests = new Test&lt;?&gt;[] {
 60         Test.create(StandardSocketOptions.SO_KEEPALIVE, Boolean.TRUE),
 61         Test.create(StandardSocketOptions.SO_SNDBUF, Integer.valueOf(10 * 100)),
 62         Test.create(StandardSocketOptions.SO_RCVBUF, Integer.valueOf(8 * 100)),
 63         Test.create(StandardSocketOptions.SO_REUSEADDR, Boolean.FALSE),
 64         Test.create(StandardSocketOptions.SO_REUSEPORT, Boolean.FALSE),
 65         Test.create(StandardSocketOptions.SO_LINGER, Integer.valueOf(-1)),
 66         Test.create(StandardSocketOptions.SO_LINGER, Integer.valueOf(0)),
 67         Test.create(StandardSocketOptions.SO_LINGER, Integer.valueOf(80)),
 68         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(0)),  // lower-bound
 69         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(100)),
 70         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(255))  //upper-bound
 71     };
 72 
 73     static Test&lt;?&gt;[] serverSocketTests = new Test&lt;?&gt;[] {
 74         Test.create(StandardSocketOptions.SO_RCVBUF, Integer.valueOf(8 * 100)),
 75         Test.create(StandardSocketOptions.SO_REUSEADDR, Boolean.FALSE),
 76         Test.create(StandardSocketOptions.SO_REUSEPORT, Boolean.FALSE),
 77         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(0)),  // lower-bound
 78         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(100)),
 79         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(255))  //upper-bound
 80     };
 81 
 82     static Test&lt;?&gt;[] datagramSocketTests = new Test&lt;?&gt;[] {
 83         Test.create(StandardSocketOptions.SO_SNDBUF, Integer.valueOf(10 * 100)),
 84         Test.create(StandardSocketOptions.SO_RCVBUF, Integer.valueOf(8 * 100)),
 85         Test.create(StandardSocketOptions.SO_REUSEADDR, Boolean.FALSE),
 86         Test.create(StandardSocketOptions.SO_REUSEPORT, Boolean.FALSE),
 87         Test.create(StandardSocketOptions.SO_BROADCAST, Boolean.FALSE),
 88         Test.create(StandardSocketOptions.SO_BROADCAST, Boolean.TRUE),
 89         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(0)),  // lower-bound
 90         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(100)),
 91         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(255))  //upper-bound
 92     };
 93 
 94     static Test&lt;?&gt;[] multicastSocketTests = new Test&lt;?&gt;[] {
 95         Test.create(StandardSocketOptions.SO_BROADCAST, Boolean.FALSE),
 96         Test.create(StandardSocketOptions.SO_BROADCAST, Boolean.TRUE),
 97         Test.create(StandardSocketOptions.IP_MULTICAST_IF, getNetworkInterface()),
 98         Test.create(StandardSocketOptions.IP_MULTICAST_TTL, Integer.valueOf(0)),   // lower-bound
 99         Test.create(StandardSocketOptions.IP_MULTICAST_TTL, Integer.valueOf(10)),
100         Test.create(StandardSocketOptions.IP_MULTICAST_TTL, Integer.valueOf(255)), //upper-bound
101         Test.create(StandardSocketOptions.IP_MULTICAST_LOOP, Boolean.TRUE)
102     };
103 
104     static NetworkInterface getNetworkInterface() {
105         try {
106             Enumeration&lt;NetworkInterface&gt; nifs = NetworkInterface.getNetworkInterfaces();
107             while (nifs.hasMoreElements()) {
108                 NetworkInterface ni = nifs.nextElement();
109                 if (ni.supportsMulticast()) {
110                     return ni;
111                 }
112             }
113         } catch (Exception e) {
114         }
115         return null;
116     }
117 
118     static boolean okayToTest(Socket s, SocketOption&lt;?&gt; option) {
119         if (option == StandardSocketOptions.SO_REUSEPORT) {
120             // skip SO_REUSEPORT if option is not supported
121             return s.supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT);
122         }
123         if (option == StandardSocketOptions.IP_TOS &amp;&amp; s.isConnected()) {
124             // skip IP_TOS if connected
125             return false;
126         }
127         return true;
128     }
129 
130     static &lt;T&gt; void testEqual(SocketOption&lt;T&gt; option, T value1, T value2) {
131         if (!value1.equals(value2)) {
132             throw new RuntimeException(&quot;Test of &quot; + option.name() + &quot; failed: &quot;
133                     + value1 + &quot; != &quot; + value2);
134         }
135     }
136 
137     static &lt;T&gt; void test(Socket s, Test&lt;T&gt; test) throws Exception {
138         SocketOption&lt;T&gt; option = test.option;
139         s.setOption(option, test.value);
140         T value1 = s.getOption(test.option);
141         T value2 = (T) legacyGetOption(Socket.class, s, test.option);
142         testEqual(option, value1, value2);
143     }
144 
145     static &lt;T&gt; void test(ServerSocket ss, Test&lt;T&gt; test) throws Exception {
146         SocketOption&lt;T&gt; option = test.option;
147         ss.setOption(option, test.value);
148         T value1 = ss.getOption(test.option);
149         T value2 = (T) legacyGetOption(ServerSocket.class, ss, test.option);
150         testEqual(option, value1, value2);
151     }
152 
153     static &lt;T&gt; void test(DatagramSocket ds, Test&lt;T&gt; test) throws Exception {
154         SocketOption&lt;T&gt; option = test.option;
155         ds.setOption(option, test.value);
156         T value1 = ds.getOption(test.option);
157         T value2 = (T) legacyGetOption(ds.getClass(), ds, test.option);
158         testEqual(option, value1, value2);
159     }
160 
161     // Tests default and negative values of SO_LINGER. All negative values should
162     // retrieve as -1.
163     static void testSoLingerValues() throws Exception {
164         try (Socket s = new Socket()) {
165             // retrieve without set
166             int defaultValue = s.getOption(StandardSocketOptions.SO_LINGER);
167             testEqual(StandardSocketOptions.SO_LINGER, -1, defaultValue);
168 
169             for (int v : List.of(-1, -2, -100, -65534, -65535, -65536, -100000)) {
170                 System.out.println(&quot;Testing SO_LINGER with:&quot; + v);
171                 s.setOption(StandardSocketOptions.SO_LINGER, v);
172                 int value = s.getOption(StandardSocketOptions.SO_LINGER);
173                 testEqual(StandardSocketOptions.SO_LINGER, -1, value);
174             }
175         }
176     }
177 
178     @SuppressWarnings(&quot;try&quot;)
179     static void doSocketTests() throws Exception {
180         // unconnected socket
181         try (Socket s = new Socket()) {
182             for (Test&lt;?&gt; test : socketTests) {
183                 if (okayToTest(s, test.option)) {
184                     test(s, test);
185                 }
186             }
187         }
188 
189         // connected socket
190         try (ServerSocket ss = new ServerSocket()) {
191             var loopback = InetAddress.getLoopbackAddress();
192             ss.bind(new InetSocketAddress(loopback, 0));
193             try (Socket s1 = new Socket()) {
194                 s1.connect(ss.getLocalSocketAddress());
195                 try (Socket s2 = ss.accept()) {
196                     for (Test&lt;?&gt; test : socketTests) {
197                         if (okayToTest(s1, test.option)) {
198                             test(s1, test);
199                         }
200                     }
201                 }
202             }
203         }
204 
205         testSoLingerValues();
206     }
207 
208     static void doServerSocketTests() throws Exception {
209         try (ServerSocket ss = new ServerSocket(0)) {
210             Set&lt;SocketOption&lt;?&gt;&gt; options = ss.supportedOptions();
211             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
212             for (Test&lt;?&gt; test : serverSocketTests) {
213                 if (!(test.option == StandardSocketOptions.SO_REUSEPORT &amp;&amp; !reuseport)) {
214                     test(ss, test);
215                 }
216             }
217         }
218     }
219 
220     static void doDatagramSocketTests() throws Exception {
221         try (DatagramSocket ds = new DatagramSocket(0)) {
222             Set&lt;SocketOption&lt;?&gt;&gt; options = ds.supportedOptions();
223             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
224             for (Test&lt;?&gt; test : datagramSocketTests) {
225                 if (!(test.option == StandardSocketOptions.SO_REUSEPORT &amp;&amp; !reuseport)) {
226                     test(ds, test);
227                 }
228             }
229         }
230     }
231 
232     static void doMulticastSocketTests() throws Exception {
233         try (MulticastSocket ms = new MulticastSocket(0)) {
234             for (Test&lt;?&gt; test : multicastSocketTests) {
235                 test(ms, test);
236             }
237         }
238     }
239 
240     static Object legacyGetOption(Class&lt;?&gt; type, Object s, Object option) throws Exception {
241         if (type.equals(Socket.class)) {
242             Socket socket = (Socket)s;
243             Set&lt;SocketOption&lt;?&gt;&gt; options = socket.supportedOptions();
244             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
245 
246             if (option.equals(StandardSocketOptions.SO_KEEPALIVE)) {
247                 return Boolean.valueOf(socket.getKeepAlive());
248             } else if (option.equals(StandardSocketOptions.SO_SNDBUF)) {
249                 return Integer.valueOf(socket.getSendBufferSize());
250             } else if (option.equals(StandardSocketOptions.SO_RCVBUF)) {
251                 return Integer.valueOf(socket.getReceiveBufferSize());
252             } else if (option.equals(StandardSocketOptions.SO_REUSEADDR)) {
253                 return Boolean.valueOf(socket.getReuseAddress());
254             } else if (option.equals(StandardSocketOptions.SO_REUSEPORT) &amp;&amp; reuseport) {
255                 return Boolean.valueOf(socket.getOption(StandardSocketOptions.SO_REUSEPORT));
256             } else if (option.equals(StandardSocketOptions.SO_LINGER)) {
257                 return Integer.valueOf(socket.getSoLinger());
258             } else if (option.equals(StandardSocketOptions.IP_TOS)) {
259                 return Integer.valueOf(socket.getTrafficClass());
260             } else if (option.equals(StandardSocketOptions.TCP_NODELAY)) {
261                 return Boolean.valueOf(socket.getTcpNoDelay());
262             } else {
263                 throw new RuntimeException(&quot;unexpected socket option&quot;);
264             }
265         } else if  (type.equals(ServerSocket.class)) {
266             ServerSocket socket = (ServerSocket)s;
267             Set&lt;SocketOption&lt;?&gt;&gt; options = socket.supportedOptions();
268             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
269 
270             if (option.equals(StandardSocketOptions.SO_RCVBUF)) {
271                 return Integer.valueOf(socket.getReceiveBufferSize());
272             } else if (option.equals(StandardSocketOptions.SO_REUSEADDR)) {
273                 return Boolean.valueOf(socket.getReuseAddress());
274             } else if (option.equals(StandardSocketOptions.SO_REUSEPORT) &amp;&amp; reuseport) {
275                 return Boolean.valueOf(socket.getOption(StandardSocketOptions.SO_REUSEPORT));
276             } else if (option.equals(StandardSocketOptions.IP_TOS)) {
277                 return getServerSocketTrafficClass(socket);
278             } else {
279                 throw new RuntimeException(&quot;unexpected socket option&quot;);
280             }
281         } else if  (type.equals(DatagramSocket.class)) {
282             DatagramSocket socket = (DatagramSocket)s;
283             Set&lt;SocketOption&lt;?&gt;&gt; options = socket.supportedOptions();
284             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
285 
286             if (option.equals(StandardSocketOptions.SO_SNDBUF)) {
287                 return Integer.valueOf(socket.getSendBufferSize());
288             } else if (option.equals(StandardSocketOptions.SO_RCVBUF)) {
289                 return Integer.valueOf(socket.getReceiveBufferSize());
290             } else if (option.equals(StandardSocketOptions.SO_REUSEADDR)) {
291                 return Boolean.valueOf(socket.getReuseAddress());
292             } else if (option.equals(StandardSocketOptions.SO_BROADCAST)) {
293                 return Boolean.valueOf(socket.getBroadcast());
294             } else if (option.equals(StandardSocketOptions.SO_REUSEPORT) &amp;&amp; reuseport) {
295                 return Boolean.valueOf(socket.getOption(StandardSocketOptions.SO_REUSEPORT));
296             } else if (option.equals(StandardSocketOptions.IP_TOS)) {
297                 return Integer.valueOf(socket.getTrafficClass());
298             } else {
299                 throw new RuntimeException(&quot;unexpected socket option&quot;);
300             }
301 
302         } else if  (type.equals(MulticastSocket.class)) {
303             MulticastSocket socket = (MulticastSocket)s;
304             Set&lt;SocketOption&lt;?&gt;&gt; options = socket.supportedOptions();
305             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
306 
307             if (option.equals(StandardSocketOptions.SO_SNDBUF)) {
308                 return Integer.valueOf(socket.getSendBufferSize());
309             } else if (option.equals(StandardSocketOptions.SO_RCVBUF)) {
310                 return Integer.valueOf(socket.getReceiveBufferSize());
311             } else if (option.equals(StandardSocketOptions.SO_REUSEADDR)) {
312                 return Boolean.valueOf(socket.getReuseAddress());
313             } else if (option.equals(StandardSocketOptions.SO_BROADCAST)) {
314                 return Boolean.valueOf(socket.getBroadcast());
315             } else if (option.equals(StandardSocketOptions.SO_REUSEPORT) &amp;&amp; reuseport) {
316                 return Boolean.valueOf(socket.getOption(StandardSocketOptions.SO_REUSEPORT));
317             } else if (option.equals(StandardSocketOptions.IP_TOS)) {
318                 return Integer.valueOf(socket.getTrafficClass());
319             } else if (option.equals(StandardSocketOptions.IP_MULTICAST_IF)) {
320                 return socket.getNetworkInterface();
321             } else if (option.equals(StandardSocketOptions.IP_MULTICAST_TTL)) {
322                 return Integer.valueOf(socket.getTimeToLive());
323             } else if (option.equals(StandardSocketOptions.IP_MULTICAST_LOOP)) {
324                 return !Boolean.valueOf(socket.getLoopbackMode());
325             } else {
326                 throw new RuntimeException(&quot;unexpected socket option&quot;);
327             }
328         }
329         throw new RuntimeException(&quot;unexpected socket type&quot;);
330     }
331 
332     public static void main(String args[]) throws Exception {
333         IPSupport.throwSkippedExceptionIfNonOperational();
334         doSocketTests();
335         doServerSocketTests();
336         doDatagramSocketTests();
337         doMulticastSocketTests();
338     }
339 
340     // Reflectively access jdk.net.Sockets.getOption so that the test can run
341     // without the jdk.net module.
342     static Object getServerSocketTrafficClass(ServerSocket ss) throws Exception {
343         try {
344             Class&lt;?&gt; c = Class.forName(&quot;jdk.net.Sockets&quot;);
345             Method m = c.getDeclaredMethod(&quot;getOption&quot;, ServerSocket.class, SocketOption.class);
346             return m.invoke(null, ss, StandardSocketOptions.IP_TOS);
347         } catch (ClassNotFoundException e) {
348             // Ok, jdk.net module not present, just fall back
349             System.out.println(&quot;jdk.net module not present, falling back.&quot;);
350             return Integer.valueOf(ss.getOption(StandardSocketOptions.IP_TOS));
351         } catch (ReflectiveOperationException e) {
352             throw new AssertionError(e);
353         }
354     }
355 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/SocketOption/OptionsTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8036979 8072384 8044773 8225214 8233296 8234083
 27  * @library /test/lib
 28  * @requires !vm.graal.enabled
 29  * @run main/othervm -Xcheck:jni OptionsTest
 30  * @run main/othervm -Djdk.net.usePlainSocketImpl OptionsTest
 31  * @run main/othervm -Djdk.net.usePlainDatagramSocketImpl OptionsTest
 32  * @run main/othervm -Xcheck:jni -Djava.net.preferIPv4Stack=true OptionsTest
 33  * @run main/othervm --limit-modules=java.base OptionsTest
 34  */
 35 
 36 import java.lang.reflect.Method;
 37 import java.net.*;
 38 import java.util.*;
 39 import jdk.test.lib.net.IPSupport;
 40 
 41 public class OptionsTest {
 42 
 43     static class Test&lt;T&gt; {
 44         final SocketOption&lt;T&gt; option;
 45         final T value;
 46         Test(SocketOption&lt;T&gt; option, T value) {
 47             this.option = option;
 48             this.value = value;
 49         }
 50         static &lt;T&gt; Test&lt;T&gt; create(SocketOption&lt;T&gt; option, T value) {
 51             return new Test&lt;T&gt;(option, value);
 52         }
 53 
 54     }
 55 
 56     // The tests set the option using the new API, read back the set value
 57     // which could be different, and then use the legacy get API to check
 58     // these values are the same
 59 
 60     static Test&lt;?&gt;[] socketTests = new Test&lt;?&gt;[] {
 61         Test.create(StandardSocketOptions.SO_KEEPALIVE, Boolean.TRUE),
 62         Test.create(StandardSocketOptions.SO_SNDBUF, Integer.valueOf(10 * 100)),
 63         Test.create(StandardSocketOptions.SO_RCVBUF, Integer.valueOf(8 * 100)),
 64         Test.create(StandardSocketOptions.SO_REUSEADDR, Boolean.FALSE),
 65         Test.create(StandardSocketOptions.SO_REUSEPORT, Boolean.FALSE),
 66         Test.create(StandardSocketOptions.SO_LINGER, Integer.valueOf(-1)),
 67         Test.create(StandardSocketOptions.SO_LINGER, Integer.valueOf(0)),
 68         Test.create(StandardSocketOptions.SO_LINGER, Integer.valueOf(80)),
 69         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(0)),  // lower-bound
 70         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(100)),
 71         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(255))  //upper-bound
 72     };
 73 
 74     static Test&lt;?&gt;[] serverSocketTests = new Test&lt;?&gt;[] {
 75         Test.create(StandardSocketOptions.SO_RCVBUF, Integer.valueOf(8 * 100)),
 76         Test.create(StandardSocketOptions.SO_REUSEADDR, Boolean.FALSE),
 77         Test.create(StandardSocketOptions.SO_REUSEPORT, Boolean.FALSE),
 78         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(0)),  // lower-bound
 79         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(100)),
 80         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(255))  //upper-bound
 81     };
 82 
 83     static Test&lt;?&gt;[] datagramSocketTests = new Test&lt;?&gt;[] {
 84         Test.create(StandardSocketOptions.SO_SNDBUF, Integer.valueOf(10 * 100)),
 85         Test.create(StandardSocketOptions.SO_RCVBUF, Integer.valueOf(8 * 100)),
 86         Test.create(StandardSocketOptions.SO_REUSEADDR, Boolean.FALSE),
 87         Test.create(StandardSocketOptions.SO_REUSEPORT, Boolean.FALSE),
 88         Test.create(StandardSocketOptions.SO_BROADCAST, Boolean.FALSE),
 89         Test.create(StandardSocketOptions.SO_BROADCAST, Boolean.TRUE),
 90         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(0)),  // lower-bound
 91         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(100)),
 92         Test.create(StandardSocketOptions.IP_TOS, Integer.valueOf(255))  //upper-bound
 93     };
 94 
 95     static Test&lt;?&gt;[] multicastSocketTests = new Test&lt;?&gt;[] {
 96         Test.create(StandardSocketOptions.SO_BROADCAST, Boolean.FALSE),
 97         Test.create(StandardSocketOptions.SO_BROADCAST, Boolean.TRUE),
 98         Test.create(StandardSocketOptions.IP_MULTICAST_IF, getNetworkInterface()),
 99         Test.create(StandardSocketOptions.IP_MULTICAST_TTL, Integer.valueOf(0)),   // lower-bound
100         Test.create(StandardSocketOptions.IP_MULTICAST_TTL, Integer.valueOf(10)),
101         Test.create(StandardSocketOptions.IP_MULTICAST_TTL, Integer.valueOf(255)), //upper-bound
102         Test.create(StandardSocketOptions.IP_MULTICAST_LOOP, Boolean.TRUE)
103     };
104 
105     static NetworkInterface getNetworkInterface() {
106         try {
107             Enumeration&lt;NetworkInterface&gt; nifs = NetworkInterface.getNetworkInterfaces();
108             while (nifs.hasMoreElements()) {
109                 NetworkInterface ni = nifs.nextElement();
110                 if (ni.supportsMulticast()) {
111                     return ni;
112                 }
113             }
114         } catch (Exception e) {
115         }
116         return null;
117     }
118 
119     static boolean okayToTest(Socket s, SocketOption&lt;?&gt; option) {
120         if (option == StandardSocketOptions.SO_REUSEPORT) {
121             // skip SO_REUSEPORT if option is not supported
122             return s.supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT);
123         }
124         if (option == StandardSocketOptions.IP_TOS &amp;&amp; s.isConnected()) {
125             // skip IP_TOS if connected
126             return false;
127         }
128         return true;
129     }
130 
131     static &lt;T&gt; void testEqual(SocketOption&lt;T&gt; option, T value1, T value2) {
132         if (!value1.equals(value2)) {
133             throw new RuntimeException(&quot;Test of &quot; + option.name() + &quot; failed: &quot;
134                     + value1 + &quot; != &quot; + value2);
135         }
136     }
137 
138     static &lt;T&gt; void test(Socket s, Test&lt;T&gt; test) throws Exception {
139         SocketOption&lt;T&gt; option = test.option;
140         s.setOption(option, test.value);
141         T value1 = s.getOption(test.option);
142         T value2 = (T) legacyGetOption(Socket.class, s, test.option);
143         testEqual(option, value1, value2);
144     }
145 
146     static &lt;T&gt; void test(ServerSocket ss, Test&lt;T&gt; test) throws Exception {
147         SocketOption&lt;T&gt; option = test.option;
148         ss.setOption(option, test.value);
149         T value1 = ss.getOption(test.option);
150         T value2 = (T) legacyGetOption(ServerSocket.class, ss, test.option);
151         testEqual(option, value1, value2);
152     }
153 
154     static &lt;T&gt; void test(DatagramSocket ds, Test&lt;T&gt; test) throws Exception {
155         SocketOption&lt;T&gt; option = test.option;
156         ds.setOption(option, test.value);
157         T value1 = ds.getOption(test.option);
158         T value2 = (T) legacyGetOption(ds.getClass(), ds, test.option);
159         testEqual(option, value1, value2);
160     }
161 
162     // Tests default and negative values of SO_LINGER. All negative values should
163     // retrieve as -1.
164     static void testSoLingerValues() throws Exception {
165         try (Socket s = new Socket()) {
166             // retrieve without set
167             int defaultValue = s.getOption(StandardSocketOptions.SO_LINGER);
168             testEqual(StandardSocketOptions.SO_LINGER, -1, defaultValue);
169 
170             for (int v : List.of(-1, -2, -100, -65534, -65535, -65536, -100000)) {
171                 System.out.println(&quot;Testing SO_LINGER with:&quot; + v);
172                 s.setOption(StandardSocketOptions.SO_LINGER, v);
173                 int value = s.getOption(StandardSocketOptions.SO_LINGER);
174                 testEqual(StandardSocketOptions.SO_LINGER, -1, value);
175             }
176         }
177     }
178 
179     @SuppressWarnings(&quot;try&quot;)
180     static void doSocketTests() throws Exception {
181         // unconnected socket
182         try (Socket s = new Socket()) {
183             for (Test&lt;?&gt; test : socketTests) {
184                 if (okayToTest(s, test.option)) {
185                     test(s, test);
186                 }
187             }
188         }
189 
190         // connected socket
191         try (ServerSocket ss = new ServerSocket()) {
192             var loopback = InetAddress.getLoopbackAddress();
193             ss.bind(new InetSocketAddress(loopback, 0));
194             try (Socket s1 = new Socket()) {
195                 s1.connect(ss.getLocalSocketAddress());
196                 try (Socket s2 = ss.accept()) {
197                     for (Test&lt;?&gt; test : socketTests) {
198                         if (okayToTest(s1, test.option)) {
199                             test(s1, test);
200                         }
201                     }
202                 }
203             }
204         }
205 
206         testSoLingerValues();
207     }
208 
209     static void doServerSocketTests() throws Exception {
210         try (ServerSocket ss = new ServerSocket(0)) {
211             Set&lt;SocketOption&lt;?&gt;&gt; options = ss.supportedOptions();
212             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
213             for (Test&lt;?&gt; test : serverSocketTests) {
214                 if (!(test.option == StandardSocketOptions.SO_REUSEPORT &amp;&amp; !reuseport)) {
215                     test(ss, test);
216                 }
217             }
218         }
219     }
220 
221     static void doDatagramSocketTests() throws Exception {
222         try (DatagramSocket ds = new DatagramSocket(0)) {
223             Set&lt;SocketOption&lt;?&gt;&gt; options = ds.supportedOptions();
224             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
225             for (Test&lt;?&gt; test : datagramSocketTests) {
226                 if (!(test.option == StandardSocketOptions.SO_REUSEPORT &amp;&amp; !reuseport)) {
227                     test(ds, test);
228                 }
229             }
230         }
231     }
232 
233     static void doMulticastSocketTests() throws Exception {
234         try (MulticastSocket ms = new MulticastSocket(0)) {
235             for (Test&lt;?&gt; test : multicastSocketTests) {
236                 test(ms, test);
237             }
238         }
239     }
240 
241     static Object legacyGetOption(Class&lt;?&gt; type, Object s, Object option) throws Exception {
242         if (type.equals(Socket.class)) {
243             Socket socket = (Socket)s;
244             Set&lt;SocketOption&lt;?&gt;&gt; options = socket.supportedOptions();
245             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
246 
247             if (option.equals(StandardSocketOptions.SO_KEEPALIVE)) {
248                 return Boolean.valueOf(socket.getKeepAlive());
249             } else if (option.equals(StandardSocketOptions.SO_SNDBUF)) {
250                 return Integer.valueOf(socket.getSendBufferSize());
251             } else if (option.equals(StandardSocketOptions.SO_RCVBUF)) {
252                 return Integer.valueOf(socket.getReceiveBufferSize());
253             } else if (option.equals(StandardSocketOptions.SO_REUSEADDR)) {
254                 return Boolean.valueOf(socket.getReuseAddress());
255             } else if (option.equals(StandardSocketOptions.SO_REUSEPORT) &amp;&amp; reuseport) {
256                 return Boolean.valueOf(socket.getOption(StandardSocketOptions.SO_REUSEPORT));
257             } else if (option.equals(StandardSocketOptions.SO_LINGER)) {
258                 return Integer.valueOf(socket.getSoLinger());
259             } else if (option.equals(StandardSocketOptions.IP_TOS)) {
260                 return Integer.valueOf(socket.getTrafficClass());
261             } else if (option.equals(StandardSocketOptions.TCP_NODELAY)) {
262                 return Boolean.valueOf(socket.getTcpNoDelay());
263             } else {
264                 throw new RuntimeException(&quot;unexpected socket option&quot;);
265             }
266         } else if  (type.equals(ServerSocket.class)) {
267             ServerSocket socket = (ServerSocket)s;
268             Set&lt;SocketOption&lt;?&gt;&gt; options = socket.supportedOptions();
269             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
270 
271             if (option.equals(StandardSocketOptions.SO_RCVBUF)) {
272                 return Integer.valueOf(socket.getReceiveBufferSize());
273             } else if (option.equals(StandardSocketOptions.SO_REUSEADDR)) {
274                 return Boolean.valueOf(socket.getReuseAddress());
275             } else if (option.equals(StandardSocketOptions.SO_REUSEPORT) &amp;&amp; reuseport) {
276                 return Boolean.valueOf(socket.getOption(StandardSocketOptions.SO_REUSEPORT));
277             } else if (option.equals(StandardSocketOptions.IP_TOS)) {
278                 return getServerSocketTrafficClass(socket);
279             } else {
280                 throw new RuntimeException(&quot;unexpected socket option&quot;);
281             }
282         } else if  (type.equals(DatagramSocket.class)) {
283             DatagramSocket socket = (DatagramSocket)s;
284             Set&lt;SocketOption&lt;?&gt;&gt; options = socket.supportedOptions();
285             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
286 
287             if (option.equals(StandardSocketOptions.SO_SNDBUF)) {
288                 return Integer.valueOf(socket.getSendBufferSize());
289             } else if (option.equals(StandardSocketOptions.SO_RCVBUF)) {
290                 return Integer.valueOf(socket.getReceiveBufferSize());
291             } else if (option.equals(StandardSocketOptions.SO_REUSEADDR)) {
292                 return Boolean.valueOf(socket.getReuseAddress());
293             } else if (option.equals(StandardSocketOptions.SO_BROADCAST)) {
294                 return Boolean.valueOf(socket.getBroadcast());
295             } else if (option.equals(StandardSocketOptions.SO_REUSEPORT) &amp;&amp; reuseport) {
296                 return Boolean.valueOf(socket.getOption(StandardSocketOptions.SO_REUSEPORT));
297             } else if (option.equals(StandardSocketOptions.IP_TOS)) {
298                 return Integer.valueOf(socket.getTrafficClass());
299             } else {
300                 throw new RuntimeException(&quot;unexpected socket option&quot;);
301             }
302 
303         } else if  (type.equals(MulticastSocket.class)) {
304             MulticastSocket socket = (MulticastSocket)s;
305             Set&lt;SocketOption&lt;?&gt;&gt; options = socket.supportedOptions();
306             boolean reuseport = options.contains(StandardSocketOptions.SO_REUSEPORT);
307 
308             if (option.equals(StandardSocketOptions.SO_SNDBUF)) {
309                 return Integer.valueOf(socket.getSendBufferSize());
310             } else if (option.equals(StandardSocketOptions.SO_RCVBUF)) {
311                 return Integer.valueOf(socket.getReceiveBufferSize());
312             } else if (option.equals(StandardSocketOptions.SO_REUSEADDR)) {
313                 return Boolean.valueOf(socket.getReuseAddress());
314             } else if (option.equals(StandardSocketOptions.SO_BROADCAST)) {
315                 return Boolean.valueOf(socket.getBroadcast());
316             } else if (option.equals(StandardSocketOptions.SO_REUSEPORT) &amp;&amp; reuseport) {
317                 return Boolean.valueOf(socket.getOption(StandardSocketOptions.SO_REUSEPORT));
318             } else if (option.equals(StandardSocketOptions.IP_TOS)) {
319                 return Integer.valueOf(socket.getTrafficClass());
320             } else if (option.equals(StandardSocketOptions.IP_MULTICAST_IF)) {
321                 return socket.getNetworkInterface();
322             } else if (option.equals(StandardSocketOptions.IP_MULTICAST_TTL)) {
323                 return Integer.valueOf(socket.getTimeToLive());
324             } else if (option.equals(StandardSocketOptions.IP_MULTICAST_LOOP)) {
325                 return !Boolean.valueOf(socket.getLoopbackMode());
326             } else {
327                 throw new RuntimeException(&quot;unexpected socket option&quot;);
328             }
329         }
330         throw new RuntimeException(&quot;unexpected socket type&quot;);
331     }
332 
333     public static void main(String args[]) throws Exception {
334         IPSupport.throwSkippedExceptionIfNonOperational();
335         doSocketTests();
336         doServerSocketTests();
337         doDatagramSocketTests();
338         doMulticastSocketTests();
339     }
340 
341     // Reflectively access jdk.net.Sockets.getOption so that the test can run
342     // without the jdk.net module.
343     static Object getServerSocketTrafficClass(ServerSocket ss) throws Exception {
344         try {
345             Class&lt;?&gt; c = Class.forName(&quot;jdk.net.Sockets&quot;);
346             Method m = c.getDeclaredMethod(&quot;getOption&quot;, ServerSocket.class, SocketOption.class);
347             return m.invoke(null, ss, StandardSocketOptions.IP_TOS);
348         } catch (ClassNotFoundException e) {
349             // Ok, jdk.net module not present, just fall back
350             System.out.println(&quot;jdk.net module not present, falling back.&quot;);
351             return Integer.valueOf(ss.getOption(StandardSocketOptions.IP_TOS));
352         } catch (ReflectiveOperationException e) {
353             throw new AssertionError(e);
354         }
355     }
356 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/DatagramSocket/ReuseAddressTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 import java.io.IOException;
 24 import java.net.DatagramSocket;
 25 import java.net.InetAddress;
 26 import java.net.InetSocketAddress;
 27 import java.net.MulticastSocket;
 28 import java.net.SocketException;
 29 
 30 /*
 31  * @test
 32  * @bug 8153674
 33  * @key intermittent
 34  * @summary This test might fail intermittently as it needs a UDP socket that
 35  *          binds to the wildcard address.
 36  * @summary Expected SocketException not thrown when calling bind() with
 37  *   setReuseAddress(false)
 38  * @run main/othervm ReuseAddressTest
<a name="1" id="anc1"></a><span class="line-added"> 39  * @run main/othervm -Djdk.net.usePlainDatagramSocketImpl ReuseAddressTest</span>
 40  */
 41 
 42 public class ReuseAddressTest {
 43 
 44     String getInfo(DatagramSocket soc) {
 45         if (soc == null) {
 46             return null;
 47         }
 48 
 49         return &quot;localPort: &quot; + soc.getLocalPort()
 50                 + &quot;; localAddress: &quot; + soc.getLocalAddress()
 51                 + &quot;; remotePort: &quot; + soc.getPort()
 52                 + &quot;; remoteAddress: &quot; + soc.getInetAddress()
 53                 + &quot;; isClosed: &quot; + soc.isClosed()
 54                 + &quot;; isBound: &quot; + soc.isBound();
 55     }
 56 
 57     static InetSocketAddress createSocketAddress(int testMcastPort) throws Exception {
 58         InetAddress localAddress = InetAddress.getLocalHost();
 59         InetSocketAddress localSocketAddress = new InetSocketAddress(localAddress, testMcastPort);
 60         return localSocketAddress;
 61     }
 62 
 63     /* standalone interface */
 64     public static void main(String argv[]) throws Exception {
 65         ReuseAddressTest test = new ReuseAddressTest();
 66         test.DatagramSocket0029();
 67         test.DatagramSocket0030();
 68         test.DatagramSocket0031();
 69         test.DatagramSocket0032();
 70         test.DatagramSocket0034();
 71         test.DatagramSocket0035();
 72         test.DatagramSocket2028();
 73         test.DatagramSocket2029();
 74         test.DatagramSocket2030();
 75 
 76     }
 77 
 78     /**
 79      * Equivalence class partitioning with input values orientation for public
 80      * void setReuseAddress(boolean on) throws SocketException,
 81      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
 82      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: getReuseAddress() will return false
 83      */
 84     public void DatagramSocket0029() throws Exception {
 85         String testCaseID = &quot;DatagramSocket0029&quot;;
 86         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
 87 
 88         DatagramSocket ds = null;
 89         try {
 90             ds = new DatagramSocket(null);
 91             ds.setReuseAddress(false);
 92             if (ds.getReuseAddress() == true) {
 93                 throw new RuntimeException(&quot;SO_REUSEADDR is not set to false&quot;);
 94             }
 95         } catch (IOException e) {
 96             e.printStackTrace(System.out);
 97             throw new RuntimeException(&quot;unexpected: &quot; + e);
 98         } catch (SecurityException e) {
 99             System.out.println(&quot;Security restriction&quot;);
100         } finally {
101             if (ds != null) {
102                 ds.close();
103             }
104         }
105 
106         System.out.println(&quot;OKAY&quot;);
107     }
108 
109     /**
110      * Equivalence class partitioning with input values orientation for public
111      * void setReuseAddress(boolean on) throws SocketException,
112      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
113      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: Allows completely duplicate bindings (same
114      * address and port) on multicast sockets
115      */
116     public void DatagramSocket0030() throws Exception {
117         String testCaseID = &quot;DatagramSocket0030&quot;;
118         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
119 
120         MulticastSocket ms1 = null;
121         MulticastSocket ms2 = null;
122         try {
123             InetSocketAddress addr = createSocketAddress(0);
124 
125             ms1 = new MulticastSocket(null);
126             ms1.setReuseAddress(true);
127             if (!ms1.getReuseAddress()) {
128                 System.out.println(&quot;Cannot check: &quot;
129                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
130             }
131 
132             try {
133                 ms1.bind(addr);
134             } catch (SocketException e) {
135                 throw new RuntimeException(&quot;cannot bind first socket to &quot; + addr
136                         + &quot; unexpected &quot; + e);
137             }
138 
139             addr = createSocketAddress(ms1.getLocalPort());
140             ms2 = new MulticastSocket(null);
141             ms2.setReuseAddress(true);
142             if (!ms2.getReuseAddress()) {
143                 System.out.println(&quot;Cannot check: &quot;
144                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
145             }
146 
147             try {
148                 ms2.bind(addr);
149             } catch (SocketException e) {
150                 throw new RuntimeException(&quot;cannot bind second socket to &quot; + addr
151                         + &quot; unexpected &quot; + e);
152             }
153 
154             if (ms1.getLocalPort() != addr.getPort() || !ms1.isBound()
155                     || ms2.getLocalPort() != addr.getPort() || !ms2.isBound()) {
156                 System.out.println(&quot;bind() fails with: &quot; + addr);
157                 System.out.println(&quot;  ms1 [&quot; + getInfo(ms1) + &quot;]&quot;);
158                 System.out.println(&quot;  ms2 [&quot; + getInfo(ms2) + &quot;]&quot;);
159                 System.out.println(&quot;  getReuseAddress(): &quot; + ms2.getReuseAddress());
160                 throw new RuntimeException(&quot;bind() fails with: &quot; + addr);
161             }
162 
163         } catch (IOException e) {
164             e.printStackTrace(System.out);
165             throw new RuntimeException(&quot;unexpected: &quot; + e);
166         } catch (SecurityException e) {
167             System.out.println(&quot;Security restriction&quot;);
168         } finally {
169             if (ms1 != null) {
170                 ms1.close();
171             }
172             if (ms2 != null) {
173                 ms2.close();
174             }
175         }
176 
177         System.out.println(&quot;OKAY&quot;);
178     }
179 
180     /**
181      * Equivalence class partitioning with input values orientation for public
182      * void setReuseAddress(boolean on) throws SocketException,
183      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
184      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: The second bind will throw SocketException,
185      * when SO_REUSEADDR disable
186      */
187     public void DatagramSocket0031() throws Exception {
188         String testCaseID = &quot;DatagramSocket0031&quot;;
189         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
190 
191         MulticastSocket ms1 = null;
192         MulticastSocket ms2 = null;
193         try {
194             InetSocketAddress addr = createSocketAddress(0);
195 
196             ms1 = new MulticastSocket(null);
197             try {
198                 ms1.bind(addr);
199             } catch (SocketException e) {
200                 throw new RuntimeException(&quot;cannot bind first socket to &quot; + addr
201                         + &quot; unexpected &quot; + e);
202             }
203 
204             addr = createSocketAddress(ms1.getLocalPort());
205             ms2 = new MulticastSocket(null);
206             ms2.setReuseAddress(false);  // method under test
207 
208             try {
209                 ms2.bind(addr);
210                 System.out.println(&quot;No exceptions: &quot;);
211                 System.out.println(&quot;  addr: &quot; + addr);
212                 System.out.println(&quot;  ms1 [&quot; + getInfo(ms1) + &quot;]&quot;);
213                 System.out.println(&quot;  ms2 [&quot; + getInfo(ms2) + &quot;]&quot;);
214                 System.out.println(&quot;  getReuseAddress(): &quot; + ms2.getReuseAddress());
215                 throw new RuntimeException(&quot;no exceptions from bind() with &quot; + addr);
216             } catch (SocketException e) {
217             }
218 
219         } catch (IOException e) {
220             e.printStackTrace(System.out);
221             throw new RuntimeException(&quot;unexpected: &quot; + e);
222         } catch (SecurityException e) {
223             System.out.println(&quot;Security restriction&quot;);
224         } finally {
225             if (ms1 != null) {
226                 ms1.close();
227             }
228             if (ms2 != null) {
229                 ms2.close();
230             }
231         }
232 
233         System.out.println(&quot;OKAY&quot;);
234     }
235 
236     /**
237      * Equivalence class partitioning with input values orientation for public
238      * void setReuseAddress(boolean on) throws SocketException,
239      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
240      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: Allows a single process to bind the same
241      * port to multiple sockets as long as each bind specifies a different local
242      * IP address
243      */
244     public void DatagramSocket0032() throws Exception {
245         String testCaseID = &quot;DatagramSocket0032&quot;;
246         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setReuseAddress(boolean on) throws SocketException&quot;);
247 
248         DatagramSocket ds1 = null;
249         DatagramSocket ds2 = null;
250         try {
251 
252             InetSocketAddress isa1 = createSocketAddress(0);
253             InetAddress addr = isa1.getAddress();
254             InetAddress wildcard = InetAddress.getByName(&quot;0.0.0.0&quot;);
255             if (addr.equals(wildcard) || addr.isLoopbackAddress()) {
256                 System.out.println(&quot;Cannot check: addresses are equal&quot;);
257             }
258 
259 
260             ds1 = new DatagramSocket(null);
261             ds1.setReuseAddress(true);    // method under test
262             if (!ds1.getReuseAddress()) {
263                 System.out.println(&quot;Cannot check: &quot;
264                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
265             }
266             ds1.bind(isa1);
267 
268             InetSocketAddress isa2 = new InetSocketAddress(wildcard, ds1.getLocalPort());
269 
270             ds2 = new DatagramSocket(null);
271             ds2.setReuseAddress(true);    // method under test
272             if (!ds2.getReuseAddress()) {
273                 System.out.println(&quot;Cannot check: &quot;
274                         + &quot; safety for SO_REUSEADDR option is not guaranteed&quot;);
275             }
276 
277             try {
278                 ds2.bind(isa2);
279             } catch (SocketException e) {
280                 throw new RuntimeException(&quot;cannot bind second socket to &quot; + isa2
281                         + &quot; unexpected &quot; + e);
282             }
283 
284             if (ds1.getLocalPort() != ds2.getLocalPort() || !ds1.isBound()
285                     || !ds2.isBound()) {
286                 System.out.println(&quot;bind() fails with: &quot; + addr);
287                 System.out.println(&quot;  ds1 [&quot; + getInfo(ds1) + &quot;]&quot;);
288                 System.out.println(&quot;  ds2 [&quot; + getInfo(ds2) + &quot;]&quot;);
289                 System.out.println(&quot;  getReuseAddress(): &quot; + ds2.getReuseAddress());
290                 throw new RuntimeException(&quot;bind() fails with: &quot; + addr);
291             }
292 
293         } catch (IOException e) {
294             e.printStackTrace(System.out);
295             throw new RuntimeException(&quot;unexpected: &quot; + e);
296         } catch (SecurityException e) {
297             System.out.println(&quot;Security restriction&quot;);
298         } finally {
299             if (ds1 != null) {
300                 ds1.close();
301             }
302             if (ds2 != null) {
303                 ds2.close();
304             }
305         }
306 
307         System.out.println(&quot;OKAY&quot;);
308     }
309 
310     /**
311      * Assertion testing for public int getTrafficClass() throws
312      * SocketException, will return a number in range from 0 to 255 or throw
313      * SocketException.
314      */
315     public void DatagramSocket2028() throws Exception {
316         String testCaseID = &quot;DatagramSocket2028&quot;;
317         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public int getTrafficClass() throws SocketException&quot;);
318 
319         DatagramSocket ds = null;
320         try {
321             ds = new DatagramSocket();
322             int tc = ds.getTrafficClass();
323             if (tc &lt; 0 || tc &gt; 255) {
324                 throw new RuntimeException(&quot;getTrafficClass() returns: &quot; + tc);
325             }
326         } catch (SecurityException e) {
327             System.out.println(&quot;Security restriction: &quot; + e);
328         } catch (SocketException e) {
329             e.printStackTrace(System.out);
330             throw new RuntimeException(&quot;Unexpected exception : &quot; + e);
331         } finally {
332             if (ds != null) {
333                 ds.close();
334             }
335         }
336 
337         System.out.println(&quot;OKAY&quot;);
338     }
339 
340     /**
341      * Assertion testing for public void setTrafficClass(int tc) throws
342      * SocketException, IAE will be thrown with tc less than 0 or greater than
343      * 255.
344      */
345     public void DatagramSocket2029() throws Exception {
346         String testCaseID = &quot;DatagramSocket2029&quot;;
347         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setTrafficClass(int tc) throws SocketException&quot;);
348 
349         DatagramSocket ds = null;
350         try {
351             ds = new DatagramSocket();
352         } catch (SecurityException e) {
353             System.out.println(&quot;Security restriction: &quot; + e);
354         } catch (IOException e) {
355             e.printStackTrace(System.out);
356             throw new RuntimeException(&quot;cannot create socket: &quot; + e);
357         }
358 
359         int[] values = {
360             Integer.MIN_VALUE, Integer.MIN_VALUE + 1, -1000, -2, -1,
361             256, 257, 1000, 50000, Integer.MAX_VALUE - 1, Integer.MAX_VALUE
362         };
363 
364         for (int i = 0; i &lt; values.length; i++) {
365             try {
366                 ds.setTrafficClass(values[i]);
367                 System.out.println(&quot;No exception with: &quot; + values[i]);
368                 System.out.println(&quot;getTrafficClass() returns: &quot; + ds.getTrafficClass());
369                 ds.close();
370                 throw new RuntimeException(&quot;setTrafficClass() fails with : &quot; + values[i]);
371             } catch (SocketException e) {
372                 ds.close();
373                 e.printStackTrace(System.out);
374                 throw new RuntimeException(&quot;setTrafficClass() throws : &quot; + e);
375             } catch (IllegalArgumentException e) {
376             }
377         }
378 
379         System.out.println(&quot;OKAY&quot;);
380     }
381 
382     /**
383      * Assertion testing for public void setTrafficClass(int tc) throws
384      * SocketException, only SocketException may be thrown with tc in range from
385      * 0 to 255.
386      */
387     public void DatagramSocket2030() throws Exception {
388         String testCaseID = &quot;DatagramSocket2030&quot;;
389         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setTrafficClass(int tc) throws SocketException&quot;);
390 
391         DatagramSocket ds = null;
392         try {
393             ds = new DatagramSocket();
394         } catch (SecurityException e) {
395             System.out.println(&quot;Security restriction: &quot; + e);
396         } catch (IOException e) {
397             e.printStackTrace(System.out);
398             throw new RuntimeException(&quot;cannot create socket: &quot; + e);
399         }
400 
401         for (int i = 0; i &lt;= 255; i++) {
402             try {
403                 ds.setTrafficClass(i);
404             } catch (SocketException e) {
405             }
406         }
407 
408         System.out.println(&quot;OKAY&quot;);
409     }
410 
411     /**
412      * Equivalence class partitioning with input values orientation for public
413      * void setBroadcast(boolean on) throws SocketException,
414      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: false.
415      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: getBroadcast() will return false
416      */
417     public void DatagramSocket0034() throws Exception {
418         String testCaseID = &quot;DatagramSocket0034&quot;;
419         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setBroadcast(boolean on) throws SocketException&quot;);
420 
421         DatagramSocket ds = null;
422         try {
423             ds = new DatagramSocket();
424             ds.setBroadcast(false);
425             if (ds.getBroadcast() == true) {
426                 throw new RuntimeException(&quot;SO_BROADCAST is not set to false&quot;);
427             }
428         } catch (IOException e) {
429             e.printStackTrace(System.out);
430             throw new RuntimeException(&quot;unexpected: &quot; + e);
431         } catch (SecurityException e) {
432             System.out.println(&quot;Security restriction&quot;);
433         } finally {
434             if (ds != null) {
435                 ds.close();
436             }
437         }
438 
439         System.out.println(&quot;OKAY&quot;);
440     }
441 
442     /**
443      * Equivalence class partitioning with input values orientation for public
444      * void setBroadcast(boolean on) throws SocketException,
445      * &lt;br&gt;&lt;b&gt;on&lt;/b&gt;: true.
446      * &lt;br&gt;&lt;b&gt;Expected results&lt;/b&gt;: getBroadcast() will return true
447      */
448     public void DatagramSocket0035() throws Exception {
449         String testCaseID = &quot;DatagramSocket0035&quot;;
450         System.out.println(&quot; &gt;&gt; &quot; + testCaseID + &quot;: &quot; + &quot;public void setBroadcast(boolean on) throws SocketException&quot;);
451 
452         DatagramSocket ds = null;
453         try {
454             ds = new DatagramSocket();
455             ds.setBroadcast(true);
456             if (ds.getBroadcast() == false) {
457                 throw new RuntimeException(&quot;SO_BROADCAST is not set to true&quot;);
458             }
459         } catch (IOException e) {
460             e.printStackTrace(System.out);
461             throw new RuntimeException(&quot;unexpected: &quot; + e);
462         } catch (SecurityException e) {
463             System.out.println(&quot;Security restriction&quot;);
464         } finally {
465             if (ds != null) {
466                 ds.close();
467             }
468         }
469 
470         System.out.println(&quot;OKAY&quot;);
471     }
472 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
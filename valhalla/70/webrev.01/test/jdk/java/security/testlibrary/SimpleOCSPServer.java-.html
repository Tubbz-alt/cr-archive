<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/security/testlibrary/SimpleOCSPServer.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.testlibrary;
  27 
  28 import java.io.*;
  29 import java.net.*;
  30 import java.security.*;
  31 import java.security.cert.CRLReason;
  32 import java.security.cert.X509Certificate;
  33 import java.security.cert.Extension;
  34 import java.security.cert.CertificateException;
  35 import java.security.cert.CertificateEncodingException;
  36 import java.security.Signature;
  37 import java.util.*;
  38 import java.util.concurrent.*;
  39 import java.text.SimpleDateFormat;
  40 import java.math.BigInteger;
  41 
  42 import sun.security.x509.*;
  43 import sun.security.x509.PKIXExtensions;
  44 import sun.security.provider.certpath.ResponderId;
  45 import sun.security.provider.certpath.CertId;
  46 import sun.security.provider.certpath.OCSPResponse;
  47 import sun.security.provider.certpath.OCSPResponse.ResponseStatus;
  48 import sun.security.util.Debug;
  49 import sun.security.util.DerInputStream;
  50 import sun.security.util.DerOutputStream;
  51 import sun.security.util.DerValue;
  52 import sun.security.util.ObjectIdentifier;
  53 
  54 
  55 /**
  56  * This is a simple OCSP server designed to listen and respond to incoming
  57  * requests.
  58  */
  59 public class SimpleOCSPServer {
  60     private final Debug debug = Debug.getInstance(&quot;oserv&quot;);
  61     private static final ObjectIdentifier OCSP_BASIC_RESPONSE_OID =
  62             ObjectIdentifier.of(&quot;1.3.6.1.5.5.7.48.1.1&quot;);
  63     private static final SimpleDateFormat utcDateFmt =
  64             new SimpleDateFormat(&quot;MMM dd yyyy, HH:mm:ss z&quot;);
  65 
  66     static final int FREE_PORT = 0;
  67 
  68     // CertStatus values
  69     public static enum CertStatus {
  70         CERT_STATUS_GOOD,
  71         CERT_STATUS_REVOKED,
  72         CERT_STATUS_UNKNOWN,
  73     }
  74 
  75     // Fields used for the networking portion of the responder
  76     private ServerSocket servSocket;
  77     private InetAddress listenAddress;
  78     private int listenPort;
  79 
  80     // Keystore information (certs, keys, etc.)
  81     private KeyStore keystore;
  82     private X509Certificate issuerCert;
  83     private X509Certificate signerCert;
  84     private PrivateKey signerKey;
  85 
  86     // Fields used for the operational portions of the server
  87     private boolean logEnabled = false;
  88     private ExecutorService threadPool;
  89     private volatile boolean started = false;
  90     private volatile boolean serverReady = false;
  91     private volatile boolean receivedShutdown = false;
  92     private volatile boolean acceptConnections = true;
  93     private volatile long delayMsec = 0;
  94 
  95     // Fields used in the generation of responses
  96     private long nextUpdateInterval = -1;
  97     private Date nextUpdate = null;
  98     private ResponderId respId;
  99     private AlgorithmId sigAlgId;
 100     private Map&lt;CertId, CertStatusInfo&gt; statusDb =
 101             Collections.synchronizedMap(new HashMap&lt;&gt;());
 102 
 103     /**
 104      * Construct a SimpleOCSPServer using keystore, password, and alias
 105      * parameters.
 106      *
 107      * @param ks the keystore to be used
 108      * @param password the password to access key material in the keystore
 109      * @param issuerAlias the alias of the issuer certificate
 110      * @param signerAlias the alias of the signer certificate and key.  A
 111      * value of {@code null} means that the {@code issuerAlias} will be used
 112      * to look up the signer key.
 113      *
 114      * @throws GeneralSecurityException if there are problems accessing the
 115      * keystore or finding objects within the keystore.
 116      * @throws IOException if a {@code ResponderId} cannot be generated from
 117      * the signer certificate.
 118      */
 119     public SimpleOCSPServer(KeyStore ks, String password, String issuerAlias,
 120             String signerAlias) throws GeneralSecurityException, IOException {
 121         this(null, FREE_PORT, ks, password, issuerAlias, signerAlias);
 122     }
 123 
 124     /**
 125      * Construct a SimpleOCSPServer using specific network parameters,
 126      * keystore, password, and alias.
 127      *
 128      * @param addr the address to bind the server to.  A value of {@code null}
 129      * means the server will bind to all interfaces.
 130      * @param port the port to listen on.  A value of {@code 0} will mean that
 131      * the server will randomly pick an open ephemeral port to bind to.
 132      * @param ks the keystore to be used
 133      * @param password the password to access key material in the keystore
 134      * @param issuerAlias the alias of the issuer certificate
 135      * @param signerAlias the alias of the signer certificate and key.  A
 136      * value of {@code null} means that the {@code issuerAlias} will be used
 137      * to look up the signer key.
 138      *
 139      * @throws GeneralSecurityException if there are problems accessing the
 140      * keystore or finding objects within the keystore.
 141      * @throws IOException if a {@code ResponderId} cannot be generated from
 142      * the signer certificate.
 143      */
 144     public SimpleOCSPServer(InetAddress addr, int port, KeyStore ks,
 145             String password, String issuerAlias, String signerAlias)
 146             throws GeneralSecurityException, IOException {
 147         Objects.requireNonNull(ks, &quot;Null keystore provided&quot;);
 148         Objects.requireNonNull(issuerAlias, &quot;Null issuerName provided&quot;);
 149 
 150         utcDateFmt.setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;));
 151 
 152         keystore = ks;
 153         issuerCert = (X509Certificate)ks.getCertificate(issuerAlias);
 154         if (issuerCert == null) {
 155             throw new IllegalArgumentException(&quot;Certificate for alias &quot; +
 156                     issuerAlias + &quot; not found&quot;);
 157         }
 158 
 159         if (signerAlias != null) {
 160             signerCert = (X509Certificate)ks.getCertificate(signerAlias);
 161             if (signerCert == null) {
 162                 throw new IllegalArgumentException(&quot;Certificate for alias &quot; +
 163                     signerAlias + &quot; not found&quot;);
 164             }
 165             signerKey = (PrivateKey)ks.getKey(signerAlias,
 166                     password.toCharArray());
 167             if (signerKey == null) {
 168                 throw new IllegalArgumentException(&quot;PrivateKey for alias &quot; +
 169                     signerAlias + &quot; not found&quot;);
 170             }
 171         } else {
 172             signerCert = issuerCert;
 173             signerKey = (PrivateKey)ks.getKey(issuerAlias,
 174                     password.toCharArray());
 175             if (signerKey == null) {
 176                 throw new IllegalArgumentException(&quot;PrivateKey for alias &quot; +
 177                     issuerAlias + &quot; not found&quot;);
 178             }
 179         }
 180 
 181         sigAlgId = AlgorithmId.get(&quot;Sha256withRSA&quot;);
 182         respId = new ResponderId(signerCert.getSubjectX500Principal());
 183         listenAddress = addr;
 184         listenPort = port;
 185     }
 186 
 187     /**
 188      * Start the server.  The server will bind to the specified network
 189      * address and begin listening for incoming connections.
 190      *
 191      * @throws IOException if any number of things go wonky.
 192      */
 193     public synchronized void start() throws IOException {
 194         // You cannot start the server twice.
 195         if (started) {
 196             log(&quot;Server has already been started&quot;);
 197             return;
 198         } else {
 199             started = true;
 200         }
 201 
 202         // Create and start the thread pool
 203         threadPool = Executors.newFixedThreadPool(32, new ThreadFactory() {
 204             @Override
 205             public Thread newThread(Runnable r) {
 206                 Thread t = Executors.defaultThreadFactory().newThread(r);
 207                 t.setDaemon(true);
 208                 return t;
 209             }
 210         });
 211 
 212         threadPool.submit(new Runnable() {
 213             @Override
 214             public void run() {
 215                 try (ServerSocket sSock = new ServerSocket()) {
 216                     servSocket = sSock;
 217                     servSocket.setReuseAddress(true);
 218                     servSocket.setSoTimeout(500);
 219                     servSocket.bind(new InetSocketAddress(listenAddress,
 220                             listenPort), 128);
 221                     log(&quot;Listening on &quot; + servSocket.getLocalSocketAddress());
 222 
 223                     // Singal ready
 224                     serverReady = true;
 225 
 226                     // Update the listenPort with the new port number.  If
 227                     // the server is restarted, it will bind to the same
 228                     // port rather than picking a new one.
 229                     listenPort = servSocket.getLocalPort();
 230 
 231                     // Main dispatch loop
 232                     while (!receivedShutdown) {
 233                         try {
 234                             Socket newConnection = servSocket.accept();
 235                             if (!acceptConnections) {
 236                                 try {
 237                                     log(&quot;Reject connection&quot;);
 238                                     newConnection.close();
 239                                 } catch (IOException e) {
 240                                     // ignore
 241                                 }
 242                                 continue;
 243                             }
 244                             threadPool.submit(new OcspHandler(newConnection));
 245                         } catch (SocketTimeoutException timeout) {
 246                             // Nothing to do here.  If receivedShutdown
 247                             // has changed to true then the loop will
 248                             // exit on its own.
 249                         } catch (IOException ioe) {
 250                             // Something bad happened, log and force a shutdown
 251                             log(&quot;Unexpected Exception: &quot; + ioe);
 252                             stop();
 253                         }
 254                     }
 255 
 256                     log(&quot;Shutting down...&quot;);
 257                     threadPool.shutdown();
 258                 } catch (IOException ioe) {
 259                     err(ioe);
 260                 } finally {
 261                     // Reset state variables so the server can be restarted
 262                     receivedShutdown = false;
 263                     started = false;
 264                     serverReady = false;
 265                 }
 266             }
 267         });
 268     }
 269 
 270     /**
 271      * Make the OCSP server reject incoming connections.
 272      */
 273     public synchronized void rejectConnections() {
 274         log(&quot;Reject OCSP connections&quot;);
 275         acceptConnections = false;
 276     }
 277 
 278     /**
 279      * Make the OCSP server accept incoming connections.
 280      */
 281     public synchronized void acceptConnections() {
 282         log(&quot;Accept OCSP connections&quot;);
 283         acceptConnections = true;
 284     }
 285 
 286 
 287     /**
 288      * Stop the OCSP server.
 289      */
 290     public synchronized void stop() {
 291         if (started) {
 292             receivedShutdown = true;
 293             log(&quot;Received shutdown notification&quot;);
 294         }
 295     }
 296 
 297     /**
 298      * Print {@code SimpleOCSPServer} operating parameters.
 299      *
 300      * @return the {@code SimpleOCSPServer} operating parameters in
 301      * {@code String} form.
 302      */
 303     @Override
 304     public String toString() {
 305         StringBuilder sb = new StringBuilder();
 306         sb.append(&quot;OCSP Server:\n&quot;);
 307         sb.append(&quot;----------------------------------------------\n&quot;);
 308         sb.append(&quot;issuer: &quot;).append(issuerCert.getSubjectX500Principal()).
 309                 append(&quot;\n&quot;);
 310         sb.append(&quot;signer: &quot;).append(signerCert.getSubjectX500Principal()).
 311                 append(&quot;\n&quot;);
 312         sb.append(&quot;ResponderId: &quot;).append(respId).append(&quot;\n&quot;);
 313         sb.append(&quot;----------------------------------------------&quot;);
 314 
 315         return sb.toString();
 316     }
 317 
 318     /**
 319      * Helpful debug routine to hex dump byte arrays.
 320      *
 321      * @param data the array of bytes to dump to stdout.
 322      *
 323      * @return the hexdump of the byte array
 324      */
 325     private static String dumpHexBytes(byte[] data) {
 326         return dumpHexBytes(data, 16, &quot;\n&quot;, &quot; &quot;);
 327     }
 328 
 329     /**
 330      *
 331      * @param data the array of bytes to dump to stdout.
 332      * @param itemsPerLine the number of bytes to display per line
 333      * if the {@code lineDelim} character is blank then all bytes will be
 334      * printed on a single line.
 335      * @param lineDelim the delimiter between lines
 336      * @param itemDelim the delimiter between bytes
 337      *
 338      * @return The hexdump of the byte array
 339      */
 340     private static String dumpHexBytes(byte[] data, int itemsPerLine,
 341             String lineDelim, String itemDelim) {
 342         StringBuilder sb = new StringBuilder();
 343         if (data != null) {
 344             for (int i = 0; i &lt; data.length; i++) {
 345                 if (i % itemsPerLine == 0 &amp;&amp; i != 0) {
 346                     sb.append(lineDelim);
 347                 }
 348                 sb.append(String.format(&quot;%02X&quot;, data[i])).append(itemDelim);
 349             }
 350         }
 351 
 352         return sb.toString();
 353     }
 354 
 355     /**
 356      * Enable or disable the logging feature.
 357      *
 358      * @param enable {@code true} to enable logging, {@code false} to
 359      * disable it.  The setting must be activated before the server calls
 360      * its start method.  Any calls after that have no effect.
 361      */
 362     public void enableLog(boolean enable) {
 363         if (!started) {
 364             logEnabled = enable;
 365         }
 366     }
 367 
 368     /**
 369      * Sets the nextUpdate interval.  Intervals will be calculated relative
 370      * to the server startup time.  When first set, the nextUpdate date is
 371      * calculated based on the current time plus the interval.  After that,
 372      * calls to getNextUpdate() will return this date if it is still
 373      * later than current time.  If not, the Date will be updated to the
 374      * next interval that is later than current time.  This value must be set
 375      * before the server has had its start method called.  Calls made after
 376      * the server has been started have no effect.
 377      *
 378      * @param interval the recurring time interval in seconds used to
 379      * calculate nextUpdate times.   A value less than or equal to 0 will
 380      * disable the nextUpdate feature.
 381      */
 382     public synchronized void setNextUpdateInterval(long interval) {
 383         if (!started) {
 384             if (interval &lt;= 0) {
 385                 nextUpdateInterval = -1;
 386                 nextUpdate = null;
 387                 log(&quot;nexUpdate support has been disabled&quot;);
 388             } else {
 389                 nextUpdateInterval = interval * 1000;
 390                 nextUpdate = new Date(System.currentTimeMillis() +
 391                         nextUpdateInterval);
 392                 log(&quot;nextUpdate set to &quot; + nextUpdate);
 393             }
 394         }
 395     }
 396 
 397     /**
 398      * Return the nextUpdate {@code Date} object for this server.  If the
 399      * nextUpdate date has already passed, set a new nextUpdate based on
 400      * the nextUpdate interval and return that date.
 401      *
 402      * @return a {@code Date} object set to the nextUpdate field for OCSP
 403      * responses.
 404      */
 405     private synchronized Date getNextUpdate() {
 406         if (nextUpdate != null &amp;&amp; nextUpdate.before(new Date())) {
 407             long nuEpochTime = nextUpdate.getTime();
 408             long currentTime = System.currentTimeMillis();
 409 
 410             // Keep adding nextUpdate intervals until you reach a date
 411             // that is later than current time.
 412             while (currentTime &gt;= nuEpochTime) {
 413                 nuEpochTime += nextUpdateInterval;
 414             }
 415 
 416             // Set the nextUpdate for future threads
 417             nextUpdate = new Date(nuEpochTime);
 418             log(&quot;nextUpdate updated to new value: &quot; + nextUpdate);
 419         }
 420         return nextUpdate;
 421     }
 422 
 423     /**
 424      * Add entries into the responder&#39;s status database.
 425      *
 426      * @param newEntries a map of {@code CertStatusInfo} objects, keyed on
 427      * their serial number (as a {@code BigInteger}).  All serial numbers
 428      * are assumed to have come from this responder&#39;s issuer certificate.
 429      *
 430      * @throws IOException if a CertId cannot be generated.
 431      */
 432     public void updateStatusDb(Map&lt;BigInteger, CertStatusInfo&gt; newEntries)
 433             throws IOException {
 434          if (newEntries != null) {
 435             for (BigInteger serial : newEntries.keySet()) {
 436                 CertStatusInfo info = newEntries.get(serial);
 437                 if (info != null) {
 438                     CertId cid = new CertId(issuerCert,
 439                             new SerialNumber(serial));
 440                     statusDb.put(cid, info);
 441                     log(&quot;Added entry for serial &quot; + serial + &quot;(&quot; +
 442                             info.getType() + &quot;)&quot;);
 443                 }
 444             }
 445         }
 446     }
 447 
 448     /**
 449      * Check the status database for revocation information one one or more
 450      * certificates.
 451      *
 452      * @param reqList the list of {@code LocalSingleRequest} objects taken
 453      * from the incoming OCSP request.
 454      *
 455      * @return a {@code Map} of {@code CertStatusInfo} objects keyed by their
 456      * {@code CertId} values, for each single request passed in.  Those
 457      * CertIds not found in the statusDb will have returned List members with
 458      * a status of UNKNOWN.
 459      */
 460     private Map&lt;CertId, CertStatusInfo&gt; checkStatusDb(
 461             List&lt;LocalOcspRequest.LocalSingleRequest&gt; reqList) {
 462         // TODO figure out what, if anything to do with request extensions
 463         Map&lt;CertId, CertStatusInfo&gt; returnMap = new HashMap&lt;&gt;();
 464 
 465         for (LocalOcspRequest.LocalSingleRequest req : reqList) {
 466             CertId cid = req.getCertId();
 467             CertStatusInfo info = statusDb.get(cid);
 468             if (info != null) {
 469                 log(&quot;Status for SN &quot; + cid.getSerialNumber() + &quot;: &quot; +
 470                         info.getType());
 471                 returnMap.put(cid, info);
 472             } else {
 473                 log(&quot;Status for SN &quot; + cid.getSerialNumber() +
 474                         &quot; not found, using CERT_STATUS_UNKNOWN&quot;);
 475                 returnMap.put(cid,
 476                         new CertStatusInfo(CertStatus.CERT_STATUS_UNKNOWN));
 477             }
 478         }
 479 
 480         return Collections.unmodifiableMap(returnMap);
 481     }
 482 
 483     /**
 484      * Set the digital signature algorithm used to sign OCSP responses.
 485      *
 486      * @param algName The algorithm name
 487      *
 488      * @throws NoSuchAlgorithmException if the algorithm name is invalid.
 489      */
 490     public void setSignatureAlgorithm(String algName)
 491             throws NoSuchAlgorithmException {
 492         if (!started) {
 493             sigAlgId = AlgorithmId.get(algName);
 494         }
 495     }
 496 
 497     /**
 498      * Get the port the OCSP server is running on.
 499      *
 500      * @return the port that the OCSP server is running on, or -1 if the
 501      * server has not yet been bound to a port.
 502      */
 503     public int getPort() {
 504         if (serverReady) {
 505             InetSocketAddress inetSock =
 506                     (InetSocketAddress)servSocket.getLocalSocketAddress();
 507             return inetSock.getPort();
 508         } else {
 509             return -1;
 510         }
 511     }
 512 
 513     /**
 514      * Use to check if OCSP server is ready to accept connection.
 515      *
 516      * @return true if server ready, false otherwise
 517      */
 518     public boolean isServerReady() {
 519         return serverReady;
 520     }
 521 
 522     /**
 523      * Set a delay between the reception of the request and production of
 524      * the response.
 525      *
 526      * @param delayMillis the number of milliseconds to wait before acting
 527      * on the incoming request.
 528      */
 529     public void setDelay(long delayMillis) {
 530         delayMsec = delayMillis &gt; 0 ? delayMillis : 0;
 531         if (delayMsec &gt; 0) {
 532             log(&quot;OCSP latency set to &quot; + delayMsec + &quot; milliseconds.&quot;);
 533         } else {
 534             log(&quot;OCSP latency disabled&quot;);
 535         }
 536     }
 537 
 538     /**
 539      * Log a message to stdout.
 540      *
 541      * @param message the message to log
 542      */
 543     private synchronized void log(String message) {
 544         if (logEnabled || debug != null) {
 545             System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;]: &quot; +
 546                     message);
 547         }
 548     }
 549 
 550     /**
 551      * Log an error message on the stderr stream.
 552      *
 553      * @param message the message to log
 554      */
 555     private static synchronized void err(String message) {
 556         System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;]: &quot; +
 557                 message);
 558     }
 559 
 560     /**
 561      * Log exception information on the stderr stream.
 562      *
 563      * @param exc the exception to dump information about
 564      */
 565     private static synchronized void err(Throwable exc) {
 566         System.out.print(&quot;[&quot; + Thread.currentThread().getName() +
 567                 &quot;]: Exception: &quot;);
 568         exc.printStackTrace(System.out);
 569     }
 570 
 571     /**
 572      * The {@code CertStatusInfo} class defines an object used to return
 573      * information from the internal status database.  The data in this
 574      * object may be used to construct OCSP responses.
 575      */
 576     public static class CertStatusInfo {
 577         private CertStatus certStatusType;
 578         private CRLReason reason;
 579         private Date revocationTime;
 580 
 581         /**
 582          * Create a Certificate status object by providing the status only.
 583          * If the status is {@code REVOKED} then current time is assumed
 584          * for the revocation time.
 585          *
 586          * @param statType the status for this entry.
 587          */
 588         public CertStatusInfo(CertStatus statType) {
 589             this(statType, null, null);
 590         }
 591 
 592         /**
 593          * Create a CertStatusInfo providing both type and revocation date
 594          * (if applicable).
 595          *
 596          * @param statType the status for this entry.
 597          * @param revDate if applicable, the date that revocation took place.
 598          * A value of {@code null} indicates that current time should be used.
 599          * If the value of {@code statType} is not {@code CERT_STATUS_REVOKED},
 600          * then the {@code revDate} parameter is ignored.
 601          */
 602         public CertStatusInfo(CertStatus statType, Date revDate) {
 603             this(statType, revDate, null);
 604         }
 605 
 606         /**
 607          * Create a CertStatusInfo providing type, revocation date
 608          * (if applicable) and revocation reason.
 609          *
 610          * @param statType the status for this entry.
 611          * @param revDate if applicable, the date that revocation took place.
 612          * A value of {@code null} indicates that current time should be used.
 613          * If the value of {@code statType} is not {@code CERT_STATUS_REVOKED},
 614          * then the {@code revDate} parameter is ignored.
 615          * @param revReason the reason the certificate was revoked.  A value of
 616          * {@code null} means that no reason was provided.
 617          */
 618         public CertStatusInfo(CertStatus statType, Date revDate,
 619                 CRLReason revReason) {
 620             Objects.requireNonNull(statType, &quot;Cert Status must be non-null&quot;);
 621             certStatusType = statType;
 622             switch (statType) {
 623                 case CERT_STATUS_GOOD:
 624                 case CERT_STATUS_UNKNOWN:
 625                     revocationTime = null;
 626                     break;
 627                 case CERT_STATUS_REVOKED:
 628                     revocationTime = revDate != null ? (Date)revDate.clone() :
 629                             new Date();
 630                     break;
 631                 default:
 632                     throw new IllegalArgumentException(&quot;Unknown status type: &quot; +
 633                             statType);
 634             }
 635         }
 636 
 637         /**
 638          * Get the cert status type
 639          *
 640          * @return the status applied to this object (e.g.
 641          * {@code CERT_STATUS_GOOD}, {@code CERT_STATUS_UNKNOWN}, etc.)
 642          */
 643         public CertStatus getType() {
 644             return certStatusType;
 645         }
 646 
 647         /**
 648          * Get the revocation time (if applicable).
 649          *
 650          * @return the revocation time as a {@code Date} object, or
 651          * {@code null} if not applicable (i.e. if the certificate hasn&#39;t been
 652          * revoked).
 653          */
 654         public Date getRevocationTime() {
 655             return (revocationTime != null ? (Date)revocationTime.clone() :
 656                     null);
 657         }
 658 
 659         /**
 660          * Get the revocation reason.
 661          *
 662          * @return the revocation reason, or {@code null} if one was not
 663          * provided.
 664          */
 665         public CRLReason getRevocationReason() {
 666             return reason;
 667         }
 668     }
 669 
 670     /**
 671      * Runnable task that handles incoming OCSP Requests and returns
 672      * responses.
 673      */
 674     private class OcspHandler implements Runnable {
 675         private final Socket sock;
 676         InetSocketAddress peerSockAddr;
 677 
 678         /**
 679          * Construct an {@code OcspHandler}.
 680          *
 681          * @param incomingSocket the socket the server created on accept()
 682          */
 683         private OcspHandler(Socket incomingSocket) {
 684             sock = incomingSocket;
 685         }
 686 
 687         /**
 688          * Run the OCSP Request parser and construct a response to be sent
 689          * back to the client.
 690          */
 691         @Override
 692         public void run() {
 693             // If we have implemented a delay to simulate network latency
 694             // wait out the delay here before any other processing.
 695             try {
 696                 if (delayMsec &gt; 0) {
 697                     Thread.sleep(delayMsec);
 698                 }
 699             } catch (InterruptedException ie) {
 700                 // Just log the interrupted sleep
 701                 log(&quot;Delay of &quot; + delayMsec + &quot; milliseconds was interrupted&quot;);
 702             }
 703 
 704             try (Socket ocspSocket = sock;
 705                     InputStream in = ocspSocket.getInputStream();
 706                     OutputStream out = ocspSocket.getOutputStream()) {
 707                 peerSockAddr =
 708                         (InetSocketAddress)ocspSocket.getRemoteSocketAddress();
 709                 log(&quot;Received incoming connection from &quot; + peerSockAddr);
 710                 String[] headerTokens = readLine(in).split(&quot; &quot;);
 711                 LocalOcspRequest ocspReq = null;
 712                 LocalOcspResponse ocspResp = null;
 713                 ResponseStatus respStat = ResponseStatus.INTERNAL_ERROR;
 714                 try {
 715                     if (headerTokens[0] != null) {
 716                         switch (headerTokens[0]) {
 717                             case &quot;POST&quot;:
 718                                     ocspReq = parseHttpOcspPost(in);
 719                                 break;
 720                             case &quot;GET&quot;:
 721                                 // req = parseHttpOcspGet(in);
 722                                 // TODO implement the GET parsing
 723                                 throw new IOException(&quot;GET method unsupported&quot;);
 724                             default:
 725                                 respStat = ResponseStatus.MALFORMED_REQUEST;
 726                                 throw new IOException(&quot;Not a GET or POST&quot;);
 727                         }
 728                     } else {
 729                         respStat = ResponseStatus.MALFORMED_REQUEST;
 730                         throw new IOException(&quot;Unable to get HTTP method&quot;);
 731                     }
 732 
 733                     if (ocspReq != null) {
 734                         log(ocspReq.toString());
 735                         // Get responses for all CertIds in the request
 736                         Map&lt;CertId, CertStatusInfo&gt; statusMap =
 737                                 checkStatusDb(ocspReq.getRequests());
 738                         if (statusMap.isEmpty()) {
 739                             respStat = ResponseStatus.UNAUTHORIZED;
 740                         } else {
 741                             ocspResp = new LocalOcspResponse(
 742                                     ResponseStatus.SUCCESSFUL, statusMap,
 743                                     ocspReq.getExtensions());
 744                         }
 745                     } else {
 746                         respStat = ResponseStatus.MALFORMED_REQUEST;
 747                         throw new IOException(&quot;Found null request&quot;);
 748                     }
 749                 } catch (IOException | RuntimeException exc) {
 750                     err(exc);
 751                 }
 752                 if (ocspResp == null) {
 753                     ocspResp = new LocalOcspResponse(respStat);
 754                 }
 755                 sendResponse(out, ocspResp);
 756             } catch (IOException | CertificateException exc) {
 757                 err(exc);
 758             }
 759         }
 760 
 761         /**
 762          * Send an OCSP response on an {@code OutputStream}.
 763          *
 764          * @param out the {@code OutputStream} on which to send the response.
 765          * @param resp the OCSP response to send.
 766          *
 767          * @throws IOException if an encoding error occurs.
 768          */
 769         public void sendResponse(OutputStream out, LocalOcspResponse resp)
 770                 throws IOException {
 771             StringBuilder sb = new StringBuilder();
 772 
 773             byte[] respBytes;
 774             try {
 775                 respBytes = resp.getBytes();
 776             } catch (RuntimeException re) {
 777                 err(re);
 778                 return;
 779             }
 780 
 781             sb.append(&quot;HTTP/1.0 200 OK\r\n&quot;);
 782             sb.append(&quot;Content-Type: application/ocsp-response\r\n&quot;);
 783             sb.append(&quot;Content-Length: &quot;).append(respBytes.length);
 784             sb.append(&quot;\r\n\r\n&quot;);
 785 
 786             out.write(sb.toString().getBytes(&quot;UTF-8&quot;));
 787             out.write(respBytes);
 788             log(resp.toString());
 789         }
 790 
 791         /**
 792          * Parse the incoming HTTP POST of an OCSP Request.
 793          *
 794          * @param inStream the input stream from the socket bound to this
 795          * {@code OcspHandler}.
 796          *
 797          * @return the OCSP Request as a {@code LocalOcspRequest}
 798          *
 799          * @throws IOException if there are network related issues or problems
 800          * occur during parsing of the OCSP request.
 801          * @throws CertificateException if one or more of the certificates in
 802          * the OCSP request cannot be read/parsed.
 803          */
 804         private LocalOcspRequest parseHttpOcspPost(InputStream inStream)
 805                 throws IOException, CertificateException {
 806             boolean endOfHeader = false;
 807             boolean properContentType = false;
 808             int length = -1;
 809 
 810             while (!endOfHeader) {
 811                 String[] lineTokens = readLine(inStream).split(&quot; &quot;);
 812                 if (lineTokens[0].isEmpty()) {
 813                     endOfHeader = true;
 814                 } else if (lineTokens[0].equalsIgnoreCase(&quot;Content-Type:&quot;)) {
 815                     if (lineTokens[1] == null ||
 816                             !lineTokens[1].equals(
 817                                     &quot;application/ocsp-request&quot;)) {
 818                         log(&quot;Unknown Content-Type: &quot; +
 819                                 (lineTokens[1] != null ?
 820                                         lineTokens[1] : &quot;&lt;NULL&gt;&quot;));
 821                         return null;
 822                     } else {
 823                         properContentType = true;
 824                         log(&quot;Content-Type = &quot; + lineTokens[1]);
 825                     }
 826                 } else if (lineTokens[0].equalsIgnoreCase(&quot;Content-Length:&quot;)) {
 827                     if (lineTokens[1] != null) {
 828                         length = Integer.parseInt(lineTokens[1]);
 829                         log(&quot;Content-Length = &quot; + length);
 830                     }
 831                 }
 832             }
 833 
 834             // Okay, make sure we got what we needed from the header, then
 835             // read the remaining OCSP Request bytes
 836             if (properContentType &amp;&amp; length &gt;= 0) {
 837                 byte[] ocspBytes = new byte[length];
 838                 inStream.read(ocspBytes);
 839                 return new LocalOcspRequest(ocspBytes);
 840             } else {
 841                 return null;
 842             }
 843         }
 844 
 845         /**
 846          * Read a line of text that is CRLF-delimited.
 847          *
 848          * @param is the {@code InputStream} tied to the socket
 849          * for this {@code OcspHandler}
 850          *
 851          * @return a {@code String} consisting of the line of text
 852          * read from the stream with the CRLF stripped.
 853          *
 854          * @throws IOException if any I/O error occurs.
 855          */
 856         private String readLine(InputStream is) throws IOException {
 857             PushbackInputStream pbis = new PushbackInputStream(is);
 858             ByteArrayOutputStream bos = new ByteArrayOutputStream();
 859             boolean done = false;
 860             while (!done) {
 861                 byte b = (byte)pbis.read();
 862                 if (b == &#39;\r&#39;) {
 863                     byte bNext = (byte)pbis.read();
 864                     if (bNext == &#39;\n&#39; || bNext == -1) {
 865                         done = true;
 866                     } else {
 867                         pbis.unread(bNext);
 868                         bos.write(b);
 869                     }
 870                 } else if (b == -1) {
 871                     done = true;
 872                 } else {
 873                     bos.write(b);
 874                 }
 875             }
 876 
 877             return new String(bos.toByteArray(), &quot;UTF-8&quot;);
 878         }
 879     }
 880 
 881 
 882     /**
 883      * Simple nested class to handle OCSP requests without making
 884      * changes to sun.security.provider.certpath.OCSPRequest
 885      */
 886     public class LocalOcspRequest {
 887 
 888         private byte[] nonce;
 889         private byte[] signature = null;
 890         private AlgorithmId algId = null;
 891         private int version = 0;
 892         private GeneralName requestorName = null;
 893         private Map&lt;String, Extension&gt; extensions = Collections.emptyMap();
 894         private final List&lt;LocalSingleRequest&gt; requestList = new ArrayList&lt;&gt;();
 895         private final List&lt;X509Certificate&gt; certificates = new ArrayList&lt;&gt;();
 896 
 897         /**
 898          * Construct a {@code LocalOcspRequest} from its DER encoding.
 899          *
 900          * @param requestBytes the DER-encoded bytes
 901          *
 902          * @throws IOException if decoding errors occur
 903          * @throws CertificateException if certificates are found in the
 904          * OCSP request and they do not parse correctly.
 905          */
 906         private LocalOcspRequest(byte[] requestBytes) throws IOException,
 907                 CertificateException {
 908             Objects.requireNonNull(requestBytes, &quot;Received null input&quot;);
 909 
 910             DerInputStream dis = new DerInputStream(requestBytes);
 911 
 912             // Parse the top-level structure, it should have no more than
 913             // two elements.
 914             DerValue[] topStructs = dis.getSequence(2);
 915             for (DerValue dv : topStructs) {
 916                 if (dv.tag == DerValue.tag_Sequence) {
 917                     parseTbsRequest(dv);
 918                 } else if (dv.isContextSpecific((byte)0)) {
 919                     parseSignature(dv);
 920                 } else {
 921                     throw new IOException(&quot;Unknown tag at top level: &quot; +
 922                             dv.tag);
 923                 }
 924             }
 925         }
 926 
 927         /**
 928          * Parse the signature block from an OCSP request
 929          *
 930          * @param sigSequence a {@code DerValue} containing the signature
 931          * block at the outer sequence datum.
 932          *
 933          * @throws IOException if any non-certificate-based parsing errors occur
 934          * @throws CertificateException if certificates are found in the
 935          * OCSP request and they do not parse correctly.
 936          */
 937         private void parseSignature(DerValue sigSequence)
 938                 throws IOException, CertificateException {
 939             DerValue[] sigItems = sigSequence.data.getSequence(3);
 940             if (sigItems.length != 3) {
 941                 throw new IOException(&quot;Invalid number of signature items: &quot; +
 942                         &quot;expected 3, got &quot; + sigItems.length);
 943             }
 944 
 945             algId = AlgorithmId.parse(sigItems[0]);
 946             signature = sigItems[1].getBitString();
 947 
 948             if (sigItems[2].isContextSpecific((byte)0)) {
 949                 DerValue[] certDerItems = sigItems[2].data.getSequence(4);
 950                 int i = 0;
 951                 for (DerValue dv : certDerItems) {
 952                     X509Certificate xc = new X509CertImpl(dv);
 953                     certificates.add(xc);
 954                 }
 955             } else {
 956                 throw new IOException(&quot;Invalid tag in signature block: &quot; +
 957                     sigItems[2].tag);
 958             }
 959         }
 960 
 961         /**
 962          * Parse the to-be-signed request data
 963          *
 964          * @param tbsReqSeq a {@code DerValue} object containing the to-be-
 965          * signed OCSP request at the outermost SEQUENCE tag.
 966          * @throws IOException if any parsing errors occur
 967          */
 968         private void parseTbsRequest(DerValue tbsReqSeq) throws IOException {
 969             while (tbsReqSeq.data.available() &gt; 0) {
 970                 DerValue dv = tbsReqSeq.data.getDerValue();
 971                 if (dv.isContextSpecific((byte)0)) {
 972                     // The version was explicitly called out
 973                     version = dv.data.getInteger();
 974                 } else if (dv.isContextSpecific((byte)1)) {
 975                     // A GeneralName was provided
 976                     requestorName = new GeneralName(dv.data.getDerValue());
 977                 } else if (dv.isContextSpecific((byte)2)) {
 978                     // Parse the extensions
 979                     DerValue[] extItems = dv.data.getSequence(2);
 980                     extensions = parseExtensions(extItems);
 981                 } else if (dv.tag == DerValue.tag_Sequence) {
 982                     while (dv.data.available() &gt; 0) {
 983                         requestList.add(new LocalSingleRequest(dv.data));
 984                     }
 985                 }
 986             }
 987         }
 988 
 989         /**
 990          * Parse a SEQUENCE of extensions.  This routine is used both
 991          * at the overall request level and down at the singleRequest layer.
 992          *
 993          * @param extDerItems an array of {@code DerValue} items, each one
 994          * consisting of a DER-encoded extension.
 995          *
 996          * @return a {@code Map} of zero or more extensions,
 997          * keyed by its object identifier in {@code String} form.
 998          *
 999          * @throws IOException if any parsing errors occur.
1000          */
1001         private Map&lt;String, Extension&gt; parseExtensions(DerValue[] extDerItems)
1002                 throws IOException {
1003             Map&lt;String, Extension&gt; extMap = new HashMap&lt;&gt;();
1004 
1005             if (extDerItems != null &amp;&amp; extDerItems.length != 0) {
1006                 for (DerValue extDerVal : extDerItems) {
1007                     sun.security.x509.Extension ext =
1008                             new sun.security.x509.Extension(extDerVal);
1009                     extMap.put(ext.getId(), ext);
1010                 }
1011             }
1012 
1013             return extMap;
1014         }
1015 
1016         /**
1017          * Return the list of single request objects in this OCSP request.
1018          *
1019          * @return an unmodifiable {@code List} of zero or more requests.
1020          */
1021         private List&lt;LocalSingleRequest&gt; getRequests() {
1022             return Collections.unmodifiableList(requestList);
1023         }
1024 
1025         /**
1026          * Return the list of X.509 Certificates in this OCSP request.
1027          *
1028          * @return an unmodifiable {@code List} of zero or more
1029          * {@cpde X509Certificate} objects.
1030          */
1031         private List&lt;X509Certificate&gt; getCertificates() {
1032             return Collections.unmodifiableList(certificates);
1033         }
1034 
1035         /**
1036          * Return the map of OCSP request extensions.
1037          *
1038          * @return an unmodifiable {@code Map} of zero or more
1039          * {@code Extension} objects, keyed by their object identifiers
1040          * in {@code String} form.
1041          */
1042         private Map&lt;String, Extension&gt; getExtensions() {
1043             return Collections.unmodifiableMap(extensions);
1044         }
1045 
1046         /**
1047          * Display the {@code LocalOcspRequest} in human readable form.
1048          *
1049          * @return a {@code String} representation of the
1050          * {@code LocalOcspRequest}
1051          */
1052         @Override
1053         public String toString() {
1054             StringBuilder sb = new StringBuilder();
1055 
1056             sb.append(String.format(&quot;OCSP Request: Version %d (0x%X)&quot;,
1057                     version + 1, version)).append(&quot;\n&quot;);
1058             if (requestorName != null) {
1059                 sb.append(&quot;Requestor Name: &quot;).append(requestorName).
1060                         append(&quot;\n&quot;);
1061             }
1062 
1063             int requestCtr = 0;
1064             for (LocalSingleRequest lsr : requestList) {
1065                 sb.append(&quot;Request [&quot;).append(requestCtr++).append(&quot;]\n&quot;);
1066                 sb.append(lsr).append(&quot;\n&quot;);
1067             }
1068             if (!extensions.isEmpty()) {
1069                 sb.append(&quot;Extensions (&quot;).append(extensions.size()).
1070                         append(&quot;)\n&quot;);
1071                 for (Extension ext : extensions.values()) {
1072                     sb.append(&quot;\t&quot;).append(ext).append(&quot;\n&quot;);
1073                 }
1074             }
1075             if (signature != null) {
1076                 sb.append(&quot;Signature: &quot;).append(algId).append(&quot;\n&quot;);
1077                 sb.append(dumpHexBytes(signature)).append(&quot;\n&quot;);
1078                 int certCtr = 0;
1079                 for (X509Certificate cert : certificates) {
1080                     sb.append(&quot;Certificate [&quot;).append(certCtr++).append(&quot;]&quot;).
1081                             append(&quot;\n&quot;);
1082                     sb.append(&quot;\tSubject: &quot;);
1083                     sb.append(cert.getSubjectX500Principal()).append(&quot;\n&quot;);
1084                     sb.append(&quot;\tIssuer: &quot;);
1085                     sb.append(cert.getIssuerX500Principal()).append(&quot;\n&quot;);
1086                     sb.append(&quot;\tSerial: &quot;).append(cert.getSerialNumber());
1087                 }
1088             }
1089 
1090             return sb.toString();
1091         }
1092 
1093         /**
1094          * Inner class designed to handle the decoding/representation of
1095          * single requests within a {@code LocalOcspRequest} object.
1096          */
1097         public class LocalSingleRequest {
1098             private final CertId cid;
1099             private Map&lt;String, Extension&gt; extensions = Collections.emptyMap();
1100 
1101             private LocalSingleRequest(DerInputStream dis)
1102                     throws IOException {
1103                 DerValue[] srItems = dis.getSequence(2);
1104 
1105                 // There should be 1, possibly 2 DerValue items
1106                 if (srItems.length == 1 || srItems.length == 2) {
1107                     // The first parsable item should be the mandatory CertId
1108                     cid = new CertId(srItems[0].data);
1109                     if (srItems.length == 2) {
1110                         if (srItems[1].isContextSpecific((byte)0)) {
1111                             DerValue[] extDerItems = srItems[1].data.getSequence(2);
1112                             extensions = parseExtensions(extDerItems);
1113                         } else {
1114                             throw new IOException(&quot;Illegal tag in Request &quot; +
1115                                     &quot;extensions: &quot; + srItems[1].tag);
1116                         }
1117                     }
1118                 } else {
1119                     throw new IOException(&quot;Invalid number of items in &quot; +
1120                             &quot;Request (&quot; + srItems.length + &quot;)&quot;);
1121                 }
1122             }
1123 
1124             /**
1125              * Get the {@code CertId} for this single request.
1126              *
1127              * @return the {@code CertId} for this single request.
1128              */
1129             private CertId getCertId() {
1130                 return cid;
1131             }
1132 
1133             /**
1134              * Return the map of single request extensions.
1135              *
1136              * @return an unmodifiable {@code Map} of zero or more
1137              * {@code Extension} objects, keyed by their object identifiers
1138              * in {@code String} form.
1139              */
1140             private Map&lt;String, Extension&gt; getExtensions() {
1141                 return Collections.unmodifiableMap(extensions);
1142             }
1143 
1144             /**
1145              * Display the {@code LocalSingleRequest} in human readable form.
1146              *
1147              * @return a {@code String} representation of the
1148              * {@code LocalSingleRequest}
1149              */
1150             @Override
1151             public String toString() {
1152                 StringBuilder sb = new StringBuilder();
1153                 sb.append(&quot;CertId, Algorithm = &quot;);
1154                 sb.append(cid.getHashAlgorithm()).append(&quot;\n&quot;);
1155                 sb.append(&quot;\tIssuer Name Hash: &quot;);
1156                 sb.append(dumpHexBytes(cid.getIssuerNameHash(), 256, &quot;&quot;, &quot;&quot;));
1157                 sb.append(&quot;\n&quot;);
1158                 sb.append(&quot;\tIssuer Key Hash: &quot;);
1159                 sb.append(dumpHexBytes(cid.getIssuerKeyHash(), 256, &quot;&quot;, &quot;&quot;));
1160                 sb.append(&quot;\n&quot;);
1161                 sb.append(&quot;\tSerial Number: &quot;).append(cid.getSerialNumber());
1162                 if (!extensions.isEmpty()) {
1163                     sb.append(&quot;Extensions (&quot;).append(extensions.size()).
1164                             append(&quot;)\n&quot;);
1165                     for (Extension ext : extensions.values()) {
1166                         sb.append(&quot;\t&quot;).append(ext).append(&quot;\n&quot;);
1167                     }
1168                 }
1169 
1170                 return sb.toString();
1171             }
1172         }
1173     }
1174 
1175     /**
1176      * Simple nested class to handle OCSP requests without making
1177      * changes to sun.security.provider.certpath.OCSPResponse
1178      */
1179     public class LocalOcspResponse {
1180         private final int version = 0;
1181         private final OCSPResponse.ResponseStatus responseStatus;
1182         private final Map&lt;CertId, CertStatusInfo&gt; respItemMap;
1183         private final Date producedAtDate;
1184         private final List&lt;LocalSingleResponse&gt; singleResponseList =
1185                 new ArrayList&lt;&gt;();
1186         private final Map&lt;String, Extension&gt; responseExtensions;
1187         private byte[] signature;
1188         private final List&lt;X509Certificate&gt; certificates;
1189         private final byte[] encodedResponse;
1190 
1191         /**
1192          * Constructor for the generation of non-successful responses
1193          *
1194          * @param respStat the OCSP response status.
1195          *
1196          * @throws IOException if an error happens during encoding
1197          * @throws NullPointerException if {@code respStat} is {@code null}
1198          * or {@code respStat} is successful.
1199          */
1200         public LocalOcspResponse(OCSPResponse.ResponseStatus respStat)
1201                 throws IOException {
1202             this(respStat, null, null);
1203         }
1204 
1205         /**
1206          * Construct a response from a list of certificate
1207          * status objects and extensions.
1208          *
1209          * @param respStat the status of the entire response
1210          * @param itemMap a {@code Map} of {@code CertId} objects and their
1211          * respective revocation statuses from the server&#39;s response DB.
1212          * @param reqExtensions a {@code Map} of request extensions
1213          *
1214          * @throws IOException if an error happens during encoding
1215          * @throws NullPointerException if {@code respStat} is {@code null}
1216          * or {@code respStat} is successful, and a {@code null} {@code itemMap}
1217          * has been provided.
1218          */
1219         public LocalOcspResponse(OCSPResponse.ResponseStatus respStat,
1220                 Map&lt;CertId, CertStatusInfo&gt; itemMap,
1221                 Map&lt;String, Extension&gt; reqExtensions) throws IOException {
1222             responseStatus = Objects.requireNonNull(respStat,
1223                     &quot;Illegal null response status&quot;);
1224             if (responseStatus == ResponseStatus.SUCCESSFUL) {
1225                 respItemMap = Objects.requireNonNull(itemMap,
1226                         &quot;SUCCESSFUL responses must have a response map&quot;);
1227                 producedAtDate = new Date();
1228 
1229                 // Turn the answerd from the response DB query into a list
1230                 // of single responses.
1231                 for (CertId id : itemMap.keySet()) {
1232                     singleResponseList.add(
1233                             new LocalSingleResponse(id, itemMap.get(id)));
1234                 }
1235 
1236                 responseExtensions = setResponseExtensions(reqExtensions);
1237                 certificates = new ArrayList&lt;&gt;();
1238                 if (signerCert != issuerCert) {
1239                     certificates.add(signerCert);
1240                 }
1241                 certificates.add(issuerCert);
1242             } else {
1243                 respItemMap = null;
1244                 producedAtDate = null;
1245                 responseExtensions = null;
1246                 certificates = null;
1247             }
1248             encodedResponse = this.getBytes();
1249         }
1250 
1251         /**
1252          * Set the response extensions based on the request extensions
1253          * that were received.  Right now, this is limited to the
1254          * OCSP nonce extension.
1255          *
1256          * @param reqExts a {@code Map} of zero or more request extensions
1257          *
1258          * @return a {@code Map} of zero or more response extensions, keyed
1259          * by the extension object identifier in {@code String} form.
1260          */
1261         private Map&lt;String, Extension&gt; setResponseExtensions(
1262                 Map&lt;String, Extension&gt; reqExts) {
1263             Map&lt;String, Extension&gt; respExts = new HashMap&lt;&gt;();
1264             String ocspNonceStr = PKIXExtensions.OCSPNonce_Id.toString();
1265 
1266             if (reqExts != null) {
1267                 for (String id : reqExts.keySet()) {
1268                     if (id.equals(ocspNonceStr)) {
1269                         // We found a nonce, add it into the response extensions
1270                         Extension ext = reqExts.get(id);
1271                         if (ext != null) {
1272                             respExts.put(id, ext);
1273                             log(&quot;Added OCSP Nonce to response&quot;);
1274                         } else {
1275                             log(&quot;Error: Found nonce entry, but found null &quot; +
1276                                     &quot;value.  Skipping&quot;);
1277                         }
1278                     }
1279                 }
1280             }
1281 
1282             return respExts;
1283         }
1284 
1285         /**
1286          * Get the DER-encoded response bytes for this response
1287          *
1288          * @return a byte array containing the DER-encoded bytes for
1289          * the response
1290          *
1291          * @throws IOException if any encoding errors occur
1292          */
1293         private byte[] getBytes() throws IOException {
1294             DerOutputStream outerSeq = new DerOutputStream();
1295             DerOutputStream responseStream = new DerOutputStream();
1296             responseStream.putEnumerated(responseStatus.ordinal());
1297             if (responseStatus == ResponseStatus.SUCCESSFUL &amp;&amp;
1298                     respItemMap != null) {
1299                 encodeResponseBytes(responseStream);
1300             }
1301 
1302             // Commit the outermost sequence bytes
1303             outerSeq.write(DerValue.tag_Sequence, responseStream);
1304             return outerSeq.toByteArray();
1305         }
1306 
1307         private void encodeResponseBytes(DerOutputStream responseStream)
1308                 throws IOException {
1309             DerOutputStream explicitZero = new DerOutputStream();
1310             DerOutputStream respItemStream = new DerOutputStream();
1311 
1312             respItemStream.putOID(OCSP_BASIC_RESPONSE_OID);
1313 
1314             byte[] basicOcspBytes = encodeBasicOcspResponse();
1315             respItemStream.putOctetString(basicOcspBytes);
1316             explicitZero.write(DerValue.tag_Sequence, respItemStream);
1317             responseStream.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1318                     true, (byte)0), explicitZero);
1319         }
1320 
1321         private byte[] encodeBasicOcspResponse() throws IOException {
1322             DerOutputStream outerSeq = new DerOutputStream();
1323             DerOutputStream basicORItemStream = new DerOutputStream();
1324 
1325             // Encode the tbsResponse
1326             byte[] tbsResponseBytes = encodeTbsResponse();
1327             basicORItemStream.write(tbsResponseBytes);
1328 
1329             try {
1330                 sigAlgId.derEncode(basicORItemStream);
1331 
1332                 // Create the signature
1333                 Signature sig = Signature.getInstance(sigAlgId.getName());
1334                 sig.initSign(signerKey);
1335                 sig.update(tbsResponseBytes);
1336                 signature = sig.sign();
1337                 basicORItemStream.putBitString(signature);
1338             } catch (GeneralSecurityException exc) {
1339                 err(exc);
1340                 throw new IOException(exc);
1341             }
1342 
1343             // Add certificates
1344             try {
1345                 DerOutputStream certStream = new DerOutputStream();
1346                 ArrayList&lt;DerValue&gt; certList = new ArrayList&lt;&gt;();
1347                 if (signerCert != issuerCert) {
1348                     certList.add(new DerValue(signerCert.getEncoded()));
1349                 }
1350                 certList.add(new DerValue(issuerCert.getEncoded()));
1351                 DerValue[] dvals = new DerValue[certList.size()];
1352                 certStream.putSequence(certList.toArray(dvals));
1353                 basicORItemStream.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1354                         true, (byte)0), certStream);
1355             } catch (CertificateEncodingException cex) {
1356                 err(cex);
1357                 throw new IOException(cex);
1358             }
1359 
1360             // Commit the outermost sequence bytes
1361             outerSeq.write(DerValue.tag_Sequence, basicORItemStream);
1362             return outerSeq.toByteArray();
1363         }
1364 
1365         private byte[] encodeTbsResponse() throws IOException {
1366             DerOutputStream outerSeq = new DerOutputStream();
1367             DerOutputStream tbsStream = new DerOutputStream();
1368 
1369             // Note: We&#39;re not going explicitly assert the version
1370             tbsStream.write(respId.getEncoded());
1371             tbsStream.putGeneralizedTime(producedAtDate);
1372 
1373             // Sequence of responses
1374             encodeSingleResponses(tbsStream);
1375 
1376             // TODO: add response extension support
1377             encodeExtensions(tbsStream);
1378 
1379             outerSeq.write(DerValue.tag_Sequence, tbsStream);
1380             return outerSeq.toByteArray();
1381         }
1382 
1383         private void encodeSingleResponses(DerOutputStream tbsStream)
1384                 throws IOException {
1385             DerValue[] srDerVals = new DerValue[singleResponseList.size()];
1386             int srDvCtr = 0;
1387 
1388             for (LocalSingleResponse lsr : singleResponseList) {
1389                 srDerVals[srDvCtr++] = new DerValue(lsr.getBytes());
1390             }
1391 
1392             tbsStream.putSequence(srDerVals);
1393         }
1394 
1395         private void encodeExtensions(DerOutputStream tbsStream)
1396                 throws IOException {
1397             DerOutputStream extSequence = new DerOutputStream();
1398             DerOutputStream extItems = new DerOutputStream();
1399 
1400             for (Extension ext : responseExtensions.values()) {
1401                 ext.encode(extItems);
1402             }
1403             extSequence.write(DerValue.tag_Sequence, extItems);
1404             tbsStream.write(DerValue.createTag(DerValue.TAG_CONTEXT, true,
1405                     (byte)1), extSequence);
1406         }
1407 
1408         @Override
1409         public String toString() {
1410             StringBuilder sb = new StringBuilder();
1411 
1412             sb.append(&quot;OCSP Response: &quot;).append(responseStatus).append(&quot;\n&quot;);
1413             if (responseStatus == ResponseStatus.SUCCESSFUL) {
1414                 sb.append(&quot;Response Type: &quot;).
1415                         append(OCSP_BASIC_RESPONSE_OID.toString()).append(&quot;\n&quot;);
1416                 sb.append(String.format(&quot;Version: %d (0x%X)&quot;, version + 1,
1417                         version)).append(&quot;\n&quot;);
1418                 sb.append(&quot;Responder Id: &quot;).append(respId.toString()).
1419                         append(&quot;\n&quot;);
1420                 sb.append(&quot;Produced At: &quot;).
1421                         append(utcDateFmt.format(producedAtDate)).append(&quot;\n&quot;);
1422 
1423                 int srCtr = 0;
1424                 for (LocalSingleResponse lsr : singleResponseList) {
1425                     sb.append(&quot;SingleResponse [&quot;).append(srCtr++).append(&quot;]\n&quot;);
1426                     sb.append(lsr);
1427                 }
1428 
1429                 if (!responseExtensions.isEmpty()) {
1430                     sb.append(&quot;Extensions (&quot;).append(responseExtensions.size()).
1431                             append(&quot;)\n&quot;);
1432                     for (Extension ext : responseExtensions.values()) {
1433                         sb.append(&quot;\t&quot;).append(ext).append(&quot;\n&quot;);
1434                     }
1435                 } else {
1436                     sb.append(&quot;\n&quot;);
1437                 }
1438 
1439                 if (signature != null) {
1440                     sb.append(&quot;Signature: &quot;).append(sigAlgId).append(&quot;\n&quot;);
1441                     sb.append(dumpHexBytes(signature)).append(&quot;\n&quot;);
1442                     int certCtr = 0;
1443                     for (X509Certificate cert : certificates) {
1444                         sb.append(&quot;Certificate [&quot;).append(certCtr++).append(&quot;]&quot;).
1445                                 append(&quot;\n&quot;);
1446                         sb.append(&quot;\tSubject: &quot;);
1447                         sb.append(cert.getSubjectX500Principal()).append(&quot;\n&quot;);
1448                         sb.append(&quot;\tIssuer: &quot;);
1449                         sb.append(cert.getIssuerX500Principal()).append(&quot;\n&quot;);
1450                         sb.append(&quot;\tSerial: &quot;).append(cert.getSerialNumber());
1451                         sb.append(&quot;\n&quot;);
1452                     }
1453                 }
1454             }
1455 
1456             return sb.toString();
1457         }
1458 
1459         private class LocalSingleResponse {
1460             private final CertId certId;
1461             private final CertStatusInfo csInfo;
1462             private final Date thisUpdate;
1463             private final Date lsrNextUpdate;
1464             private final Map&lt;String, Extension&gt; singleExtensions;
1465 
1466             public LocalSingleResponse(CertId cid, CertStatusInfo info) {
1467                 certId = Objects.requireNonNull(cid, &quot;CertId must be non-null&quot;);
1468                 csInfo = Objects.requireNonNull(info,
1469                         &quot;CertStatusInfo must be non-null&quot;);
1470 
1471                 // For now, we&#39;ll keep things simple and make the thisUpdate
1472                 // field the same as the producedAt date.
1473                 thisUpdate = producedAtDate;
1474                 lsrNextUpdate = getNextUpdate();
1475 
1476                 // TODO Add extensions support
1477                 singleExtensions = Collections.emptyMap();
1478             }
1479 
1480             @Override
1481             public String toString() {
1482                 StringBuilder sb = new StringBuilder();
1483                 sb.append(&quot;Certificate Status: &quot;).append(csInfo.getType());
1484                 sb.append(&quot;\n&quot;);
1485                 if (csInfo.getType() == CertStatus.CERT_STATUS_REVOKED) {
1486                     sb.append(&quot;Revocation Time: &quot;);
1487                     sb.append(utcDateFmt.format(csInfo.getRevocationTime()));
1488                     sb.append(&quot;\n&quot;);
1489                     if (csInfo.getRevocationReason() != null) {
1490                         sb.append(&quot;Revocation Reason: &quot;);
1491                         sb.append(csInfo.getRevocationReason()).append(&quot;\n&quot;);
1492                     }
1493                 }
1494 
1495                 sb.append(&quot;CertId, Algorithm = &quot;);
1496                 sb.append(certId.getHashAlgorithm()).append(&quot;\n&quot;);
1497                 sb.append(&quot;\tIssuer Name Hash: &quot;);
1498                 sb.append(dumpHexBytes(certId.getIssuerNameHash(), 256, &quot;&quot;, &quot;&quot;));
1499                 sb.append(&quot;\n&quot;);
1500                 sb.append(&quot;\tIssuer Key Hash: &quot;);
1501                 sb.append(dumpHexBytes(certId.getIssuerKeyHash(), 256, &quot;&quot;, &quot;&quot;));
1502                 sb.append(&quot;\n&quot;);
1503                 sb.append(&quot;\tSerial Number: &quot;).append(certId.getSerialNumber());
1504                 sb.append(&quot;\n&quot;);
1505                 sb.append(&quot;This Update: &quot;);
1506                 sb.append(utcDateFmt.format(thisUpdate)).append(&quot;\n&quot;);
1507                 if (lsrNextUpdate != null) {
1508                     sb.append(&quot;Next Update: &quot;);
1509                     sb.append(utcDateFmt.format(lsrNextUpdate)).append(&quot;\n&quot;);
1510                 }
1511 
1512                 if (!singleExtensions.isEmpty()) {
1513                     sb.append(&quot;Extensions (&quot;).append(singleExtensions.size()).
1514                             append(&quot;)\n&quot;);
1515                     for (Extension ext : singleExtensions.values()) {
1516                         sb.append(&quot;\t&quot;).append(ext).append(&quot;\n&quot;);
1517                     }
1518                 }
1519 
1520                 return sb.toString();
1521             }
1522 
1523             public byte[] getBytes() throws IOException {
1524                 byte[] nullData = { };
1525                 DerOutputStream responseSeq = new DerOutputStream();
1526                 DerOutputStream srStream = new DerOutputStream();
1527 
1528                 // Encode the CertId
1529                 certId.encode(srStream);
1530 
1531                 // Next, encode the CertStatus field
1532                 CertStatus csiType = csInfo.getType();
1533                 switch (csiType) {
1534                     case CERT_STATUS_GOOD:
1535                         srStream.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1536                                 false, (byte)0), nullData);
1537                         break;
1538                     case CERT_STATUS_REVOKED:
1539                         DerOutputStream revInfo = new DerOutputStream();
1540                         revInfo.putGeneralizedTime(csInfo.getRevocationTime());
1541                         CRLReason revReason = csInfo.getRevocationReason();
1542                         if (revReason != null) {
1543                             byte[] revDer = new byte[3];
1544                             revDer[0] = DerValue.tag_Enumerated;
1545                             revDer[1] = 1;
1546                             revDer[2] = (byte)revReason.ordinal();
1547                             revInfo.write(DerValue.createTag(
1548                                     DerValue.TAG_CONTEXT, true, (byte)0),
1549                                     revDer);
1550                         }
1551                         srStream.write(DerValue.createTag(
1552                                 DerValue.TAG_CONTEXT, true, (byte)1),
1553                                 revInfo);
1554                         break;
1555                     case CERT_STATUS_UNKNOWN:
1556                         srStream.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1557                                 false, (byte)2), nullData);
1558                         break;
1559                     default:
1560                         throw new IOException(&quot;Unknown CertStatus: &quot; + csiType);
1561                 }
1562 
1563                 // Add the necessary dates
1564                 srStream.putGeneralizedTime(thisUpdate);
1565                 if (lsrNextUpdate != null) {
1566                     DerOutputStream nuStream = new DerOutputStream();
1567                     nuStream.putGeneralizedTime(lsrNextUpdate);
1568                     srStream.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1569                             true, (byte)0), nuStream);
1570                 }
1571 
1572                 // TODO add singleResponse Extension support
1573 
1574                 // Add the single response to the response output stream
1575                 responseSeq.write(DerValue.tag_Sequence, srStream);
1576                 return responseSeq.toByteArray();
1577             }
1578         }
1579     }
1580 }
    </pre>
  </body>
</html>
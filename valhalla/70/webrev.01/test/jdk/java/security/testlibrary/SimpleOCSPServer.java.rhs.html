<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/security/testlibrary/SimpleOCSPServer.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.testlibrary;
  27 
  28 import java.io.*;
  29 import java.net.*;
  30 import java.security.*;
  31 import java.security.cert.CRLReason;
  32 import java.security.cert.X509Certificate;
  33 import java.security.cert.Extension;
  34 import java.security.cert.CertificateException;
  35 import java.security.cert.CertificateEncodingException;
  36 import java.security.Signature;
  37 import java.util.*;
  38 import java.util.concurrent.*;
  39 import java.text.SimpleDateFormat;
  40 import java.math.BigInteger;
  41 
  42 import sun.security.x509.*;
  43 import sun.security.x509.PKIXExtensions;
  44 import sun.security.provider.certpath.ResponderId;
  45 import sun.security.provider.certpath.CertId;
  46 import sun.security.provider.certpath.OCSPResponse;
  47 import sun.security.provider.certpath.OCSPResponse.ResponseStatus;
<a name="1" id="anc1"></a><span class="line-modified">  48 import sun.security.util.*;</span>




  49 
  50 
  51 /**
  52  * This is a simple OCSP server designed to listen and respond to incoming
  53  * requests.
  54  */
  55 public class SimpleOCSPServer {
  56     private final Debug debug = Debug.getInstance(&quot;oserv&quot;);
  57     private static final ObjectIdentifier OCSP_BASIC_RESPONSE_OID =
<a name="2" id="anc2"></a><span class="line-modified">  58             ObjectIdentifier.of(KnownOIDs.OCSPBasicResponse);</span>
<span class="line-added">  59 </span>
  60     private static final SimpleDateFormat utcDateFmt =
  61             new SimpleDateFormat(&quot;MMM dd yyyy, HH:mm:ss z&quot;);
  62 
  63     static final int FREE_PORT = 0;
  64 
  65     // CertStatus values
  66     public static enum CertStatus {
  67         CERT_STATUS_GOOD,
  68         CERT_STATUS_REVOKED,
  69         CERT_STATUS_UNKNOWN,
  70     }
  71 
  72     // Fields used for the networking portion of the responder
  73     private ServerSocket servSocket;
  74     private InetAddress listenAddress;
  75     private int listenPort;
  76 
  77     // Keystore information (certs, keys, etc.)
  78     private KeyStore keystore;
  79     private X509Certificate issuerCert;
  80     private X509Certificate signerCert;
  81     private PrivateKey signerKey;
  82 
  83     // Fields used for the operational portions of the server
  84     private boolean logEnabled = false;
  85     private ExecutorService threadPool;
  86     private volatile boolean started = false;
  87     private volatile boolean serverReady = false;
  88     private volatile boolean receivedShutdown = false;
  89     private volatile boolean acceptConnections = true;
  90     private volatile long delayMsec = 0;
  91 
  92     // Fields used in the generation of responses
  93     private long nextUpdateInterval = -1;
  94     private Date nextUpdate = null;
  95     private ResponderId respId;
  96     private AlgorithmId sigAlgId;
  97     private Map&lt;CertId, CertStatusInfo&gt; statusDb =
  98             Collections.synchronizedMap(new HashMap&lt;&gt;());
  99 
 100     /**
 101      * Construct a SimpleOCSPServer using keystore, password, and alias
 102      * parameters.
 103      *
 104      * @param ks the keystore to be used
 105      * @param password the password to access key material in the keystore
 106      * @param issuerAlias the alias of the issuer certificate
 107      * @param signerAlias the alias of the signer certificate and key.  A
 108      * value of {@code null} means that the {@code issuerAlias} will be used
 109      * to look up the signer key.
 110      *
 111      * @throws GeneralSecurityException if there are problems accessing the
 112      * keystore or finding objects within the keystore.
 113      * @throws IOException if a {@code ResponderId} cannot be generated from
 114      * the signer certificate.
 115      */
 116     public SimpleOCSPServer(KeyStore ks, String password, String issuerAlias,
 117             String signerAlias) throws GeneralSecurityException, IOException {
 118         this(null, FREE_PORT, ks, password, issuerAlias, signerAlias);
 119     }
 120 
 121     /**
 122      * Construct a SimpleOCSPServer using specific network parameters,
 123      * keystore, password, and alias.
 124      *
 125      * @param addr the address to bind the server to.  A value of {@code null}
 126      * means the server will bind to all interfaces.
 127      * @param port the port to listen on.  A value of {@code 0} will mean that
 128      * the server will randomly pick an open ephemeral port to bind to.
 129      * @param ks the keystore to be used
 130      * @param password the password to access key material in the keystore
 131      * @param issuerAlias the alias of the issuer certificate
 132      * @param signerAlias the alias of the signer certificate and key.  A
 133      * value of {@code null} means that the {@code issuerAlias} will be used
 134      * to look up the signer key.
 135      *
 136      * @throws GeneralSecurityException if there are problems accessing the
 137      * keystore or finding objects within the keystore.
 138      * @throws IOException if a {@code ResponderId} cannot be generated from
 139      * the signer certificate.
 140      */
 141     public SimpleOCSPServer(InetAddress addr, int port, KeyStore ks,
 142             String password, String issuerAlias, String signerAlias)
 143             throws GeneralSecurityException, IOException {
 144         Objects.requireNonNull(ks, &quot;Null keystore provided&quot;);
 145         Objects.requireNonNull(issuerAlias, &quot;Null issuerName provided&quot;);
 146 
 147         utcDateFmt.setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;));
 148 
 149         keystore = ks;
 150         issuerCert = (X509Certificate)ks.getCertificate(issuerAlias);
 151         if (issuerCert == null) {
 152             throw new IllegalArgumentException(&quot;Certificate for alias &quot; +
 153                     issuerAlias + &quot; not found&quot;);
 154         }
 155 
 156         if (signerAlias != null) {
 157             signerCert = (X509Certificate)ks.getCertificate(signerAlias);
 158             if (signerCert == null) {
 159                 throw new IllegalArgumentException(&quot;Certificate for alias &quot; +
 160                     signerAlias + &quot; not found&quot;);
 161             }
 162             signerKey = (PrivateKey)ks.getKey(signerAlias,
 163                     password.toCharArray());
 164             if (signerKey == null) {
 165                 throw new IllegalArgumentException(&quot;PrivateKey for alias &quot; +
 166                     signerAlias + &quot; not found&quot;);
 167             }
 168         } else {
 169             signerCert = issuerCert;
 170             signerKey = (PrivateKey)ks.getKey(issuerAlias,
 171                     password.toCharArray());
 172             if (signerKey == null) {
 173                 throw new IllegalArgumentException(&quot;PrivateKey for alias &quot; +
 174                     issuerAlias + &quot; not found&quot;);
 175             }
 176         }
 177 
 178         sigAlgId = AlgorithmId.get(&quot;Sha256withRSA&quot;);
 179         respId = new ResponderId(signerCert.getSubjectX500Principal());
 180         listenAddress = addr;
 181         listenPort = port;
 182     }
 183 
 184     /**
 185      * Start the server.  The server will bind to the specified network
 186      * address and begin listening for incoming connections.
 187      *
 188      * @throws IOException if any number of things go wonky.
 189      */
 190     public synchronized void start() throws IOException {
 191         // You cannot start the server twice.
 192         if (started) {
 193             log(&quot;Server has already been started&quot;);
 194             return;
 195         } else {
 196             started = true;
 197         }
 198 
 199         // Create and start the thread pool
 200         threadPool = Executors.newFixedThreadPool(32, new ThreadFactory() {
 201             @Override
 202             public Thread newThread(Runnable r) {
 203                 Thread t = Executors.defaultThreadFactory().newThread(r);
 204                 t.setDaemon(true);
 205                 return t;
 206             }
 207         });
 208 
 209         threadPool.submit(new Runnable() {
 210             @Override
 211             public void run() {
 212                 try (ServerSocket sSock = new ServerSocket()) {
 213                     servSocket = sSock;
 214                     servSocket.setReuseAddress(true);
 215                     servSocket.setSoTimeout(500);
 216                     servSocket.bind(new InetSocketAddress(listenAddress,
 217                             listenPort), 128);
 218                     log(&quot;Listening on &quot; + servSocket.getLocalSocketAddress());
 219 
 220                     // Singal ready
 221                     serverReady = true;
 222 
 223                     // Update the listenPort with the new port number.  If
 224                     // the server is restarted, it will bind to the same
 225                     // port rather than picking a new one.
 226                     listenPort = servSocket.getLocalPort();
 227 
 228                     // Main dispatch loop
 229                     while (!receivedShutdown) {
 230                         try {
 231                             Socket newConnection = servSocket.accept();
 232                             if (!acceptConnections) {
 233                                 try {
 234                                     log(&quot;Reject connection&quot;);
 235                                     newConnection.close();
 236                                 } catch (IOException e) {
 237                                     // ignore
 238                                 }
 239                                 continue;
 240                             }
 241                             threadPool.submit(new OcspHandler(newConnection));
 242                         } catch (SocketTimeoutException timeout) {
 243                             // Nothing to do here.  If receivedShutdown
 244                             // has changed to true then the loop will
 245                             // exit on its own.
 246                         } catch (IOException ioe) {
 247                             // Something bad happened, log and force a shutdown
 248                             log(&quot;Unexpected Exception: &quot; + ioe);
 249                             stop();
 250                         }
 251                     }
 252 
 253                     log(&quot;Shutting down...&quot;);
 254                     threadPool.shutdown();
 255                 } catch (IOException ioe) {
 256                     err(ioe);
 257                 } finally {
 258                     // Reset state variables so the server can be restarted
 259                     receivedShutdown = false;
 260                     started = false;
 261                     serverReady = false;
 262                 }
 263             }
 264         });
 265     }
 266 
 267     /**
 268      * Make the OCSP server reject incoming connections.
 269      */
 270     public synchronized void rejectConnections() {
 271         log(&quot;Reject OCSP connections&quot;);
 272         acceptConnections = false;
 273     }
 274 
 275     /**
 276      * Make the OCSP server accept incoming connections.
 277      */
 278     public synchronized void acceptConnections() {
 279         log(&quot;Accept OCSP connections&quot;);
 280         acceptConnections = true;
 281     }
 282 
 283 
 284     /**
 285      * Stop the OCSP server.
 286      */
 287     public synchronized void stop() {
 288         if (started) {
 289             receivedShutdown = true;
 290             log(&quot;Received shutdown notification&quot;);
 291         }
 292     }
 293 
 294     /**
 295      * Print {@code SimpleOCSPServer} operating parameters.
 296      *
 297      * @return the {@code SimpleOCSPServer} operating parameters in
 298      * {@code String} form.
 299      */
 300     @Override
 301     public String toString() {
 302         StringBuilder sb = new StringBuilder();
 303         sb.append(&quot;OCSP Server:\n&quot;);
 304         sb.append(&quot;----------------------------------------------\n&quot;);
 305         sb.append(&quot;issuer: &quot;).append(issuerCert.getSubjectX500Principal()).
 306                 append(&quot;\n&quot;);
 307         sb.append(&quot;signer: &quot;).append(signerCert.getSubjectX500Principal()).
 308                 append(&quot;\n&quot;);
 309         sb.append(&quot;ResponderId: &quot;).append(respId).append(&quot;\n&quot;);
 310         sb.append(&quot;----------------------------------------------&quot;);
 311 
 312         return sb.toString();
 313     }
 314 
 315     /**
 316      * Helpful debug routine to hex dump byte arrays.
 317      *
 318      * @param data the array of bytes to dump to stdout.
 319      *
 320      * @return the hexdump of the byte array
 321      */
 322     private static String dumpHexBytes(byte[] data) {
 323         return dumpHexBytes(data, 16, &quot;\n&quot;, &quot; &quot;);
 324     }
 325 
 326     /**
 327      *
 328      * @param data the array of bytes to dump to stdout.
 329      * @param itemsPerLine the number of bytes to display per line
 330      * if the {@code lineDelim} character is blank then all bytes will be
 331      * printed on a single line.
 332      * @param lineDelim the delimiter between lines
 333      * @param itemDelim the delimiter between bytes
 334      *
 335      * @return The hexdump of the byte array
 336      */
 337     private static String dumpHexBytes(byte[] data, int itemsPerLine,
 338             String lineDelim, String itemDelim) {
 339         StringBuilder sb = new StringBuilder();
 340         if (data != null) {
 341             for (int i = 0; i &lt; data.length; i++) {
 342                 if (i % itemsPerLine == 0 &amp;&amp; i != 0) {
 343                     sb.append(lineDelim);
 344                 }
 345                 sb.append(String.format(&quot;%02X&quot;, data[i])).append(itemDelim);
 346             }
 347         }
 348 
 349         return sb.toString();
 350     }
 351 
 352     /**
 353      * Enable or disable the logging feature.
 354      *
 355      * @param enable {@code true} to enable logging, {@code false} to
 356      * disable it.  The setting must be activated before the server calls
 357      * its start method.  Any calls after that have no effect.
 358      */
 359     public void enableLog(boolean enable) {
 360         if (!started) {
 361             logEnabled = enable;
 362         }
 363     }
 364 
 365     /**
 366      * Sets the nextUpdate interval.  Intervals will be calculated relative
 367      * to the server startup time.  When first set, the nextUpdate date is
 368      * calculated based on the current time plus the interval.  After that,
 369      * calls to getNextUpdate() will return this date if it is still
 370      * later than current time.  If not, the Date will be updated to the
 371      * next interval that is later than current time.  This value must be set
 372      * before the server has had its start method called.  Calls made after
 373      * the server has been started have no effect.
 374      *
 375      * @param interval the recurring time interval in seconds used to
 376      * calculate nextUpdate times.   A value less than or equal to 0 will
 377      * disable the nextUpdate feature.
 378      */
 379     public synchronized void setNextUpdateInterval(long interval) {
 380         if (!started) {
 381             if (interval &lt;= 0) {
 382                 nextUpdateInterval = -1;
 383                 nextUpdate = null;
 384                 log(&quot;nexUpdate support has been disabled&quot;);
 385             } else {
 386                 nextUpdateInterval = interval * 1000;
 387                 nextUpdate = new Date(System.currentTimeMillis() +
 388                         nextUpdateInterval);
 389                 log(&quot;nextUpdate set to &quot; + nextUpdate);
 390             }
 391         }
 392     }
 393 
 394     /**
 395      * Return the nextUpdate {@code Date} object for this server.  If the
 396      * nextUpdate date has already passed, set a new nextUpdate based on
 397      * the nextUpdate interval and return that date.
 398      *
 399      * @return a {@code Date} object set to the nextUpdate field for OCSP
 400      * responses.
 401      */
 402     private synchronized Date getNextUpdate() {
 403         if (nextUpdate != null &amp;&amp; nextUpdate.before(new Date())) {
 404             long nuEpochTime = nextUpdate.getTime();
 405             long currentTime = System.currentTimeMillis();
 406 
 407             // Keep adding nextUpdate intervals until you reach a date
 408             // that is later than current time.
 409             while (currentTime &gt;= nuEpochTime) {
 410                 nuEpochTime += nextUpdateInterval;
 411             }
 412 
 413             // Set the nextUpdate for future threads
 414             nextUpdate = new Date(nuEpochTime);
 415             log(&quot;nextUpdate updated to new value: &quot; + nextUpdate);
 416         }
 417         return nextUpdate;
 418     }
 419 
 420     /**
 421      * Add entries into the responder&#39;s status database.
 422      *
 423      * @param newEntries a map of {@code CertStatusInfo} objects, keyed on
 424      * their serial number (as a {@code BigInteger}).  All serial numbers
 425      * are assumed to have come from this responder&#39;s issuer certificate.
 426      *
 427      * @throws IOException if a CertId cannot be generated.
 428      */
 429     public void updateStatusDb(Map&lt;BigInteger, CertStatusInfo&gt; newEntries)
 430             throws IOException {
 431          if (newEntries != null) {
 432             for (BigInteger serial : newEntries.keySet()) {
 433                 CertStatusInfo info = newEntries.get(serial);
 434                 if (info != null) {
 435                     CertId cid = new CertId(issuerCert,
 436                             new SerialNumber(serial));
 437                     statusDb.put(cid, info);
 438                     log(&quot;Added entry for serial &quot; + serial + &quot;(&quot; +
 439                             info.getType() + &quot;)&quot;);
 440                 }
 441             }
 442         }
 443     }
 444 
 445     /**
 446      * Check the status database for revocation information one one or more
 447      * certificates.
 448      *
 449      * @param reqList the list of {@code LocalSingleRequest} objects taken
 450      * from the incoming OCSP request.
 451      *
 452      * @return a {@code Map} of {@code CertStatusInfo} objects keyed by their
 453      * {@code CertId} values, for each single request passed in.  Those
 454      * CertIds not found in the statusDb will have returned List members with
 455      * a status of UNKNOWN.
 456      */
 457     private Map&lt;CertId, CertStatusInfo&gt; checkStatusDb(
 458             List&lt;LocalOcspRequest.LocalSingleRequest&gt; reqList) {
 459         // TODO figure out what, if anything to do with request extensions
 460         Map&lt;CertId, CertStatusInfo&gt; returnMap = new HashMap&lt;&gt;();
 461 
 462         for (LocalOcspRequest.LocalSingleRequest req : reqList) {
 463             CertId cid = req.getCertId();
 464             CertStatusInfo info = statusDb.get(cid);
 465             if (info != null) {
 466                 log(&quot;Status for SN &quot; + cid.getSerialNumber() + &quot;: &quot; +
 467                         info.getType());
 468                 returnMap.put(cid, info);
 469             } else {
 470                 log(&quot;Status for SN &quot; + cid.getSerialNumber() +
 471                         &quot; not found, using CERT_STATUS_UNKNOWN&quot;);
 472                 returnMap.put(cid,
 473                         new CertStatusInfo(CertStatus.CERT_STATUS_UNKNOWN));
 474             }
 475         }
 476 
 477         return Collections.unmodifiableMap(returnMap);
 478     }
 479 
 480     /**
 481      * Set the digital signature algorithm used to sign OCSP responses.
 482      *
 483      * @param algName The algorithm name
 484      *
 485      * @throws NoSuchAlgorithmException if the algorithm name is invalid.
 486      */
 487     public void setSignatureAlgorithm(String algName)
 488             throws NoSuchAlgorithmException {
 489         if (!started) {
 490             sigAlgId = AlgorithmId.get(algName);
 491         }
 492     }
 493 
 494     /**
 495      * Get the port the OCSP server is running on.
 496      *
 497      * @return the port that the OCSP server is running on, or -1 if the
 498      * server has not yet been bound to a port.
 499      */
 500     public int getPort() {
 501         if (serverReady) {
 502             InetSocketAddress inetSock =
 503                     (InetSocketAddress)servSocket.getLocalSocketAddress();
 504             return inetSock.getPort();
 505         } else {
 506             return -1;
 507         }
 508     }
 509 
 510     /**
 511      * Use to check if OCSP server is ready to accept connection.
 512      *
 513      * @return true if server ready, false otherwise
 514      */
 515     public boolean isServerReady() {
 516         return serverReady;
 517     }
 518 
 519     /**
 520      * Set a delay between the reception of the request and production of
 521      * the response.
 522      *
 523      * @param delayMillis the number of milliseconds to wait before acting
 524      * on the incoming request.
 525      */
 526     public void setDelay(long delayMillis) {
 527         delayMsec = delayMillis &gt; 0 ? delayMillis : 0;
 528         if (delayMsec &gt; 0) {
 529             log(&quot;OCSP latency set to &quot; + delayMsec + &quot; milliseconds.&quot;);
 530         } else {
 531             log(&quot;OCSP latency disabled&quot;);
 532         }
 533     }
 534 
 535     /**
 536      * Log a message to stdout.
 537      *
 538      * @param message the message to log
 539      */
 540     private synchronized void log(String message) {
 541         if (logEnabled || debug != null) {
 542             System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;]: &quot; +
 543                     message);
 544         }
 545     }
 546 
 547     /**
 548      * Log an error message on the stderr stream.
 549      *
 550      * @param message the message to log
 551      */
 552     private static synchronized void err(String message) {
 553         System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;]: &quot; +
 554                 message);
 555     }
 556 
 557     /**
 558      * Log exception information on the stderr stream.
 559      *
 560      * @param exc the exception to dump information about
 561      */
 562     private static synchronized void err(Throwable exc) {
 563         System.out.print(&quot;[&quot; + Thread.currentThread().getName() +
 564                 &quot;]: Exception: &quot;);
 565         exc.printStackTrace(System.out);
 566     }
 567 
 568     /**
 569      * The {@code CertStatusInfo} class defines an object used to return
 570      * information from the internal status database.  The data in this
 571      * object may be used to construct OCSP responses.
 572      */
 573     public static class CertStatusInfo {
 574         private CertStatus certStatusType;
 575         private CRLReason reason;
 576         private Date revocationTime;
 577 
 578         /**
 579          * Create a Certificate status object by providing the status only.
 580          * If the status is {@code REVOKED} then current time is assumed
 581          * for the revocation time.
 582          *
 583          * @param statType the status for this entry.
 584          */
 585         public CertStatusInfo(CertStatus statType) {
 586             this(statType, null, null);
 587         }
 588 
 589         /**
 590          * Create a CertStatusInfo providing both type and revocation date
 591          * (if applicable).
 592          *
 593          * @param statType the status for this entry.
 594          * @param revDate if applicable, the date that revocation took place.
 595          * A value of {@code null} indicates that current time should be used.
 596          * If the value of {@code statType} is not {@code CERT_STATUS_REVOKED},
 597          * then the {@code revDate} parameter is ignored.
 598          */
 599         public CertStatusInfo(CertStatus statType, Date revDate) {
 600             this(statType, revDate, null);
 601         }
 602 
 603         /**
 604          * Create a CertStatusInfo providing type, revocation date
 605          * (if applicable) and revocation reason.
 606          *
 607          * @param statType the status for this entry.
 608          * @param revDate if applicable, the date that revocation took place.
 609          * A value of {@code null} indicates that current time should be used.
 610          * If the value of {@code statType} is not {@code CERT_STATUS_REVOKED},
 611          * then the {@code revDate} parameter is ignored.
 612          * @param revReason the reason the certificate was revoked.  A value of
 613          * {@code null} means that no reason was provided.
 614          */
 615         public CertStatusInfo(CertStatus statType, Date revDate,
 616                 CRLReason revReason) {
 617             Objects.requireNonNull(statType, &quot;Cert Status must be non-null&quot;);
 618             certStatusType = statType;
 619             switch (statType) {
 620                 case CERT_STATUS_GOOD:
 621                 case CERT_STATUS_UNKNOWN:
 622                     revocationTime = null;
 623                     break;
 624                 case CERT_STATUS_REVOKED:
 625                     revocationTime = revDate != null ? (Date)revDate.clone() :
 626                             new Date();
 627                     break;
 628                 default:
 629                     throw new IllegalArgumentException(&quot;Unknown status type: &quot; +
 630                             statType);
 631             }
 632         }
 633 
 634         /**
 635          * Get the cert status type
 636          *
 637          * @return the status applied to this object (e.g.
 638          * {@code CERT_STATUS_GOOD}, {@code CERT_STATUS_UNKNOWN}, etc.)
 639          */
 640         public CertStatus getType() {
 641             return certStatusType;
 642         }
 643 
 644         /**
 645          * Get the revocation time (if applicable).
 646          *
 647          * @return the revocation time as a {@code Date} object, or
 648          * {@code null} if not applicable (i.e. if the certificate hasn&#39;t been
 649          * revoked).
 650          */
 651         public Date getRevocationTime() {
 652             return (revocationTime != null ? (Date)revocationTime.clone() :
 653                     null);
 654         }
 655 
 656         /**
 657          * Get the revocation reason.
 658          *
 659          * @return the revocation reason, or {@code null} if one was not
 660          * provided.
 661          */
 662         public CRLReason getRevocationReason() {
 663             return reason;
 664         }
 665     }
 666 
 667     /**
 668      * Runnable task that handles incoming OCSP Requests and returns
 669      * responses.
 670      */
 671     private class OcspHandler implements Runnable {
 672         private final Socket sock;
 673         InetSocketAddress peerSockAddr;
 674 
 675         /**
 676          * Construct an {@code OcspHandler}.
 677          *
 678          * @param incomingSocket the socket the server created on accept()
 679          */
 680         private OcspHandler(Socket incomingSocket) {
 681             sock = incomingSocket;
 682         }
 683 
 684         /**
 685          * Run the OCSP Request parser and construct a response to be sent
 686          * back to the client.
 687          */
 688         @Override
 689         public void run() {
 690             // If we have implemented a delay to simulate network latency
 691             // wait out the delay here before any other processing.
 692             try {
 693                 if (delayMsec &gt; 0) {
 694                     Thread.sleep(delayMsec);
 695                 }
 696             } catch (InterruptedException ie) {
 697                 // Just log the interrupted sleep
 698                 log(&quot;Delay of &quot; + delayMsec + &quot; milliseconds was interrupted&quot;);
 699             }
 700 
 701             try (Socket ocspSocket = sock;
 702                     InputStream in = ocspSocket.getInputStream();
 703                     OutputStream out = ocspSocket.getOutputStream()) {
 704                 peerSockAddr =
 705                         (InetSocketAddress)ocspSocket.getRemoteSocketAddress();
 706                 log(&quot;Received incoming connection from &quot; + peerSockAddr);
 707                 String[] headerTokens = readLine(in).split(&quot; &quot;);
 708                 LocalOcspRequest ocspReq = null;
 709                 LocalOcspResponse ocspResp = null;
 710                 ResponseStatus respStat = ResponseStatus.INTERNAL_ERROR;
 711                 try {
 712                     if (headerTokens[0] != null) {
 713                         switch (headerTokens[0]) {
 714                             case &quot;POST&quot;:
 715                                     ocspReq = parseHttpOcspPost(in);
 716                                 break;
 717                             case &quot;GET&quot;:
 718                                 // req = parseHttpOcspGet(in);
 719                                 // TODO implement the GET parsing
 720                                 throw new IOException(&quot;GET method unsupported&quot;);
 721                             default:
 722                                 respStat = ResponseStatus.MALFORMED_REQUEST;
 723                                 throw new IOException(&quot;Not a GET or POST&quot;);
 724                         }
 725                     } else {
 726                         respStat = ResponseStatus.MALFORMED_REQUEST;
 727                         throw new IOException(&quot;Unable to get HTTP method&quot;);
 728                     }
 729 
 730                     if (ocspReq != null) {
 731                         log(ocspReq.toString());
 732                         // Get responses for all CertIds in the request
 733                         Map&lt;CertId, CertStatusInfo&gt; statusMap =
 734                                 checkStatusDb(ocspReq.getRequests());
 735                         if (statusMap.isEmpty()) {
 736                             respStat = ResponseStatus.UNAUTHORIZED;
 737                         } else {
 738                             ocspResp = new LocalOcspResponse(
 739                                     ResponseStatus.SUCCESSFUL, statusMap,
 740                                     ocspReq.getExtensions());
 741                         }
 742                     } else {
 743                         respStat = ResponseStatus.MALFORMED_REQUEST;
 744                         throw new IOException(&quot;Found null request&quot;);
 745                     }
 746                 } catch (IOException | RuntimeException exc) {
 747                     err(exc);
 748                 }
 749                 if (ocspResp == null) {
 750                     ocspResp = new LocalOcspResponse(respStat);
 751                 }
 752                 sendResponse(out, ocspResp);
 753             } catch (IOException | CertificateException exc) {
 754                 err(exc);
 755             }
 756         }
 757 
 758         /**
 759          * Send an OCSP response on an {@code OutputStream}.
 760          *
 761          * @param out the {@code OutputStream} on which to send the response.
 762          * @param resp the OCSP response to send.
 763          *
 764          * @throws IOException if an encoding error occurs.
 765          */
 766         public void sendResponse(OutputStream out, LocalOcspResponse resp)
 767                 throws IOException {
 768             StringBuilder sb = new StringBuilder();
 769 
 770             byte[] respBytes;
 771             try {
 772                 respBytes = resp.getBytes();
 773             } catch (RuntimeException re) {
 774                 err(re);
 775                 return;
 776             }
 777 
 778             sb.append(&quot;HTTP/1.0 200 OK\r\n&quot;);
 779             sb.append(&quot;Content-Type: application/ocsp-response\r\n&quot;);
 780             sb.append(&quot;Content-Length: &quot;).append(respBytes.length);
 781             sb.append(&quot;\r\n\r\n&quot;);
 782 
 783             out.write(sb.toString().getBytes(&quot;UTF-8&quot;));
 784             out.write(respBytes);
 785             log(resp.toString());
 786         }
 787 
 788         /**
 789          * Parse the incoming HTTP POST of an OCSP Request.
 790          *
 791          * @param inStream the input stream from the socket bound to this
 792          * {@code OcspHandler}.
 793          *
 794          * @return the OCSP Request as a {@code LocalOcspRequest}
 795          *
 796          * @throws IOException if there are network related issues or problems
 797          * occur during parsing of the OCSP request.
 798          * @throws CertificateException if one or more of the certificates in
 799          * the OCSP request cannot be read/parsed.
 800          */
 801         private LocalOcspRequest parseHttpOcspPost(InputStream inStream)
 802                 throws IOException, CertificateException {
 803             boolean endOfHeader = false;
 804             boolean properContentType = false;
 805             int length = -1;
 806 
 807             while (!endOfHeader) {
 808                 String[] lineTokens = readLine(inStream).split(&quot; &quot;);
 809                 if (lineTokens[0].isEmpty()) {
 810                     endOfHeader = true;
 811                 } else if (lineTokens[0].equalsIgnoreCase(&quot;Content-Type:&quot;)) {
 812                     if (lineTokens[1] == null ||
 813                             !lineTokens[1].equals(
 814                                     &quot;application/ocsp-request&quot;)) {
 815                         log(&quot;Unknown Content-Type: &quot; +
 816                                 (lineTokens[1] != null ?
 817                                         lineTokens[1] : &quot;&lt;NULL&gt;&quot;));
 818                         return null;
 819                     } else {
 820                         properContentType = true;
 821                         log(&quot;Content-Type = &quot; + lineTokens[1]);
 822                     }
 823                 } else if (lineTokens[0].equalsIgnoreCase(&quot;Content-Length:&quot;)) {
 824                     if (lineTokens[1] != null) {
 825                         length = Integer.parseInt(lineTokens[1]);
 826                         log(&quot;Content-Length = &quot; + length);
 827                     }
 828                 }
 829             }
 830 
 831             // Okay, make sure we got what we needed from the header, then
 832             // read the remaining OCSP Request bytes
 833             if (properContentType &amp;&amp; length &gt;= 0) {
 834                 byte[] ocspBytes = new byte[length];
 835                 inStream.read(ocspBytes);
 836                 return new LocalOcspRequest(ocspBytes);
 837             } else {
 838                 return null;
 839             }
 840         }
 841 
 842         /**
 843          * Read a line of text that is CRLF-delimited.
 844          *
 845          * @param is the {@code InputStream} tied to the socket
 846          * for this {@code OcspHandler}
 847          *
 848          * @return a {@code String} consisting of the line of text
 849          * read from the stream with the CRLF stripped.
 850          *
 851          * @throws IOException if any I/O error occurs.
 852          */
 853         private String readLine(InputStream is) throws IOException {
 854             PushbackInputStream pbis = new PushbackInputStream(is);
 855             ByteArrayOutputStream bos = new ByteArrayOutputStream();
 856             boolean done = false;
 857             while (!done) {
 858                 byte b = (byte)pbis.read();
 859                 if (b == &#39;\r&#39;) {
 860                     byte bNext = (byte)pbis.read();
 861                     if (bNext == &#39;\n&#39; || bNext == -1) {
 862                         done = true;
 863                     } else {
 864                         pbis.unread(bNext);
 865                         bos.write(b);
 866                     }
 867                 } else if (b == -1) {
 868                     done = true;
 869                 } else {
 870                     bos.write(b);
 871                 }
 872             }
 873 
 874             return new String(bos.toByteArray(), &quot;UTF-8&quot;);
 875         }
 876     }
 877 
 878 
 879     /**
 880      * Simple nested class to handle OCSP requests without making
 881      * changes to sun.security.provider.certpath.OCSPRequest
 882      */
 883     public class LocalOcspRequest {
 884 
 885         private byte[] nonce;
 886         private byte[] signature = null;
 887         private AlgorithmId algId = null;
 888         private int version = 0;
 889         private GeneralName requestorName = null;
 890         private Map&lt;String, Extension&gt; extensions = Collections.emptyMap();
 891         private final List&lt;LocalSingleRequest&gt; requestList = new ArrayList&lt;&gt;();
 892         private final List&lt;X509Certificate&gt; certificates = new ArrayList&lt;&gt;();
 893 
 894         /**
 895          * Construct a {@code LocalOcspRequest} from its DER encoding.
 896          *
 897          * @param requestBytes the DER-encoded bytes
 898          *
 899          * @throws IOException if decoding errors occur
 900          * @throws CertificateException if certificates are found in the
 901          * OCSP request and they do not parse correctly.
 902          */
 903         private LocalOcspRequest(byte[] requestBytes) throws IOException,
 904                 CertificateException {
 905             Objects.requireNonNull(requestBytes, &quot;Received null input&quot;);
 906 
 907             DerInputStream dis = new DerInputStream(requestBytes);
 908 
 909             // Parse the top-level structure, it should have no more than
 910             // two elements.
 911             DerValue[] topStructs = dis.getSequence(2);
 912             for (DerValue dv : topStructs) {
 913                 if (dv.tag == DerValue.tag_Sequence) {
 914                     parseTbsRequest(dv);
 915                 } else if (dv.isContextSpecific((byte)0)) {
 916                     parseSignature(dv);
 917                 } else {
 918                     throw new IOException(&quot;Unknown tag at top level: &quot; +
 919                             dv.tag);
 920                 }
 921             }
 922         }
 923 
 924         /**
 925          * Parse the signature block from an OCSP request
 926          *
 927          * @param sigSequence a {@code DerValue} containing the signature
 928          * block at the outer sequence datum.
 929          *
 930          * @throws IOException if any non-certificate-based parsing errors occur
 931          * @throws CertificateException if certificates are found in the
 932          * OCSP request and they do not parse correctly.
 933          */
 934         private void parseSignature(DerValue sigSequence)
 935                 throws IOException, CertificateException {
 936             DerValue[] sigItems = sigSequence.data.getSequence(3);
 937             if (sigItems.length != 3) {
 938                 throw new IOException(&quot;Invalid number of signature items: &quot; +
 939                         &quot;expected 3, got &quot; + sigItems.length);
 940             }
 941 
 942             algId = AlgorithmId.parse(sigItems[0]);
 943             signature = sigItems[1].getBitString();
 944 
 945             if (sigItems[2].isContextSpecific((byte)0)) {
 946                 DerValue[] certDerItems = sigItems[2].data.getSequence(4);
 947                 int i = 0;
 948                 for (DerValue dv : certDerItems) {
 949                     X509Certificate xc = new X509CertImpl(dv);
 950                     certificates.add(xc);
 951                 }
 952             } else {
 953                 throw new IOException(&quot;Invalid tag in signature block: &quot; +
 954                     sigItems[2].tag);
 955             }
 956         }
 957 
 958         /**
 959          * Parse the to-be-signed request data
 960          *
 961          * @param tbsReqSeq a {@code DerValue} object containing the to-be-
 962          * signed OCSP request at the outermost SEQUENCE tag.
 963          * @throws IOException if any parsing errors occur
 964          */
 965         private void parseTbsRequest(DerValue tbsReqSeq) throws IOException {
 966             while (tbsReqSeq.data.available() &gt; 0) {
 967                 DerValue dv = tbsReqSeq.data.getDerValue();
 968                 if (dv.isContextSpecific((byte)0)) {
 969                     // The version was explicitly called out
 970                     version = dv.data.getInteger();
 971                 } else if (dv.isContextSpecific((byte)1)) {
 972                     // A GeneralName was provided
 973                     requestorName = new GeneralName(dv.data.getDerValue());
 974                 } else if (dv.isContextSpecific((byte)2)) {
 975                     // Parse the extensions
 976                     DerValue[] extItems = dv.data.getSequence(2);
 977                     extensions = parseExtensions(extItems);
 978                 } else if (dv.tag == DerValue.tag_Sequence) {
 979                     while (dv.data.available() &gt; 0) {
 980                         requestList.add(new LocalSingleRequest(dv.data));
 981                     }
 982                 }
 983             }
 984         }
 985 
 986         /**
 987          * Parse a SEQUENCE of extensions.  This routine is used both
 988          * at the overall request level and down at the singleRequest layer.
 989          *
 990          * @param extDerItems an array of {@code DerValue} items, each one
 991          * consisting of a DER-encoded extension.
 992          *
 993          * @return a {@code Map} of zero or more extensions,
 994          * keyed by its object identifier in {@code String} form.
 995          *
 996          * @throws IOException if any parsing errors occur.
 997          */
 998         private Map&lt;String, Extension&gt; parseExtensions(DerValue[] extDerItems)
 999                 throws IOException {
1000             Map&lt;String, Extension&gt; extMap = new HashMap&lt;&gt;();
1001 
1002             if (extDerItems != null &amp;&amp; extDerItems.length != 0) {
1003                 for (DerValue extDerVal : extDerItems) {
1004                     sun.security.x509.Extension ext =
1005                             new sun.security.x509.Extension(extDerVal);
1006                     extMap.put(ext.getId(), ext);
1007                 }
1008             }
1009 
1010             return extMap;
1011         }
1012 
1013         /**
1014          * Return the list of single request objects in this OCSP request.
1015          *
1016          * @return an unmodifiable {@code List} of zero or more requests.
1017          */
1018         private List&lt;LocalSingleRequest&gt; getRequests() {
1019             return Collections.unmodifiableList(requestList);
1020         }
1021 
1022         /**
1023          * Return the list of X.509 Certificates in this OCSP request.
1024          *
1025          * @return an unmodifiable {@code List} of zero or more
1026          * {@cpde X509Certificate} objects.
1027          */
1028         private List&lt;X509Certificate&gt; getCertificates() {
1029             return Collections.unmodifiableList(certificates);
1030         }
1031 
1032         /**
1033          * Return the map of OCSP request extensions.
1034          *
1035          * @return an unmodifiable {@code Map} of zero or more
1036          * {@code Extension} objects, keyed by their object identifiers
1037          * in {@code String} form.
1038          */
1039         private Map&lt;String, Extension&gt; getExtensions() {
1040             return Collections.unmodifiableMap(extensions);
1041         }
1042 
1043         /**
1044          * Display the {@code LocalOcspRequest} in human readable form.
1045          *
1046          * @return a {@code String} representation of the
1047          * {@code LocalOcspRequest}
1048          */
1049         @Override
1050         public String toString() {
1051             StringBuilder sb = new StringBuilder();
1052 
1053             sb.append(String.format(&quot;OCSP Request: Version %d (0x%X)&quot;,
1054                     version + 1, version)).append(&quot;\n&quot;);
1055             if (requestorName != null) {
1056                 sb.append(&quot;Requestor Name: &quot;).append(requestorName).
1057                         append(&quot;\n&quot;);
1058             }
1059 
1060             int requestCtr = 0;
1061             for (LocalSingleRequest lsr : requestList) {
1062                 sb.append(&quot;Request [&quot;).append(requestCtr++).append(&quot;]\n&quot;);
1063                 sb.append(lsr).append(&quot;\n&quot;);
1064             }
1065             if (!extensions.isEmpty()) {
1066                 sb.append(&quot;Extensions (&quot;).append(extensions.size()).
1067                         append(&quot;)\n&quot;);
1068                 for (Extension ext : extensions.values()) {
1069                     sb.append(&quot;\t&quot;).append(ext).append(&quot;\n&quot;);
1070                 }
1071             }
1072             if (signature != null) {
1073                 sb.append(&quot;Signature: &quot;).append(algId).append(&quot;\n&quot;);
1074                 sb.append(dumpHexBytes(signature)).append(&quot;\n&quot;);
1075                 int certCtr = 0;
1076                 for (X509Certificate cert : certificates) {
1077                     sb.append(&quot;Certificate [&quot;).append(certCtr++).append(&quot;]&quot;).
1078                             append(&quot;\n&quot;);
1079                     sb.append(&quot;\tSubject: &quot;);
1080                     sb.append(cert.getSubjectX500Principal()).append(&quot;\n&quot;);
1081                     sb.append(&quot;\tIssuer: &quot;);
1082                     sb.append(cert.getIssuerX500Principal()).append(&quot;\n&quot;);
1083                     sb.append(&quot;\tSerial: &quot;).append(cert.getSerialNumber());
1084                 }
1085             }
1086 
1087             return sb.toString();
1088         }
1089 
1090         /**
1091          * Inner class designed to handle the decoding/representation of
1092          * single requests within a {@code LocalOcspRequest} object.
1093          */
1094         public class LocalSingleRequest {
1095             private final CertId cid;
1096             private Map&lt;String, Extension&gt; extensions = Collections.emptyMap();
1097 
1098             private LocalSingleRequest(DerInputStream dis)
1099                     throws IOException {
1100                 DerValue[] srItems = dis.getSequence(2);
1101 
1102                 // There should be 1, possibly 2 DerValue items
1103                 if (srItems.length == 1 || srItems.length == 2) {
1104                     // The first parsable item should be the mandatory CertId
1105                     cid = new CertId(srItems[0].data);
1106                     if (srItems.length == 2) {
1107                         if (srItems[1].isContextSpecific((byte)0)) {
1108                             DerValue[] extDerItems = srItems[1].data.getSequence(2);
1109                             extensions = parseExtensions(extDerItems);
1110                         } else {
1111                             throw new IOException(&quot;Illegal tag in Request &quot; +
1112                                     &quot;extensions: &quot; + srItems[1].tag);
1113                         }
1114                     }
1115                 } else {
1116                     throw new IOException(&quot;Invalid number of items in &quot; +
1117                             &quot;Request (&quot; + srItems.length + &quot;)&quot;);
1118                 }
1119             }
1120 
1121             /**
1122              * Get the {@code CertId} for this single request.
1123              *
1124              * @return the {@code CertId} for this single request.
1125              */
1126             private CertId getCertId() {
1127                 return cid;
1128             }
1129 
1130             /**
1131              * Return the map of single request extensions.
1132              *
1133              * @return an unmodifiable {@code Map} of zero or more
1134              * {@code Extension} objects, keyed by their object identifiers
1135              * in {@code String} form.
1136              */
1137             private Map&lt;String, Extension&gt; getExtensions() {
1138                 return Collections.unmodifiableMap(extensions);
1139             }
1140 
1141             /**
1142              * Display the {@code LocalSingleRequest} in human readable form.
1143              *
1144              * @return a {@code String} representation of the
1145              * {@code LocalSingleRequest}
1146              */
1147             @Override
1148             public String toString() {
1149                 StringBuilder sb = new StringBuilder();
1150                 sb.append(&quot;CertId, Algorithm = &quot;);
1151                 sb.append(cid.getHashAlgorithm()).append(&quot;\n&quot;);
1152                 sb.append(&quot;\tIssuer Name Hash: &quot;);
1153                 sb.append(dumpHexBytes(cid.getIssuerNameHash(), 256, &quot;&quot;, &quot;&quot;));
1154                 sb.append(&quot;\n&quot;);
1155                 sb.append(&quot;\tIssuer Key Hash: &quot;);
1156                 sb.append(dumpHexBytes(cid.getIssuerKeyHash(), 256, &quot;&quot;, &quot;&quot;));
1157                 sb.append(&quot;\n&quot;);
1158                 sb.append(&quot;\tSerial Number: &quot;).append(cid.getSerialNumber());
1159                 if (!extensions.isEmpty()) {
1160                     sb.append(&quot;Extensions (&quot;).append(extensions.size()).
1161                             append(&quot;)\n&quot;);
1162                     for (Extension ext : extensions.values()) {
1163                         sb.append(&quot;\t&quot;).append(ext).append(&quot;\n&quot;);
1164                     }
1165                 }
1166 
1167                 return sb.toString();
1168             }
1169         }
1170     }
1171 
1172     /**
1173      * Simple nested class to handle OCSP requests without making
1174      * changes to sun.security.provider.certpath.OCSPResponse
1175      */
1176     public class LocalOcspResponse {
1177         private final int version = 0;
1178         private final OCSPResponse.ResponseStatus responseStatus;
1179         private final Map&lt;CertId, CertStatusInfo&gt; respItemMap;
1180         private final Date producedAtDate;
1181         private final List&lt;LocalSingleResponse&gt; singleResponseList =
1182                 new ArrayList&lt;&gt;();
1183         private final Map&lt;String, Extension&gt; responseExtensions;
1184         private byte[] signature;
1185         private final List&lt;X509Certificate&gt; certificates;
1186         private final byte[] encodedResponse;
1187 
1188         /**
1189          * Constructor for the generation of non-successful responses
1190          *
1191          * @param respStat the OCSP response status.
1192          *
1193          * @throws IOException if an error happens during encoding
1194          * @throws NullPointerException if {@code respStat} is {@code null}
1195          * or {@code respStat} is successful.
1196          */
1197         public LocalOcspResponse(OCSPResponse.ResponseStatus respStat)
1198                 throws IOException {
1199             this(respStat, null, null);
1200         }
1201 
1202         /**
1203          * Construct a response from a list of certificate
1204          * status objects and extensions.
1205          *
1206          * @param respStat the status of the entire response
1207          * @param itemMap a {@code Map} of {@code CertId} objects and their
1208          * respective revocation statuses from the server&#39;s response DB.
1209          * @param reqExtensions a {@code Map} of request extensions
1210          *
1211          * @throws IOException if an error happens during encoding
1212          * @throws NullPointerException if {@code respStat} is {@code null}
1213          * or {@code respStat} is successful, and a {@code null} {@code itemMap}
1214          * has been provided.
1215          */
1216         public LocalOcspResponse(OCSPResponse.ResponseStatus respStat,
1217                 Map&lt;CertId, CertStatusInfo&gt; itemMap,
1218                 Map&lt;String, Extension&gt; reqExtensions) throws IOException {
1219             responseStatus = Objects.requireNonNull(respStat,
1220                     &quot;Illegal null response status&quot;);
1221             if (responseStatus == ResponseStatus.SUCCESSFUL) {
1222                 respItemMap = Objects.requireNonNull(itemMap,
1223                         &quot;SUCCESSFUL responses must have a response map&quot;);
1224                 producedAtDate = new Date();
1225 
1226                 // Turn the answerd from the response DB query into a list
1227                 // of single responses.
1228                 for (CertId id : itemMap.keySet()) {
1229                     singleResponseList.add(
1230                             new LocalSingleResponse(id, itemMap.get(id)));
1231                 }
1232 
1233                 responseExtensions = setResponseExtensions(reqExtensions);
1234                 certificates = new ArrayList&lt;&gt;();
1235                 if (signerCert != issuerCert) {
1236                     certificates.add(signerCert);
1237                 }
1238                 certificates.add(issuerCert);
1239             } else {
1240                 respItemMap = null;
1241                 producedAtDate = null;
1242                 responseExtensions = null;
1243                 certificates = null;
1244             }
1245             encodedResponse = this.getBytes();
1246         }
1247 
1248         /**
1249          * Set the response extensions based on the request extensions
1250          * that were received.  Right now, this is limited to the
1251          * OCSP nonce extension.
1252          *
1253          * @param reqExts a {@code Map} of zero or more request extensions
1254          *
1255          * @return a {@code Map} of zero or more response extensions, keyed
1256          * by the extension object identifier in {@code String} form.
1257          */
1258         private Map&lt;String, Extension&gt; setResponseExtensions(
1259                 Map&lt;String, Extension&gt; reqExts) {
1260             Map&lt;String, Extension&gt; respExts = new HashMap&lt;&gt;();
1261             String ocspNonceStr = PKIXExtensions.OCSPNonce_Id.toString();
1262 
1263             if (reqExts != null) {
1264                 for (String id : reqExts.keySet()) {
1265                     if (id.equals(ocspNonceStr)) {
1266                         // We found a nonce, add it into the response extensions
1267                         Extension ext = reqExts.get(id);
1268                         if (ext != null) {
1269                             respExts.put(id, ext);
1270                             log(&quot;Added OCSP Nonce to response&quot;);
1271                         } else {
1272                             log(&quot;Error: Found nonce entry, but found null &quot; +
1273                                     &quot;value.  Skipping&quot;);
1274                         }
1275                     }
1276                 }
1277             }
1278 
1279             return respExts;
1280         }
1281 
1282         /**
1283          * Get the DER-encoded response bytes for this response
1284          *
1285          * @return a byte array containing the DER-encoded bytes for
1286          * the response
1287          *
1288          * @throws IOException if any encoding errors occur
1289          */
1290         private byte[] getBytes() throws IOException {
1291             DerOutputStream outerSeq = new DerOutputStream();
1292             DerOutputStream responseStream = new DerOutputStream();
1293             responseStream.putEnumerated(responseStatus.ordinal());
1294             if (responseStatus == ResponseStatus.SUCCESSFUL &amp;&amp;
1295                     respItemMap != null) {
1296                 encodeResponseBytes(responseStream);
1297             }
1298 
1299             // Commit the outermost sequence bytes
1300             outerSeq.write(DerValue.tag_Sequence, responseStream);
1301             return outerSeq.toByteArray();
1302         }
1303 
1304         private void encodeResponseBytes(DerOutputStream responseStream)
1305                 throws IOException {
1306             DerOutputStream explicitZero = new DerOutputStream();
1307             DerOutputStream respItemStream = new DerOutputStream();
1308 
1309             respItemStream.putOID(OCSP_BASIC_RESPONSE_OID);
1310 
1311             byte[] basicOcspBytes = encodeBasicOcspResponse();
1312             respItemStream.putOctetString(basicOcspBytes);
1313             explicitZero.write(DerValue.tag_Sequence, respItemStream);
1314             responseStream.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1315                     true, (byte)0), explicitZero);
1316         }
1317 
1318         private byte[] encodeBasicOcspResponse() throws IOException {
1319             DerOutputStream outerSeq = new DerOutputStream();
1320             DerOutputStream basicORItemStream = new DerOutputStream();
1321 
1322             // Encode the tbsResponse
1323             byte[] tbsResponseBytes = encodeTbsResponse();
1324             basicORItemStream.write(tbsResponseBytes);
1325 
1326             try {
1327                 sigAlgId.derEncode(basicORItemStream);
1328 
1329                 // Create the signature
1330                 Signature sig = Signature.getInstance(sigAlgId.getName());
1331                 sig.initSign(signerKey);
1332                 sig.update(tbsResponseBytes);
1333                 signature = sig.sign();
1334                 basicORItemStream.putBitString(signature);
1335             } catch (GeneralSecurityException exc) {
1336                 err(exc);
1337                 throw new IOException(exc);
1338             }
1339 
1340             // Add certificates
1341             try {
1342                 DerOutputStream certStream = new DerOutputStream();
1343                 ArrayList&lt;DerValue&gt; certList = new ArrayList&lt;&gt;();
1344                 if (signerCert != issuerCert) {
1345                     certList.add(new DerValue(signerCert.getEncoded()));
1346                 }
1347                 certList.add(new DerValue(issuerCert.getEncoded()));
1348                 DerValue[] dvals = new DerValue[certList.size()];
1349                 certStream.putSequence(certList.toArray(dvals));
1350                 basicORItemStream.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1351                         true, (byte)0), certStream);
1352             } catch (CertificateEncodingException cex) {
1353                 err(cex);
1354                 throw new IOException(cex);
1355             }
1356 
1357             // Commit the outermost sequence bytes
1358             outerSeq.write(DerValue.tag_Sequence, basicORItemStream);
1359             return outerSeq.toByteArray();
1360         }
1361 
1362         private byte[] encodeTbsResponse() throws IOException {
1363             DerOutputStream outerSeq = new DerOutputStream();
1364             DerOutputStream tbsStream = new DerOutputStream();
1365 
1366             // Note: We&#39;re not going explicitly assert the version
1367             tbsStream.write(respId.getEncoded());
1368             tbsStream.putGeneralizedTime(producedAtDate);
1369 
1370             // Sequence of responses
1371             encodeSingleResponses(tbsStream);
1372 
1373             // TODO: add response extension support
1374             encodeExtensions(tbsStream);
1375 
1376             outerSeq.write(DerValue.tag_Sequence, tbsStream);
1377             return outerSeq.toByteArray();
1378         }
1379 
1380         private void encodeSingleResponses(DerOutputStream tbsStream)
1381                 throws IOException {
1382             DerValue[] srDerVals = new DerValue[singleResponseList.size()];
1383             int srDvCtr = 0;
1384 
1385             for (LocalSingleResponse lsr : singleResponseList) {
1386                 srDerVals[srDvCtr++] = new DerValue(lsr.getBytes());
1387             }
1388 
1389             tbsStream.putSequence(srDerVals);
1390         }
1391 
1392         private void encodeExtensions(DerOutputStream tbsStream)
1393                 throws IOException {
1394             DerOutputStream extSequence = new DerOutputStream();
1395             DerOutputStream extItems = new DerOutputStream();
1396 
1397             for (Extension ext : responseExtensions.values()) {
1398                 ext.encode(extItems);
1399             }
1400             extSequence.write(DerValue.tag_Sequence, extItems);
1401             tbsStream.write(DerValue.createTag(DerValue.TAG_CONTEXT, true,
1402                     (byte)1), extSequence);
1403         }
1404 
1405         @Override
1406         public String toString() {
1407             StringBuilder sb = new StringBuilder();
1408 
1409             sb.append(&quot;OCSP Response: &quot;).append(responseStatus).append(&quot;\n&quot;);
1410             if (responseStatus == ResponseStatus.SUCCESSFUL) {
1411                 sb.append(&quot;Response Type: &quot;).
1412                         append(OCSP_BASIC_RESPONSE_OID.toString()).append(&quot;\n&quot;);
1413                 sb.append(String.format(&quot;Version: %d (0x%X)&quot;, version + 1,
1414                         version)).append(&quot;\n&quot;);
1415                 sb.append(&quot;Responder Id: &quot;).append(respId.toString()).
1416                         append(&quot;\n&quot;);
1417                 sb.append(&quot;Produced At: &quot;).
1418                         append(utcDateFmt.format(producedAtDate)).append(&quot;\n&quot;);
1419 
1420                 int srCtr = 0;
1421                 for (LocalSingleResponse lsr : singleResponseList) {
1422                     sb.append(&quot;SingleResponse [&quot;).append(srCtr++).append(&quot;]\n&quot;);
1423                     sb.append(lsr);
1424                 }
1425 
1426                 if (!responseExtensions.isEmpty()) {
1427                     sb.append(&quot;Extensions (&quot;).append(responseExtensions.size()).
1428                             append(&quot;)\n&quot;);
1429                     for (Extension ext : responseExtensions.values()) {
1430                         sb.append(&quot;\t&quot;).append(ext).append(&quot;\n&quot;);
1431                     }
1432                 } else {
1433                     sb.append(&quot;\n&quot;);
1434                 }
1435 
1436                 if (signature != null) {
1437                     sb.append(&quot;Signature: &quot;).append(sigAlgId).append(&quot;\n&quot;);
1438                     sb.append(dumpHexBytes(signature)).append(&quot;\n&quot;);
1439                     int certCtr = 0;
1440                     for (X509Certificate cert : certificates) {
1441                         sb.append(&quot;Certificate [&quot;).append(certCtr++).append(&quot;]&quot;).
1442                                 append(&quot;\n&quot;);
1443                         sb.append(&quot;\tSubject: &quot;);
1444                         sb.append(cert.getSubjectX500Principal()).append(&quot;\n&quot;);
1445                         sb.append(&quot;\tIssuer: &quot;);
1446                         sb.append(cert.getIssuerX500Principal()).append(&quot;\n&quot;);
1447                         sb.append(&quot;\tSerial: &quot;).append(cert.getSerialNumber());
1448                         sb.append(&quot;\n&quot;);
1449                     }
1450                 }
1451             }
1452 
1453             return sb.toString();
1454         }
1455 
1456         private class LocalSingleResponse {
1457             private final CertId certId;
1458             private final CertStatusInfo csInfo;
1459             private final Date thisUpdate;
1460             private final Date lsrNextUpdate;
1461             private final Map&lt;String, Extension&gt; singleExtensions;
1462 
1463             public LocalSingleResponse(CertId cid, CertStatusInfo info) {
1464                 certId = Objects.requireNonNull(cid, &quot;CertId must be non-null&quot;);
1465                 csInfo = Objects.requireNonNull(info,
1466                         &quot;CertStatusInfo must be non-null&quot;);
1467 
1468                 // For now, we&#39;ll keep things simple and make the thisUpdate
1469                 // field the same as the producedAt date.
1470                 thisUpdate = producedAtDate;
1471                 lsrNextUpdate = getNextUpdate();
1472 
1473                 // TODO Add extensions support
1474                 singleExtensions = Collections.emptyMap();
1475             }
1476 
1477             @Override
1478             public String toString() {
1479                 StringBuilder sb = new StringBuilder();
1480                 sb.append(&quot;Certificate Status: &quot;).append(csInfo.getType());
1481                 sb.append(&quot;\n&quot;);
1482                 if (csInfo.getType() == CertStatus.CERT_STATUS_REVOKED) {
1483                     sb.append(&quot;Revocation Time: &quot;);
1484                     sb.append(utcDateFmt.format(csInfo.getRevocationTime()));
1485                     sb.append(&quot;\n&quot;);
1486                     if (csInfo.getRevocationReason() != null) {
1487                         sb.append(&quot;Revocation Reason: &quot;);
1488                         sb.append(csInfo.getRevocationReason()).append(&quot;\n&quot;);
1489                     }
1490                 }
1491 
1492                 sb.append(&quot;CertId, Algorithm = &quot;);
1493                 sb.append(certId.getHashAlgorithm()).append(&quot;\n&quot;);
1494                 sb.append(&quot;\tIssuer Name Hash: &quot;);
1495                 sb.append(dumpHexBytes(certId.getIssuerNameHash(), 256, &quot;&quot;, &quot;&quot;));
1496                 sb.append(&quot;\n&quot;);
1497                 sb.append(&quot;\tIssuer Key Hash: &quot;);
1498                 sb.append(dumpHexBytes(certId.getIssuerKeyHash(), 256, &quot;&quot;, &quot;&quot;));
1499                 sb.append(&quot;\n&quot;);
1500                 sb.append(&quot;\tSerial Number: &quot;).append(certId.getSerialNumber());
1501                 sb.append(&quot;\n&quot;);
1502                 sb.append(&quot;This Update: &quot;);
1503                 sb.append(utcDateFmt.format(thisUpdate)).append(&quot;\n&quot;);
1504                 if (lsrNextUpdate != null) {
1505                     sb.append(&quot;Next Update: &quot;);
1506                     sb.append(utcDateFmt.format(lsrNextUpdate)).append(&quot;\n&quot;);
1507                 }
1508 
1509                 if (!singleExtensions.isEmpty()) {
1510                     sb.append(&quot;Extensions (&quot;).append(singleExtensions.size()).
1511                             append(&quot;)\n&quot;);
1512                     for (Extension ext : singleExtensions.values()) {
1513                         sb.append(&quot;\t&quot;).append(ext).append(&quot;\n&quot;);
1514                     }
1515                 }
1516 
1517                 return sb.toString();
1518             }
1519 
1520             public byte[] getBytes() throws IOException {
1521                 byte[] nullData = { };
1522                 DerOutputStream responseSeq = new DerOutputStream();
1523                 DerOutputStream srStream = new DerOutputStream();
1524 
1525                 // Encode the CertId
1526                 certId.encode(srStream);
1527 
1528                 // Next, encode the CertStatus field
1529                 CertStatus csiType = csInfo.getType();
1530                 switch (csiType) {
1531                     case CERT_STATUS_GOOD:
1532                         srStream.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1533                                 false, (byte)0), nullData);
1534                         break;
1535                     case CERT_STATUS_REVOKED:
1536                         DerOutputStream revInfo = new DerOutputStream();
1537                         revInfo.putGeneralizedTime(csInfo.getRevocationTime());
1538                         CRLReason revReason = csInfo.getRevocationReason();
1539                         if (revReason != null) {
1540                             byte[] revDer = new byte[3];
1541                             revDer[0] = DerValue.tag_Enumerated;
1542                             revDer[1] = 1;
1543                             revDer[2] = (byte)revReason.ordinal();
1544                             revInfo.write(DerValue.createTag(
1545                                     DerValue.TAG_CONTEXT, true, (byte)0),
1546                                     revDer);
1547                         }
1548                         srStream.write(DerValue.createTag(
1549                                 DerValue.TAG_CONTEXT, true, (byte)1),
1550                                 revInfo);
1551                         break;
1552                     case CERT_STATUS_UNKNOWN:
1553                         srStream.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1554                                 false, (byte)2), nullData);
1555                         break;
1556                     default:
1557                         throw new IOException(&quot;Unknown CertStatus: &quot; + csiType);
1558                 }
1559 
1560                 // Add the necessary dates
1561                 srStream.putGeneralizedTime(thisUpdate);
1562                 if (lsrNextUpdate != null) {
1563                     DerOutputStream nuStream = new DerOutputStream();
1564                     nuStream.putGeneralizedTime(lsrNextUpdate);
1565                     srStream.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1566                             true, (byte)0), nuStream);
1567                 }
1568 
1569                 // TODO add singleResponse Extension support
1570 
1571                 // Add the single response to the response output stream
1572                 responseSeq.write(DerValue.tag_Sequence, srStream);
1573                 return responseSeq.toByteArray();
1574             }
1575         }
1576     }
1577 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
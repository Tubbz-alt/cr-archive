<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/tools/jarsigner/TimestampCheck.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import com.sun.net.httpserver.*;
  25 
  26 import java.io.ByteArrayInputStream;
  27 import java.io.ByteArrayOutputStream;
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.OutputStream;
  32 import java.math.BigInteger;
  33 import java.net.InetSocketAddress;
  34 import java.nio.file.Files;
  35 import java.nio.file.Paths;
  36 import java.security.KeyStore;
  37 import java.security.PrivateKey;
  38 import java.security.Signature;
  39 import java.security.cert.Certificate;
  40 import java.security.cert.CertificateException;
  41 import java.security.cert.CertificateFactory;
  42 import java.security.cert.X509Certificate;
  43 import java.time.Instant;
  44 import java.time.temporal.ChronoUnit;
  45 import java.util.*;
  46 import java.util.jar.JarEntry;
  47 import java.util.jar.JarFile;
  48 
  49 import jdk.test.lib.SecurityTools;
  50 import jdk.test.lib.process.OutputAnalyzer;
  51 import jdk.test.lib.util.JarUtils;
  52 import sun.security.pkcs.ContentInfo;
  53 import sun.security.pkcs.PKCS7;
  54 import sun.security.pkcs.PKCS9Attribute;
  55 import sun.security.pkcs.SignerInfo;
  56 import sun.security.timestamp.TimestampToken;
  57 import sun.security.util.DerOutputStream;
  58 import sun.security.util.DerValue;
  59 import sun.security.util.ObjectIdentifier;
  60 import sun.security.x509.AlgorithmId;
  61 import sun.security.x509.X500Name;
  62 
  63 /*
  64  * @test
  65  * @bug 6543842 6543440 6939248 8009636 8024302 8163304 8169911 8180289 8172404
  66  *          8242151
  67  * @summary checking response of timestamp
  68  * @modules java.base/sun.security.pkcs
  69  *          java.base/sun.security.timestamp
  70  *          java.base/sun.security.x509
  71  *          java.base/sun.security.util
  72  *          java.base/sun.security.tools.keytool
  73  * @library /lib/testlibrary
  74  * @library /test/lib
  75  * @build jdk.test.lib.util.JarUtils
  76  *        jdk.test.lib.SecurityTools
  77  *        jdk.test.lib.Utils
  78  *        jdk.test.lib.Asserts
  79  *        jdk.test.lib.JDKToolFinder
  80  *        jdk.test.lib.JDKToolLauncher
  81  *        jdk.test.lib.Platform
  82  *        jdk.test.lib.process.*
  83  * @compile -XDignore.symbol.file TimestampCheck.java
  84  * @run main/timeout=600 TimestampCheck
  85  */
  86 public class TimestampCheck {
  87 
  88     static final String defaultPolicyId = &quot;2.3.4&quot;;
  89     static String host = null;
  90 
  91     static class Handler implements HttpHandler, AutoCloseable {
  92 
  93         private final HttpServer httpServer;
  94         private final String keystore;
  95 
  96         @Override
  97         public void handle(HttpExchange t) throws IOException {
  98             int len = 0;
  99             for (String h: t.getRequestHeaders().keySet()) {
 100                 if (h.equalsIgnoreCase(&quot;Content-length&quot;)) {
 101                     len = Integer.valueOf(t.getRequestHeaders().get(h).get(0));
 102                 }
 103             }
 104             byte[] input = new byte[len];
 105             t.getRequestBody().read(input);
 106 
 107             try {
 108                 String path = t.getRequestURI().getPath().substring(1);
 109                 byte[] output = sign(input, path);
 110                 Headers out = t.getResponseHeaders();
 111                 out.set(&quot;Content-Type&quot;, &quot;application/timestamp-reply&quot;);
 112 
 113                 t.sendResponseHeaders(200, output.length);
 114                 OutputStream os = t.getResponseBody();
 115                 os.write(output);
 116             } catch (Exception e) {
 117                 e.printStackTrace();
 118                 t.sendResponseHeaders(500, 0);
 119             }
 120             t.close();
 121         }
 122 
 123         /**
 124          * @param input The data to sign
 125          * @param path different cases to simulate, impl on URL path
 126          * @returns the signed
 127          */
 128         byte[] sign(byte[] input, String path) throws Exception {
 129 
 130             DerValue value = new DerValue(input);
 131             System.out.println(&quot;#\n# Incoming Request\n===================&quot;);
 132             System.out.println(&quot;# Version: &quot; + value.data.getInteger());
 133             DerValue messageImprint = value.data.getDerValue();
 134             AlgorithmId aid = AlgorithmId.parse(
 135                     messageImprint.data.getDerValue());
 136             System.out.println(&quot;# AlgorithmId: &quot; + aid);
 137 
 138             ObjectIdentifier policyId = ObjectIdentifier.of(defaultPolicyId);
 139             BigInteger nonce = null;
 140             while (value.data.available() &gt; 0) {
 141                 DerValue v = value.data.getDerValue();
 142                 if (v.tag == DerValue.tag_Integer) {
 143                     nonce = v.getBigInteger();
 144                     System.out.println(&quot;# nonce: &quot; + nonce);
 145                 } else if (v.tag == DerValue.tag_Boolean) {
 146                     System.out.println(&quot;# certReq: &quot; + v.getBoolean());
 147                 } else if (v.tag == DerValue.tag_ObjectId) {
 148                     policyId = v.getOID();
 149                     System.out.println(&quot;# PolicyID: &quot; + policyId);
 150                 }
 151             }
 152 
 153             System.out.println(&quot;#\n# Response\n===================&quot;);
 154             KeyStore ks = KeyStore.getInstance(
 155                     new File(keystore), &quot;changeit&quot;.toCharArray());
 156 
 157             // If path starts with &quot;ts&quot;, use the TSA it points to.
 158             // Otherwise, always use &quot;ts&quot;.
 159             String alias = path.startsWith(&quot;ts&quot;) ? path : &quot;ts&quot;;
 160 
 161             if (path.equals(&quot;diffpolicy&quot;)) {
 162                 policyId = ObjectIdentifier.of(defaultPolicyId);
 163             }
 164 
 165             DerOutputStream statusInfo = new DerOutputStream();
 166             statusInfo.putInteger(0);
 167 
 168             AlgorithmId[] algorithms = {aid};
 169             Certificate[] chain = ks.getCertificateChain(alias);
 170             X509Certificate[] signerCertificateChain;
 171             X509Certificate signer = (X509Certificate)chain[0];
 172 
 173             if (path.equals(&quot;fullchain&quot;)) {   // Only case 5 uses full chain
 174                 signerCertificateChain = new X509Certificate[chain.length];
 175                 for (int i=0; i&lt;chain.length; i++) {
 176                     signerCertificateChain[i] = (X509Certificate)chain[i];
 177                 }
 178             } else if (path.equals(&quot;nocert&quot;)) {
 179                 signerCertificateChain = new X509Certificate[0];
 180             } else {
 181                 signerCertificateChain = new X509Certificate[1];
 182                 signerCertificateChain[0] = (X509Certificate)chain[0];
 183             }
 184 
 185             DerOutputStream tst = new DerOutputStream();
 186 
 187             tst.putInteger(1);
 188             tst.putOID(policyId);
 189 
 190             if (!path.equals(&quot;baddigest&quot;) &amp;&amp; !path.equals(&quot;diffalg&quot;)) {
 191                 tst.putDerValue(messageImprint);
 192             } else {
 193                 byte[] data = messageImprint.toByteArray();
 194                 if (path.equals(&quot;diffalg&quot;)) {
 195                     data[6] = (byte)0x01;
 196                 } else {
 197                     data[data.length-1] = (byte)0x01;
 198                     data[data.length-2] = (byte)0x02;
 199                     data[data.length-3] = (byte)0x03;
 200                 }
 201                 tst.write(data);
 202             }
 203 
 204             tst.putInteger(1);
 205 
 206             Instant instant = Instant.now();
 207             if (path.equals(&quot;tsold&quot;)) {
 208                 instant = instant.minus(20, ChronoUnit.DAYS);
 209             }
 210             tst.putGeneralizedTime(Date.from(instant));
 211 
 212             if (path.equals(&quot;diffnonce&quot;)) {
 213                 tst.putInteger(1234);
 214             } else if (path.equals(&quot;nononce&quot;)) {
 215                 // no noce
 216             } else {
 217                 tst.putInteger(nonce);
 218             }
 219 
 220             DerOutputStream tstInfo = new DerOutputStream();
 221             tstInfo.write(DerValue.tag_Sequence, tst);
 222 
 223             DerOutputStream tstInfo2 = new DerOutputStream();
 224             tstInfo2.putOctetString(tstInfo.toByteArray());
 225 
 226             // Always use the same algorithm at timestamp signing
 227             // so it is different from the hash algorithm.
 228             String sigAlg = &quot;SHA256withRSA&quot;;
 229             Signature sig = Signature.getInstance(sigAlg);
 230             sig.initSign((PrivateKey)(ks.getKey(
 231                     alias, &quot;changeit&quot;.toCharArray())));
 232             sig.update(tstInfo.toByteArray());
 233 
 234             ContentInfo contentInfo = new ContentInfo(ObjectIdentifier.of(
 235                     &quot;1.2.840.113549.1.9.16.1.4&quot;),
 236                     new DerValue(tstInfo2.toByteArray()));
 237 
 238             System.out.println(&quot;# Signing...&quot;);
 239             System.out.println(&quot;# &quot; + new X500Name(signer
 240                     .getIssuerX500Principal().getName()));
 241             System.out.println(&quot;# &quot; + signer.getSerialNumber());
 242 
 243             SignerInfo signerInfo = new SignerInfo(
 244                     new X500Name(signer.getIssuerX500Principal().getName()),
 245                     signer.getSerialNumber(),
 246                     AlgorithmId.get(AlgorithmId.getDigAlgFromSigAlg(sigAlg)),
 247                     AlgorithmId.get(AlgorithmId.getEncAlgFromSigAlg(sigAlg)),
 248                     sig.sign());
 249 
 250             SignerInfo[] signerInfos = {signerInfo};
 251             PKCS7 p7 = new PKCS7(algorithms, contentInfo,
 252                     signerCertificateChain, signerInfos);
 253             ByteArrayOutputStream p7out = new ByteArrayOutputStream();
 254             p7.encodeSignedData(p7out);
 255 
 256             DerOutputStream response = new DerOutputStream();
 257             response.write(DerValue.tag_Sequence, statusInfo);
 258             response.putDerValue(new DerValue(p7out.toByteArray()));
 259 
 260             DerOutputStream out = new DerOutputStream();
 261             out.write(DerValue.tag_Sequence, response);
 262 
 263             return out.toByteArray();
 264         }
 265 
 266         private Handler(HttpServer httpServer, String keystore) {
 267             this.httpServer = httpServer;
 268             this.keystore = keystore;
 269         }
 270 
 271         /**
 272          * Initialize TSA instance.
 273          *
 274          * Extended Key Info extension of certificate that is used for
 275          * signing TSA responses should contain timeStamping value.
 276          */
 277         static Handler init(int port, String keystore) throws IOException {
 278             HttpServer httpServer = HttpServer.create(
 279                     new InetSocketAddress(port), 0);
 280             Handler tsa = new Handler(httpServer, keystore);
 281             httpServer.createContext(&quot;/&quot;, tsa);
 282             return tsa;
 283         }
 284 
 285         /**
 286          * Start TSA service.
 287          */
 288         void start() {
 289             httpServer.start();
 290         }
 291 
 292         /**
 293          * Stop TSA service.
 294          */
 295         void stop() {
 296             httpServer.stop(0);
 297         }
 298 
 299         /**
 300          * Return server port number.
 301          */
 302         int getPort() {
 303             return httpServer.getAddress().getPort();
 304         }
 305 
 306         @Override
 307         public void close() throws Exception {
 308             stop();
 309         }
 310     }
 311 
 312     public static void main(String[] args) throws Throwable {
 313 
 314         try (Handler tsa = Handler.init(0, &quot;ks&quot;);) {
 315             tsa.start();
 316             int port = tsa.getPort();
 317             host = &quot;http://localhost:&quot; + port + &quot;/&quot;;
 318 
 319             if (args.length == 0) {         // Run this test
 320 
 321                 prepare();
 322 
 323                 sign(&quot;normal&quot;)
 324                         .shouldNotContain(&quot;Warning&quot;)
 325                         .shouldContain(&quot;The signer certificate will expire on&quot;)
 326                         .shouldContain(&quot;The timestamp will expire on&quot;)
 327                         .shouldHaveExitValue(0);
 328 
 329                 verify(&quot;normal.jar&quot;)
 330                         .shouldNotContain(&quot;Warning&quot;)
 331                         .shouldHaveExitValue(0);
 332 
 333                 verify(&quot;normal.jar&quot;, &quot;-verbose&quot;)
 334                         .shouldNotContain(&quot;Warning&quot;)
 335                         .shouldContain(&quot;The signer certificate will expire on&quot;)
 336                         .shouldContain(&quot;The timestamp will expire on&quot;)
 337                         .shouldHaveExitValue(0);
 338 
 339                 // Simulate signing at a previous date:
 340                 // 1. tsold will create a timestamp of 20 days ago.
 341                 // 2. oldsigner expired 10 days ago.
 342                 signVerbose(&quot;tsold&quot;, &quot;unsigned.jar&quot;, &quot;tsold.jar&quot;, &quot;oldsigner&quot;)
 343                         .shouldNotContain(&quot;Warning&quot;)
 344                         .shouldMatch(&quot;signer certificate expired on .*. &quot;
 345                                 + &quot;However, the JAR will be valid&quot;)
 346                         .shouldHaveExitValue(0);
 347 
 348                 // It verifies perfectly.
 349                 verify(&quot;tsold.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
 350                         .shouldNotContain(&quot;Warning&quot;)
 351                         .shouldMatch(&quot;signer certificate expired on .*. &quot;
 352                                 + &quot;However, the JAR will be valid&quot;)
 353                         .shouldHaveExitValue(0);
 354 
 355                 // No timestamp
 356                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;none.jar&quot;, &quot;signer&quot;)
 357                         .shouldContain(&quot;is not timestamped&quot;)
 358                         .shouldContain(&quot;The signer certificate will expire on&quot;)
 359                         .shouldHaveExitValue(0);
 360 
 361                 verify(&quot;none.jar&quot;, &quot;-verbose&quot;)
 362                         .shouldContain(&quot;do not include a timestamp&quot;)
 363                         .shouldContain(&quot;The signer certificate will expire on&quot;)
 364                         .shouldHaveExitValue(0);
 365 
 366                 // Error cases
 367 
 368                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;badku.jar&quot;, &quot;badku&quot;)
 369                         .shouldContain(&quot;KeyUsage extension doesn&#39;t allow code signing&quot;)
 370                         .shouldHaveExitValue(8);
 371                 checkBadKU(&quot;badku.jar&quot;);
 372 
 373                 // 8180289: unvalidated TSA cert chain
 374                 sign(&quot;tsnoca&quot;)
 375                         .shouldContain(&quot;The TSA certificate chain is invalid. &quot;
 376                                 + &quot;Reason: Path does not chain with any of the trust anchors&quot;)
 377                         .shouldHaveExitValue(64);
 378 
 379                 verify(&quot;tsnoca.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
 380                         .shouldHaveExitValue(64)
 381                         .shouldContain(&quot;jar verified&quot;)
 382                         .shouldContain(&quot;Invalid TSA certificate chain: &quot;
 383                                 + &quot;Path does not chain with any of the trust anchors&quot;)
 384                         .shouldContain(&quot;TSA certificate chain is invalid.&quot;
 385                                 + &quot; Reason: Path does not chain with any of the trust anchors&quot;);
 386 
 387                 sign(&quot;nononce&quot;)
 388                         .shouldContain(&quot;Nonce missing in timestamp token&quot;)
 389                         .shouldHaveExitValue(1);
 390                 sign(&quot;diffnonce&quot;)
 391                         .shouldContain(&quot;Nonce changed in timestamp token&quot;)
 392                         .shouldHaveExitValue(1);
 393                 sign(&quot;baddigest&quot;)
 394                         .shouldContain(&quot;Digest octets changed in timestamp token&quot;)
 395                         .shouldHaveExitValue(1);
 396                 sign(&quot;diffalg&quot;)
 397                         .shouldContain(&quot;Digest algorithm not&quot;)
 398                         .shouldHaveExitValue(1);
 399 
 400                 sign(&quot;fullchain&quot;)
 401                         .shouldHaveExitValue(0);   // Success, 6543440 solved.
 402 
 403                 sign(&quot;tsbad1&quot;)
 404                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
 405                         .shouldHaveExitValue(1);
 406                 sign(&quot;tsbad2&quot;)
 407                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
 408                         .shouldHaveExitValue(1);
 409                 sign(&quot;tsbad3&quot;)
 410                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
 411                         .shouldHaveExitValue(1);
 412                 sign(&quot;nocert&quot;)
 413                         .shouldContain(&quot;Certificate not included in timestamp token&quot;)
 414                         .shouldHaveExitValue(1);
 415 
 416                 sign(&quot;policy&quot;, &quot;-tsapolicyid&quot;,  &quot;1.2.3&quot;)
 417                         .shouldHaveExitValue(0);
 418                 checkTimestamp(&quot;policy.jar&quot;, &quot;1.2.3&quot;, &quot;SHA-256&quot;);
 419 
 420                 sign(&quot;diffpolicy&quot;, &quot;-tsapolicyid&quot;, &quot;1.2.3&quot;)
 421                         .shouldContain(&quot;TSAPolicyID changed in timestamp token&quot;)
 422                         .shouldHaveExitValue(1);
 423 
 424                 sign(&quot;sha384alg&quot;, &quot;-tsadigestalg&quot;, &quot;SHA-384&quot;)
 425                         .shouldHaveExitValue(0);
 426                 checkTimestamp(&quot;sha384alg.jar&quot;, defaultPolicyId, &quot;SHA-384&quot;);
 427 
 428                 // Legacy algorithms
 429                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;sha1alg.jar&quot;, &quot;signer&quot;,
 430                         &quot;-strict&quot;, &quot;-digestalg&quot;, &quot;SHA-1&quot;)
 431                         .shouldHaveExitValue(0)
 432                         .shouldContain(&quot;jar signed, with signer errors&quot;)
 433                         .shouldMatch(&quot;SHA-1.*-digestalg.*will be disabled&quot;);
 434                 verify(&quot;sha1alg.jar&quot;, &quot;-strict&quot;)
 435                         .shouldHaveExitValue(0)
 436                         .shouldContain(&quot;jar verified, with signer errors&quot;)
 437                         .shouldContain(&quot;SHA-1 digest algorithm is considered a security risk&quot;)
 438                         .shouldContain(&quot;This algorithm will be disabled in a future update&quot;)
 439                         .shouldNotContain(&quot;is disabled&quot;);
 440 
 441                 sign(&quot;sha1tsaalg&quot;, &quot;-tsadigestalg&quot;, &quot;SHA-1&quot;, &quot;-strict&quot;)
 442                         .shouldHaveExitValue(0)
 443                         .shouldContain(&quot;jar signed, with signer errors&quot;)
 444                         .shouldMatch(&quot;SHA-1.*-tsadigestalg.*will be disabled&quot;)
 445                         .shouldNotContain(&quot;is disabled&quot;);
 446                 verify(&quot;sha1tsaalg.jar&quot;, &quot;-strict&quot;)
 447                         .shouldHaveExitValue(0)
 448                         .shouldContain(&quot;jar verified, with signer errors&quot;)
 449                         .shouldContain(&quot;SHA-1 timestamp digest algorithm is considered a security risk&quot;)
 450                         .shouldNotContain(&quot;is disabled&quot;);
 451 
 452                 // Disabled algorithms
 453                 sign(&quot;tsdisabled&quot;, &quot;-digestalg&quot;, &quot;MD5&quot;,
 454                                 &quot;-sigalg&quot;, &quot;MD5withRSA&quot;, &quot;-tsadigestalg&quot;, &quot;MD5&quot;)
 455                         .shouldHaveExitValue(68)
 456                         .shouldContain(&quot;The timestamp is invalid. Without a valid timestamp&quot;)
 457                         .shouldMatch(&quot;MD5.*-digestalg.*is disabled&quot;)
 458                         .shouldMatch(&quot;MD5.*-tsadigestalg.*is disabled&quot;)
 459                         .shouldMatch(&quot;MD5withRSA.*-sigalg.*is disabled&quot;);
 460                 checkDisabled(&quot;tsdisabled.jar&quot;);
 461 
 462                 signVerbose(&quot;tsdisabled&quot;, &quot;unsigned.jar&quot;, &quot;tsdisabled2.jar&quot;, &quot;signer&quot;)
 463                         .shouldHaveExitValue(64)
 464                         .shouldContain(&quot;The timestamp is invalid. Without a valid timestamp&quot;)
 465                         .shouldContain(&quot;TSA certificate chain is invalid&quot;);
 466 
 467                 // Disabled timestamp is an error and jar treated unsigned
 468                 verify(&quot;tsdisabled2.jar&quot;, &quot;-verbose&quot;)
 469                         .shouldHaveExitValue(16)
 470                         .shouldContain(&quot;treated as unsigned&quot;)
 471                         .shouldMatch(&quot;Timestamp.*512.*(disabled)&quot;);
 472 
 473                 // Algorithm used in signing is disabled
 474                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;halfDisabled.jar&quot;, &quot;signer&quot;,
 475                         &quot;-digestalg&quot;, &quot;MD5&quot;)
 476                         .shouldContain(&quot;-digestalg option is considered a security risk and is disabled&quot;)
 477                         .shouldHaveExitValue(4);
 478                 checkHalfDisabled(&quot;halfDisabled.jar&quot;);
 479 
 480                 // sign with DSA key
 481                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;sign1.jar&quot;, &quot;dsakey&quot;)
 482                         .shouldHaveExitValue(0);
 483 
 484                 // sign with RSAkeysize &lt; 1024
 485                 signVerbose(&quot;normal&quot;, &quot;sign1.jar&quot;, &quot;sign2.jar&quot;, &quot;disabledkeysize&quot;)
 486                         .shouldContain(&quot;Algorithm constraints check failed on keysize&quot;)
 487                         .shouldHaveExitValue(4);
 488                 checkMultiple(&quot;sign2.jar&quot;);
 489 
 490                 // Legacy algorithms
 491                 sign(&quot;tsweak&quot;, &quot;-digestalg&quot;, &quot;SHA1&quot;,
 492                                 &quot;-sigalg&quot;, &quot;SHA1withRSA&quot;, &quot;-tsadigestalg&quot;, &quot;SHA1&quot;)
 493                         .shouldHaveExitValue(0)
 494                         .shouldMatch(&quot;SHA1.*-digestalg.*will be disabled&quot;)
 495                         .shouldMatch(&quot;SHA1.*-tsadigestalg.*will be disabled&quot;)
 496                         .shouldMatch(&quot;SHA1withRSA.*-sigalg.*will be disabled&quot;);
 497                 checkWeak(&quot;tsweak.jar&quot;);
 498 
 499                 signVerbose(&quot;tsweak&quot;, &quot;unsigned.jar&quot;, &quot;tsweak2.jar&quot;, &quot;signer&quot;)
 500                         .shouldHaveExitValue(0);
 501 
 502                 verify(&quot;tsweak2.jar&quot;, &quot;-verbose&quot;)
 503                         .shouldHaveExitValue(0)
 504                         .shouldContain(&quot;jar verified&quot;)
 505                         .shouldMatch(&quot;Timestamp.*1024.*(weak)&quot;);
 506 
 507                 // Algorithm used in signing is weak
 508                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;halfWeak.jar&quot;, &quot;signer&quot;,
 509                         &quot;-digestalg&quot;, &quot;SHA1&quot;)
 510                         .shouldContain(&quot;-digestalg option is considered a security risk.&quot;)
 511                         .shouldContain(&quot;This algorithm will be disabled in a future update.&quot;)
 512                         .shouldHaveExitValue(0);
 513                 checkHalfWeak(&quot;halfWeak.jar&quot;);
 514 
 515                 // sign with DSA key
 516                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;sign1.jar&quot;, &quot;dsakey&quot;)
 517                         .shouldHaveExitValue(0);
 518 
 519                 // sign with RSAkeysize &lt; 2048
 520                 signVerbose(&quot;normal&quot;, &quot;sign1.jar&quot;, &quot;sign2.jar&quot;, &quot;weakkeysize&quot;)
 521                         .shouldNotContain(&quot;Algorithm constraints check failed on keysize&quot;)
 522                         .shouldHaveExitValue(0);
 523                 checkMultipleWeak(&quot;sign2.jar&quot;);
 524 
 525 
 526                 // 8191438: jarsigner should print when a timestamp will expire
 527                 checkExpiration();
 528 
 529                 // When .SF or .RSA is missing or invalid
 530                 checkMissingOrInvalidFiles(&quot;normal.jar&quot;);
 531 
 532                 if (Files.exists(Paths.get(&quot;ts2.cert&quot;))) {
 533                     checkInvalidTsaCertKeyUsage();
 534                 }
 535             } else {                        // Run as a standalone server
 536                 System.out.println(&quot;TSA started at &quot; + host
 537                         + &quot;. Press Enter to quit server&quot;);
 538                 System.in.read();
 539             }
 540         }
 541     }
 542 
 543     private static void checkExpiration() throws Exception {
 544 
 545         // Warning when expired or expiring
 546         signVerbose(null, &quot;unsigned.jar&quot;, &quot;expired.jar&quot;, &quot;expired&quot;)
 547                 .shouldContain(&quot;signer certificate has expired&quot;)
 548                 .shouldHaveExitValue(4);
 549         verify(&quot;expired.jar&quot;)
 550                 .shouldContain(&quot;signer certificate has expired&quot;)
 551                 .shouldHaveExitValue(4);
 552         signVerbose(null, &quot;unsigned.jar&quot;, &quot;expiring.jar&quot;, &quot;expiring&quot;)
 553                 .shouldContain(&quot;signer certificate will expire within&quot;)
 554                 .shouldHaveExitValue(0);
 555         verify(&quot;expiring.jar&quot;)
 556                 .shouldContain(&quot;signer certificate will expire within&quot;)
 557                 .shouldHaveExitValue(0);
 558         // Info for long
 559         signVerbose(null, &quot;unsigned.jar&quot;, &quot;long.jar&quot;, &quot;long&quot;)
 560                 .shouldNotContain(&quot;signer certificate has expired&quot;)
 561                 .shouldNotContain(&quot;signer certificate will expire within&quot;)
 562                 .shouldContain(&quot;signer certificate will expire on&quot;)
 563                 .shouldHaveExitValue(0);
 564         verify(&quot;long.jar&quot;)
 565                 .shouldNotContain(&quot;signer certificate has expired&quot;)
 566                 .shouldNotContain(&quot;signer certificate will expire within&quot;)
 567                 .shouldNotContain(&quot;The signer certificate will expire&quot;)
 568                 .shouldHaveExitValue(0);
 569         verify(&quot;long.jar&quot;, &quot;-verbose&quot;)
 570                 .shouldContain(&quot;The signer certificate will expire&quot;)
 571                 .shouldHaveExitValue(0);
 572 
 573         // Both expired
 574         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
 575                 &quot;tsexpired-expired.jar&quot;, &quot;expired&quot;)
 576                 .shouldContain(&quot;The signer certificate has expired.&quot;)
 577                 .shouldContain(&quot;The timestamp has expired.&quot;)
 578                 .shouldHaveExitValue(4);
 579         verify(&quot;tsexpired-expired.jar&quot;)
 580                 .shouldContain(&quot;signer certificate has expired&quot;)
 581                 .shouldContain(&quot;timestamp has expired.&quot;)
 582                 .shouldHaveExitValue(4);
 583 
 584         // TS expired but signer still good
 585         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
 586                 &quot;tsexpired-long.jar&quot;, &quot;long&quot;)
 587                 .shouldContain(&quot;The timestamp expired on&quot;)
 588                 .shouldHaveExitValue(0);
 589         verify(&quot;tsexpired-long.jar&quot;)
 590                 .shouldMatch(&quot;timestamp expired on.*However, the JAR will be valid&quot;)
 591                 .shouldNotContain(&quot;Error&quot;)
 592                 .shouldHaveExitValue(0);
 593 
 594         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
 595                 &quot;tsexpired-ca.jar&quot;, &quot;ca&quot;)
 596                 .shouldContain(&quot;The timestamp has expired.&quot;)
 597                 .shouldHaveExitValue(4);
 598         verify(&quot;tsexpired-ca.jar&quot;)
 599                 .shouldNotContain(&quot;timestamp has expired&quot;)
 600                 .shouldNotContain(&quot;Error&quot;)
 601                 .shouldHaveExitValue(0);
 602 
 603         // Warning when expiring
 604         sign(&quot;tsexpiring&quot;)
 605                 .shouldContain(&quot;timestamp will expire within&quot;)
 606                 .shouldHaveExitValue(0);
 607         verify(&quot;tsexpiring.jar&quot;)
 608                 .shouldContain(&quot;timestamp will expire within&quot;)
 609                 .shouldNotContain(&quot;still valid&quot;)
 610                 .shouldHaveExitValue(0);
 611 
 612         signVerbose(&quot;tsexpiring&quot;, &quot;unsigned.jar&quot;,
 613                 &quot;tsexpiring-ca.jar&quot;, &quot;ca&quot;)
 614                 .shouldContain(&quot;self-signed&quot;)
 615                 .stderrShouldNotMatch(&quot;The.*expir&quot;)
 616                 .shouldHaveExitValue(4); // self-signed
 617         verify(&quot;tsexpiring-ca.jar&quot;)
 618                 .stderrShouldNotMatch(&quot;The.*expir&quot;)
 619                 .shouldHaveExitValue(0);
 620 
 621         signVerbose(&quot;tsexpiringsoon&quot;, &quot;unsigned.jar&quot;,
 622                 &quot;tsexpiringsoon-long.jar&quot;, &quot;long&quot;)
 623                 .shouldContain(&quot;The timestamp will expire&quot;)
 624                 .shouldHaveExitValue(0);
 625         verify(&quot;tsexpiringsoon-long.jar&quot;)
 626                 .shouldMatch(&quot;timestamp will expire.*However, the JAR will be valid until&quot;)
 627                 .shouldHaveExitValue(0);
 628 
 629         // Info for long
 630         sign(&quot;tslong&quot;)
 631                 .shouldNotContain(&quot;timestamp has expired&quot;)
 632                 .shouldNotContain(&quot;timestamp will expire within&quot;)
 633                 .shouldContain(&quot;timestamp will expire on&quot;)
 634                 .shouldContain(&quot;signer certificate will expire on&quot;)
 635                 .shouldHaveExitValue(0);
 636         verify(&quot;tslong.jar&quot;)
 637                 .shouldNotContain(&quot;timestamp has expired&quot;)
 638                 .shouldNotContain(&quot;timestamp will expire within&quot;)
 639                 .shouldNotContain(&quot;timestamp will expire on&quot;)
 640                 .shouldNotContain(&quot;signer certificate will expire on&quot;)
 641                 .shouldHaveExitValue(0);
 642         verify(&quot;tslong.jar&quot;, &quot;-verbose&quot;)
 643                 .shouldContain(&quot;timestamp will expire on&quot;)
 644                 .shouldContain(&quot;signer certificate will expire on&quot;)
 645                 .shouldHaveExitValue(0);
 646     }
 647 
 648     private static void checkInvalidTsaCertKeyUsage() throws Exception {
 649 
 650         // Hack: Rewrite the TSA cert inside normal.jar into ts2.jar.
 651 
 652         // Both the cert and the serial number must be rewritten.
 653         byte[] tsCert = Files.readAllBytes(Paths.get(&quot;ts.cert&quot;));
 654         byte[] ts2Cert = Files.readAllBytes(Paths.get(&quot;ts2.cert&quot;));
 655         byte[] tsSerial = getCert(tsCert)
 656                 .getSerialNumber().toByteArray();
 657         byte[] ts2Serial = getCert(ts2Cert)
 658                 .getSerialNumber().toByteArray();
 659 
 660         byte[] oldBlock;
 661         try (JarFile normal = new JarFile(&quot;normal.jar&quot;)) {
 662             oldBlock = normal.getInputStream(
 663                     normal.getJarEntry(&quot;META-INF/SIGNER.RSA&quot;)).readAllBytes();
 664         }
 665 
 666         JarUtils.updateJar(&quot;normal.jar&quot;, &quot;ts2.jar&quot;,
 667                 Map.of(&quot;META-INF/SIGNER.RSA&quot;,
 668                         updateBytes(updateBytes(oldBlock, tsCert, ts2Cert),
 669                                 tsSerial, ts2Serial)));
 670 
 671         verify(&quot;ts2.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
 672                 .shouldHaveExitValue(64)
 673                 .shouldContain(&quot;jar verified&quot;)
 674                 .shouldContain(&quot;Invalid TSA certificate chain: Extended key usage does not permit use for TSA server&quot;);
 675     }
 676 
 677     public static X509Certificate getCert(byte[] data)
 678             throws CertificateException, IOException {
 679         return (X509Certificate)
 680                 CertificateFactory.getInstance(&quot;X.509&quot;)
 681                         .generateCertificate(new ByteArrayInputStream(data));
 682     }
 683 
 684     private static byte[] updateBytes(byte[] old, byte[] from, byte[] to) {
 685         int pos = 0;
 686         while (true) {
 687             if (pos + from.length &gt; old.length) {
 688                 return null;
 689             }
 690             if (Arrays.equals(Arrays.copyOfRange(old, pos, pos+from.length), from)) {
 691                 byte[] result = old.clone();
 692                 System.arraycopy(to, 0, result, pos, from.length);
 693                 return result;
 694             }
 695             pos++;
 696         }
 697     }
 698 
 699     private static void checkMissingOrInvalidFiles(String s)
 700             throws Throwable {
 701 
 702         JarUtils.updateJar(s, &quot;1.jar&quot;, Map.of(&quot;META-INF/SIGNER.SF&quot;, Boolean.FALSE));
 703         verify(&quot;1.jar&quot;, &quot;-verbose&quot;)
 704                 .shouldHaveExitValue(16)
 705                 .shouldContain(&quot;treated as unsigned&quot;)
 706                 .shouldContain(&quot;Missing signature-related file META-INF/SIGNER.SF&quot;);
 707         JarUtils.updateJar(s, &quot;2.jar&quot;, Map.of(&quot;META-INF/SIGNER.RSA&quot;, Boolean.FALSE));
 708         verify(&quot;2.jar&quot;, &quot;-verbose&quot;)
 709                 .shouldHaveExitValue(16)
 710                 .shouldContain(&quot;treated as unsigned&quot;)
 711                 .shouldContain(&quot;Missing block file for signature-related file META-INF/SIGNER.SF&quot;);
 712         JarUtils.updateJar(s, &quot;3.jar&quot;, Map.of(&quot;META-INF/SIGNER.SF&quot;, &quot;dummy&quot;));
 713         verify(&quot;3.jar&quot;, &quot;-verbose&quot;)
 714                 .shouldHaveExitValue(16)
 715                 .shouldContain(&quot;treated as unsigned&quot;)
 716                 .shouldContain(&quot;Unparsable signature-related file META-INF/SIGNER.SF&quot;);
 717         JarUtils.updateJar(s, &quot;4.jar&quot;, Map.of(&quot;META-INF/SIGNER.RSA&quot;, &quot;dummy&quot;));
 718         verify(&quot;4.jar&quot;, &quot;-verbose&quot;)
 719                 .shouldHaveExitValue(16)
 720                 .shouldContain(&quot;treated as unsigned&quot;)
 721                 .shouldContain(&quot;Unparsable signature-related file META-INF/SIGNER.RSA&quot;);
 722     }
 723 
 724     static OutputAnalyzer jarsigner(List&lt;String&gt; extra)
 725             throws Exception {
 726         List&lt;String&gt; args = new ArrayList&lt;&gt;(
 727                 List.of(&quot;-keystore&quot;, &quot;ks&quot;, &quot;-storepass&quot;, &quot;changeit&quot;));
 728         args.addAll(extra);
 729         return SecurityTools.jarsigner(args);
 730     }
 731 
 732     static OutputAnalyzer verify(String file, String... extra)
 733             throws Exception {
 734         List&lt;String&gt; args = new ArrayList&lt;&gt;();
 735         args.add(&quot;-verify&quot;);
 736         args.add(&quot;-strict&quot;);
 737         args.add(file);
 738         args.addAll(Arrays.asList(extra));
 739         return jarsigner(args);
 740     }
 741 
 742     static void checkBadKU(String file) throws Exception {
 743         verify(file)
 744                 .shouldHaveExitValue(16)
 745                 .shouldContain(&quot;treated as unsigned&quot;)
 746                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
 747         verify(file, &quot;-verbose&quot;)
 748                 .shouldHaveExitValue(16)
 749                 .shouldContain(&quot;Signed by&quot;)
 750                 .shouldContain(&quot;treated as unsigned&quot;)
 751                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
 752         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
 753                 .shouldHaveExitValue(16)
 754                 .shouldContain(&quot;SignatureException: Key usage restricted&quot;)
 755                 .shouldContain(&quot;treated as unsigned&quot;)
 756                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
 757     }
 758 
 759     static void checkDisabled(String file) throws Exception {
 760         verify(file)
 761                 .shouldHaveExitValue(16)
 762                 .shouldContain(&quot;treated as unsigned&quot;)
 763                 .shouldMatch(&quot;weak algorithm that is now disabled.&quot;)
 764                 .shouldMatch(&quot;Re-run jarsigner with the -verbose option for more details&quot;);
 765         verify(file, &quot;-verbose&quot;)
 766                 .shouldHaveExitValue(16)
 767                 .shouldContain(&quot;treated as unsigned&quot;)
 768                 .shouldMatch(&quot;weak algorithm that is now disabled by&quot;)
 769                 .shouldMatch(&quot;Digest algorithm: .*(disabled)&quot;)
 770                 .shouldMatch(&quot;Signature algorithm: .*(disabled)&quot;)
 771                 .shouldMatch(&quot;Timestamp digest algorithm: .*(disabled)&quot;)
 772                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
 773                 .shouldMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
 774         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
 775                 .shouldHaveExitValue(16)
 776                 .shouldMatch(&quot;SignatureException:.*disabled&quot;);
 777 
 778         // For 8171319: keytool should print out warnings when reading or
 779         //              generating cert/cert req using disabled algorithms.
 780         // Must call keytool the command, otherwise doPrintCert() might not
 781         // be able to reset &quot;jdk.certpath.disabledAlgorithms&quot;.
 782         String sout = SecurityTools.keytool(&quot;-printcert -jarfile &quot; + file)
 783                 .stderrShouldContain(&quot;The TSA certificate uses a 512-bit RSA key&quot; +
 784                         &quot; which is considered a security risk and is disabled.&quot;)
 785                 .getStdout();
 786         if (sout.indexOf(&quot;disabled&quot;, sout.indexOf(&quot;Timestamp:&quot;)) &lt; 0) {
 787             throw new RuntimeException(&quot;timestamp not disabled: &quot; + sout);
 788         }
 789     }
 790 
 791     static void checkHalfDisabled(String file) throws Exception {
 792         verify(file)
 793                 .shouldHaveExitValue(16)
 794                 .shouldContain(&quot;treated as unsigned&quot;)
 795                 .shouldMatch(&quot;weak algorithm that is now disabled.&quot;)
 796                 .shouldMatch(&quot;Re-run jarsigner with the -verbose option for more details&quot;);
 797         verify(file, &quot;-verbose&quot;)
 798                 .shouldHaveExitValue(16)
 799                 .shouldContain(&quot;treated as unsigned&quot;)
 800                 .shouldMatch(&quot;weak algorithm that is now disabled by&quot;)
 801                 .shouldMatch(&quot;Digest algorithm: .*(disabled)&quot;)
 802                 .shouldNotMatch(&quot;Signature algorithm: .*(weak)&quot;)
 803                 .shouldNotMatch(&quot;Signature algorithm: .*(disabled)&quot;)
 804                 .shouldNotMatch(&quot;Timestamp digest algorithm: .*(disabled)&quot;)
 805                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
 806                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(disabled).*(disabled)&quot;)
 807                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;)
 808                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
 809      }
 810 
 811     static void checkMultiple(String file) throws Exception {
 812         verify(file)
 813                 .shouldHaveExitValue(0)
 814                 .shouldContain(&quot;jar verified&quot;);
 815         verify(file, &quot;-verbose&quot;, &quot;-certs&quot;)
 816                 .shouldHaveExitValue(0)
 817                 .shouldContain(&quot;jar verified&quot;)
 818                 .shouldMatch(&quot;X.509.*CN=dsakey&quot;)
 819                 .shouldNotMatch(&quot;X.509.*CN=disabledkeysize&quot;)
 820                 .shouldMatch(&quot;Signed by .*CN=dsakey&quot;)
 821                 .shouldMatch(&quot;Signed by .*CN=disabledkeysize&quot;)
 822                 .shouldMatch(&quot;Signature algorithm: .*key.*(disabled)&quot;);
 823     }
 824 
 825     static void checkWeak(String file) throws Exception {
 826         verify(file)
 827                 .shouldHaveExitValue(0)
 828                 .shouldNotContain(&quot;treated as unsigned&quot;);
 829         verify(file, &quot;-verbose&quot;)
 830                 .shouldHaveExitValue(0)
 831                 .shouldNotContain(&quot;treated as unsigned&quot;)
 832                 .shouldMatch(&quot;Digest algorithm: .*(weak)&quot;)
 833                 .shouldMatch(&quot;Signature algorithm: .*(weak)&quot;)
 834                 .shouldMatch(&quot;Timestamp digest algorithm: .*(weak)&quot;)
 835                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
 836                 .shouldMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;);
 837         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
 838                 .shouldHaveExitValue(0)
 839                 .shouldNotMatch(&quot;SignatureException:.*disabled&quot;);
 840 
 841         // keytool should print out warnings when reading or
 842         // generating cert/cert req using legacy algorithms.
 843         String sout = SecurityTools.keytool(&quot;-printcert -jarfile &quot; + file)
 844                 .stderrShouldContain(&quot;The TSA certificate uses a 1024-bit RSA key&quot; +
 845                         &quot; which is considered a security risk.&quot; +
 846                         &quot; This key size will be disabled in a future update.&quot;)
 847                 .getStdout();
 848         if (sout.indexOf(&quot;weak&quot;, sout.indexOf(&quot;Timestamp:&quot;)) &lt; 0) {
 849             throw new RuntimeException(&quot;timestamp not weak: &quot; + sout);
 850         }
 851     }
 852 
 853     static void checkHalfWeak(String file) throws Exception {
 854         verify(file)
 855                 .shouldHaveExitValue(0)
 856                 .shouldNotContain(&quot;treated as unsigned&quot;);
 857         verify(file, &quot;-verbose&quot;)
 858                 .shouldHaveExitValue(0)
 859                 .shouldNotContain(&quot;treated as unsigned&quot;)
 860                 .shouldMatch(&quot;Digest algorithm: .*(weak)&quot;)
 861                 .shouldNotMatch(&quot;Signature algorithm: .*(weak)&quot;)
 862                 .shouldNotMatch(&quot;Signature algorithm: .*(disabled)&quot;)
 863                 .shouldNotMatch(&quot;Timestamp digest algorithm: .*(weak)&quot;)
 864                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
 865                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(disabled).*(disabled)&quot;)
 866                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;)
 867                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
 868     }
 869 
 870     static void checkMultipleWeak(String file) throws Exception {
 871         verify(file)
 872                 .shouldHaveExitValue(0)
 873                 .shouldContain(&quot;jar verified&quot;);
 874         verify(file, &quot;-verbose&quot;, &quot;-certs&quot;)
 875                 .shouldHaveExitValue(0)
 876                 .shouldContain(&quot;jar verified&quot;)
 877                 .shouldMatch(&quot;X.509.*CN=dsakey&quot;)
 878                 .shouldMatch(&quot;X.509.*CN=weakkeysize&quot;)
 879                 .shouldMatch(&quot;Signed by .*CN=dsakey&quot;)
 880                 .shouldMatch(&quot;Signed by .*CN=weakkeysize&quot;)
 881                 .shouldMatch(&quot;Signature algorithm: .*key.*(weak)&quot;);
 882     }
 883 
 884     static void checkTimestamp(String file, String policyId, String digestAlg)
 885             throws Exception {
 886         try (JarFile jf = new JarFile(file)) {
 887             JarEntry je = jf.getJarEntry(&quot;META-INF/SIGNER.RSA&quot;);
 888             try (InputStream is = jf.getInputStream(je)) {
 889                 byte[] content = is.readAllBytes();
 890                 PKCS7 p7 = new PKCS7(content);
 891                 SignerInfo[] si = p7.getSignerInfos();
 892                 if (si == null || si.length == 0) {
 893                     throw new Exception(&quot;Not signed&quot;);
 894                 }
 895                 PKCS9Attribute p9 = si[0].getUnauthenticatedAttributes()
 896                         .getAttribute(PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID);
 897                 PKCS7 tsToken = new PKCS7((byte[]) p9.getValue());
 898                 TimestampToken tt =
 899                         new TimestampToken(tsToken.getContentInfo().getData());
 900                 if (!tt.getHashAlgorithm().toString().equals(digestAlg)) {
 901                     throw new Exception(&quot;Digest alg different&quot;);
 902                 }
 903                 if (!tt.getPolicyID().equals(policyId)) {
 904                     throw new Exception(&quot;policyId different&quot;);
 905                 }
 906             }
 907         }
 908     }
 909 
 910     static int which = 0;
 911 
 912     /**
 913      * Sign with a TSA path. Always use alias &quot;signer&quot; to sign &quot;unsigned.jar&quot;.
 914      * The signed jar name is always path.jar.
 915      *
 916      * @param extra more args given to jarsigner
 917      */
 918     static OutputAnalyzer sign(String path, String... extra)
 919             throws Exception {
 920         return signVerbose(
 921                 path,
 922                 &quot;unsigned.jar&quot;,
 923                 path + &quot;.jar&quot;,
 924                 &quot;signer&quot;,
 925                 extra);
 926     }
 927 
 928     static OutputAnalyzer signVerbose(
 929             String path,    // TSA URL path
 930             String oldJar,
 931             String newJar,
 932             String alias,   // signer
 933             String...extra) throws Exception {
 934         which++;
 935         System.out.println(&quot;\n&gt;&gt; Test #&quot; + which);
 936         List&lt;String&gt; args = new ArrayList&lt;&gt;(List.of(
 937                 &quot;-strict&quot;, &quot;-verbose&quot;, &quot;-debug&quot;, &quot;-signedjar&quot;, newJar, oldJar, alias));
 938         if (path != null) {
 939             args.add(&quot;-tsa&quot;);
 940             args.add(host + path);
 941         }
 942         args.addAll(Arrays.asList(extra));
 943         return jarsigner(args);
 944     }
 945 
 946     static void prepare() throws Exception {
 947         JarUtils.createJar(&quot;unsigned.jar&quot;, &quot;A&quot;);
 948         Files.deleteIfExists(Paths.get(&quot;ks&quot;));
 949         keytool(&quot;-alias signer -genkeypair -ext bc -dname CN=signer&quot;);
 950         keytool(&quot;-alias oldsigner -genkeypair -dname CN=oldsigner&quot;);
 951         keytool(&quot;-alias dsakey -genkeypair -keyalg DSA -dname CN=dsakey&quot;);
 952         keytool(&quot;-alias weakkeysize -genkeypair -keysize 1024 -dname CN=weakkeysize&quot;);
 953         keytool(&quot;-alias disabledkeysize -genkeypair -keysize 512 -dname CN=disabledkeysize&quot;);
 954         keytool(&quot;-alias badku -genkeypair -dname CN=badku&quot;);
 955         keytool(&quot;-alias ts -genkeypair -dname CN=ts&quot;);
 956         keytool(&quot;-alias tsold -genkeypair -dname CN=tsold&quot;);
 957         keytool(&quot;-alias tsweak -genkeypair -keysize 1024 -dname CN=tsweak&quot;);
 958         keytool(&quot;-alias tsdisabled -genkeypair -keysize 512 -dname CN=tsdisabled&quot;);
 959         keytool(&quot;-alias tsbad1 -genkeypair -dname CN=tsbad1&quot;);
 960         keytool(&quot;-alias tsbad2 -genkeypair -dname CN=tsbad2&quot;);
 961         keytool(&quot;-alias tsbad3 -genkeypair -dname CN=tsbad3&quot;);
 962         keytool(&quot;-alias tsnoca -genkeypair -dname CN=tsnoca&quot;);
 963 
 964         keytool(&quot;-alias expired -genkeypair -dname CN=expired&quot;);
 965         keytool(&quot;-alias expiring -genkeypair -dname CN=expiring&quot;);
 966         keytool(&quot;-alias long -genkeypair -dname CN=long&quot;);
 967         keytool(&quot;-alias tsexpired -genkeypair -dname CN=tsexpired&quot;);
 968         keytool(&quot;-alias tsexpiring -genkeypair -dname CN=tsexpiring&quot;);
 969         keytool(&quot;-alias tsexpiringsoon -genkeypair -dname CN=tsexpiringsoon&quot;);
 970         keytool(&quot;-alias tslong -genkeypair -dname CN=tslong&quot;);
 971 
 972         // tsnoca&#39;s issuer will be removed from keystore later
 973         keytool(&quot;-alias ca -genkeypair -ext bc -dname CN=CA&quot;);
 974         gencert(&quot;tsnoca&quot;, &quot;-ext eku:critical=ts&quot;);
 975         keytool(&quot;-delete -alias ca&quot;);
 976         keytool(&quot;-alias ca -genkeypair -ext bc -dname CN=CA -startdate -40d&quot;);
 977 
 978         gencert(&quot;signer&quot;);
 979         gencert(&quot;oldsigner&quot;, &quot;-startdate -30d -validity 20&quot;);
 980         gencert(&quot;dsakey&quot;);
 981         gencert(&quot;weakkeysize&quot;);
 982         gencert(&quot;disabledkeysize&quot;);
 983         gencert(&quot;badku&quot;, &quot;-ext ku:critical=keyAgreement&quot;);
 984         gencert(&quot;ts&quot;, &quot;-ext eku:critical=ts -validity 500&quot;);
 985 
 986         gencert(&quot;expired&quot;, &quot;-validity 10 -startdate -12d&quot;);
 987         gencert(&quot;expiring&quot;, &quot;-validity 178&quot;);
 988         gencert(&quot;long&quot;, &quot;-validity 182&quot;);
 989         gencert(&quot;tsexpired&quot;, &quot;-ext eku:critical=ts -validity 10 -startdate -12d&quot;);
 990         gencert(&quot;tsexpiring&quot;, &quot;-ext eku:critical=ts -validity 364&quot;);
 991         gencert(&quot;tsexpiringsoon&quot;, &quot;-ext eku:critical=ts -validity 170&quot;); // earlier than expiring
 992         gencert(&quot;tslong&quot;, &quot;-ext eku:critical=ts -validity 367&quot;);
 993 
 994 
 995         for (int i = 0; i &lt; 5; i++) {
 996             // Issue another cert for &quot;ts&quot; with a different EKU.
 997             // Length might be different because serial number is
 998             // random. Try several times until a cert with the same
 999             // length is generated so we can substitute ts.cert
1000             // embedded in the PKCS7 block with ts2.cert.
1001             // If cannot create one, related test will be ignored.
1002             keytool(&quot;-gencert -alias ca -infile ts.req -outfile ts2.cert &quot; +
1003                     &quot;-ext eku:critical=1.3.6.1.5.5.7.3.9&quot;);
1004             if (Files.size(Paths.get(&quot;ts.cert&quot;)) != Files.size(Paths.get(&quot;ts2.cert&quot;))) {
1005                 Files.delete(Paths.get(&quot;ts2.cert&quot;));
1006                 System.out.println(&quot;Warning: cannot create same length&quot;);
1007             } else {
1008                 break;
1009             }
1010         }
1011 
1012         gencert(&quot;tsold&quot;, &quot;-ext eku:critical=ts -startdate -40d -validity 500&quot;);
1013 
1014         gencert(&quot;tsweak&quot;, &quot;-ext eku:critical=ts&quot;);
1015         gencert(&quot;tsdisabled&quot;, &quot;-ext eku:critical=ts&quot;);
1016         gencert(&quot;tsbad1&quot;);
1017         gencert(&quot;tsbad2&quot;, &quot;-ext eku=ts&quot;);
1018         gencert(&quot;tsbad3&quot;, &quot;-ext eku:critical=cs&quot;);
1019     }
1020 
1021     static void gencert(String alias, String... extra) throws Exception {
1022         keytool(&quot;-alias &quot; + alias + &quot; -certreq -file &quot; + alias + &quot;.req&quot;);
1023         String genCmd = &quot;-gencert -alias ca -infile &quot; +
1024                 alias + &quot;.req -outfile &quot; + alias + &quot;.cert&quot;;
1025         for (String s : extra) {
1026             genCmd += &quot; &quot; + s;
1027         }
1028         keytool(genCmd);
1029         keytool(&quot;-alias &quot; + alias + &quot; -importcert -file &quot; + alias + &quot;.cert&quot;);
1030     }
1031 
1032     static void keytool(String cmd) throws Exception {
1033         cmd = &quot;-keystore ks -storepass changeit -keypass changeit &quot; +
1034                 &quot;-keyalg rsa -validity 200 &quot; + cmd;
1035         sun.security.tools.keytool.Main.main(cmd.split(&quot; &quot;));
1036     }
1037 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/security/tools/jarsigner/TimestampCheck.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import com.sun.net.httpserver.*;
  25 
  26 import java.io.ByteArrayInputStream;
  27 import java.io.ByteArrayOutputStream;
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.OutputStream;
  32 import java.math.BigInteger;
  33 import java.net.InetSocketAddress;
  34 import java.nio.file.Files;
  35 import java.nio.file.Paths;
  36 import java.security.KeyStore;
  37 import java.security.PrivateKey;
  38 import java.security.Signature;
  39 import java.security.cert.Certificate;
  40 import java.security.cert.CertificateException;
  41 import java.security.cert.CertificateFactory;
  42 import java.security.cert.X509Certificate;
  43 import java.time.Instant;
  44 import java.time.temporal.ChronoUnit;
  45 import java.util.*;
  46 import java.util.jar.JarEntry;
  47 import java.util.jar.JarFile;
  48 
  49 import jdk.test.lib.SecurityTools;
  50 import jdk.test.lib.process.OutputAnalyzer;
  51 import jdk.test.lib.util.JarUtils;
  52 import sun.security.pkcs.ContentInfo;
  53 import sun.security.pkcs.PKCS7;
  54 import sun.security.pkcs.PKCS9Attribute;
  55 import sun.security.pkcs.SignerInfo;
  56 import sun.security.timestamp.TimestampToken;
  57 import sun.security.util.DerOutputStream;
  58 import sun.security.util.DerValue;
  59 import sun.security.util.ObjectIdentifier;
  60 import sun.security.x509.AlgorithmId;
  61 import sun.security.x509.X500Name;
  62 
  63 /*
  64  * @test
  65  * @bug 6543842 6543440 6939248 8009636 8024302 8163304 8169911 8180289 8172404
<a name="1" id="anc1"></a>
  66  * @summary checking response of timestamp
  67  * @modules java.base/sun.security.pkcs
  68  *          java.base/sun.security.timestamp
  69  *          java.base/sun.security.x509
  70  *          java.base/sun.security.util
  71  *          java.base/sun.security.tools.keytool
  72  * @library /lib/testlibrary
  73  * @library /test/lib
  74  * @build jdk.test.lib.util.JarUtils
  75  *        jdk.test.lib.SecurityTools
  76  *        jdk.test.lib.Utils
  77  *        jdk.test.lib.Asserts
  78  *        jdk.test.lib.JDKToolFinder
  79  *        jdk.test.lib.JDKToolLauncher
  80  *        jdk.test.lib.Platform
  81  *        jdk.test.lib.process.*
  82  * @compile -XDignore.symbol.file TimestampCheck.java
  83  * @run main/timeout=600 TimestampCheck
  84  */
  85 public class TimestampCheck {
  86 
  87     static final String defaultPolicyId = &quot;2.3.4&quot;;
  88     static String host = null;
  89 
  90     static class Handler implements HttpHandler, AutoCloseable {
  91 
  92         private final HttpServer httpServer;
  93         private final String keystore;
  94 
  95         @Override
  96         public void handle(HttpExchange t) throws IOException {
  97             int len = 0;
  98             for (String h: t.getRequestHeaders().keySet()) {
  99                 if (h.equalsIgnoreCase(&quot;Content-length&quot;)) {
 100                     len = Integer.valueOf(t.getRequestHeaders().get(h).get(0));
 101                 }
 102             }
 103             byte[] input = new byte[len];
 104             t.getRequestBody().read(input);
 105 
 106             try {
 107                 String path = t.getRequestURI().getPath().substring(1);
 108                 byte[] output = sign(input, path);
 109                 Headers out = t.getResponseHeaders();
 110                 out.set(&quot;Content-Type&quot;, &quot;application/timestamp-reply&quot;);
 111 
 112                 t.sendResponseHeaders(200, output.length);
 113                 OutputStream os = t.getResponseBody();
 114                 os.write(output);
 115             } catch (Exception e) {
 116                 e.printStackTrace();
 117                 t.sendResponseHeaders(500, 0);
 118             }
 119             t.close();
 120         }
 121 
 122         /**
 123          * @param input The data to sign
 124          * @param path different cases to simulate, impl on URL path
 125          * @returns the signed
 126          */
 127         byte[] sign(byte[] input, String path) throws Exception {
 128 
 129             DerValue value = new DerValue(input);
 130             System.out.println(&quot;#\n# Incoming Request\n===================&quot;);
 131             System.out.println(&quot;# Version: &quot; + value.data.getInteger());
 132             DerValue messageImprint = value.data.getDerValue();
 133             AlgorithmId aid = AlgorithmId.parse(
 134                     messageImprint.data.getDerValue());
 135             System.out.println(&quot;# AlgorithmId: &quot; + aid);
 136 
<a name="2" id="anc2"></a><span class="line-modified"> 137             ObjectIdentifier policyId = new ObjectIdentifier(defaultPolicyId);</span>
 138             BigInteger nonce = null;
 139             while (value.data.available() &gt; 0) {
 140                 DerValue v = value.data.getDerValue();
 141                 if (v.tag == DerValue.tag_Integer) {
 142                     nonce = v.getBigInteger();
 143                     System.out.println(&quot;# nonce: &quot; + nonce);
 144                 } else if (v.tag == DerValue.tag_Boolean) {
 145                     System.out.println(&quot;# certReq: &quot; + v.getBoolean());
 146                 } else if (v.tag == DerValue.tag_ObjectId) {
 147                     policyId = v.getOID();
 148                     System.out.println(&quot;# PolicyID: &quot; + policyId);
 149                 }
 150             }
 151 
 152             System.out.println(&quot;#\n# Response\n===================&quot;);
 153             KeyStore ks = KeyStore.getInstance(
 154                     new File(keystore), &quot;changeit&quot;.toCharArray());
 155 
 156             // If path starts with &quot;ts&quot;, use the TSA it points to.
 157             // Otherwise, always use &quot;ts&quot;.
 158             String alias = path.startsWith(&quot;ts&quot;) ? path : &quot;ts&quot;;
 159 
 160             if (path.equals(&quot;diffpolicy&quot;)) {
<a name="3" id="anc3"></a><span class="line-modified"> 161                 policyId = new ObjectIdentifier(defaultPolicyId);</span>
 162             }
 163 
 164             DerOutputStream statusInfo = new DerOutputStream();
 165             statusInfo.putInteger(0);
 166 
 167             AlgorithmId[] algorithms = {aid};
 168             Certificate[] chain = ks.getCertificateChain(alias);
 169             X509Certificate[] signerCertificateChain;
 170             X509Certificate signer = (X509Certificate)chain[0];
 171 
 172             if (path.equals(&quot;fullchain&quot;)) {   // Only case 5 uses full chain
 173                 signerCertificateChain = new X509Certificate[chain.length];
 174                 for (int i=0; i&lt;chain.length; i++) {
 175                     signerCertificateChain[i] = (X509Certificate)chain[i];
 176                 }
 177             } else if (path.equals(&quot;nocert&quot;)) {
 178                 signerCertificateChain = new X509Certificate[0];
 179             } else {
 180                 signerCertificateChain = new X509Certificate[1];
 181                 signerCertificateChain[0] = (X509Certificate)chain[0];
 182             }
 183 
 184             DerOutputStream tst = new DerOutputStream();
 185 
 186             tst.putInteger(1);
 187             tst.putOID(policyId);
 188 
 189             if (!path.equals(&quot;baddigest&quot;) &amp;&amp; !path.equals(&quot;diffalg&quot;)) {
 190                 tst.putDerValue(messageImprint);
 191             } else {
 192                 byte[] data = messageImprint.toByteArray();
 193                 if (path.equals(&quot;diffalg&quot;)) {
 194                     data[6] = (byte)0x01;
 195                 } else {
 196                     data[data.length-1] = (byte)0x01;
 197                     data[data.length-2] = (byte)0x02;
 198                     data[data.length-3] = (byte)0x03;
 199                 }
 200                 tst.write(data);
 201             }
 202 
 203             tst.putInteger(1);
 204 
 205             Instant instant = Instant.now();
 206             if (path.equals(&quot;tsold&quot;)) {
 207                 instant = instant.minus(20, ChronoUnit.DAYS);
 208             }
 209             tst.putGeneralizedTime(Date.from(instant));
 210 
 211             if (path.equals(&quot;diffnonce&quot;)) {
 212                 tst.putInteger(1234);
 213             } else if (path.equals(&quot;nononce&quot;)) {
 214                 // no noce
 215             } else {
 216                 tst.putInteger(nonce);
 217             }
 218 
 219             DerOutputStream tstInfo = new DerOutputStream();
 220             tstInfo.write(DerValue.tag_Sequence, tst);
 221 
 222             DerOutputStream tstInfo2 = new DerOutputStream();
 223             tstInfo2.putOctetString(tstInfo.toByteArray());
 224 
 225             // Always use the same algorithm at timestamp signing
 226             // so it is different from the hash algorithm.
 227             String sigAlg = &quot;SHA256withRSA&quot;;
 228             Signature sig = Signature.getInstance(sigAlg);
 229             sig.initSign((PrivateKey)(ks.getKey(
 230                     alias, &quot;changeit&quot;.toCharArray())));
 231             sig.update(tstInfo.toByteArray());
 232 
<a name="4" id="anc4"></a><span class="line-modified"> 233             ContentInfo contentInfo = new ContentInfo(new ObjectIdentifier(</span>
 234                     &quot;1.2.840.113549.1.9.16.1.4&quot;),
 235                     new DerValue(tstInfo2.toByteArray()));
 236 
 237             System.out.println(&quot;# Signing...&quot;);
 238             System.out.println(&quot;# &quot; + new X500Name(signer
 239                     .getIssuerX500Principal().getName()));
 240             System.out.println(&quot;# &quot; + signer.getSerialNumber());
 241 
 242             SignerInfo signerInfo = new SignerInfo(
 243                     new X500Name(signer.getIssuerX500Principal().getName()),
 244                     signer.getSerialNumber(),
 245                     AlgorithmId.get(AlgorithmId.getDigAlgFromSigAlg(sigAlg)),
 246                     AlgorithmId.get(AlgorithmId.getEncAlgFromSigAlg(sigAlg)),
 247                     sig.sign());
 248 
 249             SignerInfo[] signerInfos = {signerInfo};
 250             PKCS7 p7 = new PKCS7(algorithms, contentInfo,
 251                     signerCertificateChain, signerInfos);
 252             ByteArrayOutputStream p7out = new ByteArrayOutputStream();
 253             p7.encodeSignedData(p7out);
 254 
 255             DerOutputStream response = new DerOutputStream();
 256             response.write(DerValue.tag_Sequence, statusInfo);
 257             response.putDerValue(new DerValue(p7out.toByteArray()));
 258 
 259             DerOutputStream out = new DerOutputStream();
 260             out.write(DerValue.tag_Sequence, response);
 261 
 262             return out.toByteArray();
 263         }
 264 
 265         private Handler(HttpServer httpServer, String keystore) {
 266             this.httpServer = httpServer;
 267             this.keystore = keystore;
 268         }
 269 
 270         /**
 271          * Initialize TSA instance.
 272          *
 273          * Extended Key Info extension of certificate that is used for
 274          * signing TSA responses should contain timeStamping value.
 275          */
 276         static Handler init(int port, String keystore) throws IOException {
 277             HttpServer httpServer = HttpServer.create(
 278                     new InetSocketAddress(port), 0);
 279             Handler tsa = new Handler(httpServer, keystore);
 280             httpServer.createContext(&quot;/&quot;, tsa);
 281             return tsa;
 282         }
 283 
 284         /**
 285          * Start TSA service.
 286          */
 287         void start() {
 288             httpServer.start();
 289         }
 290 
 291         /**
 292          * Stop TSA service.
 293          */
 294         void stop() {
 295             httpServer.stop(0);
 296         }
 297 
 298         /**
 299          * Return server port number.
 300          */
 301         int getPort() {
 302             return httpServer.getAddress().getPort();
 303         }
 304 
 305         @Override
 306         public void close() throws Exception {
 307             stop();
 308         }
 309     }
 310 
 311     public static void main(String[] args) throws Throwable {
 312 
 313         try (Handler tsa = Handler.init(0, &quot;ks&quot;);) {
 314             tsa.start();
 315             int port = tsa.getPort();
 316             host = &quot;http://localhost:&quot; + port + &quot;/&quot;;
 317 
 318             if (args.length == 0) {         // Run this test
 319 
 320                 prepare();
 321 
 322                 sign(&quot;normal&quot;)
 323                         .shouldNotContain(&quot;Warning&quot;)
 324                         .shouldContain(&quot;The signer certificate will expire on&quot;)
 325                         .shouldContain(&quot;The timestamp will expire on&quot;)
 326                         .shouldHaveExitValue(0);
 327 
 328                 verify(&quot;normal.jar&quot;)
 329                         .shouldNotContain(&quot;Warning&quot;)
 330                         .shouldHaveExitValue(0);
 331 
 332                 verify(&quot;normal.jar&quot;, &quot;-verbose&quot;)
 333                         .shouldNotContain(&quot;Warning&quot;)
 334                         .shouldContain(&quot;The signer certificate will expire on&quot;)
 335                         .shouldContain(&quot;The timestamp will expire on&quot;)
 336                         .shouldHaveExitValue(0);
 337 
 338                 // Simulate signing at a previous date:
 339                 // 1. tsold will create a timestamp of 20 days ago.
 340                 // 2. oldsigner expired 10 days ago.
 341                 signVerbose(&quot;tsold&quot;, &quot;unsigned.jar&quot;, &quot;tsold.jar&quot;, &quot;oldsigner&quot;)
 342                         .shouldNotContain(&quot;Warning&quot;)
 343                         .shouldMatch(&quot;signer certificate expired on .*. &quot;
 344                                 + &quot;However, the JAR will be valid&quot;)
 345                         .shouldHaveExitValue(0);
 346 
 347                 // It verifies perfectly.
 348                 verify(&quot;tsold.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
 349                         .shouldNotContain(&quot;Warning&quot;)
 350                         .shouldMatch(&quot;signer certificate expired on .*. &quot;
 351                                 + &quot;However, the JAR will be valid&quot;)
 352                         .shouldHaveExitValue(0);
 353 
 354                 // No timestamp
 355                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;none.jar&quot;, &quot;signer&quot;)
 356                         .shouldContain(&quot;is not timestamped&quot;)
 357                         .shouldContain(&quot;The signer certificate will expire on&quot;)
 358                         .shouldHaveExitValue(0);
 359 
 360                 verify(&quot;none.jar&quot;, &quot;-verbose&quot;)
 361                         .shouldContain(&quot;do not include a timestamp&quot;)
 362                         .shouldContain(&quot;The signer certificate will expire on&quot;)
 363                         .shouldHaveExitValue(0);
 364 
 365                 // Error cases
 366 
 367                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;badku.jar&quot;, &quot;badku&quot;)
 368                         .shouldContain(&quot;KeyUsage extension doesn&#39;t allow code signing&quot;)
 369                         .shouldHaveExitValue(8);
 370                 checkBadKU(&quot;badku.jar&quot;);
 371 
 372                 // 8180289: unvalidated TSA cert chain
 373                 sign(&quot;tsnoca&quot;)
 374                         .shouldContain(&quot;The TSA certificate chain is invalid. &quot;
 375                                 + &quot;Reason: Path does not chain with any of the trust anchors&quot;)
 376                         .shouldHaveExitValue(64);
 377 
 378                 verify(&quot;tsnoca.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
 379                         .shouldHaveExitValue(64)
 380                         .shouldContain(&quot;jar verified&quot;)
 381                         .shouldContain(&quot;Invalid TSA certificate chain: &quot;
 382                                 + &quot;Path does not chain with any of the trust anchors&quot;)
 383                         .shouldContain(&quot;TSA certificate chain is invalid.&quot;
 384                                 + &quot; Reason: Path does not chain with any of the trust anchors&quot;);
 385 
 386                 sign(&quot;nononce&quot;)
 387                         .shouldContain(&quot;Nonce missing in timestamp token&quot;)
 388                         .shouldHaveExitValue(1);
 389                 sign(&quot;diffnonce&quot;)
 390                         .shouldContain(&quot;Nonce changed in timestamp token&quot;)
 391                         .shouldHaveExitValue(1);
 392                 sign(&quot;baddigest&quot;)
 393                         .shouldContain(&quot;Digest octets changed in timestamp token&quot;)
 394                         .shouldHaveExitValue(1);
 395                 sign(&quot;diffalg&quot;)
 396                         .shouldContain(&quot;Digest algorithm not&quot;)
 397                         .shouldHaveExitValue(1);
 398 
 399                 sign(&quot;fullchain&quot;)
 400                         .shouldHaveExitValue(0);   // Success, 6543440 solved.
 401 
 402                 sign(&quot;tsbad1&quot;)
 403                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
 404                         .shouldHaveExitValue(1);
 405                 sign(&quot;tsbad2&quot;)
 406                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
 407                         .shouldHaveExitValue(1);
 408                 sign(&quot;tsbad3&quot;)
 409                         .shouldContain(&quot;Certificate is not valid for timestamping&quot;)
 410                         .shouldHaveExitValue(1);
 411                 sign(&quot;nocert&quot;)
 412                         .shouldContain(&quot;Certificate not included in timestamp token&quot;)
 413                         .shouldHaveExitValue(1);
 414 
 415                 sign(&quot;policy&quot;, &quot;-tsapolicyid&quot;,  &quot;1.2.3&quot;)
 416                         .shouldHaveExitValue(0);
 417                 checkTimestamp(&quot;policy.jar&quot;, &quot;1.2.3&quot;, &quot;SHA-256&quot;);
 418 
 419                 sign(&quot;diffpolicy&quot;, &quot;-tsapolicyid&quot;, &quot;1.2.3&quot;)
 420                         .shouldContain(&quot;TSAPolicyID changed in timestamp token&quot;)
 421                         .shouldHaveExitValue(1);
 422 
 423                 sign(&quot;sha384alg&quot;, &quot;-tsadigestalg&quot;, &quot;SHA-384&quot;)
 424                         .shouldHaveExitValue(0);
 425                 checkTimestamp(&quot;sha384alg.jar&quot;, defaultPolicyId, &quot;SHA-384&quot;);
 426 
 427                 // Legacy algorithms
 428                 signVerbose(null, &quot;unsigned.jar&quot;, &quot;sha1alg.jar&quot;, &quot;signer&quot;,
 429                         &quot;-strict&quot;, &quot;-digestalg&quot;, &quot;SHA-1&quot;)
 430                         .shouldHaveExitValue(0)
 431                         .shouldContain(&quot;jar signed, with signer errors&quot;)
 432                         .shouldMatch(&quot;SHA-1.*-digestalg.*will be disabled&quot;);
 433                 verify(&quot;sha1alg.jar&quot;, &quot;-strict&quot;)
 434                         .shouldHaveExitValue(0)
 435                         .shouldContain(&quot;jar verified, with signer errors&quot;)
 436                         .shouldContain(&quot;SHA-1 digest algorithm is considered a security risk&quot;)
 437                         .shouldContain(&quot;This algorithm will be disabled in a future update&quot;)
 438                         .shouldNotContain(&quot;is disabled&quot;);
 439 
 440                 sign(&quot;sha1tsaalg&quot;, &quot;-tsadigestalg&quot;, &quot;SHA-1&quot;, &quot;-strict&quot;)
 441                         .shouldHaveExitValue(0)
 442                         .shouldContain(&quot;jar signed, with signer errors&quot;)
 443                         .shouldMatch(&quot;SHA-1.*-tsadigestalg.*will be disabled&quot;)
 444                         .shouldNotContain(&quot;is disabled&quot;);
 445                 verify(&quot;sha1tsaalg.jar&quot;, &quot;-strict&quot;)
 446                         .shouldHaveExitValue(0)
 447                         .shouldContain(&quot;jar verified, with signer errors&quot;)
<a name="5" id="anc5"></a><span class="line-modified"> 448                         .shouldContain(&quot;SHA-1 digest algorithm is considered a security risk&quot;)</span>
 449                         .shouldNotContain(&quot;is disabled&quot;);
 450 
 451                 // Disabled algorithms
 452                 sign(&quot;tsdisabled&quot;, &quot;-digestalg&quot;, &quot;MD5&quot;,
 453                                 &quot;-sigalg&quot;, &quot;MD5withRSA&quot;, &quot;-tsadigestalg&quot;, &quot;MD5&quot;)
 454                         .shouldHaveExitValue(68)
 455                         .shouldContain(&quot;The timestamp is invalid. Without a valid timestamp&quot;)
 456                         .shouldMatch(&quot;MD5.*-digestalg.*is disabled&quot;)
 457                         .shouldMatch(&quot;MD5.*-tsadigestalg.*is disabled&quot;)
 458                         .shouldMatch(&quot;MD5withRSA.*-sigalg.*is disabled&quot;);
 459                 checkDisabled(&quot;tsdisabled.jar&quot;);
 460 
 461                 signVerbose(&quot;tsdisabled&quot;, &quot;unsigned.jar&quot;, &quot;tsdisabled2.jar&quot;, &quot;signer&quot;)
 462                         .shouldHaveExitValue(64)
 463                         .shouldContain(&quot;The timestamp is invalid. Without a valid timestamp&quot;)
 464                         .shouldContain(&quot;TSA certificate chain is invalid&quot;);
 465 
 466                 // Disabled timestamp is an error and jar treated unsigned
 467                 verify(&quot;tsdisabled2.jar&quot;, &quot;-verbose&quot;)
 468                         .shouldHaveExitValue(16)
 469                         .shouldContain(&quot;treated as unsigned&quot;)
 470                         .shouldMatch(&quot;Timestamp.*512.*(disabled)&quot;);
 471 
 472                 // Algorithm used in signing is disabled
 473                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;halfDisabled.jar&quot;, &quot;signer&quot;,
 474                         &quot;-digestalg&quot;, &quot;MD5&quot;)
 475                         .shouldContain(&quot;-digestalg option is considered a security risk and is disabled&quot;)
 476                         .shouldHaveExitValue(4);
 477                 checkHalfDisabled(&quot;halfDisabled.jar&quot;);
 478 
 479                 // sign with DSA key
 480                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;sign1.jar&quot;, &quot;dsakey&quot;)
 481                         .shouldHaveExitValue(0);
 482 
 483                 // sign with RSAkeysize &lt; 1024
 484                 signVerbose(&quot;normal&quot;, &quot;sign1.jar&quot;, &quot;sign2.jar&quot;, &quot;disabledkeysize&quot;)
 485                         .shouldContain(&quot;Algorithm constraints check failed on keysize&quot;)
 486                         .shouldHaveExitValue(4);
 487                 checkMultiple(&quot;sign2.jar&quot;);
 488 
 489                 // Legacy algorithms
 490                 sign(&quot;tsweak&quot;, &quot;-digestalg&quot;, &quot;SHA1&quot;,
 491                                 &quot;-sigalg&quot;, &quot;SHA1withRSA&quot;, &quot;-tsadigestalg&quot;, &quot;SHA1&quot;)
 492                         .shouldHaveExitValue(0)
 493                         .shouldMatch(&quot;SHA1.*-digestalg.*will be disabled&quot;)
 494                         .shouldMatch(&quot;SHA1.*-tsadigestalg.*will be disabled&quot;)
 495                         .shouldMatch(&quot;SHA1withRSA.*-sigalg.*will be disabled&quot;);
 496                 checkWeak(&quot;tsweak.jar&quot;);
 497 
 498                 signVerbose(&quot;tsweak&quot;, &quot;unsigned.jar&quot;, &quot;tsweak2.jar&quot;, &quot;signer&quot;)
 499                         .shouldHaveExitValue(0);
 500 
 501                 verify(&quot;tsweak2.jar&quot;, &quot;-verbose&quot;)
 502                         .shouldHaveExitValue(0)
 503                         .shouldContain(&quot;jar verified&quot;)
 504                         .shouldMatch(&quot;Timestamp.*1024.*(weak)&quot;);
 505 
 506                 // Algorithm used in signing is weak
 507                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;halfWeak.jar&quot;, &quot;signer&quot;,
 508                         &quot;-digestalg&quot;, &quot;SHA1&quot;)
 509                         .shouldContain(&quot;-digestalg option is considered a security risk.&quot;)
 510                         .shouldContain(&quot;This algorithm will be disabled in a future update.&quot;)
 511                         .shouldHaveExitValue(0);
 512                 checkHalfWeak(&quot;halfWeak.jar&quot;);
 513 
 514                 // sign with DSA key
 515                 signVerbose(&quot;normal&quot;, &quot;unsigned.jar&quot;, &quot;sign1.jar&quot;, &quot;dsakey&quot;)
 516                         .shouldHaveExitValue(0);
 517 
 518                 // sign with RSAkeysize &lt; 2048
 519                 signVerbose(&quot;normal&quot;, &quot;sign1.jar&quot;, &quot;sign2.jar&quot;, &quot;weakkeysize&quot;)
 520                         .shouldNotContain(&quot;Algorithm constraints check failed on keysize&quot;)
 521                         .shouldHaveExitValue(0);
 522                 checkMultipleWeak(&quot;sign2.jar&quot;);
 523 
 524 
 525                 // 8191438: jarsigner should print when a timestamp will expire
 526                 checkExpiration();
 527 
 528                 // When .SF or .RSA is missing or invalid
 529                 checkMissingOrInvalidFiles(&quot;normal.jar&quot;);
 530 
 531                 if (Files.exists(Paths.get(&quot;ts2.cert&quot;))) {
 532                     checkInvalidTsaCertKeyUsage();
 533                 }
 534             } else {                        // Run as a standalone server
 535                 System.out.println(&quot;TSA started at &quot; + host
 536                         + &quot;. Press Enter to quit server&quot;);
 537                 System.in.read();
 538             }
 539         }
 540     }
 541 
 542     private static void checkExpiration() throws Exception {
 543 
 544         // Warning when expired or expiring
 545         signVerbose(null, &quot;unsigned.jar&quot;, &quot;expired.jar&quot;, &quot;expired&quot;)
 546                 .shouldContain(&quot;signer certificate has expired&quot;)
 547                 .shouldHaveExitValue(4);
 548         verify(&quot;expired.jar&quot;)
 549                 .shouldContain(&quot;signer certificate has expired&quot;)
 550                 .shouldHaveExitValue(4);
 551         signVerbose(null, &quot;unsigned.jar&quot;, &quot;expiring.jar&quot;, &quot;expiring&quot;)
 552                 .shouldContain(&quot;signer certificate will expire within&quot;)
 553                 .shouldHaveExitValue(0);
 554         verify(&quot;expiring.jar&quot;)
 555                 .shouldContain(&quot;signer certificate will expire within&quot;)
 556                 .shouldHaveExitValue(0);
 557         // Info for long
 558         signVerbose(null, &quot;unsigned.jar&quot;, &quot;long.jar&quot;, &quot;long&quot;)
 559                 .shouldNotContain(&quot;signer certificate has expired&quot;)
 560                 .shouldNotContain(&quot;signer certificate will expire within&quot;)
 561                 .shouldContain(&quot;signer certificate will expire on&quot;)
 562                 .shouldHaveExitValue(0);
 563         verify(&quot;long.jar&quot;)
 564                 .shouldNotContain(&quot;signer certificate has expired&quot;)
 565                 .shouldNotContain(&quot;signer certificate will expire within&quot;)
 566                 .shouldNotContain(&quot;The signer certificate will expire&quot;)
 567                 .shouldHaveExitValue(0);
 568         verify(&quot;long.jar&quot;, &quot;-verbose&quot;)
 569                 .shouldContain(&quot;The signer certificate will expire&quot;)
 570                 .shouldHaveExitValue(0);
 571 
 572         // Both expired
 573         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
 574                 &quot;tsexpired-expired.jar&quot;, &quot;expired&quot;)
 575                 .shouldContain(&quot;The signer certificate has expired.&quot;)
 576                 .shouldContain(&quot;The timestamp has expired.&quot;)
 577                 .shouldHaveExitValue(4);
 578         verify(&quot;tsexpired-expired.jar&quot;)
 579                 .shouldContain(&quot;signer certificate has expired&quot;)
 580                 .shouldContain(&quot;timestamp has expired.&quot;)
 581                 .shouldHaveExitValue(4);
 582 
 583         // TS expired but signer still good
 584         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
 585                 &quot;tsexpired-long.jar&quot;, &quot;long&quot;)
 586                 .shouldContain(&quot;The timestamp expired on&quot;)
 587                 .shouldHaveExitValue(0);
 588         verify(&quot;tsexpired-long.jar&quot;)
 589                 .shouldMatch(&quot;timestamp expired on.*However, the JAR will be valid&quot;)
 590                 .shouldNotContain(&quot;Error&quot;)
 591                 .shouldHaveExitValue(0);
 592 
 593         signVerbose(&quot;tsexpired&quot;, &quot;unsigned.jar&quot;,
 594                 &quot;tsexpired-ca.jar&quot;, &quot;ca&quot;)
 595                 .shouldContain(&quot;The timestamp has expired.&quot;)
 596                 .shouldHaveExitValue(4);
 597         verify(&quot;tsexpired-ca.jar&quot;)
 598                 .shouldNotContain(&quot;timestamp has expired&quot;)
 599                 .shouldNotContain(&quot;Error&quot;)
 600                 .shouldHaveExitValue(0);
 601 
 602         // Warning when expiring
 603         sign(&quot;tsexpiring&quot;)
 604                 .shouldContain(&quot;timestamp will expire within&quot;)
 605                 .shouldHaveExitValue(0);
 606         verify(&quot;tsexpiring.jar&quot;)
 607                 .shouldContain(&quot;timestamp will expire within&quot;)
 608                 .shouldNotContain(&quot;still valid&quot;)
 609                 .shouldHaveExitValue(0);
 610 
 611         signVerbose(&quot;tsexpiring&quot;, &quot;unsigned.jar&quot;,
 612                 &quot;tsexpiring-ca.jar&quot;, &quot;ca&quot;)
 613                 .shouldContain(&quot;self-signed&quot;)
 614                 .stderrShouldNotMatch(&quot;The.*expir&quot;)
 615                 .shouldHaveExitValue(4); // self-signed
 616         verify(&quot;tsexpiring-ca.jar&quot;)
 617                 .stderrShouldNotMatch(&quot;The.*expir&quot;)
 618                 .shouldHaveExitValue(0);
 619 
 620         signVerbose(&quot;tsexpiringsoon&quot;, &quot;unsigned.jar&quot;,
 621                 &quot;tsexpiringsoon-long.jar&quot;, &quot;long&quot;)
 622                 .shouldContain(&quot;The timestamp will expire&quot;)
 623                 .shouldHaveExitValue(0);
 624         verify(&quot;tsexpiringsoon-long.jar&quot;)
 625                 .shouldMatch(&quot;timestamp will expire.*However, the JAR will be valid until&quot;)
 626                 .shouldHaveExitValue(0);
 627 
 628         // Info for long
 629         sign(&quot;tslong&quot;)
 630                 .shouldNotContain(&quot;timestamp has expired&quot;)
 631                 .shouldNotContain(&quot;timestamp will expire within&quot;)
 632                 .shouldContain(&quot;timestamp will expire on&quot;)
 633                 .shouldContain(&quot;signer certificate will expire on&quot;)
 634                 .shouldHaveExitValue(0);
 635         verify(&quot;tslong.jar&quot;)
 636                 .shouldNotContain(&quot;timestamp has expired&quot;)
 637                 .shouldNotContain(&quot;timestamp will expire within&quot;)
 638                 .shouldNotContain(&quot;timestamp will expire on&quot;)
 639                 .shouldNotContain(&quot;signer certificate will expire on&quot;)
 640                 .shouldHaveExitValue(0);
 641         verify(&quot;tslong.jar&quot;, &quot;-verbose&quot;)
 642                 .shouldContain(&quot;timestamp will expire on&quot;)
 643                 .shouldContain(&quot;signer certificate will expire on&quot;)
 644                 .shouldHaveExitValue(0);
 645     }
 646 
 647     private static void checkInvalidTsaCertKeyUsage() throws Exception {
 648 
 649         // Hack: Rewrite the TSA cert inside normal.jar into ts2.jar.
 650 
 651         // Both the cert and the serial number must be rewritten.
 652         byte[] tsCert = Files.readAllBytes(Paths.get(&quot;ts.cert&quot;));
 653         byte[] ts2Cert = Files.readAllBytes(Paths.get(&quot;ts2.cert&quot;));
 654         byte[] tsSerial = getCert(tsCert)
 655                 .getSerialNumber().toByteArray();
 656         byte[] ts2Serial = getCert(ts2Cert)
 657                 .getSerialNumber().toByteArray();
 658 
 659         byte[] oldBlock;
 660         try (JarFile normal = new JarFile(&quot;normal.jar&quot;)) {
 661             oldBlock = normal.getInputStream(
 662                     normal.getJarEntry(&quot;META-INF/SIGNER.RSA&quot;)).readAllBytes();
 663         }
 664 
 665         JarUtils.updateJar(&quot;normal.jar&quot;, &quot;ts2.jar&quot;,
 666                 Map.of(&quot;META-INF/SIGNER.RSA&quot;,
 667                         updateBytes(updateBytes(oldBlock, tsCert, ts2Cert),
 668                                 tsSerial, ts2Serial)));
 669 
 670         verify(&quot;ts2.jar&quot;, &quot;-verbose&quot;, &quot;-certs&quot;)
 671                 .shouldHaveExitValue(64)
 672                 .shouldContain(&quot;jar verified&quot;)
 673                 .shouldContain(&quot;Invalid TSA certificate chain: Extended key usage does not permit use for TSA server&quot;);
 674     }
 675 
 676     public static X509Certificate getCert(byte[] data)
 677             throws CertificateException, IOException {
 678         return (X509Certificate)
 679                 CertificateFactory.getInstance(&quot;X.509&quot;)
 680                         .generateCertificate(new ByteArrayInputStream(data));
 681     }
 682 
 683     private static byte[] updateBytes(byte[] old, byte[] from, byte[] to) {
 684         int pos = 0;
 685         while (true) {
 686             if (pos + from.length &gt; old.length) {
 687                 return null;
 688             }
 689             if (Arrays.equals(Arrays.copyOfRange(old, pos, pos+from.length), from)) {
 690                 byte[] result = old.clone();
 691                 System.arraycopy(to, 0, result, pos, from.length);
 692                 return result;
 693             }
 694             pos++;
 695         }
 696     }
 697 
 698     private static void checkMissingOrInvalidFiles(String s)
 699             throws Throwable {
 700 
 701         JarUtils.updateJar(s, &quot;1.jar&quot;, Map.of(&quot;META-INF/SIGNER.SF&quot;, Boolean.FALSE));
 702         verify(&quot;1.jar&quot;, &quot;-verbose&quot;)
 703                 .shouldHaveExitValue(16)
 704                 .shouldContain(&quot;treated as unsigned&quot;)
 705                 .shouldContain(&quot;Missing signature-related file META-INF/SIGNER.SF&quot;);
 706         JarUtils.updateJar(s, &quot;2.jar&quot;, Map.of(&quot;META-INF/SIGNER.RSA&quot;, Boolean.FALSE));
 707         verify(&quot;2.jar&quot;, &quot;-verbose&quot;)
 708                 .shouldHaveExitValue(16)
 709                 .shouldContain(&quot;treated as unsigned&quot;)
 710                 .shouldContain(&quot;Missing block file for signature-related file META-INF/SIGNER.SF&quot;);
 711         JarUtils.updateJar(s, &quot;3.jar&quot;, Map.of(&quot;META-INF/SIGNER.SF&quot;, &quot;dummy&quot;));
 712         verify(&quot;3.jar&quot;, &quot;-verbose&quot;)
 713                 .shouldHaveExitValue(16)
 714                 .shouldContain(&quot;treated as unsigned&quot;)
 715                 .shouldContain(&quot;Unparsable signature-related file META-INF/SIGNER.SF&quot;);
 716         JarUtils.updateJar(s, &quot;4.jar&quot;, Map.of(&quot;META-INF/SIGNER.RSA&quot;, &quot;dummy&quot;));
 717         verify(&quot;4.jar&quot;, &quot;-verbose&quot;)
 718                 .shouldHaveExitValue(16)
 719                 .shouldContain(&quot;treated as unsigned&quot;)
 720                 .shouldContain(&quot;Unparsable signature-related file META-INF/SIGNER.RSA&quot;);
 721     }
 722 
 723     static OutputAnalyzer jarsigner(List&lt;String&gt; extra)
 724             throws Exception {
 725         List&lt;String&gt; args = new ArrayList&lt;&gt;(
 726                 List.of(&quot;-keystore&quot;, &quot;ks&quot;, &quot;-storepass&quot;, &quot;changeit&quot;));
 727         args.addAll(extra);
 728         return SecurityTools.jarsigner(args);
 729     }
 730 
 731     static OutputAnalyzer verify(String file, String... extra)
 732             throws Exception {
 733         List&lt;String&gt; args = new ArrayList&lt;&gt;();
 734         args.add(&quot;-verify&quot;);
 735         args.add(&quot;-strict&quot;);
 736         args.add(file);
 737         args.addAll(Arrays.asList(extra));
 738         return jarsigner(args);
 739     }
 740 
 741     static void checkBadKU(String file) throws Exception {
 742         verify(file)
 743                 .shouldHaveExitValue(16)
 744                 .shouldContain(&quot;treated as unsigned&quot;)
 745                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
 746         verify(file, &quot;-verbose&quot;)
 747                 .shouldHaveExitValue(16)
 748                 .shouldContain(&quot;Signed by&quot;)
 749                 .shouldContain(&quot;treated as unsigned&quot;)
 750                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
 751         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
 752                 .shouldHaveExitValue(16)
 753                 .shouldContain(&quot;SignatureException: Key usage restricted&quot;)
 754                 .shouldContain(&quot;treated as unsigned&quot;)
 755                 .shouldContain(&quot;re-run jarsigner with debug enabled&quot;);
 756     }
 757 
 758     static void checkDisabled(String file) throws Exception {
 759         verify(file)
 760                 .shouldHaveExitValue(16)
 761                 .shouldContain(&quot;treated as unsigned&quot;)
 762                 .shouldMatch(&quot;weak algorithm that is now disabled.&quot;)
 763                 .shouldMatch(&quot;Re-run jarsigner with the -verbose option for more details&quot;);
 764         verify(file, &quot;-verbose&quot;)
 765                 .shouldHaveExitValue(16)
 766                 .shouldContain(&quot;treated as unsigned&quot;)
 767                 .shouldMatch(&quot;weak algorithm that is now disabled by&quot;)
 768                 .shouldMatch(&quot;Digest algorithm: .*(disabled)&quot;)
 769                 .shouldMatch(&quot;Signature algorithm: .*(disabled)&quot;)
 770                 .shouldMatch(&quot;Timestamp digest algorithm: .*(disabled)&quot;)
 771                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
 772                 .shouldMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
 773         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
 774                 .shouldHaveExitValue(16)
 775                 .shouldMatch(&quot;SignatureException:.*disabled&quot;);
 776 
 777         // For 8171319: keytool should print out warnings when reading or
 778         //              generating cert/cert req using disabled algorithms.
 779         // Must call keytool the command, otherwise doPrintCert() might not
 780         // be able to reset &quot;jdk.certpath.disabledAlgorithms&quot;.
 781         String sout = SecurityTools.keytool(&quot;-printcert -jarfile &quot; + file)
 782                 .stderrShouldContain(&quot;The TSA certificate uses a 512-bit RSA key&quot; +
 783                         &quot; which is considered a security risk and is disabled.&quot;)
 784                 .getStdout();
 785         if (sout.indexOf(&quot;disabled&quot;, sout.indexOf(&quot;Timestamp:&quot;)) &lt; 0) {
 786             throw new RuntimeException(&quot;timestamp not disabled: &quot; + sout);
 787         }
 788     }
 789 
 790     static void checkHalfDisabled(String file) throws Exception {
 791         verify(file)
 792                 .shouldHaveExitValue(16)
 793                 .shouldContain(&quot;treated as unsigned&quot;)
 794                 .shouldMatch(&quot;weak algorithm that is now disabled.&quot;)
 795                 .shouldMatch(&quot;Re-run jarsigner with the -verbose option for more details&quot;);
 796         verify(file, &quot;-verbose&quot;)
 797                 .shouldHaveExitValue(16)
 798                 .shouldContain(&quot;treated as unsigned&quot;)
 799                 .shouldMatch(&quot;weak algorithm that is now disabled by&quot;)
 800                 .shouldMatch(&quot;Digest algorithm: .*(disabled)&quot;)
 801                 .shouldNotMatch(&quot;Signature algorithm: .*(weak)&quot;)
 802                 .shouldNotMatch(&quot;Signature algorithm: .*(disabled)&quot;)
 803                 .shouldNotMatch(&quot;Timestamp digest algorithm: .*(disabled)&quot;)
 804                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
 805                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(disabled).*(disabled)&quot;)
 806                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;)
 807                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
 808      }
 809 
 810     static void checkMultiple(String file) throws Exception {
 811         verify(file)
 812                 .shouldHaveExitValue(0)
 813                 .shouldContain(&quot;jar verified&quot;);
 814         verify(file, &quot;-verbose&quot;, &quot;-certs&quot;)
 815                 .shouldHaveExitValue(0)
 816                 .shouldContain(&quot;jar verified&quot;)
 817                 .shouldMatch(&quot;X.509.*CN=dsakey&quot;)
 818                 .shouldNotMatch(&quot;X.509.*CN=disabledkeysize&quot;)
 819                 .shouldMatch(&quot;Signed by .*CN=dsakey&quot;)
 820                 .shouldMatch(&quot;Signed by .*CN=disabledkeysize&quot;)
 821                 .shouldMatch(&quot;Signature algorithm: .*key.*(disabled)&quot;);
 822     }
 823 
 824     static void checkWeak(String file) throws Exception {
 825         verify(file)
 826                 .shouldHaveExitValue(0)
 827                 .shouldNotContain(&quot;treated as unsigned&quot;);
 828         verify(file, &quot;-verbose&quot;)
 829                 .shouldHaveExitValue(0)
 830                 .shouldNotContain(&quot;treated as unsigned&quot;)
 831                 .shouldMatch(&quot;Digest algorithm: .*(weak)&quot;)
 832                 .shouldMatch(&quot;Signature algorithm: .*(weak)&quot;)
 833                 .shouldMatch(&quot;Timestamp digest algorithm: .*(weak)&quot;)
 834                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
 835                 .shouldMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;);
 836         verify(file, &quot;-J-Djava.security.debug=jar&quot;)
 837                 .shouldHaveExitValue(0)
 838                 .shouldNotMatch(&quot;SignatureException:.*disabled&quot;);
 839 
 840         // keytool should print out warnings when reading or
 841         // generating cert/cert req using legacy algorithms.
 842         String sout = SecurityTools.keytool(&quot;-printcert -jarfile &quot; + file)
 843                 .stderrShouldContain(&quot;The TSA certificate uses a 1024-bit RSA key&quot; +
 844                         &quot; which is considered a security risk.&quot; +
 845                         &quot; This key size will be disabled in a future update.&quot;)
 846                 .getStdout();
 847         if (sout.indexOf(&quot;weak&quot;, sout.indexOf(&quot;Timestamp:&quot;)) &lt; 0) {
 848             throw new RuntimeException(&quot;timestamp not weak: &quot; + sout);
 849         }
 850     }
 851 
 852     static void checkHalfWeak(String file) throws Exception {
 853         verify(file)
 854                 .shouldHaveExitValue(0)
 855                 .shouldNotContain(&quot;treated as unsigned&quot;);
 856         verify(file, &quot;-verbose&quot;)
 857                 .shouldHaveExitValue(0)
 858                 .shouldNotContain(&quot;treated as unsigned&quot;)
 859                 .shouldMatch(&quot;Digest algorithm: .*(weak)&quot;)
 860                 .shouldNotMatch(&quot;Signature algorithm: .*(weak)&quot;)
 861                 .shouldNotMatch(&quot;Signature algorithm: .*(disabled)&quot;)
 862                 .shouldNotMatch(&quot;Timestamp digest algorithm: .*(weak)&quot;)
 863                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(weak).*(weak)&quot;)
 864                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*(disabled).*(disabled)&quot;)
 865                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(weak)&quot;)
 866                 .shouldNotMatch(&quot;Timestamp signature algorithm: .*key.*(disabled)&quot;);
 867     }
 868 
 869     static void checkMultipleWeak(String file) throws Exception {
 870         verify(file)
 871                 .shouldHaveExitValue(0)
 872                 .shouldContain(&quot;jar verified&quot;);
 873         verify(file, &quot;-verbose&quot;, &quot;-certs&quot;)
 874                 .shouldHaveExitValue(0)
 875                 .shouldContain(&quot;jar verified&quot;)
 876                 .shouldMatch(&quot;X.509.*CN=dsakey&quot;)
 877                 .shouldMatch(&quot;X.509.*CN=weakkeysize&quot;)
 878                 .shouldMatch(&quot;Signed by .*CN=dsakey&quot;)
 879                 .shouldMatch(&quot;Signed by .*CN=weakkeysize&quot;)
 880                 .shouldMatch(&quot;Signature algorithm: .*key.*(weak)&quot;);
 881     }
 882 
 883     static void checkTimestamp(String file, String policyId, String digestAlg)
 884             throws Exception {
 885         try (JarFile jf = new JarFile(file)) {
 886             JarEntry je = jf.getJarEntry(&quot;META-INF/SIGNER.RSA&quot;);
 887             try (InputStream is = jf.getInputStream(je)) {
 888                 byte[] content = is.readAllBytes();
 889                 PKCS7 p7 = new PKCS7(content);
 890                 SignerInfo[] si = p7.getSignerInfos();
 891                 if (si == null || si.length == 0) {
 892                     throw new Exception(&quot;Not signed&quot;);
 893                 }
 894                 PKCS9Attribute p9 = si[0].getUnauthenticatedAttributes()
 895                         .getAttribute(PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID);
 896                 PKCS7 tsToken = new PKCS7((byte[]) p9.getValue());
 897                 TimestampToken tt =
 898                         new TimestampToken(tsToken.getContentInfo().getData());
 899                 if (!tt.getHashAlgorithm().toString().equals(digestAlg)) {
 900                     throw new Exception(&quot;Digest alg different&quot;);
 901                 }
 902                 if (!tt.getPolicyID().equals(policyId)) {
 903                     throw new Exception(&quot;policyId different&quot;);
 904                 }
 905             }
 906         }
 907     }
 908 
 909     static int which = 0;
 910 
 911     /**
 912      * Sign with a TSA path. Always use alias &quot;signer&quot; to sign &quot;unsigned.jar&quot;.
 913      * The signed jar name is always path.jar.
 914      *
 915      * @param extra more args given to jarsigner
 916      */
 917     static OutputAnalyzer sign(String path, String... extra)
 918             throws Exception {
 919         return signVerbose(
 920                 path,
 921                 &quot;unsigned.jar&quot;,
 922                 path + &quot;.jar&quot;,
 923                 &quot;signer&quot;,
 924                 extra);
 925     }
 926 
 927     static OutputAnalyzer signVerbose(
 928             String path,    // TSA URL path
 929             String oldJar,
 930             String newJar,
 931             String alias,   // signer
 932             String...extra) throws Exception {
 933         which++;
 934         System.out.println(&quot;\n&gt;&gt; Test #&quot; + which);
 935         List&lt;String&gt; args = new ArrayList&lt;&gt;(List.of(
 936                 &quot;-strict&quot;, &quot;-verbose&quot;, &quot;-debug&quot;, &quot;-signedjar&quot;, newJar, oldJar, alias));
 937         if (path != null) {
 938             args.add(&quot;-tsa&quot;);
 939             args.add(host + path);
 940         }
 941         args.addAll(Arrays.asList(extra));
 942         return jarsigner(args);
 943     }
 944 
 945     static void prepare() throws Exception {
 946         JarUtils.createJar(&quot;unsigned.jar&quot;, &quot;A&quot;);
 947         Files.deleteIfExists(Paths.get(&quot;ks&quot;));
 948         keytool(&quot;-alias signer -genkeypair -ext bc -dname CN=signer&quot;);
 949         keytool(&quot;-alias oldsigner -genkeypair -dname CN=oldsigner&quot;);
 950         keytool(&quot;-alias dsakey -genkeypair -keyalg DSA -dname CN=dsakey&quot;);
 951         keytool(&quot;-alias weakkeysize -genkeypair -keysize 1024 -dname CN=weakkeysize&quot;);
 952         keytool(&quot;-alias disabledkeysize -genkeypair -keysize 512 -dname CN=disabledkeysize&quot;);
 953         keytool(&quot;-alias badku -genkeypair -dname CN=badku&quot;);
 954         keytool(&quot;-alias ts -genkeypair -dname CN=ts&quot;);
 955         keytool(&quot;-alias tsold -genkeypair -dname CN=tsold&quot;);
 956         keytool(&quot;-alias tsweak -genkeypair -keysize 1024 -dname CN=tsweak&quot;);
 957         keytool(&quot;-alias tsdisabled -genkeypair -keysize 512 -dname CN=tsdisabled&quot;);
 958         keytool(&quot;-alias tsbad1 -genkeypair -dname CN=tsbad1&quot;);
 959         keytool(&quot;-alias tsbad2 -genkeypair -dname CN=tsbad2&quot;);
 960         keytool(&quot;-alias tsbad3 -genkeypair -dname CN=tsbad3&quot;);
 961         keytool(&quot;-alias tsnoca -genkeypair -dname CN=tsnoca&quot;);
 962 
 963         keytool(&quot;-alias expired -genkeypair -dname CN=expired&quot;);
 964         keytool(&quot;-alias expiring -genkeypair -dname CN=expiring&quot;);
 965         keytool(&quot;-alias long -genkeypair -dname CN=long&quot;);
 966         keytool(&quot;-alias tsexpired -genkeypair -dname CN=tsexpired&quot;);
 967         keytool(&quot;-alias tsexpiring -genkeypair -dname CN=tsexpiring&quot;);
 968         keytool(&quot;-alias tsexpiringsoon -genkeypair -dname CN=tsexpiringsoon&quot;);
 969         keytool(&quot;-alias tslong -genkeypair -dname CN=tslong&quot;);
 970 
 971         // tsnoca&#39;s issuer will be removed from keystore later
 972         keytool(&quot;-alias ca -genkeypair -ext bc -dname CN=CA&quot;);
 973         gencert(&quot;tsnoca&quot;, &quot;-ext eku:critical=ts&quot;);
 974         keytool(&quot;-delete -alias ca&quot;);
 975         keytool(&quot;-alias ca -genkeypair -ext bc -dname CN=CA -startdate -40d&quot;);
 976 
 977         gencert(&quot;signer&quot;);
 978         gencert(&quot;oldsigner&quot;, &quot;-startdate -30d -validity 20&quot;);
 979         gencert(&quot;dsakey&quot;);
 980         gencert(&quot;weakkeysize&quot;);
 981         gencert(&quot;disabledkeysize&quot;);
 982         gencert(&quot;badku&quot;, &quot;-ext ku:critical=keyAgreement&quot;);
 983         gencert(&quot;ts&quot;, &quot;-ext eku:critical=ts -validity 500&quot;);
 984 
 985         gencert(&quot;expired&quot;, &quot;-validity 10 -startdate -12d&quot;);
 986         gencert(&quot;expiring&quot;, &quot;-validity 178&quot;);
 987         gencert(&quot;long&quot;, &quot;-validity 182&quot;);
 988         gencert(&quot;tsexpired&quot;, &quot;-ext eku:critical=ts -validity 10 -startdate -12d&quot;);
 989         gencert(&quot;tsexpiring&quot;, &quot;-ext eku:critical=ts -validity 364&quot;);
 990         gencert(&quot;tsexpiringsoon&quot;, &quot;-ext eku:critical=ts -validity 170&quot;); // earlier than expiring
 991         gencert(&quot;tslong&quot;, &quot;-ext eku:critical=ts -validity 367&quot;);
 992 
 993 
 994         for (int i = 0; i &lt; 5; i++) {
 995             // Issue another cert for &quot;ts&quot; with a different EKU.
 996             // Length might be different because serial number is
 997             // random. Try several times until a cert with the same
 998             // length is generated so we can substitute ts.cert
 999             // embedded in the PKCS7 block with ts2.cert.
1000             // If cannot create one, related test will be ignored.
1001             keytool(&quot;-gencert -alias ca -infile ts.req -outfile ts2.cert &quot; +
1002                     &quot;-ext eku:critical=1.3.6.1.5.5.7.3.9&quot;);
1003             if (Files.size(Paths.get(&quot;ts.cert&quot;)) != Files.size(Paths.get(&quot;ts2.cert&quot;))) {
1004                 Files.delete(Paths.get(&quot;ts2.cert&quot;));
1005                 System.out.println(&quot;Warning: cannot create same length&quot;);
1006             } else {
1007                 break;
1008             }
1009         }
1010 
1011         gencert(&quot;tsold&quot;, &quot;-ext eku:critical=ts -startdate -40d -validity 500&quot;);
1012 
1013         gencert(&quot;tsweak&quot;, &quot;-ext eku:critical=ts&quot;);
1014         gencert(&quot;tsdisabled&quot;, &quot;-ext eku:critical=ts&quot;);
1015         gencert(&quot;tsbad1&quot;);
1016         gencert(&quot;tsbad2&quot;, &quot;-ext eku=ts&quot;);
1017         gencert(&quot;tsbad3&quot;, &quot;-ext eku:critical=cs&quot;);
1018     }
1019 
1020     static void gencert(String alias, String... extra) throws Exception {
1021         keytool(&quot;-alias &quot; + alias + &quot; -certreq -file &quot; + alias + &quot;.req&quot;);
1022         String genCmd = &quot;-gencert -alias ca -infile &quot; +
1023                 alias + &quot;.req -outfile &quot; + alias + &quot;.cert&quot;;
1024         for (String s : extra) {
1025             genCmd += &quot; &quot; + s;
1026         }
1027         keytool(genCmd);
1028         keytool(&quot;-alias &quot; + alias + &quot; -importcert -file &quot; + alias + &quot;.cert&quot;);
1029     }
1030 
1031     static void keytool(String cmd) throws Exception {
1032         cmd = &quot;-keystore ks -storepass changeit -keypass changeit &quot; +
1033                 &quot;-keyalg rsa -validity 200 &quot; + cmd;
1034         sun.security.tools.keytool.Main.main(cmd.split(&quot; &quot;));
1035     }
1036 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/ec/ed/EdDSAReuseTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.security.KeyPair;
 25 import java.security.KeyPairGenerator;
 26 import java.security.PrivateKey;
 27 import java.security.PublicKey;
 28 import java.security.Signature;
 29 import java.security.spec.NamedParameterSpec;
 30 import java.util.ArrayList;
 31 import java.util.List;
 32 
 33 /*
 34  * @test
 35  * @bug 8209632
 36  * @summary Test behaviour of Signature instance by re-using it multiple times
 37  *          in different way.
 38  * @run main EdDSAReuseTest
 39  */
 40 public class EdDSAReuseTest {
 41 
 42     private static final String EDDSA = &quot;EdDSA&quot;;
 43     private static final String ED25519 = &quot;Ed25519&quot;;
 44     private static final String ED448 = &quot;Ed448&quot;;
 45     private static final String PROVIDER = &quot;SunEC&quot;;
 46     private static final String MSG = &quot;TEST&quot;;
 47     private static final int REUSE = 20;
 48     private static final int ONCE = 1;
 49     private static final int TENTH = 10;
 50     private static final int FIFTH = 5;
 51 
 52     public static void main(String[] args) throws Exception {
 53 
 54         for (boolean initKey : new boolean[]{true, false}) {
 55             // Sign and Verify with data update once
 56             test(PROVIDER, EDDSA, null, initKey, ONCE, ONCE);
 57             test(PROVIDER, ED25519, ED25519, initKey, ONCE, ONCE);
 58             test(PROVIDER, ED448, ED448, initKey, ONCE, ONCE);
 59 
 60             // Sign and Verify with data update 10 times
 61             test(PROVIDER, EDDSA, null, initKey, TENTH, TENTH);
 62             test(PROVIDER, ED25519, ED25519, initKey, TENTH, TENTH);
 63             test(PROVIDER, ED448, ED448, initKey, TENTH, TENTH);
 64 
 65             // Sign and Verify with data update unmatched number of times
 66             test(PROVIDER, EDDSA, null, initKey, TENTH, FIFTH);
 67             test(PROVIDER, ED25519, ED25519, initKey, TENTH, FIFTH);
 68             test(PROVIDER, ED448, ED448, initKey, TENTH, FIFTH);
 69         }
 70     }
 71 
 72     private static void test(String provider, String name, Object param,
 73             boolean initKey, int signUpdate, int verifyUpdate)
 74             throws Exception {
 75 
 76         System.out.printf(&quot;Case for signature name: %s, param: %s,&quot;
 77                 + &quot; initialize signature instance before each operation: %s%n&quot;,
 78                 name, param, initKey);
 79         KeyPairGenerator kpg = KeyPairGenerator.getInstance(name, provider);
 80         if (param != null) {
 81             kpg.initialize(new NamedParameterSpec((String) param));
 82         }
 83         KeyPair kp = kpg.generateKeyPair();
 84         Signature sig = Signature.getInstance(name, provider);
 85         testAPI(sig, kp, initKey, signUpdate, verifyUpdate);
 86         System.out.println(&quot;Passed.&quot;);
 87     }
 88 
 89     private static void testAPI(Signature sig, KeyPair kp, boolean initKey,
 90             int signUpdate, int verifyUpdate) throws Exception {
 91 
 92         sig.initSign(kp.getPrivate());
 93         List&lt;byte[]&gt; signatures = new ArrayList&lt;&gt;();
 94         // Re-use the signature instance 20 times
 95         for (int i = 0; i &lt; REUSE; i++) {
 96             signatures.add(sign(sig, kp.getPrivate(), MSG, initKey, signUpdate));
 97         }
 98         System.out.printf(&quot;Generated signatures %s times%n&quot;, signatures.size());
 99         sig.initVerify(kp.getPublic());
100         for (byte[] sign : signatures) {
101             // Verification will pass when message update matches with
102             // the same used for sign
103             if (verify(sig, kp.getPublic(), MSG, sign, initKey, verifyUpdate)
104                     != (signUpdate == verifyUpdate)) {
105                 throw new RuntimeException(
106                         &quot;Verification succed with unmatched message&quot;);
107             }
108         }
109         System.out.printf(&quot;Verified signatures %s times%n&quot;, signatures.size());
110     }
111 
112     private static byte[] sign(Signature sig, PrivateKey priKey, String msg,
113             boolean initKey, int signUpdate) throws Exception {
114         if (initKey) {
115             sig.initSign(priKey);
116         }
117         for (int update = 0; update &lt; signUpdate; update++) {
118             sig.update(msg.getBytes());
119         }
120         return sig.sign();
121     }
122 
123     private static boolean verify(Signature sig, PublicKey pubKey, String msg,
124             byte[] sign, boolean initKey, int verifyUpdate) throws Exception {
125         if (initKey) {
126             sig.initVerify(pubKey);
127         }
128         for (int update = 0; update &lt; verifyUpdate; update++) {
129             sig.update(msg.getBytes());
130         }
131         return sig.verify(sign);
132     }
133 }
    </pre>
  </body>
</html>
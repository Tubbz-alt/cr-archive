<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/ec/ed/EdDSAKeySize.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 import static javax.crypto.Cipher.PRIVATE_KEY;
 24 import static javax.crypto.Cipher.PUBLIC_KEY;
 25 import java.security.InvalidKeyException;
 26 import java.security.Key;
 27 import java.security.KeyFactory;
 28 import java.security.KeyPair;
 29 import java.security.KeyPairGenerator;
 30 import java.security.NoSuchAlgorithmException;
 31 import java.security.NoSuchProviderException;
 32 import java.security.SecureRandom;
 33 import java.security.interfaces.EdECPrivateKey;
 34 import java.security.interfaces.EdECPublicKey;
 35 import java.security.spec.PKCS8EncodedKeySpec;
 36 import java.security.spec.X509EncodedKeySpec;
 37 import java.security.spec.EdECPrivateKeySpec;
 38 import java.security.spec.EdECPublicKeySpec;
 39 import java.security.spec.InvalidKeySpecException;
 40 import java.security.spec.NamedParameterSpec;
 41 import java.util.Arrays;
 42 import jdk.test.lib.Convert;
 43 
 44 /*
 45  * @test
 46  * @bug 8209632
 47  * @summary Verify KeyLength for EDDSA, ED25519, ED448.
 48  * @library /test/lib
 49  * @build jdk.test.lib.Convert
 50  * @run main EdDSAKeySize
 51  */
 52 public class EdDSAKeySize {
 53 
 54     private static final String EDDSA = &quot;EDDSA&quot;;
 55     private static final String ED25519 = &quot;ED25519&quot;;
 56     private static final String ED448 = &quot;ED448&quot;;
 57     private static final String OIDN25519 = &quot;1.3.101.112&quot;;
 58     private static final String OID25519 = &quot;OID.1.3.101.112&quot;;
 59     private static final String OIDN448 = &quot;1.3.101.113&quot;;
 60     private static final String OID448 = &quot;OID.1.3.101.113&quot;;
 61     private static final String PROVIDER = &quot;SunEC&quot;;
 62     private static final SecureRandom RND = new SecureRandom(new byte[]{0x1});
 63 
 64     public static void main(String[] args) throws Exception {
 65 
 66         for (boolean initWithRandom : new boolean[]{true, false}) {
 67 
 68             // As per rfc8032 the generated keysize for ED25519 is
 69             // 32 octets(256 bits) and ED448 is 57 octets(456 bits).
 70             // Case with default parameter
 71             testKeyAttributes(PROVIDER, EDDSA, initWithRandom, null, 256);
 72             testKeyAttributes(PROVIDER, ED25519, initWithRandom, null, 256);
 73             testKeyAttributes(PROVIDER, ED448, initWithRandom, null, 456);
 74 
 75             // With named parameter
 76             testKeyAttributes(PROVIDER, EDDSA, initWithRandom, ED25519, 256);
 77             testKeyAttributes(PROVIDER, ED25519, initWithRandom, ED25519, 256);
 78             testKeyAttributes(PROVIDER, OIDN25519, initWithRandom, ED25519, 256);
 79             testKeyAttributes(PROVIDER, OID25519, initWithRandom, ED25519, 256);
 80             testKeyAttributes(PROVIDER, ED448, initWithRandom, ED448, 456);
 81             testKeyAttributes(PROVIDER, OIDN448, initWithRandom, ED448, 456);
 82             testKeyAttributes(PROVIDER, OID448, initWithRandom, ED448, 456);
 83 
 84             // With size parameter
 85             testKeyAttributes(PROVIDER, EDDSA, initWithRandom, 255, 256);
 86             testKeyAttributes(PROVIDER, ED25519, initWithRandom, 255, 256);
 87             testKeyAttributes(PROVIDER, OIDN25519, initWithRandom, 255, 256);
 88             testKeyAttributes(PROVIDER, OID25519, initWithRandom, 255, 256);
 89             testKeyAttributes(PROVIDER, ED448, initWithRandom, 448, 456);
 90             testKeyAttributes(PROVIDER, OIDN448, initWithRandom, 448, 456);
 91             testKeyAttributes(PROVIDER, OID448, initWithRandom, 448, 456);
 92         }
 93     }
 94 
 95     /**
 96      * Test standard Key attributes.
 97      */
 98     private static void testKeyAttributes(String provider, String name,
 99             boolean initWithRandom, Object param, int keySize) throws Exception {
100 
101         System.out.printf(&quot;Case name: %s, param: %s, Expected keysize: %s, &quot;
102                 + &quot;Initiate with random: %s%n&quot;, name, param, keySize,
103                 initWithRandom);
104         KeyPairGenerator kpg = KeyPairGenerator.getInstance(name, provider);
105         if (initWithRandom) {
106             if (param instanceof Integer) {
107                 kpg.initialize((Integer) param, RND);
108             } else if (param instanceof String) {
109                 kpg.initialize(new NamedParameterSpec((String) param), RND);
110             }
111         } else {
112             if (param instanceof Integer) {
113                 kpg.initialize((Integer) param);
114             } else if (param instanceof String) {
115                 kpg.initialize(new NamedParameterSpec((String) param));
116             }
117         }
118         KeyPair kp = kpg.generateKeyPair();
119         NamedParameterSpec namedSpec = getNamedParamSpec(name);
120 
121         // Verify original PrivateKey with it&#39;s different representation
122         Key[] privs = manipulateKey(provider, name, PRIVATE_KEY,
123                 kp.getPrivate(), namedSpec);
124         Arrays.stream(privs).forEach(
125                 priv -&gt; testPrivateKey((EdECPrivateKey) kp.getPrivate(),
126                         (EdECPrivateKey) priv, keySize));
127 
128         // Verify original PublicKey with it&#39;s different representation
129         Key[] pubs = manipulateKey(provider, name, PUBLIC_KEY,
130                 kp.getPublic(), namedSpec);
131         Arrays.stream(pubs).forEach(
132                 pub -&gt; testPublicKey((EdECPublicKey) kp.getPublic(),
133                         (EdECPublicKey) pub));
134         System.out.println(&quot;Passed.&quot;);
135     }
136 
137     private static NamedParameterSpec getNamedParamSpec(String algo) {
138         NamedParameterSpec namedSpec = switch (algo) {
139             case EDDSA
140                 , OIDN25519, OID25519 -&gt; new NamedParameterSpec(ED25519);
141             case OIDN448
142                 , OID448 -&gt; new NamedParameterSpec(ED448);
143             default-&gt;
144                 new NamedParameterSpec(algo);
145         };
146             return namedSpec;
147     }
148 
149     private static Key[] manipulateKey(String provider, String algo, int type,
150             Key key, NamedParameterSpec namedSpec)
151             throws NoSuchAlgorithmException, InvalidKeySpecException,
152             NoSuchProviderException, InvalidKeyException {
153 
154         KeyFactory kf = KeyFactory.getInstance(algo, provider);
155         switch (type) {
156             case PUBLIC_KEY:
157                 return new Key[]{
158                     kf.generatePublic(new X509EncodedKeySpec(key.getEncoded())),
159                     kf.generatePublic(kf.getKeySpec(
160                     key, EdECPublicKeySpec.class)),
161                     kf.generatePublic(new EdECPublicKeySpec(namedSpec,
162                     ((EdECPublicKey) key).getPoint())),
163                     kf.translateKey(key)
164                 };
165             case PRIVATE_KEY:
166                 return new Key[]{
167                     kf.generatePrivate(new PKCS8EncodedKeySpec(key.getEncoded())),
168                     kf.generatePrivate(
169                     kf.getKeySpec(key, EdECPrivateKeySpec.class)),
170                     kf.generatePrivate(new EdECPrivateKeySpec(namedSpec,
171                     ((EdECPrivateKey) key).getBytes().get())),
172                     kf.translateKey(key)
173                 };
174         }
175         throw new RuntimeException(&quot;We shouldn&#39;t reach here&quot;);
176     }
177 
178     /**
179      * Basic PrivateKey Test cases
180      */
181     private static void testPrivateKey(EdECPrivateKey orig,
182             EdECPrivateKey generated, int size) {
183 
184         equals(orig.getBytes().get().length * 8, size);
185         equals(generated.getBytes().get().length * 8, size);
186         equals(orig.getBytes().get(), generated.getBytes().get());
187         equals(orig.getFormat(), generated.getFormat());
188         equals(orig.getEncoded(), generated.getEncoded());
189         equals(((NamedParameterSpec) orig.getParams()).getName(),
190                 ((NamedParameterSpec) generated.getParams()).getName());
191     }
192 
193     /**
194      * Basic PublicKey Test cases
195      */
196     private static void testPublicKey(EdECPublicKey orig,
197             EdECPublicKey generated) {
198 
199         equals(orig.getPoint().getY(), generated.getPoint().getY());
200         equals(orig.getPoint().isXOdd(), generated.getPoint().isXOdd());
201         equals(orig.getFormat(), generated.getFormat());
202         equals(orig.getEncoded(), generated.getEncoded());
203         equals(((NamedParameterSpec) orig.getParams()).getName(),
204                 ((NamedParameterSpec) generated.getParams()).getName());
205     }
206 
207     private static void equals(Object actual, Object expected) {
208         if (!actual.equals(expected)) {
209             throw new RuntimeException(String.format(&quot;Actual: %s, Expected: %s&quot;,
210                     actual, expected));
211         }
212     }
213 
214     private static void equals(byte[] actual, byte[] expected) {
215         if (!Arrays.equals(actual, expected)) {
216             throw new RuntimeException(String.format(&quot;Actual array: %s, &quot;
217                     + &quot;Expected array:%s&quot;, Convert.byteArrayToHexString(actual),
218                     Convert.byteArrayToHexString(expected)));
219         }
220     }
221 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/ec/ed/EdECKeyFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8166597
 27  * @summary Check for correct formatting of EdDSA keys
 28  * @library /test/lib
 29  * @build jdk.test.lib.Convert
 30  * @modules java.base/sun.security.util
 31  * @run main EdECKeyFormat
 32  */
 33 
 34 import java.security.*;
 35 import java.security.spec.*;
 36 import java.security.interfaces.*;
 37 import java.io.*;
 38 import java.nio.file.*;
 39 import java.math.*;
 40 import java.util.*;
 41 
 42 import jdk.test.lib.Convert;
 43 
 44 import sun.security.util.*;
 45 
 46 public class EdECKeyFormat {
 47 
 48     private interface Test {
 49         public void runTest(Provider p) throws Exception;
 50     }
 51 
 52     private static void forEachProvider(Test t, String algName)
 53         throws Exception {
 54 
 55         int tested = 0;
 56         for (Provider p : Security.getProviders()) {
 57             Provider.Service s = p.getService(&quot;KeyPairGenerator&quot;, algName);
 58             if (s != null) {
 59                 t.runTest(p);
 60                 tested++;
 61             }
 62         }
 63         if (tested == 0) {
 64             throw new RuntimeException(&quot;no service found for &quot; + algName);
 65         }
 66     }
 67 
 68     private static Map&lt;String, String&gt; privKeys = Map.of(
 69         &quot;Ed25519&quot;,
 70         &quot;302e020100300506032b657004220420d4ee72dbf913584ad5b6d8f1f769f8ad3afe&quot; +
 71         &quot;7c28cbf1d4fbe097a88f44755842&quot;,
 72         &quot;Ed448&quot;,
 73         &quot;3047020100300506032b6571043b043980998f387e05852d217c1d715b177c24aa7b&quot; +
 74         &quot;f3f4c3a72223f4983597b9ab2ed4793c30d871c24388b380d80bb36d963f5c276219&quot; +
 75         &quot;b0677fed00&quot;
 76     );
 77 
 78     private static List&lt;String&gt; pubKeys = List.of(
 79         &quot;302a300506032b657003210019bf44096984cdfe8541bac167dc3b96c85086aa30b6&quot; +
 80         &quot;b6cb0c5c38ad703166e1&quot;
 81     );
 82 
 83     public static void main(String[] args) throws Exception {
 84         privKeyTest(&quot;Ed25519&quot;);
 85         privKeyTest(&quot;Ed448&quot;);
 86         pubKeyTest();
 87     }
 88 
 89     private static void pubKeyTest() throws Exception {
 90         forEachProvider(EdECKeyFormat::pubKeyTest, &quot;EdDSA&quot;);
 91     }
 92 
 93     private static void pubKeyTest(Provider p) throws Exception {
 94         for (String s : pubKeys) {
 95             pubKeyTest(p, s);
 96         }
 97     }
 98 
 99     private static void pubKeyTest(Provider p, String key) throws Exception {
100         // ensure that a properly-formatted key can be read
101         byte[] encodedKey = Convert.hexStringToByteArray(key);
102         X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encodedKey);
103         KeyFactory kf = KeyFactory.getInstance(&quot;EdDSA&quot;, p);
104         kf.generatePublic(keySpec);
105     }
106 
107     private static void privKeyTest(String algName) throws Exception {
108 
109         forEachProvider(p -&gt; privKeyTest(algName, p), algName);
110     }
111 
112     private static void privKeyTest(String algName, Provider p)
113         throws Exception {
114 
115         System.out.println(&quot;Testing &quot; + algName + &quot; in &quot; + p.getName());
116 
117         // ensure format produced is correct
118         KeyPairGenerator kpg = KeyPairGenerator.getInstance(algName, p);
119         KeyPair kp = kpg.generateKeyPair();
120         PrivateKey priv = kp.getPrivate();
121         checkPrivKeyFormat(priv.getEncoded());
122         KeyFactory kf = KeyFactory.getInstance(algName, p);
123         PKCS8EncodedKeySpec keySpec =
124             kf.getKeySpec(priv, PKCS8EncodedKeySpec.class);
125         checkPrivKeyFormat(keySpec.getEncoded());
126 
127         // ensure that a properly-formatted key can be read
128         byte[] encodedKey = Convert.hexStringToByteArray(privKeys.get(algName));
129         keySpec = new PKCS8EncodedKeySpec(encodedKey);
130         kf.generatePrivate(keySpec);
131     }
132 
133     private static void checkPrivKeyFormat(byte[] key) throws IOException {
134         // key value should be nested octet strings
135         DerValue val = new DerValue(new ByteArrayInputStream(key));
136         BigInteger version = val.data.getBigInteger();
137         DerValue algId = val.data.getDerValue();
138         byte[] keyValue = val.data.getOctetString();
139         val = new DerValue(new ByteArrayInputStream(keyValue));
140         if (val.tag != DerValue.tag_OctetString) {
141             throw new RuntimeException(&quot;incorrect format&quot;);
142         }
143     }
144 }
    </pre>
  </body>
</html>
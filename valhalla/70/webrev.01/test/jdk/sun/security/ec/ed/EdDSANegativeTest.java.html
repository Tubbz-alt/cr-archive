<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/ec/ed/EdDSANegativeTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.security.InvalidKeyException;
 25 import java.security.InvalidParameterException;
 26 import java.security.KeyFactory;
 27 import java.security.KeyPair;
 28 import java.security.KeyPairGenerator;
 29 import java.security.NoSuchAlgorithmException;
 30 import java.security.PrivateKey;
 31 import java.security.PublicKey;
 32 import java.security.Signature;
 33 import java.security.interfaces.EdECPrivateKey;
 34 import java.security.interfaces.EdECPublicKey;
 35 import java.security.spec.EdDSAParameterSpec;
 36 import java.util.Arrays;
 37 import jdk.test.lib.Convert;
 38 
 39 /*
 40  * @test
 41  * @bug 8209632
 42  * @summary Negative cases for EDDSA.
 43  * @library /test/lib
 44  * @build jdk.test.lib.Convert
 45  * @run main EdDSANegativeTest
 46  */
 47 public class EdDSANegativeTest {
 48 
 49     private static final String EDDSA = &quot;EdDSA&quot;;
 50     private static final String ED25519 = &quot;Ed25519&quot;;
 51     private static final String ED448 = &quot;Ed448&quot;;
 52     private static final String PROVIDER = &quot;SunEC&quot;;
 53     private static final String OTHER = &quot;other&quot;;
 54     private static final byte[] MSG = &quot;TEST&quot;.getBytes();
 55 
 56     public static void main(String[] args) throws Exception {
 57         byName();
 58         byParam();
 59         byInvalidKey();
 60         byInvalidKeyType();
 61     }
 62 
 63     private static void byName() throws Exception {
 64 
 65         for (String name : new String[]{null, &quot;&quot;, &quot;EDDSA&quot;, &quot;eddsa&quot;, &quot;EDdsa&quot;,
 66             EDDSA, ED25519, &quot;ed25519&quot;, &quot;ED25519&quot;, ED448, &quot;eD448&quot;, &quot;ED448&quot;,
 67             &quot;ed448&quot;, OTHER}) {
 68             try {
 69                 KeyPair kp = genKeyPair(name);
 70                 KeyFactory kf = KeyFactory.getInstance(name, PROVIDER);
 71                 EdECPrivateKey edPri
 72                         = (EdECPrivateKey) kf.translateKey(kp.getPrivate());
 73                 EdECPublicKey edPub
 74                         = (EdECPublicKey) kf.translateKey(kp.getPublic());
 75                 Signature sig = Signature.getInstance(name, PROVIDER);
 76                 byte[] computedSig = sign(sig, edPri, MSG);
 77                 if (!verify(sig, edPub, MSG, computedSig)) {
 78                     throw new RuntimeException(&quot;Signature verification failed&quot;);
 79                 }
 80                 if (name == null || &quot;&quot;.equals(name)) {
 81                     throw new RuntimeException(
 82                             &quot;Should not reach here for algo: &quot; + name);
 83                 }
 84                 System.out.println(&quot;Passed: byName: &quot; + name);
 85             } catch (NullPointerException e) {
 86                 if (name != null) {
 87                     throw new RuntimeException(
 88                             &quot;Unknown issue with algo name: &quot; + name, e);
 89                 }
 90             } catch (NoSuchAlgorithmException e) {
 91                 if (!(&quot;&quot;.equals(name) || OTHER.equals(name))) {
 92                     throw new RuntimeException(
 93                             &quot;Unknown issue with algo name: &quot; + name, e);
 94                 }
 95             }
 96         }
 97     }
 98 
 99     private static void byParam() throws Exception {
100         testParam(EDDSA);
101         testParam(ED25519);
102         testParam(ED448);
103     }
104 
105     private static void byInvalidKey() throws Exception {
106         testInvalidKey(EDDSA);
107         testInvalidKey(ED25519);
108         testInvalidKey(ED448);
109     }
110 
111     private static void byInvalidKeyType() throws Exception {
112         testInvalidKeyType(EDDSA);
113         testInvalidKeyType(ED25519);
114         testInvalidKeyType(ED448);
115     }
116 
117     /**
118      * Test Signature.
119      */
120     private static void testParam(String name) throws Exception {
121 
122         KeyPair kp = genKeyPair(name);
123         Signature sig = Signature.getInstance(name, PROVIDER);
124         // Set initial paramter to generate a signature
125         EdDSAParameterSpec initParam
126                 = new EdDSAParameterSpec(true, &quot;testContext&quot;.getBytes());
127         sig.setParameter(initParam);
128         byte[] computedSig = sign(sig, kp.getPrivate(), MSG);
129         // Signature should not get verified other than same parameter
130         // which is set through the signature instance.
131         for (boolean preHash : new boolean[]{true, false}) {
132             // Test case with prehash as parameter without context set.
133             verify(sig, kp.getPublic(), MSG, new EdDSAParameterSpec(preHash),
134                     initParam, computedSig);
135             // Test Case with Context combined of different sizes.
136             // As per rfc8032, value of context is maximum of 255 octet
137             for (byte[] context : new byte[][]{{}, &quot;other&quot;.getBytes(),
138             new byte[255], new byte[500]}) {
139                 System.out.printf(&quot;Testing signature for name: %s, algorithm &quot;
140                         + &quot;spec: (prehash:%s, context:%s)%n&quot;, name, preHash,
141                         Convert.byteArrayToHexString(context));
142                 try {
143                     verify(sig, kp.getPublic(), MSG,
144                             new EdDSAParameterSpec(preHash, context),
145                             initParam, computedSig);
146                 } catch (InvalidParameterException e) {
147                     if (context.length &lt;= 255) {
148                         throw new RuntimeException(&quot;Should not throw exception &quot;
149                                 + &quot;when context size &lt;= 255 octet: &quot;
150                                 + context.length);
151                     }
152                 }
153             }
154         }
155     }
156 
157     private static void testInvalidKey(String name) throws Exception {
158         KeyPair kp = genKeyPair(name);
159         KeyPair kp1 = genKeyPair(name);
160         Signature sig = Signature.getInstance(name, PROVIDER);
161         byte[] computedSig = sign(sig, kp.getPrivate(), MSG);
162         if (verify(sig, kp1.getPublic(), MSG, computedSig)) {
163             throw new RuntimeException(&quot;Signature verification failed &quot;
164                     + &quot;for unpaired key.&quot;);
165         }
166         System.out.println(&quot;Passed: testInvalidKey: &quot; + name);
167     }
168 
169     private static void testInvalidKeyType(String name) throws Exception {
170 
171         KeyFactory kf = KeyFactory.getInstance(name, PROVIDER);
172         try {
173             kf.translateKey(new InvalidPrivateKey());
174         } catch (InvalidKeyException e) {
175             // Expected exception and not to be handled
176         }
177         try {
178             kf.translateKey(new InvalidPublicKey());
179         } catch (InvalidKeyException e) {
180             // Expected exception and not to be handled
181         }
182         System.out.println(&quot;Passed: testInvalidKeyType: &quot; + name);
183     }
184 
185     private static KeyPair genKeyPair(String name) throws Exception {
186         KeyPairGenerator kpg = KeyPairGenerator.getInstance(name, PROVIDER);
187         return kpg.generateKeyPair();
188     }
189 
190     private static byte[] sign(Signature sig, PrivateKey priKey, byte[] msg)
191             throws Exception {
192         sig.initSign(priKey);
193         sig.update(msg);
194         return sig.sign();
195     }
196 
197     private static boolean verify(Signature sig, PublicKey pubKey, byte[] msg,
198             byte[] sign) throws Exception {
199         sig.initVerify(pubKey);
200         sig.update(msg);
201         return sig.verify(sign);
202     }
203 
204     private static void verify(Signature sig, PublicKey pubKey, byte[] msg,
205             EdDSAParameterSpec params, EdDSAParameterSpec initParam,
206             byte[] computedSig) throws Exception {
207 
208         sig.setParameter(params);
209         if (verify(sig, pubKey, msg, computedSig)) {
210             byte[] context = params.getContext().isPresent()
211                     ? params.getContext().get() : null;
212             byte[] initContext = initParam.getContext().isPresent()
213                     ? initParam.getContext().get() : null;
214             boolean preHash = params.isPrehash();
215             boolean initPreHash = initParam.isPrehash();
216             // The signature should not get verified with other parameters
217             // set through signature instance.
218             if (!(equals(context, initContext) &amp;&amp; equals(preHash, initPreHash))) {
219                 throw new RuntimeException(String.format(&quot;Signature verification&quot;
220                         + &quot; success with different param context(actual:%s, &quot;
221                         + &quot;expected:%s), Prehash(actual:%s, expected:%s)&quot;,
222                         Convert.byteArrayToHexString(context),
223                         Convert.byteArrayToHexString(initContext),
224                         preHash, initPreHash));
225             } else {
226                 System.out.println(&quot;Atleast a case matched&quot;);
227             }
228         }
229     }
230 
231     private static boolean equals(Object actual, Object expected) {
232         if (actual == expected) {
233             return true;
234         }
235         if (actual == null || expected == null) {
236             return false;
237         }
238         boolean equals = actual.equals(expected);
239         if (!equals) {
240             throw new RuntimeException(String.format(&quot;Actual: %s, Expected: %s&quot;,
241                     actual, expected));
242         }
243         return equals;
244     }
245 
246     private static boolean equals(byte[] actual, byte[] expected) {
247         if (actual == expected) {
248             return true;
249         }
250         if (actual == null || expected == null) {
251             return false;
252         }
253         boolean equals = Arrays.equals(actual, expected);
254         if (!equals) {
255             throw new RuntimeException(String.format(&quot;Actual array: %s, &quot;
256                     + &quot;Expected array:%s&quot;, Convert.byteArrayToHexString(actual),
257                     Convert.byteArrayToHexString(expected)));
258         }
259         return equals;
260     }
261 
262     private static class InvalidPrivateKey implements PrivateKey {
263 
264         @Override
265         public String getAlgorithm() {
266             return &quot;test&quot;;
267         }
268 
269         @Override
270         public String getFormat() {
271             return &quot;test&quot;;
272         }
273 
274         @Override
275         public byte[] getEncoded() {
276             return &quot;test&quot;.getBytes();
277         }
278 
279     }
280 
281     private static class InvalidPublicKey implements PublicKey {
282 
283         @Override
284         public String getAlgorithm() {
285             return &quot;test&quot;;
286         }
287 
288         @Override
289         public String getFormat() {
290             return &quot;test&quot;;
291         }
292 
293         @Override
294         public byte[] getEncoded() {
295             return &quot;test&quot;.getBytes();
296         }
297 
298     }
299 }
    </pre>
  </body>
</html>
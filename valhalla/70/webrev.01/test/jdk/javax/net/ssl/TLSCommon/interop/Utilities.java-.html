<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/javax/net/ssl/TLSCommon/interop/Utilities.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.ByteArrayInputStream;
 25 import java.io.File;
 26 import java.io.IOException;
 27 import java.io.InputStream;
 28 import java.io.OutputStream;
 29 import java.lang.reflect.Array;
 30 import java.nio.charset.Charset;
 31 import java.nio.charset.StandardCharsets;
 32 import java.nio.file.Files;
 33 import java.nio.file.Path;
 34 import java.security.KeyFactory;
 35 import java.security.KeyStore;
 36 import java.security.KeyStoreException;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.PrivateKey;
 39 import java.security.cert.Certificate;
 40 import java.security.cert.CertificateException;
 41 import java.security.cert.CertificateFactory;
 42 import java.security.spec.InvalidKeySpecException;
 43 import java.security.spec.PKCS8EncodedKeySpec;
 44 import java.util.Arrays;
 45 import java.util.Base64;
 46 import java.util.Optional;
 47 import java.util.StringJoiner;
 48 import java.util.concurrent.TimeUnit;
 49 import java.util.function.Function;
 50 import java.util.function.Predicate;
 51 import java.util.stream.Collectors;
 52 
 53 import javax.net.ssl.KeyManagerFactory;
 54 import javax.net.ssl.SSLContext;
 55 import javax.net.ssl.TrustManagerFactory;
 56 
 57 import jdk.test.lib.process.OutputAnalyzer;
 58 
 59 /*
 60  * Utilities for interop testing.
 61  */
 62 public class Utilities {
 63 
 64     public static final String JAVA_HOME = System.getProperty(&quot;java.home&quot;);
 65     public static final String JAVA
 66             = String.join(File.separator, JAVA_HOME, &quot;bin&quot;, &quot;java&quot;);
 67     public static final String JAVAC
 68             = String.join(File.separator, JAVA_HOME, &quot;bin&quot;, &quot;javac&quot;);
 69 
 70     public static final String TEST_SRC = System.getProperty(&quot;test.src&quot;);
 71     public static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;);
 72     public static final String TEST_CLASSPATH = System.getProperty(&quot;test.class.path&quot;);
 73 
 74     public static final Charset CHARSET = StandardCharsets.UTF_8;
 75 
 76     public static final boolean DEBUG = Boolean.getBoolean(&quot;test.debug&quot;);
 77     public static final int TIMEOUT = Integer.getInteger(&quot;test.timeout&quot;, 20);
 78     public static final String LOG_PATH = System.getProperty(&quot;test.log.path&quot;);
 79 
 80     public static final String PARAM_DELIMITER = &quot;;&quot;;
 81     public static final String VALUE_DELIMITER = &quot;,&quot;;
 82 
 83     public static final CipherSuite[] ALL_CIPHER_SUITES
 84             = Utilities.getAllCipherSuites();
 85 
 86     /*
 87      * Gets all supported cipher suites.
 88      */
 89     private static CipherSuite[] getAllCipherSuites() {
 90         String[] supportedCipherSuites;
 91         try {
 92             supportedCipherSuites = SSLContext.getDefault()
 93                     .createSSLEngine()
 94                     .getSupportedCipherSuites();
 95         } catch (NoSuchAlgorithmException e) {
 96             throw new RuntimeException(
 97                     &quot;Failed to get supported cipher suites&quot;, e);
 98         }
 99 
100         CipherSuite[] cipherSuites = Arrays.stream(supportedCipherSuites)
101                 .map(cipherSuite -&gt; {
102                     return CipherSuite.cipherSuite(cipherSuite);})
103                 .filter(cipherSuite -&gt; {
104                     return cipherSuite
105                             != CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV;})
106                 .toArray(CipherSuite[]::new);
107 
108         return cipherSuites;
109     }
110 
111     /*
112      * Creates SSL context with the specified certificates.
113      */
114     public static SSLContext createSSLContext(CertTuple certTuple)
115             throws Exception {
116         KeyStore trustStore = createTrustStore(certTuple.trustedCerts);
117         TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;PKIX&quot;);
118         tmf.init(trustStore);
119 
120         KeyStore keyStore = createKeyStore(certTuple.endEntityCerts);
121         KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;NewSunX509&quot;);
122         kmf.init(keyStore, null);
123 
124         SSLContext context = SSLContext.getInstance(&quot;TLS&quot;);
125         context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
126         return context;
127     }
128 
129     /*
130      * Creates trust store with the specified certificates.
131      */
132     public static KeyStore createTrustStore(Cert... certs)
133             throws KeyStoreException, IOException, NoSuchAlgorithmException,
134             CertificateException {
135         KeyStore trustStore = KeyStore.getInstance(&quot;PKCS12&quot;);
136         trustStore.load(null, null);
137 
138         if (certs != null) {
139             for (int i = 0; i &lt; certs.length; i++) {
140                 if (certs[i] != null) {
141                     trustStore.setCertificateEntry(&quot;trust-&quot; + i,
142                             createCert(certs[i]));
143                 }
144             }
145         }
146 
147         return trustStore;
148     }
149 
150     /*
151      * Creates key store with the specified certificates.
152      */
153     public static KeyStore createKeyStore(Cert... certs)
154             throws KeyStoreException, IOException, NoSuchAlgorithmException,
155             CertificateException, InvalidKeySpecException {
156         KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;);
157         keyStore.load(null, null);
158 
159         if (certs != null) {
160             for (int i = 0; i &lt; certs.length; i++) {
161                 if (certs[i] != null) {
162                     keyStore.setKeyEntry(&quot;cert-&quot; + i, createKey(certs[i]), null,
163                             new Certificate[] { createCert(certs[i]) });
164                 }
165             }
166         }
167 
168         return keyStore;
169     }
170 
171     /*
172      * Creates Certificate instance with the specified certificate.
173      */
174     public static Certificate createCert(Cert cert) {
175         try {
176             CertificateFactory certFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
177             return certFactory.generateCertificate(
178                     new ByteArrayInputStream(cert.certMaterials.getBytes()));
179         } catch (CertificateException e) {
180             throw new RuntimeException(&quot;Create cert failed: &quot; + cert, e);
181         }
182     }
183 
184     /*
185      * Creates PrivateKey instance with the specified certificate.
186      */
187     public static PrivateKey createKey(Cert cert)
188             throws NoSuchAlgorithmException, InvalidKeySpecException {
189         PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(
190                 Base64.getMimeDecoder().decode(cert.keyMaterials));
191         KeyFactory keyFactory = KeyFactory.getInstance(
192                 cert.keyAlgo.name);
193         PrivateKey privKey = keyFactory.generatePrivate(privKeySpec);
194         return privKey;
195     }
196 
197     /*
198      * Reads an input stream, in which the content length isn&#39;t more than 1024.
199      */
200     public static String readIn(InputStream input) throws IOException {
201         byte[] buf = new byte[1024];
202         int length = input.read(buf);
203         if (length &gt; 0) {
204             return new String(buf, 0, length);
205         } else {
206             return &quot;&quot;;
207         }
208     }
209 
210     /*
211      * Writes the specified content to an output stream.
212      */
213     public static void writeOut(OutputStream output, String content)
214             throws IOException {
215         output.write(content.getBytes(Utilities.CHARSET));
216         output.flush();
217     }
218 
219     /*
220      *  Sleeps until the condition is true or getting timeout.
221      */
222     public static &lt;T&gt; boolean waitFor(Predicate&lt;T&gt; predicate, T t) {
223         long deadline = System.currentTimeMillis() + Utilities.TIMEOUT * 1000;
224         while (!predicate.test(t) &amp;&amp; System.currentTimeMillis() &lt; deadline) {
225             try {
226                 TimeUnit.SECONDS.sleep(1);
227             } catch (InterruptedException e) {
228                 throw new RuntimeException(&quot;Sleep is interrupted.&quot;, e);
229             }
230         }
231 
232         return predicate.test(t);
233     }
234 
235     /*
236      * Converts Enum array to string array.
237      * The string elements are the Enum names.
238      */
239     public static String[] enumsToStrs(Enum&lt;?&gt;... elements) {
240         return enumsToStrs(element -&gt; {
241             return element.name();
242         }, elements);
243     }
244 
245     /*
246      * Converts NamedGroup array to string array.
247      * The string elements are the NameGroups&#39; names.
248      */
249     public static String[] namedGroupsToStrs(NamedGroup... namedGroups) {
250         return enumsToStrs(namedGroup -&gt; {
251             return ((NamedGroup) namedGroup).name;
252         }, namedGroups);
253     }
254 
255     /*
256      * Converts Enum array to string array.
257      * The string elements are determined by the specified Function.
258      */
259     public static String[] enumsToStrs(Function&lt;Enum&lt;?&gt;, String&gt; function,
260             Enum&lt;?&gt;... elements) {
261         return elements == null
262                 ? null
263                 : Arrays.stream(elements).map(function).toArray(String[]::new);
264     }
265 
266     /*
267      * Converts string array to Enum array.
268      */
269     @SuppressWarnings(&quot;unchecked&quot;)
270     public static &lt;T extends Enum&lt;T&gt;&gt; T[] strToEnums(Class&lt;T&gt; enumType,
271             String namesStr) {
272         if (namesStr == null) {
273             return null;
274         }
275 
276         return Arrays.stream(namesStr.split(VALUE_DELIMITER)).map(name -&gt; {
277             return Enum.valueOf(enumType, name);
278         }).collect(Collectors.toList()).toArray(
279                 (T[]) Array.newInstance(enumType, 0));
280     }
281 
282     /*
283      * Executes shell command and return a OutputAnalyzer wrapping the process.
284      */
285     public static OutputAnalyzer shell(String command) throws IOException {
286         Process process = shellProc(command);
287         OutputAnalyzer oa = new OutputAnalyzer(process);
288         try {
289             process.waitFor();
290             return oa;
291         } catch (InterruptedException e) {
292             throw new RuntimeException(&quot;Shell process is interruptted!&quot;, e);
293         }
294     }
295 
296     /*
297      * Executes shell command and redirect the output to a local file,
298      * and return the process.
299      */
300     public static Process shellProc(String command, Path outputPath)
301             throws IOException {
302         String[] cmds = new String[3];
303         cmds[0] = &quot;sh&quot;;
304         cmds[1] = &quot;-c&quot;;
305         cmds[2] = command;
306         if (DEBUG) {
307             System.out.println(&quot;[sh -c &quot; + command + &quot;]&quot;);
308         }
309         ProcessBuilder pb = new ProcessBuilder(cmds);
310         pb.redirectErrorStream(true);
311         if (outputPath != null) {
312             pb.redirectOutput(outputPath.toFile());
313         }
314         return pb.start();
315     }
316 
317     /*
318      * Executes shell command and return the process.
319      */
320     public static Process shellProc(String command) throws IOException {
321         return shellProc(command, null);
322     }
323 
324     /*
325      * Determines if the specified process is alive.
326      */
327     public static boolean isAliveProcess(Process process) {
328         return process != null &amp;&amp; process.isAlive();
329     }
330 
331     /*
332      * Destroys the specified process and the associated child processes.
333      */
334     public static void destroyProcess(Process process) {
335         process.children().forEach(ProcessHandle::destroy);
336         process.destroy();
337     }
338 
339     /*
340      * Reads the content for the specified file.
341      */
342     public static Optional&lt;String&gt; readFile(Path path) throws IOException {
343         if (!Files.exists(path)) {
344             return Optional.empty();
345         } else {
346             return Optional.of(new String(Files.readAllBytes(path)));
347         }
348     }
349 
350     /*
351      * Tries to delete the specified file before getting timeout,
352      * in case that the file is not released by some process in time.
353      */
354     public static void deleteFile(Path filePath) throws IOException {
355         if (filePath == null) {
356             return;
357         }
358 
359         waitFor(path -&gt; delete(path), filePath);
360         if (Files.exists(filePath)) {
361             throw new IOException(
362                     &quot;File is not deleted in time: &quot; + filePath.toAbsolutePath());
363         }
364     }
365 
366     private static boolean delete(Path filePath) {
367         boolean deleted = false;
368         try {
369             deleted = Files.deleteIfExists(filePath);
370         } catch (IOException e) {
371             e.printStackTrace(System.out);
372         }
373 
374         return deleted;
375     }
376 
377     /*
378      * Determines if the TLS session is resumed.
379      */
380     public static boolean isSessionResumed(ResumptionMode mode,
381             byte[] firstSessionId, byte[] secondSessionId,
382             long secondConnStartTime, long secondSessionCreationTime) {
383         System.out.println(&quot;ResumptionMode: &quot; + mode);
384         System.out.println(&quot;firstSessionId: &quot; + Arrays.toString(firstSessionId));
385         System.out.println(&quot;secondSessionId: &quot; + Arrays.toString(secondSessionId));
386         System.out.println(&quot;secondConnStartTime: &quot; + secondConnStartTime);
387         System.out.println(&quot;secondSessionCreationTime: &quot; + secondSessionCreationTime);
388 
389         boolean resumed = secondConnStartTime &gt; secondSessionCreationTime;
390         if (mode == ResumptionMode.ID) {
391             resumed = resumed &amp;&amp; firstSessionId.length &gt; 0
392                     &amp;&amp; Arrays.equals(firstSessionId, secondSessionId);
393         }
394         return resumed;
395     }
396 
397     @SuppressWarnings(&quot;unchecked&quot;)
398     public static &lt;T&gt; String join(String delimiter, Function&lt;T, String&gt; toStr,
399             T... elements) {
400         if (elements == null) {
401             return &quot;&quot;;
402         }
403 
404         StringJoiner joiner = new StringJoiner(delimiter);
405         for (T element : elements) {
406             if (element != null) {
407                 String str = toStr.apply(element);
408                 if (str != null &amp;&amp; !str.isEmpty()) {
409                     joiner.add(str);
410                 }
411             }
412         }
413         return joiner.toString();
414     }
415 
416     @SuppressWarnings(&quot;unchecked&quot;)
417     public static &lt;T&gt; String join(String delimiter, T... elements) {
418         return join(delimiter, elem -&gt; {
419             return elem.toString();
420         }, elements);
421     }
422 
423     @SuppressWarnings(&quot;unchecked&quot;)
424     public static &lt;T&gt; String join(T... elements) {
425         return join(VALUE_DELIMITER, elements);
426     }
427 
428     @SuppressWarnings(&quot;unchecked&quot;)
429     public static &lt;T&gt; String join(Function&lt;T, String&gt; toStr, T... elements) {
430         return join(VALUE_DELIMITER, toStr, elements);
431     }
432 
433     public static String joinOptValue(String delimiter, String option,
434             Object value) {
435         return value == null || value.toString().isEmpty()
436                 ? &quot;&quot;
437                 : option + delimiter + value;
438     }
439 
440     public static String joinOptValue(String option, Object value) {
441         return joinOptValue(&quot; &quot;, option, value);
442     }
443 
444     public static String joinNameValue(String option, Object value) {
445         return joinOptValue(&quot;=&quot;, option, value);
446     }
447 
448     public static String[] split(String str, String delimiter) {
449         if (str == null) {
450             return null;
451         }
452 
453         return str.split(delimiter);
454     }
455 
456     public static String[] split(String str) {
457         return split(str, VALUE_DELIMITER);
458     }
459 
460     public static String trimStr(String str) {
461         return str == null ? &quot;&quot; : str.trim();
462     }
463 
464     public static boolean isEmpty(String str) {
465         return str == null || str.isEmpty();
466     }
467 
468     /*
469      * Determines the expected negotiated application protocol from the server
470      * and client application protocols.
471      */
472     public static String expectedNegoAppProtocol(String[] serverAppProtocols,
473             String[] clientAppProtocols) {
474         if (serverAppProtocols != null &amp;&amp; clientAppProtocols != null) {
475             for(String clientAppProtocol : clientAppProtocols) {
476                 for(String serverAppProtocol : serverAppProtocols) {
477                     if (clientAppProtocol.equals(serverAppProtocol)) {
478                         return clientAppProtocol;
479                     }
480                 }
481             }
482         }
483 
484         return null;
485     }
486 
487     /*
488      * Finds the minimum protocol in the specified protocols.
489      */
490     public static Protocol minProtocol(Protocol[] protocols) {
491         return findProtocol(protocols, true);
492     }
493 
494     /*
495      * Finds the maximum protocol in the specified protocols.
496      */
497     public static Protocol maxProtocol(Protocol[] protocols) {
498         return findProtocol(protocols, false);
499     }
500 
501     private static Protocol findProtocol(Protocol[] protocols, boolean findMin) {
502         if (protocols == null) {
503             return null;
504         }
505 
506         Arrays.sort(protocols, (p1, p2) -&gt; {
507             return (p1.id - p2.id) * (findMin ? 1 : -1);
508         });
509         return protocols[0];
510     }
511 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/javax/net/ssl/TLSCommon/interop/Utilities.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.ByteArrayInputStream;
 25 import java.io.File;
 26 import java.io.IOException;
 27 import java.io.InputStream;
 28 import java.io.OutputStream;
 29 import java.lang.reflect.Array;
 30 import java.nio.charset.Charset;
 31 import java.nio.charset.StandardCharsets;
 32 import java.nio.file.Files;
 33 import java.nio.file.Path;
 34 import java.security.KeyFactory;
 35 import java.security.KeyStore;
 36 import java.security.KeyStoreException;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.PrivateKey;
 39 import java.security.cert.Certificate;
 40 import java.security.cert.CertificateException;
 41 import java.security.cert.CertificateFactory;
 42 import java.security.spec.InvalidKeySpecException;
 43 import java.security.spec.PKCS8EncodedKeySpec;
 44 import java.util.Arrays;
 45 import java.util.Base64;
 46 import java.util.Optional;
 47 import java.util.StringJoiner;
 48 import java.util.concurrent.TimeUnit;
 49 import java.util.function.Function;
 50 import java.util.function.Predicate;
 51 import java.util.stream.Collectors;
 52 
 53 import javax.net.ssl.KeyManagerFactory;
 54 import javax.net.ssl.SSLContext;
 55 import javax.net.ssl.TrustManagerFactory;
 56 
 57 import jdk.test.lib.process.OutputAnalyzer;
 58 
 59 /*
 60  * Utilities for interop testing.
 61  */
 62 public class Utilities {
 63 
 64     public static final String JAVA_HOME = System.getProperty(&quot;java.home&quot;);
 65     public static final String JAVA
 66             = String.join(File.separator, JAVA_HOME, &quot;bin&quot;, &quot;java&quot;);
 67     public static final String JAVAC
 68             = String.join(File.separator, JAVA_HOME, &quot;bin&quot;, &quot;javac&quot;);
 69 
 70     public static final String TEST_SRC = System.getProperty(&quot;test.src&quot;);
 71     public static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;);
 72     public static final String TEST_CLASSPATH = System.getProperty(&quot;test.class.path&quot;);
 73 
 74     public static final Charset CHARSET = StandardCharsets.UTF_8;
 75 
 76     public static final boolean DEBUG = Boolean.getBoolean(&quot;test.debug&quot;);
 77     public static final int TIMEOUT = Integer.getInteger(&quot;test.timeout&quot;, 20);
 78     public static final String LOG_PATH = System.getProperty(&quot;test.log.path&quot;);
 79 
 80     public static final String PARAM_DELIMITER = &quot;;&quot;;
 81     public static final String VALUE_DELIMITER = &quot;,&quot;;
 82 
 83     public static final CipherSuite[] ALL_CIPHER_SUITES = getAllCipherSuites();
 84 
 85     /*
 86      * Gets all supported cipher suites.
 87      */
 88     private static CipherSuite[] getAllCipherSuites() {
 89         String[] supportedCipherSuites;
 90         try {
 91             supportedCipherSuites = SSLContext.getDefault()
 92                     .createSSLEngine()
 93                     .getSupportedCipherSuites();
 94         } catch (NoSuchAlgorithmException e) {
 95             throw new RuntimeException(
 96                     &quot;Failed to get supported cipher suites&quot;, e);
 97         }
 98 
 99         CipherSuite[] cipherSuites = Arrays.stream(supportedCipherSuites)
100                 .map(cipherSuite -&gt; {
101                     return CipherSuite.cipherSuite(cipherSuite);})
102                 .filter(cipherSuite -&gt; {
103                     return cipherSuite != CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV; })
104                 .toArray(CipherSuite[]::new);
105 
106         return cipherSuites;
107     }
108 
109     /*
110      * Creates SSL context with the specified certificates.
111      */
112     public static SSLContext createSSLContext(CertTuple certTuple)
113             throws Exception {
114         KeyStore trustStore = createTrustStore(certTuple.trustedCerts);
115         TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;PKIX&quot;);
116         tmf.init(trustStore);
117 
118         KeyStore keyStore = createKeyStore(certTuple.endEntityCerts);
119         KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;NewSunX509&quot;);
120         kmf.init(keyStore, null);
121 
122         SSLContext context = SSLContext.getInstance(&quot;TLS&quot;);
123         context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
124         return context;
125     }
126 
127     /*
128      * Creates trust store with the specified certificates.
129      */
130     public static KeyStore createTrustStore(Cert... certs)
131             throws KeyStoreException, IOException, NoSuchAlgorithmException,
132             CertificateException {
133         KeyStore trustStore = KeyStore.getInstance(&quot;PKCS12&quot;);
134         trustStore.load(null, null);
135 
136         if (certs != null) {
137             for (int i = 0; i &lt; certs.length; i++) {
138                 if (certs[i] != null) {
139                     trustStore.setCertificateEntry(&quot;trust-&quot; + i,
140                             createCert(certs[i]));
141                 }
142             }
143         }
144 
145         return trustStore;
146     }
147 
148     /*
149      * Creates key store with the specified certificates.
150      */
151     public static KeyStore createKeyStore(Cert... certs)
152             throws KeyStoreException, IOException, NoSuchAlgorithmException,
153             CertificateException, InvalidKeySpecException {
154         KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;);
155         keyStore.load(null, null);
156 
157         if (certs != null) {
158             for (int i = 0; i &lt; certs.length; i++) {
159                 if (certs[i] != null) {
160                     keyStore.setKeyEntry(&quot;cert-&quot; + i, createKey(certs[i]), null,
161                             new Certificate[] { createCert(certs[i]) });
162                 }
163             }
164         }
165 
166         return keyStore;
167     }
168 
169     /*
170      * Creates Certificate instance with the specified certificate.
171      */
172     public static Certificate createCert(Cert cert) {
173         try {
174             CertificateFactory certFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
175             return certFactory.generateCertificate(
176                     new ByteArrayInputStream(cert.certMaterials.getBytes()));
177         } catch (CertificateException e) {
178             throw new RuntimeException(&quot;Create cert failed: &quot; + cert, e);
179         }
180     }
181 
182     /*
183      * Creates PrivateKey instance with the specified certificate.
184      */
185     public static PrivateKey createKey(Cert cert)
186             throws NoSuchAlgorithmException, InvalidKeySpecException {
187         PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(
188                 Base64.getMimeDecoder().decode(cert.keyMaterials));
189         KeyFactory keyFactory = KeyFactory.getInstance(
190                 cert.keyAlgo.name);
191         PrivateKey privKey = keyFactory.generatePrivate(privKeySpec);
192         return privKey;
193     }
194 
195     /*
196      * Reads an input stream, in which the content length isn&#39;t more than 1024.
197      */
198     public static String readIn(InputStream input) throws IOException {
199         byte[] buf = new byte[1024];
200         int length = input.read(buf);
201         if (length &gt; 0) {
202             return new String(buf, 0, length);
203         } else {
204             return &quot;&quot;;
205         }
206     }
207 
208     /*
209      * Writes the specified content to an output stream.
210      */
211     public static void writeOut(OutputStream output, String content)
212             throws IOException {
213         output.write(content.getBytes(Utilities.CHARSET));
214         output.flush();
215     }
216 
217     /*
218      *  Sleeps until the condition is true or getting timeout.
219      */
220     public static &lt;T&gt; boolean waitFor(Predicate&lt;T&gt; predicate, T t) {
221         long deadline = System.currentTimeMillis() + Utilities.TIMEOUT * 1000;
222         while (!predicate.test(t) &amp;&amp; System.currentTimeMillis() &lt; deadline) {
223             try {
224                 TimeUnit.SECONDS.sleep(1);
225             } catch (InterruptedException e) {
226                 throw new RuntimeException(&quot;Sleep is interrupted.&quot;, e);
227             }
228         }
229 
230         return predicate.test(t);
231     }
232 
233     /*
234      * Converts Enum array to string array.
235      * The string elements are the Enum names.
236      */
237     public static String[] enumsToStrs(Enum&lt;?&gt;... elements) {
238         return enumsToStrs(element -&gt; {
239             return element.name();
240         }, elements);
241     }
242 
243     /*
244      * Converts NamedGroup array to string array.
245      * The string elements are the NameGroups&#39; names.
246      */
247     public static String[] namedGroupsToStrs(NamedGroup... namedGroups) {
248         return enumsToStrs(namedGroup -&gt; {
249             return ((NamedGroup) namedGroup).name;
250         }, namedGroups);
251     }
252 
253     /*
254      * Converts Enum array to string array.
255      * The string elements are determined by the specified Function.
256      */
257     public static String[] enumsToStrs(Function&lt;Enum&lt;?&gt;, String&gt; function,
258             Enum&lt;?&gt;... elements) {
259         return elements == null
260                 ? null
261                 : Arrays.stream(elements).map(function).toArray(String[]::new);
262     }
263 
264     /*
265      * Converts string array to Enum array.
266      */
267     @SuppressWarnings(&quot;unchecked&quot;)
268     public static &lt;T extends Enum&lt;T&gt;&gt; T[] strToEnums(Class&lt;T&gt; enumType,
269             String namesStr) {
270         if (namesStr == null) {
271             return null;
272         }
273 
274         return Arrays.stream(namesStr.split(VALUE_DELIMITER)).map(name -&gt; {
275             return Enum.valueOf(enumType, name);
276         }).collect(Collectors.toList()).toArray(
277                 (T[]) Array.newInstance(enumType, 0));
278     }
279 
280     /*
281      * Executes shell command and return a OutputAnalyzer wrapping the process.
282      */
283     public static OutputAnalyzer shell(String command) throws IOException {
284         Process process = shellProc(command);
285         OutputAnalyzer oa = new OutputAnalyzer(process);
286         try {
287             process.waitFor();
288             return oa;
289         } catch (InterruptedException e) {
290             throw new RuntimeException(&quot;Shell process is interruptted!&quot;, e);
291         }
292     }
293 
294     /*
295      * Executes shell command and redirect the output to a local file,
296      * and return the process.
297      */
298     public static Process shellProc(String command, Path outputPath)
299             throws IOException {
300         String[] cmds = new String[3];
301         cmds[0] = &quot;sh&quot;;
302         cmds[1] = &quot;-c&quot;;
303         cmds[2] = command;
304         if (DEBUG) {
305             System.out.println(&quot;[sh -c &quot; + command + &quot;]&quot;);
306         }
307         ProcessBuilder pb = new ProcessBuilder(cmds);
308         pb.redirectErrorStream(true);
309         if (outputPath != null) {
310             pb.redirectOutput(outputPath.toFile());
311         }
312         return pb.start();
313     }
314 
315     /*
316      * Executes shell command and return the process.
317      */
318     public static Process shellProc(String command) throws IOException {
319         return shellProc(command, null);
320     }
321 
322     /*
323      * Determines if the specified process is alive.
324      */
325     public static boolean isAliveProcess(Process process) {
326         return process != null &amp;&amp; process.isAlive();
327     }
328 
329     /*
330      * Destroys the specified process and the associated child processes.
331      */
332     public static void destroyProcess(Process process) {
333         process.children().forEach(ProcessHandle::destroy);
334         process.destroy();
335     }
336 
337     /*
338      * Reads the content for the specified file.
339      */
340     public static Optional&lt;String&gt; readFile(Path path) throws IOException {
341         if (!Files.exists(path)) {
342             return Optional.empty();
343         } else {
344             return Optional.of(new String(Files.readAllBytes(path)));
345         }
346     }
347 
348     /*
349      * Tries to delete the specified file before getting timeout,
350      * in case that the file is not released by some process in time.
351      */
352     public static void deleteFile(Path filePath) throws IOException {
353         if (filePath == null) {
354             return;
355         }
356 
357         waitFor(path -&gt; delete(path), filePath);
358         if (Files.exists(filePath)) {
359             throw new IOException(
360                     &quot;File is not deleted in time: &quot; + filePath.toAbsolutePath());
361         }
362     }
363 
364     private static boolean delete(Path filePath) {
365         boolean deleted = false;
366         try {
367             deleted = Files.deleteIfExists(filePath);
368         } catch (IOException e) {
369             e.printStackTrace(System.out);
370         }
371 
372         return deleted;
373     }
374 
375     /*
376      * Determines if the TLS session is resumed.
377      */
378     public static boolean isSessionResumed(ResumptionMode mode,
379             byte[] firstSessionId, byte[] secondSessionId,
380             long secondConnStartTime, long secondSessionCreationTime) {
381         System.out.println(&quot;ResumptionMode: &quot; + mode);
382         System.out.println(&quot;firstSessionId: &quot; + Arrays.toString(firstSessionId));
383         System.out.println(&quot;secondSessionId: &quot; + Arrays.toString(secondSessionId));
384         System.out.println(&quot;secondConnStartTime: &quot; + secondConnStartTime);
385         System.out.println(&quot;secondSessionCreationTime: &quot; + secondSessionCreationTime);
386 
387         boolean resumed = secondConnStartTime &gt; secondSessionCreationTime;
388         if (mode == ResumptionMode.ID) {
389             resumed = resumed &amp;&amp; firstSessionId.length &gt; 0
390                     &amp;&amp; Arrays.equals(firstSessionId, secondSessionId);
391         }
392         return resumed;
393     }
394 
395     @SuppressWarnings(&quot;unchecked&quot;)
396     public static &lt;T&gt; String join(String delimiter, Function&lt;T, String&gt; toStr,
397             T... elements) {
398         if (elements == null) {
399             return &quot;&quot;;
400         }
401 
402         StringJoiner joiner = new StringJoiner(delimiter);
403         for (T element : elements) {
404             if (element != null) {
405                 String str = toStr.apply(element);
406                 if (str != null &amp;&amp; !str.isEmpty()) {
407                     joiner.add(str);
408                 }
409             }
410         }
411         return joiner.toString();
412     }
413 
414     @SuppressWarnings(&quot;unchecked&quot;)
415     public static &lt;T&gt; String join(String delimiter, T... elements) {
416         return join(delimiter, elem -&gt; {
417             return elem.toString();
418         }, elements);
419     }
420 
421     @SuppressWarnings(&quot;unchecked&quot;)
422     public static &lt;T&gt; String join(T... elements) {
423         return join(VALUE_DELIMITER, elements);
424     }
425 
426     @SuppressWarnings(&quot;unchecked&quot;)
427     public static &lt;T&gt; String join(Function&lt;T, String&gt; toStr, T... elements) {
428         return join(VALUE_DELIMITER, toStr, elements);
429     }
430 
431     public static String joinOptValue(String delimiter, String option,
432             Object value) {
433         return value == null || value.toString().isEmpty()
434                 ? &quot;&quot;
435                 : option + delimiter + value;
436     }
437 
438     public static String joinOptValue(String option, Object value) {
439         return joinOptValue(&quot; &quot;, option, value);
440     }
441 
442     public static String joinNameValue(String option, Object value) {
443         return joinOptValue(&quot;=&quot;, option, value);
444     }
445 
446     public static String[] split(String str, String delimiter) {
447         if (str == null) {
448             return null;
449         }
450 
451         return str.split(delimiter);
452     }
453 
454     public static String[] split(String str) {
455         return split(str, VALUE_DELIMITER);
456     }
457 
458     public static String trimStr(String str) {
459         return str == null ? &quot;&quot; : str.trim();
460     }
461 
462     public static boolean isEmpty(String str) {
463         return str == null || str.isEmpty();
464     }
465 
466     /*
467      * Determines the expected negotiated application protocol from the server
468      * and client application protocols.
469      */
470     public static String expectedNegoAppProtocol(String[] serverAppProtocols,
471             String[] clientAppProtocols) {
472         if (serverAppProtocols != null &amp;&amp; clientAppProtocols != null) {
473             for(String clientAppProtocol : clientAppProtocols) {
474                 for(String serverAppProtocol : serverAppProtocols) {
475                     if (clientAppProtocol.equals(serverAppProtocol)) {
476                         return clientAppProtocol;
477                     }
478                 }
479             }
480         }
481 
482         return null;
483     }
484 
485     /*
486      * Finds the minimum protocol in the specified protocols.
487      */
488     public static Protocol minProtocol(Protocol[] protocols) {
489         return findProtocol(protocols, true);
490     }
491 
492     /*
493      * Finds the maximum protocol in the specified protocols.
494      */
495     public static Protocol maxProtocol(Protocol[] protocols) {
496         return findProtocol(protocols, false);
497     }
498 
499     private static Protocol findProtocol(Protocol[] protocols, boolean findMin) {
500         if (protocols == null) {
501             return null;
502         }
503 
504         Arrays.sort(protocols, (p1, p2) -&gt; {
505             return (p1.id - p2.id) * (findMin ? 1 : -1);
506         });
507         return protocols[0];
508     }
509 }
    </pre>
  </body>
</html>
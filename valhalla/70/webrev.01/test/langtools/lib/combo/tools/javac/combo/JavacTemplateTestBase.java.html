<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/lib/combo/tools/javac/combo/JavacTemplateTestBase.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package tools.javac.combo;
 25 
 26 import java.io.File;
 27 import java.io.IOException;
 28 import java.net.MalformedURLException;
 29 import java.net.URI;
 30 import java.net.URL;
 31 import java.net.URLClassLoader;
 32 import java.util.ArrayList;
 33 import java.util.Arrays;
 34 import java.util.Collections;
 35 import java.util.HashMap;
 36 import java.util.HashSet;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.Set;
 40 import java.util.concurrent.atomic.AtomicInteger;
 41 import java.util.function.Consumer;
 42 import javax.tools.Diagnostic;
 43 import javax.tools.JavaCompiler;
 44 import javax.tools.JavaFileObject;
 45 import javax.tools.SimpleJavaFileObject;
 46 import javax.tools.StandardJavaFileManager;
 47 import javax.tools.StandardLocation;
 48 import javax.tools.ToolProvider;
 49 
 50 import com.sun.source.util.JavacTask;
 51 import com.sun.tools.javac.util.Pair;
 52 import org.testng.ITestResult;
 53 import org.testng.annotations.AfterMethod;
 54 import org.testng.annotations.AfterSuite;
 55 import org.testng.annotations.BeforeMethod;
 56 import org.testng.annotations.Test;
 57 
 58 import static org.testng.Assert.fail;
 59 
 60 /**
 61  * Base class for template-driven TestNG javac tests that support on-the-fly
 62  * source file generation, compilation, classloading, execution, and separate
 63  * compilation.
 64  *
 65  * &lt;p&gt;Manages a set of templates (which have embedded tags of the form
 66  * {@code #\{NAME\}}), source files (which are also templates), and compile
 67  * options.  Test cases can register templates and source files, cause them to
 68  * be compiled, validate whether the set of diagnostic messages output by the
 69  * compiler is correct, and optionally load and run the compiled classes.
 70  *
 71  * @author Brian Goetz
 72  */
 73 @Test
 74 public abstract class JavacTemplateTestBase {
 75     private static final Set&lt;String&gt; suiteErrors = Collections.synchronizedSet(new HashSet&lt;&gt;());
 76     private static final AtomicInteger counter = new AtomicInteger();
 77     private static final File root = new File(&quot;gen&quot;);
 78     private static final File nullDir = new File(&quot;empty&quot;);
 79 
 80     protected final Map&lt;String, Template&gt; templates = new HashMap&lt;&gt;();
 81     protected final Diagnostics diags = new Diagnostics();
 82     protected final List&lt;Pair&lt;String, String&gt;&gt; sourceFiles = new ArrayList&lt;&gt;();
 83     protected final List&lt;String&gt; compileOptions = new ArrayList&lt;&gt;();
 84     protected final List&lt;File&gt; classpaths = new ArrayList&lt;&gt;();
 85 
 86     /** Add a template with a specified name */
 87     protected void addTemplate(String name, Template t) {
 88         templates.put(name, t);
 89     }
 90 
 91     /** Add a template with a specified name */
 92     protected void addTemplate(String name, String s) {
 93         templates.put(name, new StringTemplate(s));
 94     }
 95 
 96     /** Add a source file */
 97     protected void addSourceFile(String name, String template) {
 98         sourceFiles.add(new Pair&lt;&gt;(name, template));
 99     }
100 
101     /** Add a File to the class path to be used when loading classes; File values
102      * will generally be the result of a previous call to {@link #compile()}.
103      * This enables testing of separate compilation scenarios if the class path
104      * is set up properly.
105      */
106     protected void addClassPath(File path) {
107         classpaths.add(path);
108     }
109 
110     /**
111      * Add a set of compilation command-line options
112      */
113     protected void addCompileOptions(String... opts) {
114         Collections.addAll(compileOptions, opts);
115     }
116 
117     /** Reset the compile options to the default (empty) value */
118     protected void resetCompileOptions() { compileOptions.clear(); }
119 
120     /** Remove all templates */
121     protected void resetTemplates() { templates.clear(); }
122 
123     /** Remove accumulated diagnostics */
124     protected void resetDiagnostics() { diags.reset(); }
125 
126     /** Remove all source files */
127     protected void resetSourceFiles() { sourceFiles.clear(); }
128 
129     /** Remove registered class paths */
130     protected void resetClassPaths() { classpaths.clear(); }
131 
132     // Before each test method, reset everything
133     @BeforeMethod
134     public void reset() {
135         resetCompileOptions();
136         resetDiagnostics();
137         resetSourceFiles();
138         resetTemplates();
139         resetClassPaths();
140     }
141 
142     // After each test method, if the test failed, capture source files and diagnostics and put them in the log
143     @AfterMethod
144     public void copyErrors(ITestResult result) {
145         if (!result.isSuccess()) {
146             suiteErrors.addAll(diags.errorKeys());
147 
148             List&lt;Object&gt; list = new ArrayList&lt;&gt;();
149             Collections.addAll(list, result.getParameters());
150             list.add(&quot;Test case: &quot; + getTestCaseDescription());
151             for (Pair&lt;String, String&gt; e : sourceFiles)
152                 list.add(&quot;Source file &quot; + e.fst + &quot;: &quot; + e.snd);
153             if (diags.errorsFound())
154                 list.add(&quot;Compile diagnostics: &quot; + diags.toString());
155             result.setParameters(list.toArray(new Object[list.size()]));
156         }
157     }
158 
159     @AfterSuite
160     // After the suite is done, dump any errors to output
161     public void dumpErrors() {
162         if (!suiteErrors.isEmpty())
163             System.err.println(&quot;Errors found in test suite: &quot; + suiteErrors);
164     }
165 
166     /**
167      * Get a description of this test case; since test cases may be combinatorially
168      * generated, this should include all information needed to describe the test case
169      */
170     protected String getTestCaseDescription() {
171         return this.toString();
172     }
173 
174     /** Assert that all previous calls to compile() succeeded */
175     protected void assertCompileSucceeded() {
176         if (diags.errorsFound())
177             fail(&quot;Expected successful compilation&quot;);
178     }
179 
180     /** Assert that all previous calls to compile() succeeded */
181     protected void assertCompileSucceededWithWarning(String warning) {
182         if (diags.errorsFound())
183             fail(&quot;Expected successful compilation&quot;);
184         if (!diags.containsWarningKey(warning)) {
185             fail(String.format(&quot;Expected compilation warning with %s, found %s&quot;, warning, diags.keys()));
186         }
187     }
188 
189     /**
190      * If the provided boolean is true, assert all previous compiles succeeded,
191      * otherwise assert that a compile failed.
192      * */
193     protected void assertCompileSucceededIff(boolean b) {
194         if (b)
195             assertCompileSucceeded();
196         else
197             assertCompileFailed();
198     }
199 
200     /** Assert that a previous call to compile() failed */
201     protected void assertCompileFailed() {
202         if (!diags.errorsFound())
203             fail(&quot;Expected failed compilation&quot;);
204     }
205 
206     /** Assert that a previous call to compile() failed with a specific error key */
207     protected void assertCompileFailed(String key) {
208         if (!diags.errorsFound())
209             fail(&quot;Expected failed compilation: &quot; + key);
210         if (!diags.containsErrorKey(key)) {
211             fail(String.format(&quot;Expected compilation error with %s, found %s&quot;, key, diags.keys()));
212         }
213     }
214 
215     protected void assertCompileFailed(String key, Consumer&lt;Diagnostic&lt;?&gt;&gt; diagConsumer) {
216         if (!diags.errorsFound())
217             fail(&quot;Expected failed compilation: &quot; + key);
218         if (!diags.containsErrorKey(key)) {
219             fail(String.format(&quot;Expected compilation error with %s, found %s&quot;, key, diags.keys()));
220         } else {
221             // for additional checks
222             diagConsumer.accept(diags.getDiagWithKey(key));
223         }
224     }
225 
226     /** Assert that a previous call to compile() failed with a specific error key */
227     protected void assertCompileFailedOneOf(String... keys) {
228         if (!diags.errorsFound())
229             fail(&quot;Expected failed compilation with one of: &quot; + Arrays.asList(keys));
230         boolean found = false;
231         for (String k : keys)
232             if (diags.containsErrorKey(k))
233                 found = true;
234         fail(String.format(&quot;Expected compilation error with one of %s, found %s&quot;, Arrays.asList(keys), diags.keys()));
235     }
236 
237     /** Assert that a previous call to compile() failed with all of the specified error keys */
238     protected void assertCompileErrors(String... keys) {
239         if (!diags.errorsFound())
240             fail(&quot;Expected failed compilation&quot;);
241         for (String k : keys)
242             if (!diags.containsErrorKey(k))
243                 fail(&quot;Expected compilation error &quot; + k);
244     }
245 
246     /** Compile all registered source files */
247     protected void compile() throws IOException {
248         compile(false);
249     }
250 
251     /** Compile all registered source files, optionally generating class files
252      * and returning a File describing the directory to which they were written */
253     protected File compile(boolean generate) throws IOException {
254         List&lt;JavaFileObject&gt; files = new ArrayList&lt;&gt;();
255         for (Pair&lt;String, String&gt; e : sourceFiles)
256             files.add(new FileAdapter(e.fst, e.snd));
257         return compile(classpaths, files, generate);
258     }
259 
260     /** Compile all registered source files, using the provided list of class paths
261      * for finding required classfiles, optionally generating class files
262      * and returning a File describing the directory to which they were written */
263     protected File compile(List&lt;File&gt; classpaths, boolean generate) throws IOException {
264         List&lt;JavaFileObject&gt; files = new ArrayList&lt;&gt;();
265         for (Pair&lt;String, String&gt; e : sourceFiles)
266             files.add(new FileAdapter(e.fst, e.snd));
267         return compile(classpaths, files, generate);
268     }
269 
270     private File compile(List&lt;File&gt; classpaths, List&lt;JavaFileObject&gt; files, boolean generate) throws IOException {
271         JavaCompiler systemJavaCompiler = ToolProvider.getSystemJavaCompiler();
272         try (StandardJavaFileManager fm = systemJavaCompiler.getStandardFileManager(null, null, null)) {
273             if (classpaths.size() &gt; 0)
274                 fm.setLocation(StandardLocation.CLASS_PATH, classpaths);
275             JavacTask ct = (JavacTask) systemJavaCompiler.getTask(null, fm, diags, compileOptions, null, files);
276             if (generate) {
277                 File destDir = new File(root, Integer.toString(counter.incrementAndGet()));
278                 // @@@ Assert that this directory didn&#39;t exist, or start counter at max+1
279                 destDir.mkdirs();
280                 fm.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(destDir));
281                 ct.generate();
282                 return destDir;
283             }
284             else {
285                 ct.analyze();
286                 return nullDir;
287             }
288         }
289     }
290 
291     /** Load the given class using the provided list of class paths */
292     protected Class&lt;?&gt; loadClass(String className, File... destDirs) {
293         try {
294             List&lt;URL&gt; list = new ArrayList&lt;&gt;();
295             for (File f : destDirs)
296                 list.add(new URL(&quot;file:&quot; + f.toString().replace(&quot;\\&quot;, &quot;/&quot;) + &quot;/&quot;));
297             return Class.forName(className, true, new URLClassLoader(list.toArray(new URL[list.size()])));
298         } catch (ClassNotFoundException | MalformedURLException e) {
299             throw new RuntimeException(&quot;Error loading class &quot; + className, e);
300         }
301     }
302 
303     /** An implementation of Template which is backed by a String */
304     protected class StringTemplate implements Template {
305         protected final String template;
306 
307         public StringTemplate(String template) {
308             this.template = template;
309         }
310 
311         public String expand(String selectorIgnored) {
312             return Template.expandTemplate(template, templates);
313         }
314 
315         public String toString() {
316             return expand(&quot;&quot;);
317         }
318     }
319 
320     private class FileAdapter extends SimpleJavaFileObject {
321         private final String templateString;
322 
323         FileAdapter(String filename, String templateString) {
324             super(URI.create(&quot;myfo:/&quot; + filename), Kind.SOURCE);
325             this.templateString = templateString;
326         }
327 
328         public CharSequence getCharContent(boolean ignoreEncodingErrors) {
329             return toString();
330         }
331 
332         public String toString() {
333             return Template.expandTemplate(templateString, templates);
334         }
335     }
336 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/processing/model/element/CheckingTypeAnnotationsOnRecords.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Verify that annotation processing works for records
 27  * @library /tools/lib /tools/javac/lib
 28  * @modules
 29  *      jdk.compiler/com.sun.tools.javac.api
 30  *      jdk.compiler/com.sun.tools.javac.main
 31  *      jdk.compiler/com.sun.tools.javac.code
 32  *      jdk.compiler/com.sun.tools.javac.util
 33  * @build toolbox.ToolBox toolbox.JavacTask
 34  * @build JavacTestingAbstractProcessor
 35  * @compile --enable-preview -source ${jdk.version} CheckingTypeAnnotationsOnRecords.java
 36  * @run main/othervm --enable-preview CheckingTypeAnnotationsOnRecords
 37  */
 38 
 39 import java.io.*;
 40 import java.nio.file.Files;
 41 import java.nio.file.Path;
 42 import java.nio.file.Paths;
 43 import java.util.*;
 44 
 45 import javax.annotation.processing.*;
 46 import javax.lang.model.SourceVersion;
 47 import javax.lang.model.element.Element;
 48 import javax.lang.model.element.ElementKind;
 49 import javax.lang.model.element.RecordComponentElement;
 50 import javax.lang.model.element.TypeElement;
 51 import javax.lang.model.element.VariableElement;
 52 import javax.lang.model.type.TypeKind;
 53 import javax.lang.model.util.ElementFilter;
 54 import javax.lang.model.util.ElementScanner14;
 55 import javax.tools.Diagnostic.Kind;
 56 import javax.tools.*;
 57 
 58 import java.lang.annotation.*;
 59 import java.util.*;
 60 import javax.annotation.processing.*;
 61 import javax.lang.model.element.*;
 62 import javax.lang.model.type.*;
 63 import javax.tools.Diagnostic.Kind;
 64 
 65 import java.lang.annotation.ElementType;
 66 import java.lang.annotation.Retention;
 67 import java.lang.annotation.RetentionPolicy;
 68 import java.lang.annotation.Target;
 69 
 70 import com.sun.tools.javac.code.Symbol;
 71 import com.sun.tools.javac.code.Symbol.VarSymbol;
 72 
 73 import com.sun.tools.javac.util.Assert;
 74 
 75 import toolbox.JavacTask;
 76 import toolbox.Task;
 77 import toolbox.Task.Mode;
 78 import toolbox.Task.OutputKind;
 79 import toolbox.TestRunner;
 80 import toolbox.ToolBox;
 81 
 82 public class CheckingTypeAnnotationsOnRecords extends TestRunner {
 83     protected ToolBox tb;
 84 
 85     CheckingTypeAnnotationsOnRecords() {
 86         super(System.err);
 87         tb = new ToolBox();
 88     }
 89 
 90     public static void main(String... args) throws Exception {
<a name="2" id="anc2"></a>
 91         new CheckingTypeAnnotationsOnRecords().runTests();
 92     }
 93 
 94     protected void runTests() throws Exception {
 95         runTests(m -&gt; new Object[] { Paths.get(m.getName()) });
 96     }
 97 
 98     Path[] findJavaFiles(Path... paths) throws IOException {
 99         return tb.findJavaFiles(paths);
100     }
101 
102     void checkOutputContains(String log, String... expect) throws Exception {
103         for (String e : expect) {
104             if (!log.contains(e)) {
105                 throw new Exception(&quot;expected output not found: &quot; + e);
106             }
107         }
108     }
109 
110     static final String SOURCE =
111             &quot;&quot;&quot;
112             import java.lang.annotation.*;
113             import java.util.*;
114             import javax.annotation.processing.*;
115             import javax.lang.model.element.*;
116 
117             @Retention(RetentionPolicy.RUNTIME)
118             @Target({ ElementType.TYPE_USE })
119             @interface TypeUse {}
120 
121             record R1(@TypeUse int annotated) {}
122 
123             record R2(@TypeUse String annotated) {}
124 
125             record R3(@TypeUse String... annotated) {}
126 
127             @Retention(RetentionPolicy.RUNTIME)
128             @Target({ ElementType.TYPE_PARAMETER })
129             @interface TypeParameter {}
130 
131             record R4&lt;@TypeParameter T&gt;(T t) {}
132             &quot;&quot;&quot;;
133 
134     @Test
135     public void testAnnoProcessing(Path base) throws Exception {
136         Path src = base.resolve(&quot;src&quot;);
137         Path r = src.resolve(&quot;Records&quot;);
138 
139         Path classes = base.resolve(&quot;classes&quot;);
140 
141         Files.createDirectories(classes);
142 
143         tb.writeJavaFiles(r, SOURCE);
144 
145         for (Mode mode : new Mode[] {Mode.API}) {
146             new JavacTask(tb, mode)
147                     .options(&quot;-nowarn&quot;,
148                             &quot;-processor&quot;, Processor.class.getName(),
149                             &quot;--enable-preview&quot;,
150                             &quot;-source&quot;, Integer.toString(Runtime.version().feature()))
151                     .files(findJavaFiles(src))
152                     .outdir(classes)
153                     .run()
154                     .writeAll()
155                     .getOutputLines(Task.OutputKind.DIRECT);
156         }
157     }
158 
159     @SupportedAnnotationTypes(&quot;*&quot;)
160     public static final class Processor extends JavacTestingAbstractProcessor {
161 
162         static private final Map&lt;String, String&gt; recordNameExpectedAnnotationMap = new HashMap&lt;&gt;();
163         static private final Map&lt;String, Integer&gt; recordNameExpectedAnnotationNumberMap = new HashMap&lt;&gt;();
164         static {
165             recordNameExpectedAnnotationMap.put(&quot;R1&quot;, &quot;@TypeUse&quot;);
166             recordNameExpectedAnnotationMap.put(&quot;R2&quot;, &quot;@TypeUse&quot;);
167             recordNameExpectedAnnotationMap.put(&quot;R3&quot;, &quot;@TypeUse&quot;);
168             recordNameExpectedAnnotationMap.put(&quot;R4&quot;, &quot;@TypeParameter&quot;);
169 
170             recordNameExpectedAnnotationNumberMap.put(&quot;R1&quot;, 4);
171             recordNameExpectedAnnotationNumberMap.put(&quot;R2&quot;, 4);
172             recordNameExpectedAnnotationNumberMap.put(&quot;R3&quot;, 4);
173             recordNameExpectedAnnotationNumberMap.put(&quot;R4&quot;, 1);
174         }
175 
176         @Override
177         public boolean process(Set&lt;? extends TypeElement&gt; annotations,
178                                RoundEnvironment roundEnv) {
179             if (roundEnv.processingOver()) {
180                 for (String key : recordNameExpectedAnnotationMap.keySet()) {
181                     Element element = processingEnv.getElementUtils().getTypeElement(key);
182                     numberOfAnnotations = 0;
183                     verifyReferredTypesAcceptable(element, recordNameExpectedAnnotationMap.get(key));
184                     Assert.check(numberOfAnnotations == recordNameExpectedAnnotationNumberMap.get(key), &quot;expected = &quot; +
185                             recordNameExpectedAnnotationNumberMap.get(key) + &quot; found = &quot; + numberOfAnnotations);
186                 }
187             }
188             return true;
189         }
190 
191         int numberOfAnnotations = 0;
192 
193         private void verifyReferredTypesAcceptable(Element rootElement, String expectedAnnotationName) {
194             new ElementScanner&lt;Void, Void&gt;() {
195                 @Override public Void visitType(TypeElement e, Void p) {
196                     scan(e.getTypeParameters(), p);
197                     scan(e.getEnclosedElements(), p);
198                     verifyAnnotations(e.getAnnotationMirrors(), expectedAnnotationName);
199                     return null;
200                 }
201                 @Override public Void visitTypeParameter(TypeParameterElement e, Void p) {
202                     verifyTypesAcceptable(e.getBounds(), expectedAnnotationName);
203                     scan(e.getEnclosedElements(), p);
204                     verifyAnnotations(e.getAnnotationMirrors(), expectedAnnotationName);
205                     return null;
206                 }
207                 @Override public Void visitVariable(VariableElement e, Void p) {
208                     verifyTypeAcceptable(e.asType(), expectedAnnotationName);
209                     scan(e.getEnclosedElements(), p);
210                     verifyAnnotations(e.getAnnotationMirrors(), expectedAnnotationName);
211                     return null;
212                 }
213                 @Override
214                 public Void visitExecutable(ExecutableElement e, Void p) {
215                     scan(e.getTypeParameters(), p);
216                     verifyTypeAcceptable(e.getReturnType(), expectedAnnotationName);
217                     scan(e.getParameters(), p);
218                     verifyTypesAcceptable(e.getThrownTypes(), expectedAnnotationName);
219                     scan(e.getEnclosedElements(), p);
220                     verifyAnnotations(e.getAnnotationMirrors(), expectedAnnotationName);
221                     return null;
222                 }
223                 @Override public Void visitRecordComponent(RecordComponentElement e, Void p) {
224                     verifyTypeAcceptable(e.asType(), expectedAnnotationName);
225                     scan(e.getEnclosedElements(), p);
226                     verifyAnnotations(e.getAnnotationMirrors(), expectedAnnotationName);
227                     return null;
228                 }
229             }.scan(rootElement, null);
230         }
231 
232         private void verifyAnnotations(Iterable&lt;? extends AnnotationMirror&gt; annotations, String expectedName) {
233             for (AnnotationMirror mirror : annotations) {
234                 Assert.check(mirror.toString().equals(expectedName));
235                 numberOfAnnotations++;
236             }
237         }
238 
239         private void verifyTypesAcceptable(Iterable&lt;? extends TypeMirror&gt; types, String expectedAnnotationName) {
240             if (types == null) return ;
241 
242             for (TypeMirror type : types) {
243                 verifyTypeAcceptable(type, expectedAnnotationName);
244             }
245         }
246 
247         private void verifyTypeAcceptable(TypeMirror type, String expectedAnnotationName) {
248             if (type == null) return ;
249 
250             verifyAnnotations(type.getAnnotationMirrors(), expectedAnnotationName);
251 
252             switch (type.getKind()) {
253                 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FLOAT:
254                 case INT: case LONG: case SHORT: case VOID: case NONE: case NULL:
255                     return ;
256                 case DECLARED:
257                     DeclaredType dt = (DeclaredType) type;
258                     TypeElement outermostTypeElement = outermostTypeElement(dt.asElement());
259                     String outermostType = outermostTypeElement.getQualifiedName().toString();
260 
261                     for (TypeMirror bound : dt.getTypeArguments()) {
262                         verifyTypeAcceptable(bound, expectedAnnotationName);
263                     }
264                     break;
265                 case ARRAY:
266                     verifyTypeAcceptable(((ArrayType) type).getComponentType(), expectedAnnotationName);
267                     break;
268                 case INTERSECTION:
269                     for (TypeMirror element : ((IntersectionType) type).getBounds()) {
270                         verifyTypeAcceptable(element, expectedAnnotationName);
271                     }
272                     break;
273                 case TYPEVAR:
274                     verifyTypeAcceptable(((TypeVariable) type).getLowerBound(), expectedAnnotationName);
275                     verifyTypeAcceptable(((TypeVariable) type).getUpperBound(), expectedAnnotationName);
276                     break;
277                 case WILDCARD:
278                     verifyTypeAcceptable(((WildcardType) type).getExtendsBound(), expectedAnnotationName);
279                     verifyTypeAcceptable(((WildcardType) type).getSuperBound(), expectedAnnotationName);
280                     break;
281                 default:
282                     error(&quot;Type not acceptable for this API: &quot; + type.toString());
283                     break;
284 
285             }
286         }
287 
288         private TypeElement outermostTypeElement(Element el) {
289             while (el.getEnclosingElement().getKind() != ElementKind.PACKAGE) {
290                 el = el.getEnclosingElement();
291             }
292 
293             return (TypeElement) el;
294         }
295 
296         private void error(String text) {
297             processingEnv.getMessager().printMessage(Kind.ERROR, text);
298         }
299     }
300 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
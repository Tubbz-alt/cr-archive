<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/processing/model/element/CheckingTypeAnnotationsOnRecords.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Verify that annotation processing works for records
 27  * @library /tools/lib /tools/javac/lib
 28  * @modules
 29  *      jdk.compiler/com.sun.tools.javac.api
 30  *      jdk.compiler/com.sun.tools.javac.main
 31  *      jdk.compiler/com.sun.tools.javac.code
 32  *      jdk.compiler/com.sun.tools.javac.util
 33  * @build toolbox.ToolBox toolbox.JavacTask
 34  * @build JavacTestingAbstractProcessor
 35  * @compile --enable-preview -source ${jdk.version} CheckingTypeAnnotationsOnRecords.java
 36  * @run main/othervm --enable-preview CheckingTypeAnnotationsOnRecords
 37  */
 38 
 39 import java.io.*;
 40 import java.nio.file.Files;
 41 import java.nio.file.Path;
 42 import java.nio.file.Paths;
 43 import java.util.*;
 44 
 45 import javax.annotation.processing.*;
 46 import javax.lang.model.SourceVersion;
 47 import javax.lang.model.element.Element;
 48 import javax.lang.model.element.ElementKind;
 49 import javax.lang.model.element.RecordComponentElement;
 50 import javax.lang.model.element.TypeElement;
 51 import javax.lang.model.element.VariableElement;
 52 import javax.lang.model.type.TypeKind;
 53 import javax.lang.model.util.ElementFilter;
 54 import javax.lang.model.util.ElementScanner14;
 55 import javax.tools.Diagnostic.Kind;
 56 import javax.tools.*;
 57 
 58 import java.lang.annotation.*;
 59 import java.util.*;
 60 import javax.annotation.processing.*;
 61 import javax.lang.model.element.*;
 62 import javax.lang.model.type.*;
 63 import javax.tools.Diagnostic.Kind;
 64 
 65 import java.lang.annotation.ElementType;
 66 import java.lang.annotation.Retention;
 67 import java.lang.annotation.RetentionPolicy;
 68 import java.lang.annotation.Target;
 69 
 70 import com.sun.tools.javac.code.Symbol;
 71 import com.sun.tools.javac.code.Symbol.VarSymbol;
 72 
 73 import com.sun.tools.javac.util.Assert;
 74 
 75 import toolbox.JavacTask;
 76 import toolbox.Task;
 77 import toolbox.Task.Mode;
 78 import toolbox.Task.OutputKind;
 79 import toolbox.TestRunner;
 80 import toolbox.ToolBox;
 81 
 82 public class CheckingTypeAnnotationsOnRecords extends TestRunner {
 83     protected ToolBox tb;
 84 
 85     CheckingTypeAnnotationsOnRecords() {
 86         super(System.err);
 87         tb = new ToolBox();
 88     }
 89 
 90     public static void main(String... args) throws Exception {
<a name="2" id="anc2"></a><span class="line-removed"> 91         System.out.println(System.getProperties());</span>
 92         new CheckingTypeAnnotationsOnRecords().runTests();
 93     }
 94 
 95     protected void runTests() throws Exception {
 96         runTests(m -&gt; new Object[] { Paths.get(m.getName()) });
 97     }
 98 
 99     Path[] findJavaFiles(Path... paths) throws IOException {
100         return tb.findJavaFiles(paths);
101     }
102 
103     void checkOutputContains(String log, String... expect) throws Exception {
104         for (String e : expect) {
105             if (!log.contains(e)) {
106                 throw new Exception(&quot;expected output not found: &quot; + e);
107             }
108         }
109     }
110 
111     static final String SOURCE =
112             &quot;&quot;&quot;
113             import java.lang.annotation.*;
114             import java.util.*;
115             import javax.annotation.processing.*;
116             import javax.lang.model.element.*;
117 
118             @Retention(RetentionPolicy.RUNTIME)
119             @Target({ ElementType.TYPE_USE })
120             @interface TypeUse {}
121 
122             record R1(@TypeUse int annotated) {}
123 
124             record R2(@TypeUse String annotated) {}
125 
126             record R3(@TypeUse String... annotated) {}
127 
128             @Retention(RetentionPolicy.RUNTIME)
129             @Target({ ElementType.TYPE_PARAMETER })
130             @interface TypeParameter {}
131 
132             record R4&lt;@TypeParameter T&gt;(T t) {}
133             &quot;&quot;&quot;;
134 
135     @Test
136     public void testAnnoProcessing(Path base) throws Exception {
137         Path src = base.resolve(&quot;src&quot;);
138         Path r = src.resolve(&quot;Records&quot;);
139 
140         Path classes = base.resolve(&quot;classes&quot;);
141 
142         Files.createDirectories(classes);
143 
144         tb.writeJavaFiles(r, SOURCE);
145 
146         for (Mode mode : new Mode[] {Mode.API}) {
147             new JavacTask(tb, mode)
148                     .options(&quot;-nowarn&quot;,
149                             &quot;-processor&quot;, Processor.class.getName(),
150                             &quot;--enable-preview&quot;,
151                             &quot;-source&quot;, Integer.toString(Runtime.version().feature()))
152                     .files(findJavaFiles(src))
153                     .outdir(classes)
154                     .run()
155                     .writeAll()
156                     .getOutputLines(Task.OutputKind.DIRECT);
157         }
158     }
159 
160     @SupportedAnnotationTypes(&quot;*&quot;)
161     public static final class Processor extends JavacTestingAbstractProcessor {
162 
163         static private final Map&lt;String, String&gt; recordNameExpectedAnnotationMap = new HashMap&lt;&gt;();
164         static private final Map&lt;String, Integer&gt; recordNameExpectedAnnotationNumberMap = new HashMap&lt;&gt;();
165         static {
166             recordNameExpectedAnnotationMap.put(&quot;R1&quot;, &quot;@TypeUse&quot;);
167             recordNameExpectedAnnotationMap.put(&quot;R2&quot;, &quot;@TypeUse&quot;);
168             recordNameExpectedAnnotationMap.put(&quot;R3&quot;, &quot;@TypeUse&quot;);
169             recordNameExpectedAnnotationMap.put(&quot;R4&quot;, &quot;@TypeParameter&quot;);
170 
171             recordNameExpectedAnnotationNumberMap.put(&quot;R1&quot;, 4);
172             recordNameExpectedAnnotationNumberMap.put(&quot;R2&quot;, 4);
173             recordNameExpectedAnnotationNumberMap.put(&quot;R3&quot;, 4);
174             recordNameExpectedAnnotationNumberMap.put(&quot;R4&quot;, 1);
175         }
176 
177         @Override
178         public boolean process(Set&lt;? extends TypeElement&gt; annotations,
179                                RoundEnvironment roundEnv) {
180             if (roundEnv.processingOver()) {
181                 for (String key : recordNameExpectedAnnotationMap.keySet()) {
182                     Element element = processingEnv.getElementUtils().getTypeElement(key);
183                     numberOfAnnotations = 0;
184                     verifyReferredTypesAcceptable(element, recordNameExpectedAnnotationMap.get(key));
185                     Assert.check(numberOfAnnotations == recordNameExpectedAnnotationNumberMap.get(key), &quot;expected = &quot; +
186                             recordNameExpectedAnnotationNumberMap.get(key) + &quot; found = &quot; + numberOfAnnotations);
187                 }
188             }
189             return true;
190         }
191 
192         int numberOfAnnotations = 0;
193 
194         private void verifyReferredTypesAcceptable(Element rootElement, String expectedAnnotationName) {
195             new ElementScanner&lt;Void, Void&gt;() {
196                 @Override public Void visitType(TypeElement e, Void p) {
197                     scan(e.getTypeParameters(), p);
198                     scan(e.getEnclosedElements(), p);
199                     verifyAnnotations(e.getAnnotationMirrors(), expectedAnnotationName);
200                     return null;
201                 }
202                 @Override public Void visitTypeParameter(TypeParameterElement e, Void p) {
203                     verifyTypesAcceptable(e.getBounds(), expectedAnnotationName);
204                     scan(e.getEnclosedElements(), p);
205                     verifyAnnotations(e.getAnnotationMirrors(), expectedAnnotationName);
206                     return null;
207                 }
208                 @Override public Void visitVariable(VariableElement e, Void p) {
209                     verifyTypeAcceptable(e.asType(), expectedAnnotationName);
210                     scan(e.getEnclosedElements(), p);
211                     verifyAnnotations(e.getAnnotationMirrors(), expectedAnnotationName);
212                     return null;
213                 }
214                 @Override
215                 public Void visitExecutable(ExecutableElement e, Void p) {
216                     scan(e.getTypeParameters(), p);
217                     verifyTypeAcceptable(e.getReturnType(), expectedAnnotationName);
218                     scan(e.getParameters(), p);
219                     verifyTypesAcceptable(e.getThrownTypes(), expectedAnnotationName);
220                     scan(e.getEnclosedElements(), p);
221                     verifyAnnotations(e.getAnnotationMirrors(), expectedAnnotationName);
222                     return null;
223                 }
224                 @Override public Void visitRecordComponent(RecordComponentElement e, Void p) {
225                     verifyTypeAcceptable(e.asType(), expectedAnnotationName);
226                     scan(e.getEnclosedElements(), p);
227                     verifyAnnotations(e.getAnnotationMirrors(), expectedAnnotationName);
228                     return null;
229                 }
230             }.scan(rootElement, null);
231         }
232 
233         private void verifyAnnotations(Iterable&lt;? extends AnnotationMirror&gt; annotations, String expectedName) {
234             for (AnnotationMirror mirror : annotations) {
235                 Assert.check(mirror.toString().equals(expectedName));
236                 numberOfAnnotations++;
237             }
238         }
239 
240         private void verifyTypesAcceptable(Iterable&lt;? extends TypeMirror&gt; types, String expectedAnnotationName) {
241             if (types == null) return ;
242 
243             for (TypeMirror type : types) {
244                 verifyTypeAcceptable(type, expectedAnnotationName);
245             }
246         }
247 
248         private void verifyTypeAcceptable(TypeMirror type, String expectedAnnotationName) {
249             if (type == null) return ;
250 
251             verifyAnnotations(type.getAnnotationMirrors(), expectedAnnotationName);
252 
253             switch (type.getKind()) {
254                 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FLOAT:
255                 case INT: case LONG: case SHORT: case VOID: case NONE: case NULL:
256                     return ;
257                 case DECLARED:
258                     DeclaredType dt = (DeclaredType) type;
259                     TypeElement outermostTypeElement = outermostTypeElement(dt.asElement());
260                     String outermostType = outermostTypeElement.getQualifiedName().toString();
261 
262                     for (TypeMirror bound : dt.getTypeArguments()) {
263                         verifyTypeAcceptable(bound, expectedAnnotationName);
264                     }
265                     break;
266                 case ARRAY:
267                     verifyTypeAcceptable(((ArrayType) type).getComponentType(), expectedAnnotationName);
268                     break;
269                 case INTERSECTION:
270                     for (TypeMirror element : ((IntersectionType) type).getBounds()) {
271                         verifyTypeAcceptable(element, expectedAnnotationName);
272                     }
273                     break;
274                 case TYPEVAR:
275                     verifyTypeAcceptable(((TypeVariable) type).getLowerBound(), expectedAnnotationName);
276                     verifyTypeAcceptable(((TypeVariable) type).getUpperBound(), expectedAnnotationName);
277                     break;
278                 case WILDCARD:
279                     verifyTypeAcceptable(((WildcardType) type).getExtendsBound(), expectedAnnotationName);
280                     verifyTypeAcceptable(((WildcardType) type).getSuperBound(), expectedAnnotationName);
281                     break;
282                 default:
283                     error(&quot;Type not acceptable for this API: &quot; + type.toString());
284                     break;
285 
286             }
287         }
288 
289         private TypeElement outermostTypeElement(Element el) {
290             while (el.getEnclosingElement().getKind() != ElementKind.PACKAGE) {
291                 el = el.getEnclosingElement();
292             }
293 
294             return (TypeElement) el;
295         }
296 
297         private void error(String text) {
298             processingEnv.getMessager().printMessage(Kind.ERROR, text);
299         }
300     }
301 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
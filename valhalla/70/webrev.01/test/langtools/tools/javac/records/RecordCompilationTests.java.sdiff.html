<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/langtools/tools/javac/records/RecordCompilationTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../processing/model/element/TestRecordDesugar.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="RecordMemberTests.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/tools/javac/records/RecordCompilationTests.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /**
  27  * RecordCompilationTests
  28  *
  29  * @test
  30  * @summary Negative compilation tests, and positive compilation (smoke) tests for records
  31  * @library /lib/combo /tools/lib /tools/javac/lib
  32  * @modules
  33  *      jdk.compiler/com.sun.tools.javac.api
  34  *      jdk.compiler/com.sun.tools.javac.code
  35  *      jdk.compiler/com.sun.tools.javac.util
  36  *      jdk.jdeps/com.sun.tools.classfile
  37  * @build JavacTestingAbstractProcessor
  38  * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java
<span class="line-modified">  39  * @run testng/othervm --enable-preview RecordCompilationTests</span>

  40  */
  41 
  42 import java.io.File;
  43 
  44 import java.lang.annotation.ElementType;
  45 import java.util.Arrays;
  46 import java.util.EnumMap;
  47 import java.util.EnumSet;
  48 import java.util.HashSet;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.Set;
  52 import java.util.stream.Collectors;
  53 import java.util.stream.Stream;
  54 
  55 
  56 import com.sun.tools.javac.util.Assert;
  57 

  58 import javax.annotation.processing.RoundEnvironment;
  59 import javax.annotation.processing.SupportedAnnotationTypes;
  60 
  61 import javax.lang.model.element.AnnotationMirror;
  62 import javax.lang.model.element.AnnotationValue;
  63 import javax.lang.model.element.Element;
  64 import javax.lang.model.element.ElementKind;
  65 import javax.lang.model.element.ExecutableElement;
  66 import javax.lang.model.element.RecordComponentElement;
  67 import javax.lang.model.element.TypeElement;
  68 import javax.lang.model.element.VariableElement;
  69 
  70 import javax.lang.model.type.ArrayType;
  71 import javax.lang.model.type.TypeMirror;
  72 

  73 import com.sun.tools.classfile.Annotation;
  74 import com.sun.tools.classfile.Attribute;
  75 import com.sun.tools.classfile.Attributes;
  76 import com.sun.tools.classfile.ClassFile;

  77 import com.sun.tools.classfile.ConstantPool;

  78 import com.sun.tools.classfile.ConstantPool.CPInfo;
  79 import com.sun.tools.classfile.Field;

  80 import com.sun.tools.classfile.Method;
  81 import com.sun.tools.classfile.Record_attribute;
  82 import com.sun.tools.classfile.Record_attribute.ComponentInfo;
  83 import com.sun.tools.classfile.RuntimeAnnotations_attribute;
  84 import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;
  85 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
  86 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
  87 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
  88 import com.sun.tools.classfile.TypeAnnotation;
  89 
  90 import com.sun.tools.javac.api.ClientCodeWrapper.DiagnosticSourceUnwrapper;
  91 import com.sun.tools.javac.code.Attribute.TypeCompound;
  92 import com.sun.tools.javac.code.Symbol;
  93 import com.sun.tools.javac.code.Symbol.VarSymbol;
  94 import com.sun.tools.javac.util.JCDiagnostic;
  95 
  96 import org.testng.annotations.Test;
  97 import tools.javac.combo.CompilationTestCase;
  98 
  99 import static java.lang.annotation.ElementType.*;
 100 import static org.testng.Assert.assertEquals;
 101 












 102 @Test
 103 public class RecordCompilationTests extends CompilationTestCase {
<span class="line-removed"> 104 </span>
 105     // @@@ When records become a permanent feature, we don&#39;t need these any more
<span class="line-modified"> 106     private static String[] PREVIEW_OPTIONS = {&quot;--enable-preview&quot;, &quot;-source&quot;,</span>
<span class="line-modified"> 107                                                Integer.toString(Runtime.version().feature())};</span>








 108 
 109     private static final List&lt;String&gt; BAD_COMPONENT_NAMES = List.of(
 110             &quot;clone&quot;, &quot;finalize&quot;, &quot;getClass&quot;, &quot;hashCode&quot;,
 111             &quot;notify&quot;, &quot;notifyAll&quot;, &quot;toString&quot;, &quot;wait&quot;);
 112 
<span class="line-modified"> 113     {</span>











 114         setDefaultFilename(&quot;R.java&quot;);
<span class="line-modified"> 115         setCompileOptions(PREVIEW_OPTIONS);</span>

 116     }
 117 
 118     public void testMalformedDeclarations() {
 119         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R()&quot;);
 120         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R();&quot;);
 121         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R(,) { }&quot;);
 122         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R((int x)) { }&quot;);
 123         assertFail(&quot;compiler.err.record.header.expected&quot;, &quot;record R { }&quot;);
 124         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(foo) { }&quot;);
 125         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int int) { }&quot;);
 126         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;abstract record R(String foo) { }&quot;);
 127         //assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;non-sealed record R(String foo) { }&quot;);
 128         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;public public record R(String foo) { }&quot;);
 129         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;private private record R(String foo) { }&quot;);
 130         assertFail(&quot;compiler.err.already.defined&quot;, &quot;record R(int x, int x) {}&quot;);
 131         for (String s : List.of(&quot;var&quot;, &quot;record&quot;))
 132             assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, &quot;record R(# x) { }&quot;, s);
<span class="line-modified"> 133         for (String s : List.of(&quot;public&quot;, &quot;private&quot;, &quot;volatile&quot;, &quot;final&quot;))</span>

 134             assertFail(&quot;compiler.err.record.cant.declare.field.modifiers&quot;, &quot;record R(# String foo) { }&quot;, s);
 135         assertFail(&quot;compiler.err.varargs.must.be.last&quot;, &quot;record R(int... x, int... y) {}&quot;);
 136         assertFail(&quot;compiler.err.instance.initializer.not.allowed.in.records&quot;, &quot;record R(int i) { {} }&quot;);
 137     }
 138 
 139     public void testGoodDeclarations() {
 140         assertOK(&quot;public record R() { }&quot;);
 141         assertOK(&quot;record R() { }&quot;);
 142         assertOK(&quot;record R() implements java.io.Serializable, Runnable { public void run() { } }&quot;);
 143         assertOK(&quot;record R(int x) { }&quot;);
 144         assertOK(&quot;record R(int x, int y) { }&quot;);
 145         assertOK(&quot;record R(int... xs) { }&quot;);
 146         assertOK(&quot;record R(String... ss) { }&quot;);
 147         assertOK(&quot;@Deprecated record R(int x, int y) { }&quot;);
 148         assertOK(&quot;record R(@Deprecated int x, int y) { }&quot;);
 149         assertOK(&quot;record R&lt;T&gt;(T x, T y) { }&quot;);
 150     }
 151 
 152     public void testGoodMemberDeclarations() {
 153         String template = &quot;public record R(int x) {\n&quot;
</pre>
<hr />
<pre>
 193         )) {
 194             assertOK(&quot;record R(int i) { # }&quot;, s);
 195         }
 196     }
 197 
 198     public void testCyclic() {
 199         // Cyclic records are OK, but cyclic inline records would not be
 200         assertOK(&quot;record R(R r) { }&quot;);
 201     }
 202 
 203     public void testBadExtends() {
 204         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) extends Object { }&quot;);
 205         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) {}\n&quot;
 206                 + &quot;record R2(int x) extends R { }&quot;);
 207         assertFail(&quot;compiler.err.cant.inherit.from.final&quot;, &quot;record R(int x) {}\n&quot;
 208                 + &quot;class C extends R { }&quot;);
 209     }
 210 
 211     public void testNoExtendRecord() {
 212         assertFail(&quot;compiler.err.invalid.supertype.record&quot;,
<span class="line-modified"> 213                    &quot;class R extends Record { public String toString() { return null; } public int hashCode() { return 0; } public boolean equals(Object o) { return false; } } }&quot;);</span>







 214     }
 215 
 216     public void testFieldDeclarations() {
 217         // static fields are OK
 218         assertOK(&quot;public record R(int x) {\n&quot; +
 219                 &quot;    static int I = 1;\n&quot; +
 220                 &quot;    static final String S = \&quot;Hello World!\&quot;;\n&quot; +
 221                 &quot;    static private Object O = null;\n&quot; +
 222                 &quot;    static protected Object O2 = null;\n&quot; +
 223                 &quot;}&quot;);
 224 
 225         // instance fields are not
 226         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 227                 &quot;public record R(int x) {\n&quot; +
 228                         &quot;    private final int y = 0;&quot; +
 229                         &quot;}&quot;);
 230 
 231         // mutable instance fields definitely not
 232         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 233                 &quot;public record R(int x) {\n&quot; +
 234                         &quot;    private int y = 0;&quot; +
 235                         &quot;}&quot;);
 236 
 237         // redeclaring components also not
 238         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 239                 &quot;public record R(int x) {\n&quot; +
 240                         &quot;    private final int x;&quot; +
 241                         &quot;}&quot;);
 242     }
 243 
 244     public void testAccessorRedeclaration() {
 245         assertOK(&quot;public record R(int x) {\n&quot; +
 246                 &quot;    public int x() { return x; };&quot; +
 247                 &quot;}&quot;);
 248 








 249         assertOK(&quot;public record R(int x) {\n&quot; +
 250                 &quot;    public final int x() { return 0; };&quot; +
 251                 &quot;}&quot;);
 252 
 253         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 254                 &quot;public record R(int x) {\n&quot; +
 255                         &quot;    final int x() { return 0; };&quot; +
 256                         &quot;}&quot;);
 257 
 258         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 259                 &quot;public record R(int x) {\n&quot; +
 260                         &quot;    int x() { return 0; };&quot; +
 261                         &quot;}&quot;);
 262 
 263         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 264                 &quot;public record R(int x) {\n&quot; +
 265                         &quot;    private int x() { return 0; };&quot; +
 266                         &quot;}&quot;);
 267 
 268         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
</pre>
<hr />
<pre>
 276                             &quot;public record R(List&lt;String&gt; x) {\n&quot; +
 277                             &quot;    public # x() { return null; };&quot; +
 278                             &quot;}&quot;, s);
 279 
 280         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 281                 &quot;public record R(int x) {\n&quot; +
 282                         &quot;    public &lt;T&gt; int x() { return x; };&quot; +
 283                         &quot;}&quot;);
 284 
 285         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 286                 &quot;public record R(int x) {\n&quot; +
 287                         &quot;    static private final j = 0;&quot; +
 288                         &quot;    static public int x() { return j; };&quot; +
 289                         &quot;}&quot;);
 290     }
 291 
 292     public void testConstructorRedeclaration() {
 293         for (String goodCtor : List.of(
 294                 &quot;public R(int x) { this(x, 0); }&quot;,
 295                 &quot;public R(int x, int y) { this.x = x; this.y = y; }&quot;,
<span class="line-modified"> 296                 &quot;public R { }&quot;,</span>
<span class="line-removed"> 297                 &quot;public R { this.x = 0; }&quot;))</span>
 298             assertOK(&quot;record R(int x, int y) { # }&quot;, goodCtor);
 299 
 300         assertOK(&quot;import java.util.*; record R(String x, String y) {  public R { Objects.requireNonNull(x); Objects.requireNonNull(y); } }&quot;);
 301 
 302         // Not OK to redeclare canonical without DA
 303         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x, int y) { # }&quot;,
 304                    &quot;public R(int x, int y) { this.x = x; }&quot;);
 305 
 306         // Not OK to rearrange or change names
 307         for (String s : List.of(&quot;public R(int y, int x) { this.x = x; this.y = y; }&quot;,
 308                                 &quot;public R(int _x, int _y) { this.x = _x; this.y = _y; }&quot;))
 309             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;, s);
 310 
<span class="line-removed"> 311         // canonical ctor must be public</span>
<span class="line-removed"> 312         for (String s : List.of(&quot;&quot;, &quot;protected&quot;, &quot;private&quot;))</span>
<span class="line-removed"> 313             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;,</span>
<span class="line-removed"> 314                        &quot;# R(int x, int y) { this.x = x; this.y = y; }&quot;,</span>
<span class="line-removed"> 315                        s);</span>
<span class="line-removed"> 316 </span>
 317         // ctor args must match types
 318         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 319                 &quot;import java.util.*;\n&quot; +
 320                         &quot;record R(List&lt;String&gt; list) { # }&quot;,
 321                 &quot;R(List list) { this.list = list; }&quot;);
 322 
 323         // canonical ctor should not throw checked exceptions
 324         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 325                    &quot;record R() { # }&quot;,
 326                    &quot;public R() throws Exception { }&quot;);
 327 
 328         // same for compact
 329         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 330                 &quot;record R() { # }&quot;,
 331                 &quot;public R throws Exception { }&quot;);
 332 
 333         // not even unchecked exceptions
 334         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 335                 &quot;record R() { # }&quot;,
 336                  &quot;public R() throws IllegalArgumentException { }&quot;);
</pre>
<hr />
<pre>
 417                                 &quot;private static&quot;, &quot;public static&quot;, &quot;private static final&quot;))
 418             assertOK(template, s);
 419 
 420         for (String s : List.of(&quot;class C { }&quot;,
 421                                 &quot;static class C { }&quot;,
 422                                 &quot;enum X { A; }&quot;,
 423                                 &quot;interface I { }&quot;,
 424                                 &quot;record RR(int y) { }&quot;))
 425             assertOK(&quot;record R(int x) { # }&quot;, s);
 426     }
 427 
 428     public void testDuplicatedMember() {
 429         String template
 430                 = &quot;    record R(int i) {\n&quot; +
 431                   &quot;        public int i() { return i; }\n&quot; +
 432                   &quot;        public int i() { return i; }\n&quot; +
 433                   &quot;    }&quot;;
 434         assertFail(&quot;compiler.err.already.defined&quot;, template);
 435     }
 436 
<span class="line-modified"> 437     public void testLocalRecords() {</span>
<span class="line-removed"> 438         assertOK(&quot;class R { \n&quot; +</span>
<span class="line-removed"> 439                 &quot;    void m() { \n&quot; +</span>
<span class="line-removed"> 440                 &quot;        record RR(int x) { };\n&quot; +</span>
<span class="line-removed"> 441                 &quot;    }\n&quot; +</span>
<span class="line-removed"> 442                 &quot;}&quot;);</span>
<span class="line-removed"> 443 </span>
 444         // local records can also be final
 445         assertOK(&quot;class R { \n&quot; +
 446                 &quot;    void m() { \n&quot; +
 447                 &quot;        final record RR(int x) { };\n&quot; +
 448                 &quot;    }\n&quot; +
 449                 &quot;}&quot;);
 450 
 451         // Cant capture locals
 452         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 453                 &quot;class R { \n&quot; +
 454                         &quot;    void m(int y) { \n&quot; +
 455                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
 456                         &quot;    }\n&quot; +
 457                         &quot;}&quot;);
 458 
 459         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 460                 &quot;class R { \n&quot; +
 461                         &quot;    void m() {\n&quot; +
 462                         &quot;        int y;\n&quot; +
 463                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
</pre>
<hr />
<pre>
 471                         &quot;    void m() { \n&quot; +
 472                         &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
 473                         &quot;    }\n&quot; +
 474                         &quot;}&quot;);
 475 
 476         // or type variables
 477         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 478                 &quot;class R&lt;T&gt; { \n&quot; +
 479                         &quot;    void m() { \n&quot; +
 480                         &quot;        record RR(T t) {};\n&quot; +
 481                         &quot;    }\n&quot; +
 482                         &quot;}&quot;);
 483 
 484         // but static fields are OK
 485         assertOK(&quot;class R { \n&quot; +
 486                 &quot;    static int z = 0;\n&quot; +
 487                 &quot;    void m() { \n&quot; +
 488                 &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
 489                 &quot;    }\n&quot; +
 490                 &quot;}&quot;);
<span class="line-removed"> 491         // can be contained inside a lambda</span>
<span class="line-removed"> 492         assertOK(&quot;&quot;&quot;</span>
<span class="line-removed"> 493                 class Outer {</span>
<span class="line-removed"> 494                     Runnable run = () -&gt; {</span>
<span class="line-removed"> 495                         record TestRecord(int i) {}</span>
<span class="line-removed"> 496                     };</span>
<span class="line-removed"> 497                 }</span>
<span class="line-removed"> 498                 &quot;&quot;&quot;);</span>
<span class="line-removed"> 499 </span>
 500         // Can&#39;t self-shadow
 501         assertFail(&quot;compiler.err.already.defined&quot;,
<span class="line-modified"> 502                    &quot;class R { \n&quot; +</span>
<span class="line-modified"> 503                    &quot;    void m() { \n&quot; +</span>
<span class="line-modified"> 504                    &quot;        record R(int x) { };\n&quot; +</span>
<span class="line-modified"> 505                    &quot;    }\n&quot; +</span>
<span class="line-modified"> 506                    &quot;}&quot;);</span>
<span class="line-modified"> 507     }</span>
<span class="line-modified"> 508 </span>
<span class="line-modified"> 509     public void testCompactDADU() {</span>
<span class="line-modified"> 510         // trivial cases</span>
<span class="line-modified"> 511         assertOK(&quot;record R() { public R {} }&quot;);</span>
<span class="line-modified"> 512         assertOK(&quot;record R(int x) { public R {} }&quot;);</span>
<span class="line-modified"> 513 </span>
<span class="line-modified"> 514         // throwing an unchecked exception</span>
<span class="line-modified"> 515         assertOK(&quot;record R(int x) { public R { if (x &lt; 0) { this.x = x; throw new RuntimeException(); }} }&quot;);</span>
<span class="line-modified"> 516 </span>
<span class="line-modified"> 517         assertOK(&quot;record R(int x) { public R { if (x &lt; 0) { this.x = x; throw new RuntimeException(); }} }&quot;);</span>
<span class="line-modified"> 518 </span>
<span class="line-modified"> 519         // x is not DA nor DU in the body of the constructor hence error</span>
<span class="line-removed"> 520         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x) { # }&quot;,</span>
<span class="line-removed"> 521                 &quot;public R { if (x &lt; 0) { this.x = -x; } }&quot;);</span>
<span class="line-removed"> 522 </span>
<span class="line-removed"> 523         // if static fields are not DA then error</span>
<span class="line-removed"> 524         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,</span>
<span class="line-removed"> 525                 &quot;record R() { # }&quot;, &quot;static final String x;&quot;);</span>
<span class="line-removed"> 526 </span>
<span class="line-removed"> 527         // ditto</span>
<span class="line-removed"> 528         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,</span>
<span class="line-removed"> 529                 &quot;record R() { # }&quot;, &quot;static final String x; public R {}&quot;);</span>
<span class="line-removed"> 530 </span>
<span class="line-removed"> 531         // ditto</span>
<span class="line-removed"> 532         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,</span>
<span class="line-removed"> 533                 &quot;record R(int i) { # }&quot;, &quot;static final String x; public R {}&quot;);</span>
 534     }
 535 
 536     public void testReturnInCanonical_Compact() {
 537         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
 538                 &quot;public R { return; }&quot;);
 539         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
 540                 &quot;public R { if (i &lt; 0) { return; }}&quot;);
 541         assertOK(&quot;record R(int x) { public R(int x) { this.x = x; return; } }&quot;);
 542         assertOK(&quot;record R(int x) { public R { Runnable r = () -&gt; { return; };} }&quot;);
 543     }
 544 
 545     public void testArgumentsAreNotFinalInCompact() {
 546         assertOK(
 547                 &quot;&quot;&quot;
 548                 record R(int x) {
 549                     public R {
 550                         x++;
 551                     }
 552                 }
 553                 &quot;&quot;&quot;);
 554     }
 555 
 556     public void testNoNativeMethods() {
 557         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
 558                 &quot;public native R {}&quot;);
 559         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
 560                 &quot;public native void m();&quot;);
 561     }
 562 
 563     public void testRecordsInsideInner() {
<span class="line-modified"> 564         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,</span>
<span class="line-modified"> 565                 &quot;class Outer {\n&quot; +</span>
<span class="line-modified"> 566                 &quot;    class Inner {\n&quot; +</span>
<span class="line-modified"> 567                 &quot;        record R(int a) {}\n&quot; +</span>
<span class="line-modified"> 568                 &quot;    }\n&quot; +</span>
<span class="line-modified"> 569                 &quot;}&quot;);</span>
<span class="line-modified"> 570         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,</span>



 571                 &quot;&quot;&quot;
 572                 class Outer {
 573                     public void test() {
 574                         class Inner extends Outer {
 575                             record R(int i) {}
 576                         }
 577                     }
 578                 }
 579                 &quot;&quot;&quot;);
<span class="line-modified"> 580         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,</span>
 581                 &quot;&quot;&quot;
 582                 class Outer {
 583                     Runnable run = new Runnable() {
 584                         record TestRecord(int i) {}
 585                         public void run() {}
 586                     };
 587                 }
 588                 &quot;&quot;&quot;);
<span class="line-modified"> 589         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,</span>
 590                 &quot;&quot;&quot;
 591                 class Outer {
 592                     void m() {
 593                         record A() {
 594                             record B() { }
 595                         }
 596                     }
 597                 }
 598                 &quot;&quot;&quot;);
 599     }
 600 
 601     public void testReceiverParameter() {
 602         assertFail(&quot;compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class&quot;,
 603                 &quot;&quot;&quot;
 604                 record R(int i) {
 605                     public R(R this, int i) {
 606                         this.i = i;
 607                     }
 608                 }
 609                 &quot;&quot;&quot;);
</pre>
<hr />
<pre>
 629     public void testOnlyOneFieldRef() throws Exception {
 630         int numberOfFieldRefs = 0;
 631         File dir = assertOK(true, &quot;record R(int recordComponent) {}&quot;);
 632         for (final File fileEntry : dir.listFiles()) {
 633             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
 634                 ClassFile classFile = ClassFile.read(fileEntry);
 635                 for (CPInfo cpInfo : classFile.constant_pool.entries()) {
 636                     if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {
 637                         numberOfFieldRefs++;
 638                         ConstantPool.CONSTANT_NameAndType_info nameAndType =
 639                                 (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool
 640                                         .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);
 641                         Assert.check(nameAndType.getName().equals(&quot;recordComponent&quot;));
 642                     }
 643                 }
 644             }
 645         }
 646         Assert.check(numberOfFieldRefs == 1);
 647     }
 648 









































 649     public void testAcceptRecordId() {
 650         String[] testOptions = {/* no options */};
 651         setCompileOptions(testOptions);
 652         assertOKWithWarning(&quot;compiler.warn.restricted.type.not.allowed.preview&quot;,
 653                 &quot;class R {\n&quot; +
 654                 &quot;    record RR(int i) {\n&quot; +
 655                 &quot;        return null;\n&quot; +
 656                 &quot;    }\n&quot; +
 657                 &quot;    class record {}\n&quot; +
 658                 &quot;}&quot;);
 659         setCompileOptions(PREVIEW_OPTIONS);
 660     }
 661 
 662     public void testAnnos() throws Exception {
 663         String srcTemplate =
 664                 &quot;&quot;&quot;
 665                     import java.lang.annotation.*;
 666                     @Target({#TARGET})
 667                     @Retention(RetentionPolicy.RUNTIME)
 668                     @interface Anno { }
</pre>
<hr />
<pre>
 965                     scan(e.getParameters(), p);
 966                     return null;
 967                 }
 968                 @Override public Void visitRecordComponent(RecordComponentElement e, Void p) {
 969                     int currentTAs = numberOfTypeAnnotations;
 970                     verifyTypeAnnotations(e.asType().getAnnotationMirrors());
 971                     Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
 972                     return null;
 973                 }
 974             }.scan(rootElement, null);
 975         }
 976 
 977         private void verifyTypeAnnotations(Iterable&lt;? extends AnnotationMirror&gt; annotations) {
 978             for (AnnotationMirror mirror : annotations) {
 979                 Assert.check(mirror.toString().startsWith(&quot;@Anno&quot;));
 980                 if (mirror instanceof TypeCompound) {
 981                     numberOfTypeAnnotations++;
 982                 }
 983             }
 984         }

















































 985 



































































































































































































 986     }
 987 }
</pre>
</td>
<td>
<hr />
<pre>
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /**
  27  * RecordCompilationTests
  28  *
  29  * @test
  30  * @summary Negative compilation tests, and positive compilation (smoke) tests for records
  31  * @library /lib/combo /tools/lib /tools/javac/lib
  32  * @modules
  33  *      jdk.compiler/com.sun.tools.javac.api
  34  *      jdk.compiler/com.sun.tools.javac.code
  35  *      jdk.compiler/com.sun.tools.javac.util
  36  *      jdk.jdeps/com.sun.tools.classfile
  37  * @build JavacTestingAbstractProcessor
  38  * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java
<span class="line-modified">  39  * @run testng/othervm -DuseAP=false --enable-preview RecordCompilationTests</span>
<span class="line-added">  40  * @run testng/othervm -DuseAP=true --enable-preview RecordCompilationTests</span>
  41  */
  42 
  43 import java.io.File;
  44 
  45 import java.lang.annotation.ElementType;
  46 import java.util.Arrays;
  47 import java.util.EnumMap;
  48 import java.util.EnumSet;
  49 import java.util.HashSet;
  50 import java.util.List;
  51 import java.util.Map;
  52 import java.util.Set;
  53 import java.util.stream.Collectors;
  54 import java.util.stream.Stream;
  55 
  56 
  57 import com.sun.tools.javac.util.Assert;
  58 
<span class="line-added">  59 import javax.annotation.processing.AbstractProcessor;</span>
  60 import javax.annotation.processing.RoundEnvironment;
  61 import javax.annotation.processing.SupportedAnnotationTypes;
  62 
  63 import javax.lang.model.element.AnnotationMirror;
  64 import javax.lang.model.element.AnnotationValue;
  65 import javax.lang.model.element.Element;
  66 import javax.lang.model.element.ElementKind;
  67 import javax.lang.model.element.ExecutableElement;
  68 import javax.lang.model.element.RecordComponentElement;
  69 import javax.lang.model.element.TypeElement;
  70 import javax.lang.model.element.VariableElement;
  71 
  72 import javax.lang.model.type.ArrayType;
  73 import javax.lang.model.type.TypeMirror;
  74 
<span class="line-added">  75 import com.sun.tools.classfile.AccessFlags;</span>
  76 import com.sun.tools.classfile.Annotation;
  77 import com.sun.tools.classfile.Attribute;
  78 import com.sun.tools.classfile.Attributes;
  79 import com.sun.tools.classfile.ClassFile;
<span class="line-added">  80 import com.sun.tools.classfile.Code_attribute;</span>
  81 import com.sun.tools.classfile.ConstantPool;
<span class="line-added">  82 import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;</span>
  83 import com.sun.tools.classfile.ConstantPool.CPInfo;
  84 import com.sun.tools.classfile.Field;
<span class="line-added">  85 import com.sun.tools.classfile.Instruction;</span>
  86 import com.sun.tools.classfile.Method;
  87 import com.sun.tools.classfile.Record_attribute;
  88 import com.sun.tools.classfile.Record_attribute.ComponentInfo;
  89 import com.sun.tools.classfile.RuntimeAnnotations_attribute;
  90 import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;
  91 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
  92 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
  93 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
  94 import com.sun.tools.classfile.TypeAnnotation;
  95 
  96 import com.sun.tools.javac.api.ClientCodeWrapper.DiagnosticSourceUnwrapper;
  97 import com.sun.tools.javac.code.Attribute.TypeCompound;
  98 import com.sun.tools.javac.code.Symbol;
  99 import com.sun.tools.javac.code.Symbol.VarSymbol;
 100 import com.sun.tools.javac.util.JCDiagnostic;
 101 
 102 import org.testng.annotations.Test;
 103 import tools.javac.combo.CompilationTestCase;
 104 
 105 import static java.lang.annotation.ElementType.*;
 106 import static org.testng.Assert.assertEquals;
 107 
<span class="line-added"> 108 /** Records are the first feature which sports automatic injection of (declarative and type) annotations : from a</span>
<span class="line-added"> 109  *  given record component to one or more record members, if applicable.</span>
<span class="line-added"> 110  *  This implies that the record&#39;s implementation can be stressed with the presence of annotation processors. Which is</span>
<span class="line-added"> 111  *  something the implementator could easily skip. For this reason this test is executed twice, once without the</span>
<span class="line-added"> 112  *  presence of any annotation processor and one with a simple annotation processor (which does not annotation processing</span>
<span class="line-added"> 113  *  at all) just to force at least a round of annotation processing.</span>
<span class="line-added"> 114  *</span>
<span class="line-added"> 115  *  Tests needing special compilation options need to store current options, set its customs options by invoking method</span>
<span class="line-added"> 116  *  `setCompileOptions` and then reset the previous compilation options for other tests. To see an example of this check</span>
<span class="line-added"> 117  *  method: testAnnos()</span>
<span class="line-added"> 118  */</span>
<span class="line-added"> 119 </span>
 120 @Test
 121 public class RecordCompilationTests extends CompilationTestCase {

 122     // @@@ When records become a permanent feature, we don&#39;t need these any more
<span class="line-modified"> 123     private static String[] PREVIEW_OPTIONS = {</span>
<span class="line-modified"> 124             &quot;--enable-preview&quot;,</span>
<span class="line-added"> 125             &quot;-source&quot;, Integer.toString(Runtime.version().feature())</span>
<span class="line-added"> 126     };</span>
<span class="line-added"> 127 </span>
<span class="line-added"> 128     private static String[] PREVIEW_OPTIONS_WITH_AP = {</span>
<span class="line-added"> 129             &quot;--enable-preview&quot;,</span>
<span class="line-added"> 130             &quot;-source&quot;, Integer.toString(Runtime.version().feature()),</span>
<span class="line-added"> 131             &quot;-processor&quot;, SimplestAP.class.getName()</span>
<span class="line-added"> 132     };</span>
 133 
 134     private static final List&lt;String&gt; BAD_COMPONENT_NAMES = List.of(
 135             &quot;clone&quot;, &quot;finalize&quot;, &quot;getClass&quot;, &quot;hashCode&quot;,
 136             &quot;notify&quot;, &quot;notifyAll&quot;, &quot;toString&quot;, &quot;wait&quot;);
 137 
<span class="line-modified"> 138     /* simplest annotation processor just to force a round of annotation processing for all tests</span>
<span class="line-added"> 139      */</span>
<span class="line-added"> 140     @SupportedAnnotationTypes(&quot;*&quot;)</span>
<span class="line-added"> 141     public static class SimplestAP extends AbstractProcessor {</span>
<span class="line-added"> 142         @Override</span>
<span class="line-added"> 143         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {</span>
<span class="line-added"> 144             return true;</span>
<span class="line-added"> 145         }</span>
<span class="line-added"> 146     }</span>
<span class="line-added"> 147 </span>
<span class="line-added"> 148     public RecordCompilationTests() {</span>
<span class="line-added"> 149         boolean useAP = System.getProperty(&quot;useAP&quot;) == null ? false : System.getProperty(&quot;useAP&quot;).equals(&quot;true&quot;);</span>
 150         setDefaultFilename(&quot;R.java&quot;);
<span class="line-modified"> 151         setCompileOptions(useAP ? PREVIEW_OPTIONS_WITH_AP : PREVIEW_OPTIONS);</span>
<span class="line-added"> 152         System.out.println(useAP ? &quot;running all tests using an annotation processor&quot; : &quot;running all tests without annotation processor&quot;);</span>
 153     }
 154 
 155     public void testMalformedDeclarations() {
 156         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R()&quot;);
 157         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R();&quot;);
 158         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R(,) { }&quot;);
 159         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R((int x)) { }&quot;);
 160         assertFail(&quot;compiler.err.record.header.expected&quot;, &quot;record R { }&quot;);
 161         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(foo) { }&quot;);
 162         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int int) { }&quot;);
 163         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;abstract record R(String foo) { }&quot;);
 164         //assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;non-sealed record R(String foo) { }&quot;);
 165         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;public public record R(String foo) { }&quot;);
 166         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;private private record R(String foo) { }&quot;);
 167         assertFail(&quot;compiler.err.already.defined&quot;, &quot;record R(int x, int x) {}&quot;);
 168         for (String s : List.of(&quot;var&quot;, &quot;record&quot;))
 169             assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, &quot;record R(# x) { }&quot;, s);
<span class="line-modified"> 170         for (String s : List.of(&quot;public&quot;, &quot;protected&quot;, &quot;private&quot;, &quot;static&quot;, &quot;final&quot;, &quot;transient&quot;, &quot;volatile&quot;,</span>
<span class="line-added"> 171                 &quot;abstract&quot;, &quot;synchronized&quot;, &quot;native&quot;, &quot;strictfp&quot;)) // missing: sealed and non-sealed</span>
 172             assertFail(&quot;compiler.err.record.cant.declare.field.modifiers&quot;, &quot;record R(# String foo) { }&quot;, s);
 173         assertFail(&quot;compiler.err.varargs.must.be.last&quot;, &quot;record R(int... x, int... y) {}&quot;);
 174         assertFail(&quot;compiler.err.instance.initializer.not.allowed.in.records&quot;, &quot;record R(int i) { {} }&quot;);
 175     }
 176 
 177     public void testGoodDeclarations() {
 178         assertOK(&quot;public record R() { }&quot;);
 179         assertOK(&quot;record R() { }&quot;);
 180         assertOK(&quot;record R() implements java.io.Serializable, Runnable { public void run() { } }&quot;);
 181         assertOK(&quot;record R(int x) { }&quot;);
 182         assertOK(&quot;record R(int x, int y) { }&quot;);
 183         assertOK(&quot;record R(int... xs) { }&quot;);
 184         assertOK(&quot;record R(String... ss) { }&quot;);
 185         assertOK(&quot;@Deprecated record R(int x, int y) { }&quot;);
 186         assertOK(&quot;record R(@Deprecated int x, int y) { }&quot;);
 187         assertOK(&quot;record R&lt;T&gt;(T x, T y) { }&quot;);
 188     }
 189 
 190     public void testGoodMemberDeclarations() {
 191         String template = &quot;public record R(int x) {\n&quot;
</pre>
<hr />
<pre>
 231         )) {
 232             assertOK(&quot;record R(int i) { # }&quot;, s);
 233         }
 234     }
 235 
 236     public void testCyclic() {
 237         // Cyclic records are OK, but cyclic inline records would not be
 238         assertOK(&quot;record R(R r) { }&quot;);
 239     }
 240 
 241     public void testBadExtends() {
 242         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) extends Object { }&quot;);
 243         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) {}\n&quot;
 244                 + &quot;record R2(int x) extends R { }&quot;);
 245         assertFail(&quot;compiler.err.cant.inherit.from.final&quot;, &quot;record R(int x) {}\n&quot;
 246                 + &quot;class C extends R { }&quot;);
 247     }
 248 
 249     public void testNoExtendRecord() {
 250         assertFail(&quot;compiler.err.invalid.supertype.record&quot;,
<span class="line-modified"> 251                    &quot;&quot;&quot;</span>
<span class="line-added"> 252                    class R extends Record {</span>
<span class="line-added"> 253                        public String toString() { return null; }</span>
<span class="line-added"> 254                        public int hashCode() { return 0; }</span>
<span class="line-added"> 255                        public boolean equals(Object o) { return false; }</span>
<span class="line-added"> 256                    }</span>
<span class="line-added"> 257                    &quot;&quot;&quot;</span>
<span class="line-added"> 258         );</span>
 259     }
 260 
 261     public void testFieldDeclarations() {
 262         // static fields are OK
 263         assertOK(&quot;public record R(int x) {\n&quot; +
 264                 &quot;    static int I = 1;\n&quot; +
 265                 &quot;    static final String S = \&quot;Hello World!\&quot;;\n&quot; +
 266                 &quot;    static private Object O = null;\n&quot; +
 267                 &quot;    static protected Object O2 = null;\n&quot; +
 268                 &quot;}&quot;);
 269 
 270         // instance fields are not
 271         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 272                 &quot;public record R(int x) {\n&quot; +
 273                         &quot;    private final int y = 0;&quot; +
 274                         &quot;}&quot;);
 275 
 276         // mutable instance fields definitely not
 277         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 278                 &quot;public record R(int x) {\n&quot; +
 279                         &quot;    private int y = 0;&quot; +
 280                         &quot;}&quot;);
 281 
 282         // redeclaring components also not
 283         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 284                 &quot;public record R(int x) {\n&quot; +
 285                         &quot;    private final int x;&quot; +
 286                         &quot;}&quot;);
 287     }
 288 
 289     public void testAccessorRedeclaration() {
 290         assertOK(&quot;public record R(int x) {\n&quot; +
 291                 &quot;    public int x() { return x; };&quot; +
 292                 &quot;}&quot;);
 293 
<span class="line-added"> 294         assertOK(&quot;public record R(int... x) {\n&quot; +</span>
<span class="line-added"> 295                 &quot;    public int[] x() { return x; };&quot; +</span>
<span class="line-added"> 296                 &quot;}&quot;);</span>
<span class="line-added"> 297 </span>
<span class="line-added"> 298         assertOK(&quot;public record R(int x) {\n&quot; +</span>
<span class="line-added"> 299                 &quot;    public final int x() { return 0; };&quot; +</span>
<span class="line-added"> 300                 &quot;}&quot;);</span>
<span class="line-added"> 301 </span>
 302         assertOK(&quot;public record R(int x) {\n&quot; +
 303                 &quot;    public final int x() { return 0; };&quot; +
 304                 &quot;}&quot;);
 305 
 306         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 307                 &quot;public record R(int x) {\n&quot; +
 308                         &quot;    final int x() { return 0; };&quot; +
 309                         &quot;}&quot;);
 310 
 311         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 312                 &quot;public record R(int x) {\n&quot; +
 313                         &quot;    int x() { return 0; };&quot; +
 314                         &quot;}&quot;);
 315 
 316         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 317                 &quot;public record R(int x) {\n&quot; +
 318                         &quot;    private int x() { return 0; };&quot; +
 319                         &quot;}&quot;);
 320 
 321         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
</pre>
<hr />
<pre>
 329                             &quot;public record R(List&lt;String&gt; x) {\n&quot; +
 330                             &quot;    public # x() { return null; };&quot; +
 331                             &quot;}&quot;, s);
 332 
 333         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 334                 &quot;public record R(int x) {\n&quot; +
 335                         &quot;    public &lt;T&gt; int x() { return x; };&quot; +
 336                         &quot;}&quot;);
 337 
 338         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 339                 &quot;public record R(int x) {\n&quot; +
 340                         &quot;    static private final j = 0;&quot; +
 341                         &quot;    static public int x() { return j; };&quot; +
 342                         &quot;}&quot;);
 343     }
 344 
 345     public void testConstructorRedeclaration() {
 346         for (String goodCtor : List.of(
 347                 &quot;public R(int x) { this(x, 0); }&quot;,
 348                 &quot;public R(int x, int y) { this.x = x; this.y = y; }&quot;,
<span class="line-modified"> 349                 &quot;public R { }&quot;))</span>

 350             assertOK(&quot;record R(int x, int y) { # }&quot;, goodCtor);
 351 
 352         assertOK(&quot;import java.util.*; record R(String x, String y) {  public R { Objects.requireNonNull(x); Objects.requireNonNull(y); } }&quot;);
 353 
 354         // Not OK to redeclare canonical without DA
 355         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x, int y) { # }&quot;,
 356                    &quot;public R(int x, int y) { this.x = x; }&quot;);
 357 
 358         // Not OK to rearrange or change names
 359         for (String s : List.of(&quot;public R(int y, int x) { this.x = x; this.y = y; }&quot;,
 360                                 &quot;public R(int _x, int _y) { this.x = _x; this.y = _y; }&quot;))
 361             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;, s);
 362 






 363         // ctor args must match types
 364         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 365                 &quot;import java.util.*;\n&quot; +
 366                         &quot;record R(List&lt;String&gt; list) { # }&quot;,
 367                 &quot;R(List list) { this.list = list; }&quot;);
 368 
 369         // canonical ctor should not throw checked exceptions
 370         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 371                    &quot;record R() { # }&quot;,
 372                    &quot;public R() throws Exception { }&quot;);
 373 
 374         // same for compact
 375         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 376                 &quot;record R() { # }&quot;,
 377                 &quot;public R throws Exception { }&quot;);
 378 
 379         // not even unchecked exceptions
 380         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 381                 &quot;record R() { # }&quot;,
 382                  &quot;public R() throws IllegalArgumentException { }&quot;);
</pre>
<hr />
<pre>
 463                                 &quot;private static&quot;, &quot;public static&quot;, &quot;private static final&quot;))
 464             assertOK(template, s);
 465 
 466         for (String s : List.of(&quot;class C { }&quot;,
 467                                 &quot;static class C { }&quot;,
 468                                 &quot;enum X { A; }&quot;,
 469                                 &quot;interface I { }&quot;,
 470                                 &quot;record RR(int y) { }&quot;))
 471             assertOK(&quot;record R(int x) { # }&quot;, s);
 472     }
 473 
 474     public void testDuplicatedMember() {
 475         String template
 476                 = &quot;    record R(int i) {\n&quot; +
 477                   &quot;        public int i() { return i; }\n&quot; +
 478                   &quot;        public int i() { return i; }\n&quot; +
 479                   &quot;    }&quot;;
 480         assertFail(&quot;compiler.err.already.defined&quot;, template);
 481     }
 482 
<span class="line-modified"> 483     public void testStaticLocalTypes() {</span>






 484         // local records can also be final
 485         assertOK(&quot;class R { \n&quot; +
 486                 &quot;    void m() { \n&quot; +
 487                 &quot;        final record RR(int x) { };\n&quot; +
 488                 &quot;    }\n&quot; +
 489                 &quot;}&quot;);
 490 
 491         // Cant capture locals
 492         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 493                 &quot;class R { \n&quot; +
 494                         &quot;    void m(int y) { \n&quot; +
 495                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
 496                         &quot;    }\n&quot; +
 497                         &quot;}&quot;);
 498 
 499         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 500                 &quot;class R { \n&quot; +
 501                         &quot;    void m() {\n&quot; +
 502                         &quot;        int y;\n&quot; +
 503                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
</pre>
<hr />
<pre>
 511                         &quot;    void m() { \n&quot; +
 512                         &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
 513                         &quot;    }\n&quot; +
 514                         &quot;}&quot;);
 515 
 516         // or type variables
 517         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 518                 &quot;class R&lt;T&gt; { \n&quot; +
 519                         &quot;    void m() { \n&quot; +
 520                         &quot;        record RR(T t) {};\n&quot; +
 521                         &quot;    }\n&quot; +
 522                         &quot;}&quot;);
 523 
 524         // but static fields are OK
 525         assertOK(&quot;class R { \n&quot; +
 526                 &quot;    static int z = 0;\n&quot; +
 527                 &quot;    void m() { \n&quot; +
 528                 &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
 529                 &quot;    }\n&quot; +
 530                 &quot;}&quot;);









 531         // Can&#39;t self-shadow
 532         assertFail(&quot;compiler.err.already.defined&quot;,
<span class="line-modified"> 533                 &quot;&quot;&quot;</span>
<span class="line-modified"> 534                 class R {</span>
<span class="line-modified"> 535                     void m() {</span>
<span class="line-modified"> 536                         record R(int x) { };</span>
<span class="line-modified"> 537                     }</span>
<span class="line-modified"> 538                 }</span>
<span class="line-modified"> 539                 &quot;&quot;&quot;</span>
<span class="line-modified"> 540         );</span>
<span class="line-modified"> 541         // can&#39;t be explicitly static</span>
<span class="line-modified"> 542         assertFail(&quot;compiler.err.illegal.start.of.expr&quot;,</span>
<span class="line-modified"> 543                 &quot;&quot;&quot;</span>
<span class="line-modified"> 544                 class R {</span>
<span class="line-modified"> 545                     void m() {</span>
<span class="line-modified"> 546                         static record RR(int x) { };</span>
<span class="line-modified"> 547                     }</span>
<span class="line-modified"> 548                 }</span>
<span class="line-modified"> 549                 &quot;&quot;&quot;</span>
<span class="line-modified"> 550         );</span>














 551     }
 552 
 553     public void testReturnInCanonical_Compact() {
 554         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
 555                 &quot;public R { return; }&quot;);
 556         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
 557                 &quot;public R { if (i &lt; 0) { return; }}&quot;);
 558         assertOK(&quot;record R(int x) { public R(int x) { this.x = x; return; } }&quot;);
 559         assertOK(&quot;record R(int x) { public R { Runnable r = () -&gt; { return; };} }&quot;);
 560     }
 561 
 562     public void testArgumentsAreNotFinalInCompact() {
 563         assertOK(
 564                 &quot;&quot;&quot;
 565                 record R(int x) {
 566                     public R {
 567                         x++;
 568                     }
 569                 }
 570                 &quot;&quot;&quot;);
 571     }
 572 
 573     public void testNoNativeMethods() {
 574         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
 575                 &quot;public native R {}&quot;);
 576         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
 577                 &quot;public native void m();&quot;);
 578     }
 579 
 580     public void testRecordsInsideInner() {
<span class="line-modified"> 581         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,</span>
<span class="line-modified"> 582                 &quot;&quot;&quot;</span>
<span class="line-modified"> 583                 class Outer {</span>
<span class="line-modified"> 584                     class Inner {</span>
<span class="line-modified"> 585                         record R(int a) {}</span>
<span class="line-modified"> 586                     }</span>
<span class="line-modified"> 587                 }</span>
<span class="line-added"> 588                 &quot;&quot;&quot;</span>
<span class="line-added"> 589         );</span>
<span class="line-added"> 590         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,</span>
 591                 &quot;&quot;&quot;
 592                 class Outer {
 593                     public void test() {
 594                         class Inner extends Outer {
 595                             record R(int i) {}
 596                         }
 597                     }
 598                 }
 599                 &quot;&quot;&quot;);
<span class="line-modified"> 600         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,</span>
 601                 &quot;&quot;&quot;
 602                 class Outer {
 603                     Runnable run = new Runnable() {
 604                         record TestRecord(int i) {}
 605                         public void run() {}
 606                     };
 607                 }
 608                 &quot;&quot;&quot;);
<span class="line-modified"> 609         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,</span>
 610                 &quot;&quot;&quot;
 611                 class Outer {
 612                     void m() {
 613                         record A() {
 614                             record B() { }
 615                         }
 616                     }
 617                 }
 618                 &quot;&quot;&quot;);
 619     }
 620 
 621     public void testReceiverParameter() {
 622         assertFail(&quot;compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class&quot;,
 623                 &quot;&quot;&quot;
 624                 record R(int i) {
 625                     public R(R this, int i) {
 626                         this.i = i;
 627                     }
 628                 }
 629                 &quot;&quot;&quot;);
</pre>
<hr />
<pre>
 649     public void testOnlyOneFieldRef() throws Exception {
 650         int numberOfFieldRefs = 0;
 651         File dir = assertOK(true, &quot;record R(int recordComponent) {}&quot;);
 652         for (final File fileEntry : dir.listFiles()) {
 653             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
 654                 ClassFile classFile = ClassFile.read(fileEntry);
 655                 for (CPInfo cpInfo : classFile.constant_pool.entries()) {
 656                     if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {
 657                         numberOfFieldRefs++;
 658                         ConstantPool.CONSTANT_NameAndType_info nameAndType =
 659                                 (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool
 660                                         .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);
 661                         Assert.check(nameAndType.getName().equals(&quot;recordComponent&quot;));
 662                     }
 663                 }
 664             }
 665         }
 666         Assert.check(numberOfFieldRefs == 1);
 667     }
 668 
<span class="line-added"> 669     /*  check that fields are initialized in a canonical constructor in the same declaration order as the corresponding</span>
<span class="line-added"> 670      *  record component</span>
<span class="line-added"> 671      */</span>
<span class="line-added"> 672     public void testCheckInitializationOrderInCompactConstructor() throws Exception {</span>
<span class="line-added"> 673         int putField1 = -1;</span>
<span class="line-added"> 674         int putField2 = -1;</span>
<span class="line-added"> 675         File dir = assertOK(true, &quot;record R(int i, String s) { R {} }&quot;);</span>
<span class="line-added"> 676         for (final File fileEntry : dir.listFiles()) {</span>
<span class="line-added"> 677             if (fileEntry.getName().equals(&quot;R.class&quot;)) {</span>
<span class="line-added"> 678                 ClassFile classFile = ClassFile.read(fileEntry);</span>
<span class="line-added"> 679                 for (Method method : classFile.methods) {</span>
<span class="line-added"> 680                     if (method.getName(classFile.constant_pool).equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="line-added"> 681                         Code_attribute code_attribute = (Code_attribute) method.attributes.get(&quot;Code&quot;);</span>
<span class="line-added"> 682                         for (Instruction instruction : code_attribute.getInstructions()) {</span>
<span class="line-added"> 683                             if (instruction.getMnemonic().equals(&quot;putfield&quot;)) {</span>
<span class="line-added"> 684                                 if (putField1 != -1 &amp;&amp; putField2 != -1) {</span>
<span class="line-added"> 685                                     throw new AssertionError(&quot;was expecting only two putfield instructions in this method&quot;);</span>
<span class="line-added"> 686                                 }</span>
<span class="line-added"> 687                                 if (putField1 == -1) {</span>
<span class="line-added"> 688                                     putField1 = instruction.getShort(1);</span>
<span class="line-added"> 689                                 } else if (putField2 == -1) {</span>
<span class="line-added"> 690                                     putField2 = instruction.getShort(1);</span>
<span class="line-added"> 691                                 }</span>
<span class="line-added"> 692                             }</span>
<span class="line-added"> 693                         }</span>
<span class="line-added"> 694                         // now we need to check that we are assigning to `i` first and to `s` afterwards</span>
<span class="line-added"> 695                         CONSTANT_Fieldref_info fieldref_info1 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField1);</span>
<span class="line-added"> 696                         if (!fieldref_info1.getNameAndTypeInfo().getName().equals(&quot;i&quot;)) {</span>
<span class="line-added"> 697                             throw new AssertionError(&quot;was expecting variable name &#39;i&#39;&quot;);</span>
<span class="line-added"> 698                         }</span>
<span class="line-added"> 699 </span>
<span class="line-added"> 700                         CONSTANT_Fieldref_info fieldref_info2 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField2);</span>
<span class="line-added"> 701                         if (!fieldref_info2.getNameAndTypeInfo().getName().equals(&quot;s&quot;)) {</span>
<span class="line-added"> 702                             throw new AssertionError(&quot;was expecting variable name &#39;s&#39;&quot;);</span>
<span class="line-added"> 703                         }</span>
<span class="line-added"> 704                     }</span>
<span class="line-added"> 705                 }</span>
<span class="line-added"> 706             }</span>
<span class="line-added"> 707         }</span>
<span class="line-added"> 708     }</span>
<span class="line-added"> 709 </span>
 710     public void testAcceptRecordId() {
 711         String[] testOptions = {/* no options */};
 712         setCompileOptions(testOptions);
 713         assertOKWithWarning(&quot;compiler.warn.restricted.type.not.allowed.preview&quot;,
 714                 &quot;class R {\n&quot; +
 715                 &quot;    record RR(int i) {\n&quot; +
 716                 &quot;        return null;\n&quot; +
 717                 &quot;    }\n&quot; +
 718                 &quot;    class record {}\n&quot; +
 719                 &quot;}&quot;);
 720         setCompileOptions(PREVIEW_OPTIONS);
 721     }
 722 
 723     public void testAnnos() throws Exception {
 724         String srcTemplate =
 725                 &quot;&quot;&quot;
 726                     import java.lang.annotation.*;
 727                     @Target({#TARGET})
 728                     @Retention(RetentionPolicy.RUNTIME)
 729                     @interface Anno { }
</pre>
<hr />
<pre>
1026                     scan(e.getParameters(), p);
1027                     return null;
1028                 }
1029                 @Override public Void visitRecordComponent(RecordComponentElement e, Void p) {
1030                     int currentTAs = numberOfTypeAnnotations;
1031                     verifyTypeAnnotations(e.asType().getAnnotationMirrors());
1032                     Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
1033                     return null;
1034                 }
1035             }.scan(rootElement, null);
1036         }
1037 
1038         private void verifyTypeAnnotations(Iterable&lt;? extends AnnotationMirror&gt; annotations) {
1039             for (AnnotationMirror mirror : annotations) {
1040                 Assert.check(mirror.toString().startsWith(&quot;@Anno&quot;));
1041                 if (mirror instanceof TypeCompound) {
1042                     numberOfTypeAnnotations++;
1043                 }
1044             }
1045         }
<span class="line-added">1046     }</span>
<span class="line-added">1047 </span>
<span class="line-added">1048     public void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {</span>
<span class="line-added">1049         int numberOfFieldRefs = 0;</span>
<span class="line-added">1050         File dir = assertOK(true, &quot;record R() {}&quot;);</span>
<span class="line-added">1051         for (final File fileEntry : dir.listFiles()) {</span>
<span class="line-added">1052             if (fileEntry.getName().equals(&quot;R.class&quot;)) {</span>
<span class="line-added">1053                 ClassFile classFile = ClassFile.read(fileEntry);</span>
<span class="line-added">1054                 for (Method method : classFile.methods)</span>
<span class="line-added">1055                     switch (method.getName(classFile.constant_pool)) {</span>
<span class="line-added">1056                         case &quot;toString&quot;, &quot;equals&quot;, &quot;hashCode&quot; -&gt;</span>
<span class="line-added">1057                             Assert.check(method.access_flags.is(AccessFlags.ACC_PUBLIC) &amp;&amp; method.access_flags.is(AccessFlags.ACC_FINAL));</span>
<span class="line-added">1058                         default -&gt; { /* do nothing */ }</span>
<span class="line-added">1059                     }</span>
<span class="line-added">1060             }</span>
<span class="line-added">1061         }</span>
<span class="line-added">1062     }</span>
<span class="line-added">1063 </span>
<span class="line-added">1064     private static final List&lt;String&gt; ACCESSIBILITY = List.of(</span>
<span class="line-added">1065             &quot;public&quot;, &quot;protected&quot;, &quot;&quot;, &quot;private&quot;);</span>
<span class="line-added">1066 </span>
<span class="line-added">1067     public void testCanonicalAccessibility() throws Exception {</span>
<span class="line-added">1068         // accessibility of canonical can&#39;t be stronger than that of the record type</span>
<span class="line-added">1069         for (String a1 : ACCESSIBILITY) {</span>
<span class="line-added">1070             for (String a2 : ACCESSIBILITY) {</span>
<span class="line-added">1071                 if (protection(a2) &gt; protection(a1)) {</span>
<span class="line-added">1072                     assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;class R {# record RR() { # RR {} } }&quot;, a1, a2);</span>
<span class="line-added">1073                 } else {</span>
<span class="line-added">1074                     assertOK(&quot;class R {# record RR() { # RR {} } }&quot;, a1, a2);</span>
<span class="line-added">1075                 }</span>
<span class="line-added">1076             }</span>
<span class="line-added">1077         }</span>
<span class="line-added">1078 </span>
<span class="line-added">1079         // now lets check that when compiler the compiler generates the canonical, it has the same accessibility</span>
<span class="line-added">1080         // as the record type</span>
<span class="line-added">1081         for (String a : ACCESSIBILITY) {</span>
<span class="line-added">1082             File dir = assertOK(true, &quot;class R {# record RR() {} }&quot;, a);</span>
<span class="line-added">1083             for (final File fileEntry : dir.listFiles()) {</span>
<span class="line-added">1084                 if (fileEntry.getName().equals(&quot;R$RR.class&quot;)) {</span>
<span class="line-added">1085                     ClassFile classFile = ClassFile.read(fileEntry);</span>
<span class="line-added">1086                     for (Method method : classFile.methods)</span>
<span class="line-added">1087                         if (method.getName(classFile.constant_pool).equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="line-added">1088                             Assert.check(method.access_flags.flags == accessFlag(a),</span>
<span class="line-added">1089                                     &quot;was expecting access flag &quot; + accessFlag(a) + &quot; but found &quot; + method.access_flags.flags);</span>
<span class="line-added">1090                         }</span>
<span class="line-added">1091                 }</span>
<span class="line-added">1092             }</span>
<span class="line-added">1093         }</span>
<span class="line-added">1094     }</span>
1095 
<span class="line-added">1096     private int protection(String access) {</span>
<span class="line-added">1097         switch (access) {</span>
<span class="line-added">1098             case &quot;private&quot;: return 3;</span>
<span class="line-added">1099             case &quot;protected&quot;: return 1;</span>
<span class="line-added">1100             case &quot;public&quot;: return 0;</span>
<span class="line-added">1101             case &quot;&quot;: return 2;</span>
<span class="line-added">1102             default:</span>
<span class="line-added">1103                 throw new AssertionError();</span>
<span class="line-added">1104         }</span>
<span class="line-added">1105     }</span>
<span class="line-added">1106 </span>
<span class="line-added">1107     private int accessFlag(String access) {</span>
<span class="line-added">1108         switch (access) {</span>
<span class="line-added">1109             case &quot;private&quot;: return AccessFlags.ACC_PRIVATE;</span>
<span class="line-added">1110             case &quot;protected&quot;: return AccessFlags.ACC_PROTECTED;</span>
<span class="line-added">1111             case &quot;public&quot;: return AccessFlags.ACC_PUBLIC;</span>
<span class="line-added">1112             case &quot;&quot;: return 0;</span>
<span class="line-added">1113             default:</span>
<span class="line-added">1114                 throw new AssertionError();</span>
<span class="line-added">1115         }</span>
<span class="line-added">1116     }</span>
<span class="line-added">1117 </span>
<span class="line-added">1118     public void testSameArity() {</span>
<span class="line-added">1119         for (String source : List.of(</span>
<span class="line-added">1120                 &quot;&quot;&quot;</span>
<span class="line-added">1121                 record R(int... args) {</span>
<span class="line-added">1122                     public R(int... args) {</span>
<span class="line-added">1123                         this.args = args;</span>
<span class="line-added">1124                     }</span>
<span class="line-added">1125                 }</span>
<span class="line-added">1126                 &quot;&quot;&quot;,</span>
<span class="line-added">1127                 &quot;&quot;&quot;</span>
<span class="line-added">1128                 record R(int[] args) {</span>
<span class="line-added">1129                     public R(int[] args) {</span>
<span class="line-added">1130                         this.args = args;</span>
<span class="line-added">1131                     }</span>
<span class="line-added">1132                 }</span>
<span class="line-added">1133                 &quot;&quot;&quot;</span>
<span class="line-added">1134         )) {</span>
<span class="line-added">1135             assertOK(source);</span>
<span class="line-added">1136         }</span>
<span class="line-added">1137 </span>
<span class="line-added">1138         for (String source : List.of(</span>
<span class="line-added">1139                 &quot;&quot;&quot;</span>
<span class="line-added">1140                 record R(int... args) {</span>
<span class="line-added">1141                     public R(int[] args) {</span>
<span class="line-added">1142                         this.args = args;</span>
<span class="line-added">1143                     }</span>
<span class="line-added">1144                 }</span>
<span class="line-added">1145                 &quot;&quot;&quot;,</span>
<span class="line-added">1146                 &quot;&quot;&quot;</span>
<span class="line-added">1147                 record R(int... args) {</span>
<span class="line-added">1148                     public R(int[] args) {</span>
<span class="line-added">1149                         this.args = args;</span>
<span class="line-added">1150                     }</span>
<span class="line-added">1151                 }</span>
<span class="line-added">1152                 &quot;&quot;&quot;,</span>
<span class="line-added">1153                 &quot;&quot;&quot;</span>
<span class="line-added">1154                 record R(String... args) {</span>
<span class="line-added">1155                     public R(String[] args) {</span>
<span class="line-added">1156                         this.args = args;</span>
<span class="line-added">1157                     }</span>
<span class="line-added">1158                 }</span>
<span class="line-added">1159                 &quot;&quot;&quot;,</span>
<span class="line-added">1160                 &quot;&quot;&quot;</span>
<span class="line-added">1161                 record R(String... args) {</span>
<span class="line-added">1162                     public R(String[] args) {</span>
<span class="line-added">1163                         this.args = args;</span>
<span class="line-added">1164                     }</span>
<span class="line-added">1165                 }</span>
<span class="line-added">1166                 &quot;&quot;&quot;</span>
<span class="line-added">1167         )) {</span>
<span class="line-added">1168             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, source);</span>
<span class="line-added">1169         }</span>
<span class="line-added">1170     }</span>
<span class="line-added">1171 </span>
<span class="line-added">1172     public void testSafeVararsAnno() {</span>
<span class="line-added">1173         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;,</span>
<span class="line-added">1174                 &quot;&quot;&quot;</span>
<span class="line-added">1175                 @SafeVarargs</span>
<span class="line-added">1176                 record R&lt;T&gt;(T... t) {}</span>
<span class="line-added">1177                 &quot;&quot;&quot;,</span>
<span class="line-added">1178                 &quot;&quot;&quot;</span>
<span class="line-added">1179                 @SafeVarargs</span>
<span class="line-added">1180                 record R&lt;T&gt;(T... t) {</span>
<span class="line-added">1181                     R(T... t) {</span>
<span class="line-added">1182                         this.t = t;</span>
<span class="line-added">1183                     }</span>
<span class="line-added">1184                 }</span>
<span class="line-added">1185                 &quot;&quot;&quot;</span>
<span class="line-added">1186         );</span>
<span class="line-added">1187 </span>
<span class="line-added">1188         assertOK(</span>
<span class="line-added">1189                 &quot;&quot;&quot;</span>
<span class="line-added">1190                 record R&lt;T&gt;(T... t) {</span>
<span class="line-added">1191                     @SafeVarargs</span>
<span class="line-added">1192                     R(T... t) {</span>
<span class="line-added">1193                         this.t = t;</span>
<span class="line-added">1194                     }</span>
<span class="line-added">1195                 }</span>
<span class="line-added">1196                 &quot;&quot;&quot;</span>
<span class="line-added">1197         );</span>
<span class="line-added">1198 </span>
<span class="line-added">1199         appendCompileOptions(&quot;-Xlint:unchecked&quot;);</span>
<span class="line-added">1200         assertOKWithWarning(&quot;compiler.warn.unchecked.varargs.non.reifiable.type&quot;,</span>
<span class="line-added">1201                 &quot;&quot;&quot;</span>
<span class="line-added">1202                 record R&lt;T&gt;(T... t) {</span>
<span class="line-added">1203                     R(T... t) {</span>
<span class="line-added">1204                         this.t = t;</span>
<span class="line-added">1205                     }</span>
<span class="line-added">1206                 }</span>
<span class="line-added">1207                 &quot;&quot;&quot;</span>
<span class="line-added">1208         );</span>
<span class="line-added">1209         removeLastCompileOptions(1);</span>
<span class="line-added">1210 </span>
<span class="line-added">1211         assertOK(</span>
<span class="line-added">1212                 &quot;&quot;&quot;</span>
<span class="line-added">1213                 @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">1214                 record R&lt;T&gt;(T... t) {</span>
<span class="line-added">1215                     R(T... t) {</span>
<span class="line-added">1216                         this.t = t;</span>
<span class="line-added">1217                     }</span>
<span class="line-added">1218                 }</span>
<span class="line-added">1219                 &quot;&quot;&quot;</span>
<span class="line-added">1220         );</span>
<span class="line-added">1221 </span>
<span class="line-added">1222         assertOK(</span>
<span class="line-added">1223                 &quot;&quot;&quot;</span>
<span class="line-added">1224                 record R&lt;T&gt;(T... t) {</span>
<span class="line-added">1225                     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">1226                     R(T... t) {</span>
<span class="line-added">1227                         this.t = t;</span>
<span class="line-added">1228                     }</span>
<span class="line-added">1229                 }</span>
<span class="line-added">1230                 &quot;&quot;&quot;</span>
<span class="line-added">1231         );</span>
<span class="line-added">1232     }</span>
<span class="line-added">1233 </span>
<span class="line-added">1234     public void testOverrideAtAccessor() {</span>
<span class="line-added">1235         assertOK(</span>
<span class="line-added">1236                 &quot;&quot;&quot;</span>
<span class="line-added">1237                 record R(int i) {</span>
<span class="line-added">1238                     @Override</span>
<span class="line-added">1239                     public int i() { return i; }</span>
<span class="line-added">1240                 }</span>
<span class="line-added">1241                 &quot;&quot;&quot;,</span>
<span class="line-added">1242                 &quot;&quot;&quot;</span>
<span class="line-added">1243                 record R(int i, int j) {</span>
<span class="line-added">1244                     @Override</span>
<span class="line-added">1245                     public int i() { return i; }</span>
<span class="line-added">1246                     public int j() { return j; }</span>
<span class="line-added">1247                 }</span>
<span class="line-added">1248                 &quot;&quot;&quot;,</span>
<span class="line-added">1249                 &quot;&quot;&quot;</span>
<span class="line-added">1250                 interface I { int i(); }</span>
<span class="line-added">1251                 record R(int i) implements I {</span>
<span class="line-added">1252                     @Override</span>
<span class="line-added">1253                     public int i() { return i; }</span>
<span class="line-added">1254                 }</span>
<span class="line-added">1255                 &quot;&quot;&quot;,</span>
<span class="line-added">1256                 &quot;&quot;&quot;</span>
<span class="line-added">1257                 interface I { int i(); }</span>
<span class="line-added">1258                 record R(int i) implements I {</span>
<span class="line-added">1259                     public int i() { return i; }</span>
<span class="line-added">1260                 }</span>
<span class="line-added">1261                 &quot;&quot;&quot;,</span>
<span class="line-added">1262                 &quot;&quot;&quot;</span>
<span class="line-added">1263                 interface I { default int i() { return 0; } }</span>
<span class="line-added">1264                 record R(int i) implements I {</span>
<span class="line-added">1265                     @Override</span>
<span class="line-added">1266                     public int i() { return i; }</span>
<span class="line-added">1267                 }</span>
<span class="line-added">1268                 &quot;&quot;&quot;</span>
<span class="line-added">1269         );</span>
<span class="line-added">1270     }</span>
<span class="line-added">1271 </span>
<span class="line-added">1272     public void testNoAssigmentInsideCompactRecord() {</span>
<span class="line-added">1273         assertFail(&quot;compiler.err.cant.assign.val.to.final.var&quot;,</span>
<span class="line-added">1274                 &quot;&quot;&quot;</span>
<span class="line-added">1275                 record R(int i) {</span>
<span class="line-added">1276                     R {</span>
<span class="line-added">1277                         this.i = i;</span>
<span class="line-added">1278                     }</span>
<span class="line-added">1279                 }</span>
<span class="line-added">1280                 &quot;&quot;&quot;</span>
<span class="line-added">1281         );</span>
<span class="line-added">1282         assertFail(&quot;compiler.err.cant.assign.val.to.final.var&quot;,</span>
<span class="line-added">1283                 &quot;&quot;&quot;</span>
<span class="line-added">1284                 record R(int i) {</span>
<span class="line-added">1285                     R {</span>
<span class="line-added">1286                         (this).i = i;</span>
<span class="line-added">1287                     }</span>
<span class="line-added">1288                 }</span>
<span class="line-added">1289                 &quot;&quot;&quot;</span>
<span class="line-added">1290         );</span>
1291     }
1292 }
</pre>
</td>
</tr>
</table>
<center><a href="../processing/model/element/TestRecordDesugar.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="RecordMemberTests.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/records/RecordCompilationTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /**
  27  * RecordCompilationTests
  28  *
  29  * @test
  30  * @summary Negative compilation tests, and positive compilation (smoke) tests for records
  31  * @library /lib/combo /tools/lib /tools/javac/lib
  32  * @modules
  33  *      jdk.compiler/com.sun.tools.javac.api
  34  *      jdk.compiler/com.sun.tools.javac.code
  35  *      jdk.compiler/com.sun.tools.javac.util
  36  *      jdk.jdeps/com.sun.tools.classfile
  37  * @build JavacTestingAbstractProcessor
  38  * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java
  39  * @run testng/othervm -DuseAP=false --enable-preview RecordCompilationTests
  40  * @run testng/othervm -DuseAP=true --enable-preview RecordCompilationTests
  41  */
  42 
  43 import java.io.File;
  44 
  45 import java.lang.annotation.ElementType;
  46 import java.util.Arrays;
  47 import java.util.EnumMap;
  48 import java.util.EnumSet;
  49 import java.util.HashSet;
  50 import java.util.List;
  51 import java.util.Map;
  52 import java.util.Set;
  53 import java.util.stream.Collectors;
  54 import java.util.stream.Stream;
  55 
  56 
  57 import com.sun.tools.javac.util.Assert;
  58 
  59 import javax.annotation.processing.AbstractProcessor;
  60 import javax.annotation.processing.RoundEnvironment;
  61 import javax.annotation.processing.SupportedAnnotationTypes;
  62 
  63 import javax.lang.model.element.AnnotationMirror;
  64 import javax.lang.model.element.AnnotationValue;
  65 import javax.lang.model.element.Element;
  66 import javax.lang.model.element.ElementKind;
  67 import javax.lang.model.element.ExecutableElement;
  68 import javax.lang.model.element.RecordComponentElement;
  69 import javax.lang.model.element.TypeElement;
  70 import javax.lang.model.element.VariableElement;
  71 
  72 import javax.lang.model.type.ArrayType;
  73 import javax.lang.model.type.TypeMirror;
  74 
  75 import com.sun.tools.classfile.AccessFlags;
  76 import com.sun.tools.classfile.Annotation;
  77 import com.sun.tools.classfile.Attribute;
  78 import com.sun.tools.classfile.Attributes;
  79 import com.sun.tools.classfile.ClassFile;
  80 import com.sun.tools.classfile.Code_attribute;
  81 import com.sun.tools.classfile.ConstantPool;
  82 import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;
  83 import com.sun.tools.classfile.ConstantPool.CPInfo;
  84 import com.sun.tools.classfile.Field;
  85 import com.sun.tools.classfile.Instruction;
  86 import com.sun.tools.classfile.Method;
  87 import com.sun.tools.classfile.Record_attribute;
  88 import com.sun.tools.classfile.Record_attribute.ComponentInfo;
  89 import com.sun.tools.classfile.RuntimeAnnotations_attribute;
  90 import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;
  91 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
  92 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
  93 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
  94 import com.sun.tools.classfile.TypeAnnotation;
  95 
  96 import com.sun.tools.javac.api.ClientCodeWrapper.DiagnosticSourceUnwrapper;
  97 import com.sun.tools.javac.code.Attribute.TypeCompound;
  98 import com.sun.tools.javac.code.Symbol;
  99 import com.sun.tools.javac.code.Symbol.VarSymbol;
 100 import com.sun.tools.javac.util.JCDiagnostic;
 101 
 102 import org.testng.annotations.Test;
 103 import tools.javac.combo.CompilationTestCase;
 104 
 105 import static java.lang.annotation.ElementType.*;
 106 import static org.testng.Assert.assertEquals;
 107 
 108 /** Records are the first feature which sports automatic injection of (declarative and type) annotations : from a
 109  *  given record component to one or more record members, if applicable.
 110  *  This implies that the record&#39;s implementation can be stressed with the presence of annotation processors. Which is
 111  *  something the implementator could easily skip. For this reason this test is executed twice, once without the
 112  *  presence of any annotation processor and one with a simple annotation processor (which does not annotation processing
 113  *  at all) just to force at least a round of annotation processing.
 114  *
 115  *  Tests needing special compilation options need to store current options, set its customs options by invoking method
 116  *  `setCompileOptions` and then reset the previous compilation options for other tests. To see an example of this check
 117  *  method: testAnnos()
 118  */
 119 
 120 @Test
 121 public class RecordCompilationTests extends CompilationTestCase {
 122     // @@@ When records become a permanent feature, we don&#39;t need these any more
 123     private static String[] PREVIEW_OPTIONS = {
 124             &quot;--enable-preview&quot;,
 125             &quot;-source&quot;, Integer.toString(Runtime.version().feature())
 126     };
 127 
 128     private static String[] PREVIEW_OPTIONS_WITH_AP = {
 129             &quot;--enable-preview&quot;,
 130             &quot;-source&quot;, Integer.toString(Runtime.version().feature()),
 131             &quot;-processor&quot;, SimplestAP.class.getName()
 132     };
 133 
 134     private static final List&lt;String&gt; BAD_COMPONENT_NAMES = List.of(
 135             &quot;clone&quot;, &quot;finalize&quot;, &quot;getClass&quot;, &quot;hashCode&quot;,
 136             &quot;notify&quot;, &quot;notifyAll&quot;, &quot;toString&quot;, &quot;wait&quot;);
 137 
 138     /* simplest annotation processor just to force a round of annotation processing for all tests
 139      */
 140     @SupportedAnnotationTypes(&quot;*&quot;)
 141     public static class SimplestAP extends AbstractProcessor {
 142         @Override
 143         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 144             return true;
 145         }
 146     }
 147 
 148     public RecordCompilationTests() {
 149         boolean useAP = System.getProperty(&quot;useAP&quot;) == null ? false : System.getProperty(&quot;useAP&quot;).equals(&quot;true&quot;);
 150         setDefaultFilename(&quot;R.java&quot;);
 151         setCompileOptions(useAP ? PREVIEW_OPTIONS_WITH_AP : PREVIEW_OPTIONS);
 152         System.out.println(useAP ? &quot;running all tests using an annotation processor&quot; : &quot;running all tests without annotation processor&quot;);
 153     }
 154 
 155     public void testMalformedDeclarations() {
 156         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R()&quot;);
 157         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R();&quot;);
 158         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R(,) { }&quot;);
 159         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R((int x)) { }&quot;);
 160         assertFail(&quot;compiler.err.record.header.expected&quot;, &quot;record R { }&quot;);
 161         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(foo) { }&quot;);
 162         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int int) { }&quot;);
 163         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;abstract record R(String foo) { }&quot;);
 164         //assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;non-sealed record R(String foo) { }&quot;);
 165         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;public public record R(String foo) { }&quot;);
 166         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;private private record R(String foo) { }&quot;);
 167         assertFail(&quot;compiler.err.already.defined&quot;, &quot;record R(int x, int x) {}&quot;);
 168         for (String s : List.of(&quot;var&quot;, &quot;record&quot;))
 169             assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, &quot;record R(# x) { }&quot;, s);
 170         for (String s : List.of(&quot;public&quot;, &quot;protected&quot;, &quot;private&quot;, &quot;static&quot;, &quot;final&quot;, &quot;transient&quot;, &quot;volatile&quot;,
 171                 &quot;abstract&quot;, &quot;synchronized&quot;, &quot;native&quot;, &quot;strictfp&quot;)) // missing: sealed and non-sealed
 172             assertFail(&quot;compiler.err.record.cant.declare.field.modifiers&quot;, &quot;record R(# String foo) { }&quot;, s);
 173         assertFail(&quot;compiler.err.varargs.must.be.last&quot;, &quot;record R(int... x, int... y) {}&quot;);
 174         assertFail(&quot;compiler.err.instance.initializer.not.allowed.in.records&quot;, &quot;record R(int i) { {} }&quot;);
 175     }
 176 
 177     public void testGoodDeclarations() {
 178         assertOK(&quot;public record R() { }&quot;);
 179         assertOK(&quot;record R() { }&quot;);
 180         assertOK(&quot;record R() implements java.io.Serializable, Runnable { public void run() { } }&quot;);
 181         assertOK(&quot;record R(int x) { }&quot;);
 182         assertOK(&quot;record R(int x, int y) { }&quot;);
 183         assertOK(&quot;record R(int... xs) { }&quot;);
 184         assertOK(&quot;record R(String... ss) { }&quot;);
 185         assertOK(&quot;@Deprecated record R(int x, int y) { }&quot;);
 186         assertOK(&quot;record R(@Deprecated int x, int y) { }&quot;);
 187         assertOK(&quot;record R&lt;T&gt;(T x, T y) { }&quot;);
 188     }
 189 
 190     public void testGoodMemberDeclarations() {
 191         String template = &quot;public record R(int x) {\n&quot;
 192                 + &quot;    public R(int x) { this.x = x; }\n&quot;
 193                 + &quot;    public int x() { return x; }\n&quot;
 194                 + &quot;    public boolean equals(Object o) { return true; }\n&quot;
 195                 + &quot;    public int hashCode() { return 0; }\n&quot;
 196                 + &quot;    public String toString() { return null; }\n&quot;
 197                 + &quot;}&quot;;
 198         assertOK(template);
 199     }
 200 
 201     public void testBadComponentNames() {
 202         for (String s : BAD_COMPONENT_NAMES)
 203             assertFail(&quot;compiler.err.illegal.record.component.name&quot;, &quot;record R(int #) { } &quot;, s);
 204     }
 205 
 206     public void testRestrictedIdentifiers() {
 207         for (String s : List.of(&quot;interface record { void m(); }&quot;,
 208                 &quot;@interface record { }&quot;,
 209                 &quot;class record { }&quot;,
 210                 &quot;record record(int x) { }&quot;,
 211                 &quot;enum record { A, B }&quot;,
 212                 &quot;class R&lt;record&gt; { }&quot;)) {
 213             assertFail(
 214                     &quot;compiler.err.restricted.type.not.allowed&quot;,
 215                     diagWrapper -&gt; {
 216                         JCDiagnostic diagnostic = ((DiagnosticSourceUnwrapper)diagWrapper).d;
 217                         Object[] args = diagnostic.getArgs();
 218                         Assert.check(args.length == 2);
 219                         Assert.check(args[1].toString().equals(&quot;JDK14&quot;));
 220                     },
 221                     s);
 222         }
 223     }
 224 
 225     public void testValidMembers() {
 226         for (String s : List.of(&quot;record X(int j) { }&quot;,
 227                 &quot;interface I { }&quot;,
 228                 &quot;static { }&quot;,
 229                 &quot;enum E { A, B }&quot;,
 230                 &quot;class C { }&quot;
 231         )) {
 232             assertOK(&quot;record R(int i) { # }&quot;, s);
 233         }
 234     }
 235 
 236     public void testCyclic() {
 237         // Cyclic records are OK, but cyclic inline records would not be
 238         assertOK(&quot;record R(R r) { }&quot;);
 239     }
 240 
 241     public void testBadExtends() {
 242         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) extends Object { }&quot;);
 243         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) {}\n&quot;
 244                 + &quot;record R2(int x) extends R { }&quot;);
 245         assertFail(&quot;compiler.err.cant.inherit.from.final&quot;, &quot;record R(int x) {}\n&quot;
 246                 + &quot;class C extends R { }&quot;);
 247     }
 248 
 249     public void testNoExtendRecord() {
 250         assertFail(&quot;compiler.err.invalid.supertype.record&quot;,
 251                    &quot;&quot;&quot;
 252                    class R extends Record {
 253                        public String toString() { return null; }
 254                        public int hashCode() { return 0; }
 255                        public boolean equals(Object o) { return false; }
 256                    }
 257                    &quot;&quot;&quot;
 258         );
 259     }
 260 
 261     public void testFieldDeclarations() {
 262         // static fields are OK
 263         assertOK(&quot;public record R(int x) {\n&quot; +
 264                 &quot;    static int I = 1;\n&quot; +
 265                 &quot;    static final String S = \&quot;Hello World!\&quot;;\n&quot; +
 266                 &quot;    static private Object O = null;\n&quot; +
 267                 &quot;    static protected Object O2 = null;\n&quot; +
 268                 &quot;}&quot;);
 269 
 270         // instance fields are not
 271         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 272                 &quot;public record R(int x) {\n&quot; +
 273                         &quot;    private final int y = 0;&quot; +
 274                         &quot;}&quot;);
 275 
 276         // mutable instance fields definitely not
 277         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 278                 &quot;public record R(int x) {\n&quot; +
 279                         &quot;    private int y = 0;&quot; +
 280                         &quot;}&quot;);
 281 
 282         // redeclaring components also not
 283         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
 284                 &quot;public record R(int x) {\n&quot; +
 285                         &quot;    private final int x;&quot; +
 286                         &quot;}&quot;);
 287     }
 288 
 289     public void testAccessorRedeclaration() {
 290         assertOK(&quot;public record R(int x) {\n&quot; +
 291                 &quot;    public int x() { return x; };&quot; +
 292                 &quot;}&quot;);
 293 
 294         assertOK(&quot;public record R(int... x) {\n&quot; +
 295                 &quot;    public int[] x() { return x; };&quot; +
 296                 &quot;}&quot;);
 297 
 298         assertOK(&quot;public record R(int x) {\n&quot; +
 299                 &quot;    public final int x() { return 0; };&quot; +
 300                 &quot;}&quot;);
 301 
 302         assertOK(&quot;public record R(int x) {\n&quot; +
 303                 &quot;    public final int x() { return 0; };&quot; +
 304                 &quot;}&quot;);
 305 
 306         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 307                 &quot;public record R(int x) {\n&quot; +
 308                         &quot;    final int x() { return 0; };&quot; +
 309                         &quot;}&quot;);
 310 
 311         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 312                 &quot;public record R(int x) {\n&quot; +
 313                         &quot;    int x() { return 0; };&quot; +
 314                         &quot;}&quot;);
 315 
 316         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 317                 &quot;public record R(int x) {\n&quot; +
 318                         &quot;    private int x() { return 0; };&quot; +
 319                         &quot;}&quot;);
 320 
 321         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 322                    &quot;public record R(int x) {\n&quot; +
 323                    &quot;    public int x() throws Exception { return 0; };&quot; +
 324                    &quot;}&quot;);
 325 
 326         for (String s : List.of(&quot;List&quot;, &quot;List&lt;?&gt;&quot;, &quot;Object&quot;, &quot;ArrayList&lt;String&gt;&quot;, &quot;int&quot;))
 327             assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 328                     &quot;import java.util.*;\n&quot; +
 329                             &quot;public record R(List&lt;String&gt; x) {\n&quot; +
 330                             &quot;    public # x() { return null; };&quot; +
 331                             &quot;}&quot;, s);
 332 
 333         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 334                 &quot;public record R(int x) {\n&quot; +
 335                         &quot;    public &lt;T&gt; int x() { return x; };&quot; +
 336                         &quot;}&quot;);
 337 
 338         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
 339                 &quot;public record R(int x) {\n&quot; +
 340                         &quot;    static private final j = 0;&quot; +
 341                         &quot;    static public int x() { return j; };&quot; +
 342                         &quot;}&quot;);
 343     }
 344 
 345     public void testConstructorRedeclaration() {
 346         for (String goodCtor : List.of(
 347                 &quot;public R(int x) { this(x, 0); }&quot;,
 348                 &quot;public R(int x, int y) { this.x = x; this.y = y; }&quot;,
 349                 &quot;public R { }&quot;))
 350             assertOK(&quot;record R(int x, int y) { # }&quot;, goodCtor);
 351 
 352         assertOK(&quot;import java.util.*; record R(String x, String y) {  public R { Objects.requireNonNull(x); Objects.requireNonNull(y); } }&quot;);
 353 
 354         // Not OK to redeclare canonical without DA
 355         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x, int y) { # }&quot;,
 356                    &quot;public R(int x, int y) { this.x = x; }&quot;);
 357 
 358         // Not OK to rearrange or change names
 359         for (String s : List.of(&quot;public R(int y, int x) { this.x = x; this.y = y; }&quot;,
 360                                 &quot;public R(int _x, int _y) { this.x = _x; this.y = _y; }&quot;))
 361             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;, s);
 362 
 363         // ctor args must match types
 364         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 365                 &quot;import java.util.*;\n&quot; +
 366                         &quot;record R(List&lt;String&gt; list) { # }&quot;,
 367                 &quot;R(List list) { this.list = list; }&quot;);
 368 
 369         // canonical ctor should not throw checked exceptions
 370         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 371                    &quot;record R() { # }&quot;,
 372                    &quot;public R() throws Exception { }&quot;);
 373 
 374         // same for compact
 375         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 376                 &quot;record R() { # }&quot;,
 377                 &quot;public R throws Exception { }&quot;);
 378 
 379         // not even unchecked exceptions
 380         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 381                 &quot;record R() { # }&quot;,
 382                  &quot;public R() throws IllegalArgumentException { }&quot;);
 383 
 384         // ditto
 385         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 386                 &quot;record R() { # }&quot;,
 387                 &quot;public R throws IllegalArgumentException { }&quot;);
 388 
 389         // If types match, names must match
 390         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 391                    &quot;record R(int x, int y) { public R(int y, int x) { this.x = this.y = 0; }}&quot;);
 392 
 393         // first invocation should be one to the canonical
 394         assertFail(&quot;compiler.err.first.statement.must.be.call.to.another.constructor&quot;,
 395                 &quot;record R(int x, int y) { public R(int y, int x, int z) { this.x = this.y = 0; } }&quot;);
 396 
 397         assertOK(&quot;record R(int x, int y) { &quot; +
 398                  &quot;    public R(int x, int y, int z) { this(x, y); } &quot; +
 399                  &quot;}&quot;);
 400 
 401         assertOK(&quot;record R(int x) { &quot; +
 402                 &quot;    public R(int x, int y) { this(x, y, 0); } &quot; +
 403                 &quot;    public R(int x, int y, int z) { this(x); } &quot; +
 404                 &quot;}&quot;);
 405 
 406         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 407                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
 408                 &quot;public &lt;T&gt; R {}&quot;);
 409 
 410         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 411                 &quot;record R(int i) { # }&quot;,
 412                 &quot;public &lt;T&gt; R(int i) { this.i = i; }&quot;);
 413 
 414         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 415                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
 416                 &quot;public &lt;T&gt; R(T a) { this.a = a; }&quot;);
 417 
 418         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
 419                 &quot;record R(int a) { # }&quot;,
 420                 &quot;public R(int a) { super(); this.a = a; }&quot;);
 421     }
 422 
 423     public void testAnnotationCriteria() {
 424         String imports = &quot;import java.lang.annotation.*;\n&quot;;
 425         String template = &quot;@Target({ # }) @interface A {}\n&quot;;
 426         EnumMap&lt;ElementType, String&gt; annotations = new EnumMap&lt;&gt;(ElementType.class);
 427         for (ElementType e : values())
 428             annotations.put(e, template.replace(&quot;#&quot;, &quot;ElementType.&quot; + e.name()));
 429         EnumSet&lt;ElementType&gt; goodSet = EnumSet.of(RECORD_COMPONENT, FIELD, METHOD, PARAMETER, TYPE_USE);
 430         EnumSet&lt;ElementType&gt; badSet = EnumSet.of(CONSTRUCTOR, PACKAGE, TYPE, LOCAL_VARIABLE, ANNOTATION_TYPE, TYPE_PARAMETER, MODULE);
 431 
 432         assertEquals(goodSet.size() + badSet.size(), values().length);
 433         String A_GOOD = template.replace(&quot;#&quot;,
 434                                          goodSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
 435         String A_BAD = template.replace(&quot;#&quot;,
 436                                         badSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
 437         String A_ALL = template.replace(&quot;#&quot;,
 438                                         Stream.of(ElementType.values()).map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
 439         String A_NONE = &quot;@interface A {}&quot;;
 440 
 441         for (ElementType e : goodSet)
 442             assertOK(imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
 443         assertOK(imports + A_GOOD + &quot;record R(@A int x) { }&quot;);
 444         assertOK(imports + A_ALL + &quot;record R(@A int x) { }&quot;);
 445         assertOK(imports + A_NONE);
 446 
 447         for (ElementType e : badSet) {
 448             assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
 449         }
 450 
 451         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + A_BAD + &quot;record R(@A int x) { }&quot;);
 452 
 453         // TODO: OK to redeclare with or without same annos
 454     }
 455 
 456     public void testNestedRecords() {
 457         String template = &quot;class R { \n&quot; +
 458                           &quot;    # record RR(int a) { }\n&quot; +
 459                           &quot;}&quot;;
 460 
 461         for (String s : List.of(&quot;&quot;, &quot;static&quot;, &quot;final&quot;,
 462                                 &quot;private&quot;, &quot;public&quot;, &quot;protected&quot;,
 463                                 &quot;private static&quot;, &quot;public static&quot;, &quot;private static final&quot;))
 464             assertOK(template, s);
 465 
 466         for (String s : List.of(&quot;class C { }&quot;,
 467                                 &quot;static class C { }&quot;,
 468                                 &quot;enum X { A; }&quot;,
 469                                 &quot;interface I { }&quot;,
 470                                 &quot;record RR(int y) { }&quot;))
 471             assertOK(&quot;record R(int x) { # }&quot;, s);
 472     }
 473 
 474     public void testDuplicatedMember() {
 475         String template
 476                 = &quot;    record R(int i) {\n&quot; +
 477                   &quot;        public int i() { return i; }\n&quot; +
 478                   &quot;        public int i() { return i; }\n&quot; +
 479                   &quot;    }&quot;;
 480         assertFail(&quot;compiler.err.already.defined&quot;, template);
 481     }
 482 
 483     public void testStaticLocalTypes() {
 484         // local records can also be final
 485         assertOK(&quot;class R { \n&quot; +
 486                 &quot;    void m() { \n&quot; +
 487                 &quot;        final record RR(int x) { };\n&quot; +
 488                 &quot;    }\n&quot; +
 489                 &quot;}&quot;);
 490 
 491         // Cant capture locals
 492         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 493                 &quot;class R { \n&quot; +
 494                         &quot;    void m(int y) { \n&quot; +
 495                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
 496                         &quot;    }\n&quot; +
 497                         &quot;}&quot;);
 498 
 499         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 500                 &quot;class R { \n&quot; +
 501                         &quot;    void m() {\n&quot; +
 502                         &quot;        int y;\n&quot; +
 503                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
 504                         &quot;    }\n&quot; +
 505                         &quot;}&quot;);
 506 
 507         // instance fields
 508         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 509                 &quot;class R { \n&quot; +
 510                         &quot;    int z = 0;\n&quot; +
 511                         &quot;    void m() { \n&quot; +
 512                         &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
 513                         &quot;    }\n&quot; +
 514                         &quot;}&quot;);
 515 
 516         // or type variables
 517         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 518                 &quot;class R&lt;T&gt; { \n&quot; +
 519                         &quot;    void m() { \n&quot; +
 520                         &quot;        record RR(T t) {};\n&quot; +
 521                         &quot;    }\n&quot; +
 522                         &quot;}&quot;);
 523 
 524         // but static fields are OK
 525         assertOK(&quot;class R { \n&quot; +
 526                 &quot;    static int z = 0;\n&quot; +
 527                 &quot;    void m() { \n&quot; +
 528                 &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
 529                 &quot;    }\n&quot; +
 530                 &quot;}&quot;);
 531         // Can&#39;t self-shadow
 532         assertFail(&quot;compiler.err.already.defined&quot;,
 533                 &quot;&quot;&quot;
 534                 class R {
 535                     void m() {
 536                         record R(int x) { };
 537                     }
 538                 }
 539                 &quot;&quot;&quot;
 540         );
 541         // can&#39;t be explicitly static
 542         assertFail(&quot;compiler.err.illegal.start.of.expr&quot;,
 543                 &quot;&quot;&quot;
 544                 class R {
 545                     void m() {
 546                         static record RR(int x) { };
 547                     }
 548                 }
 549                 &quot;&quot;&quot;
 550         );
 551     }
 552 
 553     public void testReturnInCanonical_Compact() {
 554         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
 555                 &quot;public R { return; }&quot;);
 556         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
 557                 &quot;public R { if (i &lt; 0) { return; }}&quot;);
 558         assertOK(&quot;record R(int x) { public R(int x) { this.x = x; return; } }&quot;);
 559         assertOK(&quot;record R(int x) { public R { Runnable r = () -&gt; { return; };} }&quot;);
 560     }
 561 
 562     public void testArgumentsAreNotFinalInCompact() {
 563         assertOK(
 564                 &quot;&quot;&quot;
 565                 record R(int x) {
 566                     public R {
 567                         x++;
 568                     }
 569                 }
 570                 &quot;&quot;&quot;);
 571     }
 572 
 573     public void testNoNativeMethods() {
 574         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
 575                 &quot;public native R {}&quot;);
 576         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
 577                 &quot;public native void m();&quot;);
 578     }
 579 
 580     public void testRecordsInsideInner() {
 581         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 582                 &quot;&quot;&quot;
 583                 class Outer {
 584                     class Inner {
 585                         record R(int a) {}
 586                     }
 587                 }
 588                 &quot;&quot;&quot;
 589         );
 590         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 591                 &quot;&quot;&quot;
 592                 class Outer {
 593                     public void test() {
 594                         class Inner extends Outer {
 595                             record R(int i) {}
 596                         }
 597                     }
 598                 }
 599                 &quot;&quot;&quot;);
 600         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 601                 &quot;&quot;&quot;
 602                 class Outer {
 603                     Runnable run = new Runnable() {
 604                         record TestRecord(int i) {}
 605                         public void run() {}
 606                     };
 607                 }
 608                 &quot;&quot;&quot;);
 609         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,
 610                 &quot;&quot;&quot;
 611                 class Outer {
 612                     void m() {
 613                         record A() {
 614                             record B() { }
 615                         }
 616                     }
 617                 }
 618                 &quot;&quot;&quot;);
 619     }
 620 
 621     public void testReceiverParameter() {
 622         assertFail(&quot;compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class&quot;,
 623                 &quot;&quot;&quot;
 624                 record R(int i) {
 625                     public R(R this, int i) {
 626                         this.i = i;
 627                     }
 628                 }
 629                 &quot;&quot;&quot;);
 630         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
 631                 &quot;&quot;&quot;
 632                 class Outer {
 633                     record R(int i) {
 634                         public R(Outer Outer.this, int i) {
 635                             this.i = i;
 636                         }
 637                     }
 638                 }
 639                 &quot;&quot;&quot;);
 640         assertOK(
 641                 &quot;&quot;&quot;
 642                 record R(int i) {
 643                     void m(R this) {}
 644                     public int i(R this) { return i; }
 645                 }
 646                 &quot;&quot;&quot;);
 647     }
 648 
 649     public void testOnlyOneFieldRef() throws Exception {
 650         int numberOfFieldRefs = 0;
 651         File dir = assertOK(true, &quot;record R(int recordComponent) {}&quot;);
 652         for (final File fileEntry : dir.listFiles()) {
 653             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
 654                 ClassFile classFile = ClassFile.read(fileEntry);
 655                 for (CPInfo cpInfo : classFile.constant_pool.entries()) {
 656                     if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {
 657                         numberOfFieldRefs++;
 658                         ConstantPool.CONSTANT_NameAndType_info nameAndType =
 659                                 (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool
 660                                         .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);
 661                         Assert.check(nameAndType.getName().equals(&quot;recordComponent&quot;));
 662                     }
 663                 }
 664             }
 665         }
 666         Assert.check(numberOfFieldRefs == 1);
 667     }
 668 
 669     /*  check that fields are initialized in a canonical constructor in the same declaration order as the corresponding
 670      *  record component
 671      */
 672     public void testCheckInitializationOrderInCompactConstructor() throws Exception {
 673         int putField1 = -1;
 674         int putField2 = -1;
 675         File dir = assertOK(true, &quot;record R(int i, String s) { R {} }&quot;);
 676         for (final File fileEntry : dir.listFiles()) {
 677             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
 678                 ClassFile classFile = ClassFile.read(fileEntry);
 679                 for (Method method : classFile.methods) {
 680                     if (method.getName(classFile.constant_pool).equals(&quot;&lt;init&gt;&quot;)) {
 681                         Code_attribute code_attribute = (Code_attribute) method.attributes.get(&quot;Code&quot;);
 682                         for (Instruction instruction : code_attribute.getInstructions()) {
 683                             if (instruction.getMnemonic().equals(&quot;putfield&quot;)) {
 684                                 if (putField1 != -1 &amp;&amp; putField2 != -1) {
 685                                     throw new AssertionError(&quot;was expecting only two putfield instructions in this method&quot;);
 686                                 }
 687                                 if (putField1 == -1) {
 688                                     putField1 = instruction.getShort(1);
 689                                 } else if (putField2 == -1) {
 690                                     putField2 = instruction.getShort(1);
 691                                 }
 692                             }
 693                         }
 694                         // now we need to check that we are assigning to `i` first and to `s` afterwards
 695                         CONSTANT_Fieldref_info fieldref_info1 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField1);
 696                         if (!fieldref_info1.getNameAndTypeInfo().getName().equals(&quot;i&quot;)) {
 697                             throw new AssertionError(&quot;was expecting variable name &#39;i&#39;&quot;);
 698                         }
 699 
 700                         CONSTANT_Fieldref_info fieldref_info2 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField2);
 701                         if (!fieldref_info2.getNameAndTypeInfo().getName().equals(&quot;s&quot;)) {
 702                             throw new AssertionError(&quot;was expecting variable name &#39;s&#39;&quot;);
 703                         }
 704                     }
 705                 }
 706             }
 707         }
 708     }
 709 
 710     public void testAcceptRecordId() {
 711         String[] testOptions = {/* no options */};
 712         setCompileOptions(testOptions);
 713         assertOKWithWarning(&quot;compiler.warn.restricted.type.not.allowed.preview&quot;,
 714                 &quot;class R {\n&quot; +
 715                 &quot;    record RR(int i) {\n&quot; +
 716                 &quot;        return null;\n&quot; +
 717                 &quot;    }\n&quot; +
 718                 &quot;    class record {}\n&quot; +
 719                 &quot;}&quot;);
 720         setCompileOptions(PREVIEW_OPTIONS);
 721     }
 722 
 723     public void testAnnos() throws Exception {
 724         String srcTemplate =
 725                 &quot;&quot;&quot;
 726                     import java.lang.annotation.*;
 727                     @Target({#TARGET})
 728                     @Retention(RetentionPolicy.RUNTIME)
 729                     @interface Anno { }
 730 
 731                     record R(@Anno String s) {}
 732                 &quot;&quot;&quot;;
 733 
 734         // testing several combinations, adding even more combinations won&#39;t add too much value
 735         List&lt;String&gt; annoApplicableTargets = List.of(
 736                 &quot;ElementType.FIELD&quot;,
 737                 &quot;ElementType.METHOD&quot;,
 738                 &quot;ElementType.PARAMETER&quot;,
 739                 &quot;ElementType.RECORD_COMPONENT&quot;,
 740                 &quot;ElementType.TYPE_USE&quot;,
 741                 &quot;ElementType.TYPE_USE,ElementType.FIELD&quot;,
 742                 &quot;ElementType.TYPE_USE,ElementType.METHOD&quot;,
 743                 &quot;ElementType.TYPE_USE,ElementType.PARAMETER&quot;,
 744                 &quot;ElementType.TYPE_USE,ElementType.RECORD_COMPONENT&quot;,
 745                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.METHOD&quot;,
 746                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.PARAMETER&quot;,
 747                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.RECORD_COMPONENT&quot;,
 748                 &quot;ElementType.FIELD,ElementType.TYPE_USE&quot;,
 749                 &quot;ElementType.METHOD,ElementType.TYPE_USE&quot;,
 750                 &quot;ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
 751                 &quot;ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;,
 752                 &quot;ElementType.FIELD,ElementType.METHOD,ElementType.TYPE_USE&quot;,
 753                 &quot;ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
 754                 &quot;ElementType.FIELD,ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;
 755         );
 756 
 757         String[] generalOptions = {
 758                 &quot;--enable-preview&quot;,
 759                 &quot;-source&quot;, Integer.toString(Runtime.version().feature()),
 760                 &quot;-processor&quot;, Processor.class.getName(),
 761                 &quot;-Atargets=&quot;
 762         };
 763 
 764         for (String target : annoApplicableTargets) {
 765             String code = srcTemplate.replaceFirst(&quot;#TARGET&quot;, target);
 766             String[] testOptions = generalOptions.clone();
 767             testOptions[testOptions.length - 1] = testOptions[testOptions.length - 1] + target;
 768             setCompileOptions(testOptions);
 769 
 770             File dir = assertOK(true, code);
 771 
 772             ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, &quot;R.class&quot;));
 773 
 774             // field first
 775             Assert.check(classFile.fields.length == 1);
 776             Field field = classFile.fields[0];
 777             /* if FIELD is one of the targets then there must be a declaration annotation applied to the field, apart from
 778              * the type annotation
 779              */
 780             if (target.contains(&quot;FIELD&quot;)) {
 781                 checkAnno(classFile,
 782                         (RuntimeAnnotations_attribute)findAttributeOrFail(
 783                                 field.attributes,
 784                                 RuntimeVisibleAnnotations_attribute.class),
 785                         &quot;Anno&quot;);
 786             } else {
 787                 assertAttributeNotPresent(field.attributes, RuntimeVisibleAnnotations_attribute.class);
 788             }
 789 
 790             // lets check now for the type annotation
 791             if (target.contains(&quot;TYPE_USE&quot;)) {
 792                 checkTypeAnno(
 793                         classFile,
 794                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
 795                         &quot;FIELD&quot;,
 796                         &quot;Anno&quot;);
 797             } else {
 798                 assertAttributeNotPresent(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
 799             }
 800 
 801             // checking for the annotation on the corresponding parameter of the canonical constructor
 802             Method init = findMethodOrFail(classFile, &quot;&lt;init&gt;&quot;);
 803             /* if PARAMETER is one of the targets then there must be a declaration annotation applied to the parameter, apart from
 804              * the type annotation
 805              */
 806             if (target.contains(&quot;PARAMETER&quot;)) {
 807                 checkParameterAnno(classFile,
 808                         (RuntimeVisibleParameterAnnotations_attribute)findAttributeOrFail(
 809                                 init.attributes,
 810                                 RuntimeVisibleParameterAnnotations_attribute.class),
 811                         &quot;Anno&quot;);
 812             } else {
 813                 assertAttributeNotPresent(init.attributes, RuntimeVisibleAnnotations_attribute.class);
 814             }
 815             // let&#39;s check now for the type annotation
 816             if (target.contains(&quot;TYPE_USE&quot;)) {
 817                 checkTypeAnno(
 818                         classFile,
 819                         (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
 820                         &quot;METHOD_FORMAL_PARAMETER&quot;, &quot;Anno&quot;);
 821             } else {
 822                 assertAttributeNotPresent(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
 823             }
 824 
 825             // checking for the annotation in the accessor
 826             Method accessor = findMethodOrFail(classFile, &quot;s&quot;);
 827             /* if METHOD is one of the targets then there must be a declaration annotation applied to the accessor, apart from
 828              * the type annotation
 829              */
 830             if (target.contains(&quot;METHOD&quot;)) {
 831                 checkAnno(classFile,
 832                         (RuntimeAnnotations_attribute)findAttributeOrFail(
 833                                 accessor.attributes,
 834                                 RuntimeVisibleAnnotations_attribute.class),
 835                         &quot;Anno&quot;);
 836             } else {
 837                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleAnnotations_attribute.class);
 838             }
 839             // let&#39;s check now for the type annotation
 840             if (target.contains(&quot;TYPE_USE&quot;)) {
 841                 checkTypeAnno(
 842                         classFile,
 843                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
 844                         &quot;METHOD_RETURN&quot;, &quot;Anno&quot;);
 845             } else {
 846                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
 847             }
 848 
 849             // checking for the annotation in the Record attribute
 850             Record_attribute record = (Record_attribute)findAttributeOrFail(classFile.attributes, Record_attribute.class);
 851             Assert.check(record.component_count == 1);
 852             /* if RECORD_COMPONENT is one of the targets then there must be a declaration annotation applied to the
 853              * field, apart from the type annotation
 854              */
 855             if (target.contains(&quot;RECORD_COMPONENT&quot;)) {
 856                 checkAnno(classFile,
 857                         (RuntimeAnnotations_attribute)findAttributeOrFail(
 858                                 record.component_info_arr[0].attributes,
 859                                 RuntimeVisibleAnnotations_attribute.class),
 860                         &quot;Anno&quot;);
 861             } else {
 862                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleAnnotations_attribute.class);
 863             }
 864             // lets check now for the type annotation
 865             if (target.contains(&quot;TYPE_USE&quot;)) {
 866                 checkTypeAnno(
 867                         classFile,
 868                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(
 869                                 record.component_info_arr[0].attributes,
 870                                 RuntimeVisibleTypeAnnotations_attribute.class),
 871                         &quot;FIELD&quot;, &quot;Anno&quot;);
 872             } else {
 873                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleTypeAnnotations_attribute.class);
 874             }
 875         }
 876 
 877         // let&#39;s reset the default compiler options for other tests
 878         setCompileOptions(PREVIEW_OPTIONS);
 879     }
 880 
 881     private void checkTypeAnno(ClassFile classFile,
 882                                RuntimeTypeAnnotations_attribute rtAnnos,
 883                                String positionType,
 884                                String annoName) throws Exception {
 885         // containing only one type annotation
 886         Assert.check(rtAnnos.annotations.length == 1);
 887         TypeAnnotation tAnno = (TypeAnnotation)rtAnnos.annotations[0];
 888         Assert.check(tAnno.position.type.toString().equals(positionType));
 889         String annotationName = classFile.constant_pool.getUTF8Value(tAnno.annotation.type_index).toString().substring(1);
 890         Assert.check(annotationName.startsWith(annoName));
 891     }
 892 
 893     private void checkAnno(ClassFile classFile,
 894                            RuntimeAnnotations_attribute rAnnos,
 895                            String annoName) throws Exception {
 896         // containing only one type annotation
 897         Assert.check(rAnnos.annotations.length == 1);
 898         Annotation anno = (Annotation)rAnnos.annotations[0];
 899         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
 900         Assert.check(annotationName.startsWith(annoName));
 901     }
 902 
 903     // special case for parameter annotations
 904     private void checkParameterAnno(ClassFile classFile,
 905                            RuntimeVisibleParameterAnnotations_attribute rAnnos,
 906                            String annoName) throws Exception {
 907         // containing only one type annotation
 908         Assert.check(rAnnos.parameter_annotations.length == 1);
 909         Assert.check(rAnnos.parameter_annotations[0].length == 1);
 910         Annotation anno = (Annotation)rAnnos.parameter_annotations[0][0];
 911         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
 912         Assert.check(annotationName.startsWith(annoName));
 913     }
 914 
 915     private File findClassFileOrFail(File dir, String name) {
 916         for (final File fileEntry : dir.listFiles()) {
 917             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
 918                 return fileEntry;
 919             }
 920         }
 921         throw new AssertionError(&quot;file not found&quot;);
 922     }
 923 
 924     private Method findMethodOrFail(ClassFile classFile, String name) throws Exception {
 925         for (Method method : classFile.methods) {
 926             if (method.getName(classFile.constant_pool).equals(name)) {
 927                 return method;
 928             }
 929         }
 930         throw new AssertionError(&quot;method not found&quot;);
 931     }
 932 
 933     private Attribute findAttributeOrFail(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
 934         for (Attribute attribute : attributes) {
 935             if (attribute.getClass() == attrClass) {
 936                 return attribute;
 937             }
 938         }
 939         throw new AssertionError(&quot;attribute not found&quot;);
 940     }
 941 
 942     private void assertAttributeNotPresent(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
 943         for (Attribute attribute : attributes) {
 944             if (attribute.getClass() == attrClass) {
 945                 throw new AssertionError(&quot;attribute not expected&quot;);
 946             }
 947         }
 948     }
 949 
 950     @SupportedAnnotationTypes(&quot;*&quot;)
 951     public static final class Processor extends JavacTestingAbstractProcessor {
 952 
 953         String targets;
 954         int numberOfTypeAnnotations;
 955 
 956         @Override
 957         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 958             targets = processingEnv.getOptions().get(&quot;targets&quot;);
 959             for (TypeElement te : annotations) {
 960                 if (te.toString().equals(&quot;Anno&quot;)) {
 961                     checkElements(te, roundEnv, targets);
 962                     if (targets.contains(&quot;TYPE_USE&quot;)) {
 963                         Element element = processingEnv.getElementUtils().getTypeElement(&quot;R&quot;);
 964                         numberOfTypeAnnotations = 0;
 965                         checkTypeAnnotations(element);
 966                         Assert.check(numberOfTypeAnnotations == 4);
 967                     }
 968                 }
 969             }
 970             return true;
 971         }
 972 
 973         void checkElements(TypeElement te, RoundEnvironment renv, String targets) {
 974             Set&lt;? extends Element&gt; annoElements = renv.getElementsAnnotatedWith(te);
 975             Set&lt;String&gt; targetSet = new HashSet&lt;&gt;(Arrays.asList(targets.split(&quot;,&quot;)));
 976             // we will check for type annotation in another method
 977             targetSet.remove(&quot;ElementType.TYPE_USE&quot;);
 978             for (Element e : annoElements) {
 979                 Symbol s = (Symbol) e;
 980                 switch (s.getKind()) {
 981                     case FIELD:
 982                         Assert.check(targetSet.contains(&quot;ElementType.FIELD&quot;));
 983                         targetSet.remove(&quot;ElementType.FIELD&quot;);
 984                         break;
 985                     case METHOD:
 986                         Assert.check(targetSet.contains(&quot;ElementType.METHOD&quot;));
 987                         targetSet.remove(&quot;ElementType.METHOD&quot;);
 988                         break;
 989                     case PARAMETER:
 990                         Assert.check(targetSet.contains(&quot;ElementType.PARAMETER&quot;));
 991                         targetSet.remove(&quot;ElementType.PARAMETER&quot;);
 992                         break;
 993                     case RECORD_COMPONENT:
 994                         Assert.check(targetSet.contains(&quot;ElementType.RECORD_COMPONENT&quot;));
 995                         targetSet.remove(&quot;ElementType.RECORD_COMPONENT&quot;);
 996                         break;
 997                     default:
 998                         throw new AssertionError(&quot;unexpected element kind&quot;);
 999                 }
1000             }
1001             Assert.check(targetSet.isEmpty(), targetSet.toString());
1002         }
1003 
1004         private void checkTypeAnnotations(Element rootElement) {
1005             new ElementScanner&lt;Void, Void&gt;() {
1006                 @Override public Void visitVariable(VariableElement e, Void p) {
1007                     Symbol s = (Symbol) e;
1008                     if (s.getKind() == ElementKind.FIELD ||
1009                             s.getKind() == ElementKind.PARAMETER &amp;&amp;
1010                             s.name.toString().equals(&quot;s&quot;)) {
1011                         int currentTAs = numberOfTypeAnnotations;
1012                         verifyTypeAnnotations(e.asType().getAnnotationMirrors());
1013                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
1014                     }
1015                     return null;
1016                 }
1017                 @Override
1018                 public Void visitExecutable(ExecutableElement e, Void p) {
1019                     Symbol s = (Symbol) e;
1020                     if (s.getKind() == ElementKind.METHOD &amp;&amp;
1021                                     s.name.toString().equals(&quot;s&quot;)) {
1022                         int currentTAs = numberOfTypeAnnotations;
1023                         verifyTypeAnnotations(e.getReturnType().getAnnotationMirrors());
1024                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
1025                     }
1026                     scan(e.getParameters(), p);
1027                     return null;
1028                 }
1029                 @Override public Void visitRecordComponent(RecordComponentElement e, Void p) {
1030                     int currentTAs = numberOfTypeAnnotations;
1031                     verifyTypeAnnotations(e.asType().getAnnotationMirrors());
1032                     Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
1033                     return null;
1034                 }
1035             }.scan(rootElement, null);
1036         }
1037 
1038         private void verifyTypeAnnotations(Iterable&lt;? extends AnnotationMirror&gt; annotations) {
1039             for (AnnotationMirror mirror : annotations) {
1040                 Assert.check(mirror.toString().startsWith(&quot;@Anno&quot;));
1041                 if (mirror instanceof TypeCompound) {
1042                     numberOfTypeAnnotations++;
1043                 }
1044             }
1045         }
1046     }
1047 
1048     public void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {
1049         int numberOfFieldRefs = 0;
1050         File dir = assertOK(true, &quot;record R() {}&quot;);
1051         for (final File fileEntry : dir.listFiles()) {
1052             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
1053                 ClassFile classFile = ClassFile.read(fileEntry);
1054                 for (Method method : classFile.methods)
1055                     switch (method.getName(classFile.constant_pool)) {
1056                         case &quot;toString&quot;, &quot;equals&quot;, &quot;hashCode&quot; -&gt;
1057                             Assert.check(method.access_flags.is(AccessFlags.ACC_PUBLIC) &amp;&amp; method.access_flags.is(AccessFlags.ACC_FINAL));
1058                         default -&gt; { /* do nothing */ }
1059                     }
1060             }
1061         }
1062     }
1063 
1064     private static final List&lt;String&gt; ACCESSIBILITY = List.of(
1065             &quot;public&quot;, &quot;protected&quot;, &quot;&quot;, &quot;private&quot;);
1066 
1067     public void testCanonicalAccessibility() throws Exception {
1068         // accessibility of canonical can&#39;t be stronger than that of the record type
1069         for (String a1 : ACCESSIBILITY) {
1070             for (String a2 : ACCESSIBILITY) {
1071                 if (protection(a2) &gt; protection(a1)) {
1072                     assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;class R {# record RR() { # RR {} } }&quot;, a1, a2);
1073                 } else {
1074                     assertOK(&quot;class R {# record RR() { # RR {} } }&quot;, a1, a2);
1075                 }
1076             }
1077         }
1078 
1079         // now lets check that when compiler the compiler generates the canonical, it has the same accessibility
1080         // as the record type
1081         for (String a : ACCESSIBILITY) {
1082             File dir = assertOK(true, &quot;class R {# record RR() {} }&quot;, a);
1083             for (final File fileEntry : dir.listFiles()) {
1084                 if (fileEntry.getName().equals(&quot;R$RR.class&quot;)) {
1085                     ClassFile classFile = ClassFile.read(fileEntry);
1086                     for (Method method : classFile.methods)
1087                         if (method.getName(classFile.constant_pool).equals(&quot;&lt;init&gt;&quot;)) {
1088                             Assert.check(method.access_flags.flags == accessFlag(a),
1089                                     &quot;was expecting access flag &quot; + accessFlag(a) + &quot; but found &quot; + method.access_flags.flags);
1090                         }
1091                 }
1092             }
1093         }
1094     }
1095 
1096     private int protection(String access) {
1097         switch (access) {
1098             case &quot;private&quot;: return 3;
1099             case &quot;protected&quot;: return 1;
1100             case &quot;public&quot;: return 0;
1101             case &quot;&quot;: return 2;
1102             default:
1103                 throw new AssertionError();
1104         }
1105     }
1106 
1107     private int accessFlag(String access) {
1108         switch (access) {
1109             case &quot;private&quot;: return AccessFlags.ACC_PRIVATE;
1110             case &quot;protected&quot;: return AccessFlags.ACC_PROTECTED;
1111             case &quot;public&quot;: return AccessFlags.ACC_PUBLIC;
1112             case &quot;&quot;: return 0;
1113             default:
1114                 throw new AssertionError();
1115         }
1116     }
1117 
1118     public void testSameArity() {
1119         for (String source : List.of(
1120                 &quot;&quot;&quot;
1121                 record R(int... args) {
1122                     public R(int... args) {
1123                         this.args = args;
1124                     }
1125                 }
1126                 &quot;&quot;&quot;,
1127                 &quot;&quot;&quot;
1128                 record R(int[] args) {
1129                     public R(int[] args) {
1130                         this.args = args;
1131                     }
1132                 }
1133                 &quot;&quot;&quot;
1134         )) {
1135             assertOK(source);
1136         }
1137 
1138         for (String source : List.of(
1139                 &quot;&quot;&quot;
1140                 record R(int... args) {
1141                     public R(int[] args) {
1142                         this.args = args;
1143                     }
1144                 }
1145                 &quot;&quot;&quot;,
1146                 &quot;&quot;&quot;
1147                 record R(int... args) {
1148                     public R(int[] args) {
1149                         this.args = args;
1150                     }
1151                 }
1152                 &quot;&quot;&quot;,
1153                 &quot;&quot;&quot;
1154                 record R(String... args) {
1155                     public R(String[] args) {
1156                         this.args = args;
1157                     }
1158                 }
1159                 &quot;&quot;&quot;,
1160                 &quot;&quot;&quot;
1161                 record R(String... args) {
1162                     public R(String[] args) {
1163                         this.args = args;
1164                     }
1165                 }
1166                 &quot;&quot;&quot;
1167         )) {
1168             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, source);
1169         }
1170     }
1171 
1172     public void testSafeVararsAnno() {
1173         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;,
1174                 &quot;&quot;&quot;
1175                 @SafeVarargs
1176                 record R&lt;T&gt;(T... t) {}
1177                 &quot;&quot;&quot;,
1178                 &quot;&quot;&quot;
1179                 @SafeVarargs
1180                 record R&lt;T&gt;(T... t) {
1181                     R(T... t) {
1182                         this.t = t;
1183                     }
1184                 }
1185                 &quot;&quot;&quot;
1186         );
1187 
1188         assertOK(
1189                 &quot;&quot;&quot;
1190                 record R&lt;T&gt;(T... t) {
1191                     @SafeVarargs
1192                     R(T... t) {
1193                         this.t = t;
1194                     }
1195                 }
1196                 &quot;&quot;&quot;
1197         );
1198 
1199         appendCompileOptions(&quot;-Xlint:unchecked&quot;);
1200         assertOKWithWarning(&quot;compiler.warn.unchecked.varargs.non.reifiable.type&quot;,
1201                 &quot;&quot;&quot;
1202                 record R&lt;T&gt;(T... t) {
1203                     R(T... t) {
1204                         this.t = t;
1205                     }
1206                 }
1207                 &quot;&quot;&quot;
1208         );
1209         removeLastCompileOptions(1);
1210 
1211         assertOK(
1212                 &quot;&quot;&quot;
1213                 @SuppressWarnings(&quot;unchecked&quot;)
1214                 record R&lt;T&gt;(T... t) {
1215                     R(T... t) {
1216                         this.t = t;
1217                     }
1218                 }
1219                 &quot;&quot;&quot;
1220         );
1221 
1222         assertOK(
1223                 &quot;&quot;&quot;
1224                 record R&lt;T&gt;(T... t) {
1225                     @SuppressWarnings(&quot;unchecked&quot;)
1226                     R(T... t) {
1227                         this.t = t;
1228                     }
1229                 }
1230                 &quot;&quot;&quot;
1231         );
1232     }
1233 
1234     public void testOverrideAtAccessor() {
1235         assertOK(
1236                 &quot;&quot;&quot;
1237                 record R(int i) {
1238                     @Override
1239                     public int i() { return i; }
1240                 }
1241                 &quot;&quot;&quot;,
1242                 &quot;&quot;&quot;
1243                 record R(int i, int j) {
1244                     @Override
1245                     public int i() { return i; }
1246                     public int j() { return j; }
1247                 }
1248                 &quot;&quot;&quot;,
1249                 &quot;&quot;&quot;
1250                 interface I { int i(); }
1251                 record R(int i) implements I {
1252                     @Override
1253                     public int i() { return i; }
1254                 }
1255                 &quot;&quot;&quot;,
1256                 &quot;&quot;&quot;
1257                 interface I { int i(); }
1258                 record R(int i) implements I {
1259                     public int i() { return i; }
1260                 }
1261                 &quot;&quot;&quot;,
1262                 &quot;&quot;&quot;
1263                 interface I { default int i() { return 0; } }
1264                 record R(int i) implements I {
1265                     @Override
1266                     public int i() { return i; }
1267                 }
1268                 &quot;&quot;&quot;
1269         );
1270     }
1271 
1272     public void testNoAssigmentInsideCompactRecord() {
1273         assertFail(&quot;compiler.err.cant.assign.val.to.final.var&quot;,
1274                 &quot;&quot;&quot;
1275                 record R(int i) {
1276                     R {
1277                         this.i = i;
1278                     }
1279                 }
1280                 &quot;&quot;&quot;
1281         );
1282         assertFail(&quot;compiler.err.cant.assign.val.to.final.var&quot;,
1283                 &quot;&quot;&quot;
1284                 record R(int i) {
1285                     R {
1286                         (this).i = i;
1287                     }
1288                 }
1289                 &quot;&quot;&quot;
1290         );
1291     }
1292 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/langtools/tools/javac/records/RecordCompilationTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../processing/model/element/TestRecordDesugar.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="RecordMemberTests.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/tools/javac/records/RecordCompilationTests.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,11 ***</span>
   *      jdk.compiler/com.sun.tools.javac.code
   *      jdk.compiler/com.sun.tools.javac.util
   *      jdk.jdeps/com.sun.tools.classfile
   * @build JavacTestingAbstractProcessor
   * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java
<span class="line-modified">!  * @run testng/othervm --enable-preview RecordCompilationTests</span>
   */
  
  import java.io.File;
  
  import java.lang.annotation.ElementType;
<span class="line-new-header">--- 34,12 ---</span>
   *      jdk.compiler/com.sun.tools.javac.code
   *      jdk.compiler/com.sun.tools.javac.util
   *      jdk.jdeps/com.sun.tools.classfile
   * @build JavacTestingAbstractProcessor
   * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java
<span class="line-modified">!  * @run testng/othervm -DuseAP=false --enable-preview RecordCompilationTests</span>
<span class="line-added">+  * @run testng/othervm -DuseAP=true --enable-preview RecordCompilationTests</span>
   */
  
  import java.io.File;
  
  import java.lang.annotation.ElementType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,10 ***</span>
<span class="line-new-header">--- 54,11 ---</span>
  import java.util.stream.Stream;
  
  
  import com.sun.tools.javac.util.Assert;
  
<span class="line-added">+ import javax.annotation.processing.AbstractProcessor;</span>
  import javax.annotation.processing.RoundEnvironment;
  import javax.annotation.processing.SupportedAnnotationTypes;
  
  import javax.lang.model.element.AnnotationMirror;
  import javax.lang.model.element.AnnotationValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,17 ***</span>
<span class="line-new-header">--- 70,21 ---</span>
  import javax.lang.model.element.VariableElement;
  
  import javax.lang.model.type.ArrayType;
  import javax.lang.model.type.TypeMirror;
  
<span class="line-added">+ import com.sun.tools.classfile.AccessFlags;</span>
  import com.sun.tools.classfile.Annotation;
  import com.sun.tools.classfile.Attribute;
  import com.sun.tools.classfile.Attributes;
  import com.sun.tools.classfile.ClassFile;
<span class="line-added">+ import com.sun.tools.classfile.Code_attribute;</span>
  import com.sun.tools.classfile.ConstantPool;
<span class="line-added">+ import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;</span>
  import com.sun.tools.classfile.ConstantPool.CPInfo;
  import com.sun.tools.classfile.Field;
<span class="line-added">+ import com.sun.tools.classfile.Instruction;</span>
  import com.sun.tools.classfile.Method;
  import com.sun.tools.classfile.Record_attribute;
  import com.sun.tools.classfile.Record_attribute.ComponentInfo;
  import com.sun.tools.classfile.RuntimeAnnotations_attribute;
  import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,24 ***</span>
  import tools.javac.combo.CompilationTestCase;
  
  import static java.lang.annotation.ElementType.*;
  import static org.testng.Assert.assertEquals;
  
  @Test
  public class RecordCompilationTests extends CompilationTestCase {
<span class="line-removed">- </span>
      // @@@ When records become a permanent feature, we don&#39;t need these any more
<span class="line-modified">!     private static String[] PREVIEW_OPTIONS = {&quot;--enable-preview&quot;, &quot;-source&quot;,</span>
<span class="line-modified">!                                                Integer.toString(Runtime.version().feature())};</span>
  
      private static final List&lt;String&gt; BAD_COMPONENT_NAMES = List.of(
              &quot;clone&quot;, &quot;finalize&quot;, &quot;getClass&quot;, &quot;hashCode&quot;,
              &quot;notify&quot;, &quot;notifyAll&quot;, &quot;toString&quot;, &quot;wait&quot;);
  
<span class="line-modified">!     {</span>
          setDefaultFilename(&quot;R.java&quot;);
<span class="line-modified">!         setCompileOptions(PREVIEW_OPTIONS);</span>
      }
  
      public void testMalformedDeclarations() {
          assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R()&quot;);
          assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R();&quot;);
<span class="line-new-header">--- 103,55 ---</span>
  import tools.javac.combo.CompilationTestCase;
  
  import static java.lang.annotation.ElementType.*;
  import static org.testng.Assert.assertEquals;
  
<span class="line-added">+ /** Records are the first feature which sports automatic injection of (declarative and type) annotations : from a</span>
<span class="line-added">+  *  given record component to one or more record members, if applicable.</span>
<span class="line-added">+  *  This implies that the record&#39;s implementation can be stressed with the presence of annotation processors. Which is</span>
<span class="line-added">+  *  something the implementator could easily skip. For this reason this test is executed twice, once without the</span>
<span class="line-added">+  *  presence of any annotation processor and one with a simple annotation processor (which does not annotation processing</span>
<span class="line-added">+  *  at all) just to force at least a round of annotation processing.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  *  Tests needing special compilation options need to store current options, set its customs options by invoking method</span>
<span class="line-added">+  *  `setCompileOptions` and then reset the previous compilation options for other tests. To see an example of this check</span>
<span class="line-added">+  *  method: testAnnos()</span>
<span class="line-added">+  */</span>
<span class="line-added">+ </span>
  @Test
  public class RecordCompilationTests extends CompilationTestCase {
      // @@@ When records become a permanent feature, we don&#39;t need these any more
<span class="line-modified">!     private static String[] PREVIEW_OPTIONS = {</span>
<span class="line-modified">!             &quot;--enable-preview&quot;,</span>
<span class="line-added">+             &quot;-source&quot;, Integer.toString(Runtime.version().feature())</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static String[] PREVIEW_OPTIONS_WITH_AP = {</span>
<span class="line-added">+             &quot;--enable-preview&quot;,</span>
<span class="line-added">+             &quot;-source&quot;, Integer.toString(Runtime.version().feature()),</span>
<span class="line-added">+             &quot;-processor&quot;, SimplestAP.class.getName()</span>
<span class="line-added">+     };</span>
  
      private static final List&lt;String&gt; BAD_COMPONENT_NAMES = List.of(
              &quot;clone&quot;, &quot;finalize&quot;, &quot;getClass&quot;, &quot;hashCode&quot;,
              &quot;notify&quot;, &quot;notifyAll&quot;, &quot;toString&quot;, &quot;wait&quot;);
  
<span class="line-modified">!     /* simplest annotation processor just to force a round of annotation processing for all tests</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @SupportedAnnotationTypes(&quot;*&quot;)</span>
<span class="line-added">+     public static class SimplestAP extends AbstractProcessor {</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public RecordCompilationTests() {</span>
<span class="line-added">+         boolean useAP = System.getProperty(&quot;useAP&quot;) == null ? false : System.getProperty(&quot;useAP&quot;).equals(&quot;true&quot;);</span>
          setDefaultFilename(&quot;R.java&quot;);
<span class="line-modified">!         setCompileOptions(useAP ? PREVIEW_OPTIONS_WITH_AP : PREVIEW_OPTIONS);</span>
<span class="line-added">+         System.out.println(useAP ? &quot;running all tests using an annotation processor&quot; : &quot;running all tests without annotation processor&quot;);</span>
      }
  
      public void testMalformedDeclarations() {
          assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R()&quot;);
          assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R();&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 128,11 ***</span>
          assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;public public record R(String foo) { }&quot;);
          assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;private private record R(String foo) { }&quot;);
          assertFail(&quot;compiler.err.already.defined&quot;, &quot;record R(int x, int x) {}&quot;);
          for (String s : List.of(&quot;var&quot;, &quot;record&quot;))
              assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, &quot;record R(# x) { }&quot;, s);
<span class="line-modified">!         for (String s : List.of(&quot;public&quot;, &quot;private&quot;, &quot;volatile&quot;, &quot;final&quot;))</span>
              assertFail(&quot;compiler.err.record.cant.declare.field.modifiers&quot;, &quot;record R(# String foo) { }&quot;, s);
          assertFail(&quot;compiler.err.varargs.must.be.last&quot;, &quot;record R(int... x, int... y) {}&quot;);
          assertFail(&quot;compiler.err.instance.initializer.not.allowed.in.records&quot;, &quot;record R(int i) { {} }&quot;);
      }
  
<span class="line-new-header">--- 165,12 ---</span>
          assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;public public record R(String foo) { }&quot;);
          assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;private private record R(String foo) { }&quot;);
          assertFail(&quot;compiler.err.already.defined&quot;, &quot;record R(int x, int x) {}&quot;);
          for (String s : List.of(&quot;var&quot;, &quot;record&quot;))
              assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, &quot;record R(# x) { }&quot;, s);
<span class="line-modified">!         for (String s : List.of(&quot;public&quot;, &quot;protected&quot;, &quot;private&quot;, &quot;static&quot;, &quot;final&quot;, &quot;transient&quot;, &quot;volatile&quot;,</span>
<span class="line-added">+                 &quot;abstract&quot;, &quot;synchronized&quot;, &quot;native&quot;, &quot;strictfp&quot;)) // missing: sealed and non-sealed</span>
              assertFail(&quot;compiler.err.record.cant.declare.field.modifiers&quot;, &quot;record R(# String foo) { }&quot;, s);
          assertFail(&quot;compiler.err.varargs.must.be.last&quot;, &quot;record R(int... x, int... y) {}&quot;);
          assertFail(&quot;compiler.err.instance.initializer.not.allowed.in.records&quot;, &quot;record R(int i) { {} }&quot;);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,11 ***</span>
                  + &quot;class C extends R { }&quot;);
      }
  
      public void testNoExtendRecord() {
          assertFail(&quot;compiler.err.invalid.supertype.record&quot;,
<span class="line-modified">!                    &quot;class R extends Record { public String toString() { return null; } public int hashCode() { return 0; } public boolean equals(Object o) { return false; } } }&quot;);</span>
      }
  
      public void testFieldDeclarations() {
          // static fields are OK
          assertOK(&quot;public record R(int x) {\n&quot; +
<span class="line-new-header">--- 246,18 ---</span>
                  + &quot;class C extends R { }&quot;);
      }
  
      public void testNoExtendRecord() {
          assertFail(&quot;compiler.err.invalid.supertype.record&quot;,
<span class="line-modified">!                    &quot;&quot;&quot;</span>
<span class="line-added">+                    class R extends Record {</span>
<span class="line-added">+                        public String toString() { return null; }</span>
<span class="line-added">+                        public int hashCode() { return 0; }</span>
<span class="line-added">+                        public boolean equals(Object o) { return false; }</span>
<span class="line-added">+                    }</span>
<span class="line-added">+                    &quot;&quot;&quot;</span>
<span class="line-added">+         );</span>
      }
  
      public void testFieldDeclarations() {
          // static fields are OK
          assertOK(&quot;public record R(int x) {\n&quot; +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,10 ***</span>
<span class="line-new-header">--- 289,18 ---</span>
      public void testAccessorRedeclaration() {
          assertOK(&quot;public record R(int x) {\n&quot; +
                  &quot;    public int x() { return x; };&quot; +
                  &quot;}&quot;);
  
<span class="line-added">+         assertOK(&quot;public record R(int... x) {\n&quot; +</span>
<span class="line-added">+                 &quot;    public int[] x() { return x; };&quot; +</span>
<span class="line-added">+                 &quot;}&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         assertOK(&quot;public record R(int x) {\n&quot; +</span>
<span class="line-added">+                 &quot;    public final int x() { return 0; };&quot; +</span>
<span class="line-added">+                 &quot;}&quot;);</span>
<span class="line-added">+ </span>
          assertOK(&quot;public record R(int x) {\n&quot; +
                  &quot;    public final int x() { return 0; };&quot; +
                  &quot;}&quot;);
  
          assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,12 ***</span>
  
      public void testConstructorRedeclaration() {
          for (String goodCtor : List.of(
                  &quot;public R(int x) { this(x, 0); }&quot;,
                  &quot;public R(int x, int y) { this.x = x; this.y = y; }&quot;,
<span class="line-modified">!                 &quot;public R { }&quot;,</span>
<span class="line-removed">-                 &quot;public R { this.x = 0; }&quot;))</span>
              assertOK(&quot;record R(int x, int y) { # }&quot;, goodCtor);
  
          assertOK(&quot;import java.util.*; record R(String x, String y) {  public R { Objects.requireNonNull(x); Objects.requireNonNull(y); } }&quot;);
  
          // Not OK to redeclare canonical without DA
<span class="line-new-header">--- 344,11 ---</span>
  
      public void testConstructorRedeclaration() {
          for (String goodCtor : List.of(
                  &quot;public R(int x) { this(x, 0); }&quot;,
                  &quot;public R(int x, int y) { this.x = x; this.y = y; }&quot;,
<span class="line-modified">!                 &quot;public R { }&quot;))</span>
              assertOK(&quot;record R(int x, int y) { # }&quot;, goodCtor);
  
          assertOK(&quot;import java.util.*; record R(String x, String y) {  public R { Objects.requireNonNull(x); Objects.requireNonNull(y); } }&quot;);
  
          // Not OK to redeclare canonical without DA
</pre>
<hr />
<pre>
<span class="line-old-header">*** 306,16 ***</span>
          // Not OK to rearrange or change names
          for (String s : List.of(&quot;public R(int y, int x) { this.x = x; this.y = y; }&quot;,
                                  &quot;public R(int _x, int _y) { this.x = _x; this.y = _y; }&quot;))
              assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;, s);
  
<span class="line-removed">-         // canonical ctor must be public</span>
<span class="line-removed">-         for (String s : List.of(&quot;&quot;, &quot;protected&quot;, &quot;private&quot;))</span>
<span class="line-removed">-             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;,</span>
<span class="line-removed">-                        &quot;# R(int x, int y) { this.x = x; this.y = y; }&quot;,</span>
<span class="line-removed">-                        s);</span>
<span class="line-removed">- </span>
          // ctor args must match types
          assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
                  &quot;import java.util.*;\n&quot; +
                          &quot;record R(List&lt;String&gt; list) { # }&quot;,
                  &quot;R(List list) { this.list = list; }&quot;);
<span class="line-new-header">--- 358,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 432,17 ***</span>
                    &quot;        public int i() { return i; }\n&quot; +
                    &quot;    }&quot;;
          assertFail(&quot;compiler.err.already.defined&quot;, template);
      }
  
<span class="line-modified">!     public void testLocalRecords() {</span>
<span class="line-removed">-         assertOK(&quot;class R { \n&quot; +</span>
<span class="line-removed">-                 &quot;    void m() { \n&quot; +</span>
<span class="line-removed">-                 &quot;        record RR(int x) { };\n&quot; +</span>
<span class="line-removed">-                 &quot;    }\n&quot; +</span>
<span class="line-removed">-                 &quot;}&quot;);</span>
<span class="line-removed">- </span>
          // local records can also be final
          assertOK(&quot;class R { \n&quot; +
                  &quot;    void m() { \n&quot; +
                  &quot;        final record RR(int x) { };\n&quot; +
                  &quot;    }\n&quot; +
<span class="line-new-header">--- 478,11 ---</span>
                    &quot;        public int i() { return i; }\n&quot; +
                    &quot;    }&quot;;
          assertFail(&quot;compiler.err.already.defined&quot;, template);
      }
  
<span class="line-modified">!     public void testStaticLocalTypes() {</span>
          // local records can also be final
          assertOK(&quot;class R { \n&quot; +
                  &quot;    void m() { \n&quot; +
                  &quot;        final record RR(int x) { };\n&quot; +
                  &quot;    }\n&quot; +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 486,53 ***</span>
                  &quot;    static int z = 0;\n&quot; +
                  &quot;    void m() { \n&quot; +
                  &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
                  &quot;    }\n&quot; +
                  &quot;}&quot;);
<span class="line-removed">-         // can be contained inside a lambda</span>
<span class="line-removed">-         assertOK(&quot;&quot;&quot;</span>
<span class="line-removed">-                 class Outer {</span>
<span class="line-removed">-                     Runnable run = () -&gt; {</span>
<span class="line-removed">-                         record TestRecord(int i) {}</span>
<span class="line-removed">-                     };</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 &quot;&quot;&quot;);</span>
<span class="line-removed">- </span>
          // Can&#39;t self-shadow
          assertFail(&quot;compiler.err.already.defined&quot;,
<span class="line-modified">!                    &quot;class R { \n&quot; +</span>
<span class="line-modified">!                    &quot;    void m() { \n&quot; +</span>
<span class="line-modified">!                    &quot;        record R(int x) { };\n&quot; +</span>
<span class="line-modified">!                    &quot;    }\n&quot; +</span>
<span class="line-modified">!                    &quot;}&quot;);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public void testCompactDADU() {</span>
<span class="line-modified">!         // trivial cases</span>
<span class="line-modified">!         assertOK(&quot;record R() { public R {} }&quot;);</span>
<span class="line-modified">!         assertOK(&quot;record R(int x) { public R {} }&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // throwing an unchecked exception</span>
<span class="line-modified">!         assertOK(&quot;record R(int x) { public R { if (x &lt; 0) { this.x = x; throw new RuntimeException(); }} }&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         assertOK(&quot;record R(int x) { public R { if (x &lt; 0) { this.x = x; throw new RuntimeException(); }} }&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // x is not DA nor DU in the body of the constructor hence error</span>
<span class="line-removed">-         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x) { # }&quot;,</span>
<span class="line-removed">-                 &quot;public R { if (x &lt; 0) { this.x = -x; } }&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // if static fields are not DA then error</span>
<span class="line-removed">-         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,</span>
<span class="line-removed">-                 &quot;record R() { # }&quot;, &quot;static final String x;&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // ditto</span>
<span class="line-removed">-         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,</span>
<span class="line-removed">-                 &quot;record R() { # }&quot;, &quot;static final String x; public R {}&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // ditto</span>
<span class="line-removed">-         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,</span>
<span class="line-removed">-                 &quot;record R(int i) { # }&quot;, &quot;static final String x; public R {}&quot;);</span>
      }
  
      public void testReturnInCanonical_Compact() {
          assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
                  &quot;public R { return; }&quot;);
<span class="line-new-header">--- 526,30 ---</span>
                  &quot;    static int z = 0;\n&quot; +
                  &quot;    void m() { \n&quot; +
                  &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
                  &quot;    }\n&quot; +
                  &quot;}&quot;);
          // Can&#39;t self-shadow
          assertFail(&quot;compiler.err.already.defined&quot;,
<span class="line-modified">!                 &quot;&quot;&quot;</span>
<span class="line-modified">!                 class R {</span>
<span class="line-modified">!                     void m() {</span>
<span class="line-modified">!                         record R(int x) { };</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 &quot;&quot;&quot;</span>
<span class="line-modified">!         );</span>
<span class="line-modified">!         // can&#39;t be explicitly static</span>
<span class="line-modified">!         assertFail(&quot;compiler.err.illegal.start.of.expr&quot;,</span>
<span class="line-modified">!                 &quot;&quot;&quot;</span>
<span class="line-modified">!                 class R {</span>
<span class="line-modified">!                     void m() {</span>
<span class="line-modified">!                         static record RR(int x) { };</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 &quot;&quot;&quot;</span>
<span class="line-modified">!         );</span>
      }
  
      public void testReturnInCanonical_Compact() {
          assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
                  &quot;public R { return; }&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,36 ***</span>
          assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
                  &quot;public native void m();&quot;);
      }
  
      public void testRecordsInsideInner() {
<span class="line-modified">!         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,</span>
<span class="line-modified">!                 &quot;class Outer {\n&quot; +</span>
<span class="line-modified">!                 &quot;    class Inner {\n&quot; +</span>
<span class="line-modified">!                 &quot;        record R(int a) {}\n&quot; +</span>
<span class="line-modified">!                 &quot;    }\n&quot; +</span>
<span class="line-modified">!                 &quot;}&quot;);</span>
<span class="line-modified">!         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,</span>
                  &quot;&quot;&quot;
                  class Outer {
                      public void test() {
                          class Inner extends Outer {
                              record R(int i) {}
                          }
                      }
                  }
                  &quot;&quot;&quot;);
<span class="line-modified">!         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,</span>
                  &quot;&quot;&quot;
                  class Outer {
                      Runnable run = new Runnable() {
                          record TestRecord(int i) {}
                          public void run() {}
                      };
                  }
                  &quot;&quot;&quot;);
<span class="line-modified">!         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,</span>
                  &quot;&quot;&quot;
                  class Outer {
                      void m() {
                          record A() {
                              record B() { }
<span class="line-new-header">--- 576,39 ---</span>
          assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
                  &quot;public native void m();&quot;);
      }
  
      public void testRecordsInsideInner() {
<span class="line-modified">!         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,</span>
<span class="line-modified">!                 &quot;&quot;&quot;</span>
<span class="line-modified">!                 class Outer {</span>
<span class="line-modified">!                     class Inner {</span>
<span class="line-modified">!                         record R(int a) {}</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,</span>
                  &quot;&quot;&quot;
                  class Outer {
                      public void test() {
                          class Inner extends Outer {
                              record R(int i) {}
                          }
                      }
                  }
                  &quot;&quot;&quot;);
<span class="line-modified">!         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,</span>
                  &quot;&quot;&quot;
                  class Outer {
                      Runnable run = new Runnable() {
                          record TestRecord(int i) {}
                          public void run() {}
                      };
                  }
                  &quot;&quot;&quot;);
<span class="line-modified">!         assertFail(&quot;compiler.err.static.declaration.not.allowed.in.inner.classes&quot;,</span>
                  &quot;&quot;&quot;
                  class Outer {
                      void m() {
                          record A() {
                              record B() { }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 644,10 ***</span>
<span class="line-new-header">--- 664,51 ---</span>
              }
          }
          Assert.check(numberOfFieldRefs == 1);
      }
  
<span class="line-added">+     /*  check that fields are initialized in a canonical constructor in the same declaration order as the corresponding</span>
<span class="line-added">+      *  record component</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void testCheckInitializationOrderInCompactConstructor() throws Exception {</span>
<span class="line-added">+         int putField1 = -1;</span>
<span class="line-added">+         int putField2 = -1;</span>
<span class="line-added">+         File dir = assertOK(true, &quot;record R(int i, String s) { R {} }&quot;);</span>
<span class="line-added">+         for (final File fileEntry : dir.listFiles()) {</span>
<span class="line-added">+             if (fileEntry.getName().equals(&quot;R.class&quot;)) {</span>
<span class="line-added">+                 ClassFile classFile = ClassFile.read(fileEntry);</span>
<span class="line-added">+                 for (Method method : classFile.methods) {</span>
<span class="line-added">+                     if (method.getName(classFile.constant_pool).equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="line-added">+                         Code_attribute code_attribute = (Code_attribute) method.attributes.get(&quot;Code&quot;);</span>
<span class="line-added">+                         for (Instruction instruction : code_attribute.getInstructions()) {</span>
<span class="line-added">+                             if (instruction.getMnemonic().equals(&quot;putfield&quot;)) {</span>
<span class="line-added">+                                 if (putField1 != -1 &amp;&amp; putField2 != -1) {</span>
<span class="line-added">+                                     throw new AssertionError(&quot;was expecting only two putfield instructions in this method&quot;);</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                                 if (putField1 == -1) {</span>
<span class="line-added">+                                     putField1 = instruction.getShort(1);</span>
<span class="line-added">+                                 } else if (putField2 == -1) {</span>
<span class="line-added">+                                     putField2 = instruction.getShort(1);</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         // now we need to check that we are assigning to `i` first and to `s` afterwards</span>
<span class="line-added">+                         CONSTANT_Fieldref_info fieldref_info1 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField1);</span>
<span class="line-added">+                         if (!fieldref_info1.getNameAndTypeInfo().getName().equals(&quot;i&quot;)) {</span>
<span class="line-added">+                             throw new AssertionError(&quot;was expecting variable name &#39;i&#39;&quot;);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+ </span>
<span class="line-added">+                         CONSTANT_Fieldref_info fieldref_info2 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField2);</span>
<span class="line-added">+                         if (!fieldref_info2.getNameAndTypeInfo().getName().equals(&quot;s&quot;)) {</span>
<span class="line-added">+                             throw new AssertionError(&quot;was expecting variable name &#39;s&#39;&quot;);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public void testAcceptRecordId() {
          String[] testOptions = {/* no options */};
          setCompileOptions(testOptions);
          assertOKWithWarning(&quot;compiler.warn.restricted.type.not.allowed.preview&quot;,
                  &quot;class R {\n&quot; +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 980,8 ***</span>
<span class="line-new-header">--- 1041,252 ---</span>
                  if (mirror instanceof TypeCompound) {
                      numberOfTypeAnnotations++;
                  }
              }
          }
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {</span>
<span class="line-added">+         int numberOfFieldRefs = 0;</span>
<span class="line-added">+         File dir = assertOK(true, &quot;record R() {}&quot;);</span>
<span class="line-added">+         for (final File fileEntry : dir.listFiles()) {</span>
<span class="line-added">+             if (fileEntry.getName().equals(&quot;R.class&quot;)) {</span>
<span class="line-added">+                 ClassFile classFile = ClassFile.read(fileEntry);</span>
<span class="line-added">+                 for (Method method : classFile.methods)</span>
<span class="line-added">+                     switch (method.getName(classFile.constant_pool)) {</span>
<span class="line-added">+                         case &quot;toString&quot;, &quot;equals&quot;, &quot;hashCode&quot; -&gt;</span>
<span class="line-added">+                             Assert.check(method.access_flags.is(AccessFlags.ACC_PUBLIC) &amp;&amp; method.access_flags.is(AccessFlags.ACC_FINAL));</span>
<span class="line-added">+                         default -&gt; { /* do nothing */ }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final List&lt;String&gt; ACCESSIBILITY = List.of(</span>
<span class="line-added">+             &quot;public&quot;, &quot;protected&quot;, &quot;&quot;, &quot;private&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     public void testCanonicalAccessibility() throws Exception {</span>
<span class="line-added">+         // accessibility of canonical can&#39;t be stronger than that of the record type</span>
<span class="line-added">+         for (String a1 : ACCESSIBILITY) {</span>
<span class="line-added">+             for (String a2 : ACCESSIBILITY) {</span>
<span class="line-added">+                 if (protection(a2) &gt; protection(a1)) {</span>
<span class="line-added">+                     assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;class R {# record RR() { # RR {} } }&quot;, a1, a2);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     assertOK(&quot;class R {# record RR() { # RR {} } }&quot;, a1, a2);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // now lets check that when compiler the compiler generates the canonical, it has the same accessibility</span>
<span class="line-added">+         // as the record type</span>
<span class="line-added">+         for (String a : ACCESSIBILITY) {</span>
<span class="line-added">+             File dir = assertOK(true, &quot;class R {# record RR() {} }&quot;, a);</span>
<span class="line-added">+             for (final File fileEntry : dir.listFiles()) {</span>
<span class="line-added">+                 if (fileEntry.getName().equals(&quot;R$RR.class&quot;)) {</span>
<span class="line-added">+                     ClassFile classFile = ClassFile.read(fileEntry);</span>
<span class="line-added">+                     for (Method method : classFile.methods)</span>
<span class="line-added">+                         if (method.getName(classFile.constant_pool).equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="line-added">+                             Assert.check(method.access_flags.flags == accessFlag(a),</span>
<span class="line-added">+                                     &quot;was expecting access flag &quot; + accessFlag(a) + &quot; but found &quot; + method.access_flags.flags);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-added">+     private int protection(String access) {</span>
<span class="line-added">+         switch (access) {</span>
<span class="line-added">+             case &quot;private&quot;: return 3;</span>
<span class="line-added">+             case &quot;protected&quot;: return 1;</span>
<span class="line-added">+             case &quot;public&quot;: return 0;</span>
<span class="line-added">+             case &quot;&quot;: return 2;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 throw new AssertionError();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private int accessFlag(String access) {</span>
<span class="line-added">+         switch (access) {</span>
<span class="line-added">+             case &quot;private&quot;: return AccessFlags.ACC_PRIVATE;</span>
<span class="line-added">+             case &quot;protected&quot;: return AccessFlags.ACC_PROTECTED;</span>
<span class="line-added">+             case &quot;public&quot;: return AccessFlags.ACC_PUBLIC;</span>
<span class="line-added">+             case &quot;&quot;: return 0;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 throw new AssertionError();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public void testSameArity() {</span>
<span class="line-added">+         for (String source : List.of(</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R(int... args) {</span>
<span class="line-added">+                     public R(int... args) {</span>
<span class="line-added">+                         this.args = args;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R(int[] args) {</span>
<span class="line-added">+                     public R(int[] args) {</span>
<span class="line-added">+                         this.args = args;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         )) {</span>
<span class="line-added">+             assertOK(source);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (String source : List.of(</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R(int... args) {</span>
<span class="line-added">+                     public R(int[] args) {</span>
<span class="line-added">+                         this.args = args;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R(int... args) {</span>
<span class="line-added">+                     public R(int[] args) {</span>
<span class="line-added">+                         this.args = args;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R(String... args) {</span>
<span class="line-added">+                     public R(String[] args) {</span>
<span class="line-added">+                         this.args = args;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R(String... args) {</span>
<span class="line-added">+                     public R(String[] args) {</span>
<span class="line-added">+                         this.args = args;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         )) {</span>
<span class="line-added">+             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, source);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public void testSafeVararsAnno() {</span>
<span class="line-added">+         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 @SafeVarargs</span>
<span class="line-added">+                 record R&lt;T&gt;(T... t) {}</span>
<span class="line-added">+                 &quot;&quot;&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 @SafeVarargs</span>
<span class="line-added">+                 record R&lt;T&gt;(T... t) {</span>
<span class="line-added">+                     R(T... t) {</span>
<span class="line-added">+                         this.t = t;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+ </span>
<span class="line-added">+         assertOK(</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R&lt;T&gt;(T... t) {</span>
<span class="line-added">+                     @SafeVarargs</span>
<span class="line-added">+                     R(T... t) {</span>
<span class="line-added">+                         this.t = t;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+ </span>
<span class="line-added">+         appendCompileOptions(&quot;-Xlint:unchecked&quot;);</span>
<span class="line-added">+         assertOKWithWarning(&quot;compiler.warn.unchecked.varargs.non.reifiable.type&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R&lt;T&gt;(T... t) {</span>
<span class="line-added">+                     R(T... t) {</span>
<span class="line-added">+                         this.t = t;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+         removeLastCompileOptions(1);</span>
<span class="line-added">+ </span>
<span class="line-added">+         assertOK(</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">+                 record R&lt;T&gt;(T... t) {</span>
<span class="line-added">+                     R(T... t) {</span>
<span class="line-added">+                         this.t = t;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+ </span>
<span class="line-added">+         assertOK(</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R&lt;T&gt;(T... t) {</span>
<span class="line-added">+                     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">+                     R(T... t) {</span>
<span class="line-added">+                         this.t = t;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public void testOverrideAtAccessor() {</span>
<span class="line-added">+         assertOK(</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R(int i) {</span>
<span class="line-added">+                     @Override</span>
<span class="line-added">+                     public int i() { return i; }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R(int i, int j) {</span>
<span class="line-added">+                     @Override</span>
<span class="line-added">+                     public int i() { return i; }</span>
<span class="line-added">+                     public int j() { return j; }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 interface I { int i(); }</span>
<span class="line-added">+                 record R(int i) implements I {</span>
<span class="line-added">+                     @Override</span>
<span class="line-added">+                     public int i() { return i; }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 interface I { int i(); }</span>
<span class="line-added">+                 record R(int i) implements I {</span>
<span class="line-added">+                     public int i() { return i; }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 interface I { default int i() { return 0; } }</span>
<span class="line-added">+                 record R(int i) implements I {</span>
<span class="line-added">+                     @Override</span>
<span class="line-added">+                     public int i() { return i; }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public void testNoAssigmentInsideCompactRecord() {</span>
<span class="line-added">+         assertFail(&quot;compiler.err.cant.assign.val.to.final.var&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R(int i) {</span>
<span class="line-added">+                     R {</span>
<span class="line-added">+                         this.i = i;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         );</span>
<span class="line-added">+         assertFail(&quot;compiler.err.cant.assign.val.to.final.var&quot;,</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+                 record R(int i) {</span>
<span class="line-added">+                     R {</span>
<span class="line-added">+                         (this).i = i;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 &quot;&quot;&quot;</span>
<span class="line-added">+         );</span>
      }
  }
</pre>
<center><a href="../processing/model/element/TestRecordDesugar.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="RecordMemberTests.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/gtest/utilities/test_resourceHash.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;memory/allocation.hpp&quot;
 26 #include &quot;memory/resourceArea.hpp&quot;
 27 #include &quot;unittest.hpp&quot;
 28 #include &quot;utilities/debug.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 30 #include &quot;utilities/resourceHash.hpp&quot;
 31 
 32 class CommonResourceHashtableTest : public ::testing::Test {
 33  protected:
 34   typedef void* K;
<a name="2" id="anc2"></a><span class="line-modified"> 35   typedef uintx V;</span>
 36   const static MEMFLAGS MEM_TYPE = mtInternal;
 37 
 38   static unsigned identity_hash(const K&amp; k) {
 39     return (unsigned) (uintptr_t) k;
 40   }
 41 
 42   static unsigned bad_hash(const K&amp; k) {
 43     return 1;
 44   }
 45 
 46   static void* as_K(uintptr_t val) {
 47     return (void*) val;
 48   }
 49 
 50   class EqualityTestIter {
 51    public:
 52 
 53     bool do_entry(K const&amp; k, V const&amp; v) {
 54       if ((uintptr_t) k != (uintptr_t) v) {
 55         EXPECT_EQ((uintptr_t) k, (uintptr_t) v);
 56         return false;
 57       } else {
 58         return true; // continue iteration
 59       }
 60     }
 61   };
<a name="3" id="anc3"></a><span class="line-added"> 62 </span>
 63 };
 64 
 65 class SmallResourceHashtableTest : public CommonResourceHashtableTest {
 66  protected:
 67 
 68   template&lt;
 69   unsigned (*HASH) (K const&amp;) = primitive_hash&lt;K&gt;,
 70   bool (*EQUALS)(K const&amp;, K const&amp;) = primitive_equals&lt;K&gt;,
 71   unsigned SIZE = 256,
 72   ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA
 73   &gt;
 74   class Runner : public AllStatic {
 75    public:
 76 
 77     static void test(V step) {
 78       EqualityTestIter et;
 79       ResourceHashtable&lt;K, V, HASH, EQUALS, SIZE, ALLOC_TYPE, MEM_TYPE&gt; rh;
 80 
 81       ASSERT_FALSE(rh.contains(as_K(step)));
 82 
 83       ASSERT_TRUE(rh.put(as_K(step), step));
 84       ASSERT_TRUE(rh.contains(as_K(step)));
 85 
 86       ASSERT_FALSE(rh.put(as_K(step), step));
 87 
 88       ASSERT_TRUE(rh.put(as_K(2 * step), 2 * step));
 89       ASSERT_TRUE(rh.put(as_K(3 * step), 3 * step));
 90       ASSERT_TRUE(rh.put(as_K(4 * step), 4 * step));
 91       ASSERT_TRUE(rh.put(as_K(5 * step), 5 * step));
 92 
 93       ASSERT_FALSE(rh.remove(as_K(0x0)));
 94 
 95       rh.iterate(&amp;et);
 96       if (::testing::Test::HasFailure()) {
 97         return;
 98       }
 99 
100       ASSERT_TRUE(rh.remove(as_K(step)));
<a name="4" id="anc4"></a><span class="line-added">101       ASSERT_FALSE(rh.contains(as_K(step)));</span>
<span class="line-added">102       rh.iterate(&amp;et);</span>
<span class="line-added">103 </span>
<span class="line-added">104 </span>
<span class="line-added">105       // Test put_if_absent(key) (creating a default-created value)</span>
<span class="line-added">106       bool created = false;</span>
<span class="line-added">107       V* v = rh.put_if_absent(as_K(step), &amp;created);</span>
<span class="line-added">108       ASSERT_TRUE(rh.contains(as_K(step)));</span>
<span class="line-added">109       ASSERT_TRUE(created);</span>
<span class="line-added">110       *v = (V)step;</span>
<span class="line-added">111 </span>
<span class="line-added">112       // Calling this function a second time should yield the same value pointer</span>
<span class="line-added">113       V* v2 = rh.put_if_absent(as_K(step), &amp;created);</span>
<span class="line-added">114       ASSERT_EQ(v, v2);</span>
<span class="line-added">115       ASSERT_EQ(*v2, *v);</span>
<span class="line-added">116       ASSERT_FALSE(created);</span>
<span class="line-added">117 </span>
<span class="line-added">118       ASSERT_TRUE(rh.remove(as_K(step)));</span>
<span class="line-added">119       ASSERT_FALSE(rh.contains(as_K(step)));</span>
120       rh.iterate(&amp;et);
<a name="5" id="anc5"></a><span class="line-added">121 </span>
<span class="line-added">122       // Test put_if_absent(key, value)</span>
<span class="line-added">123       v = rh.put_if_absent(as_K(step), step, &amp;created);</span>
<span class="line-added">124       ASSERT_EQ(*v, step);</span>
<span class="line-added">125       ASSERT_TRUE(rh.contains(as_K(step)));</span>
<span class="line-added">126       ASSERT_TRUE(created);</span>
<span class="line-added">127 </span>
<span class="line-added">128       v2 = rh.put_if_absent(as_K(step), step, &amp;created);</span>
<span class="line-added">129       // Calling this function a second time should yield the same value pointer</span>
<span class="line-added">130       ASSERT_EQ(v, v2);</span>
<span class="line-added">131       ASSERT_EQ(*v2, (V)step);</span>
<span class="line-added">132       ASSERT_FALSE(created);</span>
<span class="line-added">133 </span>
<span class="line-added">134       ASSERT_TRUE(rh.remove(as_K(step)));</span>
<span class="line-added">135       ASSERT_FALSE(rh.contains(as_K(step)));</span>
<span class="line-added">136       rh.iterate(&amp;et);</span>
<span class="line-added">137 </span>
<span class="line-added">138 </span>
139     }
140   };
141 };
142 
143 TEST_VM_F(SmallResourceHashtableTest, default) {
144   ResourceMark rm;
145   Runner&lt;&gt;::test(0x1);
146 }
147 
148 TEST_VM_F(SmallResourceHashtableTest, default_shifted) {
149   ResourceMark rm;
150   Runner&lt;&gt;::test(0x10);
151 }
152 
153 TEST_VM_F(SmallResourceHashtableTest, bad_hash) {
154   ResourceMark rm;
155   Runner&lt;bad_hash&gt;::test(0x1);
156 }
157 
158 TEST_VM_F(SmallResourceHashtableTest, bad_hash_shifted) {
159   ResourceMark rm;
160   Runner&lt;bad_hash&gt;::test(0x10);
161 }
162 
163 TEST_VM_F(SmallResourceHashtableTest, identity_hash) {
164   ResourceMark rm;
165   Runner&lt;identity_hash&gt;::test(0x1);
166 }
167 
168 TEST_VM_F(SmallResourceHashtableTest, identity_hash_shifted) {
169   ResourceMark rm;
170   Runner&lt;identity_hash&gt;::test(0x10);
171 }
172 
173 TEST_VM_F(SmallResourceHashtableTest, primitive_hash_no_rm) {
174   Runner&lt;primitive_hash&lt;K&gt;, primitive_equals&lt;K&gt;, 512, ResourceObj::C_HEAP&gt;::test(0x1);
175 }
176 
177 TEST_VM_F(SmallResourceHashtableTest, primitive_hash_no_rm_shifted) {
178   Runner&lt;primitive_hash&lt;K&gt;, primitive_equals&lt;K&gt;, 512, ResourceObj::C_HEAP&gt;::test(0x10);
179 }
180 
181 TEST_VM_F(SmallResourceHashtableTest, bad_hash_no_rm) {
182   Runner&lt;bad_hash, primitive_equals&lt;K&gt;, 512, ResourceObj::C_HEAP&gt;::test(0x1);
183 }
184 
185 TEST_VM_F(SmallResourceHashtableTest, bad_hash_no_rm_shifted) {
186   Runner&lt;bad_hash, primitive_equals&lt;K&gt;, 512, ResourceObj::C_HEAP&gt;::test(0x10);
187 }
188 
189 TEST_VM_F(SmallResourceHashtableTest, identity_hash_no_rm) {
190   Runner&lt;identity_hash, primitive_equals&lt;K&gt;, 1, ResourceObj::C_HEAP&gt;::test(0x1);
191 }
192 
193 TEST_VM_F(SmallResourceHashtableTest, identity_hash_no_rm_shifted) {
194   Runner&lt;identity_hash, primitive_equals&lt;K&gt;, 1, ResourceObj::C_HEAP&gt;::test(0x10);
195 }
196 
197 class GenericResourceHashtableTest : public CommonResourceHashtableTest {
198  protected:
199 
200   template&lt;
201   unsigned (*HASH) (K const&amp;) = primitive_hash&lt;K&gt;,
202   bool (*EQUALS)(K const&amp;, K const&amp;) = primitive_equals&lt;K&gt;,
203   unsigned SIZE = 256,
204   ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA
205   &gt;
206   class Runner : public AllStatic {
207    public:
208 
209     static void test(unsigned num_elements = SIZE) {
210       EqualityTestIter et;
211       ResourceHashtable&lt;K, V, HASH, EQUALS, SIZE, ALLOC_TYPE, MEM_TYPE&gt; rh;
212 
213       for (uintptr_t i = 0; i &lt; num_elements; ++i) {
214         ASSERT_TRUE(rh.put(as_K(i), i));
215       }
216 
217       rh.iterate(&amp;et);
218       if (::testing::Test::HasFailure()) {
219         return;
220       }
221 
222       for (uintptr_t i = num_elements; i &gt; 0; --i) {
223         uintptr_t index = i - 1;
224         ASSERT_TRUE((rh.remove(as_K(index))));
225       }
226 
227       rh.iterate(&amp;et);
228       if (::testing::Test::HasFailure()) {
229         return;
230       }
231       for (uintptr_t i = num_elements; i &gt; 0; --i) {
232         uintptr_t index = i - 1;
233         ASSERT_FALSE(rh.remove(as_K(index)));
234       }
235       rh.iterate(&amp;et);
236     }
237   };
238 };
239 
240 TEST_VM_F(GenericResourceHashtableTest, default) {
241   ResourceMark rm;
242   Runner&lt;&gt;::test();
243 }
244 
245 TEST_VM_F(GenericResourceHashtableTest, bad_hash) {
246   ResourceMark rm;
247   Runner&lt;bad_hash&gt;::test();
248 }
249 
250 TEST_VM_F(GenericResourceHashtableTest, identity_hash) {
251   ResourceMark rm;
252   Runner&lt;identity_hash&gt;::test();
253 }
254 
255 TEST_VM_F(GenericResourceHashtableTest, primitive_hash_no_rm) {
256   Runner&lt;primitive_hash&lt;K&gt;, primitive_equals&lt;K&gt;, 512, ResourceObj::C_HEAP&gt;::test();
257 }
258 
259 TEST_VM_F(GenericResourceHashtableTest, bad_hash_no_rm) {
260   Runner&lt;bad_hash, primitive_equals&lt;K&gt;, 512, ResourceObj::C_HEAP&gt;::test();
261 }
262 
263 TEST_VM_F(GenericResourceHashtableTest, identity_hash_no_rm) {
264   Runner&lt;identity_hash, primitive_equals&lt;K&gt;, 1, ResourceObj::C_HEAP&gt;::test(512);
265 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
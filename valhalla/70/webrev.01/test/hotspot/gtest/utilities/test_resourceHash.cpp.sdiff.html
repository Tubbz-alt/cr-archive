<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/gtest/utilities/test_resourceHash.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/test_markWord.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../jtreg/ProblemList-graal.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/utilities/test_resourceHash.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;memory/allocation.hpp&quot;
 26 #include &quot;memory/resourceArea.hpp&quot;
 27 #include &quot;unittest.hpp&quot;
 28 #include &quot;utilities/debug.hpp&quot;

 29 #include &quot;utilities/resourceHash.hpp&quot;
 30 
 31 class CommonResourceHashtableTest : public ::testing::Test {
 32  protected:
 33   typedef void* K;
<span class="line-modified"> 34   typedef int V;</span>
 35   const static MEMFLAGS MEM_TYPE = mtInternal;
 36 
 37   static unsigned identity_hash(const K&amp; k) {
 38     return (unsigned) (uintptr_t) k;
 39   }
 40 
 41   static unsigned bad_hash(const K&amp; k) {
 42     return 1;
 43   }
 44 
 45   static void* as_K(uintptr_t val) {
 46     return (void*) val;
 47   }
 48 
 49   class EqualityTestIter {
 50    public:
 51 
 52     bool do_entry(K const&amp; k, V const&amp; v) {
 53       if ((uintptr_t) k != (uintptr_t) v) {
 54         EXPECT_EQ((uintptr_t) k, (uintptr_t) v);
 55         return false;
 56       } else {
 57         return true; // continue iteration
 58       }
 59     }
 60   };

 61 };
 62 
 63 class SmallResourceHashtableTest : public CommonResourceHashtableTest {
 64  protected:
 65 
 66   template&lt;
 67   unsigned (*HASH) (K const&amp;) = primitive_hash&lt;K&gt;,
 68   bool (*EQUALS)(K const&amp;, K const&amp;) = primitive_equals&lt;K&gt;,
 69   unsigned SIZE = 256,
 70   ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA
 71   &gt;
 72   class Runner : public AllStatic {
 73    public:
 74 
 75     static void test(V step) {
 76       EqualityTestIter et;
 77       ResourceHashtable&lt;K, V, HASH, EQUALS, SIZE, ALLOC_TYPE, MEM_TYPE&gt; rh;
 78 
 79       ASSERT_FALSE(rh.contains(as_K(step)));
 80 
 81       ASSERT_TRUE(rh.put(as_K(step), step));
 82       ASSERT_TRUE(rh.contains(as_K(step)));
 83 
 84       ASSERT_FALSE(rh.put(as_K(step), step));
 85 
 86       ASSERT_TRUE(rh.put(as_K(2 * step), 2 * step));
 87       ASSERT_TRUE(rh.put(as_K(3 * step), 3 * step));
 88       ASSERT_TRUE(rh.put(as_K(4 * step), 4 * step));
 89       ASSERT_TRUE(rh.put(as_K(5 * step), 5 * step));
 90 
 91       ASSERT_FALSE(rh.remove(as_K(0x0)));
 92 
 93       rh.iterate(&amp;et);
 94       if (::testing::Test::HasFailure()) {
 95         return;
 96       }
 97 
 98       ASSERT_TRUE(rh.remove(as_K(step)));



















 99       rh.iterate(&amp;et);


















100     }
101   };
102 };
103 
104 TEST_VM_F(SmallResourceHashtableTest, default) {
105   ResourceMark rm;
106   Runner&lt;&gt;::test(0x1);
107 }
108 
109 TEST_VM_F(SmallResourceHashtableTest, default_shifted) {
110   ResourceMark rm;
111   Runner&lt;&gt;::test(0x10);
112 }
113 
114 TEST_VM_F(SmallResourceHashtableTest, bad_hash) {
115   ResourceMark rm;
116   Runner&lt;bad_hash&gt;::test(0x1);
117 }
118 
119 TEST_VM_F(SmallResourceHashtableTest, bad_hash_shifted) {
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;memory/allocation.hpp&quot;
 26 #include &quot;memory/resourceArea.hpp&quot;
 27 #include &quot;unittest.hpp&quot;
 28 #include &quot;utilities/debug.hpp&quot;
<span class="line-added"> 29 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 30 #include &quot;utilities/resourceHash.hpp&quot;
 31 
 32 class CommonResourceHashtableTest : public ::testing::Test {
 33  protected:
 34   typedef void* K;
<span class="line-modified"> 35   typedef uintx V;</span>
 36   const static MEMFLAGS MEM_TYPE = mtInternal;
 37 
 38   static unsigned identity_hash(const K&amp; k) {
 39     return (unsigned) (uintptr_t) k;
 40   }
 41 
 42   static unsigned bad_hash(const K&amp; k) {
 43     return 1;
 44   }
 45 
 46   static void* as_K(uintptr_t val) {
 47     return (void*) val;
 48   }
 49 
 50   class EqualityTestIter {
 51    public:
 52 
 53     bool do_entry(K const&amp; k, V const&amp; v) {
 54       if ((uintptr_t) k != (uintptr_t) v) {
 55         EXPECT_EQ((uintptr_t) k, (uintptr_t) v);
 56         return false;
 57       } else {
 58         return true; // continue iteration
 59       }
 60     }
 61   };
<span class="line-added"> 62 </span>
 63 };
 64 
 65 class SmallResourceHashtableTest : public CommonResourceHashtableTest {
 66  protected:
 67 
 68   template&lt;
 69   unsigned (*HASH) (K const&amp;) = primitive_hash&lt;K&gt;,
 70   bool (*EQUALS)(K const&amp;, K const&amp;) = primitive_equals&lt;K&gt;,
 71   unsigned SIZE = 256,
 72   ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA
 73   &gt;
 74   class Runner : public AllStatic {
 75    public:
 76 
 77     static void test(V step) {
 78       EqualityTestIter et;
 79       ResourceHashtable&lt;K, V, HASH, EQUALS, SIZE, ALLOC_TYPE, MEM_TYPE&gt; rh;
 80 
 81       ASSERT_FALSE(rh.contains(as_K(step)));
 82 
 83       ASSERT_TRUE(rh.put(as_K(step), step));
 84       ASSERT_TRUE(rh.contains(as_K(step)));
 85 
 86       ASSERT_FALSE(rh.put(as_K(step), step));
 87 
 88       ASSERT_TRUE(rh.put(as_K(2 * step), 2 * step));
 89       ASSERT_TRUE(rh.put(as_K(3 * step), 3 * step));
 90       ASSERT_TRUE(rh.put(as_K(4 * step), 4 * step));
 91       ASSERT_TRUE(rh.put(as_K(5 * step), 5 * step));
 92 
 93       ASSERT_FALSE(rh.remove(as_K(0x0)));
 94 
 95       rh.iterate(&amp;et);
 96       if (::testing::Test::HasFailure()) {
 97         return;
 98       }
 99 
100       ASSERT_TRUE(rh.remove(as_K(step)));
<span class="line-added">101       ASSERT_FALSE(rh.contains(as_K(step)));</span>
<span class="line-added">102       rh.iterate(&amp;et);</span>
<span class="line-added">103 </span>
<span class="line-added">104 </span>
<span class="line-added">105       // Test put_if_absent(key) (creating a default-created value)</span>
<span class="line-added">106       bool created = false;</span>
<span class="line-added">107       V* v = rh.put_if_absent(as_K(step), &amp;created);</span>
<span class="line-added">108       ASSERT_TRUE(rh.contains(as_K(step)));</span>
<span class="line-added">109       ASSERT_TRUE(created);</span>
<span class="line-added">110       *v = (V)step;</span>
<span class="line-added">111 </span>
<span class="line-added">112       // Calling this function a second time should yield the same value pointer</span>
<span class="line-added">113       V* v2 = rh.put_if_absent(as_K(step), &amp;created);</span>
<span class="line-added">114       ASSERT_EQ(v, v2);</span>
<span class="line-added">115       ASSERT_EQ(*v2, *v);</span>
<span class="line-added">116       ASSERT_FALSE(created);</span>
<span class="line-added">117 </span>
<span class="line-added">118       ASSERT_TRUE(rh.remove(as_K(step)));</span>
<span class="line-added">119       ASSERT_FALSE(rh.contains(as_K(step)));</span>
120       rh.iterate(&amp;et);
<span class="line-added">121 </span>
<span class="line-added">122       // Test put_if_absent(key, value)</span>
<span class="line-added">123       v = rh.put_if_absent(as_K(step), step, &amp;created);</span>
<span class="line-added">124       ASSERT_EQ(*v, step);</span>
<span class="line-added">125       ASSERT_TRUE(rh.contains(as_K(step)));</span>
<span class="line-added">126       ASSERT_TRUE(created);</span>
<span class="line-added">127 </span>
<span class="line-added">128       v2 = rh.put_if_absent(as_K(step), step, &amp;created);</span>
<span class="line-added">129       // Calling this function a second time should yield the same value pointer</span>
<span class="line-added">130       ASSERT_EQ(v, v2);</span>
<span class="line-added">131       ASSERT_EQ(*v2, (V)step);</span>
<span class="line-added">132       ASSERT_FALSE(created);</span>
<span class="line-added">133 </span>
<span class="line-added">134       ASSERT_TRUE(rh.remove(as_K(step)));</span>
<span class="line-added">135       ASSERT_FALSE(rh.contains(as_K(step)));</span>
<span class="line-added">136       rh.iterate(&amp;et);</span>
<span class="line-added">137 </span>
<span class="line-added">138 </span>
139     }
140   };
141 };
142 
143 TEST_VM_F(SmallResourceHashtableTest, default) {
144   ResourceMark rm;
145   Runner&lt;&gt;::test(0x1);
146 }
147 
148 TEST_VM_F(SmallResourceHashtableTest, default_shifted) {
149   ResourceMark rm;
150   Runner&lt;&gt;::test(0x10);
151 }
152 
153 TEST_VM_F(SmallResourceHashtableTest, bad_hash) {
154   ResourceMark rm;
155   Runner&lt;bad_hash&gt;::test(0x1);
156 }
157 
158 TEST_VM_F(SmallResourceHashtableTest, bad_hash_shifted) {
</pre>
</td>
</tr>
</table>
<center><a href="../oops/test_markWord.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../jtreg/ProblemList-graal.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
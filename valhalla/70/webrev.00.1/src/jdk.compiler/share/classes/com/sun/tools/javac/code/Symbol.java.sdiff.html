<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Flags.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Attr.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 397 
 398     public boolean isStatic() {
 399         return
 400             (flags() &amp; STATIC) != 0 ||
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 



























 417     public boolean isPublic() {
 418         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 419     }
 420 
 421     public boolean isEnum() {
 422         return (flags() &amp; ENUM) != 0;
 423     }
 424 
 425     public boolean isFinal() {
 426         return (flags_field &amp; FINAL) != 0;
 427     }
 428 
 429    /** Is this symbol declared (directly or indirectly) local
 430      *  to a method or variable initializer?
 431      *  Also includes fields of inner classes which are in
 432      *  turn local to a method or variable initializer.
 433      */
 434     public boolean isLocal() {
 435         return
 436             (owner.kind.matches(KindSelector.VAL_MTH) ||
 437              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 438     }
 439 
 440     /** Has this symbol an empty name? This includes anonymous
 441      *  inner classes.
 442      */
 443     public boolean isAnonymous() {
 444         return name.isEmpty();
 445     }
 446 
 447     /** Is this symbol a constructor?
 448      */
 449     public boolean isConstructor() {
<span class="line-modified"> 450         return name == name.table.names.init;</span>






 451     }
 452 
 453     public boolean isDynamic() {
 454         return false;
 455     }
 456 
 457     /** The fully qualified name of this symbol.
 458      *  This is the same as the symbol&#39;s name except for class symbols,
 459      *  which are handled separately.
 460      */
 461     public Name getQualifiedName() {
 462         return name;
 463     }
 464 
 465     /** The fully qualified name of this symbol after converting to flat
 466      *  representation. This is the same as the symbol&#39;s name except for
 467      *  class symbols, which are handled separately.
 468      */
 469     public Name flatName() {
 470         return getQualifiedName();
</pre>
<hr />
<pre>
 493     public boolean hasOuterInstance() {
 494         return
 495             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 496     }
 497 
 498     /** The closest enclosing class of this symbol&#39;s declaration.
 499      *  Warning: this (misnamed) method returns the receiver itself
 500      *  when the receiver is a class (as opposed to its enclosing
 501      *  class as one may be misled to believe.)
 502      */
 503     public ClassSymbol enclClass() {
 504         Symbol c = this;
 505         while (c != null &amp;&amp;
 506                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 507             c = c.owner;
 508         }
 509         return (ClassSymbol)c;
 510     }
 511 
 512     /** The outermost class which indirectly owns this symbol.


 513      */
 514     public ClassSymbol outermostClass() {
 515         Symbol sym = this;
 516         Symbol prev = null;
 517         while (sym.kind != PCK) {
 518             prev = sym;
 519             sym = sym.owner;
 520         }
<span class="line-modified"> 521         return (ClassSymbol) prev;</span>
 522     }
 523 
 524     /** The package which indirectly owns this symbol.
 525      */
 526     public PackageSymbol packge() {
 527         Symbol sym = this;
 528         while (sym.kind != PCK) {
 529             sym = sym.owner;
 530         }
 531         return (PackageSymbol) sym;
 532     }
 533 
 534     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 535      */
 536     public boolean isSubClass(Symbol base, Types types) {
 537         throw new AssertionError(&quot;isSubClass &quot; + this);
 538     }
 539 
 540     /** Fully check membership: hierarchy, protection, and hiding.
 541      *  Does not exclude methods not inherited due to overriding.
</pre>
<hr />
<pre>
1268         public JavaFileObject sourcefile;
1269 
1270         /** the classfile from where to load this class
1271          *  this will have extension .class or .java
1272          */
1273         public JavaFileObject classfile;
1274 
1275         /** the list of translated local classes (used for generating
1276          * InnerClasses attribute)
1277          */
1278         public List&lt;ClassSymbol&gt; trans_local;
1279 
1280         /** the annotation metadata attached to this class */
1281         private AnnotationTypeMetadata annotationTypeMetadata;
1282 
1283         /* the list of any of record components, only non empty if the class is a record
1284          * and it has at least one record component
1285          */
1286         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1287 






1288         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1289             super(TYP, flags, name, type, owner);
1290             this.members_field = null;
1291             this.fullname = formFullName(name, owner);
1292             this.flatname = formFlatName(name, owner);
1293             this.sourcefile = null;
1294             this.classfile = null;
1295             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1296         }
1297 
1298         public ClassSymbol(long flags, Name name, Symbol owner) {
1299             this(
1300                 flags,
1301                 name,
1302                 new ClassType(Type.noType, null, null),
1303                 owner);
1304             this.type.tsym = this;
1305         }
1306 
1307         /** The Java source which this symbol represents.
</pre>
<hr />
<pre>
1327         }
1328 
1329         @Override
1330         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1331             complete();
1332             return super.getRawTypeAttributes();
1333         }
1334 
1335         public Type erasure(Types types) {
1336             if (erasure_field == null)
1337                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1338                                               List.nil(), this,
1339                                               type.getMetadata());
1340             return erasure_field;
1341         }
1342 
1343         public String className() {
1344             if (name.isEmpty())
1345                 return
1346                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
<span class="line-modified">1347             else</span>
1348                 return fullname.toString();
1349         }
1350 
1351         @DefinedBy(Api.LANGUAGE_MODEL)
1352         public Name getQualifiedName() {
1353             return fullname;
1354         }
1355 
1356         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1357         public List&lt;Symbol&gt; getEnclosedElements() {
1358             List&lt;Symbol&gt; result = super.getEnclosedElements();
1359             if (!recordComponents.isEmpty()) {
1360                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1361                 for (RecordComponent rc : reversed) {
1362                     result = result.prepend(rc);
1363                 }
1364             }
1365             return result;
1366         }
1367 
</pre>
<hr />
<pre>
1584 
1585         @Override
1586         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1587             return annotationTypeMetadata;
1588         }
1589 
1590         @Override
1591         public boolean isAnnotationType() {
1592             return (flags_field &amp; Flags.ANNOTATION) != 0;
1593         }
1594 
1595         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1596             Assert.checkNonNull(a);
1597             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1598             this.annotationTypeMetadata = a;
1599         }
1600 
1601         public boolean isRecord() {
1602             return (flags_field &amp; RECORD) != 0;
1603         }























































1604     }
1605 
1606 
1607     /** A class for variable symbols
1608      */
1609     public static class VarSymbol extends Symbol implements VariableElement {
1610 
1611         /** The variable&#39;s declaration position.
1612          */
1613         public int pos = Position.NOPOS;
1614 
1615         /** The variable&#39;s address. Used for different purposes during
1616          *  flow analysis, translation and code generation.
1617          *  Flow analysis:
1618          *    If this is a blank final or local variable, its sequence number.
1619          *  Translation:
1620          *    If this is a private field, its access number.
1621          *  Code generation:
1622          *    If this is a local variable, its logical slot number.
1623          */
1624         public int adr = -1;
1625 





1626         /** Construct a variable symbol, given its flags, name, type and owner.
1627          */
1628         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1629             super(VAR, flags, name, type, owner);
1630         }
1631 
1632         @Override
1633         public int poolTag() {
1634             return ClassFile.CONSTANT_Fieldref;
1635         }
1636 
1637         public MethodHandleSymbol asMethodHandle(boolean getter) {
1638             return new MethodHandleSymbol(this, getter);
1639         }
1640 
1641         /** Clone this symbol with new owner.
1642          */
1643         public VarSymbol clone(Symbol newOwner) {
1644             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1645                 @Override
1646                 public Symbol baseSymbol() {
1647                     return VarSymbol.this;
1648                 }
1649 
1650                 @Override
1651                 public Object poolKey(Types types) {
1652                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1653                 }
1654             };
1655             v.pos = pos;
1656             v.adr = adr;
1657             v.data = data;

1658 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1659             return v;
1660         }
1661 
1662         public String toString() {
1663             return name.toString();
1664         }
1665 
1666         public Symbol asMemberOf(Type site, Types types) {
1667             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1668         }
1669 
1670         @DefinedBy(Api.LANGUAGE_MODEL)
1671         public ElementKind getKind() {
1672             long flags = flags();
1673             if ((flags &amp; PARAMETER) != 0) {
1674                 if (isExceptionParameter())
1675                     return ElementKind.EXCEPTION_PARAMETER;
1676                 else
1677                     return ElementKind.PARAMETER;
</pre>
<hr />
<pre>
1690             }
1691         }
1692 
1693         @DefinedBy(Api.LANGUAGE_MODEL)
1694         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1695             return v.visitVariable(this, p);
1696         }
1697 
1698         @DefinedBy(Api.LANGUAGE_MODEL)
1699         public Object getConstantValue() { // Mirror API
1700             return Constants.decode(getConstValue(), type);
1701         }
1702 
1703         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1704                                       final Attr attr,
1705                                       final JCVariableDecl variable)
1706         {
1707             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1708         }
1709 












1710         /**
1711          * The variable&#39;s constant value, if this is a constant.
1712          * Before the constant value is evaluated, it points to an
1713          * initializer environment.  If this is not a constant, it can
1714          * be used for other stuff.
1715          */
1716         private Object data;
1717 
1718         public boolean isExceptionParameter() {
1719             return data == ElementKind.EXCEPTION_PARAMETER;
1720         }
1721 
1722         public boolean isResourceVariable() {
1723             return data == ElementKind.RESOURCE_VARIABLE;
1724         }
1725 
1726         public Object getConstValue() {
1727             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1728             if (data == ElementKind.EXCEPTION_PARAMETER ||
1729                 data == ElementKind.RESOURCE_VARIABLE) {
</pre>
<hr />
<pre>
1851     public static class MethodSymbol extends Symbol implements ExecutableElement {
1852 
1853         /** The code of the method. */
1854         public Code code = null;
1855 
1856         /** The extra (synthetic/mandated) parameters of the method. */
1857         public List&lt;VarSymbol&gt; extraParams = List.nil();
1858 
1859         /** The captured local variables in an anonymous class */
1860         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1861 
1862         /** The parameters of the method. */
1863         public List&lt;VarSymbol&gt; params = null;
1864 
1865         /** For an annotation type element, its default value if any.
1866          *  The value is null if none appeared in the method
1867          *  declaration.
1868          */
1869         public Attribute defaultValue = null;
1870 





1871         /** Construct a method symbol, given its flags, name, type and owner.
1872          */
1873         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1874             super(MTH, flags, name, type, owner);
1875             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1876         }
1877 
1878         /** Clone this symbol with new owner.
1879          */
1880         public MethodSymbol clone(Symbol newOwner) {
1881             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1882                 @Override
1883                 public Symbol baseSymbol() {
1884                     return MethodSymbol.this;
1885                 }
1886 
1887                 @Override
1888                 public Object poolKey(Types types) {
1889                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1890                 }
1891             };
1892             m.code = code;

1893             return m;
1894         }
1895 
1896         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1897         public Set&lt;Modifier&gt; getModifiers() {
1898             long flags = flags();
1899             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
1900         }
1901 
1902         /** The Java source which this symbol represents.
1903          */
1904         public String toString() {
1905             if ((flags() &amp; BLOCK) != 0) {
1906                 return owner.name.toString();
1907             } else {
1908                 String s = (name == name.table.names.init)
1909                     ? owner.name.toString()
1910                     : name.toString();
1911                 if (type != null) {
1912                     if (type.hasTag(FORALL))
</pre>
<hr />
<pre>
2021             return overrides(_other, origin, types, checkResult, true);
2022         }
2023 
2024         /** Does this symbol override `other&#39; symbol, when both are seen as
2025          *  members of class `origin&#39;?  It is assumed that _other is a member
2026          *  of origin.
2027          *
2028          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2029          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2030          *  is false.
2031          *
2032          *  It is assumed that both symbols have the same name.  The static
2033          *  modifier is ignored for this test.
2034          *
2035          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2036          */
2037         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2038                                             boolean requireConcreteIfInherited) {
2039             if (isConstructor() || _other.kind != MTH) return false;
2040 










2041             if (this == _other) return true;
2042             MethodSymbol other = (MethodSymbol)_other;
2043 
2044             // check for a direct implementation
2045             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2046                 types.asSuper(owner.type, other.owner) != null) {
2047                 Type mt = types.memberType(owner.type, this);
2048                 Type ot = types.memberType(owner.type, other);
2049                 if (types.isSubSignature(mt, ot)) {
2050                     if (!checkResult)
2051                         return true;
2052                     if (types.returnTypeSubstitutable(mt, ot))
2053                         return true;
2054                 }
2055             }
2056 
2057             // check for an inherited implementation
2058             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2059                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2060                     !other.isOverridableIn(origin) ||
</pre>
<hr />
<pre>
2075             case Flags.PRIVATE:
2076                 return false;
2077             case Flags.PUBLIC:
2078                 return !this.owner.isInterface() ||
2079                         (flags_field &amp; STATIC) == 0;
2080             case Flags.PROTECTED:
2081                 return (origin.flags() &amp; INTERFACE) == 0;
2082             case 0:
2083                 // for package private: can only override in the same
2084                 // package
2085                 return
2086                     this.packge() == origin.packge() &amp;&amp;
2087                     (origin.flags() &amp; INTERFACE) == 0;
2088             default:
2089                 return false;
2090             }
2091         }
2092 
2093         @Override
2094         public boolean isInheritedIn(Symbol clazz, Types types) {









2095             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2096                 case PUBLIC:
2097                     return !this.owner.isInterface() ||
2098                             clazz == owner ||
2099                             (flags_field &amp; STATIC) == 0;
2100                 default:
2101                     return super.isInheritedIn(clazz, types);
2102             }
2103         }
2104 
2105         public boolean isLambdaMethod() {
2106             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2107         }
2108 












2109         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2110          *  lambda method
2111          */
2112         public MethodSymbol originalEnclosingMethod() {
2113             return this;
2114         }
2115 
2116         /** The implementation of this (abstract) symbol in class origin;
2117          *  null if none exists. Synthetic methods are not considered
2118          *  as possible implementations.
2119          */
2120         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2121             return implementation(origin, types, checkResult, implementation_filter);
2122         }
2123         // where
2124             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2125                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2126 
2127         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2128             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
</pre>
<hr />
<pre>
2382         private int accessCode = Integer.MIN_VALUE;
2383 
2384         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2385             super(PUBLIC | STATIC, name, type, owner);
2386             this.opcode = opcode;
2387         }
2388 
2389         @Override
2390         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2391             return v.visitOperatorSymbol(this, p);
2392         }
2393 
2394         public int getAccessCode(Tag tag) {
2395             if (accessCode != Integer.MIN_VALUE &amp;&amp; !tag.isIncOrDecUnaryOp()) {
2396                 return accessCode;
2397             }
2398             accessCode = AccessCode.from(tag, opcode);
2399             return accessCode;
2400         }
2401 
<span class="line-modified">2402         /** Access codes for dereferencing, assignment,</span>
2403          *  and pre/post increment/decrement.
2404 
2405          *  All access codes for accesses to the current class are even.
2406          *  If a member of the superclass should be accessed instead (because
2407          *  access was via a qualified super), add one to the corresponding code
2408          *  for the current class, making the number odd.
2409          *  This numbering scheme is used by the backend to decide whether
2410          *  to issue an invokevirtual or invokespecial call.
2411          *
2412          *  @see Gen#visitSelect(JCFieldAccess tree)
2413          */
2414         public enum AccessCode {
2415             UNKNOWN(-1, Tag.NO_TAG),
2416             DEREF(0, Tag.NO_TAG),
2417             ASSIGN(2, Tag.ASSIGN),
2418             PREINC(4, Tag.PREINC),
2419             PREDEC(6, Tag.PREDEC),
2420             POSTINC(8, Tag.POSTINC),
2421             POSTDEC(10, Tag.POSTDEC),
<span class="line-modified">2422             FIRSTASGOP(12, Tag.NO_TAG);</span>

2423 
2424             public final int code;
2425             public final Tag tag;
2426             public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;
2427 
2428             AccessCode(int code, Tag tag) {
2429                 this.code = code;
2430                 this.tag = tag;
2431             }
2432 
2433             static public AccessCode getFromCode(int code) {
2434                 for (AccessCode aCodes : AccessCode.values()) {
2435                     if (aCodes.code == code) {
2436                         return aCodes;
2437                     }
2438                 }
2439                 return UNKNOWN;
2440             }
2441 
2442             static int from(Tag tag, int opcode) {
2443                 /** Map bytecode of binary operation to access code of corresponding
2444                 *  assignment operation. This is always an even number.
2445                 */
2446                 switch (tag) {
2447                     case PREINC:
2448                         return AccessCode.PREINC.code;
2449                     case PREDEC:
2450                         return AccessCode.PREDEC.code;
2451                     case POSTINC:
2452                         return AccessCode.POSTINC.code;
2453                     case POSTDEC:
2454                         return AccessCode.POSTDEC.code;


2455                 }
2456                 if (iadd &lt;= opcode &amp;&amp; opcode &lt;= lxor) {
2457                     return (opcode - iadd) * 2 + FIRSTASGOP.code;
2458                 } else if (opcode == string_add) {
2459                     return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;
2460                 } else if (ishll &lt;= opcode &amp;&amp; opcode &lt;= lushrl) {
2461                     return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;
2462                 }
2463                 return -1;
2464             }
2465         }
2466     }
2467 
2468     /** Symbol completer interface.
2469      */
2470     public static interface Completer {
2471 
2472         /** Dummy completer to be used when the symbol has been completed or
2473          * does not need completion.
2474          */
</pre>
</td>
<td>
<hr />
<pre>
 397 
 398     public boolean isStatic() {
 399         return
 400             (flags() &amp; STATIC) != 0 ||
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
<span class="line-added"> 417     public boolean isValue() {</span>
<span class="line-added"> 418         return (flags() &amp; VALUE) != 0;</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420 </span>
<span class="line-added"> 421     /**</span>
<span class="line-added"> 422      * Is this a *derived* reference projection symbol ??</span>
<span class="line-added"> 423      */</span>
<span class="line-added"> 424     public boolean isReferenceProjection() {</span>
<span class="line-added"> 425         return false;</span>
<span class="line-added"> 426     }</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428     /**</span>
<span class="line-added"> 429      * Return the value projection IFF &#39;this&#39; happens to be derived reference projection, null</span>
<span class="line-added"> 430      * otherwise.</span>
<span class="line-added"> 431      */</span>
<span class="line-added"> 432     public Symbol valueProjection() {</span>
<span class="line-added"> 433         return null;</span>
<span class="line-added"> 434     }</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436     /**</span>
<span class="line-added"> 437      * Return the reference projection IFF &#39;this&#39; happens to be value projection, null</span>
<span class="line-added"> 438      * otherwise.</span>
<span class="line-added"> 439      */</span>
<span class="line-added"> 440     public Symbol referenceProjection() {</span>
<span class="line-added"> 441         return null;</span>
<span class="line-added"> 442     }</span>
<span class="line-added"> 443 </span>
 444     public boolean isPublic() {
 445         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 446     }
 447 
 448     public boolean isEnum() {
 449         return (flags() &amp; ENUM) != 0;
 450     }
 451 
 452     public boolean isFinal() {
 453         return (flags_field &amp; FINAL) != 0;
 454     }
 455 
 456    /** Is this symbol declared (directly or indirectly) local
 457      *  to a method or variable initializer?
 458      *  Also includes fields of inner classes which are in
 459      *  turn local to a method or variable initializer.
 460      */
 461     public boolean isLocal() {
 462         return
 463             (owner.kind.matches(KindSelector.VAL_MTH) ||
 464              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 465     }
 466 
 467     /** Has this symbol an empty name? This includes anonymous
 468      *  inner classes.
 469      */
 470     public boolean isAnonymous() {
 471         return name.isEmpty();
 472     }
 473 
 474     /** Is this symbol a constructor?
 475      */
 476     public boolean isConstructor() {
<span class="line-modified"> 477         return name == name.table.names.init &amp;&amp; (flags() &amp; STATIC) == 0;</span>
<span class="line-added"> 478     }</span>
<span class="line-added"> 479 </span>
<span class="line-added"> 480     /** Is this symbol a value factory?</span>
<span class="line-added"> 481      */</span>
<span class="line-added"> 482     public boolean isValueFactory() {</span>
<span class="line-added"> 483         return ((name == name.table.names.init &amp;&amp; this.type.getReturnType().tsym == this.owner));</span>
 484     }
 485 
 486     public boolean isDynamic() {
 487         return false;
 488     }
 489 
 490     /** The fully qualified name of this symbol.
 491      *  This is the same as the symbol&#39;s name except for class symbols,
 492      *  which are handled separately.
 493      */
 494     public Name getQualifiedName() {
 495         return name;
 496     }
 497 
 498     /** The fully qualified name of this symbol after converting to flat
 499      *  representation. This is the same as the symbol&#39;s name except for
 500      *  class symbols, which are handled separately.
 501      */
 502     public Name flatName() {
 503         return getQualifiedName();
</pre>
<hr />
<pre>
 526     public boolean hasOuterInstance() {
 527         return
 528             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 529     }
 530 
 531     /** The closest enclosing class of this symbol&#39;s declaration.
 532      *  Warning: this (misnamed) method returns the receiver itself
 533      *  when the receiver is a class (as opposed to its enclosing
 534      *  class as one may be misled to believe.)
 535      */
 536     public ClassSymbol enclClass() {
 537         Symbol c = this;
 538         while (c != null &amp;&amp;
 539                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 540             c = c.owner;
 541         }
 542         return (ClassSymbol)c;
 543     }
 544 
 545     /** The outermost class which indirectly owns this symbol.
<span class="line-added"> 546      * &#39;outermost&#39; being a lexical construct, should transcend</span>
<span class="line-added"> 547      *  projections</span>
 548      */
 549     public ClassSymbol outermostClass() {
 550         Symbol sym = this;
 551         Symbol prev = null;
 552         while (sym.kind != PCK) {
 553             prev = sym;
 554             sym = sym.owner;
 555         }
<span class="line-modified"> 556         return (ClassSymbol) (prev!= null &amp;&amp; prev.isReferenceProjection() ? prev.valueProjection() : prev);</span>
 557     }
 558 
 559     /** The package which indirectly owns this symbol.
 560      */
 561     public PackageSymbol packge() {
 562         Symbol sym = this;
 563         while (sym.kind != PCK) {
 564             sym = sym.owner;
 565         }
 566         return (PackageSymbol) sym;
 567     }
 568 
 569     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 570      */
 571     public boolean isSubClass(Symbol base, Types types) {
 572         throw new AssertionError(&quot;isSubClass &quot; + this);
 573     }
 574 
 575     /** Fully check membership: hierarchy, protection, and hiding.
 576      *  Does not exclude methods not inherited due to overriding.
</pre>
<hr />
<pre>
1303         public JavaFileObject sourcefile;
1304 
1305         /** the classfile from where to load this class
1306          *  this will have extension .class or .java
1307          */
1308         public JavaFileObject classfile;
1309 
1310         /** the list of translated local classes (used for generating
1311          * InnerClasses attribute)
1312          */
1313         public List&lt;ClassSymbol&gt; trans_local;
1314 
1315         /** the annotation metadata attached to this class */
1316         private AnnotationTypeMetadata annotationTypeMetadata;
1317 
1318         /* the list of any of record components, only non empty if the class is a record
1319          * and it has at least one record component
1320          */
1321         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1322 
<span class="line-added">1323         /* the &#39;other&#39; projection: If &#39;this&#39; is an inline class then &#39;projection&#39; is its reference projection</span>
<span class="line-added">1324            and vice versa.</span>
<span class="line-added">1325          */</span>
<span class="line-added">1326         public ClassSymbol projection;</span>
<span class="line-added">1327 </span>
<span class="line-added">1328 </span>
1329         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1330             super(TYP, flags, name, type, owner);
1331             this.members_field = null;
1332             this.fullname = formFullName(name, owner);
1333             this.flatname = formFlatName(name, owner);
1334             this.sourcefile = null;
1335             this.classfile = null;
1336             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1337         }
1338 
1339         public ClassSymbol(long flags, Name name, Symbol owner) {
1340             this(
1341                 flags,
1342                 name,
1343                 new ClassType(Type.noType, null, null),
1344                 owner);
1345             this.type.tsym = this;
1346         }
1347 
1348         /** The Java source which this symbol represents.
</pre>
<hr />
<pre>
1368         }
1369 
1370         @Override
1371         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1372             complete();
1373             return super.getRawTypeAttributes();
1374         }
1375 
1376         public Type erasure(Types types) {
1377             if (erasure_field == null)
1378                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1379                                               List.nil(), this,
1380                                               type.getMetadata());
1381             return erasure_field;
1382         }
1383 
1384         public String className() {
1385             if (name.isEmpty())
1386                 return
1387                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
<span class="line-modified">1388 </span>
1389                 return fullname.toString();
1390         }
1391 
1392         @DefinedBy(Api.LANGUAGE_MODEL)
1393         public Name getQualifiedName() {
1394             return fullname;
1395         }
1396 
1397         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1398         public List&lt;Symbol&gt; getEnclosedElements() {
1399             List&lt;Symbol&gt; result = super.getEnclosedElements();
1400             if (!recordComponents.isEmpty()) {
1401                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1402                 for (RecordComponent rc : reversed) {
1403                     result = result.prepend(rc);
1404                 }
1405             }
1406             return result;
1407         }
1408 
</pre>
<hr />
<pre>
1625 
1626         @Override
1627         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1628             return annotationTypeMetadata;
1629         }
1630 
1631         @Override
1632         public boolean isAnnotationType() {
1633             return (flags_field &amp; Flags.ANNOTATION) != 0;
1634         }
1635 
1636         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1637             Assert.checkNonNull(a);
1638             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1639             this.annotationTypeMetadata = a;
1640         }
1641 
1642         public boolean isRecord() {
1643             return (flags_field &amp; RECORD) != 0;
1644         }
<span class="line-added">1645 </span>
<span class="line-added">1646         @Override</span>
<span class="line-added">1647         public boolean isReferenceProjection() {</span>
<span class="line-added">1648             return projection != null &amp;&amp; projection.isValue();</span>
<span class="line-added">1649         }</span>
<span class="line-added">1650 </span>
<span class="line-added">1651         @Override</span>
<span class="line-added">1652         public ClassSymbol valueProjection() {</span>
<span class="line-added">1653             return isReferenceProjection() ? projection : null;</span>
<span class="line-added">1654         }</span>
<span class="line-added">1655 </span>
<span class="line-added">1656         @Override</span>
<span class="line-added">1657         public ClassSymbol referenceProjection() {</span>
<span class="line-added">1658             if (!isValue() || projection != null)</span>
<span class="line-added">1659                 return projection;</span>
<span class="line-added">1660 </span>
<span class="line-added">1661             ClassType ct = (ClassType) this.type;</span>
<span class="line-added">1662             ClassType projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);</span>
<span class="line-added">1663             projectedType.allparams_field = ct.allparams_field;</span>
<span class="line-added">1664             projectedType.supertype_field = ct.supertype_field;</span>
<span class="line-added">1665 </span>
<span class="line-added">1666             projectedType.interfaces_field = ct.interfaces_field;</span>
<span class="line-added">1667             projectedType.all_interfaces_field = ct.all_interfaces_field;</span>
<span class="line-added">1668             projectedType.projection = ct;</span>
<span class="line-added">1669             ct.projection = projectedType;</span>
<span class="line-added">1670 </span>
<span class="line-added">1671             Name projectionName = this.name.append(&#39;$&#39;, this.name.table.names.ref);</span>
<span class="line-added">1672             long projectionFlags = (this.flags() &amp; ~(VALUE | UNATTRIBUTED));</span>
<span class="line-added">1673 </span>
<span class="line-added">1674             projection = new ClassSymbol(projectionFlags, projectionName, projectedType, this.owner);</span>
<span class="line-added">1675             projection.members_field = WriteableScope.create(projection);</span>
<span class="line-added">1676             for (Symbol s : this.members().getSymbols(s-&gt;(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {</span>
<span class="line-added">1677                 Symbol clone = null;</span>
<span class="line-added">1678                 if (s.kind == MTH) {</span>
<span class="line-added">1679                     MethodSymbol valMethod = (MethodSymbol)s;</span>
<span class="line-added">1680                     MethodSymbol refMethod = valMethod.clone(projection);</span>
<span class="line-added">1681                     valMethod.projection = refMethod;</span>
<span class="line-added">1682                     refMethod.projection = valMethod;</span>
<span class="line-added">1683                     clone = refMethod;</span>
<span class="line-added">1684                 } else if (s.kind == VAR) {</span>
<span class="line-added">1685                     VarSymbol valVar = (VarSymbol)s;</span>
<span class="line-added">1686                     VarSymbol refVar = valVar.clone(projection);</span>
<span class="line-added">1687                     valVar.projection = refVar;</span>
<span class="line-added">1688                     refVar.projection = valVar;</span>
<span class="line-added">1689                     clone = refVar;</span>
<span class="line-added">1690                 }</span>
<span class="line-added">1691                 projection.members_field.enter(clone);</span>
<span class="line-added">1692             }</span>
<span class="line-added">1693             projection.completer = Completer.NULL_COMPLETER;</span>
<span class="line-added">1694             projection.sourcefile = this.sourcefile;</span>
<span class="line-added">1695             projection.flatname = this.flatname.append(&#39;$&#39;, this.name.table.names.ref);</span>
<span class="line-added">1696             projection.projection = this;</span>
<span class="line-added">1697             projectedType.tsym = projection;</span>
<span class="line-added">1698             return projection;</span>
<span class="line-added">1699         }</span>
1700     }
1701 
1702 
1703     /** A class for variable symbols
1704      */
1705     public static class VarSymbol extends Symbol implements VariableElement {
1706 
1707         /** The variable&#39;s declaration position.
1708          */
1709         public int pos = Position.NOPOS;
1710 
1711         /** The variable&#39;s address. Used for different purposes during
1712          *  flow analysis, translation and code generation.
1713          *  Flow analysis:
1714          *    If this is a blank final or local variable, its sequence number.
1715          *  Translation:
1716          *    If this is a private field, its access number.
1717          *  Code generation:
1718          *    If this is a local variable, its logical slot number.
1719          */
1720         public int adr = -1;
1721 
<span class="line-added">1722         /* The &#39;other&#39; projection: If &#39;this&#39; is a field of an inline class, then &#39;projection&#39; is the</span>
<span class="line-added">1723            its doppleganger in its referene projection class and vice versa.</span>
<span class="line-added">1724         */</span>
<span class="line-added">1725         public VarSymbol projection;</span>
<span class="line-added">1726 </span>
1727         /** Construct a variable symbol, given its flags, name, type and owner.
1728          */
1729         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1730             super(VAR, flags, name, type, owner);
1731         }
1732 
1733         @Override
1734         public int poolTag() {
1735             return ClassFile.CONSTANT_Fieldref;
1736         }
1737 
1738         public MethodHandleSymbol asMethodHandle(boolean getter) {
1739             return new MethodHandleSymbol(this, getter);
1740         }
1741 
1742         /** Clone this symbol with new owner.
1743          */
1744         public VarSymbol clone(Symbol newOwner) {
1745             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1746                 @Override
1747                 public Symbol baseSymbol() {
1748                     return VarSymbol.this;
1749                 }
1750 
1751                 @Override
1752                 public Object poolKey(Types types) {
1753                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1754                 }
1755             };
1756             v.pos = pos;
1757             v.adr = adr;
1758             v.data = data;
<span class="line-added">1759             v.projection = projection;</span>
1760 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1761             return v;
1762         }
1763 
1764         public String toString() {
1765             return name.toString();
1766         }
1767 
1768         public Symbol asMemberOf(Type site, Types types) {
1769             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1770         }
1771 
1772         @DefinedBy(Api.LANGUAGE_MODEL)
1773         public ElementKind getKind() {
1774             long flags = flags();
1775             if ((flags &amp; PARAMETER) != 0) {
1776                 if (isExceptionParameter())
1777                     return ElementKind.EXCEPTION_PARAMETER;
1778                 else
1779                     return ElementKind.PARAMETER;
</pre>
<hr />
<pre>
1792             }
1793         }
1794 
1795         @DefinedBy(Api.LANGUAGE_MODEL)
1796         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1797             return v.visitVariable(this, p);
1798         }
1799 
1800         @DefinedBy(Api.LANGUAGE_MODEL)
1801         public Object getConstantValue() { // Mirror API
1802             return Constants.decode(getConstValue(), type);
1803         }
1804 
1805         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1806                                       final Attr attr,
1807                                       final JCVariableDecl variable)
1808         {
1809             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1810         }
1811 
<span class="line-added">1812         @Override</span>
<span class="line-added">1813         public VarSymbol referenceProjection() {</span>
<span class="line-added">1814             return this.owner.isValue() ?</span>
<span class="line-added">1815                     this.owner.referenceProjection() != null ? projection : null</span>
<span class="line-added">1816                                : null;</span>
<span class="line-added">1817         }</span>
<span class="line-added">1818 </span>
<span class="line-added">1819         @Override</span>
<span class="line-added">1820         public VarSymbol valueProjection() {</span>
<span class="line-added">1821             return  projection != null ? projection.owner.isValue() ? projection : null: null;</span>
<span class="line-added">1822         }</span>
<span class="line-added">1823 </span>
1824         /**
1825          * The variable&#39;s constant value, if this is a constant.
1826          * Before the constant value is evaluated, it points to an
1827          * initializer environment.  If this is not a constant, it can
1828          * be used for other stuff.
1829          */
1830         private Object data;
1831 
1832         public boolean isExceptionParameter() {
1833             return data == ElementKind.EXCEPTION_PARAMETER;
1834         }
1835 
1836         public boolean isResourceVariable() {
1837             return data == ElementKind.RESOURCE_VARIABLE;
1838         }
1839 
1840         public Object getConstValue() {
1841             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1842             if (data == ElementKind.EXCEPTION_PARAMETER ||
1843                 data == ElementKind.RESOURCE_VARIABLE) {
</pre>
<hr />
<pre>
1965     public static class MethodSymbol extends Symbol implements ExecutableElement {
1966 
1967         /** The code of the method. */
1968         public Code code = null;
1969 
1970         /** The extra (synthetic/mandated) parameters of the method. */
1971         public List&lt;VarSymbol&gt; extraParams = List.nil();
1972 
1973         /** The captured local variables in an anonymous class */
1974         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1975 
1976         /** The parameters of the method. */
1977         public List&lt;VarSymbol&gt; params = null;
1978 
1979         /** For an annotation type element, its default value if any.
1980          *  The value is null if none appeared in the method
1981          *  declaration.
1982          */
1983         public Attribute defaultValue = null;
1984 
<span class="line-added">1985         /* The &#39;other&#39; projection: If &#39;this&#39; is a method of an inline class, then &#39;projection&#39; is the</span>
<span class="line-added">1986            its doppleganger in its referene projection class and vice versa.</span>
<span class="line-added">1987         */</span>
<span class="line-added">1988         public MethodSymbol projection;</span>
<span class="line-added">1989 </span>
1990         /** Construct a method symbol, given its flags, name, type and owner.
1991          */
1992         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1993             super(MTH, flags, name, type, owner);
1994             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1995         }
1996 
1997         /** Clone this symbol with new owner.
1998          */
1999         public MethodSymbol clone(Symbol newOwner) {
2000             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
2001                 @Override
2002                 public Symbol baseSymbol() {
2003                     return MethodSymbol.this;
2004                 }
2005 
2006                 @Override
2007                 public Object poolKey(Types types) {
2008                     return new Pair&lt;&gt;(newOwner, baseSymbol());
2009                 }
2010             };
2011             m.code = code;
<span class="line-added">2012             m.projection = projection;</span>
2013             return m;
2014         }
2015 
2016         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2017         public Set&lt;Modifier&gt; getModifiers() {
2018             long flags = flags();
2019             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
2020         }
2021 
2022         /** The Java source which this symbol represents.
2023          */
2024         public String toString() {
2025             if ((flags() &amp; BLOCK) != 0) {
2026                 return owner.name.toString();
2027             } else {
2028                 String s = (name == name.table.names.init)
2029                     ? owner.name.toString()
2030                     : name.toString();
2031                 if (type != null) {
2032                     if (type.hasTag(FORALL))
</pre>
<hr />
<pre>
2141             return overrides(_other, origin, types, checkResult, true);
2142         }
2143 
2144         /** Does this symbol override `other&#39; symbol, when both are seen as
2145          *  members of class `origin&#39;?  It is assumed that _other is a member
2146          *  of origin.
2147          *
2148          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2149          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2150          *  is false.
2151          *
2152          *  It is assumed that both symbols have the same name.  The static
2153          *  modifier is ignored for this test.
2154          *
2155          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2156          */
2157         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2158                                             boolean requireConcreteIfInherited) {
2159             if (isConstructor() || _other.kind != MTH) return false;
2160 
<span class="line-added">2161 </span>
<span class="line-added">2162             /* If any inline types are involved, ask the same question in the reference universe,</span>
<span class="line-added">2163                where the hierarchy is navigable</span>
<span class="line-added">2164             */</span>
<span class="line-added">2165             if (origin.isValue())</span>
<span class="line-added">2166                 origin = (TypeSymbol) origin.referenceProjection();</span>
<span class="line-added">2167 </span>
<span class="line-added">2168             if (this.owner.isValue())</span>
<span class="line-added">2169                 return this.projection.overrides(_other, origin, types, checkResult, requireConcreteIfInherited);</span>
<span class="line-added">2170 </span>
2171             if (this == _other) return true;
2172             MethodSymbol other = (MethodSymbol)_other;
2173 
2174             // check for a direct implementation
2175             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2176                 types.asSuper(owner.type, other.owner) != null) {
2177                 Type mt = types.memberType(owner.type, this);
2178                 Type ot = types.memberType(owner.type, other);
2179                 if (types.isSubSignature(mt, ot)) {
2180                     if (!checkResult)
2181                         return true;
2182                     if (types.returnTypeSubstitutable(mt, ot))
2183                         return true;
2184                 }
2185             }
2186 
2187             // check for an inherited implementation
2188             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2189                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2190                     !other.isOverridableIn(origin) ||
</pre>
<hr />
<pre>
2205             case Flags.PRIVATE:
2206                 return false;
2207             case Flags.PUBLIC:
2208                 return !this.owner.isInterface() ||
2209                         (flags_field &amp; STATIC) == 0;
2210             case Flags.PROTECTED:
2211                 return (origin.flags() &amp; INTERFACE) == 0;
2212             case 0:
2213                 // for package private: can only override in the same
2214                 // package
2215                 return
2216                     this.packge() == origin.packge() &amp;&amp;
2217                     (origin.flags() &amp; INTERFACE) == 0;
2218             default:
2219                 return false;
2220             }
2221         }
2222 
2223         @Override
2224         public boolean isInheritedIn(Symbol clazz, Types types) {
<span class="line-added">2225 </span>
<span class="line-added">2226             /* If any inline types are involved, ask the same question in the reference universe,</span>
<span class="line-added">2227                where the hierarchy is navigable</span>
<span class="line-added">2228             */</span>
<span class="line-added">2229             if (clazz.isValue())</span>
<span class="line-added">2230                 clazz = clazz.referenceProjection();</span>
<span class="line-added">2231             if (this.owner.isValue())</span>
<span class="line-added">2232                 return this.projection.isInheritedIn(clazz, types);</span>
<span class="line-added">2233 </span>
2234             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2235                 case PUBLIC:
2236                     return !this.owner.isInterface() ||
2237                             clazz == owner ||
2238                             (flags_field &amp; STATIC) == 0;
2239                 default:
2240                     return super.isInheritedIn(clazz, types);
2241             }
2242         }
2243 
2244         public boolean isLambdaMethod() {
2245             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2246         }
2247 
<span class="line-added">2248         @Override</span>
<span class="line-added">2249         public MethodSymbol referenceProjection() {</span>
<span class="line-added">2250             return this.owner.isValue() ?</span>
<span class="line-added">2251                     this.owner.referenceProjection() != null ? projection : null</span>
<span class="line-added">2252                     : null;</span>
<span class="line-added">2253         }</span>
<span class="line-added">2254 </span>
<span class="line-added">2255         @Override</span>
<span class="line-added">2256         public MethodSymbol valueProjection() {</span>
<span class="line-added">2257             return  projection != null ? projection.owner.isValue() ? projection : null : null;</span>
<span class="line-added">2258         }</span>
<span class="line-added">2259 </span>
2260         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2261          *  lambda method
2262          */
2263         public MethodSymbol originalEnclosingMethod() {
2264             return this;
2265         }
2266 
2267         /** The implementation of this (abstract) symbol in class origin;
2268          *  null if none exists. Synthetic methods are not considered
2269          *  as possible implementations.
2270          */
2271         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2272             return implementation(origin, types, checkResult, implementation_filter);
2273         }
2274         // where
2275             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2276                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2277 
2278         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2279             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
</pre>
<hr />
<pre>
2533         private int accessCode = Integer.MIN_VALUE;
2534 
2535         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2536             super(PUBLIC | STATIC, name, type, owner);
2537             this.opcode = opcode;
2538         }
2539 
2540         @Override
2541         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2542             return v.visitOperatorSymbol(this, p);
2543         }
2544 
2545         public int getAccessCode(Tag tag) {
2546             if (accessCode != Integer.MIN_VALUE &amp;&amp; !tag.isIncOrDecUnaryOp()) {
2547                 return accessCode;
2548             }
2549             accessCode = AccessCode.from(tag, opcode);
2550             return accessCode;
2551         }
2552 
<span class="line-modified">2553         /** Access codes for dereferencing, assignment, withfield</span>
2554          *  and pre/post increment/decrement.
2555 
2556          *  All access codes for accesses to the current class are even.
2557          *  If a member of the superclass should be accessed instead (because
2558          *  access was via a qualified super), add one to the corresponding code
2559          *  for the current class, making the number odd.
2560          *  This numbering scheme is used by the backend to decide whether
2561          *  to issue an invokevirtual or invokespecial call.
2562          *
2563          *  @see Gen#visitSelect(JCFieldAccess tree)
2564          */
2565         public enum AccessCode {
2566             UNKNOWN(-1, Tag.NO_TAG),
2567             DEREF(0, Tag.NO_TAG),
2568             ASSIGN(2, Tag.ASSIGN),
2569             PREINC(4, Tag.PREINC),
2570             PREDEC(6, Tag.PREDEC),
2571             POSTINC(8, Tag.POSTINC),
2572             POSTDEC(10, Tag.POSTDEC),
<span class="line-modified">2573             WITHFIELD(12, Tag.WITHFIELD),</span>
<span class="line-added">2574             FIRSTASGOP(14, Tag.NO_TAG);</span>
2575 
2576             public final int code;
2577             public final Tag tag;
2578             public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;
2579 
2580             AccessCode(int code, Tag tag) {
2581                 this.code = code;
2582                 this.tag = tag;
2583             }
2584 
2585             static public AccessCode getFromCode(int code) {
2586                 for (AccessCode aCodes : AccessCode.values()) {
2587                     if (aCodes.code == code) {
2588                         return aCodes;
2589                     }
2590                 }
2591                 return UNKNOWN;
2592             }
2593 
2594             static int from(Tag tag, int opcode) {
2595                 /** Map bytecode of binary operation to access code of corresponding
2596                 *  assignment operation. This is always an even number.
2597                 */
2598                 switch (tag) {
2599                     case PREINC:
2600                         return AccessCode.PREINC.code;
2601                     case PREDEC:
2602                         return AccessCode.PREDEC.code;
2603                     case POSTINC:
2604                         return AccessCode.POSTINC.code;
2605                     case POSTDEC:
2606                         return AccessCode.POSTDEC.code;
<span class="line-added">2607                     case WITHFIELD:</span>
<span class="line-added">2608                         return AccessCode.WITHFIELD.code;</span>
2609                 }
2610                 if (iadd &lt;= opcode &amp;&amp; opcode &lt;= lxor) {
2611                     return (opcode - iadd) * 2 + FIRSTASGOP.code;
2612                 } else if (opcode == string_add) {
2613                     return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;
2614                 } else if (ishll &lt;= opcode &amp;&amp; opcode &lt;= lushrl) {
2615                     return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;
2616                 }
2617                 return -1;
2618             }
2619         }
2620     }
2621 
2622     /** Symbol completer interface.
2623      */
2624     public static interface Completer {
2625 
2626         /** Dummy completer to be used when the symbol has been completed or
2627          * does not need completion.
2628          */
</pre>
</td>
</tr>
</table>
<center><a href="Flags.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Attr.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 
  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
  59 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  60 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  61 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  62 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  63 
  64 /** The parser maps a token sequence into an abstract syntax
  65  *  tree. It operates by recursive descent, with code derived
  66  *  systematically from an LL(1) grammar. For efficiency reasons, an
  67  *  operator precedence scheme is used for parsing binary operation
  68  *  expressions.
  69  *
  70  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  71  *  If you write code that depends on this, you do so at your own risk.
  72  *  This code and its internal interfaces are subject to change or
  73  *  deletion without notice.&lt;/b&gt;
  74  */
  75 public class JavacParser implements Parser {
  76 
  77     /** The number of precedence levels of infix operators.
  78      */
  79     private static final int infixPrecedenceLevels = 10;
  80 
  81     /** Is the parser instantiated to parse a module-info file ?
  82      */
  83     private final boolean parseModuleInfo;
  84 
  85     /** The scanner used for lexical analysis.
  86      */
  87     protected Lexer S;
  88 
  89     /** The factory to be used for abstract syntax tree construction.
  90      */
  91     protected TreeMaker F;
  92 
  93     /** The log to be used for error diagnostics.
  94      */
  95     private Log log;
  96 
  97     /** The Source language setting. */
  98     private Source source;
  99 
 100     /** The Preview language setting. */
 101     private Preview preview;
 102 
 103     /** The name table. */
 104     private Names names;
 105 
 106     /** End position mappings container */
 107     protected final AbstractEndPosTable endPosTable;
 108 
 109     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 110     // the presence of type annotations even though they are not ambiguous
 111     // in the absence of type annotations.  Consider this code:
 112     //   void m(String [] m) { }
 113     //   void m(String ... m) { }
 114     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 115     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 116     // if the next token is ... and in that case parse an ellipsis.  But in
 117     // the presence of type annotations:
 118     //   void m(String @A [] m) { }
 119     //   void m(String @A ... m) { }
 120     // no finite lookahead is enough to determine whether to read array
 121     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 122     // bracketsOpt first reads all the leading annotations and only then
 123     // discovers that it needs to fail.  bracketsOpt needs a way to push
 124     // back the extra annotations that it read.  (But, bracketsOpt should
 125     // not *always* be allowed to push back extra annotations that it finds
 126     // -- in most contexts, any such extra annotation is an error.
 127     //
 128     // The following two variables permit type annotations that have
 129     // already been read to be stored for later use.  Alternate
 130     // implementations are possible but would cause much larger changes to
 131     // the parser.
 132 
 133     /** Type annotations that have already been read but have not yet been used. **/
 134     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 135 
 136     /**
 137      * If the parser notices extra annotations, then it either immediately
 138      * issues an error (if this variable is false) or places the extra
 139      * annotations in variable typeAnnotationsPushedBack (if this variable
 140      * is true).
 141      */
 142     private boolean permitTypeAnnotationsPushBack = false;
 143 
 144     interface ErrorRecoveryAction {
 145         JCTree doRecover(JavacParser parser);
 146     }
 147 
 148     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 149         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 150         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 151     }
 152 
 153     /** Construct a parser from a given scanner, tree factory and log.
 154      */
 155     protected JavacParser(ParserFactory fac,
 156                           Lexer S,
 157                           boolean keepDocComments,
 158                           boolean keepLineMap,
 159                           boolean keepEndPositions) {
 160         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 161 
 162     }
 163     /** Construct a parser from a given scanner, tree factory and log.
 164      */
 165     protected JavacParser(ParserFactory fac,
 166                      Lexer S,
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);
 189     }
 190 
 191     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 192         return  keepEndPositions
 193                 ? new SimpleEndPosTable(this)
 194                 : new EmptyEndPosTable(this);
 195     }
 196 
 197     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 198         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 199     }
 200 
 201     /** Switch: should we fold strings?
 202      */
 203     boolean allowStringFolding;
 204 
 205     /** Switch: should we keep docComments?
 206      */
 207     boolean keepDocComments;
 208 
 209     /** Switch: should we keep line table?
 210      */
 211     boolean keepLineMap;
 212 
 213     /** Switch: is &quot;this&quot; allowed as an identifier?
 214      * This is needed to parse receiver types.
 215      */
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
 225 
 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed
 236      */
 237     protected static final int EXPR = 0x1;
 238     protected static final int TYPE = 0x2;
 239     protected static final int NOPARAMS = 0x4;
 240     protected static final int TYPEARG = 0x8;
 241     protected static final int DIAMOND = 0x10;
 242     protected static final int NOLAMBDA = 0x20;
 243 
 244     protected void selectExprMode() {
 245         mode = (mode &amp; NOLAMBDA) | EXPR;
 246     }
 247 
 248     protected void selectTypeMode() {
 249         mode = (mode &amp; NOLAMBDA) | TYPE;
 250     }
 251 
 252     /** The current mode.
 253      */
 254     protected int mode = 0;
 255 
 256     /** The mode of the term that was parsed last.
 257      */
 258     protected int lastmode = 0;
 259 
 260     /* ---------- token management -------------- */
 261 
 262     protected Token token;
 263 
 264     public Token token() {
 265         return token;
 266     }
 267 
 268     public void nextToken() {
 269         S.nextToken();
 270         token = S.token();
 271     }
 272 
 273     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 274         return peekToken(0, tk);
 275     }
 276 
 277     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 278         return tk.accepts(S.token(lookahead + 1).kind);
 279     }
 280 
 281     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 282         return peekToken(0, tk1, tk2);
 283     }
 284 
 285     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 286         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 287                 tk2.accepts(S.token(lookahead + 2).kind);
 288     }
 289 
 290     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 291         return peekToken(0, tk1, tk2, tk3);
 292     }
 293 
 294     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 295         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 296                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 297                 tk3.accepts(S.token(lookahead + 3).kind);
 298     }
 299 
 300     @SuppressWarnings(&quot;unchecked&quot;)
 301     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 302         return peekToken(0, kinds);
 303     }
 304 
 305     @SuppressWarnings(&quot;unchecked&quot;)
 306     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 307         for (; lookahead &lt; kinds.length ; lookahead++) {
 308             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 309                 return false;
 310             }
 311         }
 312         return true;
 313     }
 314 
 315     /* ---------- error recovery -------------- */
 316 
 317     private JCErroneous errorTree;
 318 
 319     /** Skip forward until a suitable stop token is found.
 320      */
 321     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 322          while (true) {
 323              switch (token.kind) {
 324                 case SEMI:
 325                     nextToken();
 326                     return;
 327                 case PUBLIC:
 328                 case FINAL:
 329                 case ABSTRACT:
 330                 case MONKEYS_AT:
 331                 case EOF:
 332                 case CLASS:
 333                 case INTERFACE:
 334                 case ENUM:
 335                     return;
 336                 case IMPORT:
 337                     if (stopAtImport)
 338                         return;
 339                     break;
 340                 case LBRACE:
 341                 case RBRACE:
 342                 case PRIVATE:
 343                 case PROTECTED:
 344                 case STATIC:
 345                 case TRANSIENT:
 346                 case NATIVE:
 347                 case VOLATILE:
 348                 case SYNCHRONIZED:
 349                 case STRICTFP:
 350                 case LT:
 351                 case BYTE:
 352                 case SHORT:
 353                 case CHAR:
 354                 case INT:
 355                 case LONG:
 356                 case FLOAT:
 357                 case DOUBLE:
 358                 case BOOLEAN:
 359                 case VOID:
 360                     if (stopAtMemberDecl)
 361                         return;
 362                     break;
 363                 case UNDERSCORE:
 364                 case IDENTIFIER:
 365                    if (stopAtIdentifier)
 366                         return;
 367                     break;
 368                 case CASE:
 369                 case DEFAULT:
 370                 case IF:
 371                 case FOR:
 372                 case WHILE:
 373                 case DO:
 374                 case TRY:
 375                 case SWITCH:
 376                 case RETURN:
 377                 case THROW:
 378                 case BREAK:
 379                 case CONTINUE:
 380                 case ELSE:
 381                 case FINALLY:
 382                 case CATCH:
 383                 case THIS:
 384                 case SUPER:
 385                 case NEW:
 386                     if (stopAtStatement)
 387                         return;
 388                     break;
 389                 case ASSERT:
 390                     if (stopAtStatement)
 391                         return;
 392                     break;
 393             }
 394             nextToken();
 395         }
 396     }
 397 
 398     protected JCErroneous syntaxError(int pos, Error errorKey) {
 399         return syntaxError(pos, List.nil(), errorKey);
 400     }
 401 
 402     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 403         setErrorEndPos(pos);
 404         JCErroneous err = F.at(pos).Erroneous(errs);
 405         reportSyntaxError(err, errorKey);
 406         if (errs != null) {
 407             JCTree last = errs.last();
 408             if (last != null)
 409                 storeEnd(last, pos);
 410         }
 411         return toP(err);
 412     }
 413 
 414     private static final int RECOVERY_THRESHOLD = 50;
 415     private int errorPos = Position.NOPOS;
 416     private int count = 0;
 417 
 418     /**
 419      * Report a syntax using the given the position parameter and arguments,
 420      * unless one was already reported at the same position.
 421      */
 422     protected void reportSyntaxError(int pos, Error errorKey) {
 423         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 424         reportSyntaxError(diag, errorKey);
 425     }
 426 
 427     /**
 428      * Report a syntax error using the given DiagnosticPosition object and
 429      * arguments, unless one was already reported at the same position.
 430      */
 431     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 432         int pos = diagPos.getPreferredPosition();
 433         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 434             if (token.kind == EOF) {
 435                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 436             } else {
 437                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 438             }
 439         }
 440         S.errPos(pos);
 441         if (token.pos == errorPos) {
 442             //check for a possible infinite loop in parsing:
 443             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 444         } else {
 445             count = 0;
 446             errorPos = token.pos;
 447         }
 448     }
 449 
 450     /** If next input token matches given token, skip it, otherwise report
 451      *  an error.
 452      */
 453     public void accept(TokenKind tk) {
 454         accept(tk, Errors::Expected);
 455     }
 456 
 457     /** If next input token matches given token, skip it, otherwise report
 458      *  an error.
 459      */
 460     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 461         if (token.kind == tk) {
 462             nextToken();
 463         } else {
 464             setErrorEndPos(token.pos);
 465             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 466         }
 467     }
 468 
 469     /** Report an illegal start of expression/type error at given position.
 470      */
 471     JCExpression illegal(int pos) {
 472         setErrorEndPos(pos);
 473         if ((mode &amp; EXPR) != 0)
 474             return syntaxError(pos, Errors.IllegalStartOfExpr);
 475         else
 476             return syntaxError(pos, Errors.IllegalStartOfType);
 477 
 478     }
 479 
 480     /** Report an illegal start of expression/type error at current position.
 481      */
 482     JCExpression illegal() {
 483         return illegal(token.pos);
 484     }
 485 
 486     /** Diagnose a modifier flag from the set, if any. */
 487     protected void checkNoMods(long mods) {
 488         if (mods != 0) {
 489             long lowestMod = mods &amp; -mods;
 490             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 491         }
 492     }
 493 
 494 /* ---------- doc comments --------- */
 495 
 496     /** A table to store all documentation comments
 497      *  indexed by the tree nodes they refer to.
 498      *  defined only if option flag keepDocComment is set.
 499      */
 500     private final DocCommentTable docComments;
 501 
 502     /** Make an entry into docComments hashtable,
 503      *  provided flag keepDocComments is set and given doc comment is non-null.
 504      *  @param tree   The tree to be used as index in the hashtable
 505      *  @param dc     The doc comment to associate with the tree, or null.
 506      */
 507     protected void attach(JCTree tree, Comment dc) {
 508         if (keepDocComments &amp;&amp; dc != null) {
 509 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 510             docComments.putComment(tree, dc);
 511         }
 512     }
 513 
 514 /* -------- source positions ------- */
 515 
 516     protected void setErrorEndPos(int errPos) {
 517         endPosTable.setErrorEndPos(errPos);
 518     }
 519 
 520     protected void storeEnd(JCTree tree, int endpos) {
 521         endPosTable.storeEnd(tree, endpos);
 522     }
 523 
 524     protected &lt;T extends JCTree&gt; T to(T t) {
 525         return endPosTable.to(t);
 526     }
 527 
 528     protected &lt;T extends JCTree&gt; T toP(T t) {
 529         return endPosTable.toP(t);
 530     }
 531 
 532     /** Get the start position for a tree node.  The start position is
 533      * defined to be the position of the first character of the first
 534      * token of the node&#39;s source text.
 535      * @param tree  The tree node
 536      */
 537     public int getStartPos(JCTree tree) {
 538         return TreeInfo.getStartPos(tree);
 539     }
 540 
 541     /**
 542      * Get the end position for a tree node.  The end position is
 543      * defined to be the position of the last character of the last
 544      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 545      * positions are not generated or the position is otherwise not
 546      * found.
 547      * @param tree  The tree node
 548      */
 549     public int getEndPos(JCTree tree) {
 550         return endPosTable.getEndPos(tree);
 551     }
 552 
 553 
 554 
 555 /* ---------- parsing -------------- */
 556 
 557     /**
 558      * Ident = IDENTIFIER
 559      */
 560     public Name ident() {
 561         return ident(false);
 562     }
 563 
 564     protected Name ident(boolean advanceOnErrors) {
 565         if (token.kind == IDENTIFIER) {
 566             Name name = token.name();
 567             nextToken();
 568             return name;
 569         } else if (token.kind == ASSERT) {
 570             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 571             nextToken();
 572             return names.error;
 573         } else if (token.kind == ENUM) {
 574             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 575             nextToken();
 576             return names.error;
 577         } else if (token.kind == THIS) {
 578             if (allowThisIdent) {
 579                 // Make sure we&#39;re using a supported source version.
 580                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 581                 Name name = token.name();
 582                 nextToken();
 583                 return name;
 584             } else {
 585                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 586                 nextToken();
 587                 return names.error;
 588             }
 589         } else if (token.kind == UNDERSCORE) {
 590             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 591                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 592             } else {
 593                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 594             }
 595             Name name = token.name();
 596             nextToken();
 597             return name;
 598         } else {
 599             accept(IDENTIFIER);
 600             if (advanceOnErrors) {
 601                 nextToken();
 602             }
 603             return names.error;
 604         }
 605     }
 606 
 607     /**
 608      * Qualident = Ident { DOT [Annotations] Ident }
 609      */
 610     public JCExpression qualident(boolean allowAnnos) {
 611         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 612         while (token.kind == DOT) {
 613             int pos = token.pos;
 614             nextToken();
 615             List&lt;JCAnnotation&gt; tyannos = null;
 616             if (allowAnnos) {
 617                 tyannos = typeAnnotationsOpt();
 618             }
 619             t = toP(F.at(pos).Select(t, ident()));
 620             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 621                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 622             }
 623         }
 624         return t;
 625     }
 626 
 627     JCExpression literal(Name prefix) {
 628         return literal(prefix, token.pos);
 629     }
 630 
 631     /**
 632      * Literal =
 633      *     INTLITERAL
 634      *   | LONGLITERAL
 635      *   | FLOATLITERAL
 636      *   | DOUBLELITERAL
 637      *   | CHARLITERAL
 638      *   | STRINGLITERAL
 639      *   | TRUE
 640      *   | FALSE
 641      *   | NULL
 642      */
 643     JCExpression literal(Name prefix, int pos) {
 644         JCExpression t = errorTree;
 645         switch (token.kind) {
 646         case INTLITERAL:
 647             try {
 648                 t = F.at(pos).Literal(
 649                     TypeTag.INT,
 650                     Convert.string2int(strval(prefix), token.radix()));
 651             } catch (NumberFormatException ex) {
 652                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 653             }
 654             break;
 655         case LONGLITERAL:
 656             try {
 657                 t = F.at(pos).Literal(
 658                     TypeTag.LONG,
 659                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 660             } catch (NumberFormatException ex) {
 661                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 662             }
 663             break;
 664         case FLOATLITERAL: {
 665             String proper = token.radix() == 16 ?
 666                     (&quot;0x&quot;+ token.stringVal()) :
 667                     token.stringVal();
 668             Float n;
 669             try {
 670                 n = Float.valueOf(proper);
 671             } catch (NumberFormatException ex) {
 672                 // error already reported in scanner
 673                 n = Float.NaN;
 674             }
 675             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 676                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 677             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 678                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 679             else
 680                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 681             break;
 682         }
 683         case DOUBLELITERAL: {
 684             String proper = token.radix() == 16 ?
 685                     (&quot;0x&quot;+ token.stringVal()) :
 686                     token.stringVal();
 687             Double n;
 688             try {
 689                 n = Double.valueOf(proper);
 690             } catch (NumberFormatException ex) {
 691                 // error already reported in scanner
 692                 n = Double.NaN;
 693             }
 694             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 695                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 696             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 697                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 698             else
 699                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 700             break;
 701         }
 702         case CHARLITERAL:
 703             t = F.at(pos).Literal(
 704                 TypeTag.CHAR,
 705                 token.stringVal().charAt(0) + 0);
 706             break;
 707         case STRINGLITERAL:
 708             t = F.at(pos).Literal(
 709                 TypeTag.CLASS,
 710                 token.stringVal());
 711             break;
 712         case TRUE: case FALSE:
 713             t = F.at(pos).Literal(
 714                 TypeTag.BOOLEAN,
 715                 (token.kind == TRUE ? 1 : 0));
 716             break;
 717         case NULL:
 718             t = F.at(pos).Literal(
 719                 TypeTag.BOT,
 720                 null);
 721             break;
 722         default:
 723             Assert.error();
 724         }
 725         if (t == errorTree)
 726             t = F.at(pos).Erroneous();
 727         storeEnd(t, token.endPos);
 728         nextToken();
 729         return t;
 730     }
 731     //where
 732         boolean isZero(String s) {
 733             char[] cs = s.toCharArray();
 734             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 735             int i = ((base==16) ? 2 : 0);
 736             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 737             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 738         }
 739 
 740         String strval(Name prefix) {
 741             String s = token.stringVal();
 742             return prefix.isEmpty() ? s : prefix + s;
 743         }
 744 
 745     /** terms can be either expressions or types.
 746      */
 747     public JCExpression parseExpression() {
 748         return term(EXPR);
 749     }
 750 
 751     /**
 752      * parses (optional) type annotations followed by a type. If the
 753      * annotations are present before the type and are not consumed during array
 754      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 755      * these annotations and the underlying type. Otherwise, it returns the
 756      * underlying type.
 757      *
 758      * &lt;p&gt;
 759      *
 760      * Note that this method sets {@code mode} to {@code TYPE} first, before
 761      * parsing annotations.
 762      */
 763     public JCExpression parseType() {
 764         return parseType(false);
 765     }
 766 
 767     public JCExpression parseType(boolean allowVar) {
 768         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 769         return parseType(allowVar, annotations);
 770     }
 771 
 772     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 773         JCExpression result = unannotatedType(allowVar);
 774 
 775         if (annotations.nonEmpty()) {
 776             result = insertAnnotationsToMostInner(result, annotations, false);
 777         }
 778 
 779         return result;
 780     }
 781 
 782     public JCExpression unannotatedType(boolean allowVar) {
 783         JCExpression result = term(TYPE);
 784         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 785 
 786         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 787             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 788         }
 789 
 790         return result;
 791     }
 792 
 793 
 794 
 795     protected JCExpression term(int newmode) {
 796         int prevmode = mode;
 797         mode = newmode;
 798         JCExpression t = term();
 799         lastmode = mode;
 800         mode = prevmode;
 801         return t;
 802     }
 803 
 804     /**
 805      *  {@literal
 806      *  Expression = Expression1 [ExpressionRest]
 807      *  ExpressionRest = [AssignmentOperator Expression1]
 808      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 809      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 810      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 811      *  Type = Type1
 812      *  TypeNoParams = TypeNoParams1
 813      *  StatementExpression = Expression
 814      *  ConstantExpression = Expression
 815      *  }
 816      */
 817     JCExpression term() {
 818         JCExpression t = term1();
 819         if ((mode &amp; EXPR) != 0 &amp;&amp;
 820             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 821             return termRest(t);
 822         else
 823             return t;
 824     }
 825 
 826     JCExpression termRest(JCExpression t) {
 827         switch (token.kind) {
 828         case EQ: {
 829             int pos = token.pos;
 830             nextToken();
 831             selectExprMode();
 832             JCExpression t1 = term();
 833             return toP(F.at(pos).Assign(t, t1));
 834         }
 835         case PLUSEQ:
 836         case SUBEQ:
 837         case STAREQ:
 838         case SLASHEQ:
 839         case PERCENTEQ:
 840         case AMPEQ:
 841         case BAREQ:
 842         case CARETEQ:
 843         case LTLTEQ:
 844         case GTGTEQ:
 845         case GTGTGTEQ:
 846             int pos = token.pos;
 847             TokenKind tk = token.kind;
 848             nextToken();
 849             selectExprMode();
 850             JCExpression t1 = term();
 851             return F.at(pos).Assignop(optag(tk), t, t1);
 852         default:
 853             return t;
 854         }
 855     }
 856 
 857     /** Expression1   = Expression2 [Expression1Rest]
 858      *  Type1         = Type2
 859      *  TypeNoParams1 = TypeNoParams2
 860      */
 861     JCExpression term1() {
 862         JCExpression t = term2();
 863         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 864             selectExprMode();
 865             return term1Rest(t);
 866         } else {
 867             return t;
 868         }
 869     }
 870 
 871     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 872      */
 873     JCExpression term1Rest(JCExpression t) {
 874         if (token.kind == QUES) {
 875             int pos = token.pos;
 876             nextToken();
 877             JCExpression t1 = term();
 878             accept(COLON);
 879             JCExpression t2 = term1();
 880             return F.at(pos).Conditional(t, t1, t2);
 881         } else {
 882             return t;
 883         }
 884     }
 885 
 886     /** Expression2   = Expression3 [Expression2Rest]
 887      *  Type2         = Type3
 888      *  TypeNoParams2 = TypeNoParams3
 889      */
 890     JCExpression term2() {
 891         JCExpression t = term3();
 892         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 893             selectExprMode();
 894             return term2Rest(t, TreeInfo.orPrec);
 895         } else {
 896             return t;
 897         }
 898     }
 899 
 900     /*  Expression2Rest = {infixop Expression3}
 901      *                  | Expression3 instanceof Type
 902      *                  | Expression3 instanceof Pattern
 903      *  infixop         = &quot;||&quot;
 904      *                  | &quot;&amp;&amp;&quot;
 905      *                  | &quot;|&quot;
 906      *                  | &quot;^&quot;
 907      *                  | &quot;&amp;&quot;
 908      *                  | &quot;==&quot; | &quot;!=&quot;
 909      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 910      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 911      *                  | &quot;+&quot; | &quot;-&quot;
 912      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 913      */
 914     JCExpression term2Rest(JCExpression t, int minprec) {
 915         JCExpression[] odStack = newOdStack();
 916         Token[] opStack = newOpStack();
 917 
 918         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 919         int top = 0;
 920         odStack[0] = t;
 921         int startPos = token.pos;
 922         Token topOp = Tokens.DUMMY;
 923         while (prec(token.kind) &gt;= minprec) {
 924             opStack[top] = topOp;
 925 
 926             if (token.kind == INSTANCEOF) {
 927                 int pos = token.pos;
 928                 nextToken();
 929                 JCTree pattern = parseType();
 930                 if (token.kind == IDENTIFIER) {
 931                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 932                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 933                 }
 934                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 935             } else {
 936                 topOp = token;
 937                 nextToken();
 938                 top++;
 939                 odStack[top] = term3();
 940             }
 941             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 942                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 943                 top--;
 944                 topOp = opStack[top];
 945             }
 946         }
 947         Assert.check(top == 0);
 948         t = odStack[0];
 949 
 950         if (t.hasTag(JCTree.Tag.PLUS)) {
 951             t = foldStrings(t);
 952         }
 953 
 954         odStackSupply.add(odStack);
 955         opStackSupply.add(opStack);
 956         return t;
 957     }
 958     //where
 959         /** If tree is a concatenation of string literals, replace it
 960          *  by a single literal representing the concatenated string.
 961          */
 962         protected JCExpression foldStrings(JCExpression tree) {
 963             if (!allowStringFolding)
 964                 return tree;
 965             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
 966             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
 967             boolean needsFolding = false;
 968             JCExpression curr = tree;
 969             while (true) {
 970                 if (curr.hasTag(JCTree.Tag.PLUS)) {
 971                     JCBinary op = (JCBinary)curr;
 972                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
 973                     curr = op.lhs;
 974                 } else {
 975                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
 976                     break; //last one!
 977                 }
 978             }
 979             if (needsFolding) {
 980                 List&lt;JCExpression&gt; ops = opStack.toList();
 981                 JCExpression res = ops.head;
 982                 for (JCExpression op : ops.tail) {
 983                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
 984                     storeEnd(res, getEndPos(op));
 985                 }
 986                 return res;
 987             } else {
 988                 return tree;
 989             }
 990         }
 991 
 992         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
 993                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
 994             JCLiteral str = stringLiteral(tree);
 995             if (str != null) {
 996                 litBuf.prepend(str);
 997                 return last &amp;&amp; merge(litBuf, opStack);
 998             } else {
 999                 boolean res = merge(litBuf, opStack);
1000                 litBuf.clear();
1001                 opStack.prepend(tree);
1002                 return res;
1003             }
1004         }
1005 
1006         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1007             if (litBuf.isEmpty()) {
1008                 return false;
1009             } else if (litBuf.size() == 1) {
1010                 opStack.prepend(litBuf.first());
1011                 return false;
1012             } else {
1013                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1014                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1015                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1016                 opStack.prepend(t);
1017                 return true;
1018             }
1019         }
1020 
1021         private JCLiteral stringLiteral(JCTree tree) {
1022             if (tree.hasTag(LITERAL)) {
1023                 JCLiteral lit = (JCLiteral)tree;
1024                 if (lit.typetag == TypeTag.CLASS) {
1025                     return lit;
1026                 }
1027             }
1028             return null;
1029         }
1030 
1031 
1032         /** optimization: To save allocating a new operand/operator stack
1033          *  for every binary operation, we use supplys.
1034          */
1035         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1036         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1037 
1038         private JCExpression[] newOdStack() {
1039             if (odStackSupply.isEmpty())
1040                 return new JCExpression[infixPrecedenceLevels + 1];
1041             return odStackSupply.remove(odStackSupply.size() - 1);
1042         }
1043 
1044         private Token[] newOpStack() {
1045             if (opStackSupply.isEmpty())
1046                 return new Token[infixPrecedenceLevels + 1];
1047             return opStackSupply.remove(opStackSupply.size() - 1);
1048         }
1049 
1050     /**
1051      *  Expression3    = PrefixOp Expression3
1052      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1053      *                 | Primary {Selector} {PostfixOp}
1054      *
1055      *  {@literal
1056      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1057      *                 | Literal
1058      *                 | [TypeArguments] THIS [Arguments]
1059      *                 | [TypeArguments] SUPER SuperSuffix
1060      *                 | NEW [TypeArguments] Creator
1061      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1062      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1063      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1064      *                 | Expression3 MemberReferenceSuffix
1065      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1066      *                   | Arguments
1067      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1068      *                   ]
1069      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1070      *  }
1071      *
1072      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1073      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1074      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1075      *                 | BasicType
1076      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1077      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1078      *                 | &quot;.&quot; THIS
1079      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1080      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1081      *                 | &quot;[&quot; Expression &quot;]&quot;
1082      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1083      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1084      */
1085     protected JCExpression term3() {
1086         int pos = token.pos;
1087         JCExpression t;
1088         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1089         switch (token.kind) {
1090         case QUES:
1091             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1092                 selectTypeMode();
1093                 return typeArgument();
1094             } else
1095                 return illegal();
1096         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1097             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1098                 TokenKind tk = token.kind;
1099                 nextToken();
1100                 selectExprMode();
1101                 if (tk == SUB &amp;&amp;
1102                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1103                     token.radix() == 10) {
1104                     selectExprMode();
1105                     t = literal(names.hyphen, pos);
1106                 } else {
1107                     t = term3();
1108                     return F.at(pos).Unary(unoptag(tk), t);
1109                 }
1110             } else return illegal();
1111             break;
1112         case LPAREN:
1113             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1114                 ParensResult pres = analyzeParens();
1115                 switch (pres) {
1116                     case CAST:
1117                        accept(LPAREN);
1118                        selectTypeMode();
1119                        int pos1 = pos;
1120                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1121                        while (token.kind == AMP) {
1122                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1123                            accept(AMP);
1124                            targets = targets.prepend(parseType());
1125                        }
1126                        if (targets.length() &gt; 1) {
1127                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1128                        }
1129                        accept(RPAREN);
1130                        selectExprMode();
1131                        JCExpression t1 = term3();
1132                        return F.at(pos).TypeCast(t, t1);
1133                     case IMPLICIT_LAMBDA:
1134                     case EXPLICIT_LAMBDA:
1135                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1136                         break;
1137                     default: //PARENS
1138                         accept(LPAREN);
1139                         selectExprMode();
1140                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1141                         accept(RPAREN);
1142                         t = toP(F.at(pos).Parens(t));
1143                         break;
1144                 }
1145             } else {
1146                 return illegal();
1147             }
1148             break;
1149         case THIS:
1150             if ((mode &amp; EXPR) != 0) {
1151                 selectExprMode();
1152                 t = to(F.at(pos).Ident(names._this));
1153                 nextToken();
1154                 if (typeArgs == null)
1155                     t = argumentsOpt(null, t);
1156                 else
1157                     t = arguments(typeArgs, t);
1158                 typeArgs = null;
1159             } else return illegal();
1160             break;
1161         case SUPER:
1162             if ((mode &amp; EXPR) != 0) {
1163                 selectExprMode();
1164                 t = to(F.at(pos).Ident(names._super));
1165                 t = superSuffix(typeArgs, t);
1166                 typeArgs = null;
1167             } else return illegal();
1168             break;
1169         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1170         case CHARLITERAL: case STRINGLITERAL:
1171         case TRUE: case FALSE: case NULL:
1172             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1173                 selectExprMode();
1174                 t = literal(names.empty);
1175             } else return illegal();
1176             break;
1177         case NEW:
1178             if (typeArgs != null) return illegal();
1179             if ((mode &amp; EXPR) != 0) {
1180                 selectExprMode();
1181                 nextToken();
1182                 if (token.kind == LT) typeArgs = typeArguments(false);
1183                 t = creator(pos, typeArgs);
1184                 typeArgs = null;
1185             } else return illegal();
1186             break;
1187         case MONKEYS_AT:
1188             // Only annotated cast types and method references are valid
1189             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1190             if (typeAnnos.isEmpty()) {
1191                 // else there would be no &#39;@&#39;
1192                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1193             }
1194 
1195             JCExpression expr = term3();
1196 
1197             if ((mode &amp; TYPE) == 0) {
1198                 // Type annotations on class literals no longer legal
1199                 switch (expr.getTag()) {
1200                 case REFERENCE: {
1201                     JCMemberReference mref = (JCMemberReference) expr;
1202                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1203                     t = mref;
1204                     break;
1205                 }
1206                 case SELECT: {
1207                     JCFieldAccess sel = (JCFieldAccess) expr;
1208 
1209                     if (sel.name != names._class) {
1210                         return illegal();
1211                     } else {
1212                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1213                         return expr;
1214                     }
1215                 }
1216                 default:
1217                     return illegal(typeAnnos.head.pos);
1218                 }
1219 
1220             } else {
1221                 // Type annotations targeting a cast
1222                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1223             }
1224             break;
1225         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1226             if (typeArgs != null) return illegal();
1227             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1228                 t = lambdaExpressionOrStatement(false, false, pos);
1229             } else {
1230                 t = toP(F.at(token.pos).Ident(ident()));
1231                 loop: while (true) {
1232                     pos = token.pos;
1233                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1234 
1235                     // need to report an error later if LBRACKET is for array
1236                     // index access rather than array creation level
1237                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1238                         return illegal(annos.head.pos);
1239 
1240                     switch (token.kind) {
1241                     case LBRACKET:
1242                         nextToken();
1243                         if (token.kind == RBRACKET) {
1244                             nextToken();
1245                             t = bracketsOpt(t);
1246                             t = toP(F.at(pos).TypeArray(t));
1247                             if (annos.nonEmpty()) {
1248                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1249                             }
1250                             t = bracketsSuffix(t);
1251                         } else {
1252                             if ((mode &amp; EXPR) != 0) {
1253                                 selectExprMode();
1254                                 JCExpression t1 = term();
1255                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1256                                 t = to(F.at(pos).Indexed(t, t1));
1257                             }
1258                             accept(RBRACKET);
1259                         }
1260                         break loop;
1261                     case LPAREN:
1262                         if ((mode &amp; EXPR) != 0) {
1263                             selectExprMode();
1264                             t = arguments(typeArgs, t);
1265                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1266                             typeArgs = null;
1267                         }
1268                         break loop;
1269                     case DOT:
1270                         nextToken();
1271                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1272                             return illegal();
1273                         }
1274                         int oldmode = mode;
1275                         mode &amp;= ~NOPARAMS;
1276                         typeArgs = typeArgumentsOpt(EXPR);
1277                         mode = oldmode;
1278                         if ((mode &amp; EXPR) != 0) {
1279                             switch (token.kind) {
1280                             case CLASS:
1281                                 if (typeArgs != null) return illegal();
1282                                 selectExprMode();
1283                                 t = to(F.at(pos).Select(t, names._class));
1284                                 nextToken();
1285                                 break loop;
1286                             case THIS:
1287                                 if (typeArgs != null) return illegal();
1288                                 selectExprMode();
1289                                 t = to(F.at(pos).Select(t, names._this));
1290                                 nextToken();
1291                                 break loop;
1292                             case SUPER:
1293                                 selectExprMode();
1294                                 t = to(F.at(pos).Select(t, names._super));
1295                                 t = superSuffix(typeArgs, t);
1296                                 typeArgs = null;
1297                                 break loop;
1298                             case NEW:
1299                                 if (typeArgs != null) return illegal();
1300                                 selectExprMode();
1301                                 int pos1 = token.pos;
1302                                 nextToken();
1303                                 if (token.kind == LT) typeArgs = typeArguments(false);
1304                                 t = innerCreator(pos1, typeArgs, t);
1305                                 typeArgs = null;
1306                                 break loop;
1307                             }
1308                         }
1309 
1310                         List&lt;JCAnnotation&gt; tyannos = null;
1311                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1312                             tyannos = typeAnnotationsOpt();
1313                         }
1314                         // typeArgs saved for next loop iteration.
1315                         t = toP(F.at(pos).Select(t, ident()));
1316                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1317                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1318                         }
1319                         break;
1320                     case ELLIPSIS:
1321                         if (this.permitTypeAnnotationsPushBack) {
1322                             this.typeAnnotationsPushedBack = annos;
1323                         } else if (annos.nonEmpty()) {
1324                             // Don&#39;t return here -- error recovery attempt
1325                             illegal(annos.head.pos);
1326                         }
1327                         break loop;
1328                     case LT:
1329                         if ((mode &amp; TYPE) == 0 &amp;&amp; isUnboundMemberRef()) {
1330                             //this is an unbound method reference whose qualifier
1331                             //is a generic type i.e. A&lt;S&gt;::m
1332                             int pos1 = token.pos;
1333                             accept(LT);
1334                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1335                             args.append(typeArgument());
1336                             while (token.kind == COMMA) {
1337                                 nextToken();
1338                                 args.append(typeArgument());
1339                             }
1340                             accept(GT);
1341                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1342                             while (token.kind == DOT) {
1343                                 nextToken();
1344                                 selectTypeMode();
1345                                 t = toP(F.at(token.pos).Select(t, ident()));
1346                                 t = typeArgumentsOpt(t);
1347                             }
1348                             t = bracketsOpt(t);
1349                             if (token.kind != COLCOL) {
1350                                 //method reference expected here
1351                                 t = illegal();
1352                             }
1353                             selectExprMode();
1354                             return term3Rest(t, typeArgs);
1355                         }
1356                         break loop;
1357                     default:
1358                         break loop;
1359                     }
1360                 }
1361             }
1362             if (typeArgs != null) illegal();
1363             t = typeArgumentsOpt(t);
1364             break;
1365         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1366         case DOUBLE: case BOOLEAN:
1367             if (typeArgs != null) illegal();
1368             t = bracketsSuffix(bracketsOpt(basicType()));
1369             break;
1370         case VOID:
1371             if (typeArgs != null) illegal();
1372             if ((mode &amp; EXPR) != 0) {
1373                 nextToken();
1374                 if (token.kind == DOT) {
1375                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1376                     t = bracketsSuffix(ti);
1377                 } else {
1378                     return illegal(pos);
1379                 }
1380             } else {
1381                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1382                 // a void type (like other primitive types) to the next phase.
1383                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1384                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1385                 nextToken();
1386                 return ti;
1387                 //return illegal();
1388             }
1389             break;
1390         case SWITCH:
1391             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1392             allowYieldStatement = true;
1393             int switchPos = token.pos;
1394             nextToken();
1395             JCExpression selector = parExpression();
1396             accept(LBRACE);
1397             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1398             while (true) {
1399                 pos = token.pos;
1400                 switch (token.kind) {
1401                 case CASE:
1402                 case DEFAULT:
1403                     cases.appendList(switchExpressionStatementGroup());
1404                     break;
1405                 case RBRACE: case EOF:
1406                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1407                                                                                cases.toList()));
1408                     e.endpos = token.pos;
1409                     accept(RBRACE);
1410                     return e;
1411                 default:
1412                     nextToken(); // to ensure progress
1413                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1414                 }
1415             }
1416         default:
1417             return illegal();
1418         }
1419         return term3Rest(t, typeArgs);
1420     }
1421 
1422     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1423         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1424         int casePos = token.pos;
1425         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1426 
1427         if (token.kind == DEFAULT) {
1428             nextToken();
1429         } else {
1430             accept(CASE);
1431             while (true) {
1432                 pats.append(term(EXPR | NOLAMBDA));
1433                 if (token.kind != COMMA) break;
1434                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1435                 nextToken();
1436             };
1437         }
1438         List&lt;JCStatement&gt; stats = null;
1439         JCTree body = null;
1440         CaseTree.CaseKind kind;
1441         switch (token.kind) {
1442             case ARROW:
1443                 checkSourceLevel(Feature.SWITCH_RULE);
1444                 nextToken();
1445                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1446                     stats = List.of(parseStatement());
1447                     body = stats.head;
1448                     kind = JCCase.RULE;
1449                 } else {
1450                     JCExpression value = parseExpression();
1451                     stats = List.of(to(F.at(value).Yield(value)));
1452                     body = value;
1453                     kind = JCCase.RULE;
1454                     accept(SEMI);
1455                 }
1456                 break;
1457             default:
1458                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1459                 stats = blockStatements();
1460                 kind = JCCase.STATEMENT;
1461                 break;
1462         }
1463         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1464         return caseExprs.toList();
1465     }
1466 
1467     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1468         if (typeArgs != null) illegal();
1469         while (true) {
1470             int pos1 = token.pos;
1471             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1472 
1473             if (token.kind == LBRACKET) {
1474                 nextToken();
1475                 if ((mode &amp; TYPE) != 0) {
1476                     int oldmode = mode;
1477                     selectTypeMode();
1478                     if (token.kind == RBRACKET) {
1479                         nextToken();
1480                         t = bracketsOpt(t);
1481                         t = toP(F.at(pos1).TypeArray(t));
1482                         if (token.kind == COLCOL) {
1483                             selectExprMode();
1484                             continue;
1485                         }
1486                         if (annos.nonEmpty()) {
1487                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1488                         }
1489                         return t;
1490                     }
1491                     mode = oldmode;
1492                 }
1493                 if ((mode &amp; EXPR) != 0) {
1494                     selectExprMode();
1495                     JCExpression t1 = term();
1496                     t = to(F.at(pos1).Indexed(t, t1));
1497                 }
1498                 accept(RBRACKET);
1499             } else if (token.kind == DOT) {
1500                 nextToken();
1501                 typeArgs = typeArgumentsOpt(EXPR);
1502                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1503                     selectExprMode();
1504                     t = to(F.at(pos1).Select(t, names._super));
1505                     nextToken();
1506                     t = arguments(typeArgs, t);
1507                     typeArgs = null;
1508                 } else if (token.kind == NEW &amp;&amp; (mode &amp; EXPR) != 0) {
1509                     if (typeArgs != null) return illegal();
1510                     selectExprMode();
1511                     int pos2 = token.pos;
1512                     nextToken();
1513                     if (token.kind == LT) typeArgs = typeArguments(false);
1514                     t = innerCreator(pos2, typeArgs, t);
1515                     typeArgs = null;
1516                 } else {
1517                     List&lt;JCAnnotation&gt; tyannos = null;
1518                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1519                         // is the mode check needed?
1520                         tyannos = typeAnnotationsOpt();
1521                     }
1522                     t = toP(F.at(pos1).Select(t, ident(true)));
1523                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1524                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1525                     }
1526                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1527                     typeArgs = null;
1528                 }
1529             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1530                 selectExprMode();
1531                 if (typeArgs != null) return illegal();
1532                 accept(COLCOL);
1533                 t = memberReferenceSuffix(pos1, t);
1534             } else {
1535                 if (!annos.isEmpty()) {
1536                     if (permitTypeAnnotationsPushBack)
1537                         typeAnnotationsPushedBack = annos;
1538                     else
1539                         return illegal(annos.head.pos);
1540                 }
1541                 break;
1542             }
1543         }
1544         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1545             selectExprMode();
1546             t = to(F.at(token.pos).Unary(
1547                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1548             nextToken();
1549         }
1550         return toP(t);
1551     }
1552 
1553     /**
1554      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1555      * method reference or a binary expression. To disambiguate, look for a
1556      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1557      */
1558     @SuppressWarnings(&quot;fallthrough&quot;)
1559     boolean isUnboundMemberRef() {
1560         int pos = 0, depth = 0;
1561         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1562             switch (t.kind) {
1563                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1564                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1565                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1566                 case DOUBLE: case BOOLEAN: case CHAR:
1567                 case MONKEYS_AT:
1568                     break;
1569 
1570                 case LPAREN:
1571                     // skip annotation values
1572                     int nesting = 0;
1573                     for (; ; pos++) {
1574                         TokenKind tk2 = S.token(pos).kind;
1575                         switch (tk2) {
1576                             case EOF:
1577                                 return false;
1578                             case LPAREN:
1579                                 nesting++;
1580                                 break;
1581                             case RPAREN:
1582                                 nesting--;
1583                                 if (nesting == 0) {
1584                                     continue outer;
1585                                 }
1586                                 break;
1587                         }
1588                     }
1589 
1590                 case LT:
1591                     depth++; break;
1592                 case GTGTGT:
1593                     depth--;
1594                 case GTGT:
1595                     depth--;
1596                 case GT:
1597                     depth--;
1598                     if (depth == 0) {
1599                         TokenKind nextKind = S.token(pos + 1).kind;
1600                         return
1601                             nextKind == TokenKind.DOT ||
1602                             nextKind == TokenKind.LBRACKET ||
1603                             nextKind == TokenKind.COLCOL;
1604                     }
1605                     break;
1606                 default:
1607                     return false;
1608             }
1609         }
1610     }
1611 
1612     /**
1613      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1614      * method reference or a binary expression. To disambiguate, look for a
1615      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1616      */
1617     @SuppressWarnings(&quot;fallthrough&quot;)
1618     ParensResult analyzeParens() {
1619         int depth = 0;
1620         boolean type = false;
1621         ParensResult defaultResult = ParensResult.PARENS;
1622         outer: for (int lookahead = 0; ; lookahead++) {
1623             TokenKind tk = S.token(lookahead).kind;
1624             switch (tk) {
1625                 case COMMA:
1626                     type = true;
1627                 case EXTENDS: case SUPER: case DOT: case AMP:
1628                     //skip
1629                     break;
1630                 case QUES:
1631                     if (peekToken(lookahead, EXTENDS) ||
1632                             peekToken(lookahead, SUPER)) {
1633                         //wildcards
1634                         type = true;
1635                     }
1636                     break;
1637                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1638                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1639                     if (peekToken(lookahead, RPAREN)) {
1640                         //Type, &#39;)&#39; -&gt; cast
1641                         return ParensResult.CAST;
1642                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1643                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1644                         return ParensResult.EXPLICIT_LAMBDA;
1645                     }
1646                     break;
1647                 case LPAREN:
1648                     if (lookahead != 0) {
1649                         // &#39;(&#39; in a non-starting position -&gt; parens
1650                         return ParensResult.PARENS;
1651                     } else if (peekToken(lookahead, RPAREN)) {
1652                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1653                         return ParensResult.EXPLICIT_LAMBDA;
1654                     }
1655                     break;
1656                 case RPAREN:
1657                     // if we have seen something that looks like a type,
1658                     // then it&#39;s a cast expression
1659                     if (type) return ParensResult.CAST;
1660                     // otherwise, disambiguate cast vs. parenthesized expression
1661                     // based on subsequent token.
1662                     switch (S.token(lookahead + 1).kind) {
1663                         /*case PLUSPLUS: case SUBSUB: */
1664                         case BANG: case TILDE:
1665                         case LPAREN: case THIS: case SUPER:
1666                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1667                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1668                         case TRUE: case FALSE: case NULL:
1669                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1670                         case SWITCH:
1671                         case BYTE: case SHORT: case CHAR: case INT:
1672                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1673                             return ParensResult.CAST;
1674                         default:
1675                             return defaultResult;
1676                     }
1677                 case UNDERSCORE:
1678                 case ASSERT:
1679                 case ENUM:
1680                 case IDENTIFIER:
1681                     if (peekToken(lookahead, LAX_IDENTIFIER)) {
1682                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1683                         return ParensResult.EXPLICIT_LAMBDA;
1684                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1685                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1686                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1687                                                       : ParensResult.PARENS;
1688                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1689                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1690                     }
1691                     type = false;
1692                     break;
1693                 case FINAL:
1694                 case ELLIPSIS:
1695                     //those can only appear in explicit lambdas
1696                     return ParensResult.EXPLICIT_LAMBDA;
1697                 case MONKEYS_AT:
1698                     type = true;
1699                     lookahead += 1; //skip &#39;@&#39;
1700                     while (peekToken(lookahead, DOT)) {
1701                         lookahead += 2;
1702                     }
1703                     if (peekToken(lookahead, LPAREN)) {
1704                         lookahead++;
1705                         //skip annotation values
1706                         int nesting = 0;
1707                         for (; ; lookahead++) {
1708                             TokenKind tk2 = S.token(lookahead).kind;
1709                             switch (tk2) {
1710                                 case EOF:
1711                                     return ParensResult.PARENS;
1712                                 case LPAREN:
1713                                     nesting++;
1714                                     break;
1715                                 case RPAREN:
1716                                     nesting--;
1717                                     if (nesting == 0) {
1718                                         continue outer;
1719                                     }
1720                                 break;
1721                             }
1722                         }
1723                     }
1724                     break;
1725                 case LBRACKET:
1726                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1727                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1728                         return ParensResult.EXPLICIT_LAMBDA;
1729                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1730                             peekToken(lookahead, RBRACKET, AMP)) {
1731                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1732                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1733                         return ParensResult.CAST;
1734                     } else if (peekToken(lookahead, RBRACKET)) {
1735                         //consume the &#39;]&#39; and skip
1736                         type = true;
1737                         lookahead++;
1738                         break;
1739                     } else {
1740                         return ParensResult.PARENS;
1741                     }
1742                 case LT:
1743                     depth++; break;
1744                 case GTGTGT:
1745                     depth--;
1746                 case GTGT:
1747                     depth--;
1748                 case GT:
1749                     depth--;
1750                     if (depth == 0) {
1751                         if (peekToken(lookahead, RPAREN) ||
1752                                 peekToken(lookahead, AMP)) {
1753                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1754                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1755                             return ParensResult.CAST;
1756                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1757                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
1758                                 peekToken(lookahead, ELLIPSIS)) {
1759                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1760                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1761                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1762                             return ParensResult.EXPLICIT_LAMBDA;
1763                         }
1764                         //it looks a type, but could still be (i) a cast to generic type,
1765                         //(ii) an unbound method reference or (iii) an explicit lambda
1766                         type = true;
1767                         break;
1768                     } else if (depth &lt; 0) {
1769                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1770                         return ParensResult.PARENS;
1771                     }
1772                     break;
1773                 default:
1774                     //this includes EOF
1775                     return defaultResult;
1776             }
1777         }
1778     }
1779 
1780     /** Accepts all identifier-like tokens */
1781     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1782 
1783     enum ParensResult {
1784         CAST,
1785         EXPLICIT_LAMBDA,
1786         IMPLICIT_LAMBDA,
1787         PARENS
1788     }
1789 
1790     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1791         List&lt;JCVariableDecl&gt; params = explicitParams ?
1792                 formalParameters(true, false) :
1793                 implicitParameters(hasParens);
1794         if (explicitParams) {
1795             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1796             for (JCVariableDecl param: params) {
1797                 Name restrictedTypeName;
1798                 if (param.vartype != null &amp;&amp;
1799                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1800                         param.vartype.hasTag(TYPEARRAY)) {
1801                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1802                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1803                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1804                 }
1805                 lambdaClassifier.addParameter(param);
1806                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1807                     break;
1808                 }
1809             }
1810             if (lambdaClassifier.diagFragment != null) {
1811                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1812             }
1813             for (JCVariableDecl param: params) {
1814                 if (param.vartype != null
1815                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1816                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1817                     param.startPos = TreeInfo.getStartPos(param.vartype);
1818                     param.vartype = null;
1819                 }
1820             }
1821         }
1822         return lambdaExpressionOrStatementRest(params, pos);
1823     }
1824 
1825     enum LambdaParameterKind {
1826         VAR(0),
1827         EXPLICIT(1),
1828         IMPLICIT(2),
1829         ERROR(-1);
1830 
1831         private final int index;
1832 
1833         LambdaParameterKind(int index) {
1834             this.index = index;
1835         }
1836     }
1837 
1838     private final static Fragment[][] decisionTable = new Fragment[][] {
1839         /*              VAR                              EXPLICIT                         IMPLICIT  */
1840         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1841         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1842         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1843     };
1844 
1845     class LambdaClassifier {
1846 
1847         LambdaParameterKind kind;
1848         Fragment diagFragment;
1849         List&lt;JCVariableDecl&gt; params;
1850 
1851         void addParameter(JCVariableDecl param) {
1852             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1853                 if (restrictedTypeName(param.vartype, false) != null) {
1854                     reduce(LambdaParameterKind.VAR);
1855                 } else {
1856                     reduce(LambdaParameterKind.EXPLICIT);
1857                 }
1858             }
1859             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1860                 param.vartype != null &amp;&amp; param.name == names.empty) {
1861                 reduce(LambdaParameterKind.IMPLICIT);
1862             }
1863         }
1864 
1865         private void reduce(LambdaParameterKind newKind) {
1866             if (kind == null) {
1867                 kind = newKind;
1868             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1869                 LambdaParameterKind currentKind = kind;
1870                 kind = LambdaParameterKind.ERROR;
1871                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1872                         newKind.index == LambdaParameterKind.VAR.index;
1873                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1874                         decisionTable[currentKind.index][newKind.index] : null;
1875             }
1876         }
1877 
1878         LambdaParameterKind result() {
1879             return kind;
1880         }
1881     }
1882 
1883     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1884         checkSourceLevel(Feature.LAMBDA);
1885         accept(ARROW);
1886 
1887         return token.kind == LBRACE ?
1888             lambdaStatement(args, pos, token.pos) :
1889             lambdaExpression(args, pos);
1890     }
1891 
1892     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1893         JCBlock block = block(pos2, 0);
1894         return toP(F.at(pos).Lambda(args, block));
1895     }
1896 
1897     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1898         JCTree expr = parseExpression();
1899         return toP(F.at(pos).Lambda(args, expr));
1900     }
1901 
1902     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1903      */
1904     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1905         nextToken();
1906         if (token.kind == LPAREN || typeArgs != null) {
1907             t = arguments(typeArgs, t);
1908         } else if (token.kind == COLCOL) {
1909             if (typeArgs != null) return illegal();
1910             t = memberReferenceSuffix(t);
1911         } else {
1912             int pos = token.pos;
1913             accept(DOT);
1914             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
1915             t = toP(F.at(pos).Select(t, ident()));
1916             t = argumentsOpt(typeArgs, t);
1917         }
1918         return t;
1919     }
1920 
1921     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
1922      */
1923     JCPrimitiveTypeTree basicType() {
1924         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
1925         nextToken();
1926         return t;
1927     }
1928 
1929     /** ArgumentsOpt = [ Arguments ]
1930      */
1931     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1932         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
1933             selectExprMode();
1934             return arguments(typeArgs, t);
1935         } else {
1936             return t;
1937         }
1938     }
1939 
1940     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
1941      */
1942     List&lt;JCExpression&gt; arguments() {
1943         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1944         if (token.kind == LPAREN) {
1945             nextToken();
1946             if (token.kind != RPAREN) {
1947                 args.append(parseExpression());
1948                 while (token.kind == COMMA) {
1949                     nextToken();
1950                     args.append(parseExpression());
1951                 }
1952             }
1953             accept(RPAREN);
1954         } else {
1955             syntaxError(token.pos, Errors.Expected(LPAREN));
1956         }
1957         return args.toList();
1958     }
1959 
1960     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1961         int pos = token.pos;
1962         List&lt;JCExpression&gt; args = arguments();
1963         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
1964         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
1965                                                                     ((JCIdent) t).name)) {
1966             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
1967             mi = F.Erroneous(List.of(mi));
1968         }
1969         return toP(mi);
1970     }
1971 
1972     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
1973         if (name == names.yield) {
1974             if (allowYieldStatement) {
1975                 return true;
1976             } else {
1977                 log.warning(pos, Warnings.InvalidYield);
1978             }
1979         }
1980         return false;
1981     }
1982 
1983     /**  TypeArgumentsOpt = [ TypeArguments ]
1984      */
1985     JCExpression typeArgumentsOpt(JCExpression t) {
1986         if (token.kind == LT &amp;&amp;
1987             (mode &amp; TYPE) != 0 &amp;&amp;
1988             (mode &amp; NOPARAMS) == 0) {
1989             selectTypeMode();
1990             return typeArguments(t, false);
1991         } else {
1992             return t;
1993         }
1994     }
1995     List&lt;JCExpression&gt; typeArgumentsOpt() {
1996         return typeArgumentsOpt(TYPE);
1997     }
1998 
1999     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2000         if (token.kind == LT) {
2001             if ((mode &amp; useMode) == 0 ||
2002                 (mode &amp; NOPARAMS) != 0) {
2003                 illegal();
2004             }
2005             mode = useMode;
2006             return typeArguments(false);
2007         }
2008         return null;
2009     }
2010 
2011     /**
2012      *  {@literal
2013      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2014      *  }
2015      */
2016     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2017         if (token.kind == LT) {
2018             nextToken();
2019             if (token.kind == GT &amp;&amp; diamondAllowed) {
2020                 checkSourceLevel(Feature.DIAMOND);
2021                 mode |= DIAMOND;
2022                 nextToken();
2023                 return List.nil();
2024             } else {
2025                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2026                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2027                 while (token.kind == COMMA) {
2028                     nextToken();
2029                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2030                 }
2031                 switch (token.kind) {
2032 
2033                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2034                 case GTGTGT: case GTGT:
2035                     token = S.split();
2036                     break;
2037                 case GT:
2038                     nextToken();
2039                     break;
2040                 default:
2041                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2042                     break;
2043                 }
2044                 return args.toList();
2045             }
2046         } else {
2047             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2048         }
2049     }
2050 
2051     /**
2052      *  {@literal
2053      *  TypeArgument = Type
2054      *               | [Annotations] &quot;?&quot;
2055      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2056      *               | [Annotations] &quot;?&quot; SUPER Type
2057      *  }
2058      */
2059     JCExpression typeArgument() {
2060         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2061         if (token.kind != QUES) return parseType(false, annotations);
2062         int pos = token.pos;
2063         nextToken();
2064         JCExpression result;
2065         if (token.kind == EXTENDS) {
2066             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2067             nextToken();
2068             JCExpression bound = parseType();
2069             result = F.at(pos).Wildcard(t, bound);
2070         } else if (token.kind == SUPER) {
2071             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2072             nextToken();
2073             JCExpression bound = parseType();
2074             result = F.at(pos).Wildcard(t, bound);
2075         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2076             //error recovery
2077             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2078             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2079             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2080             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2081             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2082             result = err;
2083         } else {
2084             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2085             result = toP(F.at(pos).Wildcard(t, null));
2086         }
2087         if (!annotations.isEmpty()) {
2088             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2089         }
2090         return result;
2091     }
2092 
2093     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2094         int pos = token.pos;
2095         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
2096         return toP(F.at(pos).TypeApply(t, args));
2097     }
2098 
2099     /**
2100      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2101      *
2102      * &lt;p&gt;
2103      *
2104      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2105      * the expression &lt;code&gt;t&lt;/code&gt;.
2106      */
2107     private JCExpression bracketsOpt(JCExpression t,
2108             List&lt;JCAnnotation&gt; annotations) {
2109         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2110 
2111         if (token.kind == LBRACKET) {
2112             int pos = token.pos;
2113             nextToken();
2114             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2115         } else if (!nextLevelAnnotations.isEmpty()) {
2116             if (permitTypeAnnotationsPushBack) {
2117                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2118             } else {
2119                 return illegal(nextLevelAnnotations.head.pos);
2120             }
2121         }
2122 
2123         if (!annotations.isEmpty()) {
2124             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2125         }
2126         return t;
2127     }
2128 
2129     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2130      */
2131     private JCExpression bracketsOpt(JCExpression t) {
2132         return bracketsOpt(t, List.nil());
2133     }
2134 
2135     private JCExpression bracketsOptCont(JCExpression t, int pos,
2136             List&lt;JCAnnotation&gt; annotations) {
2137         accept(RBRACKET);
2138         t = bracketsOpt(t);
2139         t = toP(F.at(pos).TypeArray(t));
2140         if (annotations.nonEmpty()) {
2141             t = toP(F.at(pos).AnnotatedType(annotations, t));
2142         }
2143         return t;
2144     }
2145 
2146     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2147      *  BracketsSuffixType =
2148      */
2149     JCExpression bracketsSuffix(JCExpression t) {
2150         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2151             selectExprMode();
2152             int pos = token.pos;
2153             nextToken();
2154             accept(CLASS);
2155             if (token.pos == endPosTable.errorEndPos) {
2156                 // error recovery
2157                 Name name;
2158                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2159                     name = token.name();
2160                     nextToken();
2161                 } else {
2162                     name = names.error;
2163                 }
2164                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2165             } else {
2166                 Tag tag = t.getTag();
2167                 // Type annotations are illegal on class literals. Annotated non array class literals
2168                 // are complained about directly in term3(), Here check for type annotations on dimensions
2169                 // taking care to handle some interior dimension(s) being annotated.
2170                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2171                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
2172                 t = toP(F.at(pos).Select(t, names._class));
2173             }
2174         } else if ((mode &amp; TYPE) != 0) {
2175             if (token.kind != COLCOL) {
2176                 selectTypeMode();
2177             }
2178         } else if (token.kind != COLCOL) {
2179             syntaxError(token.pos, Errors.DotClassExpected);
2180         }
2181         return t;
2182     }
2183 
2184     /**
2185      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2186      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2187      */
2188     JCExpression memberReferenceSuffix(JCExpression t) {
2189         int pos1 = token.pos;
2190         accept(COLCOL);
2191         return memberReferenceSuffix(pos1, t);
2192     }
2193 
2194     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2195         checkSourceLevel(Feature.METHOD_REFERENCES);
2196         selectExprMode();
2197         List&lt;JCExpression&gt; typeArgs = null;
2198         if (token.kind == LT) {
2199             typeArgs = typeArguments(false);
2200         }
2201         Name refName;
2202         ReferenceMode refMode;
2203         if (token.kind == NEW) {
2204             refMode = ReferenceMode.NEW;
2205             refName = names.init;
2206             nextToken();
2207         } else {
2208             refMode = ReferenceMode.INVOKE;
2209             refName = ident();
2210         }
2211         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2212     }
2213 
2214     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2215      */
2216     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
2217         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2218 
2219         switch (token.kind) {
2220         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2221         case DOUBLE: case BOOLEAN:
2222             if (typeArgs == null) {
2223                 if (newAnnotations.isEmpty()) {
2224                     return arrayCreatorRest(newpos, basicType());
2225                 } else {
2226                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2227                 }
2228             }
2229             break;
2230         default:
2231         }
2232         JCExpression t = qualident(true);
2233 
2234         int oldmode = mode;
2235         selectTypeMode();
2236         boolean diamondFound = false;
2237         int lastTypeargsPos = -1;
2238         if (token.kind == LT) {
2239             lastTypeargsPos = token.pos;
2240             t = typeArguments(t, true);
2241             diamondFound = (mode &amp; DIAMOND) != 0;
2242         }
2243         while (token.kind == DOT) {
2244             if (diamondFound) {
2245                 //cannot select after a diamond
2246                 illegal();
2247             }
2248             int pos = token.pos;
2249             nextToken();
2250             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2251             t = toP(F.at(pos).Select(t, ident()));
2252 
2253             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2254                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2255             }
2256 
2257             if (token.kind == LT) {
2258                 lastTypeargsPos = token.pos;
2259                 t = typeArguments(t, true);
2260                 diamondFound = (mode &amp; DIAMOND) != 0;
2261             }
2262         }
2263         mode = oldmode;
2264         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2265             // handle type annotations for non primitive arrays
2266             if (newAnnotations.nonEmpty()) {
2267                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2268             }
2269 
2270             JCExpression e = arrayCreatorRest(newpos, t);
2271             if (diamondFound) {
2272                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2273                 return toP(F.at(newpos).Erroneous(List.of(e)));
2274             }
2275             else if (typeArgs != null) {
2276                 int pos = newpos;
2277                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2278                     // note: this should always happen but we should
2279                     // not rely on this as the parser is continuously
2280                     // modified to improve error recovery.
2281                     pos = typeArgs.head.pos;
2282                 }
2283                 setErrorEndPos(S.prevToken().endPos);
2284                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2285                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2286                 return toP(err);
2287             }
2288             return e;
2289         } else if (token.kind == LPAREN) {
2290             // handle type annotations for instantiations and anonymous classes
2291             if (newAnnotations.nonEmpty()) {
2292                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2293             }
2294             return classCreatorRest(newpos, null, typeArgs, t);
2295         } else {
2296             setErrorEndPos(token.pos);
2297             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2298             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2299             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2300         }
2301     }
2302 
2303     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2304      */
2305     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2306         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2307 
2308         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2309 
2310         if (newAnnotations.nonEmpty()) {
2311             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2312         }
2313 
2314         if (token.kind == LT) {
2315             int oldmode = mode;
2316             t = typeArguments(t, true);
2317             mode = oldmode;
2318         }
2319         return classCreatorRest(newpos, encl, typeArgs, t);
2320     }
2321 
2322     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2323      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2324      */
2325     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2326         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2327 
2328         accept(LBRACKET);
2329         if (token.kind == RBRACKET) {
2330             accept(RBRACKET);
2331             elemtype = bracketsOpt(elemtype, annos);
2332             if (token.kind == LBRACE) {
2333                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2334                 if (annos.nonEmpty()) {
2335                     // when an array initializer is present then
2336                     // the parsed annotations should target the
2337                     // new array tree
2338                     // bracketsOpt inserts the annotation in
2339                     // elemtype, and it needs to be corrected
2340                     //
2341                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2342                     assert annotated.annotations == annos;
2343                     na.annotations = annotated.annotations;
2344                     na.elemtype = annotated.underlyingType;
2345                 }
2346                 return na;
2347             } else {
2348                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2349                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2350             }
2351         } else {
2352             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2353 
2354             // maintain array dimension type annotations
2355             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2356             dimAnnotations.append(annos);
2357 
2358             dims.append(parseExpression());
2359             accept(RBRACKET);
2360             while (token.kind == LBRACKET
2361                     || token.kind == MONKEYS_AT) {
2362                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2363                 int pos = token.pos;
2364                 nextToken();
2365                 if (token.kind == RBRACKET) {
2366                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2367                 } else {
2368                     if (token.kind == RBRACKET) { // no dimension
2369                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2370                     } else {
2371                         dimAnnotations.append(maybeDimAnnos);
2372                         dims.append(parseExpression());
2373                         accept(RBRACKET);
2374                     }
2375                 }
2376             }
2377 
2378             List&lt;JCExpression&gt; elems = null;
2379             int errpos = token.pos;
2380 
2381             if (token.kind == LBRACE) {
2382                 elems = arrayInitializerElements(newpos, elemtype);
2383             }
2384 
2385             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2386             na.dimAnnotations = dimAnnotations.toList();
2387 
2388             if (elems != null) {
2389                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2390             }
2391 
2392             return na;
2393         }
2394     }
2395 
2396     /** ClassCreatorRest = Arguments [ClassBody]
2397      */
2398     JCNewClass classCreatorRest(int newpos,
2399                                   JCExpression encl,
2400                                   List&lt;JCExpression&gt; typeArgs,
2401                                   JCExpression t)
2402     {
2403         List&lt;JCExpression&gt; args = arguments();
2404         JCClassDecl body = null;
2405         if (token.kind == LBRACE) {
2406             int pos = token.pos;
2407             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
2408             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2409             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2410         }
2411         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2412     }
2413 
2414     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2415      */
2416     JCExpression arrayInitializer(int newpos, JCExpression t) {
2417         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2418         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2419     }
2420 
2421     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2422         accept(LBRACE);
2423         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2424         if (token.kind == COMMA) {
2425             nextToken();
2426         } else if (token.kind != RBRACE) {
2427             elems.append(variableInitializer());
2428             while (token.kind == COMMA) {
2429                 nextToken();
2430                 if (token.kind == RBRACE) break;
2431                 elems.append(variableInitializer());
2432             }
2433         }
2434         accept(RBRACE);
2435         return elems.toList();
2436     }
2437 
2438     /** VariableInitializer = ArrayInitializer | Expression
2439      */
2440     public JCExpression variableInitializer() {
2441         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2442     }
2443 
2444     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2445      */
2446     JCExpression parExpression() {
2447         int pos = token.pos;
2448         accept(LPAREN);
2449         JCExpression t = parseExpression();
2450         accept(RPAREN);
2451         return toP(F.at(pos).Parens(t));
2452     }
2453 
2454     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2455      */
2456     JCBlock block(int pos, long flags) {
2457         accept(LBRACE);
2458         List&lt;JCStatement&gt; stats = blockStatements();
2459         JCBlock t = F.at(pos).Block(flags, stats);
2460         while (token.kind == CASE || token.kind == DEFAULT) {
2461             syntaxError(token.pos, Errors.Orphaned(token.kind));
2462             switchBlockStatementGroups();
2463         }
2464         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2465         // usually but not necessarily the last char of the last token.
2466         t.endpos = token.pos;
2467         accept(RBRACE);
2468         return toP(t);
2469     }
2470 
2471     public JCBlock block() {
2472         return block(token.pos, 0);
2473     }
2474 
2475     /** BlockStatements = { BlockStatement }
2476      *  BlockStatement  = LocalVariableDeclarationStatement
2477      *                  | ClassOrInterfaceOrEnumDeclaration
2478      *                  | [Ident &quot;:&quot;] Statement
2479      *  LocalVariableDeclarationStatement
2480      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2481      */
2482     @SuppressWarnings(&quot;fallthrough&quot;)
2483     List&lt;JCStatement&gt; blockStatements() {
2484         //todo: skip to anchor on error(?)
2485         int lastErrPos = -1;
2486         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2487         while (true) {
2488             List&lt;JCStatement&gt; stat = blockStatement();
2489             if (stat.isEmpty()) {
2490                 return stats.toList();
2491             } else {
2492                 // error recovery
2493                 if (token.pos == lastErrPos)
2494                     return stats.toList();
2495                 if (token.pos &lt;= endPosTable.errorEndPos) {
2496                     skip(false, true, true, true);
2497                     lastErrPos = token.pos;
2498                 }
2499                 stats.addAll(stat);
2500             }
2501         }
2502     }
2503 
2504     /*
2505      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2506      * this method will also recognize variable and class declarations (which are
2507      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2508      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2509      * and an error will be produced by this method.
2510      */
2511     JCStatement parseStatementAsBlock() {
2512         int pos = token.pos;
2513         List&lt;JCStatement&gt; stats = blockStatement();
2514         if (stats.isEmpty()) {
2515             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2516             return toP(F.at(pos).Exec(e));
2517         } else {
2518             JCStatement first = stats.head;
2519             Error error = null;
2520             switch (first.getTag()) {
2521             case CLASSDEF:
2522                 error = Errors.ClassNotAllowed;
2523                 break;
2524             case VARDEF:
2525                 error = Errors.VariableNotAllowed;
2526                 break;
2527             }
2528             if (error != null) {
2529                 log.error(DiagnosticFlag.SYNTAX, first, error);
2530                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2531                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2532             }
2533             return first;
2534         }
2535     }
2536 
2537     /**This method parses a statement appearing inside a block.
2538      */
2539     @SuppressWarnings(&quot;fallthrough&quot;)
2540     List&lt;JCStatement&gt; blockStatement() {
2541         //todo: skip to anchor on error(?)
2542         Comment dc;
2543         int pos = token.pos;
2544         switch (token.kind) {
2545         case RBRACE: case CASE: case DEFAULT: case EOF:
2546             return List.nil();
2547         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2548         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2549         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2550         case ASSERT:
2551             return List.of(parseSimpleStatement());
2552         case MONKEYS_AT:
2553         case FINAL: {
2554             dc = token.comment(CommentStyle.JAVADOC);
2555             JCModifiers mods = modifiersOpt();
2556             if (token.kind == INTERFACE ||
2557                 token.kind == CLASS ||
2558                 token.kind == ENUM ||
2559                 isRecordStart()) {
2560                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2561             } else {
2562                 JCExpression t = parseType(true);
2563                 return localVariableDeclarations(mods, t);
2564             }
2565         }
2566         case ABSTRACT: case STRICTFP: {
2567             dc = token.comment(CommentStyle.JAVADOC);
2568             JCModifiers mods = modifiersOpt();
2569             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2570         }
2571         case INTERFACE:
2572         case CLASS:
2573             dc = token.comment(CommentStyle.JAVADOC);
2574             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2575         case ENUM:
2576             if (!allowRecords) {
2577                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2578             }
2579             dc = token.comment(CommentStyle.JAVADOC);
2580             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2581         case IDENTIFIER:
2582             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2583                 Token next = S.token(1);
2584                 boolean isYieldStatement;
2585                 switch (next.kind) {
2586                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
2587                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
2588                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2589                     case NEW: case SWITCH: case THIS: case SUPER:
2590                         isYieldStatement = true;
2591                         break;
2592                     case PLUSPLUS: case SUBSUB:
2593                         isYieldStatement = S.token(2).kind != SEMI;
2594                         break;
2595                     case LPAREN:
2596                         int lookahead = 2;
2597                         int balance = 1;
2598                         boolean hasComma = false;
2599                         Token l;
2600                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2601                             switch (l.kind) {
2602                                 case LPAREN: balance++; break;
2603                                 case RPAREN: balance--; break;
2604                                 case COMMA: if (balance == 1) hasComma = true; break;
2605                             }
2606                             lookahead++;
2607                         }
2608                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2609                         break;
2610                     case SEMI: //error recovery - this is not a valid statement:
2611                         isYieldStatement = true;
2612                         break;
2613                     default:
2614                         isYieldStatement = false;
2615                         break;
2616                 }
2617 
2618                 if (isYieldStatement) {
2619                     nextToken();
2620                     JCExpression t = term(EXPR);
2621                     accept(SEMI);
2622                     return List.of(toP(F.at(pos).Yield(t)));
2623                 }
2624 
2625                 //else intentional fall-through
2626             }
2627         }
2628         if (isRecordStart() &amp;&amp; allowRecords) {
2629             dc = token.comment(CommentStyle.JAVADOC);
2630             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2631         } else {
2632             Token prevToken = token;
2633             JCExpression t = term(EXPR | TYPE);
2634             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2635                 nextToken();
2636                 JCStatement stat = parseStatementAsBlock();
2637                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2638             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2639                 pos = token.pos;
2640                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2641                 F.at(pos);
2642                 return localVariableDeclarations(mods, t);
2643             } else {
2644                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2645                 t = checkExprStat(t);
2646                 accept(SEMI);
2647                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2648                 return List.of(expr);
2649             }
2650         }
2651     }
2652     //where
2653         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2654             ListBuffer&lt;JCStatement&gt; stats =
2655                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2656             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2657             accept(SEMI);
2658             storeEnd(stats.last(), S.prevToken().endPos);
2659             return stats.toList();
2660         }
2661 
2662     /** Statement =
2663      *       Block
2664      *     | IF ParExpression Statement [ELSE Statement]
2665      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2666      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2667      *     | WHILE ParExpression Statement
2668      *     | DO Statement WHILE ParExpression &quot;;&quot;
2669      *     | TRY Block ( Catches | [Catches] FinallyPart )
2670      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2671      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2672      *     | SYNCHRONIZED ParExpression Block
2673      *     | RETURN [Expression] &quot;;&quot;
2674      *     | THROW Expression &quot;;&quot;
2675      *     | BREAK [Ident] &quot;;&quot;
2676      *     | CONTINUE [Ident] &quot;;&quot;
2677      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2678      *     | &quot;;&quot;
2679      */
2680     public JCStatement parseSimpleStatement() {
2681         int pos = token.pos;
2682         switch (token.kind) {
2683         case LBRACE:
2684             return block();
2685         case IF: {
2686             nextToken();
2687             JCExpression cond = parExpression();
2688             JCStatement thenpart = parseStatementAsBlock();
2689             JCStatement elsepart = null;
2690             if (token.kind == ELSE) {
2691                 nextToken();
2692                 elsepart = parseStatementAsBlock();
2693             }
2694             return F.at(pos).If(cond, thenpart, elsepart);
2695         }
2696         case FOR: {
2697             nextToken();
2698             accept(LPAREN);
2699             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2700             if (inits.length() == 1 &amp;&amp;
2701                 inits.head.hasTag(VARDEF) &amp;&amp;
2702                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2703                 token.kind == COLON) {
2704                 JCVariableDecl var = (JCVariableDecl)inits.head;
2705                 accept(COLON);
2706                 JCExpression expr = parseExpression();
2707                 accept(RPAREN);
2708                 JCStatement body = parseStatementAsBlock();
2709                 return F.at(pos).ForeachLoop(var, expr, body);
2710             } else {
2711                 accept(SEMI);
2712                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2713                 accept(SEMI);
2714                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2715                 accept(RPAREN);
2716                 JCStatement body = parseStatementAsBlock();
2717                 return F.at(pos).ForLoop(inits, cond, steps, body);
2718             }
2719         }
2720         case WHILE: {
2721             nextToken();
2722             JCExpression cond = parExpression();
2723             JCStatement body = parseStatementAsBlock();
2724             return F.at(pos).WhileLoop(cond, body);
2725         }
2726         case DO: {
2727             nextToken();
2728             JCStatement body = parseStatementAsBlock();
2729             accept(WHILE);
2730             JCExpression cond = parExpression();
2731             accept(SEMI);
2732             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2733             return t;
2734         }
2735         case TRY: {
2736             nextToken();
2737             List&lt;JCTree&gt; resources = List.nil();
2738             if (token.kind == LPAREN) {
2739                 nextToken();
2740                 resources = resources();
2741                 accept(RPAREN);
2742             }
2743             JCBlock body = block();
2744             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2745             JCBlock finalizer = null;
2746             if (token.kind == CATCH || token.kind == FINALLY) {
2747                 while (token.kind == CATCH) catchers.append(catchClause());
2748                 if (token.kind == FINALLY) {
2749                     nextToken();
2750                     finalizer = block();
2751                 }
2752             } else {
2753                 if (resources.isEmpty()) {
2754                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2755                 }
2756             }
2757             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2758         }
2759         case SWITCH: {
2760             nextToken();
2761             JCExpression selector = parExpression();
2762             accept(LBRACE);
2763             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2764             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2765             accept(RBRACE);
2766             return t;
2767         }
2768         case SYNCHRONIZED: {
2769             nextToken();
2770             JCExpression lock = parExpression();
2771             JCBlock body = block();
2772             return F.at(pos).Synchronized(lock, body);
2773         }
2774         case RETURN: {
2775             nextToken();
2776             JCExpression result = token.kind == SEMI ? null : parseExpression();
2777             accept(SEMI);
2778             JCReturn t = toP(F.at(pos).Return(result));
2779             return t;
2780         }
2781         case THROW: {
2782             nextToken();
2783             JCExpression exc = parseExpression();
2784             accept(SEMI);
2785             JCThrow t = toP(F.at(pos).Throw(exc));
2786             return t;
2787         }
2788         case BREAK: {
2789             nextToken();
2790             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2791             accept(SEMI);
2792             JCBreak t = toP(F.at(pos).Break(label));
2793             return t;
2794         }
2795         case CONTINUE: {
2796             nextToken();
2797             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2798             accept(SEMI);
2799             JCContinue t =  toP(F.at(pos).Continue(label));
2800             return t;
2801         }
2802         case SEMI:
2803             nextToken();
2804             return toP(F.at(pos).Skip());
2805         case ELSE:
2806             int elsePos = token.pos;
2807             nextToken();
2808             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2809         case FINALLY:
2810             int finallyPos = token.pos;
2811             nextToken();
2812             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2813         case CATCH:
2814             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2815         case ASSERT: {
2816             nextToken();
2817             JCExpression assertion = parseExpression();
2818             JCExpression message = null;
2819             if (token.kind == COLON) {
2820                 nextToken();
2821                 message = parseExpression();
2822             }
2823             accept(SEMI);
2824             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2825             return t;
2826         }
2827         default:
2828             Assert.error();
2829             return null;
2830         }
2831     }
2832 
2833     @Override
2834     public JCStatement parseStatement() {
2835         return parseStatementAsBlock();
2836     }
2837 
2838     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2839         int errPos = S.errPos();
2840         JCTree stm = action.doRecover(this);
2841         S.errPos(errPos);
2842         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2843     }
2844 
2845     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2846      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2847      */
2848     protected JCCatch catchClause() {
2849         int pos = token.pos;
2850         accept(CATCH);
2851         accept(LPAREN);
2852         JCModifiers mods = optFinal(Flags.PARAMETER);
2853         List&lt;JCExpression&gt; catchTypes = catchTypes();
2854         JCExpression paramType = catchTypes.size() &gt; 1 ?
2855                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2856                 catchTypes.head;
2857         JCVariableDecl formal = variableDeclaratorId(mods, paramType);
2858         accept(RPAREN);
2859         JCBlock body = block();
2860         return F.at(pos).Catch(formal, body);
2861     }
2862 
2863     List&lt;JCExpression&gt; catchTypes() {
2864         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2865         catchTypes.add(parseType());
2866         while (token.kind == BAR) {
2867             nextToken();
2868             // Instead of qualident this is now parseType.
2869             // But would that allow too much, e.g. arrays or generics?
2870             catchTypes.add(parseType());
2871         }
2872         return catchTypes.toList();
2873     }
2874 
2875     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2876      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2877      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
2878      */
2879     List&lt;JCCase&gt; switchBlockStatementGroups() {
2880         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2881         while (true) {
2882             int pos = token.pos;
2883             switch (token.kind) {
2884             case CASE:
2885             case DEFAULT:
2886                 cases.appendList(switchBlockStatementGroup());
2887                 break;
2888             case RBRACE: case EOF:
2889                 return cases.toList();
2890             default:
2891                 nextToken(); // to ensure progress
2892                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2893             }
2894         }
2895     }
2896 
2897     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2898         int pos = token.pos;
2899         List&lt;JCStatement&gt; stats;
2900         JCCase c;
2901         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2902         switch (token.kind) {
2903         case CASE: {
2904             nextToken();
2905             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
2906             while (true) {
2907                 pats.append(term(EXPR | NOLAMBDA));
2908                 if (token.kind != COMMA) break;
2909                 nextToken();
2910                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2911             };
2912             CaseTree.CaseKind caseKind;
2913             JCTree body = null;
2914             if (token.kind == ARROW) {
2915                 checkSourceLevel(Feature.SWITCH_RULE);
2916                 accept(ARROW);
2917                 caseKind = JCCase.RULE;
2918                 JCStatement statement = parseStatementAsBlock();
2919                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2920                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2921                 }
2922                 stats = List.of(statement);
2923                 body = stats.head;
2924             } else {
2925                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2926                 caseKind = JCCase.STATEMENT;
2927                 stats = blockStatements();
2928             }
2929             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
2930             if (stats.isEmpty())
2931                 storeEnd(c, S.prevToken().endPos);
2932             return cases.append(c).toList();
2933         }
2934         case DEFAULT: {
2935             nextToken();
2936             CaseTree.CaseKind caseKind;
2937             JCTree body = null;
2938             if (token.kind == ARROW) {
2939                 checkSourceLevel(Feature.SWITCH_RULE);
2940                 accept(ARROW);
2941                 caseKind = JCCase.RULE;
2942                 JCStatement statement = parseStatementAsBlock();
2943                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2944                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2945                 }
2946                 stats = List.of(statement);
2947                 body = stats.head;
2948             } else {
2949                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2950                 caseKind = JCCase.STATEMENT;
2951                 stats = blockStatements();
2952             }
2953             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
2954             if (stats.isEmpty())
2955                 storeEnd(c, S.prevToken().endPos);
2956             return cases.append(c).toList();
2957         }
2958         }
2959         throw new AssertionError(&quot;should not reach here&quot;);
2960     }
2961 
2962     /** MoreStatementExpressions = { COMMA StatementExpression }
2963      */
2964     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
2965                                                                     JCExpression first,
2966                                                                     T stats) {
2967         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
2968         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
2969         while (token.kind == COMMA) {
2970             nextToken();
2971             pos = token.pos;
2972             JCExpression t = parseExpression();
2973             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
2974             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
2975         }
2976         return stats;
2977     }
2978 
2979     /** ForInit = StatementExpression MoreStatementExpressions
2980      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
2981      */
2982     List&lt;JCStatement&gt; forInit() {
2983         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2984         int pos = token.pos;
2985         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
2986             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
2987         } else {
2988             JCExpression t = term(EXPR | TYPE);
2989             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2990                 return variableDeclarators(modifiersOpt(), t, stats, true).toList();
2991             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
2992                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
2993                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
2994             } else {
2995                 return moreStatementExpressions(pos, t, stats).toList();
2996             }
2997         }
2998     }
2999 
3000     /** ForUpdate = StatementExpression MoreStatementExpressions
3001      */
3002     List&lt;JCExpressionStatement&gt; forUpdate() {
3003         return moreStatementExpressions(token.pos,
3004                                         parseExpression(),
3005                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3006     }
3007 
3008     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3009      *
3010      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3011      */
3012     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3013         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3014         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3015         int prevmode = mode;
3016         while (token.kind == MONKEYS_AT) {
3017             int pos = token.pos;
3018             nextToken();
3019             buf.append(annotation(pos, kind));
3020         }
3021         lastmode = mode;
3022         mode = prevmode;
3023         List&lt;JCAnnotation&gt; annotations = buf.toList();
3024 
3025         return annotations;
3026     }
3027 
3028     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3029         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3030         return annotations;
3031     }
3032 
3033     /** ModifiersOpt = { Modifier }
3034      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3035      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3036      *           | &quot;@&quot; Annotation
3037      */
3038     protected JCModifiers modifiersOpt() {
3039         return modifiersOpt(null);
3040     }
3041     protected JCModifiers modifiersOpt(JCModifiers partial) {
3042         long flags;
3043         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3044         int pos;
3045         if (partial == null) {
3046             flags = 0;
3047             pos = token.pos;
3048         } else {
3049             flags = partial.flags;
3050             annotations.appendList(partial.annotations);
3051             pos = partial.pos;
3052         }
3053         if (token.deprecatedFlag()) {
3054             flags |= Flags.DEPRECATED;
3055         }
3056         int lastPos;
3057     loop:
3058         while (true) {
3059             long flag;
3060             switch (token.kind) {
3061             case PRIVATE     : flag = Flags.PRIVATE; break;
3062             case PROTECTED   : flag = Flags.PROTECTED; break;
3063             case PUBLIC      : flag = Flags.PUBLIC; break;
3064             case STATIC      : flag = Flags.STATIC; break;
3065             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3066             case FINAL       : flag = Flags.FINAL; break;
3067             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3068             case NATIVE      : flag = Flags.NATIVE; break;
3069             case VOLATILE    : flag = Flags.VOLATILE; break;
3070             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3071             case STRICTFP    : flag = Flags.STRICTFP; break;
3072             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3073             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3074             case ERROR       : flag = 0; nextToken(); break;
3075             default: break loop;
3076             }
3077             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3078             lastPos = token.pos;
3079             nextToken();
3080             if (flag == Flags.ANNOTATION) {
3081                 if (token.kind != INTERFACE) {
3082                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3083                     // if first modifier is an annotation, set pos to annotation&#39;s.
3084                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3085                         pos = ann.pos;
3086                     annotations.append(ann);
3087                     flag = 0;
3088                 }
3089             }
3090             flags |= flag;
3091         }
3092         switch (token.kind) {
3093         case ENUM: flags |= Flags.ENUM; break;
3094         case INTERFACE: flags |= Flags.INTERFACE; break;
3095         default: break;
3096         }
3097 
3098         /* A modifiers tree with no modifier tokens or annotations
3099          * has no text position. */
3100         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3101             pos = Position.NOPOS;
3102 
3103         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3104         if (pos != Position.NOPOS)
3105             storeEnd(mods, S.prevToken().endPos);
3106         return mods;
3107     }
3108 
3109     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3110      *
3111      * @param pos position of &quot;@&quot; token
3112      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3113      */
3114     JCAnnotation annotation(int pos, Tag kind) {
3115         // accept(AT); // AT consumed by caller
3116         if (kind == Tag.TYPE_ANNOTATION) {
3117             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3118         }
3119         JCTree ident = qualident(false);
3120         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3121         JCAnnotation ann;
3122         if (kind == Tag.ANNOTATION) {
3123             ann = F.at(pos).Annotation(ident, fieldValues);
3124         } else if (kind == Tag.TYPE_ANNOTATION) {
3125             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3126         } else {
3127             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3128         }
3129 
3130         storeEnd(ann, S.prevToken().endPos);
3131         return ann;
3132     }
3133 
3134     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3135         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3136     }
3137 
3138     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3139     List&lt;JCExpression&gt; annotationFieldValues() {
3140         accept(LPAREN);
3141         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3142         if (token.kind != RPAREN) {
3143             buf.append(annotationFieldValue());
3144             while (token.kind == COMMA) {
3145                 nextToken();
3146                 buf.append(annotationFieldValue());
3147             }
3148         }
3149         accept(RPAREN);
3150         return buf.toList();
3151     }
3152 
3153     /** AnnotationFieldValue    = AnnotationValue
3154      *                          | Identifier &quot;=&quot; AnnotationValue
3155      */
3156     JCExpression annotationFieldValue() {
3157         if (LAX_IDENTIFIER.accepts(token.kind)) {
3158             selectExprMode();
3159             JCExpression t1 = term1();
3160             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3161                 int pos = token.pos;
3162                 accept(EQ);
3163                 JCExpression v = annotationValue();
3164                 return toP(F.at(pos).Assign(t1, v));
3165             } else {
3166                 return t1;
3167             }
3168         }
3169         return annotationValue();
3170     }
3171 
3172     /* AnnotationValue          = ConditionalExpression
3173      *                          | Annotation
3174      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3175      */
3176     JCExpression annotationValue() {
3177         int pos;
3178         switch (token.kind) {
3179         case MONKEYS_AT:
3180             pos = token.pos;
3181             nextToken();
3182             return annotation(pos, Tag.ANNOTATION);
3183         case LBRACE:
3184             pos = token.pos;
3185             accept(LBRACE);
3186             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3187             if (token.kind == COMMA) {
3188                 nextToken();
3189             } else if (token.kind != RBRACE) {
3190                 buf.append(annotationValue());
3191                 while (token.kind == COMMA) {
3192                     nextToken();
3193                     if (token.kind == RBRACE) break;
3194                     buf.append(annotationValue());
3195                 }
3196             }
3197             accept(RBRACE);
3198             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3199         default:
3200             selectExprMode();
3201             return term1();
3202         }
3203     }
3204 
3205     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3206      */
3207     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3208                                                                          JCExpression type,
3209                                                                          T vdefs,
3210                                                                          boolean localDecl)
3211     {
3212         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3213     }
3214 
3215     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3216      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3217      *
3218      *  @param reqInit  Is an initializer always required?
3219      *  @param dc       The documentation comment for the variable declarations, or null.
3220      */
3221     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3222                                                                      JCModifiers mods,
3223                                                                      JCExpression type,
3224                                                                      Name name,
3225                                                                      boolean reqInit,
3226                                                                      Comment dc,
3227                                                                      T vdefs,
3228                                                                      boolean localDecl)
3229     {
3230         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3231         vdefs.append(head);
3232         while (token.kind == COMMA) {
3233             // All but last of multiple declarators subsume a comma
3234             storeEnd((JCTree)vdefs.last(), token.endPos);
3235             nextToken();
3236             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3237         }
3238         return vdefs;
3239     }
3240 
3241     /** VariableDeclarator = Ident VariableDeclaratorRest
3242      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3243      */
3244     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3245         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3246     }
3247 
3248     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3249      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3250      *
3251      *  @param reqInit  Is an initializer always required?
3252      *  @param dc       The documentation comment for the variable declarations, or null.
3253      */
3254     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3255                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3256         type = bracketsOpt(type);
3257         JCExpression init = null;
3258         if (token.kind == EQ) {
3259             nextToken();
3260             init = variableInitializer();
3261         }
3262         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3263         JCTree elemType = TreeInfo.innermostType(type, true);
3264         int startPos = Position.NOPOS;
3265         if (elemType.hasTag(IDENT)) {
3266             Name typeName = ((JCIdent)elemType).name;
3267             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3268                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3269                     //error - &#39;var&#39; and arrays
3270                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3271                 } else {
3272                     if(compound)
3273                         //error - &#39;var&#39; in compound local var decl
3274                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3275                     startPos = TreeInfo.getStartPos(mods);
3276                     if (startPos == Position.NOPOS)
3277                         startPos = TreeInfo.getStartPos(type);
3278                     //implicit type
3279                     type = null;
3280                 }
3281             }
3282         }
3283         JCVariableDecl result =
3284             toP(F.at(pos).VarDef(mods, name, type, init));
3285         attach(result, dc);
3286         result.startPos = startPos;
3287         return result;
3288     }
3289 
3290     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3291         switch (e.getTag()) {
3292             case IDENT:
3293                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3294             case TYPEARRAY:
3295                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3296             default:
3297                 return null;
3298         }
3299     }
3300 
3301     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3302         if (name == names.var) {
3303             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3304                 return Source.JDK10;
3305             } else if (shouldWarn) {
3306                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3307             }
3308         }
3309         if (name == names.yield) {
3310             if (allowYieldStatement) {
3311                 return Source.JDK14;
3312             } else if (shouldWarn) {
3313                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3314             }
3315         }
3316         if (name == names.record) {
3317             if (allowRecords) {
3318                 return Source.JDK14;
3319             } else if (shouldWarn) {
3320                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3321             }
3322         }
3323         return null;
3324     }
3325 
3326     /** VariableDeclaratorId = Ident BracketsOpt
3327      */
3328     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3329         return variableDeclaratorId(mods, type, false);
3330     }
3331     //where
3332     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3333         int pos = token.pos;
3334         Name name;
3335         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3336             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3337             name = token.name();
3338             nextToken();
3339         } else {
3340             if (allowThisIdent ||
3341                 !lambdaParameter ||
3342                 LAX_IDENTIFIER.accepts(token.kind) ||
3343                 mods.flags != Flags.PARAMETER ||
3344                 mods.annotations.nonEmpty()) {
3345                 JCExpression pn = qualident(false);
3346                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3347                     name = ((JCIdent)pn).name;
3348                 } else {
3349                     if (allowThisIdent) {
3350                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3351                             log.error(token.pos, Errors.VarargsAndReceiver);
3352                         }
3353                         if (token.kind == LBRACKET) {
3354                             log.error(token.pos, Errors.ArrayAndReceiver);
3355                         }
3356                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3357                             log.error(token.pos, Errors.WrongReceiver);
3358                         }
3359                     }
3360                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3361                 }
3362             } else {
3363                 /** if it is a lambda parameter and the token kind is not an identifier,
3364                  *  and there are no modifiers or annotations, then this means that the compiler
3365                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3366                  *  var or explicit parameters. So we assign the error name to the parameter name
3367                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3368                  *  a higher level.
3369                  */
3370                 name = names.empty;
3371             }
3372         }
3373         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3374                 token.kind == LBRACKET) {
3375             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3376         }
3377         type = bracketsOpt(type);
3378 
3379         return toP(F.at(pos).VarDef(mods, name, type, null));
3380     }
3381 
3382     /** Resources = Resource { &quot;;&quot; Resources }
3383      */
3384     List&lt;JCTree&gt; resources() {
3385         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3386         defs.append(resource());
3387         while (token.kind == SEMI) {
3388             // All but last of multiple declarators must subsume a semicolon
3389             storeEnd(defs.last(), token.endPos);
3390             int semiColonPos = token.pos;
3391             nextToken();
3392             if (token.kind == RPAREN) { // Optional trailing semicolon
3393                                        // after last resource
3394                 break;
3395             }
3396             defs.append(resource());
3397         }
3398         return defs.toList();
3399     }
3400 
3401     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3402      *           | Expression
3403      */
3404     protected JCTree resource() {
3405         int startPos = token.pos;
3406         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3407             JCModifiers mods = optFinal(Flags.FINAL);
3408             JCExpression t = parseType(true);
3409             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3410         }
3411         JCExpression t = term(EXPR | TYPE);
3412         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3413             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3414             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3415         } else {
3416             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3417             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3418                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3419             }
3420 
3421             return t;
3422         }
3423     }
3424 
3425     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3426      */
3427     public JCTree.JCCompilationUnit parseCompilationUnit() {
3428         Token firstToken = token;
3429         JCModifiers mods = null;
3430         boolean consumedToplevelDoc = false;
3431         boolean seenImport = false;
3432         boolean seenPackage = false;
3433         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3434         if (token.kind == MONKEYS_AT)
3435             mods = modifiersOpt();
3436 
3437         if (token.kind == PACKAGE) {
3438             int packagePos = token.pos;
3439             List&lt;JCAnnotation&gt; annotations = List.nil();
3440             seenPackage = true;
3441             if (mods != null) {
3442                 checkNoMods(mods.flags);
3443                 annotations = mods.annotations;
3444                 mods = null;
3445             }
3446             nextToken();
3447             JCExpression pid = qualident(false);
3448             accept(SEMI);
3449             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3450             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3451             consumedToplevelDoc = true;
3452             defs.append(pd);
3453         }
3454 
3455         boolean checkForImports = true;
3456         boolean firstTypeDecl = true;
3457         while (token.kind != EOF) {
3458             if (token.pos &lt;= endPosTable.errorEndPos) {
3459                 // error recovery
3460                 skip(checkForImports, false, false, false);
3461                 if (token.kind == EOF)
3462                     break;
3463             }
3464             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3465                 seenImport = true;
3466                 defs.append(importDeclaration());
3467             } else {
3468                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3469                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3470                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3471                     consumedToplevelDoc = true;
3472                 }
3473                 if (mods != null || token.kind != SEMI)
3474                     mods = modifiersOpt(mods);
3475                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3476                     ModuleKind kind = ModuleKind.STRONG;
3477                     if (token.name() == names.open) {
3478                         kind = ModuleKind.OPEN;
3479                         nextToken();
3480                     }
3481                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3482                         if (mods != null) {
3483                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3484                         }
3485                         defs.append(moduleDecl(mods, kind, docComment));
3486                         consumedToplevelDoc = true;
3487                         break;
3488                     } else if (kind != ModuleKind.STRONG) {
3489                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3490                     }
3491                 }
3492                 JCTree def = typeDeclaration(mods, docComment);
3493                 if (def instanceof JCExpressionStatement)
3494                     def = ((JCExpressionStatement)def).expr;
3495                 defs.append(def);
3496                 if (def instanceof JCClassDecl)
3497                     checkForImports = false;
3498                 mods = null;
3499                 firstTypeDecl = false;
3500             }
3501         }
3502         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3503         if (!consumedToplevelDoc)
3504             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3505         if (defs.isEmpty())
3506             storeEnd(toplevel, S.prevToken().endPos);
3507         if (keepDocComments)
3508             toplevel.docComments = docComments;
3509         if (keepLineMap)
3510             toplevel.lineMap = S.getLineMap();
3511         this.endPosTable.setParser(null); // remove reference to parser
3512         toplevel.endPositions = this.endPosTable;
3513         return toplevel;
3514     }
3515 
3516     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3517         int pos = token.pos;
3518         checkSourceLevel(Feature.MODULES);
3519 
3520         nextToken();
3521         JCExpression name = qualident(false);
3522         List&lt;JCDirective&gt; directives = null;
3523 
3524         accept(LBRACE);
3525         directives = moduleDirectiveList();
3526         accept(RBRACE);
3527         accept(EOF);
3528 
3529         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3530         attach(result, dc);
3531         return result;
3532     }
3533 
3534     List&lt;JCDirective&gt; moduleDirectiveList() {
3535         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3536         while (token.kind == IDENTIFIER) {
3537             int pos = token.pos;
3538             if (token.name() == names.requires) {
3539                 nextToken();
3540                 boolean isTransitive = false;
3541                 boolean isStaticPhase = false;
3542             loop:
3543                 while (true) {
3544                     switch (token.kind) {
3545                         case IDENTIFIER:
3546                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3547                                 Token t1 = S.token(1);
3548                                 if (t1.kind == SEMI || t1.kind == DOT) {
3549                                     break loop;
3550                                 }
3551                                 isTransitive = true;
3552                                 break;
3553                             } else {
3554                                 break loop;
3555                             }
3556                         case STATIC:
3557                             if (isStaticPhase) {
3558                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3559                             }
3560                             isStaticPhase = true;
3561                             break;
3562                         default:
3563                             break loop;
3564                     }
3565                     nextToken();
3566                 }
3567                 JCExpression moduleName = qualident(false);
3568                 accept(SEMI);
3569                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3570             } else if (token.name() == names.exports || token.name() == names.opens) {
3571                 boolean exports = token.name() == names.exports;
3572                 nextToken();
3573                 JCExpression pkgName = qualident(false);
3574                 List&lt;JCExpression&gt; moduleNames = null;
3575                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3576                     nextToken();
3577                     moduleNames = qualidentList(false);
3578                 }
3579                 accept(SEMI);
3580                 JCDirective d;
3581                 if (exports) {
3582                     d = F.at(pos).Exports(pkgName, moduleNames);
3583                 } else {
3584                     d = F.at(pos).Opens(pkgName, moduleNames);
3585                 }
3586                 defs.append(toP(d));
3587             } else if (token.name() == names.provides) {
3588                 nextToken();
3589                 JCExpression serviceName = qualident(false);
3590                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3591                     nextToken();
3592                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3593                     accept(SEMI);
3594                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3595                 } else {
3596                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3597                     skip(false, false, false, false);
3598                 }
3599             } else if (token.name() == names.uses) {
3600                 nextToken();
3601                 JCExpression service = qualident(false);
3602                 accept(SEMI);
3603                 defs.append(toP(F.at(pos).Uses(service)));
3604             } else {
3605                 setErrorEndPos(pos);
3606                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3607                 break;
3608             }
3609         }
3610         return defs.toList();
3611     }
3612 
3613     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3614      */
3615     protected JCTree importDeclaration() {
3616         int pos = token.pos;
3617         nextToken();
3618         boolean importStatic = false;
3619         if (token.kind == STATIC) {
3620             importStatic = true;
3621             nextToken();
3622         }
3623         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3624         do {
3625             int pos1 = token.pos;
3626             accept(DOT);
3627             if (token.kind == STAR) {
3628                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3629                 nextToken();
3630                 break;
3631             } else {
3632                 pid = toP(F.at(pos1).Select(pid, ident()));
3633             }
3634         } while (token.kind == DOT);
3635         accept(SEMI);
3636         return toP(F.at(pos).Import(pid, importStatic));
3637     }
3638 
3639     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3640      *                  | &quot;;&quot;
3641      */
3642     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3643         int pos = token.pos;
3644         if (mods == null &amp;&amp; token.kind == SEMI) {
3645             nextToken();
3646             return toP(F.at(pos).Skip());
3647         } else {
3648             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3649         }
3650     }
3651 
3652     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3653      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3654      *  @param mods     Any modifiers starting the class or interface declaration
3655      *  @param dc       The documentation comment for the class, or null.
3656      */
3657     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3658         if (token.kind == CLASS) {
3659             return classDeclaration(mods, dc);
3660         } if (isRecordStart()) {
3661             return recordDeclaration(mods, dc);
3662         } else if (token.kind == INTERFACE) {
3663             return interfaceDeclaration(mods, dc);
3664         } else if (token.kind == ENUM) {
3665             return enumDeclaration(mods, dc);
3666         } else {
3667             int pos = token.pos;
3668             List&lt;JCTree&gt; errs;
3669             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3670                 checkSourceLevel(Feature.RECORDS);
3671                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3672                 return toP(F.Exec(erroneousTree));
3673             } else {
3674                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3675                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3676                     setErrorEndPos(token.pos);
3677                 } else {
3678                     errs = List.of(mods);
3679                 }
3680                 final JCErroneous erroneousTree;
3681                 if (parseModuleInfo) {
3682                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3683                 } else {
3684                     if (allowRecords) {
3685                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3686                     } else {
3687                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3688                     }
3689                 }
3690                 return toP(F.Exec(erroneousTree));
3691             }
3692         }
3693     }
3694 
3695     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3696      *                     [IMPLEMENTS TypeList] ClassBody
3697      *  @param mods    The modifiers starting the class declaration
3698      *  @param dc       The documentation comment for the class, or null.
3699      */
3700     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3701         int pos = token.pos;
3702         accept(CLASS);
3703         Name name = typeName();
3704 
3705         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3706 
3707         JCExpression extending = null;
3708         if (token.kind == EXTENDS) {
3709             nextToken();
3710             extending = parseType();
3711         }
3712         List&lt;JCExpression&gt; implementing = List.nil();
3713         if (token.kind == IMPLEMENTS) {
3714             nextToken();
3715             implementing = typeList();
3716         }
3717         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3718         JCClassDecl result = toP(F.at(pos).ClassDef(
3719             mods, name, typarams, extending, implementing, defs));
3720         attach(result, dc);
3721         return result;
3722     }
3723 
3724     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3725         int pos = token.pos;
3726         nextToken();
3727         mods.flags |= Flags.RECORD;
3728         Name name = typeName();
3729 
3730         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3731 
3732         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3733 
3734         List&lt;JCExpression&gt; implementing = List.nil();
3735         if (token.kind == IMPLEMENTS) {
3736             nextToken();
3737             implementing = typeList();
3738         }
3739         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3740         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3741         for (JCVariableDecl field : headerFields) {
3742             fields.add(field);
3743         }
3744         for (JCTree def : defs) {
3745             if (def.hasTag(METHODDEF)) {
3746                 JCMethodDecl methDef = (JCMethodDecl) def;
3747                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3748                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3749                     for (JCVariableDecl param : headerFields) {
3750                         tmpParams.add(F.at(param)
3751                                 // we will get flags plus annotations from the record component
3752                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3753                                 param.name, param.vartype, null));
3754                     }
3755                     methDef.params = tmpParams.toList();
3756                 }
3757             }
3758         }
3759         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3760             JCVariableDecl field = fields.get(i);
3761             defs = defs.prepend(field);
3762         }
3763         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3764         attach(result, dc);
3765         return result;
3766     }
3767 
3768     Name typeName() {
3769         int pos = token.pos;
3770         Name name = ident();
3771         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3772         if (source != null) {
3773             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3774         }
3775         return name;
3776     }
3777 
3778     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3779      *                         [EXTENDS TypeList] InterfaceBody
3780      *  @param mods    The modifiers starting the interface declaration
3781      *  @param dc       The documentation comment for the interface, or null.
3782      */
3783     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3784         int pos = token.pos;
3785         accept(INTERFACE);
3786 
3787         Name name = typeName();
3788 
3789         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3790 
3791         List&lt;JCExpression&gt; extending = List.nil();
3792         if (token.kind == EXTENDS) {
3793             nextToken();
3794             extending = typeList();
3795         }
3796         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);
3797         JCClassDecl result = toP(F.at(pos).ClassDef(
3798             mods, name, typarams, null, extending, defs));
3799         attach(result, dc);
3800         return result;
3801     }
3802 
3803     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3804      *  @param mods    The modifiers starting the enum declaration
3805      *  @param dc       The documentation comment for the enum, or null.
3806      */
3807     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3808         int pos = token.pos;
3809         accept(ENUM);
3810 
3811         Name name = typeName();
3812 
3813         List&lt;JCExpression&gt; implementing = List.nil();
3814         if (token.kind == IMPLEMENTS) {
3815             nextToken();
3816             implementing = typeList();
3817         }
3818 
3819         List&lt;JCTree&gt; defs = enumBody(name);
3820         mods.flags |= Flags.ENUM;
3821         JCClassDecl result = toP(F.at(pos).
3822             ClassDef(mods, name, List.nil(),
3823                      null, implementing, defs));
3824         attach(result, dc);
3825         return result;
3826     }
3827 
3828     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3829      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3830      */
3831     List&lt;JCTree&gt; enumBody(Name enumName) {
3832         accept(LBRACE);
3833         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3834         boolean wasSemi = false;
3835         boolean hasStructuralErrors = false;
3836         boolean wasError = false;
3837         if (token.kind == COMMA) {
3838             nextToken();
3839             if (token.kind == SEMI) {
3840                 wasSemi = true;
3841                 nextToken();
3842             } else if (token.kind != RBRACE) {
3843                 reportSyntaxError(S.prevToken().endPos,
3844                                   Errors.Expected2(RBRACE, SEMI));
3845                 wasError = true;
3846             }
3847         }
3848         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
3849             if (token.kind == SEMI) {
3850                 accept(SEMI);
3851                 wasSemi = true;
3852                 if (token.kind == RBRACE || token.kind == EOF) break;
3853             }
3854             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
3855             if (memberType == EnumeratorEstimate.UNKNOWN) {
3856                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
3857                                      : EnumeratorEstimate.ENUMERATOR;
3858             }
3859             if (memberType == EnumeratorEstimate.ENUMERATOR) {
3860                 wasError = false;
3861                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
3862                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
3863                     hasStructuralErrors = true;
3864                 }
3865                 defs.append(enumeratorDeclaration(enumName));
3866                 if (token.pos &lt;= endPosTable.errorEndPos) {
3867                     // error recovery
3868                    skip(false, true, true, false);
3869                 } else {
3870                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
3871                         if (token.kind == COMMA) {
3872                             nextToken();
3873                         } else {
3874                             setErrorEndPos(token.pos);
3875                             reportSyntaxError(S.prevToken().endPos,
3876                                               Errors.Expected3(COMMA, RBRACE, SEMI));
3877                             wasError = true;
3878                         }
3879                     }
3880                 }
3881             } else {
3882                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
3883                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
3884                     hasStructuralErrors = true;
3885                 }
3886                 wasError = false;
3887                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
3888                                                                 false, false));
3889                 if (token.pos &lt;= endPosTable.errorEndPos) {
3890                     // error recovery
3891                    skip(false, true, true, false);
3892                 }
3893             }
3894         }
3895         accept(RBRACE);
3896         return defs.toList();
3897     }
3898 
3899     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
3900         // if we are seeing a record declaration inside of an enum we want the same error message as expected for a
3901         // let&#39;s say an interface declaration inside an enum
3902         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName &amp;&amp;
3903                 (!allowRecords || !isRecordStart())) {
3904             Token next = S.token(1);
3905             switch (next.kind) {
3906                 case LPAREN: case LBRACE: case COMMA: case SEMI:
3907                     return EnumeratorEstimate.ENUMERATOR;
3908             }
3909         }
3910         switch (token.kind) {
3911             case IDENTIFIER: case MONKEYS_AT: case LT:
3912                 if (token.kind == IDENTIFIER) {
3913                     if (allowRecords &amp;&amp; isRecordStart()) {
3914                         return EnumeratorEstimate.MEMBER;
3915                     }
3916                 }
3917                 return EnumeratorEstimate.UNKNOWN;
3918             default:
3919                 return EnumeratorEstimate.MEMBER;
3920         }
3921     }
3922 
3923     private enum EnumeratorEstimate {
3924         ENUMERATOR,
3925         MEMBER,
3926         UNKNOWN;
3927     }
3928 
3929     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
3930      */
3931     JCTree enumeratorDeclaration(Name enumName) {
3932         Comment dc = token.comment(CommentStyle.JAVADOC);
3933         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
3934         if (token.deprecatedFlag()) {
3935             flags |= Flags.DEPRECATED;
3936         }
3937         int pos = token.pos;
3938         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
3939         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
3940         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
3941         int identPos = token.pos;
3942         Name name = ident();
3943         int createPos = token.pos;
3944         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
3945             ? arguments() : List.nil();
3946         JCClassDecl body = null;
3947         if (token.kind == LBRACE) {
3948             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
3949             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
3950             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
3951         }
3952         if (args.isEmpty() &amp;&amp; body == null)
3953             createPos = identPos;
3954         JCIdent ident = F.at(identPos).Ident(enumName);
3955         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
3956         if (createPos != identPos)
3957             storeEnd(create, S.prevToken().endPos);
3958         ident = F.at(identPos).Ident(enumName);
3959         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
3960         attach(result, dc);
3961         return result;
3962     }
3963 
3964     /** TypeList = Type {&quot;,&quot; Type}
3965      */
3966     List&lt;JCExpression&gt; typeList() {
3967         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
3968         ts.append(parseType());
3969         while (token.kind == COMMA) {
3970             nextToken();
3971             ts.append(parseType());
3972         }
3973         return ts.toList();
3974     }
3975 
3976     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
3977      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
3978      */
3979     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
3980         accept(LBRACE);
3981         if (token.pos &lt;= endPosTable.errorEndPos) {
3982             // error recovery
3983             skip(false, true, false, false);
3984             if (token.kind == LBRACE)
3985                 nextToken();
3986         }
3987         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3988         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
3989             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
3990             if (token.pos &lt;= endPosTable.errorEndPos) {
3991                // error recovery
3992                skip(false, true, true, false);
3993            }
3994         }
3995         accept(RBRACE);
3996         return defs.toList();
3997     }
3998 
3999     /** ClassBodyDeclaration =
4000      *      &quot;;&quot;
4001      *    | [STATIC] Block
4002      *    | ModifiersOpt
4003      *      ( Type Ident
4004      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4005      *      | VOID Ident VoidMethodDeclaratorRest
4006      *      | TypeParameters [Annotations]
4007      *        ( Type Ident MethodDeclaratorRest
4008      *        | VOID Ident VoidMethodDeclaratorRest
4009      *        )
4010      *      | Ident ConstructorDeclaratorRest
4011      *      | TypeParameters Ident ConstructorDeclaratorRest
4012      *      | ClassOrInterfaceOrEnumDeclaration
4013      *      )
4014      *  InterfaceBodyDeclaration =
4015      *      &quot;;&quot;
4016      *    | ModifiersOpt
4017      *      ( Type Ident
4018      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4019      *      | VOID Ident MethodDeclaratorRest
4020      *      | TypeParameters [Annotations]
4021      *        ( Type Ident MethodDeclaratorRest
4022      *        | VOID Ident VoidMethodDeclaratorRest
4023      *        )
4024      *      | ClassOrInterfaceOrEnumDeclaration
4025      *      )
4026      *
4027      */
4028     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4029         if (token.kind == SEMI) {
4030             nextToken();
4031             return List.nil();
4032         } else {
4033             Comment dc = token.comment(CommentStyle.JAVADOC);
4034             int pos = token.pos;
4035             JCModifiers mods = modifiersOpt();
4036             if (token.kind == CLASS ||
4037                 allowRecords &amp;&amp; isRecordStart() ||
4038                 token.kind == INTERFACE ||
4039                 token.kind == ENUM) {
4040                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4041             } else if (token.kind == LBRACE &amp;&amp;
4042                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4043                        mods.annotations.isEmpty()) {
4044                 if (isInterface) {
4045                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4046                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4047                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4048                 }
4049                 return List.of(block(pos, mods.flags));
4050             } else {
4051                 pos = token.pos;
4052                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4053                 // if there are type parameters but no modifiers, save the start
4054                 // position of the method in the modifiers.
4055                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4056                     mods.pos = pos;
4057                     storeEnd(mods, pos);
4058                 }
4059                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4060 
4061                 if (annosAfterParams.nonEmpty()) {
4062                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4063                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4064                     if (mods.pos == Position.NOPOS)
4065                         mods.pos = mods.annotations.head.pos;
4066                 }
4067 
4068                 Token tk = token;
4069                 pos = token.pos;
4070                 JCExpression type;
4071                 boolean isVoid = token.kind == VOID;
4072                 if (isVoid) {
4073                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4074                     nextToken();
4075                 } else {
4076                     // method returns types are un-annotated types
4077                     type = unannotatedType(false);
4078                 }
4079                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4080                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4081                     if (isInterface || tk.name() != className)
4082                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4083                     else if (annosAfterParams.nonEmpty())
4084                         illegal(annosAfterParams.head.pos);
4085                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4086                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4087                     }
4088                     return List.of(methodDeclaratorRest(
4089                         pos, mods, null, names.init, typarams,
4090                         isInterface, true, isRecord, dc));
4091                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4092                     // trying to define a compact constructor with a throws clause
4093                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4094                             Errors.InvalidCanonicalConstructorInRecord(
4095                                     Fragments.Compact,
4096                                     className,
4097                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4098                     skip(false, true, false, false);
4099                     return List.of(methodDeclaratorRest(
4100                             pos, mods, null, names.init, typarams,
4101                             isInterface, true, isRecord, dc));
4102                 } else {
4103                     pos = token.pos;
4104                     Name name = ident();
4105                     if (token.kind == LPAREN) {
4106                         return List.of(methodDeclaratorRest(
4107                             pos, mods, type, name, typarams,
4108                             isInterface, isVoid, false, dc));
4109                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4110                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4111                         List&lt;JCTree&gt; defs =
4112                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4113                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4114                         accept(SEMI);
4115                         storeEnd(defs.last(), S.prevToken().endPos);
4116                         return defs;
4117                     } else {
4118                             int errPos = pos;
4119                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4120                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4121                             accept(SEMI);
4122                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4123                         }
4124                     } else {
4125                         pos = token.pos;
4126                         List&lt;JCTree&gt; err;
4127                         if (isVoid || typarams.nonEmpty()) {
4128                             JCMethodDecl m =
4129                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4130                                                             List.nil(), List.nil(), null, null));
4131                             attach(m, dc);
4132                             err = List.of(m);
4133                         } else {
4134                             err = List.nil();
4135                         }
4136                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4137                     }
4138                 }
4139             }
4140         }
4141     }
4142 
4143     protected boolean isRecordStart() {
4144      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;
4145             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4146              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4147              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
4148           checkSourceLevel(Feature.RECORDS);
4149           return true;
4150     } else {
4151        return false;
4152    }
4153 }
4154 
4155     /** MethodDeclaratorRest =
4156      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4157      *  VoidMethodDeclaratorRest =
4158      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4159      *  ConstructorDeclaratorRest =
4160      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4161      */
4162     protected JCTree methodDeclaratorRest(int pos,
4163                               JCModifiers mods,
4164                               JCExpression type,
4165                               Name name,
4166                               List&lt;JCTypeParameter&gt; typarams,
4167                               boolean isInterface, boolean isVoid,
4168                               boolean isRecord,
4169                               Comment dc) {
4170         if (isInterface) {
4171             if ((mods.flags &amp; Flags.STATIC) != 0) {
4172                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4173             }
4174             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4175                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4176             }
4177         }
4178         JCVariableDecl prevReceiverParam = this.receiverParam;
4179         try {
4180             this.receiverParam = null;
4181             // Parsing formalParameters sets the receiverParam, if present
4182             List&lt;JCVariableDecl&gt; params = List.nil();
4183             List&lt;JCExpression&gt; thrown = List.nil();
4184             if (!isRecord || name != names.init || token.kind == LPAREN) {
4185                 params = formalParameters();
4186                 if (!isVoid) type = bracketsOpt(type);
4187                 if (token.kind == THROWS) {
4188                     nextToken();
4189                     thrown = qualidentList(true);
4190                 }
4191             }
4192             JCBlock body = null;
4193             JCExpression defaultValue;
4194             if (token.kind == LBRACE) {
4195                 body = block();
4196                 defaultValue = null;
4197             } else {
4198                 if (token.kind == DEFAULT) {
4199                     accept(DEFAULT);
4200                     defaultValue = annotationValue();
4201                 } else {
4202                     defaultValue = null;
4203                 }
4204                 accept(SEMI);
4205                 if (token.pos &lt;= endPosTable.errorEndPos) {
4206                     // error recovery
4207                     skip(false, true, false, false);
4208                     if (token.kind == LBRACE) {
4209                         body = block();
4210                     }
4211                 }
4212             }
4213 
4214             JCMethodDecl result =
4215                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4216                                             receiverParam, params, thrown,
4217                                             body, defaultValue));
4218             attach(result, dc);
4219             return result;
4220         } finally {
4221             this.receiverParam = prevReceiverParam;
4222         }
4223     }
4224 
4225     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4226      */
4227     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4228         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4229 
4230         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4231         JCExpression qi = qualident(allowAnnos);
4232         if (!typeAnnos.isEmpty()) {
4233             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4234             ts.append(at);
4235         } else {
4236             ts.append(qi);
4237         }
4238         while (token.kind == COMMA) {
4239             nextToken();
4240 
4241             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4242             qi = qualident(allowAnnos);
4243             if (!typeAnnos.isEmpty()) {
4244                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4245                 ts.append(at);
4246             } else {
4247                 ts.append(qi);
4248             }
4249         }
4250         return ts.toList();
4251     }
4252 
4253     /**
4254      *  {@literal
4255      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4256      *  }
4257      */
4258     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4259         if (token.kind == LT) {
4260             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4261             nextToken();
4262             typarams.append(typeParameter());
4263             while (token.kind == COMMA) {
4264                 nextToken();
4265                 typarams.append(typeParameter());
4266             }
4267             accept(GT);
4268             return typarams.toList();
4269         } else {
4270             return List.nil();
4271         }
4272     }
4273 
4274     /**
4275      *  {@literal
4276      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4277      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4278      *  TypeVariable = Ident
4279      *  }
4280      */
4281     JCTypeParameter typeParameter() {
4282         int pos = token.pos;
4283         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4284         Name name = typeName();
4285         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4286         if (token.kind == EXTENDS) {
4287             nextToken();
4288             bounds.append(parseType());
4289             while (token.kind == AMP) {
4290                 nextToken();
4291                 bounds.append(parseType());
4292             }
4293         }
4294         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4295     }
4296 
4297     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4298      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4299      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4300      */
4301     List&lt;JCVariableDecl&gt; formalParameters() {
4302         return formalParameters(false, false);
4303     }
4304     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {
4305         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4306         JCVariableDecl lastParam;
4307         accept(LPAREN);
4308         if (token.kind != RPAREN) {
4309             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;
4310             lastParam = formalParameter(lambdaParameters, recordComponents);
4311             if (lastParam.nameexpr != null) {
4312                 this.receiverParam = lastParam;
4313             } else {
4314                 params.append(lastParam);
4315             }
4316             this.allowThisIdent = false;
4317             while (token.kind == COMMA) {
4318                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4319                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4320                 }
4321                 nextToken();
4322                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));
4323             }
4324         }
4325         if (token.kind == RPAREN) {
4326             nextToken();
4327         } else {
4328             setErrorEndPos(token.pos);
4329             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4330         }
4331         return params.toList();
4332     }
4333 
4334     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4335         if (hasParens) {
4336             accept(LPAREN);
4337         }
4338         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4339         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4340             params.append(implicitParameter());
4341             while (token.kind == COMMA) {
4342                 nextToken();
4343                 params.append(implicitParameter());
4344             }
4345         }
4346         if (hasParens) {
4347             accept(RPAREN);
4348         }
4349         return params.toList();
4350     }
4351 
4352     JCModifiers optFinal(long flags) {
4353         JCModifiers mods = modifiersOpt();
4354         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4355         mods.flags |= flags;
4356         return mods;
4357     }
4358 
4359     /**
4360      * Inserts the annotations (and possibly a new array level)
4361      * to the left-most type in an array or nested type.
4362      *
4363      * When parsing a type like {@code @B Outer.Inner @A []}, the
4364      * {@code @A} annotation should target the array itself, while
4365      * {@code @B} targets the nested type {@code Outer}.
4366      *
4367      * Currently the parser parses the annotation first, then
4368      * the array, and then inserts the annotation to the left-most
4369      * nested type.
4370      *
4371      * When {@code createNewLevel} is true, then a new array
4372      * level is inserted as the most inner type, and have the
4373      * annotations target it.  This is useful in the case of
4374      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4375      * first parses the type {@code String @A []} then inserts
4376      * a new array level with {@code @B} annotation.
4377      */
4378     private JCExpression insertAnnotationsToMostInner(
4379             JCExpression type, List&lt;JCAnnotation&gt; annos,
4380             boolean createNewLevel) {
4381         int origEndPos = getEndPos(type);
4382         JCExpression mostInnerType = type;
4383         JCArrayTypeTree mostInnerArrayType = null;
4384         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4385             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4386             mostInnerType = mostInnerArrayType.elemtype;
4387         }
4388 
4389         if (createNewLevel) {
4390             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4391         }
4392 
4393         JCExpression mostInnerTypeToReturn = mostInnerType;
4394         if (annos.nonEmpty()) {
4395             JCExpression lastToModify = mostInnerType;
4396 
4397             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4398                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4399                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4400                     lastToModify = mostInnerType;
4401                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4402                 }
4403                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4404                     lastToModify = mostInnerType;
4405                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4406                 }
4407             }
4408 
4409             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4410 
4411             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4412                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4413             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4414                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4415             } else {
4416                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4417                 mostInnerTypeToReturn = mostInnerType;
4418             }
4419         }
4420 
4421         if (mostInnerArrayType == null) {
4422             return mostInnerTypeToReturn;
4423         } else {
4424             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4425             storeEnd(type, origEndPos);
4426             return type;
4427         }
4428     }
4429 
4430     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4431      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4432      */
4433     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {
4434         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();
4435         if (recordComponent &amp;&amp; mods.flags != 0) {
4436             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4437         }
4438         if (recordComponent) {
4439             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4440         }
4441         // need to distinguish between vararg annos and array annos
4442         // look at typeAnnotationsPushedBack comment
4443         this.permitTypeAnnotationsPushBack = true;
4444         JCExpression type = parseType(lambdaParameter);
4445         this.permitTypeAnnotationsPushBack = false;
4446 
4447         if (token.kind == ELLIPSIS) {
4448             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4449             typeAnnotationsPushedBack = List.nil();
4450             mods.flags |= Flags.VARARGS;
4451             // insert var arg type annotations
4452             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4453             nextToken();
4454         } else {
4455             // if not a var arg, then typeAnnotationsPushedBack should be null
4456             if (typeAnnotationsPushedBack.nonEmpty()) {
4457                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4458             }
4459             typeAnnotationsPushedBack = List.nil();
4460         }
4461         return variableDeclaratorId(mods, type, lambdaParameter);
4462     }
4463 
4464     protected JCVariableDecl implicitParameter() {
4465         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4466         return variableDeclaratorId(mods, null, true);
4467     }
4468 
4469 /* ---------- auxiliary methods -------------- */
4470     /** Check that given tree is a legal expression statement.
4471      */
4472     protected JCExpression checkExprStat(JCExpression t) {
4473         if (!TreeInfo.isExpressionStatement(t)) {
4474             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4475             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4476             return ret;
4477         } else {
4478             return t;
4479         }
4480     }
4481 
4482     /** Return precedence of operator represented by token,
4483      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4484      */
4485     static int prec(TokenKind token) {
4486         JCTree.Tag oc = optag(token);
4487         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4488     }
4489 
4490     /**
4491      * Return the lesser of two positions, making allowance for either one
4492      * being unset.
4493      */
4494     static int earlier(int pos1, int pos2) {
4495         if (pos1 == Position.NOPOS)
4496             return pos2;
4497         if (pos2 == Position.NOPOS)
4498             return pos1;
4499         return (pos1 &lt; pos2 ? pos1 : pos2);
4500     }
4501 
4502     /** Return operation tag of binary operator represented by token,
4503      *  No_TAG if token is not a binary operator.
4504      */
4505     static JCTree.Tag optag(TokenKind token) {
4506         switch (token) {
4507         case BARBAR:
4508             return OR;
4509         case AMPAMP:
4510             return AND;
4511         case BAR:
4512             return BITOR;
4513         case BAREQ:
4514             return BITOR_ASG;
4515         case CARET:
4516             return BITXOR;
4517         case CARETEQ:
4518             return BITXOR_ASG;
4519         case AMP:
4520             return BITAND;
4521         case AMPEQ:
4522             return BITAND_ASG;
4523         case EQEQ:
4524             return JCTree.Tag.EQ;
4525         case BANGEQ:
4526             return NE;
4527         case LT:
4528             return JCTree.Tag.LT;
4529         case GT:
4530             return JCTree.Tag.GT;
4531         case LTEQ:
4532             return LE;
4533         case GTEQ:
4534             return GE;
4535         case LTLT:
4536             return SL;
4537         case LTLTEQ:
4538             return SL_ASG;
4539         case GTGT:
4540             return SR;
4541         case GTGTEQ:
4542             return SR_ASG;
4543         case GTGTGT:
4544             return USR;
4545         case GTGTGTEQ:
4546             return USR_ASG;
4547         case PLUS:
4548             return JCTree.Tag.PLUS;
4549         case PLUSEQ:
4550             return PLUS_ASG;
4551         case SUB:
4552             return MINUS;
4553         case SUBEQ:
4554             return MINUS_ASG;
4555         case STAR:
4556             return MUL;
4557         case STAREQ:
4558             return MUL_ASG;
4559         case SLASH:
4560             return DIV;
4561         case SLASHEQ:
4562             return DIV_ASG;
4563         case PERCENT:
4564             return MOD;
4565         case PERCENTEQ:
4566             return MOD_ASG;
4567         case INSTANCEOF:
4568             return TYPETEST;
4569         default:
4570             return NO_TAG;
4571         }
4572     }
4573 
4574     /** Return operation tag of unary operator represented by token,
4575      *  No_TAG if token is not a binary operator.
4576      */
4577     static JCTree.Tag unoptag(TokenKind token) {
4578         switch (token) {
4579         case PLUS:
4580             return POS;
4581         case SUB:
4582             return NEG;
4583         case BANG:
4584             return NOT;
4585         case TILDE:
4586             return COMPL;
4587         case PLUSPLUS:
4588             return PREINC;
4589         case SUBSUB:
4590             return PREDEC;
4591         default:
4592             return NO_TAG;
4593         }
4594     }
4595 
4596     /** Return type tag of basic type represented by token,
4597      *  NONE if token is not a basic type identifier.
4598      */
4599     static TypeTag typetag(TokenKind token) {
4600         switch (token) {
4601         case BYTE:
4602             return TypeTag.BYTE;
4603         case CHAR:
4604             return TypeTag.CHAR;
4605         case SHORT:
4606             return TypeTag.SHORT;
4607         case INT:
4608             return TypeTag.INT;
4609         case LONG:
4610             return TypeTag.LONG;
4611         case FLOAT:
4612             return TypeTag.FLOAT;
4613         case DOUBLE:
4614             return TypeTag.DOUBLE;
4615         case BOOLEAN:
4616             return TypeTag.BOOLEAN;
4617         default:
4618             return TypeTag.NONE;
4619         }
4620     }
4621 
4622     void checkSourceLevel(Feature feature) {
4623         checkSourceLevel(token.pos, feature);
4624     }
4625 
4626     protected void checkSourceLevel(int pos, Feature feature) {
4627         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4628             //preview feature without --preview flag, error
4629             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4630         } else if (!feature.allowedInSource(source)) {
4631             //incompatible source level, error
4632             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4633         } else if (preview.isPreview(feature)) {
4634             //use of preview feature, warn
4635             preview.warnPreview(pos, feature);
4636         }
4637     }
4638 
4639     /*
4640      * a functional source tree and end position mappings
4641      */
4642     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4643 
4644         private final IntHashTable endPosMap;
4645 
4646         SimpleEndPosTable(JavacParser parser) {
4647             super(parser);
4648             endPosMap = new IntHashTable();
4649         }
4650 
4651         public void storeEnd(JCTree tree, int endpos) {
4652             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4653                                  endPosMap.lookup(tree));
4654         }
4655 
4656         protected &lt;T extends JCTree&gt; T to(T t) {
4657             storeEnd(t, parser.token.endPos);
4658             return t;
4659         }
4660 
4661         protected &lt;T extends JCTree&gt; T toP(T t) {
4662             storeEnd(t, parser.S.prevToken().endPos);
4663             return t;
4664         }
4665 
4666         public int getEndPos(JCTree tree) {
4667             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4668             // As long as Position.NOPOS==-1, this just returns value.
4669             return (value == -1) ? Position.NOPOS : value;
4670         }
4671 
4672         public int replaceTree(JCTree oldTree, JCTree newTree) {
4673             int pos = endPosMap.remove(oldTree);
4674             if (pos != -1) {
4675                 storeEnd(newTree, pos);
4676                 return pos;
4677             }
4678             return Position.NOPOS;
4679         }
4680     }
4681 
4682     /*
4683      * a default skeletal implementation without any mapping overhead.
4684      */
4685     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4686 
4687         EmptyEndPosTable(JavacParser parser) {
4688             super(parser);
4689         }
4690 
4691         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4692 
4693         protected &lt;T extends JCTree&gt; T to(T t) {
4694             return t;
4695         }
4696 
4697         protected &lt;T extends JCTree&gt; T toP(T t) {
4698             return t;
4699         }
4700 
4701         public int getEndPos(JCTree tree) {
4702             return Position.NOPOS;
4703         }
4704 
4705         public int replaceTree(JCTree oldTree, JCTree newTree) {
4706             return Position.NOPOS;
4707         }
4708 
4709     }
4710 
4711     protected static abstract class AbstractEndPosTable implements EndPosTable {
4712         /**
4713          * The current parser.
4714          */
4715         protected JavacParser parser;
4716 
4717         /**
4718          * Store the last error position.
4719          */
4720         public int errorEndPos = Position.NOPOS;
4721 
4722         public AbstractEndPosTable(JavacParser parser) {
4723             this.parser = parser;
4724         }
4725 
4726         /**
4727          * Store current token&#39;s ending position for a tree, the value of which
4728          * will be the greater of last error position and the ending position of
4729          * the current token.
4730          * @param t The tree.
4731          */
4732         protected abstract &lt;T extends JCTree&gt; T to(T t);
4733 
4734         /**
4735          * Store current token&#39;s ending position for a tree, the value of which
4736          * will be the greater of last error position and the ending position of
4737          * the previous token.
4738          * @param t The tree.
4739          */
4740         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4741 
4742         /**
4743          * Set the error position during the parsing phases, the value of which
4744          * will be set only if it is greater than the last stored error position.
4745          * @param errPos The error position
4746          */
4747         public void setErrorEndPos(int errPos) {
4748             if (errPos &gt; errorEndPos) {
4749                 errorEndPos = errPos;
4750             }
4751         }
4752 
4753         public void setParser(JavacParser parser) {
4754             this.parser = parser;
4755         }
4756     }
4757 }
    </pre>
  </body>
</html>
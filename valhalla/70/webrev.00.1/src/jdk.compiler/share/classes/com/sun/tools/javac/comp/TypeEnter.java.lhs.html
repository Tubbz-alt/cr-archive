<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.HashSet;
  29 import java.util.Set;
  30 import java.util.function.BiConsumer;
  31 
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Lint.LintCategory;
  36 import com.sun.tools.javac.code.Scope.ImportFilter;
  37 import com.sun.tools.javac.code.Scope.NamedImportScope;
  38 import com.sun.tools.javac.code.Scope.StarImportScope;
  39 import com.sun.tools.javac.code.Scope.WriteableScope;
  40 import com.sun.tools.javac.code.Source.Feature;
  41 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
<a name="1" id="anc1"></a>
  42 import com.sun.tools.javac.tree.*;
  43 import com.sun.tools.javac.util.*;
  44 import com.sun.tools.javac.util.DefinedBy.Api;
  45 
  46 import com.sun.tools.javac.code.Symbol.*;
  47 import com.sun.tools.javac.code.Type.*;
  48 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  49 import com.sun.tools.javac.tree.JCTree.*;
  50 
  51 import static com.sun.tools.javac.code.Flags.*;
  52 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  53 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  54 import static com.sun.tools.javac.code.Kinds.Kind.*;
  55 import static com.sun.tools.javac.code.TypeTag.CLASS;
  56 import static com.sun.tools.javac.code.TypeTag.ERROR;
  57 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  58 
  59 import static com.sun.tools.javac.code.TypeTag.*;
  60 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  61 
  62 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  63 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  64 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  65 
  66 /** This is the second phase of Enter, in which classes are completed
  67  *  by resolving their headers and entering their members in the into
  68  *  the class scope. See Enter for an overall overview.
  69  *
  70  *  This class uses internal phases to process the classes. When a phase
  71  *  processes classes, the lower phases are not invoked until all classes
  72  *  pass through the current phase. Note that it is possible that upper phases
  73  *  are run due to recursive completion. The internal phases are:
  74  *  - ImportPhase: shallow pass through imports, adds information about imports
  75  *                 the NamedImportScope and StarImportScope, but avoids queries
  76  *                 about class hierarchy.
  77  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  78  *                    type parameters of the class or type argument of the supertypes.
  79  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
  80  *                 type parameters, attributing supertypes including type arguments
  81  *                 and scheduling full annotation attribution. This phase also adds
  82  *                 a synthetic default constructor if needed and synthetic &quot;this&quot; field.
  83  *  - MembersPhase: resolves headers for fields, methods and constructors in the given class.
  84  *                  Also generates synthetic enum members.
  85  *
  86  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  87  *  If you write code that depends on this, you do so at your own risk.
  88  *  This code and its internal interfaces are subject to change or
  89  *  deletion without notice.&lt;/b&gt;
  90  */
  91 public class TypeEnter implements Completer {
  92     protected static final Context.Key&lt;TypeEnter&gt; typeEnterKey = new Context.Key&lt;&gt;();
  93 
  94     /** A switch to determine whether we check for package/class conflicts
  95      */
  96     final static boolean checkClash = true;
  97 
  98     private final Names names;
  99     private final Enter enter;
 100     private final MemberEnter memberEnter;
 101     private final Log log;
 102     private final Check chk;
 103     private final Attr attr;
 104     private final Symtab syms;
 105     private final TreeMaker make;
 106     private final Todo todo;
 107     private final Annotate annotate;
 108     private final TypeAnnotations typeAnnotations;
 109     private final Types types;
 110     private final JCDiagnostic.Factory diags;
 111     private final DeferredLintHandler deferredLintHandler;
 112     private final Lint lint;
 113     private final TypeEnvs typeEnvs;
 114     private final Dependencies dependencies;
 115 
 116     public static TypeEnter instance(Context context) {
 117         TypeEnter instance = context.get(typeEnterKey);
 118         if (instance == null)
 119             instance = new TypeEnter(context);
 120         return instance;
 121     }
 122 
 123     protected TypeEnter(Context context) {
 124         context.put(typeEnterKey, this);
 125         names = Names.instance(context);
 126         enter = Enter.instance(context);
 127         memberEnter = MemberEnter.instance(context);
 128         log = Log.instance(context);
 129         chk = Check.instance(context);
 130         attr = Attr.instance(context);
 131         syms = Symtab.instance(context);
 132         make = TreeMaker.instance(context);
 133         todo = Todo.instance(context);
 134         annotate = Annotate.instance(context);
 135         typeAnnotations = TypeAnnotations.instance(context);
 136         types = Types.instance(context);
 137         diags = JCDiagnostic.Factory.instance(context);
 138         deferredLintHandler = DeferredLintHandler.instance(context);
 139         lint = Lint.instance(context);
 140         typeEnvs = TypeEnvs.instance(context);
 141         dependencies = Dependencies.instance(context);
 142         Source source = Source.instance(context);
 143         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 144         allowDeprecationOnImport = Feature.DEPRECATION_ON_IMPORT.allowedInSource(source);
 145     }
 146 
 147     /** Switch: support type annotations.
 148      */
 149     boolean allowTypeAnnos;
 150 
 151     /**
 152      * Switch: should deprecation warnings be issued on import
 153      */
 154     boolean allowDeprecationOnImport;
 155 
 156     /** A flag to disable completion from time to time during member
 157      *  enter, as we only need to look up types.  This avoids
 158      *  unnecessarily deep recursion.
 159      */
 160     boolean completionEnabled = true;
 161 
 162     /* Verify Imports:
 163      */
 164     protected void ensureImportsChecked(List&lt;JCCompilationUnit&gt; trees) {
 165         // if there remain any unimported toplevels (these must have
 166         // no classes at all), process their import statements as well.
 167         for (JCCompilationUnit tree : trees) {
 168             if (!tree.starImportScope.isFilled()) {
 169                 Env&lt;AttrContext&gt; topEnv = enter.topLevelEnv(tree);
 170                 finishImports(tree, () -&gt; { completeClass.resolveImports(tree, topEnv); });
 171             }
 172         }
 173     }
 174 
 175 /* ********************************************************************
 176  * Source completer
 177  *********************************************************************/
 178 
 179     /** Complete entering a class.
 180      *  @param sym         The symbol of the class to be completed.
 181      */
 182     @Override
 183     public void complete(Symbol sym) throws CompletionFailure {
 184         // Suppress some (recursive) MemberEnter invocations
 185         if (!completionEnabled) {
 186             // Re-install same completer for next time around and return.
 187             Assert.check((sym.flags() &amp; Flags.COMPOUND) == 0);
 188             sym.completer = this;
 189             return;
 190         }
 191 
 192         try {
 193             annotate.blockAnnotations();
 194             sym.flags_field |= UNATTRIBUTED;
 195 
 196             List&lt;Env&lt;AttrContext&gt;&gt; queue;
 197 
 198             dependencies.push((ClassSymbol) sym, CompletionCause.MEMBER_ENTER);
 199             try {
 200                 queue = completeClass.completeEnvs(List.of(typeEnvs.get((ClassSymbol) sym)));
 201             } finally {
 202                 dependencies.pop();
 203             }
 204 
 205             if (!queue.isEmpty()) {
 206                 Set&lt;JCCompilationUnit&gt; seen = new HashSet&lt;&gt;();
 207 
 208                 for (Env&lt;AttrContext&gt; env : queue) {
 209                     if (env.toplevel.defs.contains(env.enclClass) &amp;&amp; seen.add(env.toplevel)) {
 210                         finishImports(env.toplevel, () -&gt; {});
 211                     }
 212                 }
 213             }
 214         } finally {
 215             annotate.unblockAnnotations();
 216         }
 217     }
 218 
 219     void finishImports(JCCompilationUnit toplevel, Runnable resolve) {
 220         JavaFileObject prev = log.useSource(toplevel.sourcefile);
 221         try {
 222             resolve.run();
 223             chk.checkImportsUnique(toplevel);
 224             chk.checkImportsResolvable(toplevel);
 225             chk.checkImportedPackagesObservable(toplevel);
 226             toplevel.namedImportScope.finalizeScope();
 227             toplevel.starImportScope.finalizeScope();
 228         } catch (CompletionFailure cf) {
 229             chk.completionError(toplevel.pos(), cf);
 230         } finally {
 231             log.useSource(prev);
 232         }
 233     }
 234 
 235     abstract class Phase {
 236         private final ListBuffer&lt;Env&lt;AttrContext&gt;&gt; queue = new ListBuffer&lt;&gt;();
 237         private final Phase next;
 238         private final CompletionCause phaseName;
 239 
 240         Phase(CompletionCause phaseName, Phase next) {
 241             this.phaseName = phaseName;
 242             this.next = next;
 243         }
 244 
 245         public final List&lt;Env&lt;AttrContext&gt;&gt; completeEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 246             boolean firstToComplete = queue.isEmpty();
 247 
 248             Phase prevTopLevelPhase = topLevelPhase;
 249             boolean success = false;
 250 
 251             try {
 252                 topLevelPhase = this;
 253                 doCompleteEnvs(envs);
 254                 success = true;
 255             } finally {
 256                 topLevelPhase = prevTopLevelPhase;
 257                 if (!success &amp;&amp; firstToComplete) {
 258                     //an exception was thrown, e.g. BreakAttr:
 259                     //the queue would become stale, clear it:
 260                     queue.clear();
 261                 }
 262             }
 263 
 264             if (firstToComplete) {
 265                 List&lt;Env&lt;AttrContext&gt;&gt; out = queue.toList();
 266 
 267                 queue.clear();
 268                 return next != null ? next.completeEnvs(out) : out;
 269             } else {
 270                 return List.nil();
 271             }
 272         }
 273 
 274         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 275             for (Env&lt;AttrContext&gt; env : envs) {
 276                 JCClassDecl tree = (JCClassDecl)env.tree;
 277 
 278                 queue.add(env);
 279 
 280                 JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 281                 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());
 282                 try {
 283                     dependencies.push(env.enclClass.sym, phaseName);
 284                     runPhase(env);
 285                 } catch (CompletionFailure ex) {
 286                     chk.completionError(tree.pos(), ex);
 287                 } finally {
 288                     dependencies.pop();
 289                     deferredLintHandler.setPos(prevLintPos);
 290                     log.useSource(prev);
 291                 }
 292             }
 293         }
 294 
 295         protected abstract void runPhase(Env&lt;AttrContext&gt; env);
 296     }
 297 
 298     private final ImportsPhase completeClass = new ImportsPhase();
 299     private Phase topLevelPhase;
 300 
 301     /**Analyze import clauses.
 302      */
 303     private final class ImportsPhase extends Phase {
 304 
 305         public ImportsPhase() {
 306             super(CompletionCause.IMPORTS_PHASE, new HierarchyPhase());
 307         }
 308 
 309         Env&lt;AttrContext&gt; env;
 310         ImportFilter staticImportFilter;
 311         ImportFilter typeImportFilter;
 312         BiConsumer&lt;JCImport, CompletionFailure&gt; cfHandler =
 313                 (imp, cf) -&gt; chk.completionError(imp.pos(), cf);
 314 
 315         @Override
 316         protected void runPhase(Env&lt;AttrContext&gt; env) {
 317             JCClassDecl tree = env.enclClass;
 318             ClassSymbol sym = tree.sym;
 319 
 320             // If sym is a toplevel-class, make sure any import
 321             // clauses in its source file have been seen.
 322             if (sym.owner.kind == PCK) {
 323                 resolveImports(env.toplevel, env.enclosing(TOPLEVEL));
 324                 todo.append(env);
 325             }
 326 
 327             if (sym.owner.kind == TYP)
 328                 sym.owner.complete();
 329         }
 330 
 331         private void resolveImports(JCCompilationUnit tree, Env&lt;AttrContext&gt; env) {
 332             if (tree.starImportScope.isFilled()) {
 333                 // we must have already processed this toplevel
 334                 return;
 335             }
 336 
 337             ImportFilter prevStaticImportFilter = staticImportFilter;
 338             ImportFilter prevTypeImportFilter = typeImportFilter;
 339             DiagnosticPosition prevLintPos = deferredLintHandler.immediate();
 340             Lint prevLint = chk.setLint(lint);
 341             Env&lt;AttrContext&gt; prevEnv = this.env;
 342             try {
 343                 this.env = env;
 344                 final PackageSymbol packge = env.toplevel.packge;
 345                 this.staticImportFilter =
 346                         (origin, sym) -&gt; sym.isStatic() &amp;&amp;
 347                                          chk.importAccessible(sym, packge) &amp;&amp;
 348                                          sym.isMemberOf((TypeSymbol) origin.owner, types);
 349                 this.typeImportFilter =
 350                         (origin, sym) -&gt; sym.kind == TYP &amp;&amp;
 351                                          chk.importAccessible(sym, packge);
 352 
 353                 // Import-on-demand java.lang.
 354                 PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);
 355                 if (javaLang.members().isEmpty() &amp;&amp; !javaLang.exists())
 356                     throw new FatalError(diags.fragment(Fragments.FatalErrNoJavaLang));
 357                 importAll(make.at(tree.pos()).Import(make.QualIdent(javaLang), false), javaLang, env);
 358 
 359                 JCModuleDecl decl = tree.getModuleDecl();
 360 
 361                 // Process the package def and all import clauses.
 362                 if (tree.getPackage() != null &amp;&amp; decl == null)
 363                     checkClassPackageClash(tree.getPackage());
 364 
 365                 for (JCImport imp : tree.getImports()) {
 366                     doImport(imp);
 367                 }
 368 
 369                 if (decl != null) {
 370                     //check @Deprecated:
 371                     markDeprecated(decl.sym, decl.mods.annotations, env);
 372                     // process module annotations
 373                     annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, null);
 374                 }
 375             } finally {
 376                 this.env = prevEnv;
 377                 chk.setLint(prevLint);
 378                 deferredLintHandler.setPos(prevLintPos);
 379                 this.staticImportFilter = prevStaticImportFilter;
 380                 this.typeImportFilter = prevTypeImportFilter;
 381             }
 382         }
 383 
 384         private void checkClassPackageClash(JCPackageDecl tree) {
 385             // check that no class exists with same fully qualified name as
 386             // toplevel package
 387             if (checkClash &amp;&amp; tree.pid != null) {
 388                 Symbol p = env.toplevel.packge;
 389                 while (p.owner != syms.rootPackage) {
 390                     p.owner.complete(); // enter all class members of p
 391                     //need to lookup the owning module/package:
 392                     PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, p.owner.getQualifiedName());
 393                     if (syms.getClass(pack.modle, p.getQualifiedName()) != null) {
 394                         log.error(tree.pos,
 395                                   Errors.PkgClashesWithClassOfSameName(p));
 396                     }
 397                     p = p.owner;
 398                 }
 399             }
 400             // process package annotations
 401             annotate.annotateLater(tree.annotations, env, env.toplevel.packge, null);
 402         }
 403 
 404         private void doImport(JCImport tree) {
 405             JCFieldAccess imp = (JCFieldAccess)tree.qualid;
 406             Name name = TreeInfo.name(imp);
 407 
 408             // Create a local environment pointing to this tree to disable
 409             // effects of other imports in Resolve.findGlobalType
 410             Env&lt;AttrContext&gt; localEnv = env.dup(tree);
 411 
 412             TypeSymbol p = attr.attribImportQualifier(tree, localEnv).tsym;
 413             if (name == names.asterisk) {
 414                 // Import on demand.
 415                 chk.checkCanonical(imp.selected);
 416                 if (tree.staticImport)
 417                     importStaticAll(tree, p, env);
 418                 else
 419                     importAll(tree, p, env);
 420             } else {
 421                 // Named type import.
 422                 if (tree.staticImport) {
 423                     importNamedStatic(tree, p, name, localEnv);
 424                     chk.checkCanonical(imp.selected);
 425                 } else {
 426                     Type importedType = attribImportType(imp, localEnv);
 427                     Type originalType = importedType.getOriginalType();
 428                     TypeSymbol c = originalType.hasTag(CLASS) ? originalType.tsym : importedType.tsym;
 429                     chk.checkCanonical(imp);
 430                     importNamed(tree.pos(), c, env, tree);
 431                 }
 432             }
 433         }
 434 
 435         Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
 436             Assert.check(completionEnabled);
 437             Lint prevLint = chk.setLint(allowDeprecationOnImport ?
 438                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));
 439             try {
 440                 // To prevent deep recursion, suppress completion of some
 441                 // types.
 442                 completionEnabled = false;
 443                 return attr.attribType(tree, env);
 444             } finally {
 445                 completionEnabled = true;
 446                 chk.setLint(prevLint);
 447             }
 448         }
 449 
 450         /** Import all classes of a class or package on demand.
 451          *  @param imp           The import that is being handled.
 452          *  @param tsym          The class or package the members of which are imported.
 453          *  @param env           The env in which the imported classes will be entered.
 454          */
 455         private void importAll(JCImport imp,
 456                                final TypeSymbol tsym,
 457                                Env&lt;AttrContext&gt; env) {
 458             env.toplevel.starImportScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);
 459         }
 460 
 461         /** Import all static members of a class or package on demand.
 462          *  @param imp           The import that is being handled.
 463          *  @param tsym          The class or package the members of which are imported.
 464          *  @param env           The env in which the imported classes will be entered.
 465          */
 466         private void importStaticAll(JCImport imp,
 467                                      final TypeSymbol tsym,
 468                                      Env&lt;AttrContext&gt; env) {
 469             final StarImportScope toScope = env.toplevel.starImportScope;
 470             final TypeSymbol origin = tsym;
 471 
 472             toScope.importAll(types, origin.members(), staticImportFilter, imp, cfHandler);
 473         }
 474 
 475         /** Import statics types of a given name.  Non-types are handled in Attr.
 476          *  @param imp           The import that is being handled.
 477          *  @param tsym          The class from which the name is imported.
 478          *  @param name          The (simple) name being imported.
 479          *  @param env           The environment containing the named import
 480          *                  scope to add to.
 481          */
 482         private void importNamedStatic(final JCImport imp,
 483                                        final TypeSymbol tsym,
 484                                        final Name name,
 485                                        final Env&lt;AttrContext&gt; env) {
 486             if (tsym.kind != TYP) {
 487                 log.error(DiagnosticFlag.RECOVERABLE, imp.pos(), Errors.StaticImpOnlyClassesAndInterfaces);
 488                 return;
 489             }
 490 
 491             final NamedImportScope toScope = env.toplevel.namedImportScope;
 492             final Scope originMembers = tsym.members();
 493 
 494             imp.importScope = toScope.importByName(types, originMembers, name, staticImportFilter, imp, cfHandler);
 495         }
 496 
 497         /** Import given class.
 498          *  @param pos           Position to be used for error reporting.
 499          *  @param tsym          The class to be imported.
 500          *  @param env           The environment containing the named import
 501          *                  scope to add to.
 502          */
 503         private void importNamed(DiagnosticPosition pos, final Symbol tsym, Env&lt;AttrContext&gt; env, JCImport imp) {
 504             if (tsym.kind == TYP)
 505                 imp.importScope = env.toplevel.namedImportScope.importType(tsym.owner.members(), tsym.owner.members(), tsym);
 506         }
 507 
 508     }
 509 
 510     /**Defines common utility methods used by the HierarchyPhase and HeaderPhase.
 511      */
 512     private abstract class AbstractHeaderPhase extends Phase {
 513 
 514         public AbstractHeaderPhase(CompletionCause phaseName, Phase next) {
 515             super(phaseName, next);
 516         }
 517 
 518         protected Env&lt;AttrContext&gt; baseEnv(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 519             WriteableScope baseScope = WriteableScope.create(tree.sym);
 520             //import already entered local classes into base scope
 521             for (Symbol sym : env.outer.info.scope.getSymbols(NON_RECURSIVE)) {
 522                 if (sym.isLocal()) {
 523                     baseScope.enter(sym);
 524                 }
 525             }
 526             //import current type-parameters into base scope
 527             if (tree.typarams != null)
 528                 for (List&lt;JCTypeParameter&gt; typarams = tree.typarams;
 529                      typarams.nonEmpty();
 530                      typarams = typarams.tail)
 531                     baseScope.enter(typarams.head.type.tsym);
 532             Env&lt;AttrContext&gt; outer = env.outer; // the base clause can&#39;t see members of this class
 533             Env&lt;AttrContext&gt; localEnv = outer.dup(tree, outer.info.dup(baseScope));
 534             localEnv.baseClause = true;
 535             localEnv.outer = outer;
 536             localEnv.info.isSelfCall = false;
 537             return localEnv;
 538         }
 539 
 540         /** Generate a base clause for an enum type.
 541          *  @param pos              The position for trees and diagnostics, if any
 542          *  @param c                The class symbol of the enum
 543          */
 544         protected  JCExpression enumBase(int pos, ClassSymbol c) {
 545             JCExpression result = make.at(pos).
 546                 TypeApply(make.QualIdent(syms.enumSym),
 547                           List.of(make.Type(c.type)));
 548             return result;
 549         }
 550 
 551         protected Type modelMissingTypes(Env&lt;AttrContext&gt; env, Type t, final JCExpression tree, final boolean interfaceExpected) {
 552             if (!t.hasTag(ERROR))
 553                 return t;
 554 
 555             return new ErrorType(t.getOriginalType(), t.tsym) {
 556                 private Type modelType;
 557 
 558                 @Override
 559                 public Type getModelType() {
 560                     if (modelType == null)
 561                         modelType = new Synthesizer(env.toplevel.modle, getOriginalType(), interfaceExpected).visit(tree);
 562                     return modelType;
 563                 }
 564             };
 565         }
 566             // where:
 567             private class Synthesizer extends JCTree.Visitor {
 568                 ModuleSymbol msym;
 569                 Type originalType;
 570                 boolean interfaceExpected;
 571                 List&lt;ClassSymbol&gt; synthesizedSymbols = List.nil();
 572                 Type result;
 573 
 574                 Synthesizer(ModuleSymbol msym, Type originalType, boolean interfaceExpected) {
 575                     this.msym = msym;
 576                     this.originalType = originalType;
 577                     this.interfaceExpected = interfaceExpected;
 578                 }
 579 
 580                 Type visit(JCTree tree) {
 581                     tree.accept(this);
 582                     return result;
 583                 }
 584 
 585                 List&lt;Type&gt; visit(List&lt;? extends JCTree&gt; trees) {
 586                     ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 587                     for (JCTree t: trees)
 588                         lb.append(visit(t));
 589                     return lb.toList();
 590                 }
 591 
 592                 @Override
 593                 public void visitTree(JCTree tree) {
 594                     result = syms.errType;
 595                 }
 596 
 597                 @Override
 598                 public void visitIdent(JCIdent tree) {
 599                     if (!tree.type.hasTag(ERROR)) {
 600                         result = tree.type;
 601                     } else {
 602                         result = synthesizeClass(tree.name, msym.unnamedPackage).type;
 603                     }
 604                 }
 605 
 606                 @Override
 607                 public void visitSelect(JCFieldAccess tree) {
 608                     if (!tree.type.hasTag(ERROR)) {
 609                         result = tree.type;
 610                     } else {
 611                         Type selectedType;
 612                         boolean prev = interfaceExpected;
 613                         try {
 614                             interfaceExpected = false;
 615                             selectedType = visit(tree.selected);
 616                         } finally {
 617                             interfaceExpected = prev;
 618                         }
 619                         ClassSymbol c = synthesizeClass(tree.name, selectedType.tsym);
 620                         result = c.type;
 621                     }
 622                 }
 623 
 624                 @Override
 625                 public void visitTypeApply(JCTypeApply tree) {
 626                     if (!tree.type.hasTag(ERROR)) {
 627                         result = tree.type;
 628                     } else {
 629                         ClassType clazzType = (ClassType) visit(tree.clazz);
 630                         if (synthesizedSymbols.contains(clazzType.tsym))
 631                             synthesizeTyparams((ClassSymbol) clazzType.tsym, tree.arguments.size());
 632                         final List&lt;Type&gt; actuals = visit(tree.arguments);
 633                         result = new ErrorType(tree.type, clazzType.tsym) {
 634                             @Override @DefinedBy(Api.LANGUAGE_MODEL)
 635                             public List&lt;Type&gt; getTypeArguments() {
 636                                 return actuals;
 637                             }
 638                         };
 639                     }
 640                 }
 641 
 642                 ClassSymbol synthesizeClass(Name name, Symbol owner) {
 643                     int flags = interfaceExpected ? INTERFACE : 0;
 644                     ClassSymbol c = new ClassSymbol(flags, name, owner);
 645                     c.members_field = new Scope.ErrorScope(c);
 646                     c.type = new ErrorType(originalType, c) {
 647                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 648                         public List&lt;Type&gt; getTypeArguments() {
 649                             return typarams_field;
 650                         }
 651                     };
 652                     synthesizedSymbols = synthesizedSymbols.prepend(c);
 653                     return c;
 654                 }
 655 
 656                 void synthesizeTyparams(ClassSymbol sym, int n) {
 657                     ClassType ct = (ClassType) sym.type;
 658                     Assert.check(ct.typarams_field.isEmpty());
 659                     if (n == 1) {
 660                         TypeVar v = new TypeVar(names.fromString(&quot;T&quot;), sym, syms.botType);
 661                         ct.typarams_field = ct.typarams_field.prepend(v);
 662                     } else {
 663                         for (int i = n; i &gt; 0; i--) {
 664                             TypeVar v = new TypeVar(names.fromString(&quot;T&quot; + i), sym,
 665                                                     syms.botType);
 666                             ct.typarams_field = ct.typarams_field.prepend(v);
 667                         }
 668                     }
 669                 }
 670             }
 671 
 672         protected void attribSuperTypes(Env&lt;AttrContext&gt; env, Env&lt;AttrContext&gt; baseEnv) {
 673             JCClassDecl tree = env.enclClass;
 674             ClassSymbol sym = tree.sym;
 675             ClassType ct = (ClassType)sym.type;
 676             // Determine supertype.
 677             Type supertype;
 678             JCExpression extending;
<a name="2" id="anc2"></a>
 679 
 680             if (tree.extending != null) {
 681                 extending = clearTypeParams(tree.extending);
 682                 supertype = attr.attribBase(extending, baseEnv, true, false, true);
 683                 if (supertype == syms.recordType) {
 684                     log.error(tree, Errors.InvalidSupertypeRecord(supertype.tsym));
 685                 }
 686             } else {
 687                 extending = null;
 688                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 689                 ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
 690                                   true, false, false)
 691                 : (sym.fullname == names.java_lang_Object)
 692                 ? Type.noType
 693                 : sym.isRecord() ? syms.recordType : syms.objectType;
 694             }
 695             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 696 
 697             // Determine interfaces.
 698             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 699             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 700             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 701             for (JCExpression iface : interfaceTrees) {
 702                 iface = clearTypeParams(iface);
 703                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
 704                 if (it.hasTag(CLASS)) {
 705                     interfaces.append(it);
 706                     if (all_interfaces != null) all_interfaces.append(it);
 707                 } else {
 708                     if (all_interfaces == null)
 709                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 710                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 711                 }
 712             }
 713 
 714             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 715                 ct.interfaces_field = List.of(syms.annotationType);
 716                 ct.all_interfaces_field = ct.interfaces_field;
 717             }  else {
 718                 ct.interfaces_field = interfaces.toList();
 719                 ct.all_interfaces_field = (all_interfaces == null)
 720                         ? ct.interfaces_field : all_interfaces.toList();
 721             }
<a name="3" id="anc3"></a>








 722         }
 723             //where:
 724             protected JCExpression clearTypeParams(JCExpression superType) {
 725                 return superType;
 726             }
 727     }
 728 
 729     private final class HierarchyPhase extends AbstractHeaderPhase implements Completer {
 730 
 731         public HierarchyPhase() {
 732             super(CompletionCause.HIERARCHY_PHASE, new HeaderPhase());
 733         }
 734 
 735         @Override
 736         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 737             //The ClassSymbols in the envs list may not be in the dependency order.
 738             //To get proper results, for every class or interface C, the supertypes of
 739             //C must be processed by the HierarchyPhase phase before C.
 740             //To achieve that, the HierarchyPhase is registered as the Completer for
 741             //all the classes first, and then all the classes are completed.
 742             for (Env&lt;AttrContext&gt; env : envs) {
 743                 env.enclClass.sym.completer = this;
 744             }
 745             for (Env&lt;AttrContext&gt; env : envs) {
 746                 env.enclClass.sym.complete();
 747             }
 748         }
 749 
 750         @Override
 751         protected void runPhase(Env&lt;AttrContext&gt; env) {
 752             JCClassDecl tree = env.enclClass;
 753             ClassSymbol sym = tree.sym;
 754             ClassType ct = (ClassType)sym.type;
 755 
 756             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 757 
 758             attribSuperTypes(env, baseEnv);
 759 
 760             if (sym.fullname == names.java_lang_Object) {
 761                 if (tree.extending != null) {
 762                     chk.checkNonCyclic(tree.extending.pos(),
 763                                        ct.supertype_field);
 764                     ct.supertype_field = Type.noType;
 765                 }
 766                 else if (tree.implementing.nonEmpty()) {
 767                     chk.checkNonCyclic(tree.implementing.head.pos(),
 768                                        ct.interfaces_field.head);
 769                     ct.interfaces_field = List.nil();
 770                 }
 771             }
 772 
 773             markDeprecated(sym, tree.mods.annotations, baseEnv);
 774 
 775             chk.checkNonCyclicDecl(tree);
 776         }
 777             //where:
 778             @Override
 779             protected JCExpression clearTypeParams(JCExpression superType) {
 780                 switch (superType.getTag()) {
 781                     case TYPEAPPLY:
 782                         return ((JCTypeApply) superType).clazz;
 783                 }
 784 
 785                 return superType;
 786             }
 787 
 788         @Override
 789         public void complete(Symbol sym) throws CompletionFailure {
 790             Assert.check((topLevelPhase instanceof ImportsPhase) ||
 791                          (topLevelPhase == this));
 792 
 793             if (topLevelPhase != this) {
 794                 //only do the processing based on dependencies in the HierarchyPhase:
 795                 sym.completer = this;
 796                 return ;
 797             }
 798 
 799             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 800 
 801             super.doCompleteEnvs(List.of(env));
 802         }
 803 
 804     }
 805 
 806     private final class HeaderPhase extends AbstractHeaderPhase {
 807 
 808         public HeaderPhase() {
 809             super(CompletionCause.HEADER_PHASE, new RecordPhase());
 810         }
 811 
 812         @Override
 813         protected void runPhase(Env&lt;AttrContext&gt; env) {
 814             JCClassDecl tree = env.enclClass;
 815             ClassSymbol sym = tree.sym;
 816             ClassType ct = (ClassType)sym.type;
 817 
 818             // create an environment for evaluating the base clauses
 819             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 820 
 821             if (tree.extending != null)
 822                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 823             for (JCExpression impl : tree.implementing)
 824                 annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());
 825             annotate.flush();
 826 
 827             attribSuperTypes(env, baseEnv);
 828 
 829             Set&lt;Type&gt; interfaceSet = new HashSet&lt;&gt;();
 830 
 831             for (JCExpression iface : tree.implementing) {
 832                 Type it = iface.type;
 833                 if (it.hasTag(CLASS))
 834                     chk.checkNotRepeated(iface.pos(), types.erasure(it), interfaceSet);
 835             }
 836 
 837             annotate.annotateLater(tree.mods.annotations, baseEnv,
 838                         sym, tree.pos());
 839             attr.attribTypeVariables(tree.typarams, baseEnv, false);
 840 
 841             for (JCTypeParameter tp : tree.typarams)
 842                 annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());
 843 
 844             // check that no package exists with same fully qualified name,
 845             // but admit classes in the unnamed package which have the same
 846             // name as a top-level package.
 847             if (checkClash &amp;&amp;
 848                 sym.owner.kind == PCK &amp;&amp; sym.owner != env.toplevel.modle.unnamedPackage &amp;&amp;
 849                 syms.packageExists(env.toplevel.modle, sym.fullname)) {
 850                 log.error(tree.pos, Errors.ClashWithPkgOfSameName(Kinds.kindName(sym),sym));
 851             }
 852             if (sym.owner.kind == PCK &amp;&amp; (sym.flags_field &amp; PUBLIC) == 0 &amp;&amp;
 853                 !env.toplevel.sourcefile.isNameCompatible(sym.name.toString(),JavaFileObject.Kind.SOURCE)) {
 854                 sym.flags_field |= AUXILIARY;
 855             }
 856         }
 857     }
 858 
 859     private abstract class AbstractMembersPhase extends Phase {
 860 
 861         public AbstractMembersPhase(CompletionCause completionCause, Phase next) {
 862             super(completionCause, next);
 863         }
 864 
 865         private boolean completing;
 866         private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
 867 
 868         @Override
 869         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 870             todo = todo.prependList(envs);
 871             if (completing) {
 872                 return ; //the top-level invocation will handle all envs
 873             }
 874             boolean prevCompleting = completing;
 875             completing = true;
 876             try {
 877                 while (todo.nonEmpty()) {
 878                     Env&lt;AttrContext&gt; head = todo.head;
 879                     todo = todo.tail;
 880                     super.doCompleteEnvs(List.of(head));
 881                 }
 882             } finally {
 883                 completing = prevCompleting;
 884             }
 885         }
 886 
 887         void enterThisAndSuper(ClassSymbol sym, Env&lt;AttrContext&gt; env) {
 888             ClassType ct = (ClassType)sym.type;
 889             // enter symbols for &#39;this&#39; into current scope.
 890             VarSymbol thisSym =
 891                     new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);
 892             thisSym.pos = Position.FIRSTPOS;
 893             env.info.scope.enter(thisSym);
 894             // if this is a class, enter symbol for &#39;super&#39; into current scope.
 895             if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
 896                     ct.supertype_field.hasTag(CLASS)) {
 897                 VarSymbol superSym =
 898                         new VarSymbol(FINAL | HASINIT, names._super,
 899                                 ct.supertype_field, sym);
 900                 superSym.pos = Position.FIRSTPOS;
 901                 env.info.scope.enter(superSym);
 902             }
 903         }
 904     }
 905 
 906     private final class RecordPhase extends AbstractMembersPhase {
 907 
 908         public RecordPhase() {
 909             super(CompletionCause.RECORD_PHASE, new MembersPhase());
 910         }
 911 
 912         @Override
 913         protected void runPhase(Env&lt;AttrContext&gt; env) {
 914             JCClassDecl tree = env.enclClass;
 915             ClassSymbol sym = tree.sym;
 916             if ((sym.flags_field &amp; RECORD) != 0) {
 917                 List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);
 918                 memberEnter.memberEnter(fields, env);
 919                 for (JCVariableDecl field : fields) {
 920                     sym.getRecordComponent(field, true,
 921                             field.mods.annotations.isEmpty() ?
 922                                     List.nil() :
 923                                     new TreeCopier&lt;JCTree&gt;(make.at(field.pos)).copy(field.mods.annotations));
 924                 }
 925 
 926                 enterThisAndSuper(sym, env);
 927 
 928                 // lets enter all constructors
 929                 for (JCTree def : tree.defs) {
 930                     if (TreeInfo.isConstructor(def)) {
 931                         memberEnter.memberEnter(def, env);
 932                     }
 933                 }
 934             }
 935         }
 936     }
 937 
 938     /** Enter member fields and methods of a class
 939      */
 940     private final class MembersPhase extends AbstractMembersPhase {
 941 
 942         public MembersPhase() {
 943             super(CompletionCause.MEMBERS_PHASE, null);
 944         }
 945 
 946         @Override
 947         protected void runPhase(Env&lt;AttrContext&gt; env) {
 948             JCClassDecl tree = env.enclClass;
 949             ClassSymbol sym = tree.sym;
 950             ClassType ct = (ClassType)sym.type;
 951 
 952             // Add default constructor if needed.
 953             DefaultConstructorHelper helper = getDefaultConstructorHelper(env);
 954             if (helper != null) {
 955                 JCTree constrDef = defaultConstructor(make.at(tree.pos), helper);
 956                 tree.defs = tree.defs.prepend(constrDef);
 957             }
 958             if (!sym.isRecord()) {
 959                 enterThisAndSuper(sym, env);
 960             }
 961 
 962             if (!tree.typarams.isEmpty()) {
 963                 for (JCTypeParameter tvar : tree.typarams) {
 964                     chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
 965                 }
 966             }
 967 
 968             finishClass(tree, env);
 969 
 970             if (allowTypeAnnos) {
 971                 typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
 972                 typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
 973             }
 974         }
 975 
 976         DefaultConstructorHelper getDefaultConstructorHelper(Env&lt;AttrContext&gt; env) {
 977             JCClassDecl tree = env.enclClass;
 978             ClassSymbol sym = tree.sym;
 979             DefaultConstructorHelper helper = null;
 980             boolean isClassWithoutInit = (sym.flags() &amp; INTERFACE) == 0 &amp;&amp; !TreeInfo.hasConstructors(tree.defs);
 981             boolean isRecord = sym.isRecord();
 982             if (isClassWithoutInit &amp;&amp; !isRecord) {
 983                 helper = new BasicConstructorHelper(sym);
 984                 if (sym.name.isEmpty()) {
 985                     JCNewClass nc = (JCNewClass)env.next.tree;
 986                     if (nc.constructor != null) {
 987                         if (nc.constructor.kind != ERR) {
 988                             helper = new AnonClassConstructorHelper(sym, (MethodSymbol)nc.constructor, nc.encl);
 989                         } else {
 990                             helper = null;
 991                         }
 992                     }
 993                 }
 994             }
 995             if (isRecord) {
 996                 JCMethodDecl canonicalInit = null;
 997                 if (isClassWithoutInit || (canonicalInit = getCanonicalConstructorDecl(env.enclClass)) == null) {
 998                     helper = new RecordConstructorHelper(sym, TreeInfo.recordFields(tree));
 999                 }
1000                 if (canonicalInit != null) {
1001                     canonicalInit.sym.flags_field |= Flags.RECORD;
1002                 }
1003             }
1004             return helper;
1005         }
1006 
1007         /** Enter members for a class.
1008          */
1009         void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1010             if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
1011                 !tree.sym.type.hasTag(ERROR) &amp;&amp;
1012                 (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
1013                 addEnumMembers(tree, env);
1014             }
1015             boolean isRecord = (tree.sym.flags_field &amp; RECORD) != 0;
1016             List&lt;JCTree&gt; alreadyEntered = null;
1017             if (isRecord) {
1018                 alreadyEntered = List.convert(JCTree.class, TreeInfo.recordFields(tree));
1019                 alreadyEntered = alreadyEntered.prependList(tree.defs.stream()
1020                         .filter(t -&gt; TreeInfo.isConstructor(t) &amp;&amp;
1021                                 ((JCMethodDecl)t).sym != null &amp;&amp;
1022                                 (((JCMethodDecl)t).sym.flags_field &amp; Flags.GENERATEDCONSTR) == 0).collect(List.collector()));
1023             }
1024             List&lt;JCTree&gt; defsToEnter = isRecord ?
1025                     tree.defs.diff(alreadyEntered) : tree.defs;
1026             memberEnter.memberEnter(defsToEnter, env);
1027             if (isRecord) {
1028                 addRecordMembersIfNeeded(tree, env);
1029             }
<a name="4" id="anc4"></a>


1030             if (tree.sym.isAnnotationType()) {
1031                 Assert.check(tree.sym.isCompleted());
1032                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
1033             }
1034         }
1035 
1036         private void addAccessor(JCVariableDecl tree, Env&lt;AttrContext&gt; env) {
1037             MethodSymbol implSym = lookupMethod(env.enclClass.sym, tree.sym.name, List.nil());
1038             RecordComponent rec = ((ClassSymbol) tree.sym.owner).getRecordComponent(tree.sym);
1039             if (implSym == null || (implSym.flags_field &amp; GENERATED_MEMBER) != 0) {
1040                 /* here we are pushing the annotations present in the corresponding field down to the accessor
1041                  * it could be that some of those annotations are not applicable to the accessor, they will be striped
1042                  * away later at Check::validateAnnotation
1043                  */
1044                 List&lt;JCAnnotation&gt; originalAnnos = rec.getOriginalAnnos().isEmpty() ?
1045                         rec.getOriginalAnnos() :
1046                         new TreeCopier&lt;JCTree&gt;(make.at(tree.pos)).copy(rec.getOriginalAnnos());
1047                 JCMethodDecl getter = make.at(tree.pos).
1048                         MethodDef(
1049                                 make.Modifiers(PUBLIC | Flags.GENERATED_MEMBER, originalAnnos),
1050                           tree.sym.name,
1051                           /* we need to special case for the case when the user declared the type as an ident
1052                            * if we don&#39;t do that then we can have issues if type annotations are applied to the
1053                            * return type: javac issues an error if a type annotation is applied to java.lang.String
1054                            * but applying a type annotation to String is kosher
1055                            */
1056                           tree.vartype.hasTag(IDENT) ? make.Ident(tree.vartype.type.tsym) : make.Type(tree.sym.type),
1057                           List.nil(),
1058                           List.nil(),
1059                           List.nil(), // thrown
1060                           null,
1061                           null);
1062                 memberEnter.memberEnter(getter, env);
1063                 rec.accessor = getter.sym;
1064                 rec.accessorMeth = getter;
1065             } else if (implSym != null) {
1066                 rec.accessor = implSym;
1067             }
1068         }
1069 
1070         /** Add the implicit members for an enum type
1071          *  to the symbol table.
1072          */
1073         private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1074             JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
1075 
1076             JCMethodDecl values = make.
1077                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1078                           names.values,
1079                           valuesType,
1080                           List.nil(),
1081                           List.nil(),
1082                           List.nil(),
1083                           null,
1084                           null);
1085             memberEnter.memberEnter(values, env);
1086 
1087             JCMethodDecl valueOf = make.
1088                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1089                           names.valueOf,
1090                           make.Type(tree.sym.type),
1091                           List.nil(),
1092                           List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
1093                                                              Flags.MANDATED),
1094                                                 names.fromString(&quot;name&quot;),
1095                                                 make.Type(syms.stringType), null)),
1096                           List.nil(),
1097                           null,
1098                           null);
1099             memberEnter.memberEnter(valueOf, env);
1100         }
1101 
<a name="5" id="anc5"></a>























































































1102         JCMethodDecl getCanonicalConstructorDecl(JCClassDecl tree) {
1103             // let&#39;s check if there is a constructor with exactly the same arguments as the record components
1104             List&lt;Type&gt; recordComponentErasedTypes = types.erasure(TreeInfo.recordFields(tree).map(vd -&gt; vd.sym.type));
1105             JCMethodDecl canonicalDecl = null;
1106             for (JCTree def : tree.defs) {
1107                 if (TreeInfo.isConstructor(def)) {
1108                     JCMethodDecl mdecl = (JCMethodDecl)def;
1109                     if (types.isSameTypes(types.erasure(mdecl.params.stream().map(v -&gt; v.sym.type).collect(List.collector())), recordComponentErasedTypes)) {
1110                         canonicalDecl = mdecl;
1111                         break;
1112                     }
1113                 }
1114             }
1115             return canonicalDecl;
1116         }
1117 
1118         /** Add the implicit members for a record
1119          *  to the symbol table.
1120          */
1121         private void addRecordMembersIfNeeded(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1122             if (lookupMethod(tree.sym, names.toString, List.nil()) == null) {
1123                 JCMethodDecl toString = make.
1124                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1125                               names.toString,
1126                               make.Type(syms.stringType),
1127                               List.nil(),
1128                               List.nil(),
1129                               List.nil(),
1130                               null,
1131                               null);
1132                 memberEnter.memberEnter(toString, env);
1133             }
1134 
1135             if (lookupMethod(tree.sym, names.hashCode, List.nil()) == null) {
1136                 JCMethodDecl hashCode = make.
1137                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1138                               names.hashCode,
1139                               make.Type(syms.intType),
1140                               List.nil(),
1141                               List.nil(),
1142                               List.nil(),
1143                               null,
1144                               null);
1145                 memberEnter.memberEnter(hashCode, env);
1146             }
1147 
1148             if (lookupMethod(tree.sym, names.equals, List.of(syms.objectType)) == null) {
1149                 JCMethodDecl equals = make.
1150                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1151                               names.equals,
1152                               make.Type(syms.booleanType),
1153                               List.nil(),
1154                               List.of(make.VarDef(make.Modifiers(Flags.PARAMETER),
1155                                                 names.fromString(&quot;o&quot;),
1156                                                 make.Type(syms.objectType), null)),
1157                               List.nil(),
1158                               null,
1159                               null);
1160                 memberEnter.memberEnter(equals, env);
1161             }
1162 
1163             // fields can&#39;t be varargs, lets remove the flag
1164             List&lt;JCVariableDecl&gt; recordFields = TreeInfo.recordFields(tree);
1165             for (JCVariableDecl field: recordFields) {
1166                 field.mods.flags &amp;= ~Flags.VARARGS;
1167                 field.sym.flags_field &amp;= ~Flags.VARARGS;
1168             }
1169             // now lets add the accessors
1170             recordFields.stream()
1171                     .filter(vd -&gt; (lookupMethod(syms.objectType.tsym, vd.name, List.nil()) == null))
1172                     .forEach(vd -&gt; addAccessor(vd, env));
1173         }
1174     }
1175 
1176     private MethodSymbol lookupMethod(TypeSymbol tsym, Name name, List&lt;Type&gt; argtypes) {
1177         for (Symbol s : tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1178             if (types.isSameTypes(s.type.getParameterTypes(), argtypes)) {
1179                 return (MethodSymbol) s;
1180             }
1181         }
1182         return null;
1183     }
1184 
1185 /* ***************************************************************************
1186  * tree building
1187  ****************************************************************************/
1188 
1189     interface DefaultConstructorHelper {
1190        Type constructorType();
1191        MethodSymbol constructorSymbol();
1192        Type enclosingType();
1193        TypeSymbol owner();
1194        List&lt;Name&gt; superArgs();
1195        default JCMethodDecl finalAdjustment(JCMethodDecl md) { return md; }
1196     }
1197 
1198     class BasicConstructorHelper implements DefaultConstructorHelper {
1199 
1200         TypeSymbol owner;
1201         Type constructorType;
1202         MethodSymbol constructorSymbol;
1203 
1204         BasicConstructorHelper(TypeSymbol owner) {
1205             this.owner = owner;
1206         }
1207 
1208         @Override
1209         public Type constructorType() {
1210             if (constructorType == null) {
1211                 constructorType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);
1212             }
1213             return constructorType;
1214         }
1215 
1216         @Override
1217         public MethodSymbol constructorSymbol() {
1218             if (constructorSymbol == null) {
1219                 long flags;
1220                 if ((owner().flags() &amp; ENUM) != 0 &amp;&amp;
1221                     (types.supertype(owner().type).tsym == syms.enumSym)) {
1222                     // constructors of true enums are private
1223                     flags = PRIVATE | GENERATEDCONSTR;
1224                 } else {
1225                     flags = (owner().flags() &amp; AccessFlags) | GENERATEDCONSTR;
1226                 }
1227                 constructorSymbol = new MethodSymbol(flags, names.init,
1228                     constructorType(), owner());
1229             }
1230             return constructorSymbol;
1231         }
1232 
1233         @Override
1234         public Type enclosingType() {
1235             return Type.noType;
1236     }
1237 
1238         @Override
1239         public TypeSymbol owner() {
1240             return owner;
1241         }
1242 
1243         @Override
1244         public List&lt;Name&gt; superArgs() {
1245             return List.nil();
1246             }
1247     }
1248 
1249     class AnonClassConstructorHelper extends BasicConstructorHelper {
1250 
1251         MethodSymbol constr;
1252         Type encl;
1253         boolean based = false;
1254 
1255         AnonClassConstructorHelper(TypeSymbol owner, MethodSymbol constr, JCExpression encl) {
1256             super(owner);
1257             this.constr = constr;
1258             this.encl = encl != null ? encl.type : Type.noType;
1259         }
1260 
1261         @Override
1262         public Type constructorType() {
1263             if (constructorType == null) {
1264                 Type ctype = types.memberType(owner.type, constr);
1265                 if (!enclosingType().hasTag(NONE)) {
1266                     ctype = types.createMethodTypeWithParameters(ctype, ctype.getParameterTypes().prepend(enclosingType()));
1267                     based = true;
1268                 }
1269                 constructorType = ctype;
1270             }
1271             return constructorType;
1272         }
1273 
1274         @Override
1275         public MethodSymbol constructorSymbol() {
1276             MethodSymbol csym = super.constructorSymbol();
1277             csym.flags_field |= ANONCONSTR | (constr.flags() &amp; VARARGS);
1278             csym.flags_field |= based ? ANONCONSTR_BASED : 0;
1279             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1280             List&lt;Type&gt; argtypes = constructorType().getParameterTypes();
1281             if (!enclosingType().hasTag(NONE)) {
1282                 argtypes = argtypes.tail;
1283                 params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));
1284             }
1285             if (constr.params != null) {
1286                 for (VarSymbol p : constr.params) {
1287                     params.add(new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym));
1288                     argtypes = argtypes.tail;
1289                 }
1290             }
1291             csym.params = params.toList();
1292             return csym;
1293         }
1294 
1295         @Override
1296         public Type enclosingType() {
1297             return encl;
1298         }
1299 
1300         @Override
1301         public List&lt;Name&gt; superArgs() {
1302             List&lt;JCVariableDecl&gt; params = make.Params(constructorType().getParameterTypes(), constructorSymbol());
1303             if (!enclosingType().hasTag(NONE)) {
1304                 params = params.tail;
1305             }
1306             return params.map(vd -&gt; vd.name);
1307         }
1308     }
1309 
1310     class RecordConstructorHelper extends BasicConstructorHelper {
1311         boolean lastIsVarargs;
1312         List&lt;JCVariableDecl&gt; recordFieldDecls;
1313 
1314         RecordConstructorHelper(ClassSymbol owner, List&lt;JCVariableDecl&gt; recordFieldDecls) {
1315             super(owner);
1316             this.recordFieldDecls = recordFieldDecls;
1317             this.lastIsVarargs = owner.getRecordComponents().stream().anyMatch(rc -&gt; rc.isVarargs());
1318         }
1319 
1320         @Override
1321         public Type constructorType() {
1322             if (constructorType == null) {
1323                 ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();
1324                 JCVariableDecl lastField = recordFieldDecls.last();
1325                 for (JCVariableDecl field : recordFieldDecls) {
1326                     argtypes.add(field == lastField &amp;&amp; lastIsVarargs ? types.elemtype(field.sym.type) : field.sym.type);
1327                 }
1328 
1329                 constructorType = new MethodType(argtypes.toList(), syms.voidType, List.nil(), syms.methodClass);
1330             }
1331             return constructorType;
1332         }
1333 
1334         @Override
1335         public MethodSymbol constructorSymbol() {
1336             MethodSymbol csym = super.constructorSymbol();
1337             /* if we have to generate a default constructor for records we will treat it as the compact one
1338              * to trigger field initialization later on
1339              */
1340             csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;
1341             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1342             JCVariableDecl lastField = recordFieldDecls.last();
1343             for (JCVariableDecl field : recordFieldDecls) {
1344                 params.add(new VarSymbol(
1345                         GENERATED_MEMBER | PARAMETER | RECORD | (field == lastField &amp;&amp; lastIsVarargs ? Flags.VARARGS : 0),
1346                         field.name, field.sym.type, csym));
1347             }
1348             csym.params = params.toList();
1349             csym.flags_field |= RECORD;
1350             return csym;
1351         }
1352 
1353         @Override
1354         public JCMethodDecl finalAdjustment(JCMethodDecl md) {
1355             List&lt;JCVariableDecl&gt; tmpRecordFieldDecls = recordFieldDecls;
1356             for (JCVariableDecl arg : md.params) {
1357                 /* at this point we are passing all the annotations in the field to the corresponding
1358                  * parameter in the constructor.
1359                  */
1360                 RecordComponent rc = ((ClassSymbol) owner).getRecordComponent(arg.sym);
1361                 arg.mods.annotations = rc.getOriginalAnnos().isEmpty() ?
1362                         List.nil() :
1363                         new TreeCopier&lt;JCTree&gt;(make.at(arg.pos)).copy(rc.getOriginalAnnos());
1364                 arg.vartype = tmpRecordFieldDecls.head.vartype;
1365                 tmpRecordFieldDecls = tmpRecordFieldDecls.tail;
1366             }
1367             return md;
1368         }
1369     }
1370 
1371     JCTree defaultConstructor(TreeMaker make, DefaultConstructorHelper helper) {
1372         Type initType = helper.constructorType();
1373         MethodSymbol initSym = helper.constructorSymbol();
1374         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
1375         if (helper.owner().type != syms.objectType) {
1376             JCExpression meth;
1377             if (!helper.enclosingType().hasTag(NONE)) {
1378                 meth = make.Select(make.Ident(initSym.params.head), names._super);
1379             } else {
1380                 meth = make.Ident(names._super);
1381             }
1382             List&lt;JCExpression&gt; typeargs = initType.getTypeArguments().nonEmpty() ?
1383                     make.Types(initType.getTypeArguments()) : null;
1384             JCStatement superCall = make.Exec(make.Apply(typeargs, meth, helper.superArgs().map(make::Ident)));
1385             stats.add(superCall);
1386         }
1387         JCMethodDecl result = make.MethodDef(initSym, make.Block(0, stats.toList()));
1388         return helper.finalAdjustment(result);
1389     }
1390 
1391     /**
1392      * Mark sym deprecated if annotations contain @Deprecated annotation.
1393      */
1394     public void markDeprecated(Symbol sym, List&lt;JCAnnotation&gt; annotations, Env&lt;AttrContext&gt; env) {
1395         // In general, we cannot fully process annotations yet,  but we
1396         // can attribute the annotation types and then check to see if the
1397         // @Deprecated annotation is present.
1398         attr.attribAnnotationTypes(annotations, env);
1399         handleDeprecatedAnnotations(annotations, sym);
1400     }
1401 
1402     /**
1403      * If a list of annotations contains a reference to java.lang.Deprecated,
1404      * set the DEPRECATED flag.
1405      * If the annotation is marked forRemoval=true, also set DEPRECATED_REMOVAL.
1406      **/
1407     private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
1408         for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
1409             JCAnnotation a = al.head;
1410             if (a.annotationType.type == syms.deprecatedType) {
1411                 sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
1412                 setFlagIfAttributeTrue(a, sym, names.forRemoval, DEPRECATED_REMOVAL);
1413             } else if (a.annotationType.type == syms.previewFeatureType) {
1414                 sym.flags_field |= Flags.PREVIEW_API;
1415                 setFlagIfAttributeTrue(a, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1416             }
1417         }
1418     }
1419     //where:
1420         private void setFlagIfAttributeTrue(JCAnnotation a, Symbol sym, Name attribute, long flag) {
1421             a.args.stream()
1422                     .filter(e -&gt; e.hasTag(ASSIGN))
1423                     .map(e -&gt; (JCAssign) e)
1424                     .filter(assign -&gt; TreeInfo.name(assign.lhs) == attribute)
1425                     .findFirst()
1426                     .ifPresent(assign -&gt; {
1427                         JCExpression rhs = TreeInfo.skipParens(assign.rhs);
1428                         if (rhs.hasTag(LITERAL)
1429                                 &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {
1430                             sym.flags_field |= flag;
1431                         }
1432                     });
1433         }
1434 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;

  98 
  99     // The set of lint options currently in effect. It is initialized
 100     // from the context, and then is set/reset as needed by Attr as it
 101     // visits all the various parts of the trees during attribution.
 102     private Lint lint;
 103 
 104     // The method being analyzed in Attr - it is set/reset as needed by
 105     // Attr as it visits new method declarations.
 106     private MethodSymbol method;
 107 
 108     public static Check instance(Context context) {
 109         Check instance = context.get(checkKey);
 110         if (instance == null)
 111             instance = new Check(context);
 112         return instance;
 113     }
 114 
 115     protected Check(Context context) {
 116         context.put(checkKey, this);
 117 
 118         names = Names.instance(context);
 119         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 120             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 121             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 122         log = Log.instance(context);
 123         rs = Resolve.instance(context);
 124         syms = Symtab.instance(context);
 125         enter = Enter.instance(context);
 126         deferredAttr = DeferredAttr.instance(context);
 127         infer = Infer.instance(context);
 128         types = Types.instance(context);
 129         typeAnnotations = TypeAnnotations.instance(context);
 130         diags = JCDiagnostic.Factory.instance(context);
 131         Options options = Options.instance(context);
 132         lint = Lint.instance(context);
 133         fileManager = context.get(JavaFileManager.class);
 134 
 135         source = Source.instance(context);
 136         target = Target.instance(context);
 137         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
<span class="line-modified"> 138 </span>
 139         Target target = Target.instance(context);
 140         syntheticNameChar = target.syntheticNameChar();
 141 
 142         profile = Profile.instance(context);
 143         preview = Preview.instance(context);
 144 
 145         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 146         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 147         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 148         boolean enforceMandatoryWarnings = true;
 149 
 150         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 151                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 152         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 153                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 154         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 155                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 156         sunApiHandler = new MandatoryWarningHandler(log, false,
 157                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 158 
</pre>
<hr />
<pre>
 473         uncheckedHandler.clear();
 474         sunApiHandler.clear();
 475     }
 476 
 477     public void putCompiled(ClassSymbol csym) {
 478         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 479     }
 480 
 481     public ClassSymbol getCompiled(ClassSymbol csym) {
 482         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 483     }
 484 
 485     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 486         return compiled.get(Pair.of(msym, flatname));
 487     }
 488 
 489     public void removeCompiled(ClassSymbol csym) {
 490         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 491     }
 492 
<span class="line-modified"> 493 /* *************************************************************************</span>
 494  * Type Checking
 495  **************************************************************************/
 496 
 497     /**
 498      * A check context is an object that can be used to perform compatibility
 499      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 500      * vary significantly.
 501      */
 502     public interface CheckContext {
 503         /**
 504          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 505          */
 506         boolean compatible(Type found, Type req, Warner warn);
 507         /**
 508          * Report a check error
 509          */
 510         void report(DiagnosticPosition pos, JCDiagnostic details);
 511         /**
 512          * Obtain a warner for this check context
 513          */
</pre>
<hr />
<pre>
 579         public String toString() {
 580             return &quot;CheckContext: basicHandler&quot;;
 581         }
 582     };
 583 
 584     /** Check that a given type is assignable to a given proto-type.
 585      *  If it is, return the type, otherwise return errType.
 586      *  @param pos        Position to be used for error reporting.
 587      *  @param found      The type that was found.
 588      *  @param req        The type that was required.
 589      */
 590     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 591         return checkType(pos, found, req, basicHandler);
 592     }
 593 
 594     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 595         final InferenceContext inferenceContext = checkContext.inferenceContext();
 596         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 597             inferenceContext.addFreeTypeListener(List.of(req, found),
 598                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));





 599         }
 600         if (req.hasTag(ERROR))
 601             return req;
 602         if (req.hasTag(NONE))
 603             return found;
 604         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {



 605             return found;
 606         } else {
 607             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 608                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 609                 return types.createErrorType(found);
 610             }
 611             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 612             return types.createErrorType(found);
 613         }
 614     }
 615 
 616     /** Check that a given type can be cast to a given target type.
 617      *  Return the result of the cast.
 618      *  @param pos        Position to be used for error reporting.
 619      *  @param found      The type that is being cast.
 620      *  @param req        The target type of the cast.
 621      */
 622     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 623         return checkCastable(pos, found, req, basicHandler);
 624     }
 625     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 626         if (types.isCastable(found, req, castWarner(pos, found, req))) {







 627             return req;
 628         } else {
 629             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 630             return types.createErrorType(found);
 631         }
 632     }
 633 
 634     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 635      * The problem should only be reported for non-292 cast
 636      */
 637     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 638         if (!tree.type.isErroneous()
 639                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 640                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 641                 &amp;&amp; !is292targetTypeCast(tree)) {
 642             deferredLintHandler.report(() -&gt; {
 643                 if (lint.isEnabled(LintCategory.CAST))
 644                     log.warning(LintCategory.CAST,
 645                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 646             });
</pre>
<hr />
<pre>
 709     /** Check that type is a class or interface type.
 710      *  @param pos           Position to be used for error reporting.
 711      *  @param t             The type to be checked.
 712      */
 713     Type checkClassType(DiagnosticPosition pos, Type t) {
 714         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 715             return typeTagError(pos,
 716                                 diags.fragment(Fragments.TypeReqClass),
 717                                 asTypeParam(t));
 718         } else {
 719             return t;
 720         }
 721     }
 722     //where
 723         private Object asTypeParam(Type t) {
 724             return (t.hasTag(TYPEVAR))
 725                                     ? diags.fragment(Fragments.TypeParameter(t))
 726                                     : t;
 727         }
 728 











































 729     /** Check that type is a valid qualifier for a constructor reference expression
 730      */
 731     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 732         t = checkClassOrArrayType(pos, t);
 733         if (t.hasTag(CLASS)) {
 734             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 735                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 736                 t = types.createErrorType(t);
 737             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 738                 log.error(pos, Errors.EnumCantBeInstantiated);
 739                 t = types.createErrorType(t);
 740             } else {
 741                 t = checkClassType(pos, t, true);
 742             }
 743         } else if (t.hasTag(ARRAY)) {
 744             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 745                 log.error(pos, Errors.GenericArrayCreation);
 746                 t = types.createErrorType(t);
 747             }
 748         }
</pre>
<hr />
<pre>
 756      */
 757     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 758         t = checkClassType(pos, t);
 759         if (noBounds &amp;&amp; t.isParameterized()) {
 760             List&lt;Type&gt; args = t.getTypeArguments();
 761             while (args.nonEmpty()) {
 762                 if (args.head.hasTag(WILDCARD))
 763                     return typeTagError(pos,
 764                                         diags.fragment(Fragments.TypeReqExact),
 765                                         args.head);
 766                 args = args.tail;
 767             }
 768         }
 769         return t;
 770     }
 771 
 772     /** Check that type is a reference type, i.e. a class, interface or array type
 773      *  or a type variable.
 774      *  @param pos           Position to be used for error reporting.
 775      *  @param t             The type to be checked.

 776      */
<span class="line-modified"> 777     Type checkRefType(DiagnosticPosition pos, Type t) {</span>
<span class="line-modified"> 778         if (t.isReference())</span>
 779             return t;
 780         else
 781             return typeTagError(pos,
 782                                 diags.fragment(Fragments.TypeReqRef),
 783                                 t);
 784     }
 785 









 786     /** Check that each type is a reference type, i.e. a class, interface or array type
 787      *  or a type variable.
 788      *  @param trees         Original trees, used for error reporting.
 789      *  @param types         The types to be checked.
 790      */
 791     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 792         List&lt;JCExpression&gt; tl = trees;
 793         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
<span class="line-modified"> 794             l.head = checkRefType(tl.head.pos(), l.head);</span>
 795             tl = tl.tail;
 796         }
 797         return types;
 798     }
 799 
 800     /** Check that type is a null or reference type.
 801      *  @param pos           Position to be used for error reporting.
 802      *  @param t             The type to be checked.
 803      */
 804     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 805         if (t.isReference() || t.hasTag(BOT))
 806             return t;
 807         else
 808             return typeTagError(pos,
 809                                 diags.fragment(Fragments.TypeReqRef),
 810                                 t);
 811     }
 812 
 813     /** Check that flag set does not contain elements of two conflicting sets. s
 814      *  Return true if it doesn&#39;t.
 815      *  @param pos           Position to be used for error reporting.
 816      *  @param flags         The set of flags to be checked.
 817      *  @param set1          Conflicting flags set #1.
 818      *  @param set2          Conflicting flags set #2.
 819      */
 820     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 821         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 822             log.error(pos,
 823                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 824                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 825             return false;
 826         } else
 827             return true;
 828     }
 829 
















































 830     /** Check that usage of diamond operator is correct (i.e. diamond should not
 831      * be used with non-generic classes or in anonymous class creation expressions)
 832      */
 833     Type checkDiamond(JCNewClass tree, Type t) {
 834         if (!TreeInfo.isDiamond(tree) ||
 835                 t.isErroneous()) {
 836             return checkClassType(tree.clazz.pos(), t, true);
 837         } else {
 838             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 839                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 840                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 841             }
 842             if (t.tsym.type.getTypeArguments().isEmpty()) {
 843                 log.error(tree.clazz.pos(),
 844                           Errors.CantApplyDiamond1(t,
 845                                                    Fragments.DiamondNonGeneric(t)));
 846                 return types.createErrorType(t);
 847             } else if (tree.typeargs != null &amp;&amp;
 848                     tree.typeargs.nonEmpty()) {
 849                 log.error(tree.clazz.pos(),
</pre>
<hr />
<pre>
 958     }
 959     //where
 960         private boolean isTrustMeAllowedOnMethod(Symbol s) {
 961             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
 962                 (s.isConstructor() ||
 963                     (s.flags() &amp; (STATIC | FINAL |
 964                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
 965         }
 966 
 967     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
 968         //check that resulting type is not the null type
 969         if (t.hasTag(BOT)) {
 970             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
 971             return types.createErrorType(t);
 972         } else if (t.hasTag(VOID)) {
 973             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
 974             return types.createErrorType(t);
 975         }
 976 
 977         //upward project the initializer type
<span class="line-modified"> 978         return types.upward(t, types.captures(t));</span>





































 979     }
 980 
 981     Type checkMethod(final Type mtype,
 982             final Symbol sym,
 983             final Env&lt;AttrContext&gt; env,
 984             final List&lt;JCExpression&gt; argtrees,
 985             final List&lt;Type&gt; argtypes,
 986             final boolean useVarargs,
 987             InferenceContext inferenceContext) {
 988         // System.out.println(&quot;call   : &quot; + env.tree);
 989         // System.out.println(&quot;method : &quot; + owntype);
 990         // System.out.println(&quot;actuals: &quot; + argtypes);
 991         if (inferenceContext.free(mtype)) {
 992             inferenceContext.addFreeTypeListener(List.of(mtype),
 993                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
 994             return mtype;
 995         }
 996         Type owntype = mtype;
 997         List&lt;Type&gt; formals = owntype.getParameterTypes();
 998         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
</pre>
<hr />
<pre>
1156      *  return modifiers together with any implicit modifiers for that symbol.
1157      *  Warning: we can&#39;t use flags() here since this method
1158      *  is called during class enter, when flags() would cause a premature
1159      *  completion.
1160      *  @param pos           Position to be used for error reporting.
1161      *  @param flags         The set of modifiers given in a definition.
1162      *  @param sym           The defined symbol.
1163      */
1164     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1165         long mask;
1166         long implicit = 0;
1167 
1168         switch (sym.kind) {
1169         case VAR:
1170             if (TreeInfo.isReceiverParam(tree))
1171                 mask = ReceiverParamFlags;
1172             else if (sym.owner.kind != TYP)
1173                 mask = LocalVarFlags;
1174             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1175                 mask = implicit = InterfaceVarFlags;
<span class="line-modified">1176             else</span>
1177                 mask = VarFlags;




1178             break;
1179         case MTH:
1180             if (sym.name == names.init) {
1181                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1182                     // enum constructors cannot be declared public or
1183                     // protected and must be implicitly or explicitly
1184                     // private
1185                     implicit = PRIVATE;
1186                     mask = PRIVATE;
1187                 } else
1188                     mask = ConstructorFlags;
1189             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1190                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1191                     mask = AnnotationTypeElementMask;
1192                     implicit = PUBLIC | ABSTRACT;
1193                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1194                     mask = InterfaceMethodMask;
1195                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1196                     if ((flags &amp; DEFAULT) != 0) {
1197                         implicit |= ABSTRACT;
1198                     }
1199                 } else {
1200                     mask = implicit = InterfaceMethodFlags;
1201                 }
1202             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1203                 mask = RecordMethodFlags;
1204             } else {
<span class="line-modified">1205                 mask = MethodFlags;</span>


1206             }
1207             // Imply STRICTFP if owner has STRICTFP set.
1208             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1209                 ((flags) &amp; Flags.DEFAULT) != 0)
1210                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1211             break;
1212         case TYP:
1213             if (sym.isLocal()) {
1214                 boolean implicitlyStatic = !sym.isAnonymous() &amp;&amp;
1215                         ((flags &amp; RECORD) != 0 || (flags &amp; ENUM) != 0 || (flags &amp; INTERFACE) != 0);
1216                 boolean staticOrImplicitlyStatic = (flags &amp; STATIC) != 0 || implicitlyStatic;
1217                 mask = staticOrImplicitlyStatic &amp;&amp; allowRecords ? StaticLocalFlags : LocalClassFlags;
1218                 implicit = implicitlyStatic ? STATIC : implicit;
1219                 if (staticOrImplicitlyStatic) {
1220                     if (sym.owner.kind == TYP) {
1221                         log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1222                     }
1223                 }
1224             } else if (sym.owner.kind == TYP) {
1225                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;
1226                 if (sym.owner.owner.kind == PCK ||
1227                     (sym.owner.flags_field &amp; STATIC) != 0)
1228                     mask |= STATIC;
1229                 else if ((flags &amp; ENUM) != 0 || (flags &amp; RECORD) != 0) {
1230                     log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1231                 }
1232                 // Nested interfaces and enums are always STATIC (Spec ???)
1233                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1234             } else {
1235                 mask = ClassFlags;
1236             }
1237             // Interfaces are always ABSTRACT
1238             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1239 
1240             if ((flags &amp; ENUM) != 0) {
<span class="line-modified">1241                 // enums can&#39;t be declared abstract or final</span>
<span class="line-modified">1242                 mask &amp;= ~(ABSTRACT | FINAL);</span>
1243                 implicit |= implicitEnumFinalFlag(tree);
1244             }
1245             if ((flags &amp; RECORD) != 0) {
1246                 // records can&#39;t be declared abstract
1247                 mask &amp;= ~ABSTRACT;
1248                 implicit |= FINAL;
1249             }
1250             // Imply STRICTFP if owner has STRICTFP set.
1251             implicit |= sym.owner.flags_field &amp; STRICTFP;
1252             break;
1253         default:
1254             throw new AssertionError();
1255         }
1256         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1257         if (illegal != 0) {
1258             if ((illegal &amp; INTERFACE) != 0) {
1259                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1260                 mask |= INTERFACE;
1261             }
1262             else {
1263                 log.error(pos,
1264                         Errors.ModNotAllowedHere(asFlagSet(illegal)));
1265             }
1266         }
1267         else if ((sym.kind == TYP ||
1268                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1269                   // in the presence of inner classes. Should it be deleted here?
1270                   checkDisjoint(pos, flags,
1271                                 ABSTRACT,
1272                                 PRIVATE | STATIC | DEFAULT))
1273                  &amp;&amp;
1274                  checkDisjoint(pos, flags,
1275                                 STATIC | PRIVATE,
1276                                 DEFAULT)
1277                  &amp;&amp;
1278                  checkDisjoint(pos, flags,
1279                                ABSTRACT | INTERFACE,
<span class="line-modified">1280                                FINAL | NATIVE | SYNCHRONIZED)</span>
1281                  &amp;&amp;
1282                  checkDisjoint(pos, flags,
1283                                PUBLIC,
1284                                PRIVATE | PROTECTED)
1285                  &amp;&amp;
1286                  checkDisjoint(pos, flags,
1287                                PRIVATE,
1288                                PUBLIC | PROTECTED)
1289                  &amp;&amp;
<span class="line-modified">1290                  checkDisjoint(pos, flags,</span>
1291                                FINAL,
1292                                VOLATILE)
1293                  &amp;&amp;
1294                  (sym.kind == TYP ||
1295                   checkDisjoint(pos, flags,
1296                                 ABSTRACT | NATIVE,
1297                                 STRICTFP))) {
1298             // skip
1299         }
1300         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1301     }
1302 
1303 
1304     /** Determine if this enum should be implicitly final.
1305      *
1306      *  If the enum has no specialized enum constants, it is final.
1307      *
1308      *  If the enum does have specialized enum constants, it is
1309      *  &lt;i&gt;not&lt;/i&gt; final.
1310      */
</pre>
<hr />
<pre>
1438         @Override
1439         public void visitWildcard(JCWildcard tree) {
1440             if (tree.inner != null)
1441                 validateTree(tree.inner, true, isOuter);
1442         }
1443 
1444         @Override
1445         public void visitSelect(JCFieldAccess tree) {
1446             if (tree.type.hasTag(CLASS)) {
1447                 visitSelectInternal(tree);
1448 
1449                 // Check that this type is either fully parameterized, or
1450                 // not parameterized at all.
1451                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1452                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1453             }
1454         }
1455 
1456         public void visitSelectInternal(JCFieldAccess tree) {
1457             if (tree.type.tsym.isStatic() &amp;&amp;
<span class="line-modified">1458                 tree.selected.type.isParameterized()) {</span>

1459                 // The enclosing type is not a class, so we are
1460                 // looking at a static member type.  However, the
1461                 // qualifying expression is parameterized.


1462                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1463             } else {
1464                 // otherwise validate the rest of the expression
1465                 tree.selected.accept(this);
1466             }
1467         }
1468 
1469         @Override
1470         public void visitAnnotatedType(JCAnnotatedType tree) {
1471             tree.underlyingType.accept(this);
1472         }
1473 
1474         @Override
1475         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1476             if (that.type.hasTag(TypeTag.VOID)) {
1477                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1478             }
1479             super.visitTypeIdent(that);
1480         }
1481 
</pre>
<hr />
<pre>
1768             return;
1769         }
1770 
1771         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1772             // handled in validateAnnotationMethod
1773             return;
1774         }
1775 
1776         // Error if overriding method has weaker access (JLS 8.4.6.3).
1777         if (protection(m.flags()) &gt; protection(other.flags())) {
1778             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1779                       (other.flags() &amp; AccessFlags) == 0 ?
1780                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1781                                                           &quot;package&quot;) :
1782                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1783                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1784             m.flags_field |= BAD_OVERRIDE;
1785             return;
1786         }
1787 









1788         Type mt = types.memberType(origin.type, m);
1789         Type ot = types.memberType(origin.type, other);
1790         // Error if overriding result type is different
1791         // (or, in the case of generics mode, not a subtype) of
1792         // overridden result type. We have to rename any type parameters
1793         // before comparing types.
1794         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1795         List&lt;Type&gt; otvars = ot.getTypeArguments();
1796         Type mtres = mt.getReturnType();
1797         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1798 
1799         overrideWarner.clear();
1800         boolean resultTypesOK =
1801             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1802         if (!resultTypesOK) {
1803             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1804                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1805                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1806                                         other.location()), mtres, otres));
1807                 m.flags_field |= BAD_OVERRIDE;
</pre>
<hr />
<pre>
2080             if (recordComponent.isPresent()) {
2081                 return;
2082             }
2083         }
2084 
2085         for (Type t = origin.type; t.hasTag(CLASS);
2086              t = types.supertype(t)) {
2087             if (t != origin.type) {
2088                 checkOverride(tree, t, origin, m);
2089             }
2090             for (Type t2 : types.interfaces(t)) {
2091                 checkOverride(tree, t2, origin, m);
2092             }
2093         }
2094 
2095         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2096         // Check if this method must override a super method due to being annotated with @Override
2097         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2098         // be treated &quot;as if as they were annotated&quot; with @Override.
2099         boolean mustOverride = explicitOverride ||
<span class="line-modified">2100                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate());</span>

2101         if (mustOverride &amp;&amp; !isOverrider(m)) {
2102             DiagnosticPosition pos = tree.pos();
2103             for (JCAnnotation a : tree.getModifiers().annotations) {
2104                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2105                     pos = a.pos();
2106                     break;
2107                 }
2108             }
2109             log.error(pos,
2110                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2111                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2112         }
2113     }
2114 
2115     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2116         TypeSymbol c = site.tsym;
2117         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2118             if (m.overrides(sym, origin, types, false)) {
2119                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2120                     checkOverride(tree, m, (MethodSymbol)sym, origin);
</pre>
<hr />
<pre>
2206                 cf.accepts(s2) &amp;&amp;
2207                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2208     }
2209 
2210 
2211     /** Check that all abstract members of given class have definitions.
2212      *  @param pos          Position to be used for error reporting.
2213      *  @param c            The class.
2214      */
2215     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2216         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2217         if (undef != null) {
2218             MethodSymbol undef1 =
2219                 new MethodSymbol(undef.flags(), undef.name,
2220                                  types.memberType(c.type, undef), undef.owner);
2221             log.error(pos,
2222                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2223         }
2224     }
2225 







































2226     void checkNonCyclicDecl(JCClassDecl tree) {
2227         CycleChecker cc = new CycleChecker();
2228         cc.scan(tree);
2229         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2230             tree.sym.flags_field |= ACYCLIC;
2231         }
2232     }
2233 
2234     class CycleChecker extends TreeScanner {
2235 
2236         List&lt;Symbol&gt; seenClasses = List.nil();
2237         boolean errorFound = false;
2238         boolean partialCheck = false;
2239 
2240         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2241             if (sym != null &amp;&amp; sym.kind == TYP) {
2242                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2243                 if (classEnv != null) {
2244                     DiagnosticSource prevSource = log.currentSource();
2245                     try {
</pre>
<hr />
<pre>
2454     /** Check that all abstract methods implemented by a class are
2455      *  mutually compatible.
2456      *  @param pos          Position to be used for error reporting.
2457      *  @param c            The class whose interfaces are checked.
2458      */
2459     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2460         List&lt;Type&gt; supertypes = types.interfaces(c);
2461         Type supertype = types.supertype(c);
2462         if (supertype.hasTag(CLASS) &amp;&amp;
2463             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2464             supertypes = supertypes.prepend(supertype);
2465         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2466             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2467                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2468                 return;
2469             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2470                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2471                     return;
2472         }
2473         checkCompatibleConcretes(pos, c);




2474     }
2475 
2476     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2477      *  are mutually compatible (JLS 8.4.8/9.4.1).
2478      *
2479      *  @param pos  Position to be used for error reporting.
2480      *  @param site The class whose methods are checked.
2481      *  @param sym  The method symbol to be checked.
2482      */
2483     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2484          ClashFilter cf = new ClashFilter(site);
2485         //for each method m1 that is overridden (directly or indirectly)
2486         //by method &#39;sym&#39; in &#39;site&#39;...
2487 
2488         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2489         boolean overridesAny = false;
2490         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2491         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2492         for (Symbol m1 : symbolsByName) {
2493             if (!sym.overrides(m1, site.tsym, types, false)) {
</pre>
<hr />
<pre>
3013                                 }
3014                             }
3015                             modifiers.annotations = newAnnotations.toList();
3016                         }
3017                         // now lets remove it from the symbol
3018                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3019                     } else {
3020                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3021                     }
3022                 }
3023             }
3024         }
3025 
3026         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3027             if (s.kind != TYP) {
3028                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3029             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3030                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3031             }
3032         }







3033     }
3034 
3035     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3036         Assert.checkNonNull(a.type);
3037         validateAnnotationTree(a);
3038 
3039         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3040                 !a.annotationType.type.isErroneous() &amp;&amp;
3041                 !isTypeAnnotation(a, isTypeParameter)) {
3042             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3043         }
3044     }
3045 
3046     /**
3047      * Validate the proposed container &#39;repeatable&#39; on the
3048      * annotation type symbol &#39;s&#39;. Report errors at position
3049      * &#39;pos&#39;.
3050      *
3051      * @param s The (annotation)type declaration annotated with a @Repeatable
3052      * @param repeatable the @Repeatable on &#39;s&#39;
</pre>
</td>
<td>
<hr />
<pre>
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;
<span class="line-added">  98     private final boolean allowValueBasedClasses;</span>
  99 
 100     // The set of lint options currently in effect. It is initialized
 101     // from the context, and then is set/reset as needed by Attr as it
 102     // visits all the various parts of the trees during attribution.
 103     private Lint lint;
 104 
 105     // The method being analyzed in Attr - it is set/reset as needed by
 106     // Attr as it visits new method declarations.
 107     private MethodSymbol method;
 108 
 109     public static Check instance(Context context) {
 110         Check instance = context.get(checkKey);
 111         if (instance == null)
 112             instance = new Check(context);
 113         return instance;
 114     }
 115 
 116     protected Check(Context context) {
 117         context.put(checkKey, this);
 118 
 119         names = Names.instance(context);
 120         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 121             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 122             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 123         log = Log.instance(context);
 124         rs = Resolve.instance(context);
 125         syms = Symtab.instance(context);
 126         enter = Enter.instance(context);
 127         deferredAttr = DeferredAttr.instance(context);
 128         infer = Infer.instance(context);
 129         types = Types.instance(context);
 130         typeAnnotations = TypeAnnotations.instance(context);
 131         diags = JCDiagnostic.Factory.instance(context);
 132         Options options = Options.instance(context);
 133         lint = Lint.instance(context);
 134         fileManager = context.get(JavaFileManager.class);
 135 
 136         source = Source.instance(context);
 137         target = Target.instance(context);
 138         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
<span class="line-modified"> 139         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);</span>
 140         Target target = Target.instance(context);
 141         syntheticNameChar = target.syntheticNameChar();
 142 
 143         profile = Profile.instance(context);
 144         preview = Preview.instance(context);
 145 
 146         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 147         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 148         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 149         boolean enforceMandatoryWarnings = true;
 150 
 151         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 152                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 153         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 154                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 155         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 156                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 157         sunApiHandler = new MandatoryWarningHandler(log, false,
 158                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 159 
</pre>
<hr />
<pre>
 474         uncheckedHandler.clear();
 475         sunApiHandler.clear();
 476     }
 477 
 478     public void putCompiled(ClassSymbol csym) {
 479         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 480     }
 481 
 482     public ClassSymbol getCompiled(ClassSymbol csym) {
 483         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 484     }
 485 
 486     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 487         return compiled.get(Pair.of(msym, flatname));
 488     }
 489 
 490     public void removeCompiled(ClassSymbol csym) {
 491         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 492     }
 493 
<span class="line-modified"> 494     /* *************************************************************************</span>
 495  * Type Checking
 496  **************************************************************************/
 497 
 498     /**
 499      * A check context is an object that can be used to perform compatibility
 500      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 501      * vary significantly.
 502      */
 503     public interface CheckContext {
 504         /**
 505          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 506          */
 507         boolean compatible(Type found, Type req, Warner warn);
 508         /**
 509          * Report a check error
 510          */
 511         void report(DiagnosticPosition pos, JCDiagnostic details);
 512         /**
 513          * Obtain a warner for this check context
 514          */
</pre>
<hr />
<pre>
 580         public String toString() {
 581             return &quot;CheckContext: basicHandler&quot;;
 582         }
 583     };
 584 
 585     /** Check that a given type is assignable to a given proto-type.
 586      *  If it is, return the type, otherwise return errType.
 587      *  @param pos        Position to be used for error reporting.
 588      *  @param found      The type that was found.
 589      *  @param req        The type that was required.
 590      */
 591     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 592         return checkType(pos, found, req, basicHandler);
 593     }
 594 
 595     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 596         final InferenceContext inferenceContext = checkContext.inferenceContext();
 597         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 598             inferenceContext.addFreeTypeListener(List.of(req, found),
 599                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
<span class="line-added"> 600         } else {</span>
<span class="line-added"> 601             if (found.hasTag(CLASS)) {</span>
<span class="line-added"> 602                 if (inferenceContext != infer.emptyContext)</span>
<span class="line-added"> 603                     checkParameterizationWithValues(pos, found);</span>
<span class="line-added"> 604             }</span>
 605         }
 606         if (req.hasTag(ERROR))
 607             return req;
 608         if (req.hasTag(NONE))
 609             return found;
 610         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
<span class="line-added"> 611             if (found.hasTag(BOT) &amp;&amp; types.isValueBased(req)) {</span>
<span class="line-added"> 612                 log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));</span>
<span class="line-added"> 613             }</span>
 614             return found;
 615         } else {
 616             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 617                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 618                 return types.createErrorType(found);
 619             }
 620             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 621             return types.createErrorType(found);
 622         }
 623     }
 624 
 625     /** Check that a given type can be cast to a given target type.
 626      *  Return the result of the cast.
 627      *  @param pos        Position to be used for error reporting.
 628      *  @param found      The type that is being cast.
 629      *  @param req        The target type of the cast.
 630      */
 631     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 632         return checkCastable(pos, found, req, basicHandler);
 633     }
 634     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 635         if (types.isCastable(found, req, castWarner(pos, found, req))) {
<span class="line-added"> 636             if (types.isValueBased(req)) {</span>
<span class="line-added"> 637                 if (found.hasTag(BOT)) {</span>
<span class="line-added"> 638                     log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));</span>
<span class="line-added"> 639                 } else if (!types.isValueBased(found)) {</span>
<span class="line-added"> 640                     log.warning(pos, Warnings.PotentialNullPollution(found));</span>
<span class="line-added"> 641                 }</span>
<span class="line-added"> 642             }</span>
 643             return req;
 644         } else {
 645             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 646             return types.createErrorType(found);
 647         }
 648     }
 649 
 650     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 651      * The problem should only be reported for non-292 cast
 652      */
 653     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 654         if (!tree.type.isErroneous()
 655                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 656                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 657                 &amp;&amp; !is292targetTypeCast(tree)) {
 658             deferredLintHandler.report(() -&gt; {
 659                 if (lint.isEnabled(LintCategory.CAST))
 660                     log.warning(LintCategory.CAST,
 661                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 662             });
</pre>
<hr />
<pre>
 725     /** Check that type is a class or interface type.
 726      *  @param pos           Position to be used for error reporting.
 727      *  @param t             The type to be checked.
 728      */
 729     Type checkClassType(DiagnosticPosition pos, Type t) {
 730         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 731             return typeTagError(pos,
 732                                 diags.fragment(Fragments.TypeReqClass),
 733                                 asTypeParam(t));
 734         } else {
 735             return t;
 736         }
 737     }
 738     //where
 739         private Object asTypeParam(Type t) {
 740             return (t.hasTag(TYPEVAR))
 741                                     ? diags.fragment(Fragments.TypeParameter(t))
 742                                     : t;
 743         }
 744 
<span class="line-added"> 745     void checkConstraintsOfInlineSuper(DiagnosticPosition pos, ClassSymbol c) {</span>
<span class="line-added"> 746         for(Type st = types.supertype(c.type); st != Type.noType; st = types.supertype(st)) {</span>
<span class="line-added"> 747             if (st == null || st.tsym == null || st.tsym.kind == ERR)</span>
<span class="line-added"> 748                 return;</span>
<span class="line-added"> 749             if  (st.tsym == syms.objectType.tsym)</span>
<span class="line-added"> 750                 return;</span>
<span class="line-added"> 751             if (!st.tsym.isAbstract()) {</span>
<span class="line-added"> 752                 log.error(pos, Errors.ConcreteSupertypeForInlineClass(c, st));</span>
<span class="line-added"> 753             }</span>
<span class="line-added"> 754             if ((st.tsym.flags() &amp; HASINITBLOCK) != 0) {</span>
<span class="line-added"> 755                 log.error(pos, Errors.SuperClassDeclaresInitBlock(c, st));</span>
<span class="line-added"> 756             }</span>
<span class="line-added"> 757             // No instance fields and no arged constructors both mean inner classes cannot be inline supers.</span>
<span class="line-added"> 758             Type encl = st.getEnclosingType();</span>
<span class="line-added"> 759             if (encl != null &amp;&amp; encl.hasTag(CLASS)) {</span>
<span class="line-added"> 760                 log.error(pos, Errors.SuperClassCannotBeInner(c, st));</span>
<span class="line-added"> 761             }</span>
<span class="line-added"> 762             for (Symbol s : st.tsym.members().getSymbols(NON_RECURSIVE)) {</span>
<span class="line-added"> 763                 switch (s.kind) {</span>
<span class="line-added"> 764                 case VAR:</span>
<span class="line-added"> 765                     if ((s.flags() &amp; STATIC) == 0) {</span>
<span class="line-added"> 766                         log.error(pos, Errors.SuperFieldNotAllowed(s, c, st));</span>
<span class="line-added"> 767                     }</span>
<span class="line-added"> 768                     break;</span>
<span class="line-added"> 769                 case MTH:</span>
<span class="line-added"> 770                     if ((s.flags() &amp; SYNCHRONIZED) != 0) {</span>
<span class="line-added"> 771                         log.error(pos, Errors.SuperMethodCannotBeSynchronized(s, c, st));</span>
<span class="line-added"> 772                     } else if (s.isConstructor()) {</span>
<span class="line-added"> 773                         MethodSymbol m = (MethodSymbol)s;</span>
<span class="line-added"> 774                         if (m.getParameters().size() &gt; 0) {</span>
<span class="line-added"> 775                             log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, c, st));</span>
<span class="line-added"> 776                         } else {</span>
<span class="line-added"> 777                             if ((m.flags() &amp; (GENERATEDCONSTR | EMPTYNOARGCONSTR)) == 0) {</span>
<span class="line-added"> 778                                 log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, c, st));</span>
<span class="line-added"> 779                             }</span>
<span class="line-added"> 780                         }</span>
<span class="line-added"> 781                     }</span>
<span class="line-added"> 782                     break;</span>
<span class="line-added"> 783                 }</span>
<span class="line-added"> 784             }</span>
<span class="line-added"> 785         }</span>
<span class="line-added"> 786     }</span>
<span class="line-added"> 787 </span>
 788     /** Check that type is a valid qualifier for a constructor reference expression
 789      */
 790     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 791         t = checkClassOrArrayType(pos, t);
 792         if (t.hasTag(CLASS)) {
 793             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 794                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 795                 t = types.createErrorType(t);
 796             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 797                 log.error(pos, Errors.EnumCantBeInstantiated);
 798                 t = types.createErrorType(t);
 799             } else {
 800                 t = checkClassType(pos, t, true);
 801             }
 802         } else if (t.hasTag(ARRAY)) {
 803             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 804                 log.error(pos, Errors.GenericArrayCreation);
 805                 t = types.createErrorType(t);
 806             }
 807         }
</pre>
<hr />
<pre>
 815      */
 816     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 817         t = checkClassType(pos, t);
 818         if (noBounds &amp;&amp; t.isParameterized()) {
 819             List&lt;Type&gt; args = t.getTypeArguments();
 820             while (args.nonEmpty()) {
 821                 if (args.head.hasTag(WILDCARD))
 822                     return typeTagError(pos,
 823                                         diags.fragment(Fragments.TypeReqExact),
 824                                         args.head);
 825                 args = args.tail;
 826             }
 827         }
 828         return t;
 829     }
 830 
 831     /** Check that type is a reference type, i.e. a class, interface or array type
 832      *  or a type variable.
 833      *  @param pos           Position to be used for error reporting.
 834      *  @param t             The type to be checked.
<span class="line-added"> 835      *  @param valueOK       If false, a value class does not qualify</span>
 836      */
<span class="line-modified"> 837     Type checkRefType(DiagnosticPosition pos, Type t, boolean valueOK) {</span>
<span class="line-modified"> 838         if (t.isReference() &amp;&amp; (valueOK || !types.isValue(t)))</span>
 839             return t;
 840         else
 841             return typeTagError(pos,
 842                                 diags.fragment(Fragments.TypeReqRef),
 843                                 t);
 844     }
 845 
<span class="line-added"> 846     /** Check that type is a reference type, i.e. a class, interface or array type</span>
<span class="line-added"> 847      *  or a type variable.</span>
<span class="line-added"> 848      *  @param pos           Position to be used for error reporting.</span>
<span class="line-added"> 849      *  @param t             The type to be checked.</span>
<span class="line-added"> 850      */</span>
<span class="line-added"> 851     Type checkRefType(DiagnosticPosition pos, Type t) {</span>
<span class="line-added"> 852         return checkRefType(pos, t, true);</span>
<span class="line-added"> 853     }</span>
<span class="line-added"> 854 </span>
 855     /** Check that each type is a reference type, i.e. a class, interface or array type
 856      *  or a type variable.
 857      *  @param trees         Original trees, used for error reporting.
 858      *  @param types         The types to be checked.
 859      */
 860     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 861         List&lt;JCExpression&gt; tl = trees;
 862         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
<span class="line-modified"> 863             l.head = checkRefType(tl.head.pos(), l.head, false);</span>
 864             tl = tl.tail;
 865         }
 866         return types;
 867     }
 868 
 869     /** Check that type is a null or reference type.
 870      *  @param pos           Position to be used for error reporting.
 871      *  @param t             The type to be checked.
 872      */
 873     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 874         if (t.isReference() || t.hasTag(BOT))
 875             return t;
 876         else
 877             return typeTagError(pos,
 878                                 diags.fragment(Fragments.TypeReqRef),
 879                                 t);
 880     }
 881 
 882     /** Check that flag set does not contain elements of two conflicting sets. s
 883      *  Return true if it doesn&#39;t.
 884      *  @param pos           Position to be used for error reporting.
 885      *  @param flags         The set of flags to be checked.
 886      *  @param set1          Conflicting flags set #1.
 887      *  @param set2          Conflicting flags set #2.
 888      */
 889     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 890         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 891             log.error(pos,
 892                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 893                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 894             return false;
 895         } else
 896             return true;
 897     }
 898 
<span class="line-added"> 899     void checkParameterizationWithValues(DiagnosticPosition pos, Type t) {</span>
<span class="line-added"> 900         valueParameterizationChecker.visit(t, pos);</span>
<span class="line-added"> 901     }</span>
<span class="line-added"> 902 </span>
<span class="line-added"> 903     /** valueParameterizationChecker: A type visitor that descends down the given type looking for instances of value types</span>
<span class="line-added"> 904      *  being used as type arguments and issues error against those usages.</span>
<span class="line-added"> 905      */</span>
<span class="line-added"> 906     private final Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt; valueParameterizationChecker = new Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt;() {</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908         @Override</span>
<span class="line-added"> 909         public Void visitType(Type t, DiagnosticPosition pos) {</span>
<span class="line-added"> 910             return null;</span>
<span class="line-added"> 911         }</span>
<span class="line-added"> 912 </span>
<span class="line-added"> 913         @Override</span>
<span class="line-added"> 914         public Void visitClassType(ClassType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 915             for (Type targ : t.allparams()) {</span>
<span class="line-added"> 916                 if (types.isValue(targ)) {</span>
<span class="line-added"> 917                     log.error(pos, Errors.GenericParameterizationWithValueType(t));</span>
<span class="line-added"> 918                 }</span>
<span class="line-added"> 919                 visit(targ, pos);</span>
<span class="line-added"> 920             }</span>
<span class="line-added"> 921             return null;</span>
<span class="line-added"> 922         }</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924         @Override</span>
<span class="line-added"> 925         public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {</span>
<span class="line-added"> 926              return null;</span>
<span class="line-added"> 927         }</span>
<span class="line-added"> 928 </span>
<span class="line-added"> 929         @Override</span>
<span class="line-added"> 930         public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 931             return null;</span>
<span class="line-added"> 932         }</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934         @Override</span>
<span class="line-added"> 935         public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 936             return visit(t.elemtype, pos);</span>
<span class="line-added"> 937         }</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939         @Override</span>
<span class="line-added"> 940         public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 941             return visit(t.type, pos);</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943     };</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945 </span>
<span class="line-added"> 946 </span>
 947     /** Check that usage of diamond operator is correct (i.e. diamond should not
 948      * be used with non-generic classes or in anonymous class creation expressions)
 949      */
 950     Type checkDiamond(JCNewClass tree, Type t) {
 951         if (!TreeInfo.isDiamond(tree) ||
 952                 t.isErroneous()) {
 953             return checkClassType(tree.clazz.pos(), t, true);
 954         } else {
 955             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 956                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 957                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 958             }
 959             if (t.tsym.type.getTypeArguments().isEmpty()) {
 960                 log.error(tree.clazz.pos(),
 961                           Errors.CantApplyDiamond1(t,
 962                                                    Fragments.DiamondNonGeneric(t)));
 963                 return types.createErrorType(t);
 964             } else if (tree.typeargs != null &amp;&amp;
 965                     tree.typeargs.nonEmpty()) {
 966                 log.error(tree.clazz.pos(),
</pre>
<hr />
<pre>
1075     }
1076     //where
1077         private boolean isTrustMeAllowedOnMethod(Symbol s) {
1078             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
1079                 (s.isConstructor() ||
1080                     (s.flags() &amp; (STATIC | FINAL |
1081                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
1082         }
1083 
1084     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
1085         //check that resulting type is not the null type
1086         if (t.hasTag(BOT)) {
1087             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
1088             return types.createErrorType(t);
1089         } else if (t.hasTag(VOID)) {
1090             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
1091             return types.createErrorType(t);
1092         }
1093 
1094         //upward project the initializer type
<span class="line-modified">1095         Type varType = types.upward(t, types.captures(t));</span>
<span class="line-added">1096         if (varType.hasTag(CLASS)) {</span>
<span class="line-added">1097             checkParameterizationWithValues(pos, varType);</span>
<span class="line-added">1098         }</span>
<span class="line-added">1099         return varType;</span>
<span class="line-added">1100     }</span>
<span class="line-added">1101 </span>
<span class="line-added">1102     public void checkForSuspectClassLiteralComparison(</span>
<span class="line-added">1103             final JCBinary tree,</span>
<span class="line-added">1104             final Type leftType,</span>
<span class="line-added">1105             final Type rightType) {</span>
<span class="line-added">1106 </span>
<span class="line-added">1107         if (lint.isEnabled(LintCategory.MIGRATION)) {</span>
<span class="line-added">1108             if (isInvocationOfGetClass(tree.lhs) &amp;&amp; isClassOfSomeInterface(rightType) ||</span>
<span class="line-added">1109                     isInvocationOfGetClass(tree.rhs) &amp;&amp; isClassOfSomeInterface(leftType)) {</span>
<span class="line-added">1110                 log.warning(LintCategory.MIGRATION, tree.pos(), Warnings.GetClassComparedWithInterface);</span>
<span class="line-added">1111             }</span>
<span class="line-added">1112         }</span>
<span class="line-added">1113     }</span>
<span class="line-added">1114     //where</span>
<span class="line-added">1115     private boolean isClassOfSomeInterface(Type someClass) {</span>
<span class="line-added">1116         if (someClass.tsym.flatName() == names.java_lang_Class) {</span>
<span class="line-added">1117             List&lt;Type&gt; arguments = someClass.getTypeArguments();</span>
<span class="line-added">1118             if (arguments.length() == 1) {</span>
<span class="line-added">1119                 return arguments.head.isInterface();</span>
<span class="line-added">1120             }</span>
<span class="line-added">1121         }</span>
<span class="line-added">1122         return false;</span>
<span class="line-added">1123     }</span>
<span class="line-added">1124     //where</span>
<span class="line-added">1125     private boolean isInvocationOfGetClass(JCExpression tree) {</span>
<span class="line-added">1126         tree = TreeInfo.skipParens(tree);</span>
<span class="line-added">1127         if (tree.hasTag(APPLY)) {</span>
<span class="line-added">1128             JCMethodInvocation apply = (JCMethodInvocation)tree;</span>
<span class="line-added">1129             MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(apply.meth);</span>
<span class="line-added">1130             return msym.name == names.getClass &amp;&amp; msym.implementedIn(syms.objectType.tsym, types) != null;</span>
<span class="line-added">1131         }</span>
<span class="line-added">1132         return false;</span>
1133     }
1134 
1135     Type checkMethod(final Type mtype,
1136             final Symbol sym,
1137             final Env&lt;AttrContext&gt; env,
1138             final List&lt;JCExpression&gt; argtrees,
1139             final List&lt;Type&gt; argtypes,
1140             final boolean useVarargs,
1141             InferenceContext inferenceContext) {
1142         // System.out.println(&quot;call   : &quot; + env.tree);
1143         // System.out.println(&quot;method : &quot; + owntype);
1144         // System.out.println(&quot;actuals: &quot; + argtypes);
1145         if (inferenceContext.free(mtype)) {
1146             inferenceContext.addFreeTypeListener(List.of(mtype),
1147                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
1148             return mtype;
1149         }
1150         Type owntype = mtype;
1151         List&lt;Type&gt; formals = owntype.getParameterTypes();
1152         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
</pre>
<hr />
<pre>
1310      *  return modifiers together with any implicit modifiers for that symbol.
1311      *  Warning: we can&#39;t use flags() here since this method
1312      *  is called during class enter, when flags() would cause a premature
1313      *  completion.
1314      *  @param pos           Position to be used for error reporting.
1315      *  @param flags         The set of modifiers given in a definition.
1316      *  @param sym           The defined symbol.
1317      */
1318     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1319         long mask;
1320         long implicit = 0;
1321 
1322         switch (sym.kind) {
1323         case VAR:
1324             if (TreeInfo.isReceiverParam(tree))
1325                 mask = ReceiverParamFlags;
1326             else if (sym.owner.kind != TYP)
1327                 mask = LocalVarFlags;
1328             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1329                 mask = implicit = InterfaceVarFlags;
<span class="line-modified">1330             else {</span>
1331                 mask = VarFlags;
<span class="line-added">1332                 if (types.isValue(sym.owner.type) &amp;&amp; (flags &amp; STATIC) == 0) {</span>
<span class="line-added">1333                     implicit |= FINAL;</span>
<span class="line-added">1334                 }</span>
<span class="line-added">1335             }</span>
1336             break;
1337         case MTH:
1338             if (sym.name == names.init) {
1339                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1340                     // enum constructors cannot be declared public or
1341                     // protected and must be implicitly or explicitly
1342                     // private
1343                     implicit = PRIVATE;
1344                     mask = PRIVATE;
1345                 } else
1346                     mask = ConstructorFlags;
1347             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1348                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1349                     mask = AnnotationTypeElementMask;
1350                     implicit = PUBLIC | ABSTRACT;
1351                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1352                     mask = InterfaceMethodMask;
1353                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1354                     if ((flags &amp; DEFAULT) != 0) {
1355                         implicit |= ABSTRACT;
1356                     }
1357                 } else {
1358                     mask = implicit = InterfaceMethodFlags;
1359                 }
1360             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1361                 mask = RecordMethodFlags;
1362             } else {
<span class="line-modified">1363                 // instance methods of value types do not have a monitor associated with their `this&#39;</span>
<span class="line-added">1364                 mask = ((sym.owner.flags_field &amp; VALUE) != 0 &amp;&amp; (flags &amp; Flags.STATIC) == 0) ?</span>
<span class="line-added">1365                         MethodFlags &amp; ~SYNCHRONIZED : MethodFlags;</span>
1366             }
1367             // Imply STRICTFP if owner has STRICTFP set.
1368             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1369                 ((flags) &amp; Flags.DEFAULT) != 0)
1370                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1371             break;
1372         case TYP:
1373             if (sym.isLocal()) {
1374                 boolean implicitlyStatic = !sym.isAnonymous() &amp;&amp;
1375                         ((flags &amp; RECORD) != 0 || (flags &amp; ENUM) != 0 || (flags &amp; INTERFACE) != 0);
1376                 boolean staticOrImplicitlyStatic = (flags &amp; STATIC) != 0 || implicitlyStatic;
1377                 mask = staticOrImplicitlyStatic &amp;&amp; allowRecords ? StaticLocalFlags : LocalClassFlags;
1378                 implicit = implicitlyStatic ? STATIC : implicit;
1379                 if (staticOrImplicitlyStatic) {
1380                     if (sym.owner.kind == TYP) {
1381                         log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1382                     }
1383                 }
1384             } else if (sym.owner.kind == TYP) {
1385                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;
1386                 if (sym.owner.owner.kind == PCK ||
1387                     (sym.owner.flags_field &amp; STATIC) != 0)
1388                     mask |= STATIC;
1389                 else if ((flags &amp; ENUM) != 0 || (flags &amp; RECORD) != 0) {
1390                     log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1391                 }
1392                 // Nested interfaces and enums are always STATIC (Spec ???)
1393                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1394             } else {
1395                 mask = ClassFlags;
1396             }
1397             // Interfaces are always ABSTRACT
1398             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1399 
1400             if ((flags &amp; ENUM) != 0) {
<span class="line-modified">1401                 // enums can&#39;t be declared abstract or final or value type</span>
<span class="line-modified">1402                 mask &amp;= ~(ABSTRACT | FINAL | VALUE);</span>
1403                 implicit |= implicitEnumFinalFlag(tree);
1404             }
1405             if ((flags &amp; RECORD) != 0) {
1406                 // records can&#39;t be declared abstract
1407                 mask &amp;= ~ABSTRACT;
1408                 implicit |= FINAL;
1409             }
1410             // Imply STRICTFP if owner has STRICTFP set.
1411             implicit |= sym.owner.flags_field &amp; STRICTFP;
1412             break;
1413         default:
1414             throw new AssertionError();
1415         }
1416         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1417         if (illegal != 0) {
1418             if ((illegal &amp; INTERFACE) != 0) {
1419                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1420                 mask |= INTERFACE;
1421             }
1422             else {
1423                 log.error(pos,
1424                         Errors.ModNotAllowedHere(asFlagSet(illegal)));
1425             }
1426         }
1427         else if ((sym.kind == TYP ||
1428                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1429                   // in the presence of inner classes. Should it be deleted here?
1430                   checkDisjoint(pos, flags,
1431                                 ABSTRACT,
1432                                 PRIVATE | STATIC | DEFAULT))
1433                  &amp;&amp;
1434                  checkDisjoint(pos, flags,
1435                                 STATIC | PRIVATE,
1436                                 DEFAULT)
1437                  &amp;&amp;
1438                  checkDisjoint(pos, flags,
1439                                ABSTRACT | INTERFACE,
<span class="line-modified">1440                                FINAL | NATIVE | SYNCHRONIZED | VALUE)</span>
1441                  &amp;&amp;
1442                  checkDisjoint(pos, flags,
1443                                PUBLIC,
1444                                PRIVATE | PROTECTED)
1445                  &amp;&amp;
1446                  checkDisjoint(pos, flags,
1447                                PRIVATE,
1448                                PUBLIC | PROTECTED)
1449                  &amp;&amp;
<span class="line-modified">1450                  checkDisjoint(pos, (flags | implicit), // complain against volatile &amp; implcitly final entities too.</span>
1451                                FINAL,
1452                                VOLATILE)
1453                  &amp;&amp;
1454                  (sym.kind == TYP ||
1455                   checkDisjoint(pos, flags,
1456                                 ABSTRACT | NATIVE,
1457                                 STRICTFP))) {
1458             // skip
1459         }
1460         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1461     }
1462 
1463 
1464     /** Determine if this enum should be implicitly final.
1465      *
1466      *  If the enum has no specialized enum constants, it is final.
1467      *
1468      *  If the enum does have specialized enum constants, it is
1469      *  &lt;i&gt;not&lt;/i&gt; final.
1470      */
</pre>
<hr />
<pre>
1598         @Override
1599         public void visitWildcard(JCWildcard tree) {
1600             if (tree.inner != null)
1601                 validateTree(tree.inner, true, isOuter);
1602         }
1603 
1604         @Override
1605         public void visitSelect(JCFieldAccess tree) {
1606             if (tree.type.hasTag(CLASS)) {
1607                 visitSelectInternal(tree);
1608 
1609                 // Check that this type is either fully parameterized, or
1610                 // not parameterized at all.
1611                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1612                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1613             }
1614         }
1615 
1616         public void visitSelectInternal(JCFieldAccess tree) {
1617             if (tree.type.tsym.isStatic() &amp;&amp;
<span class="line-modified">1618                 tree.selected.type.isParameterized() &amp;&amp;</span>
<span class="line-added">1619                     (tree.name != names.ref || !tree.type.isReferenceProjection())) {</span>
1620                 // The enclosing type is not a class, so we are
1621                 // looking at a static member type.  However, the
1622                 // qualifying expression is parameterized.
<span class="line-added">1623                 // Tolerate the pseudo-select V.ref: V&lt;T&gt;.ref will be static if V&lt;T&gt; is and</span>
<span class="line-added">1624                 // should not be confused as selecting a static member of a parameterized type.</span>
1625                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1626             } else {
1627                 // otherwise validate the rest of the expression
1628                 tree.selected.accept(this);
1629             }
1630         }
1631 
1632         @Override
1633         public void visitAnnotatedType(JCAnnotatedType tree) {
1634             tree.underlyingType.accept(this);
1635         }
1636 
1637         @Override
1638         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1639             if (that.type.hasTag(TypeTag.VOID)) {
1640                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1641             }
1642             super.visitTypeIdent(that);
1643         }
1644 
</pre>
<hr />
<pre>
1931             return;
1932         }
1933 
1934         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1935             // handled in validateAnnotationMethod
1936             return;
1937         }
1938 
1939         // Error if overriding method has weaker access (JLS 8.4.6.3).
1940         if (protection(m.flags()) &gt; protection(other.flags())) {
1941             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1942                       (other.flags() &amp; AccessFlags) == 0 ?
1943                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1944                                                           &quot;package&quot;) :
1945                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1946                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1947             m.flags_field |= BAD_OVERRIDE;
1948             return;
1949         }
1950 
<span class="line-added">1951         if (origin.isValue() &amp;&amp; other.owner == syms.objectType.tsym &amp;&amp; m.type.getParameterTypes().size() == 0) {</span>
<span class="line-added">1952             if (m.name == names.clone || m.name == names.finalize) {</span>
<span class="line-added">1953                 log.error(TreeInfo.diagnosticPositionFor(m, tree),</span>
<span class="line-added">1954                         Errors.InlineClassMayNotOverride(m.name));</span>
<span class="line-added">1955                 m.flags_field |= BAD_OVERRIDE;</span>
<span class="line-added">1956                 return;</span>
<span class="line-added">1957             }</span>
<span class="line-added">1958         }</span>
<span class="line-added">1959 </span>
1960         Type mt = types.memberType(origin.type, m);
1961         Type ot = types.memberType(origin.type, other);
1962         // Error if overriding result type is different
1963         // (or, in the case of generics mode, not a subtype) of
1964         // overridden result type. We have to rename any type parameters
1965         // before comparing types.
1966         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1967         List&lt;Type&gt; otvars = ot.getTypeArguments();
1968         Type mtres = mt.getReturnType();
1969         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1970 
1971         overrideWarner.clear();
1972         boolean resultTypesOK =
1973             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1974         if (!resultTypesOK) {
1975             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1976                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1977                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1978                                         other.location()), mtres, otres));
1979                 m.flags_field |= BAD_OVERRIDE;
</pre>
<hr />
<pre>
2252             if (recordComponent.isPresent()) {
2253                 return;
2254             }
2255         }
2256 
2257         for (Type t = origin.type; t.hasTag(CLASS);
2258              t = types.supertype(t)) {
2259             if (t != origin.type) {
2260                 checkOverride(tree, t, origin, m);
2261             }
2262             for (Type t2 : types.interfaces(t)) {
2263                 checkOverride(tree, t2, origin, m);
2264             }
2265         }
2266 
2267         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2268         // Check if this method must override a super method due to being annotated with @Override
2269         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2270         // be treated &quot;as if as they were annotated&quot; with @Override.
2271         boolean mustOverride = explicitOverride ||
<span class="line-modified">2272                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate() &amp;&amp;</span>
<span class="line-added">2273                         (!m.owner.isValue() || (tree.body.flags &amp; SYNTHETIC) == 0));</span>
2274         if (mustOverride &amp;&amp; !isOverrider(m)) {
2275             DiagnosticPosition pos = tree.pos();
2276             for (JCAnnotation a : tree.getModifiers().annotations) {
2277                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2278                     pos = a.pos();
2279                     break;
2280                 }
2281             }
2282             log.error(pos,
2283                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2284                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2285         }
2286     }
2287 
2288     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2289         TypeSymbol c = site.tsym;
2290         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2291             if (m.overrides(sym, origin, types, false)) {
2292                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2293                     checkOverride(tree, m, (MethodSymbol)sym, origin);
</pre>
<hr />
<pre>
2379                 cf.accepts(s2) &amp;&amp;
2380                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2381     }
2382 
2383 
2384     /** Check that all abstract members of given class have definitions.
2385      *  @param pos          Position to be used for error reporting.
2386      *  @param c            The class.
2387      */
2388     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2389         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2390         if (undef != null) {
2391             MethodSymbol undef1 =
2392                 new MethodSymbol(undef.flags(), undef.name,
2393                                  types.memberType(c.type, undef), undef.owner);
2394             log.error(pos,
2395                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2396         }
2397     }
2398 
<span class="line-added">2399     // A value class cannot contain a field of its own type either or indirectly.</span>
<span class="line-added">2400     void checkNonCyclicMembership(JCClassDecl tree) {</span>
<span class="line-added">2401         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);</span>
<span class="line-added">2402         try {</span>
<span class="line-added">2403             tree.sym.flags_field |= LOCKED;</span>
<span class="line-added">2404             for (List&lt;? extends JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {</span>
<span class="line-added">2405                 if (l.head.hasTag(VARDEF)) {</span>
<span class="line-added">2406                     JCVariableDecl field = (JCVariableDecl) l.head;</span>
<span class="line-added">2407                     if (cyclePossible(field.sym)) {</span>
<span class="line-added">2408                         Type fieldType = field.sym.type;</span>
<span class="line-added">2409                         checkNonCyclicMembership((ClassSymbol) fieldType.tsym, field.pos());</span>
<span class="line-added">2410                     }</span>
<span class="line-added">2411                 }</span>
<span class="line-added">2412             }</span>
<span class="line-added">2413         } finally {</span>
<span class="line-added">2414             tree.sym.flags_field &amp;= ~LOCKED;</span>
<span class="line-added">2415         }</span>
<span class="line-added">2416 </span>
<span class="line-added">2417     }</span>
<span class="line-added">2418     // where</span>
<span class="line-added">2419     private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {</span>
<span class="line-added">2420         if ((c.flags_field &amp; LOCKED) != 0) {</span>
<span class="line-added">2421             log.error(pos, Errors.CyclicValueTypeMembership(c));</span>
<span class="line-added">2422             return;</span>
<span class="line-added">2423         }</span>
<span class="line-added">2424         try {</span>
<span class="line-added">2425             c.flags_field |= LOCKED;</span>
<span class="line-added">2426             for (Symbol fld : c.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; cyclePossible((VarSymbol) s), NON_RECURSIVE)) {</span>
<span class="line-added">2427                 checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);</span>
<span class="line-added">2428             }</span>
<span class="line-added">2429         } finally {</span>
<span class="line-added">2430             c.flags_field &amp;= ~LOCKED;</span>
<span class="line-added">2431         }</span>
<span class="line-added">2432     }</span>
<span class="line-added">2433         // where</span>
<span class="line-added">2434         private boolean cyclePossible(VarSymbol symbol) {</span>
<span class="line-added">2435             return (symbol.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(symbol.type);</span>
<span class="line-added">2436         }</span>
<span class="line-added">2437 </span>
2438     void checkNonCyclicDecl(JCClassDecl tree) {
2439         CycleChecker cc = new CycleChecker();
2440         cc.scan(tree);
2441         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2442             tree.sym.flags_field |= ACYCLIC;
2443         }
2444     }
2445 
2446     class CycleChecker extends TreeScanner {
2447 
2448         List&lt;Symbol&gt; seenClasses = List.nil();
2449         boolean errorFound = false;
2450         boolean partialCheck = false;
2451 
2452         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2453             if (sym != null &amp;&amp; sym.kind == TYP) {
2454                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2455                 if (classEnv != null) {
2456                     DiagnosticSource prevSource = log.currentSource();
2457                     try {
</pre>
<hr />
<pre>
2666     /** Check that all abstract methods implemented by a class are
2667      *  mutually compatible.
2668      *  @param pos          Position to be used for error reporting.
2669      *  @param c            The class whose interfaces are checked.
2670      */
2671     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2672         List&lt;Type&gt; supertypes = types.interfaces(c);
2673         Type supertype = types.supertype(c);
2674         if (supertype.hasTag(CLASS) &amp;&amp;
2675             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2676             supertypes = supertypes.prepend(supertype);
2677         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2678             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2679                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2680                 return;
2681             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2682                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2683                     return;
2684         }
2685         checkCompatibleConcretes(pos, c);
<span class="line-added">2686 </span>
<span class="line-added">2687         if (c.isValue() &amp;&amp; types.asSuper(c, syms.identityObjectType.tsym, true) != null) {</span>
<span class="line-added">2688             log.error(pos, Errors.InlineTypeMustNotImplementIdentityObject(c));</span>
<span class="line-added">2689         }</span>
2690     }
2691 
2692     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2693      *  are mutually compatible (JLS 8.4.8/9.4.1).
2694      *
2695      *  @param pos  Position to be used for error reporting.
2696      *  @param site The class whose methods are checked.
2697      *  @param sym  The method symbol to be checked.
2698      */
2699     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2700          ClashFilter cf = new ClashFilter(site);
2701         //for each method m1 that is overridden (directly or indirectly)
2702         //by method &#39;sym&#39; in &#39;site&#39;...
2703 
2704         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2705         boolean overridesAny = false;
2706         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2707         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2708         for (Symbol m1 : symbolsByName) {
2709             if (!sym.overrides(m1, site.tsym, types, false)) {
</pre>
<hr />
<pre>
3229                                 }
3230                             }
3231                             modifiers.annotations = newAnnotations.toList();
3232                         }
3233                         // now lets remove it from the symbol
3234                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3235                     } else {
3236                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3237                     }
3238                 }
3239             }
3240         }
3241 
3242         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3243             if (s.kind != TYP) {
3244                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3245             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3246                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3247             }
3248         }
<span class="line-added">3249         if (a.annotationType.type.tsym == syms.valueBasedType.tsym) {</span>
<span class="line-added">3250             if (s.isInterface() || s.isEnum()) {</span>
<span class="line-added">3251                 log.error(a.pos(), Errors.BadValueBasedAnno);</span>
<span class="line-added">3252             } else if (allowValueBasedClasses) {</span>
<span class="line-added">3253                 s.flags_field |= VALUEBASED;</span>
<span class="line-added">3254             }</span>
<span class="line-added">3255         }</span>
3256     }
3257 
3258     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3259         Assert.checkNonNull(a.type);
3260         validateAnnotationTree(a);
3261 
3262         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3263                 !a.annotationType.type.isErroneous() &amp;&amp;
3264                 !isTypeAnnotation(a, isTypeParameter)) {
3265             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3266         }
3267     }
3268 
3269     /**
3270      * Validate the proposed container &#39;repeatable&#39; on the
3271      * annotation type symbol &#39;s&#39;. Report errors at position
3272      * &#39;pos&#39;.
3273      *
3274      * @param s The (annotation)type declaration annotated with a @Repeatable
3275      * @param repeatable the @Repeatable on &#39;s&#39;
</pre>
</td>
</tr>
</table>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
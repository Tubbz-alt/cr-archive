<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
<span class="line-removed">  30 import java.util.stream.Collectors;</span>
  31 
  32 import javax.lang.model.element.ElementKind;
  33 import javax.tools.JavaFileObject;
  34 
  35 import com.sun.source.tree.CaseTree;
  36 import com.sun.source.tree.IdentifierTree;
  37 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  38 import com.sun.source.tree.MemberSelectTree;
  39 import com.sun.source.tree.TreeVisitor;
  40 import com.sun.source.util.SimpleTreeVisitor;
  41 import com.sun.tools.javac.code.*;
  42 import com.sun.tools.javac.code.Lint.LintCategory;
  43 import com.sun.tools.javac.code.Scope.WriteableScope;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Symbol.*;
  46 import com.sun.tools.javac.code.Type.*;
  47 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  48 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  49 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  50 import com.sun.tools.javac.comp.Check.CheckContext;
</pre>
<hr />
<pre>
 149         target = Target.instance(context);
 150         types = Types.instance(context);
 151         preview = Preview.instance(context);
 152         diags = JCDiagnostic.Factory.instance(context);
 153         annotate = Annotate.instance(context);
 154         typeAnnotations = TypeAnnotations.instance(context);
 155         deferredLintHandler = DeferredLintHandler.instance(context);
 156         typeEnvs = TypeEnvs.instance(context);
 157         dependencies = Dependencies.instance(context);
 158         argumentAttr = ArgumentAttr.instance(context);
 159         matchBindingsComputer = MatchBindingsComputer.instance(context);
 160 
 161         Options options = Options.instance(context);
 162 
 163         Source source = Source.instance(context);
 164         allowPoly = Feature.POLY.allowedInSource(source);
 165         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 166         allowLambda = Feature.LAMBDA.allowedInSource(source);
 167         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 168         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);

 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);


 174 
 175         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 176         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 177         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 178         methodAttrInfo = new MethodAttrInfo();
 179         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 180         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 181         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 182     }
 183 
 184     /** Switch: support target-typing inference
 185      */
 186     boolean allowPoly;
 187 
 188     /** Switch: support type annotations.
 189      */
 190     boolean allowTypeAnnos;
 191 
 192     /** Switch: support lambda expressions ?
 193      */
 194     boolean allowLambda;
 195 
 196     /** Switch: support default methods ?
 197      */
 198     boolean allowDefaultMethods;
 199 




 200     /** Switch: static interface methods enabled?
 201      */
 202     boolean allowStaticInterfaceMethods;
 203 
 204     /** Switch: reifiable types in instanceof enabled?
 205      */
 206     boolean allowReifiableTypesInInstanceof;
 207 
 208     /**
 209      * Switch: warn about use of variable before declaration?
 210      * RFE: 6425594
 211      */
 212     boolean useBeforeDeclarationWarning;
 213 










 214     /**
 215      * Switch: name of source level; used for error reporting.
 216      */
 217     String sourceName;
 218 
 219     /** Check kind and type of given tree against protokind and prototype.
 220      *  If check succeeds, store type in tree and return it.
 221      *  If check fails, store errType in tree and return it.
 222      *  No checks are performed if the prototype is a method type.
 223      *  It is not necessary in this case since we know that kind and type
 224      *  are correct.
 225      *
 226      *  @param tree     The tree whose kind and type is checked
 227      *  @param found    The computed type of the tree
 228      *  @param ownkind  The computed kind of the tree
 229      *  @param resultInfo  The expected result of the tree
 230      */
 231     Type check(final JCTree tree,
 232                final Type found,
 233                final KindSelector ownkind,
</pre>
<hr />
<pre>
 292      *  @param pos    The current source code position.
 293      *  @param v      The assigned variable
 294      *  @param base   If the variable is referred to in a Select, the part
 295      *                to the left of the `.&#39;, null otherwise.
 296      *  @param env    The current environment.
 297      */
 298     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 299         if (v.name == names._this) {
 300             log.error(pos, Errors.CantAssignValToThis);
 301         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 302             ((v.flags() &amp; HASINIT) != 0
 303              ||
 304              !((base == null ||
 305                TreeInfo.isThisQualifier(base)) &amp;&amp;
 306                isAssignableAsBlankFinal(v, env)))) {
 307             if (v.isResourceVariable()) { //TWR resource
 308                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 309             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 310                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 311             } else {
<span class="line-modified"> 312                 log.error(pos, Errors.CantAssignValToFinalVar(v));</span>










 313             }
 314         }
 315     }
 316 
 317     /** Does tree represent a static reference to an identifier?
 318      *  It is assumed that tree is either a SELECT or an IDENT.
 319      *  We have to weed out selects from non-type names here.
 320      *  @param tree    The candidate tree.
 321      */
 322     boolean isStaticReference(JCTree tree) {
 323         if (tree.hasTag(SELECT)) {
 324             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 325             if (lsym == null || lsym.kind != TYP) {
 326                 return false;
 327             }
 328         }
 329         return true;
 330     }
 331 
 332     /** Is this symbol a type?
</pre>
<hr />
<pre>
 784     /** Attribute a type argument list, returning a list of types.
 785      *  Check that all the types are references.
 786      */
 787     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 788         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 789         return chk.checkRefTypes(trees, types);
 790     }
 791 
 792     /**
 793      * Attribute type variables (of generic classes or methods).
 794      * Compound types are attributed later in attribBounds.
 795      * @param typarams the type variables to enter
 796      * @param env      the current environment
 797      */
 798     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 799         for (JCTypeParameter tvar : typarams) {
 800             TypeVar a = (TypeVar)tvar.type;
 801             a.tsym.flags_field |= UNATTRIBUTED;
 802             a.setUpperBound(Type.noType);
 803             if (!tvar.bounds.isEmpty()) {
<span class="line-modified"> 804                 List&lt;Type&gt; bounds = List.of(attribType(tvar.bounds.head, env));</span>
 805                 for (JCExpression bound : tvar.bounds.tail)
<span class="line-modified"> 806                     bounds = bounds.prepend(attribType(bound, env));</span>
 807                 types.setBounds(a, bounds.reverse());
 808             } else {
 809                 // if no bounds are given, assume a single bound of
 810                 // java.lang.Object.
 811                 types.setBounds(a, List.of(syms.objectType));
 812             }
 813             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 814         }
 815         if (checkCyclic) {
 816             for (JCTypeParameter tvar : typarams) {
 817                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 818             }
 819         }
 820     }
 821 
 822     /**
 823      * Attribute the type references in a list of annotations.
 824      */
 825     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 826                                Env&lt;AttrContext&gt; env) {
</pre>
<hr />
<pre>
 947                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 948                     enter.classEnter(tree, env);
 949             }
 950 
 951             ClassSymbol c = tree.sym;
 952             if (c == null) {
 953                 // exit in case something drastic went wrong during enter.
 954                 result = null;
 955             } else {
 956                 // make sure class has been completed:
 957                 c.complete();
 958 
 959                 // If this class appears as an anonymous class
 960                 // in a superclass constructor call
 961                 // disable implicit outer instance from being passed.
 962                 // (This would be an illegal access to &quot;this before super&quot;).
 963                 if (env.info.isSelfCall &amp;&amp;
 964                         env.tree.hasTag(NEWCLASS)) {
 965                     c.flags_field |= NOOUTERTHIS;
 966                 }



 967                 attribClass(tree.pos(), c);
 968                 result = tree.type = c.type;
 969             }
 970         } finally {
 971             localCacheContext.ifPresent(LocalCacheContext::leave);
 972         }
 973     }
 974 
 975     public void visitMethodDef(JCMethodDecl tree) {
 976         MethodSymbol m = tree.sym;
 977         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
 978 
 979         Lint lint = env.info.lint.augment(m);
 980         Lint prevLint = chk.setLint(lint);
 981         MethodSymbol prevMethod = chk.setMethod(m);
 982         try {
 983             deferredLintHandler.flush(tree.pos());
 984             chk.checkDeprecatedAnnotation(tree.pos(), m);
 985 
 986 
</pre>
<hr />
<pre>
1168                         log.error(tree.pos(),
1169                                   Errors.DefaultAllowedInIntfAnnotationMember);
1170                 }
1171                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1172                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1173             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1174                 if ((owner.flags() &amp; INTERFACE) != 0) {
1175                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1176                 } else {
1177                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1178                 }
1179             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1180                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1181             } else {
1182                 // Add an implicit super() call unless an explicit call to
1183                 // super(...) or this(...) is given
1184                 // or we are compiling class java.lang.Object.
1185                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1186                     JCBlock body = tree.body;
1187                     if (body.stats.isEmpty() ||
<span class="line-modified">1188                             TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {</span>
1189                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1190                                 make.Ident(names._super), make.Idents(List.nil())));
1191                         body.stats = body.stats.prepend(supCall);
1192                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1193                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1194                             TreeInfo.isSuperCall(body.stats.head)) {
1195                         // enum constructors are not allowed to call super
1196                         // directly, so make sure there aren&#39;t any super calls
1197                         // in enum constructors, except in the compiler
1198                         // generated one.
1199                         log.error(tree.body.stats.head.pos(),
1200                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1201                     }
1202                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1203                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1204                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1205                         if (!initParamNames.equals(recordComponentNames)) {
1206                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1207                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1208                         }
1209                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1210                             log.error(tree,
1211                                     Errors.InvalidCanonicalConstructorInRecord(
1212                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1213                                             env.enclClass.sym.name,
1214                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1215                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1216                         }
1217                     }
1218                 }






1219 
1220                 // Attribute all type annotations in the body
1221                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1222                 annotate.flush();
1223 
1224                 // Attribute method body.
1225                 attribStat(tree.body, localEnv);
1226             }
1227 
1228             localEnv.info.scope.leave();
1229             result = tree.type = m.type;
1230         } finally {
1231             chk.setLint(prevLint);
1232             chk.setMethod(prevMethod);
1233         }
1234     }
1235 
1236     public void visitVarDef(JCVariableDecl tree) {
1237         // Local variables have not been entered yet, so we need to do it now:
1238         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
</pre>
<hr />
<pre>
1268                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1269                 annotate.flush();
1270             }
1271         }
1272 
1273         VarSymbol v = tree.sym;
1274         Lint lint = env.info.lint.augment(v);
1275         Lint prevLint = chk.setLint(lint);
1276 
1277         // Check that the variable&#39;s declared type is well-formed.
1278         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1279                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1280                 (tree.sym.flags() &amp; PARAMETER) != 0;
1281         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1282 
1283         try {
1284             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1285             deferredLintHandler.flush(tree.pos());
1286             chk.checkDeprecatedAnnotation(tree.pos(), v);
1287 



1288             if (tree.init != null) {
<span class="line-modified">1289                 if ((v.flags_field &amp; FINAL) == 0 ||</span>
1290                     !memberEnter.needsLazyConstValue(tree.init)) {
1291                     // Not a compile-time constant
1292                     // Attribute initializer in a new environment
1293                     // with the declared variable as owner.
1294                     // Check that initializer conforms to variable&#39;s declared type.
1295                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1296                     initEnv.info.lint = lint;
1297                     // In order to catch self-references, we set the variable&#39;s
1298                     // declaration position to maximal possible value, effectively
1299                     // marking the variable as undefined.
1300                     initEnv.info.enclVar = v;
1301                     attribExpr(tree.init, initEnv, v.type);
1302                     if (tree.isImplicitlyTyped()) {
1303                         //fixup local variable type
1304                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1305                     }
1306                 }
1307                 if (tree.isImplicitlyTyped()) {
1308                     setSyntheticVariableType(tree, v.type);
1309                 }
</pre>
<hr />
<pre>
1393             }
1394         }
1395     }
1396 
1397     public void visitSkip(JCSkip tree) {
1398         result = null;
1399     }
1400 
1401     public void visitBlock(JCBlock tree) {
1402         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1403             // Block is a static or instance initializer;
1404             // let the owner of the environment be a freshly
1405             // created BLOCK-method.
1406             Symbol fakeOwner =
1407                 new MethodSymbol(tree.flags | BLOCK |
1408                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1409                     env.info.scope.owner);
1410             final Env&lt;AttrContext&gt; localEnv =
1411                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1412 
<span class="line-modified">1413             if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;</span>




1414             // Attribute all type annotations in the block
1415             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1416             annotate.flush();
1417             attribStats(tree.stats, localEnv);
1418 
1419             {
1420                 // Store init and clinit type annotations with the ClassSymbol
1421                 // to allow output in Gen.normalizeDefs.
1422                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1423                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1424                 if ((tree.flags &amp; STATIC) != 0) {
1425                     cs.appendClassInitTypeAttributes(tas);
1426                 } else {
1427                     cs.appendInitTypeAttributes(tas);
1428                 }
1429             }
1430         } else {
1431             // Create a new local environment with a local scope.
1432             Env&lt;AttrContext&gt; localEnv =
1433                 env.dup(tree, env.info.dup(env.info.scope.dup()));
</pre>
<hr />
<pre>
1458         // include condition&#39;s bindings when true in the body:
1459         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1460         try {
1461             attribStat(tree.body, whileEnv.dup(tree));
1462         } finally {
1463             whileEnv.info.scope.leave();
1464         }
1465         if (!breaksOutOf(tree, tree.body)) {
1466             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1467             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1468             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1469         }
1470         result = null;
1471     }
1472 
1473     private boolean breaksOutOf(JCTree loop, JCTree body) {
1474         preFlow(body);
1475         return flow.breaksOutOf(env, loop, body, make);
1476     }
1477 

































1478     public void visitForLoop(JCForLoop tree) {
1479         Env&lt;AttrContext&gt; loopEnv =
1480             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1481         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1482         try {
1483             attribStats(tree.init, loopEnv);
1484             if (tree.cond != null) {
1485                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1486                 // include condition&#39;s bindings when true in the body and step:
1487                 condBindings = matchBindings;
1488             }
1489             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1490             try {
1491                 bodyEnv.tree = tree; // before, we were not in loop!
1492                 attribStats(tree.step, bodyEnv);
1493                 attribStat(tree.body, bodyEnv);
1494             } finally {
1495                 bodyEnv.info.scope.leave();
1496             }
1497             result = null;
</pre>
<hr />
<pre>
1501         }
1502         if (!breaksOutOf(tree, tree.body)) {
1503             //include condition&#39;s body when false after the while, if cannot get out of the loop
1504             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1505             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1506         }
1507     }
1508 
1509     public void visitForeachLoop(JCEnhancedForLoop tree) {
1510         Env&lt;AttrContext&gt; loopEnv =
1511             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1512         try {
1513             //the Formal Parameter of a for-each loop is not in the scope when
1514             //attributing the for-each expression; we mimic this by attributing
1515             //the for-each expression first (against original scope).
1516             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1517             chk.checkNonVoid(tree.pos(), exprType);
1518             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1519             if (elemtype == null) {
1520                 // or perhaps expr implements Iterable&lt;T&gt;?
<span class="line-modified">1521                 Type base = types.asSuper(exprType, syms.iterableType.tsym);</span>
1522                 if (base == null) {
1523                     log.error(tree.expr.pos(),
1524                               Errors.ForeachNotApplicableToType(exprType,
1525                                                                 Fragments.TypeReqArrayOrIterable));
1526                     elemtype = types.createErrorType(exprType);
1527                 } else {
1528                     List&lt;Type&gt; iterableParams = base.allparams();
1529                     elemtype = iterableParams.isEmpty()
1530                         ? syms.objectType
1531                         : types.wildUpperBound(iterableParams.head);
1532                 }
1533             }
1534             if (tree.var.isImplicitlyTyped()) {
1535                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1536                 setSyntheticVariableType(tree.var, inferredType);
1537             }
1538             attribStat(tree.var, loopEnv);
1539             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1540             loopEnv.tree = tree; // before, we were not in loop!
1541             attribStat(tree.body, loopEnv);
</pre>
<hr />
<pre>
1715     // where
1716     /** Return the selected enumeration constant symbol, or null. */
1717     private Symbol enumConstant(JCTree tree, Type enumType) {
1718         if (tree.hasTag(IDENT)) {
1719             JCIdent ident = (JCIdent)tree;
1720             Name name = ident.name;
1721             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1722                 if (sym.kind == VAR) {
1723                     Symbol s = ident.sym = sym;
1724                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1725                     ident.type = s.type;
1726                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1727                         ? null : s;
1728                 }
1729             }
1730         }
1731         return null;
1732     }
1733 
1734     public void visitSynchronized(JCSynchronized tree) {
<span class="line-modified">1735         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env));</span>
1736         attribStat(tree.body, env);
1737         result = null;
1738     }
1739 
1740     public void visitTry(JCTry tree) {
1741         // Create a new local environment with a local
1742         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1743         try {
1744             boolean isTryWithResource = tree.resources.nonEmpty();
1745             // Create a nested environment for attributing the try block if needed
1746             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1747                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1748                 localEnv;
1749             try {
1750                 // Attribute resource declarations
1751                 for (JCTree resource : tree.resources) {
1752                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1753                         @Override
1754                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1755                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
</pre>
<hr />
<pre>
1796                     chk.checkType(c.param.vartype.pos(),
1797                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1798                                   syms.throwableType);
1799                     attribStat(c.body, catchEnv);
1800                 } finally {
1801                     catchEnv.info.scope.leave();
1802                 }
1803             }
1804 
1805             // Attribute finalizer
1806             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1807             result = null;
1808         }
1809         finally {
1810             localEnv.info.scope.leave();
1811         }
1812     }
1813 
1814     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1815         if (!resource.isErroneous() &amp;&amp;
<span class="line-modified">1816             types.asSuper(resource, syms.autoCloseableType.tsym) != null &amp;&amp;</span>
1817             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1818             Symbol close = syms.noSymbol;
1819             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1820             try {
1821                 close = rs.resolveQualifiedMethod(pos,
1822                         env,
1823                         types.skipTypeVars(resource, false),
1824                         names.close,
1825                         List.nil(),
1826                         List.nil());
1827             }
1828             finally {
1829                 log.popDiagnosticHandler(discardHandler);
1830             }
1831             if (close.kind == MTH &amp;&amp;
1832                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1833                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1834                     env.info.lint.isEnabled(LintCategory.TRY)) {
1835                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1836             }
</pre>
<hr />
<pre>
2396             // ... and attribute the method using as a prototype a methodtype
2397             // whose formal argument types is exactly the list of actual
2398             // arguments (this will also set the method symbol).
2399             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2400             localEnv.info.pendingResolutionPhase = null;
2401             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2402 
2403             // Compute the result type.
2404             Type restype = mtype.getReturnType();
2405             if (restype.hasTag(WILDCARD))
2406                 throw new AssertionError(mtype);
2407 
2408             Type qualifier = (tree.meth.hasTag(SELECT))
2409                     ? ((JCFieldAccess) tree.meth).selected.type
2410                     : env.enclClass.sym.type;
2411             Symbol msym = TreeInfo.symbol(tree.meth);
2412             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2413 
2414             chk.checkRefTypes(tree.typeargs, typeargtypes);
2415 




































2416             // Check that value of resulting type is admissible in the
2417             // current context.  Also, capture the return type
2418             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2419             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2420         }
2421         chk.validate(tree.typeargs, localEnv);
2422     }
2423     //where
2424         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2425             if (msym != null &amp;&amp;
2426                     msym.owner == syms.objectType.tsym &amp;&amp;
2427                     methodName == names.getClass &amp;&amp;
2428                     argtypes.isEmpty()) {
2429                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;









2430                 return new ClassType(restype.getEnclosingType(),
<span class="line-modified">2431                         List.of(new WildcardType(types.erasure(qualifierType),</span>
2432                                 BoundKind.EXTENDS,
2433                                 syms.boundClass)),
2434                         restype.tsym,
2435                         restype.getMetadata());
2436             } else if (msym != null &amp;&amp;
2437                     msym.owner == syms.arrayClass &amp;&amp;
2438                     methodName == names.clone &amp;&amp;
2439                     types.isArray(qualifierType)) {
2440                 // as a special case, array.clone() has a result that is
2441                 // the same as static type of the array being cloned
2442                 return qualifierType;
2443             } else {
2444                 return restype;
2445             }
2446         }
2447 
2448         /** Check that given application node appears as first statement
2449          *  in a constructor call.
2450          *  @param tree          The application node
2451          *  @param enclMethod    The enclosing method of the application.
</pre>
<hr />
<pre>
2755                                 this.resultInfo = prevResult;
2756                             }
2757                         });
2758             } else {
2759                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2760                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2761                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2762                         // One or more types inferred in the previous steps is non-denotable.
2763                         Fragment fragment = Diamond(clazztype.tsym);
2764                         log.error(tree.clazz.pos(),
2765                                 Errors.CantApplyDiamond1(
2766                                         fragment,
2767                                         invalidDiamondArgs.size() &gt; 1 ?
2768                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2769                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2770                     }
2771                     // For &lt;&gt;(){}, inferred types must also be accessible.
2772                     for (Type t : clazztype.getTypeArguments()) {
2773                         rs.checkAccessibleType(env, t);
2774                     }

2775                 }
2776 
2777                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2778                 // false for isInterface call even when the original type is an interface.
2779                 boolean implementing = clazztype.tsym.isInterface() ||
2780                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2781                         clazztype.getOriginalType().tsym.isInterface();
2782 
2783                 if (implementing) {
2784                     cdef.implementing = List.of(clazz);
2785                 } else {
2786                     cdef.extending = clazz;
2787                 }
2788 
2789                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2790                     isSerializable(clazztype)) {
2791                     localEnv.info.isSerializable = true;
2792                 }
2793 
2794                 attribStat(cdef, localEnv);
</pre>
<hr />
<pre>
2827             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2828             chk.validate(tree.typeargs, localEnv);
2829         }
2830 
2831         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2832             return new Check.NestedCheckContext(checkContext) {
2833                 @Override
2834                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2835                     enclosingContext.report(clazz.clazz,
2836                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2837                 }
2838             };
2839         }
2840 
2841     /** Make an attributed null check tree.
2842      */
2843     public JCExpression makeNullCheck(JCExpression arg) {
2844         // optimization: new Outer() can never be null; skip null check
2845         if (arg.getTag() == NEWCLASS)
2846             return arg;



2847         // optimization: X.this is never null; skip null check
2848         Name name = TreeInfo.name(arg);
2849         if (name == names._this || name == names._super) return arg;
2850 
2851         JCTree.Tag optag = NULLCHK;
2852         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2853         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2854         tree.type = arg.type;
2855         return tree;
2856     }
2857 
2858     public void visitNewArray(JCNewArray tree) {
2859         Type owntype = types.createErrorType(tree.type);
2860         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2861         Type elemtype;
2862         if (tree.elemtype != null) {
2863             elemtype = attribType(tree.elemtype, localEnv);
2864             chk.validate(tree.elemtype, localEnv);
2865             owntype = elemtype;
2866             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
3833         if (operator != operators.noOpSymbol &amp;&amp;
3834                 !left.isErroneous() &amp;&amp;
3835                 !right.isErroneous()) {
3836             owntype = operator.type.getReturnType();
3837             int opc = ((OperatorSymbol)operator).opcode;
3838             // If both arguments are constants, fold them.
3839             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3840                 Type ctype = cfolder.fold2(opc, left, right);
3841                 if (ctype != null) {
3842                     owntype = cfolder.coerce(ctype, owntype);
3843                 }
3844             }
3845 
3846             // Check that argument types of a reference ==, != are
3847             // castable to each other, (JLS 15.21).  Note: unboxing
3848             // comparisons will not have an acmp* opc at this point.
3849             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3850                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3851                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3852                 }

3853             }
3854 
3855             chk.checkDivZero(tree.rhs.pos(), operator, right);
3856         }
3857         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3858     }
3859 
3860     public void visitTypeCast(final JCTypeCast tree) {
3861         Type clazztype = attribType(tree.clazz, env);
3862         chk.validate(tree.clazz, env, false);
3863         //a fresh environment is required for 292 inference to work properly ---
3864         //see Infer.instantiatePolymorphicSignatureInstance()
3865         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
3866         //should we propagate the target type?
3867         final ResultInfo castInfo;
3868         JCExpression expr = TreeInfo.skipParens(tree.expr);
3869         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
3870         if (isPoly) {
3871             //expression is a poly - we need to propagate target type info
3872             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
</pre>
<hr />
<pre>
4030         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4031             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4032             // If the found symbol is inaccessible, then it is
4033             // accessed through an enclosing instance.  Locate this
4034             // enclosing instance:
4035             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4036                 env1 = env1.outer;
4037         }
4038 
4039         if (env.info.isSerializable) {
4040             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4041         }
4042 
4043         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4044     }
4045 
4046     public void visitSelect(JCFieldAccess tree) {
4047         // Determine the expected kind of the qualifier expression.
4048         KindSelector skind = KindSelector.NIL;
4049         if (tree.name == names._this || tree.name == names._super ||
<span class="line-modified">4050                 tree.name == names._class)</span>
4051         {




4052             skind = KindSelector.TYP;
4053         } else {
4054             if (pkind().contains(KindSelector.PCK))
4055                 skind = KindSelector.of(skind, KindSelector.PCK);
4056             if (pkind().contains(KindSelector.TYP))
4057                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4058             if (pkind().contains(KindSelector.VAL_MTH))
4059                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4060         }
4061 
4062         // Attribute the qualifier expression, and determine its symbol (if any).
4063         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4064         if (!pkind().contains(KindSelector.TYP_PCK))
4065             site = capture(site); // Capture field access
4066 
4067         // don&#39;t allow T.class T[].class, etc
4068         if (skind == KindSelector.TYP) {
4069             Type elt = site;
4070             while (elt.hasTag(ARRAY))
4071                 elt = ((ArrayType)elt).elemtype;
4072             if (elt.hasTag(TYPEVAR)) {
<span class="line-modified">4073                 log.error(tree.pos(), Errors.TypeVarCantBeDeref);</span>
<span class="line-modified">4074                 result = tree.type = types.createErrorType(tree.name, site.tsym, site);</span>
<span class="line-modified">4075                 tree.sym = tree.type.tsym;</span>
<span class="line-modified">4076                 return ;</span>





4077             }
4078         }
4079 
4080         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4081         // for the selection. This is relevant for determining whether
4082         // protected symbols are accessible.
4083         Symbol sitesym = TreeInfo.symbol(tree.selected);

4084         boolean selectSuperPrev = env.info.selectSuper;
4085         env.info.selectSuper =
4086             sitesym != null &amp;&amp;
4087             sitesym.name == names._super;
4088 
4089         // Determine the symbol represented by the selection.
4090         env.info.pendingResolutionPhase = null;
4091         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4092         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4093             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4094             sym = syms.errSymbol;
4095         }
4096         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4097             site = capture(site);
4098             sym = selectSym(tree, sitesym, site, env, resultInfo);
4099         }
4100         boolean varArgs = env.info.lastResolveVarargs();
4101         tree.sym = sym;
4102 
4103         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
</pre>
<hr />
<pre>
4199                                  Env&lt;AttrContext&gt; env,
4200                                  ResultInfo resultInfo) {
4201             DiagnosticPosition pos = tree.pos();
4202             Name name = tree.name;
4203             switch (site.getTag()) {
4204             case PACKAGE:
4205                 return rs.accessBase(
4206                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4207                     pos, location, site, name, true);
4208             case ARRAY:
4209             case CLASS:
4210                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4211                     return rs.resolveQualifiedMethod(
4212                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4213                 } else if (name == names._this || name == names._super) {
4214                     return rs.resolveSelf(pos, env, site.tsym, name);
4215                 } else if (name == names._class) {
4216                     // In this case, we have already made sure in
4217                     // visitSelect that qualifier expression is a type.
4218                     return syms.getClassField(site, types);






4219                 } else {
4220                     // We are seeing a plain identifier as selector.
4221                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4222                         sym = rs.accessBase(sym, pos, location, site, name, true);
4223                     return sym;
4224                 }
4225             case WILDCARD:
4226                 throw new AssertionError(tree);
4227             case TYPEVAR:




4228                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4229                 // It should only happen during memberEnter/attribBase
4230                 // when determining the super type which *must* be
4231                 // done before attributing the type variables.  In
4232                 // other words, we are seeing this illegal program:
4233                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4234                 Symbol sym = (site.getUpperBound() != null)
4235                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4236                     : null;
4237                 if (sym == null) {
4238                     log.error(pos, Errors.TypeVarCantBeDeref);
4239                     return syms.errSymbol;
4240                 } else {
4241                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4242                         rs.new AccessError(env, site, sym) :
4243                                 sym;
4244                     rs.accessBase(sym2, pos, location, site, name, true);
4245                     return sym;
4246                 }
4247             case ERROR:
4248                 // preserve identifier names through errors
4249                 return types.createErrorType(name, site.tsym, site).tsym;
4250             default:
4251                 // The qualifier expression is of a primitive type -- only
<span class="line-modified">4252                 // .class is allowed for these.</span>
4253                 if (name == names._class) {
4254                     // In this case, we have already made sure in Select that
4255                     // qualifier expression is a type.
4256                     return syms.getClassField(site, types);


4257                 } else {
4258                     log.error(pos, Errors.CantDeref(site));
4259                     return syms.errSymbol;
4260                 }
4261             }
4262         }
4263 
4264         /** Determine type of identifier or select expression and check that
4265          *  (1) the referenced symbol is not deprecated
4266          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4267          *  (3) if symbol is a variable, check that its type and kind are
4268          *      compatible with the prototype and protokind.
4269          *  (4) if symbol is an instance field of a raw type,
4270          *      which is being assigned to, issue an unchecked warning if its
4271          *      type changes under erasure.
4272          *  (5) if symbol is an instance method of a raw type, issue an
4273          *      unchecked warning if its argument types change under erasure.
4274          *  If checks succeed:
4275          *    If symbol is a constant, return its constant type
4276          *    else if symbol is a method, return its result type
</pre>
<hr />
<pre>
4848         if (bounds.length() == 0) {
4849             return syms.objectType;
4850         } else if (bounds.length() == 1) {
4851             return bounds.head.type;
4852         } else {
4853             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
4854             // ... the variable&#39;s bound is a class type flagged COMPOUND
4855             // (see comment for TypeVar.bound).
4856             // In this case, generate a class tree that represents the
4857             // bound class, ...
4858             JCExpression extending;
4859             List&lt;JCExpression&gt; implementing;
4860             if (!bounds.head.type.isInterface()) {
4861                 extending = bounds.head;
4862                 implementing = bounds.tail;
4863             } else {
4864                 extending = null;
4865                 implementing = bounds;
4866             }
4867             JCClassDecl cd = make.at(tree).ClassDef(
<span class="line-modified">4868                 make.Modifiers(PUBLIC | ABSTRACT),</span>
4869                 names.empty, List.nil(),
4870                 extending, implementing, List.nil());
4871 
4872             ClassSymbol c = (ClassSymbol)owntype.tsym;
4873             Assert.check((c.flags() &amp; COMPOUND) != 0);
4874             cd.sym = c;
4875             c.sourcefile = env.toplevel.sourcefile;
4876 
4877             // ... and attribute the bound class
4878             c.flags_field |= UNATTRIBUTED;
4879             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
4880             typeEnvs.put(c, cenv);
4881             attribClass(c);
4882             return owntype;
4883         }
4884     }
4885 
4886     public void visitWildcard(JCWildcard tree) {
4887         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
4888         Type type = (tree.kind.kind == BoundKind.UNBOUND)
4889             ? syms.objectType
4890             : attribType(tree.inner, env);
<span class="line-modified">4891         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),</span>
4892                                               tree.kind.kind,
4893                                               syms.boundClass),
4894                 KindSelector.TYP, resultInfo);
4895     }
4896 
4897     public void visitAnnotation(JCAnnotation tree) {
4898         Assert.error(&quot;should be handled in annotate&quot;);
4899     }
4900 
4901     public void visitAnnotatedType(JCAnnotatedType tree) {
4902         attribAnnotationTypes(tree.annotations, env);
4903         Type underlyingType = attribType(tree.underlyingType, env);
4904         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
4905 
4906         if (!env.info.isNewClass)
4907             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
4908         result = tree.type = annotatedType;
4909     }
4910 
4911     public void visitErroneous(JCErroneous tree) {
</pre>
<hr />
<pre>
4975             chk.completionError(pos, ex);
4976         }
4977     }
4978 
4979     void attribModule(ModuleSymbol m) {
4980         // Get environment current at the point of module definition.
4981         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
4982         attribStat(env.tree, env);
4983     }
4984 
4985     /** Main method: attribute class definition associated with given class symbol.
4986      *  reporting completion failures at the given position.
4987      *  @param pos The source position at which completion errors are to be
4988      *             reported.
4989      *  @param c   The class symbol whose definition will be attributed.
4990      */
4991     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
4992         try {
4993             annotate.flush();
4994             attribClass(c);







4995         } catch (CompletionFailure ex) {
4996             chk.completionError(pos, ex);
4997         }
4998     }
4999 
5000     /** Attribute class definition associated with given class symbol.
5001      *  @param c   The class symbol whose definition will be attributed.
5002      */
5003     void attribClass(ClassSymbol c) throws CompletionFailure {
5004         if (c.type.hasTag(ERROR)) return;
5005 
5006         // Check for cycles in the inheritance graph, which can arise from
5007         // ill-formed class files.
5008         chk.checkNonCyclic(null, c.type);
5009 
5010         Type st = types.supertype(c.type);
5011         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5012             // First, attribute superclass.
5013             if (st.hasTag(CLASS))
5014                 attribClass((ClassSymbol)st.tsym);
</pre>
<hr />
<pre>
5047                 deferredLintHandler.flush(env.tree);
5048                 env.info.returnResult = null;
5049                 // java.lang.Enum may not be subclassed by a non-enum
5050                 if (st.tsym == syms.enumSym &amp;&amp;
5051                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5052                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5053 
5054                 // Enums may not be extended by source-level classes
5055                 if (st.tsym != null &amp;&amp;
5056                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5057                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5058                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5059                 }
5060 
5061                 if (isSerializable(c.type)) {
5062                     env.info.isSerializable = true;
5063                 }
5064 
5065                 attribClassBody(env, c);
5066 








5067                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5068                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5069                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5070                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5071             } finally {
5072                 env.info.returnResult = prevReturnRes;
5073                 log.useSource(prev);
5074                 chk.setLint(prevLint);
5075             }
5076 
5077         }
5078     }
5079 
5080     public void visitImport(JCImport tree) {
5081         // nothing to do
5082     }
5083 
5084     public void visitModuleDef(JCModuleDecl tree) {
5085         tree.sym.completeUsesProvides();
5086         ModuleSymbol msym = tree.sym;
</pre>
<hr />
<pre>
5152         chk.checkClassBounds(tree.pos(), c.type);
5153 
5154         tree.type = c.type;
5155 
5156         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5157              l.nonEmpty(); l = l.tail) {
5158              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5159         }
5160 
5161         // Check that a generic class doesn&#39;t extend Throwable
5162         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5163             log.error(tree.extending.pos(), Errors.GenericThrowable);
5164 
5165         // Check that all methods which implement some
5166         // method conform to the method they implement.
5167         chk.checkImplementations(tree);
5168 
5169         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5170         checkAutoCloseable(tree.pos(), env, c.type);
5171 

5172         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5173             // Attribute declaration
5174             attribStat(l.head, env);




5175             // Check that declarations in inner classes are not static (JLS 8.1.2)
5176             // Make an exception for static constants.
5177             if (c.owner.kind != PCK &amp;&amp;
5178                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5179                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5180                 Symbol sym = null;
5181                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5182                 if (sym == null ||
5183                     sym.kind != VAR ||
5184                     ((VarSymbol) sym).getConstValue() == null)
5185                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5186             }
5187         }



5188 
5189         // Check for cycles among non-initial constructors.
5190         chk.checkCyclicConstructors(tree);
5191 
5192         // Check for cycles among annotation elements.
5193         chk.checkNonCyclicElements(tree);
5194 
5195         // Check for proper use of serialVersionUID
5196         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5197                 &amp;&amp; isSerializable(c.type)
5198                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5199                 &amp;&amp; !c.isAnonymous()) {
5200             checkSerialVersionUID(tree, c);
5201         }
5202         if (allowTypeAnnos) {
5203             // Correctly organize the positions of the type annotations
5204             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5205 
5206             // Check type annotations applicability rules
5207             validateTypeAnnotations(tree, false);
</pre>
</td>
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;

  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.source.tree.CaseTree;
  35 import com.sun.source.tree.IdentifierTree;
  36 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  37 import com.sun.source.tree.MemberSelectTree;
  38 import com.sun.source.tree.TreeVisitor;
  39 import com.sun.source.util.SimpleTreeVisitor;
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Lint.LintCategory;
  42 import com.sun.tools.javac.code.Scope.WriteableScope;
  43 import com.sun.tools.javac.code.Source.Feature;
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Type.*;
  46 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  47 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  48 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  49 import com.sun.tools.javac.comp.Check.CheckContext;
</pre>
<hr />
<pre>
 148         target = Target.instance(context);
 149         types = Types.instance(context);
 150         preview = Preview.instance(context);
 151         diags = JCDiagnostic.Factory.instance(context);
 152         annotate = Annotate.instance(context);
 153         typeAnnotations = TypeAnnotations.instance(context);
 154         deferredLintHandler = DeferredLintHandler.instance(context);
 155         typeEnvs = TypeEnvs.instance(context);
 156         dependencies = Dependencies.instance(context);
 157         argumentAttr = ArgumentAttr.instance(context);
 158         matchBindingsComputer = MatchBindingsComputer.instance(context);
 159 
 160         Options options = Options.instance(context);
 161 
 162         Source source = Source.instance(context);
 163         allowPoly = Feature.POLY.allowedInSource(source);
 164         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 165         allowLambda = Feature.LAMBDA.allowedInSource(source);
 166         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 167         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
<span class="line-added"> 168         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);</span>
 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
<span class="line-added"> 174         allowEmptyValues = options.isSet(&quot;allowEmptyValues&quot;);</span>
<span class="line-added"> 175         allowValueMemberCycles = options.isSet(&quot;allowValueMemberCycles&quot;);</span>
 176 
 177         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 178         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 179         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 180         methodAttrInfo = new MethodAttrInfo();
 181         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 182         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 183         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 184     }
 185 
 186     /** Switch: support target-typing inference
 187      */
 188     boolean allowPoly;
 189 
 190     /** Switch: support type annotations.
 191      */
 192     boolean allowTypeAnnos;
 193 
 194     /** Switch: support lambda expressions ?
 195      */
 196     boolean allowLambda;
 197 
 198     /** Switch: support default methods ?
 199      */
 200     boolean allowDefaultMethods;
 201 
<span class="line-added"> 202     /** Switch: allow inline types?</span>
<span class="line-added"> 203      */</span>
<span class="line-added"> 204     boolean allowInlineTypes;</span>
<span class="line-added"> 205 </span>
 206     /** Switch: static interface methods enabled?
 207      */
 208     boolean allowStaticInterfaceMethods;
 209 
 210     /** Switch: reifiable types in instanceof enabled?
 211      */
 212     boolean allowReifiableTypesInInstanceof;
 213 
 214     /**
 215      * Switch: warn about use of variable before declaration?
 216      * RFE: 6425594
 217      */
 218     boolean useBeforeDeclarationWarning;
 219 
<span class="line-added"> 220     /**</span>
<span class="line-added"> 221      * Switch: Allow value types with no instance state?</span>
<span class="line-added"> 222      */</span>
<span class="line-added"> 223     boolean allowEmptyValues;</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225     /**</span>
<span class="line-added"> 226      * Switch: Allow value type member cycles?</span>
<span class="line-added"> 227      */</span>
<span class="line-added"> 228     boolean allowValueMemberCycles;</span>
<span class="line-added"> 229 </span>
 230     /**
 231      * Switch: name of source level; used for error reporting.
 232      */
 233     String sourceName;
 234 
 235     /** Check kind and type of given tree against protokind and prototype.
 236      *  If check succeeds, store type in tree and return it.
 237      *  If check fails, store errType in tree and return it.
 238      *  No checks are performed if the prototype is a method type.
 239      *  It is not necessary in this case since we know that kind and type
 240      *  are correct.
 241      *
 242      *  @param tree     The tree whose kind and type is checked
 243      *  @param found    The computed type of the tree
 244      *  @param ownkind  The computed kind of the tree
 245      *  @param resultInfo  The expected result of the tree
 246      */
 247     Type check(final JCTree tree,
 248                final Type found,
 249                final KindSelector ownkind,
</pre>
<hr />
<pre>
 308      *  @param pos    The current source code position.
 309      *  @param v      The assigned variable
 310      *  @param base   If the variable is referred to in a Select, the part
 311      *                to the left of the `.&#39;, null otherwise.
 312      *  @param env    The current environment.
 313      */
 314     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 315         if (v.name == names._this) {
 316             log.error(pos, Errors.CantAssignValToThis);
 317         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 318             ((v.flags() &amp; HASINIT) != 0
 319              ||
 320              !((base == null ||
 321                TreeInfo.isThisQualifier(base)) &amp;&amp;
 322                isAssignableAsBlankFinal(v, env)))) {
 323             if (v.isResourceVariable()) { //TWR resource
 324                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 325             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 326                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 327             } else {
<span class="line-modified"> 328                 boolean complain = true;</span>
<span class="line-added"> 329                 /* Allow updates to instance fields of value classes by any method in the same nest via the</span>
<span class="line-added"> 330                    withfield operator -This does not result in mutation of final fields; the code generator</span>
<span class="line-added"> 331                    would implement `copy on write&#39; semantics via the opcode `withfield&#39;.</span>
<span class="line-added"> 332                 */</span>
<span class="line-added"> 333                 if (env.info.inWithField &amp;&amp; v.getKind() == ElementKind.FIELD &amp;&amp; (v.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) {</span>
<span class="line-added"> 334                     if (env.enclClass.sym.outermostClass() == v.owner.outermostClass())</span>
<span class="line-added"> 335                         complain = false;</span>
<span class="line-added"> 336                 }</span>
<span class="line-added"> 337                 if (complain)</span>
<span class="line-added"> 338                     log.error(pos, Errors.CantAssignValToFinalVar(v));</span>
 339             }
 340         }
 341     }
 342 
 343     /** Does tree represent a static reference to an identifier?
 344      *  It is assumed that tree is either a SELECT or an IDENT.
 345      *  We have to weed out selects from non-type names here.
 346      *  @param tree    The candidate tree.
 347      */
 348     boolean isStaticReference(JCTree tree) {
 349         if (tree.hasTag(SELECT)) {
 350             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 351             if (lsym == null || lsym.kind != TYP) {
 352                 return false;
 353             }
 354         }
 355         return true;
 356     }
 357 
 358     /** Is this symbol a type?
</pre>
<hr />
<pre>
 810     /** Attribute a type argument list, returning a list of types.
 811      *  Check that all the types are references.
 812      */
 813     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 814         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 815         return chk.checkRefTypes(trees, types);
 816     }
 817 
 818     /**
 819      * Attribute type variables (of generic classes or methods).
 820      * Compound types are attributed later in attribBounds.
 821      * @param typarams the type variables to enter
 822      * @param env      the current environment
 823      */
 824     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 825         for (JCTypeParameter tvar : typarams) {
 826             TypeVar a = (TypeVar)tvar.type;
 827             a.tsym.flags_field |= UNATTRIBUTED;
 828             a.setUpperBound(Type.noType);
 829             if (!tvar.bounds.isEmpty()) {
<span class="line-modified"> 830                 List&lt;Type&gt; bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));</span>
 831                 for (JCExpression bound : tvar.bounds.tail)
<span class="line-modified"> 832                     bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));</span>
 833                 types.setBounds(a, bounds.reverse());
 834             } else {
 835                 // if no bounds are given, assume a single bound of
 836                 // java.lang.Object.
 837                 types.setBounds(a, List.of(syms.objectType));
 838             }
 839             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 840         }
 841         if (checkCyclic) {
 842             for (JCTypeParameter tvar : typarams) {
 843                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 844             }
 845         }
 846     }
 847 
 848     /**
 849      * Attribute the type references in a list of annotations.
 850      */
 851     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 852                                Env&lt;AttrContext&gt; env) {
</pre>
<hr />
<pre>
 973                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 974                     enter.classEnter(tree, env);
 975             }
 976 
 977             ClassSymbol c = tree.sym;
 978             if (c == null) {
 979                 // exit in case something drastic went wrong during enter.
 980                 result = null;
 981             } else {
 982                 // make sure class has been completed:
 983                 c.complete();
 984 
 985                 // If this class appears as an anonymous class
 986                 // in a superclass constructor call
 987                 // disable implicit outer instance from being passed.
 988                 // (This would be an illegal access to &quot;this before super&quot;).
 989                 if (env.info.isSelfCall &amp;&amp;
 990                         env.tree.hasTag(NEWCLASS)) {
 991                     c.flags_field |= NOOUTERTHIS;
 992                 }
<span class="line-added"> 993                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; types.isValue(c.getSuperclass())) {</span>
<span class="line-added"> 994                     c.flags_field |= VALUE; // avoid further secondary errors.</span>
<span class="line-added"> 995                 }</span>
 996                 attribClass(tree.pos(), c);
 997                 result = tree.type = c.type;
 998             }
 999         } finally {
1000             localCacheContext.ifPresent(LocalCacheContext::leave);
1001         }
1002     }
1003 
1004     public void visitMethodDef(JCMethodDecl tree) {
1005         MethodSymbol m = tree.sym;
1006         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
1007 
1008         Lint lint = env.info.lint.augment(m);
1009         Lint prevLint = chk.setLint(lint);
1010         MethodSymbol prevMethod = chk.setMethod(m);
1011         try {
1012             deferredLintHandler.flush(tree.pos());
1013             chk.checkDeprecatedAnnotation(tree.pos(), m);
1014 
1015 
</pre>
<hr />
<pre>
1197                         log.error(tree.pos(),
1198                                   Errors.DefaultAllowedInIntfAnnotationMember);
1199                 }
1200                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1201                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1202             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1203                 if ((owner.flags() &amp; INTERFACE) != 0) {
1204                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1205                 } else {
1206                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1207                 }
1208             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1209                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1210             } else {
1211                 // Add an implicit super() call unless an explicit call to
1212                 // super(...) or this(...) is given
1213                 // or we are compiling class java.lang.Object.
1214                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1215                     JCBlock body = tree.body;
1216                     if (body.stats.isEmpty() ||
<span class="line-modified">1217                             TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {</span>
1218                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1219                                 make.Ident(names._super), make.Idents(List.nil())));
1220                         body.stats = body.stats.prepend(supCall);
1221                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1222                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1223                             TreeInfo.isSuperCall(body.stats.head)) {
1224                         // enum constructors are not allowed to call super
1225                         // directly, so make sure there aren&#39;t any super calls
1226                         // in enum constructors, except in the compiler
1227                         // generated one.
1228                         log.error(tree.body.stats.head.pos(),
1229                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1230                     }
1231                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1232                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1233                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1234                         if (!initParamNames.equals(recordComponentNames)) {
1235                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1236                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1237                         }
1238                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1239                             log.error(tree,
1240                                     Errors.InvalidCanonicalConstructorInRecord(
1241                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1242                                             env.enclClass.sym.name,
1243                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1244                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1245                         }
1246                     }
1247                 }
<span class="line-added">1248                 if (m.isConstructor() &amp;&amp; m.type.getParameterTypes().size() == 0) {</span>
<span class="line-added">1249                     if ((owner.type == syms.objectType) ||</span>
<span class="line-added">1250                             (tree.body.stats.size() == 1 &amp;&amp; TreeInfo.getConstructorInvocationName(tree.body.stats, names, false) == names._super)) {</span>
<span class="line-added">1251                         m.flags_field |= EMPTYNOARGCONSTR;</span>
<span class="line-added">1252                     }</span>
<span class="line-added">1253                 }</span>
1254 
1255                 // Attribute all type annotations in the body
1256                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1257                 annotate.flush();
1258 
1259                 // Attribute method body.
1260                 attribStat(tree.body, localEnv);
1261             }
1262 
1263             localEnv.info.scope.leave();
1264             result = tree.type = m.type;
1265         } finally {
1266             chk.setLint(prevLint);
1267             chk.setMethod(prevMethod);
1268         }
1269     }
1270 
1271     public void visitVarDef(JCVariableDecl tree) {
1272         // Local variables have not been entered yet, so we need to do it now:
1273         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
</pre>
<hr />
<pre>
1303                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1304                 annotate.flush();
1305             }
1306         }
1307 
1308         VarSymbol v = tree.sym;
1309         Lint lint = env.info.lint.augment(v);
1310         Lint prevLint = chk.setLint(lint);
1311 
1312         // Check that the variable&#39;s declared type is well-formed.
1313         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1314                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1315                 (tree.sym.flags() &amp; PARAMETER) != 0;
1316         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1317 
1318         try {
1319             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1320             deferredLintHandler.flush(tree.pos());
1321             chk.checkDeprecatedAnnotation(tree.pos(), v);
1322 
<span class="line-added">1323             /* Don&#39;t want constant propagation/folding for instance fields of value classes,</span>
<span class="line-added">1324                as these can undergo updates via copy on write.</span>
<span class="line-added">1325             */</span>
1326             if (tree.init != null) {
<span class="line-modified">1327                 if ((v.flags_field &amp; FINAL) == 0 || ((v.flags_field &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) ||</span>
1328                     !memberEnter.needsLazyConstValue(tree.init)) {
1329                     // Not a compile-time constant
1330                     // Attribute initializer in a new environment
1331                     // with the declared variable as owner.
1332                     // Check that initializer conforms to variable&#39;s declared type.
1333                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1334                     initEnv.info.lint = lint;
1335                     // In order to catch self-references, we set the variable&#39;s
1336                     // declaration position to maximal possible value, effectively
1337                     // marking the variable as undefined.
1338                     initEnv.info.enclVar = v;
1339                     attribExpr(tree.init, initEnv, v.type);
1340                     if (tree.isImplicitlyTyped()) {
1341                         //fixup local variable type
1342                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1343                     }
1344                 }
1345                 if (tree.isImplicitlyTyped()) {
1346                     setSyntheticVariableType(tree, v.type);
1347                 }
</pre>
<hr />
<pre>
1431             }
1432         }
1433     }
1434 
1435     public void visitSkip(JCSkip tree) {
1436         result = null;
1437     }
1438 
1439     public void visitBlock(JCBlock tree) {
1440         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1441             // Block is a static or instance initializer;
1442             // let the owner of the environment be a freshly
1443             // created BLOCK-method.
1444             Symbol fakeOwner =
1445                 new MethodSymbol(tree.flags | BLOCK |
1446                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1447                     env.info.scope.owner);
1448             final Env&lt;AttrContext&gt; localEnv =
1449                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1450 
<span class="line-modified">1451             if ((tree.flags &amp; STATIC) != 0)</span>
<span class="line-added">1452                 localEnv.info.staticLevel++;</span>
<span class="line-added">1453             else if (tree.stats.size() &gt; 0)</span>
<span class="line-added">1454                 env.info.scope.owner.flags_field |= HASINITBLOCK;</span>
<span class="line-added">1455 </span>
1456             // Attribute all type annotations in the block
1457             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1458             annotate.flush();
1459             attribStats(tree.stats, localEnv);
1460 
1461             {
1462                 // Store init and clinit type annotations with the ClassSymbol
1463                 // to allow output in Gen.normalizeDefs.
1464                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1465                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1466                 if ((tree.flags &amp; STATIC) != 0) {
1467                     cs.appendClassInitTypeAttributes(tas);
1468                 } else {
1469                     cs.appendInitTypeAttributes(tas);
1470                 }
1471             }
1472         } else {
1473             // Create a new local environment with a local scope.
1474             Env&lt;AttrContext&gt; localEnv =
1475                 env.dup(tree, env.info.dup(env.info.scope.dup()));
</pre>
<hr />
<pre>
1500         // include condition&#39;s bindings when true in the body:
1501         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1502         try {
1503             attribStat(tree.body, whileEnv.dup(tree));
1504         } finally {
1505             whileEnv.info.scope.leave();
1506         }
1507         if (!breaksOutOf(tree, tree.body)) {
1508             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1509             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1510             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1511         }
1512         result = null;
1513     }
1514 
1515     private boolean breaksOutOf(JCTree loop, JCTree body) {
1516         preFlow(body);
1517         return flow.breaksOutOf(env, loop, body, make);
1518     }
1519 
<span class="line-added">1520     public void visitWithField(JCWithField tree) {</span>
<span class="line-added">1521         boolean inWithField = env.info.inWithField;</span>
<span class="line-added">1522         try {</span>
<span class="line-added">1523             env.info.inWithField = true;</span>
<span class="line-added">1524             Type fieldtype = attribTree(tree.field, env.dup(tree), varAssignmentInfo);</span>
<span class="line-added">1525             attribExpr(tree.value, env, fieldtype);</span>
<span class="line-added">1526             Type capturedType = syms.errType;</span>
<span class="line-added">1527             if (tree.field.type != null &amp;&amp; !tree.field.type.isErroneous()) {</span>
<span class="line-added">1528                 final Symbol sym = TreeInfo.symbol(tree.field);</span>
<span class="line-added">1529                 if (sym == null || sym.kind != VAR || sym.owner.kind != TYP ||</span>
<span class="line-added">1530                         (sym.flags() &amp; STATIC) != 0 || !types.isValue(sym.owner.type)) {</span>
<span class="line-added">1531                     log.error(tree.field.pos(), Errors.ValueInstanceFieldExpectedHere);</span>
<span class="line-added">1532                 } else {</span>
<span class="line-added">1533                     Type ownType = sym.owner.type;</span>
<span class="line-added">1534                     switch(tree.field.getTag()) {</span>
<span class="line-added">1535                         case IDENT:</span>
<span class="line-added">1536                             JCIdent ident = (JCIdent) tree.field;</span>
<span class="line-added">1537                             ownType = ident.sym.owner.type;</span>
<span class="line-added">1538                             break;</span>
<span class="line-added">1539                         case SELECT:</span>
<span class="line-added">1540                             JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;</span>
<span class="line-added">1541                             ownType = fieldAccess.selected.type;</span>
<span class="line-added">1542                             break;</span>
<span class="line-added">1543                     }</span>
<span class="line-added">1544                     capturedType = capture(ownType);</span>
<span class="line-added">1545                 }</span>
<span class="line-added">1546             }</span>
<span class="line-added">1547             result = check(tree, capturedType, KindSelector.VAL, resultInfo);</span>
<span class="line-added">1548         } finally {</span>
<span class="line-added">1549             env.info.inWithField = inWithField;</span>
<span class="line-added">1550         }</span>
<span class="line-added">1551     }</span>
<span class="line-added">1552 </span>
1553     public void visitForLoop(JCForLoop tree) {
1554         Env&lt;AttrContext&gt; loopEnv =
1555             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1556         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1557         try {
1558             attribStats(tree.init, loopEnv);
1559             if (tree.cond != null) {
1560                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1561                 // include condition&#39;s bindings when true in the body and step:
1562                 condBindings = matchBindings;
1563             }
1564             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1565             try {
1566                 bodyEnv.tree = tree; // before, we were not in loop!
1567                 attribStats(tree.step, bodyEnv);
1568                 attribStat(tree.body, bodyEnv);
1569             } finally {
1570                 bodyEnv.info.scope.leave();
1571             }
1572             result = null;
</pre>
<hr />
<pre>
1576         }
1577         if (!breaksOutOf(tree, tree.body)) {
1578             //include condition&#39;s body when false after the while, if cannot get out of the loop
1579             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1580             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1581         }
1582     }
1583 
1584     public void visitForeachLoop(JCEnhancedForLoop tree) {
1585         Env&lt;AttrContext&gt; loopEnv =
1586             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1587         try {
1588             //the Formal Parameter of a for-each loop is not in the scope when
1589             //attributing the for-each expression; we mimic this by attributing
1590             //the for-each expression first (against original scope).
1591             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1592             chk.checkNonVoid(tree.pos(), exprType);
1593             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1594             if (elemtype == null) {
1595                 // or perhaps expr implements Iterable&lt;T&gt;?
<span class="line-modified">1596                 Type base = types.asSuper(exprType, syms.iterableType.tsym, true);</span>
1597                 if (base == null) {
1598                     log.error(tree.expr.pos(),
1599                               Errors.ForeachNotApplicableToType(exprType,
1600                                                                 Fragments.TypeReqArrayOrIterable));
1601                     elemtype = types.createErrorType(exprType);
1602                 } else {
1603                     List&lt;Type&gt; iterableParams = base.allparams();
1604                     elemtype = iterableParams.isEmpty()
1605                         ? syms.objectType
1606                         : types.wildUpperBound(iterableParams.head);
1607                 }
1608             }
1609             if (tree.var.isImplicitlyTyped()) {
1610                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1611                 setSyntheticVariableType(tree.var, inferredType);
1612             }
1613             attribStat(tree.var, loopEnv);
1614             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1615             loopEnv.tree = tree; // before, we were not in loop!
1616             attribStat(tree.body, loopEnv);
</pre>
<hr />
<pre>
1790     // where
1791     /** Return the selected enumeration constant symbol, or null. */
1792     private Symbol enumConstant(JCTree tree, Type enumType) {
1793         if (tree.hasTag(IDENT)) {
1794             JCIdent ident = (JCIdent)tree;
1795             Name name = ident.name;
1796             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1797                 if (sym.kind == VAR) {
1798                     Symbol s = ident.sym = sym;
1799                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1800                     ident.type = s.type;
1801                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1802                         ? null : s;
1803                 }
1804             }
1805         }
1806         return null;
1807     }
1808 
1809     public void visitSynchronized(JCSynchronized tree) {
<span class="line-modified">1810         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env), false);</span>
1811         attribStat(tree.body, env);
1812         result = null;
1813     }
1814 
1815     public void visitTry(JCTry tree) {
1816         // Create a new local environment with a local
1817         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1818         try {
1819             boolean isTryWithResource = tree.resources.nonEmpty();
1820             // Create a nested environment for attributing the try block if needed
1821             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1822                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1823                 localEnv;
1824             try {
1825                 // Attribute resource declarations
1826                 for (JCTree resource : tree.resources) {
1827                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1828                         @Override
1829                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1830                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
</pre>
<hr />
<pre>
1871                     chk.checkType(c.param.vartype.pos(),
1872                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1873                                   syms.throwableType);
1874                     attribStat(c.body, catchEnv);
1875                 } finally {
1876                     catchEnv.info.scope.leave();
1877                 }
1878             }
1879 
1880             // Attribute finalizer
1881             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1882             result = null;
1883         }
1884         finally {
1885             localEnv.info.scope.leave();
1886         }
1887     }
1888 
1889     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1890         if (!resource.isErroneous() &amp;&amp;
<span class="line-modified">1891             types.asSuper(resource, syms.autoCloseableType.tsym, true) != null &amp;&amp;</span>
1892             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1893             Symbol close = syms.noSymbol;
1894             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1895             try {
1896                 close = rs.resolveQualifiedMethod(pos,
1897                         env,
1898                         types.skipTypeVars(resource, false),
1899                         names.close,
1900                         List.nil(),
1901                         List.nil());
1902             }
1903             finally {
1904                 log.popDiagnosticHandler(discardHandler);
1905             }
1906             if (close.kind == MTH &amp;&amp;
1907                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1908                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1909                     env.info.lint.isEnabled(LintCategory.TRY)) {
1910                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1911             }
</pre>
<hr />
<pre>
2471             // ... and attribute the method using as a prototype a methodtype
2472             // whose formal argument types is exactly the list of actual
2473             // arguments (this will also set the method symbol).
2474             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2475             localEnv.info.pendingResolutionPhase = null;
2476             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2477 
2478             // Compute the result type.
2479             Type restype = mtype.getReturnType();
2480             if (restype.hasTag(WILDCARD))
2481                 throw new AssertionError(mtype);
2482 
2483             Type qualifier = (tree.meth.hasTag(SELECT))
2484                     ? ((JCFieldAccess) tree.meth).selected.type
2485                     : env.enclClass.sym.type;
2486             Symbol msym = TreeInfo.symbol(tree.meth);
2487             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2488 
2489             chk.checkRefTypes(tree.typeargs, typeargtypes);
2490 
<span class="line-added">2491             final Symbol symbol = TreeInfo.symbol(tree.meth);</span>
<span class="line-added">2492             if (symbol != null) {</span>
<span class="line-added">2493                 /* Is this an ill conceived attempt to invoke jlO methods not available on value types ??</span>
<span class="line-added">2494                  */</span>
<span class="line-added">2495                 boolean superCallOnValueReceiver = types.isValue(env.enclClass.sym.type)</span>
<span class="line-added">2496                         &amp;&amp; (tree.meth.hasTag(SELECT))</span>
<span class="line-added">2497                         &amp;&amp; ((JCFieldAccess)tree.meth).selected.hasTag(IDENT)</span>
<span class="line-added">2498                         &amp;&amp; TreeInfo.name(((JCFieldAccess)tree.meth).selected) == names._super;</span>
<span class="line-added">2499                 if (types.isValue(qualifier) || superCallOnValueReceiver) {</span>
<span class="line-added">2500                     int argSize = argtypes.size();</span>
<span class="line-added">2501                     Name name = symbol.name;</span>
<span class="line-added">2502                     switch (name.toString()) {</span>
<span class="line-added">2503                         case &quot;wait&quot;:</span>
<span class="line-added">2504                             if (argSize == 0</span>
<span class="line-added">2505                                     || (types.isConvertible(argtypes.head, syms.longType) &amp;&amp;</span>
<span class="line-added">2506                                     (argSize == 1 || (argSize == 2 &amp;&amp; types.isConvertible(argtypes.tail.head, syms.intType))))) {</span>
<span class="line-added">2507                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));</span>
<span class="line-added">2508                             }</span>
<span class="line-added">2509                             break;</span>
<span class="line-added">2510                         case &quot;notify&quot;:</span>
<span class="line-added">2511                         case &quot;notifyAll&quot;:</span>
<span class="line-added">2512                         case &quot;clone&quot;:</span>
<span class="line-added">2513                         case &quot;finalize&quot;:</span>
<span class="line-added">2514                             if (argSize == 0)</span>
<span class="line-added">2515                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));</span>
<span class="line-added">2516                             break;</span>
<span class="line-added">2517                         case &quot;hashCode&quot;:</span>
<span class="line-added">2518                         case &quot;equals&quot;:</span>
<span class="line-added">2519                         case &quot;toString&quot;:</span>
<span class="line-added">2520                             if (superCallOnValueReceiver)</span>
<span class="line-added">2521                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(names.fromString(&quot;invocation of super.&quot; + name)));</span>
<span class="line-added">2522                             break;</span>
<span class="line-added">2523                     }</span>
<span class="line-added">2524                 }</span>
<span class="line-added">2525             }</span>
<span class="line-added">2526 </span>
2527             // Check that value of resulting type is admissible in the
2528             // current context.  Also, capture the return type
2529             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2530             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2531         }
2532         chk.validate(tree.typeargs, localEnv);
2533     }
2534     //where
2535         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2536             if (msym != null &amp;&amp;
2537                     msym.owner == syms.objectType.tsym &amp;&amp;
2538                     methodName == names.getClass &amp;&amp;
2539                     argtypes.isEmpty()) {
2540                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;
<span class="line-added">2541                 // Temporary treatment for inline class: Given an inline class V that implements</span>
<span class="line-added">2542                 // I1, I2, ... In, v.getClass() is typed to be Class&lt;? extends Object &amp; I1 &amp; I2 .. &amp; In&gt;</span>
<span class="line-added">2543                 Type wcb;</span>
<span class="line-added">2544                 if (qualifierType.isValue()) {</span>
<span class="line-added">2545                     List&lt;Type&gt; bounds = List.of(syms.objectType).appendList(((ClassSymbol) qualifierType.tsym).getInterfaces());</span>
<span class="line-added">2546                     wcb = types.makeIntersectionType(bounds);</span>
<span class="line-added">2547                 } else {</span>
<span class="line-added">2548                     wcb = types.erasure(qualifierType);</span>
<span class="line-added">2549                 }</span>
2550                 return new ClassType(restype.getEnclosingType(),
<span class="line-modified">2551                         List.of(new WildcardType(wcb,</span>
2552                                 BoundKind.EXTENDS,
2553                                 syms.boundClass)),
2554                         restype.tsym,
2555                         restype.getMetadata());
2556             } else if (msym != null &amp;&amp;
2557                     msym.owner == syms.arrayClass &amp;&amp;
2558                     methodName == names.clone &amp;&amp;
2559                     types.isArray(qualifierType)) {
2560                 // as a special case, array.clone() has a result that is
2561                 // the same as static type of the array being cloned
2562                 return qualifierType;
2563             } else {
2564                 return restype;
2565             }
2566         }
2567 
2568         /** Check that given application node appears as first statement
2569          *  in a constructor call.
2570          *  @param tree          The application node
2571          *  @param enclMethod    The enclosing method of the application.
</pre>
<hr />
<pre>
2875                                 this.resultInfo = prevResult;
2876                             }
2877                         });
2878             } else {
2879                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2880                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2881                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2882                         // One or more types inferred in the previous steps is non-denotable.
2883                         Fragment fragment = Diamond(clazztype.tsym);
2884                         log.error(tree.clazz.pos(),
2885                                 Errors.CantApplyDiamond1(
2886                                         fragment,
2887                                         invalidDiamondArgs.size() &gt; 1 ?
2888                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2889                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2890                     }
2891                     // For &lt;&gt;(){}, inferred types must also be accessible.
2892                     for (Type t : clazztype.getTypeArguments()) {
2893                         rs.checkAccessibleType(env, t);
2894                     }
<span class="line-added">2895                     chk.checkParameterizationWithValues(tree, clazztype);</span>
2896                 }
2897 
2898                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2899                 // false for isInterface call even when the original type is an interface.
2900                 boolean implementing = clazztype.tsym.isInterface() ||
2901                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2902                         clazztype.getOriginalType().tsym.isInterface();
2903 
2904                 if (implementing) {
2905                     cdef.implementing = List.of(clazz);
2906                 } else {
2907                     cdef.extending = clazz;
2908                 }
2909 
2910                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2911                     isSerializable(clazztype)) {
2912                     localEnv.info.isSerializable = true;
2913                 }
2914 
2915                 attribStat(cdef, localEnv);
</pre>
<hr />
<pre>
2948             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2949             chk.validate(tree.typeargs, localEnv);
2950         }
2951 
2952         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2953             return new Check.NestedCheckContext(checkContext) {
2954                 @Override
2955                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2956                     enclosingContext.report(clazz.clazz,
2957                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2958                 }
2959             };
2960         }
2961 
2962     /** Make an attributed null check tree.
2963      */
2964     public JCExpression makeNullCheck(JCExpression arg) {
2965         // optimization: new Outer() can never be null; skip null check
2966         if (arg.getTag() == NEWCLASS)
2967             return arg;
<span class="line-added">2968         // Likewise arg can&#39;t be null if it is a value.</span>
<span class="line-added">2969         if (types.isValue(arg.type))</span>
<span class="line-added">2970             return arg;</span>
2971         // optimization: X.this is never null; skip null check
2972         Name name = TreeInfo.name(arg);
2973         if (name == names._this || name == names._super) return arg;
2974 
2975         JCTree.Tag optag = NULLCHK;
2976         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2977         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2978         tree.type = arg.type;
2979         return tree;
2980     }
2981 
2982     public void visitNewArray(JCNewArray tree) {
2983         Type owntype = types.createErrorType(tree.type);
2984         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2985         Type elemtype;
2986         if (tree.elemtype != null) {
2987             elemtype = attribType(tree.elemtype, localEnv);
2988             chk.validate(tree.elemtype, localEnv);
2989             owntype = elemtype;
2990             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
3957         if (operator != operators.noOpSymbol &amp;&amp;
3958                 !left.isErroneous() &amp;&amp;
3959                 !right.isErroneous()) {
3960             owntype = operator.type.getReturnType();
3961             int opc = ((OperatorSymbol)operator).opcode;
3962             // If both arguments are constants, fold them.
3963             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3964                 Type ctype = cfolder.fold2(opc, left, right);
3965                 if (ctype != null) {
3966                     owntype = cfolder.coerce(ctype, owntype);
3967                 }
3968             }
3969 
3970             // Check that argument types of a reference ==, != are
3971             // castable to each other, (JLS 15.21).  Note: unboxing
3972             // comparisons will not have an acmp* opc at this point.
3973             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3974                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3975                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3976                 }
<span class="line-added">3977                 chk.checkForSuspectClassLiteralComparison(tree, left, right);</span>
3978             }
3979 
3980             chk.checkDivZero(tree.rhs.pos(), operator, right);
3981         }
3982         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3983     }
3984 
3985     public void visitTypeCast(final JCTypeCast tree) {
3986         Type clazztype = attribType(tree.clazz, env);
3987         chk.validate(tree.clazz, env, false);
3988         //a fresh environment is required for 292 inference to work properly ---
3989         //see Infer.instantiatePolymorphicSignatureInstance()
3990         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
3991         //should we propagate the target type?
3992         final ResultInfo castInfo;
3993         JCExpression expr = TreeInfo.skipParens(tree.expr);
3994         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
3995         if (isPoly) {
3996             //expression is a poly - we need to propagate target type info
3997             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
</pre>
<hr />
<pre>
4155         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4156             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4157             // If the found symbol is inaccessible, then it is
4158             // accessed through an enclosing instance.  Locate this
4159             // enclosing instance:
4160             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4161                 env1 = env1.outer;
4162         }
4163 
4164         if (env.info.isSerializable) {
4165             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4166         }
4167 
4168         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4169     }
4170 
4171     public void visitSelect(JCFieldAccess tree) {
4172         // Determine the expected kind of the qualifier expression.
4173         KindSelector skind = KindSelector.NIL;
4174         if (tree.name == names._this || tree.name == names._super ||
<span class="line-modified">4175                 tree.name == names._class || tree.name == names._default)</span>
4176         {
<span class="line-added">4177             if (tree.name == names._default &amp;&amp; !allowInlineTypes) {</span>
<span class="line-added">4178                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),</span>
<span class="line-added">4179                         Feature.INLINE_TYPES.error(sourceName));</span>
<span class="line-added">4180             }</span>
4181             skind = KindSelector.TYP;
4182         } else {
4183             if (pkind().contains(KindSelector.PCK))
4184                 skind = KindSelector.of(skind, KindSelector.PCK);
4185             if (pkind().contains(KindSelector.TYP))
4186                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4187             if (pkind().contains(KindSelector.VAL_MTH))
4188                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4189         }
4190 
4191         // Attribute the qualifier expression, and determine its symbol (if any).
4192         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4193         if (!pkind().contains(KindSelector.TYP_PCK))
4194             site = capture(site); // Capture field access
4195 
4196         // don&#39;t allow T.class T[].class, etc
4197         if (skind == KindSelector.TYP) {
4198             Type elt = site;
4199             while (elt.hasTag(ARRAY))
4200                 elt = ((ArrayType)elt).elemtype;
4201             if (elt.hasTag(TYPEVAR)) {
<span class="line-modified">4202                 if (tree.name == names._default) {</span>
<span class="line-modified">4203                     result = check(tree, litType(BOT).constType(null),</span>
<span class="line-modified">4204                             KindSelector.VAL, resultInfo);</span>
<span class="line-modified">4205                 } else {</span>
<span class="line-added">4206                     log.error(tree.pos(), Errors.TypeVarCantBeDeref);</span>
<span class="line-added">4207                     result = tree.type = types.createErrorType(tree.name, site.tsym, site);</span>
<span class="line-added">4208                     tree.sym = tree.type.tsym;</span>
<span class="line-added">4209                     return;</span>
<span class="line-added">4210                 }</span>
4211             }
4212         }
4213 
4214         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4215         // for the selection. This is relevant for determining whether
4216         // protected symbols are accessible.
4217         Symbol sitesym = TreeInfo.symbol(tree.selected);
<span class="line-added">4218 </span>
4219         boolean selectSuperPrev = env.info.selectSuper;
4220         env.info.selectSuper =
4221             sitesym != null &amp;&amp;
4222             sitesym.name == names._super;
4223 
4224         // Determine the symbol represented by the selection.
4225         env.info.pendingResolutionPhase = null;
4226         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4227         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4228             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4229             sym = syms.errSymbol;
4230         }
4231         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4232             site = capture(site);
4233             sym = selectSym(tree, sitesym, site, env, resultInfo);
4234         }
4235         boolean varArgs = env.info.lastResolveVarargs();
4236         tree.sym = sym;
4237 
4238         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
</pre>
<hr />
<pre>
4334                                  Env&lt;AttrContext&gt; env,
4335                                  ResultInfo resultInfo) {
4336             DiagnosticPosition pos = tree.pos();
4337             Name name = tree.name;
4338             switch (site.getTag()) {
4339             case PACKAGE:
4340                 return rs.accessBase(
4341                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4342                     pos, location, site, name, true);
4343             case ARRAY:
4344             case CLASS:
4345                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4346                     return rs.resolveQualifiedMethod(
4347                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4348                 } else if (name == names._this || name == names._super) {
4349                     return rs.resolveSelf(pos, env, site.tsym, name);
4350                 } else if (name == names._class) {
4351                     // In this case, we have already made sure in
4352                     // visitSelect that qualifier expression is a type.
4353                     return syms.getClassField(site, types);
<span class="line-added">4354                 } else if (name == names._default) {</span>
<span class="line-added">4355                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
<span class="line-added">4356                 } else if (name == names.ref &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {</span>
<span class="line-added">4357                     return site.tsym.referenceProjection();</span>
<span class="line-added">4358                 } else if (name == names.val &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {</span>
<span class="line-added">4359                     return site.tsym;</span>
4360                 } else {
4361                     // We are seeing a plain identifier as selector.
4362                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4363                         sym = rs.accessBase(sym, pos, location, site, name, true);
4364                     return sym;
4365                 }
4366             case WILDCARD:
4367                 throw new AssertionError(tree);
4368             case TYPEVAR:
<span class="line-added">4369                 if (name == names._default) {</span>
<span class="line-added">4370                     // Be sure to return the default value before examining bounds</span>
<span class="line-added">4371                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
<span class="line-added">4372                 }</span>
4373                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4374                 // It should only happen during memberEnter/attribBase
4375                 // when determining the super type which *must* be
4376                 // done before attributing the type variables.  In
4377                 // other words, we are seeing this illegal program:
4378                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4379                 Symbol sym = (site.getUpperBound() != null)
4380                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4381                     : null;
4382                 if (sym == null) {
4383                     log.error(pos, Errors.TypeVarCantBeDeref);
4384                     return syms.errSymbol;
4385                 } else {
4386                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4387                         rs.new AccessError(env, site, sym) :
4388                                 sym;
4389                     rs.accessBase(sym2, pos, location, site, name, true);
4390                     return sym;
4391                 }
4392             case ERROR:
4393                 // preserve identifier names through errors
4394                 return types.createErrorType(name, site.tsym, site).tsym;
4395             default:
4396                 // The qualifier expression is of a primitive type -- only
<span class="line-modified">4397                 // .class and .default is allowed for these.</span>
4398                 if (name == names._class) {
4399                     // In this case, we have already made sure in Select that
4400                     // qualifier expression is a type.
4401                     return syms.getClassField(site, types);
<span class="line-added">4402                 } else if (name == names._default) {</span>
<span class="line-added">4403                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
4404                 } else {
4405                     log.error(pos, Errors.CantDeref(site));
4406                     return syms.errSymbol;
4407                 }
4408             }
4409         }
4410 
4411         /** Determine type of identifier or select expression and check that
4412          *  (1) the referenced symbol is not deprecated
4413          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4414          *  (3) if symbol is a variable, check that its type and kind are
4415          *      compatible with the prototype and protokind.
4416          *  (4) if symbol is an instance field of a raw type,
4417          *      which is being assigned to, issue an unchecked warning if its
4418          *      type changes under erasure.
4419          *  (5) if symbol is an instance method of a raw type, issue an
4420          *      unchecked warning if its argument types change under erasure.
4421          *  If checks succeed:
4422          *    If symbol is a constant, return its constant type
4423          *    else if symbol is a method, return its result type
</pre>
<hr />
<pre>
4995         if (bounds.length() == 0) {
4996             return syms.objectType;
4997         } else if (bounds.length() == 1) {
4998             return bounds.head.type;
4999         } else {
5000             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
5001             // ... the variable&#39;s bound is a class type flagged COMPOUND
5002             // (see comment for TypeVar.bound).
5003             // In this case, generate a class tree that represents the
5004             // bound class, ...
5005             JCExpression extending;
5006             List&lt;JCExpression&gt; implementing;
5007             if (!bounds.head.type.isInterface()) {
5008                 extending = bounds.head;
5009                 implementing = bounds.tail;
5010             } else {
5011                 extending = null;
5012                 implementing = bounds;
5013             }
5014             JCClassDecl cd = make.at(tree).ClassDef(
<span class="line-modified">5015                 make.Modifiers(PUBLIC | ABSTRACT | (extending != null &amp;&amp; TreeInfo.symbol(extending).isValue() ? VALUE : 0)),</span>
5016                 names.empty, List.nil(),
5017                 extending, implementing, List.nil());
5018 
5019             ClassSymbol c = (ClassSymbol)owntype.tsym;
5020             Assert.check((c.flags() &amp; COMPOUND) != 0);
5021             cd.sym = c;
5022             c.sourcefile = env.toplevel.sourcefile;
5023 
5024             // ... and attribute the bound class
5025             c.flags_field |= UNATTRIBUTED;
5026             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
5027             typeEnvs.put(c, cenv);
5028             attribClass(c);
5029             return owntype;
5030         }
5031     }
5032 
5033     public void visitWildcard(JCWildcard tree) {
5034         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
5035         Type type = (tree.kind.kind == BoundKind.UNBOUND)
5036             ? syms.objectType
5037             : attribType(tree.inner, env);
<span class="line-modified">5038         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),</span>
5039                                               tree.kind.kind,
5040                                               syms.boundClass),
5041                 KindSelector.TYP, resultInfo);
5042     }
5043 
5044     public void visitAnnotation(JCAnnotation tree) {
5045         Assert.error(&quot;should be handled in annotate&quot;);
5046     }
5047 
5048     public void visitAnnotatedType(JCAnnotatedType tree) {
5049         attribAnnotationTypes(tree.annotations, env);
5050         Type underlyingType = attribType(tree.underlyingType, env);
5051         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
5052 
5053         if (!env.info.isNewClass)
5054             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
5055         result = tree.type = annotatedType;
5056     }
5057 
5058     public void visitErroneous(JCErroneous tree) {
</pre>
<hr />
<pre>
5122             chk.completionError(pos, ex);
5123         }
5124     }
5125 
5126     void attribModule(ModuleSymbol m) {
5127         // Get environment current at the point of module definition.
5128         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
5129         attribStat(env.tree, env);
5130     }
5131 
5132     /** Main method: attribute class definition associated with given class symbol.
5133      *  reporting completion failures at the given position.
5134      *  @param pos The source position at which completion errors are to be
5135      *             reported.
5136      *  @param c   The class symbol whose definition will be attributed.
5137      */
5138     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
5139         try {
5140             annotate.flush();
5141             attribClass(c);
<span class="line-added">5142             if (types.isValue(c.type)) {</span>
<span class="line-added">5143                 final Env&lt;AttrContext&gt; env = typeEnvs.get(c);</span>
<span class="line-added">5144                 if (!allowValueMemberCycles) {</span>
<span class="line-added">5145                     if (env != null &amp;&amp; env.tree != null &amp;&amp; env.tree.hasTag(CLASSDEF))</span>
<span class="line-added">5146                         chk.checkNonCyclicMembership((JCClassDecl)env.tree);</span>
<span class="line-added">5147                 }</span>
<span class="line-added">5148             }</span>
5149         } catch (CompletionFailure ex) {
5150             chk.completionError(pos, ex);
5151         }
5152     }
5153 
5154     /** Attribute class definition associated with given class symbol.
5155      *  @param c   The class symbol whose definition will be attributed.
5156      */
5157     void attribClass(ClassSymbol c) throws CompletionFailure {
5158         if (c.type.hasTag(ERROR)) return;
5159 
5160         // Check for cycles in the inheritance graph, which can arise from
5161         // ill-formed class files.
5162         chk.checkNonCyclic(null, c.type);
5163 
5164         Type st = types.supertype(c.type);
5165         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5166             // First, attribute superclass.
5167             if (st.hasTag(CLASS))
5168                 attribClass((ClassSymbol)st.tsym);
</pre>
<hr />
<pre>
5201                 deferredLintHandler.flush(env.tree);
5202                 env.info.returnResult = null;
5203                 // java.lang.Enum may not be subclassed by a non-enum
5204                 if (st.tsym == syms.enumSym &amp;&amp;
5205                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5206                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5207 
5208                 // Enums may not be extended by source-level classes
5209                 if (st.tsym != null &amp;&amp;
5210                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5211                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5212                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5213                 }
5214 
5215                 if (isSerializable(c.type)) {
5216                     env.info.isSerializable = true;
5217                 }
5218 
5219                 attribClassBody(env, c);
5220 
<span class="line-added">5221                 if ((c.flags() &amp; (VALUE | ABSTRACT)) == VALUE) { // for non-intersection, concrete values.</span>
<span class="line-added">5222                     Assert.check(env.tree.hasTag(CLASSDEF));</span>
<span class="line-added">5223                     JCClassDecl classDecl = (JCClassDecl) env.tree;</span>
<span class="line-added">5224                     if (classDecl.extending != null) {</span>
<span class="line-added">5225                         chk.checkConstraintsOfInlineSuper(env.tree.pos(), c);</span>
<span class="line-added">5226                     }</span>
<span class="line-added">5227                 }</span>
<span class="line-added">5228 </span>
5229                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5230                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5231                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5232                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5233             } finally {
5234                 env.info.returnResult = prevReturnRes;
5235                 log.useSource(prev);
5236                 chk.setLint(prevLint);
5237             }
5238 
5239         }
5240     }
5241 
5242     public void visitImport(JCImport tree) {
5243         // nothing to do
5244     }
5245 
5246     public void visitModuleDef(JCModuleDecl tree) {
5247         tree.sym.completeUsesProvides();
5248         ModuleSymbol msym = tree.sym;
</pre>
<hr />
<pre>
5314         chk.checkClassBounds(tree.pos(), c.type);
5315 
5316         tree.type = c.type;
5317 
5318         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5319              l.nonEmpty(); l = l.tail) {
5320              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5321         }
5322 
5323         // Check that a generic class doesn&#39;t extend Throwable
5324         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5325             log.error(tree.extending.pos(), Errors.GenericThrowable);
5326 
5327         // Check that all methods which implement some
5328         // method conform to the method they implement.
5329         chk.checkImplementations(tree);
5330 
5331         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5332         checkAutoCloseable(tree.pos(), env, c.type);
5333 
<span class="line-added">5334         boolean hasInstanceFields = false;</span>
5335         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5336             // Attribute declaration
5337             attribStat(l.head, env);
<span class="line-added">5338 </span>
<span class="line-added">5339             if (l.head.hasTag(VARDEF) &amp;&amp; (TreeInfo.flags(l.head) &amp; STATIC) == 0)</span>
<span class="line-added">5340                 hasInstanceFields = true;</span>
<span class="line-added">5341 </span>
5342             // Check that declarations in inner classes are not static (JLS 8.1.2)
5343             // Make an exception for static constants.
5344             if (c.owner.kind != PCK &amp;&amp;
5345                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5346                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5347                 Symbol sym = null;
5348                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5349                 if (sym == null ||
5350                     sym.kind != VAR ||
5351                     ((VarSymbol) sym).getConstValue() == null)
5352                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5353             }
5354         }
<span class="line-added">5355         if (!allowEmptyValues &amp;&amp; !hasInstanceFields &amp;&amp; (c.flags() &amp; (VALUE | SYNTHETIC)) == VALUE) {</span>
<span class="line-added">5356             log.error(tree.pos(), Errors.EmptyValueNotYet);</span>
<span class="line-added">5357         }</span>
5358 
5359         // Check for cycles among non-initial constructors.
5360         chk.checkCyclicConstructors(tree);
5361 
5362         // Check for cycles among annotation elements.
5363         chk.checkNonCyclicElements(tree);
5364 
5365         // Check for proper use of serialVersionUID
5366         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5367                 &amp;&amp; isSerializable(c.type)
5368                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5369                 &amp;&amp; !c.isAnonymous()) {
5370             checkSerialVersionUID(tree, c);
5371         }
5372         if (allowTypeAnnos) {
5373             // Correctly organize the positions of the type annotations
5374             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5375 
5376             // Check type annotations applicability rules
5377             validateTypeAnnotations(tree, false);
</pre>
</td>
</tr>
</table>
<center><a href="../code/Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
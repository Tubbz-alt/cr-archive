<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.Supplier;
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileManager;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.Compound;
  36 import com.sun.tools.javac.code.Directive.ExportsDirective;
  37 import com.sun.tools.javac.code.Directive.RequiresDirective;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  40 import com.sun.tools.javac.jvm.*;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  51 import com.sun.tools.javac.util.List;
  52 
  53 import com.sun.tools.javac.code.Lint;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Scope.WriteableScope;
  56 import com.sun.tools.javac.code.Type.*;
  57 import com.sun.tools.javac.code.Symbol.*;
  58 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  59 import com.sun.tools.javac.tree.JCTree.*;
  60 
  61 import static com.sun.tools.javac.code.Flags.*;
  62 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  63 import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
  64 import static com.sun.tools.javac.code.Kinds.*;
  65 import static com.sun.tools.javac.code.Kinds.Kind.*;
  66 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  67 import static com.sun.tools.javac.code.TypeTag.*;
  68 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  69 
  70 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  71 
  72 /** Type checking helper class for the attribution phase.
  73  *
  74  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  75  *  If you write code that depends on this, you do so at your own risk.
  76  *  This code and its internal interfaces are subject to change or
  77  *  deletion without notice.&lt;/b&gt;
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;
<a name="1" id="anc1"></a><span class="line-added">  98     private final boolean allowValueBasedClasses;</span>
  99 
 100     // The set of lint options currently in effect. It is initialized
 101     // from the context, and then is set/reset as needed by Attr as it
 102     // visits all the various parts of the trees during attribution.
 103     private Lint lint;
 104 
 105     // The method being analyzed in Attr - it is set/reset as needed by
 106     // Attr as it visits new method declarations.
 107     private MethodSymbol method;
 108 
 109     public static Check instance(Context context) {
 110         Check instance = context.get(checkKey);
 111         if (instance == null)
 112             instance = new Check(context);
 113         return instance;
 114     }
 115 
 116     protected Check(Context context) {
 117         context.put(checkKey, this);
 118 
 119         names = Names.instance(context);
 120         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 121             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 122             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 123         log = Log.instance(context);
 124         rs = Resolve.instance(context);
 125         syms = Symtab.instance(context);
 126         enter = Enter.instance(context);
 127         deferredAttr = DeferredAttr.instance(context);
 128         infer = Infer.instance(context);
 129         types = Types.instance(context);
 130         typeAnnotations = TypeAnnotations.instance(context);
 131         diags = JCDiagnostic.Factory.instance(context);
 132         Options options = Options.instance(context);
 133         lint = Lint.instance(context);
 134         fileManager = context.get(JavaFileManager.class);
 135 
 136         source = Source.instance(context);
 137         target = Target.instance(context);
 138         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
<a name="2" id="anc2"></a><span class="line-modified"> 139         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);</span>
 140         Target target = Target.instance(context);
 141         syntheticNameChar = target.syntheticNameChar();
 142 
 143         profile = Profile.instance(context);
 144         preview = Preview.instance(context);
 145 
 146         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 147         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 148         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 149         boolean enforceMandatoryWarnings = true;
 150 
 151         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 152                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 153         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 154                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 155         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 156                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 157         sunApiHandler = new MandatoryWarningHandler(log, false,
 158                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 159 
 160         deferredLintHandler = DeferredLintHandler.instance(context);
 161 
 162         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 163                 Feature.RECORDS.allowedInSource(source);
 164     }
 165 
 166     /** Character for synthetic names
 167      */
 168     char syntheticNameChar;
 169 
 170     /** A table mapping flat names of all compiled classes for each module in this run
 171      *  to their symbols; maintained from outside.
 172      */
 173     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 174 
 175     /** A handler for messages about deprecated usage.
 176      */
 177     private MandatoryWarningHandler deprecationHandler;
 178 
 179     /** A handler for messages about deprecated-for-removal usage.
 180      */
 181     private MandatoryWarningHandler removalHandler;
 182 
 183     /** A handler for messages about unchecked or unsafe usage.
 184      */
 185     private MandatoryWarningHandler uncheckedHandler;
 186 
 187     /** A handler for messages about using proprietary API.
 188      */
 189     private MandatoryWarningHandler sunApiHandler;
 190 
 191     /** A handler for deferred lint warnings.
 192      */
 193     private DeferredLintHandler deferredLintHandler;
 194 
 195     /** Are records allowed
 196      */
 197     private final boolean allowRecords;
 198 
 199 /* *************************************************************************
 200  * Errors and Warnings
 201  **************************************************************************/
 202 
 203     Lint setLint(Lint newLint) {
 204         Lint prev = lint;
 205         lint = newLint;
 206         return prev;
 207     }
 208 
 209     MethodSymbol setMethod(MethodSymbol newMethod) {
 210         MethodSymbol prev = method;
 211         method = newMethod;
 212         return prev;
 213     }
 214 
 215     /** Warn about deprecated symbol.
 216      *  @param pos        Position to be used for error reporting.
 217      *  @param sym        The deprecated symbol.
 218      */
 219     void warnDeprecated(DiagnosticPosition pos, Symbol sym) {
 220         if (sym.isDeprecatedForRemoval()) {
 221             if (!lint.isSuppressed(LintCategory.REMOVAL)) {
 222                 if (sym.kind == MDL) {
 223                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemovalModule(sym));
 224                 } else {
 225                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemoval(sym, sym.location()));
 226                 }
 227             }
 228         } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {
 229             if (sym.kind == MDL) {
 230                 deprecationHandler.report(pos, Warnings.HasBeenDeprecatedModule(sym));
 231             } else {
 232                 deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));
 233             }
 234         }
 235     }
 236 
 237     /** Warn about deprecated symbol.
 238      *  @param pos        Position to be used for error reporting.
 239      *  @param sym        The deprecated symbol.
 240      */
 241     void warnPreview(DiagnosticPosition pos, Symbol sym) {
 242         warnPreview(pos, Warnings.IsPreview(sym));
 243     }
 244 
 245     /** Log a preview warning.
 246      *  @param pos        Position to be used for error reporting.
 247      *  @param msg        A Warning describing the problem.
 248      */
 249     public void warnPreview(DiagnosticPosition pos, Warning warnKey) {
 250         if (!lint.isSuppressed(LintCategory.PREVIEW))
 251             preview.reportPreviewWarning(pos, warnKey);
 252     }
 253 
 254     /** Warn about unchecked operation.
 255      *  @param pos        Position to be used for error reporting.
 256      *  @param msg        A string describing the problem.
 257      */
 258     public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {
 259         if (!lint.isSuppressed(LintCategory.UNCHECKED))
 260             uncheckedHandler.report(pos, warnKey);
 261     }
 262 
 263     /** Warn about unsafe vararg method decl.
 264      *  @param pos        Position to be used for error reporting.
 265      */
 266     void warnUnsafeVararg(DiagnosticPosition pos, Warning warnKey) {
 267         if (lint.isEnabled(LintCategory.VARARGS))
 268             log.warning(LintCategory.VARARGS, pos, warnKey);
 269     }
 270 
 271     public void warnStatic(DiagnosticPosition pos, Warning warnKey) {
 272         if (lint.isEnabled(LintCategory.STATIC))
 273             log.warning(LintCategory.STATIC, pos, warnKey);
 274     }
 275 
 276     /** Warn about division by integer constant zero.
 277      *  @param pos        Position to be used for error reporting.
 278      */
 279     void warnDivZero(DiagnosticPosition pos) {
 280         if (lint.isEnabled(LintCategory.DIVZERO))
 281             log.warning(LintCategory.DIVZERO, pos, Warnings.DivZero);
 282     }
 283 
 284     /**
 285      * Report any deferred diagnostics.
 286      */
 287     public void reportDeferredDiagnostics() {
 288         deprecationHandler.reportDeferredDiagnostic();
 289         removalHandler.reportDeferredDiagnostic();
 290         uncheckedHandler.reportDeferredDiagnostic();
 291         sunApiHandler.reportDeferredDiagnostic();
 292     }
 293 
 294 
 295     /** Report a failure to complete a class.
 296      *  @param pos        Position to be used for error reporting.
 297      *  @param ex         The failure to report.
 298      */
 299     public Type completionError(DiagnosticPosition pos, CompletionFailure ex) {
 300         log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));
 301         return syms.errType;
 302     }
 303 
 304     /** Report an error that wrong type tag was found.
 305      *  @param pos        Position to be used for error reporting.
 306      *  @param required   An internationalized string describing the type tag
 307      *                    required.
 308      *  @param found      The type that was found.
 309      */
 310     Type typeTagError(DiagnosticPosition pos, JCDiagnostic required, Object found) {
 311         // this error used to be raised by the parser,
 312         // but has been delayed to this point:
 313         if (found instanceof Type &amp;&amp; ((Type)found).hasTag(VOID)) {
 314             log.error(pos, Errors.IllegalStartOfType);
 315             return syms.errType;
 316         }
 317         log.error(pos, Errors.TypeFoundReq(found, required));
 318         return types.createErrorType(found instanceof Type ? (Type)found : syms.errType);
 319     }
 320 
 321     /** Report an error that symbol cannot be referenced before super
 322      *  has been called.
 323      *  @param pos        Position to be used for error reporting.
 324      *  @param sym        The referenced symbol.
 325      */
 326     void earlyRefError(DiagnosticPosition pos, Symbol sym) {
 327         log.error(pos, Errors.CantRefBeforeCtorCalled(sym));
 328     }
 329 
 330     /** Report duplicate declaration error.
 331      */
 332     void duplicateError(DiagnosticPosition pos, Symbol sym) {
 333         if (!sym.type.isErroneous()) {
 334             Symbol location = sym.location();
 335             if (location.kind == MTH &amp;&amp;
 336                     ((MethodSymbol)location).isStaticOrInstanceInit()) {
 337                 log.error(pos,
 338                           Errors.AlreadyDefinedInClinit(kindName(sym),
 339                                                         sym,
 340                                                         kindName(sym.location()),
 341                                                         kindName(sym.location().enclClass()),
 342                                                         sym.location().enclClass()));
 343             } else {
 344                 /* dont error if this is a duplicated parameter of a generated canonical constructor
 345                  * as we should have issued an error for the duplicated fields
 346                  */
 347                 if (location.kind != MTH ||
 348                         ((sym.owner.flags_field &amp; GENERATEDCONSTR) == 0) ||
 349                         ((sym.owner.flags_field &amp; RECORD) == 0)) {
 350                     log.error(pos,
 351                             Errors.AlreadyDefined(kindName(sym),
 352                                     sym,
 353                                     kindName(sym.location()),
 354                                     sym.location()));
 355                 }
 356             }
 357         }
 358     }
 359 
 360     /** Report array/varargs duplicate declaration
 361      */
 362     void varargsDuplicateError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
 363         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
 364             log.error(pos, Errors.ArrayAndVarargs(sym1, sym2, sym2.location()));
 365         }
 366     }
 367 
 368 /* ************************************************************************
 369  * duplicate declaration checking
 370  *************************************************************************/
 371 
 372     /** Check that variable does not hide variable with same name in
 373      *  immediately enclosing local scope.
 374      *  @param pos           Position for error reporting.
 375      *  @param v             The symbol.
 376      *  @param s             The scope.
 377      */
 378     void checkTransparentVar(DiagnosticPosition pos, VarSymbol v, Scope s) {
 379         for (Symbol sym : s.getSymbolsByName(v.name)) {
 380             if (sym.owner != v.owner) break;
 381             if (sym.kind == VAR &amp;&amp;
 382                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 383                 v.name != names.error) {
 384                 duplicateError(pos, sym);
 385                 return;
 386             }
 387         }
 388     }
 389 
 390     /** Check that a class or interface does not hide a class or
 391      *  interface with same name in immediately enclosing local scope.
 392      *  @param pos           Position for error reporting.
 393      *  @param c             The symbol.
 394      *  @param s             The scope.
 395      */
 396     void checkTransparentClass(DiagnosticPosition pos, ClassSymbol c, Scope s) {
 397         for (Symbol sym : s.getSymbolsByName(c.name)) {
 398             if (sym.owner != c.owner) break;
 399             if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR) &amp;&amp;
 400                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 401                 c.name != names.error) {
 402                 duplicateError(pos, sym);
 403                 return;
 404             }
 405         }
 406     }
 407 
 408     /** Check that class does not have the same name as one of
 409      *  its enclosing classes, or as a class defined in its enclosing scope.
 410      *  return true if class is unique in its enclosing scope.
 411      *  @param pos           Position for error reporting.
 412      *  @param name          The class name.
 413      *  @param s             The enclosing scope.
 414      */
 415     boolean checkUniqueClassName(DiagnosticPosition pos, Name name, Scope s) {
 416         for (Symbol sym : s.getSymbolsByName(name, NON_RECURSIVE)) {
 417             if (sym.kind == TYP &amp;&amp; sym.name != names.error) {
 418                 duplicateError(pos, sym);
 419                 return false;
 420             }
 421         }
 422         for (Symbol sym = s.owner; sym != null; sym = sym.owner) {
 423             if (sym.kind == TYP &amp;&amp; sym.name == name &amp;&amp; sym.name != names.error) {
 424                 duplicateError(pos, sym);
 425                 return true;
 426             }
 427         }
 428         return true;
 429     }
 430 
 431 /* *************************************************************************
 432  * Class name generation
 433  **************************************************************************/
 434 
 435 
 436     private Map&lt;Pair&lt;Name, Name&gt;, Integer&gt; localClassNameIndexes = new HashMap&lt;&gt;();
 437 
 438     /** Return name of local class.
 439      *  This is of the form   {@code &lt;enclClass&gt; $ n &lt;classname&gt; }
 440      *  where
 441      *    enclClass is the flat name of the enclosing class,
 442      *    classname is the simple name of the local class
 443      */
 444     public Name localClassName(ClassSymbol c) {
 445         Name enclFlatname = c.owner.enclClass().flatname;
 446         String enclFlatnameStr = enclFlatname.toString();
 447         Pair&lt;Name, Name&gt; key = new Pair&lt;&gt;(enclFlatname, c.name);
 448         Integer index = localClassNameIndexes.get(key);
 449         for (int i = (index == null) ? 1 : index; ; i++) {
 450             Name flatname = names.fromString(enclFlatnameStr
 451                     + syntheticNameChar + i + c.name);
 452             if (getCompiled(c.packge().modle, flatname) == null) {
 453                 localClassNameIndexes.put(key, i + 1);
 454                 return flatname;
 455             }
 456         }
 457     }
 458 
 459     public void clearLocalClassNameIndexes(ClassSymbol c) {
 460         if (c.owner != null &amp;&amp; c.owner.kind != NIL) {
 461             localClassNameIndexes.remove(new Pair&lt;&gt;(
 462                     c.owner.enclClass().flatname, c.name));
 463         }
 464     }
 465 
 466     public void newRound() {
 467         compiled.clear();
 468         localClassNameIndexes.clear();
 469     }
 470 
 471     public void clear() {
 472         deprecationHandler.clear();
 473         removalHandler.clear();
 474         uncheckedHandler.clear();
 475         sunApiHandler.clear();
 476     }
 477 
 478     public void putCompiled(ClassSymbol csym) {
 479         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 480     }
 481 
 482     public ClassSymbol getCompiled(ClassSymbol csym) {
 483         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 484     }
 485 
 486     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 487         return compiled.get(Pair.of(msym, flatname));
 488     }
 489 
 490     public void removeCompiled(ClassSymbol csym) {
 491         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 492     }
 493 
<a name="3" id="anc3"></a><span class="line-modified"> 494     /* *************************************************************************</span>
 495  * Type Checking
 496  **************************************************************************/
 497 
 498     /**
 499      * A check context is an object that can be used to perform compatibility
 500      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 501      * vary significantly.
 502      */
 503     public interface CheckContext {
 504         /**
 505          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 506          */
 507         boolean compatible(Type found, Type req, Warner warn);
 508         /**
 509          * Report a check error
 510          */
 511         void report(DiagnosticPosition pos, JCDiagnostic details);
 512         /**
 513          * Obtain a warner for this check context
 514          */
 515         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req);
 516 
 517         public InferenceContext inferenceContext();
 518 
 519         public DeferredAttr.DeferredAttrContext deferredAttrContext();
 520     }
 521 
 522     /**
 523      * This class represent a check context that is nested within another check
 524      * context - useful to check sub-expressions. The default behavior simply
 525      * redirects all method calls to the enclosing check context leveraging
 526      * the forwarding pattern.
 527      */
 528     static class NestedCheckContext implements CheckContext {
 529         CheckContext enclosingContext;
 530 
 531         NestedCheckContext(CheckContext enclosingContext) {
 532             this.enclosingContext = enclosingContext;
 533         }
 534 
 535         public boolean compatible(Type found, Type req, Warner warn) {
 536             return enclosingContext.compatible(found, req, warn);
 537         }
 538 
 539         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 540             enclosingContext.report(pos, details);
 541         }
 542 
 543         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 544             return enclosingContext.checkWarner(pos, found, req);
 545         }
 546 
 547         public InferenceContext inferenceContext() {
 548             return enclosingContext.inferenceContext();
 549         }
 550 
 551         public DeferredAttrContext deferredAttrContext() {
 552             return enclosingContext.deferredAttrContext();
 553         }
 554     }
 555 
 556     /**
 557      * Check context to be used when evaluating assignment/return statements
 558      */
 559     CheckContext basicHandler = new CheckContext() {
 560         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 561             log.error(pos, Errors.ProbFoundReq(details));
 562         }
 563         public boolean compatible(Type found, Type req, Warner warn) {
 564             return types.isAssignable(found, req, warn);
 565         }
 566 
 567         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 568             return convertWarner(pos, found, req);
 569         }
 570 
 571         public InferenceContext inferenceContext() {
 572             return infer.emptyContext;
 573         }
 574 
 575         public DeferredAttrContext deferredAttrContext() {
 576             return deferredAttr.emptyDeferredAttrContext;
 577         }
 578 
 579         @Override
 580         public String toString() {
 581             return &quot;CheckContext: basicHandler&quot;;
 582         }
 583     };
 584 
 585     /** Check that a given type is assignable to a given proto-type.
 586      *  If it is, return the type, otherwise return errType.
 587      *  @param pos        Position to be used for error reporting.
 588      *  @param found      The type that was found.
 589      *  @param req        The type that was required.
 590      */
 591     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 592         return checkType(pos, found, req, basicHandler);
 593     }
 594 
 595     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 596         final InferenceContext inferenceContext = checkContext.inferenceContext();
 597         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 598             inferenceContext.addFreeTypeListener(List.of(req, found),
 599                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
<a name="4" id="anc4"></a><span class="line-added"> 600         } else {</span>
<span class="line-added"> 601             if (found.hasTag(CLASS)) {</span>
<span class="line-added"> 602                 if (inferenceContext != infer.emptyContext)</span>
<span class="line-added"> 603                     checkParameterizationWithValues(pos, found);</span>
<span class="line-added"> 604             }</span>
 605         }
 606         if (req.hasTag(ERROR))
 607             return req;
 608         if (req.hasTag(NONE))
 609             return found;
 610         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
<a name="5" id="anc5"></a><span class="line-added"> 611             if (found.hasTag(BOT) &amp;&amp; types.isValueBased(req)) {</span>
<span class="line-added"> 612                 log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));</span>
<span class="line-added"> 613             }</span>
 614             return found;
 615         } else {
 616             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 617                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 618                 return types.createErrorType(found);
 619             }
 620             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 621             return types.createErrorType(found);
 622         }
 623     }
 624 
 625     /** Check that a given type can be cast to a given target type.
 626      *  Return the result of the cast.
 627      *  @param pos        Position to be used for error reporting.
 628      *  @param found      The type that is being cast.
 629      *  @param req        The target type of the cast.
 630      */
 631     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 632         return checkCastable(pos, found, req, basicHandler);
 633     }
 634     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 635         if (types.isCastable(found, req, castWarner(pos, found, req))) {
<a name="6" id="anc6"></a><span class="line-added"> 636             if (types.isValueBased(req)) {</span>
<span class="line-added"> 637                 if (found.hasTag(BOT)) {</span>
<span class="line-added"> 638                     log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));</span>
<span class="line-added"> 639                 } else if (!types.isValueBased(found)) {</span>
<span class="line-added"> 640                     log.warning(pos, Warnings.PotentialNullPollution(found));</span>
<span class="line-added"> 641                 }</span>
<span class="line-added"> 642             }</span>
 643             return req;
 644         } else {
 645             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 646             return types.createErrorType(found);
 647         }
 648     }
 649 
 650     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 651      * The problem should only be reported for non-292 cast
 652      */
 653     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 654         if (!tree.type.isErroneous()
 655                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 656                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 657                 &amp;&amp; !is292targetTypeCast(tree)) {
 658             deferredLintHandler.report(() -&gt; {
 659                 if (lint.isEnabled(LintCategory.CAST))
 660                     log.warning(LintCategory.CAST,
 661                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 662             });
 663         }
 664     }
 665     //where
 666         private boolean is292targetTypeCast(JCTypeCast tree) {
 667             boolean is292targetTypeCast = false;
 668             JCExpression expr = TreeInfo.skipParens(tree.expr);
 669             if (expr.hasTag(APPLY)) {
 670                 JCMethodInvocation apply = (JCMethodInvocation)expr;
 671                 Symbol sym = TreeInfo.symbol(apply.meth);
 672                 is292targetTypeCast = sym != null &amp;&amp;
 673                     sym.kind == MTH &amp;&amp;
 674                     (sym.flags() &amp; HYPOTHETICAL) != 0;
 675             }
 676             return is292targetTypeCast;
 677         }
 678 
 679         private static final boolean ignoreAnnotatedCasts = true;
 680 
 681     /** Check that a type is within some bounds.
 682      *
 683      *  Used in TypeApply to verify that, e.g., X in {@code V&lt;X&gt;} is a valid
 684      *  type argument.
 685      *  @param a             The type that should be bounded by bs.
 686      *  @param bound         The bound.
 687      */
 688     private boolean checkExtends(Type a, Type bound) {
 689          if (a.isUnbound()) {
 690              return true;
 691          } else if (!a.hasTag(WILDCARD)) {
 692              a = types.cvarUpperBound(a);
 693              return types.isSubtype(a, bound);
 694          } else if (a.isExtendsBound()) {
 695              return types.isCastable(bound, types.wildUpperBound(a), types.noWarnings);
 696          } else if (a.isSuperBound()) {
 697              return !types.notSoftSubtype(types.wildLowerBound(a), bound);
 698          }
 699          return true;
 700      }
 701 
 702     /** Check that type is different from &#39;void&#39;.
 703      *  @param pos           Position to be used for error reporting.
 704      *  @param t             The type to be checked.
 705      */
 706     Type checkNonVoid(DiagnosticPosition pos, Type t) {
 707         if (t.hasTag(VOID)) {
 708             log.error(pos, Errors.VoidNotAllowedHere);
 709             return types.createErrorType(t);
 710         } else {
 711             return t;
 712         }
 713     }
 714 
 715     Type checkClassOrArrayType(DiagnosticPosition pos, Type t) {
 716         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ARRAY) &amp;&amp; !t.hasTag(ERROR)) {
 717             return typeTagError(pos,
 718                                 diags.fragment(Fragments.TypeReqClassArray),
 719                                 asTypeParam(t));
 720         } else {
 721             return t;
 722         }
 723     }
 724 
 725     /** Check that type is a class or interface type.
 726      *  @param pos           Position to be used for error reporting.
 727      *  @param t             The type to be checked.
 728      */
 729     Type checkClassType(DiagnosticPosition pos, Type t) {
 730         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 731             return typeTagError(pos,
 732                                 diags.fragment(Fragments.TypeReqClass),
 733                                 asTypeParam(t));
 734         } else {
 735             return t;
 736         }
 737     }
 738     //where
 739         private Object asTypeParam(Type t) {
 740             return (t.hasTag(TYPEVAR))
 741                                     ? diags.fragment(Fragments.TypeParameter(t))
 742                                     : t;
 743         }
 744 
<a name="7" id="anc7"></a><span class="line-added"> 745     void checkConstraintsOfInlineSuper(DiagnosticPosition pos, ClassSymbol c) {</span>
<span class="line-added"> 746         for(Type st = types.supertype(c.type); st != Type.noType; st = types.supertype(st)) {</span>
<span class="line-added"> 747             if (st == null || st.tsym == null || st.tsym.kind == ERR)</span>
<span class="line-added"> 748                 return;</span>
<span class="line-added"> 749             if  (st.tsym == syms.objectType.tsym)</span>
<span class="line-added"> 750                 return;</span>
<span class="line-added"> 751             if (!st.tsym.isAbstract()) {</span>
<span class="line-added"> 752                 log.error(pos, Errors.ConcreteSupertypeForInlineClass(c, st));</span>
<span class="line-added"> 753             }</span>
<span class="line-added"> 754             if ((st.tsym.flags() &amp; HASINITBLOCK) != 0) {</span>
<span class="line-added"> 755                 log.error(pos, Errors.SuperClassDeclaresInitBlock(c, st));</span>
<span class="line-added"> 756             }</span>
<span class="line-added"> 757             // No instance fields and no arged constructors both mean inner classes cannot be inline supers.</span>
<span class="line-added"> 758             Type encl = st.getEnclosingType();</span>
<span class="line-added"> 759             if (encl != null &amp;&amp; encl.hasTag(CLASS)) {</span>
<span class="line-added"> 760                 log.error(pos, Errors.SuperClassCannotBeInner(c, st));</span>
<span class="line-added"> 761             }</span>
<span class="line-added"> 762             for (Symbol s : st.tsym.members().getSymbols(NON_RECURSIVE)) {</span>
<span class="line-added"> 763                 switch (s.kind) {</span>
<span class="line-added"> 764                 case VAR:</span>
<span class="line-added"> 765                     if ((s.flags() &amp; STATIC) == 0) {</span>
<span class="line-added"> 766                         log.error(pos, Errors.SuperFieldNotAllowed(s, c, st));</span>
<span class="line-added"> 767                     }</span>
<span class="line-added"> 768                     break;</span>
<span class="line-added"> 769                 case MTH:</span>
<span class="line-added"> 770                     if ((s.flags() &amp; SYNCHRONIZED) != 0) {</span>
<span class="line-added"> 771                         log.error(pos, Errors.SuperMethodCannotBeSynchronized(s, c, st));</span>
<span class="line-added"> 772                     } else if (s.isConstructor()) {</span>
<span class="line-added"> 773                         MethodSymbol m = (MethodSymbol)s;</span>
<span class="line-added"> 774                         if (m.getParameters().size() &gt; 0) {</span>
<span class="line-added"> 775                             log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, c, st));</span>
<span class="line-added"> 776                         } else {</span>
<span class="line-added"> 777                             if ((m.flags() &amp; (GENERATEDCONSTR | EMPTYNOARGCONSTR)) == 0) {</span>
<span class="line-added"> 778                                 log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, c, st));</span>
<span class="line-added"> 779                             }</span>
<span class="line-added"> 780                         }</span>
<span class="line-added"> 781                     }</span>
<span class="line-added"> 782                     break;</span>
<span class="line-added"> 783                 }</span>
<span class="line-added"> 784             }</span>
<span class="line-added"> 785         }</span>
<span class="line-added"> 786     }</span>
<span class="line-added"> 787 </span>
 788     /** Check that type is a valid qualifier for a constructor reference expression
 789      */
 790     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 791         t = checkClassOrArrayType(pos, t);
 792         if (t.hasTag(CLASS)) {
 793             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 794                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 795                 t = types.createErrorType(t);
 796             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 797                 log.error(pos, Errors.EnumCantBeInstantiated);
 798                 t = types.createErrorType(t);
 799             } else {
 800                 t = checkClassType(pos, t, true);
 801             }
 802         } else if (t.hasTag(ARRAY)) {
 803             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 804                 log.error(pos, Errors.GenericArrayCreation);
 805                 t = types.createErrorType(t);
 806             }
 807         }
 808         return t;
 809     }
 810 
 811     /** Check that type is a class or interface type.
 812      *  @param pos           Position to be used for error reporting.
 813      *  @param t             The type to be checked.
 814      *  @param noBounds    True if type bounds are illegal here.
 815      */
 816     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 817         t = checkClassType(pos, t);
 818         if (noBounds &amp;&amp; t.isParameterized()) {
 819             List&lt;Type&gt; args = t.getTypeArguments();
 820             while (args.nonEmpty()) {
 821                 if (args.head.hasTag(WILDCARD))
 822                     return typeTagError(pos,
 823                                         diags.fragment(Fragments.TypeReqExact),
 824                                         args.head);
 825                 args = args.tail;
 826             }
 827         }
 828         return t;
 829     }
 830 
 831     /** Check that type is a reference type, i.e. a class, interface or array type
 832      *  or a type variable.
 833      *  @param pos           Position to be used for error reporting.
 834      *  @param t             The type to be checked.
<a name="8" id="anc8"></a><span class="line-added"> 835      *  @param valueOK       If false, a value class does not qualify</span>
 836      */
<a name="9" id="anc9"></a><span class="line-modified"> 837     Type checkRefType(DiagnosticPosition pos, Type t, boolean valueOK) {</span>
<span class="line-modified"> 838         if (t.isReference() &amp;&amp; (valueOK || !types.isValue(t)))</span>
 839             return t;
 840         else
 841             return typeTagError(pos,
 842                                 diags.fragment(Fragments.TypeReqRef),
 843                                 t);
 844     }
 845 
<a name="10" id="anc10"></a><span class="line-added"> 846     /** Check that type is a reference type, i.e. a class, interface or array type</span>
<span class="line-added"> 847      *  or a type variable.</span>
<span class="line-added"> 848      *  @param pos           Position to be used for error reporting.</span>
<span class="line-added"> 849      *  @param t             The type to be checked.</span>
<span class="line-added"> 850      */</span>
<span class="line-added"> 851     Type checkRefType(DiagnosticPosition pos, Type t) {</span>
<span class="line-added"> 852         return checkRefType(pos, t, true);</span>
<span class="line-added"> 853     }</span>
<span class="line-added"> 854 </span>
 855     /** Check that each type is a reference type, i.e. a class, interface or array type
 856      *  or a type variable.
 857      *  @param trees         Original trees, used for error reporting.
 858      *  @param types         The types to be checked.
 859      */
 860     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 861         List&lt;JCExpression&gt; tl = trees;
 862         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
<a name="11" id="anc11"></a><span class="line-modified"> 863             l.head = checkRefType(tl.head.pos(), l.head, false);</span>
 864             tl = tl.tail;
 865         }
 866         return types;
 867     }
 868 
 869     /** Check that type is a null or reference type.
 870      *  @param pos           Position to be used for error reporting.
 871      *  @param t             The type to be checked.
 872      */
 873     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 874         if (t.isReference() || t.hasTag(BOT))
 875             return t;
 876         else
 877             return typeTagError(pos,
 878                                 diags.fragment(Fragments.TypeReqRef),
 879                                 t);
 880     }
 881 
 882     /** Check that flag set does not contain elements of two conflicting sets. s
 883      *  Return true if it doesn&#39;t.
 884      *  @param pos           Position to be used for error reporting.
 885      *  @param flags         The set of flags to be checked.
 886      *  @param set1          Conflicting flags set #1.
 887      *  @param set2          Conflicting flags set #2.
 888      */
 889     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 890         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 891             log.error(pos,
 892                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 893                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 894             return false;
 895         } else
 896             return true;
 897     }
 898 
<a name="12" id="anc12"></a><span class="line-added"> 899     void checkParameterizationWithValues(DiagnosticPosition pos, Type t) {</span>
<span class="line-added"> 900         valueParameterizationChecker.visit(t, pos);</span>
<span class="line-added"> 901     }</span>
<span class="line-added"> 902 </span>
<span class="line-added"> 903     /** valueParameterizationChecker: A type visitor that descends down the given type looking for instances of value types</span>
<span class="line-added"> 904      *  being used as type arguments and issues error against those usages.</span>
<span class="line-added"> 905      */</span>
<span class="line-added"> 906     private final Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt; valueParameterizationChecker = new Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt;() {</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908         @Override</span>
<span class="line-added"> 909         public Void visitType(Type t, DiagnosticPosition pos) {</span>
<span class="line-added"> 910             return null;</span>
<span class="line-added"> 911         }</span>
<span class="line-added"> 912 </span>
<span class="line-added"> 913         @Override</span>
<span class="line-added"> 914         public Void visitClassType(ClassType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 915             for (Type targ : t.allparams()) {</span>
<span class="line-added"> 916                 if (types.isValue(targ)) {</span>
<span class="line-added"> 917                     log.error(pos, Errors.GenericParameterizationWithValueType(t));</span>
<span class="line-added"> 918                 }</span>
<span class="line-added"> 919                 visit(targ, pos);</span>
<span class="line-added"> 920             }</span>
<span class="line-added"> 921             return null;</span>
<span class="line-added"> 922         }</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924         @Override</span>
<span class="line-added"> 925         public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {</span>
<span class="line-added"> 926              return null;</span>
<span class="line-added"> 927         }</span>
<span class="line-added"> 928 </span>
<span class="line-added"> 929         @Override</span>
<span class="line-added"> 930         public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 931             return null;</span>
<span class="line-added"> 932         }</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934         @Override</span>
<span class="line-added"> 935         public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 936             return visit(t.elemtype, pos);</span>
<span class="line-added"> 937         }</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939         @Override</span>
<span class="line-added"> 940         public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 941             return visit(t.type, pos);</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943     };</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945 </span>
<span class="line-added"> 946 </span>
 947     /** Check that usage of diamond operator is correct (i.e. diamond should not
 948      * be used with non-generic classes or in anonymous class creation expressions)
 949      */
 950     Type checkDiamond(JCNewClass tree, Type t) {
 951         if (!TreeInfo.isDiamond(tree) ||
 952                 t.isErroneous()) {
 953             return checkClassType(tree.clazz.pos(), t, true);
 954         } else {
 955             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 956                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 957                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 958             }
 959             if (t.tsym.type.getTypeArguments().isEmpty()) {
 960                 log.error(tree.clazz.pos(),
 961                           Errors.CantApplyDiamond1(t,
 962                                                    Fragments.DiamondNonGeneric(t)));
 963                 return types.createErrorType(t);
 964             } else if (tree.typeargs != null &amp;&amp;
 965                     tree.typeargs.nonEmpty()) {
 966                 log.error(tree.clazz.pos(),
 967                           Errors.CantApplyDiamond1(t,
 968                                                    Fragments.DiamondAndExplicitParams(t)));
 969                 return types.createErrorType(t);
 970             } else {
 971                 return t;
 972             }
 973         }
 974     }
 975 
 976     /** Check that the type inferred using the diamond operator does not contain
 977      *  non-denotable types such as captured types or intersection types.
 978      *  @param t the type inferred using the diamond operator
 979      *  @return  the (possibly empty) list of non-denotable types.
 980      */
 981     List&lt;Type&gt; checkDiamondDenotable(ClassType t) {
 982         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 983         for (Type arg : t.allparams()) {
 984             if (!checkDenotable(arg)) {
 985                 buf.append(arg);
 986             }
 987         }
 988         return buf.toList();
 989     }
 990 
 991     public boolean checkDenotable(Type t) {
 992         return denotableChecker.visit(t, null);
 993     }
 994         // where
 995 
 996         /** diamondTypeChecker: A type visitor that descends down the given type looking for non-denotable
 997          *  types. The visit methods return false as soon as a non-denotable type is encountered and true
 998          *  otherwise.
 999          */
1000         private static final Types.SimpleVisitor&lt;Boolean, Void&gt; denotableChecker = new Types.SimpleVisitor&lt;Boolean, Void&gt;() {
1001             @Override
1002             public Boolean visitType(Type t, Void s) {
1003                 return true;
1004             }
1005             @Override
1006             public Boolean visitClassType(ClassType t, Void s) {
1007                 if (t.isUnion() || t.isIntersection()) {
1008                     return false;
1009                 }
1010                 for (Type targ : t.allparams()) {
1011                     if (!visit(targ, s)) {
1012                         return false;
1013                     }
1014                 }
1015                 return true;
1016             }
1017 
1018             @Override
1019             public Boolean visitTypeVar(TypeVar t, Void s) {
1020                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
1021                   (i.e cannot have been produced by inference (18.4))
1022                 */
1023                 return (t.tsym.flags() &amp; SYNTHETIC) == 0;
1024             }
1025 
1026             @Override
1027             public Boolean visitCapturedType(CapturedType t, Void s) {
1028                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
1029                   (i.e cannot have been produced by capture conversion (5.1.10))
1030                 */
1031                 return false;
1032             }
1033 
1034             @Override
1035             public Boolean visitArrayType(ArrayType t, Void s) {
1036                 return visit(t.elemtype, s);
1037             }
1038 
1039             @Override
1040             public Boolean visitWildcardType(WildcardType t, Void s) {
1041                 return visit(t.type, s);
1042             }
1043         };
1044 
1045     void checkVarargsMethodDecl(Env&lt;AttrContext&gt; env, JCMethodDecl tree) {
1046         MethodSymbol m = tree.sym;
1047         boolean hasTrustMeAnno = m.attribute(syms.trustMeType.tsym) != null;
1048         Type varargElemType = null;
1049         if (m.isVarArgs()) {
1050             varargElemType = types.elemtype(tree.params.last().type);
1051         }
1052         if (hasTrustMeAnno &amp;&amp; !isTrustMeAllowedOnMethod(m)) {
1053             if (varargElemType != null) {
1054                 JCDiagnostic msg = Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ?
1055                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargs(m)) :
1056                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargsFinalOnly(m));
1057                 log.error(tree,
1058                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
1059                                                            msg));
1060             } else {
1061                 log.error(tree,
1062                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
1063                                                            Fragments.VarargsTrustmeOnNonVarargsMeth(m)));
1064             }
1065         } else if (hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
1066                             types.isReifiable(varargElemType)) {
1067             warnUnsafeVararg(tree, Warnings.VarargsRedundantTrustmeAnno(
1068                                 syms.trustMeType.tsym,
1069                                 diags.fragment(Fragments.VarargsTrustmeOnReifiableVarargs(varargElemType))));
1070         }
1071         else if (!hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
1072                 !types.isReifiable(varargElemType)) {
1073             warnUnchecked(tree.params.head.pos(), Warnings.UncheckedVarargsNonReifiableType(varargElemType));
1074         }
1075     }
1076     //where
1077         private boolean isTrustMeAllowedOnMethod(Symbol s) {
1078             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
1079                 (s.isConstructor() ||
1080                     (s.flags() &amp; (STATIC | FINAL |
1081                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
1082         }
1083 
1084     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
1085         //check that resulting type is not the null type
1086         if (t.hasTag(BOT)) {
1087             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
1088             return types.createErrorType(t);
1089         } else if (t.hasTag(VOID)) {
1090             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
1091             return types.createErrorType(t);
1092         }
1093 
1094         //upward project the initializer type
<a name="13" id="anc13"></a><span class="line-modified">1095         Type varType = types.upward(t, types.captures(t));</span>
<span class="line-added">1096         if (varType.hasTag(CLASS)) {</span>
<span class="line-added">1097             checkParameterizationWithValues(pos, varType);</span>
<span class="line-added">1098         }</span>
<span class="line-added">1099         return varType;</span>
<span class="line-added">1100     }</span>
<span class="line-added">1101 </span>
<span class="line-added">1102     public void checkForSuspectClassLiteralComparison(</span>
<span class="line-added">1103             final JCBinary tree,</span>
<span class="line-added">1104             final Type leftType,</span>
<span class="line-added">1105             final Type rightType) {</span>
<span class="line-added">1106 </span>
<span class="line-added">1107         if (lint.isEnabled(LintCategory.MIGRATION)) {</span>
<span class="line-added">1108             if (isInvocationOfGetClass(tree.lhs) &amp;&amp; isClassOfSomeInterface(rightType) ||</span>
<span class="line-added">1109                     isInvocationOfGetClass(tree.rhs) &amp;&amp; isClassOfSomeInterface(leftType)) {</span>
<span class="line-added">1110                 log.warning(LintCategory.MIGRATION, tree.pos(), Warnings.GetClassComparedWithInterface);</span>
<span class="line-added">1111             }</span>
<span class="line-added">1112         }</span>
<span class="line-added">1113     }</span>
<span class="line-added">1114     //where</span>
<span class="line-added">1115     private boolean isClassOfSomeInterface(Type someClass) {</span>
<span class="line-added">1116         if (someClass.tsym.flatName() == names.java_lang_Class) {</span>
<span class="line-added">1117             List&lt;Type&gt; arguments = someClass.getTypeArguments();</span>
<span class="line-added">1118             if (arguments.length() == 1) {</span>
<span class="line-added">1119                 return arguments.head.isInterface();</span>
<span class="line-added">1120             }</span>
<span class="line-added">1121         }</span>
<span class="line-added">1122         return false;</span>
<span class="line-added">1123     }</span>
<span class="line-added">1124     //where</span>
<span class="line-added">1125     private boolean isInvocationOfGetClass(JCExpression tree) {</span>
<span class="line-added">1126         tree = TreeInfo.skipParens(tree);</span>
<span class="line-added">1127         if (tree.hasTag(APPLY)) {</span>
<span class="line-added">1128             JCMethodInvocation apply = (JCMethodInvocation)tree;</span>
<span class="line-added">1129             MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(apply.meth);</span>
<span class="line-added">1130             return msym.name == names.getClass &amp;&amp; msym.implementedIn(syms.objectType.tsym, types) != null;</span>
<span class="line-added">1131         }</span>
<span class="line-added">1132         return false;</span>
1133     }
1134 
1135     Type checkMethod(final Type mtype,
1136             final Symbol sym,
1137             final Env&lt;AttrContext&gt; env,
1138             final List&lt;JCExpression&gt; argtrees,
1139             final List&lt;Type&gt; argtypes,
1140             final boolean useVarargs,
1141             InferenceContext inferenceContext) {
1142         // System.out.println(&quot;call   : &quot; + env.tree);
1143         // System.out.println(&quot;method : &quot; + owntype);
1144         // System.out.println(&quot;actuals: &quot; + argtypes);
1145         if (inferenceContext.free(mtype)) {
1146             inferenceContext.addFreeTypeListener(List.of(mtype),
1147                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
1148             return mtype;
1149         }
1150         Type owntype = mtype;
1151         List&lt;Type&gt; formals = owntype.getParameterTypes();
1152         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
1153         if (nonInferred.length() != formals.length()) nonInferred = formals;
1154         Type last = useVarargs ? formals.last() : null;
1155         if (sym.name == names.init &amp;&amp; sym.owner == syms.enumSym) {
1156             formals = formals.tail.tail;
1157             nonInferred = nonInferred.tail.tail;
1158         }
1159         if ((sym.flags() &amp; ANONCONSTR_BASED) != 0) {
1160             formals = formals.tail;
1161             nonInferred = nonInferred.tail;
1162         }
1163         List&lt;JCExpression&gt; args = argtrees;
1164         if (args != null) {
1165             //this is null when type-checking a method reference
1166             while (formals.head != last) {
1167                 JCTree arg = args.head;
1168                 Warner warn = convertWarner(arg.pos(), arg.type, nonInferred.head);
1169                 assertConvertible(arg, arg.type, formals.head, warn);
1170                 args = args.tail;
1171                 formals = formals.tail;
1172                 nonInferred = nonInferred.tail;
1173             }
1174             if (useVarargs) {
1175                 Type varArg = types.elemtype(last);
1176                 while (args.tail != null) {
1177                     JCTree arg = args.head;
1178                     Warner warn = convertWarner(arg.pos(), arg.type, varArg);
1179                     assertConvertible(arg, arg.type, varArg, warn);
1180                     args = args.tail;
1181                 }
1182             } else if ((sym.flags() &amp; (VARARGS | SIGNATURE_POLYMORPHIC)) == VARARGS) {
1183                 // non-varargs call to varargs method
1184                 Type varParam = owntype.getParameterTypes().last();
1185                 Type lastArg = argtypes.last();
1186                 if (types.isSubtypeUnchecked(lastArg, types.elemtype(varParam)) &amp;&amp;
1187                     !types.isSameType(types.erasure(varParam), types.erasure(lastArg)))
1188                     log.warning(argtrees.last().pos(),
1189                                 Warnings.InexactNonVarargsCall(types.elemtype(varParam),varParam));
1190             }
1191         }
1192         if (useVarargs) {
1193             Type argtype = owntype.getParameterTypes().last();
1194             if (!types.isReifiable(argtype) &amp;&amp;
1195                 (sym.baseSymbol().attribute(syms.trustMeType.tsym) == null ||
1196                  !isTrustMeAllowedOnMethod(sym))) {
1197                 warnUnchecked(env.tree.pos(), Warnings.UncheckedGenericArrayCreation(argtype));
1198             }
1199             TreeInfo.setVarargsElement(env.tree, types.elemtype(argtype));
1200          }
1201          return owntype;
1202     }
1203     //where
1204     private void assertConvertible(JCTree tree, Type actual, Type formal, Warner warn) {
1205         if (types.isConvertible(actual, formal, warn))
1206             return;
1207 
1208         if (formal.isCompound()
1209             &amp;&amp; types.isSubtype(actual, types.supertype(formal))
1210             &amp;&amp; types.isSubtypeUnchecked(actual, types.interfaces(formal), warn))
1211             return;
1212     }
1213 
1214     /**
1215      * Check that type &#39;t&#39; is a valid instantiation of a generic class
1216      * (see JLS 4.5)
1217      *
1218      * @param t class type to be checked
1219      * @return true if &#39;t&#39; is well-formed
1220      */
1221     public boolean checkValidGenericType(Type t) {
1222         return firstIncompatibleTypeArg(t) == null;
1223     }
1224     //WHERE
1225         private Type firstIncompatibleTypeArg(Type type) {
1226             List&lt;Type&gt; formals = type.tsym.type.allparams();
1227             List&lt;Type&gt; actuals = type.allparams();
1228             List&lt;Type&gt; args = type.getTypeArguments();
1229             List&lt;Type&gt; forms = type.tsym.type.getTypeArguments();
1230             ListBuffer&lt;Type&gt; bounds_buf = new ListBuffer&lt;&gt;();
1231 
1232             // For matching pairs of actual argument types `a&#39; and
1233             // formal type parameters with declared bound `b&#39; ...
1234             while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1235                 // exact type arguments needs to know their
1236                 // bounds (for upper and lower bound
1237                 // calculations).  So we create new bounds where
1238                 // type-parameters are replaced with actuals argument types.
1239                 bounds_buf.append(types.subst(forms.head.getUpperBound(), formals, actuals));
1240                 args = args.tail;
1241                 forms = forms.tail;
1242             }
1243 
1244             args = type.getTypeArguments();
1245             List&lt;Type&gt; tvars_cap = types.substBounds(formals,
1246                                       formals,
1247                                       types.capture(type).allparams());
1248             while (args.nonEmpty() &amp;&amp; tvars_cap.nonEmpty()) {
1249                 // Let the actual arguments know their bound
1250                 args.head.withTypeVar((TypeVar)tvars_cap.head);
1251                 args = args.tail;
1252                 tvars_cap = tvars_cap.tail;
1253             }
1254 
1255             args = type.getTypeArguments();
1256             List&lt;Type&gt; bounds = bounds_buf.toList();
1257 
1258             while (args.nonEmpty() &amp;&amp; bounds.nonEmpty()) {
1259                 Type actual = args.head;
1260                 if (!isTypeArgErroneous(actual) &amp;&amp;
1261                         !bounds.head.isErroneous() &amp;&amp;
1262                         !checkExtends(actual, bounds.head)) {
1263                     return args.head;
1264                 }
1265                 args = args.tail;
1266                 bounds = bounds.tail;
1267             }
1268 
1269             args = type.getTypeArguments();
1270             bounds = bounds_buf.toList();
1271 
1272             for (Type arg : types.capture(type).getTypeArguments()) {
1273                 if (arg.hasTag(TYPEVAR) &amp;&amp;
1274                         arg.getUpperBound().isErroneous() &amp;&amp;
1275                         !bounds.head.isErroneous() &amp;&amp;
1276                         !isTypeArgErroneous(args.head)) {
1277                     return args.head;
1278                 }
1279                 bounds = bounds.tail;
1280                 args = args.tail;
1281             }
1282 
1283             return null;
1284         }
1285         //where
1286         boolean isTypeArgErroneous(Type t) {
1287             return isTypeArgErroneous.visit(t);
1288         }
1289 
1290         Types.UnaryVisitor&lt;Boolean&gt; isTypeArgErroneous = new Types.UnaryVisitor&lt;Boolean&gt;() {
1291             public Boolean visitType(Type t, Void s) {
1292                 return t.isErroneous();
1293             }
1294             @Override
1295             public Boolean visitTypeVar(TypeVar t, Void s) {
1296                 return visit(t.getUpperBound());
1297             }
1298             @Override
1299             public Boolean visitCapturedType(CapturedType t, Void s) {
1300                 return visit(t.getUpperBound()) ||
1301                         visit(t.getLowerBound());
1302             }
1303             @Override
1304             public Boolean visitWildcardType(WildcardType t, Void s) {
1305                 return visit(t.type);
1306             }
1307         };
1308 
1309     /** Check that given modifiers are legal for given symbol and
1310      *  return modifiers together with any implicit modifiers for that symbol.
1311      *  Warning: we can&#39;t use flags() here since this method
1312      *  is called during class enter, when flags() would cause a premature
1313      *  completion.
1314      *  @param pos           Position to be used for error reporting.
1315      *  @param flags         The set of modifiers given in a definition.
1316      *  @param sym           The defined symbol.
1317      */
1318     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1319         long mask;
1320         long implicit = 0;
1321 
1322         switch (sym.kind) {
1323         case VAR:
1324             if (TreeInfo.isReceiverParam(tree))
1325                 mask = ReceiverParamFlags;
1326             else if (sym.owner.kind != TYP)
1327                 mask = LocalVarFlags;
1328             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1329                 mask = implicit = InterfaceVarFlags;
<a name="14" id="anc14"></a><span class="line-modified">1330             else {</span>
1331                 mask = VarFlags;
<a name="15" id="anc15"></a><span class="line-added">1332                 if (types.isValue(sym.owner.type) &amp;&amp; (flags &amp; STATIC) == 0) {</span>
<span class="line-added">1333                     implicit |= FINAL;</span>
<span class="line-added">1334                 }</span>
<span class="line-added">1335             }</span>
1336             break;
1337         case MTH:
1338             if (sym.name == names.init) {
1339                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1340                     // enum constructors cannot be declared public or
1341                     // protected and must be implicitly or explicitly
1342                     // private
1343                     implicit = PRIVATE;
1344                     mask = PRIVATE;
1345                 } else
1346                     mask = ConstructorFlags;
1347             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1348                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1349                     mask = AnnotationTypeElementMask;
1350                     implicit = PUBLIC | ABSTRACT;
1351                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1352                     mask = InterfaceMethodMask;
1353                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1354                     if ((flags &amp; DEFAULT) != 0) {
1355                         implicit |= ABSTRACT;
1356                     }
1357                 } else {
1358                     mask = implicit = InterfaceMethodFlags;
1359                 }
1360             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1361                 mask = RecordMethodFlags;
1362             } else {
<a name="16" id="anc16"></a><span class="line-modified">1363                 // instance methods of value types do not have a monitor associated with their `this&#39;</span>
<span class="line-added">1364                 mask = ((sym.owner.flags_field &amp; VALUE) != 0 &amp;&amp; (flags &amp; Flags.STATIC) == 0) ?</span>
<span class="line-added">1365                         MethodFlags &amp; ~SYNCHRONIZED : MethodFlags;</span>
1366             }
1367             // Imply STRICTFP if owner has STRICTFP set.
1368             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1369                 ((flags) &amp; Flags.DEFAULT) != 0)
1370                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1371             break;
1372         case TYP:
1373             if (sym.isLocal()) {
1374                 boolean implicitlyStatic = !sym.isAnonymous() &amp;&amp;
1375                         ((flags &amp; RECORD) != 0 || (flags &amp; ENUM) != 0 || (flags &amp; INTERFACE) != 0);
1376                 boolean staticOrImplicitlyStatic = (flags &amp; STATIC) != 0 || implicitlyStatic;
1377                 mask = staticOrImplicitlyStatic &amp;&amp; allowRecords ? StaticLocalFlags : LocalClassFlags;
1378                 implicit = implicitlyStatic ? STATIC : implicit;
1379                 if (staticOrImplicitlyStatic) {
1380                     if (sym.owner.kind == TYP) {
1381                         log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1382                     }
1383                 }
1384             } else if (sym.owner.kind == TYP) {
1385                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;
1386                 if (sym.owner.owner.kind == PCK ||
1387                     (sym.owner.flags_field &amp; STATIC) != 0)
1388                     mask |= STATIC;
1389                 else if ((flags &amp; ENUM) != 0 || (flags &amp; RECORD) != 0) {
1390                     log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1391                 }
1392                 // Nested interfaces and enums are always STATIC (Spec ???)
1393                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1394             } else {
1395                 mask = ClassFlags;
1396             }
1397             // Interfaces are always ABSTRACT
1398             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1399 
1400             if ((flags &amp; ENUM) != 0) {
<a name="17" id="anc17"></a><span class="line-modified">1401                 // enums can&#39;t be declared abstract or final or value type</span>
<span class="line-modified">1402                 mask &amp;= ~(ABSTRACT | FINAL | VALUE);</span>
1403                 implicit |= implicitEnumFinalFlag(tree);
1404             }
1405             if ((flags &amp; RECORD) != 0) {
1406                 // records can&#39;t be declared abstract
1407                 mask &amp;= ~ABSTRACT;
1408                 implicit |= FINAL;
1409             }
1410             // Imply STRICTFP if owner has STRICTFP set.
1411             implicit |= sym.owner.flags_field &amp; STRICTFP;
1412             break;
1413         default:
1414             throw new AssertionError();
1415         }
1416         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1417         if (illegal != 0) {
1418             if ((illegal &amp; INTERFACE) != 0) {
1419                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1420                 mask |= INTERFACE;
1421             }
1422             else {
1423                 log.error(pos,
1424                         Errors.ModNotAllowedHere(asFlagSet(illegal)));
1425             }
1426         }
1427         else if ((sym.kind == TYP ||
1428                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1429                   // in the presence of inner classes. Should it be deleted here?
1430                   checkDisjoint(pos, flags,
1431                                 ABSTRACT,
1432                                 PRIVATE | STATIC | DEFAULT))
1433                  &amp;&amp;
1434                  checkDisjoint(pos, flags,
1435                                 STATIC | PRIVATE,
1436                                 DEFAULT)
1437                  &amp;&amp;
1438                  checkDisjoint(pos, flags,
1439                                ABSTRACT | INTERFACE,
<a name="18" id="anc18"></a><span class="line-modified">1440                                FINAL | NATIVE | SYNCHRONIZED | VALUE)</span>
1441                  &amp;&amp;
1442                  checkDisjoint(pos, flags,
1443                                PUBLIC,
1444                                PRIVATE | PROTECTED)
1445                  &amp;&amp;
1446                  checkDisjoint(pos, flags,
1447                                PRIVATE,
1448                                PUBLIC | PROTECTED)
1449                  &amp;&amp;
<a name="19" id="anc19"></a><span class="line-modified">1450                  checkDisjoint(pos, (flags | implicit), // complain against volatile &amp; implcitly final entities too.</span>
1451                                FINAL,
1452                                VOLATILE)
1453                  &amp;&amp;
1454                  (sym.kind == TYP ||
1455                   checkDisjoint(pos, flags,
1456                                 ABSTRACT | NATIVE,
1457                                 STRICTFP))) {
1458             // skip
1459         }
1460         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1461     }
1462 
1463 
1464     /** Determine if this enum should be implicitly final.
1465      *
1466      *  If the enum has no specialized enum constants, it is final.
1467      *
1468      *  If the enum does have specialized enum constants, it is
1469      *  &lt;i&gt;not&lt;/i&gt; final.
1470      */
1471     private long implicitEnumFinalFlag(JCTree tree) {
1472         if (!tree.hasTag(CLASSDEF)) return 0;
1473         class SpecialTreeVisitor extends JCTree.Visitor {
1474             boolean specialized;
1475             SpecialTreeVisitor() {
1476                 this.specialized = false;
1477             }
1478 
1479             @Override
1480             public void visitTree(JCTree tree) { /* no-op */ }
1481 
1482             @Override
1483             public void visitVarDef(JCVariableDecl tree) {
1484                 if ((tree.mods.flags &amp; ENUM) != 0) {
1485                     if (tree.init instanceof JCNewClass &amp;&amp;
1486                         ((JCNewClass) tree.init).def != null) {
1487                         specialized = true;
1488                     }
1489                 }
1490             }
1491         }
1492 
1493         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1494         JCClassDecl cdef = (JCClassDecl) tree;
1495         for (JCTree defs: cdef.defs) {
1496             defs.accept(sts);
1497             if (sts.specialized) return 0;
1498         }
1499         return FINAL;
1500     }
1501 
1502 /* *************************************************************************
1503  * Type Validation
1504  **************************************************************************/
1505 
1506     /** Validate a type expression. That is,
1507      *  check that all type arguments of a parametric type are within
1508      *  their bounds. This must be done in a second phase after type attribution
1509      *  since a class might have a subclass as type parameter bound. E.g:
1510      *
1511      *  &lt;pre&gt;{@code
1512      *  class B&lt;A extends C&gt; { ... }
1513      *  class C extends B&lt;C&gt; { ... }
1514      *  }&lt;/pre&gt;
1515      *
1516      *  and we can&#39;t make sure that the bound is already attributed because
1517      *  of possible cycles.
1518      *
1519      * Visitor method: Validate a type expression, if it is not null, catching
1520      *  and reporting any completion failures.
1521      */
1522     void validate(JCTree tree, Env&lt;AttrContext&gt; env) {
1523         validate(tree, env, true);
1524     }
1525     void validate(JCTree tree, Env&lt;AttrContext&gt; env, boolean checkRaw) {
1526         new Validator(env).validateTree(tree, checkRaw, true);
1527     }
1528 
1529     /** Visitor method: Validate a list of type expressions.
1530      */
1531     void validate(List&lt;? extends JCTree&gt; trees, Env&lt;AttrContext&gt; env) {
1532         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1533             validate(l.head, env);
1534     }
1535 
1536     /** A visitor class for type validation.
1537      */
1538     class Validator extends JCTree.Visitor {
1539 
1540         boolean checkRaw;
1541         boolean isOuter;
1542         Env&lt;AttrContext&gt; env;
1543 
1544         Validator(Env&lt;AttrContext&gt; env) {
1545             this.env = env;
1546         }
1547 
1548         @Override
1549         public void visitTypeArray(JCArrayTypeTree tree) {
1550             validateTree(tree.elemtype, checkRaw, isOuter);
1551         }
1552 
1553         @Override
1554         public void visitTypeApply(JCTypeApply tree) {
1555             if (tree.type.hasTag(CLASS)) {
1556                 List&lt;JCExpression&gt; args = tree.arguments;
1557                 List&lt;Type&gt; forms = tree.type.tsym.type.getTypeArguments();
1558 
1559                 Type incompatibleArg = firstIncompatibleTypeArg(tree.type);
1560                 if (incompatibleArg != null) {
1561                     for (JCTree arg : tree.arguments) {
1562                         if (arg.type == incompatibleArg) {
1563                             log.error(arg, Errors.NotWithinBounds(incompatibleArg, forms.head));
1564                         }
1565                         forms = forms.tail;
1566                      }
1567                  }
1568 
1569                 forms = tree.type.tsym.type.getTypeArguments();
1570 
1571                 boolean is_java_lang_Class = tree.type.tsym.flatName() == names.java_lang_Class;
1572 
1573                 // For matching pairs of actual argument types `a&#39; and
1574                 // formal type parameters with declared bound `b&#39; ...
1575                 while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1576                     validateTree(args.head,
1577                             !(isOuter &amp;&amp; is_java_lang_Class),
1578                             false);
1579                     args = args.tail;
1580                     forms = forms.tail;
1581                 }
1582 
1583                 // Check that this type is either fully parameterized, or
1584                 // not parameterized at all.
1585                 if (tree.type.getEnclosingType().isRaw())
1586                     log.error(tree.pos(), Errors.ImproperlyFormedTypeInnerRawParam);
1587                 if (tree.clazz.hasTag(SELECT))
1588                     visitSelectInternal((JCFieldAccess)tree.clazz);
1589             }
1590         }
1591 
1592         @Override
1593         public void visitTypeParameter(JCTypeParameter tree) {
1594             validateTrees(tree.bounds, true, isOuter);
1595             checkClassBounds(tree.pos(), tree.type);
1596         }
1597 
1598         @Override
1599         public void visitWildcard(JCWildcard tree) {
1600             if (tree.inner != null)
1601                 validateTree(tree.inner, true, isOuter);
1602         }
1603 
1604         @Override
1605         public void visitSelect(JCFieldAccess tree) {
1606             if (tree.type.hasTag(CLASS)) {
1607                 visitSelectInternal(tree);
1608 
1609                 // Check that this type is either fully parameterized, or
1610                 // not parameterized at all.
1611                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1612                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1613             }
1614         }
1615 
1616         public void visitSelectInternal(JCFieldAccess tree) {
1617             if (tree.type.tsym.isStatic() &amp;&amp;
<a name="20" id="anc20"></a><span class="line-modified">1618                 tree.selected.type.isParameterized() &amp;&amp;</span>
<span class="line-added">1619                     (tree.name != names.ref || !tree.type.isReferenceProjection())) {</span>
1620                 // The enclosing type is not a class, so we are
1621                 // looking at a static member type.  However, the
1622                 // qualifying expression is parameterized.
<a name="21" id="anc21"></a><span class="line-added">1623                 // Tolerate the pseudo-select V.ref: V&lt;T&gt;.ref will be static if V&lt;T&gt; is and</span>
<span class="line-added">1624                 // should not be confused as selecting a static member of a parameterized type.</span>
1625                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1626             } else {
1627                 // otherwise validate the rest of the expression
1628                 tree.selected.accept(this);
1629             }
1630         }
1631 
1632         @Override
1633         public void visitAnnotatedType(JCAnnotatedType tree) {
1634             tree.underlyingType.accept(this);
1635         }
1636 
1637         @Override
1638         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1639             if (that.type.hasTag(TypeTag.VOID)) {
1640                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1641             }
1642             super.visitTypeIdent(that);
1643         }
1644 
1645         /** Default visitor method: do nothing.
1646          */
1647         @Override
1648         public void visitTree(JCTree tree) {
1649         }
1650 
1651         public void validateTree(JCTree tree, boolean checkRaw, boolean isOuter) {
1652             if (tree != null) {
1653                 boolean prevCheckRaw = this.checkRaw;
1654                 this.checkRaw = checkRaw;
1655                 this.isOuter = isOuter;
1656 
1657                 try {
1658                     tree.accept(this);
1659                     if (checkRaw)
1660                         checkRaw(tree, env);
1661                 } catch (CompletionFailure ex) {
1662                     completionError(tree.pos(), ex);
1663                 } finally {
1664                     this.checkRaw = prevCheckRaw;
1665                 }
1666             }
1667         }
1668 
1669         public void validateTrees(List&lt;? extends JCTree&gt; trees, boolean checkRaw, boolean isOuter) {
1670             for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1671                 validateTree(l.head, checkRaw, isOuter);
1672         }
1673     }
1674 
1675     void checkRaw(JCTree tree, Env&lt;AttrContext&gt; env) {
1676         if (lint.isEnabled(LintCategory.RAW) &amp;&amp;
1677             tree.type.hasTag(CLASS) &amp;&amp;
1678             !TreeInfo.isDiamond(tree) &amp;&amp;
1679             !withinAnonConstr(env) &amp;&amp;
1680             tree.type.isRaw()) {
1681             log.warning(LintCategory.RAW,
1682                     tree.pos(), Warnings.RawClassUse(tree.type, tree.type.tsym.type));
1683         }
1684     }
1685     //where
1686         private boolean withinAnonConstr(Env&lt;AttrContext&gt; env) {
1687             return env.enclClass.name.isEmpty() &amp;&amp;
1688                     env.enclMethod != null &amp;&amp; env.enclMethod.name == names.init;
1689         }
1690 
1691 /* *************************************************************************
1692  * Exception checking
1693  **************************************************************************/
1694 
1695     /* The following methods treat classes as sets that contain
1696      * the class itself and all their subclasses
1697      */
1698 
1699     /** Is given type a subtype of some of the types in given list?
1700      */
1701     boolean subset(Type t, List&lt;Type&gt; ts) {
1702         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1703             if (types.isSubtype(t, l.head)) return true;
1704         return false;
1705     }
1706 
1707     /** Is given type a subtype or supertype of
1708      *  some of the types in given list?
1709      */
1710     boolean intersects(Type t, List&lt;Type&gt; ts) {
1711         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1712             if (types.isSubtype(t, l.head) || types.isSubtype(l.head, t)) return true;
1713         return false;
1714     }
1715 
1716     /** Add type set to given type list, unless it is a subclass of some class
1717      *  in the list.
1718      */
1719     List&lt;Type&gt; incl(Type t, List&lt;Type&gt; ts) {
1720         return subset(t, ts) ? ts : excl(t, ts).prepend(t);
1721     }
1722 
1723     /** Remove type set from type set list.
1724      */
1725     List&lt;Type&gt; excl(Type t, List&lt;Type&gt; ts) {
1726         if (ts.isEmpty()) {
1727             return ts;
1728         } else {
1729             List&lt;Type&gt; ts1 = excl(t, ts.tail);
1730             if (types.isSubtype(ts.head, t)) return ts1;
1731             else if (ts1 == ts.tail) return ts;
1732             else return ts1.prepend(ts.head);
1733         }
1734     }
1735 
1736     /** Form the union of two type set lists.
1737      */
1738     List&lt;Type&gt; union(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1739         List&lt;Type&gt; ts = ts1;
1740         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1741             ts = incl(l.head, ts);
1742         return ts;
1743     }
1744 
1745     /** Form the difference of two type lists.
1746      */
1747     List&lt;Type&gt; diff(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1748         List&lt;Type&gt; ts = ts1;
1749         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1750             ts = excl(l.head, ts);
1751         return ts;
1752     }
1753 
1754     /** Form the intersection of two type lists.
1755      */
1756     public List&lt;Type&gt; intersect(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1757         List&lt;Type&gt; ts = List.nil();
1758         for (List&lt;Type&gt; l = ts1; l.nonEmpty(); l = l.tail)
1759             if (subset(l.head, ts2)) ts = incl(l.head, ts);
1760         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1761             if (subset(l.head, ts1)) ts = incl(l.head, ts);
1762         return ts;
1763     }
1764 
1765     /** Is exc an exception symbol that need not be declared?
1766      */
1767     boolean isUnchecked(ClassSymbol exc) {
1768         return
1769             exc.kind == ERR ||
1770             exc.isSubClass(syms.errorType.tsym, types) ||
1771             exc.isSubClass(syms.runtimeExceptionType.tsym, types);
1772     }
1773 
1774     /** Is exc an exception type that need not be declared?
1775      */
1776     boolean isUnchecked(Type exc) {
1777         return
1778             (exc.hasTag(TYPEVAR)) ? isUnchecked(types.supertype(exc)) :
1779             (exc.hasTag(CLASS)) ? isUnchecked((ClassSymbol)exc.tsym) :
1780             exc.hasTag(BOT);
1781     }
1782 
1783     boolean isChecked(Type exc) {
1784         return !isUnchecked(exc);
1785     }
1786 
1787     /** Same, but handling completion failures.
1788      */
1789     boolean isUnchecked(DiagnosticPosition pos, Type exc) {
1790         try {
1791             return isUnchecked(exc);
1792         } catch (CompletionFailure ex) {
1793             completionError(pos, ex);
1794             return true;
1795         }
1796     }
1797 
1798     /** Is exc handled by given exception list?
1799      */
1800     boolean isHandled(Type exc, List&lt;Type&gt; handled) {
1801         return isUnchecked(exc) || subset(exc, handled);
1802     }
1803 
1804     /** Return all exceptions in thrown list that are not in handled list.
1805      *  @param thrown     The list of thrown exceptions.
1806      *  @param handled    The list of handled exceptions.
1807      */
1808     List&lt;Type&gt; unhandled(List&lt;Type&gt; thrown, List&lt;Type&gt; handled) {
1809         List&lt;Type&gt; unhandled = List.nil();
1810         for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1811             if (!isHandled(l.head, handled)) unhandled = unhandled.prepend(l.head);
1812         return unhandled;
1813     }
1814 
1815 /* *************************************************************************
1816  * Overriding/Implementation checking
1817  **************************************************************************/
1818 
1819     /** The level of access protection given by a flag set,
1820      *  where PRIVATE is highest and PUBLIC is lowest.
1821      */
1822     static int protection(long flags) {
1823         switch ((short)(flags &amp; AccessFlags)) {
1824         case PRIVATE: return 3;
1825         case PROTECTED: return 1;
1826         default:
1827         case PUBLIC: return 0;
1828         case 0: return 2;
1829         }
1830     }
1831 
1832     /** A customized &quot;cannot override&quot; error message.
1833      *  @param m      The overriding method.
1834      *  @param other  The overridden method.
1835      *  @return       An internationalized string.
1836      */
1837     Fragment cannotOverride(MethodSymbol m, MethodSymbol other) {
1838         Symbol mloc = m.location();
1839         Symbol oloc = other.location();
1840 
1841         if ((other.owner.flags() &amp; INTERFACE) == 0)
1842             return Fragments.CantOverride(m, mloc, other, oloc);
1843         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1844             return Fragments.CantImplement(m, mloc, other, oloc);
1845         else
1846             return Fragments.ClashesWith(m, mloc, other, oloc);
1847     }
1848 
1849     /** A customized &quot;override&quot; warning message.
1850      *  @param m      The overriding method.
1851      *  @param other  The overridden method.
1852      *  @return       An internationalized string.
1853      */
1854     Fragment uncheckedOverrides(MethodSymbol m, MethodSymbol other) {
1855         Symbol mloc = m.location();
1856         Symbol oloc = other.location();
1857 
1858         if ((other.owner.flags() &amp; INTERFACE) == 0)
1859             return Fragments.UncheckedOverride(m, mloc, other, oloc);
1860         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1861             return Fragments.UncheckedImplement(m, mloc, other, oloc);
1862         else
1863             return Fragments.UncheckedClashWith(m, mloc, other, oloc);
1864     }
1865 
1866     /** A customized &quot;override&quot; warning message.
1867      *  @param m      The overriding method.
1868      *  @param other  The overridden method.
1869      *  @return       An internationalized string.
1870      */
1871     Fragment varargsOverrides(MethodSymbol m, MethodSymbol other) {
1872         Symbol mloc = m.location();
1873         Symbol oloc = other.location();
1874 
1875         if ((other.owner.flags() &amp; INTERFACE) == 0)
1876             return Fragments.VarargsOverride(m, mloc, other, oloc);
1877         else  if ((m.owner.flags() &amp; INTERFACE) == 0)
1878             return Fragments.VarargsImplement(m, mloc, other, oloc);
1879         else
1880             return Fragments.VarargsClashWith(m, mloc, other, oloc);
1881     }
1882 
1883     /** Check that this method conforms with overridden method &#39;other&#39;.
1884      *  where `origin&#39; is the class where checking started.
1885      *  Complications:
1886      *  (1) Do not check overriding of synthetic methods
1887      *      (reason: they might be final).
1888      *      todo: check whether this is still necessary.
1889      *  (2) Admit the case where an interface proxy throws fewer exceptions
1890      *      than the method it implements. Augment the proxy methods with the
1891      *      undeclared exceptions in this case.
1892      *  (3) When generics are enabled, admit the case where an interface proxy
1893      *      has a result type
1894      *      extended by the result type of the method it implements.
1895      *      Change the proxies result type to the smaller type in this case.
1896      *
1897      *  @param tree         The tree from which positions
1898      *                      are extracted for errors.
1899      *  @param m            The overriding method.
1900      *  @param other        The overridden method.
1901      *  @param origin       The class of which the overriding method
1902      *                      is a member.
1903      */
1904     void checkOverride(JCTree tree,
1905                        MethodSymbol m,
1906                        MethodSymbol other,
1907                        ClassSymbol origin) {
1908         // Don&#39;t check overriding of synthetic methods or by bridge methods.
1909         if ((m.flags() &amp; (SYNTHETIC|BRIDGE)) != 0 || (other.flags() &amp; SYNTHETIC) != 0) {
1910             return;
1911         }
1912 
1913         // Error if static method overrides instance method (JLS 8.4.6.2).
1914         if ((m.flags() &amp; STATIC) != 0 &amp;&amp;
1915                    (other.flags() &amp; STATIC) == 0) {
1916             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1917                       Errors.OverrideStatic(cannotOverride(m, other)));
1918             m.flags_field |= BAD_OVERRIDE;
1919             return;
1920         }
1921 
1922         // Error if instance method overrides static or final
1923         // method (JLS 8.4.6.1).
1924         if ((other.flags() &amp; FINAL) != 0 ||
1925                  (m.flags() &amp; STATIC) == 0 &amp;&amp;
1926                  (other.flags() &amp; STATIC) != 0) {
1927             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1928                       Errors.OverrideMeth(cannotOverride(m, other),
1929                                           asFlagSet(other.flags() &amp; (FINAL | STATIC))));
1930             m.flags_field |= BAD_OVERRIDE;
1931             return;
1932         }
1933 
1934         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1935             // handled in validateAnnotationMethod
1936             return;
1937         }
1938 
1939         // Error if overriding method has weaker access (JLS 8.4.6.3).
1940         if (protection(m.flags()) &gt; protection(other.flags())) {
1941             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1942                       (other.flags() &amp; AccessFlags) == 0 ?
1943                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1944                                                           &quot;package&quot;) :
1945                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1946                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1947             m.flags_field |= BAD_OVERRIDE;
1948             return;
1949         }
1950 
<a name="22" id="anc22"></a><span class="line-added">1951         if (origin.isValue() &amp;&amp; other.owner == syms.objectType.tsym &amp;&amp; m.type.getParameterTypes().size() == 0) {</span>
<span class="line-added">1952             if (m.name == names.clone || m.name == names.finalize) {</span>
<span class="line-added">1953                 log.error(TreeInfo.diagnosticPositionFor(m, tree),</span>
<span class="line-added">1954                         Errors.InlineClassMayNotOverride(m.name));</span>
<span class="line-added">1955                 m.flags_field |= BAD_OVERRIDE;</span>
<span class="line-added">1956                 return;</span>
<span class="line-added">1957             }</span>
<span class="line-added">1958         }</span>
<span class="line-added">1959 </span>
1960         Type mt = types.memberType(origin.type, m);
1961         Type ot = types.memberType(origin.type, other);
1962         // Error if overriding result type is different
1963         // (or, in the case of generics mode, not a subtype) of
1964         // overridden result type. We have to rename any type parameters
1965         // before comparing types.
1966         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1967         List&lt;Type&gt; otvars = ot.getTypeArguments();
1968         Type mtres = mt.getReturnType();
1969         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1970 
1971         overrideWarner.clear();
1972         boolean resultTypesOK =
1973             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1974         if (!resultTypesOK) {
1975             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1976                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1977                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1978                                         other.location()), mtres, otres));
1979                 m.flags_field |= BAD_OVERRIDE;
1980             } else {
1981                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1982                           Errors.OverrideIncompatibleRet(cannotOverride(m, other), mtres, otres));
1983                 m.flags_field |= BAD_OVERRIDE;
1984             }
1985             return;
1986         } else if (overrideWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
1987             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
1988                     Warnings.OverrideUncheckedRet(uncheckedOverrides(m, other), mtres, otres));
1989         }
1990 
1991         // Error if overriding method throws an exception not reported
1992         // by overridden method.
1993         List&lt;Type&gt; otthrown = types.subst(ot.getThrownTypes(), otvars, mtvars);
1994         List&lt;Type&gt; unhandledErased = unhandled(mt.getThrownTypes(), types.erasure(otthrown));
1995         List&lt;Type&gt; unhandledUnerased = unhandled(mt.getThrownTypes(), otthrown);
1996         if (unhandledErased.nonEmpty()) {
1997             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1998                       Errors.OverrideMethDoesntThrow(cannotOverride(m, other), unhandledUnerased.head));
1999             m.flags_field |= BAD_OVERRIDE;
2000             return;
2001         }
2002         else if (unhandledUnerased.nonEmpty()) {
2003             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
2004                           Warnings.OverrideUncheckedThrown(cannotOverride(m, other), unhandledUnerased.head));
2005             return;
2006         }
2007 
2008         // Optional warning if varargs don&#39;t agree
2009         if ((((m.flags() ^ other.flags()) &amp; Flags.VARARGS) != 0)
2010             &amp;&amp; lint.isEnabled(LintCategory.OVERRIDES)) {
2011             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
2012                         ((m.flags() &amp; Flags.VARARGS) != 0)
2013                         ? Warnings.OverrideVarargsMissing(varargsOverrides(m, other))
2014                         : Warnings.OverrideVarargsExtra(varargsOverrides(m, other)));
2015         }
2016 
2017         // Warn if instance method overrides bridge method (compiler spec ??)
2018         if ((other.flags() &amp; BRIDGE) != 0) {
2019             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
2020                         Warnings.OverrideBridge(uncheckedOverrides(m, other)));
2021         }
2022 
2023         // Warn if a deprecated method overridden by a non-deprecated one.
2024         if (!isDeprecatedOverrideIgnorable(other, origin)) {
2025             Lint prevLint = setLint(lint.augment(m));
2026             try {
2027                 checkDeprecated(() -&gt; TreeInfo.diagnosticPositionFor(m, tree), m, other);
2028             } finally {
2029                 setLint(prevLint);
2030             }
2031         }
2032     }
2033     // where
2034         private boolean isDeprecatedOverrideIgnorable(MethodSymbol m, ClassSymbol origin) {
2035             // If the method, m, is defined in an interface, then ignore the issue if the method
2036             // is only inherited via a supertype and also implemented in the supertype,
2037             // because in that case, we will rediscover the issue when examining the method
2038             // in the supertype.
2039             // If the method, m, is not defined in an interface, then the only time we need to
2040             // address the issue is when the method is the supertype implementation: any other
2041             // case, we will have dealt with when examining the supertype classes
2042             ClassSymbol mc = m.enclClass();
2043             Type st = types.supertype(origin.type);
2044             if (!st.hasTag(CLASS))
2045                 return true;
2046             MethodSymbol stimpl = m.implementation((ClassSymbol)st.tsym, types, false);
2047 
2048             if (mc != null &amp;&amp; ((mc.flags() &amp; INTERFACE) != 0)) {
2049                 List&lt;Type&gt; intfs = types.interfaces(origin.type);
2050                 return (intfs.contains(mc.type) ? false : (stimpl != null));
2051             }
2052             else
2053                 return (stimpl != m);
2054         }
2055 
2056 
2057     // used to check if there were any unchecked conversions
2058     Warner overrideWarner = new Warner();
2059 
2060     /** Check that a class does not inherit two concrete methods
2061      *  with the same signature.
2062      *  @param pos          Position to be used for error reporting.
2063      *  @param site         The class type to be checked.
2064      */
2065     public void checkCompatibleConcretes(DiagnosticPosition pos, Type site) {
2066         Type sup = types.supertype(site);
2067         if (!sup.hasTag(CLASS)) return;
2068 
2069         for (Type t1 = sup;
2070              t1.hasTag(CLASS) &amp;&amp; t1.tsym.type.isParameterized();
2071              t1 = types.supertype(t1)) {
2072             for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2073                 if (s1.kind != MTH ||
2074                     (s1.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
2075                     !s1.isInheritedIn(site.tsym, types) ||
2076                     ((MethodSymbol)s1).implementation(site.tsym,
2077                                                       types,
2078                                                       true) != s1)
2079                     continue;
2080                 Type st1 = types.memberType(t1, s1);
2081                 int s1ArgsLength = st1.getParameterTypes().length();
2082                 if (st1 == s1.type) continue;
2083 
2084                 for (Type t2 = sup;
2085                      t2.hasTag(CLASS);
2086                      t2 = types.supertype(t2)) {
2087                     for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2088                         if (s2 == s1 ||
2089                             s2.kind != MTH ||
2090                             (s2.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
2091                             s2.type.getParameterTypes().length() != s1ArgsLength ||
2092                             !s2.isInheritedIn(site.tsym, types) ||
2093                             ((MethodSymbol)s2).implementation(site.tsym,
2094                                                               types,
2095                                                               true) != s2)
2096                             continue;
2097                         Type st2 = types.memberType(t2, s2);
2098                         if (types.overrideEquivalent(st1, st2))
2099                             log.error(pos,
2100                                       Errors.ConcreteInheritanceConflict(s1, t1, s2, t2, sup));
2101                     }
2102                 }
2103             }
2104         }
2105     }
2106 
2107     /** Check that classes (or interfaces) do not each define an abstract
2108      *  method with same name and arguments but incompatible return types.
2109      *  @param pos          Position to be used for error reporting.
2110      *  @param t1           The first argument type.
2111      *  @param t2           The second argument type.
2112      */
2113     public boolean checkCompatibleAbstracts(DiagnosticPosition pos,
2114                                             Type t1,
2115                                             Type t2,
2116                                             Type site) {
2117         if ((site.tsym.flags() &amp; COMPOUND) != 0) {
2118             // special case for intersections: need to eliminate wildcards in supertypes
2119             t1 = types.capture(t1);
2120             t2 = types.capture(t2);
2121         }
2122         return firstIncompatibility(pos, t1, t2, site) == null;
2123     }
2124 
2125     /** Return the first method which is defined with same args
2126      *  but different return types in two given interfaces, or null if none
2127      *  exists.
2128      *  @param t1     The first type.
2129      *  @param t2     The second type.
2130      *  @param site   The most derived type.
2131      *  @return symbol from t2 that conflicts with one in t1.
2132      */
2133     private Symbol firstIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2134         Map&lt;TypeSymbol,Type&gt; interfaces1 = new HashMap&lt;&gt;();
2135         closure(t1, interfaces1);
2136         Map&lt;TypeSymbol,Type&gt; interfaces2;
2137         if (t1 == t2)
2138             interfaces2 = interfaces1;
2139         else
2140             closure(t2, interfaces1, interfaces2 = new HashMap&lt;&gt;());
2141 
2142         for (Type t3 : interfaces1.values()) {
2143             for (Type t4 : interfaces2.values()) {
2144                 Symbol s = firstDirectIncompatibility(pos, t3, t4, site);
2145                 if (s != null) return s;
2146             }
2147         }
2148         return null;
2149     }
2150 
2151     /** Compute all the supertypes of t, indexed by type symbol. */
2152     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typeMap) {
2153         if (!t.hasTag(CLASS)) return;
2154         if (typeMap.put(t.tsym, t) == null) {
2155             closure(types.supertype(t), typeMap);
2156             for (Type i : types.interfaces(t))
2157                 closure(i, typeMap);
2158         }
2159     }
2160 
2161     /** Compute all the supertypes of t, indexed by type symbol (except those in typesSkip). */
2162     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typesSkip, Map&lt;TypeSymbol,Type&gt; typeMap) {
2163         if (!t.hasTag(CLASS)) return;
2164         if (typesSkip.get(t.tsym) != null) return;
2165         if (typeMap.put(t.tsym, t) == null) {
2166             closure(types.supertype(t), typesSkip, typeMap);
2167             for (Type i : types.interfaces(t))
2168                 closure(i, typesSkip, typeMap);
2169         }
2170     }
2171 
2172     /** Return the first method in t2 that conflicts with a method from t1. */
2173     private Symbol firstDirectIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2174         for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2175             Type st1 = null;
2176             if (s1.kind != MTH || !s1.isInheritedIn(site.tsym, types) ||
2177                     (s1.flags() &amp; SYNTHETIC) != 0) continue;
2178             Symbol impl = ((MethodSymbol)s1).implementation(site.tsym, types, false);
2179             if (impl != null &amp;&amp; (impl.flags() &amp; ABSTRACT) == 0) continue;
2180             for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2181                 if (s1 == s2) continue;
2182                 if (s2.kind != MTH || !s2.isInheritedIn(site.tsym, types) ||
2183                         (s2.flags() &amp; SYNTHETIC) != 0) continue;
2184                 if (st1 == null) st1 = types.memberType(t1, s1);
2185                 Type st2 = types.memberType(t2, s2);
2186                 if (types.overrideEquivalent(st1, st2)) {
2187                     List&lt;Type&gt; tvars1 = st1.getTypeArguments();
2188                     List&lt;Type&gt; tvars2 = st2.getTypeArguments();
2189                     Type rt1 = st1.getReturnType();
2190                     Type rt2 = types.subst(st2.getReturnType(), tvars2, tvars1);
2191                     boolean compat =
2192                         types.isSameType(rt1, rt2) ||
2193                         !rt1.isPrimitiveOrVoid() &amp;&amp;
2194                         !rt2.isPrimitiveOrVoid() &amp;&amp;
2195                         (types.covariantReturnType(rt1, rt2, types.noWarnings) ||
2196                          types.covariantReturnType(rt2, rt1, types.noWarnings)) ||
2197                          checkCommonOverriderIn(s1,s2,site);
2198                     if (!compat) {
2199                         log.error(pos, Errors.TypesIncompatible(t1, t2,
2200                                 Fragments.IncompatibleDiffRet(s2.name, types.memberType(t2, s2).getParameterTypes())));
2201                         return s2;
2202                     }
2203                 } else if (checkNameClash((ClassSymbol)site.tsym, s1, s2) &amp;&amp;
2204                         !checkCommonOverriderIn(s1, s2, site)) {
2205                     log.error(pos, Errors.NameClashSameErasureNoOverride(
2206                             s1.name, types.memberType(site, s1).asMethodType().getParameterTypes(), s1.location(),
2207                             s2.name, types.memberType(site, s2).asMethodType().getParameterTypes(), s2.location()));
2208                     return s2;
2209                 }
2210             }
2211         }
2212         return null;
2213     }
2214     //WHERE
2215     boolean checkCommonOverriderIn(Symbol s1, Symbol s2, Type site) {
2216         Map&lt;TypeSymbol,Type&gt; supertypes = new HashMap&lt;&gt;();
2217         Type st1 = types.memberType(site, s1);
2218         Type st2 = types.memberType(site, s2);
2219         closure(site, supertypes);
2220         for (Type t : supertypes.values()) {
2221             for (Symbol s3 : t.tsym.members().getSymbolsByName(s1.name)) {
2222                 if (s3 == s1 || s3 == s2 || s3.kind != MTH || (s3.flags() &amp; (BRIDGE|SYNTHETIC)) != 0) continue;
2223                 Type st3 = types.memberType(site,s3);
2224                 if (types.overrideEquivalent(st3, st1) &amp;&amp;
2225                         types.overrideEquivalent(st3, st2) &amp;&amp;
2226                         types.returnTypeSubstitutable(st3, st1) &amp;&amp;
2227                         types.returnTypeSubstitutable(st3, st2)) {
2228                     return true;
2229                 }
2230             }
2231         }
2232         return false;
2233     }
2234 
2235     /** Check that a given method conforms with any method it overrides.
2236      *  @param tree         The tree from which positions are extracted
2237      *                      for errors.
2238      *  @param m            The overriding method.
2239      */
2240     void checkOverride(Env&lt;AttrContext&gt; env, JCMethodDecl tree, MethodSymbol m) {
2241         ClassSymbol origin = (ClassSymbol)m.owner;
2242         if ((origin.flags() &amp; ENUM) != 0 &amp;&amp; names.finalize.equals(m.name)) {
2243             if (m.overrides(syms.enumFinalFinalize, origin, types, false)) {
2244                 log.error(tree.pos(), Errors.EnumNoFinalize);
2245                 return;
2246             }
2247         }
2248         if (allowRecords &amp;&amp; origin.isRecord()) {
2249             // let&#39;s find out if this is a user defined accessor in which case the @Override annotation is acceptable
2250             Optional&lt;? extends RecordComponent&gt; recordComponent = origin.getRecordComponents().stream()
2251                     .filter(rc -&gt; rc.accessor == tree.sym &amp;&amp; (rc.accessor.flags_field &amp; GENERATED_MEMBER) == 0).findFirst();
2252             if (recordComponent.isPresent()) {
2253                 return;
2254             }
2255         }
2256 
2257         for (Type t = origin.type; t.hasTag(CLASS);
2258              t = types.supertype(t)) {
2259             if (t != origin.type) {
2260                 checkOverride(tree, t, origin, m);
2261             }
2262             for (Type t2 : types.interfaces(t)) {
2263                 checkOverride(tree, t2, origin, m);
2264             }
2265         }
2266 
2267         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2268         // Check if this method must override a super method due to being annotated with @Override
2269         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2270         // be treated &quot;as if as they were annotated&quot; with @Override.
2271         boolean mustOverride = explicitOverride ||
<a name="23" id="anc23"></a><span class="line-modified">2272                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate() &amp;&amp;</span>
<span class="line-added">2273                         (!m.owner.isValue() || (tree.body.flags &amp; SYNTHETIC) == 0));</span>
2274         if (mustOverride &amp;&amp; !isOverrider(m)) {
2275             DiagnosticPosition pos = tree.pos();
2276             for (JCAnnotation a : tree.getModifiers().annotations) {
2277                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2278                     pos = a.pos();
2279                     break;
2280                 }
2281             }
2282             log.error(pos,
2283                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2284                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2285         }
2286     }
2287 
2288     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2289         TypeSymbol c = site.tsym;
2290         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2291             if (m.overrides(sym, origin, types, false)) {
2292                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2293                     checkOverride(tree, m, (MethodSymbol)sym, origin);
2294                 }
2295             }
2296         }
2297     }
2298 
2299     private Filter&lt;Symbol&gt; equalsHasCodeFilter = s -&gt; MethodSymbol.implementation_filter.accepts(s) &amp;&amp;
2300             (s.flags() &amp; BAD_OVERRIDE) == 0;
2301 
2302     public void checkClassOverrideEqualsAndHashIfNeeded(DiagnosticPosition pos,
2303             ClassSymbol someClass) {
2304         /* At present, annotations cannot possibly have a method that is override
2305          * equivalent with Object.equals(Object) but in any case the condition is
2306          * fine for completeness.
2307          */
2308         if (someClass == (ClassSymbol)syms.objectType.tsym ||
2309             someClass.isInterface() || someClass.isEnum() ||
2310             (someClass.flags() &amp; ANNOTATION) != 0 ||
2311             (someClass.flags() &amp; ABSTRACT) != 0) return;
2312         //anonymous inner classes implementing interfaces need especial treatment
2313         if (someClass.isAnonymous()) {
2314             List&lt;Type&gt; interfaces =  types.interfaces(someClass.type);
2315             if (interfaces != null &amp;&amp; !interfaces.isEmpty() &amp;&amp;
2316                 interfaces.head.tsym == syms.comparatorType.tsym) return;
2317         }
2318         checkClassOverrideEqualsAndHash(pos, someClass);
2319     }
2320 
2321     private void checkClassOverrideEqualsAndHash(DiagnosticPosition pos,
2322             ClassSymbol someClass) {
2323         if (lint.isEnabled(LintCategory.OVERRIDES)) {
2324             MethodSymbol equalsAtObject = (MethodSymbol)syms.objectType
2325                     .tsym.members().findFirst(names.equals);
2326             MethodSymbol hashCodeAtObject = (MethodSymbol)syms.objectType
2327                     .tsym.members().findFirst(names.hashCode);
2328             MethodSymbol equalsImpl = types.implementation(equalsAtObject,
2329                     someClass, false, equalsHasCodeFilter);
2330             boolean overridesEquals = equalsImpl != null &amp;&amp;
2331                                       equalsImpl.owner == someClass;
2332             boolean overridesHashCode = types.implementation(hashCodeAtObject,
2333                 someClass, false, equalsHasCodeFilter) != hashCodeAtObject;
2334 
2335             if (overridesEquals &amp;&amp; !overridesHashCode) {
2336                 log.warning(LintCategory.OVERRIDES, pos,
2337                             Warnings.OverrideEqualsButNotHashcode(someClass));
2338             }
2339         }
2340     }
2341 
2342     public void checkModuleName (JCModuleDecl tree) {
2343         Name moduleName = tree.sym.name;
2344         Assert.checkNonNull(moduleName);
2345         if (lint.isEnabled(LintCategory.MODULE)) {
2346             JCExpression qualId = tree.qualId;
2347             while (qualId != null) {
2348                 Name componentName;
2349                 DiagnosticPosition pos;
2350                 switch (qualId.getTag()) {
2351                     case SELECT:
2352                         JCFieldAccess selectNode = ((JCFieldAccess) qualId);
2353                         componentName = selectNode.name;
2354                         pos = selectNode.pos();
2355                         qualId = selectNode.selected;
2356                         break;
2357                     case IDENT:
2358                         componentName = ((JCIdent) qualId).name;
2359                         pos = qualId.pos();
2360                         qualId = null;
2361                         break;
2362                     default:
2363                         throw new AssertionError(&quot;Unexpected qualified identifier: &quot; + qualId.toString());
2364                 }
2365                 if (componentName != null) {
2366                     String moduleNameComponentString = componentName.toString();
2367                     int nameLength = moduleNameComponentString.length();
2368                     if (nameLength &gt; 0 &amp;&amp; Character.isDigit(moduleNameComponentString.charAt(nameLength - 1))) {
2369                         log.warning(Lint.LintCategory.MODULE, pos, Warnings.PoorChoiceForModuleName(componentName));
2370                     }
2371                 }
2372             }
2373         }
2374     }
2375 
2376     private boolean checkNameClash(ClassSymbol origin, Symbol s1, Symbol s2) {
2377         ClashFilter cf = new ClashFilter(origin.type);
2378         return (cf.accepts(s1) &amp;&amp;
2379                 cf.accepts(s2) &amp;&amp;
2380                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2381     }
2382 
2383 
2384     /** Check that all abstract members of given class have definitions.
2385      *  @param pos          Position to be used for error reporting.
2386      *  @param c            The class.
2387      */
2388     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2389         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2390         if (undef != null) {
2391             MethodSymbol undef1 =
2392                 new MethodSymbol(undef.flags(), undef.name,
2393                                  types.memberType(c.type, undef), undef.owner);
2394             log.error(pos,
2395                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2396         }
2397     }
2398 
<a name="24" id="anc24"></a><span class="line-added">2399     // A value class cannot contain a field of its own type either or indirectly.</span>
<span class="line-added">2400     void checkNonCyclicMembership(JCClassDecl tree) {</span>
<span class="line-added">2401         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);</span>
<span class="line-added">2402         try {</span>
<span class="line-added">2403             tree.sym.flags_field |= LOCKED;</span>
<span class="line-added">2404             for (List&lt;? extends JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {</span>
<span class="line-added">2405                 if (l.head.hasTag(VARDEF)) {</span>
<span class="line-added">2406                     JCVariableDecl field = (JCVariableDecl) l.head;</span>
<span class="line-added">2407                     if (cyclePossible(field.sym)) {</span>
<span class="line-added">2408                         Type fieldType = field.sym.type;</span>
<span class="line-added">2409                         checkNonCyclicMembership((ClassSymbol) fieldType.tsym, field.pos());</span>
<span class="line-added">2410                     }</span>
<span class="line-added">2411                 }</span>
<span class="line-added">2412             }</span>
<span class="line-added">2413         } finally {</span>
<span class="line-added">2414             tree.sym.flags_field &amp;= ~LOCKED;</span>
<span class="line-added">2415         }</span>
<span class="line-added">2416 </span>
<span class="line-added">2417     }</span>
<span class="line-added">2418     // where</span>
<span class="line-added">2419     private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {</span>
<span class="line-added">2420         if ((c.flags_field &amp; LOCKED) != 0) {</span>
<span class="line-added">2421             log.error(pos, Errors.CyclicValueTypeMembership(c));</span>
<span class="line-added">2422             return;</span>
<span class="line-added">2423         }</span>
<span class="line-added">2424         try {</span>
<span class="line-added">2425             c.flags_field |= LOCKED;</span>
<span class="line-added">2426             for (Symbol fld : c.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; cyclePossible((VarSymbol) s), NON_RECURSIVE)) {</span>
<span class="line-added">2427                 checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);</span>
<span class="line-added">2428             }</span>
<span class="line-added">2429         } finally {</span>
<span class="line-added">2430             c.flags_field &amp;= ~LOCKED;</span>
<span class="line-added">2431         }</span>
<span class="line-added">2432     }</span>
<span class="line-added">2433         // where</span>
<span class="line-added">2434         private boolean cyclePossible(VarSymbol symbol) {</span>
<span class="line-added">2435             return (symbol.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(symbol.type);</span>
<span class="line-added">2436         }</span>
<span class="line-added">2437 </span>
2438     void checkNonCyclicDecl(JCClassDecl tree) {
2439         CycleChecker cc = new CycleChecker();
2440         cc.scan(tree);
2441         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2442             tree.sym.flags_field |= ACYCLIC;
2443         }
2444     }
2445 
2446     class CycleChecker extends TreeScanner {
2447 
2448         List&lt;Symbol&gt; seenClasses = List.nil();
2449         boolean errorFound = false;
2450         boolean partialCheck = false;
2451 
2452         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2453             if (sym != null &amp;&amp; sym.kind == TYP) {
2454                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2455                 if (classEnv != null) {
2456                     DiagnosticSource prevSource = log.currentSource();
2457                     try {
2458                         log.useSource(classEnv.toplevel.sourcefile);
2459                         scan(classEnv.tree);
2460                     }
2461                     finally {
2462                         log.useSource(prevSource.getFile());
2463                     }
2464                 } else if (sym.kind == TYP) {
2465                     checkClass(pos, sym, List.nil());
2466                 }
2467             } else {
2468                 //not completed yet
2469                 partialCheck = true;
2470             }
2471         }
2472 
2473         @Override
2474         public void visitSelect(JCFieldAccess tree) {
2475             super.visitSelect(tree);
2476             checkSymbol(tree.pos(), tree.sym);
2477         }
2478 
2479         @Override
2480         public void visitIdent(JCIdent tree) {
2481             checkSymbol(tree.pos(), tree.sym);
2482         }
2483 
2484         @Override
2485         public void visitTypeApply(JCTypeApply tree) {
2486             scan(tree.clazz);
2487         }
2488 
2489         @Override
2490         public void visitTypeArray(JCArrayTypeTree tree) {
2491             scan(tree.elemtype);
2492         }
2493 
2494         @Override
2495         public void visitClassDef(JCClassDecl tree) {
2496             List&lt;JCTree&gt; supertypes = List.nil();
2497             if (tree.getExtendsClause() != null) {
2498                 supertypes = supertypes.prepend(tree.getExtendsClause());
2499             }
2500             if (tree.getImplementsClause() != null) {
2501                 for (JCTree intf : tree.getImplementsClause()) {
2502                     supertypes = supertypes.prepend(intf);
2503                 }
2504             }
2505             checkClass(tree.pos(), tree.sym, supertypes);
2506         }
2507 
2508         void checkClass(DiagnosticPosition pos, Symbol c, List&lt;JCTree&gt; supertypes) {
2509             if ((c.flags_field &amp; ACYCLIC) != 0)
2510                 return;
2511             if (seenClasses.contains(c)) {
2512                 errorFound = true;
2513                 noteCyclic(pos, (ClassSymbol)c);
2514             } else if (!c.type.isErroneous()) {
2515                 try {
2516                     seenClasses = seenClasses.prepend(c);
2517                     if (c.type.hasTag(CLASS)) {
2518                         if (supertypes.nonEmpty()) {
2519                             scan(supertypes);
2520                         }
2521                         else {
2522                             ClassType ct = (ClassType)c.type;
2523                             if (ct.supertype_field == null ||
2524                                     ct.interfaces_field == null) {
2525                                 //not completed yet
2526                                 partialCheck = true;
2527                                 return;
2528                             }
2529                             checkSymbol(pos, ct.supertype_field.tsym);
2530                             for (Type intf : ct.interfaces_field) {
2531                                 checkSymbol(pos, intf.tsym);
2532                             }
2533                         }
2534                         if (c.owner.kind == TYP) {
2535                             checkSymbol(pos, c.owner);
2536                         }
2537                     }
2538                 } finally {
2539                     seenClasses = seenClasses.tail;
2540                 }
2541             }
2542         }
2543     }
2544 
2545     /** Check for cyclic references. Issue an error if the
2546      *  symbol of the type referred to has a LOCKED flag set.
2547      *
2548      *  @param pos      Position to be used for error reporting.
2549      *  @param t        The type referred to.
2550      */
2551     void checkNonCyclic(DiagnosticPosition pos, Type t) {
2552         checkNonCyclicInternal(pos, t);
2553     }
2554 
2555 
2556     void checkNonCyclic(DiagnosticPosition pos, TypeVar t) {
2557         checkNonCyclic1(pos, t, List.nil());
2558     }
2559 
2560     private void checkNonCyclic1(DiagnosticPosition pos, Type t, List&lt;TypeVar&gt; seen) {
2561         final TypeVar tv;
2562         if  (t.hasTag(TYPEVAR) &amp;&amp; (t.tsym.flags() &amp; UNATTRIBUTED) != 0)
2563             return;
2564         if (seen.contains(t)) {
2565             tv = (TypeVar)t;
2566             tv.setUpperBound(types.createErrorType(t));
2567             log.error(pos, Errors.CyclicInheritance(t));
2568         } else if (t.hasTag(TYPEVAR)) {
2569             tv = (TypeVar)t;
2570             seen = seen.prepend(tv);
2571             for (Type b : types.getBounds(tv))
2572                 checkNonCyclic1(pos, b, seen);
2573         }
2574     }
2575 
2576     /** Check for cyclic references. Issue an error if the
2577      *  symbol of the type referred to has a LOCKED flag set.
2578      *
2579      *  @param pos      Position to be used for error reporting.
2580      *  @param t        The type referred to.
2581      *  @returns        True if the check completed on all attributed classes
2582      */
2583     private boolean checkNonCyclicInternal(DiagnosticPosition pos, Type t) {
2584         boolean complete = true; // was the check complete?
2585         //- System.err.println(&quot;checkNonCyclicInternal(&quot;+t+&quot;);&quot;);//DEBUG
2586         Symbol c = t.tsym;
2587         if ((c.flags_field &amp; ACYCLIC) != 0) return true;
2588 
2589         if ((c.flags_field &amp; LOCKED) != 0) {
2590             noteCyclic(pos, (ClassSymbol)c);
2591         } else if (!c.type.isErroneous()) {
2592             try {
2593                 c.flags_field |= LOCKED;
2594                 if (c.type.hasTag(CLASS)) {
2595                     ClassType clazz = (ClassType)c.type;
2596                     if (clazz.interfaces_field != null)
2597                         for (List&lt;Type&gt; l=clazz.interfaces_field; l.nonEmpty(); l=l.tail)
2598                             complete &amp;= checkNonCyclicInternal(pos, l.head);
2599                     if (clazz.supertype_field != null) {
2600                         Type st = clazz.supertype_field;
2601                         if (st != null &amp;&amp; st.hasTag(CLASS))
2602                             complete &amp;= checkNonCyclicInternal(pos, st);
2603                     }
2604                     if (c.owner.kind == TYP)
2605                         complete &amp;= checkNonCyclicInternal(pos, c.owner.type);
2606                 }
2607             } finally {
2608                 c.flags_field &amp;= ~LOCKED;
2609             }
2610         }
2611         if (complete)
2612             complete = ((c.flags_field &amp; UNATTRIBUTED) == 0) &amp;&amp; c.isCompleted();
2613         if (complete) c.flags_field |= ACYCLIC;
2614         return complete;
2615     }
2616 
2617     /** Note that we found an inheritance cycle. */
2618     private void noteCyclic(DiagnosticPosition pos, ClassSymbol c) {
2619         log.error(pos, Errors.CyclicInheritance(c));
2620         for (List&lt;Type&gt; l=types.interfaces(c.type); l.nonEmpty(); l=l.tail)
2621             l.head = types.createErrorType((ClassSymbol)l.head.tsym, Type.noType);
2622         Type st = types.supertype(c.type);
2623         if (st.hasTag(CLASS))
2624             ((ClassType)c.type).supertype_field = types.createErrorType((ClassSymbol)st.tsym, Type.noType);
2625         c.type = types.createErrorType(c, c.type);
2626         c.flags_field |= ACYCLIC;
2627     }
2628 
2629     /** Check that all methods which implement some
2630      *  method conform to the method they implement.
2631      *  @param tree         The class definition whose members are checked.
2632      */
2633     void checkImplementations(JCClassDecl tree) {
2634         checkImplementations(tree, tree.sym, tree.sym);
2635     }
2636     //where
2637         /** Check that all methods which implement some
2638          *  method in `ic&#39; conform to the method they implement.
2639          */
2640         void checkImplementations(JCTree tree, ClassSymbol origin, ClassSymbol ic) {
2641             for (List&lt;Type&gt; l = types.closure(ic.type); l.nonEmpty(); l = l.tail) {
2642                 ClassSymbol lc = (ClassSymbol)l.head.tsym;
2643                 if ((lc.flags() &amp; ABSTRACT) != 0) {
2644                     for (Symbol sym : lc.members().getSymbols(NON_RECURSIVE)) {
2645                         if (sym.kind == MTH &amp;&amp;
2646                             (sym.flags() &amp; (STATIC|ABSTRACT)) == ABSTRACT) {
2647                             MethodSymbol absmeth = (MethodSymbol)sym;
2648                             MethodSymbol implmeth = absmeth.implementation(origin, types, false);
2649                             if (implmeth != null &amp;&amp; implmeth != absmeth &amp;&amp;
2650                                 (implmeth.owner.flags() &amp; INTERFACE) ==
2651                                 (origin.flags() &amp; INTERFACE)) {
2652                                 // don&#39;t check if implmeth is in a class, yet
2653                                 // origin is an interface. This case arises only
2654                                 // if implmeth is declared in Object. The reason is
2655                                 // that interfaces really don&#39;t inherit from
2656                                 // Object it&#39;s just that the compiler represents
2657                                 // things that way.
2658                                 checkOverride(tree, implmeth, absmeth, origin);
2659                             }
2660                         }
2661                     }
2662                 }
2663             }
2664         }
2665 
2666     /** Check that all abstract methods implemented by a class are
2667      *  mutually compatible.
2668      *  @param pos          Position to be used for error reporting.
2669      *  @param c            The class whose interfaces are checked.
2670      */
2671     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2672         List&lt;Type&gt; supertypes = types.interfaces(c);
2673         Type supertype = types.supertype(c);
2674         if (supertype.hasTag(CLASS) &amp;&amp;
2675             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2676             supertypes = supertypes.prepend(supertype);
2677         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2678             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2679                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2680                 return;
2681             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2682                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2683                     return;
2684         }
2685         checkCompatibleConcretes(pos, c);
<a name="25" id="anc25"></a><span class="line-added">2686 </span>
<span class="line-added">2687         if (c.isValue() &amp;&amp; types.asSuper(c, syms.identityObjectType.tsym, true) != null) {</span>
<span class="line-added">2688             log.error(pos, Errors.InlineTypeMustNotImplementIdentityObject(c));</span>
<span class="line-added">2689         }</span>
2690     }
2691 
2692     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2693      *  are mutually compatible (JLS 8.4.8/9.4.1).
2694      *
2695      *  @param pos  Position to be used for error reporting.
2696      *  @param site The class whose methods are checked.
2697      *  @param sym  The method symbol to be checked.
2698      */
2699     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2700          ClashFilter cf = new ClashFilter(site);
2701         //for each method m1 that is overridden (directly or indirectly)
2702         //by method &#39;sym&#39; in &#39;site&#39;...
2703 
2704         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2705         boolean overridesAny = false;
2706         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2707         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2708         for (Symbol m1 : symbolsByName) {
2709             if (!sym.overrides(m1, site.tsym, types, false)) {
2710                 if (m1 == sym) {
2711                     continue;
2712                 }
2713 
2714                 if (!overridesAny) {
2715                     potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);
2716                 }
2717                 continue;
2718             }
2719 
2720             if (m1 != sym) {
2721                 overridesAny = true;
2722                 potentiallyAmbiguousList = List.nil();
2723             }
2724 
2725             //...check each method m2 that is a member of &#39;site&#39;
2726             for (Symbol m2 : symbolsByName) {
2727                 if (m2 == m1) continue;
2728                 //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2729                 //a member of &#39;site&#39;) and (ii) m1 has the same erasure as m2, issue an error
2730                 if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &amp;&amp;
2731                         types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
2732                     sym.flags_field |= CLASH;
2733                     if (m1 == sym) {
2734                         log.error(pos, Errors.NameClashSameErasureNoOverride(
2735                             m1.name, types.memberType(site, m1).asMethodType().getParameterTypes(), m1.location(),
2736                             m2.name, types.memberType(site, m2).asMethodType().getParameterTypes(), m2.location()));
2737                     } else {
2738                         ClassType ct = (ClassType)site;
2739                         String kind = ct.isInterface() ? &quot;interface&quot; : &quot;class&quot;;
2740                         log.error(pos, Errors.NameClashSameErasureNoOverride1(
2741                             kind,
2742                             ct.tsym.name,
2743                             m1.name,
2744                             types.memberType(site, m1).asMethodType().getParameterTypes(),
2745                             m1.location(),
2746                             m2.name,
2747                             types.memberType(site, m2).asMethodType().getParameterTypes(),
2748                             m2.location()));
2749                     }
2750                     return;
2751                 }
2752             }
2753         }
2754 
2755         if (!overridesAny) {
2756             for (MethodSymbol m: potentiallyAmbiguousList) {
2757                 checkPotentiallyAmbiguousOverloads(pos, site, sym, m);
2758             }
2759         }
2760     }
2761 
2762     /** Check that all static methods accessible from &#39;site&#39; are
2763      *  mutually compatible (JLS 8.4.8).
2764      *
2765      *  @param pos  Position to be used for error reporting.
2766      *  @param site The class whose methods are checked.
2767      *  @param sym  The method symbol to be checked.
2768      */
2769     void checkHideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2770         ClashFilter cf = new ClashFilter(site);
2771         //for each method m1 that is a member of &#39;site&#39;...
2772         for (Symbol s : types.membersClosure(site, true).getSymbolsByName(sym.name, cf)) {
2773             //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2774             //a member of &#39;site&#39;) and (ii) &#39;sym&#39; has the same erasure as m1, issue an error
2775             if (!types.isSubSignature(sym.type, types.memberType(site, s), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source))) {
2776                 if (types.hasSameArgs(s.erasure(types), sym.erasure(types))) {
2777                     log.error(pos,
2778                               Errors.NameClashSameErasureNoHide(sym, sym.location(), s, s.location()));
2779                     return;
2780                 } else {
2781                     checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);
2782                 }
2783             }
2784          }
2785      }
2786 
2787      //where
2788      private class ClashFilter implements Filter&lt;Symbol&gt; {
2789 
2790          Type site;
2791 
2792          ClashFilter(Type site) {
2793              this.site = site;
2794          }
2795 
2796          boolean shouldSkip(Symbol s) {
2797              return (s.flags() &amp; CLASH) != 0 &amp;&amp;
2798                 s.owner == site.tsym;
2799          }
2800 
2801          public boolean accepts(Symbol s) {
2802              return s.kind == MTH &amp;&amp;
2803                      (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
2804                      !shouldSkip(s) &amp;&amp;
2805                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2806                      !s.isConstructor();
2807          }
2808      }
2809 
2810     void checkDefaultMethodClashes(DiagnosticPosition pos, Type site) {
2811         DefaultMethodClashFilter dcf = new DefaultMethodClashFilter(site);
2812         for (Symbol m : types.membersClosure(site, false).getSymbols(dcf)) {
2813             Assert.check(m.kind == MTH);
2814             List&lt;MethodSymbol&gt; prov = types.interfaceCandidates(site, (MethodSymbol)m);
2815             if (prov.size() &gt; 1) {
2816                 ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
2817                 ListBuffer&lt;Symbol&gt; defaults = new ListBuffer&lt;&gt;();
2818                 for (MethodSymbol provSym : prov) {
2819                     if ((provSym.flags() &amp; DEFAULT) != 0) {
2820                         defaults = defaults.append(provSym);
2821                     } else if ((provSym.flags() &amp; ABSTRACT) != 0) {
2822                         abstracts = abstracts.append(provSym);
2823                     }
2824                     if (defaults.nonEmpty() &amp;&amp; defaults.size() + abstracts.size() &gt;= 2) {
2825                         //strong semantics - issue an error if two sibling interfaces
2826                         //have two override-equivalent defaults - or if one is abstract
2827                         //and the other is default
2828                         Fragment diagKey;
2829                         Symbol s1 = defaults.first();
2830                         Symbol s2;
2831                         if (defaults.size() &gt; 1) {
2832                             s2 = defaults.toList().tail.head;
2833                             diagKey = Fragments.IncompatibleUnrelatedDefaults(Kinds.kindName(site.tsym), site,
2834                                     m.name, types.memberType(site, m).getParameterTypes(),
2835                                     s1.location(), s2.location());
2836 
2837                         } else {
2838                             s2 = abstracts.first();
2839                             diagKey = Fragments.IncompatibleAbstractDefault(Kinds.kindName(site.tsym), site,
2840                                     m.name, types.memberType(site, m).getParameterTypes(),
2841                                     s1.location(), s2.location());
2842                         }
2843                         log.error(pos, Errors.TypesIncompatible(s1.location().type, s2.location().type, diagKey));
2844                         break;
2845                     }
2846                 }
2847             }
2848         }
2849     }
2850 
2851     //where
2852      private class DefaultMethodClashFilter implements Filter&lt;Symbol&gt; {
2853 
2854          Type site;
2855 
2856          DefaultMethodClashFilter(Type site) {
2857              this.site = site;
2858          }
2859 
2860          public boolean accepts(Symbol s) {
2861              return s.kind == MTH &amp;&amp;
2862                      (s.flags() &amp; DEFAULT) != 0 &amp;&amp;
2863                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2864                      !s.isConstructor();
2865          }
2866      }
2867 
2868     /**
2869       * Report warnings for potentially ambiguous method declarations. Two declarations
2870       * are potentially ambiguous if they feature two unrelated functional interface
2871       * in same argument position (in which case, a call site passing an implicit
2872       * lambda would be ambiguous).
2873       */
2874     void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,
2875             MethodSymbol msym1, MethodSymbol msym2) {
2876         if (msym1 != msym2 &amp;&amp;
2877                 Feature.DEFAULT_METHODS.allowedInSource(source) &amp;&amp;
2878                 lint.isEnabled(LintCategory.OVERLOADS) &amp;&amp;
2879                 (msym1.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0 &amp;&amp;
2880                 (msym2.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0) {
2881             Type mt1 = types.memberType(site, msym1);
2882             Type mt2 = types.memberType(site, msym2);
2883             //if both generic methods, adjust type variables
2884             if (mt1.hasTag(FORALL) &amp;&amp; mt2.hasTag(FORALL) &amp;&amp;
2885                     types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {
2886                 mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);
2887             }
2888             //expand varargs methods if needed
2889             int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());
2890             List&lt;Type&gt; args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);
2891             List&lt;Type&gt; args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);
2892             //if arities don&#39;t match, exit
2893             if (args1.length() != args2.length()) return;
2894             boolean potentiallyAmbiguous = false;
2895             while (args1.nonEmpty() &amp;&amp; args2.nonEmpty()) {
2896                 Type s = args1.head;
2897                 Type t = args2.head;
2898                 if (!types.isSubtype(t, s) &amp;&amp; !types.isSubtype(s, t)) {
2899                     if (types.isFunctionalInterface(s) &amp;&amp; types.isFunctionalInterface(t) &amp;&amp;
2900                             types.findDescriptorType(s).getParameterTypes().length() &gt; 0 &amp;&amp;
2901                             types.findDescriptorType(s).getParameterTypes().length() ==
2902                             types.findDescriptorType(t).getParameterTypes().length()) {
2903                         potentiallyAmbiguous = true;
2904                     } else {
2905                         break;
2906                     }
2907                 }
2908                 args1 = args1.tail;
2909                 args2 = args2.tail;
2910             }
2911             if (potentiallyAmbiguous) {
2912                 //we found two incompatible functional interfaces with same arity
2913                 //this means a call site passing an implicit lambda would be ambiguous
2914                 msym1.flags_field |= POTENTIALLY_AMBIGUOUS;
2915                 msym2.flags_field |= POTENTIALLY_AMBIGUOUS;
2916                 log.warning(LintCategory.OVERLOADS, pos,
2917                             Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),
2918                                                                   msym2, msym2.location()));
2919                 return;
2920             }
2921         }
2922     }
2923 
2924     void checkAccessFromSerializableElement(final JCTree tree, boolean isLambda) {
2925         if (warnOnAnyAccessToMembers ||
2926             (lint.isEnabled(LintCategory.SERIAL) &amp;&amp;
2927             !lint.isSuppressed(LintCategory.SERIAL) &amp;&amp;
2928             isLambda)) {
2929             Symbol sym = TreeInfo.symbol(tree);
2930             if (!sym.kind.matches(KindSelector.VAL_MTH)) {
2931                 return;
2932             }
2933 
2934             if (sym.kind == VAR) {
2935                 if ((sym.flags() &amp; PARAMETER) != 0 ||
2936                     sym.isLocal() ||
2937                     sym.name == names._this ||
2938                     sym.name == names._super) {
2939                     return;
2940                 }
2941             }
2942 
2943             if (!types.isSubtype(sym.owner.type, syms.serializableType) &amp;&amp;
2944                 isEffectivelyNonPublic(sym)) {
2945                 if (isLambda) {
2946                     if (belongsToRestrictedPackage(sym)) {
2947                         log.warning(LintCategory.SERIAL, tree.pos(),
2948                                     Warnings.AccessToMemberFromSerializableLambda(sym));
2949                     }
2950                 } else {
2951                     log.warning(tree.pos(),
2952                                 Warnings.AccessToMemberFromSerializableElement(sym));
2953                 }
2954             }
2955         }
2956     }
2957 
2958     private boolean isEffectivelyNonPublic(Symbol sym) {
2959         if (sym.packge() == syms.rootPackage) {
2960             return false;
2961         }
2962 
2963         while (sym.kind != PCK) {
2964             if ((sym.flags() &amp; PUBLIC) == 0) {
2965                 return true;
2966             }
2967             sym = sym.owner;
2968         }
2969         return false;
2970     }
2971 
2972     private boolean belongsToRestrictedPackage(Symbol sym) {
2973         String fullName = sym.packge().fullname.toString();
2974         return fullName.startsWith(&quot;java.&quot;) ||
2975                 fullName.startsWith(&quot;javax.&quot;) ||
2976                 fullName.startsWith(&quot;sun.&quot;) ||
2977                 fullName.contains(&quot;.internal.&quot;);
2978     }
2979 
2980     /** Check that class c does not implement directly or indirectly
2981      *  the same parameterized interface with two different argument lists.
2982      *  @param pos          Position to be used for error reporting.
2983      *  @param type         The type whose interfaces are checked.
2984      */
2985     void checkClassBounds(DiagnosticPosition pos, Type type) {
2986         checkClassBounds(pos, new HashMap&lt;TypeSymbol,Type&gt;(), type);
2987     }
2988 //where
2989         /** Enter all interfaces of type `type&#39; into the hash table `seensofar&#39;
2990          *  with their class symbol as key and their type as value. Make
2991          *  sure no class is entered with two different types.
2992          */
2993         void checkClassBounds(DiagnosticPosition pos,
2994                               Map&lt;TypeSymbol,Type&gt; seensofar,
2995                               Type type) {
2996             if (type.isErroneous()) return;
2997             for (List&lt;Type&gt; l = types.interfaces(type); l.nonEmpty(); l = l.tail) {
2998                 Type it = l.head;
2999                 if (type.hasTag(CLASS) &amp;&amp; !it.hasTag(CLASS)) continue; // JLS 8.1.5
3000 
3001                 Type oldit = seensofar.put(it.tsym, it);
3002                 if (oldit != null) {
3003                     List&lt;Type&gt; oldparams = oldit.allparams();
3004                     List&lt;Type&gt; newparams = it.allparams();
3005                     if (!types.containsTypeEquivalent(oldparams, newparams))
3006                         log.error(pos,
3007                                   Errors.CantInheritDiffArg(it.tsym,
3008                                                             Type.toString(oldparams),
3009                                                             Type.toString(newparams)));
3010                 }
3011                 checkClassBounds(pos, seensofar, it);
3012             }
3013             Type st = types.supertype(type);
3014             if (type.hasTag(CLASS) &amp;&amp; !st.hasTag(CLASS)) return; // JLS 8.1.4
3015             if (st != Type.noType) checkClassBounds(pos, seensofar, st);
3016         }
3017 
3018     /** Enter interface into into set.
3019      *  If it existed already, issue a &quot;repeated interface&quot; error.
3020      */
3021     void checkNotRepeated(DiagnosticPosition pos, Type it, Set&lt;Type&gt; its) {
3022         if (its.contains(it))
3023             log.error(pos, Errors.RepeatedInterface);
3024         else {
3025             its.add(it);
3026         }
3027     }
3028 
3029 /* *************************************************************************
3030  * Check annotations
3031  **************************************************************************/
3032 
3033     /**
3034      * Recursively validate annotations values
3035      */
3036     void validateAnnotationTree(JCTree tree) {
3037         class AnnotationValidator extends TreeScanner {
3038             @Override
3039             public void visitAnnotation(JCAnnotation tree) {
3040                 if (!tree.type.isErroneous() &amp;&amp; tree.type.tsym.isAnnotationType()) {
3041                     super.visitAnnotation(tree);
3042                     validateAnnotation(tree);
3043                 }
3044             }
3045         }
3046         tree.accept(new AnnotationValidator());
3047     }
3048 
3049     /**
3050      *  {@literal
3051      *  Annotation types are restricted to primitives, String, an
3052      *  enum, an annotation, Class, Class&lt;?&gt;, Class&lt;? extends
3053      *  Anything&gt;, arrays of the preceding.
3054      *  }
3055      */
3056     void validateAnnotationType(JCTree restype) {
3057         // restype may be null if an error occurred, so don&#39;t bother validating it
3058         if (restype != null) {
3059             validateAnnotationType(restype.pos(), restype.type);
3060         }
3061     }
3062 
3063     void validateAnnotationType(DiagnosticPosition pos, Type type) {
3064         if (type.isPrimitive()) return;
3065         if (types.isSameType(type, syms.stringType)) return;
3066         if ((type.tsym.flags() &amp; Flags.ENUM) != 0) return;
3067         if ((type.tsym.flags() &amp; Flags.ANNOTATION) != 0) return;
3068         if (types.cvarLowerBound(type).tsym == syms.classType.tsym) return;
3069         if (types.isArray(type) &amp;&amp; !types.isArray(types.elemtype(type))) {
3070             validateAnnotationType(pos, types.elemtype(type));
3071             return;
3072         }
3073         log.error(pos, Errors.InvalidAnnotationMemberType);
3074     }
3075 
3076     /**
3077      * &quot;It is also a compile-time error if any method declared in an
3078      * annotation type has a signature that is override-equivalent to
3079      * that of any public or protected method declared in class Object
3080      * or in the interface annotation.Annotation.&quot;
3081      *
3082      * @jls 9.6 Annotation Types
3083      */
3084     void validateAnnotationMethod(DiagnosticPosition pos, MethodSymbol m) {
3085         for (Type sup = syms.annotationType; sup.hasTag(CLASS); sup = types.supertype(sup)) {
3086             Scope s = sup.tsym.members();
3087             for (Symbol sym : s.getSymbolsByName(m.name)) {
3088                 if (sym.kind == MTH &amp;&amp;
3089                     (sym.flags() &amp; (PUBLIC | PROTECTED)) != 0 &amp;&amp;
3090                     types.overrideEquivalent(m.type, sym.type))
3091                     log.error(pos, Errors.IntfAnnotationMemberClash(sym, sup));
3092             }
3093         }
3094     }
3095 
3096     /** Check the annotations of a symbol.
3097      */
3098     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, JCTree declarationTree, Symbol s) {
3099         for (JCAnnotation a : annotations)
3100             validateAnnotation(a, declarationTree, s);
3101     }
3102 
3103     /** Check the type annotations.
3104      */
3105     public void validateTypeAnnotations(List&lt;JCAnnotation&gt; annotations, boolean isTypeParameter) {
3106         for (JCAnnotation a : annotations)
3107             validateTypeAnnotation(a, isTypeParameter);
3108     }
3109 
3110     /** Check an annotation of a symbol.
3111      */
3112     private void validateAnnotation(JCAnnotation a, JCTree declarationTree, Symbol s) {
3113         validateAnnotationTree(a);
3114         boolean isRecordMember = (s.flags_field &amp; RECORD) != 0 || s.enclClass() != null &amp;&amp; s.enclClass().isRecord();
3115 
3116         boolean isRecordField = isRecordMember &amp;&amp;
3117                 (s.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
3118                 declarationTree.hasTag(VARDEF) &amp;&amp;
3119                 s.owner.kind == TYP;
3120 
3121         if (isRecordField) {
3122             // first we need to check if the annotation is applicable to records
3123             Name[] targets = getTargetNames(a);
3124             boolean appliesToRecords = false;
3125             for (Name target : targets) {
3126                 appliesToRecords =
3127                                 target == names.FIELD ||
3128                                 target == names.PARAMETER ||
3129                                 target == names.METHOD ||
3130                                 target == names.TYPE_USE ||
3131                                 target == names.RECORD_COMPONENT;
3132                 if (appliesToRecords) {
3133                     break;
3134                 }
3135             }
3136             if (!appliesToRecords) {
3137                 log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3138             } else {
3139                 /* lets now find the annotations in the field that are targeted to record components and append them to
3140                  * the corresponding record component
3141                  */
3142                 ClassSymbol recordClass = (ClassSymbol) s.owner;
3143                 RecordComponent rc = recordClass.getRecordComponent((VarSymbol)s);
3144                 SymbolMetadata metadata = rc.getMetadata();
3145                 if (metadata == null || metadata.isEmpty()) {
3146                     /* if not is empty then we have already been here, which is the case if multiple annotations are applied
3147                      * to the record component declaration
3148                      */
3149                     rc.appendAttributes(s.getRawAttributes().stream().filter(anno -&gt;
3150                             Arrays.stream(getTargetNames(anno.type.tsym)).anyMatch(name -&gt; name == names.RECORD_COMPONENT)
3151                     ).collect(List.collector()));
3152                     rc.setTypeAttributes(s.getRawTypeAttributes());
3153                     // to get all the type annotations applied to the type
3154                     rc.type = s.type;
3155                 }
3156             }
3157         }
3158 
3159         /* the section below is tricky. Annotations applied to record components are propagated to the corresponding
3160          * record member so if an annotation has target: FIELD, it is propagated to the corresponding FIELD, if it has
3161          * target METHOD, it is propagated to the accessor and so on. But at the moment when method members are generated
3162          * there is no enough information to propagate only the right annotations. So all the annotations are propagated
3163          * to all the possible locations.
3164          *
3165          * At this point we need to remove all the annotations that are not in place before going on with the annotation
3166          * party. On top of the above there is the issue that there is no AST representing record components, just symbols
3167          * so the corresponding field has been holding all the annotations and it&#39;s metadata has been modified as if it
3168          * was both a field and a record component.
3169          *
3170          * So there are two places where we need to trim annotations from: the metadata of the symbol and / or the modifiers
3171          * in the AST. Whatever is in the metadata will be written to the class file, whatever is in the modifiers could
3172          * be see by annotation processors.
3173          *
3174          * The metadata contains both type annotations and declaration annotations. At this point of the game we don&#39;t
3175          * need to care about type annotations, they are all in the right place. But we could need to remove declaration
3176          * annotations. So for declaration annotations if they are not applicable to the record member, excluding type
3177          * annotations which are already correct, then we will remove it. For the AST modifiers if the annotation is not
3178          * applicable either as type annotation and or declaration annotation, only in that case it will be removed.
3179          *
3180          * So it could be that annotation is removed as a declaration annotation but it is kept in the AST modifier for
3181          * further inspection by annotation processors.
3182          *
3183          * For example:
3184          *
3185          *     import java.lang.annotation.*;
3186          *
3187          *     @Target({ElementType.TYPE_USE, ElementType.RECORD_COMPONENT})
3188          *     @Retention(RetentionPolicy.RUNTIME)
3189          *     @interface Anno { }
3190          *
3191          *     record R(@Anno String s) {}
3192          *
3193          * at this point we will have for the case of the generated field:
3194          *   - @Anno in the modifier
3195          *   - @Anno as a type annotation
3196          *   - @Anno as a declaration annotation
3197          *
3198          * the last one should be removed because the annotation has not FIELD as target but it was applied as a
3199          * declaration annotation because the field was being treated both as a field and as a record component
3200          * as we have already copied the annotations to the record component, now the field doesn&#39;t need to hold
3201          * annotations that are not intended for it anymore. Still @Anno has to be kept in the AST&#39;s modifiers as it
3202          * is applicable as a type annotation to the type of the field.
3203          */
3204 
3205         if (a.type.tsym.isAnnotationType()) {
3206             Optional&lt;Set&lt;Name&gt;&gt; applicableTargetsOp = getApplicableTargets(a, s);
3207             if (!applicableTargetsOp.isEmpty()) {
3208                 Set&lt;Name&gt; applicableTargets = applicableTargetsOp.get();
3209                 boolean notApplicableOrIsTypeUseOnly = applicableTargets.isEmpty() ||
3210                         applicableTargets.size() == 1 &amp;&amp; applicableTargets.contains(names.TYPE_USE);
3211                 boolean isRecordMemberWithNonApplicableDeclAnno =
3212                         isRecordMember &amp;&amp; (s.flags_field &amp; Flags.GENERATED_MEMBER) != 0 &amp;&amp; notApplicableOrIsTypeUseOnly;
3213 
3214                 if (applicableTargets.isEmpty() || isRecordMemberWithNonApplicableDeclAnno) {
3215                     if (isRecordMemberWithNonApplicableDeclAnno) {
3216                             /* so we have found an annotation that is not applicable to a record member that was generated by the
3217                              * compiler. This was intentionally done at TypeEnter, now is the moment strip away the annotations
3218                              * that are not applicable to the given record member
3219                              */
3220                         JCModifiers modifiers = TreeInfo.getModifiers(declarationTree);
3221                             /* lets first remove the annotation from the modifier if it is not applicable, we have to check again as
3222                              * it could be a type annotation
3223                              */
3224                         if (modifiers != null &amp;&amp; applicableTargets.isEmpty()) {
3225                             ListBuffer&lt;JCAnnotation&gt; newAnnotations = new ListBuffer&lt;&gt;();
3226                             for (JCAnnotation anno : modifiers.annotations) {
3227                                 if (anno != a) {
3228                                     newAnnotations.add(anno);
3229                                 }
3230                             }
3231                             modifiers.annotations = newAnnotations.toList();
3232                         }
3233                         // now lets remove it from the symbol
3234                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3235                     } else {
3236                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3237                     }
3238                 }
3239             }
3240         }
3241 
3242         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3243             if (s.kind != TYP) {
3244                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3245             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3246                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3247             }
3248         }
<a name="26" id="anc26"></a><span class="line-added">3249         if (a.annotationType.type.tsym == syms.valueBasedType.tsym) {</span>
<span class="line-added">3250             if (s.isInterface() || s.isEnum()) {</span>
<span class="line-added">3251                 log.error(a.pos(), Errors.BadValueBasedAnno);</span>
<span class="line-added">3252             } else if (allowValueBasedClasses) {</span>
<span class="line-added">3253                 s.flags_field |= VALUEBASED;</span>
<span class="line-added">3254             }</span>
<span class="line-added">3255         }</span>
3256     }
3257 
3258     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3259         Assert.checkNonNull(a.type);
3260         validateAnnotationTree(a);
3261 
3262         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3263                 !a.annotationType.type.isErroneous() &amp;&amp;
3264                 !isTypeAnnotation(a, isTypeParameter)) {
3265             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3266         }
3267     }
3268 
3269     /**
3270      * Validate the proposed container &#39;repeatable&#39; on the
3271      * annotation type symbol &#39;s&#39;. Report errors at position
3272      * &#39;pos&#39;.
3273      *
3274      * @param s The (annotation)type declaration annotated with a @Repeatable
3275      * @param repeatable the @Repeatable on &#39;s&#39;
3276      * @param pos where to report errors
3277      */
3278     public void validateRepeatable(TypeSymbol s, Attribute.Compound repeatable, DiagnosticPosition pos) {
3279         Assert.check(types.isSameType(repeatable.type, syms.repeatableType));
3280 
3281         Type t = null;
3282         List&lt;Pair&lt;MethodSymbol,Attribute&gt;&gt; l = repeatable.values;
3283         if (!l.isEmpty()) {
3284             Assert.check(l.head.fst.name == names.value);
3285             t = ((Attribute.Class)l.head.snd).getValue();
3286         }
3287 
3288         if (t == null) {
3289             // errors should already have been reported during Annotate
3290             return;
3291         }
3292 
3293         validateValue(t.tsym, s, pos);
3294         validateRetention(t.tsym, s, pos);
3295         validateDocumented(t.tsym, s, pos);
3296         validateInherited(t.tsym, s, pos);
3297         validateTarget(t.tsym, s, pos);
3298         validateDefault(t.tsym, pos);
3299     }
3300 
3301     private void validateValue(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3302         Symbol sym = container.members().findFirst(names.value);
3303         if (sym != null &amp;&amp; sym.kind == MTH) {
3304             MethodSymbol m = (MethodSymbol) sym;
3305             Type ret = m.getReturnType();
3306             if (!(ret.hasTag(ARRAY) &amp;&amp; types.isSameType(((ArrayType)ret).elemtype, contained.type))) {
3307                 log.error(pos,
3308                           Errors.InvalidRepeatableAnnotationValueReturn(container,
3309                                                                         ret,
3310                                                                         types.makeArrayType(contained.type)));
3311             }
3312         } else {
3313             log.error(pos, Errors.InvalidRepeatableAnnotationNoValue(container));
3314         }
3315     }
3316 
3317     private void validateRetention(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3318         Attribute.RetentionPolicy containerRetention = types.getRetention(container);
3319         Attribute.RetentionPolicy containedRetention = types.getRetention(contained);
3320 
3321         boolean error = false;
3322         switch (containedRetention) {
3323         case RUNTIME:
3324             if (containerRetention != Attribute.RetentionPolicy.RUNTIME) {
3325                 error = true;
3326             }
3327             break;
3328         case CLASS:
3329             if (containerRetention == Attribute.RetentionPolicy.SOURCE)  {
3330                 error = true;
3331             }
3332         }
3333         if (error ) {
3334             log.error(pos,
3335                       Errors.InvalidRepeatableAnnotationRetention(container,
3336                                                                   containerRetention.name(),
3337                                                                   contained,
3338                                                                   containedRetention.name()));
3339         }
3340     }
3341 
3342     private void validateDocumented(Symbol container, Symbol contained, DiagnosticPosition pos) {
3343         if (contained.attribute(syms.documentedType.tsym) != null) {
3344             if (container.attribute(syms.documentedType.tsym) == null) {
3345                 log.error(pos, Errors.InvalidRepeatableAnnotationNotDocumented(container, contained));
3346             }
3347         }
3348     }
3349 
3350     private void validateInherited(Symbol container, Symbol contained, DiagnosticPosition pos) {
3351         if (contained.attribute(syms.inheritedType.tsym) != null) {
3352             if (container.attribute(syms.inheritedType.tsym) == null) {
3353                 log.error(pos, Errors.InvalidRepeatableAnnotationNotInherited(container, contained));
3354             }
3355         }
3356     }
3357 
3358     private void validateTarget(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3359         // The set of targets the container is applicable to must be a subset
3360         // (with respect to annotation target semantics) of the set of targets
3361         // the contained is applicable to. The target sets may be implicit or
3362         // explicit.
3363 
3364         Set&lt;Name&gt; containerTargets;
3365         Attribute.Array containerTarget = getAttributeTargetAttribute(container);
3366         if (containerTarget == null) {
3367             containerTargets = getDefaultTargetSet();
3368         } else {
3369             containerTargets = new HashSet&lt;&gt;();
3370             for (Attribute app : containerTarget.values) {
3371                 if (!(app instanceof Attribute.Enum)) {
3372                     continue; // recovery
3373                 }
3374                 Attribute.Enum e = (Attribute.Enum)app;
3375                 containerTargets.add(e.value.name);
3376             }
3377         }
3378 
3379         Set&lt;Name&gt; containedTargets;
3380         Attribute.Array containedTarget = getAttributeTargetAttribute(contained);
3381         if (containedTarget == null) {
3382             containedTargets = getDefaultTargetSet();
3383         } else {
3384             containedTargets = new HashSet&lt;&gt;();
3385             for (Attribute app : containedTarget.values) {
3386                 if (!(app instanceof Attribute.Enum)) {
3387                     continue; // recovery
3388                 }
3389                 Attribute.Enum e = (Attribute.Enum)app;
3390                 containedTargets.add(e.value.name);
3391             }
3392         }
3393 
3394         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3395             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3396         }
3397     }
3398 
3399     /* get a set of names for the default target */
3400     private Set&lt;Name&gt; getDefaultTargetSet() {
3401         if (defaultTargets == null) {
3402             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3403             targets.add(names.ANNOTATION_TYPE);
3404             targets.add(names.CONSTRUCTOR);
3405             targets.add(names.FIELD);
3406             if (allowRecords) {
3407                 targets.add(names.RECORD_COMPONENT);
3408             }
3409             targets.add(names.LOCAL_VARIABLE);
3410             targets.add(names.METHOD);
3411             targets.add(names.PACKAGE);
3412             targets.add(names.PARAMETER);
3413             targets.add(names.TYPE);
3414 
3415             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3416         }
3417 
3418         return defaultTargets;
3419     }
3420     private Set&lt;Name&gt; defaultTargets;
3421 
3422 
3423     /** Checks that s is a subset of t, with respect to ElementType
3424      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3425      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3426      * TYPE_PARAMETER}.
3427      */
3428     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
3429         // Check that all elements in s are present in t
3430         for (Name n2 : s) {
3431             boolean currentElementOk = false;
3432             for (Name n1 : t) {
3433                 if (n1 == n2) {
3434                     currentElementOk = true;
3435                     break;
3436                 } else if (n1 == names.TYPE &amp;&amp; n2 == names.ANNOTATION_TYPE) {
3437                     currentElementOk = true;
3438                     break;
3439                 } else if (n1 == names.TYPE_USE &amp;&amp;
3440                         (n2 == names.TYPE ||
3441                          n2 == names.ANNOTATION_TYPE ||
3442                          n2 == names.TYPE_PARAMETER)) {
3443                     currentElementOk = true;
3444                     break;
3445                 }
3446             }
3447             if (!currentElementOk)
3448                 return false;
3449         }
3450         return true;
3451     }
3452 
3453     private void validateDefault(Symbol container, DiagnosticPosition pos) {
3454         // validate that all other elements of containing type has defaults
3455         Scope scope = container.members();
3456         for(Symbol elm : scope.getSymbols()) {
3457             if (elm.name != names.value &amp;&amp;
3458                 elm.kind == MTH &amp;&amp;
3459                 ((MethodSymbol)elm).defaultValue == null) {
3460                 log.error(pos,
3461                           Errors.InvalidRepeatableAnnotationElemNondefault(container, elm));
3462             }
3463         }
3464     }
3465 
3466     /** Is s a method symbol that overrides a method in a superclass? */
3467     boolean isOverrider(Symbol s) {
3468         if (s.kind != MTH || s.isStatic())
3469             return false;
3470         MethodSymbol m = (MethodSymbol)s;
3471         TypeSymbol owner = (TypeSymbol)m.owner;
3472         for (Type sup : types.closure(owner.type)) {
3473             if (sup == owner.type)
3474                 continue; // skip &quot;this&quot;
3475             Scope scope = sup.tsym.members();
3476             for (Symbol sym : scope.getSymbolsByName(m.name)) {
3477                 if (!sym.isStatic() &amp;&amp; m.overrides(sym, owner, types, true))
3478                     return true;
3479             }
3480         }
3481         return false;
3482     }
3483 
3484     /** Is the annotation applicable to types? */
3485     protected boolean isTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3486         List&lt;Attribute&gt; targets = typeAnnotations.annotationTargets(a.annotationType.type.tsym);
3487         return (targets == null) ?
3488                 false :
3489                 targets.stream()
3490                         .anyMatch(attr -&gt; isTypeAnnotation(attr, isTypeParameter));
3491     }
3492     //where
3493         boolean isTypeAnnotation(Attribute a, boolean isTypeParameter) {
3494             Attribute.Enum e = (Attribute.Enum)a;
3495             return (e.value.name == names.TYPE_USE ||
3496                     (isTypeParameter &amp;&amp; e.value.name == names.TYPE_PARAMETER));
3497         }
3498 
3499     /** Is the annotation applicable to the symbol? */
3500     Name[] getTargetNames(JCAnnotation a) {
3501         return getTargetNames(a.annotationType.type.tsym);
3502     }
3503 
3504     public Name[] getTargetNames(TypeSymbol annoSym) {
3505         Attribute.Array arr = getAttributeTargetAttribute(annoSym);
3506         Name[] targets;
3507         if (arr == null) {
3508             targets = defaultTargetMetaInfo();
3509         } else {
3510             // TODO: can we optimize this?
3511             targets = new Name[arr.values.length];
3512             for (int i=0; i&lt;arr.values.length; ++i) {
3513                 Attribute app = arr.values[i];
3514                 if (!(app instanceof Attribute.Enum)) {
3515                     return new Name[0];
3516                 }
3517                 Attribute.Enum e = (Attribute.Enum) app;
3518                 targets[i] = e.value.name;
3519             }
3520         }
3521         return targets;
3522     }
3523 
3524     boolean annotationApplicable(JCAnnotation a, Symbol s) {
3525         Optional&lt;Set&lt;Name&gt;&gt; targets = getApplicableTargets(a, s);
3526         /* the optional could be emtpy if the annotation is unknown in that case
3527          * we return that it is applicable and if it is erroneous that should imply
3528          * an error at the declaration site
3529          */
3530         return targets.isEmpty() || targets.isPresent() &amp;&amp; !targets.get().isEmpty();
3531     }
3532 
3533     @SuppressWarnings(&quot;preview&quot;)
3534     Optional&lt;Set&lt;Name&gt;&gt; getApplicableTargets(JCAnnotation a, Symbol s) {
3535         Attribute.Array arr = getAttributeTargetAttribute(a.annotationType.type.tsym);
3536         Name[] targets;
3537         Set&lt;Name&gt; applicableTargets = new HashSet&lt;&gt;();
3538 
3539         if (arr == null) {
3540             targets = defaultTargetMetaInfo();
3541         } else {
3542             // TODO: can we optimize this?
3543             targets = new Name[arr.values.length];
3544             for (int i=0; i&lt;arr.values.length; ++i) {
3545                 Attribute app = arr.values[i];
3546                 if (!(app instanceof Attribute.Enum)) {
3547                     // recovery
3548                     return Optional.empty();
3549                 }
3550                 Attribute.Enum e = (Attribute.Enum) app;
3551                 targets[i] = e.value.name;
3552             }
3553         }
3554         for (Name target : targets) {
3555             if (target == names.TYPE) {
3556                 if (s.kind == TYP)
3557                     applicableTargets.add(names.TYPE);
3558             } else if (target == names.FIELD) {
3559                 if (s.kind == VAR &amp;&amp; s.owner.kind != MTH)
3560                     applicableTargets.add(names.FIELD);
3561             } else if (target == names.RECORD_COMPONENT) {
3562                 if (s.getKind() == ElementKind.RECORD_COMPONENT) {
3563                     applicableTargets.add(names.RECORD_COMPONENT);
3564                 }
3565             } else if (target == names.METHOD) {
3566                 if (s.kind == MTH &amp;&amp; !s.isConstructor())
3567                     applicableTargets.add(names.METHOD);
3568             } else if (target == names.PARAMETER) {
3569                 if (s.kind == VAR &amp;&amp;
3570                     (s.owner.kind == MTH &amp;&amp; (s.flags() &amp; PARAMETER) != 0)) {
3571                     applicableTargets.add(names.PARAMETER);
3572                 }
3573             } else if (target == names.CONSTRUCTOR) {
3574                 if (s.kind == MTH &amp;&amp; s.isConstructor())
3575                     applicableTargets.add(names.CONSTRUCTOR);
3576             } else if (target == names.LOCAL_VARIABLE) {
3577                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;
3578                       (s.flags() &amp; PARAMETER) == 0) {
3579                     applicableTargets.add(names.LOCAL_VARIABLE);
3580                 }
3581             } else if (target == names.ANNOTATION_TYPE) {
3582                 if (s.kind == TYP &amp;&amp; (s.flags() &amp; ANNOTATION) != 0) {
3583                     applicableTargets.add(names.ANNOTATION_TYPE);
3584                 }
3585             } else if (target == names.PACKAGE) {
3586                 if (s.kind == PCK)
3587                     applicableTargets.add(names.PACKAGE);
3588             } else if (target == names.TYPE_USE) {
3589                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp; s.type.hasTag(NONE)) {
3590                     //cannot type annotate implicitly typed locals
3591                     continue;
3592                 } else if (s.kind == TYP || s.kind == VAR ||
3593                         (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
3594                                 !s.type.getReturnType().hasTag(VOID)) ||
3595                         (s.kind == MTH &amp;&amp; s.isConstructor())) {
3596                     applicableTargets.add(names.TYPE_USE);
3597                 }
3598             } else if (target == names.TYPE_PARAMETER) {
3599                 if (s.kind == TYP &amp;&amp; s.type.hasTag(TYPEVAR))
3600                     applicableTargets.add(names.TYPE_PARAMETER);
3601             } else
3602                 return Optional.empty(); // Unknown ElementType. This should be an error at declaration site,
3603                                          // assume applicable.
3604         }
3605         return Optional.of(applicableTargets);
3606     }
3607 
3608     Attribute.Array getAttributeTargetAttribute(TypeSymbol s) {
3609         Attribute.Compound atTarget = s.getAnnotationTypeMetadata().getTarget();
3610         if (atTarget == null) return null; // ok, is applicable
3611         Attribute atValue = atTarget.member(names.value);
3612         if (!(atValue instanceof Attribute.Array)) return null; // error recovery
3613         return (Attribute.Array) atValue;
3614     }
3615 
3616     public final Name[] dfltTargetMeta;
3617     private Name[] defaultTargetMetaInfo() {
3618         return dfltTargetMeta;
3619     }
3620 
3621     /** Check an annotation value.
3622      *
3623      * @param a The annotation tree to check
3624      * @return true if this annotation tree is valid, otherwise false
3625      */
3626     public boolean validateAnnotationDeferErrors(JCAnnotation a) {
3627         boolean res = false;
3628         final Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
3629         try {
3630             res = validateAnnotation(a);
3631         } finally {
3632             log.popDiagnosticHandler(diagHandler);
3633         }
3634         return res;
3635     }
3636 
3637     private boolean validateAnnotation(JCAnnotation a) {
3638         boolean isValid = true;
3639         AnnotationTypeMetadata metadata = a.annotationType.type.tsym.getAnnotationTypeMetadata();
3640 
3641         // collect an inventory of the annotation elements
3642         Set&lt;MethodSymbol&gt; elements = metadata.getAnnotationElements();
3643 
3644         // remove the ones that are assigned values
3645         for (JCTree arg : a.args) {
3646             if (!arg.hasTag(ASSIGN)) continue; // recovery
3647             JCAssign assign = (JCAssign)arg;
3648             Symbol m = TreeInfo.symbol(assign.lhs);
3649             if (m == null || m.type.isErroneous()) continue;
3650             if (!elements.remove(m)) {
3651                 isValid = false;
3652                 log.error(assign.lhs.pos(),
3653                           Errors.DuplicateAnnotationMemberValue(m.name, a.type));
3654             }
3655         }
3656 
3657         // all the remaining ones better have default values
3658         List&lt;Name&gt; missingDefaults = List.nil();
3659         Set&lt;MethodSymbol&gt; membersWithDefault = metadata.getAnnotationElementsWithDefault();
3660         for (MethodSymbol m : elements) {
3661             if (m.type.isErroneous())
3662                 continue;
3663 
3664             if (!membersWithDefault.contains(m))
3665                 missingDefaults = missingDefaults.append(m.name);
3666         }
3667         missingDefaults = missingDefaults.reverse();
3668         if (missingDefaults.nonEmpty()) {
3669             isValid = false;
3670             Error errorKey = (missingDefaults.size() &gt; 1)
3671                     ? Errors.AnnotationMissingDefaultValue1(a.type, missingDefaults)
3672                     : Errors.AnnotationMissingDefaultValue(a.type, missingDefaults);
3673             log.error(a.pos(), errorKey);
3674         }
3675 
3676         return isValid &amp;&amp; validateTargetAnnotationValue(a);
3677     }
3678 
3679     /* Validate the special java.lang.annotation.Target annotation */
3680     boolean validateTargetAnnotationValue(JCAnnotation a) {
3681         // special case: java.lang.annotation.Target must not have
3682         // repeated values in its value member
3683         if (a.annotationType.type.tsym != syms.annotationTargetType.tsym ||
3684                 a.args.tail == null)
3685             return true;
3686 
3687         boolean isValid = true;
3688         if (!a.args.head.hasTag(ASSIGN)) return false; // error recovery
3689         JCAssign assign = (JCAssign) a.args.head;
3690         Symbol m = TreeInfo.symbol(assign.lhs);
3691         if (m.name != names.value) return false;
3692         JCTree rhs = assign.rhs;
3693         if (!rhs.hasTag(NEWARRAY)) return false;
3694         JCNewArray na = (JCNewArray) rhs;
3695         Set&lt;Symbol&gt; targets = new HashSet&lt;&gt;();
3696         for (JCTree elem : na.elems) {
3697             if (!targets.add(TreeInfo.symbol(elem))) {
3698                 isValid = false;
3699                 log.error(elem.pos(), Errors.RepeatedAnnotationTarget);
3700             }
3701         }
3702         return isValid;
3703     }
3704 
3705     void checkDeprecatedAnnotation(DiagnosticPosition pos, Symbol s) {
3706         if (lint.isEnabled(LintCategory.DEP_ANN) &amp;&amp; s.isDeprecatableViaAnnotation() &amp;&amp;
3707             (s.flags() &amp; DEPRECATED) != 0 &amp;&amp;
3708             !syms.deprecatedType.isErroneous() &amp;&amp;
3709             s.attribute(syms.deprecatedType.tsym) == null) {
3710             log.warning(LintCategory.DEP_ANN,
3711                     pos, Warnings.MissingDeprecatedAnnotation);
3712         }
3713         // Note: @Deprecated has no effect on local variables, parameters and package decls.
3714         if (lint.isEnabled(LintCategory.DEPRECATION) &amp;&amp; !s.isDeprecatableViaAnnotation()) {
3715             if (!syms.deprecatedType.isErroneous() &amp;&amp; s.attribute(syms.deprecatedType.tsym) != null) {
3716                 log.warning(LintCategory.DEPRECATION, pos,
3717                             Warnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));
3718             }
3719         }
3720     }
3721 
3722     void checkDeprecated(final DiagnosticPosition pos, final Symbol other, final Symbol s) {
3723         checkDeprecated(() -&gt; pos, other, s);
3724     }
3725 
3726     void checkDeprecated(Supplier&lt;DiagnosticPosition&gt; pos, final Symbol other, final Symbol s) {
3727         if ( (s.isDeprecatedForRemoval()
3728                 || s.isDeprecated() &amp;&amp; !other.isDeprecated())
3729                 &amp;&amp; (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {
3730             deferredLintHandler.report(() -&gt; warnDeprecated(pos.get(), s));
3731         }
3732     }
3733 
3734     void checkSunAPI(final DiagnosticPosition pos, final Symbol s) {
3735         if ((s.flags() &amp; PROPRIETARY) != 0) {
3736             deferredLintHandler.report(() -&gt; {
3737                 log.mandatoryWarning(pos, Warnings.SunProprietary(s));
3738             });
3739         }
3740     }
3741 
3742     void checkProfile(final DiagnosticPosition pos, final Symbol s) {
3743         if (profile != Profile.DEFAULT &amp;&amp; (s.flags() &amp; NOT_IN_PROFILE) != 0) {
3744             log.error(pos, Errors.NotInProfile(s, profile));
3745         }
3746     }
3747 
3748     void checkPreview(DiagnosticPosition pos, Symbol s) {
3749         if ((s.flags() &amp; PREVIEW_API) != 0) {
3750             if ((s.flags() &amp; PREVIEW_ESSENTIAL_API) != 0 &amp;&amp; !preview.isEnabled()) {
3751                 log.error(pos, Errors.IsPreview(s));
3752             } else {
3753                 deferredLintHandler.report(() -&gt; warnPreview(pos, s));
3754             }
3755         }
3756     }
3757 
3758 /* *************************************************************************
3759  * Check for recursive annotation elements.
3760  **************************************************************************/
3761 
3762     /** Check for cycles in the graph of annotation elements.
3763      */
3764     void checkNonCyclicElements(JCClassDecl tree) {
3765         if ((tree.sym.flags_field &amp; ANNOTATION) == 0) return;
3766         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
3767         try {
3768             tree.sym.flags_field |= LOCKED;
3769             for (JCTree def : tree.defs) {
3770                 if (!def.hasTag(METHODDEF)) continue;
3771                 JCMethodDecl meth = (JCMethodDecl)def;
3772                 checkAnnotationResType(meth.pos(), meth.restype.type);
3773             }
3774         } finally {
3775             tree.sym.flags_field &amp;= ~LOCKED;
3776             tree.sym.flags_field |= ACYCLIC_ANN;
3777         }
3778     }
3779 
3780     void checkNonCyclicElementsInternal(DiagnosticPosition pos, TypeSymbol tsym) {
3781         if ((tsym.flags_field &amp; ACYCLIC_ANN) != 0)
3782             return;
3783         if ((tsym.flags_field &amp; LOCKED) != 0) {
3784             log.error(pos, Errors.CyclicAnnotationElement(tsym));
3785             return;
3786         }
3787         try {
3788             tsym.flags_field |= LOCKED;
3789             for (Symbol s : tsym.members().getSymbols(NON_RECURSIVE)) {
3790                 if (s.kind != MTH)
3791                     continue;
3792                 checkAnnotationResType(pos, ((MethodSymbol)s).type.getReturnType());
3793             }
3794         } finally {
3795             tsym.flags_field &amp;= ~LOCKED;
3796             tsym.flags_field |= ACYCLIC_ANN;
3797         }
3798     }
3799 
3800     void checkAnnotationResType(DiagnosticPosition pos, Type type) {
3801         switch (type.getTag()) {
3802         case CLASS:
3803             if ((type.tsym.flags() &amp; ANNOTATION) != 0)
3804                 checkNonCyclicElementsInternal(pos, type.tsym);
3805             break;
3806         case ARRAY:
3807             checkAnnotationResType(pos, types.elemtype(type));
3808             break;
3809         default:
3810             break; // int etc
3811         }
3812     }
3813 
3814 /* *************************************************************************
3815  * Check for cycles in the constructor call graph.
3816  **************************************************************************/
3817 
3818     /** Check for cycles in the graph of constructors calling other
3819      *  constructors.
3820      */
3821     void checkCyclicConstructors(JCClassDecl tree) {
3822         Map&lt;Symbol,Symbol&gt; callMap = new HashMap&lt;&gt;();
3823 
3824         // enter each constructor this-call into the map
3825         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
3826             JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);
3827             if (app == null) continue;
3828             JCMethodDecl meth = (JCMethodDecl) l.head;
3829             if (TreeInfo.name(app.meth) == names._this) {
3830                 callMap.put(meth.sym, TreeInfo.symbol(app.meth));
3831             } else {
3832                 meth.sym.flags_field |= ACYCLIC;
3833             }
3834         }
3835 
3836         // Check for cycles in the map
3837         Symbol[] ctors = new Symbol[0];
3838         ctors = callMap.keySet().toArray(ctors);
3839         for (Symbol caller : ctors) {
3840             checkCyclicConstructor(tree, caller, callMap);
3841         }
3842     }
3843 
3844     /** Look in the map to see if the given constructor is part of a
3845      *  call cycle.
3846      */
3847     private void checkCyclicConstructor(JCClassDecl tree, Symbol ctor,
3848                                         Map&lt;Symbol,Symbol&gt; callMap) {
3849         if (ctor != null &amp;&amp; (ctor.flags_field &amp; ACYCLIC) == 0) {
3850             if ((ctor.flags_field &amp; LOCKED) != 0) {
3851                 log.error(TreeInfo.diagnosticPositionFor(ctor, tree),
3852                           Errors.RecursiveCtorInvocation);
3853             } else {
3854                 ctor.flags_field |= LOCKED;
3855                 checkCyclicConstructor(tree, callMap.remove(ctor), callMap);
3856                 ctor.flags_field &amp;= ~LOCKED;
3857             }
3858             ctor.flags_field |= ACYCLIC;
3859         }
3860     }
3861 
3862 /* *************************************************************************
3863  * Miscellaneous
3864  **************************************************************************/
3865 
3866     /**
3867      *  Check for division by integer constant zero
3868      *  @param pos           Position for error reporting.
3869      *  @param operator      The operator for the expression
3870      *  @param operand       The right hand operand for the expression
3871      */
3872     void checkDivZero(final DiagnosticPosition pos, Symbol operator, Type operand) {
3873         if (operand.constValue() != null
3874             &amp;&amp; operand.getTag().isSubRangeOf(LONG)
3875             &amp;&amp; ((Number) (operand.constValue())).longValue() == 0) {
3876             int opc = ((OperatorSymbol)operator).opcode;
3877             if (opc == ByteCodes.idiv || opc == ByteCodes.imod
3878                 || opc == ByteCodes.ldiv || opc == ByteCodes.lmod) {
3879                 deferredLintHandler.report(() -&gt; warnDivZero(pos));
3880             }
3881         }
3882     }
3883 
3884     /**
3885      * Check for empty statements after if
3886      */
3887     void checkEmptyIf(JCIf tree) {
3888         if (tree.thenpart.hasTag(SKIP) &amp;&amp; tree.elsepart == null &amp;&amp;
3889                 lint.isEnabled(LintCategory.EMPTY))
3890             log.warning(LintCategory.EMPTY, tree.thenpart.pos(), Warnings.EmptyIf);
3891     }
3892 
3893     /** Check that symbol is unique in given scope.
3894      *  @param pos           Position for error reporting.
3895      *  @param sym           The symbol.
3896      *  @param s             The scope.
3897      */
3898     boolean checkUnique(DiagnosticPosition pos, Symbol sym, Scope s) {
3899         if (sym.type.isErroneous())
3900             return true;
3901         if (sym.owner.name == names.any) return false;
3902         for (Symbol byName : s.getSymbolsByName(sym.name, NON_RECURSIVE)) {
3903             if (sym != byName &amp;&amp;
3904                     (byName.flags() &amp; CLASH) == 0 &amp;&amp;
3905                     sym.kind == byName.kind &amp;&amp;
3906                     sym.name != names.error &amp;&amp;
3907                     (sym.kind != MTH ||
3908                      types.hasSameArgs(sym.type, byName.type) ||
3909                      types.hasSameArgs(types.erasure(sym.type), types.erasure(byName.type)))) {
3910                 if ((sym.flags() &amp; VARARGS) != (byName.flags() &amp; VARARGS)) {
3911                     sym.flags_field |= CLASH;
3912                     varargsDuplicateError(pos, sym, byName);
3913                     return true;
3914                 } else if (sym.kind == MTH &amp;&amp; !types.hasSameArgs(sym.type, byName.type, false)) {
3915                     duplicateErasureError(pos, sym, byName);
3916                     sym.flags_field |= CLASH;
3917                     return true;
3918                 } else if ((sym.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3919                            (byName.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3920                            (byName.flags() &amp; MATCH_BINDING_TO_OUTER) == 0) {
3921                     if (!sym.type.isErroneous()) {
3922                         log.error(pos, Errors.MatchBindingExists);
3923                         sym.flags_field |= CLASH;
3924                     }
3925                     return false;
3926                 } else {
3927                     duplicateError(pos, byName);
3928                     return false;
3929                 }
3930             }
3931         }
3932         return true;
3933     }
3934 
3935     /** Report duplicate declaration error.
3936      */
3937     void duplicateErasureError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
3938         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
3939             log.error(pos, Errors.NameClashSameErasure(sym1, sym2));
3940         }
3941     }
3942 
3943     /**Check that types imported through the ordinary imports don&#39;t clash with types imported
3944      * by other (static or ordinary) imports. Note that two static imports may import two clashing
3945      * types without an error on the imports.
3946      * @param toplevel       The toplevel tree for which the test should be performed.
3947      */
3948     void checkImportsUnique(JCCompilationUnit toplevel) {
3949         WriteableScope ordinallyImportedSoFar = WriteableScope.create(toplevel.packge);
3950         WriteableScope staticallyImportedSoFar = WriteableScope.create(toplevel.packge);
3951         WriteableScope topLevelScope = toplevel.toplevelScope;
3952 
3953         for (JCTree def : toplevel.defs) {
3954             if (!def.hasTag(IMPORT))
3955                 continue;
3956 
3957             JCImport imp = (JCImport) def;
3958 
3959             if (imp.importScope == null)
3960                 continue;
3961 
3962             for (Symbol sym : imp.importScope.getSymbols(sym -&gt; sym.kind == TYP)) {
3963                 if (imp.isStatic()) {
3964                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, true);
3965                     staticallyImportedSoFar.enter(sym);
3966                 } else {
3967                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, false);
3968                     ordinallyImportedSoFar.enter(sym);
3969                 }
3970             }
3971 
3972             imp.importScope = null;
3973         }
3974     }
3975 
3976     /** Check that single-type import is not already imported or top-level defined,
3977      *  but make an exception for two single-type imports which denote the same type.
3978      *  @param pos                     Position for error reporting.
3979      *  @param ordinallyImportedSoFar  A Scope containing types imported so far through
3980      *                                 ordinary imports.
3981      *  @param staticallyImportedSoFar A Scope containing types imported so far through
3982      *                                 static imports.
3983      *  @param topLevelScope           The current file&#39;s top-level Scope
3984      *  @param sym                     The symbol.
3985      *  @param staticImport            Whether or not this was a static import
3986      */
3987     private boolean checkUniqueImport(DiagnosticPosition pos, Scope ordinallyImportedSoFar,
3988                                       Scope staticallyImportedSoFar, Scope topLevelScope,
3989                                       Symbol sym, boolean staticImport) {
3990         Filter&lt;Symbol&gt; duplicates = candidate -&gt; candidate != sym &amp;&amp; !candidate.type.isErroneous();
3991         Symbol ordinaryClashing = ordinallyImportedSoFar.findFirst(sym.name, duplicates);
3992         Symbol staticClashing = null;
3993         if (ordinaryClashing == null &amp;&amp; !staticImport) {
3994             staticClashing = staticallyImportedSoFar.findFirst(sym.name, duplicates);
3995         }
3996         if (ordinaryClashing != null || staticClashing != null) {
3997             if (ordinaryClashing != null)
3998                 log.error(pos, Errors.AlreadyDefinedSingleImport(ordinaryClashing));
3999             else
4000                 log.error(pos, Errors.AlreadyDefinedStaticSingleImport(staticClashing));
4001             return false;
4002         }
4003         Symbol clashing = topLevelScope.findFirst(sym.name, duplicates);
4004         if (clashing != null) {
4005             log.error(pos, Errors.AlreadyDefinedThisUnit(clashing));
4006             return false;
4007         }
4008         return true;
4009     }
4010 
4011     /** Check that a qualified name is in canonical form (for import decls).
4012      */
4013     public void checkCanonical(JCTree tree) {
4014         if (!isCanonical(tree))
4015             log.error(tree.pos(),
4016                       Errors.ImportRequiresCanonical(TreeInfo.symbol(tree)));
4017     }
4018         // where
4019         private boolean isCanonical(JCTree tree) {
4020             while (tree.hasTag(SELECT)) {
4021                 JCFieldAccess s = (JCFieldAccess) tree;
4022                 if (s.sym.owner.getQualifiedName() != TreeInfo.symbol(s.selected).getQualifiedName())
4023                     return false;
4024                 tree = s.selected;
4025             }
4026             return true;
4027         }
4028 
4029     /** Check that an auxiliary class is not accessed from any other file than its own.
4030      */
4031     void checkForBadAuxiliaryClassAccess(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, ClassSymbol c) {
4032         if (lint.isEnabled(Lint.LintCategory.AUXILIARYCLASS) &amp;&amp;
4033             (c.flags() &amp; AUXILIARY) != 0 &amp;&amp;
4034             rs.isAccessible(env, c) &amp;&amp;
4035             !fileManager.isSameFile(c.sourcefile, env.toplevel.sourcefile))
4036         {
4037             log.warning(pos,
4038                         Warnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));
4039         }
4040     }
4041 
4042     private class ConversionWarner extends Warner {
4043         final String uncheckedKey;
4044         final Type found;
4045         final Type expected;
4046         public ConversionWarner(DiagnosticPosition pos, String uncheckedKey, Type found, Type expected) {
4047             super(pos);
4048             this.uncheckedKey = uncheckedKey;
4049             this.found = found;
4050             this.expected = expected;
4051         }
4052 
4053         @Override
4054         public void warn(LintCategory lint) {
4055             boolean warned = this.warned;
4056             super.warn(lint);
4057             if (warned) return; // suppress redundant diagnostics
4058             switch (lint) {
4059                 case UNCHECKED:
4060                     Check.this.warnUnchecked(pos(), Warnings.ProbFoundReq(diags.fragment(uncheckedKey), found, expected));
4061                     break;
4062                 case VARARGS:
4063                     if (method != null &amp;&amp;
4064                             method.attribute(syms.trustMeType.tsym) != null &amp;&amp;
4065                             isTrustMeAllowedOnMethod(method) &amp;&amp;
4066                             !types.isReifiable(method.type.getParameterTypes().last())) {
4067                         Check.this.warnUnsafeVararg(pos(), Warnings.VarargsUnsafeUseVarargsParam(method.params.last()));
4068                     }
4069                     break;
4070                 default:
4071                     throw new AssertionError(&quot;Unexpected lint: &quot; + lint);
4072             }
4073         }
4074     }
4075 
4076     public Warner castWarner(DiagnosticPosition pos, Type found, Type expected) {
4077         return new ConversionWarner(pos, &quot;unchecked.cast.to.type&quot;, found, expected);
4078     }
4079 
4080     public Warner convertWarner(DiagnosticPosition pos, Type found, Type expected) {
4081         return new ConversionWarner(pos, &quot;unchecked.assign&quot;, found, expected);
4082     }
4083 
4084     public void checkFunctionalInterface(JCClassDecl tree, ClassSymbol cs) {
4085         Compound functionalType = cs.attribute(syms.functionalInterfaceType.tsym);
4086 
4087         if (functionalType != null) {
4088             try {
4089                 types.findDescriptorSymbol((TypeSymbol)cs);
4090             } catch (Types.FunctionDescriptorLookupError ex) {
4091                 DiagnosticPosition pos = tree.pos();
4092                 for (JCAnnotation a : tree.getModifiers().annotations) {
4093                     if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
4094                         pos = a.pos();
4095                         break;
4096                     }
4097                 }
4098                 log.error(pos, Errors.BadFunctionalIntfAnno1(ex.getDiagnostic()));
4099             }
4100         }
4101     }
4102 
4103     public void checkImportsResolvable(final JCCompilationUnit toplevel) {
4104         for (final JCImport imp : toplevel.getImports()) {
4105             if (!imp.staticImport || !imp.qualid.hasTag(SELECT))
4106                 continue;
4107             final JCFieldAccess select = (JCFieldAccess) imp.qualid;
4108             final Symbol origin;
4109             if (select.name == names.asterisk || (origin = TreeInfo.symbol(select.selected)) == null || origin.kind != TYP)
4110                 continue;
4111 
4112             TypeSymbol site = (TypeSymbol) TreeInfo.symbol(select.selected);
4113             if (!checkTypeContainsImportableElement(site, site, toplevel.packge, select.name, new HashSet&lt;Symbol&gt;())) {
4114                 log.error(imp.pos(),
4115                           Errors.CantResolveLocation(KindName.STATIC,
4116                                                      select.name,
4117                                                      null,
4118                                                      null,
4119                                                      Fragments.Location(kindName(site),
4120                                                                         site,
4121                                                                         null)));
4122             }
4123         }
4124     }
4125 
4126     // Check that packages imported are in scope (JLS 7.4.3, 6.3, 6.5.3.1, 6.5.3.2)
4127     public void checkImportedPackagesObservable(final JCCompilationUnit toplevel) {
4128         OUTER: for (JCImport imp : toplevel.getImports()) {
4129             if (!imp.staticImport &amp;&amp; TreeInfo.name(imp.qualid) == names.asterisk) {
4130                 TypeSymbol tsym = ((JCFieldAccess)imp.qualid).selected.type.tsym;
4131                 if (tsym.kind == PCK &amp;&amp; tsym.members().isEmpty() &amp;&amp;
4132                     !(Feature.IMPORT_ON_DEMAND_OBSERVABLE_PACKAGES.allowedInSource(source) &amp;&amp; tsym.exists())) {
4133                     log.error(DiagnosticFlag.RESOLVE_ERROR, imp.pos, Errors.DoesntExist(tsym));
4134                 }
4135             }
4136         }
4137     }
4138 
4139     private boolean checkTypeContainsImportableElement(TypeSymbol tsym, TypeSymbol origin, PackageSymbol packge, Name name, Set&lt;Symbol&gt; processed) {
4140         if (tsym == null || !processed.add(tsym))
4141             return false;
4142 
4143             // also search through inherited names
4144         if (checkTypeContainsImportableElement(types.supertype(tsym.type).tsym, origin, packge, name, processed))
4145             return true;
4146 
4147         for (Type t : types.interfaces(tsym.type))
4148             if (checkTypeContainsImportableElement(t.tsym, origin, packge, name, processed))
4149                 return true;
4150 
4151         for (Symbol sym : tsym.members().getSymbolsByName(name)) {
4152             if (sym.isStatic() &amp;&amp;
4153                 importAccessible(sym, packge) &amp;&amp;
4154                 sym.isMemberOf(origin, types)) {
4155                 return true;
4156             }
4157         }
4158 
4159         return false;
4160     }
4161 
4162     // is the sym accessible everywhere in packge?
4163     public boolean importAccessible(Symbol sym, PackageSymbol packge) {
4164         try {
4165             int flags = (int)(sym.flags() &amp; AccessFlags);
4166             switch (flags) {
4167             default:
4168             case PUBLIC:
4169                 return true;
4170             case PRIVATE:
4171                 return false;
4172             case 0:
4173             case PROTECTED:
4174                 return sym.packge() == packge;
4175             }
4176         } catch (ClassFinder.BadClassFile err) {
4177             throw err;
4178         } catch (CompletionFailure ex) {
4179             return false;
4180         }
4181     }
4182 
4183     public void checkLeaksNotAccessible(Env&lt;AttrContext&gt; env, JCClassDecl check) {
4184         JCCompilationUnit toplevel = env.toplevel;
4185 
4186         if (   toplevel.modle == syms.unnamedModule
4187             || toplevel.modle == syms.noModule
4188             || (check.sym.flags() &amp; COMPOUND) != 0) {
4189             return ;
4190         }
4191 
4192         ExportsDirective currentExport = findExport(toplevel.packge);
4193 
4194         if (   currentExport == null //not exported
4195             || currentExport.modules != null) //don&#39;t check classes in qualified export
4196             return ;
4197 
4198         new TreeScanner() {
4199             Lint lint = env.info.lint;
4200             boolean inSuperType;
4201 
4202             @Override
4203             public void visitBlock(JCBlock tree) {
4204             }
4205             @Override
4206             public void visitMethodDef(JCMethodDecl tree) {
4207                 if (!isAPISymbol(tree.sym))
4208                     return;
4209                 Lint prevLint = lint;
4210                 try {
4211                     lint = lint.augment(tree.sym);
4212                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4213                         super.visitMethodDef(tree);
4214                     }
4215                 } finally {
4216                     lint = prevLint;
4217                 }
4218             }
4219             @Override
4220             public void visitVarDef(JCVariableDecl tree) {
4221                 if (!isAPISymbol(tree.sym) &amp;&amp; tree.sym.owner.kind != MTH)
4222                     return;
4223                 Lint prevLint = lint;
4224                 try {
4225                     lint = lint.augment(tree.sym);
4226                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4227                         scan(tree.mods);
4228                         scan(tree.vartype);
4229                     }
4230                 } finally {
4231                     lint = prevLint;
4232                 }
4233             }
4234             @Override
4235             public void visitClassDef(JCClassDecl tree) {
4236                 if (tree != check)
4237                     return ;
4238 
4239                 if (!isAPISymbol(tree.sym))
4240                     return ;
4241 
4242                 Lint prevLint = lint;
4243                 try {
4244                     lint = lint.augment(tree.sym);
4245                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4246                         scan(tree.mods);
4247                         scan(tree.typarams);
4248                         try {
4249                             inSuperType = true;
4250                             scan(tree.extending);
4251                             scan(tree.implementing);
4252                         } finally {
4253                             inSuperType = false;
4254                         }
4255                         scan(tree.defs);
4256                     }
4257                 } finally {
4258                     lint = prevLint;
4259                 }
4260             }
4261             @Override
4262             public void visitTypeApply(JCTypeApply tree) {
4263                 scan(tree.clazz);
4264                 boolean oldInSuperType = inSuperType;
4265                 try {
4266                     inSuperType = false;
4267                     scan(tree.arguments);
4268                 } finally {
4269                     inSuperType = oldInSuperType;
4270                 }
4271             }
4272             @Override
4273             public void visitIdent(JCIdent tree) {
4274                 Symbol sym = TreeInfo.symbol(tree);
4275                 if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR)) {
4276                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4277                 }
4278             }
4279 
4280             @Override
4281             public void visitSelect(JCFieldAccess tree) {
4282                 Symbol sym = TreeInfo.symbol(tree);
4283                 Symbol sitesym = TreeInfo.symbol(tree.selected);
4284                 if (sym.kind == TYP &amp;&amp; sitesym.kind == PCK) {
4285                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4286                 } else {
4287                     super.visitSelect(tree);
4288                 }
4289             }
4290 
4291             @Override
4292             public void visitAnnotation(JCAnnotation tree) {
4293                 if (tree.attribute.type.tsym.getAnnotation(java.lang.annotation.Documented.class) != null)
4294                     super.visitAnnotation(tree);
4295             }
4296 
4297         }.scan(check);
4298     }
4299         //where:
4300         private ExportsDirective findExport(PackageSymbol pack) {
4301             for (ExportsDirective d : pack.modle.exports) {
4302                 if (d.packge == pack)
4303                     return d;
4304             }
4305 
4306             return null;
4307         }
4308         private boolean isAPISymbol(Symbol sym) {
4309             while (sym.kind != PCK) {
4310                 if ((sym.flags() &amp; Flags.PUBLIC) == 0 &amp;&amp; (sym.flags() &amp; Flags.PROTECTED) == 0) {
4311                     return false;
4312                 }
4313                 sym = sym.owner;
4314             }
4315             return true;
4316         }
4317         private void checkVisible(DiagnosticPosition pos, Symbol what, PackageSymbol inPackage, boolean inSuperType) {
4318             if (!isAPISymbol(what) &amp;&amp; !inSuperType) { //package private/private element
4319                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessible(kindName(what), what, what.packge().modle));
4320                 return ;
4321             }
4322 
4323             PackageSymbol whatPackage = what.packge();
4324             ExportsDirective whatExport = findExport(whatPackage);
4325             ExportsDirective inExport = findExport(inPackage);
4326 
4327             if (whatExport == null) { //package not exported:
4328                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexported(kindName(what), what, what.packge().modle));
4329                 return ;
4330             }
4331 
4332             if (whatExport.modules != null) {
4333                 if (inExport.modules == null || !whatExport.modules.containsAll(inExport.modules)) {
4334                     log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexportedQualified(kindName(what), what, what.packge().modle));
4335                 }
4336             }
4337 
4338             if (whatPackage.modle != inPackage.modle &amp;&amp; whatPackage.modle != syms.java_base) {
4339                 //check that relativeTo.modle requires transitive what.modle, somehow:
4340                 List&lt;ModuleSymbol&gt; todo = List.of(inPackage.modle);
4341 
4342                 while (todo.nonEmpty()) {
4343                     ModuleSymbol current = todo.head;
4344                     todo = todo.tail;
4345                     if (current == whatPackage.modle)
4346                         return ; //OK
4347                     if ((current.flags() &amp; Flags.AUTOMATIC_MODULE) != 0)
4348                         continue; //for automatic modules, don&#39;t look into their dependencies
4349                     for (RequiresDirective req : current.requires) {
4350                         if (req.isTransitive()) {
4351                             todo = todo.prepend(req.module);
4352                         }
4353                     }
4354                 }
4355 
4356                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleNotRequiredTransitive(kindName(what), what, what.packge().modle));
4357             }
4358         }
4359 
4360     void checkModuleExists(final DiagnosticPosition pos, ModuleSymbol msym) {
4361         if (msym.kind != MDL) {
4362             deferredLintHandler.report(() -&gt; {
4363                 if (lint.isEnabled(LintCategory.MODULE))
4364                     log.warning(LintCategory.MODULE, pos, Warnings.ModuleNotFound(msym));
4365             });
4366         }
4367     }
4368 
4369     void checkPackageExistsForOpens(final DiagnosticPosition pos, PackageSymbol packge) {
4370         if (packge.members().isEmpty() &amp;&amp;
4371             ((packge.flags() &amp; Flags.HAS_RESOURCE) == 0)) {
4372             deferredLintHandler.report(() -&gt; {
4373                 if (lint.isEnabled(LintCategory.OPENS))
4374                     log.warning(pos, Warnings.PackageEmptyOrNotFound(packge));
4375             });
4376         }
4377     }
4378 
4379     void checkModuleRequires(final DiagnosticPosition pos, final RequiresDirective rd) {
4380         if ((rd.module.flags() &amp; Flags.AUTOMATIC_MODULE) != 0) {
4381             deferredLintHandler.report(() -&gt; {
4382                 if (rd.isTransitive() &amp;&amp; lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {
4383                     log.warning(pos, Warnings.RequiresTransitiveAutomatic);
4384                 } else if (lint.isEnabled(LintCategory.REQUIRES_AUTOMATIC)) {
4385                     log.warning(pos, Warnings.RequiresAutomatic);
4386                 }
4387             });
4388         }
4389     }
4390 
4391 }
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
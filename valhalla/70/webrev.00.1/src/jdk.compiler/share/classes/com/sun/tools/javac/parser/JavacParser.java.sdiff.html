<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;

  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 

  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;

  59 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  60 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  61 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  62 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  63 
  64 /** The parser maps a token sequence into an abstract syntax
  65  *  tree. It operates by recursive descent, with code derived
  66  *  systematically from an LL(1) grammar. For efficiency reasons, an
  67  *  operator precedence scheme is used for parsing binary operation
  68  *  expressions.
  69  *
  70  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  71  *  If you write code that depends on this, you do so at your own risk.
  72  *  This code and its internal interfaces are subject to change or
  73  *  deletion without notice.&lt;/b&gt;
  74  */
  75 public class JavacParser implements Parser {
  76 
  77     /** The number of precedence levels of infix operators.
  78      */
</pre>
<hr />
<pre>
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);

 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);
 189     }
 190 
 191     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 192         return  keepEndPositions
 193                 ? new SimpleEndPosTable(this)
 194                 : new EmptyEndPosTable(this);
 195     }
 196 
 197     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 198         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 199     }
 200 
 201     /** Switch: should we fold strings?
 202      */
 203     boolean allowStringFolding;
 204 




 205     /** Switch: should we keep docComments?
 206      */
 207     boolean keepDocComments;
 208 
 209     /** Switch: should we keep line table?
 210      */
 211     boolean keepLineMap;
 212 
 213     /** Switch: is &quot;this&quot; allowed as an identifier?
 214      * This is needed to parse receiver types.
 215      */
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
</pre>
<hr />
<pre>
 280 
 281     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 282         return peekToken(0, tk1, tk2);
 283     }
 284 
 285     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 286         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 287                 tk2.accepts(S.token(lookahead + 2).kind);
 288     }
 289 
 290     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 291         return peekToken(0, tk1, tk2, tk3);
 292     }
 293 
 294     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 295         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 296                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 297                 tk3.accepts(S.token(lookahead + 3).kind);
 298     }
 299 







 300     @SuppressWarnings(&quot;unchecked&quot;)
 301     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 302         return peekToken(0, kinds);
 303     }
 304 
 305     @SuppressWarnings(&quot;unchecked&quot;)
 306     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 307         for (; lookahead &lt; kinds.length ; lookahead++) {
 308             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 309                 return false;
 310             }
 311         }
 312         return true;
 313     }
 314 
 315     /* ---------- error recovery -------------- */
 316 
 317     private JCErroneous errorTree;
 318 
 319     /** Skip forward until a suitable stop token is found.
</pre>
<hr />
<pre>
 449 
 450     /** If next input token matches given token, skip it, otherwise report
 451      *  an error.
 452      */
 453     public void accept(TokenKind tk) {
 454         accept(tk, Errors::Expected);
 455     }
 456 
 457     /** If next input token matches given token, skip it, otherwise report
 458      *  an error.
 459      */
 460     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 461         if (token.kind == tk) {
 462             nextToken();
 463         } else {
 464             setErrorEndPos(token.pos);
 465             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 466         }
 467     }
 468 
















 469     /** Report an illegal start of expression/type error at given position.
 470      */
 471     JCExpression illegal(int pos) {
 472         setErrorEndPos(pos);
 473         if ((mode &amp; EXPR) != 0)
 474             return syntaxError(pos, Errors.IllegalStartOfExpr);
 475         else
 476             return syntaxError(pos, Errors.IllegalStartOfType);
 477 
 478     }
 479 
 480     /** Report an illegal start of expression/type error at current position.
 481      */
 482     JCExpression illegal() {
 483         return illegal(token.pos);
 484     }
 485 
 486     /** Diagnose a modifier flag from the set, if any. */
 487     protected void checkNoMods(long mods) {
 488         if (mods != 0) {
</pre>
<hr />
<pre>
1092                 selectTypeMode();
1093                 return typeArgument();
1094             } else
1095                 return illegal();
1096         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1097             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1098                 TokenKind tk = token.kind;
1099                 nextToken();
1100                 selectExprMode();
1101                 if (tk == SUB &amp;&amp;
1102                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1103                     token.radix() == 10) {
1104                     selectExprMode();
1105                     t = literal(names.hyphen, pos);
1106                 } else {
1107                     t = term3();
1108                     return F.at(pos).Unary(unoptag(tk), t);
1109                 }
1110             } else return illegal();
1111             break;















1112         case LPAREN:
1113             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1114                 ParensResult pres = analyzeParens();
1115                 switch (pres) {
1116                     case CAST:
1117                        accept(LPAREN);
1118                        selectTypeMode();
1119                        int pos1 = pos;
1120                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1121                        while (token.kind == AMP) {
1122                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1123                            accept(AMP);
1124                            targets = targets.prepend(parseType());
1125                        }
1126                        if (targets.length() &gt; 1) {
1127                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1128                        }
1129                        accept(RPAREN);
1130                        selectExprMode();
1131                        JCExpression t1 = term3();
</pre>
<hr />
<pre>
1260                         break loop;
1261                     case LPAREN:
1262                         if ((mode &amp; EXPR) != 0) {
1263                             selectExprMode();
1264                             t = arguments(typeArgs, t);
1265                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1266                             typeArgs = null;
1267                         }
1268                         break loop;
1269                     case DOT:
1270                         nextToken();
1271                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1272                             return illegal();
1273                         }
1274                         int oldmode = mode;
1275                         mode &amp;= ~NOPARAMS;
1276                         typeArgs = typeArgumentsOpt(EXPR);
1277                         mode = oldmode;
1278                         if ((mode &amp; EXPR) != 0) {
1279                             switch (token.kind) {






1280                             case CLASS:
1281                                 if (typeArgs != null) return illegal();
1282                                 selectExprMode();
1283                                 t = to(F.at(pos).Select(t, names._class));
1284                                 nextToken();
1285                                 break loop;
1286                             case THIS:
1287                                 if (typeArgs != null) return illegal();
1288                                 selectExprMode();
1289                                 t = to(F.at(pos).Select(t, names._this));
1290                                 nextToken();
1291                                 break loop;
1292                             case SUPER:
1293                                 selectExprMode();
1294                                 t = to(F.at(pos).Select(t, names._super));
1295                                 t = superSuffix(typeArgs, t);
1296                                 typeArgs = null;
1297                                 break loop;
1298                             case NEW:
1299                                 if (typeArgs != null) return illegal();
</pre>
<hr />
<pre>
1309 
1310                         List&lt;JCAnnotation&gt; tyannos = null;
1311                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1312                             tyannos = typeAnnotationsOpt();
1313                         }
1314                         // typeArgs saved for next loop iteration.
1315                         t = toP(F.at(pos).Select(t, ident()));
1316                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1317                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1318                         }
1319                         break;
1320                     case ELLIPSIS:
1321                         if (this.permitTypeAnnotationsPushBack) {
1322                             this.typeAnnotationsPushedBack = annos;
1323                         } else if (annos.nonEmpty()) {
1324                             // Don&#39;t return here -- error recovery attempt
1325                             illegal(annos.head.pos);
1326                         }
1327                         break loop;
1328                     case LT:
<span class="line-modified">1329                         if ((mode &amp; TYPE) == 0 &amp;&amp; isUnboundMemberRef()) {</span>
<span class="line-modified">1330                             //this is an unbound method reference whose qualifier</span>
<span class="line-modified">1331                             //is a generic type i.e. A&lt;S&gt;::m</span>

1332                             int pos1 = token.pos;
1333                             accept(LT);
1334                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1335                             args.append(typeArgument());
1336                             while (token.kind == COMMA) {
1337                                 nextToken();
1338                                 args.append(typeArgument());
1339                             }
1340                             accept(GT);
1341                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1342                             while (token.kind == DOT) {
1343                                 nextToken();






1344                                 selectTypeMode();
1345                                 t = toP(F.at(token.pos).Select(t, ident()));
1346                                 t = typeArgumentsOpt(t);
1347                             }
1348                             t = bracketsOpt(t);
1349                             if (token.kind != COLCOL) {
1350                                 //method reference expected here
1351                                 t = illegal();
1352                             }
1353                             selectExprMode();
1354                             return term3Rest(t, typeArgs);
1355                         }
1356                         break loop;
1357                     default:
1358                         break loop;
1359                     }
1360                 }
1361             }
1362             if (typeArgs != null) illegal();
1363             t = typeArgumentsOpt(t);
</pre>
<hr />
<pre>
1488                         }
1489                         return t;
1490                     }
1491                     mode = oldmode;
1492                 }
1493                 if ((mode &amp; EXPR) != 0) {
1494                     selectExprMode();
1495                     JCExpression t1 = term();
1496                     t = to(F.at(pos1).Indexed(t, t1));
1497                 }
1498                 accept(RBRACKET);
1499             } else if (token.kind == DOT) {
1500                 nextToken();
1501                 typeArgs = typeArgumentsOpt(EXPR);
1502                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1503                     selectExprMode();
1504                     t = to(F.at(pos1).Select(t, names._super));
1505                     nextToken();
1506                     t = arguments(typeArgs, t);
1507                     typeArgs = null;
<span class="line-modified">1508                 } else if (token.kind == NEW &amp;&amp; (mode &amp; EXPR) != 0) {</span>
1509                     if (typeArgs != null) return illegal();
1510                     selectExprMode();
1511                     int pos2 = token.pos;
1512                     nextToken();
1513                     if (token.kind == LT) typeArgs = typeArguments(false);
1514                     t = innerCreator(pos2, typeArgs, t);
1515                     typeArgs = null;
1516                 } else {
1517                     List&lt;JCAnnotation&gt; tyannos = null;
1518                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1519                         // is the mode check needed?
1520                         tyannos = typeAnnotationsOpt();
1521                     }
1522                     t = toP(F.at(pos1).Select(t, ident(true)));
1523                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1524                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1525                     }
1526                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1527                     typeArgs = null;
1528                 }
</pre>
<hr />
<pre>
1535                 if (!annos.isEmpty()) {
1536                     if (permitTypeAnnotationsPushBack)
1537                         typeAnnotationsPushedBack = annos;
1538                     else
1539                         return illegal(annos.head.pos);
1540                 }
1541                 break;
1542             }
1543         }
1544         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1545             selectExprMode();
1546             t = to(F.at(token.pos).Unary(
1547                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1548             nextToken();
1549         }
1550         return toP(t);
1551     }
1552 
1553     /**
1554      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
<span class="line-modified">1555      * method reference or a binary expression. To disambiguate, look for a</span>

1556      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1557      */
1558     @SuppressWarnings(&quot;fallthrough&quot;)
<span class="line-modified">1559     boolean isUnboundMemberRef() {</span>
1560         int pos = 0, depth = 0;
1561         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1562             switch (t.kind) {
1563                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1564                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1565                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1566                 case DOUBLE: case BOOLEAN: case CHAR:
1567                 case MONKEYS_AT:
1568                     break;
1569 
1570                 case LPAREN:
1571                     // skip annotation values
1572                     int nesting = 0;
1573                     for (; ; pos++) {
1574                         TokenKind tk2 = S.token(pos).kind;
1575                         switch (tk2) {
1576                             case EOF:
1577                                 return false;
1578                             case LPAREN:
1579                                 nesting++;
</pre>
<hr />
<pre>
1661                     // based on subsequent token.
1662                     switch (S.token(lookahead + 1).kind) {
1663                         /*case PLUSPLUS: case SUBSUB: */
1664                         case BANG: case TILDE:
1665                         case LPAREN: case THIS: case SUPER:
1666                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1667                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1668                         case TRUE: case FALSE: case NULL:
1669                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1670                         case SWITCH:
1671                         case BYTE: case SHORT: case CHAR: case INT:
1672                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1673                             return ParensResult.CAST;
1674                         default:
1675                             return defaultResult;
1676                     }
1677                 case UNDERSCORE:
1678                 case ASSERT:
1679                 case ENUM:
1680                 case IDENTIFIER:
<span class="line-modified">1681                     if (peekToken(lookahead, LAX_IDENTIFIER)) {</span>
<span class="line-modified">1682                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda</span>
1683                         return ParensResult.EXPLICIT_LAMBDA;
1684                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1685                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1686                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1687                                                       : ParensResult.PARENS;
1688                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1689                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1690                     }
1691                     type = false;
1692                     break;
1693                 case FINAL:
1694                 case ELLIPSIS:
1695                     //those can only appear in explicit lambdas
1696                     return ParensResult.EXPLICIT_LAMBDA;
1697                 case MONKEYS_AT:
1698                     type = true;
1699                     lookahead += 1; //skip &#39;@&#39;
1700                     while (peekToken(lookahead, DOT)) {
1701                         lookahead += 2;
1702                     }
</pre>
<hr />
<pre>
1738                         break;
1739                     } else {
1740                         return ParensResult.PARENS;
1741                     }
1742                 case LT:
1743                     depth++; break;
1744                 case GTGTGT:
1745                     depth--;
1746                 case GTGT:
1747                     depth--;
1748                 case GT:
1749                     depth--;
1750                     if (depth == 0) {
1751                         if (peekToken(lookahead, RPAREN) ||
1752                                 peekToken(lookahead, AMP)) {
1753                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1754                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1755                             return ParensResult.CAST;
1756                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1757                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||


1758                                 peekToken(lookahead, ELLIPSIS)) {
1759                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1760                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1761                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1762                             return ParensResult.EXPLICIT_LAMBDA;
1763                         }
1764                         //it looks a type, but could still be (i) a cast to generic type,
1765                         //(ii) an unbound method reference or (iii) an explicit lambda
1766                         type = true;
1767                         break;
1768                     } else if (depth &lt; 0) {
1769                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1770                         return ParensResult.PARENS;
1771                     }
1772                     break;
1773                 default:
1774                     //this includes EOF
1775                     return defaultResult;
1776             }
1777         }
</pre>
<hr />
<pre>
2134 
2135     private JCExpression bracketsOptCont(JCExpression t, int pos,
2136             List&lt;JCAnnotation&gt; annotations) {
2137         accept(RBRACKET);
2138         t = bracketsOpt(t);
2139         t = toP(F.at(pos).TypeArray(t));
2140         if (annotations.nonEmpty()) {
2141             t = toP(F.at(pos).AnnotatedType(annotations, t));
2142         }
2143         return t;
2144     }
2145 
2146     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2147      *  BracketsSuffixType =
2148      */
2149     JCExpression bracketsSuffix(JCExpression t) {
2150         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2151             selectExprMode();
2152             int pos = token.pos;
2153             nextToken();
<span class="line-modified">2154             accept(CLASS);</span>
2155             if (token.pos == endPosTable.errorEndPos) {
2156                 // error recovery
2157                 Name name;
2158                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2159                     name = token.name();
2160                     nextToken();
2161                 } else {
2162                     name = names.error;
2163                 }
2164                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2165             } else {
2166                 Tag tag = t.getTag();
2167                 // Type annotations are illegal on class literals. Annotated non array class literals
2168                 // are complained about directly in term3(), Here check for type annotations on dimensions
2169                 // taking care to handle some interior dimension(s) being annotated.
2170                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2171                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
<span class="line-modified">2172                 t = toP(F.at(pos).Select(t, names._class));</span>
2173             }
2174         } else if ((mode &amp; TYPE) != 0) {
2175             if (token.kind != COLCOL) {
2176                 selectTypeMode();
2177             }
2178         } else if (token.kind != COLCOL) {
2179             syntaxError(token.pos, Errors.DotClassExpected);
2180         }
2181         return t;
2182     }
2183 
2184     /**
2185      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2186      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2187      */
2188     JCExpression memberReferenceSuffix(JCExpression t) {
2189         int pos1 = token.pos;
2190         accept(COLCOL);
2191         return memberReferenceSuffix(pos1, t);
2192     }
</pre>
<hr />
<pre>
2197         List&lt;JCExpression&gt; typeArgs = null;
2198         if (token.kind == LT) {
2199             typeArgs = typeArguments(false);
2200         }
2201         Name refName;
2202         ReferenceMode refMode;
2203         if (token.kind == NEW) {
2204             refMode = ReferenceMode.NEW;
2205             refName = names.init;
2206             nextToken();
2207         } else {
2208             refMode = ReferenceMode.INVOKE;
2209             refName = ident();
2210         }
2211         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2212     }
2213 
2214     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2215      */
2216     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
<span class="line-modified">2217         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();</span>
<span class="line-modified">2218 </span>



2219         switch (token.kind) {
2220         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2221         case DOUBLE: case BOOLEAN:




2222             if (typeArgs == null) {
2223                 if (newAnnotations.isEmpty()) {
2224                     return arrayCreatorRest(newpos, basicType());
2225                 } else {
2226                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2227                 }
2228             }
2229             break;
2230         default:
2231         }
2232         JCExpression t = qualident(true);
2233 
2234         int oldmode = mode;
2235         selectTypeMode();
2236         boolean diamondFound = false;
2237         int lastTypeargsPos = -1;
2238         if (token.kind == LT) {
2239             lastTypeargsPos = token.pos;
2240             t = typeArguments(t, true);
2241             diamondFound = (mode &amp; DIAMOND) != 0;
</pre>
<hr />
<pre>
2270             JCExpression e = arrayCreatorRest(newpos, t);
2271             if (diamondFound) {
2272                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2273                 return toP(F.at(newpos).Erroneous(List.of(e)));
2274             }
2275             else if (typeArgs != null) {
2276                 int pos = newpos;
2277                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2278                     // note: this should always happen but we should
2279                     // not rely on this as the parser is continuously
2280                     // modified to improve error recovery.
2281                     pos = typeArgs.head.pos;
2282                 }
2283                 setErrorEndPos(S.prevToken().endPos);
2284                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2285                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2286                 return toP(err);
2287             }
2288             return e;
2289         } else if (token.kind == LPAREN) {



2290             // handle type annotations for instantiations and anonymous classes
2291             if (newAnnotations.nonEmpty()) {
2292                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2293             }
<span class="line-modified">2294             return classCreatorRest(newpos, null, typeArgs, t);</span>





2295         } else {
2296             setErrorEndPos(token.pos);
2297             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2298             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2299             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2300         }
2301     }
2302 
2303     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2304      */
2305     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2306         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2307 
2308         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2309 
2310         if (newAnnotations.nonEmpty()) {
2311             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2312         }
2313 
2314         if (token.kind == LT) {
2315             int oldmode = mode;
2316             t = typeArguments(t, true);
2317             mode = oldmode;
2318         }
<span class="line-modified">2319         return classCreatorRest(newpos, encl, typeArgs, t);</span>
2320     }
2321 
2322     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2323      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2324      */
2325     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2326         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2327 
2328         accept(LBRACKET);
2329         if (token.kind == RBRACKET) {
2330             accept(RBRACKET);
2331             elemtype = bracketsOpt(elemtype, annos);
2332             if (token.kind == LBRACE) {
2333                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2334                 if (annos.nonEmpty()) {
2335                     // when an array initializer is present then
2336                     // the parsed annotations should target the
2337                     // new array tree
2338                     // bracketsOpt inserts the annotation in
2339                     // elemtype, and it needs to be corrected
</pre>
<hr />
<pre>
2381             if (token.kind == LBRACE) {
2382                 elems = arrayInitializerElements(newpos, elemtype);
2383             }
2384 
2385             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2386             na.dimAnnotations = dimAnnotations.toList();
2387 
2388             if (elems != null) {
2389                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2390             }
2391 
2392             return na;
2393         }
2394     }
2395 
2396     /** ClassCreatorRest = Arguments [ClassBody]
2397      */
2398     JCNewClass classCreatorRest(int newpos,
2399                                   JCExpression encl,
2400                                   List&lt;JCExpression&gt; typeArgs,
<span class="line-modified">2401                                   JCExpression t)</span>

2402     {
2403         List&lt;JCExpression&gt; args = arguments();
2404         JCClassDecl body = null;
2405         if (token.kind == LBRACE) {
2406             int pos = token.pos;
2407             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
<span class="line-modified">2408             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);</span>
2409             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2410         }
<span class="line-modified">2411         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));</span>

2412     }
2413 
2414     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2415      */
2416     JCExpression arrayInitializer(int newpos, JCExpression t) {
2417         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2418         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2419     }
2420 
2421     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2422         accept(LBRACE);
2423         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2424         if (token.kind == COMMA) {
2425             nextToken();
2426         } else if (token.kind != RBRACE) {
2427             elems.append(variableInitializer());
2428             while (token.kind == COMMA) {
2429                 nextToken();
2430                 if (token.kind == RBRACE) break;
2431                 elems.append(variableInitializer());
</pre>
<hr />
<pre>
2522                 error = Errors.ClassNotAllowed;
2523                 break;
2524             case VARDEF:
2525                 error = Errors.VariableNotAllowed;
2526                 break;
2527             }
2528             if (error != null) {
2529                 log.error(DiagnosticFlag.SYNTAX, first, error);
2530                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2531                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2532             }
2533             return first;
2534         }
2535     }
2536 
2537     /**This method parses a statement appearing inside a block.
2538      */
2539     @SuppressWarnings(&quot;fallthrough&quot;)
2540     List&lt;JCStatement&gt; blockStatement() {
2541         //todo: skip to anchor on error(?)

2542         Comment dc;
2543         int pos = token.pos;
2544         switch (token.kind) {
2545         case RBRACE: case CASE: case DEFAULT: case EOF:
2546             return List.nil();
2547         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2548         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2549         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2550         case ASSERT:
2551             return List.of(parseSimpleStatement());

2552         case MONKEYS_AT:
2553         case FINAL: {
2554             dc = token.comment(CommentStyle.JAVADOC);
2555             JCModifiers mods = modifiersOpt();
2556             if (token.kind == INTERFACE ||
2557                 token.kind == CLASS ||
2558                 token.kind == ENUM ||
2559                 isRecordStart()) {
2560                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2561             } else {
2562                 JCExpression t = parseType(true);
2563                 return localVariableDeclarations(mods, t);
2564             }
2565         }
2566         case ABSTRACT: case STRICTFP: {
2567             dc = token.comment(CommentStyle.JAVADOC);
2568             JCModifiers mods = modifiersOpt();
2569             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2570         }
2571         case INTERFACE:
</pre>
<hr />
<pre>
2970             nextToken();
2971             pos = token.pos;
2972             JCExpression t = parseExpression();
2973             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
2974             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
2975         }
2976         return stats;
2977     }
2978 
2979     /** ForInit = StatementExpression MoreStatementExpressions
2980      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
2981      */
2982     List&lt;JCStatement&gt; forInit() {
2983         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2984         int pos = token.pos;
2985         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
2986             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
2987         } else {
2988             JCExpression t = term(EXPR | TYPE);
2989             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
<span class="line-modified">2990                 return variableDeclarators(modifiersOpt(), t, stats, true).toList();</span>



2991             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
2992                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
2993                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
2994             } else {
2995                 return moreStatementExpressions(pos, t, stats).toList();
2996             }
2997         }
2998     }
2999 
3000     /** ForUpdate = StatementExpression MoreStatementExpressions
3001      */
3002     List&lt;JCExpressionStatement&gt; forUpdate() {
3003         return moreStatementExpressions(token.pos,
3004                                         parseExpression(),
3005                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3006     }
3007 
3008     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3009      *
3010      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
</pre>
<hr />
<pre>
3040     }
3041     protected JCModifiers modifiersOpt(JCModifiers partial) {
3042         long flags;
3043         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3044         int pos;
3045         if (partial == null) {
3046             flags = 0;
3047             pos = token.pos;
3048         } else {
3049             flags = partial.flags;
3050             annotations.appendList(partial.annotations);
3051             pos = partial.pos;
3052         }
3053         if (token.deprecatedFlag()) {
3054             flags |= Flags.DEPRECATED;
3055         }
3056         int lastPos;
3057     loop:
3058         while (true) {
3059             long flag;

3060             switch (token.kind) {
3061             case PRIVATE     : flag = Flags.PRIVATE; break;
3062             case PROTECTED   : flag = Flags.PROTECTED; break;
3063             case PUBLIC      : flag = Flags.PUBLIC; break;
3064             case STATIC      : flag = Flags.STATIC; break;
3065             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3066             case FINAL       : flag = Flags.FINAL; break;
3067             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3068             case NATIVE      : flag = Flags.NATIVE; break;

3069             case VOLATILE    : flag = Flags.VOLATILE; break;
3070             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3071             case STRICTFP    : flag = Flags.STRICTFP; break;
3072             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3073             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3074             case ERROR       : flag = 0; nextToken(); break;
3075             default: break loop;
3076             }
3077             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3078             lastPos = token.pos;
3079             nextToken();
3080             if (flag == Flags.ANNOTATION) {
3081                 if (token.kind != INTERFACE) {
3082                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3083                     // if first modifier is an annotation, set pos to annotation&#39;s.
3084                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3085                         pos = ann.pos;
<span class="line-modified">3086                     annotations.append(ann);</span>
<span class="line-modified">3087                     flag = 0;</span>





3088                 }
3089             }
3090             flags |= flag;
3091         }
3092         switch (token.kind) {
3093         case ENUM: flags |= Flags.ENUM; break;
3094         case INTERFACE: flags |= Flags.INTERFACE; break;
3095         default: break;
3096         }
3097 
3098         /* A modifiers tree with no modifier tokens or annotations
3099          * has no text position. */
3100         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3101             pos = Position.NOPOS;
3102 





3103         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3104         if (pos != Position.NOPOS)
3105             storeEnd(mods, S.prevToken().endPos);
3106         return mods;
3107     }
3108 
3109     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3110      *
3111      * @param pos position of &quot;@&quot; token
3112      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3113      */
3114     JCAnnotation annotation(int pos, Tag kind) {
3115         // accept(AT); // AT consumed by caller
3116         if (kind == Tag.TYPE_ANNOTATION) {
3117             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3118         }
3119         JCTree ident = qualident(false);
3120         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3121         JCAnnotation ann;
3122         if (kind == Tag.ANNOTATION) {
</pre>
<hr />
<pre>
3270                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3271                 } else {
3272                     if(compound)
3273                         //error - &#39;var&#39; in compound local var decl
3274                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3275                     startPos = TreeInfo.getStartPos(mods);
3276                     if (startPos == Position.NOPOS)
3277                         startPos = TreeInfo.getStartPos(type);
3278                     //implicit type
3279                     type = null;
3280                 }
3281             }
3282         }
3283         JCVariableDecl result =
3284             toP(F.at(pos).VarDef(mods, name, type, init));
3285         attach(result, dc);
3286         result.startPos = startPos;
3287         return result;
3288     }
3289 




































3290     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3291         switch (e.getTag()) {
3292             case IDENT:
3293                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3294             case TYPEARRAY:
3295                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3296             default:
3297                 return null;
3298         }
3299     }
3300 
3301     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3302         if (name == names.var) {
3303             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3304                 return Source.JDK10;
3305             } else if (shouldWarn) {
3306                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3307             }
3308         }
3309         if (name == names.yield) {
</pre>
</td>
<td>
<hr />
<pre>
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
<span class="line-added">  37 import com.sun.tools.javac.code.Flags.Flag;</span>
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.parser.Tokens.*;
  40 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.tree.JCTree.*;
  46 import com.sun.tools.javac.util.*;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.List;
  51 
<span class="line-added">  52 import static com.sun.tools.javac.code.Flags.asFlagSet;</span>
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  59 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  60 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
<span class="line-added">  61 import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;</span>
  62 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  63 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  64 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  65 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  66 
  67 /** The parser maps a token sequence into an abstract syntax
  68  *  tree. It operates by recursive descent, with code derived
  69  *  systematically from an LL(1) grammar. For efficiency reasons, an
  70  *  operator precedence scheme is used for parsing binary operation
  71  *  expressions.
  72  *
  73  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  74  *  If you write code that depends on this, you do so at your own risk.
  75  *  This code and its internal interfaces are subject to change or
  76  *  deletion without notice.&lt;/b&gt;
  77  */
  78 public class JavacParser implements Parser {
  79 
  80     /** The number of precedence levels of infix operators.
  81      */
</pre>
<hr />
<pre>
 170                      boolean keepDocComments,
 171                      boolean keepLineMap,
 172                      boolean keepEndPositions,
 173                      boolean parseModuleInfo) {
 174         this.S = S;
 175         nextToken(); // prime the pump
 176         this.F = fac.F;
 177         this.log = fac.log;
 178         this.names = fac.names;
 179         this.source = fac.source;
 180         this.preview = fac.preview;
 181         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 182         this.keepDocComments = keepDocComments;
 183         this.parseModuleInfo = parseModuleInfo;
 184         docComments = newDocCommentTable(keepDocComments, fac);
 185         this.keepLineMap = keepLineMap;
 186         this.errorTree = F.Erroneous();
 187         endPosTable = newEndPosTable(keepEndPositions);
 188         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 189                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
<span class="line-added"> 190         this.allowWithFieldOperator = fac.options.isSet(&quot;allowWithFieldOperator&quot;);</span>
 191         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 192                 Feature.RECORDS.allowedInSource(source);
 193     }
 194 
 195     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 196         return  keepEndPositions
 197                 ? new SimpleEndPosTable(this)
 198                 : new EmptyEndPosTable(this);
 199     }
 200 
 201     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 202         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 203     }
 204 
 205     /** Switch: should we fold strings?
 206      */
 207     boolean allowStringFolding;
 208 
<span class="line-added"> 209     /** Switch: should we allow withField operator at source level ?</span>
<span class="line-added"> 210     */</span>
<span class="line-added"> 211     boolean allowWithFieldOperator;</span>
<span class="line-added"> 212 </span>
 213     /** Switch: should we keep docComments?
 214      */
 215     boolean keepDocComments;
 216 
 217     /** Switch: should we keep line table?
 218      */
 219     boolean keepLineMap;
 220 
 221     /** Switch: is &quot;this&quot; allowed as an identifier?
 222      * This is needed to parse receiver types.
 223      */
 224     boolean allowThisIdent;
 225 
 226     /** Switch: is yield statement allowed in this source level?
 227      */
 228     boolean allowYieldStatement;
 229 
 230     /** Switch: are records allowed in this source level?
 231      */
 232     boolean allowRecords;
</pre>
<hr />
<pre>
 288 
 289     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 290         return peekToken(0, tk1, tk2);
 291     }
 292 
 293     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 294         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 295                 tk2.accepts(S.token(lookahead + 2).kind);
 296     }
 297 
 298     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 299         return peekToken(0, tk1, tk2, tk3);
 300     }
 301 
 302     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 303         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 304                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 305                 tk3.accepts(S.token(lookahead + 3).kind);
 306     }
 307 
<span class="line-added"> 308     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3, Filter&lt;TokenKind&gt; tk4) {</span>
<span class="line-added"> 309         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;</span>
<span class="line-added"> 310                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;</span>
<span class="line-added"> 311                 tk3.accepts(S.token(lookahead + 3).kind) &amp;&amp;</span>
<span class="line-added"> 312                 tk4.accepts(S.token(lookahead + 4).kind);</span>
<span class="line-added"> 313     }</span>
<span class="line-added"> 314 </span>
 315     @SuppressWarnings(&quot;unchecked&quot;)
 316     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 317         return peekToken(0, kinds);
 318     }
 319 
 320     @SuppressWarnings(&quot;unchecked&quot;)
 321     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 322         for (; lookahead &lt; kinds.length ; lookahead++) {
 323             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 324                 return false;
 325             }
 326         }
 327         return true;
 328     }
 329 
 330     /* ---------- error recovery -------------- */
 331 
 332     private JCErroneous errorTree;
 333 
 334     /** Skip forward until a suitable stop token is found.
</pre>
<hr />
<pre>
 464 
 465     /** If next input token matches given token, skip it, otherwise report
 466      *  an error.
 467      */
 468     public void accept(TokenKind tk) {
 469         accept(tk, Errors::Expected);
 470     }
 471 
 472     /** If next input token matches given token, skip it, otherwise report
 473      *  an error.
 474      */
 475     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 476         if (token.kind == tk) {
 477             nextToken();
 478         } else {
 479             setErrorEndPos(token.pos);
 480             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 481         }
 482     }
 483 
<span class="line-added"> 484     /** If next input token matches one of the two given tokens, skip it, otherwise report</span>
<span class="line-added"> 485      *  an error.</span>
<span class="line-added"> 486      *</span>
<span class="line-added"> 487      * @return The actual token kind.</span>
<span class="line-added"> 488      */</span>
<span class="line-added"> 489     public TokenKind accept2(TokenKind tk1, TokenKind tk2) {</span>
<span class="line-added"> 490         TokenKind returnValue = token.kind;</span>
<span class="line-added"> 491         if (token.kind == tk1 || token.kind == tk2) {</span>
<span class="line-added"> 492             nextToken();</span>
<span class="line-added"> 493         } else {</span>
<span class="line-added"> 494             setErrorEndPos(token.pos);</span>
<span class="line-added"> 495             reportSyntaxError(S.prevToken().endPos, Errors.Expected2(tk1, tk2));</span>
<span class="line-added"> 496         }</span>
<span class="line-added"> 497         return returnValue;</span>
<span class="line-added"> 498     }</span>
<span class="line-added"> 499 </span>
 500     /** Report an illegal start of expression/type error at given position.
 501      */
 502     JCExpression illegal(int pos) {
 503         setErrorEndPos(pos);
 504         if ((mode &amp; EXPR) != 0)
 505             return syntaxError(pos, Errors.IllegalStartOfExpr);
 506         else
 507             return syntaxError(pos, Errors.IllegalStartOfType);
 508 
 509     }
 510 
 511     /** Report an illegal start of expression/type error at current position.
 512      */
 513     JCExpression illegal() {
 514         return illegal(token.pos);
 515     }
 516 
 517     /** Diagnose a modifier flag from the set, if any. */
 518     protected void checkNoMods(long mods) {
 519         if (mods != 0) {
</pre>
<hr />
<pre>
1123                 selectTypeMode();
1124                 return typeArgument();
1125             } else
1126                 return illegal();
1127         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1128             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1129                 TokenKind tk = token.kind;
1130                 nextToken();
1131                 selectExprMode();
1132                 if (tk == SUB &amp;&amp;
1133                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1134                     token.radix() == 10) {
1135                     selectExprMode();
1136                     t = literal(names.hyphen, pos);
1137                 } else {
1138                     t = term3();
1139                     return F.at(pos).Unary(unoptag(tk), t);
1140                 }
1141             } else return illegal();
1142             break;
<span class="line-added">1143         case WITHFIELD:</span>
<span class="line-added">1144             if (!allowWithFieldOperator) {</span>
<span class="line-added">1145                 log.error(pos, Errors.WithFieldOperatorDisallowed);</span>
<span class="line-added">1146             }</span>
<span class="line-added">1147             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {</span>
<span class="line-added">1148                 nextToken();</span>
<span class="line-added">1149                 accept(LPAREN);</span>
<span class="line-added">1150                 mode = EXPR;</span>
<span class="line-added">1151                 t = term();</span>
<span class="line-added">1152                 accept(COMMA);</span>
<span class="line-added">1153                 mode = EXPR;</span>
<span class="line-added">1154                 JCExpression v = term();</span>
<span class="line-added">1155                 accept(RPAREN);</span>
<span class="line-added">1156                 return F.at(pos).WithField(t, v);</span>
<span class="line-added">1157             } else return illegal();</span>
1158         case LPAREN:
1159             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1160                 ParensResult pres = analyzeParens();
1161                 switch (pres) {
1162                     case CAST:
1163                        accept(LPAREN);
1164                        selectTypeMode();
1165                        int pos1 = pos;
1166                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1167                        while (token.kind == AMP) {
1168                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1169                            accept(AMP);
1170                            targets = targets.prepend(parseType());
1171                        }
1172                        if (targets.length() &gt; 1) {
1173                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1174                        }
1175                        accept(RPAREN);
1176                        selectExprMode();
1177                        JCExpression t1 = term3();
</pre>
<hr />
<pre>
1306                         break loop;
1307                     case LPAREN:
1308                         if ((mode &amp; EXPR) != 0) {
1309                             selectExprMode();
1310                             t = arguments(typeArgs, t);
1311                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1312                             typeArgs = null;
1313                         }
1314                         break loop;
1315                     case DOT:
1316                         nextToken();
1317                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1318                             return illegal();
1319                         }
1320                         int oldmode = mode;
1321                         mode &amp;= ~NOPARAMS;
1322                         typeArgs = typeArgumentsOpt(EXPR);
1323                         mode = oldmode;
1324                         if ((mode &amp; EXPR) != 0) {
1325                             switch (token.kind) {
<span class="line-added">1326                             case DEFAULT:</span>
<span class="line-added">1327                                 if (typeArgs != null) return illegal();</span>
<span class="line-added">1328                                 selectExprMode();</span>
<span class="line-added">1329                                 t = to(F.at(pos).Select(t, names._default));</span>
<span class="line-added">1330                                 nextToken();</span>
<span class="line-added">1331                                 break loop;</span>
1332                             case CLASS:
1333                                 if (typeArgs != null) return illegal();
1334                                 selectExprMode();
1335                                 t = to(F.at(pos).Select(t, names._class));
1336                                 nextToken();
1337                                 break loop;
1338                             case THIS:
1339                                 if (typeArgs != null) return illegal();
1340                                 selectExprMode();
1341                                 t = to(F.at(pos).Select(t, names._this));
1342                                 nextToken();
1343                                 break loop;
1344                             case SUPER:
1345                                 selectExprMode();
1346                                 t = to(F.at(pos).Select(t, names._super));
1347                                 t = superSuffix(typeArgs, t);
1348                                 typeArgs = null;
1349                                 break loop;
1350                             case NEW:
1351                                 if (typeArgs != null) return illegal();
</pre>
<hr />
<pre>
1361 
1362                         List&lt;JCAnnotation&gt; tyannos = null;
1363                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1364                             tyannos = typeAnnotationsOpt();
1365                         }
1366                         // typeArgs saved for next loop iteration.
1367                         t = toP(F.at(pos).Select(t, ident()));
1368                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1369                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1370                         }
1371                         break;
1372                     case ELLIPSIS:
1373                         if (this.permitTypeAnnotationsPushBack) {
1374                             this.typeAnnotationsPushedBack = annos;
1375                         } else if (annos.nonEmpty()) {
1376                             // Don&#39;t return here -- error recovery attempt
1377                             illegal(annos.head.pos);
1378                         }
1379                         break loop;
1380                     case LT:
<span class="line-modified">1381                         if ((mode &amp; TYPE) == 0 &amp;&amp; isParameterizedTypePrefix()) {</span>
<span class="line-modified">1382                             //this is either an unbound method reference whose qualifier</span>
<span class="line-modified">1383                             //is a generic type i.e. A&lt;S&gt;::m or a default value creation of</span>
<span class="line-added">1384                             //the form ValueType&lt;S&gt;.default</span>
1385                             int pos1 = token.pos;
1386                             accept(LT);
1387                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1388                             args.append(typeArgument());
1389                             while (token.kind == COMMA) {
1390                                 nextToken();
1391                                 args.append(typeArgument());
1392                             }
1393                             accept(GT);
1394                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1395                             while (token.kind == DOT) {
1396                                 nextToken();
<span class="line-added">1397                                 if (token.kind == DEFAULT) {</span>
<span class="line-added">1398                                     t =  toP(F.at(token.pos).Select(t, names._default));</span>
<span class="line-added">1399                                     nextToken();</span>
<span class="line-added">1400                                     selectExprMode();</span>
<span class="line-added">1401                                     return term3Rest(t, typeArgs);</span>
<span class="line-added">1402                                 }</span>
1403                                 selectTypeMode();
1404                                 t = toP(F.at(token.pos).Select(t, ident()));
1405                                 t = typeArgumentsOpt(t);
1406                             }
1407                             t = bracketsOpt(t);
1408                             if (token.kind != COLCOL) {
1409                                 //method reference expected here
1410                                 t = illegal();
1411                             }
1412                             selectExprMode();
1413                             return term3Rest(t, typeArgs);
1414                         }
1415                         break loop;
1416                     default:
1417                         break loop;
1418                     }
1419                 }
1420             }
1421             if (typeArgs != null) illegal();
1422             t = typeArgumentsOpt(t);
</pre>
<hr />
<pre>
1547                         }
1548                         return t;
1549                     }
1550                     mode = oldmode;
1551                 }
1552                 if ((mode &amp; EXPR) != 0) {
1553                     selectExprMode();
1554                     JCExpression t1 = term();
1555                     t = to(F.at(pos1).Indexed(t, t1));
1556                 }
1557                 accept(RBRACKET);
1558             } else if (token.kind == DOT) {
1559                 nextToken();
1560                 typeArgs = typeArgumentsOpt(EXPR);
1561                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1562                     selectExprMode();
1563                     t = to(F.at(pos1).Select(t, names._super));
1564                     nextToken();
1565                     t = arguments(typeArgs, t);
1566                     typeArgs = null;
<span class="line-modified">1567                 } else if ((token.kind == NEW) &amp;&amp; (mode &amp; EXPR) != 0) {</span>
1568                     if (typeArgs != null) return illegal();
1569                     selectExprMode();
1570                     int pos2 = token.pos;
1571                     nextToken();
1572                     if (token.kind == LT) typeArgs = typeArguments(false);
1573                     t = innerCreator(pos2, typeArgs, t);
1574                     typeArgs = null;
1575                 } else {
1576                     List&lt;JCAnnotation&gt; tyannos = null;
1577                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1578                         // is the mode check needed?
1579                         tyannos = typeAnnotationsOpt();
1580                     }
1581                     t = toP(F.at(pos1).Select(t, ident(true)));
1582                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1583                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1584                     }
1585                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1586                     typeArgs = null;
1587                 }
</pre>
<hr />
<pre>
1594                 if (!annos.isEmpty()) {
1595                     if (permitTypeAnnotationsPushBack)
1596                         typeAnnotationsPushedBack = annos;
1597                     else
1598                         return illegal(annos.head.pos);
1599                 }
1600                 break;
1601             }
1602         }
1603         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1604             selectExprMode();
1605             t = to(F.at(token.pos).Unary(
1606                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1607             nextToken();
1608         }
1609         return toP(t);
1610     }
1611 
1612     /**
1613      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
<span class="line-modified">1614      * method reference or a default value creation that uses a parameterized type</span>
<span class="line-added">1615      * or a binary expression. To disambiguate, look for a</span>
1616      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1617      */
1618     @SuppressWarnings(&quot;fallthrough&quot;)
<span class="line-modified">1619     boolean isParameterizedTypePrefix() {</span>
1620         int pos = 0, depth = 0;
1621         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1622             switch (t.kind) {
1623                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1624                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1625                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1626                 case DOUBLE: case BOOLEAN: case CHAR:
1627                 case MONKEYS_AT:
1628                     break;
1629 
1630                 case LPAREN:
1631                     // skip annotation values
1632                     int nesting = 0;
1633                     for (; ; pos++) {
1634                         TokenKind tk2 = S.token(pos).kind;
1635                         switch (tk2) {
1636                             case EOF:
1637                                 return false;
1638                             case LPAREN:
1639                                 nesting++;
</pre>
<hr />
<pre>
1721                     // based on subsequent token.
1722                     switch (S.token(lookahead + 1).kind) {
1723                         /*case PLUSPLUS: case SUBSUB: */
1724                         case BANG: case TILDE:
1725                         case LPAREN: case THIS: case SUPER:
1726                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1727                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1728                         case TRUE: case FALSE: case NULL:
1729                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1730                         case SWITCH:
1731                         case BYTE: case SHORT: case CHAR: case INT:
1732                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1733                             return ParensResult.CAST;
1734                         default:
1735                             return defaultResult;
1736                     }
1737                 case UNDERSCORE:
1738                 case ASSERT:
1739                 case ENUM:
1740                 case IDENTIFIER:
<span class="line-modified">1741                     if (peekToken(lookahead, LAX_IDENTIFIER) || (peekToken(lookahead, QUES, LAX_IDENTIFIER) &amp;&amp; (peekToken(lookahead + 2, RPAREN) || peekToken(lookahead + 2, COMMA)))) {</span>
<span class="line-modified">1742                         // Identifier[?], Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda</span>
1743                         return ParensResult.EXPLICIT_LAMBDA;
1744                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1745                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1746                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1747                                                       : ParensResult.PARENS;
1748                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1749                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1750                     }
1751                     type = false;
1752                     break;
1753                 case FINAL:
1754                 case ELLIPSIS:
1755                     //those can only appear in explicit lambdas
1756                     return ParensResult.EXPLICIT_LAMBDA;
1757                 case MONKEYS_AT:
1758                     type = true;
1759                     lookahead += 1; //skip &#39;@&#39;
1760                     while (peekToken(lookahead, DOT)) {
1761                         lookahead += 2;
1762                     }
</pre>
<hr />
<pre>
1798                         break;
1799                     } else {
1800                         return ParensResult.PARENS;
1801                     }
1802                 case LT:
1803                     depth++; break;
1804                 case GTGTGT:
1805                     depth--;
1806                 case GTGT:
1807                     depth--;
1808                 case GT:
1809                     depth--;
1810                     if (depth == 0) {
1811                         if (peekToken(lookahead, RPAREN) ||
1812                                 peekToken(lookahead, AMP)) {
1813                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1814                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1815                             return ParensResult.CAST;
1816                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1817                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
<span class="line-added">1818                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, COMMA) ||</span>
<span class="line-added">1819                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, RPAREN, ARROW) ||</span>
1820                                 peekToken(lookahead, ELLIPSIS)) {
1821                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1822                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1823                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1824                             return ParensResult.EXPLICIT_LAMBDA;
1825                         }
1826                         //it looks a type, but could still be (i) a cast to generic type,
1827                         //(ii) an unbound method reference or (iii) an explicit lambda
1828                         type = true;
1829                         break;
1830                     } else if (depth &lt; 0) {
1831                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1832                         return ParensResult.PARENS;
1833                     }
1834                     break;
1835                 default:
1836                     //this includes EOF
1837                     return defaultResult;
1838             }
1839         }
</pre>
<hr />
<pre>
2196 
2197     private JCExpression bracketsOptCont(JCExpression t, int pos,
2198             List&lt;JCAnnotation&gt; annotations) {
2199         accept(RBRACKET);
2200         t = bracketsOpt(t);
2201         t = toP(F.at(pos).TypeArray(t));
2202         if (annotations.nonEmpty()) {
2203             t = toP(F.at(pos).AnnotatedType(annotations, t));
2204         }
2205         return t;
2206     }
2207 
2208     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2209      *  BracketsSuffixType =
2210      */
2211     JCExpression bracketsSuffix(JCExpression t) {
2212         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2213             selectExprMode();
2214             int pos = token.pos;
2215             nextToken();
<span class="line-modified">2216             TokenKind selector = accept2(CLASS, DEFAULT);</span>
2217             if (token.pos == endPosTable.errorEndPos) {
2218                 // error recovery
2219                 Name name;
2220                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2221                     name = token.name();
2222                     nextToken();
2223                 } else {
2224                     name = names.error;
2225                 }
2226                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2227             } else {
2228                 Tag tag = t.getTag();
2229                 // Type annotations are illegal on class literals. Annotated non array class literals
2230                 // are complained about directly in term3(), Here check for type annotations on dimensions
2231                 // taking care to handle some interior dimension(s) being annotated.
2232                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2233                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
<span class="line-modified">2234                 t = toP(F.at(pos).Select(t, selector == CLASS ? names._class : names._default));</span>
2235             }
2236         } else if ((mode &amp; TYPE) != 0) {
2237             if (token.kind != COLCOL) {
2238                 selectTypeMode();
2239             }
2240         } else if (token.kind != COLCOL) {
2241             syntaxError(token.pos, Errors.DotClassExpected);
2242         }
2243         return t;
2244     }
2245 
2246     /**
2247      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2248      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2249      */
2250     JCExpression memberReferenceSuffix(JCExpression t) {
2251         int pos1 = token.pos;
2252         accept(COLCOL);
2253         return memberReferenceSuffix(pos1, t);
2254     }
</pre>
<hr />
<pre>
2259         List&lt;JCExpression&gt; typeArgs = null;
2260         if (token.kind == LT) {
2261             typeArgs = typeArguments(false);
2262         }
2263         Name refName;
2264         ReferenceMode refMode;
2265         if (token.kind == NEW) {
2266             refMode = ReferenceMode.NEW;
2267             refName = names.init;
2268             nextToken();
2269         } else {
2270             refMode = ReferenceMode.INVOKE;
2271             refName = ident();
2272         }
2273         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2274     }
2275 
2276     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2277      */
2278     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
<span class="line-modified">2279         final JCModifiers mods = modifiersOpt();</span>
<span class="line-modified">2280         List&lt;JCAnnotation&gt; newAnnotations = mods.annotations;</span>
<span class="line-added">2281         if (!newAnnotations.isEmpty()) {</span>
<span class="line-added">2282             checkSourceLevel(newAnnotations.head.pos, Feature.TYPE_ANNOTATIONS);</span>
<span class="line-added">2283         }</span>
2284         switch (token.kind) {
2285         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2286         case DOUBLE: case BOOLEAN:
<span class="line-added">2287             if (mods.flags != 0) {</span>
<span class="line-added">2288                 long badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;</span>
<span class="line-added">2289                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));</span>
<span class="line-added">2290             }</span>
2291             if (typeArgs == null) {
2292                 if (newAnnotations.isEmpty()) {
2293                     return arrayCreatorRest(newpos, basicType());
2294                 } else {
2295                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2296                 }
2297             }
2298             break;
2299         default:
2300         }
2301         JCExpression t = qualident(true);
2302 
2303         int oldmode = mode;
2304         selectTypeMode();
2305         boolean diamondFound = false;
2306         int lastTypeargsPos = -1;
2307         if (token.kind == LT) {
2308             lastTypeargsPos = token.pos;
2309             t = typeArguments(t, true);
2310             diamondFound = (mode &amp; DIAMOND) != 0;
</pre>
<hr />
<pre>
2339             JCExpression e = arrayCreatorRest(newpos, t);
2340             if (diamondFound) {
2341                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2342                 return toP(F.at(newpos).Erroneous(List.of(e)));
2343             }
2344             else if (typeArgs != null) {
2345                 int pos = newpos;
2346                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2347                     // note: this should always happen but we should
2348                     // not rely on this as the parser is continuously
2349                     // modified to improve error recovery.
2350                     pos = typeArgs.head.pos;
2351                 }
2352                 setErrorEndPos(S.prevToken().endPos);
2353                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2354                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2355                 return toP(err);
2356             }
2357             return e;
2358         } else if (token.kind == LPAREN) {
<span class="line-added">2359             long badModifiers = mods.flags &amp; ~(Flags.VALUE | Flags.FINAL);</span>
<span class="line-added">2360             if (badModifiers != 0)</span>
<span class="line-added">2361                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));</span>
2362             // handle type annotations for instantiations and anonymous classes
2363             if (newAnnotations.nonEmpty()) {
2364                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2365             }
<span class="line-modified">2366             JCNewClass newClass = classCreatorRest(newpos, null, typeArgs, t, mods.flags);</span>
<span class="line-added">2367             if ((newClass.def == null) &amp;&amp; (mods.flags != 0)) {</span>
<span class="line-added">2368                 badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;</span>
<span class="line-added">2369                 log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));</span>
<span class="line-added">2370             }</span>
<span class="line-added">2371             return newClass;</span>
2372         } else {
2373             setErrorEndPos(token.pos);
2374             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2375             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2376             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2377         }
2378     }
2379 
2380     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2381      */
2382     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2383         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2384 
2385         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2386 
2387         if (newAnnotations.nonEmpty()) {
2388             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2389         }
2390 
2391         if (token.kind == LT) {
2392             int oldmode = mode;
2393             t = typeArguments(t, true);
2394             mode = oldmode;
2395         }
<span class="line-modified">2396         return classCreatorRest(newpos, encl, typeArgs, t, 0);</span>
2397     }
2398 
2399     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2400      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2401      */
2402     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2403         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2404 
2405         accept(LBRACKET);
2406         if (token.kind == RBRACKET) {
2407             accept(RBRACKET);
2408             elemtype = bracketsOpt(elemtype, annos);
2409             if (token.kind == LBRACE) {
2410                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2411                 if (annos.nonEmpty()) {
2412                     // when an array initializer is present then
2413                     // the parsed annotations should target the
2414                     // new array tree
2415                     // bracketsOpt inserts the annotation in
2416                     // elemtype, and it needs to be corrected
</pre>
<hr />
<pre>
2458             if (token.kind == LBRACE) {
2459                 elems = arrayInitializerElements(newpos, elemtype);
2460             }
2461 
2462             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2463             na.dimAnnotations = dimAnnotations.toList();
2464 
2465             if (elems != null) {
2466                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2467             }
2468 
2469             return na;
2470         }
2471     }
2472 
2473     /** ClassCreatorRest = Arguments [ClassBody]
2474      */
2475     JCNewClass classCreatorRest(int newpos,
2476                                   JCExpression encl,
2477                                   List&lt;JCExpression&gt; typeArgs,
<span class="line-modified">2478                                   JCExpression t,</span>
<span class="line-added">2479                                   long flags)</span>
2480     {
2481         List&lt;JCExpression&gt; args = arguments();
2482         JCClassDecl body = null;
2483         if (token.kind == LBRACE) {
2484             int pos = token.pos;
2485             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
<span class="line-modified">2486             JCModifiers mods = F.at(Position.NOPOS).Modifiers(flags);</span>
2487             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2488         }
<span class="line-modified">2489         JCNewClass newClass = toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));</span>
<span class="line-added">2490         return newClass;</span>
2491     }
2492 
2493     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2494      */
2495     JCExpression arrayInitializer(int newpos, JCExpression t) {
2496         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2497         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2498     }
2499 
2500     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2501         accept(LBRACE);
2502         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2503         if (token.kind == COMMA) {
2504             nextToken();
2505         } else if (token.kind != RBRACE) {
2506             elems.append(variableInitializer());
2507             while (token.kind == COMMA) {
2508                 nextToken();
2509                 if (token.kind == RBRACE) break;
2510                 elems.append(variableInitializer());
</pre>
<hr />
<pre>
2601                 error = Errors.ClassNotAllowed;
2602                 break;
2603             case VARDEF:
2604                 error = Errors.VariableNotAllowed;
2605                 break;
2606             }
2607             if (error != null) {
2608                 log.error(DiagnosticFlag.SYNTAX, first, error);
2609                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2610                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2611             }
2612             return first;
2613         }
2614     }
2615 
2616     /**This method parses a statement appearing inside a block.
2617      */
2618     @SuppressWarnings(&quot;fallthrough&quot;)
2619     List&lt;JCStatement&gt; blockStatement() {
2620         //todo: skip to anchor on error(?)
<span class="line-added">2621         token = recastToken(token);</span>
2622         Comment dc;
2623         int pos = token.pos;
2624         switch (token.kind) {
2625         case RBRACE: case CASE: case DEFAULT: case EOF:
2626             return List.nil();
2627         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2628         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2629         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2630         case ASSERT:
2631             return List.of(parseSimpleStatement());
<span class="line-added">2632         case VALUE:</span>
2633         case MONKEYS_AT:
2634         case FINAL: {
2635             dc = token.comment(CommentStyle.JAVADOC);
2636             JCModifiers mods = modifiersOpt();
2637             if (token.kind == INTERFACE ||
2638                 token.kind == CLASS ||
2639                 token.kind == ENUM ||
2640                 isRecordStart()) {
2641                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2642             } else {
2643                 JCExpression t = parseType(true);
2644                 return localVariableDeclarations(mods, t);
2645             }
2646         }
2647         case ABSTRACT: case STRICTFP: {
2648             dc = token.comment(CommentStyle.JAVADOC);
2649             JCModifiers mods = modifiersOpt();
2650             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2651         }
2652         case INTERFACE:
</pre>
<hr />
<pre>
3051             nextToken();
3052             pos = token.pos;
3053             JCExpression t = parseExpression();
3054             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3055             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3056         }
3057         return stats;
3058     }
3059 
3060     /** ForInit = StatementExpression MoreStatementExpressions
3061      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3062      */
3063     List&lt;JCStatement&gt; forInit() {
3064         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3065         int pos = token.pos;
3066         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3067             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3068         } else {
3069             JCExpression t = term(EXPR | TYPE);
3070             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
<span class="line-modified">3071                 pos = token.pos;</span>
<span class="line-added">3072                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);</span>
<span class="line-added">3073                 F.at(pos);</span>
<span class="line-added">3074                 return variableDeclarators(mods, t, stats, true).toList();</span>
3075             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3076                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3077                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3078             } else {
3079                 return moreStatementExpressions(pos, t, stats).toList();
3080             }
3081         }
3082     }
3083 
3084     /** ForUpdate = StatementExpression MoreStatementExpressions
3085      */
3086     List&lt;JCExpressionStatement&gt; forUpdate() {
3087         return moreStatementExpressions(token.pos,
3088                                         parseExpression(),
3089                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3090     }
3091 
3092     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3093      *
3094      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
</pre>
<hr />
<pre>
3124     }
3125     protected JCModifiers modifiersOpt(JCModifiers partial) {
3126         long flags;
3127         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3128         int pos;
3129         if (partial == null) {
3130             flags = 0;
3131             pos = token.pos;
3132         } else {
3133             flags = partial.flags;
3134             annotations.appendList(partial.annotations);
3135             pos = partial.pos;
3136         }
3137         if (token.deprecatedFlag()) {
3138             flags |= Flags.DEPRECATED;
3139         }
3140         int lastPos;
3141     loop:
3142         while (true) {
3143             long flag;
<span class="line-added">3144             token = recastToken(token);</span>
3145             switch (token.kind) {
3146             case PRIVATE     : flag = Flags.PRIVATE; break;
3147             case PROTECTED   : flag = Flags.PROTECTED; break;
3148             case PUBLIC      : flag = Flags.PUBLIC; break;
3149             case STATIC      : flag = Flags.STATIC; break;
3150             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3151             case FINAL       : flag = Flags.FINAL; break;
3152             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3153             case NATIVE      : flag = Flags.NATIVE; break;
<span class="line-added">3154             case VALUE       : flag = Flags.VALUE; break;</span>
3155             case VOLATILE    : flag = Flags.VOLATILE; break;
3156             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3157             case STRICTFP    : flag = Flags.STRICTFP; break;
3158             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3159             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3160             case ERROR       : flag = 0; nextToken(); break;
3161             default: break loop;
3162             }
3163             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3164             lastPos = token.pos;
3165             nextToken();
3166             if (flag == Flags.ANNOTATION) {
3167                 if (token.kind != INTERFACE) {
3168                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3169                     // if first modifier is an annotation, set pos to annotation&#39;s.
3170                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3171                         pos = ann.pos;
<span class="line-modified">3172                     final Name name = TreeInfo.name(ann.annotationType);</span>
<span class="line-modified">3173                     if (name == names.__inline__ || name == names.java_lang___inline__) {</span>
<span class="line-added">3174                         flag = Flags.VALUE;</span>
<span class="line-added">3175                     } else {</span>
<span class="line-added">3176                         annotations.append(ann);</span>
<span class="line-added">3177                         flag = 0;</span>
<span class="line-added">3178                     }</span>
3179                 }
3180             }
3181             flags |= flag;
3182         }
3183         switch (token.kind) {
3184         case ENUM: flags |= Flags.ENUM; break;
3185         case INTERFACE: flags |= Flags.INTERFACE; break;
3186         default: break;
3187         }
3188 
3189         /* A modifiers tree with no modifier tokens or annotations
3190          * has no text position. */
3191         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3192             pos = Position.NOPOS;
3193 
<span class="line-added">3194         // Force value classes to be automatically final.</span>
<span class="line-added">3195         if ((flags &amp; (Flags.VALUE | Flags.ABSTRACT | Flags.INTERFACE | Flags.ENUM)) == Flags.VALUE) {</span>
<span class="line-added">3196             flags |= Flags.FINAL;</span>
<span class="line-added">3197         }</span>
<span class="line-added">3198 </span>
3199         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3200         if (pos != Position.NOPOS)
3201             storeEnd(mods, S.prevToken().endPos);
3202         return mods;
3203     }
3204 
3205     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3206      *
3207      * @param pos position of &quot;@&quot; token
3208      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3209      */
3210     JCAnnotation annotation(int pos, Tag kind) {
3211         // accept(AT); // AT consumed by caller
3212         if (kind == Tag.TYPE_ANNOTATION) {
3213             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3214         }
3215         JCTree ident = qualident(false);
3216         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3217         JCAnnotation ann;
3218         if (kind == Tag.ANNOTATION) {
</pre>
<hr />
<pre>
3366                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3367                 } else {
3368                     if(compound)
3369                         //error - &#39;var&#39; in compound local var decl
3370                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3371                     startPos = TreeInfo.getStartPos(mods);
3372                     if (startPos == Position.NOPOS)
3373                         startPos = TreeInfo.getStartPos(type);
3374                     //implicit type
3375                     type = null;
3376                 }
3377             }
3378         }
3379         JCVariableDecl result =
3380             toP(F.at(pos).VarDef(mods, name, type, init));
3381         attach(result, dc);
3382         result.startPos = startPos;
3383         return result;
3384     }
3385 
<span class="line-added">3386     // Does the given token signal an inline modifier ? If yes, suitably reclassify token.</span>
<span class="line-added">3387     Token recastToken(Token token) {</span>
<span class="line-added">3388         if (token.kind != IDENTIFIER || token.name() != names.inline) {</span>
<span class="line-added">3389             return token;</span>
<span class="line-added">3390         }</span>
<span class="line-added">3391         if (peekToken(t-&gt;t == PRIVATE ||</span>
<span class="line-added">3392                          t == PROTECTED ||</span>
<span class="line-added">3393                          t == PUBLIC ||</span>
<span class="line-added">3394                          t == STATIC ||</span>
<span class="line-added">3395                          t == TRANSIENT ||</span>
<span class="line-added">3396                          t == FINAL ||</span>
<span class="line-added">3397                          t == ABSTRACT ||</span>
<span class="line-added">3398                          t == NATIVE ||</span>
<span class="line-added">3399                          t == VOLATILE ||</span>
<span class="line-added">3400                          t == SYNCHRONIZED ||</span>
<span class="line-added">3401                          t == STRICTFP ||</span>
<span class="line-added">3402                          t == MONKEYS_AT ||</span>
<span class="line-added">3403                          t == DEFAULT ||</span>
<span class="line-added">3404                          t == BYTE ||</span>
<span class="line-added">3405                          t == SHORT ||</span>
<span class="line-added">3406                          t == CHAR ||</span>
<span class="line-added">3407                          t == INT ||</span>
<span class="line-added">3408                          t == LONG ||</span>
<span class="line-added">3409                          t == FLOAT ||</span>
<span class="line-added">3410                          t == DOUBLE ||</span>
<span class="line-added">3411                          t == BOOLEAN ||</span>
<span class="line-added">3412                          t == CLASS ||</span>
<span class="line-added">3413                          t == INTERFACE ||</span>
<span class="line-added">3414                          t == ENUM ||</span>
<span class="line-added">3415                          t == IDENTIFIER)) { // new value Comparable() {}</span>
<span class="line-added">3416             checkSourceLevel(Feature.INLINE_TYPES);</span>
<span class="line-added">3417             return new Token(VALUE, token.pos, token.endPos, token.comments);</span>
<span class="line-added">3418         }</span>
<span class="line-added">3419         return token;</span>
<span class="line-added">3420     }</span>
<span class="line-added">3421 </span>
3422     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3423         switch (e.getTag()) {
3424             case IDENT:
3425                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3426             case TYPEARRAY:
3427                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3428             default:
3429                 return null;
3430         }
3431     }
3432 
3433     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3434         if (name == names.var) {
3435             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3436                 return Source.JDK10;
3437             } else if (shouldWarn) {
3438                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3439             }
3440         }
3441         if (name == names.yield) {
</pre>
</td>
</tr>
</table>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdi/share/classes/com/sun/tools/jdi/ObjectReferenceImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JNITypeParser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ValueImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdi/share/classes/com/sun/tools/jdi/ObjectReferenceImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 59     protected static class Cache {
 60         JDWP.ObjectReference.MonitorInfo monitorInfo = null;
 61     }
 62 
 63     private static final Cache noInitCache = new Cache();
 64     private static final Cache markerCache = new Cache();
 65     private Cache cache = noInitCache;
 66 
 67     private void disableCache() {
 68         synchronized (vm.state()) {
 69             cache = null;
 70         }
 71     }
 72 
 73     private void enableCache() {
 74         synchronized (vm.state()) {
 75             cache = markerCache;
 76         }
 77     }
 78 




 79     // Override in subclasses
 80     protected Cache newCache() {
 81         return new Cache();
 82     }
 83 
 84     protected Cache getCache() {
 85         synchronized (vm.state()) {
 86             if (cache == noInitCache) {
 87                 if (vm.state().isSuspended()) {
 88                     // Set cache now, otherwise newly created objects are
 89                     // not cached until resuspend
 90                     enableCache();
 91                 } else {
 92                     disableCache();
 93                 }
 94             }
 95             if (cache == markerCache) {
 96                 cache = newCache();
 97             }
 98             return cache;
</pre>
<hr />
<pre>
128         // make sure that cache and listener management are synchronized
129         synchronized (vm.state()) {
130             if (cache != null &amp;&amp; (vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {
131                 vm.printTrace(&quot;Clearing temporary cache for &quot; + description());
132             }
133             disableCache();
134             if (addedListener) {
135                 /*
136                  * If a listener was added (i.e. this is not a
137                  * ObjectReference that adds a listener on startup),
138                  * remove it here.
139                  */
140                 addedListener = false;
141                 return false;  // false says remove
142             } else {
143                 return true;
144             }
145         }
146     }
147 



















148     public boolean equals(Object obj) {
149         if ((obj != null) &amp;&amp; (obj instanceof ObjectReferenceImpl)) {
<span class="line-modified">150             ObjectReferenceImpl other = (ObjectReferenceImpl)obj;</span>
<span class="line-modified">151             return (ref() == other.ref()) &amp;&amp;</span>
<span class="line-modified">152                    super.equals(obj);</span>




153         } else {
154             return false;
155         }
156     }
157 
158     public int hashCode() {
159         return(int)ref();
160     }
161 
162     public Type type() {
163         return referenceType();
164     }
165 
166     public ReferenceType referenceType() {
167         if (type == null) {
168             try {
169                 JDWP.ObjectReference.ReferenceType rtinfo =
170                     JDWP.ObjectReference.ReferenceType.process(vm, this);
171                 type = vm.referenceType(rtinfo.typeID,
172                                         rtinfo.refTypeTag);
</pre>
<hr />
<pre>
453             } catch (JDWPException exc) {
454                 // If already collected, no harm done, no exception
455                 if (exc.errorCode() != JDWP.Error.INVALID_OBJECT) {
456                     throw exc.toJDIException();
457                 }
458                 return;
459             }
460         }
461     }
462 
463     public boolean isCollected() {
464         try {
465             return JDWP.ObjectReference.IsCollected.process(vm, this).
466                                                               isCollected;
467         } catch (JDWPException exc) {
468             throw exc.toJDIException();
469         }
470     }
471 
472     public long uniqueID() {



473         return ref();
474     }
475 
476     JDWP.ObjectReference.MonitorInfo jdwpMonitorInfo()
477                              throws IncompatibleThreadStateException {
478         JDWP.ObjectReference.MonitorInfo info = null;
479         try {
480             Cache local;
481 
482             // getCache() and addlistener() must be synchronized
483             // so that no events are lost.
484             synchronized (vm.state()) {
485                 local = getCache();
486 
487                 if (local != null) {
488                     info = local.monitorInfo;
489 
490                     // Check if there will be something to cache
491                     // and there is not already a listener
492                     if (info == null &amp;&amp; !vm.state().hasListener(this)) {
</pre>
<hr />
<pre>
593         if (destSig.isArray() &amp;&amp; !sourceSig.isArray()) {
594             throw new InvalidTypeException(&quot;Can&#39;t assign non-array value to an array&quot;);
595         }
596         if (destSig.isVoid()) {
597             throw new InvalidTypeException(&quot;Can&#39;t assign object value to a void&quot;);
598         }
599 
600         // Validate assignment
601         ReferenceType destType = (ReferenceTypeImpl)destination.type();
602         ReferenceTypeImpl myType = (ReferenceTypeImpl)referenceType();
603         if (!myType.isAssignableTo(destType)) {
604             JNITypeParser parser = new JNITypeParser(destType.signature());
605             String destTypeName = parser.typeName();
606             throw new InvalidTypeException(&quot;Can&#39;t assign &quot; +
607                                            type().name() +
608                                            &quot; to &quot; + destTypeName);
609         }
610     }
611 
612     public String toString() {
<span class="line-modified">613         return &quot;instance of &quot; + referenceType().name() + &quot;(id=&quot; + uniqueID() + &quot;)&quot;;</span>




614     }
615 
616     byte typeValueKey() {
<span class="line-modified">617         return JDWP.Tag.OBJECT;</span>




618     }
619 
620     private static boolean isNonVirtual(int options) {
621         return (options &amp; INVOKE_NONVIRTUAL) != 0;
622     }
623 }
</pre>
</td>
<td>
<hr />
<pre>
 59     protected static class Cache {
 60         JDWP.ObjectReference.MonitorInfo monitorInfo = null;
 61     }
 62 
 63     private static final Cache noInitCache = new Cache();
 64     private static final Cache markerCache = new Cache();
 65     private Cache cache = noInitCache;
 66 
 67     private void disableCache() {
 68         synchronized (vm.state()) {
 69             cache = null;
 70         }
 71     }
 72 
 73     private void enableCache() {
 74         synchronized (vm.state()) {
 75             cache = markerCache;
 76         }
 77     }
 78 
<span class="line-added"> 79     private boolean isInlineType() {</span>
<span class="line-added"> 80         return referenceType().signature().startsWith(&quot;Q&quot;);</span>
<span class="line-added"> 81     }</span>
<span class="line-added"> 82 </span>
 83     // Override in subclasses
 84     protected Cache newCache() {
 85         return new Cache();
 86     }
 87 
 88     protected Cache getCache() {
 89         synchronized (vm.state()) {
 90             if (cache == noInitCache) {
 91                 if (vm.state().isSuspended()) {
 92                     // Set cache now, otherwise newly created objects are
 93                     // not cached until resuspend
 94                     enableCache();
 95                 } else {
 96                     disableCache();
 97                 }
 98             }
 99             if (cache == markerCache) {
100                 cache = newCache();
101             }
102             return cache;
</pre>
<hr />
<pre>
132         // make sure that cache and listener management are synchronized
133         synchronized (vm.state()) {
134             if (cache != null &amp;&amp; (vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {
135                 vm.printTrace(&quot;Clearing temporary cache for &quot; + description());
136             }
137             disableCache();
138             if (addedListener) {
139                 /*
140                  * If a listener was added (i.e. this is not a
141                  * ObjectReference that adds a listener on startup),
142                  * remove it here.
143                  */
144                 addedListener = false;
145                 return false;  // false says remove
146             } else {
147                 return true;
148             }
149         }
150     }
151 
<span class="line-added">152     // The isSubstitutable() method must perform the same comparison on</span>
<span class="line-added">153     // remote inline objects as the one performed ValueBootstrapMethods.isSubstitutable()</span>
<span class="line-added">154     // on local instances.</span>
<span class="line-added">155     private boolean isSubstitutable(ObjectReferenceImpl other) {</span>
<span class="line-added">156         if (referenceType() != other.referenceType()) return false;</span>
<span class="line-added">157         List&lt;Field&gt; fields = referenceType().fields();</span>
<span class="line-added">158         for (Field f : fields) {</span>
<span class="line-added">159             if (f.isStatic()) {</span>
<span class="line-added">160                 fields.remove(f);</span>
<span class="line-added">161             }</span>
<span class="line-added">162         }</span>
<span class="line-added">163         Map&lt;Field,Value&gt; thisFields = getValues(fields);</span>
<span class="line-added">164         Map&lt;Field,Value&gt; otherFields = other.getValues(fields);</span>
<span class="line-added">165         for (Field f : fields) {</span>
<span class="line-added">166             if (!thisFields.get(f).equals(otherFields.get(f))) return false;</span>
<span class="line-added">167         }</span>
<span class="line-added">168         return true;</span>
<span class="line-added">169     }</span>
<span class="line-added">170 </span>
171     public boolean equals(Object obj) {
172         if ((obj != null) &amp;&amp; (obj instanceof ObjectReferenceImpl)) {
<span class="line-modified">173             ObjectReferenceImpl other = (ObjectReferenceImpl) obj;</span>
<span class="line-modified">174             if (isInlineType()) {</span>
<span class="line-modified">175                 return isSubstitutable(other);</span>
<span class="line-added">176             } else {</span>
<span class="line-added">177                 return (ref() == other.ref()) &amp;&amp;</span>
<span class="line-added">178                         super.equals(obj);</span>
<span class="line-added">179             }</span>
180         } else {
181             return false;
182         }
183     }
184 
185     public int hashCode() {
186         return(int)ref();
187     }
188 
189     public Type type() {
190         return referenceType();
191     }
192 
193     public ReferenceType referenceType() {
194         if (type == null) {
195             try {
196                 JDWP.ObjectReference.ReferenceType rtinfo =
197                     JDWP.ObjectReference.ReferenceType.process(vm, this);
198                 type = vm.referenceType(rtinfo.typeID,
199                                         rtinfo.refTypeTag);
</pre>
<hr />
<pre>
480             } catch (JDWPException exc) {
481                 // If already collected, no harm done, no exception
482                 if (exc.errorCode() != JDWP.Error.INVALID_OBJECT) {
483                     throw exc.toJDIException();
484                 }
485                 return;
486             }
487         }
488     }
489 
490     public boolean isCollected() {
491         try {
492             return JDWP.ObjectReference.IsCollected.process(vm, this).
493                                                               isCollected;
494         } catch (JDWPException exc) {
495             throw exc.toJDIException();
496         }
497     }
498 
499     public long uniqueID() {
<span class="line-added">500         if (isInlineType()) {</span>
<span class="line-added">501             throw new UnsupportedOperationException(&quot;Inline types cannot have unique IDs&quot;);</span>
<span class="line-added">502         }</span>
503         return ref();
504     }
505 
506     JDWP.ObjectReference.MonitorInfo jdwpMonitorInfo()
507                              throws IncompatibleThreadStateException {
508         JDWP.ObjectReference.MonitorInfo info = null;
509         try {
510             Cache local;
511 
512             // getCache() and addlistener() must be synchronized
513             // so that no events are lost.
514             synchronized (vm.state()) {
515                 local = getCache();
516 
517                 if (local != null) {
518                     info = local.monitorInfo;
519 
520                     // Check if there will be something to cache
521                     // and there is not already a listener
522                     if (info == null &amp;&amp; !vm.state().hasListener(this)) {
</pre>
<hr />
<pre>
623         if (destSig.isArray() &amp;&amp; !sourceSig.isArray()) {
624             throw new InvalidTypeException(&quot;Can&#39;t assign non-array value to an array&quot;);
625         }
626         if (destSig.isVoid()) {
627             throw new InvalidTypeException(&quot;Can&#39;t assign object value to a void&quot;);
628         }
629 
630         // Validate assignment
631         ReferenceType destType = (ReferenceTypeImpl)destination.type();
632         ReferenceTypeImpl myType = (ReferenceTypeImpl)referenceType();
633         if (!myType.isAssignableTo(destType)) {
634             JNITypeParser parser = new JNITypeParser(destType.signature());
635             String destTypeName = parser.typeName();
636             throw new InvalidTypeException(&quot;Can&#39;t assign &quot; +
637                                            type().name() +
638                                            &quot; to &quot; + destTypeName);
639         }
640     }
641 
642     public String toString() {
<span class="line-modified">643         if (isInlineType()) {</span>
<span class="line-added">644             return &quot;instance of &quot; + referenceType().name();</span>
<span class="line-added">645         } else {</span>
<span class="line-added">646             return &quot;instance of &quot; + referenceType().name() + &quot;(id=&quot; + uniqueID() + &quot;)&quot;;</span>
<span class="line-added">647         }</span>
648     }
649 
650     byte typeValueKey() {
<span class="line-modified">651         if (isInlineType()) {</span>
<span class="line-added">652             return JDWP.Tag.INLINE_OBJECT;</span>
<span class="line-added">653         } else {</span>
<span class="line-added">654             return JDWP.Tag.OBJECT;</span>
<span class="line-added">655         }</span>
656     }
657 
658     private static boolean isNonVirtual(int options) {
659         return (options &amp; INVOKE_NONVIRTUAL) != 0;
660     }
661 }
</pre>
</td>
</tr>
</table>
<center><a href="JNITypeParser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ValueImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../System.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../module-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2314 ...
2315 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2316   &quot;asList&quot;, methodType(List.class, Object[].class));
2317 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2318          * }&lt;/pre&gt;&lt;/blockquote&gt;
2319          * @param refc the class from which the method is accessed
2320          * @param name the name of the method
2321          * @param type the type of the method
2322          * @return the desired method handle
2323          * @throws NoSuchMethodException if the method does not exist
2324          * @throws IllegalAccessException if access checking fails,
2325          *                                or if the method is not {@code static},
2326          *                                or if the method&#39;s variable arity modifier bit
2327          *                                is set and {@code asVarargsCollector} fails
2328          * @throws    SecurityException if a security manager is present and it
2329          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2330          * @throws NullPointerException if any argument is null
2331          */
2332         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2333             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);






2334             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2335         }
2336 
2337         /**
2338          * Produces a method handle for a virtual method.
2339          * The type of the method handle will be that of the method,
2340          * with the receiver type (usually {@code refc}) prepended.
2341          * The method and all its argument types must be accessible to the lookup object.
2342          * &lt;p&gt;
2343          * When called, the handle will treat the first argument as a receiver
2344          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2345          * implementation to enter.
2346          * For private methods the named method in {@code refc} will be invoked on the receiver.
2347          * (The dispatching action is identical with that performed by an
2348          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2349          * &lt;p&gt;
2350          * The first argument will be of type {@code refc} if the lookup
2351          * class has full privileges to access the member.  Otherwise
2352          * the member must be {@code protected} and the first argument
2353          * will be restricted in type to the lookup class.
</pre>
<hr />
<pre>
2459          * If the returned method handle is invoked, the constructor&#39;s class will
2460          * be initialized, if it has not already been initialized.
2461          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2462          * &lt;blockquote&gt;&lt;pre&gt;{@code
2463 import static java.lang.invoke.MethodHandles.*;
2464 import static java.lang.invoke.MethodType.*;
2465 ...
2466 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2467   ArrayList.class, methodType(void.class, Collection.class));
2468 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2469 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2470 assert(orig != copy);
2471 assertEquals(orig, copy);
2472 // a variable-arity constructor:
2473 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2474   ProcessBuilder.class, methodType(void.class, String[].class));
2475 ProcessBuilder pb = (ProcessBuilder)
2476   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2477 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2478          * }&lt;/pre&gt;&lt;/blockquote&gt;







2479          * @param refc the class or interface from which the method is accessed
2480          * @param type the type of the method, with the receiver argument omitted, and a void return type
2481          * @return the desired method handle
2482          * @throws NoSuchMethodException if the constructor does not exist
2483          * @throws IllegalAccessException if access checking fails
2484          *                                or if the method&#39;s variable arity modifier bit
2485          *                                is set and {@code asVarargsCollector} fails
2486          * @throws    SecurityException if a security manager is present and it
2487          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2488          * @throws NullPointerException if any argument is null
2489          */
2490         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2491             if (refc.isArray()) {
2492                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2493             }



2494             String name = &quot;&lt;init&gt;&quot;;
2495             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2496             return getDirectConstructor(refc, ctor);
2497         }
2498 
2499         /**
2500          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2501          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2502          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2503          * and then determines whether the class is accessible to this lookup object.
2504          * &lt;p&gt;
2505          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2506          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2507          *
2508          * @param targetName the fully qualified name of the class to be looked up.
2509          * @return the requested class.
2510          * @throws SecurityException if a security manager is present and it
2511          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2512          * @throws LinkageError if the linkage fails
2513          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
</pre>
<hr />
<pre>
3091          * arguments passed to the method handle.
3092          * &lt;p&gt;
3093          * If the constructor&#39;s {@code accessible} flag is not set,
3094          * access checking is performed immediately on behalf of the lookup class.
3095          * &lt;p&gt;
3096          * The returned method handle will have
3097          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3098          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3099          * &lt;p&gt;
3100          * If the returned method handle is invoked, the constructor&#39;s class will
3101          * be initialized, if it has not already been initialized.
3102          * @param c the reflected constructor
3103          * @return a method handle which can invoke the reflected constructor
3104          * @throws IllegalAccessException if access checking fails
3105          *                                or if the method&#39;s variable arity modifier bit
3106          *                                is set and {@code asVarargsCollector} fails
3107          * @throws NullPointerException if the argument is null
3108          */
3109         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3110             MemberName ctor = new MemberName(c);
<span class="line-modified">3111             assert(ctor.isConstructor());</span>
3112             @SuppressWarnings(&quot;deprecation&quot;)
3113             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">3114             return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>








3115         }
3116 
3117         /**
3118          * Produces a method handle giving read access to a reflected field.
3119          * The type of the method handle will have a return type of the field&#39;s
3120          * value type.
3121          * If the field is {@code static}, the method handle will take no arguments.
3122          * Otherwise, its single argument will be the instance containing
3123          * the field.
3124          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3125          * access checking is performed immediately on behalf of the lookup class.
3126          * &lt;p&gt;
3127          * If the field is static, and
3128          * if the returned method handle is invoked, the field&#39;s class will
3129          * be initialized, if it has not already been initialized.
3130          * @param f the reflected field
3131          * @return a method handle which can load values from the reflected field
3132          * @throws IllegalAccessException if access checking fails
3133          * @throws NullPointerException if the argument is null
3134          */
</pre>
<hr />
<pre>
3347             }
3348             Objects.requireNonNull(member.getName());
3349             Objects.requireNonNull(member.getType());
3350             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3351         }
3352 
3353         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3354             if (!isClassAccessible(refc)) {
3355                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3356             }
3357         }
3358 
3359         boolean isClassAccessible(Class&lt;?&gt; refc) {
3360             Objects.requireNonNull(refc);
3361             Class&lt;?&gt; caller = lookupClassOrNull();
3362             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3363         }
3364 
3365         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3366         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<span class="line-modified">3367             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial)</span>
<span class="line-modified">3368                 throw new NoSuchMethodException(&quot;illegal method name: &quot;+name);</span>



3369         }
3370 
<span class="line-removed">3371 </span>
3372         /**
3373          * Find my trustable caller class if m is a caller sensitive method.
3374          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3375          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3376          */
3377         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3378             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3379                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3380                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3381             }
3382             return this;
3383         }
3384 
3385         /**
3386          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3387          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3388          *
3389          * @deprecated This method was originally designed to test {@code PRIVATE} access
3390          * that implies full privilege access but {@code MODULE} access has since become
3391          * independent of {@code PRIVATE} access.  It is recommended to call
</pre>
<hr />
<pre>
3436                 }
3437                 return;
3438             }
3439 
3440             // Step 2a:
3441             if (m.isPublic()) return;
3442             if (!fullPowerLookup) {
3443                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3444             }
3445 
3446             // Step 3:
3447             Class&lt;?&gt; defc = m.getDeclaringClass();
3448             if (!fullPowerLookup &amp;&amp; defc != refc) {
3449                 ReflectUtil.checkPackageAccess(defc);
3450             }
3451         }
3452 
3453         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3454             boolean wantStatic = (refKind == REF_invokeStatic);
3455             String message;
<span class="line-modified">3456             if (m.isConstructor())</span>
3457                 message = &quot;expected a method, not a constructor&quot;;
3458             else if (!m.isMethod())
3459                 message = &quot;expected a method&quot;;
3460             else if (wantStatic != m.isStatic())
3461                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3462             else
3463                 { checkAccess(refKind, refc, m); return; }
3464             throw m.makeAccessException(message, this);
3465         }
3466 
3467         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3468             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3469             String message;
3470             if (wantStatic != m.isStatic())
3471                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3472             else
3473                 { checkAccess(refKind, refc, m); return; }
3474             throw m.makeAccessException(message, this);
3475         }
3476 
</pre>
<hr />
<pre>
3735                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3736                 }
3737                 refc = lookupClass();
3738             }
3739             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3740                                              this.allowedModes == TRUSTED &amp;&amp; !getField.getDeclaringClass().isHidden());
3741         }
3742         /** Check access and get the requested constructor. */
3743         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3744             final boolean checkSecurity = true;
3745             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3746         }
3747         /** Check access and get the requested constructor, eliding security manager checks. */
3748         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3749             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3750             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3751         }
3752         /** Common code for all constructors; do not call directly except from immediately above. */
3753         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3754                                                   boolean checkSecurity) throws IllegalAccessException {
<span class="line-modified">3755             assert(ctor.isConstructor());</span>
3756             checkAccess(REF_newInvokeSpecial, refc, ctor);
3757             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3758             if (checkSecurity)
3759                 checkSecurityManager(refc, ctor);
3760             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3761             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3762         }
3763 
3764         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3765          */
3766         /*non-public*/
3767         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3768                 throws ReflectiveOperationException {
3769             if (!(type instanceof Class || type instanceof MethodType))
3770                 throw new InternalError(&quot;unresolved MemberName&quot;);
3771             MemberName member = new MemberName(refKind, defc, name, type);
3772             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3773             if (mh != null) {
3774                 checkSymbolicClass(defc);
3775                 return mh;
</pre>
<hr />
<pre>
3925      * Produces a method handle giving write access to elements of an array,
3926      * as if by the {@code astore} bytecode.
3927      * The type of the method handle will have a void return type.
3928      * Its last argument will be the array&#39;s element type.
3929      * The first and second arguments will be the array type and int.
3930      *
3931      * &lt;p&gt; When the returned method handle is invoked,
3932      * the array reference and array index are checked.
3933      * A {@code NullPointerException} will be thrown if the array reference
3934      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
3935      * thrown if the index is negative or if it is greater than or equal to
3936      * the length of the array.
3937      *
3938      * @param arrayClass the class of an array
3939      * @return a method handle which can store values into the array type
3940      * @throws NullPointerException if the argument is null
3941      * @throws IllegalArgumentException if arrayClass is not an array type
3942      * @jvms 6.5 {@code aastore} Instruction
3943      */
3944     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {



3945         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
3946     }
3947 
3948     /**
3949      * Produces a VarHandle giving access to elements of an array of type
3950      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
3951      * of {@code arrayClass} and the list of coordinate types is
3952      * {@code (arrayClass, int)}, where the {@code int} coordinate type
3953      * corresponds to an argument that is an index into an array.
3954      * &lt;p&gt;
3955      * Certain access modes of the returned VarHandle are unsupported under
3956      * the following conditions:
3957      * &lt;ul&gt;
3958      * &lt;li&gt;if the component type is anything other than {@code byte},
3959      *     {@code short}, {@code char}, {@code int}, {@code long},
3960      *     {@code float}, or {@code double} then numeric atomic update access
3961      *     modes are unsupported.
3962      * &lt;li&gt;if the component type is anything other than {@code boolean},
3963      *     {@code byte}, {@code short}, {@code char}, {@code int} or
3964      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
4685     }
4686 
4687     /**
4688      * Produces a constant method handle of the requested return type which
4689      * returns the default value for that type every time it is invoked.
4690      * The resulting constant method handle will have no side effects.
4691      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4692      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4693      * since {@code explicitCastArguments} converts {@code null} to default values.
4694      * @param type the expected return type of the desired method handle
4695      * @return a constant method handle that takes no arguments
4696      *         and returns the default value of the given type (or void, if the type is void)
4697      * @throws NullPointerException if the argument is null
4698      * @see MethodHandles#constant
4699      * @see MethodHandles#empty
4700      * @see MethodHandles#explicitCastArguments
4701      * @since 9
4702      */
4703     public static MethodHandle zero(Class&lt;?&gt; type) {
4704         Objects.requireNonNull(type);
<span class="line-modified">4705         return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);</span>






4706     }
4707 
4708     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4709         return type == void.class ? zero(type) : identity(type);
4710     }
4711 
4712     /**
4713      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4714      * and returns a suitable default depending on the return type.
4715      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4716      * &lt;p&gt;The returned method handle is equivalent to
4717      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4718      *
4719      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4720      * {@code guardWithTest(pred, target, empty(target.type())}.
4721      * @param type the type of the desired method handle
4722      * @return a constant method handle of the given type, which returns a default value of the given return type
4723      * @throws NullPointerException if the argument is null
4724      * @see MethodHandles#zero
4725      * @see MethodHandles#constant
4726      * @since 9
4727      */
4728     public static  MethodHandle empty(MethodType type) {
4729         Objects.requireNonNull(type);
4730         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4731     }
4732 
4733     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4734     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<span class="line-modified">4735         MethodType mtype = methodType(ptype, ptype);</span>
4736         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4737         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4738     }
4739 
4740     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4741         int pos = btw.ordinal();
4742         MethodHandle zero = ZERO_MHS[pos];
4743         if (zero == null) {
4744             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4745         }
4746         if (zero.type().returnType() == rtype)
4747             return zero;
4748         assert(btw == Wrapper.OBJECT);
4749         return makeZero(rtype);
4750     }
4751     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4752     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4753         MethodType mtype = methodType(rtype);
4754         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4755         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
</pre>
</td>
<td>
<hr />
<pre>
2314 ...
2315 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2316   &quot;asList&quot;, methodType(List.class, Object[].class));
2317 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2318          * }&lt;/pre&gt;&lt;/blockquote&gt;
2319          * @param refc the class from which the method is accessed
2320          * @param name the name of the method
2321          * @param type the type of the method
2322          * @return the desired method handle
2323          * @throws NoSuchMethodException if the method does not exist
2324          * @throws IllegalAccessException if access checking fails,
2325          *                                or if the method is not {@code static},
2326          *                                or if the method&#39;s variable arity modifier bit
2327          *                                is set and {@code asVarargsCollector} fails
2328          * @throws    SecurityException if a security manager is present and it
2329          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2330          * @throws NullPointerException if any argument is null
2331          */
2332         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2333             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
<span class="line-added">2334             // resolveOrFail could return a non-static &lt;init&gt; method if present</span>
<span class="line-added">2335             // detect and throw NSME before producing a MethodHandle</span>
<span class="line-added">2336             if (!method.isStatic() &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="line-added">2337                 throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">2338             }</span>
<span class="line-added">2339 </span>
2340             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2341         }
2342 
2343         /**
2344          * Produces a method handle for a virtual method.
2345          * The type of the method handle will be that of the method,
2346          * with the receiver type (usually {@code refc}) prepended.
2347          * The method and all its argument types must be accessible to the lookup object.
2348          * &lt;p&gt;
2349          * When called, the handle will treat the first argument as a receiver
2350          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2351          * implementation to enter.
2352          * For private methods the named method in {@code refc} will be invoked on the receiver.
2353          * (The dispatching action is identical with that performed by an
2354          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2355          * &lt;p&gt;
2356          * The first argument will be of type {@code refc} if the lookup
2357          * class has full privileges to access the member.  Otherwise
2358          * the member must be {@code protected} and the first argument
2359          * will be restricted in type to the lookup class.
</pre>
<hr />
<pre>
2465          * If the returned method handle is invoked, the constructor&#39;s class will
2466          * be initialized, if it has not already been initialized.
2467          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2468          * &lt;blockquote&gt;&lt;pre&gt;{@code
2469 import static java.lang.invoke.MethodHandles.*;
2470 import static java.lang.invoke.MethodType.*;
2471 ...
2472 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2473   ArrayList.class, methodType(void.class, Collection.class));
2474 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2475 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2476 assert(orig != copy);
2477 assertEquals(orig, copy);
2478 // a variable-arity constructor:
2479 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2480   ProcessBuilder.class, methodType(void.class, String[].class));
2481 ProcessBuilder pb = (ProcessBuilder)
2482   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2483 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2484          * }&lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-added">2485          *</span>
<span class="line-added">2486          * @apiNote</span>
<span class="line-added">2487          * This method does not find a static {@code &lt;init&gt;} factory method as it is invoked</span>
<span class="line-added">2488          * via {@code invokestatic} bytecode as opposed to {@code invokespecial} for an</span>
<span class="line-added">2489          * object constructor.  To look up static {@code &lt;init&gt;} factory method, use</span>
<span class="line-added">2490          * the {@link #findStatic(Class, String, MethodType) findStatic} method.</span>
<span class="line-added">2491          *</span>
2492          * @param refc the class or interface from which the method is accessed
2493          * @param type the type of the method, with the receiver argument omitted, and a void return type
2494          * @return the desired method handle
2495          * @throws NoSuchMethodException if the constructor does not exist
2496          * @throws IllegalAccessException if access checking fails
2497          *                                or if the method&#39;s variable arity modifier bit
2498          *                                is set and {@code asVarargsCollector} fails
2499          * @throws    SecurityException if a security manager is present and it
2500          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2501          * @throws NullPointerException if any argument is null
2502          */
2503         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2504             if (refc.isArray()) {
2505                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2506             }
<span class="line-added">2507             if (type.returnType() != void.class) {</span>
<span class="line-added">2508                 throw new NoSuchMethodException(&quot;Constructors must have void return type: &quot; + refc.getName());</span>
<span class="line-added">2509             }</span>
2510             String name = &quot;&lt;init&gt;&quot;;
2511             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2512             return getDirectConstructor(refc, ctor);
2513         }
2514 
2515         /**
2516          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2517          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2518          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2519          * and then determines whether the class is accessible to this lookup object.
2520          * &lt;p&gt;
2521          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2522          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2523          *
2524          * @param targetName the fully qualified name of the class to be looked up.
2525          * @return the requested class.
2526          * @throws SecurityException if a security manager is present and it
2527          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2528          * @throws LinkageError if the linkage fails
2529          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
</pre>
<hr />
<pre>
3107          * arguments passed to the method handle.
3108          * &lt;p&gt;
3109          * If the constructor&#39;s {@code accessible} flag is not set,
3110          * access checking is performed immediately on behalf of the lookup class.
3111          * &lt;p&gt;
3112          * The returned method handle will have
3113          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3114          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3115          * &lt;p&gt;
3116          * If the returned method handle is invoked, the constructor&#39;s class will
3117          * be initialized, if it has not already been initialized.
3118          * @param c the reflected constructor
3119          * @return a method handle which can invoke the reflected constructor
3120          * @throws IllegalAccessException if access checking fails
3121          *                                or if the method&#39;s variable arity modifier bit
3122          *                                is set and {@code asVarargsCollector} fails
3123          * @throws NullPointerException if the argument is null
3124          */
3125         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3126             MemberName ctor = new MemberName(c);
<span class="line-modified">3127             assert(ctor.isObjectConstructorOrStaticInitMethod());</span>
3128             @SuppressWarnings(&quot;deprecation&quot;)
3129             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">3130             if (ctor.isObjectConstructor()) {</span>
<span class="line-added">3131                 assert(ctor.getReturnType() == void.class);</span>
<span class="line-added">3132                 return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>
<span class="line-added">3133             } else {</span>
<span class="line-added">3134                 // static init factory is a static method</span>
<span class="line-added">3135                 assert(ctor.isMethod() &amp;&amp; ctor.getReturnType() == ctor.getDeclaringClass() &amp;&amp; ctor.getReferenceKind() == REF_invokeStatic);</span>
<span class="line-added">3136                 assert(!MethodHandleNatives.isCallerSensitive(ctor));  // must not be caller-sensitive</span>
<span class="line-added">3137                 return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), ctor.getDeclaringClass(), ctor, lookup);</span>
<span class="line-added">3138             }</span>
3139         }
3140 
3141         /**
3142          * Produces a method handle giving read access to a reflected field.
3143          * The type of the method handle will have a return type of the field&#39;s
3144          * value type.
3145          * If the field is {@code static}, the method handle will take no arguments.
3146          * Otherwise, its single argument will be the instance containing
3147          * the field.
3148          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3149          * access checking is performed immediately on behalf of the lookup class.
3150          * &lt;p&gt;
3151          * If the field is static, and
3152          * if the returned method handle is invoked, the field&#39;s class will
3153          * be initialized, if it has not already been initialized.
3154          * @param f the reflected field
3155          * @return a method handle which can load values from the reflected field
3156          * @throws IllegalAccessException if access checking fails
3157          * @throws NullPointerException if the argument is null
3158          */
</pre>
<hr />
<pre>
3371             }
3372             Objects.requireNonNull(member.getName());
3373             Objects.requireNonNull(member.getType());
3374             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3375         }
3376 
3377         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3378             if (!isClassAccessible(refc)) {
3379                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3380             }
3381         }
3382 
3383         boolean isClassAccessible(Class&lt;?&gt; refc) {
3384             Objects.requireNonNull(refc);
3385             Class&lt;?&gt; caller = lookupClassOrNull();
3386             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3387         }
3388 
3389         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3390         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<span class="line-modified">3391             // &quot;&lt;init&gt;&quot; can only be invoked via invokespecial or it&#39;s a static init factory</span>
<span class="line-modified">3392             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial &amp;&amp;</span>
<span class="line-added">3393                     !(refKind == REF_invokeStatic &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;))) {</span>
<span class="line-added">3394                     throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">3395             }</span>
3396         }
3397 

3398         /**
3399          * Find my trustable caller class if m is a caller sensitive method.
3400          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3401          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3402          */
3403         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3404             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3405                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3406                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3407             }
3408             return this;
3409         }
3410 
3411         /**
3412          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3413          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3414          *
3415          * @deprecated This method was originally designed to test {@code PRIVATE} access
3416          * that implies full privilege access but {@code MODULE} access has since become
3417          * independent of {@code PRIVATE} access.  It is recommended to call
</pre>
<hr />
<pre>
3462                 }
3463                 return;
3464             }
3465 
3466             // Step 2a:
3467             if (m.isPublic()) return;
3468             if (!fullPowerLookup) {
3469                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3470             }
3471 
3472             // Step 3:
3473             Class&lt;?&gt; defc = m.getDeclaringClass();
3474             if (!fullPowerLookup &amp;&amp; defc != refc) {
3475                 ReflectUtil.checkPackageAccess(defc);
3476             }
3477         }
3478 
3479         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3480             boolean wantStatic = (refKind == REF_invokeStatic);
3481             String message;
<span class="line-modified">3482             if (m.isObjectConstructor())</span>
3483                 message = &quot;expected a method, not a constructor&quot;;
3484             else if (!m.isMethod())
3485                 message = &quot;expected a method&quot;;
3486             else if (wantStatic != m.isStatic())
3487                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3488             else
3489                 { checkAccess(refKind, refc, m); return; }
3490             throw m.makeAccessException(message, this);
3491         }
3492 
3493         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3494             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3495             String message;
3496             if (wantStatic != m.isStatic())
3497                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3498             else
3499                 { checkAccess(refKind, refc, m); return; }
3500             throw m.makeAccessException(message, this);
3501         }
3502 
</pre>
<hr />
<pre>
3761                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3762                 }
3763                 refc = lookupClass();
3764             }
3765             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3766                                              this.allowedModes == TRUSTED &amp;&amp; !getField.getDeclaringClass().isHidden());
3767         }
3768         /** Check access and get the requested constructor. */
3769         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3770             final boolean checkSecurity = true;
3771             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3772         }
3773         /** Check access and get the requested constructor, eliding security manager checks. */
3774         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3775             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3776             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3777         }
3778         /** Common code for all constructors; do not call directly except from immediately above. */
3779         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3780                                                   boolean checkSecurity) throws IllegalAccessException {
<span class="line-modified">3781             assert(ctor.isObjectConstructor());</span>
3782             checkAccess(REF_newInvokeSpecial, refc, ctor);
3783             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3784             if (checkSecurity)
3785                 checkSecurityManager(refc, ctor);
3786             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3787             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3788         }
3789 
3790         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3791          */
3792         /*non-public*/
3793         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3794                 throws ReflectiveOperationException {
3795             if (!(type instanceof Class || type instanceof MethodType))
3796                 throw new InternalError(&quot;unresolved MemberName&quot;);
3797             MemberName member = new MemberName(refKind, defc, name, type);
3798             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3799             if (mh != null) {
3800                 checkSymbolicClass(defc);
3801                 return mh;
</pre>
<hr />
<pre>
3951      * Produces a method handle giving write access to elements of an array,
3952      * as if by the {@code astore} bytecode.
3953      * The type of the method handle will have a void return type.
3954      * Its last argument will be the array&#39;s element type.
3955      * The first and second arguments will be the array type and int.
3956      *
3957      * &lt;p&gt; When the returned method handle is invoked,
3958      * the array reference and array index are checked.
3959      * A {@code NullPointerException} will be thrown if the array reference
3960      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
3961      * thrown if the index is negative or if it is greater than or equal to
3962      * the length of the array.
3963      *
3964      * @param arrayClass the class of an array
3965      * @return a method handle which can store values into the array type
3966      * @throws NullPointerException if the argument is null
3967      * @throws IllegalArgumentException if arrayClass is not an array type
3968      * @jvms 6.5 {@code aastore} Instruction
3969      */
3970     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<span class="line-added">3971         if (arrayClass.isInlineClass()) {</span>
<span class="line-added">3972             throw new UnsupportedOperationException();</span>
<span class="line-added">3973         }</span>
3974         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
3975     }
3976 
3977     /**
3978      * Produces a VarHandle giving access to elements of an array of type
3979      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
3980      * of {@code arrayClass} and the list of coordinate types is
3981      * {@code (arrayClass, int)}, where the {@code int} coordinate type
3982      * corresponds to an argument that is an index into an array.
3983      * &lt;p&gt;
3984      * Certain access modes of the returned VarHandle are unsupported under
3985      * the following conditions:
3986      * &lt;ul&gt;
3987      * &lt;li&gt;if the component type is anything other than {@code byte},
3988      *     {@code short}, {@code char}, {@code int}, {@code long},
3989      *     {@code float}, or {@code double} then numeric atomic update access
3990      *     modes are unsupported.
3991      * &lt;li&gt;if the component type is anything other than {@code boolean},
3992      *     {@code byte}, {@code short}, {@code char}, {@code int} or
3993      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
4714     }
4715 
4716     /**
4717      * Produces a constant method handle of the requested return type which
4718      * returns the default value for that type every time it is invoked.
4719      * The resulting constant method handle will have no side effects.
4720      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4721      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4722      * since {@code explicitCastArguments} converts {@code null} to default values.
4723      * @param type the expected return type of the desired method handle
4724      * @return a constant method handle that takes no arguments
4725      *         and returns the default value of the given type (or void, if the type is void)
4726      * @throws NullPointerException if the argument is null
4727      * @see MethodHandles#constant
4728      * @see MethodHandles#empty
4729      * @see MethodHandles#explicitCastArguments
4730      * @since 9
4731      */
4732     public static MethodHandle zero(Class&lt;?&gt; type) {
4733         Objects.requireNonNull(type);
<span class="line-modified">4734         if (type.isPrimitive()) {</span>
<span class="line-added">4735             return zero(Wrapper.forPrimitiveType(type), type);</span>
<span class="line-added">4736         } else if (type.isInlineClass()) {</span>
<span class="line-added">4737             throw new UnsupportedOperationException();</span>
<span class="line-added">4738         } else {</span>
<span class="line-added">4739             return zero(Wrapper.OBJECT, type);</span>
<span class="line-added">4740         }</span>
4741     }
4742 
4743     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4744         return type == void.class ? zero(type) : identity(type);
4745     }
4746 
4747     /**
4748      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4749      * and returns a suitable default depending on the return type.
4750      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4751      * &lt;p&gt;The returned method handle is equivalent to
4752      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4753      *
4754      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4755      * {@code guardWithTest(pred, target, empty(target.type())}.
4756      * @param type the type of the desired method handle
4757      * @return a constant method handle of the given type, which returns a default value of the given return type
4758      * @throws NullPointerException if the argument is null
4759      * @see MethodHandles#zero
4760      * @see MethodHandles#constant
4761      * @since 9
4762      */
4763     public static  MethodHandle empty(MethodType type) {
4764         Objects.requireNonNull(type);
4765         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4766     }
4767 
4768     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4769     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<span class="line-modified">4770         MethodType mtype = MethodType.methodType(ptype, ptype);</span>
4771         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4772         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4773     }
4774 
4775     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4776         int pos = btw.ordinal();
4777         MethodHandle zero = ZERO_MHS[pos];
4778         if (zero == null) {
4779             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4780         }
4781         if (zero.type().returnType() == rtype)
4782             return zero;
4783         assert(btw == Wrapper.OBJECT);
4784         return makeZero(rtype);
4785     }
4786     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4787     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4788         MethodType mtype = methodType(rtype);
4789         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4790         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
</pre>
</td>
</tr>
</table>
<center><a href="../System.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../module-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
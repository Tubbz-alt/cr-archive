<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../interpreter/templateInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 442           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 443         &quot;sha512_implCompress&quot;,
 444         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 445           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 446         &quot;sha1_implCompressMB&quot;,
 447         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 448           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 449         &quot;sha256_implCompressMB&quot;,
 450         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 451           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 452         &quot;sha512_implCompressMB&quot;,
 453         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 454           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 455         &quot;encodeBlock&quot;,
 456         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+3, ShenandoahStore },   { -1, ShenandoahNone },
 457           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 458       };
 459 
 460       if (call-&gt;is_call_to_arraycopystub()) {
 461         Node* dest = NULL;
<span class="line-modified"> 462         const TypeTuple* args = n-&gt;as_Call()-&gt;_tf-&gt;domain();</span>
 463         for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
 464           if (args-&gt;field_at(i)-&gt;isa_ptr()) {
 465             j++;
 466             if (j == 2) {
 467               dest = n-&gt;in(i);
 468               break;
 469             }
 470           }
 471         }
 472         if (!verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahLoad, trace, barriers_used) ||
 473             !verify_helper(dest, phis, visited, ShenandoahStore, trace, barriers_used)) {
 474           report_verify_failure(&quot;Shenandoah verification: ArrayCopy should have barriers&quot;, n);
 475         }
 476       } else if (strlen(call-&gt;_name) &gt; 5 &amp;&amp;
 477                  !strcmp(call-&gt;_name + strlen(call-&gt;_name) - 5, &quot;_fill&quot;)) {
 478         if (!verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahStore, trace, barriers_used)) {
 479           report_verify_failure(&quot;Shenandoah verification: _fill should have barriers&quot;, n);
 480         }
 481       } else if (!strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;)) {
 482         // skip
</pre>
<hr />
<pre>
 561         { { 2, ShenandoahLoad },                  { 4, ShenandoahLoad } },
 562         Op_StrEquals,
 563         { { 2, ShenandoahLoad },                  { 3, ShenandoahLoad } },
 564         Op_EncodeISOArray,
 565         { { 2, ShenandoahLoad },                  { 3, ShenandoahStore } },
 566         Op_HasNegatives,
 567         { { 2, ShenandoahLoad },                  { -1, ShenandoahNone} },
 568         Op_CastP2X,
 569         { { 1, ShenandoahLoad },                  { -1, ShenandoahNone} },
 570         Op_StrIndexOfChar,
 571         { { 2, ShenandoahLoad },                  { -1, ShenandoahNone } },
 572       };
 573 
 574       const int others_len = sizeof(others) / sizeof(others[0]);
 575       int i = 0;
 576       for (; i &lt; others_len; i++) {
 577         if (others[i].opcode == n-&gt;Opcode()) {
 578           break;
 579         }
 580       }
<span class="line-modified"> 581       uint stop = n-&gt;is_Call() ? n-&gt;as_Call()-&gt;tf()-&gt;domain()-&gt;cnt() : n-&gt;req();</span>
 582       if (i != others_len) {
 583         const uint inputs_len = sizeof(others[0].inputs) / sizeof(others[0].inputs[0]);
 584         for (uint j = 0; j &lt; inputs_len; j++) {
 585           int pos = others[i].inputs[j].pos;
 586           if (pos == -1) {
 587             break;
 588           }
 589           if (!verify_helper(n-&gt;in(pos), phis, visited, others[i].inputs[j].t, trace, barriers_used)) {
 590             report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
 591           }
 592         }
 593         for (uint j = 1; j &lt; stop; j++) {
 594           if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 595               n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
 596             uint k = 0;
 597             for (; k &lt; inputs_len &amp;&amp; others[i].inputs[k].pos != (int)j; k++);
 598             if (k == inputs_len) {
 599               fatal(&quot;arg %d for node %s not covered&quot;, j, n-&gt;Name());
 600             }
 601           }
</pre>
<hr />
<pre>
 781     mem_ctrl = phase-&gt;ctrl_or_self(mem);
 782   }
 783   return mem;
 784 }
 785 
 786 Node* ShenandoahBarrierC2Support::find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase) {
 787   Node* mem = NULL;
 788   Node* c = ctrl;
 789   do {
 790     if (c-&gt;is_Region()) {
 791       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {
 792         Node* u = c-&gt;fast_out(i);
 793         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {
 794           if (u-&gt;adr_type() == TypePtr::BOTTOM) {
 795             mem = u;
 796           }
 797         }
 798       }
 799     } else {
 800       if (c-&gt;is_Call() &amp;&amp; c-&gt;as_Call()-&gt;adr_type() != NULL) {
<span class="line-modified"> 801         CallProjections projs;</span>
<span class="line-modified"> 802         c-&gt;as_Call()-&gt;extract_projections(&amp;projs, true, false);</span>
<span class="line-modified"> 803         if (projs.fallthrough_memproj != NULL) {</span>
<span class="line-modified"> 804           if (projs.fallthrough_memproj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-modified"> 805             if (projs.catchall_memproj == NULL) {</span>
<span class="line-removed"> 806               mem = projs.fallthrough_memproj;</span>
 807             } else {
<span class="line-modified"> 808               if (phase-&gt;is_dominator(projs.fallthrough_catchproj, ctrl)) {</span>
<span class="line-modified"> 809                 mem = projs.fallthrough_memproj;</span>
 810               } else {
<span class="line-modified"> 811                 assert(phase-&gt;is_dominator(projs.catchall_catchproj, ctrl), &quot;one proj must dominate barrier&quot;);</span>
<span class="line-modified"> 812                 mem = projs.catchall_memproj;</span>
 813               }
 814             }
 815           }
 816         } else {
 817           Node* proj = c-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory);
 818           if (proj != NULL &amp;&amp;
 819               proj-&gt;adr_type() == TypePtr::BOTTOM) {
 820             mem = proj;
 821           }
 822         }
 823       } else {
 824         for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax; i++) {
 825           Node* u = c-&gt;fast_out(i);
 826           if (u-&gt;is_Proj() &amp;&amp;
 827               u-&gt;bottom_type() == Type::MEMORY &amp;&amp;
 828               u-&gt;adr_type() == TypePtr::BOTTOM) {
 829               assert(c-&gt;is_SafePoint() || c-&gt;is_MemBar() || c-&gt;is_Start(), &quot;&quot;);
 830               assert(mem == NULL, &quot;only one proj&quot;);
 831               mem = u;
 832           }
</pre>
<hr />
<pre>
1025       if (c != ctrl ||
1026           is_dominator_same_ctrl(old_c, barrier, u, phase) ||
1027           ShenandoahBarrierSetC2::is_shenandoah_state_load(u)) {
1028         phase-&gt;igvn().rehash_node_delayed(u);
1029         int nb = u-&gt;replace_edge(ctrl, region);
1030         if (u-&gt;is_CFG()) {
1031           if (phase-&gt;idom(u) == ctrl) {
1032             phase-&gt;set_idom(u, region, phase-&gt;dom_depth(region));
1033           }
1034         } else if (phase-&gt;get_ctrl(u) == ctrl) {
1035           assert(u != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1036           uses.push(u);
1037         }
1038         assert(nb == 1, &quot;more than 1 ctrl input?&quot;);
1039         --i, imax -= nb;
1040       }
1041     }
1042   }
1043 }
1044 
<span class="line-modified">1045 static Node* create_phis_on_call_return(Node* ctrl, Node* c, Node* n, Node* n_clone, const CallProjections&amp; projs, PhaseIdealLoop* phase) {</span>
1046   Node* region = NULL;
1047   while (c != ctrl) {
1048     if (c-&gt;is_Region()) {
1049       region = c;
1050     }
1051     c = phase-&gt;idom(c);
1052   }
1053   assert(region != NULL, &quot;&quot;);
1054   Node* phi = new PhiNode(region, n-&gt;bottom_type());
1055   for (uint j = 1; j &lt; region-&gt;req(); j++) {
1056     Node* in = region-&gt;in(j);
<span class="line-modified">1057     if (phase-&gt;is_dominator(projs.fallthrough_catchproj, in)) {</span>
1058       phi-&gt;init_req(j, n);
<span class="line-modified">1059     } else if (phase-&gt;is_dominator(projs.catchall_catchproj, in)) {</span>
1060       phi-&gt;init_req(j, n_clone);
1061     } else {
1062       phi-&gt;init_req(j, create_phis_on_call_return(ctrl, in, n, n_clone, projs, phase));
1063     }
1064   }
1065   phase-&gt;register_new_node(phi, region);
1066   return phi;
1067 }
1068 
1069 void ShenandoahBarrierC2Support::pin_and_expand(PhaseIdealLoop* phase) {
1070   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();
1071 
1072   Unique_Node_List uses;
1073   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {
1074     Node* barrier = state-&gt;enqueue_barrier(i);
1075     Node* ctrl = phase-&gt;get_ctrl(barrier);
1076     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1077     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1078       // Expanding a barrier here will break loop strip mining
1079       // verification. Transform the loop so the loop nest doesn&#39;t
</pre>
<hr />
<pre>
1157               if (phase-&gt;has_ctrl(in)) {
1158                 if (phase-&gt;is_dominator(call, phase-&gt;get_ctrl(in))) {
1159 #ifdef ASSERT
1160                   for (uint i = 0; i &lt; stack.size(); i++) {
1161                     assert(stack.node_at(i) != in, &quot;node shouldn&#39;t have been seen yet&quot;);
1162                   }
1163 #endif
1164                   stack.push(in, 0);
1165                 }
1166               } else {
1167                 assert(phase-&gt;is_dominator(in, call-&gt;in(0)), &quot;no dependency on the call&quot;);
1168               }
1169             }
1170           } else {
1171             phase-&gt;set_ctrl(n, call-&gt;in(0));
1172             stack.pop();
1173           }
1174         } while(stack.size() &gt; 0);
1175         continue;
1176       }
<span class="line-modified">1177       CallProjections projs;</span>
<span class="line-removed">1178       call-&gt;extract_projections(&amp;projs, false, false);</span>
<span class="line-removed">1179 </span>
1180 #ifdef ASSERT
1181       VectorSet cloned(Thread::current()-&gt;resource_area());
1182 #endif
1183       Node* lrb_clone = lrb-&gt;clone();
<span class="line-modified">1184       phase-&gt;register_new_node(lrb_clone, projs.catchall_catchproj);</span>
<span class="line-modified">1185       phase-&gt;set_ctrl(lrb, projs.fallthrough_catchproj);</span>
1186 
1187       stack.push(lrb, 0);
1188       clones.push(lrb_clone);
1189 
1190       do {
1191         assert(stack.size() == clones.size(), &quot;&quot;);
1192         Node* n = stack.node();
1193 #ifdef ASSERT
1194         if (n-&gt;is_Load()) {
1195           Node* mem = n-&gt;in(MemNode::Memory);
1196           for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1197             Node* u = mem-&gt;fast_out(j);
1198             assert(!u-&gt;is_Store() || !u-&gt;is_LoadStore() || phase-&gt;get_ctrl(u) != ctrl, &quot;anti dependent store?&quot;);
1199           }
1200         }
1201 #endif
1202         uint idx = stack.index();
1203         Node* n_clone = clones.at(clones.size()-1);
1204         if (idx &lt; n-&gt;outcnt()) {
1205           Node* u = n-&gt;raw_out(idx);
1206           Node* c = phase-&gt;ctrl_or_self(u);
<span class="line-modified">1207           if (phase-&gt;is_dominator(call, c) &amp;&amp; phase-&gt;is_dominator(c, projs.fallthrough_proj)) {</span>
1208             stack.set_index(idx+1);
1209             assert(!u-&gt;is_CFG(), &quot;&quot;);
1210             stack.push(u, 0);
1211             assert(!cloned.test_set(u-&gt;_idx), &quot;only one clone&quot;);
1212             Node* u_clone = u-&gt;clone();
1213             int nb = u_clone-&gt;replace_edge(n, n_clone);
1214             assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
<span class="line-modified">1215             phase-&gt;register_new_node(u_clone, projs.catchall_catchproj);</span>
1216             clones.push(u_clone);
<span class="line-modified">1217             phase-&gt;set_ctrl(u, projs.fallthrough_catchproj);</span>
1218           } else {
1219             bool replaced = false;
1220             if (u-&gt;is_Phi()) {
1221               for (uint k = 1; k &lt; u-&gt;req(); k++) {
1222                 if (u-&gt;in(k) == n) {
<span class="line-modified">1223                   if (phase-&gt;is_dominator(projs.catchall_catchproj, u-&gt;in(0)-&gt;in(k))) {</span>
1224                     phase-&gt;igvn().replace_input_of(u, k, n_clone);
1225                     replaced = true;
<span class="line-modified">1226                   } else if (!phase-&gt;is_dominator(projs.fallthrough_catchproj, u-&gt;in(0)-&gt;in(k))) {</span>
1227                     phase-&gt;igvn().replace_input_of(u, k, create_phis_on_call_return(ctrl, u-&gt;in(0)-&gt;in(k), n, n_clone, projs, phase));
1228                     replaced = true;
1229                   }
1230                 }
1231               }
1232             } else {
<span class="line-modified">1233               if (phase-&gt;is_dominator(projs.catchall_catchproj, c)) {</span>
1234                 phase-&gt;igvn().rehash_node_delayed(u);
1235                 int nb = u-&gt;replace_edge(n, n_clone);
1236                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1237                 replaced = true;
<span class="line-modified">1238               } else if (!phase-&gt;is_dominator(projs.fallthrough_catchproj, c)) {</span>
1239                 if (u-&gt;is_If()) {
1240                   // Can&#39;t break If/Bool/Cmp chain
1241                   assert(n-&gt;is_Bool(), &quot;unexpected If shape&quot;);
1242                   assert(stack.node_at(stack.size()-2)-&gt;is_Cmp(), &quot;unexpected If shape&quot;);
1243                   assert(n_clone-&gt;is_Bool(), &quot;unexpected clone&quot;);
1244                   assert(clones.at(clones.size()-2)-&gt;is_Cmp(), &quot;unexpected clone&quot;);
1245                   Node* bol_clone = n-&gt;clone();
1246                   Node* cmp_clone = stack.node_at(stack.size()-2)-&gt;clone();
1247                   bol_clone-&gt;set_req(1, cmp_clone);
1248 
1249                   Node* nn = stack.node_at(stack.size()-3);
1250                   Node* nn_clone = clones.at(clones.size()-3);
1251                   assert(nn-&gt;Opcode() == nn_clone-&gt;Opcode(), &quot;mismatch&quot;);
1252 
1253                   int nb = cmp_clone-&gt;replace_edge(nn, create_phis_on_call_return(ctrl, c, nn, nn_clone, projs, phase));
1254                   assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1255 
1256                   phase-&gt;register_new_node(bol_clone, u-&gt;in(0));
1257                   phase-&gt;register_new_node(cmp_clone, u-&gt;in(0));
1258 
</pre>
<hr />
<pre>
2373         Node* u = c-&gt;fast_out(i);
2374         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;
2375             u != n) {
2376           if (u-&gt;adr_type() == TypePtr::BOTTOM) {
2377             fix_memory_uses(u, n, n, c);
2378           } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
2379             _phase-&gt;lazy_replace(u, n);
2380             --i; --imax;
2381           }
2382         }
2383       }
2384     }
2385   }
2386 }
2387 
2388 Node* MemoryGraphFixer::get_ctrl(Node* n) const {
2389   Node* c = _phase-&gt;get_ctrl(n);
2390   if (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_Call()) {
2391     assert(c == n-&gt;in(0), &quot;&quot;);
2392     CallNode* call = c-&gt;as_Call();
<span class="line-modified">2393     CallProjections projs;</span>
<span class="line-modified">2394     call-&gt;extract_projections(&amp;projs, true, false);</span>
<span class="line-modified">2395     if (projs.catchall_memproj != NULL) {</span>
<span class="line-modified">2396       if (projs.fallthrough_memproj == n) {</span>
<span class="line-removed">2397         c = projs.fallthrough_catchproj;</span>
2398       } else {
<span class="line-modified">2399         assert(projs.catchall_memproj == n, &quot;&quot;);</span>
<span class="line-modified">2400         c = projs.catchall_catchproj;</span>
2401       }
2402     }
2403   }
2404   return c;
2405 }
2406 
2407 Node* MemoryGraphFixer::ctrl_or_self(Node* n) const {
2408   if (_phase-&gt;has_ctrl(n))
2409     return get_ctrl(n);
2410   else {
2411     assert (n-&gt;is_CFG(), &quot;must be a CFG node&quot;);
2412     return n;
2413   }
2414 }
2415 
2416 bool MemoryGraphFixer::mem_is_valid(Node* m, Node* c) const {
2417   return m != NULL &amp;&amp; get_ctrl(m) == c;
2418 }
2419 
2420 Node* MemoryGraphFixer::find_mem(Node* ctrl, Node* n) const {
</pre>
</td>
<td>
<hr />
<pre>
 442           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 443         &quot;sha512_implCompress&quot;,
 444         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 445           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 446         &quot;sha1_implCompressMB&quot;,
 447         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 448           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 449         &quot;sha256_implCompressMB&quot;,
 450         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 451           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 452         &quot;sha512_implCompressMB&quot;,
 453         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 454           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 455         &quot;encodeBlock&quot;,
 456         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+3, ShenandoahStore },   { -1, ShenandoahNone },
 457           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 458       };
 459 
 460       if (call-&gt;is_call_to_arraycopystub()) {
 461         Node* dest = NULL;
<span class="line-modified"> 462         const TypeTuple* args = n-&gt;as_Call()-&gt;_tf-&gt;domain_sig();</span>
 463         for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
 464           if (args-&gt;field_at(i)-&gt;isa_ptr()) {
 465             j++;
 466             if (j == 2) {
 467               dest = n-&gt;in(i);
 468               break;
 469             }
 470           }
 471         }
 472         if (!verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahLoad, trace, barriers_used) ||
 473             !verify_helper(dest, phis, visited, ShenandoahStore, trace, barriers_used)) {
 474           report_verify_failure(&quot;Shenandoah verification: ArrayCopy should have barriers&quot;, n);
 475         }
 476       } else if (strlen(call-&gt;_name) &gt; 5 &amp;&amp;
 477                  !strcmp(call-&gt;_name + strlen(call-&gt;_name) - 5, &quot;_fill&quot;)) {
 478         if (!verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahStore, trace, barriers_used)) {
 479           report_verify_failure(&quot;Shenandoah verification: _fill should have barriers&quot;, n);
 480         }
 481       } else if (!strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;)) {
 482         // skip
</pre>
<hr />
<pre>
 561         { { 2, ShenandoahLoad },                  { 4, ShenandoahLoad } },
 562         Op_StrEquals,
 563         { { 2, ShenandoahLoad },                  { 3, ShenandoahLoad } },
 564         Op_EncodeISOArray,
 565         { { 2, ShenandoahLoad },                  { 3, ShenandoahStore } },
 566         Op_HasNegatives,
 567         { { 2, ShenandoahLoad },                  { -1, ShenandoahNone} },
 568         Op_CastP2X,
 569         { { 1, ShenandoahLoad },                  { -1, ShenandoahNone} },
 570         Op_StrIndexOfChar,
 571         { { 2, ShenandoahLoad },                  { -1, ShenandoahNone } },
 572       };
 573 
 574       const int others_len = sizeof(others) / sizeof(others[0]);
 575       int i = 0;
 576       for (; i &lt; others_len; i++) {
 577         if (others[i].opcode == n-&gt;Opcode()) {
 578           break;
 579         }
 580       }
<span class="line-modified"> 581       uint stop = n-&gt;is_Call() ? n-&gt;as_Call()-&gt;tf()-&gt;domain_sig()-&gt;cnt() : n-&gt;req();</span>
 582       if (i != others_len) {
 583         const uint inputs_len = sizeof(others[0].inputs) / sizeof(others[0].inputs[0]);
 584         for (uint j = 0; j &lt; inputs_len; j++) {
 585           int pos = others[i].inputs[j].pos;
 586           if (pos == -1) {
 587             break;
 588           }
 589           if (!verify_helper(n-&gt;in(pos), phis, visited, others[i].inputs[j].t, trace, barriers_used)) {
 590             report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
 591           }
 592         }
 593         for (uint j = 1; j &lt; stop; j++) {
 594           if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 595               n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
 596             uint k = 0;
 597             for (; k &lt; inputs_len &amp;&amp; others[i].inputs[k].pos != (int)j; k++);
 598             if (k == inputs_len) {
 599               fatal(&quot;arg %d for node %s not covered&quot;, j, n-&gt;Name());
 600             }
 601           }
</pre>
<hr />
<pre>
 781     mem_ctrl = phase-&gt;ctrl_or_self(mem);
 782   }
 783   return mem;
 784 }
 785 
 786 Node* ShenandoahBarrierC2Support::find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase) {
 787   Node* mem = NULL;
 788   Node* c = ctrl;
 789   do {
 790     if (c-&gt;is_Region()) {
 791       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {
 792         Node* u = c-&gt;fast_out(i);
 793         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {
 794           if (u-&gt;adr_type() == TypePtr::BOTTOM) {
 795             mem = u;
 796           }
 797         }
 798       }
 799     } else {
 800       if (c-&gt;is_Call() &amp;&amp; c-&gt;as_Call()-&gt;adr_type() != NULL) {
<span class="line-modified"> 801         CallProjections* projs = c-&gt;as_Call()-&gt;extract_projections(true, false);</span>
<span class="line-modified"> 802         if (projs-&gt;fallthrough_memproj != NULL) {</span>
<span class="line-modified"> 803           if (projs-&gt;fallthrough_memproj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-modified"> 804             if (projs-&gt;catchall_memproj == NULL) {</span>
<span class="line-modified"> 805               mem = projs-&gt;fallthrough_memproj;</span>

 806             } else {
<span class="line-modified"> 807               if (phase-&gt;is_dominator(projs-&gt;fallthrough_catchproj, ctrl)) {</span>
<span class="line-modified"> 808                 mem = projs-&gt;fallthrough_memproj;</span>
 809               } else {
<span class="line-modified"> 810                 assert(phase-&gt;is_dominator(projs-&gt;catchall_catchproj, ctrl), &quot;one proj must dominate barrier&quot;);</span>
<span class="line-modified"> 811                 mem = projs-&gt;catchall_memproj;</span>
 812               }
 813             }
 814           }
 815         } else {
 816           Node* proj = c-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory);
 817           if (proj != NULL &amp;&amp;
 818               proj-&gt;adr_type() == TypePtr::BOTTOM) {
 819             mem = proj;
 820           }
 821         }
 822       } else {
 823         for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax; i++) {
 824           Node* u = c-&gt;fast_out(i);
 825           if (u-&gt;is_Proj() &amp;&amp;
 826               u-&gt;bottom_type() == Type::MEMORY &amp;&amp;
 827               u-&gt;adr_type() == TypePtr::BOTTOM) {
 828               assert(c-&gt;is_SafePoint() || c-&gt;is_MemBar() || c-&gt;is_Start(), &quot;&quot;);
 829               assert(mem == NULL, &quot;only one proj&quot;);
 830               mem = u;
 831           }
</pre>
<hr />
<pre>
1024       if (c != ctrl ||
1025           is_dominator_same_ctrl(old_c, barrier, u, phase) ||
1026           ShenandoahBarrierSetC2::is_shenandoah_state_load(u)) {
1027         phase-&gt;igvn().rehash_node_delayed(u);
1028         int nb = u-&gt;replace_edge(ctrl, region);
1029         if (u-&gt;is_CFG()) {
1030           if (phase-&gt;idom(u) == ctrl) {
1031             phase-&gt;set_idom(u, region, phase-&gt;dom_depth(region));
1032           }
1033         } else if (phase-&gt;get_ctrl(u) == ctrl) {
1034           assert(u != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1035           uses.push(u);
1036         }
1037         assert(nb == 1, &quot;more than 1 ctrl input?&quot;);
1038         --i, imax -= nb;
1039       }
1040     }
1041   }
1042 }
1043 
<span class="line-modified">1044 static Node* create_phis_on_call_return(Node* ctrl, Node* c, Node* n, Node* n_clone, const CallProjections* projs, PhaseIdealLoop* phase) {</span>
1045   Node* region = NULL;
1046   while (c != ctrl) {
1047     if (c-&gt;is_Region()) {
1048       region = c;
1049     }
1050     c = phase-&gt;idom(c);
1051   }
1052   assert(region != NULL, &quot;&quot;);
1053   Node* phi = new PhiNode(region, n-&gt;bottom_type());
1054   for (uint j = 1; j &lt; region-&gt;req(); j++) {
1055     Node* in = region-&gt;in(j);
<span class="line-modified">1056     if (phase-&gt;is_dominator(projs-&gt;fallthrough_catchproj, in)) {</span>
1057       phi-&gt;init_req(j, n);
<span class="line-modified">1058     } else if (phase-&gt;is_dominator(projs-&gt;catchall_catchproj, in)) {</span>
1059       phi-&gt;init_req(j, n_clone);
1060     } else {
1061       phi-&gt;init_req(j, create_phis_on_call_return(ctrl, in, n, n_clone, projs, phase));
1062     }
1063   }
1064   phase-&gt;register_new_node(phi, region);
1065   return phi;
1066 }
1067 
1068 void ShenandoahBarrierC2Support::pin_and_expand(PhaseIdealLoop* phase) {
1069   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();
1070 
1071   Unique_Node_List uses;
1072   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {
1073     Node* barrier = state-&gt;enqueue_barrier(i);
1074     Node* ctrl = phase-&gt;get_ctrl(barrier);
1075     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1076     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1077       // Expanding a barrier here will break loop strip mining
1078       // verification. Transform the loop so the loop nest doesn&#39;t
</pre>
<hr />
<pre>
1156               if (phase-&gt;has_ctrl(in)) {
1157                 if (phase-&gt;is_dominator(call, phase-&gt;get_ctrl(in))) {
1158 #ifdef ASSERT
1159                   for (uint i = 0; i &lt; stack.size(); i++) {
1160                     assert(stack.node_at(i) != in, &quot;node shouldn&#39;t have been seen yet&quot;);
1161                   }
1162 #endif
1163                   stack.push(in, 0);
1164                 }
1165               } else {
1166                 assert(phase-&gt;is_dominator(in, call-&gt;in(0)), &quot;no dependency on the call&quot;);
1167               }
1168             }
1169           } else {
1170             phase-&gt;set_ctrl(n, call-&gt;in(0));
1171             stack.pop();
1172           }
1173         } while(stack.size() &gt; 0);
1174         continue;
1175       }
<span class="line-modified">1176       CallProjections* projs = call-&gt;extract_projections(false, false);</span>


1177 #ifdef ASSERT
1178       VectorSet cloned(Thread::current()-&gt;resource_area());
1179 #endif
1180       Node* lrb_clone = lrb-&gt;clone();
<span class="line-modified">1181       phase-&gt;register_new_node(lrb_clone, projs-&gt;catchall_catchproj);</span>
<span class="line-modified">1182       phase-&gt;set_ctrl(lrb, projs-&gt;fallthrough_catchproj);</span>
1183 
1184       stack.push(lrb, 0);
1185       clones.push(lrb_clone);
1186 
1187       do {
1188         assert(stack.size() == clones.size(), &quot;&quot;);
1189         Node* n = stack.node();
1190 #ifdef ASSERT
1191         if (n-&gt;is_Load()) {
1192           Node* mem = n-&gt;in(MemNode::Memory);
1193           for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1194             Node* u = mem-&gt;fast_out(j);
1195             assert(!u-&gt;is_Store() || !u-&gt;is_LoadStore() || phase-&gt;get_ctrl(u) != ctrl, &quot;anti dependent store?&quot;);
1196           }
1197         }
1198 #endif
1199         uint idx = stack.index();
1200         Node* n_clone = clones.at(clones.size()-1);
1201         if (idx &lt; n-&gt;outcnt()) {
1202           Node* u = n-&gt;raw_out(idx);
1203           Node* c = phase-&gt;ctrl_or_self(u);
<span class="line-modified">1204           if (phase-&gt;is_dominator(call, c) &amp;&amp; phase-&gt;is_dominator(c, projs-&gt;fallthrough_proj)) {</span>
1205             stack.set_index(idx+1);
1206             assert(!u-&gt;is_CFG(), &quot;&quot;);
1207             stack.push(u, 0);
1208             assert(!cloned.test_set(u-&gt;_idx), &quot;only one clone&quot;);
1209             Node* u_clone = u-&gt;clone();
1210             int nb = u_clone-&gt;replace_edge(n, n_clone);
1211             assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
<span class="line-modified">1212             phase-&gt;register_new_node(u_clone, projs-&gt;catchall_catchproj);</span>
1213             clones.push(u_clone);
<span class="line-modified">1214             phase-&gt;set_ctrl(u, projs-&gt;fallthrough_catchproj);</span>
1215           } else {
1216             bool replaced = false;
1217             if (u-&gt;is_Phi()) {
1218               for (uint k = 1; k &lt; u-&gt;req(); k++) {
1219                 if (u-&gt;in(k) == n) {
<span class="line-modified">1220                   if (phase-&gt;is_dominator(projs-&gt;catchall_catchproj, u-&gt;in(0)-&gt;in(k))) {</span>
1221                     phase-&gt;igvn().replace_input_of(u, k, n_clone);
1222                     replaced = true;
<span class="line-modified">1223                   } else if (!phase-&gt;is_dominator(projs-&gt;fallthrough_catchproj, u-&gt;in(0)-&gt;in(k))) {</span>
1224                     phase-&gt;igvn().replace_input_of(u, k, create_phis_on_call_return(ctrl, u-&gt;in(0)-&gt;in(k), n, n_clone, projs, phase));
1225                     replaced = true;
1226                   }
1227                 }
1228               }
1229             } else {
<span class="line-modified">1230               if (phase-&gt;is_dominator(projs-&gt;catchall_catchproj, c)) {</span>
1231                 phase-&gt;igvn().rehash_node_delayed(u);
1232                 int nb = u-&gt;replace_edge(n, n_clone);
1233                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1234                 replaced = true;
<span class="line-modified">1235               } else if (!phase-&gt;is_dominator(projs-&gt;fallthrough_catchproj, c)) {</span>
1236                 if (u-&gt;is_If()) {
1237                   // Can&#39;t break If/Bool/Cmp chain
1238                   assert(n-&gt;is_Bool(), &quot;unexpected If shape&quot;);
1239                   assert(stack.node_at(stack.size()-2)-&gt;is_Cmp(), &quot;unexpected If shape&quot;);
1240                   assert(n_clone-&gt;is_Bool(), &quot;unexpected clone&quot;);
1241                   assert(clones.at(clones.size()-2)-&gt;is_Cmp(), &quot;unexpected clone&quot;);
1242                   Node* bol_clone = n-&gt;clone();
1243                   Node* cmp_clone = stack.node_at(stack.size()-2)-&gt;clone();
1244                   bol_clone-&gt;set_req(1, cmp_clone);
1245 
1246                   Node* nn = stack.node_at(stack.size()-3);
1247                   Node* nn_clone = clones.at(clones.size()-3);
1248                   assert(nn-&gt;Opcode() == nn_clone-&gt;Opcode(), &quot;mismatch&quot;);
1249 
1250                   int nb = cmp_clone-&gt;replace_edge(nn, create_phis_on_call_return(ctrl, c, nn, nn_clone, projs, phase));
1251                   assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1252 
1253                   phase-&gt;register_new_node(bol_clone, u-&gt;in(0));
1254                   phase-&gt;register_new_node(cmp_clone, u-&gt;in(0));
1255 
</pre>
<hr />
<pre>
2370         Node* u = c-&gt;fast_out(i);
2371         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;
2372             u != n) {
2373           if (u-&gt;adr_type() == TypePtr::BOTTOM) {
2374             fix_memory_uses(u, n, n, c);
2375           } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
2376             _phase-&gt;lazy_replace(u, n);
2377             --i; --imax;
2378           }
2379         }
2380       }
2381     }
2382   }
2383 }
2384 
2385 Node* MemoryGraphFixer::get_ctrl(Node* n) const {
2386   Node* c = _phase-&gt;get_ctrl(n);
2387   if (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_Call()) {
2388     assert(c == n-&gt;in(0), &quot;&quot;);
2389     CallNode* call = c-&gt;as_Call();
<span class="line-modified">2390     CallProjections* projs = call-&gt;extract_projections(true, false);</span>
<span class="line-modified">2391     if (projs-&gt;catchall_memproj != NULL) {</span>
<span class="line-modified">2392       if (projs-&gt;fallthrough_memproj == n) {</span>
<span class="line-modified">2393         c = projs-&gt;fallthrough_catchproj;</span>

2394       } else {
<span class="line-modified">2395         assert(projs-&gt;catchall_memproj == n, &quot;&quot;);</span>
<span class="line-modified">2396         c = projs-&gt;catchall_catchproj;</span>
2397       }
2398     }
2399   }
2400   return c;
2401 }
2402 
2403 Node* MemoryGraphFixer::ctrl_or_self(Node* n) const {
2404   if (_phase-&gt;has_ctrl(n))
2405     return get_ctrl(n);
2406   else {
2407     assert (n-&gt;is_CFG(), &quot;must be a CFG node&quot;);
2408     return n;
2409   }
2410 }
2411 
2412 bool MemoryGraphFixer::mem_is_valid(Node* m, Node* c) const {
2413   return m != NULL &amp;&amp; get_ctrl(m) == c;
2414 }
2415 
2416 Node* MemoryGraphFixer::find_mem(Node* ctrl, Node* n) const {
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../interpreter/templateInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../interpreter/templateInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../memory/oopFactory.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1242           if (initialSkip &gt; 0) {
1243             initialSkip--;
1244           } else {
1245             ScopeDesc* scope = cvf-&gt;scope();
1246             // native wrappers do not have a scope
1247             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1248               GrowableArray&lt;ScopeValue*&gt;* objects;
1249               if (!realloc_called) {
1250                 objects = scope-&gt;objects();
1251               } else {
1252                 // some object might already have been re-allocated, only reallocate the non-allocated ones
1253                 objects = new GrowableArray&lt;ScopeValue*&gt;(scope-&gt;objects()-&gt;length());
1254                 for (int i = 0; i &lt; scope-&gt;objects()-&gt;length(); i++) {
1255                   ObjectValue* sv = (ObjectValue*) scope-&gt;objects()-&gt;at(i);
1256                   if (sv-&gt;value().is_null()) {
1257                     objects-&gt;append(sv);
1258                   }
1259                 }
1260               }
1261               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);
<span class="line-modified">1262               Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);</span>
1263               realloc_called = true;
1264 
1265               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1266               assert(local_values != NULL, &quot;NULL locals&quot;);
1267               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1268               typeArrayHandle array(THREAD, array_oop);
1269               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1270                 ScopeValue* value = local_values-&gt;at(i);
1271                 if (value-&gt;is_object()) {
1272                   array-&gt;bool_at_put(i, true);
1273                 }
1274               }
1275               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());
1276             } else {
1277               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);
1278             }
1279 
1280             locals = cvf-&gt;locals();
1281             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf-&gt;bci());
1282             methodHandle mh(THREAD, cvf-&gt;method());
</pre>
<hr />
<pre>
1502       break;
1503     }
1504     vf = vf-&gt;sender();
1505   }
1506 
1507   int last_frame_number = JVMCIENV-&gt;get_HotSpotStackFrameReference_frameNumber(hs_frame);
1508   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1509     JVMCI_THROW_MSG(IllegalStateException, &quot;invalid frame number&quot;);
1510   }
1511 
1512   // Reallocate the non-escaping objects and restore their fields.
1513   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,&quot;invalid scope&quot;);
1514   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1515 
1516   if (objects == NULL) {
1517     // no objects to materialize
1518     return;
1519   }
1520 
1521   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, CHECK);
<span class="line-modified">1522   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);</span>
1523 
1524   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1525     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1526 
1527     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1528     StackValueCollection* locals = cvf-&gt;locals();
1529     if (locals != NULL) {
1530       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1531         StackValue* var = locals-&gt;at(i2);
1532         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1533           jvalue val;
1534           val.l = cast_from_oop&lt;jobject&gt;(locals-&gt;at(i2)-&gt;get_obj()());
1535           cvf-&gt;update_local(T_OBJECT, i2, val);
1536         }
1537       }
1538     }
1539 
1540     GrowableArray&lt;ScopeValue*&gt;* scopeExpressions = cvf-&gt;scope()-&gt;expressions();
1541     StackValueCollection* expressions = cvf-&gt;expressions();
1542     if (expressions != NULL) {
</pre>
<hr />
<pre>
1890   return JVMCIENV-&gt;get_jobject(result);
1891 C2V_END
1892 
1893 C2V_VMENTRY_NULL(jobjectArray, getDeclaredConstructors, (JNIEnv* env, jobject, jobject holder))
1894   if (holder == NULL) {
1895     JVMCI_THROW_0(NullPointerException);
1896   }
1897   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1898   if (!klass-&gt;is_instance_klass()) {
1899     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1900     return JVMCIENV-&gt;get_jobjectArray(methods);
1901   }
1902 
1903   InstanceKlass* iklass = InstanceKlass::cast(klass);
1904   // Ensure class is linked
1905   iklass-&gt;link_class(CHECK_NULL);
1906 
1907   GrowableArray&lt;Method*&gt; constructors_array;
1908   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1909     Method* m = iklass-&gt;methods()-&gt;at(i);
<span class="line-modified">1910     if (m-&gt;is_initializer() &amp;&amp; !m-&gt;is_static()) {</span>
1911       constructors_array.append(m);
1912     }
1913   }
1914   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(constructors_array.length(), JVMCI_CHECK_NULL);
1915   for (int i = 0; i &lt; constructors_array.length(); i++) {
1916     methodHandle ctor(THREAD, constructors_array.at(i));
1917     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(ctor, JVMCI_CHECK_NULL);
1918     JVMCIENV-&gt;put_object_at(methods, i, method);
1919   }
1920   return JVMCIENV-&gt;get_jobjectArray(methods);
1921 C2V_END
1922 
1923 C2V_VMENTRY_NULL(jobjectArray, getDeclaredMethods, (JNIEnv* env, jobject, jobject holder))
1924   if (holder == NULL) {
1925     JVMCI_THROW_0(NullPointerException);
1926   }
1927   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1928   if (!klass-&gt;is_instance_klass()) {
1929     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1930     return JVMCIENV-&gt;get_jobjectArray(methods);
1931   }
1932 
1933   InstanceKlass* iklass = InstanceKlass::cast(klass);
1934   // Ensure class is linked
1935   iklass-&gt;link_class(CHECK_NULL);
1936 
1937   GrowableArray&lt;Method*&gt; methods_array;
1938   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1939     Method* m = iklass-&gt;methods()-&gt;at(i);
<span class="line-modified">1940     if (!m-&gt;is_initializer() &amp;&amp; !m-&gt;is_overpass()) {</span>
1941       methods_array.append(m);
1942     }
1943   }
1944   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(methods_array.length(), JVMCI_CHECK_NULL);
1945   for (int i = 0; i &lt; methods_array.length(); i++) {
1946     methodHandle mh(THREAD, methods_array.at(i));
1947     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1948     JVMCIENV-&gt;put_object_at(methods, i, method);
1949   }
1950   return JVMCIENV-&gt;get_jobjectArray(methods);
1951 C2V_END
1952 
1953 C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject field, jboolean is_volatile))
1954   if (object == NULL || field == NULL) {
1955     JVMCI_THROW_0(NullPointerException);
1956   }
1957   JVMCIObject field_object = JVMCIENV-&gt;wrap(field);
1958   JVMCIObject java_type = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_type(field_object);
1959   int modifiers = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_modifiers(field_object);
1960   Klass* holder = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_holder(field_object));
</pre>
<hr />
<pre>
2516   JVMCIENV-&gt;get_nmethod(code, locker);
2517 }
2518 
2519 C2V_VMENTRY_NULL(jbyteArray, getCode, (JNIEnv* env, jobject, jobject code_handle))
2520   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);
2521   nmethodLocker locker;
2522   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(code, locker);
2523   if (cb == NULL) {
2524     return NULL;
2525   }
2526   int code_size = cb-&gt;code_size();
2527   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);
2528   JVMCIENV-&gt;copy_bytes_from((jbyte*) cb-&gt;code_begin(), result, 0, code_size);
2529   return JVMCIENV-&gt;get_jbyteArray(result);
2530 }
2531 
2532 C2V_VMENTRY_NULL(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))
2533   requireInHotSpot(&quot;asReflectionExecutable&quot;, JVMCI_CHECK_NULL);
2534   methodHandle m(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
2535   oop executable;
<span class="line-modified">2536   if (m-&gt;is_initializer()) {</span>
<span class="line-removed">2537     if (m-&gt;is_static_initializer()) {</span>
2538       JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2539           &quot;Cannot create java.lang.reflect.Method for class initializer&quot;);
<span class="line-modified">2540     }</span>

2541     executable = Reflection::new_constructor(m, CHECK_NULL);
2542   } else {
2543     executable = Reflection::new_method(m, false, CHECK_NULL);
2544   }
2545   return JNIHandles::make_local(THREAD, executable);
2546 }
2547 
2548 C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))
2549   requireInHotSpot(&quot;asReflectionField&quot;, JVMCI_CHECK_NULL);
2550   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
2551   if (!klass-&gt;is_instance_klass()) {
2552     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2553         err_msg(&quot;Expected non-primitive type, got %s&quot;, klass-&gt;external_name()));
2554   }
2555   InstanceKlass* iklass = InstanceKlass::cast(klass);
2556   Array&lt;u2&gt;* fields = iklass-&gt;fields();
2557   if (index &lt; 0 ||index &gt; fields-&gt;length()) {
2558     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2559         err_msg(&quot;Field index %d out of bounds for %s&quot;, index, klass-&gt;external_name()));
2560   }
</pre>
</td>
<td>
<hr />
<pre>
1242           if (initialSkip &gt; 0) {
1243             initialSkip--;
1244           } else {
1245             ScopeDesc* scope = cvf-&gt;scope();
1246             // native wrappers do not have a scope
1247             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1248               GrowableArray&lt;ScopeValue*&gt;* objects;
1249               if (!realloc_called) {
1250                 objects = scope-&gt;objects();
1251               } else {
1252                 // some object might already have been re-allocated, only reallocate the non-allocated ones
1253                 objects = new GrowableArray&lt;ScopeValue*&gt;(scope-&gt;objects()-&gt;length());
1254                 for (int i = 0; i &lt; scope-&gt;objects()-&gt;length(); i++) {
1255                   ObjectValue* sv = (ObjectValue*) scope-&gt;objects()-&gt;at(i);
1256                   if (sv-&gt;value().is_null()) {
1257                     objects-&gt;append(sv);
1258                   }
1259                 }
1260               }
1261               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);
<span class="line-modified">1262               Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false, CHECK_NULL);</span>
1263               realloc_called = true;
1264 
1265               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1266               assert(local_values != NULL, &quot;NULL locals&quot;);
1267               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1268               typeArrayHandle array(THREAD, array_oop);
1269               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1270                 ScopeValue* value = local_values-&gt;at(i);
1271                 if (value-&gt;is_object()) {
1272                   array-&gt;bool_at_put(i, true);
1273                 }
1274               }
1275               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());
1276             } else {
1277               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);
1278             }
1279 
1280             locals = cvf-&gt;locals();
1281             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf-&gt;bci());
1282             methodHandle mh(THREAD, cvf-&gt;method());
</pre>
<hr />
<pre>
1502       break;
1503     }
1504     vf = vf-&gt;sender();
1505   }
1506 
1507   int last_frame_number = JVMCIENV-&gt;get_HotSpotStackFrameReference_frameNumber(hs_frame);
1508   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1509     JVMCI_THROW_MSG(IllegalStateException, &quot;invalid frame number&quot;);
1510   }
1511 
1512   // Reallocate the non-escaping objects and restore their fields.
1513   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,&quot;invalid scope&quot;);
1514   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1515 
1516   if (objects == NULL) {
1517     // no objects to materialize
1518     return;
1519   }
1520 
1521   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, CHECK);
<span class="line-modified">1522   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false, THREAD);</span>
1523 
1524   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1525     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1526 
1527     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1528     StackValueCollection* locals = cvf-&gt;locals();
1529     if (locals != NULL) {
1530       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1531         StackValue* var = locals-&gt;at(i2);
1532         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1533           jvalue val;
1534           val.l = cast_from_oop&lt;jobject&gt;(locals-&gt;at(i2)-&gt;get_obj()());
1535           cvf-&gt;update_local(T_OBJECT, i2, val);
1536         }
1537       }
1538     }
1539 
1540     GrowableArray&lt;ScopeValue*&gt;* scopeExpressions = cvf-&gt;scope()-&gt;expressions();
1541     StackValueCollection* expressions = cvf-&gt;expressions();
1542     if (expressions != NULL) {
</pre>
<hr />
<pre>
1890   return JVMCIENV-&gt;get_jobject(result);
1891 C2V_END
1892 
1893 C2V_VMENTRY_NULL(jobjectArray, getDeclaredConstructors, (JNIEnv* env, jobject, jobject holder))
1894   if (holder == NULL) {
1895     JVMCI_THROW_0(NullPointerException);
1896   }
1897   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1898   if (!klass-&gt;is_instance_klass()) {
1899     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1900     return JVMCIENV-&gt;get_jobjectArray(methods);
1901   }
1902 
1903   InstanceKlass* iklass = InstanceKlass::cast(klass);
1904   // Ensure class is linked
1905   iklass-&gt;link_class(CHECK_NULL);
1906 
1907   GrowableArray&lt;Method*&gt; constructors_array;
1908   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1909     Method* m = iklass-&gt;methods()-&gt;at(i);
<span class="line-modified">1910     if (m-&gt;is_object_constructor()) {</span>
1911       constructors_array.append(m);
1912     }
1913   }
1914   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(constructors_array.length(), JVMCI_CHECK_NULL);
1915   for (int i = 0; i &lt; constructors_array.length(); i++) {
1916     methodHandle ctor(THREAD, constructors_array.at(i));
1917     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(ctor, JVMCI_CHECK_NULL);
1918     JVMCIENV-&gt;put_object_at(methods, i, method);
1919   }
1920   return JVMCIENV-&gt;get_jobjectArray(methods);
1921 C2V_END
1922 
1923 C2V_VMENTRY_NULL(jobjectArray, getDeclaredMethods, (JNIEnv* env, jobject, jobject holder))
1924   if (holder == NULL) {
1925     JVMCI_THROW_0(NullPointerException);
1926   }
1927   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1928   if (!klass-&gt;is_instance_klass()) {
1929     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1930     return JVMCIENV-&gt;get_jobjectArray(methods);
1931   }
1932 
1933   InstanceKlass* iklass = InstanceKlass::cast(klass);
1934   // Ensure class is linked
1935   iklass-&gt;link_class(CHECK_NULL);
1936 
1937   GrowableArray&lt;Method*&gt; methods_array;
1938   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1939     Method* m = iklass-&gt;methods()-&gt;at(i);
<span class="line-modified">1940     if (!(m-&gt;is_object_constructor() || m-&gt;is_class_initializer()) &amp;&amp; !m-&gt;is_overpass()) {</span>
1941       methods_array.append(m);
1942     }
1943   }
1944   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(methods_array.length(), JVMCI_CHECK_NULL);
1945   for (int i = 0; i &lt; methods_array.length(); i++) {
1946     methodHandle mh(THREAD, methods_array.at(i));
1947     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1948     JVMCIENV-&gt;put_object_at(methods, i, method);
1949   }
1950   return JVMCIENV-&gt;get_jobjectArray(methods);
1951 C2V_END
1952 
1953 C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject field, jboolean is_volatile))
1954   if (object == NULL || field == NULL) {
1955     JVMCI_THROW_0(NullPointerException);
1956   }
1957   JVMCIObject field_object = JVMCIENV-&gt;wrap(field);
1958   JVMCIObject java_type = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_type(field_object);
1959   int modifiers = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_modifiers(field_object);
1960   Klass* holder = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_holder(field_object));
</pre>
<hr />
<pre>
2516   JVMCIENV-&gt;get_nmethod(code, locker);
2517 }
2518 
2519 C2V_VMENTRY_NULL(jbyteArray, getCode, (JNIEnv* env, jobject, jobject code_handle))
2520   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);
2521   nmethodLocker locker;
2522   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(code, locker);
2523   if (cb == NULL) {
2524     return NULL;
2525   }
2526   int code_size = cb-&gt;code_size();
2527   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);
2528   JVMCIENV-&gt;copy_bytes_from((jbyte*) cb-&gt;code_begin(), result, 0, code_size);
2529   return JVMCIENV-&gt;get_jbyteArray(result);
2530 }
2531 
2532 C2V_VMENTRY_NULL(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))
2533   requireInHotSpot(&quot;asReflectionExecutable&quot;, JVMCI_CHECK_NULL);
2534   methodHandle m(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
2535   oop executable;
<span class="line-modified">2536   if (m-&gt;is_class_initializer()) {</span>

2537       JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2538           &quot;Cannot create java.lang.reflect.Method for class initializer&quot;);
<span class="line-modified">2539   }</span>
<span class="line-added">2540   else if (m-&gt;is_object_constructor()) {</span>
2541     executable = Reflection::new_constructor(m, CHECK_NULL);
2542   } else {
2543     executable = Reflection::new_method(m, false, CHECK_NULL);
2544   }
2545   return JNIHandles::make_local(THREAD, executable);
2546 }
2547 
2548 C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))
2549   requireInHotSpot(&quot;asReflectionField&quot;, JVMCI_CHECK_NULL);
2550   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
2551   if (!klass-&gt;is_instance_klass()) {
2552     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2553         err_msg(&quot;Expected non-primitive type, got %s&quot;, klass-&gt;external_name()));
2554   }
2555   InstanceKlass* iklass = InstanceKlass::cast(klass);
2556   Array&lt;u2&gt;* fields = iklass-&gt;fields();
2557   if (index &lt; 0 ||index &gt; fields-&gt;length()) {
2558     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2559         err_msg(&quot;Field index %d out of bounds for %s&quot;, index, klass-&gt;external_name()));
2560   }
</pre>
</td>
</tr>
</table>
<center><a href="../interpreter/templateInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../memory/oopFactory.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bytecodeAssembler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 19,10 ***</span>
<span class="line-new-header">--- 19,11 ---</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   *
   */
<span class="line-added">+ </span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;jvm.h&quot;
  #include &quot;aot/aotLoader.hpp&quot;
  #include &quot;classfile/classFileParser.hpp&quot;
  #include &quot;classfile/classFileStream.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 56,10 ***</span>
<span class="line-new-header">--- 57,11 ---</span>
  #include &quot;oops/metadata.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/recordComponent.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
<span class="line-added">+ #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,10 ***</span>
<span class="line-new-header">--- 81,11 ---</span>
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
  #include &quot;utilities/resourceHash.hpp&quot;
<span class="line-added">+ #include &quot;utilities/stringUtils.hpp&quot;</span>
  #include &quot;utilities/utf8.hpp&quot;
  
  #if INCLUDE_CDS
  #include &quot;classfile/systemDictionaryShared.hpp&quot;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,10 ***</span>
<span class="line-new-header">--- 133,12 ---</span>
  
  #define JAVA_14_VERSION                   58
  
  #define JAVA_15_VERSION                   59
  
<span class="line-added">+ #define CONSTANT_CLASS_DESCRIPTORS        59</span>
<span class="line-added">+ </span>
  void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
    assert((bad_constant == JVM_CONSTANT_Module ||
            bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
           &quot;Unexpected bad constant pool entry&quot;);
    if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 169,11 ***</span>
      // Each of the following case guarantees one more byte in the stream
      // for the following tag or the access_flags following constant pool,
      // so we don&#39;t need bounds-check for reading tag.
      const u1 tag = cfs-&gt;get_u1_fast();
      switch (tag) {
<span class="line-modified">!       case JVM_CONSTANT_Class : {</span>
          cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
          const u2 name_index = cfs-&gt;get_u2_fast();
          cp-&gt;klass_index_at_put(index, name_index);
          break;
        }
<span class="line-new-header">--- 174,11 ---</span>
      // Each of the following case guarantees one more byte in the stream
      // for the following tag or the access_flags following constant pool,
      // so we don&#39;t need bounds-check for reading tag.
      const u1 tag = cfs-&gt;get_u1_fast();
      switch (tag) {
<span class="line-modified">!       case JVM_CONSTANT_Class: {</span>
          cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
          const u2 name_index = cfs-&gt;get_u2_fast();
          cp-&gt;klass_index_at_put(index, name_index);
          break;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,11 ***</span>
        case JVM_CONSTANT_ClassIndex: {
          const int class_index = cp-&gt;klass_index_at(index);
          check_property(valid_symbol_at(class_index),
            &quot;Invalid constant pool index %u in class file %s&quot;,
            class_index, CHECK);
<span class="line-modified">!         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>
          break;
        }
        case JVM_CONSTANT_StringIndex: {
          const int string_index = cp-&gt;string_index_at(index);
          check_property(valid_symbol_at(string_index),
<span class="line-new-header">--- 504,18 ---</span>
        case JVM_CONSTANT_ClassIndex: {
          const int class_index = cp-&gt;klass_index_at(index);
          check_property(valid_symbol_at(class_index),
            &quot;Invalid constant pool index %u in class file %s&quot;,
            class_index, CHECK);
<span class="line-modified">! </span>
<span class="line-added">+         Symbol* const name = cp-&gt;symbol_at(class_index);</span>
<span class="line-added">+         const unsigned int name_len = name-&gt;utf8_length();</span>
<span class="line-added">+         if (name-&gt;is_Q_signature()) {</span>
<span class="line-added">+           cp-&gt;unresolved_qdescriptor_at_put(index, class_index, num_klasses++);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>
<span class="line-added">+         }</span>
          break;
        }
        case JVM_CONSTANT_StringIndex: {
          const int string_index = cp-&gt;string_index_at(index);
          check_property(valid_symbol_at(string_index),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 753,18 ***</span>
              const int name_and_type_ref_index =
                cp-&gt;name_and_type_ref_index_at(ref_index);
              const int name_ref_index =
                cp-&gt;name_ref_index_at(name_and_type_ref_index);
              const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified">!             if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-modified">!               if (name != vmSymbols::object_initializer_name()) {</span>
                  classfile_parse_error(
                    &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
                      name_ref_index, CHECK);
                }
              } else {
<span class="line-modified">!               if (name == vmSymbols::object_initializer_name()) {</span>
                  classfile_parse_error(
                    &quot;Bad method name at constant pool index %u in class file %s&quot;,
                    name_ref_index, CHECK);
                }
              }
<span class="line-new-header">--- 765,29 ---</span>
              const int name_and_type_ref_index =
                cp-&gt;name_and_type_ref_index_at(ref_index);
              const int name_ref_index =
                cp-&gt;name_ref_index_at(name_and_type_ref_index);
              const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified">!             if (name != vmSymbols::object_initializer_name()) {</span>
<span class="line-modified">!               if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
                  classfile_parse_error(
                    &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
                      name_ref_index, CHECK);
                }
              } else {
<span class="line-modified">!               // The allowed invocation mode of &lt;init&gt; depends on its signature.</span>
<span class="line-added">+               // This test corresponds to verify_invoke_instructions in the verifier.</span>
<span class="line-added">+               const int signature_ref_index =</span>
<span class="line-added">+                 cp-&gt;signature_ref_index_at(name_and_type_ref_index);</span>
<span class="line-added">+               const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);</span>
<span class="line-added">+               if (signature-&gt;is_void_method_signature()</span>
<span class="line-added">+                   &amp;&amp; ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-added">+                 // OK, could be a constructor call</span>
<span class="line-added">+               } else if (!signature-&gt;is_void_method_signature()</span>
<span class="line-added">+                          &amp;&amp; ref_kind == JVM_REF_invokeStatic) {</span>
<span class="line-added">+                 // also OK, could be a static factory call</span>
<span class="line-added">+               } else {</span>
                  classfile_parse_error(
                    &quot;Bad method name at constant pool index %u in class file %s&quot;,
                    name_ref_index, CHECK);
                }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 919,26 ***</span>
  
    return true;
  }
  
  // Side-effects: populates the _local_interfaces field
<span class="line-modified">! void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,</span>
<span class="line-modified">!                                        const int itfs_len,</span>
<span class="line-modified">!                                        ConstantPool* const cp,</span>
                                         bool* const has_nonstatic_concrete_methods,
                                         TRAPS) {
    assert(stream != NULL, &quot;invariant&quot;);
    assert(cp != NULL, &quot;invariant&quot;);
    assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
  
    if (itfs_len == 0) {
<span class="line-modified">!     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
    } else {
      assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified">!     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     int index;</span>
      for (index = 0; index &lt; itfs_len; index++) {
        const u2 interface_index = stream-&gt;get_u2(CHECK);
        Klass* interf;
        check_property(
          valid_klass_reference_at(interface_index),
<span class="line-new-header">--- 942,33 ---</span>
  
    return true;
  }
  
  // Side-effects: populates the _local_interfaces field
<span class="line-modified">! void ClassFileParser::parse_interfaces(const ClassFileStream* stream,</span>
<span class="line-modified">!                                        int itfs_len,</span>
<span class="line-modified">!                                        ConstantPool* cp,</span>
<span class="line-added">+                                        bool is_inline_type,</span>
                                         bool* const has_nonstatic_concrete_methods,
<span class="line-added">+                                        // FIXME: lots of these functions</span>
<span class="line-added">+                                        // declare their parameters as const,</span>
<span class="line-added">+                                        // which adds only noise to the code.</span>
<span class="line-added">+                                        // Remove the spurious const modifiers.</span>
<span class="line-added">+                                        // Many are of the form &quot;const int x&quot;</span>
<span class="line-added">+                                        // or &quot;T* const x&quot;.</span>
<span class="line-added">+                                        bool* const is_declared_atomic,</span>
                                         TRAPS) {
    assert(stream != NULL, &quot;invariant&quot;);
    assert(cp != NULL, &quot;invariant&quot;);
    assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
  
    if (itfs_len == 0) {
<span class="line-modified">!     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(0);</span>
    } else {
      assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified">!     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len);</span>
<span class="line-modified">!     int index = 0;</span>
      for (index = 0; index &lt; itfs_len; index++) {
        const u2 interface_index = stream-&gt;get_u2(CHECK);
        Klass* interf;
        check_property(
          valid_klass_reference_at(interface_index),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 952,11 ***</span>
          // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
          // But need to make sure it&#39;s not an array type.
          guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
                             &quot;Bad interface name in class file %s&quot;, CHECK);
  
<span class="line-modified">!         // Call resolve_super so classcircularity is checked</span>
          interf = SystemDictionary::resolve_super_or_fail(
                                                    _class_name,
                                                    unresolved_klass,
                                                    Handle(THREAD, _loader_data-&gt;class_loader()),
                                                    _protection_domain,
<span class="line-new-header">--- 982,11 ---</span>
          // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
          // But need to make sure it&#39;s not an array type.
          guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
                             &quot;Bad interface name in class file %s&quot;, CHECK);
  
<span class="line-modified">!         // Call resolve_super so class circularity is checked</span>
          interf = SystemDictionary::resolve_super_or_fail(
                                                    _class_name,
                                                    unresolved_klass,
                                                    Handle(THREAD, _loader_data-&gt;class_loader()),
                                                    _protection_domain,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 970,14 ***</span>
                            _class_name-&gt;as_klass_external_name(),
                            interf-&gt;external_name(),
                            interf-&gt;class_in_module_of_loader()));
        }
  
<span class="line-modified">!       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {</span>
          *has_nonstatic_concrete_methods = true;
        }
<span class="line-modified">!       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));</span>
      }
  
      if (!_need_verify || itfs_len &lt;= 1) {
        return;
      }
<span class="line-new-header">--- 1000,33 ---</span>
                            _class_name-&gt;as_klass_external_name(),
                            interf-&gt;external_name(),
                            interf-&gt;class_in_module_of_loader()));
        }
  
<span class="line-modified">!       InstanceKlass* ik = InstanceKlass::cast(interf);</span>
<span class="line-added">+       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">+         ResourceMark rm(THREAD);</span>
<span class="line-added">+         Exceptions::fthrow(</span>
<span class="line-added">+           THREAD_AND_LOCATION,</span>
<span class="line-added">+           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">+           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,</span>
<span class="line-added">+           _class_name-&gt;as_klass_external_name());</span>
<span class="line-added">+         return;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">+         set_invalid_inline_super();</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (ik-&gt;has_nonstatic_concrete_methods()) {</span>
          *has_nonstatic_concrete_methods = true;
        }
<span class="line-modified">!       if (ik-&gt;is_declared_atomic()) {</span>
<span class="line-added">+         *is_declared_atomic = true;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">+         _implements_identityObject = true;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       _temp_local_interfaces-&gt;append(ik);</span>
      }
  
      if (!_need_verify || itfs_len &lt;= 1) {
        return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 991,11 ***</span>
      bool dup = false;
      const Symbol* name = NULL;
      {
        debug_only(NoSafepointVerifier nsv;)
        for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">!         const InstanceKlass* const k = _local_interfaces-&gt;at(index);</span>
          name = k-&gt;name();
          // If no duplicates, add (name, NULL) in hashtable interface_names.
          if (!put_after_lookup(name, NULL, interface_names)) {
            dup = true;
            break;
<span class="line-new-header">--- 1040,11 ---</span>
      bool dup = false;
      const Symbol* name = NULL;
      {
        debug_only(NoSafepointVerifier nsv;)
        for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">!         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);</span>
          name = k-&gt;name();
          // If no duplicates, add (name, NULL) in hashtable interface_names.
          if (!put_after_lookup(name, NULL, interface_names)) {
            dup = true;
            break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1467,15 ***</span>
<span class="line-new-header">--- 1516,17 ---</span>
    STATIC_OOP,           // Oops
    STATIC_BYTE,          // Boolean, Byte, char
    STATIC_SHORT,         // shorts
    STATIC_WORD,          // ints
    STATIC_DOUBLE,        // aligned long or double
<span class="line-added">+   STATIC_FLATTENABLE,   // flattenable field</span>
    NONSTATIC_OOP,
    NONSTATIC_BYTE,
    NONSTATIC_SHORT,
    NONSTATIC_WORD,
    NONSTATIC_DOUBLE,
<span class="line-added">+   NONSTATIC_FLATTENABLE,</span>
    MAX_FIELD_ALLOCATION_TYPE,
    BAD_ALLOCATION_TYPE = -1
  };
  
  static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1491,16 ***</span>
    NONSTATIC_SHORT,     // T_SHORT       =  9,
    NONSTATIC_WORD,      // T_INT         = 10,
    NONSTATIC_DOUBLE,    // T_LONG        = 11,
    NONSTATIC_OOP,       // T_OBJECT      = 12,
    NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>
    BAD_ALLOCATION_TYPE, // 0
    BAD_ALLOCATION_TYPE, // 1
    BAD_ALLOCATION_TYPE, // 2
    BAD_ALLOCATION_TYPE, // 3
    STATIC_BYTE ,        // T_BOOLEAN     =  4,
<span class="line-new-header">--- 1542,17 ---</span>
    NONSTATIC_SHORT,     // T_SHORT       =  9,
    NONSTATIC_WORD,      // T_INT         = 10,
    NONSTATIC_DOUBLE,    // T_LONG        = 11,
    NONSTATIC_OOP,       // T_OBJECT      = 12,
    NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">!   NONSTATIC_OOP,       // T_VALUETYPE   = 14,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">+   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,</span>
    BAD_ALLOCATION_TYPE, // 0
    BAD_ALLOCATION_TYPE, // 1
    BAD_ALLOCATION_TYPE, // 2
    BAD_ALLOCATION_TYPE, // 3
    STATIC_BYTE ,        // T_BOOLEAN     =  4,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1511,22 ***</span>
    STATIC_SHORT,        // T_SHORT       =  9,
    STATIC_WORD,         // T_INT         = 10,
    STATIC_DOUBLE,       // T_LONG        = 11,
    STATIC_OOP,          // T_OBJECT      = 12,
    STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>
  };
  
<span class="line-modified">! static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {</span>
    assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
    FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
    assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
    return result;
  }
  
  class ClassFileParser::FieldAllocationCount : public ResourceObj {
   public:
<span class="line-new-header">--- 1563,26 ---</span>
    STATIC_SHORT,        // T_SHORT       =  9,
    STATIC_WORD,         // T_INT         = 10,
    STATIC_DOUBLE,       // T_LONG        = 11,
    STATIC_OOP,          // T_OBJECT      = 12,
    STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">!   STATIC_OOP,          // T_VALUETYPE   = 14,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">!   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">+   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20</span>
  };
  
<span class="line-modified">! static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_flattenable) {</span>
    assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
    FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
    assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<span class="line-added">+   if (is_flattenable) {</span>
<span class="line-added">+     result = is_static ? STATIC_FLATTENABLE : NONSTATIC_FLATTENABLE;</span>
<span class="line-added">+   }</span>
    return result;
  }
  
  class ClassFileParser::FieldAllocationCount : public ResourceObj {
   public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1536,12 ***</span>
      for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
        count[i] = 0;
      }
    }
  
<span class="line-modified">!   FieldAllocationType update(bool is_static, BasicType type) {</span>
<span class="line-modified">!     FieldAllocationType atype = basic_type_to_atype(is_static, type);</span>
      if (atype != BAD_ALLOCATION_TYPE) {
        // Make sure there is no overflow with injected fields.
        assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
        count[atype]++;
      }
<span class="line-new-header">--- 1592,12 ---</span>
      for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
        count[i] = 0;
      }
    }
  
<span class="line-modified">!   FieldAllocationType update(bool is_static, BasicType type, bool is_flattenable) {</span>
<span class="line-modified">!     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_flattenable);</span>
      if (atype != BAD_ALLOCATION_TYPE) {
        // Make sure there is no overflow with injected fields.
        assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
        count[atype]++;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1551,10 ***</span>
<span class="line-new-header">--- 1607,11 ---</span>
  
  // Side-effects: populates the _fields, _fields_annotations,
  // _fields_type_annotations fields
  void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
                                     bool is_interface,
<span class="line-added">+                                    bool is_inline_type,</span>
                                     FieldAllocationCount* const fac,
                                     ConstantPool* cp,
                                     const int cp_size,
                                     u2* const java_fields_count_ptr,
                                     TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1573,11 ***</span>
    *java_fields_count_ptr = length;
  
    int num_injected = 0;
    const InjectedField* const injected = JavaClasses::get_injected(_class_name,
                                                                    &amp;num_injected);
<span class="line-modified">!   const int total_fields = length + num_injected;</span>
  
    // The field array starts with tuples of shorts
    // [access, name index, sig index, initial value index, byte offset].
    // A generic signature slot only exists for field with generic
    // signature attribute. And the access flag is set with
<span class="line-new-header">--- 1630,15 ---</span>
    *java_fields_count_ptr = length;
  
    int num_injected = 0;
    const InjectedField* const injected = JavaClasses::get_injected(_class_name,
                                                                    &amp;num_injected);
<span class="line-modified">! </span>
<span class="line-added">+   // two more slots are required for inline classes:</span>
<span class="line-added">+   // one for the static field with a reference to the pre-allocated default value</span>
<span class="line-added">+   // one for the field the JVM injects when detecting an empty inline class</span>
<span class="line-added">+   const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);</span>
  
    // The field array starts with tuples of shorts
    // [access, name index, sig index, initial value index, byte offset].
    // A generic signature slot only exists for field with generic
    // signature attribute. And the access flag is set with
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1603,17 ***</span>
                                                total_fields * (FieldInfo::field_slots + 1));
  
    // The generic signature slots start after all other fields&#39; data.
    int generic_signature_slot = total_fields * FieldInfo::field_slots;
    int num_generic_signature = 0;
    for (int n = 0; n &lt; length; n++) {
      // access_flags, name_index, descriptor_index, attributes_count
      cfs-&gt;guarantee_more(8, CHECK);
  
      AccessFlags access_flags;
<span class="line-removed">-     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-removed">-     verify_legal_field_modifiers(flags, is_interface, CHECK);</span>
      access_flags.set_flags(flags);
  
      const u2 name_index = cfs-&gt;get_u2_fast();
      check_property(valid_symbol_at(name_index),
        &quot;Invalid constant pool index %u for field name in class file %s&quot;,
<span class="line-new-header">--- 1664,20 ---</span>
                                                total_fields * (FieldInfo::field_slots + 1));
  
    // The generic signature slots start after all other fields&#39; data.
    int generic_signature_slot = total_fields * FieldInfo::field_slots;
    int num_generic_signature = 0;
<span class="line-added">+   int instance_fields_count = 0;</span>
    for (int n = 0; n &lt; length; n++) {
      // access_flags, name_index, descriptor_index, attributes_count
      cfs-&gt;guarantee_more(8, CHECK);
  
<span class="line-added">+     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-added">+ </span>
<span class="line-added">+     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">+     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);</span>
      AccessFlags access_flags;
      access_flags.set_flags(flags);
  
      const u2 name_index = cfs-&gt;get_u2_fast();
      check_property(valid_symbol_at(name_index),
        &quot;Invalid constant pool index %u for field name in class file %s&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1625,10 ***</span>
<span class="line-new-header">--- 1689,27 ---</span>
      check_property(valid_symbol_at(signature_index),
        &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
        signature_index, CHECK);
      const Symbol* const sig = cp-&gt;symbol_at(signature_index);
      verify_legal_field_signature(name, sig, CHECK);
<span class="line-added">+     assert(!access_flags.is_flattenable(), &quot;ACC_FLATTENABLE should have been filtered out&quot;);</span>
<span class="line-added">+     if (sig-&gt;is_Q_signature()) {</span>
<span class="line-added">+       // assert(_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS, &quot;Q-descriptors are only supported in recent classfiles&quot;);</span>
<span class="line-added">+       access_flags.set_is_flattenable();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (access_flags.is_flattenable()) {</span>
<span class="line-added">+       // Array flattenability cannot be specified.  Arrays of value classes are</span>
<span class="line-added">+       // are always flattenable.  Arrays of other classes are not flattenable.</span>
<span class="line-added">+       if (sig-&gt;utf8_length() &gt; 1 &amp;&amp; sig-&gt;char_at(0) == &#39;[&#39;) {</span>
<span class="line-added">+         classfile_parse_error(</span>
<span class="line-added">+             &quot;Field \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s is invalid.&quot;</span>
<span class="line-added">+             &quot; ACC_FLATTENABLE cannot be specified for an array&quot;,</span>
<span class="line-added">+             name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       _has_flattenable_fields = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (!access_flags.is_static()) instance_fields_count++;</span>
  
      u2 constantvalue_index = 0;
      bool is_synthetic = false;
      u2 generic_signature_index = 0;
      const bool is_static = access_flags.is_static();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1684,11 ***</span>
                        signature_index,
                        constantvalue_index);
      const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
  
      // Remember how many oops we encountered and compute allocation type
<span class="line-modified">!     const FieldAllocationType atype = fac-&gt;update(is_static, type);</span>
      field-&gt;set_allocation_type(atype);
  
      // After field is initialized with type, we can augment it with aux info
      if (parsed_annotations.has_any_annotations()) {
        parsed_annotations.apply_to(field);
<span class="line-new-header">--- 1765,11 ---</span>
                        signature_index,
                        constantvalue_index);
      const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
  
      // Remember how many oops we encountered and compute allocation type
<span class="line-modified">!     const FieldAllocationType atype = fac-&gt;update(is_static, type, access_flags.is_flattenable());</span>
      field-&gt;set_allocation_type(atype);
  
      // After field is initialized with type, we can augment it with aux info
      if (parsed_annotations.has_any_annotations()) {
        parsed_annotations.apply_to(field);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1729,16 ***</span>
                          0);
  
        const BasicType type = Signature::basic_type(injected[n].signature());
  
        // Remember how many oops we encountered and compute allocation type
<span class="line-modified">!       const FieldAllocationType atype = fac-&gt;update(false, type);</span>
        field-&gt;set_allocation_type(atype);
        index++;
      }
    }
  
    assert(NULL == _fields, &quot;invariant&quot;);
  
    _fields =
      MetadataFactory::new_array&lt;u2&gt;(_loader_data,
                                     index * FieldInfo::field_slots + num_generic_signature,
<span class="line-new-header">--- 1810,45 ---</span>
                          0);
  
        const BasicType type = Signature::basic_type(injected[n].signature());
  
        // Remember how many oops we encountered and compute allocation type
<span class="line-modified">!       const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
        field-&gt;set_allocation_type(atype);
        index++;
      }
    }
  
<span class="line-added">+   if (is_inline_type) {</span>
<span class="line-added">+     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">+     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,</span>
<span class="line-added">+                       vmSymbols::default_value_name_enum,</span>
<span class="line-added">+                       vmSymbols::object_signature_enum,</span>
<span class="line-added">+                       0);</span>
<span class="line-added">+     const BasicType type = Signature::basic_type(vmSymbols::object_signature());</span>
<span class="line-added">+     const FieldAllocationType atype = fac-&gt;update(true, type, false);</span>
<span class="line-added">+     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">+     index++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (is_inline_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-added">+     _is_empty_inline_type = true;</span>
<span class="line-added">+     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">+     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,</span>
<span class="line-added">+         vmSymbols::empty_marker_name_enum,</span>
<span class="line-added">+         vmSymbols::byte_signature_enum,</span>
<span class="line-added">+         0);</span>
<span class="line-added">+     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());</span>
<span class="line-added">+     const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
<span class="line-added">+     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">+     index++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (instance_fields_count &gt; 0) {</span>
<span class="line-added">+     _has_nonstatic_fields = true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    assert(NULL == _fields, &quot;invariant&quot;);
  
    _fields =
      MetadataFactory::new_array&lt;u2&gt;(_loader_data,
                                     index * FieldInfo::field_slots + num_generic_signature,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2050,15 ***</span>
                                              const Symbol* sig,
                                              TRAPS) const {
    assert(name != NULL, &quot;invariant&quot;);
    assert(sig != NULL, &quot;invariant&quot;);
  
    ResourceMark rm(THREAD);
    Exceptions::fthrow(THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">!       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">!       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());</span>
  }
  
  AnnotationCollector::ID
  AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
                                        const Symbol* name,
<span class="line-new-header">--- 2160,20 ---</span>
                                              const Symbol* sig,
                                              TRAPS) const {
    assert(name != NULL, &quot;invariant&quot;);
    assert(sig != NULL, &quot;invariant&quot;);
  
<span class="line-added">+   const char* class_note = &quot;&quot;;</span>
<span class="line-added">+   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">+     class_note = &quot; (an inline class)&quot;;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    ResourceMark rm(THREAD);
    Exceptions::fthrow(THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">!       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">!       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());</span>
  }
  
  AnnotationCollector::ID
  AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
                                        const Symbol* name,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2319,10 ***</span>
<span class="line-new-header">--- 2434,11 ---</span>
  // from the method back up to the containing klass. These flag values
  // are added to klass&#39;s access_flags.
  
  Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
                                        bool is_interface,
<span class="line-added">+                                       bool is_inline_type,</span>
                                        const ConstantPool* cp,
                                        AccessFlags* const promoted_flags,
                                        TRAPS) {
    assert(cfs != NULL, &quot;invariant&quot;);
    assert(cp != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2359,15 ***</span>
        flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
      } else {
        classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
      }
    } else {
<span class="line-modified">!     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {</span>
<span class="line-modified">!     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>
    }
  
    int args_size = -1;  // only used when _need_verify is true
    if (_need_verify) {
      args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
<span class="line-new-header">--- 2475,57 ---</span>
        flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
      } else {
        classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
      }
    } else {
<span class="line-modified">!     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-modified">!     if (is_interface) {</span>
<span class="line-added">+       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>
<span class="line-added">+     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">+       // OK, a constructor</span>
<span class="line-added">+     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">+       // also OK, a static factory, as long as the return value is good</span>
<span class="line-added">+       bool ok = false;</span>
<span class="line-added">+       SignatureStream ss((Symbol*) signature, true);</span>
<span class="line-added">+       while (!ss.at_return_type())  ss.next();</span>
<span class="line-added">+       if (ss.is_reference()) {</span>
<span class="line-added">+         Symbol* ret = ss.as_symbol();</span>
<span class="line-added">+         const Symbol* required = class_name();</span>
<span class="line-added">+         if (is_unsafe_anonymous()) {</span>
<span class="line-added">+           // The original class name in the UAC byte stream gets changed.  So</span>
<span class="line-added">+           // using the original name in the return type is no longer valid.</span>
<span class="line-added">+           required = vmSymbols::java_lang_Object();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         ok = (ret == required);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (!ok) {</span>
<span class="line-added">+         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // not OK, so throw the same error as in verify_legal_method_signature.</span>
<span class="line-added">+       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // A declared &lt;init&gt; method must always be either a non-static</span>
<span class="line-added">+     // object constructor, with a void return, or else it must be a</span>
<span class="line-added">+     // static factory method, with a non-void return.  No other</span>
<span class="line-added">+     // definition of &lt;init&gt; is possible.</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // The verifier (in verify_invoke_instructions) will inspect the</span>
<span class="line-added">+     // signature of any attempt to invoke &lt;init&gt;, and ensures that it</span>
<span class="line-added">+     // returns non-void if and only if it is being invoked by</span>
<span class="line-added">+     // invokestatic, and void if and only if it is being invoked by</span>
<span class="line-added">+     // invokespecial.</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // When a symbolic reference to &lt;init&gt; is resolved for a</span>
<span class="line-added">+     // particular invocation mode (special or static), the mode is</span>
<span class="line-added">+     // matched to the JVM_ACC_STATIC modifier of the &lt;init&gt; method.</span>
<span class="line-added">+     // Thus, it is impossible to statically invoke a constructor, and</span>
<span class="line-added">+     // impossible to &quot;new + invokespecial&quot; a static factory, either</span>
<span class="line-added">+     // through bytecode or through reflection.</span>
    }
  
    int args_size = -1;  // only used when _need_verify is true
    if (_need_verify) {
      args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2914,10 ***</span>
<span class="line-new-header">--- 3072,11 ---</span>
  // from the methods back up to the containing klass. These flag values
  // are added to klass&#39;s access_flags.
  // Side-effects: populates the _methods field in the parser
  void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
                                      bool is_interface,
<span class="line-added">+                                     bool is_inline_type,</span>
                                      AccessFlags* promoted_flags,
                                      bool* has_final_method,
                                      bool* declares_nonstatic_concrete_methods,
                                      TRAPS) {
    assert(cfs != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2938,10 ***</span>
<span class="line-new-header">--- 3097,11 ---</span>
                                                     CHECK);
  
      for (int index = 0; index &lt; length; index++) {
        Method* method = parse_method(cfs,
                                      is_interface,
<span class="line-added">+                                     is_inline_type,</span>
                                      _cp,
                                      promoted_flags,
                                      CHECK);
  
        if (method-&gt;is_final()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3130,18 ***</span>
        inner_name_index, CHECK_0);
      if (_need_verify) {
        guarantee_property(inner_class_info_index != outer_class_info_index,
                           &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
      }
<span class="line-modified">!     // Access flags</span>
<span class="line-modified">!     jint flags;</span>
      // JVM_ACC_MODULE is defined in JDK-9 and later.
      if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">!       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;</span>
      }
      if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
        // Set abstract bit for old class files for backward compatibility
        flags |= JVM_ACC_ABSTRACT;
      }
      verify_legal_class_modifiers(flags, CHECK_0);
<span class="line-new-header">--- 3290,24 ---</span>
        inner_name_index, CHECK_0);
      if (_need_verify) {
        guarantee_property(inner_class_info_index != outer_class_info_index,
                           &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
      }
<span class="line-modified">! </span>
<span class="line-modified">!     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;</span>
      // JVM_ACC_MODULE is defined in JDK-9 and later.
      if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">!       recognized_modifiers |= JVM_ACC_MODULE;</span>
      }
<span class="line-added">+     // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">+     if (supports_inline_types()) {</span>
<span class="line-added">+       recognized_modifiers |= JVM_ACC_VALUE;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Access flags</span>
<span class="line-added">+     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">+ </span>
      if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
        // Set abstract bit for old class files for backward compatibility
        flags |= JVM_ACC_ABSTRACT;
      }
      verify_legal_class_modifiers(flags, CHECK_0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3918,11 ***</span>
                                                          TRAPS) {
    assert(cp != NULL, &quot;invariant&quot;);
    const InstanceKlass* super_klass = NULL;
  
    if (super_class_index == 0) {
<span class="line-modified">!     check_property(_class_name == vmSymbols::java_lang_Object(),</span>
                     &quot;Invalid superclass index %u in class file %s&quot;,
                     super_class_index,
                     CHECK_NULL);
    } else {
      check_property(valid_klass_reference_at(super_class_index),
<span class="line-new-header">--- 4084,12 ---</span>
                                                          TRAPS) {
    assert(cp != NULL, &quot;invariant&quot;);
    const InstanceKlass* super_klass = NULL;
  
    if (super_class_index == 0) {
<span class="line-modified">!     check_property(_class_name == vmSymbols::java_lang_Object()</span>
<span class="line-added">+                    || (_access_flags.get_flags() &amp; JVM_ACC_VALUE),</span>
                     &quot;Invalid superclass index %u in class file %s&quot;,
                     super_class_index,
                     CHECK_NULL);
    } else {
      check_property(valid_klass_reference_at(super_class_index),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4098,10 ***</span>
<span class="line-new-header">--- 4265,29 ---</span>
  
  void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
    print_on(st);
  }
  
<span class="line-added">+ void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-added">+                                                 const char* msg,</span>
<span class="line-added">+                                                 const Symbol* name,</span>
<span class="line-added">+                                                 const Symbol* sig) const {</span>
<span class="line-added">+ </span>
<span class="line-added">+   ResourceMark rm(THREAD);</span>
<span class="line-added">+   if (name == NULL || sig == NULL) {</span>
<span class="line-added">+     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">+         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">+         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   else {</span>
<span class="line-added">+     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">+         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">+         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),</span>
<span class="line-added">+         _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
  void ClassFileParser::layout_fields(ConstantPool* cp,
                                      const FieldAllocationCount* fac,
                                      const ClassAnnotationCollector* parsed_annotations,
                                      FieldLayoutInfo* info,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4110,10 ***</span>
<span class="line-new-header">--- 4296,16 ---</span>
    assert(cp != NULL, &quot;invariant&quot;);
  
    // Field size and offset computation
    int nonstatic_field_size = _super_klass == NULL ? 0 :
                                 _super_klass-&gt;nonstatic_field_size();
<span class="line-added">+   int next_nonstatic_inline_type_offset = 0;</span>
<span class="line-added">+   int first_nonstatic_inline_type_offset = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Fields that are inline types are handled differently depending if they are static or not:</span>
<span class="line-added">+   // - static fields are oops</span>
<span class="line-added">+   // - non-static fields are embedded</span>
  
    // Count the contended fields by type.
    //
    // We ignore static fields, because @Contended is not supported for them.
    // The layout code below will also ignore the static fields.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4130,12 ***</span>
    }
  
  
    // Calculate the starting byte offsets
    int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
    int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">!                                       ((fac-&gt;count[STATIC_OOP]) * heapOopSize);</span>
    if (fac-&gt;count[STATIC_DOUBLE]) {
      next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
    }
  
    int next_static_word_offset   = next_static_double_offset +
<span class="line-new-header">--- 4322,13 ---</span>
    }
  
  
    // Calculate the starting byte offsets
    int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<span class="line-added">+   // Inline types in static fields are not embedded, they are handled with oops</span>
    int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">!                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);</span>
    if (fac-&gt;count[STATIC_DOUBLE]) {
      next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
    }
  
    int next_static_word_offset   = next_static_double_offset +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4146,50 ***</span>
                                    ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
  
    int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
                                  nonstatic_field_size * heapOopSize;
  
    int next_nonstatic_field_offset = nonstatic_fields_start;
  
    const bool is_contended_class     = parsed_annotations-&gt;is_contended();
  
    // Class is contended, pad before all the fields
    if (is_contended_class) {
      next_nonstatic_field_offset += ContendedPaddingWidth;
    }
  
    // Compute the non-contended fields count.
    // The packing code below relies on these counts to determine if some field
    // can be squeezed into the alignment gap. Contended fields are obviously
    // exempt from that.
    unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
    unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
    unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
    unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
    unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
  
    // Total non-static fields count, including every contended field
    unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
                                          fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">!                                         fac-&gt;count[NONSTATIC_OOP];</span>
  
    const bool super_has_nonstatic_fields =
            (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
    const bool has_nonstatic_fields =
      super_has_nonstatic_fields || (nonstatic_fields_count != 0);
  
  
    // Prepare list of oops for oop map generation.
    //
    // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
    // regions. offset[i] is the start of the i-th region, which then has
    // count[i] oops following. Before we know how many regions are required,
    // we pessimistically allocate the maps to fit all the oops into the
    // distinct regions.
<span class="line-modified">! </span>
    int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">!   int max_oop_map_count = super_oop_map_count + fac-&gt;count[NONSTATIC_OOP];</span>
  
    OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
    if (super_oop_map_count &gt; 0) {
      nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
                                                      _super_klass-&gt;nonstatic_oop_map_count());
<span class="line-new-header">--- 4339,151 ---</span>
                                    ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
  
    int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
                                  nonstatic_field_size * heapOopSize;
  
<span class="line-added">+   // First field of inline types is aligned on a long boundary in order to ease</span>
<span class="line-added">+   // in-lining of inline types (with header removal) in packed arrays and</span>
<span class="line-added">+   // flatten inline types</span>
<span class="line-added">+   int initial_inline_type_padding = 0;</span>
<span class="line-added">+   if (is_inline_type()) {</span>
<span class="line-added">+     int old = nonstatic_fields_start;</span>
<span class="line-added">+     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);</span>
<span class="line-added">+     initial_inline_type_padding = nonstatic_fields_start - old;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    int next_nonstatic_field_offset = nonstatic_fields_start;
  
    const bool is_contended_class     = parsed_annotations-&gt;is_contended();
  
    // Class is contended, pad before all the fields
    if (is_contended_class) {
      next_nonstatic_field_offset += ContendedPaddingWidth;
    }
  
<span class="line-added">+   // Temporary inline types restrictions</span>
<span class="line-added">+   if (is_inline_type()) {</span>
<span class="line-added">+     if (is_contended_class) {</span>
<span class="line-added">+       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Compute the non-contended fields count.
    // The packing code below relies on these counts to determine if some field
    // can be squeezed into the alignment gap. Contended fields are obviously
    // exempt from that.
    unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
    unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
    unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
    unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
    unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
  
<span class="line-added">+   int static_inline_type_count = 0;</span>
<span class="line-added">+   int nonstatic_inline_type_count = 0;</span>
<span class="line-added">+   int* nonstatic_inline_type_indexes = NULL;</span>
<span class="line-added">+   Klass** nonstatic_inline_type_klasses = NULL;</span>
<span class="line-added">+   unsigned int inline_type_oop_map_count = 0;</span>
<span class="line-added">+   int not_flattened_inline_types = 0;</span>
<span class="line-added">+   int not_atomic_inline_types = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-added">+                                                                max_nonstatic_inline_type);</span>
<span class="line-added">+   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {</span>
<span class="line-added">+     nonstatic_inline_type_indexes[i] = -1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-added">+                                                                max_nonstatic_inline_type);</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {</span>
<span class="line-added">+     if (fs.allocation_type() == STATIC_FLATTENABLE) {</span>
<span class="line-added">+       ResourceMark rm;</span>
<span class="line-added">+       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">+         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">+       }</span>
<span class="line-added">+       static_inline_type_count++;</span>
<span class="line-added">+     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {</span>
<span class="line-added">+       // Pre-resolve the flattenable field and check for inline type circularity issues.</span>
<span class="line-added">+       ResourceMark rm;</span>
<span class="line-added">+       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">+         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">+       }</span>
<span class="line-added">+       Klass* klass =</span>
<span class="line-added">+         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">+                                                             Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">+                                                             _protection_domain, true, CHECK);</span>
<span class="line-added">+       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">+       if (!klass-&gt;access_flags().is_inline_type()) {</span>
<span class="line-added">+         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">+       }</span>
<span class="line-added">+       ValueKlass* vk = ValueKlass::cast(klass);</span>
<span class="line-added">+       // Conditions to apply flattening or not should be defined in a single place</span>
<span class="line-added">+       bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-added">+                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
<span class="line-added">+       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();</span>
<span class="line-added">+       bool too_volatile_to_flatten = fs.access_flags().is_volatile();</span>
<span class="line-added">+       if (vk-&gt;is_naturally_atomic()) {</span>
<span class="line-added">+         too_atomic_to_flatten = false;</span>
<span class="line-added">+         //too_volatile_to_flatten = false; //FIXME</span>
<span class="line-added">+         // volatile fields are currently never flattened, this could change in the future</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {</span>
<span class="line-added">+         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();</span>
<span class="line-added">+         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;</span>
<span class="line-added">+         nonstatic_inline_type_count++;</span>
<span class="line-added">+ </span>
<span class="line-added">+         ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">+         if (vklass-&gt;contains_oops()) {</span>
<span class="line-added">+           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         fs.set_flattened(true);</span>
<span class="line-added">+         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="line-added">+           not_atomic_inline_types++;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         not_flattened_inline_types++;</span>
<span class="line-added">+         fs.set_flattened(false);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Adjusting non_static_oop_count to take into account not flattened inline types;</span>
<span class="line-added">+   nonstatic_oop_count += not_flattened_inline_types;</span>
<span class="line-added">+ </span>
    // Total non-static fields count, including every contended field
    unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
                                          fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">!                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];</span>
  
    const bool super_has_nonstatic_fields =
            (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
    const bool has_nonstatic_fields =
      super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-added">+   const bool has_nonstatic_value_fields = nonstatic_inline_type_count &gt; 0;</span>
  
<span class="line-added">+   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
<span class="line-added">+     // There are a number of fixes required throughout the type system and JIT</span>
<span class="line-added">+     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
  
    // Prepare list of oops for oop map generation.
    //
    // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
    // regions. offset[i] is the start of the i-th region, which then has
    // count[i] oops following. Before we know how many regions are required,
    // we pessimistically allocate the maps to fit all the oops into the
    // distinct regions.
<span class="line-modified">!   //</span>
    int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">!   int max_oop_map_count =</span>
<span class="line-added">+       super_oop_map_count +</span>
<span class="line-added">+       fac-&gt;count[NONSTATIC_OOP] +</span>
<span class="line-added">+       inline_type_oop_map_count +</span>
<span class="line-added">+       not_flattened_inline_types;</span>
  
    OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
    if (super_oop_map_count &gt; 0) {
      nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
                                                      _super_klass-&gt;nonstatic_oop_map_count());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4280,10 ***</span>
<span class="line-new-header">--- 4574,20 ---</span>
        next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
      }
      next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
    }
  
<span class="line-added">+   // Aligning embedded inline types</span>
<span class="line-added">+   // bug below, the current algorithm to layout embedded inline types always put them at the</span>
<span class="line-added">+   // end of the layout, which doesn&#39;t match the different allocation policies the VM is</span>
<span class="line-added">+   // supposed to provide =&gt; FixMe</span>
<span class="line-added">+   // Note also that the current alignment policy is to make each inline type starting on a</span>
<span class="line-added">+   // 64 bits boundary. This could be optimized later. For instance, it could be nice to</span>
<span class="line-added">+   // align inline types according to their most constrained internal type.</span>
<span class="line-added">+   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-added">+   int next_inline_type_index = 0;</span>
<span class="line-added">+ </span>
    // Iterate over fields again and compute correct offsets.
    // The field allocation type was temporarily stored in the offset slot.
    // oop fields are located before non-oop fields (static and non-static).
    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4296,10 ***</span>
<span class="line-new-header">--- 4600,12 ---</span>
      int real_offset = 0;
      const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
  
      // pack the rest of the fields
      switch (atype) {
<span class="line-added">+       // Inline types in static fields are handled with oops</span>
<span class="line-added">+       case STATIC_FLATTENABLE:   // Fallthrough</span>
        case STATIC_OOP:
          real_offset = next_static_oop_offset;
          next_static_oop_offset += heapOopSize;
          break;
        case STATIC_BYTE:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4316,10 ***</span>
<span class="line-new-header">--- 4622,35 ---</span>
          break;
        case STATIC_DOUBLE:
          real_offset = next_static_double_offset;
          next_static_double_offset += BytesPerLong;
          break;
<span class="line-added">+       case NONSTATIC_FLATTENABLE:</span>
<span class="line-added">+         if (fs.is_flattened()) {</span>
<span class="line-added">+           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];</span>
<span class="line-added">+           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);</span>
<span class="line-added">+           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);</span>
<span class="line-added">+           ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">+           real_offset = next_nonstatic_inline_type_offset;</span>
<span class="line-added">+           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-added">+           // aligning next inline type on a 64 bits boundary</span>
<span class="line-added">+           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);</span>
<span class="line-added">+           next_inline_type_index += 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+           if (vklass-&gt;contains_oops()) { // add flatten oop maps</span>
<span class="line-added">+             int diff = real_offset - vklass-&gt;first_field_offset();</span>
<span class="line-added">+             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">+             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">+             while (map &lt; last_map) {</span>
<span class="line-added">+               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());</span>
<span class="line-added">+               map++;</span>
<span class="line-added">+             }</span>
<span class="line-added">+           }</span>
<span class="line-added">+           break;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           // Fall through</span>
<span class="line-added">+         }</span>
        case NONSTATIC_OOP:
          if( nonstatic_oop_space_count &gt; 0 ) {
            real_offset = nonstatic_oop_space_offset;
            nonstatic_oop_space_offset += heapOopSize;
            nonstatic_oop_space_count  -= 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4434,10 ***</span>
<span class="line-new-header">--- 4765,16 ---</span>
              next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
              real_offset = next_nonstatic_padded_offset;
              next_nonstatic_padded_offset += BytesPerLong;
              break;
  
<span class="line-added">+             // Inline types in static fields are handled with oops</span>
<span class="line-added">+           case NONSTATIC_FLATTENABLE:</span>
<span class="line-added">+             throwInlineTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-added">+                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
            case NONSTATIC_OOP:
              next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
              real_offset = next_nonstatic_padded_offset;
              next_nonstatic_padded_offset += heapOopSize;
              nonstatic_oop_maps-&gt;add(real_offset, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4473,16 ***</span>
  
    // Entire class is contended, pad in the back.
    // This helps to alleviate memory contention effects for subclass fields
    // and/or adjacent object.
    if (is_contended_class) {
      next_nonstatic_padded_offset += ContendedPaddingWidth;
    }
  
<span class="line-modified">!   int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>
  
<span class="line-modified">!   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);</span>
    int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
    int static_fields_end         = align_up(next_static_byte_offset, wordSize);
  
    int static_field_size         = (static_fields_end -
                                     InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
<span class="line-new-header">--- 4810,28 ---</span>
  
    // Entire class is contended, pad in the back.
    // This helps to alleviate memory contention effects for subclass fields
    // and/or adjacent object.
    if (is_contended_class) {
<span class="line-added">+     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);</span>
      next_nonstatic_padded_offset += ContendedPaddingWidth;
    }
  
<span class="line-modified">!   int notaligned_nonstatic_fields_end;</span>
<span class="line-added">+   if (nonstatic_inline_type_count != 0) {</span>
<span class="line-added">+     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   int nonstatic_field_sz_align = heapOopSize;</span>
<span class="line-added">+   if (is_inline_type()) {</span>
<span class="line-added">+     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {</span>
<span class="line-added">+       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);</span>
    int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
    int static_fields_end         = align_up(next_static_byte_offset, wordSize);
  
    int static_field_size         = (static_fields_end -
                                     InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4490,12 ***</span>
                                    (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
  
    int instance_size             = align_object_size(instance_end / wordSize);
  
    assert(instance_size == align_object_size(align_up(
<span class="line-modified">!          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),</span>
<span class="line-modified">!           wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
  
    // Invariant: nonstatic_field end/start should only change if there are
    // nonstatic fields in the class, or if the class is contended. We compare
    // against the non-aligned value, so that end alignment will not fail the
    // assert without actually having the fields.
<span class="line-new-header">--- 4839,13 ---</span>
                                    (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
  
    int instance_size             = align_object_size(instance_end / wordSize);
  
    assert(instance_size == align_object_size(align_up(
<span class="line-modified">!          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)</span>
<span class="line-modified">!          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
<span class="line-added">+ </span>
  
    // Invariant: nonstatic_field end/start should only change if there are
    // nonstatic fields in the class, or if the class is contended. We compare
    // against the non-aligned value, so that end alignment will not fail the
    // assert without actually having the fields.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4505,27 ***</span>
  
    // Number of non-static oop map blocks allocated at end of klass.
    nonstatic_oop_maps-&gt;compact();
  
  #ifndef PRODUCT
<span class="line-modified">!   if (PrintFieldLayout) {</span>
      print_field_layout(_class_name,
            _fields,
            cp,
            instance_size,
            nonstatic_fields_start,
            nonstatic_fields_end,
            static_fields_end);
    }
  
  #endif
    // Pass back information needed for InstanceKlass creation
    info-&gt;oop_map_blocks = nonstatic_oop_maps;
    info-&gt;_instance_size = instance_size;
    info-&gt;_static_field_size = static_field_size;
    info-&gt;_nonstatic_field_size = nonstatic_field_size;
    info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
  }
  
  void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
    assert(ik != NULL, &quot;invariant&quot;);
  
<span class="line-new-header">--- 4855,48 ---</span>
  
    // Number of non-static oop map blocks allocated at end of klass.
    nonstatic_oop_maps-&gt;compact();
  
  #ifndef PRODUCT
<span class="line-modified">!   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||</span>
<span class="line-added">+       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_value_fields))) {</span>
      print_field_layout(_class_name,
            _fields,
            cp,
            instance_size,
            nonstatic_fields_start,
            nonstatic_fields_end,
            static_fields_end);
<span class="line-added">+     nonstatic_oop_maps-&gt;print_on(tty);</span>
<span class="line-added">+     tty-&gt;print(&quot;\n&quot;);</span>
<span class="line-added">+     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);</span>
<span class="line-added">+     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);</span>
<span class="line-added">+     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);</span>
<span class="line-added">+     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);</span>
<span class="line-added">+     tty-&gt;print_cr(&quot;---&quot;);</span>
    }
  
  #endif
    // Pass back information needed for InstanceKlass creation
    info-&gt;oop_map_blocks = nonstatic_oop_maps;
    info-&gt;_instance_size = instance_size;
    info-&gt;_static_field_size = static_field_size;
    info-&gt;_nonstatic_field_size = nonstatic_field_size;
    info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<span class="line-added">+ </span>
<span class="line-added">+   // An inline type is naturally atomic if it has just one field, and</span>
<span class="line-added">+   // that field is simple enough.</span>
<span class="line-added">+   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;</span>
<span class="line-added">+                                 !super_has_nonstatic_fields &amp;&amp;</span>
<span class="line-added">+                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;</span>
<span class="line-added">+                                 (not_atomic_inline_types == 0) &amp;&amp;</span>
<span class="line-added">+                                 (nonstatic_contended_count == 0));</span>
<span class="line-added">+   // This may be too restrictive, since if all the fields fit in 64</span>
<span class="line-added">+   // bits we could make the decision to align instances of this class</span>
<span class="line-added">+   // to 64-bit boundaries, and load and store them as single words.</span>
<span class="line-added">+   // And on machines which supported larger atomics we could similarly</span>
<span class="line-added">+   // allow larger values to be atomic, if properly aligned.</span>
  }
  
  void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
    assert(ik != NULL, &quot;invariant&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4557,10 ***</span>
<span class="line-new-header">--- 4928,15 ---</span>
  #endif
  
    // Check if this klass supports the java.lang.Cloneable interface
    if (SystemDictionary::Cloneable_klass_loaded()) {
      if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
<span class="line-added">+       if (ik-&gt;is_value()) {</span>
<span class="line-added">+         Thread *THREAD = Thread::current();</span>
<span class="line-added">+         throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+       }</span>
        ik-&gt;set_is_cloneable();
      }
    }
  
    // Check if this klass has a vanilla default constructor
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4597,10 ***</span>
<span class="line-new-header">--- 4973,15 ---</span>
      const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
      ik-&gt;set_layout_helper(lh);
    }
  }
  
<span class="line-added">+ bool ClassFileParser::supports_inline_types() const {</span>
<span class="line-added">+   // Inline types are only supported by class file version 55 and later</span>
<span class="line-added">+   return _major_version &gt;= JAVA_11_VERSION;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // utility methods for appending an array with check for duplicates
  
  static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
                                const Array&lt;InstanceKlass*&gt;* const ifs) {
    // iterate over new interfaces
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4640,13 ***</span>
      // no interfaces, use canonicalized array
      return Universe::the_empty_instance_klass_array();
    } else if (max_transitive_size == super_size) {
      // no new local interfaces added, share superklass&#39; transitive interface array
      return super-&gt;transitive_interfaces();
<span class="line-modified">!   } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">!     // only local interfaces added, share local interface array</span>
<span class="line-modified">!     return local_ifs;</span>
    } else {
      ResourceMark rm;
      GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
  
      // Copy down from superclass
<span class="line-new-header">--- 5021,14 ---</span>
      // no interfaces, use canonicalized array
      return Universe::the_empty_instance_klass_array();
    } else if (max_transitive_size == super_size) {
      // no new local interfaces added, share superklass&#39; transitive interface array
      return super-&gt;transitive_interfaces();
<span class="line-modified">!     // The three lines below are commented to work around bug JDK-8245487</span>
<span class="line-modified">! //  } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">! //    // only local interfaces added, share local interface array</span>
<span class="line-added">+ //    return local_ifs;</span>
    } else {
      ResourceMark rm;
      GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
  
      // Copy down from superclass
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4663,10 ***</span>
<span class="line-new-header">--- 5045,15 ---</span>
      append_interfaces(result, local_ifs);
  
      // length will be less than the max_transitive_size if duplicates were removed
      const int length = result-&gt;length();
      assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
<span class="line-added">+ </span>
<span class="line-added">+     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">+       return Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      Array&lt;InstanceKlass*&gt;* const new_result =
        MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
      for (int i = 0; i &lt; length; i++) {
        InstanceKlass* const e = result-&gt;at(i);
        assert(e != NULL, &quot;just checking&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4860,21 ***</span>
<span class="line-new-header">--- 5247,33 ---</span>
  
  // utility methods for format checking
  
  void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
    const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-added">+   const bool is_inline_type = (flags &amp; JVM_ACC_VALUE) != 0;</span>
    assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-added">+   assert(supports_inline_types() || !is_inline_type, &quot;JVM_ACC_VALUE should not be set&quot;);</span>
    if (is_module) {
      ResourceMark rm(THREAD);
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_NoClassDefFoundError(),
        &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
        _class_name-&gt;as_C_string());
      return;
    }
  
<span class="line-added">+   if (is_inline_type &amp;&amp; !EnableValhalla) {</span>
<span class="line-added">+     ResourceMark rm(THREAD);</span>
<span class="line-added">+     Exceptions::fthrow(</span>
<span class="line-added">+       THREAD_AND_LOCATION,</span>
<span class="line-added">+       vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">+       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,</span>
<span class="line-added">+       _class_name-&gt;as_C_string()</span>
<span class="line-added">+     );</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (!_need_verify) { return; }
  
    const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
    const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
    const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4885,17 ***</span>
    const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
  
    if ((is_abstract &amp;&amp; is_final) ||
        (is_interface &amp;&amp; !is_abstract) ||
        (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">!       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {</span>
      ResourceMark rm(THREAD);
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">!       &quot;Illegal class modifiers in class %s: 0x%X&quot;,</span>
<span class="line-modified">!       _class_name-&gt;as_C_string(), flags</span>
      );
      return;
    }
  }
  
<span class="line-new-header">--- 5284,20 ---</span>
    const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
  
    if ((is_abstract &amp;&amp; is_final) ||
        (is_interface &amp;&amp; !is_abstract) ||
        (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">!       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||</span>
<span class="line-added">+       (is_inline_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
      ResourceMark rm(THREAD);
<span class="line-added">+     const char* class_note = &quot;&quot;;</span>
<span class="line-added">+     if (is_inline_type)  class_note = &quot; (an inline class)&quot;;</span>
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">!       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,</span>
<span class="line-modified">!       _class_name-&gt;as_C_string(), class_note, flags</span>
      );
      return;
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4970,10 ***</span>
<span class="line-new-header">--- 5372,11 ---</span>
    }
  }
  
  void ClassFileParser::verify_legal_field_modifiers(jint flags,
                                                     bool is_interface,
<span class="line-added">+                                                    bool is_inline_type,</span>
                                                     TRAPS) const {
    if (!_need_verify) { return; }
  
    const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
    const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4994,10 ***</span>
<span class="line-new-header">--- 5397,14 ---</span>
        is_illegal = true;
      }
    } else { // not interface
      if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
        is_illegal = true;
<span class="line-added">+     } else {</span>
<span class="line-added">+       if (is_inline_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
<span class="line-added">+         is_illegal = true;</span>
<span class="line-added">+       }</span>
      }
    }
  
    if (is_illegal) {
      ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5010,10 ***</span>
<span class="line-new-header">--- 5417,11 ---</span>
    }
  }
  
  void ClassFileParser::verify_legal_method_modifiers(jint flags,
                                                      bool is_interface,
<span class="line-added">+                                                     bool is_inline_type,</span>
                                                      const Symbol* name,
                                                      TRAPS) const {
    if (!_need_verify) { return; }
  
    const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5030,10 ***</span>
<span class="line-new-header">--- 5438,12 ---</span>
    const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
    const bool is_initializer  = (name == vmSymbols::object_initializer_name());
  
    bool is_illegal = false;
  
<span class="line-added">+   const char* class_note = &quot;&quot;;</span>
<span class="line-added">+ </span>
    if (is_interface) {
      if (major_gte_8) {
        // Class file version is JAVA_8_VERSION or later Methods of
        // interfaces may set any of the flags except ACC_PROTECTED,
        // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5064,19 ***</span>
    } else { // not interface
      if (has_illegal_visibility(flags)) {
        is_illegal = true;
      } else {
        if (is_initializer) {
<span class="line-modified">!         if (is_static || is_final || is_synchronized || is_native ||</span>
              is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
            is_illegal = true;
          }
        } else { // not initializer
<span class="line-modified">!         if (is_abstract) {</span>
<span class="line-modified">!           if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-modified">!               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-modified">!             is_illegal = true;</span>
            }
          }
        }
      }
    }
<span class="line-new-header">--- 5474,33 ---</span>
    } else { // not interface
      if (has_illegal_visibility(flags)) {
        is_illegal = true;
      } else {
        if (is_initializer) {
<span class="line-modified">!         if (is_final || is_synchronized || is_native ||</span>
              is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
            is_illegal = true;
          }
<span class="line-added">+         if (!is_static &amp;&amp; !is_inline_type) {</span>
<span class="line-added">+           // OK, an object constructor in a regular class</span>
<span class="line-added">+         } else if (is_static &amp;&amp; is_inline_type) {</span>
<span class="line-added">+           // OK, a static init factory in an inline class</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           // but no other combinations are allowed</span>
<span class="line-added">+           is_illegal = true;</span>
<span class="line-added">+           class_note = (is_inline_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
<span class="line-added">+         }</span>
        } else { // not initializer
<span class="line-modified">!         if (is_inline_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
<span class="line-modified">!           is_illegal = true;</span>
<span class="line-modified">!           class_note = &quot; (an inline class)&quot;;</span>
<span class="line-modified">!         } else {</span>
<span class="line-added">+           if (is_abstract) {</span>
<span class="line-added">+             if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-added">+                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-added">+               is_illegal = true;</span>
<span class="line-added">+             }</span>
            }
          }
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5084,12 ***</span>
    if (is_illegal) {
      ResourceMark rm(THREAD);
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">!       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">!       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);</span>
      return;
    }
  }
  
  void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
<span class="line-new-header">--- 5508,12 ---</span>
    if (is_illegal) {
      ResourceMark rm(THREAD);
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">!       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">!       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, flags);</span>
      return;
    }
  }
  
  void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5243,22 ***</span>
      case JVM_SIGNATURE_INT:
      case JVM_SIGNATURE_FLOAT:
      case JVM_SIGNATURE_LONG:
      case JVM_SIGNATURE_DOUBLE:
        return signature + 1;
<span class="line-modified">!     case JVM_SIGNATURE_CLASS: {</span>
        if (_major_version &lt; JAVA_1_5_VERSION) {
          // Skip over the class name if one is there
          const char* const p = skip_over_field_name(signature + 1, true, --length);
  
          // The next character better be a semicolon
          if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
            return p + 1;
          }
        }
        else {
<span class="line-modified">!         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;</span>
          signature++;
          const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
          // Format check signature
          if (c != NULL) {
            int newlen = c - (char*) signature;
<span class="line-new-header">--- 5667,31 ---</span>
      case JVM_SIGNATURE_INT:
      case JVM_SIGNATURE_FLOAT:
      case JVM_SIGNATURE_LONG:
      case JVM_SIGNATURE_DOUBLE:
        return signature + 1;
<span class="line-modified">!     case JVM_SIGNATURE_VALUETYPE:</span>
<span class="line-added">+       // Can&#39;t enable this check until JDK upgrades the bytecode generators</span>
<span class="line-added">+       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {</span>
<span class="line-added">+       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;</span>
<span class="line-added">+       //                                    &quot;in descriptor in class file %s&quot;,</span>
<span class="line-added">+       //                                    CHECK_0);</span>
<span class="line-added">+       // }</span>
<span class="line-added">+       // fall through</span>
<span class="line-added">+     case JVM_SIGNATURE_CLASS:</span>
<span class="line-added">+     {</span>
        if (_major_version &lt; JAVA_1_5_VERSION) {
          // Skip over the class name if one is there
          const char* const p = skip_over_field_name(signature + 1, true, --length);
  
          // The next character better be a semicolon
          if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
            return p + 1;
          }
        }
        else {
<span class="line-modified">!         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;</span>
          signature++;
          const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
          // Format check signature
          if (c != NULL) {
            int newlen = c - (char*) signature;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5309,10 ***</span>
<span class="line-new-header">--- 5742,13 ---</span>
      } else if (_major_version &lt; JAVA_1_5_VERSION) {
        if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
          p = skip_over_field_name(bytes, true, length);
          legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
        }
<span class="line-added">+     } else if (_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS &amp;&amp; bytes[length - 1] == &#39;;&#39; ) {</span>
<span class="line-added">+       // Support for L...; and Q...; descriptors</span>
<span class="line-added">+       legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);</span>
      } else {
        // 4900761: relax the constraints based on JSR202 spec
        // Class names may be drawn from the entire Unicode character set.
        // Identifiers between &#39;/&#39; must be unqualified names.
        // The utf8 string has been verified when parsing cpool entries.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5458,14 ***</span>
      }
      // The first non-signature thing better be a &#39;)&#39;
      if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
        length--;
        if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">!         // All internal methods must return void</span>
          if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
            return args_size;
          }
        } else {
          // Now we better just have a return value
          nextp = skip_over_field_signature(p, true, length, CHECK_0);
          if (nextp &amp;&amp; ((int)length == (nextp - p))) {
            return args_size;
<span class="line-new-header">--- 5894,30 ---</span>
      }
      // The first non-signature thing better be a &#39;)&#39;
      if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
        length--;
        if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">!         // All constructor methods must return void</span>
          if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
            return args_size;
          }
<span class="line-added">+         // All static init methods must return the current class</span>
<span class="line-added">+         if ((length &gt;= 3) &amp;&amp; (p[length-1] == JVM_SIGNATURE_ENDCLASS)</span>
<span class="line-added">+             &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">+           nextp = skip_over_field_signature(p, true, length, CHECK_0);</span>
<span class="line-added">+           if (nextp &amp;&amp; ((int)length == (nextp - p))) {</span>
<span class="line-added">+             // The actual class will be checked against current class</span>
<span class="line-added">+             // when the method is defined (see parse_method).</span>
<span class="line-added">+             // A reference to a static init with a bad return type</span>
<span class="line-added">+             // will load and verify OK, but will fail to link.</span>
<span class="line-added">+             return args_size;</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // The distinction between static factory methods and</span>
<span class="line-added">+         // constructors depends on the JVM_ACC_STATIC modifier.</span>
<span class="line-added">+         // This distinction must be reflected in a void or non-void</span>
<span class="line-added">+         // return. For declared methods, the check is in parse_method.</span>
        } else {
          // Now we better just have a return value
          nextp = skip_over_field_signature(p, true, length, CHECK_0);
          if (nextp &amp;&amp; ((int)length == (nextp - p))) {
            return args_size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5619,13 ***</span>
<span class="line-new-header">--- 6071,53 ---</span>
        log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
                                   ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
      }
    }
  
<span class="line-added">+   if (ik-&gt;is_value()) {</span>
<span class="line-added">+     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">+     oop val = ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">+     vk-&gt;set_default_value(val);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    return ik;
  }
  
<span class="line-added">+ // Return true if the specified class is not a valid super class for an inline type.</span>
<span class="line-added">+ // A valid super class for an inline type is abstract, has no instance fields,</span>
<span class="line-added">+ // does not implement interface java.lang.IdentityObject (checked elsewhere), has</span>
<span class="line-added">+ // an empty body-less no-arg constructor, and no synchronized instance methods.</span>
<span class="line-added">+ // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks</span>
<span class="line-added">+ // are done elsewhere.  The final determination of whether or not a class is an</span>
<span class="line-added">+ // invalid super type for an inline class is done in fill_instance_klass().</span>
<span class="line-added">+ bool ClassFileParser::is_invalid_super_for_inline_type() {</span>
<span class="line-added">+   if (class_name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (!access_flags().is_abstract() || _has_nonstatic_fields) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Look at each method</span>
<span class="line-added">+     for (int x = 0; x &lt; _methods-&gt;length(); x++) {</span>
<span class="line-added">+       const Method* const method = _methods-&gt;at(x);</span>
<span class="line-added">+       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">+         if (method-&gt;signature() != vmSymbols::void_method_signature() ||</span>
<span class="line-added">+             !method-&gt;is_vanilla_constructor()) {</span>
<span class="line-added">+           return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
                                            bool changed_by_loadhook,
                                            const ClassInstanceInfo&amp; cl_inst_info,
                                            TRAPS) {
    assert(ik != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5654,12 ***</span>
    ik-&gt;set_should_verify_class(_need_verify);
  
    // Not yet: supers are done below to support the new subtype-checking fields
    ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
    ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
    assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">!   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);</span>
  
    // this transfers ownership of a lot of arrays from
    // the parser onto the InstanceKlass*
    apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
  
<span class="line-new-header">--- 6146,27 ---</span>
    ik-&gt;set_should_verify_class(_need_verify);
  
    // Not yet: supers are done below to support the new subtype-checking fields
    ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
    ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
<span class="line-added">+   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {</span>
<span class="line-added">+     ik-&gt;set_is_naturally_atomic();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (_is_empty_inline_type) {</span>
<span class="line-added">+     ik-&gt;set_is_empty_inline_type();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (this-&gt;_invalid_inline_super) {</span>
<span class="line-added">+     ik-&gt;set_invalid_inline_super();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (_has_injected_identityObject) {</span>
<span class="line-added">+     ik-&gt;set_has_injected_identityObject();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">!   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);</span>
  
    // this transfers ownership of a lot of arrays from
    // the parser onto the InstanceKlass*
    apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5705,10 ***</span>
<span class="line-new-header">--- 6212,13 ---</span>
  
    ik-&gt;set_minor_version(_minor_version);
    ik-&gt;set_major_version(_major_version);
    ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
    ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
<span class="line-added">+   if (_is_declared_atomic) {</span>
<span class="line-added">+     ik-&gt;set_is_declared_atomic();</span>
<span class="line-added">+   }</span>
  
    if (_unsafe_anonymous_host != NULL) {
      assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
      ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5814,10 ***</span>
<span class="line-new-header">--- 6324,44 ---</span>
        // We won a potential race
        JvmtiExport::add_default_read_edges(module_handle, THREAD);
      }
    }
  
<span class="line-added">+   int nfields = ik-&gt;java_fields_count();</span>
<span class="line-added">+   if (ik-&gt;is_value()) nfields++;</span>
<span class="line-added">+   for (int i = 0; i &lt; nfields; i++) {</span>
<span class="line-added">+     if (ik-&gt;field_is_flattenable(i)) {</span>
<span class="line-added">+       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);</span>
<span class="line-added">+       // Inline classes for instance fields must have been pre-loaded</span>
<span class="line-added">+       // Inline classes for static fields might not have been loaded yet</span>
<span class="line-added">+       Klass* klass = SystemDictionary::find(klass_name,</span>
<span class="line-added">+           Handle(THREAD, ik-&gt;class_loader()),</span>
<span class="line-added">+           Handle(THREAD, ik-&gt;protection_domain()), CHECK);</span>
<span class="line-added">+       if (klass != NULL) {</span>
<span class="line-added">+         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-added">+         ik-&gt;set_value_field_klass(i, klass);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       klass_name-&gt;decrement_refcount();</span>
<span class="line-added">+     } else</span>
<span class="line-added">+       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
<span class="line-added">+         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {</span>
<span class="line-added">+       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (is_inline_type()) {</span>
<span class="line-added">+     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">+     if (UseNewFieldLayout) {</span>
<span class="line-added">+       vk-&gt;set_alignment(_alignment);</span>
<span class="line-added">+       vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="line-added">+       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     ValueKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
  
    if (!is_internal()) {
      if (log_is_enabled(Info, class, load)) {
        ResourceMark rm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5863,10 ***</span>
<span class="line-new-header">--- 6407,14 ---</span>
    set_klass_to_deallocate(NULL);
  
    // it&#39;s official
    set_klass(ik);
  
<span class="line-added">+   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">+     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    debug_only(ik-&gt;verify();)
  }
  
  void ClassFileParser::update_class_name(Symbol* new_class_name) {
    // Decrement the refcount in the old name, since we&#39;re clobbering it.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5964,10 ***</span>
<span class="line-new-header">--- 6512,11 ---</span>
    _methods(NULL),
    _inner_classes(NULL),
    _nest_members(NULL),
    _nest_host(0),
    _record_components(NULL),
<span class="line-added">+   _temp_local_interfaces(NULL),</span>
    _local_interfaces(NULL),
    _transitive_interfaces(NULL),
    _combined_annotations(NULL),
    _class_annotations(NULL),
    _class_type_annotations(NULL),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6003,10 ***</span>
<span class="line-new-header">--- 6552,19 ---</span>
    _relax_verify(false),
    _has_nonstatic_concrete_methods(false),
    _declares_nonstatic_concrete_methods(false),
    _has_final_method(false),
    _has_contended_fields(false),
<span class="line-added">+   _has_flattenable_fields(false),</span>
<span class="line-added">+   _has_nonstatic_fields(false),</span>
<span class="line-added">+   _is_empty_inline_type(false),</span>
<span class="line-added">+   _is_naturally_atomic(false),</span>
<span class="line-added">+   _is_declared_atomic(false),</span>
<span class="line-added">+   _invalid_inline_super(false),</span>
<span class="line-added">+   _invalid_identity_super(false),</span>
<span class="line-added">+   _implements_identityObject(false),</span>
<span class="line-added">+   _has_injected_identityObject(false),</span>
    _has_finalizer(false),
    _has_empty_finalizer(false),
    _has_vanilla_constructor(false),
    _max_bootstrap_specifier_index(-1) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6208,19 ***</span>
    assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
  
    // ACCESS FLAGS
    stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
  
<span class="line-modified">!   // Access flags</span>
<span class="line-removed">-   jint flags;</span>
    // JVM_ACC_MODULE is defined in JDK-9 and later.
    if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">!     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;</span>
    }
  
    if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
      // Set abstract bit for old class files for backward compatibility
      flags |= JVM_ACC_ABSTRACT;
    }
  
<span class="line-new-header">--- 6766,23 ---</span>
    assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
  
    // ACCESS FLAGS
    stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
  
<span class="line-modified">!   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;</span>
    // JVM_ACC_MODULE is defined in JDK-9 and later.
    if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">!     recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">+   if (supports_inline_types()) {</span>
<span class="line-added">+     recognized_modifiers |= JVM_ACC_VALUE;</span>
    }
  
<span class="line-added">+   // Access flags</span>
<span class="line-added">+   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">+ </span>
    if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
      // Set abstract bit for old class files for backward compatibility
      flags |= JVM_ACC_ABSTRACT;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6374,19 ***</span>
    // Interfaces
    _itfs_len = stream-&gt;get_u2_fast();
    parse_interfaces(stream,
                     _itfs_len,
                     cp,
                     &amp;_has_nonstatic_concrete_methods,
                     CHECK);
  
<span class="line-modified">!   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
  
    // Fields (offsets are filled in later)
    _fac = new FieldAllocationCount();
    parse_fields(stream,
<span class="line-modified">!                _access_flags.is_interface(),</span>
                 _fac,
                 cp,
                 cp_size,
                 &amp;_java_fields_count,
                 CHECK);
<span class="line-new-header">--- 6936,22 ---</span>
    // Interfaces
    _itfs_len = stream-&gt;get_u2_fast();
    parse_interfaces(stream,
                     _itfs_len,
                     cp,
<span class="line-added">+                    is_inline_type(),</span>
                     &amp;_has_nonstatic_concrete_methods,
<span class="line-added">+                    &amp;_is_declared_atomic,</span>
                     CHECK);
  
<span class="line-modified">!   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);</span>
  
    // Fields (offsets are filled in later)
    _fac = new FieldAllocationCount();
    parse_fields(stream,
<span class="line-modified">!                is_interface(),</span>
<span class="line-added">+                is_inline_type(),</span>
                 _fac,
                 cp,
                 cp_size,
                 &amp;_java_fields_count,
                 CHECK);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6394,11 ***</span>
    assert(_fields != NULL, &quot;invariant&quot;);
  
    // Methods
    AccessFlags promoted_flags;
    parse_methods(stream,
<span class="line-modified">!                 _access_flags.is_interface(),</span>
                  &amp;promoted_flags,
                  &amp;_has_final_method,
                  &amp;_declares_nonstatic_concrete_methods,
                  CHECK);
  
<span class="line-new-header">--- 6959,12 ---</span>
    assert(_fields != NULL, &quot;invariant&quot;);
  
    // Methods
    AccessFlags promoted_flags;
    parse_methods(stream,
<span class="line-modified">!                 is_interface(),</span>
<span class="line-added">+                 is_inline_type(),</span>
                  &amp;promoted_flags,
                  &amp;_has_final_method,
                  &amp;_declares_nonstatic_concrete_methods,
                  CHECK);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6465,18 ***</span>
    assert(stream-&gt;at_eos(), &quot;invariant&quot;);
    assert(cp != NULL, &quot;invariant&quot;);
    assert(_loader_data != NULL, &quot;invariant&quot;);
  
    if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">!     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),</span>
<span class="line-modified">!                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">!                    CHECK);</span>
    }
    // We check super class after class file is parsed and format is checked
    if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
      Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">!     if (_access_flags.is_interface()) {</span>
        // Before attempting to resolve the superclass, check for class format
        // errors not checked yet.
        guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
          &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
          CHECK);
<span class="line-new-header">--- 7031,18 ---</span>
    assert(stream-&gt;at_eos(), &quot;invariant&quot;);
    assert(cp != NULL, &quot;invariant&quot;);
    assert(_loader_data != NULL, &quot;invariant&quot;);
  
    if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">!     check_property(_temp_local_interfaces-&gt;length() == 0,</span>
<span class="line-modified">!         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">!         CHECK);</span>
    }
    // We check super class after class file is parsed and format is checked
    if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
      Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">!     if (is_interface()) {</span>
        // Before attempting to resolve the superclass, check for class format
        // errors not checked yet.
        guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
          &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
          CHECK);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6493,10 ***</span>
<span class="line-new-header">--- 7059,13 ---</span>
  
    if (_super_klass != NULL) {
      if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
        _has_nonstatic_concrete_methods = true;
      }
<span class="line-added">+     if (_super_klass-&gt;is_declared_atomic()) {</span>
<span class="line-added">+       _is_declared_atomic = true;</span>
<span class="line-added">+     }</span>
  
      if (_super_klass-&gt;is_interface()) {
        ResourceMark rm(THREAD);
        Exceptions::fthrow(
          THREAD_AND_LOCATION,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6505,15 ***</span>
<span class="line-new-header">--- 7074,72 ---</span>
          _class_name-&gt;as_klass_external_name(),
          _super_klass-&gt;external_name()
        );
        return;
      }
<span class="line-added">+ </span>
      // Make sure super class is not final
      if (_super_klass-&gt;is_final()) {
        THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
      }
<span class="line-added">+ </span>
<span class="line-added">+     // For an inline class, only java/lang/Object or special abstract classes</span>
<span class="line-added">+     // are acceptable super classes.</span>
<span class="line-added">+     if (is_inline_type()) {</span>
<span class="line-added">+       const InstanceKlass* super_ik = _super_klass;</span>
<span class="line-added">+       if (super_ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">+         ResourceMark rm(THREAD);</span>
<span class="line-added">+         Exceptions::fthrow(</span>
<span class="line-added">+           THREAD_AND_LOCATION,</span>
<span class="line-added">+           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">+           &quot;inline class %s has an invalid super class %s&quot;,</span>
<span class="line-added">+           _class_name-&gt;as_klass_external_name(),</span>
<span class="line-added">+           _super_klass-&gt;external_name());</span>
<span class="line-added">+         return;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {</span>
<span class="line-added">+     // This is the original source of this condition.</span>
<span class="line-added">+     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.</span>
<span class="line-added">+     _is_declared_atomic = true;</span>
<span class="line-added">+   } else if (*ForceNonTearable != &#39;\0&#39;) {</span>
<span class="line-added">+     // Allow a command line switch to force the same atomicity property:</span>
<span class="line-added">+     const char* class_name_str = _class_name-&gt;as_C_string();</span>
<span class="line-added">+     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {</span>
<span class="line-added">+       _is_declared_atomic = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,</span>
<span class="line-added">+   // if super is marked invalid, or if is_invalid_super_for_inline_type()</span>
<span class="line-added">+   // returns true</span>
<span class="line-added">+   if (invalid_inline_super() ||</span>
<span class="line-added">+       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||</span>
<span class="line-added">+       is_invalid_super_for_inline_type()) {</span>
<span class="line-added">+     set_invalid_inline_super();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!is_inline_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
<span class="line-added">+       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">+     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());</span>
<span class="line-added">+     _has_injected_identityObject = true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int itfs_len = _temp_local_interfaces-&gt;length();</span>
<span class="line-added">+   if (itfs_len == 0) {</span>
<span class="line-added">+     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
<span class="line-added">+   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">+     _local_interfaces = Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-added">+     for (int i = 0; i &lt; itfs_len; i++) {</span>
<span class="line-added">+       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));</span>
<span class="line-added">+     }</span>
    }
<span class="line-added">+   _temp_local_interfaces = NULL;</span>
<span class="line-added">+   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
  
    // Compute the transitive list of all unique interfaces implemented by this class
    _transitive_interfaces =
      compute_transitive_interfaces(_super_klass,
                                    _local_interfaces,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6539,28 ***</span>
                                                      _class_name,
                                                      _local_interfaces,
                                                      CHECK);
  
    // Size of Java itable (in words)
<span class="line-modified">!   _itable_size = _access_flags.is_interface() ? 0 :</span>
      klassItable::compute_itable_size(_transitive_interfaces);
  
    assert(_fac != NULL, &quot;invariant&quot;);
    assert(_parsed_annotations != NULL, &quot;invariant&quot;);
  
    _field_info = new FieldLayoutInfo();
    if (UseNewFieldLayout) {
      FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">!                           _parsed_annotations-&gt;is_contended(), _field_info);</span>
<span class="line-modified">!     lb.build_layout();</span>
    } else {
      layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
    }
  
<span class="line-modified">!   // Compute reference typ</span>
    _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
<span class="line-removed">- </span>
  }
  
  void ClassFileParser::set_klass(InstanceKlass* klass) {
  
  #ifdef ASSERT
<span class="line-new-header">--- 7165,46 ---</span>
                                                      _class_name,
                                                      _local_interfaces,
                                                      CHECK);
  
    // Size of Java itable (in words)
<span class="line-modified">!   _itable_size = is_interface() ? 0 :</span>
      klassItable::compute_itable_size(_transitive_interfaces);
  
    assert(_fac != NULL, &quot;invariant&quot;);
    assert(_parsed_annotations != NULL, &quot;invariant&quot;);
  
<span class="line-added">+ </span>
<span class="line-added">+   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-added">+     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {</span>
<span class="line-added">+       // Pre-load value class</span>
<span class="line-added">+       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">+           Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">+           _protection_domain, true, CHECK);</span>
<span class="line-added">+       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">+       assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-added">+       _has_flattenable_fields = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    _field_info = new FieldLayoutInfo();
    if (UseNewFieldLayout) {
      FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">!         _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
<span class="line-modified">!         loader_data(), _protection_domain, _field_info);</span>
<span class="line-added">+     lb.build_layout(CHECK);</span>
<span class="line-added">+     if (is_inline_type()) {</span>
<span class="line-added">+       _alignment = lb.get_alignment();</span>
<span class="line-added">+       _first_field_offset = lb.get_first_field_offset();</span>
<span class="line-added">+       _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>
<span class="line-added">+     }</span>
    } else {
      layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
    }
  
<span class="line-modified">!   // Compute reference type</span>
    _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
  }
  
  void ClassFileParser::set_klass(InstanceKlass* klass) {
  
  #ifdef ASSERT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6588,10 ***</span>
<span class="line-new-header">--- 7232,11 ---</span>
  const ClassFileStream* ClassFileParser::clone_stream() const {
    assert(_stream != NULL, &quot;invariant&quot;);
  
    return _stream-&gt;clone();
  }
<span class="line-added">+ </span>
  // ----------------------------------------------------------------------------
  // debugging
  
  #ifdef ASSERT
  
</pre>
<center><a href="bytecodeAssembler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
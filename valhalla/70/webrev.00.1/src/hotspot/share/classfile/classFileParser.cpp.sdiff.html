<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bytecodeAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */

  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/packageEntry.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/verificationType.hpp&quot;
  40 #include &quot;classfile/verifier.hpp&quot;
  41 #include &quot;classfile/vmSymbols.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/annotations.hpp&quot;
  50 #include &quot;oops/constantPool.inline.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  54 #include &quot;oops/klass.inline.hpp&quot;
  55 #include &quot;oops/klassVtable.hpp&quot;
  56 #include &quot;oops/metadata.hpp&quot;
  57 #include &quot;oops/method.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/recordComponent.hpp&quot;
  60 #include &quot;oops/symbol.hpp&quot;

  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/os.hpp&quot;
  68 #include &quot;runtime/perfData.hpp&quot;
  69 #include &quot;runtime/reflection.hpp&quot;
  70 #include &quot;runtime/safepointVerifiers.hpp&quot;
  71 #include &quot;runtime/signature.hpp&quot;
  72 #include &quot;runtime/timer.hpp&quot;
  73 #include &quot;services/classLoadingService.hpp&quot;
  74 #include &quot;services/threadService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/bitMap.inline.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/exceptions.hpp&quot;
  79 #include &quot;utilities/globalDefinitions.hpp&quot;
  80 #include &quot;utilities/growableArray.hpp&quot;
  81 #include &quot;utilities/macros.hpp&quot;
  82 #include &quot;utilities/ostream.hpp&quot;
  83 #include &quot;utilities/resourceHash.hpp&quot;

  84 #include &quot;utilities/utf8.hpp&quot;
  85 
  86 #if INCLUDE_CDS
  87 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  88 #endif
  89 #if INCLUDE_JFR
  90 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  91 #endif
  92 
  93 // We generally try to create the oops directly when parsing, rather than
  94 // allocating temporary data structures and copying the bytes twice. A
  95 // temporary area is only needed when parsing utf8 entries in the constant
  96 // pool and when parsing line number tables.
  97 
  98 // We add assert in debug mode when class format is not checked.
  99 
 100 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 101 #define JAVA_MIN_SUPPORTED_VERSION        45
 102 #define JAVA_PREVIEW_MINOR_VERSION        65535
 103 
</pre>
<hr />
<pre>
 115 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 116 #define JAVA_7_VERSION                    51
 117 
 118 // Extension method support.
 119 #define JAVA_8_VERSION                    52
 120 
 121 #define JAVA_9_VERSION                    53
 122 
 123 #define JAVA_10_VERSION                   54
 124 
 125 #define JAVA_11_VERSION                   55
 126 
 127 #define JAVA_12_VERSION                   56
 128 
 129 #define JAVA_13_VERSION                   57
 130 
 131 #define JAVA_14_VERSION                   58
 132 
 133 #define JAVA_15_VERSION                   59
 134 


 135 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 136   assert((bad_constant == JVM_CONSTANT_Module ||
 137           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 138          &quot;Unexpected bad constant pool entry&quot;);
 139   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 140 }
 141 
 142 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 143                                                   ConstantPool* cp,
 144                                                   const int length,
 145                                                   TRAPS) {
 146   assert(stream != NULL, &quot;invariant&quot;);
 147   assert(cp != NULL, &quot;invariant&quot;);
 148 
 149   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 150   // this function (_current can be allocated in a register, with scalar
 151   // replacement of aggregates). The _current pointer is copied back to
 152   // stream() when this function returns. DON&#39;T call another method within
 153   // this method that uses stream().
 154   const ClassFileStream cfs1 = *stream;
 155   const ClassFileStream* const cfs = &amp;cfs1;
 156 
 157   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 158   debug_only(const u1* const old_current = stream-&gt;current();)
 159 
 160   // Used for batching symbol allocations.
 161   const char* names[SymbolTable::symbol_alloc_batch_size];
 162   int lengths[SymbolTable::symbol_alloc_batch_size];
 163   int indices[SymbolTable::symbol_alloc_batch_size];
 164   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 165   int names_count = 0;
 166 
 167   // parsing  Index 0 is unused
 168   for (int index = 1; index &lt; length; index++) {
 169     // Each of the following case guarantees one more byte in the stream
 170     // for the following tag or the access_flags following constant pool,
 171     // so we don&#39;t need bounds-check for reading tag.
 172     const u1 tag = cfs-&gt;get_u1_fast();
 173     switch (tag) {
<span class="line-modified"> 174       case JVM_CONSTANT_Class : {</span>
 175         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 176         const u2 name_index = cfs-&gt;get_u2_fast();
 177         cp-&gt;klass_index_at_put(index, name_index);
 178         break;
 179       }
 180       case JVM_CONSTANT_Fieldref: {
 181         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 182         const u2 class_index = cfs-&gt;get_u2_fast();
 183         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 184         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 185         break;
 186       }
 187       case JVM_CONSTANT_Methodref: {
 188         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 189         const u2 class_index = cfs-&gt;get_u2_fast();
 190         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 191         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 192         break;
 193       }
 194       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 484         check_property(valid_symbol_at(name_ref_index),
 485           &quot;Invalid constant pool index %u in class file %s&quot;,
 486           name_ref_index, CHECK);
 487         check_property(valid_symbol_at(signature_ref_index),
 488           &quot;Invalid constant pool index %u in class file %s&quot;,
 489           signature_ref_index, CHECK);
 490         break;
 491       }
 492       case JVM_CONSTANT_Utf8:
 493         break;
 494       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 495       case JVM_CONSTANT_UnresolvedClassInError: {
 496         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 497         break;
 498       }
 499       case JVM_CONSTANT_ClassIndex: {
 500         const int class_index = cp-&gt;klass_index_at(index);
 501         check_property(valid_symbol_at(class_index),
 502           &quot;Invalid constant pool index %u in class file %s&quot;,
 503           class_index, CHECK);
<span class="line-modified"> 504         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>







 505         break;
 506       }
 507       case JVM_CONSTANT_StringIndex: {
 508         const int string_index = cp-&gt;string_index_at(index);
 509         check_property(valid_symbol_at(string_index),
 510           &quot;Invalid constant pool index %u in class file %s&quot;,
 511           string_index, CHECK);
 512         Symbol* const sym = cp-&gt;symbol_at(string_index);
 513         cp-&gt;unresolved_string_at_put(index, sym);
 514         break;
 515       }
 516       case JVM_CONSTANT_MethodHandle: {
 517         const int ref_index = cp-&gt;method_handle_index_at(index);
 518         check_property(valid_cp_range(ref_index, length),
 519           &quot;Invalid constant pool index %u in class file %s&quot;,
 520           ref_index, CHECK);
 521         const constantTag tag = cp-&gt;tag_at(ref_index);
 522         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 523 
 524         switch (ref_kind) {
</pre>
<hr />
<pre>
 738             classfile_parse_error(
 739               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 740               name_ref_index, CHECK);
 741           }
 742         }
 743         break;
 744       }
 745       case JVM_CONSTANT_MethodHandle: {
 746         const int ref_index = cp-&gt;method_handle_index_at(index);
 747         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 748         switch (ref_kind) {
 749           case JVM_REF_invokeVirtual:
 750           case JVM_REF_invokeStatic:
 751           case JVM_REF_invokeSpecial:
 752           case JVM_REF_newInvokeSpecial: {
 753             const int name_and_type_ref_index =
 754               cp-&gt;name_and_type_ref_index_at(ref_index);
 755             const int name_ref_index =
 756               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 757             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 758             if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-modified"> 759               if (name != vmSymbols::object_initializer_name()) {</span>
 760                 classfile_parse_error(
 761                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 762                     name_ref_index, CHECK);
 763               }
 764             } else {
<span class="line-modified"> 765               if (name == vmSymbols::object_initializer_name()) {</span>











 766                 classfile_parse_error(
 767                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 768                   name_ref_index, CHECK);
 769               }
 770             }
 771             break;
 772           }
 773           // Other ref_kinds are already fully checked in previous pass.
 774         } // switch(ref_kind)
 775         break;
 776       }
 777       case JVM_CONSTANT_MethodType: {
 778         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 779         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 780         verify_legal_method_signature(no_name, signature, CHECK);
 781         break;
 782       }
 783       case JVM_CONSTANT_Utf8: {
 784         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 785       }
</pre>
<hr />
<pre>
 904   while (entry != NULL) {
 905     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 906       return false;
 907     }
 908     entry = entry-&gt;_next;
 909   }
 910 
 911   // No duplicate is found, allocate a new entry and fill it.
 912   entry = new NameSigHash();
 913   entry-&gt;_name = name;
 914   entry-&gt;_sig = sig;
 915 
 916   // Insert into hash table
 917   entry-&gt;_next = table[index];
 918   table[index] = entry;
 919 
 920   return true;
 921 }
 922 
 923 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 924 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,</span>
<span class="line-modified"> 925                                        const int itfs_len,</span>
<span class="line-modified"> 926                                        ConstantPool* const cp,</span>

 927                                        bool* const has_nonstatic_concrete_methods,







 928                                        TRAPS) {
 929   assert(stream != NULL, &quot;invariant&quot;);
 930   assert(cp != NULL, &quot;invariant&quot;);
 931   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 932 
 933   if (itfs_len == 0) {
<span class="line-modified"> 934     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
 935   } else {
 936     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 937     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-modified"> 938 </span>
<span class="line-removed"> 939     int index;</span>
 940     for (index = 0; index &lt; itfs_len; index++) {
 941       const u2 interface_index = stream-&gt;get_u2(CHECK);
 942       Klass* interf;
 943       check_property(
 944         valid_klass_reference_at(interface_index),
 945         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 946         interface_index, CHECK);
 947       if (cp-&gt;tag_at(interface_index).is_klass()) {
 948         interf = cp-&gt;resolved_klass_at(interface_index);
 949       } else {
 950         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 951 
 952         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 953         // But need to make sure it&#39;s not an array type.
 954         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 955                            &quot;Bad interface name in class file %s&quot;, CHECK);
 956 
<span class="line-modified"> 957         // Call resolve_super so classcircularity is checked</span>
 958         interf = SystemDictionary::resolve_super_or_fail(
 959                                                   _class_name,
 960                                                   unresolved_klass,
 961                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 962                                                   _protection_domain,
 963                                                   false,
 964                                                   CHECK);
 965       }
 966 
 967       if (!interf-&gt;is_interface()) {
 968         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 969                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 970                           _class_name-&gt;as_klass_external_name(),
 971                           interf-&gt;external_name(),
 972                           interf-&gt;class_in_module_of_loader()));
 973       }
 974 
<span class="line-modified"> 975       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {</span>













 976         *has_nonstatic_concrete_methods = true;
 977       }
<span class="line-modified"> 978       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));</span>






 979     }
 980 
 981     if (!_need_verify || itfs_len &lt;= 1) {
 982       return;
 983     }
 984 
 985     // Check if there&#39;s any duplicates in interfaces
 986     ResourceMark rm(THREAD);
 987     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
 988                                                                  NameSigHash*,
 989                                                                  HASH_ROW_SIZE);
 990     initialize_hashtable(interface_names);
 991     bool dup = false;
 992     const Symbol* name = NULL;
 993     {
 994       debug_only(NoSafepointVerifier nsv;)
 995       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified"> 996         const InstanceKlass* const k = _local_interfaces-&gt;at(index);</span>
 997         name = k-&gt;name();
 998         // If no duplicates, add (name, NULL) in hashtable interface_names.
 999         if (!put_after_lookup(name, NULL, interface_names)) {
1000           dup = true;
1001           break;
1002         }
1003       }
1004     }
1005     if (dup) {
1006       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1007                              name-&gt;as_C_string(), CHECK);
1008     }
1009   }
1010 }
1011 
1012 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1013                                            int constantvalue_index,
1014                                            int signature_index,
1015                                            TRAPS) const {
1016   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1452                                             CHECK);
1453   parsed_annotations-&gt;set_field_annotations(a);
1454   a = assemble_annotations(runtime_visible_type_annotations,
1455                            runtime_visible_type_annotations_length,
1456                            runtime_invisible_type_annotations,
1457                            runtime_invisible_type_annotations_length,
1458                            CHECK);
1459   parsed_annotations-&gt;set_field_type_annotations(a);
1460   return;
1461 }
1462 
1463 
1464 // Field allocation types. Used for computing field offsets.
1465 
1466 enum FieldAllocationType {
1467   STATIC_OOP,           // Oops
1468   STATIC_BYTE,          // Boolean, Byte, char
1469   STATIC_SHORT,         // shorts
1470   STATIC_WORD,          // ints
1471   STATIC_DOUBLE,        // aligned long or double

1472   NONSTATIC_OOP,
1473   NONSTATIC_BYTE,
1474   NONSTATIC_SHORT,
1475   NONSTATIC_WORD,
1476   NONSTATIC_DOUBLE,

1477   MAX_FIELD_ALLOCATION_TYPE,
1478   BAD_ALLOCATION_TYPE = -1
1479 };
1480 
1481 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1482   BAD_ALLOCATION_TYPE, // 0
1483   BAD_ALLOCATION_TYPE, // 1
1484   BAD_ALLOCATION_TYPE, // 2
1485   BAD_ALLOCATION_TYPE, // 3
1486   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1487   NONSTATIC_SHORT,     // T_CHAR        =  5,
1488   NONSTATIC_WORD,      // T_FLOAT       =  6,
1489   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1490   NONSTATIC_BYTE,      // T_BYTE        =  8,
1491   NONSTATIC_SHORT,     // T_SHORT       =  9,
1492   NONSTATIC_WORD,      // T_INT         = 10,
1493   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1494   NONSTATIC_OOP,       // T_OBJECT      = 12,
1495   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1496   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1497   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1498   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1499   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1500   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1501   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1502   BAD_ALLOCATION_TYPE, // 0
1503   BAD_ALLOCATION_TYPE, // 1
1504   BAD_ALLOCATION_TYPE, // 2
1505   BAD_ALLOCATION_TYPE, // 3
1506   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1507   STATIC_SHORT,        // T_CHAR        =  5,
1508   STATIC_WORD,         // T_FLOAT       =  6,
1509   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1510   STATIC_BYTE,         // T_BYTE        =  8,
1511   STATIC_SHORT,        // T_SHORT       =  9,
1512   STATIC_WORD,         // T_INT         = 10,
1513   STATIC_DOUBLE,       // T_LONG        = 11,
1514   STATIC_OOP,          // T_OBJECT      = 12,
1515   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1516   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1517   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1518   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1519   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1520   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1521   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1522 };
1523 
<span class="line-modified">1524 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {</span>
1525   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1526   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1527   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);



1528   return result;
1529 }
1530 
1531 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1532  public:
1533   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1534 
1535   FieldAllocationCount() {
1536     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1537       count[i] = 0;
1538     }
1539   }
1540 
<span class="line-modified">1541   FieldAllocationType update(bool is_static, BasicType type) {</span>
<span class="line-modified">1542     FieldAllocationType atype = basic_type_to_atype(is_static, type);</span>
1543     if (atype != BAD_ALLOCATION_TYPE) {
1544       // Make sure there is no overflow with injected fields.
1545       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1546       count[atype]++;
1547     }
1548     return atype;
1549   }
1550 };
1551 
1552 // Side-effects: populates the _fields, _fields_annotations,
1553 // _fields_type_annotations fields
1554 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1555                                    bool is_interface,

1556                                    FieldAllocationCount* const fac,
1557                                    ConstantPool* cp,
1558                                    const int cp_size,
1559                                    u2* const java_fields_count_ptr,
1560                                    TRAPS) {
1561 
1562   assert(cfs != NULL, &quot;invariant&quot;);
1563   assert(fac != NULL, &quot;invariant&quot;);
1564   assert(cp != NULL, &quot;invariant&quot;);
1565   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1566 
1567   assert(NULL == _fields, &quot;invariant&quot;);
1568   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1569   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1570 
1571   cfs-&gt;guarantee_more(2, CHECK);  // length
1572   const u2 length = cfs-&gt;get_u2_fast();
1573   *java_fields_count_ptr = length;
1574 
1575   int num_injected = 0;
1576   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1577                                                                   &amp;num_injected);
<span class="line-modified">1578   const int total_fields = length + num_injected;</span>




1579 
1580   // The field array starts with tuples of shorts
1581   // [access, name index, sig index, initial value index, byte offset].
1582   // A generic signature slot only exists for field with generic
1583   // signature attribute. And the access flag is set with
1584   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1585   // signature slots are at the end of the field array and after all
1586   // other fields data.
1587   //
1588   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1589   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1590   //       ...
1591   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1592   //       [generic signature index]
1593   //       [generic signature index]
1594   //       ...
1595   //
1596   // Allocate a temporary resource array for field data. For each field,
1597   // a slot is reserved in the temporary array for the generic signature
1598   // index. After parsing all fields, the data are copied to a permanent
1599   // array and any unused slots will be discarded.
1600   ResourceMark rm(THREAD);
1601   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1602                                               u2,
1603                                               total_fields * (FieldInfo::field_slots + 1));
1604 
1605   // The generic signature slots start after all other fields&#39; data.
1606   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1607   int num_generic_signature = 0;

1608   for (int n = 0; n &lt; length; n++) {
1609     // access_flags, name_index, descriptor_index, attributes_count
1610     cfs-&gt;guarantee_more(8, CHECK);
1611 




1612     AccessFlags access_flags;
<span class="line-removed">1613     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-removed">1614     verify_legal_field_modifiers(flags, is_interface, CHECK);</span>
1615     access_flags.set_flags(flags);
1616 
1617     const u2 name_index = cfs-&gt;get_u2_fast();
1618     check_property(valid_symbol_at(name_index),
1619       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1620       name_index, CHECK);
1621     const Symbol* const name = cp-&gt;symbol_at(name_index);
1622     verify_legal_field_name(name, CHECK);
1623 
1624     const u2 signature_index = cfs-&gt;get_u2_fast();
1625     check_property(valid_symbol_at(signature_index),
1626       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1627       signature_index, CHECK);
1628     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1629     verify_legal_field_signature(name, sig, CHECK);

















1630 
1631     u2 constantvalue_index = 0;
1632     bool is_synthetic = false;
1633     u2 generic_signature_index = 0;
1634     const bool is_static = access_flags.is_static();
1635     FieldAnnotationCollector parsed_annotations(_loader_data);
1636 
1637     const u2 attributes_count = cfs-&gt;get_u2_fast();
1638     if (attributes_count &gt; 0) {
1639       parse_field_attributes(cfs,
1640                              attributes_count,
1641                              is_static,
1642                              signature_index,
1643                              &amp;constantvalue_index,
1644                              &amp;is_synthetic,
1645                              &amp;generic_signature_index,
1646                              &amp;parsed_annotations,
1647                              CHECK);
1648 
1649       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1669 
1670       if (is_synthetic) {
1671         access_flags.set_is_synthetic();
1672       }
1673       if (generic_signature_index != 0) {
1674         access_flags.set_field_has_generic_signature();
1675         fa[generic_signature_slot] = generic_signature_index;
1676         generic_signature_slot ++;
1677         num_generic_signature ++;
1678       }
1679     }
1680 
1681     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1682     field-&gt;initialize(access_flags.as_short(),
1683                       name_index,
1684                       signature_index,
1685                       constantvalue_index);
1686     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1687 
1688     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1689     const FieldAllocationType atype = fac-&gt;update(is_static, type);</span>
1690     field-&gt;set_allocation_type(atype);
1691 
1692     // After field is initialized with type, we can augment it with aux info
1693     if (parsed_annotations.has_any_annotations()) {
1694       parsed_annotations.apply_to(field);
1695       if (field-&gt;is_contended()) {
1696         _has_contended_fields = true;
1697       }
1698     }
1699   }
1700 
1701   int index = length;
1702   if (num_injected != 0) {
1703     for (int n = 0; n &lt; num_injected; n++) {
1704       // Check for duplicates
1705       if (injected[n].may_be_java) {
1706         const Symbol* const name      = injected[n].name();
1707         const Symbol* const signature = injected[n].signature();
1708         bool duplicate = false;
1709         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1714             duplicate = true;
1715             break;
1716           }
1717         }
1718         if (duplicate) {
1719           // These will be removed from the field array at the end
1720           continue;
1721         }
1722       }
1723 
1724       // Injected field
1725       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1726       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1727                         injected[n].name_index,
1728                         injected[n].signature_index,
1729                         0);
1730 
1731       const BasicType type = Signature::basic_type(injected[n].signature());
1732 
1733       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1734       const FieldAllocationType atype = fac-&gt;update(false, type);</span>
1735       field-&gt;set_allocation_type(atype);
1736       index++;
1737     }
1738   }
1739 





























1740   assert(NULL == _fields, &quot;invariant&quot;);
1741 
1742   _fields =
1743     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1744                                    index * FieldInfo::field_slots + num_generic_signature,
1745                                    CHECK);
1746   // Sometimes injected fields already exist in the Java source so
1747   // the fields array could be too long.  In that case the
1748   // fields array is trimed. Also unused slots that were reserved
1749   // for generic signature indexes are discarded.
1750   {
1751     int i = 0;
1752     for (; i &lt; index * FieldInfo::field_slots; i++) {
1753       _fields-&gt;at_put(i, fa[i]);
1754     }
1755     for (int j = total_fields * FieldInfo::field_slots;
1756          j &lt; generic_signature_slot; j++) {
1757       _fields-&gt;at_put(i++, fa[j]);
1758     }
1759     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2035         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2036         checked_exception, CHECK_NULL);
2037     }
2038   }
2039   // check exceptions attribute length
2040   if (_need_verify) {
2041     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2042                                                    sizeof(u2) * size),
2043                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2044   }
2045   return checked_exceptions_start;
2046 }
2047 
2048 void ClassFileParser::throwIllegalSignature(const char* type,
2049                                             const Symbol* name,
2050                                             const Symbol* sig,
2051                                             TRAPS) const {
2052   assert(name != NULL, &quot;invariant&quot;);
2053   assert(sig != NULL, &quot;invariant&quot;);
2054 





2055   ResourceMark rm(THREAD);
2056   Exceptions::fthrow(THREAD_AND_LOCATION,
2057       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2058       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2059       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());</span>
2060 }
2061 
2062 AnnotationCollector::ID
2063 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2064                                       const Symbol* name,
2065                                       const bool can_access_vm_annotations) {
2066   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2067   // Privileged code can use all annotations.  Other code silently drops some.
2068   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2069                           loader_data-&gt;is_platform_class_loader_data() ||
2070                           can_access_vm_annotations;
2071   switch (sid) {
2072     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2073       if (_location != _in_method)  break;  // only allow for methods
2074       if (!privileged)              break;  // only allow in privileged code
2075       return _method_CallerSensitive;
2076     }
2077     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2078       if (_location != _in_method)  break;  // only allow for methods
2079       if (!privileged)              break;  // only allow in privileged code
</pre>
<hr />
<pre>
2304                              runtime_visible_type_annotations_length,
2305                              runtime_invisible_type_annotations,
2306                              runtime_invisible_type_annotations_length,
2307                              CHECK);
2308     cm-&gt;set_type_annotations(a);
2309   }
2310 }
2311 
2312 
2313 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2314 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2315 // Method* to save footprint, so we only know the size of the resulting Method* when the
2316 // entire method attribute is parsed.
2317 //
2318 // The promoted_flags parameter is used to pass relevant access_flags
2319 // from the method back up to the containing klass. These flag values
2320 // are added to klass&#39;s access_flags.
2321 
2322 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2323                                       bool is_interface,

2324                                       const ConstantPool* cp,
2325                                       AccessFlags* const promoted_flags,
2326                                       TRAPS) {
2327   assert(cfs != NULL, &quot;invariant&quot;);
2328   assert(cp != NULL, &quot;invariant&quot;);
2329   assert(promoted_flags != NULL, &quot;invariant&quot;);
2330 
2331   ResourceMark rm(THREAD);
2332   // Parse fixed parts:
2333   // access_flags, name_index, descriptor_index, attributes_count
2334   cfs-&gt;guarantee_more(8, CHECK_NULL);
2335 
2336   int flags = cfs-&gt;get_u2_fast();
2337   const u2 name_index = cfs-&gt;get_u2_fast();
2338   const int cp_size = cp-&gt;length();
2339   check_property(
2340     valid_symbol_at(name_index),
2341     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2342     name_index, CHECK_NULL);
2343   const Symbol* const name = cp-&gt;symbol_at(name_index);
2344   verify_legal_method_name(name, CHECK_NULL);
2345 
2346   const u2 signature_index = cfs-&gt;get_u2_fast();
2347   guarantee_property(
2348     valid_symbol_at(signature_index),
2349     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2350     signature_index, CHECK_NULL);
2351   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2352 
2353   if (name == vmSymbols::class_initializer_name()) {
2354     // We ignore the other access flags for a valid class initializer.
2355     // (JVM Spec 2nd ed., chapter 4.6)
2356     if (_major_version &lt; 51) { // backward compatibility
2357       flags = JVM_ACC_STATIC;
2358     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2359       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2360     } else {
2361       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2362     }
2363   } else {
<span class="line-modified">2364     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);</span>
<span class="line-modified">2365   }</span>
<span class="line-modified">2366 </span>
<span class="line-modified">2367   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {</span>
<span class="line-modified">2368     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>










































2369   }
2370 
2371   int args_size = -1;  // only used when _need_verify is true
2372   if (_need_verify) {
2373     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2374                  verify_legal_method_signature(name, signature, CHECK_NULL);
2375     if (args_size &gt; MAX_ARGS_SIZE) {
2376       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2377     }
2378   }
2379 
2380   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2381 
2382   // Default values for code and exceptions attribute elements
2383   u2 max_stack = 0;
2384   u2 max_locals = 0;
2385   u4 code_length = 0;
2386   const u1* code_start = 0;
2387   u2 exception_table_length = 0;
2388   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
2899       _has_finalizer = true;
2900     }
2901   }
2902   if (name == vmSymbols::object_initializer_name() &amp;&amp;
2903       signature == vmSymbols::void_method_signature() &amp;&amp;
2904       m-&gt;is_vanilla_constructor()) {
2905     _has_vanilla_constructor = true;
2906   }
2907 
2908   NOT_PRODUCT(m-&gt;verify());
2909   return m;
2910 }
2911 
2912 
2913 // The promoted_flags parameter is used to pass relevant access_flags
2914 // from the methods back up to the containing klass. These flag values
2915 // are added to klass&#39;s access_flags.
2916 // Side-effects: populates the _methods field in the parser
2917 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
2918                                     bool is_interface,

2919                                     AccessFlags* promoted_flags,
2920                                     bool* has_final_method,
2921                                     bool* declares_nonstatic_concrete_methods,
2922                                     TRAPS) {
2923   assert(cfs != NULL, &quot;invariant&quot;);
2924   assert(promoted_flags != NULL, &quot;invariant&quot;);
2925   assert(has_final_method != NULL, &quot;invariant&quot;);
2926   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
2927 
2928   assert(NULL == _methods, &quot;invariant&quot;);
2929 
2930   cfs-&gt;guarantee_more(2, CHECK);  // length
2931   const u2 length = cfs-&gt;get_u2_fast();
2932   if (length == 0) {
2933     _methods = Universe::the_empty_method_array();
2934   } else {
2935     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
2936                                                    length,
2937                                                    NULL,
2938                                                    CHECK);
2939 
2940     for (int index = 0; index &lt; length; index++) {
2941       Method* method = parse_method(cfs,
2942                                     is_interface,

2943                                     _cp,
2944                                     promoted_flags,
2945                                     CHECK);
2946 
2947       if (method-&gt;is_final()) {
2948         *has_final_method = true;
2949       }
2950       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
2951       // used for interface initialization, and default method inheritance analysis
2952       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
2953         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
2954         *declares_nonstatic_concrete_methods = true;
2955       }
2956       _methods-&gt;at_put(index, method);
2957     }
2958 
2959     if (_need_verify &amp;&amp; length &gt; 1) {
2960       // Check duplicated methods
2961       ResourceMark rm(THREAD);
2962       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3115       valid_klass_reference_at(inner_class_info_index),
3116       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3117       inner_class_info_index, CHECK_0);
3118     // Outer class index
3119     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3120     check_property(
3121       outer_class_info_index == 0 ||
3122         valid_klass_reference_at(outer_class_info_index),
3123       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3124       outer_class_info_index, CHECK_0);
3125     // Inner class name
3126     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3127     check_property(
3128       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3129       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3130       inner_name_index, CHECK_0);
3131     if (_need_verify) {
3132       guarantee_property(inner_class_info_index != outer_class_info_index,
3133                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3134     }
<span class="line-modified">3135     // Access flags</span>
<span class="line-modified">3136     jint flags;</span>
3137     // JVM_ACC_MODULE is defined in JDK-9 and later.
3138     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3139       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-removed">3140     } else {</span>
<span class="line-removed">3141       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;</span>
3142     }








3143     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3144       // Set abstract bit for old class files for backward compatibility
3145       flags |= JVM_ACC_ABSTRACT;
3146     }
3147     verify_legal_class_modifiers(flags, CHECK_0);
3148     AccessFlags inner_access_flags(flags);
3149 
3150     inner_classes-&gt;at_put(index++, inner_class_info_index);
3151     inner_classes-&gt;at_put(index++, outer_class_info_index);
3152     inner_classes-&gt;at_put(index++, inner_name_index);
3153     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3154   }
3155 
3156   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3157   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3158     for(int i = 0; i &lt; length * 4; i += 4) {
3159       for(int j = i + 4; j &lt; length * 4; j += 4) {
3160         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3161                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3162                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
3903       }
3904     }
3905     if (runtime_invisible_annotations != NULL) {
3906       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
3907         int append = runtime_visible_annotations_length+i;
3908         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
3909       }
3910     }
3911   }
3912   return annotations;
3913 }
3914 
3915 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
3916                                                         const int super_class_index,
3917                                                         const bool need_verify,
3918                                                         TRAPS) {
3919   assert(cp != NULL, &quot;invariant&quot;);
3920   const InstanceKlass* super_klass = NULL;
3921 
3922   if (super_class_index == 0) {
<span class="line-modified">3923     check_property(_class_name == vmSymbols::java_lang_Object(),</span>

3924                    &quot;Invalid superclass index %u in class file %s&quot;,
3925                    super_class_index,
3926                    CHECK_NULL);
3927   } else {
3928     check_property(valid_klass_reference_at(super_class_index),
3929                    &quot;Invalid superclass index %u in class file %s&quot;,
3930                    super_class_index,
3931                    CHECK_NULL);
3932     // The class name should be legal because it is checked when parsing constant pool.
3933     // However, make sure it is not an array type.
3934     bool is_array = false;
3935     if (cp-&gt;tag_at(super_class_index).is_klass()) {
3936       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
3937       if (need_verify)
3938         is_array = super_klass-&gt;is_array_klass();
3939     } else if (need_verify) {
3940       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
3941     }
3942     if (need_verify) {
3943       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4083 }
4084 
4085 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4086   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4087   if (_nonstatic_oop_map_count &gt; 0) {
4088     OopMapBlock* map = _nonstatic_oop_maps;
4089     OopMapBlock* last_map = last_oop_map();
4090     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4091     while (map &lt;= last_map) {
4092       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4093                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4094       map++;
4095     }
4096   }
4097 }
4098 
4099 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4100   print_on(st);
4101 }
4102 



















4103 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4104 void ClassFileParser::layout_fields(ConstantPool* cp,
4105                                     const FieldAllocationCount* fac,
4106                                     const ClassAnnotationCollector* parsed_annotations,
4107                                     FieldLayoutInfo* info,
4108                                     TRAPS) {
4109 
4110   assert(cp != NULL, &quot;invariant&quot;);
4111 
4112   // Field size and offset computation
4113   int nonstatic_field_size = _super_klass == NULL ? 0 :
4114                                _super_klass-&gt;nonstatic_field_size();






4115 
4116   // Count the contended fields by type.
4117   //
4118   // We ignore static fields, because @Contended is not supported for them.
4119   // The layout code below will also ignore the static fields.
4120   int nonstatic_contended_count = 0;
4121   FieldAllocationCount fac_contended;
4122   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4123     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4124     if (fs.is_contended()) {
4125       fac_contended.count[atype]++;
4126       if (!fs.access_flags().is_static()) {
4127         nonstatic_contended_count++;
4128       }
4129     }
4130   }
4131 
4132 
4133   // Calculate the starting byte offsets
4134   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();

4135   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4136                                       ((fac-&gt;count[STATIC_OOP]) * heapOopSize);</span>
4137   if (fac-&gt;count[STATIC_DOUBLE]) {
4138     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4139   }
4140 
4141   int next_static_word_offset   = next_static_double_offset +
4142                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4143   int next_static_short_offset  = next_static_word_offset +
4144                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4145   int next_static_byte_offset   = next_static_short_offset +
4146                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4147 
4148   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4149                                 nonstatic_field_size * heapOopSize;
4150 










4151   int next_nonstatic_field_offset = nonstatic_fields_start;
4152 
4153   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4154 
4155   // Class is contended, pad before all the fields
4156   if (is_contended_class) {
4157     next_nonstatic_field_offset += ContendedPaddingWidth;
4158   }
4159 








4160   // Compute the non-contended fields count.
4161   // The packing code below relies on these counts to determine if some field
4162   // can be squeezed into the alignment gap. Contended fields are obviously
4163   // exempt from that.
4164   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4165   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4166   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4167   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4168   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4169 









































































4170   // Total non-static fields count, including every contended field
4171   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4172                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4173                                         fac-&gt;count[NONSTATIC_OOP];</span>
4174 
4175   const bool super_has_nonstatic_fields =
4176           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4177   const bool has_nonstatic_fields =
4178     super_has_nonstatic_fields || (nonstatic_fields_count != 0);

4179 





4180 
4181   // Prepare list of oops for oop map generation.
4182   //
4183   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4184   // regions. offset[i] is the start of the i-th region, which then has
4185   // count[i] oops following. Before we know how many regions are required,
4186   // we pessimistically allocate the maps to fit all the oops into the
4187   // distinct regions.
<span class="line-modified">4188 </span>
4189   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">4190   int max_oop_map_count = super_oop_map_count + fac-&gt;count[NONSTATIC_OOP];</span>




4191 
4192   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4193   if (super_oop_map_count &gt; 0) {
4194     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4195                                                     _super_klass-&gt;nonstatic_oop_map_count());
4196   }
4197 
4198   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4199 
4200   bool compact_fields  = true;
4201   bool allocate_oops_first = false;
4202 
4203   int next_nonstatic_oop_offset = 0;
4204   int next_nonstatic_double_offset = 0;
4205 
4206   // Rearrange fields for a given allocation style
4207   if (allocate_oops_first) {
4208     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4209     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4210     next_nonstatic_double_offset = next_nonstatic_oop_offset +
</pre>
<hr />
<pre>
4265   }
4266 
4267   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4268                                      (nonstatic_double_count * BytesPerLong);
4269   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4270                                       (nonstatic_word_count * BytesPerInt);
4271   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4272                                      (nonstatic_short_count * BytesPerShort);
4273   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4274                                        nonstatic_byte_count;
4275 
4276   // let oops jump before padding with this allocation style
4277   if (!allocate_oops_first) {
4278     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4279     if( nonstatic_oop_count &gt; 0 ) {
4280       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4281     }
4282     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4283   }
4284 










4285   // Iterate over fields again and compute correct offsets.
4286   // The field allocation type was temporarily stored in the offset slot.
4287   // oop fields are located before non-oop fields (static and non-static).
4288   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4289 
4290     // skip already laid out fields
4291     if (fs.is_offset_set()) continue;
4292 
4293     // contended instance fields are handled below
4294     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4295 
4296     int real_offset = 0;
4297     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4298 
4299     // pack the rest of the fields
4300     switch (atype) {


4301       case STATIC_OOP:
4302         real_offset = next_static_oop_offset;
4303         next_static_oop_offset += heapOopSize;
4304         break;
4305       case STATIC_BYTE:
4306         real_offset = next_static_byte_offset;
4307         next_static_byte_offset += 1;
4308         break;
4309       case STATIC_SHORT:
4310         real_offset = next_static_short_offset;
4311         next_static_short_offset += BytesPerShort;
4312         break;
4313       case STATIC_WORD:
4314         real_offset = next_static_word_offset;
4315         next_static_word_offset += BytesPerInt;
4316         break;
4317       case STATIC_DOUBLE:
4318         real_offset = next_static_double_offset;
4319         next_static_double_offset += BytesPerLong;
4320         break;

























4321       case NONSTATIC_OOP:
4322         if( nonstatic_oop_space_count &gt; 0 ) {
4323           real_offset = nonstatic_oop_space_offset;
4324           nonstatic_oop_space_offset += heapOopSize;
4325           nonstatic_oop_space_count  -= 1;
4326         } else {
4327           real_offset = next_nonstatic_oop_offset;
4328           next_nonstatic_oop_offset += heapOopSize;
4329         }
4330         nonstatic_oop_maps-&gt;add(real_offset, 1);
4331         break;
4332       case NONSTATIC_BYTE:
4333         if( nonstatic_byte_space_count &gt; 0 ) {
4334           real_offset = nonstatic_byte_space_offset;
4335           nonstatic_byte_space_offset += 1;
4336           nonstatic_byte_space_count  -= 1;
4337         } else {
4338           real_offset = next_nonstatic_byte_offset;
4339           next_nonstatic_byte_offset += 1;
4340         }
</pre>
<hr />
<pre>
4419             break;
4420 
4421           case NONSTATIC_SHORT:
4422             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4423             real_offset = next_nonstatic_padded_offset;
4424             next_nonstatic_padded_offset += BytesPerShort;
4425             break;
4426 
4427           case NONSTATIC_WORD:
4428             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4429             real_offset = next_nonstatic_padded_offset;
4430             next_nonstatic_padded_offset += BytesPerInt;
4431             break;
4432 
4433           case NONSTATIC_DOUBLE:
4434             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4435             real_offset = next_nonstatic_padded_offset;
4436             next_nonstatic_padded_offset += BytesPerLong;
4437             break;
4438 






4439           case NONSTATIC_OOP:
4440             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4441             real_offset = next_nonstatic_padded_offset;
4442             next_nonstatic_padded_offset += heapOopSize;
4443             nonstatic_oop_maps-&gt;add(real_offset, 1);
4444             break;
4445 
4446           default:
4447             ShouldNotReachHere();
4448         }
4449 
4450         if (fs.contended_group() == 0) {
4451           // Contended group defines the equivalence class over the fields:
4452           // the fields within the same contended group are not inter-padded.
4453           // The only exception is default group, which does not incur the
4454           // equivalence, and so requires intra-padding.
4455           next_nonstatic_padded_offset += ContendedPaddingWidth;
4456         }
4457 
4458         fs.set_offset(real_offset);
4459       } // for
4460 
4461       // Start laying out the next group.
4462       // Note that this will effectively pad the last group in the back;
4463       // this is expected to alleviate memory contention effects for
4464       // subclass fields and/or adjacent object.
4465       // If this was the default group, the padding is already in place.
4466       if (current_group != 0) {
4467         next_nonstatic_padded_offset += ContendedPaddingWidth;
4468       }
4469     }
4470 
4471     // handle static fields
4472   }
4473 
4474   // Entire class is contended, pad in the back.
4475   // This helps to alleviate memory contention effects for subclass fields
4476   // and/or adjacent object.
4477   if (is_contended_class) {

4478     next_nonstatic_padded_offset += ContendedPaddingWidth;
4479   }
4480 
<span class="line-modified">4481   int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>





4482 
<span class="line-modified">4483   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);</span>






4484   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4485   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4486 
4487   int static_field_size         = (static_fields_end -
4488                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4489   nonstatic_field_size          = nonstatic_field_size +
4490                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4491 
4492   int instance_size             = align_object_size(instance_end / wordSize);
4493 
4494   assert(instance_size == align_object_size(align_up(
<span class="line-modified">4495          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),</span>
<span class="line-modified">4496           wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>

4497 
4498   // Invariant: nonstatic_field end/start should only change if there are
4499   // nonstatic fields in the class, or if the class is contended. We compare
4500   // against the non-aligned value, so that end alignment will not fail the
4501   // assert without actually having the fields.
4502   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4503          is_contended_class ||
4504          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4505 
4506   // Number of non-static oop map blocks allocated at end of klass.
4507   nonstatic_oop_maps-&gt;compact();
4508 
4509 #ifndef PRODUCT
<span class="line-modified">4510   if (PrintFieldLayout) {</span>

4511     print_field_layout(_class_name,
4512           _fields,
4513           cp,
4514           instance_size,
4515           nonstatic_fields_start,
4516           nonstatic_fields_end,
4517           static_fields_end);







4518   }
4519 
4520 #endif
4521   // Pass back information needed for InstanceKlass creation
4522   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4523   info-&gt;_instance_size = instance_size;
4524   info-&gt;_static_field_size = static_field_size;
4525   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4526   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;













4527 }
4528 
4529 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4530   assert(ik != NULL, &quot;invariant&quot;);
4531 
4532   const Klass* const super = ik-&gt;super();
4533 
4534   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4535   // in which case we don&#39;t have to register objects as finalizable
4536   if (!_has_empty_finalizer) {
4537     if (_has_finalizer ||
4538         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4539       ik-&gt;set_has_finalizer();
4540     }
4541   }
4542 
4543 #ifdef ASSERT
4544   bool f = false;
4545   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4546                                            vmSymbols::void_method_signature());
4547   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4548       f = true;
4549   }
4550 
4551   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4552   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4553   // will not work as expected we shouldn&#39;t abort vm in this case
4554   if (!ik-&gt;has_redefined_this_or_super()) {
4555     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4556   }
4557 #endif
4558 
4559   // Check if this klass supports the java.lang.Cloneable interface
4560   if (SystemDictionary::Cloneable_klass_loaded()) {
4561     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {





4562       ik-&gt;set_is_cloneable();
4563     }
4564   }
4565 
4566   // Check if this klass has a vanilla default constructor
4567   if (super == NULL) {
4568     // java.lang.Object has empty default constructor
4569     ik-&gt;set_has_vanilla_constructor();
4570   } else {
4571     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4572         _has_vanilla_constructor) {
4573       ik-&gt;set_has_vanilla_constructor();
4574     }
4575 #ifdef ASSERT
4576     bool v = false;
4577     if (super-&gt;has_vanilla_constructor()) {
4578       const Method* const constructor =
4579         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4580                        vmSymbols::void_method_signature());
4581       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4582         v = true;
4583       }
4584     }
4585     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4586 #endif
4587   }
4588 
4589   // If it cannot be fast-path allocated, set a bit in the layout helper.
4590   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4591   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4592   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4593       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4594       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4595       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4596     // Forbid fast-path allocation.
4597     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4598     ik-&gt;set_layout_helper(lh);
4599   }
4600 }
4601 





4602 // utility methods for appending an array with check for duplicates
4603 
4604 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4605                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4606   // iterate over new interfaces
4607   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4608     InstanceKlass* const e = ifs-&gt;at(i);
4609     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4610     // add new interface
4611     result-&gt;append_if_missing(e);
4612   }
4613 }
4614 
4615 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4616                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4617                                                             ClassLoaderData* loader_data,
4618                                                             TRAPS) {
4619   assert(local_ifs != NULL, &quot;invariant&quot;);
4620   assert(loader_data != NULL, &quot;invariant&quot;);
4621 
</pre>
<hr />
<pre>
4625   // Add superclass transitive interfaces size
4626   if (super != NULL) {
4627     super_size = super-&gt;transitive_interfaces()-&gt;length();
4628     max_transitive_size += super_size;
4629   }
4630   // Add local interfaces&#39; super interfaces
4631   const int local_size = local_ifs-&gt;length();
4632   for (int i = 0; i &lt; local_size; i++) {
4633     InstanceKlass* const l = local_ifs-&gt;at(i);
4634     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4635   }
4636   // Finally add local interfaces
4637   max_transitive_size += local_size;
4638   // Construct array
4639   if (max_transitive_size == 0) {
4640     // no interfaces, use canonicalized array
4641     return Universe::the_empty_instance_klass_array();
4642   } else if (max_transitive_size == super_size) {
4643     // no new local interfaces added, share superklass&#39; transitive interface array
4644     return super-&gt;transitive_interfaces();
<span class="line-modified">4645   } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">4646     // only local interfaces added, share local interface array</span>
<span class="line-modified">4647     return local_ifs;</span>

4648   } else {
4649     ResourceMark rm;
4650     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4651 
4652     // Copy down from superclass
4653     if (super != NULL) {
4654       append_interfaces(result, super-&gt;transitive_interfaces());
4655     }
4656 
4657     // Copy down from local interfaces&#39; superinterfaces
4658     for (int i = 0; i &lt; local_size; i++) {
4659       InstanceKlass* const l = local_ifs-&gt;at(i);
4660       append_interfaces(result, l-&gt;transitive_interfaces());
4661     }
4662     // Finally add local interfaces
4663     append_interfaces(result, local_ifs);
4664 
4665     // length will be less than the max_transitive_size if duplicates were removed
4666     const int length = result-&gt;length();
4667     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);





4668     Array&lt;InstanceKlass*&gt;* const new_result =
4669       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4670     for (int i = 0; i &lt; length; i++) {
4671       InstanceKlass* const e = result-&gt;at(i);
4672       assert(e != NULL, &quot;just checking&quot;);
4673       new_result-&gt;at_put(i, e);
4674     }
4675     return new_result;
4676   }
4677 }
4678 
4679 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4680   assert(this_klass != NULL, &quot;invariant&quot;);
4681   const Klass* const super = this_klass-&gt;super();
4682 
4683   if (super != NULL) {
4684 
4685     // If the loader is not the boot loader then throw an exception if its
4686     // superclass is in package jdk.internal.reflect and its loader is not a
4687     // special reflection class loader
</pre>
<hr />
<pre>
4845     const Method* const m = methods-&gt;at(index);
4846     // if m is static and not the init method, throw a verify error
4847     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4848       ResourceMark rm(THREAD);
4849       Exceptions::fthrow(
4850         THREAD_AND_LOCATION,
4851         vmSymbols::java_lang_VerifyError(),
4852         &quot;Illegal static method %s in interface %s&quot;,
4853         m-&gt;name()-&gt;as_C_string(),
4854         this_klass-&gt;external_name()
4855       );
4856       return;
4857     }
4858   }
4859 }
4860 
4861 // utility methods for format checking
4862 
4863 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4864   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;

4865   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);

4866   if (is_module) {
4867     ResourceMark rm(THREAD);
4868     Exceptions::fthrow(
4869       THREAD_AND_LOCATION,
4870       vmSymbols::java_lang_NoClassDefFoundError(),
4871       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4872       _class_name-&gt;as_C_string());
4873     return;
4874   }
4875 










4876   if (!_need_verify) { return; }
4877 
4878   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4879   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4880   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4881   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4882   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4883   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
4884   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4885   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
4886 
4887   if ((is_abstract &amp;&amp; is_final) ||
4888       (is_interface &amp;&amp; !is_abstract) ||
4889       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">4890       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {</span>

4891     ResourceMark rm(THREAD);


4892     Exceptions::fthrow(
4893       THREAD_AND_LOCATION,
4894       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">4895       &quot;Illegal class modifiers in class %s: 0x%X&quot;,</span>
<span class="line-modified">4896       _class_name-&gt;as_C_string(), flags</span>
4897     );
4898     return;
4899   }
4900 }
4901 
4902 static bool has_illegal_visibility(jint flags) {
4903   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4904   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4905   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4906 
4907   return ((is_public &amp;&amp; is_protected) ||
4908           (is_public &amp;&amp; is_private) ||
4909           (is_protected &amp;&amp; is_private));
4910 }
4911 
4912 // A legal major_version.minor_version must be one of the following:
4913 //
4914 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
4915 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
4916 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
4955     if (!Arguments::enable_preview()) {
4956       Exceptions::fthrow(
4957         THREAD_AND_LOCATION,
4958         vmSymbols::java_lang_UnsupportedClassVersionError(),
4959         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
4960         class_name-&gt;as_C_string(), major, minor);
4961       return;
4962     }
4963 
4964   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
4965     Exceptions::fthrow(
4966         THREAD_AND_LOCATION,
4967         vmSymbols::java_lang_UnsupportedClassVersionError(),
4968         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
4969         class_name-&gt;as_C_string(), major, minor);
4970   }
4971 }
4972 
4973 void ClassFileParser::verify_legal_field_modifiers(jint flags,
4974                                                    bool is_interface,

4975                                                    TRAPS) const {
4976   if (!_need_verify) { return; }
4977 
4978   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4979   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4980   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4981   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
4982   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
4983   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
4984   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
4985   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
4986   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4987 
4988   bool is_illegal = false;
4989 
4990   if (is_interface) {
4991     if (!is_public || !is_static || !is_final || is_private ||
4992         is_protected || is_volatile || is_transient ||
4993         (major_gte_1_5 &amp;&amp; is_enum)) {
4994       is_illegal = true;
4995     }
4996   } else { // not interface
4997     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
4998       is_illegal = true;




4999     }
5000   }
5001 
5002   if (is_illegal) {
5003     ResourceMark rm(THREAD);
5004     Exceptions::fthrow(
5005       THREAD_AND_LOCATION,
5006       vmSymbols::java_lang_ClassFormatError(),
5007       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5008       _class_name-&gt;as_C_string(), flags);
5009     return;
5010   }
5011 }
5012 
5013 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5014                                                     bool is_interface,

5015                                                     const Symbol* name,
5016                                                     TRAPS) const {
5017   if (!_need_verify) { return; }
5018 
5019   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5020   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5021   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5022   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5023   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5024   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5025   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5026   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5027   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5028   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5029   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5030   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5031   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5032 
5033   bool is_illegal = false;
5034 


5035   if (is_interface) {
5036     if (major_gte_8) {
5037       // Class file version is JAVA_8_VERSION or later Methods of
5038       // interfaces may set any of the flags except ACC_PROTECTED,
5039       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5040       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5041       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5042           (is_native || is_protected || is_final || is_synchronized) ||
5043           // If a specific method of a class or interface has its
5044           // ACC_ABSTRACT flag set, it must not have any of its
5045           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5046           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5047           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5048           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5049           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5050         is_illegal = true;
5051       }
5052     } else if (major_gte_1_5) {
5053       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5054       if (!is_public || is_private || is_protected || is_static || is_final ||
5055           is_synchronized || is_native || !is_abstract || is_strict) {
5056         is_illegal = true;
5057       }
5058     } else {
5059       // Class file version is pre-JAVA_1_5_VERSION
5060       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5061         is_illegal = true;
5062       }
5063     }
5064   } else { // not interface
5065     if (has_illegal_visibility(flags)) {
5066       is_illegal = true;
5067     } else {
5068       if (is_initializer) {
<span class="line-modified">5069         if (is_static || is_final || is_synchronized || is_native ||</span>
5070             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5071           is_illegal = true;
5072         }









5073       } else { // not initializer
<span class="line-modified">5074         if (is_abstract) {</span>
<span class="line-modified">5075           if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-modified">5076               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-modified">5077             is_illegal = true;</span>





5078           }
5079         }
5080       }
5081     }
5082   }
5083 
5084   if (is_illegal) {
5085     ResourceMark rm(THREAD);
5086     Exceptions::fthrow(
5087       THREAD_AND_LOCATION,
5088       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5089       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5090       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);</span>
5091     return;
5092   }
5093 }
5094 
5095 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5096                                         int length,
5097                                         TRAPS) const {
5098   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5099   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5100     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5101   }
5102 }
5103 
5104 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5105 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5106 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5107 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5108 // method.  Because these names have been checked as special cases before
5109 // calling this method in verify_legal_method_name.
5110 //
</pre>
<hr />
<pre>
5228 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5229 // Return a pointer to just past the signature.
5230 // Return NULL if no legal signature is found.
5231 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5232                                                        bool void_ok,
5233                                                        unsigned int length,
5234                                                        TRAPS) const {
5235   unsigned int array_dim = 0;
5236   while (length &gt; 0) {
5237     switch (signature[0]) {
5238     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5239     case JVM_SIGNATURE_BOOLEAN:
5240     case JVM_SIGNATURE_BYTE:
5241     case JVM_SIGNATURE_CHAR:
5242     case JVM_SIGNATURE_SHORT:
5243     case JVM_SIGNATURE_INT:
5244     case JVM_SIGNATURE_FLOAT:
5245     case JVM_SIGNATURE_LONG:
5246     case JVM_SIGNATURE_DOUBLE:
5247       return signature + 1;
<span class="line-modified">5248     case JVM_SIGNATURE_CLASS: {</span>









5249       if (_major_version &lt; JAVA_1_5_VERSION) {
5250         // Skip over the class name if one is there
5251         const char* const p = skip_over_field_name(signature + 1, true, --length);
5252 
5253         // The next character better be a semicolon
5254         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5255           return p + 1;
5256         }
5257       }
5258       else {
<span class="line-modified">5259         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;</span>
5260         signature++;
5261         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5262         // Format check signature
5263         if (c != NULL) {
5264           int newlen = c - (char*) signature;
5265           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5266           if (!legal) {
5267             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5268                                   &quot;in descriptor in class file %s&quot;,
5269                                   CHECK_NULL);
5270             return NULL;
5271           }
5272           return signature + newlen + 1;
5273         }
5274       }
5275       return NULL;
5276     }
5277     case JVM_SIGNATURE_ARRAY:
5278       array_dim++;
5279       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5294 
5295 // Checks if name is a legal class name.
5296 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5297   if (!_need_verify || _relax_verify) { return; }
5298 
5299   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5300   char* bytes = (char*)name-&gt;bytes();
5301   unsigned int length = name-&gt;utf8_length();
5302   bool legal = false;
5303 
5304   if (length &gt; 0) {
5305     const char* p;
5306     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5307       p = skip_over_field_signature(bytes, false, length, CHECK);
5308       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5309     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5310       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5311         p = skip_over_field_name(bytes, true, length);
5312         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5313       }



5314     } else {
5315       // 4900761: relax the constraints based on JSR202 spec
5316       // Class names may be drawn from the entire Unicode character set.
5317       // Identifiers between &#39;/&#39; must be unqualified names.
5318       // The utf8 string has been verified when parsing cpool entries.
5319       legal = verify_unqualified_name(bytes, length, LegalClass);
5320     }
5321   }
5322   if (!legal) {
5323     ResourceMark rm(THREAD);
5324     assert(_class_name != NULL, &quot;invariant&quot;);
5325     Exceptions::fthrow(
5326       THREAD_AND_LOCATION,
5327       vmSymbols::java_lang_ClassFormatError(),
5328       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5329       _class_name-&gt;as_C_string()
5330     );
5331     return;
5332   }
5333 }
</pre>
<hr />
<pre>
5443   const char* nextp;
5444 
5445   // The first character must be a &#39;(&#39;
5446   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5447     length--;
5448     // Skip over legal field signatures
5449     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5450     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5451       args_size++;
5452       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5453         args_size++;
5454       }
5455       length -= nextp - p;
5456       p = nextp;
5457       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5458     }
5459     // The first non-signature thing better be a &#39;)&#39;
5460     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5461       length--;
5462       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">5463         // All internal methods must return void</span>
5464         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5465           return args_size;
5466         }
















5467       } else {
5468         // Now we better just have a return value
5469         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5470         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5471           return args_size;
5472         }
5473       }
5474     }
5475   }
5476   // Report error
5477   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5478   return 0;
5479 }
5480 
5481 int ClassFileParser::static_field_size() const {
5482   assert(_field_info != NULL, &quot;invariant&quot;);
5483   return _field_info-&gt;_static_field_size;
5484 }
5485 
5486 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
5604 
5605 
5606   if (ik-&gt;should_store_fingerprint()) {
5607     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5608   }
5609 
5610   ik-&gt;set_has_passed_fingerprint_check(false);
5611   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5612     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5613     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5614     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5615       // This class matches with a class saved in an AOT library
5616       ik-&gt;set_has_passed_fingerprint_check(true);
5617     } else {
5618       ResourceMark rm;
5619       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5620                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5621     }
5622   }
5623 






5624   return ik;
5625 }
5626 


































5627 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
5628                                           bool changed_by_loadhook,
5629                                           const ClassInstanceInfo&amp; cl_inst_info,
5630                                           TRAPS) {
5631   assert(ik != NULL, &quot;invariant&quot;);
5632 
5633   // Set name and CLD before adding to CLD
5634   ik-&gt;set_class_loader_data(_loader_data);
5635   ik-&gt;set_name(_class_name);
5636 
5637   // Add all classes to our internal class loader list here,
5638   // including classes in the bootstrap (NULL) class loader.
5639   const bool publicize = !is_internal();
5640 
5641   _loader_data-&gt;add_class(ik, publicize);
5642 
5643   set_klass_to_deallocate(ik);
5644 
5645   assert(_field_info != NULL, &quot;invariant&quot;);
5646   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
5647   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
5648          &quot;sanity&quot;);
5649 
5650   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5651   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
5652 
5653   // Fill in information already parsed
5654   ik-&gt;set_should_verify_class(_need_verify);
5655 
5656   // Not yet: supers are done below to support the new subtype-checking fields
5657   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
5658   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);















5659   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">5660   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);</span>
5661 
5662   // this transfers ownership of a lot of arrays from
5663   // the parser onto the InstanceKlass*
5664   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5665 
5666   // can only set dynamic nest-host after static nest information is set
5667   if (cl_inst_info.dynamic_nest_host() != NULL) {
5668     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
5669   }
5670 
5671   // note that is not safe to use the fields in the parser from this point on
5672   assert(NULL == _cp, &quot;invariant&quot;);
5673   assert(NULL == _fields, &quot;invariant&quot;);
5674   assert(NULL == _methods, &quot;invariant&quot;);
5675   assert(NULL == _inner_classes, &quot;invariant&quot;);
5676   assert(NULL == _nest_members, &quot;invariant&quot;);
5677   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5678   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5679   assert(NULL == _record_components, &quot;invariant&quot;);
5680 
</pre>
<hr />
<pre>
5690   // has to be changed accordingly.
5691   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5692 
5693   ik-&gt;set_this_class_index(_this_class_index);
5694 
5695   if (_is_hidden || is_unsafe_anonymous()) {
5696     // _this_class_index is a CONSTANT_Class entry that refers to this
5697     // hidden or anonymous class itself. If this class needs to refer to its own
5698     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
5699     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
5700     // not stored in SystemDictionary), _this_class_index cannot be resolved
5701     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5702     // Therefore, we must eagerly resolve _this_class_index now.
5703     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5704   }
5705 
5706   ik-&gt;set_minor_version(_minor_version);
5707   ik-&gt;set_major_version(_major_version);
5708   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5709   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);



5710 
5711   if (_unsafe_anonymous_host != NULL) {
5712     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5713     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5714   }
5715   if (_is_hidden) {
5716     ik-&gt;set_is_hidden();
5717   }
5718 
5719   // Set PackageEntry for this_klass
5720   oop cl = ik-&gt;class_loader();
5721   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5722   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5723   ik-&gt;set_package(cld, NULL, CHECK);
5724 
5725   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5726   assert(methods != NULL, &quot;invariant&quot;);
5727   const int methods_len = methods-&gt;length();
5728 
5729   check_methods_for_intrinsics(ik, methods);
</pre>
<hr />
<pre>
5799 
5800   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5801 
5802   // Generate any default methods - default methods are public interface methods
5803   // that have a default implementation.  This is new with Java 8.
5804   if (_has_nonstatic_concrete_methods) {
5805     DefaultMethods::generate_default_methods(ik,
5806                                              _all_mirandas,
5807                                              CHECK);
5808   }
5809 
5810   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5811   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5812       !module_entry-&gt;has_default_read_edges()) {
5813     if (!module_entry-&gt;set_has_default_read_edges()) {
5814       // We won a potential race
5815       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5816     }
5817   }
5818 


































5819   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5820 
5821   if (!is_internal()) {
5822     if (log_is_enabled(Info, class, load)) {
5823       ResourceMark rm;
5824       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5825       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5826     }
5827 
5828     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5829         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5830         log_is_enabled(Info, class, preview)) {
5831       ResourceMark rm;
5832       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5833                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5834     }
5835 
5836     if (log_is_enabled(Debug, class, resolve))  {
5837       ResourceMark rm;
5838       // print out the superclass.
</pre>
<hr />
<pre>
5848         const int length = local_interfaces-&gt;length();
5849         for (int i = 0; i &lt; length; i++) {
5850           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5851           const char * to = k-&gt;external_name();
5852           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5853         }
5854       }
5855     }
5856   }
5857 
5858   JFR_ONLY(INIT_ID(ik);)
5859 
5860   // If we reach here, all is well.
5861   // Now remove the InstanceKlass* from the _klass_to_deallocate field
5862   // in order for it to not be destroyed in the ClassFileParser destructor.
5863   set_klass_to_deallocate(NULL);
5864 
5865   // it&#39;s official
5866   set_klass(ik);
5867 




5868   debug_only(ik-&gt;verify();)
5869 }
5870 
5871 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5872   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5873   _class_name-&gt;decrement_refcount();
5874 
5875   _class_name = new_class_name;
5876   // Increment the refcount of the new name.
5877   // Now the ClassFileParser owns this name and will decrement in
5878   // the destructor.
5879   _class_name-&gt;increment_refcount();
5880 }
5881 
5882 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5883 // package by prepending its host class&#39;s package name to its class name and setting
5884 // its _class_name field.
5885 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
5886   ResourceMark rm(THREAD);
5887   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
</pre>
<hr />
<pre>
5949                                  TRAPS) :
5950   _stream(stream),
5951   _class_name(NULL),
5952   _loader_data(loader_data),
5953   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
5954   _cp_patches(cl_info-&gt;cp_patches()),
5955   _is_hidden(cl_info-&gt;is_hidden()),
5956   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
5957   _num_patched_klasses(0),
5958   _max_num_patched_klasses(0),
5959   _orig_cp_size(0),
5960   _first_patched_klass_resolved_index(0),
5961   _super_klass(),
5962   _cp(NULL),
5963   _fields(NULL),
5964   _methods(NULL),
5965   _inner_classes(NULL),
5966   _nest_members(NULL),
5967   _nest_host(0),
5968   _record_components(NULL),

5969   _local_interfaces(NULL),
5970   _transitive_interfaces(NULL),
5971   _combined_annotations(NULL),
5972   _class_annotations(NULL),
5973   _class_type_annotations(NULL),
5974   _fields_annotations(NULL),
5975   _fields_type_annotations(NULL),
5976   _klass(NULL),
5977   _klass_to_deallocate(NULL),
5978   _parsed_annotations(NULL),
5979   _fac(NULL),
5980   _field_info(NULL),
5981   _method_ordering(NULL),
5982   _all_mirandas(NULL),
5983   _vtable_size(0),
5984   _itable_size(0),
5985   _num_miranda_methods(0),
5986   _rt(REF_NONE),
5987   _protection_domain(cl_info-&gt;protection_domain()),
5988   _access_flags(),
5989   _pub_level(pub_level),
5990   _bad_constant_seen(0),
5991   _synthetic_flag(false),
5992   _sde_length(false),
5993   _sde_buffer(NULL),
5994   _sourcefile_index(0),
5995   _generic_signature_index(0),
5996   _major_version(0),
5997   _minor_version(0),
5998   _this_class_index(0),
5999   _super_class_index(0),
6000   _itfs_len(0),
6001   _java_fields_count(0),
6002   _need_verify(false),
6003   _relax_verify(false),
6004   _has_nonstatic_concrete_methods(false),
6005   _declares_nonstatic_concrete_methods(false),
6006   _has_final_method(false),
6007   _has_contended_fields(false),









6008   _has_finalizer(false),
6009   _has_empty_finalizer(false),
6010   _has_vanilla_constructor(false),
6011   _max_bootstrap_specifier_index(-1) {
6012 
6013   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6014   _class_name-&gt;increment_refcount();
6015 
6016   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6017   assert(_loader_data != NULL, &quot;invariant&quot;);
6018   assert(stream != NULL, &quot;invariant&quot;);
6019   assert(_stream != NULL, &quot;invariant&quot;);
6020   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6021   assert(_class_name != NULL, &quot;invariant&quot;);
6022   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6023 
6024   // Figure out whether we can skip format checking (matching classic VM behavior)
6025   if (DumpSharedSpaces) {
6026     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6027     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6193   } else {
6194     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6195       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6196     }
6197     cp_size += _max_num_patched_klasses;
6198   }
6199 
6200   _cp = ConstantPool::allocate(_loader_data,
6201                                cp_size,
6202                                CHECK);
6203 
6204   ConstantPool* const cp = _cp;
6205 
6206   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6207 
6208   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6209 
6210   // ACCESS FLAGS
6211   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6212 
<span class="line-modified">6213   // Access flags</span>
<span class="line-removed">6214   jint flags;</span>
6215   // JVM_ACC_MODULE is defined in JDK-9 and later.
6216   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6217     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">6218   } else {</span>
<span class="line-modified">6219     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;</span>


6220   }
6221 



6222   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6223     // Set abstract bit for old class files for backward compatibility
6224     flags |= JVM_ACC_ABSTRACT;
6225   }
6226 
6227   verify_legal_class_modifiers(flags, CHECK);
6228 
6229   short bad_constant = class_bad_constant_seen();
6230   if (bad_constant != 0) {
6231     // Do not throw CFE until after the access_flags are checked because if
6232     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6233     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6234   }
6235 
6236   _access_flags.set_flags(flags);
6237 
6238   // This class and superclass
6239   _this_class_index = stream-&gt;get_u2_fast();
6240   check_property(
6241     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
6359           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6360           classlist_file-&gt;flush();
6361         }
6362       }
6363     }
6364 #endif
6365   }
6366 
6367   // SUPERKLASS
6368   _super_class_index = stream-&gt;get_u2_fast();
6369   _super_klass = parse_super_class(cp,
6370                                    _super_class_index,
6371                                    _need_verify,
6372                                    CHECK);
6373 
6374   // Interfaces
6375   _itfs_len = stream-&gt;get_u2_fast();
6376   parse_interfaces(stream,
6377                    _itfs_len,
6378                    cp,

6379                    &amp;_has_nonstatic_concrete_methods,

6380                    CHECK);
6381 
<span class="line-modified">6382   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
6383 
6384   // Fields (offsets are filled in later)
6385   _fac = new FieldAllocationCount();
6386   parse_fields(stream,
<span class="line-modified">6387                _access_flags.is_interface(),</span>

6388                _fac,
6389                cp,
6390                cp_size,
6391                &amp;_java_fields_count,
6392                CHECK);
6393 
6394   assert(_fields != NULL, &quot;invariant&quot;);
6395 
6396   // Methods
6397   AccessFlags promoted_flags;
6398   parse_methods(stream,
<span class="line-modified">6399                 _access_flags.is_interface(),</span>

6400                 &amp;promoted_flags,
6401                 &amp;_has_final_method,
6402                 &amp;_declares_nonstatic_concrete_methods,
6403                 CHECK);
6404 
6405   assert(_methods != NULL, &quot;invariant&quot;);
6406 
6407   // promote flags from parse_methods() to the klass&#39; flags
6408   _access_flags.add_promoted_flags(promoted_flags.as_int());
6409 
6410   if (_declares_nonstatic_concrete_methods) {
6411     _has_nonstatic_concrete_methods = true;
6412   }
6413 
6414   // Additional attributes/annotations
6415   _parsed_annotations = new ClassAnnotationCollector();
6416   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6417 
6418   assert(_inner_classes != NULL, &quot;invariant&quot;);
6419 
</pre>
<hr />
<pre>
6450 
6451   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
6452   // We have to update the resolved_klass_index and the name_index together
6453   // so extract the existing resolved_klass_index first.
6454   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
6455   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
6456   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
6457   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
6458          &quot;Bad name_index&quot;);
6459 }
6460 
6461 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6462                                                  ConstantPool* cp,
6463                                                  TRAPS) {
6464   assert(stream != NULL, &quot;invariant&quot;);
6465   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6466   assert(cp != NULL, &quot;invariant&quot;);
6467   assert(_loader_data != NULL, &quot;invariant&quot;);
6468 
6469   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">6470     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),</span>
<span class="line-modified">6471                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6472                    CHECK);</span>
6473   }
6474   // We check super class after class file is parsed and format is checked
6475   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6476     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">6477     if (_access_flags.is_interface()) {</span>
6478       // Before attempting to resolve the superclass, check for class format
6479       // errors not checked yet.
6480       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6481         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6482         CHECK);
6483     }
6484     Handle loader(THREAD, _loader_data-&gt;class_loader());
6485     _super_klass = (const InstanceKlass*)
6486                        SystemDictionary::resolve_super_or_fail(_class_name,
6487                                                                super_class_name,
6488                                                                loader,
6489                                                                _protection_domain,
6490                                                                true,
6491                                                                CHECK);
6492   }
6493 
6494   if (_super_klass != NULL) {
6495     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6496       _has_nonstatic_concrete_methods = true;
6497     }



6498 
6499     if (_super_klass-&gt;is_interface()) {
6500       ResourceMark rm(THREAD);
6501       Exceptions::fthrow(
6502         THREAD_AND_LOCATION,
6503         vmSymbols::java_lang_IncompatibleClassChangeError(),
6504         &quot;class %s has interface %s as super class&quot;,
6505         _class_name-&gt;as_klass_external_name(),
6506         _super_klass-&gt;external_name()
6507       );
6508       return;
6509     }

6510     // Make sure super class is not final
6511     if (_super_klass-&gt;is_final()) {
6512       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6513     }






















































6514   }


6515 
6516   // Compute the transitive list of all unique interfaces implemented by this class
6517   _transitive_interfaces =
6518     compute_transitive_interfaces(_super_klass,
6519                                   _local_interfaces,
6520                                   _loader_data,
6521                                   CHECK);
6522 
6523   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6524 
6525   // sort methods
6526   _method_ordering = sort_methods(_methods);
6527 
6528   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6529 
6530   Handle loader(THREAD, _loader_data-&gt;class_loader());
6531   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6532                                                     &amp;_num_miranda_methods,
6533                                                     _all_mirandas,
6534                                                     _super_klass,
6535                                                     _methods,
6536                                                     _access_flags,
6537                                                     _major_version,
6538                                                     loader,
6539                                                     _class_name,
6540                                                     _local_interfaces,
6541                                                     CHECK);
6542 
6543   // Size of Java itable (in words)
<span class="line-modified">6544   _itable_size = _access_flags.is_interface() ? 0 :</span>
6545     klassItable::compute_itable_size(_transitive_interfaces);
6546 
6547   assert(_fac != NULL, &quot;invariant&quot;);
6548   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6549 













6550   _field_info = new FieldLayoutInfo();
6551   if (UseNewFieldLayout) {
6552     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">6553                           _parsed_annotations-&gt;is_contended(), _field_info);</span>
<span class="line-modified">6554     lb.build_layout();</span>






6555   } else {
6556     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
6557   }
6558 
<span class="line-modified">6559   // Compute reference typ</span>
6560   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
<span class="line-removed">6561 </span>
6562 }
6563 
6564 void ClassFileParser::set_klass(InstanceKlass* klass) {
6565 
6566 #ifdef ASSERT
6567   if (klass != NULL) {
6568     assert(NULL == _klass, &quot;leaking?&quot;);
6569   }
6570 #endif
6571 
6572   _klass = klass;
6573 }
6574 
6575 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6576 
6577 #ifdef ASSERT
6578   if (klass != NULL) {
6579     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6580   }
6581 #endif
6582 
6583   _klass_to_deallocate = klass;
6584 }
6585 
6586 // Caller responsible for ResourceMark
6587 // clone stream with rewound position
6588 const ClassFileStream* ClassFileParser::clone_stream() const {
6589   assert(_stream != NULL, &quot;invariant&quot;);
6590 
6591   return _stream-&gt;clone();
6592 }

6593 // ----------------------------------------------------------------------------
6594 // debugging
6595 
6596 #ifdef ASSERT
6597 
6598 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6599 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6600   if (class_name != NULL) {
6601     ResourceMark rm;
6602     char* name = class_name-&gt;as_C_string();
6603     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6604   } else {
6605     return true;
6606   }
6607 }
6608 
6609 #endif
</pre>
</td>
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
<span class="line-added">  24 </span>
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/defaultMethods.hpp&quot;
  33 #include &quot;classfile/dictionary.hpp&quot;
  34 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/moduleEntry.hpp&quot;
  37 #include &quot;classfile/packageEntry.hpp&quot;
  38 #include &quot;classfile/symbolTable.hpp&quot;
  39 #include &quot;classfile/systemDictionary.hpp&quot;
  40 #include &quot;classfile/verificationType.hpp&quot;
  41 #include &quot;classfile/verifier.hpp&quot;
  42 #include &quot;classfile/vmSymbols.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/annotations.hpp&quot;
  51 #include &quot;oops/constantPool.inline.hpp&quot;
  52 #include &quot;oops/fieldStreams.inline.hpp&quot;
  53 #include &quot;oops/instanceKlass.hpp&quot;
  54 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  55 #include &quot;oops/klass.inline.hpp&quot;
  56 #include &quot;oops/klassVtable.hpp&quot;
  57 #include &quot;oops/metadata.hpp&quot;
  58 #include &quot;oops/method.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;oops/recordComponent.hpp&quot;
  61 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  62 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  63 #include &quot;prims/jvmtiExport.hpp&quot;
  64 #include &quot;prims/jvmtiThreadState.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;
<span class="line-added">  86 #include &quot;utilities/stringUtils.hpp&quot;</span>
  87 #include &quot;utilities/utf8.hpp&quot;
  88 
  89 #if INCLUDE_CDS
  90 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  91 #endif
  92 #if INCLUDE_JFR
  93 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  94 #endif
  95 
  96 // We generally try to create the oops directly when parsing, rather than
  97 // allocating temporary data structures and copying the bytes twice. A
  98 // temporary area is only needed when parsing utf8 entries in the constant
  99 // pool and when parsing line number tables.
 100 
 101 // We add assert in debug mode when class format is not checked.
 102 
 103 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 104 #define JAVA_MIN_SUPPORTED_VERSION        45
 105 #define JAVA_PREVIEW_MINOR_VERSION        65535
 106 
</pre>
<hr />
<pre>
 118 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 119 #define JAVA_7_VERSION                    51
 120 
 121 // Extension method support.
 122 #define JAVA_8_VERSION                    52
 123 
 124 #define JAVA_9_VERSION                    53
 125 
 126 #define JAVA_10_VERSION                   54
 127 
 128 #define JAVA_11_VERSION                   55
 129 
 130 #define JAVA_12_VERSION                   56
 131 
 132 #define JAVA_13_VERSION                   57
 133 
 134 #define JAVA_14_VERSION                   58
 135 
 136 #define JAVA_15_VERSION                   59
 137 
<span class="line-added"> 138 #define CONSTANT_CLASS_DESCRIPTORS        59</span>
<span class="line-added"> 139 </span>
 140 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 141   assert((bad_constant == JVM_CONSTANT_Module ||
 142           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 143          &quot;Unexpected bad constant pool entry&quot;);
 144   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 145 }
 146 
 147 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 148                                                   ConstantPool* cp,
 149                                                   const int length,
 150                                                   TRAPS) {
 151   assert(stream != NULL, &quot;invariant&quot;);
 152   assert(cp != NULL, &quot;invariant&quot;);
 153 
 154   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 155   // this function (_current can be allocated in a register, with scalar
 156   // replacement of aggregates). The _current pointer is copied back to
 157   // stream() when this function returns. DON&#39;T call another method within
 158   // this method that uses stream().
 159   const ClassFileStream cfs1 = *stream;
 160   const ClassFileStream* const cfs = &amp;cfs1;
 161 
 162   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 163   debug_only(const u1* const old_current = stream-&gt;current();)
 164 
 165   // Used for batching symbol allocations.
 166   const char* names[SymbolTable::symbol_alloc_batch_size];
 167   int lengths[SymbolTable::symbol_alloc_batch_size];
 168   int indices[SymbolTable::symbol_alloc_batch_size];
 169   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 170   int names_count = 0;
 171 
 172   // parsing  Index 0 is unused
 173   for (int index = 1; index &lt; length; index++) {
 174     // Each of the following case guarantees one more byte in the stream
 175     // for the following tag or the access_flags following constant pool,
 176     // so we don&#39;t need bounds-check for reading tag.
 177     const u1 tag = cfs-&gt;get_u1_fast();
 178     switch (tag) {
<span class="line-modified"> 179       case JVM_CONSTANT_Class: {</span>
 180         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 181         const u2 name_index = cfs-&gt;get_u2_fast();
 182         cp-&gt;klass_index_at_put(index, name_index);
 183         break;
 184       }
 185       case JVM_CONSTANT_Fieldref: {
 186         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 187         const u2 class_index = cfs-&gt;get_u2_fast();
 188         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 189         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 190         break;
 191       }
 192       case JVM_CONSTANT_Methodref: {
 193         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 194         const u2 class_index = cfs-&gt;get_u2_fast();
 195         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 196         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 197         break;
 198       }
 199       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 489         check_property(valid_symbol_at(name_ref_index),
 490           &quot;Invalid constant pool index %u in class file %s&quot;,
 491           name_ref_index, CHECK);
 492         check_property(valid_symbol_at(signature_ref_index),
 493           &quot;Invalid constant pool index %u in class file %s&quot;,
 494           signature_ref_index, CHECK);
 495         break;
 496       }
 497       case JVM_CONSTANT_Utf8:
 498         break;
 499       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 500       case JVM_CONSTANT_UnresolvedClassInError: {
 501         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 502         break;
 503       }
 504       case JVM_CONSTANT_ClassIndex: {
 505         const int class_index = cp-&gt;klass_index_at(index);
 506         check_property(valid_symbol_at(class_index),
 507           &quot;Invalid constant pool index %u in class file %s&quot;,
 508           class_index, CHECK);
<span class="line-modified"> 509 </span>
<span class="line-added"> 510         Symbol* const name = cp-&gt;symbol_at(class_index);</span>
<span class="line-added"> 511         const unsigned int name_len = name-&gt;utf8_length();</span>
<span class="line-added"> 512         if (name-&gt;is_Q_signature()) {</span>
<span class="line-added"> 513           cp-&gt;unresolved_qdescriptor_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 514         } else {</span>
<span class="line-added"> 515           cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 516         }</span>
 517         break;
 518       }
 519       case JVM_CONSTANT_StringIndex: {
 520         const int string_index = cp-&gt;string_index_at(index);
 521         check_property(valid_symbol_at(string_index),
 522           &quot;Invalid constant pool index %u in class file %s&quot;,
 523           string_index, CHECK);
 524         Symbol* const sym = cp-&gt;symbol_at(string_index);
 525         cp-&gt;unresolved_string_at_put(index, sym);
 526         break;
 527       }
 528       case JVM_CONSTANT_MethodHandle: {
 529         const int ref_index = cp-&gt;method_handle_index_at(index);
 530         check_property(valid_cp_range(ref_index, length),
 531           &quot;Invalid constant pool index %u in class file %s&quot;,
 532           ref_index, CHECK);
 533         const constantTag tag = cp-&gt;tag_at(ref_index);
 534         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 535 
 536         switch (ref_kind) {
</pre>
<hr />
<pre>
 750             classfile_parse_error(
 751               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 752               name_ref_index, CHECK);
 753           }
 754         }
 755         break;
 756       }
 757       case JVM_CONSTANT_MethodHandle: {
 758         const int ref_index = cp-&gt;method_handle_index_at(index);
 759         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 760         switch (ref_kind) {
 761           case JVM_REF_invokeVirtual:
 762           case JVM_REF_invokeStatic:
 763           case JVM_REF_invokeSpecial:
 764           case JVM_REF_newInvokeSpecial: {
 765             const int name_and_type_ref_index =
 766               cp-&gt;name_and_type_ref_index_at(ref_index);
 767             const int name_ref_index =
 768               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 769             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 770             if (name != vmSymbols::object_initializer_name()) {</span>
<span class="line-modified"> 771               if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
 772                 classfile_parse_error(
 773                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 774                     name_ref_index, CHECK);
 775               }
 776             } else {
<span class="line-modified"> 777               // The allowed invocation mode of &lt;init&gt; depends on its signature.</span>
<span class="line-added"> 778               // This test corresponds to verify_invoke_instructions in the verifier.</span>
<span class="line-added"> 779               const int signature_ref_index =</span>
<span class="line-added"> 780                 cp-&gt;signature_ref_index_at(name_and_type_ref_index);</span>
<span class="line-added"> 781               const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);</span>
<span class="line-added"> 782               if (signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 783                   &amp;&amp; ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-added"> 784                 // OK, could be a constructor call</span>
<span class="line-added"> 785               } else if (!signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 786                          &amp;&amp; ref_kind == JVM_REF_invokeStatic) {</span>
<span class="line-added"> 787                 // also OK, could be a static factory call</span>
<span class="line-added"> 788               } else {</span>
 789                 classfile_parse_error(
 790                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 791                   name_ref_index, CHECK);
 792               }
 793             }
 794             break;
 795           }
 796           // Other ref_kinds are already fully checked in previous pass.
 797         } // switch(ref_kind)
 798         break;
 799       }
 800       case JVM_CONSTANT_MethodType: {
 801         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 802         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 803         verify_legal_method_signature(no_name, signature, CHECK);
 804         break;
 805       }
 806       case JVM_CONSTANT_Utf8: {
 807         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 808       }
</pre>
<hr />
<pre>
 927   while (entry != NULL) {
 928     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 929       return false;
 930     }
 931     entry = entry-&gt;_next;
 932   }
 933 
 934   // No duplicate is found, allocate a new entry and fill it.
 935   entry = new NameSigHash();
 936   entry-&gt;_name = name;
 937   entry-&gt;_sig = sig;
 938 
 939   // Insert into hash table
 940   entry-&gt;_next = table[index];
 941   table[index] = entry;
 942 
 943   return true;
 944 }
 945 
 946 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,</span>
<span class="line-modified"> 948                                        int itfs_len,</span>
<span class="line-modified"> 949                                        ConstantPool* cp,</span>
<span class="line-added"> 950                                        bool is_inline_type,</span>
 951                                        bool* const has_nonstatic_concrete_methods,
<span class="line-added"> 952                                        // FIXME: lots of these functions</span>
<span class="line-added"> 953                                        // declare their parameters as const,</span>
<span class="line-added"> 954                                        // which adds only noise to the code.</span>
<span class="line-added"> 955                                        // Remove the spurious const modifiers.</span>
<span class="line-added"> 956                                        // Many are of the form &quot;const int x&quot;</span>
<span class="line-added"> 957                                        // or &quot;T* const x&quot;.</span>
<span class="line-added"> 958                                        bool* const is_declared_atomic,</span>
 959                                        TRAPS) {
 960   assert(stream != NULL, &quot;invariant&quot;);
 961   assert(cp != NULL, &quot;invariant&quot;);
 962   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 963 
 964   if (itfs_len == 0) {
<span class="line-modified"> 965     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(0);</span>
 966   } else {
 967     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 968     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len);</span>
<span class="line-modified"> 969     int index = 0;</span>

 970     for (index = 0; index &lt; itfs_len; index++) {
 971       const u2 interface_index = stream-&gt;get_u2(CHECK);
 972       Klass* interf;
 973       check_property(
 974         valid_klass_reference_at(interface_index),
 975         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 976         interface_index, CHECK);
 977       if (cp-&gt;tag_at(interface_index).is_klass()) {
 978         interf = cp-&gt;resolved_klass_at(interface_index);
 979       } else {
 980         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 981 
 982         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 983         // But need to make sure it&#39;s not an array type.
 984         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 985                            &quot;Bad interface name in class file %s&quot;, CHECK);
 986 
<span class="line-modified"> 987         // Call resolve_super so class circularity is checked</span>
 988         interf = SystemDictionary::resolve_super_or_fail(
 989                                                   _class_name,
 990                                                   unresolved_klass,
 991                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 992                                                   _protection_domain,
 993                                                   false,
 994                                                   CHECK);
 995       }
 996 
 997       if (!interf-&gt;is_interface()) {
 998         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 999                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1000                           _class_name-&gt;as_klass_external_name(),
1001                           interf-&gt;external_name(),
1002                           interf-&gt;class_in_module_of_loader()));
1003       }
1004 
<span class="line-modified">1005       InstanceKlass* ik = InstanceKlass::cast(interf);</span>
<span class="line-added">1006       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">1007         ResourceMark rm(THREAD);</span>
<span class="line-added">1008         Exceptions::fthrow(</span>
<span class="line-added">1009           THREAD_AND_LOCATION,</span>
<span class="line-added">1010           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">1011           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,</span>
<span class="line-added">1012           _class_name-&gt;as_klass_external_name());</span>
<span class="line-added">1013         return;</span>
<span class="line-added">1014       }</span>
<span class="line-added">1015       if (ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">1016         set_invalid_inline_super();</span>
<span class="line-added">1017       }</span>
<span class="line-added">1018       if (ik-&gt;has_nonstatic_concrete_methods()) {</span>
1019         *has_nonstatic_concrete_methods = true;
1020       }
<span class="line-modified">1021       if (ik-&gt;is_declared_atomic()) {</span>
<span class="line-added">1022         *is_declared_atomic = true;</span>
<span class="line-added">1023       }</span>
<span class="line-added">1024       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">1025         _implements_identityObject = true;</span>
<span class="line-added">1026       }</span>
<span class="line-added">1027       _temp_local_interfaces-&gt;append(ik);</span>
1028     }
1029 
1030     if (!_need_verify || itfs_len &lt;= 1) {
1031       return;
1032     }
1033 
1034     // Check if there&#39;s any duplicates in interfaces
1035     ResourceMark rm(THREAD);
1036     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1037                                                                  NameSigHash*,
1038                                                                  HASH_ROW_SIZE);
1039     initialize_hashtable(interface_names);
1040     bool dup = false;
1041     const Symbol* name = NULL;
1042     {
1043       debug_only(NoSafepointVerifier nsv;)
1044       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">1045         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);</span>
1046         name = k-&gt;name();
1047         // If no duplicates, add (name, NULL) in hashtable interface_names.
1048         if (!put_after_lookup(name, NULL, interface_names)) {
1049           dup = true;
1050           break;
1051         }
1052       }
1053     }
1054     if (dup) {
1055       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1056                              name-&gt;as_C_string(), CHECK);
1057     }
1058   }
1059 }
1060 
1061 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1062                                            int constantvalue_index,
1063                                            int signature_index,
1064                                            TRAPS) const {
1065   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1501                                             CHECK);
1502   parsed_annotations-&gt;set_field_annotations(a);
1503   a = assemble_annotations(runtime_visible_type_annotations,
1504                            runtime_visible_type_annotations_length,
1505                            runtime_invisible_type_annotations,
1506                            runtime_invisible_type_annotations_length,
1507                            CHECK);
1508   parsed_annotations-&gt;set_field_type_annotations(a);
1509   return;
1510 }
1511 
1512 
1513 // Field allocation types. Used for computing field offsets.
1514 
1515 enum FieldAllocationType {
1516   STATIC_OOP,           // Oops
1517   STATIC_BYTE,          // Boolean, Byte, char
1518   STATIC_SHORT,         // shorts
1519   STATIC_WORD,          // ints
1520   STATIC_DOUBLE,        // aligned long or double
<span class="line-added">1521   STATIC_FLATTENABLE,   // flattenable field</span>
1522   NONSTATIC_OOP,
1523   NONSTATIC_BYTE,
1524   NONSTATIC_SHORT,
1525   NONSTATIC_WORD,
1526   NONSTATIC_DOUBLE,
<span class="line-added">1527   NONSTATIC_FLATTENABLE,</span>
1528   MAX_FIELD_ALLOCATION_TYPE,
1529   BAD_ALLOCATION_TYPE = -1
1530 };
1531 
1532 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1533   BAD_ALLOCATION_TYPE, // 0
1534   BAD_ALLOCATION_TYPE, // 1
1535   BAD_ALLOCATION_TYPE, // 2
1536   BAD_ALLOCATION_TYPE, // 3
1537   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1538   NONSTATIC_SHORT,     // T_CHAR        =  5,
1539   NONSTATIC_WORD,      // T_FLOAT       =  6,
1540   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1541   NONSTATIC_BYTE,      // T_BYTE        =  8,
1542   NONSTATIC_SHORT,     // T_SHORT       =  9,
1543   NONSTATIC_WORD,      // T_INT         = 10,
1544   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1545   NONSTATIC_OOP,       // T_OBJECT      = 12,
1546   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1547   NONSTATIC_OOP,       // T_VALUETYPE   = 14,</span>
<span class="line-modified">1548   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1549   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1550   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1551   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1552   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1553   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,</span>
1554   BAD_ALLOCATION_TYPE, // 0
1555   BAD_ALLOCATION_TYPE, // 1
1556   BAD_ALLOCATION_TYPE, // 2
1557   BAD_ALLOCATION_TYPE, // 3
1558   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1559   STATIC_SHORT,        // T_CHAR        =  5,
1560   STATIC_WORD,         // T_FLOAT       =  6,
1561   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1562   STATIC_BYTE,         // T_BYTE        =  8,
1563   STATIC_SHORT,        // T_SHORT       =  9,
1564   STATIC_WORD,         // T_INT         = 10,
1565   STATIC_DOUBLE,       // T_LONG        = 11,
1566   STATIC_OOP,          // T_OBJECT      = 12,
1567   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1568   STATIC_OOP,          // T_VALUETYPE   = 14,</span>
<span class="line-modified">1569   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1570   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1571   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1572   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1573   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1574   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20</span>
1575 };
1576 
<span class="line-modified">1577 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_flattenable) {</span>
1578   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1579   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1580   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<span class="line-added">1581   if (is_flattenable) {</span>
<span class="line-added">1582     result = is_static ? STATIC_FLATTENABLE : NONSTATIC_FLATTENABLE;</span>
<span class="line-added">1583   }</span>
1584   return result;
1585 }
1586 
1587 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1588  public:
1589   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1590 
1591   FieldAllocationCount() {
1592     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1593       count[i] = 0;
1594     }
1595   }
1596 
<span class="line-modified">1597   FieldAllocationType update(bool is_static, BasicType type, bool is_flattenable) {</span>
<span class="line-modified">1598     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_flattenable);</span>
1599     if (atype != BAD_ALLOCATION_TYPE) {
1600       // Make sure there is no overflow with injected fields.
1601       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1602       count[atype]++;
1603     }
1604     return atype;
1605   }
1606 };
1607 
1608 // Side-effects: populates the _fields, _fields_annotations,
1609 // _fields_type_annotations fields
1610 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1611                                    bool is_interface,
<span class="line-added">1612                                    bool is_inline_type,</span>
1613                                    FieldAllocationCount* const fac,
1614                                    ConstantPool* cp,
1615                                    const int cp_size,
1616                                    u2* const java_fields_count_ptr,
1617                                    TRAPS) {
1618 
1619   assert(cfs != NULL, &quot;invariant&quot;);
1620   assert(fac != NULL, &quot;invariant&quot;);
1621   assert(cp != NULL, &quot;invariant&quot;);
1622   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1623 
1624   assert(NULL == _fields, &quot;invariant&quot;);
1625   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1626   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1627 
1628   cfs-&gt;guarantee_more(2, CHECK);  // length
1629   const u2 length = cfs-&gt;get_u2_fast();
1630   *java_fields_count_ptr = length;
1631 
1632   int num_injected = 0;
1633   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1634                                                                   &amp;num_injected);
<span class="line-modified">1635 </span>
<span class="line-added">1636   // two more slots are required for inline classes:</span>
<span class="line-added">1637   // one for the static field with a reference to the pre-allocated default value</span>
<span class="line-added">1638   // one for the field the JVM injects when detecting an empty inline class</span>
<span class="line-added">1639   const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);</span>
1640 
1641   // The field array starts with tuples of shorts
1642   // [access, name index, sig index, initial value index, byte offset].
1643   // A generic signature slot only exists for field with generic
1644   // signature attribute. And the access flag is set with
1645   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1646   // signature slots are at the end of the field array and after all
1647   // other fields data.
1648   //
1649   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1650   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1651   //       ...
1652   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1653   //       [generic signature index]
1654   //       [generic signature index]
1655   //       ...
1656   //
1657   // Allocate a temporary resource array for field data. For each field,
1658   // a slot is reserved in the temporary array for the generic signature
1659   // index. After parsing all fields, the data are copied to a permanent
1660   // array and any unused slots will be discarded.
1661   ResourceMark rm(THREAD);
1662   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1663                                               u2,
1664                                               total_fields * (FieldInfo::field_slots + 1));
1665 
1666   // The generic signature slots start after all other fields&#39; data.
1667   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1668   int num_generic_signature = 0;
<span class="line-added">1669   int instance_fields_count = 0;</span>
1670   for (int n = 0; n &lt; length; n++) {
1671     // access_flags, name_index, descriptor_index, attributes_count
1672     cfs-&gt;guarantee_more(8, CHECK);
1673 
<span class="line-added">1674     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-added">1675 </span>
<span class="line-added">1676     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">1677     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);</span>
1678     AccessFlags access_flags;


1679     access_flags.set_flags(flags);
1680 
1681     const u2 name_index = cfs-&gt;get_u2_fast();
1682     check_property(valid_symbol_at(name_index),
1683       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1684       name_index, CHECK);
1685     const Symbol* const name = cp-&gt;symbol_at(name_index);
1686     verify_legal_field_name(name, CHECK);
1687 
1688     const u2 signature_index = cfs-&gt;get_u2_fast();
1689     check_property(valid_symbol_at(signature_index),
1690       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1691       signature_index, CHECK);
1692     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1693     verify_legal_field_signature(name, sig, CHECK);
<span class="line-added">1694     assert(!access_flags.is_flattenable(), &quot;ACC_FLATTENABLE should have been filtered out&quot;);</span>
<span class="line-added">1695     if (sig-&gt;is_Q_signature()) {</span>
<span class="line-added">1696       // assert(_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS, &quot;Q-descriptors are only supported in recent classfiles&quot;);</span>
<span class="line-added">1697       access_flags.set_is_flattenable();</span>
<span class="line-added">1698     }</span>
<span class="line-added">1699     if (access_flags.is_flattenable()) {</span>
<span class="line-added">1700       // Array flattenability cannot be specified.  Arrays of value classes are</span>
<span class="line-added">1701       // are always flattenable.  Arrays of other classes are not flattenable.</span>
<span class="line-added">1702       if (sig-&gt;utf8_length() &gt; 1 &amp;&amp; sig-&gt;char_at(0) == &#39;[&#39;) {</span>
<span class="line-added">1703         classfile_parse_error(</span>
<span class="line-added">1704             &quot;Field \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s is invalid.&quot;</span>
<span class="line-added">1705             &quot; ACC_FLATTENABLE cannot be specified for an array&quot;,</span>
<span class="line-added">1706             name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);</span>
<span class="line-added">1707       }</span>
<span class="line-added">1708       _has_flattenable_fields = true;</span>
<span class="line-added">1709     }</span>
<span class="line-added">1710     if (!access_flags.is_static()) instance_fields_count++;</span>
1711 
1712     u2 constantvalue_index = 0;
1713     bool is_synthetic = false;
1714     u2 generic_signature_index = 0;
1715     const bool is_static = access_flags.is_static();
1716     FieldAnnotationCollector parsed_annotations(_loader_data);
1717 
1718     const u2 attributes_count = cfs-&gt;get_u2_fast();
1719     if (attributes_count &gt; 0) {
1720       parse_field_attributes(cfs,
1721                              attributes_count,
1722                              is_static,
1723                              signature_index,
1724                              &amp;constantvalue_index,
1725                              &amp;is_synthetic,
1726                              &amp;generic_signature_index,
1727                              &amp;parsed_annotations,
1728                              CHECK);
1729 
1730       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1750 
1751       if (is_synthetic) {
1752         access_flags.set_is_synthetic();
1753       }
1754       if (generic_signature_index != 0) {
1755         access_flags.set_field_has_generic_signature();
1756         fa[generic_signature_slot] = generic_signature_index;
1757         generic_signature_slot ++;
1758         num_generic_signature ++;
1759       }
1760     }
1761 
1762     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1763     field-&gt;initialize(access_flags.as_short(),
1764                       name_index,
1765                       signature_index,
1766                       constantvalue_index);
1767     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1768 
1769     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1770     const FieldAllocationType atype = fac-&gt;update(is_static, type, access_flags.is_flattenable());</span>
1771     field-&gt;set_allocation_type(atype);
1772 
1773     // After field is initialized with type, we can augment it with aux info
1774     if (parsed_annotations.has_any_annotations()) {
1775       parsed_annotations.apply_to(field);
1776       if (field-&gt;is_contended()) {
1777         _has_contended_fields = true;
1778       }
1779     }
1780   }
1781 
1782   int index = length;
1783   if (num_injected != 0) {
1784     for (int n = 0; n &lt; num_injected; n++) {
1785       // Check for duplicates
1786       if (injected[n].may_be_java) {
1787         const Symbol* const name      = injected[n].name();
1788         const Symbol* const signature = injected[n].signature();
1789         bool duplicate = false;
1790         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1795             duplicate = true;
1796             break;
1797           }
1798         }
1799         if (duplicate) {
1800           // These will be removed from the field array at the end
1801           continue;
1802         }
1803       }
1804 
1805       // Injected field
1806       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1807       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1808                         injected[n].name_index,
1809                         injected[n].signature_index,
1810                         0);
1811 
1812       const BasicType type = Signature::basic_type(injected[n].signature());
1813 
1814       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1815       const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
1816       field-&gt;set_allocation_type(atype);
1817       index++;
1818     }
1819   }
1820 
<span class="line-added">1821   if (is_inline_type) {</span>
<span class="line-added">1822     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1823     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,</span>
<span class="line-added">1824                       vmSymbols::default_value_name_enum,</span>
<span class="line-added">1825                       vmSymbols::object_signature_enum,</span>
<span class="line-added">1826                       0);</span>
<span class="line-added">1827     const BasicType type = Signature::basic_type(vmSymbols::object_signature());</span>
<span class="line-added">1828     const FieldAllocationType atype = fac-&gt;update(true, type, false);</span>
<span class="line-added">1829     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1830     index++;</span>
<span class="line-added">1831   }</span>
<span class="line-added">1832 </span>
<span class="line-added">1833   if (is_inline_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-added">1834     _is_empty_inline_type = true;</span>
<span class="line-added">1835     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1836     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,</span>
<span class="line-added">1837         vmSymbols::empty_marker_name_enum,</span>
<span class="line-added">1838         vmSymbols::byte_signature_enum,</span>
<span class="line-added">1839         0);</span>
<span class="line-added">1840     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());</span>
<span class="line-added">1841     const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
<span class="line-added">1842     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1843     index++;</span>
<span class="line-added">1844   }</span>
<span class="line-added">1845 </span>
<span class="line-added">1846   if (instance_fields_count &gt; 0) {</span>
<span class="line-added">1847     _has_nonstatic_fields = true;</span>
<span class="line-added">1848   }</span>
<span class="line-added">1849 </span>
1850   assert(NULL == _fields, &quot;invariant&quot;);
1851 
1852   _fields =
1853     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1854                                    index * FieldInfo::field_slots + num_generic_signature,
1855                                    CHECK);
1856   // Sometimes injected fields already exist in the Java source so
1857   // the fields array could be too long.  In that case the
1858   // fields array is trimed. Also unused slots that were reserved
1859   // for generic signature indexes are discarded.
1860   {
1861     int i = 0;
1862     for (; i &lt; index * FieldInfo::field_slots; i++) {
1863       _fields-&gt;at_put(i, fa[i]);
1864     }
1865     for (int j = total_fields * FieldInfo::field_slots;
1866          j &lt; generic_signature_slot; j++) {
1867       _fields-&gt;at_put(i++, fa[j]);
1868     }
1869     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2145         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2146         checked_exception, CHECK_NULL);
2147     }
2148   }
2149   // check exceptions attribute length
2150   if (_need_verify) {
2151     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2152                                                    sizeof(u2) * size),
2153                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2154   }
2155   return checked_exceptions_start;
2156 }
2157 
2158 void ClassFileParser::throwIllegalSignature(const char* type,
2159                                             const Symbol* name,
2160                                             const Symbol* sig,
2161                                             TRAPS) const {
2162   assert(name != NULL, &quot;invariant&quot;);
2163   assert(sig != NULL, &quot;invariant&quot;);
2164 
<span class="line-added">2165   const char* class_note = &quot;&quot;;</span>
<span class="line-added">2166   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">2167     class_note = &quot; (an inline class)&quot;;</span>
<span class="line-added">2168   }</span>
<span class="line-added">2169 </span>
2170   ResourceMark rm(THREAD);
2171   Exceptions::fthrow(THREAD_AND_LOCATION,
2172       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2173       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2174       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());</span>
2175 }
2176 
2177 AnnotationCollector::ID
2178 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2179                                       const Symbol* name,
2180                                       const bool can_access_vm_annotations) {
2181   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2182   // Privileged code can use all annotations.  Other code silently drops some.
2183   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2184                           loader_data-&gt;is_platform_class_loader_data() ||
2185                           can_access_vm_annotations;
2186   switch (sid) {
2187     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2188       if (_location != _in_method)  break;  // only allow for methods
2189       if (!privileged)              break;  // only allow in privileged code
2190       return _method_CallerSensitive;
2191     }
2192     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2193       if (_location != _in_method)  break;  // only allow for methods
2194       if (!privileged)              break;  // only allow in privileged code
</pre>
<hr />
<pre>
2419                              runtime_visible_type_annotations_length,
2420                              runtime_invisible_type_annotations,
2421                              runtime_invisible_type_annotations_length,
2422                              CHECK);
2423     cm-&gt;set_type_annotations(a);
2424   }
2425 }
2426 
2427 
2428 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2429 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2430 // Method* to save footprint, so we only know the size of the resulting Method* when the
2431 // entire method attribute is parsed.
2432 //
2433 // The promoted_flags parameter is used to pass relevant access_flags
2434 // from the method back up to the containing klass. These flag values
2435 // are added to klass&#39;s access_flags.
2436 
2437 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2438                                       bool is_interface,
<span class="line-added">2439                                       bool is_inline_type,</span>
2440                                       const ConstantPool* cp,
2441                                       AccessFlags* const promoted_flags,
2442                                       TRAPS) {
2443   assert(cfs != NULL, &quot;invariant&quot;);
2444   assert(cp != NULL, &quot;invariant&quot;);
2445   assert(promoted_flags != NULL, &quot;invariant&quot;);
2446 
2447   ResourceMark rm(THREAD);
2448   // Parse fixed parts:
2449   // access_flags, name_index, descriptor_index, attributes_count
2450   cfs-&gt;guarantee_more(8, CHECK_NULL);
2451 
2452   int flags = cfs-&gt;get_u2_fast();
2453   const u2 name_index = cfs-&gt;get_u2_fast();
2454   const int cp_size = cp-&gt;length();
2455   check_property(
2456     valid_symbol_at(name_index),
2457     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2458     name_index, CHECK_NULL);
2459   const Symbol* const name = cp-&gt;symbol_at(name_index);
2460   verify_legal_method_name(name, CHECK_NULL);
2461 
2462   const u2 signature_index = cfs-&gt;get_u2_fast();
2463   guarantee_property(
2464     valid_symbol_at(signature_index),
2465     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2466     signature_index, CHECK_NULL);
2467   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2468 
2469   if (name == vmSymbols::class_initializer_name()) {
2470     // We ignore the other access flags for a valid class initializer.
2471     // (JVM Spec 2nd ed., chapter 4.6)
2472     if (_major_version &lt; 51) { // backward compatibility
2473       flags = JVM_ACC_STATIC;
2474     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2475       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2476     } else {
2477       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2478     }
2479   } else {
<span class="line-modified">2480     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);</span>
<span class="line-modified">2481   }</span>
<span class="line-modified">2482 </span>
<span class="line-modified">2483   if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-modified">2484     if (is_interface) {</span>
<span class="line-added">2485       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>
<span class="line-added">2486     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2487       // OK, a constructor</span>
<span class="line-added">2488     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2489       // also OK, a static factory, as long as the return value is good</span>
<span class="line-added">2490       bool ok = false;</span>
<span class="line-added">2491       SignatureStream ss((Symbol*) signature, true);</span>
<span class="line-added">2492       while (!ss.at_return_type())  ss.next();</span>
<span class="line-added">2493       if (ss.is_reference()) {</span>
<span class="line-added">2494         Symbol* ret = ss.as_symbol();</span>
<span class="line-added">2495         const Symbol* required = class_name();</span>
<span class="line-added">2496         if (is_unsafe_anonymous()) {</span>
<span class="line-added">2497           // The original class name in the UAC byte stream gets changed.  So</span>
<span class="line-added">2498           // using the original name in the return type is no longer valid.</span>
<span class="line-added">2499           required = vmSymbols::java_lang_Object();</span>
<span class="line-added">2500         }</span>
<span class="line-added">2501         ok = (ret == required);</span>
<span class="line-added">2502       }</span>
<span class="line-added">2503       if (!ok) {</span>
<span class="line-added">2504         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2505       }</span>
<span class="line-added">2506     } else {</span>
<span class="line-added">2507       // not OK, so throw the same error as in verify_legal_method_signature.</span>
<span class="line-added">2508       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2509     }</span>
<span class="line-added">2510     // A declared &lt;init&gt; method must always be either a non-static</span>
<span class="line-added">2511     // object constructor, with a void return, or else it must be a</span>
<span class="line-added">2512     // static factory method, with a non-void return.  No other</span>
<span class="line-added">2513     // definition of &lt;init&gt; is possible.</span>
<span class="line-added">2514     //</span>
<span class="line-added">2515     // The verifier (in verify_invoke_instructions) will inspect the</span>
<span class="line-added">2516     // signature of any attempt to invoke &lt;init&gt;, and ensures that it</span>
<span class="line-added">2517     // returns non-void if and only if it is being invoked by</span>
<span class="line-added">2518     // invokestatic, and void if and only if it is being invoked by</span>
<span class="line-added">2519     // invokespecial.</span>
<span class="line-added">2520     //</span>
<span class="line-added">2521     // When a symbolic reference to &lt;init&gt; is resolved for a</span>
<span class="line-added">2522     // particular invocation mode (special or static), the mode is</span>
<span class="line-added">2523     // matched to the JVM_ACC_STATIC modifier of the &lt;init&gt; method.</span>
<span class="line-added">2524     // Thus, it is impossible to statically invoke a constructor, and</span>
<span class="line-added">2525     // impossible to &quot;new + invokespecial&quot; a static factory, either</span>
<span class="line-added">2526     // through bytecode or through reflection.</span>
2527   }
2528 
2529   int args_size = -1;  // only used when _need_verify is true
2530   if (_need_verify) {
2531     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2532                  verify_legal_method_signature(name, signature, CHECK_NULL);
2533     if (args_size &gt; MAX_ARGS_SIZE) {
2534       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2535     }
2536   }
2537 
2538   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2539 
2540   // Default values for code and exceptions attribute elements
2541   u2 max_stack = 0;
2542   u2 max_locals = 0;
2543   u4 code_length = 0;
2544   const u1* code_start = 0;
2545   u2 exception_table_length = 0;
2546   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
3057       _has_finalizer = true;
3058     }
3059   }
3060   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3061       signature == vmSymbols::void_method_signature() &amp;&amp;
3062       m-&gt;is_vanilla_constructor()) {
3063     _has_vanilla_constructor = true;
3064   }
3065 
3066   NOT_PRODUCT(m-&gt;verify());
3067   return m;
3068 }
3069 
3070 
3071 // The promoted_flags parameter is used to pass relevant access_flags
3072 // from the methods back up to the containing klass. These flag values
3073 // are added to klass&#39;s access_flags.
3074 // Side-effects: populates the _methods field in the parser
3075 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3076                                     bool is_interface,
<span class="line-added">3077                                     bool is_inline_type,</span>
3078                                     AccessFlags* promoted_flags,
3079                                     bool* has_final_method,
3080                                     bool* declares_nonstatic_concrete_methods,
3081                                     TRAPS) {
3082   assert(cfs != NULL, &quot;invariant&quot;);
3083   assert(promoted_flags != NULL, &quot;invariant&quot;);
3084   assert(has_final_method != NULL, &quot;invariant&quot;);
3085   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3086 
3087   assert(NULL == _methods, &quot;invariant&quot;);
3088 
3089   cfs-&gt;guarantee_more(2, CHECK);  // length
3090   const u2 length = cfs-&gt;get_u2_fast();
3091   if (length == 0) {
3092     _methods = Universe::the_empty_method_array();
3093   } else {
3094     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3095                                                    length,
3096                                                    NULL,
3097                                                    CHECK);
3098 
3099     for (int index = 0; index &lt; length; index++) {
3100       Method* method = parse_method(cfs,
3101                                     is_interface,
<span class="line-added">3102                                     is_inline_type,</span>
3103                                     _cp,
3104                                     promoted_flags,
3105                                     CHECK);
3106 
3107       if (method-&gt;is_final()) {
3108         *has_final_method = true;
3109       }
3110       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3111       // used for interface initialization, and default method inheritance analysis
3112       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3113         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3114         *declares_nonstatic_concrete_methods = true;
3115       }
3116       _methods-&gt;at_put(index, method);
3117     }
3118 
3119     if (_need_verify &amp;&amp; length &gt; 1) {
3120       // Check duplicated methods
3121       ResourceMark rm(THREAD);
3122       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3275       valid_klass_reference_at(inner_class_info_index),
3276       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3277       inner_class_info_index, CHECK_0);
3278     // Outer class index
3279     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3280     check_property(
3281       outer_class_info_index == 0 ||
3282         valid_klass_reference_at(outer_class_info_index),
3283       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3284       outer_class_info_index, CHECK_0);
3285     // Inner class name
3286     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3287     check_property(
3288       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3289       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3290       inner_name_index, CHECK_0);
3291     if (_need_verify) {
3292       guarantee_property(inner_class_info_index != outer_class_info_index,
3293                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3294     }
<span class="line-modified">3295 </span>
<span class="line-modified">3296     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;</span>
3297     // JVM_ACC_MODULE is defined in JDK-9 and later.
3298     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3299       recognized_modifiers |= JVM_ACC_MODULE;</span>


3300     }
<span class="line-added">3301     // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">3302     if (supports_inline_types()) {</span>
<span class="line-added">3303       recognized_modifiers |= JVM_ACC_VALUE;</span>
<span class="line-added">3304     }</span>
<span class="line-added">3305 </span>
<span class="line-added">3306     // Access flags</span>
<span class="line-added">3307     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">3308 </span>
3309     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3310       // Set abstract bit for old class files for backward compatibility
3311       flags |= JVM_ACC_ABSTRACT;
3312     }
3313     verify_legal_class_modifiers(flags, CHECK_0);
3314     AccessFlags inner_access_flags(flags);
3315 
3316     inner_classes-&gt;at_put(index++, inner_class_info_index);
3317     inner_classes-&gt;at_put(index++, outer_class_info_index);
3318     inner_classes-&gt;at_put(index++, inner_name_index);
3319     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3320   }
3321 
3322   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3323   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3324     for(int i = 0; i &lt; length * 4; i += 4) {
3325       for(int j = i + 4; j &lt; length * 4; j += 4) {
3326         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3327                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3328                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
4069       }
4070     }
4071     if (runtime_invisible_annotations != NULL) {
4072       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
4073         int append = runtime_visible_annotations_length+i;
4074         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
4075       }
4076     }
4077   }
4078   return annotations;
4079 }
4080 
4081 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
4082                                                         const int super_class_index,
4083                                                         const bool need_verify,
4084                                                         TRAPS) {
4085   assert(cp != NULL, &quot;invariant&quot;);
4086   const InstanceKlass* super_klass = NULL;
4087 
4088   if (super_class_index == 0) {
<span class="line-modified">4089     check_property(_class_name == vmSymbols::java_lang_Object()</span>
<span class="line-added">4090                    || (_access_flags.get_flags() &amp; JVM_ACC_VALUE),</span>
4091                    &quot;Invalid superclass index %u in class file %s&quot;,
4092                    super_class_index,
4093                    CHECK_NULL);
4094   } else {
4095     check_property(valid_klass_reference_at(super_class_index),
4096                    &quot;Invalid superclass index %u in class file %s&quot;,
4097                    super_class_index,
4098                    CHECK_NULL);
4099     // The class name should be legal because it is checked when parsing constant pool.
4100     // However, make sure it is not an array type.
4101     bool is_array = false;
4102     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4103       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4104       if (need_verify)
4105         is_array = super_klass-&gt;is_array_klass();
4106     } else if (need_verify) {
4107       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4108     }
4109     if (need_verify) {
4110       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4250 }
4251 
4252 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4253   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4254   if (_nonstatic_oop_map_count &gt; 0) {
4255     OopMapBlock* map = _nonstatic_oop_maps;
4256     OopMapBlock* last_map = last_oop_map();
4257     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4258     while (map &lt;= last_map) {
4259       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4260                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4261       map++;
4262     }
4263   }
4264 }
4265 
4266 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4267   print_on(st);
4268 }
4269 
<span class="line-added">4270 void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-added">4271                                                 const char* msg,</span>
<span class="line-added">4272                                                 const Symbol* name,</span>
<span class="line-added">4273                                                 const Symbol* sig) const {</span>
<span class="line-added">4274 </span>
<span class="line-added">4275   ResourceMark rm(THREAD);</span>
<span class="line-added">4276   if (name == NULL || sig == NULL) {</span>
<span class="line-added">4277     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4278         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4279         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4280   }</span>
<span class="line-added">4281   else {</span>
<span class="line-added">4282     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4283         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4284         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),</span>
<span class="line-added">4285         _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4286   }</span>
<span class="line-added">4287 }</span>
<span class="line-added">4288 </span>
4289 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4290 void ClassFileParser::layout_fields(ConstantPool* cp,
4291                                     const FieldAllocationCount* fac,
4292                                     const ClassAnnotationCollector* parsed_annotations,
4293                                     FieldLayoutInfo* info,
4294                                     TRAPS) {
4295 
4296   assert(cp != NULL, &quot;invariant&quot;);
4297 
4298   // Field size and offset computation
4299   int nonstatic_field_size = _super_klass == NULL ? 0 :
4300                                _super_klass-&gt;nonstatic_field_size();
<span class="line-added">4301   int next_nonstatic_inline_type_offset = 0;</span>
<span class="line-added">4302   int first_nonstatic_inline_type_offset = 0;</span>
<span class="line-added">4303 </span>
<span class="line-added">4304   // Fields that are inline types are handled differently depending if they are static or not:</span>
<span class="line-added">4305   // - static fields are oops</span>
<span class="line-added">4306   // - non-static fields are embedded</span>
4307 
4308   // Count the contended fields by type.
4309   //
4310   // We ignore static fields, because @Contended is not supported for them.
4311   // The layout code below will also ignore the static fields.
4312   int nonstatic_contended_count = 0;
4313   FieldAllocationCount fac_contended;
4314   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4315     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4316     if (fs.is_contended()) {
4317       fac_contended.count[atype]++;
4318       if (!fs.access_flags().is_static()) {
4319         nonstatic_contended_count++;
4320       }
4321     }
4322   }
4323 
4324 
4325   // Calculate the starting byte offsets
4326   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<span class="line-added">4327   // Inline types in static fields are not embedded, they are handled with oops</span>
4328   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4329                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);</span>
4330   if (fac-&gt;count[STATIC_DOUBLE]) {
4331     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4332   }
4333 
4334   int next_static_word_offset   = next_static_double_offset +
4335                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4336   int next_static_short_offset  = next_static_word_offset +
4337                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4338   int next_static_byte_offset   = next_static_short_offset +
4339                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4340 
4341   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4342                                 nonstatic_field_size * heapOopSize;
4343 
<span class="line-added">4344   // First field of inline types is aligned on a long boundary in order to ease</span>
<span class="line-added">4345   // in-lining of inline types (with header removal) in packed arrays and</span>
<span class="line-added">4346   // flatten inline types</span>
<span class="line-added">4347   int initial_inline_type_padding = 0;</span>
<span class="line-added">4348   if (is_inline_type()) {</span>
<span class="line-added">4349     int old = nonstatic_fields_start;</span>
<span class="line-added">4350     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);</span>
<span class="line-added">4351     initial_inline_type_padding = nonstatic_fields_start - old;</span>
<span class="line-added">4352   }</span>
<span class="line-added">4353 </span>
4354   int next_nonstatic_field_offset = nonstatic_fields_start;
4355 
4356   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4357 
4358   // Class is contended, pad before all the fields
4359   if (is_contended_class) {
4360     next_nonstatic_field_offset += ContendedPaddingWidth;
4361   }
4362 
<span class="line-added">4363   // Temporary inline types restrictions</span>
<span class="line-added">4364   if (is_inline_type()) {</span>
<span class="line-added">4365     if (is_contended_class) {</span>
<span class="line-added">4366       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
<span class="line-added">4367       return;</span>
<span class="line-added">4368     }</span>
<span class="line-added">4369   }</span>
<span class="line-added">4370 </span>
4371   // Compute the non-contended fields count.
4372   // The packing code below relies on these counts to determine if some field
4373   // can be squeezed into the alignment gap. Contended fields are obviously
4374   // exempt from that.
4375   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4376   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4377   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4378   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4379   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4380 
<span class="line-added">4381   int static_inline_type_count = 0;</span>
<span class="line-added">4382   int nonstatic_inline_type_count = 0;</span>
<span class="line-added">4383   int* nonstatic_inline_type_indexes = NULL;</span>
<span class="line-added">4384   Klass** nonstatic_inline_type_klasses = NULL;</span>
<span class="line-added">4385   unsigned int inline_type_oop_map_count = 0;</span>
<span class="line-added">4386   int not_flattened_inline_types = 0;</span>
<span class="line-added">4387   int not_atomic_inline_types = 0;</span>
<span class="line-added">4388 </span>
<span class="line-added">4389   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
<span class="line-added">4390 </span>
<span class="line-added">4391   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-added">4392                                                                max_nonstatic_inline_type);</span>
<span class="line-added">4393   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {</span>
<span class="line-added">4394     nonstatic_inline_type_indexes[i] = -1;</span>
<span class="line-added">4395   }</span>
<span class="line-added">4396   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-added">4397                                                                max_nonstatic_inline_type);</span>
<span class="line-added">4398 </span>
<span class="line-added">4399   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {</span>
<span class="line-added">4400     if (fs.allocation_type() == STATIC_FLATTENABLE) {</span>
<span class="line-added">4401       ResourceMark rm;</span>
<span class="line-added">4402       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">4403         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">4404       }</span>
<span class="line-added">4405       static_inline_type_count++;</span>
<span class="line-added">4406     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {</span>
<span class="line-added">4407       // Pre-resolve the flattenable field and check for inline type circularity issues.</span>
<span class="line-added">4408       ResourceMark rm;</span>
<span class="line-added">4409       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">4410         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">4411       }</span>
<span class="line-added">4412       Klass* klass =</span>
<span class="line-added">4413         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">4414                                                             Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">4415                                                             _protection_domain, true, CHECK);</span>
<span class="line-added">4416       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">4417       if (!klass-&gt;access_flags().is_inline_type()) {</span>
<span class="line-added">4418         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">4419       }</span>
<span class="line-added">4420       ValueKlass* vk = ValueKlass::cast(klass);</span>
<span class="line-added">4421       // Conditions to apply flattening or not should be defined in a single place</span>
<span class="line-added">4422       bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-added">4423                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
<span class="line-added">4424       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();</span>
<span class="line-added">4425       bool too_volatile_to_flatten = fs.access_flags().is_volatile();</span>
<span class="line-added">4426       if (vk-&gt;is_naturally_atomic()) {</span>
<span class="line-added">4427         too_atomic_to_flatten = false;</span>
<span class="line-added">4428         //too_volatile_to_flatten = false; //FIXME</span>
<span class="line-added">4429         // volatile fields are currently never flattened, this could change in the future</span>
<span class="line-added">4430       }</span>
<span class="line-added">4431       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {</span>
<span class="line-added">4432         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();</span>
<span class="line-added">4433         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;</span>
<span class="line-added">4434         nonstatic_inline_type_count++;</span>
<span class="line-added">4435 </span>
<span class="line-added">4436         ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">4437         if (vklass-&gt;contains_oops()) {</span>
<span class="line-added">4438           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">4439         }</span>
<span class="line-added">4440         fs.set_flattened(true);</span>
<span class="line-added">4441         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="line-added">4442           not_atomic_inline_types++;</span>
<span class="line-added">4443         }</span>
<span class="line-added">4444       } else {</span>
<span class="line-added">4445         not_flattened_inline_types++;</span>
<span class="line-added">4446         fs.set_flattened(false);</span>
<span class="line-added">4447       }</span>
<span class="line-added">4448     }</span>
<span class="line-added">4449   }</span>
<span class="line-added">4450 </span>
<span class="line-added">4451   // Adjusting non_static_oop_count to take into account not flattened inline types;</span>
<span class="line-added">4452   nonstatic_oop_count += not_flattened_inline_types;</span>
<span class="line-added">4453 </span>
4454   // Total non-static fields count, including every contended field
4455   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4456                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4457                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];</span>
4458 
4459   const bool super_has_nonstatic_fields =
4460           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4461   const bool has_nonstatic_fields =
4462     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-added">4463   const bool has_nonstatic_value_fields = nonstatic_inline_type_count &gt; 0;</span>
4464 
<span class="line-added">4465   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
<span class="line-added">4466     // There are a number of fixes required throughout the type system and JIT</span>
<span class="line-added">4467     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
<span class="line-added">4468     return;</span>
<span class="line-added">4469   }</span>
4470 
4471   // Prepare list of oops for oop map generation.
4472   //
4473   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4474   // regions. offset[i] is the start of the i-th region, which then has
4475   // count[i] oops following. Before we know how many regions are required,
4476   // we pessimistically allocate the maps to fit all the oops into the
4477   // distinct regions.
<span class="line-modified">4478   //</span>
4479   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">4480   int max_oop_map_count =</span>
<span class="line-added">4481       super_oop_map_count +</span>
<span class="line-added">4482       fac-&gt;count[NONSTATIC_OOP] +</span>
<span class="line-added">4483       inline_type_oop_map_count +</span>
<span class="line-added">4484       not_flattened_inline_types;</span>
4485 
4486   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4487   if (super_oop_map_count &gt; 0) {
4488     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4489                                                     _super_klass-&gt;nonstatic_oop_map_count());
4490   }
4491 
4492   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4493 
4494   bool compact_fields  = true;
4495   bool allocate_oops_first = false;
4496 
4497   int next_nonstatic_oop_offset = 0;
4498   int next_nonstatic_double_offset = 0;
4499 
4500   // Rearrange fields for a given allocation style
4501   if (allocate_oops_first) {
4502     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4503     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4504     next_nonstatic_double_offset = next_nonstatic_oop_offset +
</pre>
<hr />
<pre>
4559   }
4560 
4561   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4562                                      (nonstatic_double_count * BytesPerLong);
4563   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4564                                       (nonstatic_word_count * BytesPerInt);
4565   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4566                                      (nonstatic_short_count * BytesPerShort);
4567   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4568                                        nonstatic_byte_count;
4569 
4570   // let oops jump before padding with this allocation style
4571   if (!allocate_oops_first) {
4572     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4573     if( nonstatic_oop_count &gt; 0 ) {
4574       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4575     }
4576     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4577   }
4578 
<span class="line-added">4579   // Aligning embedded inline types</span>
<span class="line-added">4580   // bug below, the current algorithm to layout embedded inline types always put them at the</span>
<span class="line-added">4581   // end of the layout, which doesn&#39;t match the different allocation policies the VM is</span>
<span class="line-added">4582   // supposed to provide =&gt; FixMe</span>
<span class="line-added">4583   // Note also that the current alignment policy is to make each inline type starting on a</span>
<span class="line-added">4584   // 64 bits boundary. This could be optimized later. For instance, it could be nice to</span>
<span class="line-added">4585   // align inline types according to their most constrained internal type.</span>
<span class="line-added">4586   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-added">4587   int next_inline_type_index = 0;</span>
<span class="line-added">4588 </span>
4589   // Iterate over fields again and compute correct offsets.
4590   // The field allocation type was temporarily stored in the offset slot.
4591   // oop fields are located before non-oop fields (static and non-static).
4592   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4593 
4594     // skip already laid out fields
4595     if (fs.is_offset_set()) continue;
4596 
4597     // contended instance fields are handled below
4598     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4599 
4600     int real_offset = 0;
4601     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4602 
4603     // pack the rest of the fields
4604     switch (atype) {
<span class="line-added">4605       // Inline types in static fields are handled with oops</span>
<span class="line-added">4606       case STATIC_FLATTENABLE:   // Fallthrough</span>
4607       case STATIC_OOP:
4608         real_offset = next_static_oop_offset;
4609         next_static_oop_offset += heapOopSize;
4610         break;
4611       case STATIC_BYTE:
4612         real_offset = next_static_byte_offset;
4613         next_static_byte_offset += 1;
4614         break;
4615       case STATIC_SHORT:
4616         real_offset = next_static_short_offset;
4617         next_static_short_offset += BytesPerShort;
4618         break;
4619       case STATIC_WORD:
4620         real_offset = next_static_word_offset;
4621         next_static_word_offset += BytesPerInt;
4622         break;
4623       case STATIC_DOUBLE:
4624         real_offset = next_static_double_offset;
4625         next_static_double_offset += BytesPerLong;
4626         break;
<span class="line-added">4627       case NONSTATIC_FLATTENABLE:</span>
<span class="line-added">4628         if (fs.is_flattened()) {</span>
<span class="line-added">4629           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];</span>
<span class="line-added">4630           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);</span>
<span class="line-added">4631           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);</span>
<span class="line-added">4632           ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">4633           real_offset = next_nonstatic_inline_type_offset;</span>
<span class="line-added">4634           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-added">4635           // aligning next inline type on a 64 bits boundary</span>
<span class="line-added">4636           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);</span>
<span class="line-added">4637           next_inline_type_index += 1;</span>
<span class="line-added">4638 </span>
<span class="line-added">4639           if (vklass-&gt;contains_oops()) { // add flatten oop maps</span>
<span class="line-added">4640             int diff = real_offset - vklass-&gt;first_field_offset();</span>
<span class="line-added">4641             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">4642             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">4643             while (map &lt; last_map) {</span>
<span class="line-added">4644               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());</span>
<span class="line-added">4645               map++;</span>
<span class="line-added">4646             }</span>
<span class="line-added">4647           }</span>
<span class="line-added">4648           break;</span>
<span class="line-added">4649         } else {</span>
<span class="line-added">4650           // Fall through</span>
<span class="line-added">4651         }</span>
4652       case NONSTATIC_OOP:
4653         if( nonstatic_oop_space_count &gt; 0 ) {
4654           real_offset = nonstatic_oop_space_offset;
4655           nonstatic_oop_space_offset += heapOopSize;
4656           nonstatic_oop_space_count  -= 1;
4657         } else {
4658           real_offset = next_nonstatic_oop_offset;
4659           next_nonstatic_oop_offset += heapOopSize;
4660         }
4661         nonstatic_oop_maps-&gt;add(real_offset, 1);
4662         break;
4663       case NONSTATIC_BYTE:
4664         if( nonstatic_byte_space_count &gt; 0 ) {
4665           real_offset = nonstatic_byte_space_offset;
4666           nonstatic_byte_space_offset += 1;
4667           nonstatic_byte_space_count  -= 1;
4668         } else {
4669           real_offset = next_nonstatic_byte_offset;
4670           next_nonstatic_byte_offset += 1;
4671         }
</pre>
<hr />
<pre>
4750             break;
4751 
4752           case NONSTATIC_SHORT:
4753             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4754             real_offset = next_nonstatic_padded_offset;
4755             next_nonstatic_padded_offset += BytesPerShort;
4756             break;
4757 
4758           case NONSTATIC_WORD:
4759             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4760             real_offset = next_nonstatic_padded_offset;
4761             next_nonstatic_padded_offset += BytesPerInt;
4762             break;
4763 
4764           case NONSTATIC_DOUBLE:
4765             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4766             real_offset = next_nonstatic_padded_offset;
4767             next_nonstatic_padded_offset += BytesPerLong;
4768             break;
4769 
<span class="line-added">4770             // Inline types in static fields are handled with oops</span>
<span class="line-added">4771           case NONSTATIC_FLATTENABLE:</span>
<span class="line-added">4772             throwInlineTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-added">4773                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
<span class="line-added">4774             return;</span>
<span class="line-added">4775 </span>
4776           case NONSTATIC_OOP:
4777             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4778             real_offset = next_nonstatic_padded_offset;
4779             next_nonstatic_padded_offset += heapOopSize;
4780             nonstatic_oop_maps-&gt;add(real_offset, 1);
4781             break;
4782 
4783           default:
4784             ShouldNotReachHere();
4785         }
4786 
4787         if (fs.contended_group() == 0) {
4788           // Contended group defines the equivalence class over the fields:
4789           // the fields within the same contended group are not inter-padded.
4790           // The only exception is default group, which does not incur the
4791           // equivalence, and so requires intra-padding.
4792           next_nonstatic_padded_offset += ContendedPaddingWidth;
4793         }
4794 
4795         fs.set_offset(real_offset);
4796       } // for
4797 
4798       // Start laying out the next group.
4799       // Note that this will effectively pad the last group in the back;
4800       // this is expected to alleviate memory contention effects for
4801       // subclass fields and/or adjacent object.
4802       // If this was the default group, the padding is already in place.
4803       if (current_group != 0) {
4804         next_nonstatic_padded_offset += ContendedPaddingWidth;
4805       }
4806     }
4807 
4808     // handle static fields
4809   }
4810 
4811   // Entire class is contended, pad in the back.
4812   // This helps to alleviate memory contention effects for subclass fields
4813   // and/or adjacent object.
4814   if (is_contended_class) {
<span class="line-added">4815     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);</span>
4816     next_nonstatic_padded_offset += ContendedPaddingWidth;
4817   }
4818 
<span class="line-modified">4819   int notaligned_nonstatic_fields_end;</span>
<span class="line-added">4820   if (nonstatic_inline_type_count != 0) {</span>
<span class="line-added">4821     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;</span>
<span class="line-added">4822   } else {</span>
<span class="line-added">4823     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>
<span class="line-added">4824   }</span>
4825 
<span class="line-modified">4826   int nonstatic_field_sz_align = heapOopSize;</span>
<span class="line-added">4827   if (is_inline_type()) {</span>
<span class="line-added">4828     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {</span>
<span class="line-added">4829       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy</span>
<span class="line-added">4830     }</span>
<span class="line-added">4831   }</span>
<span class="line-added">4832   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);</span>
4833   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4834   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4835 
4836   int static_field_size         = (static_fields_end -
4837                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4838   nonstatic_field_size          = nonstatic_field_size +
4839                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4840 
4841   int instance_size             = align_object_size(instance_end / wordSize);
4842 
4843   assert(instance_size == align_object_size(align_up(
<span class="line-modified">4844          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)</span>
<span class="line-modified">4845          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
<span class="line-added">4846 </span>
4847 
4848   // Invariant: nonstatic_field end/start should only change if there are
4849   // nonstatic fields in the class, or if the class is contended. We compare
4850   // against the non-aligned value, so that end alignment will not fail the
4851   // assert without actually having the fields.
4852   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4853          is_contended_class ||
4854          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4855 
4856   // Number of non-static oop map blocks allocated at end of klass.
4857   nonstatic_oop_maps-&gt;compact();
4858 
4859 #ifndef PRODUCT
<span class="line-modified">4860   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||</span>
<span class="line-added">4861       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_value_fields))) {</span>
4862     print_field_layout(_class_name,
4863           _fields,
4864           cp,
4865           instance_size,
4866           nonstatic_fields_start,
4867           nonstatic_fields_end,
4868           static_fields_end);
<span class="line-added">4869     nonstatic_oop_maps-&gt;print_on(tty);</span>
<span class="line-added">4870     tty-&gt;print(&quot;\n&quot;);</span>
<span class="line-added">4871     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);</span>
<span class="line-added">4872     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);</span>
<span class="line-added">4873     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);</span>
<span class="line-added">4874     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);</span>
<span class="line-added">4875     tty-&gt;print_cr(&quot;---&quot;);</span>
4876   }
4877 
4878 #endif
4879   // Pass back information needed for InstanceKlass creation
4880   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4881   info-&gt;_instance_size = instance_size;
4882   info-&gt;_static_field_size = static_field_size;
4883   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4884   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<span class="line-added">4885 </span>
<span class="line-added">4886   // An inline type is naturally atomic if it has just one field, and</span>
<span class="line-added">4887   // that field is simple enough.</span>
<span class="line-added">4888   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;</span>
<span class="line-added">4889                                 !super_has_nonstatic_fields &amp;&amp;</span>
<span class="line-added">4890                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;</span>
<span class="line-added">4891                                 (not_atomic_inline_types == 0) &amp;&amp;</span>
<span class="line-added">4892                                 (nonstatic_contended_count == 0));</span>
<span class="line-added">4893   // This may be too restrictive, since if all the fields fit in 64</span>
<span class="line-added">4894   // bits we could make the decision to align instances of this class</span>
<span class="line-added">4895   // to 64-bit boundaries, and load and store them as single words.</span>
<span class="line-added">4896   // And on machines which supported larger atomics we could similarly</span>
<span class="line-added">4897   // allow larger values to be atomic, if properly aligned.</span>
4898 }
4899 
4900 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4901   assert(ik != NULL, &quot;invariant&quot;);
4902 
4903   const Klass* const super = ik-&gt;super();
4904 
4905   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4906   // in which case we don&#39;t have to register objects as finalizable
4907   if (!_has_empty_finalizer) {
4908     if (_has_finalizer ||
4909         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4910       ik-&gt;set_has_finalizer();
4911     }
4912   }
4913 
4914 #ifdef ASSERT
4915   bool f = false;
4916   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4917                                            vmSymbols::void_method_signature());
4918   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4919       f = true;
4920   }
4921 
4922   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4923   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4924   // will not work as expected we shouldn&#39;t abort vm in this case
4925   if (!ik-&gt;has_redefined_this_or_super()) {
4926     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4927   }
4928 #endif
4929 
4930   // Check if this klass supports the java.lang.Cloneable interface
4931   if (SystemDictionary::Cloneable_klass_loaded()) {
4932     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
<span class="line-added">4933       if (ik-&gt;is_value()) {</span>
<span class="line-added">4934         Thread *THREAD = Thread::current();</span>
<span class="line-added">4935         throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
<span class="line-added">4936         return;</span>
<span class="line-added">4937       }</span>
4938       ik-&gt;set_is_cloneable();
4939     }
4940   }
4941 
4942   // Check if this klass has a vanilla default constructor
4943   if (super == NULL) {
4944     // java.lang.Object has empty default constructor
4945     ik-&gt;set_has_vanilla_constructor();
4946   } else {
4947     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4948         _has_vanilla_constructor) {
4949       ik-&gt;set_has_vanilla_constructor();
4950     }
4951 #ifdef ASSERT
4952     bool v = false;
4953     if (super-&gt;has_vanilla_constructor()) {
4954       const Method* const constructor =
4955         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4956                        vmSymbols::void_method_signature());
4957       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4958         v = true;
4959       }
4960     }
4961     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4962 #endif
4963   }
4964 
4965   // If it cannot be fast-path allocated, set a bit in the layout helper.
4966   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4967   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4968   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4969       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4970       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4971       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4972     // Forbid fast-path allocation.
4973     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4974     ik-&gt;set_layout_helper(lh);
4975   }
4976 }
4977 
<span class="line-added">4978 bool ClassFileParser::supports_inline_types() const {</span>
<span class="line-added">4979   // Inline types are only supported by class file version 55 and later</span>
<span class="line-added">4980   return _major_version &gt;= JAVA_11_VERSION;</span>
<span class="line-added">4981 }</span>
<span class="line-added">4982 </span>
4983 // utility methods for appending an array with check for duplicates
4984 
4985 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4986                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4987   // iterate over new interfaces
4988   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4989     InstanceKlass* const e = ifs-&gt;at(i);
4990     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4991     // add new interface
4992     result-&gt;append_if_missing(e);
4993   }
4994 }
4995 
4996 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4997                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4998                                                             ClassLoaderData* loader_data,
4999                                                             TRAPS) {
5000   assert(local_ifs != NULL, &quot;invariant&quot;);
5001   assert(loader_data != NULL, &quot;invariant&quot;);
5002 
</pre>
<hr />
<pre>
5006   // Add superclass transitive interfaces size
5007   if (super != NULL) {
5008     super_size = super-&gt;transitive_interfaces()-&gt;length();
5009     max_transitive_size += super_size;
5010   }
5011   // Add local interfaces&#39; super interfaces
5012   const int local_size = local_ifs-&gt;length();
5013   for (int i = 0; i &lt; local_size; i++) {
5014     InstanceKlass* const l = local_ifs-&gt;at(i);
5015     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
5016   }
5017   // Finally add local interfaces
5018   max_transitive_size += local_size;
5019   // Construct array
5020   if (max_transitive_size == 0) {
5021     // no interfaces, use canonicalized array
5022     return Universe::the_empty_instance_klass_array();
5023   } else if (max_transitive_size == super_size) {
5024     // no new local interfaces added, share superklass&#39; transitive interface array
5025     return super-&gt;transitive_interfaces();
<span class="line-modified">5026     // The three lines below are commented to work around bug JDK-8245487</span>
<span class="line-modified">5027 //  } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">5028 //    // only local interfaces added, share local interface array</span>
<span class="line-added">5029 //    return local_ifs;</span>
5030   } else {
5031     ResourceMark rm;
5032     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5033 
5034     // Copy down from superclass
5035     if (super != NULL) {
5036       append_interfaces(result, super-&gt;transitive_interfaces());
5037     }
5038 
5039     // Copy down from local interfaces&#39; superinterfaces
5040     for (int i = 0; i &lt; local_size; i++) {
5041       InstanceKlass* const l = local_ifs-&gt;at(i);
5042       append_interfaces(result, l-&gt;transitive_interfaces());
5043     }
5044     // Finally add local interfaces
5045     append_interfaces(result, local_ifs);
5046 
5047     // length will be less than the max_transitive_size if duplicates were removed
5048     const int length = result-&gt;length();
5049     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
<span class="line-added">5050 </span>
<span class="line-added">5051     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">5052       return Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">5053     }</span>
<span class="line-added">5054 </span>
5055     Array&lt;InstanceKlass*&gt;* const new_result =
5056       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5057     for (int i = 0; i &lt; length; i++) {
5058       InstanceKlass* const e = result-&gt;at(i);
5059       assert(e != NULL, &quot;just checking&quot;);
5060       new_result-&gt;at_put(i, e);
5061     }
5062     return new_result;
5063   }
5064 }
5065 
5066 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5067   assert(this_klass != NULL, &quot;invariant&quot;);
5068   const Klass* const super = this_klass-&gt;super();
5069 
5070   if (super != NULL) {
5071 
5072     // If the loader is not the boot loader then throw an exception if its
5073     // superclass is in package jdk.internal.reflect and its loader is not a
5074     // special reflection class loader
</pre>
<hr />
<pre>
5232     const Method* const m = methods-&gt;at(index);
5233     // if m is static and not the init method, throw a verify error
5234     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
5235       ResourceMark rm(THREAD);
5236       Exceptions::fthrow(
5237         THREAD_AND_LOCATION,
5238         vmSymbols::java_lang_VerifyError(),
5239         &quot;Illegal static method %s in interface %s&quot;,
5240         m-&gt;name()-&gt;as_C_string(),
5241         this_klass-&gt;external_name()
5242       );
5243       return;
5244     }
5245   }
5246 }
5247 
5248 // utility methods for format checking
5249 
5250 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
5251   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-added">5252   const bool is_inline_type = (flags &amp; JVM_ACC_VALUE) != 0;</span>
5253   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-added">5254   assert(supports_inline_types() || !is_inline_type, &quot;JVM_ACC_VALUE should not be set&quot;);</span>
5255   if (is_module) {
5256     ResourceMark rm(THREAD);
5257     Exceptions::fthrow(
5258       THREAD_AND_LOCATION,
5259       vmSymbols::java_lang_NoClassDefFoundError(),
5260       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
5261       _class_name-&gt;as_C_string());
5262     return;
5263   }
5264 
<span class="line-added">5265   if (is_inline_type &amp;&amp; !EnableValhalla) {</span>
<span class="line-added">5266     ResourceMark rm(THREAD);</span>
<span class="line-added">5267     Exceptions::fthrow(</span>
<span class="line-added">5268       THREAD_AND_LOCATION,</span>
<span class="line-added">5269       vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">5270       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,</span>
<span class="line-added">5271       _class_name-&gt;as_C_string()</span>
<span class="line-added">5272     );</span>
<span class="line-added">5273   }</span>
<span class="line-added">5274 </span>
5275   if (!_need_verify) { return; }
5276 
5277   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
5278   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
5279   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
5280   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
5281   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
5282   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5283   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5284   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5285 
5286   if ((is_abstract &amp;&amp; is_final) ||
5287       (is_interface &amp;&amp; !is_abstract) ||
5288       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">5289       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||</span>
<span class="line-added">5290       (is_inline_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
5291     ResourceMark rm(THREAD);
<span class="line-added">5292     const char* class_note = &quot;&quot;;</span>
<span class="line-added">5293     if (is_inline_type)  class_note = &quot; (an inline class)&quot;;</span>
5294     Exceptions::fthrow(
5295       THREAD_AND_LOCATION,
5296       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5297       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,</span>
<span class="line-modified">5298       _class_name-&gt;as_C_string(), class_note, flags</span>
5299     );
5300     return;
5301   }
5302 }
5303 
5304 static bool has_illegal_visibility(jint flags) {
5305   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5306   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5307   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5308 
5309   return ((is_public &amp;&amp; is_protected) ||
5310           (is_public &amp;&amp; is_private) ||
5311           (is_protected &amp;&amp; is_private));
5312 }
5313 
5314 // A legal major_version.minor_version must be one of the following:
5315 //
5316 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5317 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5318 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
5357     if (!Arguments::enable_preview()) {
5358       Exceptions::fthrow(
5359         THREAD_AND_LOCATION,
5360         vmSymbols::java_lang_UnsupportedClassVersionError(),
5361         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5362         class_name-&gt;as_C_string(), major, minor);
5363       return;
5364     }
5365 
5366   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5367     Exceptions::fthrow(
5368         THREAD_AND_LOCATION,
5369         vmSymbols::java_lang_UnsupportedClassVersionError(),
5370         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5371         class_name-&gt;as_C_string(), major, minor);
5372   }
5373 }
5374 
5375 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5376                                                    bool is_interface,
<span class="line-added">5377                                                    bool is_inline_type,</span>
5378                                                    TRAPS) const {
5379   if (!_need_verify) { return; }
5380 
5381   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5382   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5383   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5384   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5385   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5386   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5387   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5388   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5389   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5390 
5391   bool is_illegal = false;
5392 
5393   if (is_interface) {
5394     if (!is_public || !is_static || !is_final || is_private ||
5395         is_protected || is_volatile || is_transient ||
5396         (major_gte_1_5 &amp;&amp; is_enum)) {
5397       is_illegal = true;
5398     }
5399   } else { // not interface
5400     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5401       is_illegal = true;
<span class="line-added">5402     } else {</span>
<span class="line-added">5403       if (is_inline_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
<span class="line-added">5404         is_illegal = true;</span>
<span class="line-added">5405       }</span>
5406     }
5407   }
5408 
5409   if (is_illegal) {
5410     ResourceMark rm(THREAD);
5411     Exceptions::fthrow(
5412       THREAD_AND_LOCATION,
5413       vmSymbols::java_lang_ClassFormatError(),
5414       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5415       _class_name-&gt;as_C_string(), flags);
5416     return;
5417   }
5418 }
5419 
5420 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5421                                                     bool is_interface,
<span class="line-added">5422                                                     bool is_inline_type,</span>
5423                                                     const Symbol* name,
5424                                                     TRAPS) const {
5425   if (!_need_verify) { return; }
5426 
5427   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5428   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5429   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5430   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5431   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5432   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5433   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5434   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5435   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5436   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5437   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5438   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5439   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5440 
5441   bool is_illegal = false;
5442 
<span class="line-added">5443   const char* class_note = &quot;&quot;;</span>
<span class="line-added">5444 </span>
5445   if (is_interface) {
5446     if (major_gte_8) {
5447       // Class file version is JAVA_8_VERSION or later Methods of
5448       // interfaces may set any of the flags except ACC_PROTECTED,
5449       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5450       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5451       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5452           (is_native || is_protected || is_final || is_synchronized) ||
5453           // If a specific method of a class or interface has its
5454           // ACC_ABSTRACT flag set, it must not have any of its
5455           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5456           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5457           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5458           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5459           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5460         is_illegal = true;
5461       }
5462     } else if (major_gte_1_5) {
5463       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5464       if (!is_public || is_private || is_protected || is_static || is_final ||
5465           is_synchronized || is_native || !is_abstract || is_strict) {
5466         is_illegal = true;
5467       }
5468     } else {
5469       // Class file version is pre-JAVA_1_5_VERSION
5470       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5471         is_illegal = true;
5472       }
5473     }
5474   } else { // not interface
5475     if (has_illegal_visibility(flags)) {
5476       is_illegal = true;
5477     } else {
5478       if (is_initializer) {
<span class="line-modified">5479         if (is_final || is_synchronized || is_native ||</span>
5480             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5481           is_illegal = true;
5482         }
<span class="line-added">5483         if (!is_static &amp;&amp; !is_inline_type) {</span>
<span class="line-added">5484           // OK, an object constructor in a regular class</span>
<span class="line-added">5485         } else if (is_static &amp;&amp; is_inline_type) {</span>
<span class="line-added">5486           // OK, a static init factory in an inline class</span>
<span class="line-added">5487         } else {</span>
<span class="line-added">5488           // but no other combinations are allowed</span>
<span class="line-added">5489           is_illegal = true;</span>
<span class="line-added">5490           class_note = (is_inline_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
<span class="line-added">5491         }</span>
5492       } else { // not initializer
<span class="line-modified">5493         if (is_inline_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
<span class="line-modified">5494           is_illegal = true;</span>
<span class="line-modified">5495           class_note = &quot; (an inline class)&quot;;</span>
<span class="line-modified">5496         } else {</span>
<span class="line-added">5497           if (is_abstract) {</span>
<span class="line-added">5498             if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-added">5499                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-added">5500               is_illegal = true;</span>
<span class="line-added">5501             }</span>
5502           }
5503         }
5504       }
5505     }
5506   }
5507 
5508   if (is_illegal) {
5509     ResourceMark rm(THREAD);
5510     Exceptions::fthrow(
5511       THREAD_AND_LOCATION,
5512       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5513       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5514       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, flags);</span>
5515     return;
5516   }
5517 }
5518 
5519 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5520                                         int length,
5521                                         TRAPS) const {
5522   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5523   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5524     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5525   }
5526 }
5527 
5528 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5529 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5530 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5531 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5532 // method.  Because these names have been checked as special cases before
5533 // calling this method in verify_legal_method_name.
5534 //
</pre>
<hr />
<pre>
5652 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5653 // Return a pointer to just past the signature.
5654 // Return NULL if no legal signature is found.
5655 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5656                                                        bool void_ok,
5657                                                        unsigned int length,
5658                                                        TRAPS) const {
5659   unsigned int array_dim = 0;
5660   while (length &gt; 0) {
5661     switch (signature[0]) {
5662     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5663     case JVM_SIGNATURE_BOOLEAN:
5664     case JVM_SIGNATURE_BYTE:
5665     case JVM_SIGNATURE_CHAR:
5666     case JVM_SIGNATURE_SHORT:
5667     case JVM_SIGNATURE_INT:
5668     case JVM_SIGNATURE_FLOAT:
5669     case JVM_SIGNATURE_LONG:
5670     case JVM_SIGNATURE_DOUBLE:
5671       return signature + 1;
<span class="line-modified">5672     case JVM_SIGNATURE_VALUETYPE:</span>
<span class="line-added">5673       // Can&#39;t enable this check until JDK upgrades the bytecode generators</span>
<span class="line-added">5674       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {</span>
<span class="line-added">5675       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;</span>
<span class="line-added">5676       //                                    &quot;in descriptor in class file %s&quot;,</span>
<span class="line-added">5677       //                                    CHECK_0);</span>
<span class="line-added">5678       // }</span>
<span class="line-added">5679       // fall through</span>
<span class="line-added">5680     case JVM_SIGNATURE_CLASS:</span>
<span class="line-added">5681     {</span>
5682       if (_major_version &lt; JAVA_1_5_VERSION) {
5683         // Skip over the class name if one is there
5684         const char* const p = skip_over_field_name(signature + 1, true, --length);
5685 
5686         // The next character better be a semicolon
5687         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5688           return p + 1;
5689         }
5690       }
5691       else {
<span class="line-modified">5692         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;</span>
5693         signature++;
5694         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5695         // Format check signature
5696         if (c != NULL) {
5697           int newlen = c - (char*) signature;
5698           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5699           if (!legal) {
5700             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5701                                   &quot;in descriptor in class file %s&quot;,
5702                                   CHECK_NULL);
5703             return NULL;
5704           }
5705           return signature + newlen + 1;
5706         }
5707       }
5708       return NULL;
5709     }
5710     case JVM_SIGNATURE_ARRAY:
5711       array_dim++;
5712       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5727 
5728 // Checks if name is a legal class name.
5729 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5730   if (!_need_verify || _relax_verify) { return; }
5731 
5732   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5733   char* bytes = (char*)name-&gt;bytes();
5734   unsigned int length = name-&gt;utf8_length();
5735   bool legal = false;
5736 
5737   if (length &gt; 0) {
5738     const char* p;
5739     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5740       p = skip_over_field_signature(bytes, false, length, CHECK);
5741       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5742     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5743       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5744         p = skip_over_field_name(bytes, true, length);
5745         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5746       }
<span class="line-added">5747     } else if (_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS &amp;&amp; bytes[length - 1] == &#39;;&#39; ) {</span>
<span class="line-added">5748       // Support for L...; and Q...; descriptors</span>
<span class="line-added">5749       legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);</span>
5750     } else {
5751       // 4900761: relax the constraints based on JSR202 spec
5752       // Class names may be drawn from the entire Unicode character set.
5753       // Identifiers between &#39;/&#39; must be unqualified names.
5754       // The utf8 string has been verified when parsing cpool entries.
5755       legal = verify_unqualified_name(bytes, length, LegalClass);
5756     }
5757   }
5758   if (!legal) {
5759     ResourceMark rm(THREAD);
5760     assert(_class_name != NULL, &quot;invariant&quot;);
5761     Exceptions::fthrow(
5762       THREAD_AND_LOCATION,
5763       vmSymbols::java_lang_ClassFormatError(),
5764       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5765       _class_name-&gt;as_C_string()
5766     );
5767     return;
5768   }
5769 }
</pre>
<hr />
<pre>
5879   const char* nextp;
5880 
5881   // The first character must be a &#39;(&#39;
5882   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5883     length--;
5884     // Skip over legal field signatures
5885     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5886     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5887       args_size++;
5888       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5889         args_size++;
5890       }
5891       length -= nextp - p;
5892       p = nextp;
5893       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5894     }
5895     // The first non-signature thing better be a &#39;)&#39;
5896     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5897       length--;
5898       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">5899         // All constructor methods must return void</span>
5900         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5901           return args_size;
5902         }
<span class="line-added">5903         // All static init methods must return the current class</span>
<span class="line-added">5904         if ((length &gt;= 3) &amp;&amp; (p[length-1] == JVM_SIGNATURE_ENDCLASS)</span>
<span class="line-added">5905             &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">5906           nextp = skip_over_field_signature(p, true, length, CHECK_0);</span>
<span class="line-added">5907           if (nextp &amp;&amp; ((int)length == (nextp - p))) {</span>
<span class="line-added">5908             // The actual class will be checked against current class</span>
<span class="line-added">5909             // when the method is defined (see parse_method).</span>
<span class="line-added">5910             // A reference to a static init with a bad return type</span>
<span class="line-added">5911             // will load and verify OK, but will fail to link.</span>
<span class="line-added">5912             return args_size;</span>
<span class="line-added">5913           }</span>
<span class="line-added">5914         }</span>
<span class="line-added">5915         // The distinction between static factory methods and</span>
<span class="line-added">5916         // constructors depends on the JVM_ACC_STATIC modifier.</span>
<span class="line-added">5917         // This distinction must be reflected in a void or non-void</span>
<span class="line-added">5918         // return. For declared methods, the check is in parse_method.</span>
5919       } else {
5920         // Now we better just have a return value
5921         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5922         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5923           return args_size;
5924         }
5925       }
5926     }
5927   }
5928   // Report error
5929   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5930   return 0;
5931 }
5932 
5933 int ClassFileParser::static_field_size() const {
5934   assert(_field_info != NULL, &quot;invariant&quot;);
5935   return _field_info-&gt;_static_field_size;
5936 }
5937 
5938 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
6056 
6057 
6058   if (ik-&gt;should_store_fingerprint()) {
6059     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6060   }
6061 
6062   ik-&gt;set_has_passed_fingerprint_check(false);
6063   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6064     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
6065     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
6066     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
6067       // This class matches with a class saved in an AOT library
6068       ik-&gt;set_has_passed_fingerprint_check(true);
6069     } else {
6070       ResourceMark rm;
6071       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
6072                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6073     }
6074   }
6075 
<span class="line-added">6076   if (ik-&gt;is_value()) {</span>
<span class="line-added">6077     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">6078     oop val = ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">6079     vk-&gt;set_default_value(val);</span>
<span class="line-added">6080   }</span>
<span class="line-added">6081 </span>
6082   return ik;
6083 }
6084 
<span class="line-added">6085 // Return true if the specified class is not a valid super class for an inline type.</span>
<span class="line-added">6086 // A valid super class for an inline type is abstract, has no instance fields,</span>
<span class="line-added">6087 // does not implement interface java.lang.IdentityObject (checked elsewhere), has</span>
<span class="line-added">6088 // an empty body-less no-arg constructor, and no synchronized instance methods.</span>
<span class="line-added">6089 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks</span>
<span class="line-added">6090 // are done elsewhere.  The final determination of whether or not a class is an</span>
<span class="line-added">6091 // invalid super type for an inline class is done in fill_instance_klass().</span>
<span class="line-added">6092 bool ClassFileParser::is_invalid_super_for_inline_type() {</span>
<span class="line-added">6093   if (class_name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">6094     return true;</span>
<span class="line-added">6095   }</span>
<span class="line-added">6096   if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {</span>
<span class="line-added">6097     return false;</span>
<span class="line-added">6098   }</span>
<span class="line-added">6099   if (!access_flags().is_abstract() || _has_nonstatic_fields) {</span>
<span class="line-added">6100     return true;</span>
<span class="line-added">6101   } else {</span>
<span class="line-added">6102     // Look at each method</span>
<span class="line-added">6103     for (int x = 0; x &lt; _methods-&gt;length(); x++) {</span>
<span class="line-added">6104       const Method* const method = _methods-&gt;at(x);</span>
<span class="line-added">6105       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {</span>
<span class="line-added">6106         return true;</span>
<span class="line-added">6107 </span>
<span class="line-added">6108       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">6109         if (method-&gt;signature() != vmSymbols::void_method_signature() ||</span>
<span class="line-added">6110             !method-&gt;is_vanilla_constructor()) {</span>
<span class="line-added">6111           return true;</span>
<span class="line-added">6112         }</span>
<span class="line-added">6113       }</span>
<span class="line-added">6114     }</span>
<span class="line-added">6115   }</span>
<span class="line-added">6116   return false;</span>
<span class="line-added">6117 }</span>
<span class="line-added">6118 </span>
6119 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
6120                                           bool changed_by_loadhook,
6121                                           const ClassInstanceInfo&amp; cl_inst_info,
6122                                           TRAPS) {
6123   assert(ik != NULL, &quot;invariant&quot;);
6124 
6125   // Set name and CLD before adding to CLD
6126   ik-&gt;set_class_loader_data(_loader_data);
6127   ik-&gt;set_name(_class_name);
6128 
6129   // Add all classes to our internal class loader list here,
6130   // including classes in the bootstrap (NULL) class loader.
6131   const bool publicize = !is_internal();
6132 
6133   _loader_data-&gt;add_class(ik, publicize);
6134 
6135   set_klass_to_deallocate(ik);
6136 
6137   assert(_field_info != NULL, &quot;invariant&quot;);
6138   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6139   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6140          &quot;sanity&quot;);
6141 
6142   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6143   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6144 
6145   // Fill in information already parsed
6146   ik-&gt;set_should_verify_class(_need_verify);
6147 
6148   // Not yet: supers are done below to support the new subtype-checking fields
6149   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6150   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
<span class="line-added">6151   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {</span>
<span class="line-added">6152     ik-&gt;set_is_naturally_atomic();</span>
<span class="line-added">6153   }</span>
<span class="line-added">6154   if (_is_empty_inline_type) {</span>
<span class="line-added">6155     ik-&gt;set_is_empty_inline_type();</span>
<span class="line-added">6156   }</span>
<span class="line-added">6157 </span>
<span class="line-added">6158   if (this-&gt;_invalid_inline_super) {</span>
<span class="line-added">6159     ik-&gt;set_invalid_inline_super();</span>
<span class="line-added">6160   }</span>
<span class="line-added">6161 </span>
<span class="line-added">6162   if (_has_injected_identityObject) {</span>
<span class="line-added">6163     ik-&gt;set_has_injected_identityObject();</span>
<span class="line-added">6164   }</span>
<span class="line-added">6165 </span>
6166   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">6167   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);</span>
6168 
6169   // this transfers ownership of a lot of arrays from
6170   // the parser onto the InstanceKlass*
6171   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6172 
6173   // can only set dynamic nest-host after static nest information is set
6174   if (cl_inst_info.dynamic_nest_host() != NULL) {
6175     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6176   }
6177 
6178   // note that is not safe to use the fields in the parser from this point on
6179   assert(NULL == _cp, &quot;invariant&quot;);
6180   assert(NULL == _fields, &quot;invariant&quot;);
6181   assert(NULL == _methods, &quot;invariant&quot;);
6182   assert(NULL == _inner_classes, &quot;invariant&quot;);
6183   assert(NULL == _nest_members, &quot;invariant&quot;);
6184   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6185   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6186   assert(NULL == _record_components, &quot;invariant&quot;);
6187 
</pre>
<hr />
<pre>
6197   // has to be changed accordingly.
6198   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6199 
6200   ik-&gt;set_this_class_index(_this_class_index);
6201 
6202   if (_is_hidden || is_unsafe_anonymous()) {
6203     // _this_class_index is a CONSTANT_Class entry that refers to this
6204     // hidden or anonymous class itself. If this class needs to refer to its own
6205     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
6206     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
6207     // not stored in SystemDictionary), _this_class_index cannot be resolved
6208     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6209     // Therefore, we must eagerly resolve _this_class_index now.
6210     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6211   }
6212 
6213   ik-&gt;set_minor_version(_minor_version);
6214   ik-&gt;set_major_version(_major_version);
6215   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6216   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
<span class="line-added">6217   if (_is_declared_atomic) {</span>
<span class="line-added">6218     ik-&gt;set_is_declared_atomic();</span>
<span class="line-added">6219   }</span>
6220 
6221   if (_unsafe_anonymous_host != NULL) {
6222     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6223     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6224   }
6225   if (_is_hidden) {
6226     ik-&gt;set_is_hidden();
6227   }
6228 
6229   // Set PackageEntry for this_klass
6230   oop cl = ik-&gt;class_loader();
6231   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6232   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6233   ik-&gt;set_package(cld, NULL, CHECK);
6234 
6235   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6236   assert(methods != NULL, &quot;invariant&quot;);
6237   const int methods_len = methods-&gt;length();
6238 
6239   check_methods_for_intrinsics(ik, methods);
</pre>
<hr />
<pre>
6309 
6310   assert(_all_mirandas != NULL, &quot;invariant&quot;);
6311 
6312   // Generate any default methods - default methods are public interface methods
6313   // that have a default implementation.  This is new with Java 8.
6314   if (_has_nonstatic_concrete_methods) {
6315     DefaultMethods::generate_default_methods(ik,
6316                                              _all_mirandas,
6317                                              CHECK);
6318   }
6319 
6320   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6321   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6322       !module_entry-&gt;has_default_read_edges()) {
6323     if (!module_entry-&gt;set_has_default_read_edges()) {
6324       // We won a potential race
6325       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6326     }
6327   }
6328 
<span class="line-added">6329   int nfields = ik-&gt;java_fields_count();</span>
<span class="line-added">6330   if (ik-&gt;is_value()) nfields++;</span>
<span class="line-added">6331   for (int i = 0; i &lt; nfields; i++) {</span>
<span class="line-added">6332     if (ik-&gt;field_is_flattenable(i)) {</span>
<span class="line-added">6333       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);</span>
<span class="line-added">6334       // Inline classes for instance fields must have been pre-loaded</span>
<span class="line-added">6335       // Inline classes for static fields might not have been loaded yet</span>
<span class="line-added">6336       Klass* klass = SystemDictionary::find(klass_name,</span>
<span class="line-added">6337           Handle(THREAD, ik-&gt;class_loader()),</span>
<span class="line-added">6338           Handle(THREAD, ik-&gt;protection_domain()), CHECK);</span>
<span class="line-added">6339       if (klass != NULL) {</span>
<span class="line-added">6340         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-added">6341         ik-&gt;set_value_field_klass(i, klass);</span>
<span class="line-added">6342       }</span>
<span class="line-added">6343       klass_name-&gt;decrement_refcount();</span>
<span class="line-added">6344     } else</span>
<span class="line-added">6345       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
<span class="line-added">6346         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {</span>
<span class="line-added">6347       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));</span>
<span class="line-added">6348     }</span>
<span class="line-added">6349   }</span>
<span class="line-added">6350 </span>
<span class="line-added">6351   if (is_inline_type()) {</span>
<span class="line-added">6352     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">6353     if (UseNewFieldLayout) {</span>
<span class="line-added">6354       vk-&gt;set_alignment(_alignment);</span>
<span class="line-added">6355       vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="line-added">6356       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>
<span class="line-added">6357     } else {</span>
<span class="line-added">6358       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());</span>
<span class="line-added">6359     }</span>
<span class="line-added">6360     ValueKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">6361   }</span>
<span class="line-added">6362 </span>
6363   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6364 
6365   if (!is_internal()) {
6366     if (log_is_enabled(Info, class, load)) {
6367       ResourceMark rm;
6368       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6369       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6370     }
6371 
6372     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
6373         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
6374         log_is_enabled(Info, class, preview)) {
6375       ResourceMark rm;
6376       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
6377                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
6378     }
6379 
6380     if (log_is_enabled(Debug, class, resolve))  {
6381       ResourceMark rm;
6382       // print out the superclass.
</pre>
<hr />
<pre>
6392         const int length = local_interfaces-&gt;length();
6393         for (int i = 0; i &lt; length; i++) {
6394           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6395           const char * to = k-&gt;external_name();
6396           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6397         }
6398       }
6399     }
6400   }
6401 
6402   JFR_ONLY(INIT_ID(ik);)
6403 
6404   // If we reach here, all is well.
6405   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6406   // in order for it to not be destroyed in the ClassFileParser destructor.
6407   set_klass_to_deallocate(NULL);
6408 
6409   // it&#39;s official
6410   set_klass(ik);
6411 
<span class="line-added">6412   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">6413     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);</span>
<span class="line-added">6414   }</span>
<span class="line-added">6415 </span>
6416   debug_only(ik-&gt;verify();)
6417 }
6418 
6419 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6420   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6421   _class_name-&gt;decrement_refcount();
6422 
6423   _class_name = new_class_name;
6424   // Increment the refcount of the new name.
6425   // Now the ClassFileParser owns this name and will decrement in
6426   // the destructor.
6427   _class_name-&gt;increment_refcount();
6428 }
6429 
6430 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6431 // package by prepending its host class&#39;s package name to its class name and setting
6432 // its _class_name field.
6433 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6434   ResourceMark rm(THREAD);
6435   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
</pre>
<hr />
<pre>
6497                                  TRAPS) :
6498   _stream(stream),
6499   _class_name(NULL),
6500   _loader_data(loader_data),
6501   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6502   _cp_patches(cl_info-&gt;cp_patches()),
6503   _is_hidden(cl_info-&gt;is_hidden()),
6504   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6505   _num_patched_klasses(0),
6506   _max_num_patched_klasses(0),
6507   _orig_cp_size(0),
6508   _first_patched_klass_resolved_index(0),
6509   _super_klass(),
6510   _cp(NULL),
6511   _fields(NULL),
6512   _methods(NULL),
6513   _inner_classes(NULL),
6514   _nest_members(NULL),
6515   _nest_host(0),
6516   _record_components(NULL),
<span class="line-added">6517   _temp_local_interfaces(NULL),</span>
6518   _local_interfaces(NULL),
6519   _transitive_interfaces(NULL),
6520   _combined_annotations(NULL),
6521   _class_annotations(NULL),
6522   _class_type_annotations(NULL),
6523   _fields_annotations(NULL),
6524   _fields_type_annotations(NULL),
6525   _klass(NULL),
6526   _klass_to_deallocate(NULL),
6527   _parsed_annotations(NULL),
6528   _fac(NULL),
6529   _field_info(NULL),
6530   _method_ordering(NULL),
6531   _all_mirandas(NULL),
6532   _vtable_size(0),
6533   _itable_size(0),
6534   _num_miranda_methods(0),
6535   _rt(REF_NONE),
6536   _protection_domain(cl_info-&gt;protection_domain()),
6537   _access_flags(),
6538   _pub_level(pub_level),
6539   _bad_constant_seen(0),
6540   _synthetic_flag(false),
6541   _sde_length(false),
6542   _sde_buffer(NULL),
6543   _sourcefile_index(0),
6544   _generic_signature_index(0),
6545   _major_version(0),
6546   _minor_version(0),
6547   _this_class_index(0),
6548   _super_class_index(0),
6549   _itfs_len(0),
6550   _java_fields_count(0),
6551   _need_verify(false),
6552   _relax_verify(false),
6553   _has_nonstatic_concrete_methods(false),
6554   _declares_nonstatic_concrete_methods(false),
6555   _has_final_method(false),
6556   _has_contended_fields(false),
<span class="line-added">6557   _has_flattenable_fields(false),</span>
<span class="line-added">6558   _has_nonstatic_fields(false),</span>
<span class="line-added">6559   _is_empty_inline_type(false),</span>
<span class="line-added">6560   _is_naturally_atomic(false),</span>
<span class="line-added">6561   _is_declared_atomic(false),</span>
<span class="line-added">6562   _invalid_inline_super(false),</span>
<span class="line-added">6563   _invalid_identity_super(false),</span>
<span class="line-added">6564   _implements_identityObject(false),</span>
<span class="line-added">6565   _has_injected_identityObject(false),</span>
6566   _has_finalizer(false),
6567   _has_empty_finalizer(false),
6568   _has_vanilla_constructor(false),
6569   _max_bootstrap_specifier_index(-1) {
6570 
6571   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6572   _class_name-&gt;increment_refcount();
6573 
6574   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6575   assert(_loader_data != NULL, &quot;invariant&quot;);
6576   assert(stream != NULL, &quot;invariant&quot;);
6577   assert(_stream != NULL, &quot;invariant&quot;);
6578   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6579   assert(_class_name != NULL, &quot;invariant&quot;);
6580   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6581 
6582   // Figure out whether we can skip format checking (matching classic VM behavior)
6583   if (DumpSharedSpaces) {
6584     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6585     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6751   } else {
6752     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6753       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6754     }
6755     cp_size += _max_num_patched_klasses;
6756   }
6757 
6758   _cp = ConstantPool::allocate(_loader_data,
6759                                cp_size,
6760                                CHECK);
6761 
6762   ConstantPool* const cp = _cp;
6763 
6764   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6765 
6766   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6767 
6768   // ACCESS FLAGS
6769   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6770 
<span class="line-modified">6771   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;</span>

6772   // JVM_ACC_MODULE is defined in JDK-9 and later.
6773   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6774     recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">6775   }</span>
<span class="line-modified">6776   // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">6777   if (supports_inline_types()) {</span>
<span class="line-added">6778     recognized_modifiers |= JVM_ACC_VALUE;</span>
6779   }
6780 
<span class="line-added">6781   // Access flags</span>
<span class="line-added">6782   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">6783 </span>
6784   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6785     // Set abstract bit for old class files for backward compatibility
6786     flags |= JVM_ACC_ABSTRACT;
6787   }
6788 
6789   verify_legal_class_modifiers(flags, CHECK);
6790 
6791   short bad_constant = class_bad_constant_seen();
6792   if (bad_constant != 0) {
6793     // Do not throw CFE until after the access_flags are checked because if
6794     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6795     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6796   }
6797 
6798   _access_flags.set_flags(flags);
6799 
6800   // This class and superclass
6801   _this_class_index = stream-&gt;get_u2_fast();
6802   check_property(
6803     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
6921           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6922           classlist_file-&gt;flush();
6923         }
6924       }
6925     }
6926 #endif
6927   }
6928 
6929   // SUPERKLASS
6930   _super_class_index = stream-&gt;get_u2_fast();
6931   _super_klass = parse_super_class(cp,
6932                                    _super_class_index,
6933                                    _need_verify,
6934                                    CHECK);
6935 
6936   // Interfaces
6937   _itfs_len = stream-&gt;get_u2_fast();
6938   parse_interfaces(stream,
6939                    _itfs_len,
6940                    cp,
<span class="line-added">6941                    is_inline_type(),</span>
6942                    &amp;_has_nonstatic_concrete_methods,
<span class="line-added">6943                    &amp;_is_declared_atomic,</span>
6944                    CHECK);
6945 
<span class="line-modified">6946   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);</span>
6947 
6948   // Fields (offsets are filled in later)
6949   _fac = new FieldAllocationCount();
6950   parse_fields(stream,
<span class="line-modified">6951                is_interface(),</span>
<span class="line-added">6952                is_inline_type(),</span>
6953                _fac,
6954                cp,
6955                cp_size,
6956                &amp;_java_fields_count,
6957                CHECK);
6958 
6959   assert(_fields != NULL, &quot;invariant&quot;);
6960 
6961   // Methods
6962   AccessFlags promoted_flags;
6963   parse_methods(stream,
<span class="line-modified">6964                 is_interface(),</span>
<span class="line-added">6965                 is_inline_type(),</span>
6966                 &amp;promoted_flags,
6967                 &amp;_has_final_method,
6968                 &amp;_declares_nonstatic_concrete_methods,
6969                 CHECK);
6970 
6971   assert(_methods != NULL, &quot;invariant&quot;);
6972 
6973   // promote flags from parse_methods() to the klass&#39; flags
6974   _access_flags.add_promoted_flags(promoted_flags.as_int());
6975 
6976   if (_declares_nonstatic_concrete_methods) {
6977     _has_nonstatic_concrete_methods = true;
6978   }
6979 
6980   // Additional attributes/annotations
6981   _parsed_annotations = new ClassAnnotationCollector();
6982   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6983 
6984   assert(_inner_classes != NULL, &quot;invariant&quot;);
6985 
</pre>
<hr />
<pre>
7016 
7017   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
7018   // We have to update the resolved_klass_index and the name_index together
7019   // so extract the existing resolved_klass_index first.
7020   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
7021   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
7022   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
7023   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
7024          &quot;Bad name_index&quot;);
7025 }
7026 
7027 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
7028                                                  ConstantPool* cp,
7029                                                  TRAPS) {
7030   assert(stream != NULL, &quot;invariant&quot;);
7031   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
7032   assert(cp != NULL, &quot;invariant&quot;);
7033   assert(_loader_data != NULL, &quot;invariant&quot;);
7034 
7035   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">7036     check_property(_temp_local_interfaces-&gt;length() == 0,</span>
<span class="line-modified">7037         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">7038         CHECK);</span>
7039   }
7040   // We check super class after class file is parsed and format is checked
7041   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
7042     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">7043     if (is_interface()) {</span>
7044       // Before attempting to resolve the superclass, check for class format
7045       // errors not checked yet.
7046       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
7047         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
7048         CHECK);
7049     }
7050     Handle loader(THREAD, _loader_data-&gt;class_loader());
7051     _super_klass = (const InstanceKlass*)
7052                        SystemDictionary::resolve_super_or_fail(_class_name,
7053                                                                super_class_name,
7054                                                                loader,
7055                                                                _protection_domain,
7056                                                                true,
7057                                                                CHECK);
7058   }
7059 
7060   if (_super_klass != NULL) {
7061     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
7062       _has_nonstatic_concrete_methods = true;
7063     }
<span class="line-added">7064     if (_super_klass-&gt;is_declared_atomic()) {</span>
<span class="line-added">7065       _is_declared_atomic = true;</span>
<span class="line-added">7066     }</span>
7067 
7068     if (_super_klass-&gt;is_interface()) {
7069       ResourceMark rm(THREAD);
7070       Exceptions::fthrow(
7071         THREAD_AND_LOCATION,
7072         vmSymbols::java_lang_IncompatibleClassChangeError(),
7073         &quot;class %s has interface %s as super class&quot;,
7074         _class_name-&gt;as_klass_external_name(),
7075         _super_klass-&gt;external_name()
7076       );
7077       return;
7078     }
<span class="line-added">7079 </span>
7080     // Make sure super class is not final
7081     if (_super_klass-&gt;is_final()) {
7082       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
7083     }
<span class="line-added">7084 </span>
<span class="line-added">7085     // For an inline class, only java/lang/Object or special abstract classes</span>
<span class="line-added">7086     // are acceptable super classes.</span>
<span class="line-added">7087     if (is_inline_type()) {</span>
<span class="line-added">7088       const InstanceKlass* super_ik = _super_klass;</span>
<span class="line-added">7089       if (super_ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">7090         ResourceMark rm(THREAD);</span>
<span class="line-added">7091         Exceptions::fthrow(</span>
<span class="line-added">7092           THREAD_AND_LOCATION,</span>
<span class="line-added">7093           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">7094           &quot;inline class %s has an invalid super class %s&quot;,</span>
<span class="line-added">7095           _class_name-&gt;as_klass_external_name(),</span>
<span class="line-added">7096           _super_klass-&gt;external_name());</span>
<span class="line-added">7097         return;</span>
<span class="line-added">7098       }</span>
<span class="line-added">7099     }</span>
<span class="line-added">7100   }</span>
<span class="line-added">7101 </span>
<span class="line-added">7102   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {</span>
<span class="line-added">7103     // This is the original source of this condition.</span>
<span class="line-added">7104     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.</span>
<span class="line-added">7105     _is_declared_atomic = true;</span>
<span class="line-added">7106   } else if (*ForceNonTearable != &#39;\0&#39;) {</span>
<span class="line-added">7107     // Allow a command line switch to force the same atomicity property:</span>
<span class="line-added">7108     const char* class_name_str = _class_name-&gt;as_C_string();</span>
<span class="line-added">7109     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {</span>
<span class="line-added">7110       _is_declared_atomic = true;</span>
<span class="line-added">7111     }</span>
<span class="line-added">7112   }</span>
<span class="line-added">7113 </span>
<span class="line-added">7114   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,</span>
<span class="line-added">7115   // if super is marked invalid, or if is_invalid_super_for_inline_type()</span>
<span class="line-added">7116   // returns true</span>
<span class="line-added">7117   if (invalid_inline_super() ||</span>
<span class="line-added">7118       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||</span>
<span class="line-added">7119       is_invalid_super_for_inline_type()) {</span>
<span class="line-added">7120     set_invalid_inline_super();</span>
<span class="line-added">7121   }</span>
<span class="line-added">7122 </span>
<span class="line-added">7123   if (!is_inline_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
<span class="line-added">7124       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">7125     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());</span>
<span class="line-added">7126     _has_injected_identityObject = true;</span>
<span class="line-added">7127   }</span>
<span class="line-added">7128   int itfs_len = _temp_local_interfaces-&gt;length();</span>
<span class="line-added">7129   if (itfs_len == 0) {</span>
<span class="line-added">7130     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
<span class="line-added">7131   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">7132     _local_interfaces = Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">7133   } else {</span>
<span class="line-added">7134     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-added">7135     for (int i = 0; i &lt; itfs_len; i++) {</span>
<span class="line-added">7136       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));</span>
<span class="line-added">7137     }</span>
7138   }
<span class="line-added">7139   _temp_local_interfaces = NULL;</span>
<span class="line-added">7140   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
7141 
7142   // Compute the transitive list of all unique interfaces implemented by this class
7143   _transitive_interfaces =
7144     compute_transitive_interfaces(_super_klass,
7145                                   _local_interfaces,
7146                                   _loader_data,
7147                                   CHECK);
7148 
7149   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7150 
7151   // sort methods
7152   _method_ordering = sort_methods(_methods);
7153 
7154   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7155 
7156   Handle loader(THREAD, _loader_data-&gt;class_loader());
7157   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7158                                                     &amp;_num_miranda_methods,
7159                                                     _all_mirandas,
7160                                                     _super_klass,
7161                                                     _methods,
7162                                                     _access_flags,
7163                                                     _major_version,
7164                                                     loader,
7165                                                     _class_name,
7166                                                     _local_interfaces,
7167                                                     CHECK);
7168 
7169   // Size of Java itable (in words)
<span class="line-modified">7170   _itable_size = is_interface() ? 0 :</span>
7171     klassItable::compute_itable_size(_transitive_interfaces);
7172 
7173   assert(_fac != NULL, &quot;invariant&quot;);
7174   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7175 
<span class="line-added">7176 </span>
<span class="line-added">7177   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-added">7178     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {</span>
<span class="line-added">7179       // Pre-load value class</span>
<span class="line-added">7180       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">7181           Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">7182           _protection_domain, true, CHECK);</span>
<span class="line-added">7183       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">7184       assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-added">7185       _has_flattenable_fields = true;</span>
<span class="line-added">7186     }</span>
<span class="line-added">7187   }</span>
<span class="line-added">7188 </span>
7189   _field_info = new FieldLayoutInfo();
7190   if (UseNewFieldLayout) {
7191     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">7192         _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
<span class="line-modified">7193         loader_data(), _protection_domain, _field_info);</span>
<span class="line-added">7194     lb.build_layout(CHECK);</span>
<span class="line-added">7195     if (is_inline_type()) {</span>
<span class="line-added">7196       _alignment = lb.get_alignment();</span>
<span class="line-added">7197       _first_field_offset = lb.get_first_field_offset();</span>
<span class="line-added">7198       _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>
<span class="line-added">7199     }</span>
7200   } else {
7201     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7202   }
7203 
<span class="line-modified">7204   // Compute reference type</span>
7205   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();

7206 }
7207 
7208 void ClassFileParser::set_klass(InstanceKlass* klass) {
7209 
7210 #ifdef ASSERT
7211   if (klass != NULL) {
7212     assert(NULL == _klass, &quot;leaking?&quot;);
7213   }
7214 #endif
7215 
7216   _klass = klass;
7217 }
7218 
7219 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
7220 
7221 #ifdef ASSERT
7222   if (klass != NULL) {
7223     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
7224   }
7225 #endif
7226 
7227   _klass_to_deallocate = klass;
7228 }
7229 
7230 // Caller responsible for ResourceMark
7231 // clone stream with rewound position
7232 const ClassFileStream* ClassFileParser::clone_stream() const {
7233   assert(_stream != NULL, &quot;invariant&quot;);
7234 
7235   return _stream-&gt;clone();
7236 }
<span class="line-added">7237 </span>
7238 // ----------------------------------------------------------------------------
7239 // debugging
7240 
7241 #ifdef ASSERT
7242 
7243 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
7244 bool ClassFileParser::is_internal_format(Symbol* class_name) {
7245   if (class_name != NULL) {
7246     ResourceMark rm;
7247     char* name = class_name-&gt;as_C_string();
7248     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
7249   } else {
7250     return true;
7251   }
7252 }
7253 
7254 #endif
</pre>
</td>
</tr>
</table>
<center><a href="bytecodeAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
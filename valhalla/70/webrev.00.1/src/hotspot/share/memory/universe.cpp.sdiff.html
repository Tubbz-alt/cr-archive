<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/universe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oopFactory.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/access.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/universe.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  99 #define DEFINE_PRIMITIVE_MIRROR(m) \
 100     oop Universe::m  = NULL;
 101 
 102 // Known objects
 103 PRIMITIVE_MIRRORS_DO(DEFINE_PRIMITIVE_MIRROR)
 104 Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
 105 Klass* Universe::_objectArrayKlassObj                 = NULL;
 106 oop Universe::_mirrors[T_VOID+1]                      = { NULL /*, NULL...*/ };
 107 oop Universe::_main_thread_group                      = NULL;
 108 oop Universe::_system_thread_group                    = NULL;
 109 objArrayOop Universe::_the_empty_class_klass_array    = NULL;
 110 Array&lt;Klass*&gt;* Universe::_the_array_interfaces_array = NULL;
 111 oop Universe::_the_null_sentinel                      = NULL;
 112 oop Universe::_the_null_string                        = NULL;
 113 oop Universe::_the_min_jint_string                   = NULL;
 114 LatestMethodCache* Universe::_finalizer_register_cache = NULL;
 115 LatestMethodCache* Universe::_loader_addClass_cache    = NULL;
 116 LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;
 117 LatestMethodCache* Universe::_throw_no_such_method_error_cache = NULL;
 118 LatestMethodCache* Universe::_do_stack_walk_cache     = NULL;

 119 oop Universe::_out_of_memory_error_java_heap          = NULL;
 120 oop Universe::_out_of_memory_error_metaspace          = NULL;
 121 oop Universe::_out_of_memory_error_class_metaspace    = NULL;
 122 oop Universe::_out_of_memory_error_array_size         = NULL;
 123 oop Universe::_out_of_memory_error_gc_overhead_limit  = NULL;
 124 oop Universe::_out_of_memory_error_realloc_objects    = NULL;
 125 oop Universe::_out_of_memory_error_retry              = NULL;
 126 oop Universe::_delayed_stack_overflow_error_message   = NULL;
 127 objArrayOop Universe::_preallocated_out_of_memory_error_array = NULL;
 128 volatile jint Universe::_preallocated_out_of_memory_error_avail_count = 0;
 129 bool Universe::_verify_in_progress                    = false;
 130 long Universe::verify_flags                           = Universe::Verify_All;
 131 oop Universe::_null_ptr_exception_instance            = NULL;
 132 oop Universe::_arithmetic_exception_instance          = NULL;
 133 oop Universe::_virtual_machine_error_instance         = NULL;
 134 oop Universe::_vm_exception                           = NULL;
 135 oop Universe::_reference_pending_list                 = NULL;
 136 
 137 Array&lt;int&gt;* Universe::_the_empty_int_array            = NULL;
 138 Array&lt;u2&gt;* Universe::_the_empty_short_array           = NULL;
 139 Array&lt;Klass*&gt;* Universe::_the_empty_klass_array     = NULL;
 140 Array&lt;InstanceKlass*&gt;* Universe::_the_empty_instance_klass_array  = NULL;

 141 Array&lt;Method*&gt;* Universe::_the_empty_method_array   = NULL;
 142 
 143 // These variables are guarded by FullGCALot_lock.
 144 debug_only(objArrayOop Universe::_fullgc_alot_dummy_array = NULL;)
 145 debug_only(int Universe::_fullgc_alot_dummy_next      = 0;)
 146 
 147 // Heap
 148 int             Universe::_verify_count = 0;
 149 
 150 // Oop verification (see MacroAssembler::verify_oop)
 151 uintptr_t       Universe::_verify_oop_mask = 0;
 152 uintptr_t       Universe::_verify_oop_bits = (uintptr_t) -1;
 153 
 154 int             Universe::_base_vtable_size = 0;
 155 bool            Universe::_bootstrapping = false;
 156 bool            Universe::_module_initialized = false;
 157 bool            Universe::_fully_initialized = false;
 158 
 159 size_t          Universe::_heap_capacity_at_last_gc;
 160 size_t          Universe::_heap_used_at_last_gc = 0;
</pre>
<hr />
<pre>
 207   debug_only(f-&gt;do_oop((oop*)&amp;_fullgc_alot_dummy_array);)
 208   ThreadsSMRSupport::exiting_threads_oops_do(f);
 209 }
 210 
 211 void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {
 212   it-&gt;push(&amp;_klass);
 213 }
 214 
 215 void Universe::metaspace_pointers_do(MetaspaceClosure* it) {
 216   for (int i = 0; i &lt; T_LONG+1; i++) {
 217     it-&gt;push(&amp;_typeArrayKlassObjs[i]);
 218   }
 219   it-&gt;push(&amp;_objectArrayKlassObj);
 220 
 221   it-&gt;push(&amp;_the_empty_int_array);
 222   it-&gt;push(&amp;_the_empty_short_array);
 223   it-&gt;push(&amp;_the_empty_klass_array);
 224   it-&gt;push(&amp;_the_empty_instance_klass_array);
 225   it-&gt;push(&amp;_the_empty_method_array);
 226   it-&gt;push(&amp;_the_array_interfaces_array);

 227 
 228   _finalizer_register_cache-&gt;metaspace_pointers_do(it);
 229   _loader_addClass_cache-&gt;metaspace_pointers_do(it);
 230   _throw_illegal_access_error_cache-&gt;metaspace_pointers_do(it);
 231   _throw_no_such_method_error_cache-&gt;metaspace_pointers_do(it);
 232   _do_stack_walk_cache-&gt;metaspace_pointers_do(it);

 233 }
 234 
 235 #define ASSERT_MIRROR_NULL(m) \
 236   assert(m == NULL, &quot;archived mirrors should be NULL&quot;);
 237 
 238 #define SERIALIZE_MIRROR(m) \
 239   f-&gt;do_oop(&amp;m); \
 240   if (m != NULL) { java_lang_Class::update_archived_primitive_mirror_native_pointers(m); }
 241 
 242 // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
 243 void Universe::serialize(SerializeClosure* f) {
 244 
 245   for (int i = 0; i &lt; T_LONG+1; i++) {
 246     f-&gt;do_ptr((void**)&amp;_typeArrayKlassObjs[i]);
 247   }
 248 
 249   f-&gt;do_ptr((void**)&amp;_objectArrayKlassObj);
 250 
 251 #if INCLUDE_CDS_JAVA_HEAP
 252   DEBUG_ONLY(if (DumpSharedSpaces &amp;&amp; !HeapShared::is_heap_object_archiving_allowed()) {
 253       PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NULL);
 254     });
 255   PRIMITIVE_MIRRORS_DO(SERIALIZE_MIRROR);
 256 #endif
 257 
 258   f-&gt;do_ptr((void**)&amp;_the_array_interfaces_array);
 259   f-&gt;do_ptr((void**)&amp;_the_empty_int_array);
 260   f-&gt;do_ptr((void**)&amp;_the_empty_short_array);
 261   f-&gt;do_ptr((void**)&amp;_the_empty_method_array);
 262   f-&gt;do_ptr((void**)&amp;_the_empty_klass_array);
 263   f-&gt;do_ptr((void**)&amp;_the_empty_instance_klass_array);

 264   _finalizer_register_cache-&gt;serialize(f);
 265   _loader_addClass_cache-&gt;serialize(f);
 266   _throw_illegal_access_error_cache-&gt;serialize(f);
 267   _throw_no_such_method_error_cache-&gt;serialize(f);
 268   _do_stack_walk_cache-&gt;serialize(f);

 269 }
 270 
 271 void Universe::check_alignment(uintx size, uintx alignment, const char* name) {
 272   if (size &lt; alignment || size % alignment != 0) {
 273     vm_exit_during_initialization(
 274       err_msg(&quot;Size of %s (&quot; UINTX_FORMAT &quot; bytes) must be aligned to &quot; UINTX_FORMAT &quot; bytes&quot;, name, size, alignment));
 275   }
 276 }
 277 
 278 void initialize_basic_type_klass(Klass* k, TRAPS) {
 279   Klass* ok = SystemDictionary::Object_klass();
 280 #if INCLUDE_CDS
 281   if (UseSharedSpaces) {
 282     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 283     assert(k-&gt;super() == ok, &quot;u3&quot;);
 284     if (k-&gt;is_instance_klass()) {
 285       InstanceKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), NULL, CHECK);
 286     } else {
 287       ArrayKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), CHECK);
 288     }
</pre>
<hr />
<pre>
 296 
 297 void Universe::genesis(TRAPS) {
 298   ResourceMark rm(THREAD);
 299 
 300   { FlagSetting fs(_bootstrapping, true);
 301 
 302     { MutexLocker mc(THREAD, Compile_lock);
 303 
 304       java_lang_Class::allocate_fixup_lists();
 305 
 306       // determine base vtable size; without that we cannot create the array klasses
 307       compute_base_vtable_size();
 308 
 309       if (!UseSharedSpaces) {
 310         for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 311           _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);
 312         }
 313 
 314         ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
 315 
<span class="line-modified"> 316         _the_array_interfaces_array     = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 2, NULL, CHECK);</span>
 317         _the_empty_int_array            = MetadataFactory::new_array&lt;int&gt;(null_cld, 0, CHECK);
 318         _the_empty_short_array          = MetadataFactory::new_array&lt;u2&gt;(null_cld, 0, CHECK);
 319         _the_empty_method_array         = MetadataFactory::new_array&lt;Method*&gt;(null_cld, 0, CHECK);
 320         _the_empty_klass_array          = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 0, CHECK);
 321         _the_empty_instance_klass_array = MetadataFactory::new_array&lt;InstanceKlass*&gt;(null_cld, 0, CHECK);
 322       }
 323     }
 324 
 325     vmSymbols::initialize(CHECK);
 326 
 327     SystemDictionary::initialize(CHECK);
 328 
 329     Klass* ok = SystemDictionary::Object_klass();
 330 
 331     _the_null_string            = StringTable::intern(&quot;null&quot;, CHECK);
 332     _the_min_jint_string       = StringTable::intern(&quot;-2147483648&quot;, CHECK);
 333 
 334 #if INCLUDE_CDS
 335     if (UseSharedSpaces) {
 336       // Verify shared interfaces array.
 337       assert(_the_array_interfaces_array-&gt;at(0) ==
 338              SystemDictionary::Cloneable_klass(), &quot;u3&quot;);
 339       assert(_the_array_interfaces_array-&gt;at(1) ==
 340              SystemDictionary::Serializable_klass(), &quot;u3&quot;);





 341     } else
 342 #endif
 343     {
 344       // Set up shared interfaces array.  (Do this before supers are set up.)
 345       _the_array_interfaces_array-&gt;at_put(0, SystemDictionary::Cloneable_klass());
 346       _the_array_interfaces_array-&gt;at_put(1, SystemDictionary::Serializable_klass());

 347     }
 348 
 349     initialize_basic_type_klass(boolArrayKlassObj(), CHECK);
 350     initialize_basic_type_klass(charArrayKlassObj(), CHECK);
 351     initialize_basic_type_klass(floatArrayKlassObj(), CHECK);
 352     initialize_basic_type_klass(doubleArrayKlassObj(), CHECK);
 353     initialize_basic_type_klass(byteArrayKlassObj(), CHECK);
 354     initialize_basic_type_klass(shortArrayKlassObj(), CHECK);
 355     initialize_basic_type_klass(intArrayKlassObj(), CHECK);
 356     initialize_basic_type_klass(longArrayKlassObj(), CHECK);
 357   } // end of core bootstrapping
 358 
 359   {
 360     Handle tns = java_lang_String::create_from_str(&quot;&lt;null_sentinel&gt;&quot;, CHECK);
 361     _the_null_sentinel = tns();
 362   }
 363 
 364   // Maybe this could be lifted up now that object array can be initialized
 365   // during the bootstrapping.
 366 
</pre>
<hr />
<pre>
 448         java_lang_Class::create_basic_type_mirror(&quot;long&quot;,   T_LONG, CHECK);
 449       _short_mirror   =
 450         java_lang_Class::create_basic_type_mirror(&quot;short&quot;,  T_SHORT,   CHECK);
 451       _void_mirror    =
 452         java_lang_Class::create_basic_type_mirror(&quot;void&quot;,   T_VOID, CHECK);
 453     }
 454 
 455     _mirrors[T_INT]     = _int_mirror;
 456     _mirrors[T_FLOAT]   = _float_mirror;
 457     _mirrors[T_DOUBLE]  = _double_mirror;
 458     _mirrors[T_BYTE]    = _byte_mirror;
 459     _mirrors[T_BOOLEAN] = _bool_mirror;
 460     _mirrors[T_CHAR]    = _char_mirror;
 461     _mirrors[T_LONG]    = _long_mirror;
 462     _mirrors[T_SHORT]   = _short_mirror;
 463     _mirrors[T_VOID]    = _void_mirror;
 464   //_mirrors[T_OBJECT]  = _object_klass-&gt;java_mirror();
 465   //_mirrors[T_ARRAY]   = _object_klass-&gt;java_mirror();
 466 }
 467 








 468 void Universe::fixup_mirrors(TRAPS) {
 469   // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,
 470   // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply
 471   // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note
 472   // that the number of objects allocated at this point is very small.
 473   assert(SystemDictionary::Class_klass_loaded(), &quot;java.lang.Class should be loaded&quot;);
 474   HandleMark hm(THREAD);
 475 
 476   if (!UseSharedSpaces) {
 477     // Cache the start of the static fields
 478     InstanceMirrorKlass::init_offset_of_static_fields();
 479   }
 480 
 481   GrowableArray &lt;Klass*&gt;* list = java_lang_Class::fixup_mirror_list();
 482   int list_length = list-&gt;length();
 483   for (int i = 0; i &lt; list_length; i++) {
 484     Klass* k = list-&gt;at(i);
 485     assert(k-&gt;is_klass(), &quot;List should only hold classes&quot;);
 486     EXCEPTION_MARK;
 487     java_lang_Class::fixup_mirror(k, CATCH);
</pre>
<hr />
<pre>
 644   guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord),
 645          &quot;LogHeapWordSize is incorrect.&quot;);
 646   guarantee(sizeof(oop) &gt;= sizeof(HeapWord), &quot;HeapWord larger than oop?&quot;);
 647   guarantee(sizeof(oop) % sizeof(HeapWord) == 0,
 648             &quot;oop size is not not a multiple of HeapWord size&quot;);
 649 
 650   TraceTime timer(&quot;Genesis&quot;, TRACETIME_LOG(Info, startuptime));
 651 
 652   initialize_global_behaviours();
 653 
 654   GCConfig::arguments()-&gt;initialize_heap_sizes();
 655 
 656   jint status = Universe::initialize_heap();
 657   if (status != JNI_OK) {
 658     return status;
 659   }
 660 
 661   Universe::initialize_tlab();
 662 
 663   Metaspace::global_initialize();
<span class="line-removed"> 664 </span>
 665   // Initialize performance counters for metaspaces
 666   MetaspaceCounters::initialize_performance_counters();
 667   CompressedClassSpaceCounters::initialize_performance_counters();
 668 
 669   AOTLoader::universe_init();
 670 
 671   // Checks &#39;AfterMemoryInit&#39; constraints.
 672   if (!JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterMemoryInit)) {
 673     return JNI_EINVAL;
 674   }
 675 
 676   // Create memory for metadata.  Must be after initializing heap for
 677   // DumpSharedSpaces.
 678   ClassLoaderData::init_null_class_loader_data();
 679 
 680   // We have a heap so create the Method* caches before
 681   // Metaspace::initialize_shared_spaces() tries to populate them.
 682   Universe::_finalizer_register_cache = new LatestMethodCache();
 683   Universe::_loader_addClass_cache    = new LatestMethodCache();
 684   Universe::_throw_illegal_access_error_cache = new LatestMethodCache();
 685   Universe::_throw_no_such_method_error_cache = new LatestMethodCache();
 686   Universe::_do_stack_walk_cache = new LatestMethodCache();

 687 
 688 #if INCLUDE_CDS
 689   if (UseSharedSpaces) {
 690     // Read the data structures supporting the shared spaces (shared
 691     // system dictionary, symbol table, etc.).  After that, access to
 692     // the file (other than the mapped regions) is no longer needed, and
 693     // the file is closed. Closing the file does not affect the
 694     // currently mapped regions.
 695     MetaspaceShared::initialize_shared_spaces();
 696     StringTable::create_table();
 697   } else
 698 #endif
 699   {
 700     SymbolTable::create_table();
 701     StringTable::create_table();
 702   }
 703 
 704 #if INCLUDE_CDS
 705   if (Arguments::is_dumping_archive()) {
 706     MetaspaceShared::prepare_for_dumping();
</pre>
<hr />
<pre>
 822                           SystemDictionary::internal_Unsafe_klass(),
 823                           &quot;throwIllegalAccessError&quot;,
 824                           vmSymbols::void_method_signature(), true, CHECK);
 825 
 826   initialize_known_method(_throw_no_such_method_error_cache,
 827                           SystemDictionary::internal_Unsafe_klass(),
 828                           &quot;throwNoSuchMethodError&quot;,
 829                           vmSymbols::void_method_signature(), true, CHECK);
 830 
 831   // Set up method for registering loaded classes in class loader vector
 832   initialize_known_method(_loader_addClass_cache,
 833                           SystemDictionary::ClassLoader_klass(),
 834                           &quot;addClass&quot;,
 835                           vmSymbols::class_void_signature(), false, CHECK);
 836 
 837   // Set up method for stack walking
 838   initialize_known_method(_do_stack_walk_cache,
 839                           SystemDictionary::AbstractStackWalker_klass(),
 840                           &quot;doStackWalk&quot;,
 841                           vmSymbols::doStackWalk_signature(), false, CHECK);







 842 }
 843 
 844 void universe2_init() {
 845   EXCEPTION_MARK;
 846   Universe::genesis(CATCH);
 847 }
 848 
 849 // Set after initialization of the module runtime, call_initModuleRuntime
 850 void universe_post_module_init() {
 851   Universe::_module_initialized = true;
 852 }
 853 
 854 bool universe_post_init() {
 855   assert(!is_init_completed(), &quot;Error: initialization not yet completed!&quot;);
 856   Universe::_fully_initialized = true;
 857   EXCEPTION_MARK;
 858   if (!UseSharedSpaces) {
 859     ResourceMark rm;
 860     Universe::reinitialize_vtables(CHECK_false);
 861     Universe::reinitialize_itables(CHECK_false);
</pre>
</td>
<td>
<hr />
<pre>
  99 #define DEFINE_PRIMITIVE_MIRROR(m) \
 100     oop Universe::m  = NULL;
 101 
 102 // Known objects
 103 PRIMITIVE_MIRRORS_DO(DEFINE_PRIMITIVE_MIRROR)
 104 Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
 105 Klass* Universe::_objectArrayKlassObj                 = NULL;
 106 oop Universe::_mirrors[T_VOID+1]                      = { NULL /*, NULL...*/ };
 107 oop Universe::_main_thread_group                      = NULL;
 108 oop Universe::_system_thread_group                    = NULL;
 109 objArrayOop Universe::_the_empty_class_klass_array    = NULL;
 110 Array&lt;Klass*&gt;* Universe::_the_array_interfaces_array = NULL;
 111 oop Universe::_the_null_sentinel                      = NULL;
 112 oop Universe::_the_null_string                        = NULL;
 113 oop Universe::_the_min_jint_string                   = NULL;
 114 LatestMethodCache* Universe::_finalizer_register_cache = NULL;
 115 LatestMethodCache* Universe::_loader_addClass_cache    = NULL;
 116 LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;
 117 LatestMethodCache* Universe::_throw_no_such_method_error_cache = NULL;
 118 LatestMethodCache* Universe::_do_stack_walk_cache     = NULL;
<span class="line-added"> 119 LatestMethodCache* Universe::_is_substitutable_cache  = NULL;</span>
 120 oop Universe::_out_of_memory_error_java_heap          = NULL;
 121 oop Universe::_out_of_memory_error_metaspace          = NULL;
 122 oop Universe::_out_of_memory_error_class_metaspace    = NULL;
 123 oop Universe::_out_of_memory_error_array_size         = NULL;
 124 oop Universe::_out_of_memory_error_gc_overhead_limit  = NULL;
 125 oop Universe::_out_of_memory_error_realloc_objects    = NULL;
 126 oop Universe::_out_of_memory_error_retry              = NULL;
 127 oop Universe::_delayed_stack_overflow_error_message   = NULL;
 128 objArrayOop Universe::_preallocated_out_of_memory_error_array = NULL;
 129 volatile jint Universe::_preallocated_out_of_memory_error_avail_count = 0;
 130 bool Universe::_verify_in_progress                    = false;
 131 long Universe::verify_flags                           = Universe::Verify_All;
 132 oop Universe::_null_ptr_exception_instance            = NULL;
 133 oop Universe::_arithmetic_exception_instance          = NULL;
 134 oop Universe::_virtual_machine_error_instance         = NULL;
 135 oop Universe::_vm_exception                           = NULL;
 136 oop Universe::_reference_pending_list                 = NULL;
 137 
 138 Array&lt;int&gt;* Universe::_the_empty_int_array            = NULL;
 139 Array&lt;u2&gt;* Universe::_the_empty_short_array           = NULL;
 140 Array&lt;Klass*&gt;* Universe::_the_empty_klass_array     = NULL;
 141 Array&lt;InstanceKlass*&gt;* Universe::_the_empty_instance_klass_array  = NULL;
<span class="line-added"> 142 Array&lt;InstanceKlass*&gt;* Universe::_the_single_IdentityObject_klass_array = NULL;</span>
 143 Array&lt;Method*&gt;* Universe::_the_empty_method_array   = NULL;
 144 
 145 // These variables are guarded by FullGCALot_lock.
 146 debug_only(objArrayOop Universe::_fullgc_alot_dummy_array = NULL;)
 147 debug_only(int Universe::_fullgc_alot_dummy_next      = 0;)
 148 
 149 // Heap
 150 int             Universe::_verify_count = 0;
 151 
 152 // Oop verification (see MacroAssembler::verify_oop)
 153 uintptr_t       Universe::_verify_oop_mask = 0;
 154 uintptr_t       Universe::_verify_oop_bits = (uintptr_t) -1;
 155 
 156 int             Universe::_base_vtable_size = 0;
 157 bool            Universe::_bootstrapping = false;
 158 bool            Universe::_module_initialized = false;
 159 bool            Universe::_fully_initialized = false;
 160 
 161 size_t          Universe::_heap_capacity_at_last_gc;
 162 size_t          Universe::_heap_used_at_last_gc = 0;
</pre>
<hr />
<pre>
 209   debug_only(f-&gt;do_oop((oop*)&amp;_fullgc_alot_dummy_array);)
 210   ThreadsSMRSupport::exiting_threads_oops_do(f);
 211 }
 212 
 213 void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {
 214   it-&gt;push(&amp;_klass);
 215 }
 216 
 217 void Universe::metaspace_pointers_do(MetaspaceClosure* it) {
 218   for (int i = 0; i &lt; T_LONG+1; i++) {
 219     it-&gt;push(&amp;_typeArrayKlassObjs[i]);
 220   }
 221   it-&gt;push(&amp;_objectArrayKlassObj);
 222 
 223   it-&gt;push(&amp;_the_empty_int_array);
 224   it-&gt;push(&amp;_the_empty_short_array);
 225   it-&gt;push(&amp;_the_empty_klass_array);
 226   it-&gt;push(&amp;_the_empty_instance_klass_array);
 227   it-&gt;push(&amp;_the_empty_method_array);
 228   it-&gt;push(&amp;_the_array_interfaces_array);
<span class="line-added"> 229   it-&gt;push(&amp;_the_single_IdentityObject_klass_array);</span>
 230 
 231   _finalizer_register_cache-&gt;metaspace_pointers_do(it);
 232   _loader_addClass_cache-&gt;metaspace_pointers_do(it);
 233   _throw_illegal_access_error_cache-&gt;metaspace_pointers_do(it);
 234   _throw_no_such_method_error_cache-&gt;metaspace_pointers_do(it);
 235   _do_stack_walk_cache-&gt;metaspace_pointers_do(it);
<span class="line-added"> 236   _is_substitutable_cache-&gt;metaspace_pointers_do(it);</span>
 237 }
 238 
 239 #define ASSERT_MIRROR_NULL(m) \
 240   assert(m == NULL, &quot;archived mirrors should be NULL&quot;);
 241 
 242 #define SERIALIZE_MIRROR(m) \
 243   f-&gt;do_oop(&amp;m); \
 244   if (m != NULL) { java_lang_Class::update_archived_primitive_mirror_native_pointers(m); }
 245 
 246 // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
 247 void Universe::serialize(SerializeClosure* f) {
 248 
 249   for (int i = 0; i &lt; T_LONG+1; i++) {
 250     f-&gt;do_ptr((void**)&amp;_typeArrayKlassObjs[i]);
 251   }
 252 
 253   f-&gt;do_ptr((void**)&amp;_objectArrayKlassObj);
 254 
 255 #if INCLUDE_CDS_JAVA_HEAP
 256   DEBUG_ONLY(if (DumpSharedSpaces &amp;&amp; !HeapShared::is_heap_object_archiving_allowed()) {
 257       PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NULL);
 258     });
 259   PRIMITIVE_MIRRORS_DO(SERIALIZE_MIRROR);
 260 #endif
 261 
 262   f-&gt;do_ptr((void**)&amp;_the_array_interfaces_array);
 263   f-&gt;do_ptr((void**)&amp;_the_empty_int_array);
 264   f-&gt;do_ptr((void**)&amp;_the_empty_short_array);
 265   f-&gt;do_ptr((void**)&amp;_the_empty_method_array);
 266   f-&gt;do_ptr((void**)&amp;_the_empty_klass_array);
 267   f-&gt;do_ptr((void**)&amp;_the_empty_instance_klass_array);
<span class="line-added"> 268   f-&gt;do_ptr((void**)&amp;_the_single_IdentityObject_klass_array);</span>
 269   _finalizer_register_cache-&gt;serialize(f);
 270   _loader_addClass_cache-&gt;serialize(f);
 271   _throw_illegal_access_error_cache-&gt;serialize(f);
 272   _throw_no_such_method_error_cache-&gt;serialize(f);
 273   _do_stack_walk_cache-&gt;serialize(f);
<span class="line-added"> 274   _is_substitutable_cache-&gt;serialize(f);</span>
 275 }
 276 
 277 void Universe::check_alignment(uintx size, uintx alignment, const char* name) {
 278   if (size &lt; alignment || size % alignment != 0) {
 279     vm_exit_during_initialization(
 280       err_msg(&quot;Size of %s (&quot; UINTX_FORMAT &quot; bytes) must be aligned to &quot; UINTX_FORMAT &quot; bytes&quot;, name, size, alignment));
 281   }
 282 }
 283 
 284 void initialize_basic_type_klass(Klass* k, TRAPS) {
 285   Klass* ok = SystemDictionary::Object_klass();
 286 #if INCLUDE_CDS
 287   if (UseSharedSpaces) {
 288     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 289     assert(k-&gt;super() == ok, &quot;u3&quot;);
 290     if (k-&gt;is_instance_klass()) {
 291       InstanceKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), NULL, CHECK);
 292     } else {
 293       ArrayKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), CHECK);
 294     }
</pre>
<hr />
<pre>
 302 
 303 void Universe::genesis(TRAPS) {
 304   ResourceMark rm(THREAD);
 305 
 306   { FlagSetting fs(_bootstrapping, true);
 307 
 308     { MutexLocker mc(THREAD, Compile_lock);
 309 
 310       java_lang_Class::allocate_fixup_lists();
 311 
 312       // determine base vtable size; without that we cannot create the array klasses
 313       compute_base_vtable_size();
 314 
 315       if (!UseSharedSpaces) {
 316         for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 317           _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);
 318         }
 319 
 320         ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
 321 
<span class="line-modified"> 322         _the_array_interfaces_array     = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 3, NULL, CHECK);</span>
 323         _the_empty_int_array            = MetadataFactory::new_array&lt;int&gt;(null_cld, 0, CHECK);
 324         _the_empty_short_array          = MetadataFactory::new_array&lt;u2&gt;(null_cld, 0, CHECK);
 325         _the_empty_method_array         = MetadataFactory::new_array&lt;Method*&gt;(null_cld, 0, CHECK);
 326         _the_empty_klass_array          = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 0, CHECK);
 327         _the_empty_instance_klass_array = MetadataFactory::new_array&lt;InstanceKlass*&gt;(null_cld, 0, CHECK);
 328       }
 329     }
 330 
 331     vmSymbols::initialize(CHECK);
 332 
 333     SystemDictionary::initialize(CHECK);
 334 
 335     Klass* ok = SystemDictionary::Object_klass();
 336 
 337     _the_null_string            = StringTable::intern(&quot;null&quot;, CHECK);
 338     _the_min_jint_string       = StringTable::intern(&quot;-2147483648&quot;, CHECK);
 339 
 340 #if INCLUDE_CDS
 341     if (UseSharedSpaces) {
 342       // Verify shared interfaces array.
 343       assert(_the_array_interfaces_array-&gt;at(0) ==
 344              SystemDictionary::Cloneable_klass(), &quot;u3&quot;);
 345       assert(_the_array_interfaces_array-&gt;at(1) ==
 346              SystemDictionary::Serializable_klass(), &quot;u3&quot;);
<span class="line-added"> 347       assert(_the_array_interfaces_array-&gt;at(2) ==</span>
<span class="line-added"> 348                    SystemDictionary::IdentityObject_klass(), &quot;u3&quot;);</span>
<span class="line-added"> 349 </span>
<span class="line-added"> 350       assert(_the_single_IdentityObject_klass_array-&gt;at(0) ==</span>
<span class="line-added"> 351           SystemDictionary::IdentityObject_klass(), &quot;u3&quot;);</span>
 352     } else
 353 #endif
 354     {
 355       // Set up shared interfaces array.  (Do this before supers are set up.)
 356       _the_array_interfaces_array-&gt;at_put(0, SystemDictionary::Cloneable_klass());
 357       _the_array_interfaces_array-&gt;at_put(1, SystemDictionary::Serializable_klass());
<span class="line-added"> 358       _the_array_interfaces_array-&gt;at_put(2, SystemDictionary::IdentityObject_klass());</span>
 359     }
 360 
 361     initialize_basic_type_klass(boolArrayKlassObj(), CHECK);
 362     initialize_basic_type_klass(charArrayKlassObj(), CHECK);
 363     initialize_basic_type_klass(floatArrayKlassObj(), CHECK);
 364     initialize_basic_type_klass(doubleArrayKlassObj(), CHECK);
 365     initialize_basic_type_klass(byteArrayKlassObj(), CHECK);
 366     initialize_basic_type_klass(shortArrayKlassObj(), CHECK);
 367     initialize_basic_type_klass(intArrayKlassObj(), CHECK);
 368     initialize_basic_type_klass(longArrayKlassObj(), CHECK);
 369   } // end of core bootstrapping
 370 
 371   {
 372     Handle tns = java_lang_String::create_from_str(&quot;&lt;null_sentinel&gt;&quot;, CHECK);
 373     _the_null_sentinel = tns();
 374   }
 375 
 376   // Maybe this could be lifted up now that object array can be initialized
 377   // during the bootstrapping.
 378 
</pre>
<hr />
<pre>
 460         java_lang_Class::create_basic_type_mirror(&quot;long&quot;,   T_LONG, CHECK);
 461       _short_mirror   =
 462         java_lang_Class::create_basic_type_mirror(&quot;short&quot;,  T_SHORT,   CHECK);
 463       _void_mirror    =
 464         java_lang_Class::create_basic_type_mirror(&quot;void&quot;,   T_VOID, CHECK);
 465     }
 466 
 467     _mirrors[T_INT]     = _int_mirror;
 468     _mirrors[T_FLOAT]   = _float_mirror;
 469     _mirrors[T_DOUBLE]  = _double_mirror;
 470     _mirrors[T_BYTE]    = _byte_mirror;
 471     _mirrors[T_BOOLEAN] = _bool_mirror;
 472     _mirrors[T_CHAR]    = _char_mirror;
 473     _mirrors[T_LONG]    = _long_mirror;
 474     _mirrors[T_SHORT]   = _short_mirror;
 475     _mirrors[T_VOID]    = _void_mirror;
 476   //_mirrors[T_OBJECT]  = _object_klass-&gt;java_mirror();
 477   //_mirrors[T_ARRAY]   = _object_klass-&gt;java_mirror();
 478 }
 479 
<span class="line-added"> 480 void Universe::initialize_the_single_IdentityObject_klass_array(InstanceKlass* ik, TRAPS) {</span>
<span class="line-added"> 481     assert(_the_single_IdentityObject_klass_array == NULL, &quot;Must not be initialized twice&quot;);</span>
<span class="line-added"> 482     assert(ik-&gt;name() == vmSymbols::java_lang_IdentityObject(), &quot;Must be&quot;);</span>
<span class="line-added"> 483     Array&lt;InstanceKlass*&gt;* array = MetadataFactory::new_array&lt;InstanceKlass*&gt;(ik-&gt;class_loader_data(), 1, NULL, CHECK);</span>
<span class="line-added"> 484     array-&gt;at_put(0, ik);</span>
<span class="line-added"> 485     _the_single_IdentityObject_klass_array = array;</span>
<span class="line-added"> 486   }</span>
<span class="line-added"> 487 </span>
 488 void Universe::fixup_mirrors(TRAPS) {
 489   // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,
 490   // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply
 491   // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note
 492   // that the number of objects allocated at this point is very small.
 493   assert(SystemDictionary::Class_klass_loaded(), &quot;java.lang.Class should be loaded&quot;);
 494   HandleMark hm(THREAD);
 495 
 496   if (!UseSharedSpaces) {
 497     // Cache the start of the static fields
 498     InstanceMirrorKlass::init_offset_of_static_fields();
 499   }
 500 
 501   GrowableArray &lt;Klass*&gt;* list = java_lang_Class::fixup_mirror_list();
 502   int list_length = list-&gt;length();
 503   for (int i = 0; i &lt; list_length; i++) {
 504     Klass* k = list-&gt;at(i);
 505     assert(k-&gt;is_klass(), &quot;List should only hold classes&quot;);
 506     EXCEPTION_MARK;
 507     java_lang_Class::fixup_mirror(k, CATCH);
</pre>
<hr />
<pre>
 664   guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord),
 665          &quot;LogHeapWordSize is incorrect.&quot;);
 666   guarantee(sizeof(oop) &gt;= sizeof(HeapWord), &quot;HeapWord larger than oop?&quot;);
 667   guarantee(sizeof(oop) % sizeof(HeapWord) == 0,
 668             &quot;oop size is not not a multiple of HeapWord size&quot;);
 669 
 670   TraceTime timer(&quot;Genesis&quot;, TRACETIME_LOG(Info, startuptime));
 671 
 672   initialize_global_behaviours();
 673 
 674   GCConfig::arguments()-&gt;initialize_heap_sizes();
 675 
 676   jint status = Universe::initialize_heap();
 677   if (status != JNI_OK) {
 678     return status;
 679   }
 680 
 681   Universe::initialize_tlab();
 682 
 683   Metaspace::global_initialize();

 684   // Initialize performance counters for metaspaces
 685   MetaspaceCounters::initialize_performance_counters();
 686   CompressedClassSpaceCounters::initialize_performance_counters();
 687 
 688   AOTLoader::universe_init();
 689 
 690   // Checks &#39;AfterMemoryInit&#39; constraints.
 691   if (!JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterMemoryInit)) {
 692     return JNI_EINVAL;
 693   }
 694 
 695   // Create memory for metadata.  Must be after initializing heap for
 696   // DumpSharedSpaces.
 697   ClassLoaderData::init_null_class_loader_data();
 698 
 699   // We have a heap so create the Method* caches before
 700   // Metaspace::initialize_shared_spaces() tries to populate them.
 701   Universe::_finalizer_register_cache = new LatestMethodCache();
 702   Universe::_loader_addClass_cache    = new LatestMethodCache();
 703   Universe::_throw_illegal_access_error_cache = new LatestMethodCache();
 704   Universe::_throw_no_such_method_error_cache = new LatestMethodCache();
 705   Universe::_do_stack_walk_cache = new LatestMethodCache();
<span class="line-added"> 706   Universe::_is_substitutable_cache = new LatestMethodCache();</span>
 707 
 708 #if INCLUDE_CDS
 709   if (UseSharedSpaces) {
 710     // Read the data structures supporting the shared spaces (shared
 711     // system dictionary, symbol table, etc.).  After that, access to
 712     // the file (other than the mapped regions) is no longer needed, and
 713     // the file is closed. Closing the file does not affect the
 714     // currently mapped regions.
 715     MetaspaceShared::initialize_shared_spaces();
 716     StringTable::create_table();
 717   } else
 718 #endif
 719   {
 720     SymbolTable::create_table();
 721     StringTable::create_table();
 722   }
 723 
 724 #if INCLUDE_CDS
 725   if (Arguments::is_dumping_archive()) {
 726     MetaspaceShared::prepare_for_dumping();
</pre>
<hr />
<pre>
 842                           SystemDictionary::internal_Unsafe_klass(),
 843                           &quot;throwIllegalAccessError&quot;,
 844                           vmSymbols::void_method_signature(), true, CHECK);
 845 
 846   initialize_known_method(_throw_no_such_method_error_cache,
 847                           SystemDictionary::internal_Unsafe_klass(),
 848                           &quot;throwNoSuchMethodError&quot;,
 849                           vmSymbols::void_method_signature(), true, CHECK);
 850 
 851   // Set up method for registering loaded classes in class loader vector
 852   initialize_known_method(_loader_addClass_cache,
 853                           SystemDictionary::ClassLoader_klass(),
 854                           &quot;addClass&quot;,
 855                           vmSymbols::class_void_signature(), false, CHECK);
 856 
 857   // Set up method for stack walking
 858   initialize_known_method(_do_stack_walk_cache,
 859                           SystemDictionary::AbstractStackWalker_klass(),
 860                           &quot;doStackWalk&quot;,
 861                           vmSymbols::doStackWalk_signature(), false, CHECK);
<span class="line-added"> 862 </span>
<span class="line-added"> 863   // Set up substitutability testing</span>
<span class="line-added"> 864   ResourceMark rm;</span>
<span class="line-added"> 865   initialize_known_method(_is_substitutable_cache,</span>
<span class="line-added"> 866                           SystemDictionary::ValueBootstrapMethods_klass(),</span>
<span class="line-added"> 867                           vmSymbols::isSubstitutable_name()-&gt;as_C_string(),</span>
<span class="line-added"> 868                           vmSymbols::object_object_boolean_signature(), true, CHECK);</span>
 869 }
 870 
 871 void universe2_init() {
 872   EXCEPTION_MARK;
 873   Universe::genesis(CATCH);
 874 }
 875 
 876 // Set after initialization of the module runtime, call_initModuleRuntime
 877 void universe_post_module_init() {
 878   Universe::_module_initialized = true;
 879 }
 880 
 881 bool universe_post_init() {
 882   assert(!is_init_completed(), &quot;Error: initialization not yet completed!&quot;);
 883   Universe::_fully_initialized = true;
 884   EXCEPTION_MARK;
 885   if (!UseSharedSpaces) {
 886     ResourceMark rm;
 887     Universe::reinitialize_vtables(CHECK_false);
 888     Universe::reinitialize_itables(CHECK_false);
</pre>
</td>
</tr>
</table>
<center><a href="oopFactory.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/access.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
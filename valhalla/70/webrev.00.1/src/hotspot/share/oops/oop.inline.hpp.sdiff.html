<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/oop.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/bytecodeInfo.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oop.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
143     assert(Universe::is_bootstrapping() || k-&gt;is_klass(), &quot;not a Klass&quot;); \
144   } while (0)
145 
146 void oopDesc::set_klass(Klass* k) {
147   CHECK_SET_KLASS(k);
148   if (UseCompressedClassPointers) {
149     *compressed_klass_addr() = CompressedKlassPointers::encode_not_null(k);
150   } else {
151     *klass_addr() = k;
152   }
153 }
154 
155 void oopDesc::release_set_klass(HeapWord* mem, Klass* klass) {
156   CHECK_SET_KLASS(klass);
157   if (UseCompressedClassPointers) {
158     Atomic::release_store(compressed_klass_addr(mem),
159                           CompressedKlassPointers::encode_not_null(klass));
160   } else {
161     Atomic::release_store(klass_addr(mem), klass);
162   }

163 }
164 
165 #undef CHECK_SET_KLASS
166 
167 int oopDesc::klass_gap() const {
168   return *(int*)(((intptr_t)this) + klass_gap_offset_in_bytes());
169 }
170 
171 void oopDesc::set_klass_gap(HeapWord* mem, int v) {
172   if (UseCompressedClassPointers) {
173     *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;
174   }
175 }
176 
177 void oopDesc::set_klass_gap(int v) {
178   set_klass_gap((HeapWord*)this, v);
179 }
180 
181 bool oopDesc::is_a(Klass* k) const {
182   return klass()-&gt;is_subtype_of(k);
</pre>
<hr />
<pre>
229       // disjunct below to fail if the two comparands are computed across such
230       // a concurrent change.
231       assert((s == klass-&gt;oop_size(this)) ||
232              (Universe::heap()-&gt;is_gc_active() &amp;&amp; is_objArray() &amp;&amp; is_forwarded() &amp;&amp; (UseParallelGC || UseG1GC)),
233              &quot;wrong array object size&quot;);
234     } else {
235       // Must be zero, so bite the bullet and take the virtual call.
236       s = klass-&gt;oop_size(this);
237     }
238   }
239 
240   assert(s &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, s);
241   assert(is_object_aligned(s), &quot;Oop size is not properly aligned: %d&quot;, s);
242   return s;
243 }
244 
245 bool oopDesc::is_instance()  const { return klass()-&gt;is_instance_klass();  }
246 bool oopDesc::is_array()     const { return klass()-&gt;is_array_klass();     }
247 bool oopDesc::is_objArray()  const { return klass()-&gt;is_objArray_klass();  }
248 bool oopDesc::is_typeArray() const { return klass()-&gt;is_typeArray_klass(); }


249 
250 void*    oopDesc::field_addr_raw(int offset)     const { return reinterpret_cast&lt;void*&gt;(cast_from_oop&lt;intptr_t&gt;(as_oop()) + offset); }
251 void*    oopDesc::field_addr(int offset)         const { return Access&lt;&gt;::resolve(as_oop())-&gt;field_addr_raw(offset); }
252 
253 template &lt;class T&gt;
254 T*       oopDesc::obj_field_addr_raw(int offset) const { return (T*) field_addr_raw(offset); }
255 
256 template &lt;typename T&gt;
257 size_t   oopDesc::field_offset(T* p) const { return pointer_delta((void*)p, (void*)this, 1); }
258 
259 template &lt;DecoratorSet decorators&gt;
260 inline oop  oopDesc::obj_field_access(int offset) const             { return HeapAccess&lt;decorators&gt;::oop_load_at(as_oop(), offset); }
261 inline oop  oopDesc::obj_field(int offset) const                    { return HeapAccess&lt;&gt;::oop_load_at(as_oop(), offset);  }
262 
263 inline void oopDesc::obj_field_put(int offset, oop value)           { HeapAccess&lt;&gt;::oop_store_at(as_oop(), offset, value); }
264 
265 inline jbyte oopDesc::byte_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
266 inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
267 
268 inline jchar oopDesc::char_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
</pre>
<hr />
<pre>
283 inline void  oopDesc::long_field_put(int offset, jlong value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
284 
285 inline jfloat oopDesc::float_field(int offset) const                { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
286 inline void   oopDesc::float_field_put(int offset, jfloat value)    { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
287 
288 inline jdouble oopDesc::double_field(int offset) const              { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
289 inline void    oopDesc::double_field_put(int offset, jdouble value) { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
290 
291 bool oopDesc::is_locked() const {
292   return mark().is_locked();
293 }
294 
295 bool oopDesc::is_unlocked() const {
296   return mark().is_unlocked();
297 }
298 
299 bool oopDesc::has_bias_pattern() const {
300   return mark().has_bias_pattern();
301 }
302 

303 bool oopDesc::has_bias_pattern_raw() const {
304   return mark_raw().has_bias_pattern();
305 }
306 
307 // Used only for markSweep, scavenging
308 bool oopDesc::is_gc_marked() const {
309   return mark_raw().is_marked();
310 }
311 
312 // Used by scavengers
313 bool oopDesc::is_forwarded() const {
314   // The extra heap check is needed since the obj might be locked, in which case the
315   // mark would point to a stack location and have the sentinel bit cleared
316   return mark_raw().is_marked();
317 }
318 
319 // Used by scavengers
320 void oopDesc::forward_to(oop p) {
321   verify_forwardee(p);
322   markWord m = markWord::encode_pointer_as_mark(p);
</pre>
</td>
<td>
<hr />
<pre>
143     assert(Universe::is_bootstrapping() || k-&gt;is_klass(), &quot;not a Klass&quot;); \
144   } while (0)
145 
146 void oopDesc::set_klass(Klass* k) {
147   CHECK_SET_KLASS(k);
148   if (UseCompressedClassPointers) {
149     *compressed_klass_addr() = CompressedKlassPointers::encode_not_null(k);
150   } else {
151     *klass_addr() = k;
152   }
153 }
154 
155 void oopDesc::release_set_klass(HeapWord* mem, Klass* klass) {
156   CHECK_SET_KLASS(klass);
157   if (UseCompressedClassPointers) {
158     Atomic::release_store(compressed_klass_addr(mem),
159                           CompressedKlassPointers::encode_not_null(klass));
160   } else {
161     Atomic::release_store(klass_addr(mem), klass);
162   }
<span class="line-added">163   assert(((oopDesc*)mem)-&gt;klass() == klass, &quot;failed oopDesc::klass() encode/decode&quot;);</span>
164 }
165 
166 #undef CHECK_SET_KLASS
167 
168 int oopDesc::klass_gap() const {
169   return *(int*)(((intptr_t)this) + klass_gap_offset_in_bytes());
170 }
171 
172 void oopDesc::set_klass_gap(HeapWord* mem, int v) {
173   if (UseCompressedClassPointers) {
174     *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;
175   }
176 }
177 
178 void oopDesc::set_klass_gap(int v) {
179   set_klass_gap((HeapWord*)this, v);
180 }
181 
182 bool oopDesc::is_a(Klass* k) const {
183   return klass()-&gt;is_subtype_of(k);
</pre>
<hr />
<pre>
230       // disjunct below to fail if the two comparands are computed across such
231       // a concurrent change.
232       assert((s == klass-&gt;oop_size(this)) ||
233              (Universe::heap()-&gt;is_gc_active() &amp;&amp; is_objArray() &amp;&amp; is_forwarded() &amp;&amp; (UseParallelGC || UseG1GC)),
234              &quot;wrong array object size&quot;);
235     } else {
236       // Must be zero, so bite the bullet and take the virtual call.
237       s = klass-&gt;oop_size(this);
238     }
239   }
240 
241   assert(s &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, s);
242   assert(is_object_aligned(s), &quot;Oop size is not properly aligned: %d&quot;, s);
243   return s;
244 }
245 
246 bool oopDesc::is_instance()  const { return klass()-&gt;is_instance_klass();  }
247 bool oopDesc::is_array()     const { return klass()-&gt;is_array_klass();     }
248 bool oopDesc::is_objArray()  const { return klass()-&gt;is_objArray_klass();  }
249 bool oopDesc::is_typeArray() const { return klass()-&gt;is_typeArray_klass(); }
<span class="line-added">250 bool oopDesc::is_value()     const { return klass()-&gt;is_value(); }</span>
<span class="line-added">251 bool oopDesc::is_valueArray()  const { return klass()-&gt;is_valueArray_klass(); }</span>
252 
253 void*    oopDesc::field_addr_raw(int offset)     const { return reinterpret_cast&lt;void*&gt;(cast_from_oop&lt;intptr_t&gt;(as_oop()) + offset); }
254 void*    oopDesc::field_addr(int offset)         const { return Access&lt;&gt;::resolve(as_oop())-&gt;field_addr_raw(offset); }
255 
256 template &lt;class T&gt;
257 T*       oopDesc::obj_field_addr_raw(int offset) const { return (T*) field_addr_raw(offset); }
258 
259 template &lt;typename T&gt;
260 size_t   oopDesc::field_offset(T* p) const { return pointer_delta((void*)p, (void*)this, 1); }
261 
262 template &lt;DecoratorSet decorators&gt;
263 inline oop  oopDesc::obj_field_access(int offset) const             { return HeapAccess&lt;decorators&gt;::oop_load_at(as_oop(), offset); }
264 inline oop  oopDesc::obj_field(int offset) const                    { return HeapAccess&lt;&gt;::oop_load_at(as_oop(), offset);  }
265 
266 inline void oopDesc::obj_field_put(int offset, oop value)           { HeapAccess&lt;&gt;::oop_store_at(as_oop(), offset, value); }
267 
268 inline jbyte oopDesc::byte_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
269 inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
270 
271 inline jchar oopDesc::char_field(int offset) const                  { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
</pre>
<hr />
<pre>
286 inline void  oopDesc::long_field_put(int offset, jlong value)       { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
287 
288 inline jfloat oopDesc::float_field(int offset) const                { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
289 inline void   oopDesc::float_field_put(int offset, jfloat value)    { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
290 
291 inline jdouble oopDesc::double_field(int offset) const              { return HeapAccess&lt;&gt;::load_at(as_oop(), offset);  }
292 inline void    oopDesc::double_field_put(int offset, jdouble value) { HeapAccess&lt;&gt;::store_at(as_oop(), offset, value); }
293 
294 bool oopDesc::is_locked() const {
295   return mark().is_locked();
296 }
297 
298 bool oopDesc::is_unlocked() const {
299   return mark().is_unlocked();
300 }
301 
302 bool oopDesc::has_bias_pattern() const {
303   return mark().has_bias_pattern();
304 }
305 
<span class="line-added">306 </span>
307 bool oopDesc::has_bias_pattern_raw() const {
308   return mark_raw().has_bias_pattern();
309 }
310 
311 // Used only for markSweep, scavenging
312 bool oopDesc::is_gc_marked() const {
313   return mark_raw().is_marked();
314 }
315 
316 // Used by scavengers
317 bool oopDesc::is_forwarded() const {
318   // The extra heap check is needed since the obj might be locked, in which case the
319   // mark would point to a stack location and have the sentinel bit cleared
320   return mark_raw().is_marked();
321 }
322 
323 // Used by scavengers
324 void oopDesc::forward_to(oop p) {
325   verify_forwardee(p);
326   markWord m = markWord::encode_pointer_as_mark(p);
</pre>
</td>
</tr>
</table>
<center><a href="oop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/bytecodeInfo.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
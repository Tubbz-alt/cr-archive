diff a/src/hotspot/share/oops/oop.inline.hpp b/src/hotspot/share/oops/oop.inline.hpp
--- a/src/hotspot/share/oops/oop.inline.hpp
+++ b/src/hotspot/share/oops/oop.inline.hpp
@@ -158,10 +158,11 @@
     Atomic::release_store(compressed_klass_addr(mem),
                           CompressedKlassPointers::encode_not_null(klass));
   } else {
     Atomic::release_store(klass_addr(mem), klass);
   }
+  assert(((oopDesc*)mem)->klass() == klass, "failed oopDesc::klass() encode/decode");
 }
 
 #undef CHECK_SET_KLASS
 
 int oopDesc::klass_gap() const {
@@ -244,10 +245,12 @@
 
 bool oopDesc::is_instance()  const { return klass()->is_instance_klass();  }
 bool oopDesc::is_array()     const { return klass()->is_array_klass();     }
 bool oopDesc::is_objArray()  const { return klass()->is_objArray_klass();  }
 bool oopDesc::is_typeArray() const { return klass()->is_typeArray_klass(); }
+bool oopDesc::is_value()     const { return klass()->is_value(); }
+bool oopDesc::is_valueArray()  const { return klass()->is_valueArray_klass(); }
 
 void*    oopDesc::field_addr_raw(int offset)     const { return reinterpret_cast<void*>(cast_from_oop<intptr_t>(as_oop()) + offset); }
 void*    oopDesc::field_addr(int offset)         const { return Access<>::resolve(as_oop())->field_addr_raw(offset); }
 
 template <class T>
@@ -298,10 +301,11 @@
 
 bool oopDesc::has_bias_pattern() const {
   return mark().has_bias_pattern();
 }
 
+
 bool oopDesc::has_bias_pattern_raw() const {
   return mark_raw().has_bias_pattern();
 }
 
 // Used only for markSweep, scavenging

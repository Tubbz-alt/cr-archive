<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/oops/accessBackend.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="access.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessDecorators.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/accessBackend.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -50,10 +50,18 @@</span>
    static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value &amp;&amp;
                                           HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;
    typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;
  };
  
<span class="udiff-line-added">+ // This meta-function returns either oop or narrowOop depending on whether</span>
<span class="udiff-line-added">+ // a back-end needs to consider compressed oops types or not.</span>
<span class="udiff-line-added">+ template &lt;DecoratorSet decorators&gt;</span>
<span class="udiff-line-added">+ struct ValueOopType: AllStatic {</span>
<span class="udiff-line-added">+   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;</span>
<span class="udiff-line-added">+   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  namespace AccessInternal {
    enum BarrierType {
      BARRIER_STORE,
      BARRIER_STORE_AT,
      BARRIER_LOAD,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62,10 +70,11 @@</span>
      BARRIER_ATOMIC_CMPXCHG_AT,
      BARRIER_ATOMIC_XCHG,
      BARRIER_ATOMIC_XCHG_AT,
      BARRIER_ARRAYCOPY,
      BARRIER_CLONE,
<span class="udiff-line-added">+     BARRIER_VALUE_COPY,</span>
      BARRIER_RESOLVE
    };
  
    template &lt;DecoratorSet decorators, typename T&gt;
    struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108,20 +117,21 @@</span>
      typedef T (*load_func_t)(void* addr);
      typedef void (*store_func_t)(void* addr, T value);
      typedef T (*atomic_cmpxchg_func_t)(void* addr, T compare_value, T new_value);
      typedef T (*atomic_xchg_func_t)(void* addr, T new_value);
  
<span class="udiff-line-modified-removed">-     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
<span class="udiff-line-modified-added">+     typedef void (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
                                       arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                                       size_t length);
      typedef void (*clone_func_t)(oop src, oop dst, size_t size);
<span class="udiff-line-added">+     typedef void (*value_copy_func_t)(void* src, void* dst, ValueKlass* md);</span>
      typedef oop (*resolve_func_t)(oop obj);
    };
  
    template &lt;DecoratorSet decorators&gt;
    struct AccessFunctionTypes&lt;decorators, void&gt; {
<span class="udiff-line-modified-removed">-     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,</span>
<span class="udiff-line-modified-added">+     typedef void (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,</span>
                                       arrayOop dst_obj, size_t dst_offset_in_bytes, void* dst,
                                       size_t length);
    };
  
    template &lt;DecoratorSet decorators, typename T, BarrierType barrier&gt; struct AccessFunction {};
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -139,10 +149,11 @@</span>
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG_AT, atomic_cmpxchg_at_func_t);
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);
<span class="udiff-line-added">+   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_VALUE_COPY, value_copy_func_t);</span>
    ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);
  #undef ACCESS_GENERATE_ACCESS_FUNCTION
  
    template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
    typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_barrier();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -339,11 +350,11 @@</span>
    static inline T atomic_xchg(void* addr, T new_value) {
      return atomic_xchg_maybe_locked&lt;decorators&gt;(addr, new_value);
    }
  
    template &lt;typename T&gt;
<span class="udiff-line-modified-removed">-   static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
<span class="udiff-line-modified-added">+   static void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                          size_t length);
  
    template &lt;typename T&gt;
    static void oop_store(void* addr, T value);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -384,16 +395,18 @@</span>
    static T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
      return atomic_xchg(field_addr(base, offset), new_value);
    }
  
    template &lt;typename T&gt;
<span class="udiff-line-modified-removed">-   static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
<span class="udiff-line-modified-added">+   static void oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
                              arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                              size_t length);
  
    static void clone(oop src, oop dst, size_t size);
  
<span class="udiff-line-added">+   static void value_copy(void* src, void* dst, ValueKlass* md);</span>
<span class="udiff-line-added">+ </span>
    static oop resolve(oop obj) { return obj; }
  };
  
  // Below is the implementation of the first 4 steps of the template pipeline:
  // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -547,15 +560,15 @@</span>
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
      typedef typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type func_t;
      static func_t _arraycopy_func;
  
<span class="udiff-line-modified-removed">-     static bool arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
<span class="udiff-line-modified-added">+     static void arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
                                 arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                                 size_t length);
  
<span class="udiff-line-modified-removed">-     static inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
<span class="udiff-line-modified-added">+     static inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
                                   arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                                   size_t length) {
        return _arraycopy_func(src_obj, src_offset_in_bytes, src_raw,
                               dst_obj, dst_offset_in_bytes, dst_raw,
                               length);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -572,10 +585,22 @@</span>
      static inline void clone(oop src, oop dst, size_t size) {
        _clone_func(src, dst, size);
      }
    };
  
<span class="udiff-line-added">+   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="udiff-line-added">+   struct RuntimeDispatch&lt;decorators, T, BARRIER_VALUE_COPY&gt;: AllStatic {</span>
<span class="udiff-line-added">+     typedef typename AccessFunction&lt;decorators, T, BARRIER_VALUE_COPY&gt;::type func_t;</span>
<span class="udiff-line-added">+     static func_t _value_copy_func;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static void value_copy_init(void* src, void* dst, ValueKlass* md);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static inline void value_copy(void* src, void* dst, ValueKlass* md) {</span>
<span class="udiff-line-added">+       _value_copy_func(src, dst, md);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
    template &lt;DecoratorSet decorators, typename T&gt;
    struct RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;: AllStatic {
      typedef typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type func_t;
      static func_t _resolve_func;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -625,10 +650,14 @@</span>
  
    template &lt;DecoratorSet decorators, typename T&gt;
    typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type
    RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::_clone_func = &amp;clone_init;
  
<span class="udiff-line-added">+   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="udiff-line-added">+   typename AccessFunction&lt;decorators, T, BARRIER_VALUE_COPY&gt;::type</span>
<span class="udiff-line-added">+   RuntimeDispatch&lt;decorators, T, BARRIER_VALUE_COPY&gt;::_value_copy_func = &amp;value_copy_init;</span>
<span class="udiff-line-added">+ </span>
    template &lt;DecoratorSet decorators, typename T&gt;
    typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type
    RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::_resolve_func = &amp;resolve_init;
  
    // Step 3: Pre-runtime dispatching.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -877,60 +906,60 @@</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
<span class="udiff-line-modified-removed">-       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type</span>
<span class="udiff-line-modified-added">+       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, void&gt;::type</span>
      arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                size_t length) {
        typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
        if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="udiff-line-modified-removed">-         return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-removed">-                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-removed">-                                   length);</span>
<span class="udiff-line-modified-added">+         Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-added">+                            dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-added">+                            length);</span>
        } else {
<span class="udiff-line-modified-removed">-         return Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-removed">-                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-removed">-                               length);</span>
<span class="udiff-line-modified-added">+         Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-added">+                        dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-added">+                        length);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
<span class="udiff-line-modified-removed">-       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type</span>
<span class="udiff-line-modified-added">+       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, void&gt;::type</span>
      arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                size_t length) {
        if (UseCompressedOops) {
          const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="udiff-line-modified-removed">-         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-removed">-                                                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-removed">-                                                                   length);</span>
<span class="udiff-line-modified-added">+         PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-added">+                                                            dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-added">+                                                            length);</span>
        } else {
          const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="udiff-line-modified-removed">-         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-removed">-                                                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-removed">-                                                                   length);</span>
<span class="udiff-line-modified-added">+         PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-added">+                                                            dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-added">+                                                            length);</span>
        }
      }
  
      template &lt;DecoratorSet decorators, typename T&gt;
      inline static typename EnableIf&lt;
<span class="udiff-line-modified-removed">-       !HasDecorator&lt;decorators, AS_RAW&gt;::value, bool&gt;::type</span>
<span class="udiff-line-modified-added">+       !HasDecorator&lt;decorators, AS_RAW&gt;::value, void&gt;::type</span>
      arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                size_t length) {
        if (is_hardwired_primitive&lt;decorators&gt;()) {
          const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="udiff-line-modified-removed">-         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-removed">-                                                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-removed">-                                                                   length);</span>
<span class="udiff-line-modified-added">+         PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-added">+                                                            dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-added">+                                                            length);</span>
        } else {
<span class="udiff-line-modified-removed">-         return RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-removed">-                                                                             dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-removed">-                                                                             length);</span>
<span class="udiff-line-modified-added">+         RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-added">+                                                                      dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-added">+                                                                      length);</span>
        }
      }
  
      template &lt;DecoratorSet decorators&gt;
      inline static typename EnableIf&lt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -945,10 +974,27 @@</span>
        !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
      clone(oop src, oop dst, size_t size) {
        RuntimeDispatch&lt;decorators, oop, BARRIER_CLONE&gt;::clone(src, dst, size);
      }
  
<span class="udiff-line-added">+     template &lt;DecoratorSet decorators&gt;</span>
<span class="udiff-line-added">+     inline static typename EnableIf&lt;</span>
<span class="udiff-line-added">+       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type</span>
<span class="udiff-line-added">+     value_copy(void* src, void* dst, ValueKlass* md) {</span>
<span class="udiff-line-added">+       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;</span>
<span class="udiff-line-added">+       Raw::value_copy(src, dst, md);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     template &lt;DecoratorSet decorators&gt;</span>
<span class="udiff-line-added">+     inline static typename EnableIf&lt;</span>
<span class="udiff-line-added">+       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type</span>
<span class="udiff-line-added">+       value_copy(void* src, void* dst, ValueKlass* md) {</span>
<span class="udiff-line-added">+       const DecoratorSet expanded_decorators = decorators;</span>
<span class="udiff-line-added">+       RuntimeDispatch&lt;expanded_decorators, void*, BARRIER_VALUE_COPY&gt;::value_copy(src, dst, md);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
      template &lt;DecoratorSet decorators&gt;
      inline static typename EnableIf&lt;
        HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
      resolve(oop obj) {
        typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1073,37 +1119,37 @@</span>
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
      return PreRuntimeDispatch::load&lt;expanded_decorators, oop&gt;(addr);
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
<span class="udiff-line-modified-removed">-   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
<span class="udiff-line-modified-added">+   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
                                       arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                                       size_t length) {
<span class="udiff-line-modified-removed">-     return PreRuntimeDispatch::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-removed">-                                                      dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-removed">-                                                      length);</span>
<span class="udiff-line-modified-added">+     PreRuntimeDispatch::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-added">+                                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-added">+                                               length);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="udiff-line-modified-removed">-   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, HeapWord* src_raw,</span>
<span class="udiff-line-modified-added">+   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, HeapWord* src_raw,</span>
                                       arrayOop dst_obj, size_t dst_offset_in_bytes, HeapWord* dst_raw,
                                       size_t length) {
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="udiff-line-modified-removed">-     return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-removed">-                                                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-removed">-                                                               length);</span>
<span class="udiff-line-modified-added">+     PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-added">+                                                        dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-added">+                                                        length);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
<span class="udiff-line-modified-removed">-   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,</span>
<span class="udiff-line-modified-added">+   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,</span>
                                       arrayOop dst_obj, size_t dst_offset_in_bytes, narrowOop* dst_raw,
                                       size_t length) {
      const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
                                               INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="udiff-line-modified-removed">-     return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-removed">-                                                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-removed">-                                                               length);</span>
<span class="udiff-line-modified-added">+     PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="udiff-line-modified-added">+                                                        dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="udiff-line-modified-added">+                                                        length);</span>
    }
  
    // Step 1: Set default decorators. This step remembers if a type was volatile
    // and then sets the MO_RELAXED decorator by default. Otherwise, a default
    // memory ordering is set for the access, and the implied decorator rules
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1232,29 +1278,35 @@</span>
                                                INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
      return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(base, offset, new_decayed_value);
    }
  
    template &lt;DecoratorSet decorators, typename T&gt;
<span class="udiff-line-modified-removed">-   inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,</span>
<span class="udiff-line-modified-added">+   inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,</span>
                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                          size_t length) {
      STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ||
                     (IsSame&lt;T, void&gt;::value || IsIntegral&lt;T&gt;::value) ||
                      IsFloatingPoint&lt;T&gt;::value)); // arraycopy allows type erased void elements
      typedef typename Decay&lt;T&gt;::type DecayedT;
      const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | IS_ARRAY | IN_HEAP&gt;::value;
<span class="udiff-line-modified-removed">-     return arraycopy_reduce_types&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, const_cast&lt;DecayedT*&gt;(src_raw),</span>
<span class="udiff-line-modified-removed">-                                                        dst_obj, dst_offset_in_bytes, const_cast&lt;DecayedT*&gt;(dst_raw),</span>
<span class="udiff-line-modified-removed">-                                                        length);</span>
<span class="udiff-line-modified-added">+     arraycopy_reduce_types&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, const_cast&lt;DecayedT*&gt;(src_raw),</span>
<span class="udiff-line-modified-added">+                                                 dst_obj, dst_offset_in_bytes, const_cast&lt;DecayedT*&gt;(dst_raw),</span>
<span class="udiff-line-modified-added">+                                                 length);</span>
    }
  
    template &lt;DecoratorSet decorators&gt;
    inline void clone(oop src, oop dst, size_t size) {
      const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
      PreRuntimeDispatch::clone&lt;expanded_decorators&gt;(src, dst, size);
    }
  
<span class="udiff-line-added">+   template &lt;DecoratorSet decorators&gt;</span>
<span class="udiff-line-added">+   inline void value_copy(void* src, void* dst, ValueKlass* md) {</span>
<span class="udiff-line-added">+     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;</span>
<span class="udiff-line-added">+     PreRuntimeDispatch::value_copy&lt;expanded_decorators&gt;(src, dst, md);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    template &lt;DecoratorSet decorators&gt;
    inline oop resolve(oop obj) {
      const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
      return PreRuntimeDispatch::resolve&lt;expanded_decorators&gt;(obj);
    }
</pre>
<center><a href="access.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessDecorators.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
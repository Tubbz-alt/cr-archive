<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/method.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="accessDecorators.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;interpreter/oopMapCache.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;logging/logTag.hpp&quot;
  41 #include &quot;logging/logStream.hpp&quot;
  42 #include &quot;memory/allocation.inline.hpp&quot;
  43 #include &quot;memory/metadataFactory.hpp&quot;
  44 #include &quot;memory/metaspaceClosure.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/constMethod.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/method.inline.hpp&quot;
  52 #include &quot;oops/methodData.hpp&quot;
  53 #include &quot;oops/objArrayKlass.hpp&quot;
  54 #include &quot;oops/objArrayOop.inline.hpp&quot;
  55 #include &quot;oops/oop.inline.hpp&quot;
  56 #include &quot;oops/symbol.hpp&quot;

  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/methodHandles.hpp&quot;
  59 #include &quot;prims/nativeLookup.hpp&quot;
  60 #include &quot;runtime/arguments.hpp&quot;
  61 #include &quot;runtime/atomic.hpp&quot;
  62 #include &quot;runtime/frame.inline.hpp&quot;
  63 #include &quot;runtime/handles.inline.hpp&quot;
  64 #include &quot;runtime/init.hpp&quot;
  65 #include &quot;runtime/orderAccess.hpp&quot;
  66 #include &quot;runtime/relocator.hpp&quot;
  67 #include &quot;runtime/safepointVerifiers.hpp&quot;
  68 #include &quot;runtime/sharedRuntime.hpp&quot;
  69 #include &quot;runtime/signature.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/quickSort.hpp&quot;
  72 #include &quot;utilities/vmError.hpp&quot;
  73 #include &quot;utilities/xmlstream.hpp&quot;
  74 
  75 // Implementation of Method
  76 
</pre>
<hr />
<pre>
  96   set_constMethod(xconst);
  97   set_access_flags(access_flags);
  98   set_intrinsic_id(vmIntrinsics::_none);
  99   set_force_inline(false);
 100   set_hidden(false);
 101   set_dont_inline(false);
 102   set_has_injected_profile(false);
 103   set_method_data(NULL);
 104   clear_method_counters();
 105   set_vtable_index(Method::garbage_vtable_index);
 106 
 107   // Fix and bury in Method*
 108   set_interpreter_entry(NULL); // sets i2i entry and from_int
 109   set_adapter_entry(NULL);
 110   Method::clear_code(); // from_c/from_i get set to c2i/i2i
 111 
 112   if (access_flags.is_native()) {
 113     clear_native_function();
 114     set_signature_handler(NULL);
 115   }
<span class="line-removed"> 116 </span>
 117   NOT_PRODUCT(set_compiled_invocation_count(0);)
 118 }
 119 
 120 // Release Method*.  The nmethod will be gone when we get here because
 121 // we&#39;ve walked the code cache.
 122 void Method::deallocate_contents(ClassLoaderData* loader_data) {
 123   MetadataFactory::free_metadata(loader_data, constMethod());
 124   set_constMethod(NULL);
 125   MetadataFactory::free_metadata(loader_data, method_data());
 126   set_method_data(NULL);
 127   MetadataFactory::free_metadata(loader_data, method_counters());
 128   clear_method_counters();
 129   // The nmethod will be gone when we get here.
 130   if (code() != NULL) _code = NULL;
 131 }
 132 
 133 void Method::release_C_heap_structures() {
 134   if (method_data()) {
 135 #if INCLUDE_JVMCI
 136     FailedSpeculation::free_failed_speculations(method_data()-&gt;get_failed_speculations_address());
 137 #endif
 138     // Destroy MethodData
 139     method_data()-&gt;~MethodData();
 140   }
 141 }
 142 
 143 address Method::get_i2c_entry() {
 144   assert(adapter() != NULL, &quot;must have&quot;);
 145   return adapter()-&gt;get_i2c_entry();
 146 }
 147 
 148 address Method::get_c2i_entry() {
 149   assert(adapter() != NULL, &quot;must have&quot;);
 150   return adapter()-&gt;get_c2i_entry();
 151 }
 152 





 153 address Method::get_c2i_unverified_entry() {
 154   assert(adapter() != NULL, &quot;must have&quot;);
 155   return adapter()-&gt;get_c2i_unverified_entry();
 156 }
 157 





 158 address Method::get_c2i_no_clinit_check_entry() {
 159   assert(VM_Version::supports_fast_class_init_checks(), &quot;&quot;);
 160   assert(adapter() != NULL, &quot;must have&quot;);
 161   return adapter()-&gt;get_c2i_no_clinit_check_entry();
 162 }
 163 
 164 char* Method::name_and_sig_as_C_string() const {
 165   return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature());
 166 }
 167 
 168 char* Method::name_and_sig_as_C_string(char* buf, int size) const {
 169   return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature(), buf, size);
 170 }
 171 
 172 char* Method::name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature) {
 173   const char* klass_name = klass-&gt;external_name();
 174   int klass_name_len  = (int)strlen(klass_name);
 175   int method_name_len = method_name-&gt;utf8_length();
 176   int len             = klass_name_len + 1 + method_name_len + signature-&gt;utf8_length();
 177   char* dest          = NEW_RESOURCE_ARRAY(char, len + 1);
</pre>
<hr />
<pre>
 330   // If native, then include pointers for native_function and signature_handler
 331   int extra_bytes = (is_native) ? 2*sizeof(address*) : 0;
 332   int extra_words = align_up(extra_bytes, BytesPerWord) / BytesPerWord;
 333   return align_metadata_size(header_size() + extra_words);
 334 }
 335 
 336 Symbol* Method::klass_name() const {
 337   return method_holder()-&gt;name();
 338 }
 339 
 340 void Method::metaspace_pointers_do(MetaspaceClosure* it) {
 341   log_trace(cds)(&quot;Iter(Method): %p&quot;, this);
 342 
 343   it-&gt;push(&amp;_constMethod);
 344   it-&gt;push(&amp;_method_data);
 345   it-&gt;push(&amp;_method_counters);
 346 
 347   Method* this_ptr = this;
 348   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_i2i_entry);
 349   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_entry);


 350   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_interpreted_entry);
 351 }
 352 
 353 // Attempt to return method oop to original state.  Clear any pointers
 354 // (to objects outside the shared spaces).  We won&#39;t be able to predict
 355 // where they should point in a new JVM.  Further initialize some
 356 // entries now in order allow them to be write protected later.
 357 
 358 void Method::remove_unshareable_info() {
 359   unlink_method();
 360 }
 361 
 362 void Method::set_vtable_index(int index) {
 363   if (is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite()) {
 364     // At runtime initialize_vtable is rerun as part of link_class_impl()
 365     // for a shared class loaded by the non-boot loader to obtain the loader
 366     // constraints based on the runtime classloaders&#39; context.
 367     return; // don&#39;t write into the shared class
 368   } else {
 369     _vtable_index = index;
</pre>
<hr />
<pre>
 573   return Atomic::replace_if_null(&amp;_method_counters, counters);
 574 }
 575 
 576 int Method::extra_stack_words() {
 577   // not an inline function, to avoid a header dependency on Interpreter
 578   return extra_stack_entries() * Interpreter::stackElementSize;
 579 }
 580 
 581 // Derive size of parameters, return type, and fingerprint,
 582 // all in one pass, which is run at load time.
 583 // We need the first two, and might as well grab the third.
 584 void Method::compute_from_signature(Symbol* sig) {
 585   // At this point, since we are scanning the signature,
 586   // we might as well compute the whole fingerprint.
 587   Fingerprinter fp(sig, is_static());
 588   set_size_of_parameters(fp.size_of_parameters());
 589   constMethod()-&gt;set_result_type(fp.return_type());
 590   constMethod()-&gt;set_fingerprint(fp.fingerprint());
 591 }
 592 


















 593 bool Method::is_empty_method() const {
 594   return  code_size() == 1
 595       &amp;&amp; *code_base() == Bytecodes::_return;
 596 }
 597 
 598 bool Method::is_vanilla_constructor() const {
 599   // Returns true if this method is a vanilla constructor, i.e. an &quot;&lt;init&gt;&quot; &quot;()V&quot; method
 600   // which only calls the superclass vanilla constructor and possibly does stores of
 601   // zero constants to local fields:
 602   //
<span class="line-modified"> 603   //   aload_0</span>
 604   //   invokespecial
 605   //   indexbyte1
 606   //   indexbyte2
 607   //
 608   // followed by an (optional) sequence of:
 609   //
 610   //   aload_0
 611   //   aconst_null / iconst_0 / fconst_0 / dconst_0
 612   //   putfield
 613   //   indexbyte1
 614   //   indexbyte2
 615   //
 616   // followed by:
 617   //
 618   //   return
 619 
 620   assert(name() == vmSymbols::object_initializer_name(),    &quot;Should only be called for default constructors&quot;);
 621   assert(signature() == vmSymbols::void_method_signature(), &quot;Should only be called for default constructors&quot;);
 622   int size = code_size();
 623   // Check if size match
 624   if (size == 0 || size % 5 != 0) return false;
 625   address cb = code_base();
 626   int last = size - 1;
<span class="line-modified"> 627   if (cb[0] != Bytecodes::_aload_0 || cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {</span>

 628     // Does not call superclass default constructor
 629     return false;
 630   }
 631   // Check optional sequence
 632   for (int i = 4; i &lt; last; i += 5) {
 633     if (cb[i] != Bytecodes::_aload_0) return false;
 634     if (!Bytecodes::is_zero_const(Bytecodes::cast(cb[i+1]))) return false;
 635     if (cb[i+2] != Bytecodes::_putfield) return false;
 636   }
 637   return true;
 638 }
 639 
 640 
 641 bool Method::compute_has_loops_flag() {
 642   BytecodeStream bcs(methodHandle(Thread::current(), this));
 643   Bytecodes::Code bc;
 644 
 645   while ((bc = bcs.next()) &gt;= 0) {
 646     switch( bc ) {
 647       case Bytecodes::_ifeq:
</pre>
<hr />
<pre>
 759       if (size_of_parameters() != 3) return false;
 760       break;
 761     default:
 762       return false;
 763   }
 764   if (java_code_at(2) != Bytecodes::_putfield) return false;
 765   if (java_code_at(5) != Bytecodes::_return)   return false;
 766   return true;
 767 }
 768 
 769 bool Method::is_constant_getter() const {
 770   int last_index = code_size() - 1;
 771   // Check if the first 1-3 bytecodes are a constant push
 772   // and the last bytecode is a return.
 773   return (2 &lt;= code_size() &amp;&amp; code_size() &lt;= 4 &amp;&amp;
 774           Bytecodes::is_const(java_code_at(0)) &amp;&amp;
 775           Bytecodes::length_for(java_code_at(0)) == last_index &amp;&amp;
 776           Bytecodes::is_return(java_code_at(last_index)));
 777 }
 778 
<span class="line-modified"> 779 bool Method::is_initializer() const {</span>
<span class="line-modified"> 780   return is_object_initializer() || is_static_initializer();</span>
<span class="line-removed"> 781 }</span>
<span class="line-removed"> 782 </span>
<span class="line-removed"> 783 bool Method::has_valid_initializer_flags() const {</span>
<span class="line-removed"> 784   return (is_static() ||</span>
<span class="line-removed"> 785           method_holder()-&gt;major_version() &lt; 51);</span>
 786 }
 787 
<span class="line-modified"> 788 bool Method::is_static_initializer() const {</span>
 789   // For classfiles version 51 or greater, ensure that the clinit method is
 790   // static.  Non-static methods with the name &quot;&lt;clinit&gt;&quot; are not static
 791   // initializers. (older classfiles exempted for backward compatibility)
<span class="line-modified"> 792   return name() == vmSymbols::class_initializer_name() &amp;&amp;</span>
<span class="line-modified"> 793          has_valid_initializer_flags();</span>






 794 }
 795 
<span class="line-modified"> 796 bool Method::is_object_initializer() const {</span>
<span class="line-modified"> 797    return name() == vmSymbols::object_initializer_name();</span>

 798 }
 799 
 800 bool Method::needs_clinit_barrier() const {
 801   return is_static() &amp;&amp; !method_holder()-&gt;is_initialized();
 802 }
 803 
 804 objArrayHandle Method::resolved_checked_exceptions_impl(Method* method, TRAPS) {
 805   int length = method-&gt;checked_exceptions_length();
 806   if (length == 0) {  // common case
 807     return objArrayHandle(THREAD, Universe::the_empty_class_klass_array());
 808   } else {
 809     methodHandle h_this(THREAD, method);
 810     objArrayOop m_oop = oopFactory::new_objArray(SystemDictionary::Class_klass(), length, CHECK_(objArrayHandle()));
 811     objArrayHandle mirrors (THREAD, m_oop);
 812     for (int i = 0; i &lt; length; i++) {
 813       CheckedExceptionElement* table = h_this-&gt;checked_exceptions_start(); // recompute on each iteration, not gc safe
 814       Klass* k = h_this-&gt;constants()-&gt;klass_at(table[i].class_cp_index, CHECK_(objArrayHandle()));
 815       if (log_is_enabled(Warning, exceptions) &amp;&amp;
 816           !k-&gt;is_subclass_of(SystemDictionary::Throwable_klass())) {
 817         ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
 835     // Not necessarily sorted and not necessarily one-to-one.
 836     CompressedLineNumberReadStream stream(compressed_linenumber_table());
 837     while (stream.read_pair()) {
 838       if (stream.bci() == bci) {
 839         // perfect match
 840         return stream.line();
 841       } else {
 842         // update best_bci/line
 843         if (stream.bci() &lt; bci &amp;&amp; stream.bci() &gt;= best_bci) {
 844           best_bci  = stream.bci();
 845           best_line = stream.line();
 846         }
 847       }
 848     }
 849   }
 850   return best_line;
 851 }
 852 
 853 
 854 bool Method::is_klass_loaded_by_klass_index(int klass_index) const {
<span class="line-modified"> 855   if( constants()-&gt;tag_at(klass_index).is_unresolved_klass() ) {</span>
 856     Thread *thread = Thread::current();
 857     Symbol* klass_name = constants()-&gt;klass_name_at(klass_index);
 858     Handle loader(thread, method_holder()-&gt;class_loader());
 859     Handle prot  (thread, method_holder()-&gt;protection_domain());
 860     return SystemDictionary::find(klass_name, loader, prot, thread) != NULL;
 861   } else {
 862     return true;
 863   }
 864 }
 865 
 866 
 867 bool Method::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {
 868   int klass_index = constants()-&gt;klass_ref_index_at(refinfo_index);
 869   if (must_be_resolved) {
 870     // Make sure klass is resolved in constantpool.
<span class="line-modified"> 871     if (constants()-&gt;tag_at(klass_index).is_unresolved_klass()) return false;</span>


 872   }
 873   return is_klass_loaded_by_klass_index(klass_index);
 874 }
 875 
 876 
 877 void Method::set_native_function(address function, bool post_event_flag) {
 878   assert(function != NULL, &quot;use clear_native_function to unregister natives&quot;);
 879   assert(!is_method_handle_intrinsic() || function == SharedRuntime::native_method_throw_unsatisfied_link_error_entry(), &quot;&quot;);
 880   address* native_function = native_function_addr();
 881 
 882   // We can see racers trying to place the same native function into place. Once
 883   // is plenty.
 884   address current = *native_function;
 885   if (current == function) return;
 886   if (post_event_flag &amp;&amp; JvmtiExport::should_post_native_method_bind() &amp;&amp;
 887       function != NULL) {
 888     // native_method_throw_unsatisfied_link_error_entry() should only
 889     // be passed when post_event_flag is false.
 890     assert(function !=
 891       SharedRuntime::native_method_throw_unsatisfied_link_error_entry(),
</pre>
<hr />
<pre>
1020 void Method::set_not_osr_compilable(const char* reason, int comp_level, bool report) {
1021   print_made_not_compilable(comp_level, /*is_osr*/ true, report, reason);
1022   if (comp_level == CompLevel_all) {
1023     set_not_c1_osr_compilable();
1024     set_not_c2_osr_compilable();
1025   } else {
1026     if (is_c1_compile(comp_level))
1027       set_not_c1_osr_compilable();
1028     if (is_c2_compile(comp_level))
1029       set_not_c2_osr_compilable();
1030   }
1031   assert(!CompilationPolicy::can_be_osr_compiled(methodHandle(Thread::current(), this), comp_level), &quot;sanity check&quot;);
1032 }
1033 
1034 // Revert to using the interpreter and clear out the nmethod
1035 void Method::clear_code() {
1036   // this may be NULL if c2i adapters have not been made yet
1037   // Only should happen at allocate time.
1038   if (adapter() == NULL) {
1039     _from_compiled_entry    = NULL;


1040   } else {
1041     _from_compiled_entry    = adapter()-&gt;get_c2i_entry();


1042   }
1043   OrderAccess::storestore();
1044   _from_interpreted_entry = _i2i_entry;
1045   OrderAccess::storestore();
1046   _code = NULL;
1047 }
1048 
1049 void Method::unlink_code(CompiledMethod *compare) {
1050   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1051   // We need to check if either the _code or _from_compiled_code_entry_point
1052   // refer to this nmethod because there is a race in setting these two fields
1053   // in Method* as seen in bugid 4947125.
1054   // If the vep() points to the zombie nmethod, the memory for the nmethod
1055   // could be flushed and the compiler and vtable stubs could still call
1056   // through it.
1057   if (code() == compare ||
1058       from_compiled_entry() == compare-&gt;verified_entry_point()) {
1059     clear_code();
1060   }
1061 }
</pre>
<hr />
<pre>
1066 }
1067 
1068 #if INCLUDE_CDS
1069 // Called by class data sharing to remove any entry points (which are not shared)
1070 void Method::unlink_method() {
1071   _code = NULL;
1072 
1073   Arguments::assert_is_dumping_archive();
1074   // Set the values to what they should be at run time. Note that
1075   // this Method can no longer be executed during dump time.
1076   _i2i_entry = Interpreter::entry_for_cds_method(methodHandle(Thread::current(), this));
1077   _from_interpreted_entry = _i2i_entry;
1078 
1079   if (DynamicDumpSharedSpaces) {
1080     assert(_from_compiled_entry != NULL, &quot;sanity&quot;);
1081   } else {
1082     // TODO: Simplify the adapter trampoline allocation for static archiving.
1083     //       Remove the use of CDSAdapterHandlerEntry.
1084     CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();
1085     constMethod()-&gt;set_adapter_trampoline(cds_adapter-&gt;get_adapter_trampoline());

1086     _from_compiled_entry = cds_adapter-&gt;get_c2i_entry_trampoline();
1087     assert(*((int*)_from_compiled_entry) == 0,
<span class="line-modified">1088            &quot;must be NULL during dump time, to be initialized at run time&quot;);</span>








1089   }
1090 
1091   if (is_native()) {
1092     *native_function_addr() = NULL;
1093     set_signature_handler(NULL);
1094   }
1095   NOT_PRODUCT(set_compiled_invocation_count(0);)
1096 
1097   set_method_data(NULL);
1098   clear_method_counters();
1099 }
1100 #endif
1101 
1102 /****************************************************************************
1103 // The following illustrates how the entries work for CDS shared Methods:
1104 //
1105 // Our goal is to delay writing into a shared Method until it&#39;s compiled.
1106 // Hence, we want to determine the initial values for _i2i_entry,
1107 // _from_interpreted_entry and _from_compiled_entry during CDS dump time.
1108 //
</pre>
<hr />
<pre>
1221 
1222 address Method::make_adapters(const methodHandle&amp; mh, TRAPS) {
1223   // Adapters for compiled code are made eagerly here.  They are fairly
1224   // small (generally &lt; 100 bytes) and quick to make (and cached and shared)
1225   // so making them eagerly shouldn&#39;t be too expensive.
1226   AdapterHandlerEntry* adapter = AdapterHandlerLibrary::get_adapter(mh);
1227   if (adapter == NULL ) {
1228     if (!is_init_completed()) {
1229       // Don&#39;t throw exceptions during VM initialization because java.lang.* classes
1230       // might not have been initialized, causing problems when constructing the
1231       // Java exception object.
1232       vm_exit_during_initialization(&quot;Out of space in CodeCache for adapters&quot;);
1233     } else {
1234       THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(), &quot;Out of space in CodeCache for adapters&quot;);
1235     }
1236   }
1237 
1238   if (mh-&gt;is_shared()) {
1239     assert(mh-&gt;adapter() == adapter, &quot;must be&quot;);
1240     assert(mh-&gt;_from_compiled_entry != NULL, &quot;must be&quot;);


1241   } else {
1242     mh-&gt;set_adapter_entry(adapter);
1243     mh-&gt;_from_compiled_entry = adapter-&gt;get_c2i_entry();


1244   }
1245   return adapter-&gt;get_c2i_entry();
1246 }
1247 
1248 void Method::restore_unshareable_info(TRAPS) {
1249   assert(is_method() &amp;&amp; is_valid_method(this), &quot;ensure C++ vtable is restored&quot;);
1250 












1251   // Since restore_unshareable_info can be called more than once for a method, don&#39;t
1252   // redo any work.
1253   if (adapter() == NULL) {
1254     methodHandle mh(THREAD, this);
1255     link_method(mh, CHECK);
1256   }

1257 }
1258 
<span class="line-modified">1259 address Method::from_compiled_entry_no_trampoline() const {</span>
1260   CompiledMethod *code = Atomic::load_acquire(&amp;_code);
<span class="line-modified">1261   if (code) {</span>
<span class="line-modified">1262     return code-&gt;verified_entry_point();</span>





1263   } else {
<span class="line-modified">1264     return adapter()-&gt;get_c2i_entry();</span>





1265   }
1266 }
1267 
1268 // The verified_code_entry() must be called when a invoke is resolved
1269 // on this method.
1270 
1271 // It returns the compiled code entry point, after asserting not null.
1272 // This function is called after potential safepoints so that nmethod
1273 // or adapter that it points to is still live and valid.
1274 // This function must not hit a safepoint!
1275 address Method::verified_code_entry() {
1276   debug_only(NoSafepointVerifier nsv;)
1277   assert(_from_compiled_entry != NULL, &quot;must be set&quot;);
1278   return _from_compiled_entry;
1279 }
1280 












1281 // Check that if an nmethod ref exists, it has a backlink to this or no backlink at all
1282 // (could be racing a deopt).
1283 // Not inline to avoid circular ref.
1284 bool Method::check_code() const {
1285   // cached in a register or local.  There&#39;s a race on the value of the field.
1286   CompiledMethod *code = Atomic::load_acquire(&amp;_code);
1287   return code == NULL || (code-&gt;method() == NULL) || (code-&gt;method() == (Method*)this &amp;&amp; !code-&gt;is_osr_method());
1288 }
1289 
1290 // Install compiled code.  Instantly it can execute.
1291 void Method::set_code(const methodHandle&amp; mh, CompiledMethod *code) {
1292   assert_lock_strong(CompiledMethod_lock);
1293   assert( code, &quot;use clear_code to remove code&quot; );
1294   assert( mh-&gt;check_code(), &quot;&quot; );
1295 
1296   guarantee(mh-&gt;adapter() != NULL, &quot;Adapter blob must already exist!&quot;);
1297 
1298   // These writes must happen in this order, because the interpreter will
1299   // directly jump to from_interpreted_entry which jumps to an i2c adapter
1300   // which jumps to _from_compiled_entry.
1301   mh-&gt;_code = code;             // Assign before allowing compiled code to exec
1302 
1303   int comp_level = code-&gt;comp_level();
1304   // In theory there could be a race here. In practice it is unlikely
1305   // and not worth worrying about.
1306   if (comp_level &gt; mh-&gt;highest_comp_level()) {
1307     mh-&gt;set_highest_comp_level(comp_level);
1308   }
1309 
1310   OrderAccess::storestore();
1311   mh-&gt;_from_compiled_entry = code-&gt;verified_entry_point();


1312   OrderAccess::storestore();
1313   // Instantly compiled code can execute.
1314   if (!mh-&gt;is_method_handle_intrinsic())
1315     mh-&gt;_from_interpreted_entry = mh-&gt;get_i2c_entry();
1316 }
1317 
1318 
1319 bool Method::is_overridden_in(Klass* k) const {
1320   InstanceKlass* ik = InstanceKlass::cast(k);
1321 
1322   if (ik-&gt;is_interface()) return false;
1323 
1324   // If method is an interface, we skip it - except if it
1325   // is a miranda method
1326   if (method_holder()-&gt;is_interface()) {
1327     // Check that method is not a miranda method
1328     if (ik-&gt;lookup_method(name(), signature()) == NULL) {
1329       // No implementation exist - so miranda method
1330       return false;
1331     }
</pre>
<hr />
<pre>
2323 void Method::print_on(outputStream* st) const {
2324   ResourceMark rm;
2325   assert(is_method(), &quot;must be method&quot;);
2326   st-&gt;print_cr(&quot;%s&quot;, internal_name());
2327   st-&gt;print_cr(&quot; - this oop:          &quot; INTPTR_FORMAT, p2i(this));
2328   st-&gt;print   (&quot; - method holder:     &quot;); method_holder()-&gt;print_value_on(st); st-&gt;cr();
2329   st-&gt;print   (&quot; - constants:         &quot; INTPTR_FORMAT &quot; &quot;, p2i(constants()));
2330   constants()-&gt;print_value_on(st); st-&gt;cr();
2331   st-&gt;print   (&quot; - access:            0x%x  &quot;, access_flags().as_int()); access_flags().print_on(st); st-&gt;cr();
2332   st-&gt;print   (&quot; - name:              &quot;);    name()-&gt;print_value_on(st); st-&gt;cr();
2333   st-&gt;print   (&quot; - signature:         &quot;);    signature()-&gt;print_value_on(st); st-&gt;cr();
2334   st-&gt;print_cr(&quot; - max stack:         %d&quot;,   max_stack());
2335   st-&gt;print_cr(&quot; - max locals:        %d&quot;,   max_locals());
2336   st-&gt;print_cr(&quot; - size of params:    %d&quot;,   size_of_parameters());
2337   st-&gt;print_cr(&quot; - method size:       %d&quot;,   method_size());
2338   if (intrinsic_id() != vmIntrinsics::_none)
2339     st-&gt;print_cr(&quot; - intrinsic id:      %d %s&quot;, intrinsic_id(), vmIntrinsics::name_at(intrinsic_id()));
2340   if (highest_comp_level() != CompLevel_none)
2341     st-&gt;print_cr(&quot; - highest level:     %d&quot;, highest_comp_level());
2342   st-&gt;print_cr(&quot; - vtable index:      %d&quot;,   _vtable_index);


2343   st-&gt;print_cr(&quot; - i2i entry:         &quot; INTPTR_FORMAT, p2i(interpreter_entry()));
2344   st-&gt;print(   &quot; - adapters:          &quot;);
2345   AdapterHandlerEntry* a = ((Method*)this)-&gt;adapter();
2346   if (a == NULL)
2347     st-&gt;print_cr(INTPTR_FORMAT, p2i(a));
2348   else
2349     a-&gt;print_adapter_on(st);
2350   st-&gt;print_cr(&quot; - compiled entry     &quot; INTPTR_FORMAT, p2i(from_compiled_entry()));
2351   st-&gt;print_cr(&quot; - code size:         %d&quot;,   code_size());
2352   if (code_size() != 0) {
2353     st-&gt;print_cr(&quot; - code start:        &quot; INTPTR_FORMAT, p2i(code_base()));
2354     st-&gt;print_cr(&quot; - code end (excl):   &quot; INTPTR_FORMAT, p2i(code_base() + code_size()));
2355   }
2356   if (method_data() != NULL) {
2357     st-&gt;print_cr(&quot; - method data:       &quot; INTPTR_FORMAT, p2i(method_data()));
2358   }
2359   st-&gt;print_cr(&quot; - checked ex length: %d&quot;,   checked_exceptions_length());
2360   if (checked_exceptions_length() &gt; 0) {
2361     CheckedExceptionElement* table = checked_exceptions_start();
2362     st-&gt;print_cr(&quot; - checked ex start:  &quot; INTPTR_FORMAT, p2i(table));
</pre>
<hr />
<pre>
2400     st-&gt;print_cr(&quot; - signature handler: &quot; INTPTR_FORMAT, p2i(signature_handler()));
2401   }
2402 }
2403 
2404 void Method::print_linkage_flags(outputStream* st) {
2405   access_flags().print_on(st);
2406   if (is_default_method()) {
2407     st-&gt;print(&quot;default &quot;);
2408   }
2409   if (is_overpass()) {
2410     st-&gt;print(&quot;overpass &quot;);
2411   }
2412 }
2413 #endif //PRODUCT
2414 
2415 void Method::print_value_on(outputStream* st) const {
2416   assert(is_method(), &quot;must be method&quot;);
2417   st-&gt;print(&quot;%s&quot;, internal_name());
2418   print_address_on(st);
2419   st-&gt;print(&quot; &quot;);

2420   name()-&gt;print_value_on(st);
2421   st-&gt;print(&quot; &quot;);
2422   signature()-&gt;print_value_on(st);
2423   st-&gt;print(&quot; in &quot;);
2424   method_holder()-&gt;print_value_on(st);
2425   if (WizardMode) st-&gt;print(&quot;#%d&quot;, _vtable_index);
2426   if (WizardMode) st-&gt;print(&quot;[%d,%d]&quot;, size_of_parameters(), max_locals());
2427   if (WizardMode &amp;&amp; code() != NULL) st-&gt;print(&quot; ((nmethod*)%p)&quot;, code());
2428 }
2429 
2430 // LogTouchedMethods and PrintTouchedMethods
2431 
2432 // TouchedMethodRecord -- we can&#39;t use a HashtableEntry&lt;Method*&gt; because
2433 // the Method may be garbage collected. Let&#39;s roll our own hash table.
2434 class TouchedMethodRecord : CHeapObj&lt;mtTracing&gt; {
2435 public:
2436   // It&#39;s OK to store Symbols here because they will NOT be GC&#39;ed if
2437   // LogTouchedMethods is enabled.
2438   TouchedMethodRecord* _next;
2439   Symbol* _class_name;
</pre>
</td>
<td>
<hr />
<pre>
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;interpreter/oopMapCache.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;logging/logTag.hpp&quot;
  41 #include &quot;logging/logStream.hpp&quot;
  42 #include &quot;memory/allocation.inline.hpp&quot;
  43 #include &quot;memory/metadataFactory.hpp&quot;
  44 #include &quot;memory/metaspaceClosure.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/constMethod.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/method.inline.hpp&quot;
  52 #include &quot;oops/methodData.hpp&quot;
  53 #include &quot;oops/objArrayKlass.hpp&quot;
  54 #include &quot;oops/objArrayOop.inline.hpp&quot;
  55 #include &quot;oops/oop.inline.hpp&quot;
  56 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  57 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  58 #include &quot;prims/jvmtiExport.hpp&quot;
  59 #include &quot;prims/methodHandles.hpp&quot;
  60 #include &quot;prims/nativeLookup.hpp&quot;
  61 #include &quot;runtime/arguments.hpp&quot;
  62 #include &quot;runtime/atomic.hpp&quot;
  63 #include &quot;runtime/frame.inline.hpp&quot;
  64 #include &quot;runtime/handles.inline.hpp&quot;
  65 #include &quot;runtime/init.hpp&quot;
  66 #include &quot;runtime/orderAccess.hpp&quot;
  67 #include &quot;runtime/relocator.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/sharedRuntime.hpp&quot;
  70 #include &quot;runtime/signature.hpp&quot;
  71 #include &quot;utilities/align.hpp&quot;
  72 #include &quot;utilities/quickSort.hpp&quot;
  73 #include &quot;utilities/vmError.hpp&quot;
  74 #include &quot;utilities/xmlstream.hpp&quot;
  75 
  76 // Implementation of Method
  77 
</pre>
<hr />
<pre>
  97   set_constMethod(xconst);
  98   set_access_flags(access_flags);
  99   set_intrinsic_id(vmIntrinsics::_none);
 100   set_force_inline(false);
 101   set_hidden(false);
 102   set_dont_inline(false);
 103   set_has_injected_profile(false);
 104   set_method_data(NULL);
 105   clear_method_counters();
 106   set_vtable_index(Method::garbage_vtable_index);
 107 
 108   // Fix and bury in Method*
 109   set_interpreter_entry(NULL); // sets i2i entry and from_int
 110   set_adapter_entry(NULL);
 111   Method::clear_code(); // from_c/from_i get set to c2i/i2i
 112 
 113   if (access_flags.is_native()) {
 114     clear_native_function();
 115     set_signature_handler(NULL);
 116   }

 117   NOT_PRODUCT(set_compiled_invocation_count(0);)
 118 }
 119 
 120 // Release Method*.  The nmethod will be gone when we get here because
 121 // we&#39;ve walked the code cache.
 122 void Method::deallocate_contents(ClassLoaderData* loader_data) {
 123   MetadataFactory::free_metadata(loader_data, constMethod());
 124   set_constMethod(NULL);
 125   MetadataFactory::free_metadata(loader_data, method_data());
 126   set_method_data(NULL);
 127   MetadataFactory::free_metadata(loader_data, method_counters());
 128   clear_method_counters();
 129   // The nmethod will be gone when we get here.
 130   if (code() != NULL) _code = NULL;
 131 }
 132 
 133 void Method::release_C_heap_structures() {
 134   if (method_data()) {
 135 #if INCLUDE_JVMCI
 136     FailedSpeculation::free_failed_speculations(method_data()-&gt;get_failed_speculations_address());
 137 #endif
 138     // Destroy MethodData
 139     method_data()-&gt;~MethodData();
 140   }
 141 }
 142 
 143 address Method::get_i2c_entry() {
 144   assert(adapter() != NULL, &quot;must have&quot;);
 145   return adapter()-&gt;get_i2c_entry();
 146 }
 147 
 148 address Method::get_c2i_entry() {
 149   assert(adapter() != NULL, &quot;must have&quot;);
 150   return adapter()-&gt;get_c2i_entry();
 151 }
 152 
<span class="line-added"> 153 address Method::get_c2i_value_entry() {</span>
<span class="line-added"> 154   assert(adapter() != NULL, &quot;must have&quot;);</span>
<span class="line-added"> 155   return adapter()-&gt;get_c2i_value_entry();</span>
<span class="line-added"> 156 }</span>
<span class="line-added"> 157 </span>
 158 address Method::get_c2i_unverified_entry() {
 159   assert(adapter() != NULL, &quot;must have&quot;);
 160   return adapter()-&gt;get_c2i_unverified_entry();
 161 }
 162 
<span class="line-added"> 163 address Method::get_c2i_unverified_value_entry() {</span>
<span class="line-added"> 164   assert(adapter() != NULL, &quot;must have&quot;);</span>
<span class="line-added"> 165   return adapter()-&gt;get_c2i_unverified_value_entry();</span>
<span class="line-added"> 166 }</span>
<span class="line-added"> 167 </span>
 168 address Method::get_c2i_no_clinit_check_entry() {
 169   assert(VM_Version::supports_fast_class_init_checks(), &quot;&quot;);
 170   assert(adapter() != NULL, &quot;must have&quot;);
 171   return adapter()-&gt;get_c2i_no_clinit_check_entry();
 172 }
 173 
 174 char* Method::name_and_sig_as_C_string() const {
 175   return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature());
 176 }
 177 
 178 char* Method::name_and_sig_as_C_string(char* buf, int size) const {
 179   return name_and_sig_as_C_string(constants()-&gt;pool_holder(), name(), signature(), buf, size);
 180 }
 181 
 182 char* Method::name_and_sig_as_C_string(Klass* klass, Symbol* method_name, Symbol* signature) {
 183   const char* klass_name = klass-&gt;external_name();
 184   int klass_name_len  = (int)strlen(klass_name);
 185   int method_name_len = method_name-&gt;utf8_length();
 186   int len             = klass_name_len + 1 + method_name_len + signature-&gt;utf8_length();
 187   char* dest          = NEW_RESOURCE_ARRAY(char, len + 1);
</pre>
<hr />
<pre>
 340   // If native, then include pointers for native_function and signature_handler
 341   int extra_bytes = (is_native) ? 2*sizeof(address*) : 0;
 342   int extra_words = align_up(extra_bytes, BytesPerWord) / BytesPerWord;
 343   return align_metadata_size(header_size() + extra_words);
 344 }
 345 
 346 Symbol* Method::klass_name() const {
 347   return method_holder()-&gt;name();
 348 }
 349 
 350 void Method::metaspace_pointers_do(MetaspaceClosure* it) {
 351   log_trace(cds)(&quot;Iter(Method): %p&quot;, this);
 352 
 353   it-&gt;push(&amp;_constMethod);
 354   it-&gt;push(&amp;_method_data);
 355   it-&gt;push(&amp;_method_counters);
 356 
 357   Method* this_ptr = this;
 358   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_i2i_entry);
 359   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_entry);
<span class="line-added"> 360   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_value_ro_entry);</span>
<span class="line-added"> 361   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_value_entry);</span>
 362   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_interpreted_entry);
 363 }
 364 
 365 // Attempt to return method oop to original state.  Clear any pointers
 366 // (to objects outside the shared spaces).  We won&#39;t be able to predict
 367 // where they should point in a new JVM.  Further initialize some
 368 // entries now in order allow them to be write protected later.
 369 
 370 void Method::remove_unshareable_info() {
 371   unlink_method();
 372 }
 373 
 374 void Method::set_vtable_index(int index) {
 375   if (is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite()) {
 376     // At runtime initialize_vtable is rerun as part of link_class_impl()
 377     // for a shared class loaded by the non-boot loader to obtain the loader
 378     // constraints based on the runtime classloaders&#39; context.
 379     return; // don&#39;t write into the shared class
 380   } else {
 381     _vtable_index = index;
</pre>
<hr />
<pre>
 585   return Atomic::replace_if_null(&amp;_method_counters, counters);
 586 }
 587 
 588 int Method::extra_stack_words() {
 589   // not an inline function, to avoid a header dependency on Interpreter
 590   return extra_stack_entries() * Interpreter::stackElementSize;
 591 }
 592 
 593 // Derive size of parameters, return type, and fingerprint,
 594 // all in one pass, which is run at load time.
 595 // We need the first two, and might as well grab the third.
 596 void Method::compute_from_signature(Symbol* sig) {
 597   // At this point, since we are scanning the signature,
 598   // we might as well compute the whole fingerprint.
 599   Fingerprinter fp(sig, is_static());
 600   set_size_of_parameters(fp.size_of_parameters());
 601   constMethod()-&gt;set_result_type(fp.return_type());
 602   constMethod()-&gt;set_fingerprint(fp.fingerprint());
 603 }
 604 
<span class="line-added"> 605 // ValueKlass the method is declared to return. This must not</span>
<span class="line-added"> 606 // safepoint as it is called with references live on the stack at</span>
<span class="line-added"> 607 // locations the GC is unaware of.</span>
<span class="line-added"> 608 ValueKlass* Method::returned_value_type(Thread* thread) const {</span>
<span class="line-added"> 609   SignatureStream ss(signature());</span>
<span class="line-added"> 610   while (!ss.at_return_type()) {</span>
<span class="line-added"> 611     ss.next();</span>
<span class="line-added"> 612   }</span>
<span class="line-added"> 613   Handle class_loader(thread, method_holder()-&gt;class_loader());</span>
<span class="line-added"> 614   Handle protection_domain(thread, method_holder()-&gt;protection_domain());</span>
<span class="line-added"> 615   Klass* k = NULL;</span>
<span class="line-added"> 616   {</span>
<span class="line-added"> 617     NoSafepointVerifier nsv;</span>
<span class="line-added"> 618     k = ss.as_klass(class_loader, protection_domain, SignatureStream::ReturnNull, thread);</span>
<span class="line-added"> 619   }</span>
<span class="line-added"> 620   assert(k != NULL &amp;&amp; !thread-&gt;has_pending_exception(), &quot;can&#39;t resolve klass&quot;);</span>
<span class="line-added"> 621   return ValueKlass::cast(k);</span>
<span class="line-added"> 622 }</span>
 623 bool Method::is_empty_method() const {
 624   return  code_size() == 1
 625       &amp;&amp; *code_base() == Bytecodes::_return;
 626 }
 627 
 628 bool Method::is_vanilla_constructor() const {
 629   // Returns true if this method is a vanilla constructor, i.e. an &quot;&lt;init&gt;&quot; &quot;()V&quot; method
 630   // which only calls the superclass vanilla constructor and possibly does stores of
 631   // zero constants to local fields:
 632   //
<span class="line-modified"> 633   //   aload_0, _fast_aload_0, or _nofast_aload_0</span>
 634   //   invokespecial
 635   //   indexbyte1
 636   //   indexbyte2
 637   //
 638   // followed by an (optional) sequence of:
 639   //
 640   //   aload_0
 641   //   aconst_null / iconst_0 / fconst_0 / dconst_0
 642   //   putfield
 643   //   indexbyte1
 644   //   indexbyte2
 645   //
 646   // followed by:
 647   //
 648   //   return
 649 
 650   assert(name() == vmSymbols::object_initializer_name(),    &quot;Should only be called for default constructors&quot;);
 651   assert(signature() == vmSymbols::void_method_signature(), &quot;Should only be called for default constructors&quot;);
 652   int size = code_size();
 653   // Check if size match
 654   if (size == 0 || size % 5 != 0) return false;
 655   address cb = code_base();
 656   int last = size - 1;
<span class="line-modified"> 657   if ((cb[0] != Bytecodes::_aload_0 &amp;&amp; cb[0] != Bytecodes::_fast_aload_0 &amp;&amp; cb[0] != Bytecodes::_nofast_aload_0) ||</span>
<span class="line-added"> 658        cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {</span>
 659     // Does not call superclass default constructor
 660     return false;
 661   }
 662   // Check optional sequence
 663   for (int i = 4; i &lt; last; i += 5) {
 664     if (cb[i] != Bytecodes::_aload_0) return false;
 665     if (!Bytecodes::is_zero_const(Bytecodes::cast(cb[i+1]))) return false;
 666     if (cb[i+2] != Bytecodes::_putfield) return false;
 667   }
 668   return true;
 669 }
 670 
 671 
 672 bool Method::compute_has_loops_flag() {
 673   BytecodeStream bcs(methodHandle(Thread::current(), this));
 674   Bytecodes::Code bc;
 675 
 676   while ((bc = bcs.next()) &gt;= 0) {
 677     switch( bc ) {
 678       case Bytecodes::_ifeq:
</pre>
<hr />
<pre>
 790       if (size_of_parameters() != 3) return false;
 791       break;
 792     default:
 793       return false;
 794   }
 795   if (java_code_at(2) != Bytecodes::_putfield) return false;
 796   if (java_code_at(5) != Bytecodes::_return)   return false;
 797   return true;
 798 }
 799 
 800 bool Method::is_constant_getter() const {
 801   int last_index = code_size() - 1;
 802   // Check if the first 1-3 bytecodes are a constant push
 803   // and the last bytecode is a return.
 804   return (2 &lt;= code_size() &amp;&amp; code_size() &lt;= 4 &amp;&amp;
 805           Bytecodes::is_const(java_code_at(0)) &amp;&amp;
 806           Bytecodes::length_for(java_code_at(0)) == last_index &amp;&amp;
 807           Bytecodes::is_return(java_code_at(last_index)));
 808 }
 809 
<span class="line-modified"> 810 bool Method::is_object_constructor_or_class_initializer() const {</span>
<span class="line-modified"> 811   return (is_object_constructor() || is_class_initializer());</span>





 812 }
 813 
<span class="line-modified"> 814 bool Method::is_class_initializer() const {</span>
 815   // For classfiles version 51 or greater, ensure that the clinit method is
 816   // static.  Non-static methods with the name &quot;&lt;clinit&gt;&quot; are not static
 817   // initializers. (older classfiles exempted for backward compatibility)
<span class="line-modified"> 818   return (name() == vmSymbols::class_initializer_name() &amp;&amp;</span>
<span class="line-modified"> 819           (is_static() ||</span>
<span class="line-added"> 820            method_holder()-&gt;major_version() &lt; 51));</span>
<span class="line-added"> 821 }</span>
<span class="line-added"> 822 </span>
<span class="line-added"> 823 // A method named &lt;init&gt;, if non-static, is a classic object constructor.</span>
<span class="line-added"> 824 bool Method::is_object_constructor() const {</span>
<span class="line-added"> 825    return name() == vmSymbols::object_initializer_name() &amp;&amp; !is_static();</span>
 826 }
 827 
<span class="line-modified"> 828 // A static method named &lt;init&gt; is a factory for an inline class.</span>
<span class="line-modified"> 829 bool Method::is_static_init_factory() const {</span>
<span class="line-added"> 830    return name() == vmSymbols::object_initializer_name() &amp;&amp; is_static();</span>
 831 }
 832 
 833 bool Method::needs_clinit_barrier() const {
 834   return is_static() &amp;&amp; !method_holder()-&gt;is_initialized();
 835 }
 836 
 837 objArrayHandle Method::resolved_checked_exceptions_impl(Method* method, TRAPS) {
 838   int length = method-&gt;checked_exceptions_length();
 839   if (length == 0) {  // common case
 840     return objArrayHandle(THREAD, Universe::the_empty_class_klass_array());
 841   } else {
 842     methodHandle h_this(THREAD, method);
 843     objArrayOop m_oop = oopFactory::new_objArray(SystemDictionary::Class_klass(), length, CHECK_(objArrayHandle()));
 844     objArrayHandle mirrors (THREAD, m_oop);
 845     for (int i = 0; i &lt; length; i++) {
 846       CheckedExceptionElement* table = h_this-&gt;checked_exceptions_start(); // recompute on each iteration, not gc safe
 847       Klass* k = h_this-&gt;constants()-&gt;klass_at(table[i].class_cp_index, CHECK_(objArrayHandle()));
 848       if (log_is_enabled(Warning, exceptions) &amp;&amp;
 849           !k-&gt;is_subclass_of(SystemDictionary::Throwable_klass())) {
 850         ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
 868     // Not necessarily sorted and not necessarily one-to-one.
 869     CompressedLineNumberReadStream stream(compressed_linenumber_table());
 870     while (stream.read_pair()) {
 871       if (stream.bci() == bci) {
 872         // perfect match
 873         return stream.line();
 874       } else {
 875         // update best_bci/line
 876         if (stream.bci() &lt; bci &amp;&amp; stream.bci() &gt;= best_bci) {
 877           best_bci  = stream.bci();
 878           best_line = stream.line();
 879         }
 880       }
 881     }
 882   }
 883   return best_line;
 884 }
 885 
 886 
 887 bool Method::is_klass_loaded_by_klass_index(int klass_index) const {
<span class="line-modified"> 888   if( constants()-&gt;tag_at(klass_index).is_unresolved_klass()) {</span>
 889     Thread *thread = Thread::current();
 890     Symbol* klass_name = constants()-&gt;klass_name_at(klass_index);
 891     Handle loader(thread, method_holder()-&gt;class_loader());
 892     Handle prot  (thread, method_holder()-&gt;protection_domain());
 893     return SystemDictionary::find(klass_name, loader, prot, thread) != NULL;
 894   } else {
 895     return true;
 896   }
 897 }
 898 
 899 
 900 bool Method::is_klass_loaded(int refinfo_index, bool must_be_resolved) const {
 901   int klass_index = constants()-&gt;klass_ref_index_at(refinfo_index);
 902   if (must_be_resolved) {
 903     // Make sure klass is resolved in constantpool.
<span class="line-modified"> 904     if (constants()-&gt;tag_at(klass_index).is_unresolved_klass()) {</span>
<span class="line-added"> 905       return false;</span>
<span class="line-added"> 906     }</span>
 907   }
 908   return is_klass_loaded_by_klass_index(klass_index);
 909 }
 910 
 911 
 912 void Method::set_native_function(address function, bool post_event_flag) {
 913   assert(function != NULL, &quot;use clear_native_function to unregister natives&quot;);
 914   assert(!is_method_handle_intrinsic() || function == SharedRuntime::native_method_throw_unsatisfied_link_error_entry(), &quot;&quot;);
 915   address* native_function = native_function_addr();
 916 
 917   // We can see racers trying to place the same native function into place. Once
 918   // is plenty.
 919   address current = *native_function;
 920   if (current == function) return;
 921   if (post_event_flag &amp;&amp; JvmtiExport::should_post_native_method_bind() &amp;&amp;
 922       function != NULL) {
 923     // native_method_throw_unsatisfied_link_error_entry() should only
 924     // be passed when post_event_flag is false.
 925     assert(function !=
 926       SharedRuntime::native_method_throw_unsatisfied_link_error_entry(),
</pre>
<hr />
<pre>
1055 void Method::set_not_osr_compilable(const char* reason, int comp_level, bool report) {
1056   print_made_not_compilable(comp_level, /*is_osr*/ true, report, reason);
1057   if (comp_level == CompLevel_all) {
1058     set_not_c1_osr_compilable();
1059     set_not_c2_osr_compilable();
1060   } else {
1061     if (is_c1_compile(comp_level))
1062       set_not_c1_osr_compilable();
1063     if (is_c2_compile(comp_level))
1064       set_not_c2_osr_compilable();
1065   }
1066   assert(!CompilationPolicy::can_be_osr_compiled(methodHandle(Thread::current(), this), comp_level), &quot;sanity check&quot;);
1067 }
1068 
1069 // Revert to using the interpreter and clear out the nmethod
1070 void Method::clear_code() {
1071   // this may be NULL if c2i adapters have not been made yet
1072   // Only should happen at allocate time.
1073   if (adapter() == NULL) {
1074     _from_compiled_entry    = NULL;
<span class="line-added">1075     _from_compiled_value_entry = NULL;</span>
<span class="line-added">1076     _from_compiled_value_ro_entry = NULL;</span>
1077   } else {
1078     _from_compiled_entry    = adapter()-&gt;get_c2i_entry();
<span class="line-added">1079     _from_compiled_value_entry = adapter()-&gt;get_c2i_value_entry();</span>
<span class="line-added">1080     _from_compiled_value_ro_entry = adapter()-&gt;get_c2i_value_ro_entry();</span>
1081   }
1082   OrderAccess::storestore();
1083   _from_interpreted_entry = _i2i_entry;
1084   OrderAccess::storestore();
1085   _code = NULL;
1086 }
1087 
1088 void Method::unlink_code(CompiledMethod *compare) {
1089   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1090   // We need to check if either the _code or _from_compiled_code_entry_point
1091   // refer to this nmethod because there is a race in setting these two fields
1092   // in Method* as seen in bugid 4947125.
1093   // If the vep() points to the zombie nmethod, the memory for the nmethod
1094   // could be flushed and the compiler and vtable stubs could still call
1095   // through it.
1096   if (code() == compare ||
1097       from_compiled_entry() == compare-&gt;verified_entry_point()) {
1098     clear_code();
1099   }
1100 }
</pre>
<hr />
<pre>
1105 }
1106 
1107 #if INCLUDE_CDS
1108 // Called by class data sharing to remove any entry points (which are not shared)
1109 void Method::unlink_method() {
1110   _code = NULL;
1111 
1112   Arguments::assert_is_dumping_archive();
1113   // Set the values to what they should be at run time. Note that
1114   // this Method can no longer be executed during dump time.
1115   _i2i_entry = Interpreter::entry_for_cds_method(methodHandle(Thread::current(), this));
1116   _from_interpreted_entry = _i2i_entry;
1117 
1118   if (DynamicDumpSharedSpaces) {
1119     assert(_from_compiled_entry != NULL, &quot;sanity&quot;);
1120   } else {
1121     // TODO: Simplify the adapter trampoline allocation for static archiving.
1122     //       Remove the use of CDSAdapterHandlerEntry.
1123     CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();
1124     constMethod()-&gt;set_adapter_trampoline(cds_adapter-&gt;get_adapter_trampoline());
<span class="line-added">1125 </span>
1126     _from_compiled_entry = cds_adapter-&gt;get_c2i_entry_trampoline();
1127     assert(*((int*)_from_compiled_entry) == 0,
<span class="line-modified">1128            &quot;instructions must be zeros during dump time, to be initialized at run time&quot;);</span>
<span class="line-added">1129 </span>
<span class="line-added">1130     _from_compiled_value_ro_entry = cds_adapter-&gt;get_c2i_value_ro_entry_trampoline();</span>
<span class="line-added">1131     assert(*((int*)_from_compiled_value_ro_entry) == 0,</span>
<span class="line-added">1132            &quot;instructions must be zeros during dump time, to be initialized at run time&quot;);</span>
<span class="line-added">1133 </span>
<span class="line-added">1134     _from_compiled_value_entry = cds_adapter-&gt;get_c2i_value_entry_trampoline();</span>
<span class="line-added">1135     assert(*((int*)_from_compiled_value_entry) == 0,</span>
<span class="line-added">1136            &quot;instructions must be zeros during dump time, to be initialized at run time&quot;);</span>
1137   }
1138 
1139   if (is_native()) {
1140     *native_function_addr() = NULL;
1141     set_signature_handler(NULL);
1142   }
1143   NOT_PRODUCT(set_compiled_invocation_count(0);)
1144 
1145   set_method_data(NULL);
1146   clear_method_counters();
1147 }
1148 #endif
1149 
1150 /****************************************************************************
1151 // The following illustrates how the entries work for CDS shared Methods:
1152 //
1153 // Our goal is to delay writing into a shared Method until it&#39;s compiled.
1154 // Hence, we want to determine the initial values for _i2i_entry,
1155 // _from_interpreted_entry and _from_compiled_entry during CDS dump time.
1156 //
</pre>
<hr />
<pre>
1269 
1270 address Method::make_adapters(const methodHandle&amp; mh, TRAPS) {
1271   // Adapters for compiled code are made eagerly here.  They are fairly
1272   // small (generally &lt; 100 bytes) and quick to make (and cached and shared)
1273   // so making them eagerly shouldn&#39;t be too expensive.
1274   AdapterHandlerEntry* adapter = AdapterHandlerLibrary::get_adapter(mh);
1275   if (adapter == NULL ) {
1276     if (!is_init_completed()) {
1277       // Don&#39;t throw exceptions during VM initialization because java.lang.* classes
1278       // might not have been initialized, causing problems when constructing the
1279       // Java exception object.
1280       vm_exit_during_initialization(&quot;Out of space in CodeCache for adapters&quot;);
1281     } else {
1282       THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(), &quot;Out of space in CodeCache for adapters&quot;);
1283     }
1284   }
1285 
1286   if (mh-&gt;is_shared()) {
1287     assert(mh-&gt;adapter() == adapter, &quot;must be&quot;);
1288     assert(mh-&gt;_from_compiled_entry != NULL, &quot;must be&quot;);
<span class="line-added">1289     assert(mh-&gt;_from_compiled_value_entry != NULL, &quot;must be&quot;);</span>
<span class="line-added">1290     assert(mh-&gt;_from_compiled_value_ro_entry != NULL, &quot;must be&quot;);</span>
1291   } else {
1292     mh-&gt;set_adapter_entry(adapter);
1293     mh-&gt;_from_compiled_entry = adapter-&gt;get_c2i_entry();
<span class="line-added">1294     mh-&gt;_from_compiled_value_entry = adapter-&gt;get_c2i_value_entry();</span>
<span class="line-added">1295     mh-&gt;_from_compiled_value_ro_entry = adapter-&gt;get_c2i_value_ro_entry();</span>
1296   }
1297   return adapter-&gt;get_c2i_entry();
1298 }
1299 
1300 void Method::restore_unshareable_info(TRAPS) {
1301   assert(is_method() &amp;&amp; is_valid_method(this), &quot;ensure C++ vtable is restored&quot;);
1302 
<span class="line-added">1303 #if 0</span>
<span class="line-added">1304   /*</span>
<span class="line-added">1305    * CDS:TODO --</span>
<span class="line-added">1306    * &quot;Q&quot; classes in the method signature must be resolved during link_method.</span>
<span class="line-added">1307    * However, at this point we are still inside method_holder()-&gt;restore_unshareable_info.</span>
<span class="line-added">1308    * If we try to resolve method_holder(), or multually dependent classes, it will</span>
<span class="line-added">1309    * cause deadlock and other ill effects.</span>
<span class="line-added">1310    *</span>
<span class="line-added">1311    * For now, lets do method linking inside InstanceKlass::link_class(). Optimization</span>
<span class="line-added">1312    * may be possible if we know that resolution will never happen.</span>
<span class="line-added">1313    */</span>
<span class="line-added">1314 </span>
1315   // Since restore_unshareable_info can be called more than once for a method, don&#39;t
1316   // redo any work.
1317   if (adapter() == NULL) {
1318     methodHandle mh(THREAD, this);
1319     link_method(mh, CHECK);
1320   }
<span class="line-added">1321 #endif</span>
1322 }
1323 
<span class="line-modified">1324 address Method::from_compiled_entry_no_trampoline(bool caller_is_c1) const {</span>
1325   CompiledMethod *code = Atomic::load_acquire(&amp;_code);
<span class="line-modified">1326   if (caller_is_c1) {</span>
<span class="line-modified">1327     // C1 - value arguments are passed as objects</span>
<span class="line-added">1328     if (code) {</span>
<span class="line-added">1329       return code-&gt;verified_value_entry_point();</span>
<span class="line-added">1330     } else {</span>
<span class="line-added">1331       return adapter()-&gt;get_c2i_value_entry();</span>
<span class="line-added">1332     }</span>
1333   } else {
<span class="line-modified">1334     // C2 - value arguments may be passed as fields</span>
<span class="line-added">1335     if (code) {</span>
<span class="line-added">1336       return code-&gt;verified_entry_point();</span>
<span class="line-added">1337     } else {</span>
<span class="line-added">1338       return adapter()-&gt;get_c2i_entry();</span>
<span class="line-added">1339     }</span>
1340   }
1341 }
1342 
1343 // The verified_code_entry() must be called when a invoke is resolved
1344 // on this method.
1345 
1346 // It returns the compiled code entry point, after asserting not null.
1347 // This function is called after potential safepoints so that nmethod
1348 // or adapter that it points to is still live and valid.
1349 // This function must not hit a safepoint!
1350 address Method::verified_code_entry() {
1351   debug_only(NoSafepointVerifier nsv;)
1352   assert(_from_compiled_entry != NULL, &quot;must be set&quot;);
1353   return _from_compiled_entry;
1354 }
1355 
<span class="line-added">1356 address Method::verified_value_code_entry() {</span>
<span class="line-added">1357   debug_only(NoSafepointVerifier nsv;)</span>
<span class="line-added">1358   assert(_from_compiled_value_entry != NULL, &quot;must be set&quot;);</span>
<span class="line-added">1359   return _from_compiled_value_entry;</span>
<span class="line-added">1360 }</span>
<span class="line-added">1361 </span>
<span class="line-added">1362 address Method::verified_value_ro_code_entry() {</span>
<span class="line-added">1363   debug_only(NoSafepointVerifier nsv;)</span>
<span class="line-added">1364   assert(_from_compiled_value_ro_entry != NULL, &quot;must be set&quot;);</span>
<span class="line-added">1365   return _from_compiled_value_ro_entry;</span>
<span class="line-added">1366 }</span>
<span class="line-added">1367 </span>
1368 // Check that if an nmethod ref exists, it has a backlink to this or no backlink at all
1369 // (could be racing a deopt).
1370 // Not inline to avoid circular ref.
1371 bool Method::check_code() const {
1372   // cached in a register or local.  There&#39;s a race on the value of the field.
1373   CompiledMethod *code = Atomic::load_acquire(&amp;_code);
1374   return code == NULL || (code-&gt;method() == NULL) || (code-&gt;method() == (Method*)this &amp;&amp; !code-&gt;is_osr_method());
1375 }
1376 
1377 // Install compiled code.  Instantly it can execute.
1378 void Method::set_code(const methodHandle&amp; mh, CompiledMethod *code) {
1379   assert_lock_strong(CompiledMethod_lock);
1380   assert( code, &quot;use clear_code to remove code&quot; );
1381   assert( mh-&gt;check_code(), &quot;&quot; );
1382 
1383   guarantee(mh-&gt;adapter() != NULL, &quot;Adapter blob must already exist!&quot;);
1384 
1385   // These writes must happen in this order, because the interpreter will
1386   // directly jump to from_interpreted_entry which jumps to an i2c adapter
1387   // which jumps to _from_compiled_entry.
1388   mh-&gt;_code = code;             // Assign before allowing compiled code to exec
1389 
1390   int comp_level = code-&gt;comp_level();
1391   // In theory there could be a race here. In practice it is unlikely
1392   // and not worth worrying about.
1393   if (comp_level &gt; mh-&gt;highest_comp_level()) {
1394     mh-&gt;set_highest_comp_level(comp_level);
1395   }
1396 
1397   OrderAccess::storestore();
1398   mh-&gt;_from_compiled_entry = code-&gt;verified_entry_point();
<span class="line-added">1399   mh-&gt;_from_compiled_value_entry = code-&gt;verified_value_entry_point();</span>
<span class="line-added">1400   mh-&gt;_from_compiled_value_ro_entry = code-&gt;verified_value_ro_entry_point();</span>
1401   OrderAccess::storestore();
1402   // Instantly compiled code can execute.
1403   if (!mh-&gt;is_method_handle_intrinsic())
1404     mh-&gt;_from_interpreted_entry = mh-&gt;get_i2c_entry();
1405 }
1406 
1407 
1408 bool Method::is_overridden_in(Klass* k) const {
1409   InstanceKlass* ik = InstanceKlass::cast(k);
1410 
1411   if (ik-&gt;is_interface()) return false;
1412 
1413   // If method is an interface, we skip it - except if it
1414   // is a miranda method
1415   if (method_holder()-&gt;is_interface()) {
1416     // Check that method is not a miranda method
1417     if (ik-&gt;lookup_method(name(), signature()) == NULL) {
1418       // No implementation exist - so miranda method
1419       return false;
1420     }
</pre>
<hr />
<pre>
2412 void Method::print_on(outputStream* st) const {
2413   ResourceMark rm;
2414   assert(is_method(), &quot;must be method&quot;);
2415   st-&gt;print_cr(&quot;%s&quot;, internal_name());
2416   st-&gt;print_cr(&quot; - this oop:          &quot; INTPTR_FORMAT, p2i(this));
2417   st-&gt;print   (&quot; - method holder:     &quot;); method_holder()-&gt;print_value_on(st); st-&gt;cr();
2418   st-&gt;print   (&quot; - constants:         &quot; INTPTR_FORMAT &quot; &quot;, p2i(constants()));
2419   constants()-&gt;print_value_on(st); st-&gt;cr();
2420   st-&gt;print   (&quot; - access:            0x%x  &quot;, access_flags().as_int()); access_flags().print_on(st); st-&gt;cr();
2421   st-&gt;print   (&quot; - name:              &quot;);    name()-&gt;print_value_on(st); st-&gt;cr();
2422   st-&gt;print   (&quot; - signature:         &quot;);    signature()-&gt;print_value_on(st); st-&gt;cr();
2423   st-&gt;print_cr(&quot; - max stack:         %d&quot;,   max_stack());
2424   st-&gt;print_cr(&quot; - max locals:        %d&quot;,   max_locals());
2425   st-&gt;print_cr(&quot; - size of params:    %d&quot;,   size_of_parameters());
2426   st-&gt;print_cr(&quot; - method size:       %d&quot;,   method_size());
2427   if (intrinsic_id() != vmIntrinsics::_none)
2428     st-&gt;print_cr(&quot; - intrinsic id:      %d %s&quot;, intrinsic_id(), vmIntrinsics::name_at(intrinsic_id()));
2429   if (highest_comp_level() != CompLevel_none)
2430     st-&gt;print_cr(&quot; - highest level:     %d&quot;, highest_comp_level());
2431   st-&gt;print_cr(&quot; - vtable index:      %d&quot;,   _vtable_index);
<span class="line-added">2432   if (valid_itable_index())</span>
<span class="line-added">2433     st-&gt;print_cr(&quot; - itable index:      %d&quot;,   itable_index());</span>
2434   st-&gt;print_cr(&quot; - i2i entry:         &quot; INTPTR_FORMAT, p2i(interpreter_entry()));
2435   st-&gt;print(   &quot; - adapters:          &quot;);
2436   AdapterHandlerEntry* a = ((Method*)this)-&gt;adapter();
2437   if (a == NULL)
2438     st-&gt;print_cr(INTPTR_FORMAT, p2i(a));
2439   else
2440     a-&gt;print_adapter_on(st);
2441   st-&gt;print_cr(&quot; - compiled entry     &quot; INTPTR_FORMAT, p2i(from_compiled_entry()));
2442   st-&gt;print_cr(&quot; - code size:         %d&quot;,   code_size());
2443   if (code_size() != 0) {
2444     st-&gt;print_cr(&quot; - code start:        &quot; INTPTR_FORMAT, p2i(code_base()));
2445     st-&gt;print_cr(&quot; - code end (excl):   &quot; INTPTR_FORMAT, p2i(code_base() + code_size()));
2446   }
2447   if (method_data() != NULL) {
2448     st-&gt;print_cr(&quot; - method data:       &quot; INTPTR_FORMAT, p2i(method_data()));
2449   }
2450   st-&gt;print_cr(&quot; - checked ex length: %d&quot;,   checked_exceptions_length());
2451   if (checked_exceptions_length() &gt; 0) {
2452     CheckedExceptionElement* table = checked_exceptions_start();
2453     st-&gt;print_cr(&quot; - checked ex start:  &quot; INTPTR_FORMAT, p2i(table));
</pre>
<hr />
<pre>
2491     st-&gt;print_cr(&quot; - signature handler: &quot; INTPTR_FORMAT, p2i(signature_handler()));
2492   }
2493 }
2494 
2495 void Method::print_linkage_flags(outputStream* st) {
2496   access_flags().print_on(st);
2497   if (is_default_method()) {
2498     st-&gt;print(&quot;default &quot;);
2499   }
2500   if (is_overpass()) {
2501     st-&gt;print(&quot;overpass &quot;);
2502   }
2503 }
2504 #endif //PRODUCT
2505 
2506 void Method::print_value_on(outputStream* st) const {
2507   assert(is_method(), &quot;must be method&quot;);
2508   st-&gt;print(&quot;%s&quot;, internal_name());
2509   print_address_on(st);
2510   st-&gt;print(&quot; &quot;);
<span class="line-added">2511   if (WizardMode) access_flags().print_on(st);</span>
2512   name()-&gt;print_value_on(st);
2513   st-&gt;print(&quot; &quot;);
2514   signature()-&gt;print_value_on(st);
2515   st-&gt;print(&quot; in &quot;);
2516   method_holder()-&gt;print_value_on(st);
2517   if (WizardMode) st-&gt;print(&quot;#%d&quot;, _vtable_index);
2518   if (WizardMode) st-&gt;print(&quot;[%d,%d]&quot;, size_of_parameters(), max_locals());
2519   if (WizardMode &amp;&amp; code() != NULL) st-&gt;print(&quot; ((nmethod*)%p)&quot;, code());
2520 }
2521 
2522 // LogTouchedMethods and PrintTouchedMethods
2523 
2524 // TouchedMethodRecord -- we can&#39;t use a HashtableEntry&lt;Method*&gt; because
2525 // the Method may be garbage collected. Let&#39;s roll our own hash table.
2526 class TouchedMethodRecord : CHeapObj&lt;mtTracing&gt; {
2527 public:
2528   // It&#39;s OK to store Symbols here because they will NOT be GC&#39;ed if
2529   // LogTouchedMethods is enabled.
2530   TouchedMethodRecord* _next;
2531   Symbol* _class_name;
</pre>
</td>
</tr>
</table>
<center><a href="accessDecorators.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
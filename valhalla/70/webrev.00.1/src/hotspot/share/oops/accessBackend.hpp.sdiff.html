<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/accessBackend.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="access.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessDecorators.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/accessBackend.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  35 #include &quot;metaprogramming/isIntegral.hpp&quot;
  36 #include &quot;metaprogramming/isPointer.hpp&quot;
  37 #include &quot;metaprogramming/isSame.hpp&quot;
  38 #include &quot;metaprogramming/isVolatile.hpp&quot;
  39 #include &quot;oops/accessDecorators.hpp&quot;
  40 #include &quot;oops/oopsHierarchy.hpp&quot;
  41 #include &quot;runtime/globals.hpp&quot;
  42 #include &quot;utilities/debug.hpp&quot;
  43 #include &quot;utilities/globalDefinitions.hpp&quot;
  44 
  45 
  46 // This metafunction returns either oop or narrowOop depending on whether
  47 // an access needs to use compressed oops or not.
  48 template &lt;DecoratorSet decorators&gt;
  49 struct HeapOopType: AllStatic {
  50   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value &amp;&amp;
  51                                          HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;
  52   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;
  53 };
  54 








  55 namespace AccessInternal {
  56   enum BarrierType {
  57     BARRIER_STORE,
  58     BARRIER_STORE_AT,
  59     BARRIER_LOAD,
  60     BARRIER_LOAD_AT,
  61     BARRIER_ATOMIC_CMPXCHG,
  62     BARRIER_ATOMIC_CMPXCHG_AT,
  63     BARRIER_ATOMIC_XCHG,
  64     BARRIER_ATOMIC_XCHG_AT,
  65     BARRIER_ARRAYCOPY,
  66     BARRIER_CLONE,

  67     BARRIER_RESOLVE
  68   };
  69 
  70   template &lt;DecoratorSet decorators, typename T&gt;
  71   struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
  72     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
  73     IsSame&lt;typename HeapOopType&lt;decorators&gt;::type, narrowOop&gt;::value &amp;&amp;
  74     IsSame&lt;T, oop&gt;::value&gt; {};
  75 
  76   // This metafunction returns an appropriate oop type if the value is oop-like
  77   // and otherwise returns the same type T.
  78   template &lt;DecoratorSet decorators, typename T&gt;
  79   struct EncodedType: AllStatic {
  80     typedef typename Conditional&lt;
  81       HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
  82       typename HeapOopType&lt;decorators&gt;::type, T&gt;::type type;
  83   };
  84 
  85   template &lt;DecoratorSet decorators&gt;
  86   inline typename HeapOopType&lt;decorators&gt;::type*
</pre>
<hr />
<pre>
  93   // locking to support wide atomics or not.
  94   template &lt;typename T&gt;
  95 #ifdef SUPPORTS_NATIVE_CX8
  96   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, false&gt; {};
  97 #else
  98   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, (sizeof(T) &gt; 4)&gt; {};
  99 #endif
 100 
 101   template &lt;DecoratorSet decorators, typename T&gt;
 102   struct AccessFunctionTypes {
 103     typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
 104     typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
 105     typedef T (*atomic_cmpxchg_at_func_t)(oop base, ptrdiff_t offset, T compare_value, T new_value);
 106     typedef T (*atomic_xchg_at_func_t)(oop base, ptrdiff_t offset, T new_value);
 107 
 108     typedef T (*load_func_t)(void* addr);
 109     typedef void (*store_func_t)(void* addr, T value);
 110     typedef T (*atomic_cmpxchg_func_t)(void* addr, T compare_value, T new_value);
 111     typedef T (*atomic_xchg_func_t)(void* addr, T new_value);
 112 
<span class="line-modified"> 113     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 114                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 115                                      size_t length);
 116     typedef void (*clone_func_t)(oop src, oop dst, size_t size);

 117     typedef oop (*resolve_func_t)(oop obj);
 118   };
 119 
 120   template &lt;DecoratorSet decorators&gt;
 121   struct AccessFunctionTypes&lt;decorators, void&gt; {
<span class="line-modified"> 122     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,</span>
 123                                      arrayOop dst_obj, size_t dst_offset_in_bytes, void* dst,
 124                                      size_t length);
 125   };
 126 
 127   template &lt;DecoratorSet decorators, typename T, BarrierType barrier&gt; struct AccessFunction {};
 128 
 129 #define ACCESS_GENERATE_ACCESS_FUNCTION(bt, func)                   \
 130   template &lt;DecoratorSet decorators, typename T&gt;                    \
 131   struct AccessFunction&lt;decorators, T, bt&gt;: AllStatic{              \
 132     typedef typename AccessFunctionTypes&lt;decorators, T&gt;::func type; \
 133   }
 134   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE, store_func_t);
 135   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE_AT, store_at_func_t);
 136   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD, load_func_t);
 137   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD_AT, load_at_func_t);
 138   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG, atomic_cmpxchg_func_t);
 139   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG_AT, atomic_cmpxchg_at_func_t);
 140   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
 141   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
 142   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
 143   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);

 144   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);
 145 #undef ACCESS_GENERATE_ACCESS_FUNCTION
 146 
 147   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 148   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_barrier();
 149 
 150   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 151   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_oop_barrier();
 152 
 153   class AccessLocker {
 154   public:
 155     AccessLocker();
 156     ~AccessLocker();
 157   };
 158   bool wide_atomic_needs_locking();
 159 
 160   void* field_addr(oop base, ptrdiff_t offset);
 161 
 162   // Forward calls to Copy:: in the cpp file to reduce dependencies and allow
 163   // faster build times, given how frequently included access is.
</pre>
<hr />
<pre>
 324   static inline void store(void* addr, T value) {
 325     store_internal&lt;decorators&gt;(addr, value);
 326   }
 327 
 328   template &lt;typename T&gt;
 329   static inline T load(void* addr) {
 330     return load_internal&lt;decorators, T&gt;(addr);
 331   }
 332 
 333   template &lt;typename T&gt;
 334   static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 335     return atomic_cmpxchg_maybe_locked&lt;decorators&gt;(addr, compare_value, new_value);
 336   }
 337 
 338   template &lt;typename T&gt;
 339   static inline T atomic_xchg(void* addr, T new_value) {
 340     return atomic_xchg_maybe_locked&lt;decorators&gt;(addr, new_value);
 341   }
 342 
 343   template &lt;typename T&gt;
<span class="line-modified"> 344   static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 345                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 346                         size_t length);
 347 
 348   template &lt;typename T&gt;
 349   static void oop_store(void* addr, T value);
 350   template &lt;typename T&gt;
 351   static void oop_store_at(oop base, ptrdiff_t offset, T value);
 352 
 353   template &lt;typename T&gt;
 354   static T oop_load(void* addr);
 355   template &lt;typename T&gt;
 356   static T oop_load_at(oop base, ptrdiff_t offset);
 357 
 358   template &lt;typename T&gt;
 359   static T oop_atomic_cmpxchg(void* addr, T compare_value, T new_value);
 360   template &lt;typename T&gt;
 361   static T oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value);
 362 
 363   template &lt;typename T&gt;
 364   static T oop_atomic_xchg(void* addr, T new_value);
</pre>
<hr />
<pre>
 369   static void store_at(oop base, ptrdiff_t offset, T value) {
 370     store(field_addr(base, offset), value);
 371   }
 372 
 373   template &lt;typename T&gt;
 374   static T load_at(oop base, ptrdiff_t offset) {
 375     return load&lt;T&gt;(field_addr(base, offset));
 376   }
 377 
 378   template &lt;typename T&gt;
 379   static T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
 380     return atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);
 381   }
 382 
 383   template &lt;typename T&gt;
 384   static T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 385     return atomic_xchg(field_addr(base, offset), new_value);
 386   }
 387 
 388   template &lt;typename T&gt;
<span class="line-modified"> 389   static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 390                             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 391                             size_t length);
 392 
 393   static void clone(oop src, oop dst, size_t size);
 394 


 395   static oop resolve(oop obj) { return obj; }
 396 };
 397 
 398 // Below is the implementation of the first 4 steps of the template pipeline:
 399 // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
 400 //           and sets default decorators to sensible values.
 401 // * Step 2: Reduce types. This step makes sure there is only a single T type and not
 402 //           multiple types. The P type of the address and T type of the value must
 403 //           match.
 404 // * Step 3: Pre-runtime dispatch. This step checks whether a runtime call can be
 405 //           avoided, and in that case avoids it (calling raw accesses or
 406 //           primitive accesses in a build that does not require primitive GC barriers)
 407 // * Step 4: Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 408 //           BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 409 //           to the access.
 410 
 411 namespace AccessInternal {
 412   template &lt;typename T&gt;
 413   struct OopOrNarrowOopInternal: AllStatic {
 414     typedef oop type;
</pre>
<hr />
<pre>
 532     }
 533   };
 534 
 535   template &lt;DecoratorSet decorators, typename T&gt;
 536   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;: AllStatic {
 537     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type func_t;
 538     static func_t _atomic_xchg_at_func;
 539 
 540     static T atomic_xchg_at_init(oop base, ptrdiff_t offset, T new_value);
 541 
 542     static inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 543       return _atomic_xchg_at_func(base, offset, new_value);
 544     }
 545   };
 546 
 547   template &lt;DecoratorSet decorators, typename T&gt;
 548   struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
 549     typedef typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type func_t;
 550     static func_t _arraycopy_func;
 551 
<span class="line-modified"> 552     static bool arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 553                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 554                                size_t length);
 555 
<span class="line-modified"> 556     static inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 557                                  arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 558                                  size_t length) {
 559       return _arraycopy_func(src_obj, src_offset_in_bytes, src_raw,
 560                              dst_obj, dst_offset_in_bytes, dst_raw,
 561                              length);
 562     }
 563   };
 564 
 565   template &lt;DecoratorSet decorators, typename T&gt;
 566   struct RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;: AllStatic {
 567     typedef typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type func_t;
 568     static func_t _clone_func;
 569 
 570     static void clone_init(oop src, oop dst, size_t size);
 571 
 572     static inline void clone(oop src, oop dst, size_t size) {
 573       _clone_func(src, dst, size);
 574     }
 575   };
 576 












 577   template &lt;DecoratorSet decorators, typename T&gt;
 578   struct RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;: AllStatic {
 579     typedef typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type func_t;
 580     static func_t _resolve_func;
 581 
 582     static oop resolve_init(oop obj);
 583 
 584     static inline oop resolve(oop obj) {
 585       return _resolve_func(obj);
 586     }
 587   };
 588 
 589   // Initialize the function pointers to point to the resolving function.
 590   template &lt;DecoratorSet decorators, typename T&gt;
 591   typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type
 592   RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::_store_func = &amp;store_init;
 593 
 594   template &lt;DecoratorSet decorators, typename T&gt;
 595   typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type
 596   RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::_store_at_func = &amp;store_at_init;
</pre>
<hr />
<pre>
 610   template &lt;DecoratorSet decorators, typename T&gt;
 611   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type
 612   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::_atomic_cmpxchg_at_func = &amp;atomic_cmpxchg_at_init;
 613 
 614   template &lt;DecoratorSet decorators, typename T&gt;
 615   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type
 616   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::_atomic_xchg_func = &amp;atomic_xchg_init;
 617 
 618   template &lt;DecoratorSet decorators, typename T&gt;
 619   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type
 620   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::_atomic_xchg_at_func = &amp;atomic_xchg_at_init;
 621 
 622   template &lt;DecoratorSet decorators, typename T&gt;
 623   typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type
 624   RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::_arraycopy_func = &amp;arraycopy_init;
 625 
 626   template &lt;DecoratorSet decorators, typename T&gt;
 627   typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type
 628   RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::_clone_func = &amp;clone_init;
 629 




 630   template &lt;DecoratorSet decorators, typename T&gt;
 631   typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type
 632   RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::_resolve_func = &amp;resolve_init;
 633 
 634   // Step 3: Pre-runtime dispatching.
 635   // The PreRuntimeDispatch class is responsible for filtering the barrier strength
 636   // decorators. That is, for AS_RAW, it hardwires the accesses without a runtime
 637   // dispatch point. Otherwise it goes through a runtime check if hardwiring was
 638   // not possible.
 639   struct PreRuntimeDispatch: AllStatic {
 640     template&lt;DecoratorSet decorators&gt;
 641     struct CanHardwireRaw: public IntegralConstant&lt;
 642       bool,
 643       !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // primitive access
 644       !HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value || // don&#39;t care about compressed oops (oop* address)
 645       HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value&gt; // we can infer we use compressed oops (narrowOop* address)
 646     {};
 647 
 648     static const DecoratorSet convert_compressed_oops = INTERNAL_RT_USE_COMPRESSED_OOPS | INTERNAL_CONVERT_COMPRESSED_OOP;
 649 
</pre>
<hr />
<pre>
 862     inline static typename EnableIf&lt;
 863       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 864     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 865       return atomic_xchg&lt;decorators&gt;(field_addr(base, offset), new_value);
 866     }
 867 
 868     template &lt;DecoratorSet decorators, typename T&gt;
 869     inline static typename EnableIf&lt;
 870       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 871     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 872       if (is_hardwired_primitive&lt;decorators&gt;()) {
 873         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 874         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(base, offset, new_value);
 875       } else {
 876         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at(base, offset, new_value);
 877       }
 878     }
 879 
 880     template &lt;DecoratorSet decorators, typename T&gt;
 881     inline static typename EnableIf&lt;
<span class="line-modified"> 882       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type</span>
 883     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 884               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 885               size_t length) {
 886       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 887       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="line-modified"> 888         return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 889                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 890                                   length);</span>
 891       } else {
<span class="line-modified"> 892         return Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 893                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 894                               length);</span>
 895       }
 896     }
 897 
 898     template &lt;DecoratorSet decorators, typename T&gt;
 899     inline static typename EnableIf&lt;
<span class="line-modified"> 900       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type</span>
 901     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 902               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 903               size_t length) {
 904       if (UseCompressedOops) {
 905         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="line-modified"> 906         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 907                                                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 908                                                                   length);</span>
 909       } else {
 910         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="line-modified"> 911         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 912                                                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 913                                                                   length);</span>
 914       }
 915     }
 916 
 917     template &lt;DecoratorSet decorators, typename T&gt;
 918     inline static typename EnableIf&lt;
<span class="line-modified"> 919       !HasDecorator&lt;decorators, AS_RAW&gt;::value, bool&gt;::type</span>
 920     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 921               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 922               size_t length) {
 923       if (is_hardwired_primitive&lt;decorators&gt;()) {
 924         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified"> 925         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 926                                                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 927                                                                   length);</span>
 928       } else {
<span class="line-modified"> 929         return RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 930                                                                             dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 931                                                                             length);</span>
 932       }
 933     }
 934 
 935     template &lt;DecoratorSet decorators&gt;
 936     inline static typename EnableIf&lt;
 937       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 938     clone(oop src, oop dst, size_t size) {
 939       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 940       Raw::clone(src, dst, size);
 941     }
 942 
 943     template &lt;DecoratorSet decorators&gt;
 944     inline static typename EnableIf&lt;
 945       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 946     clone(oop src, oop dst, size_t size) {
 947       RuntimeDispatch&lt;decorators, oop, BARRIER_CLONE&gt;::clone(src, dst, size);
 948     }
 949 

















 950     template &lt;DecoratorSet decorators&gt;
 951     inline static typename EnableIf&lt;
 952       HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 953     resolve(oop obj) {
 954       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 955       return Raw::resolve(obj);
 956     }
 957 
 958     template &lt;DecoratorSet decorators&gt;
 959     inline static typename EnableIf&lt;
 960       !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 961     resolve(oop obj) {
 962       return RuntimeDispatch&lt;decorators, oop, BARRIER_RESOLVE&gt;::resolve(obj);
 963     }
 964   };
 965 
 966   // Step 2: Reduce types.
 967   // Enforce that for non-oop types, T and P have to be strictly the same.
 968   // P is the type of the address and T is the type of the values.
 969   // As for oop types, it is allow to send T in {narrowOop, oop} and
</pre>
<hr />
<pre>
1058 
1059   template &lt;DecoratorSet decorators, typename T&gt;
1060   inline T load_reduce_types(T* addr) {
1061     return PreRuntimeDispatch::load&lt;decorators, T&gt;(addr);
1062   }
1063 
1064   template &lt;DecoratorSet decorators, typename T&gt;
1065   inline typename OopOrNarrowOop&lt;T&gt;::type load_reduce_types(narrowOop* addr) {
1066     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1067                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1068     return PreRuntimeDispatch::load&lt;expanded_decorators, typename OopOrNarrowOop&lt;T&gt;::type&gt;(addr);
1069   }
1070 
1071   template &lt;DecoratorSet decorators, typename T&gt;
1072   inline oop load_reduce_types(HeapWord* addr) {
1073     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1074     return PreRuntimeDispatch::load&lt;expanded_decorators, oop&gt;(addr);
1075   }
1076 
1077   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1078   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
1079                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1080                                      size_t length) {
<span class="line-modified">1081     return PreRuntimeDispatch::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified">1082                                                      dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified">1083                                                      length);</span>
1084   }
1085 
1086   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1087   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, HeapWord* src_raw,</span>
1088                                      arrayOop dst_obj, size_t dst_offset_in_bytes, HeapWord* dst_raw,
1089                                      size_t length) {
1090     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="line-modified">1091     return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified">1092                                                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified">1093                                                               length);</span>
1094   }
1095 
1096   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1097   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,</span>
1098                                      arrayOop dst_obj, size_t dst_offset_in_bytes, narrowOop* dst_raw,
1099                                      size_t length) {
1100     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1101                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">1102     return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified">1103                                                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified">1104                                                               length);</span>
1105   }
1106 
1107   // Step 1: Set default decorators. This step remembers if a type was volatile
1108   // and then sets the MO_RELAXED decorator by default. Otherwise, a default
1109   // memory ordering is set for the access, and the implied decorator rules
1110   // are applied to select sensible defaults for decorators that have not been
1111   // explicitly set. For example, default object referent strength is set to strong.
1112   // This step also decays the types passed in (e.g. getting rid of CV qualifiers
1113   // and references from the types). This step also perform some type verification
1114   // that the passed in types make sense.
1115 
1116   template &lt;DecoratorSet decorators, typename T&gt;
1117   static void verify_types(){
1118     // If this fails to compile, then you have sent in something that is
1119     // not recognized as a valid primitive type to a primitive Access function.
1120     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // oops have already been validated
1121                    (IsPointer&lt;T&gt;::value || IsIntegral&lt;T&gt;::value) ||
1122                     IsFloatingPoint&lt;T&gt;::value)); // not allowed primitive type
1123   }
1124 
</pre>
<hr />
<pre>
1217     DecayedT new_decayed_value = new_value;
1218     // atomic_xchg is only available in SEQ_CST flavour.
1219     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST&gt;::value;
1220     return atomic_xchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),
1221                                                          new_decayed_value);
1222   }
1223 
1224   template &lt;DecoratorSet decorators, typename T&gt;
1225   inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
1226     verify_types&lt;decorators, T&gt;();
1227     typedef typename Decay&lt;T&gt;::type DecayedT;
1228     DecayedT new_decayed_value = new_value;
1229     // atomic_xchg is only available in SEQ_CST flavour.
1230     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST |
1231                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1232                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1233     return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(base, offset, new_decayed_value);
1234   }
1235 
1236   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1237   inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,</span>
1238                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1239                         size_t length) {
1240     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ||
1241                    (IsSame&lt;T, void&gt;::value || IsIntegral&lt;T&gt;::value) ||
1242                     IsFloatingPoint&lt;T&gt;::value)); // arraycopy allows type erased void elements
1243     typedef typename Decay&lt;T&gt;::type DecayedT;
1244     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | IS_ARRAY | IN_HEAP&gt;::value;
<span class="line-modified">1245     return arraycopy_reduce_types&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, const_cast&lt;DecayedT*&gt;(src_raw),</span>
<span class="line-modified">1246                                                        dst_obj, dst_offset_in_bytes, const_cast&lt;DecayedT*&gt;(dst_raw),</span>
<span class="line-modified">1247                                                        length);</span>
1248   }
1249 
1250   template &lt;DecoratorSet decorators&gt;
1251   inline void clone(oop src, oop dst, size_t size) {
1252     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1253     PreRuntimeDispatch::clone&lt;expanded_decorators&gt;(src, dst, size);
1254   }
1255 






1256   template &lt;DecoratorSet decorators&gt;
1257   inline oop resolve(oop obj) {
1258     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1259     return PreRuntimeDispatch::resolve&lt;expanded_decorators&gt;(obj);
1260   }
1261 
1262   // Infer the type that should be returned from an Access::oop_load.
1263   template &lt;typename P, DecoratorSet decorators&gt;
1264   class OopLoadProxy: public StackObj {
1265   private:
1266     P *const _addr;
1267   public:
1268     OopLoadProxy(P* addr) : _addr(addr) {}
1269 
1270     inline operator oop() {
1271       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, oop&gt;(_addr);
1272     }
1273 
1274     inline operator narrowOop() {
1275       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, narrowOop&gt;(_addr);
</pre>
</td>
<td>
<hr />
<pre>
  35 #include &quot;metaprogramming/isIntegral.hpp&quot;
  36 #include &quot;metaprogramming/isPointer.hpp&quot;
  37 #include &quot;metaprogramming/isSame.hpp&quot;
  38 #include &quot;metaprogramming/isVolatile.hpp&quot;
  39 #include &quot;oops/accessDecorators.hpp&quot;
  40 #include &quot;oops/oopsHierarchy.hpp&quot;
  41 #include &quot;runtime/globals.hpp&quot;
  42 #include &quot;utilities/debug.hpp&quot;
  43 #include &quot;utilities/globalDefinitions.hpp&quot;
  44 
  45 
  46 // This metafunction returns either oop or narrowOop depending on whether
  47 // an access needs to use compressed oops or not.
  48 template &lt;DecoratorSet decorators&gt;
  49 struct HeapOopType: AllStatic {
  50   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value &amp;&amp;
  51                                          HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;
  52   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;
  53 };
  54 
<span class="line-added">  55 // This meta-function returns either oop or narrowOop depending on whether</span>
<span class="line-added">  56 // a back-end needs to consider compressed oops types or not.</span>
<span class="line-added">  57 template &lt;DecoratorSet decorators&gt;</span>
<span class="line-added">  58 struct ValueOopType: AllStatic {</span>
<span class="line-added">  59   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;</span>
<span class="line-added">  60   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;</span>
<span class="line-added">  61 };</span>
<span class="line-added">  62 </span>
  63 namespace AccessInternal {
  64   enum BarrierType {
  65     BARRIER_STORE,
  66     BARRIER_STORE_AT,
  67     BARRIER_LOAD,
  68     BARRIER_LOAD_AT,
  69     BARRIER_ATOMIC_CMPXCHG,
  70     BARRIER_ATOMIC_CMPXCHG_AT,
  71     BARRIER_ATOMIC_XCHG,
  72     BARRIER_ATOMIC_XCHG_AT,
  73     BARRIER_ARRAYCOPY,
  74     BARRIER_CLONE,
<span class="line-added">  75     BARRIER_VALUE_COPY,</span>
  76     BARRIER_RESOLVE
  77   };
  78 
  79   template &lt;DecoratorSet decorators, typename T&gt;
  80   struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
  81     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
  82     IsSame&lt;typename HeapOopType&lt;decorators&gt;::type, narrowOop&gt;::value &amp;&amp;
  83     IsSame&lt;T, oop&gt;::value&gt; {};
  84 
  85   // This metafunction returns an appropriate oop type if the value is oop-like
  86   // and otherwise returns the same type T.
  87   template &lt;DecoratorSet decorators, typename T&gt;
  88   struct EncodedType: AllStatic {
  89     typedef typename Conditional&lt;
  90       HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
  91       typename HeapOopType&lt;decorators&gt;::type, T&gt;::type type;
  92   };
  93 
  94   template &lt;DecoratorSet decorators&gt;
  95   inline typename HeapOopType&lt;decorators&gt;::type*
</pre>
<hr />
<pre>
 102   // locking to support wide atomics or not.
 103   template &lt;typename T&gt;
 104 #ifdef SUPPORTS_NATIVE_CX8
 105   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, false&gt; {};
 106 #else
 107   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, (sizeof(T) &gt; 4)&gt; {};
 108 #endif
 109 
 110   template &lt;DecoratorSet decorators, typename T&gt;
 111   struct AccessFunctionTypes {
 112     typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
 113     typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
 114     typedef T (*atomic_cmpxchg_at_func_t)(oop base, ptrdiff_t offset, T compare_value, T new_value);
 115     typedef T (*atomic_xchg_at_func_t)(oop base, ptrdiff_t offset, T new_value);
 116 
 117     typedef T (*load_func_t)(void* addr);
 118     typedef void (*store_func_t)(void* addr, T value);
 119     typedef T (*atomic_cmpxchg_func_t)(void* addr, T compare_value, T new_value);
 120     typedef T (*atomic_xchg_func_t)(void* addr, T new_value);
 121 
<span class="line-modified"> 122     typedef void (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 123                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 124                                      size_t length);
 125     typedef void (*clone_func_t)(oop src, oop dst, size_t size);
<span class="line-added"> 126     typedef void (*value_copy_func_t)(void* src, void* dst, ValueKlass* md);</span>
 127     typedef oop (*resolve_func_t)(oop obj);
 128   };
 129 
 130   template &lt;DecoratorSet decorators&gt;
 131   struct AccessFunctionTypes&lt;decorators, void&gt; {
<span class="line-modified"> 132     typedef void (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,</span>
 133                                      arrayOop dst_obj, size_t dst_offset_in_bytes, void* dst,
 134                                      size_t length);
 135   };
 136 
 137   template &lt;DecoratorSet decorators, typename T, BarrierType barrier&gt; struct AccessFunction {};
 138 
 139 #define ACCESS_GENERATE_ACCESS_FUNCTION(bt, func)                   \
 140   template &lt;DecoratorSet decorators, typename T&gt;                    \
 141   struct AccessFunction&lt;decorators, T, bt&gt;: AllStatic{              \
 142     typedef typename AccessFunctionTypes&lt;decorators, T&gt;::func type; \
 143   }
 144   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE, store_func_t);
 145   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE_AT, store_at_func_t);
 146   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD, load_func_t);
 147   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD_AT, load_at_func_t);
 148   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG, atomic_cmpxchg_func_t);
 149   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG_AT, atomic_cmpxchg_at_func_t);
 150   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
 151   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
 152   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
 153   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);
<span class="line-added"> 154   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_VALUE_COPY, value_copy_func_t);</span>
 155   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);
 156 #undef ACCESS_GENERATE_ACCESS_FUNCTION
 157 
 158   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 159   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_barrier();
 160 
 161   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 162   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_oop_barrier();
 163 
 164   class AccessLocker {
 165   public:
 166     AccessLocker();
 167     ~AccessLocker();
 168   };
 169   bool wide_atomic_needs_locking();
 170 
 171   void* field_addr(oop base, ptrdiff_t offset);
 172 
 173   // Forward calls to Copy:: in the cpp file to reduce dependencies and allow
 174   // faster build times, given how frequently included access is.
</pre>
<hr />
<pre>
 335   static inline void store(void* addr, T value) {
 336     store_internal&lt;decorators&gt;(addr, value);
 337   }
 338 
 339   template &lt;typename T&gt;
 340   static inline T load(void* addr) {
 341     return load_internal&lt;decorators, T&gt;(addr);
 342   }
 343 
 344   template &lt;typename T&gt;
 345   static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 346     return atomic_cmpxchg_maybe_locked&lt;decorators&gt;(addr, compare_value, new_value);
 347   }
 348 
 349   template &lt;typename T&gt;
 350   static inline T atomic_xchg(void* addr, T new_value) {
 351     return atomic_xchg_maybe_locked&lt;decorators&gt;(addr, new_value);
 352   }
 353 
 354   template &lt;typename T&gt;
<span class="line-modified"> 355   static void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 356                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 357                         size_t length);
 358 
 359   template &lt;typename T&gt;
 360   static void oop_store(void* addr, T value);
 361   template &lt;typename T&gt;
 362   static void oop_store_at(oop base, ptrdiff_t offset, T value);
 363 
 364   template &lt;typename T&gt;
 365   static T oop_load(void* addr);
 366   template &lt;typename T&gt;
 367   static T oop_load_at(oop base, ptrdiff_t offset);
 368 
 369   template &lt;typename T&gt;
 370   static T oop_atomic_cmpxchg(void* addr, T compare_value, T new_value);
 371   template &lt;typename T&gt;
 372   static T oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value);
 373 
 374   template &lt;typename T&gt;
 375   static T oop_atomic_xchg(void* addr, T new_value);
</pre>
<hr />
<pre>
 380   static void store_at(oop base, ptrdiff_t offset, T value) {
 381     store(field_addr(base, offset), value);
 382   }
 383 
 384   template &lt;typename T&gt;
 385   static T load_at(oop base, ptrdiff_t offset) {
 386     return load&lt;T&gt;(field_addr(base, offset));
 387   }
 388 
 389   template &lt;typename T&gt;
 390   static T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
 391     return atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);
 392   }
 393 
 394   template &lt;typename T&gt;
 395   static T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 396     return atomic_xchg(field_addr(base, offset), new_value);
 397   }
 398 
 399   template &lt;typename T&gt;
<span class="line-modified"> 400   static void oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 401                             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 402                             size_t length);
 403 
 404   static void clone(oop src, oop dst, size_t size);
 405 
<span class="line-added"> 406   static void value_copy(void* src, void* dst, ValueKlass* md);</span>
<span class="line-added"> 407 </span>
 408   static oop resolve(oop obj) { return obj; }
 409 };
 410 
 411 // Below is the implementation of the first 4 steps of the template pipeline:
 412 // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
 413 //           and sets default decorators to sensible values.
 414 // * Step 2: Reduce types. This step makes sure there is only a single T type and not
 415 //           multiple types. The P type of the address and T type of the value must
 416 //           match.
 417 // * Step 3: Pre-runtime dispatch. This step checks whether a runtime call can be
 418 //           avoided, and in that case avoids it (calling raw accesses or
 419 //           primitive accesses in a build that does not require primitive GC barriers)
 420 // * Step 4: Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 421 //           BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 422 //           to the access.
 423 
 424 namespace AccessInternal {
 425   template &lt;typename T&gt;
 426   struct OopOrNarrowOopInternal: AllStatic {
 427     typedef oop type;
</pre>
<hr />
<pre>
 545     }
 546   };
 547 
 548   template &lt;DecoratorSet decorators, typename T&gt;
 549   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;: AllStatic {
 550     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type func_t;
 551     static func_t _atomic_xchg_at_func;
 552 
 553     static T atomic_xchg_at_init(oop base, ptrdiff_t offset, T new_value);
 554 
 555     static inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 556       return _atomic_xchg_at_func(base, offset, new_value);
 557     }
 558   };
 559 
 560   template &lt;DecoratorSet decorators, typename T&gt;
 561   struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
 562     typedef typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type func_t;
 563     static func_t _arraycopy_func;
 564 
<span class="line-modified"> 565     static void arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 566                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 567                                size_t length);
 568 
<span class="line-modified"> 569     static inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 570                                  arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 571                                  size_t length) {
 572       return _arraycopy_func(src_obj, src_offset_in_bytes, src_raw,
 573                              dst_obj, dst_offset_in_bytes, dst_raw,
 574                              length);
 575     }
 576   };
 577 
 578   template &lt;DecoratorSet decorators, typename T&gt;
 579   struct RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;: AllStatic {
 580     typedef typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type func_t;
 581     static func_t _clone_func;
 582 
 583     static void clone_init(oop src, oop dst, size_t size);
 584 
 585     static inline void clone(oop src, oop dst, size_t size) {
 586       _clone_func(src, dst, size);
 587     }
 588   };
 589 
<span class="line-added"> 590   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-added"> 591   struct RuntimeDispatch&lt;decorators, T, BARRIER_VALUE_COPY&gt;: AllStatic {</span>
<span class="line-added"> 592     typedef typename AccessFunction&lt;decorators, T, BARRIER_VALUE_COPY&gt;::type func_t;</span>
<span class="line-added"> 593     static func_t _value_copy_func;</span>
<span class="line-added"> 594 </span>
<span class="line-added"> 595     static void value_copy_init(void* src, void* dst, ValueKlass* md);</span>
<span class="line-added"> 596 </span>
<span class="line-added"> 597     static inline void value_copy(void* src, void* dst, ValueKlass* md) {</span>
<span class="line-added"> 598       _value_copy_func(src, dst, md);</span>
<span class="line-added"> 599     }</span>
<span class="line-added"> 600   };</span>
<span class="line-added"> 601 </span>
 602   template &lt;DecoratorSet decorators, typename T&gt;
 603   struct RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;: AllStatic {
 604     typedef typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type func_t;
 605     static func_t _resolve_func;
 606 
 607     static oop resolve_init(oop obj);
 608 
 609     static inline oop resolve(oop obj) {
 610       return _resolve_func(obj);
 611     }
 612   };
 613 
 614   // Initialize the function pointers to point to the resolving function.
 615   template &lt;DecoratorSet decorators, typename T&gt;
 616   typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type
 617   RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::_store_func = &amp;store_init;
 618 
 619   template &lt;DecoratorSet decorators, typename T&gt;
 620   typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type
 621   RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::_store_at_func = &amp;store_at_init;
</pre>
<hr />
<pre>
 635   template &lt;DecoratorSet decorators, typename T&gt;
 636   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type
 637   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::_atomic_cmpxchg_at_func = &amp;atomic_cmpxchg_at_init;
 638 
 639   template &lt;DecoratorSet decorators, typename T&gt;
 640   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type
 641   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::_atomic_xchg_func = &amp;atomic_xchg_init;
 642 
 643   template &lt;DecoratorSet decorators, typename T&gt;
 644   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type
 645   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::_atomic_xchg_at_func = &amp;atomic_xchg_at_init;
 646 
 647   template &lt;DecoratorSet decorators, typename T&gt;
 648   typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type
 649   RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::_arraycopy_func = &amp;arraycopy_init;
 650 
 651   template &lt;DecoratorSet decorators, typename T&gt;
 652   typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type
 653   RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::_clone_func = &amp;clone_init;
 654 
<span class="line-added"> 655   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-added"> 656   typename AccessFunction&lt;decorators, T, BARRIER_VALUE_COPY&gt;::type</span>
<span class="line-added"> 657   RuntimeDispatch&lt;decorators, T, BARRIER_VALUE_COPY&gt;::_value_copy_func = &amp;value_copy_init;</span>
<span class="line-added"> 658 </span>
 659   template &lt;DecoratorSet decorators, typename T&gt;
 660   typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type
 661   RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::_resolve_func = &amp;resolve_init;
 662 
 663   // Step 3: Pre-runtime dispatching.
 664   // The PreRuntimeDispatch class is responsible for filtering the barrier strength
 665   // decorators. That is, for AS_RAW, it hardwires the accesses without a runtime
 666   // dispatch point. Otherwise it goes through a runtime check if hardwiring was
 667   // not possible.
 668   struct PreRuntimeDispatch: AllStatic {
 669     template&lt;DecoratorSet decorators&gt;
 670     struct CanHardwireRaw: public IntegralConstant&lt;
 671       bool,
 672       !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // primitive access
 673       !HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value || // don&#39;t care about compressed oops (oop* address)
 674       HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value&gt; // we can infer we use compressed oops (narrowOop* address)
 675     {};
 676 
 677     static const DecoratorSet convert_compressed_oops = INTERNAL_RT_USE_COMPRESSED_OOPS | INTERNAL_CONVERT_COMPRESSED_OOP;
 678 
</pre>
<hr />
<pre>
 891     inline static typename EnableIf&lt;
 892       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 893     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 894       return atomic_xchg&lt;decorators&gt;(field_addr(base, offset), new_value);
 895     }
 896 
 897     template &lt;DecoratorSet decorators, typename T&gt;
 898     inline static typename EnableIf&lt;
 899       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 900     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 901       if (is_hardwired_primitive&lt;decorators&gt;()) {
 902         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 903         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(base, offset, new_value);
 904       } else {
 905         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at(base, offset, new_value);
 906       }
 907     }
 908 
 909     template &lt;DecoratorSet decorators, typename T&gt;
 910     inline static typename EnableIf&lt;
<span class="line-modified"> 911       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, void&gt;::type</span>
 912     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 913               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 914               size_t length) {
 915       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 916       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<span class="line-modified"> 917         Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 918                            dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 919                            length);</span>
 920       } else {
<span class="line-modified"> 921         Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 922                        dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 923                        length);</span>
 924       }
 925     }
 926 
 927     template &lt;DecoratorSet decorators, typename T&gt;
 928     inline static typename EnableIf&lt;
<span class="line-modified"> 929       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, void&gt;::type</span>
 930     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 931               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 932               size_t length) {
 933       if (UseCompressedOops) {
 934         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<span class="line-modified"> 935         PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 936                                                            dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 937                                                            length);</span>
 938       } else {
 939         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<span class="line-modified"> 940         PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 941                                                            dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 942                                                            length);</span>
 943       }
 944     }
 945 
 946     template &lt;DecoratorSet decorators, typename T&gt;
 947     inline static typename EnableIf&lt;
<span class="line-modified"> 948       !HasDecorator&lt;decorators, AS_RAW&gt;::value, void&gt;::type</span>
 949     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 950               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 951               size_t length) {
 952       if (is_hardwired_primitive&lt;decorators&gt;()) {
 953         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<span class="line-modified"> 954         PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 955                                                            dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 956                                                            length);</span>
 957       } else {
<span class="line-modified"> 958         RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 959                                                                      dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 960                                                                      length);</span>
 961       }
 962     }
 963 
 964     template &lt;DecoratorSet decorators&gt;
 965     inline static typename EnableIf&lt;
 966       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 967     clone(oop src, oop dst, size_t size) {
 968       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 969       Raw::clone(src, dst, size);
 970     }
 971 
 972     template &lt;DecoratorSet decorators&gt;
 973     inline static typename EnableIf&lt;
 974       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 975     clone(oop src, oop dst, size_t size) {
 976       RuntimeDispatch&lt;decorators, oop, BARRIER_CLONE&gt;::clone(src, dst, size);
 977     }
 978 
<span class="line-added"> 979     template &lt;DecoratorSet decorators&gt;</span>
<span class="line-added"> 980     inline static typename EnableIf&lt;</span>
<span class="line-added"> 981       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type</span>
<span class="line-added"> 982     value_copy(void* src, void* dst, ValueKlass* md) {</span>
<span class="line-added"> 983       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;</span>
<span class="line-added"> 984       Raw::value_copy(src, dst, md);</span>
<span class="line-added"> 985     }</span>
<span class="line-added"> 986 </span>
<span class="line-added"> 987     template &lt;DecoratorSet decorators&gt;</span>
<span class="line-added"> 988     inline static typename EnableIf&lt;</span>
<span class="line-added"> 989       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type</span>
<span class="line-added"> 990       value_copy(void* src, void* dst, ValueKlass* md) {</span>
<span class="line-added"> 991       const DecoratorSet expanded_decorators = decorators;</span>
<span class="line-added"> 992       RuntimeDispatch&lt;expanded_decorators, void*, BARRIER_VALUE_COPY&gt;::value_copy(src, dst, md);</span>
<span class="line-added"> 993     }</span>
<span class="line-added"> 994 </span>
<span class="line-added"> 995 </span>
 996     template &lt;DecoratorSet decorators&gt;
 997     inline static typename EnableIf&lt;
 998       HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 999     resolve(oop obj) {
1000       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
1001       return Raw::resolve(obj);
1002     }
1003 
1004     template &lt;DecoratorSet decorators&gt;
1005     inline static typename EnableIf&lt;
1006       !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
1007     resolve(oop obj) {
1008       return RuntimeDispatch&lt;decorators, oop, BARRIER_RESOLVE&gt;::resolve(obj);
1009     }
1010   };
1011 
1012   // Step 2: Reduce types.
1013   // Enforce that for non-oop types, T and P have to be strictly the same.
1014   // P is the type of the address and T is the type of the values.
1015   // As for oop types, it is allow to send T in {narrowOop, oop} and
</pre>
<hr />
<pre>
1104 
1105   template &lt;DecoratorSet decorators, typename T&gt;
1106   inline T load_reduce_types(T* addr) {
1107     return PreRuntimeDispatch::load&lt;decorators, T&gt;(addr);
1108   }
1109 
1110   template &lt;DecoratorSet decorators, typename T&gt;
1111   inline typename OopOrNarrowOop&lt;T&gt;::type load_reduce_types(narrowOop* addr) {
1112     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1113                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1114     return PreRuntimeDispatch::load&lt;expanded_decorators, typename OopOrNarrowOop&lt;T&gt;::type&gt;(addr);
1115   }
1116 
1117   template &lt;DecoratorSet decorators, typename T&gt;
1118   inline oop load_reduce_types(HeapWord* addr) {
1119     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1120     return PreRuntimeDispatch::load&lt;expanded_decorators, oop&gt;(addr);
1121   }
1122 
1123   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1124   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
1125                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1126                                      size_t length) {
<span class="line-modified">1127     PreRuntimeDispatch::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified">1128                                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified">1129                                               length);</span>
1130   }
1131 
1132   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1133   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, HeapWord* src_raw,</span>
1134                                      arrayOop dst_obj, size_t dst_offset_in_bytes, HeapWord* dst_raw,
1135                                      size_t length) {
1136     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<span class="line-modified">1137     PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified">1138                                                        dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified">1139                                                        length);</span>
1140   }
1141 
1142   template &lt;DecoratorSet decorators&gt;
<span class="line-modified">1143   inline void arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,</span>
1144                                      arrayOop dst_obj, size_t dst_offset_in_bytes, narrowOop* dst_raw,
1145                                      size_t length) {
1146     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1147                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<span class="line-modified">1148     PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified">1149                                                        dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified">1150                                                        length);</span>
1151   }
1152 
1153   // Step 1: Set default decorators. This step remembers if a type was volatile
1154   // and then sets the MO_RELAXED decorator by default. Otherwise, a default
1155   // memory ordering is set for the access, and the implied decorator rules
1156   // are applied to select sensible defaults for decorators that have not been
1157   // explicitly set. For example, default object referent strength is set to strong.
1158   // This step also decays the types passed in (e.g. getting rid of CV qualifiers
1159   // and references from the types). This step also perform some type verification
1160   // that the passed in types make sense.
1161 
1162   template &lt;DecoratorSet decorators, typename T&gt;
1163   static void verify_types(){
1164     // If this fails to compile, then you have sent in something that is
1165     // not recognized as a valid primitive type to a primitive Access function.
1166     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // oops have already been validated
1167                    (IsPointer&lt;T&gt;::value || IsIntegral&lt;T&gt;::value) ||
1168                     IsFloatingPoint&lt;T&gt;::value)); // not allowed primitive type
1169   }
1170 
</pre>
<hr />
<pre>
1263     DecayedT new_decayed_value = new_value;
1264     // atomic_xchg is only available in SEQ_CST flavour.
1265     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST&gt;::value;
1266     return atomic_xchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),
1267                                                          new_decayed_value);
1268   }
1269 
1270   template &lt;DecoratorSet decorators, typename T&gt;
1271   inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
1272     verify_types&lt;decorators, T&gt;();
1273     typedef typename Decay&lt;T&gt;::type DecayedT;
1274     DecayedT new_decayed_value = new_value;
1275     // atomic_xchg is only available in SEQ_CST flavour.
1276     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST |
1277                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1278                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1279     return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(base, offset, new_decayed_value);
1280   }
1281 
1282   template &lt;DecoratorSet decorators, typename T&gt;
<span class="line-modified">1283   inline void arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,</span>
1284                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1285                         size_t length) {
1286     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ||
1287                    (IsSame&lt;T, void&gt;::value || IsIntegral&lt;T&gt;::value) ||
1288                     IsFloatingPoint&lt;T&gt;::value)); // arraycopy allows type erased void elements
1289     typedef typename Decay&lt;T&gt;::type DecayedT;
1290     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | IS_ARRAY | IN_HEAP&gt;::value;
<span class="line-modified">1291     arraycopy_reduce_types&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, const_cast&lt;DecayedT*&gt;(src_raw),</span>
<span class="line-modified">1292                                                 dst_obj, dst_offset_in_bytes, const_cast&lt;DecayedT*&gt;(dst_raw),</span>
<span class="line-modified">1293                                                 length);</span>
1294   }
1295 
1296   template &lt;DecoratorSet decorators&gt;
1297   inline void clone(oop src, oop dst, size_t size) {
1298     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1299     PreRuntimeDispatch::clone&lt;expanded_decorators&gt;(src, dst, size);
1300   }
1301 
<span class="line-added">1302   template &lt;DecoratorSet decorators&gt;</span>
<span class="line-added">1303   inline void value_copy(void* src, void* dst, ValueKlass* md) {</span>
<span class="line-added">1304     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;</span>
<span class="line-added">1305     PreRuntimeDispatch::value_copy&lt;expanded_decorators&gt;(src, dst, md);</span>
<span class="line-added">1306   }</span>
<span class="line-added">1307 </span>
1308   template &lt;DecoratorSet decorators&gt;
1309   inline oop resolve(oop obj) {
1310     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1311     return PreRuntimeDispatch::resolve&lt;expanded_decorators&gt;(obj);
1312   }
1313 
1314   // Infer the type that should be returned from an Access::oop_load.
1315   template &lt;typename P, DecoratorSet decorators&gt;
1316   class OopLoadProxy: public StackObj {
1317   private:
1318     P *const _addr;
1319   public:
1320     OopLoadProxy(P* addr) : _addr(addr) {}
1321 
1322     inline operator oop() {
1323       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, oop&gt;(_addr);
1324     }
1325 
1326     inline operator narrowOop() {
1327       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, narrowOop&gt;(_addr);
</pre>
</td>
</tr>
</table>
<center><a href="access.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="accessDecorators.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
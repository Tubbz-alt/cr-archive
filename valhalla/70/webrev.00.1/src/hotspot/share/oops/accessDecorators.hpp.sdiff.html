<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/accessDecorators.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="accessBackend.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="method.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/accessDecorators.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
181 // * IN_NATIVE: The access is performed in an off-heap data structure.
182 const DecoratorSet IN_HEAP            = UCONST64(1) &lt;&lt; 18;
183 const DecoratorSet IN_NATIVE          = UCONST64(1) &lt;&lt; 19;
184 const DecoratorSet IN_DECORATOR_MASK  = IN_HEAP | IN_NATIVE;
185 
186 // == Boolean Flag Decorators ==
187 // * IS_ARRAY: The access is performed on a heap allocated array. This is sometimes a special case
188 //   for some GCs.
189 // * IS_DEST_UNINITIALIZED: This property can be important to e.g. SATB barriers by
190 //   marking that the previous value is uninitialized nonsense rather than a real value.
191 // * IS_NOT_NULL: This property can make certain barriers faster such as compressing oops.
192 const DecoratorSet IS_ARRAY              = UCONST64(1) &lt;&lt; 20;
193 const DecoratorSet IS_DEST_UNINITIALIZED = UCONST64(1) &lt;&lt; 21;
194 const DecoratorSet IS_NOT_NULL           = UCONST64(1) &lt;&lt; 22;
195 
196 // == Arraycopy Decorators ==
197 // * ARRAYCOPY_CHECKCAST: This property means that the class of the objects in source
198 //   are not guaranteed to be subclasses of the class of the destination array. This requires
199 //   a check-cast barrier during the copying operation. If this is not set, it is assumed
200 //   that the array is covariant: (the source array type is-a destination array type)


201 // * ARRAYCOPY_DISJOINT: This property means that it is known that the two array ranges
202 //   are disjoint.
203 // * ARRAYCOPY_ARRAYOF: The copy is in the arrayof form.
204 // * ARRAYCOPY_ATOMIC: The accesses have to be atomic over the size of its elements.
205 // * ARRAYCOPY_ALIGNED: The accesses have to be aligned on a HeapWord.
206 const DecoratorSet ARRAYCOPY_CHECKCAST            = UCONST64(1) &lt;&lt; 23;
<span class="line-modified">207 const DecoratorSet ARRAYCOPY_DISJOINT             = UCONST64(1) &lt;&lt; 24;</span>
<span class="line-modified">208 const DecoratorSet ARRAYCOPY_ARRAYOF              = UCONST64(1) &lt;&lt; 25;</span>
<span class="line-modified">209 const DecoratorSet ARRAYCOPY_ATOMIC               = UCONST64(1) &lt;&lt; 26;</span>
<span class="line-modified">210 const DecoratorSet ARRAYCOPY_ALIGNED              = UCONST64(1) &lt;&lt; 27;</span>
<span class="line-modified">211 const DecoratorSet ARRAYCOPY_DECORATOR_MASK       = ARRAYCOPY_CHECKCAST | ARRAYCOPY_DISJOINT |</span>

212                                                     ARRAYCOPY_DISJOINT | ARRAYCOPY_ARRAYOF |
213                                                     ARRAYCOPY_ATOMIC | ARRAYCOPY_ALIGNED;
214 
215 // == Resolve barrier decorators ==
216 // * ACCESS_READ: Indicate that the resolved object is accessed read-only. This allows the GC
217 //   backend to use weaker and more efficient barriers.
218 // * ACCESS_WRITE: Indicate that the resolved object is used for write access.
<span class="line-modified">219 const DecoratorSet ACCESS_READ                    = UCONST64(1) &lt;&lt; 28;</span>
<span class="line-modified">220 const DecoratorSet ACCESS_WRITE                   = UCONST64(1) &lt;&lt; 29;</span>
221 
222 // Keep track of the last decorator.
<span class="line-modified">223 const DecoratorSet DECORATOR_LAST = UCONST64(1) &lt;&lt; 29;</span>
224 
225 namespace AccessInternal {
226   // This class adds implied decorators that follow according to decorator rules.
227   // For example adding default reference strength and default memory ordering
228   // semantics.
229   template &lt;DecoratorSet input_decorators&gt;
230   struct DecoratorFixup: AllStatic {
231     // If no reference strength has been picked, then strong will be picked
232     static const DecoratorSet ref_strength_default = input_decorators |
233       (((ON_DECORATOR_MASK &amp; input_decorators) == 0 &amp;&amp; (INTERNAL_VALUE_IS_OOP &amp; input_decorators) != 0) ?
234        ON_STRONG_OOP_REF : DECORATORS_NONE);
235     // If no memory ordering has been picked, unordered will be picked
236     static const DecoratorSet memory_ordering_default = ref_strength_default |
237       ((MO_DECORATOR_MASK &amp; ref_strength_default) == 0 ? MO_UNORDERED : DECORATORS_NONE);
238     // If no barrier strength has been picked, normal will be used
239     static const DecoratorSet barrier_strength_default = memory_ordering_default |
240       ((AS_DECORATOR_MASK &amp; memory_ordering_default) == 0 ? AS_NORMAL : DECORATORS_NONE);
241     static const DecoratorSet value = barrier_strength_default | BT_BUILDTIME_DECORATORS;
242   };
243 
</pre>
</td>
<td>
<hr />
<pre>
181 // * IN_NATIVE: The access is performed in an off-heap data structure.
182 const DecoratorSet IN_HEAP            = UCONST64(1) &lt;&lt; 18;
183 const DecoratorSet IN_NATIVE          = UCONST64(1) &lt;&lt; 19;
184 const DecoratorSet IN_DECORATOR_MASK  = IN_HEAP | IN_NATIVE;
185 
186 // == Boolean Flag Decorators ==
187 // * IS_ARRAY: The access is performed on a heap allocated array. This is sometimes a special case
188 //   for some GCs.
189 // * IS_DEST_UNINITIALIZED: This property can be important to e.g. SATB barriers by
190 //   marking that the previous value is uninitialized nonsense rather than a real value.
191 // * IS_NOT_NULL: This property can make certain barriers faster such as compressing oops.
192 const DecoratorSet IS_ARRAY              = UCONST64(1) &lt;&lt; 20;
193 const DecoratorSet IS_DEST_UNINITIALIZED = UCONST64(1) &lt;&lt; 21;
194 const DecoratorSet IS_NOT_NULL           = UCONST64(1) &lt;&lt; 22;
195 
196 // == Arraycopy Decorators ==
197 // * ARRAYCOPY_CHECKCAST: This property means that the class of the objects in source
198 //   are not guaranteed to be subclasses of the class of the destination array. This requires
199 //   a check-cast barrier during the copying operation. If this is not set, it is assumed
200 //   that the array is covariant: (the source array type is-a destination array type)
<span class="line-added">201 // * ARRAYCOPY_NOTNULL: This property means that the source array may contain null elements</span>
<span class="line-added">202 //   but the destination does not allow null elements (i.e. throw NPE)</span>
203 // * ARRAYCOPY_DISJOINT: This property means that it is known that the two array ranges
204 //   are disjoint.
205 // * ARRAYCOPY_ARRAYOF: The copy is in the arrayof form.
206 // * ARRAYCOPY_ATOMIC: The accesses have to be atomic over the size of its elements.
207 // * ARRAYCOPY_ALIGNED: The accesses have to be aligned on a HeapWord.
208 const DecoratorSet ARRAYCOPY_CHECKCAST            = UCONST64(1) &lt;&lt; 23;
<span class="line-modified">209 const DecoratorSet ARRAYCOPY_NOTNULL              = UCONST64(1) &lt;&lt; 24;</span>
<span class="line-modified">210 const DecoratorSet ARRAYCOPY_DISJOINT             = UCONST64(1) &lt;&lt; 25;</span>
<span class="line-modified">211 const DecoratorSet ARRAYCOPY_ARRAYOF              = UCONST64(1) &lt;&lt; 26;</span>
<span class="line-modified">212 const DecoratorSet ARRAYCOPY_ATOMIC               = UCONST64(1) &lt;&lt; 27;</span>
<span class="line-modified">213 const DecoratorSet ARRAYCOPY_ALIGNED              = UCONST64(1) &lt;&lt; 28;</span>
<span class="line-added">214 const DecoratorSet ARRAYCOPY_DECORATOR_MASK       = ARRAYCOPY_CHECKCAST | ARRAYCOPY_NOTNULL |</span>
215                                                     ARRAYCOPY_DISJOINT | ARRAYCOPY_ARRAYOF |
216                                                     ARRAYCOPY_ATOMIC | ARRAYCOPY_ALIGNED;
217 
218 // == Resolve barrier decorators ==
219 // * ACCESS_READ: Indicate that the resolved object is accessed read-only. This allows the GC
220 //   backend to use weaker and more efficient barriers.
221 // * ACCESS_WRITE: Indicate that the resolved object is used for write access.
<span class="line-modified">222 const DecoratorSet ACCESS_READ                    = UCONST64(1) &lt;&lt; 29;</span>
<span class="line-modified">223 const DecoratorSet ACCESS_WRITE                   = UCONST64(1) &lt;&lt; 30;</span>
224 
225 // Keep track of the last decorator.
<span class="line-modified">226 const DecoratorSet DECORATOR_LAST = UCONST64(1) &lt;&lt; 30;</span>
227 
228 namespace AccessInternal {
229   // This class adds implied decorators that follow according to decorator rules.
230   // For example adding default reference strength and default memory ordering
231   // semantics.
232   template &lt;DecoratorSet input_decorators&gt;
233   struct DecoratorFixup: AllStatic {
234     // If no reference strength has been picked, then strong will be picked
235     static const DecoratorSet ref_strength_default = input_decorators |
236       (((ON_DECORATOR_MASK &amp; input_decorators) == 0 &amp;&amp; (INTERNAL_VALUE_IS_OOP &amp; input_decorators) != 0) ?
237        ON_STRONG_OOP_REF : DECORATORS_NONE);
238     // If no memory ordering has been picked, unordered will be picked
239     static const DecoratorSet memory_ordering_default = ref_strength_default |
240       ((MO_DECORATOR_MASK &amp; ref_strength_default) == 0 ? MO_UNORDERED : DECORATORS_NONE);
241     // If no barrier strength has been picked, normal will be used
242     static const DecoratorSet barrier_strength_default = memory_ordering_default |
243       ((AS_DECORATOR_MASK &amp; memory_ordering_default) == 0 ? AS_NORMAL : DECORATORS_NONE);
244     static const DecoratorSet value = barrier_strength_default | BT_BUILDTIME_DECORATORS;
245   };
246 
</pre>
</td>
</tr>
</table>
<center><a href="accessBackend.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="method.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/accessBackend.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_ACCESSBACKEND_HPP
  26 #define SHARE_OOPS_ACCESSBACKEND_HPP
  27 
  28 #include &quot;gc/shared/barrierSetConfig.hpp&quot;
  29 #include &quot;memory/allocation.hpp&quot;
  30 #include &quot;metaprogramming/conditional.hpp&quot;
  31 #include &quot;metaprogramming/decay.hpp&quot;
  32 #include &quot;metaprogramming/enableIf.hpp&quot;
  33 #include &quot;metaprogramming/integralConstant.hpp&quot;
  34 #include &quot;metaprogramming/isFloatingPoint.hpp&quot;
  35 #include &quot;metaprogramming/isIntegral.hpp&quot;
  36 #include &quot;metaprogramming/isPointer.hpp&quot;
  37 #include &quot;metaprogramming/isSame.hpp&quot;
  38 #include &quot;metaprogramming/isVolatile.hpp&quot;
  39 #include &quot;oops/accessDecorators.hpp&quot;
  40 #include &quot;oops/oopsHierarchy.hpp&quot;
  41 #include &quot;runtime/globals.hpp&quot;
  42 #include &quot;utilities/debug.hpp&quot;
  43 #include &quot;utilities/globalDefinitions.hpp&quot;
  44 
  45 
  46 // This metafunction returns either oop or narrowOop depending on whether
  47 // an access needs to use compressed oops or not.
  48 template &lt;DecoratorSet decorators&gt;
  49 struct HeapOopType: AllStatic {
  50   static const bool needs_oop_compress = HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value &amp;&amp;
  51                                          HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value;
  52   typedef typename Conditional&lt;needs_oop_compress, narrowOop, oop&gt;::type type;
  53 };
  54 
<a name="1" id="anc1"></a>







  55 namespace AccessInternal {
  56   enum BarrierType {
  57     BARRIER_STORE,
  58     BARRIER_STORE_AT,
  59     BARRIER_LOAD,
  60     BARRIER_LOAD_AT,
  61     BARRIER_ATOMIC_CMPXCHG,
  62     BARRIER_ATOMIC_CMPXCHG_AT,
  63     BARRIER_ATOMIC_XCHG,
  64     BARRIER_ATOMIC_XCHG_AT,
  65     BARRIER_ARRAYCOPY,
  66     BARRIER_CLONE,
<a name="2" id="anc2"></a>
  67     BARRIER_RESOLVE
  68   };
  69 
  70   template &lt;DecoratorSet decorators, typename T&gt;
  71   struct MustConvertCompressedOop: public IntegralConstant&lt;bool,
  72     HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value &amp;&amp;
  73     IsSame&lt;typename HeapOopType&lt;decorators&gt;::type, narrowOop&gt;::value &amp;&amp;
  74     IsSame&lt;T, oop&gt;::value&gt; {};
  75 
  76   // This metafunction returns an appropriate oop type if the value is oop-like
  77   // and otherwise returns the same type T.
  78   template &lt;DecoratorSet decorators, typename T&gt;
  79   struct EncodedType: AllStatic {
  80     typedef typename Conditional&lt;
  81       HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
  82       typename HeapOopType&lt;decorators&gt;::type, T&gt;::type type;
  83   };
  84 
  85   template &lt;DecoratorSet decorators&gt;
  86   inline typename HeapOopType&lt;decorators&gt;::type*
  87   oop_field_addr(oop base, ptrdiff_t byte_offset) {
  88     return reinterpret_cast&lt;typename HeapOopType&lt;decorators&gt;::type*&gt;(
  89              reinterpret_cast&lt;intptr_t&gt;((void*)base) + byte_offset);
  90   }
  91 
  92   // This metafunction returns whether it is possible for a type T to require
  93   // locking to support wide atomics or not.
  94   template &lt;typename T&gt;
  95 #ifdef SUPPORTS_NATIVE_CX8
  96   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, false&gt; {};
  97 #else
  98   struct PossiblyLockedAccess: public IntegralConstant&lt;bool, (sizeof(T) &gt; 4)&gt; {};
  99 #endif
 100 
 101   template &lt;DecoratorSet decorators, typename T&gt;
 102   struct AccessFunctionTypes {
 103     typedef T (*load_at_func_t)(oop base, ptrdiff_t offset);
 104     typedef void (*store_at_func_t)(oop base, ptrdiff_t offset, T value);
 105     typedef T (*atomic_cmpxchg_at_func_t)(oop base, ptrdiff_t offset, T compare_value, T new_value);
 106     typedef T (*atomic_xchg_at_func_t)(oop base, ptrdiff_t offset, T new_value);
 107 
 108     typedef T (*load_func_t)(void* addr);
 109     typedef void (*store_func_t)(void* addr, T value);
 110     typedef T (*atomic_cmpxchg_func_t)(void* addr, T compare_value, T new_value);
 111     typedef T (*atomic_xchg_func_t)(void* addr, T new_value);
 112 
<a name="3" id="anc3"></a><span class="line-modified"> 113     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 114                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 115                                      size_t length);
 116     typedef void (*clone_func_t)(oop src, oop dst, size_t size);
<a name="4" id="anc4"></a>
 117     typedef oop (*resolve_func_t)(oop obj);
 118   };
 119 
 120   template &lt;DecoratorSet decorators&gt;
 121   struct AccessFunctionTypes&lt;decorators, void&gt; {
<a name="5" id="anc5"></a><span class="line-modified"> 122     typedef bool (*arraycopy_func_t)(arrayOop src_obj, size_t src_offset_in_bytes, void* src,</span>
 123                                      arrayOop dst_obj, size_t dst_offset_in_bytes, void* dst,
 124                                      size_t length);
 125   };
 126 
 127   template &lt;DecoratorSet decorators, typename T, BarrierType barrier&gt; struct AccessFunction {};
 128 
 129 #define ACCESS_GENERATE_ACCESS_FUNCTION(bt, func)                   \
 130   template &lt;DecoratorSet decorators, typename T&gt;                    \
 131   struct AccessFunction&lt;decorators, T, bt&gt;: AllStatic{              \
 132     typedef typename AccessFunctionTypes&lt;decorators, T&gt;::func type; \
 133   }
 134   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE, store_func_t);
 135   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_STORE_AT, store_at_func_t);
 136   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD, load_func_t);
 137   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_LOAD_AT, load_at_func_t);
 138   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG, atomic_cmpxchg_func_t);
 139   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_CMPXCHG_AT, atomic_cmpxchg_at_func_t);
 140   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG, atomic_xchg_func_t);
 141   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ATOMIC_XCHG_AT, atomic_xchg_at_func_t);
 142   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_ARRAYCOPY, arraycopy_func_t);
 143   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_CLONE, clone_func_t);
<a name="6" id="anc6"></a>
 144   ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);
 145 #undef ACCESS_GENERATE_ACCESS_FUNCTION
 146 
 147   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 148   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_barrier();
 149 
 150   template &lt;DecoratorSet decorators, typename T, BarrierType barrier_type&gt;
 151   typename AccessFunction&lt;decorators, T, barrier_type&gt;::type resolve_oop_barrier();
 152 
 153   class AccessLocker {
 154   public:
 155     AccessLocker();
 156     ~AccessLocker();
 157   };
 158   bool wide_atomic_needs_locking();
 159 
 160   void* field_addr(oop base, ptrdiff_t offset);
 161 
 162   // Forward calls to Copy:: in the cpp file to reduce dependencies and allow
 163   // faster build times, given how frequently included access is.
 164   void arraycopy_arrayof_conjoint_oops(void* src, void* dst, size_t length);
 165   void arraycopy_conjoint_oops(oop* src, oop* dst, size_t length);
 166   void arraycopy_conjoint_oops(narrowOop* src, narrowOop* dst, size_t length);
 167 
 168   void arraycopy_disjoint_words(void* src, void* dst, size_t length);
 169   void arraycopy_disjoint_words_atomic(void* src, void* dst, size_t length);
 170 
 171   template&lt;typename T&gt;
 172   void arraycopy_conjoint(T* src, T* dst, size_t length);
 173   template&lt;typename T&gt;
 174   void arraycopy_arrayof_conjoint(T* src, T* dst, size_t length);
 175   template&lt;typename T&gt;
 176   void arraycopy_conjoint_atomic(T* src, T* dst, size_t length);
 177 }
 178 
 179 // This mask specifies what decorators are relevant for raw accesses. When passing
 180 // accesses to the raw layer, irrelevant decorators are removed.
 181 const DecoratorSet RAW_DECORATOR_MASK = INTERNAL_DECORATOR_MASK | MO_DECORATOR_MASK |
 182                                         ARRAYCOPY_DECORATOR_MASK | IS_NOT_NULL;
 183 
 184 // The RawAccessBarrier performs raw accesses with additional knowledge of
 185 // memory ordering, so that OrderAccess/Atomic is called when necessary.
 186 // It additionally handles compressed oops, and hence is not completely &quot;raw&quot;
 187 // strictly speaking.
 188 template &lt;DecoratorSet decorators&gt;
 189 class RawAccessBarrier: public AllStatic {
 190 protected:
 191   static inline void* field_addr(oop base, ptrdiff_t byte_offset) {
 192     return AccessInternal::field_addr(base, byte_offset);
 193   }
 194 
 195 protected:
 196   // Only encode if INTERNAL_VALUE_IS_OOP
 197   template &lt;DecoratorSet idecorators, typename T&gt;
 198   static inline typename EnableIf&lt;
 199     AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value,
 200     typename HeapOopType&lt;idecorators&gt;::type&gt;::type
 201   encode_internal(T value);
 202 
 203   template &lt;DecoratorSet idecorators, typename T&gt;
 204   static inline typename EnableIf&lt;
 205     !AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 206   encode_internal(T value) {
 207     return value;
 208   }
 209 
 210   template &lt;typename T&gt;
 211   static inline typename AccessInternal::EncodedType&lt;decorators, T&gt;::type
 212   encode(T value) {
 213     return encode_internal&lt;decorators, T&gt;(value);
 214   }
 215 
 216   // Only decode if INTERNAL_VALUE_IS_OOP
 217   template &lt;DecoratorSet idecorators, typename T&gt;
 218   static inline typename EnableIf&lt;
 219     AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 220   decode_internal(typename HeapOopType&lt;idecorators&gt;::type value);
 221 
 222   template &lt;DecoratorSet idecorators, typename T&gt;
 223   static inline typename EnableIf&lt;
 224     !AccessInternal::MustConvertCompressedOop&lt;idecorators, T&gt;::value, T&gt;::type
 225   decode_internal(T value) {
 226     return value;
 227   }
 228 
 229   template &lt;typename T&gt;
 230   static inline T decode(typename AccessInternal::EncodedType&lt;decorators, T&gt;::type value) {
 231     return decode_internal&lt;decorators, T&gt;(value);
 232   }
 233 
 234 protected:
 235   template &lt;DecoratorSet ds, typename T&gt;
 236   static typename EnableIf&lt;
 237     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 238   load_internal(void* addr);
 239 
 240   template &lt;DecoratorSet ds, typename T&gt;
 241   static typename EnableIf&lt;
 242     HasDecorator&lt;ds, MO_ACQUIRE&gt;::value, T&gt;::type
 243   load_internal(void* addr);
 244 
 245   template &lt;DecoratorSet ds, typename T&gt;
 246   static typename EnableIf&lt;
 247     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
 248   load_internal(void* addr);
 249 
 250   template &lt;DecoratorSet ds, typename T&gt;
 251   static inline typename EnableIf&lt;
 252     HasDecorator&lt;ds, MO_UNORDERED&gt;::value, T&gt;::type
 253   load_internal(void* addr) {
 254     return *reinterpret_cast&lt;T*&gt;(addr);
 255   }
 256 
 257   template &lt;DecoratorSet ds, typename T&gt;
 258   static typename EnableIf&lt;
 259     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value&gt;::type
 260   store_internal(void* addr, T value);
 261 
 262   template &lt;DecoratorSet ds, typename T&gt;
 263   static typename EnableIf&lt;
 264     HasDecorator&lt;ds, MO_RELEASE&gt;::value&gt;::type
 265   store_internal(void* addr, T value);
 266 
 267   template &lt;DecoratorSet ds, typename T&gt;
 268   static typename EnableIf&lt;
 269     HasDecorator&lt;ds, MO_RELAXED&gt;::value&gt;::type
 270   store_internal(void* addr, T value);
 271 
 272   template &lt;DecoratorSet ds, typename T&gt;
 273   static inline typename EnableIf&lt;
 274     HasDecorator&lt;ds, MO_UNORDERED&gt;::value&gt;::type
 275   store_internal(void* addr, T value) {
 276     *reinterpret_cast&lt;T*&gt;(addr) = value;
 277   }
 278 
 279   template &lt;DecoratorSet ds, typename T&gt;
 280   static typename EnableIf&lt;
 281     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 282   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);
 283 
 284   template &lt;DecoratorSet ds, typename T&gt;
 285   static typename EnableIf&lt;
 286     HasDecorator&lt;ds, MO_RELAXED&gt;::value, T&gt;::type
 287   atomic_cmpxchg_internal(void* addr, T compare_value, T new_value);
 288 
 289   template &lt;DecoratorSet ds, typename T&gt;
 290   static typename EnableIf&lt;
 291     HasDecorator&lt;ds, MO_SEQ_CST&gt;::value, T&gt;::type
 292   atomic_xchg_internal(void* addr, T new_value);
 293 
 294   // The following *_locked mechanisms serve the purpose of handling atomic operations
 295   // that are larger than a machine can handle, and then possibly opt for using
 296   // a slower path using a mutex to perform the operation.
 297 
 298   template &lt;DecoratorSet ds, typename T&gt;
 299   static inline typename EnableIf&lt;
 300     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
 301   atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {
 302     return atomic_cmpxchg_internal&lt;ds&gt;(addr, compare_value, new_value);
 303   }
 304 
 305   template &lt;DecoratorSet ds, typename T&gt;
 306   static typename EnableIf&lt;
 307     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
 308   atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value);
 309 
 310   template &lt;DecoratorSet ds, typename T&gt;
 311   static inline typename EnableIf&lt;
 312     !AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
 313   atomic_xchg_maybe_locked(void* addr, T new_value) {
 314     return atomic_xchg_internal&lt;ds&gt;(addr, new_value);
 315   }
 316 
 317   template &lt;DecoratorSet ds, typename T&gt;
 318   static typename EnableIf&lt;
 319     AccessInternal::PossiblyLockedAccess&lt;T&gt;::value, T&gt;::type
 320   atomic_xchg_maybe_locked(void* addr, T new_value);
 321 
 322 public:
 323   template &lt;typename T&gt;
 324   static inline void store(void* addr, T value) {
 325     store_internal&lt;decorators&gt;(addr, value);
 326   }
 327 
 328   template &lt;typename T&gt;
 329   static inline T load(void* addr) {
 330     return load_internal&lt;decorators, T&gt;(addr);
 331   }
 332 
 333   template &lt;typename T&gt;
 334   static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 335     return atomic_cmpxchg_maybe_locked&lt;decorators&gt;(addr, compare_value, new_value);
 336   }
 337 
 338   template &lt;typename T&gt;
 339   static inline T atomic_xchg(void* addr, T new_value) {
 340     return atomic_xchg_maybe_locked&lt;decorators&gt;(addr, new_value);
 341   }
 342 
 343   template &lt;typename T&gt;
<a name="7" id="anc7"></a><span class="line-modified"> 344   static bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 345                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 346                         size_t length);
 347 
 348   template &lt;typename T&gt;
 349   static void oop_store(void* addr, T value);
 350   template &lt;typename T&gt;
 351   static void oop_store_at(oop base, ptrdiff_t offset, T value);
 352 
 353   template &lt;typename T&gt;
 354   static T oop_load(void* addr);
 355   template &lt;typename T&gt;
 356   static T oop_load_at(oop base, ptrdiff_t offset);
 357 
 358   template &lt;typename T&gt;
 359   static T oop_atomic_cmpxchg(void* addr, T compare_value, T new_value);
 360   template &lt;typename T&gt;
 361   static T oop_atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value);
 362 
 363   template &lt;typename T&gt;
 364   static T oop_atomic_xchg(void* addr, T new_value);
 365   template &lt;typename T&gt;
 366   static T oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value);
 367 
 368   template &lt;typename T&gt;
 369   static void store_at(oop base, ptrdiff_t offset, T value) {
 370     store(field_addr(base, offset), value);
 371   }
 372 
 373   template &lt;typename T&gt;
 374   static T load_at(oop base, ptrdiff_t offset) {
 375     return load&lt;T&gt;(field_addr(base, offset));
 376   }
 377 
 378   template &lt;typename T&gt;
 379   static T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
 380     return atomic_cmpxchg(field_addr(base, offset), compare_value, new_value);
 381   }
 382 
 383   template &lt;typename T&gt;
 384   static T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 385     return atomic_xchg(field_addr(base, offset), new_value);
 386   }
 387 
 388   template &lt;typename T&gt;
<a name="8" id="anc8"></a><span class="line-modified"> 389   static bool oop_arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 390                             arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 391                             size_t length);
 392 
 393   static void clone(oop src, oop dst, size_t size);
 394 
<a name="9" id="anc9"></a>

 395   static oop resolve(oop obj) { return obj; }
 396 };
 397 
 398 // Below is the implementation of the first 4 steps of the template pipeline:
 399 // * Step 1: Set default decorators and decay types. This step gets rid of CV qualifiers
 400 //           and sets default decorators to sensible values.
 401 // * Step 2: Reduce types. This step makes sure there is only a single T type and not
 402 //           multiple types. The P type of the address and T type of the value must
 403 //           match.
 404 // * Step 3: Pre-runtime dispatch. This step checks whether a runtime call can be
 405 //           avoided, and in that case avoids it (calling raw accesses or
 406 //           primitive accesses in a build that does not require primitive GC barriers)
 407 // * Step 4: Runtime-dispatch. This step performs a runtime dispatch to the corresponding
 408 //           BarrierSet::AccessBarrier accessor that attaches GC-required barriers
 409 //           to the access.
 410 
 411 namespace AccessInternal {
 412   template &lt;typename T&gt;
 413   struct OopOrNarrowOopInternal: AllStatic {
 414     typedef oop type;
 415   };
 416 
 417   template &lt;&gt;
 418   struct OopOrNarrowOopInternal&lt;narrowOop&gt;: AllStatic {
 419     typedef narrowOop type;
 420   };
 421 
 422   // This metafunction returns a canonicalized oop/narrowOop type for a passed
 423   // in oop-like types passed in from oop_* overloads where the user has sworn
 424   // that the passed in values should be oop-like (e.g. oop, oopDesc*, arrayOop,
 425   // narrowOoop, instanceOopDesc*, and random other things).
 426   // In the oop_* overloads, it must hold that if the passed in type T is not
 427   // narrowOop, then it by contract has to be one of many oop-like types implicitly
 428   // convertible to oop, and hence returns oop as the canonical oop type.
 429   // If it turns out it was not, then the implicit conversion to oop will fail
 430   // to compile, as desired.
 431   template &lt;typename T&gt;
 432   struct OopOrNarrowOop: AllStatic {
 433     typedef typename OopOrNarrowOopInternal&lt;typename Decay&lt;T&gt;::type&gt;::type type;
 434   };
 435 
 436   inline void* field_addr(oop base, ptrdiff_t byte_offset) {
 437     return reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;intptr_t&gt;((void*)base) + byte_offset);
 438   }
 439   // Step 4: Runtime dispatch
 440   // The RuntimeDispatch class is responsible for performing a runtime dispatch of the
 441   // accessor. This is required when the access either depends on whether compressed oops
 442   // is being used, or it depends on which GC implementation was chosen (e.g. requires GC
 443   // barriers). The way it works is that a function pointer initially pointing to an
 444   // accessor resolution function gets called for each access. Upon first invocation,
 445   // it resolves which accessor to be used in future invocations and patches the
 446   // function pointer to this new accessor.
 447 
 448   template &lt;DecoratorSet decorators, typename T, BarrierType type&gt;
 449   struct RuntimeDispatch: AllStatic {};
 450 
 451   template &lt;DecoratorSet decorators, typename T&gt;
 452   struct RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;: AllStatic {
 453     typedef typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type func_t;
 454     static func_t _store_func;
 455 
 456     static void store_init(void* addr, T value);
 457 
 458     static inline void store(void* addr, T value) {
 459       _store_func(addr, value);
 460     }
 461   };
 462 
 463   template &lt;DecoratorSet decorators, typename T&gt;
 464   struct RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;: AllStatic {
 465     typedef typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type func_t;
 466     static func_t _store_at_func;
 467 
 468     static void store_at_init(oop base, ptrdiff_t offset, T value);
 469 
 470     static inline void store_at(oop base, ptrdiff_t offset, T value) {
 471       _store_at_func(base, offset, value);
 472     }
 473   };
 474 
 475   template &lt;DecoratorSet decorators, typename T&gt;
 476   struct RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;: AllStatic {
 477     typedef typename AccessFunction&lt;decorators, T, BARRIER_LOAD&gt;::type func_t;
 478     static func_t _load_func;
 479 
 480     static T load_init(void* addr);
 481 
 482     static inline T load(void* addr) {
 483       return _load_func(addr);
 484     }
 485   };
 486 
 487   template &lt;DecoratorSet decorators, typename T&gt;
 488   struct RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;: AllStatic {
 489     typedef typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type func_t;
 490     static func_t _load_at_func;
 491 
 492     static T load_at_init(oop base, ptrdiff_t offset);
 493 
 494     static inline T load_at(oop base, ptrdiff_t offset) {
 495       return _load_at_func(base, offset);
 496     }
 497   };
 498 
 499   template &lt;DecoratorSet decorators, typename T&gt;
 500   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;: AllStatic {
 501     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type func_t;
 502     static func_t _atomic_cmpxchg_func;
 503 
 504     static T atomic_cmpxchg_init(void* addr, T compare_value, T new_value);
 505 
 506     static inline T atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 507       return _atomic_cmpxchg_func(addr, compare_value, new_value);
 508     }
 509   };
 510 
 511   template &lt;DecoratorSet decorators, typename T&gt;
 512   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;: AllStatic {
 513     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type func_t;
 514     static func_t _atomic_cmpxchg_at_func;
 515 
 516     static T atomic_cmpxchg_at_init(oop base, ptrdiff_t offset, T compare_value, T new_value);
 517 
 518     static inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
 519       return _atomic_cmpxchg_at_func(base, offset, compare_value, new_value);
 520     }
 521   };
 522 
 523   template &lt;DecoratorSet decorators, typename T&gt;
 524   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;: AllStatic {
 525     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type func_t;
 526     static func_t _atomic_xchg_func;
 527 
 528     static T atomic_xchg_init(void* addr, T new_value);
 529 
 530     static inline T atomic_xchg(void* addr, T new_value) {
 531       return _atomic_xchg_func(addr, new_value);
 532     }
 533   };
 534 
 535   template &lt;DecoratorSet decorators, typename T&gt;
 536   struct RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;: AllStatic {
 537     typedef typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type func_t;
 538     static func_t _atomic_xchg_at_func;
 539 
 540     static T atomic_xchg_at_init(oop base, ptrdiff_t offset, T new_value);
 541 
 542     static inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 543       return _atomic_xchg_at_func(base, offset, new_value);
 544     }
 545   };
 546 
 547   template &lt;DecoratorSet decorators, typename T&gt;
 548   struct RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;: AllStatic {
 549     typedef typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type func_t;
 550     static func_t _arraycopy_func;
 551 
<a name="10" id="anc10"></a><span class="line-modified"> 552     static bool arraycopy_init(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 553                                arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 554                                size_t length);
 555 
<a name="11" id="anc11"></a><span class="line-modified"> 556     static inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
 557                                  arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 558                                  size_t length) {
 559       return _arraycopy_func(src_obj, src_offset_in_bytes, src_raw,
 560                              dst_obj, dst_offset_in_bytes, dst_raw,
 561                              length);
 562     }
 563   };
 564 
 565   template &lt;DecoratorSet decorators, typename T&gt;
 566   struct RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;: AllStatic {
 567     typedef typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type func_t;
 568     static func_t _clone_func;
 569 
 570     static void clone_init(oop src, oop dst, size_t size);
 571 
 572     static inline void clone(oop src, oop dst, size_t size) {
 573       _clone_func(src, dst, size);
 574     }
 575   };
 576 
<a name="12" id="anc12"></a>











 577   template &lt;DecoratorSet decorators, typename T&gt;
 578   struct RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;: AllStatic {
 579     typedef typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type func_t;
 580     static func_t _resolve_func;
 581 
 582     static oop resolve_init(oop obj);
 583 
 584     static inline oop resolve(oop obj) {
 585       return _resolve_func(obj);
 586     }
 587   };
 588 
 589   // Initialize the function pointers to point to the resolving function.
 590   template &lt;DecoratorSet decorators, typename T&gt;
 591   typename AccessFunction&lt;decorators, T, BARRIER_STORE&gt;::type
 592   RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::_store_func = &amp;store_init;
 593 
 594   template &lt;DecoratorSet decorators, typename T&gt;
 595   typename AccessFunction&lt;decorators, T, BARRIER_STORE_AT&gt;::type
 596   RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::_store_at_func = &amp;store_at_init;
 597 
 598   template &lt;DecoratorSet decorators, typename T&gt;
 599   typename AccessFunction&lt;decorators, T, BARRIER_LOAD&gt;::type
 600   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::_load_func = &amp;load_init;
 601 
 602   template &lt;DecoratorSet decorators, typename T&gt;
 603   typename AccessFunction&lt;decorators, T, BARRIER_LOAD_AT&gt;::type
 604   RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::_load_at_func = &amp;load_at_init;
 605 
 606   template &lt;DecoratorSet decorators, typename T&gt;
 607   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::type
 608   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::_atomic_cmpxchg_func = &amp;atomic_cmpxchg_init;
 609 
 610   template &lt;DecoratorSet decorators, typename T&gt;
 611   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::type
 612   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::_atomic_cmpxchg_at_func = &amp;atomic_cmpxchg_at_init;
 613 
 614   template &lt;DecoratorSet decorators, typename T&gt;
 615   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::type
 616   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::_atomic_xchg_func = &amp;atomic_xchg_init;
 617 
 618   template &lt;DecoratorSet decorators, typename T&gt;
 619   typename AccessFunction&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::type
 620   RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::_atomic_xchg_at_func = &amp;atomic_xchg_at_init;
 621 
 622   template &lt;DecoratorSet decorators, typename T&gt;
 623   typename AccessFunction&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::type
 624   RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::_arraycopy_func = &amp;arraycopy_init;
 625 
 626   template &lt;DecoratorSet decorators, typename T&gt;
 627   typename AccessFunction&lt;decorators, T, BARRIER_CLONE&gt;::type
 628   RuntimeDispatch&lt;decorators, T, BARRIER_CLONE&gt;::_clone_func = &amp;clone_init;
 629 
<a name="13" id="anc13"></a>



 630   template &lt;DecoratorSet decorators, typename T&gt;
 631   typename AccessFunction&lt;decorators, T, BARRIER_RESOLVE&gt;::type
 632   RuntimeDispatch&lt;decorators, T, BARRIER_RESOLVE&gt;::_resolve_func = &amp;resolve_init;
 633 
 634   // Step 3: Pre-runtime dispatching.
 635   // The PreRuntimeDispatch class is responsible for filtering the barrier strength
 636   // decorators. That is, for AS_RAW, it hardwires the accesses without a runtime
 637   // dispatch point. Otherwise it goes through a runtime check if hardwiring was
 638   // not possible.
 639   struct PreRuntimeDispatch: AllStatic {
 640     template&lt;DecoratorSet decorators&gt;
 641     struct CanHardwireRaw: public IntegralConstant&lt;
 642       bool,
 643       !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // primitive access
 644       !HasDecorator&lt;decorators, INTERNAL_CONVERT_COMPRESSED_OOP&gt;::value || // don&#39;t care about compressed oops (oop* address)
 645       HasDecorator&lt;decorators, INTERNAL_RT_USE_COMPRESSED_OOPS&gt;::value&gt; // we can infer we use compressed oops (narrowOop* address)
 646     {};
 647 
 648     static const DecoratorSet convert_compressed_oops = INTERNAL_RT_USE_COMPRESSED_OOPS | INTERNAL_CONVERT_COMPRESSED_OOP;
 649 
 650     template&lt;DecoratorSet decorators&gt;
 651     static bool is_hardwired_primitive() {
 652       return !HasDecorator&lt;decorators, INTERNAL_BT_BARRIER_ON_PRIMITIVES&gt;::value &amp;&amp;
 653              !HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value;
 654     }
 655 
 656     template &lt;DecoratorSet decorators, typename T&gt;
 657     inline static typename EnableIf&lt;
 658       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value&gt;::type
 659     store(void* addr, T value) {
 660       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 661       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 662         Raw::oop_store(addr, value);
 663       } else {
 664         Raw::store(addr, value);
 665       }
 666     }
 667 
 668     template &lt;DecoratorSet decorators, typename T&gt;
 669     inline static typename EnableIf&lt;
 670       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value&gt;::type
 671     store(void* addr, T value) {
 672       if (UseCompressedOops) {
 673         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 674         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 675       } else {
 676         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 677         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 678       }
 679     }
 680 
 681     template &lt;DecoratorSet decorators, typename T&gt;
 682     inline static typename EnableIf&lt;
 683       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 684     store(void* addr, T value) {
 685       if (is_hardwired_primitive&lt;decorators&gt;()) {
 686         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 687         PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 688       } else {
 689         RuntimeDispatch&lt;decorators, T, BARRIER_STORE&gt;::store(addr, value);
 690       }
 691     }
 692 
 693     template &lt;DecoratorSet decorators, typename T&gt;
 694     inline static typename EnableIf&lt;
 695       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 696     store_at(oop base, ptrdiff_t offset, T value) {
 697       store&lt;decorators&gt;(field_addr(base, offset), value);
 698     }
 699 
 700     template &lt;DecoratorSet decorators, typename T&gt;
 701     inline static typename EnableIf&lt;
 702       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 703     store_at(oop base, ptrdiff_t offset, T value) {
 704       if (is_hardwired_primitive&lt;decorators&gt;()) {
 705         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 706         PreRuntimeDispatch::store_at&lt;expanded_decorators&gt;(base, offset, value);
 707       } else {
 708         RuntimeDispatch&lt;decorators, T, BARRIER_STORE_AT&gt;::store_at(base, offset, value);
 709       }
 710     }
 711 
 712     template &lt;DecoratorSet decorators, typename T&gt;
 713     inline static typename EnableIf&lt;
 714       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 715     load(void* addr) {
 716       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 717       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 718         return Raw::template oop_load&lt;T&gt;(addr);
 719       } else {
 720         return Raw::template load&lt;T&gt;(addr);
 721       }
 722     }
 723 
 724     template &lt;DecoratorSet decorators, typename T&gt;
 725     inline static typename EnableIf&lt;
 726       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 727     load(void* addr) {
 728       if (UseCompressedOops) {
 729         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 730         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 731       } else {
 732         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 733         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 734       }
 735     }
 736 
 737     template &lt;DecoratorSet decorators, typename T&gt;
 738     inline static typename EnableIf&lt;
 739       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 740     load(void* addr) {
 741       if (is_hardwired_primitive&lt;decorators&gt;()) {
 742         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 743         return PreRuntimeDispatch::load&lt;expanded_decorators, T&gt;(addr);
 744       } else {
 745         return RuntimeDispatch&lt;decorators, T, BARRIER_LOAD&gt;::load(addr);
 746       }
 747     }
 748 
 749     template &lt;DecoratorSet decorators, typename T&gt;
 750     inline static typename EnableIf&lt;
 751       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 752     load_at(oop base, ptrdiff_t offset) {
 753       return load&lt;decorators, T&gt;(field_addr(base, offset));
 754     }
 755 
 756     template &lt;DecoratorSet decorators, typename T&gt;
 757     inline static typename EnableIf&lt;
 758       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 759     load_at(oop base, ptrdiff_t offset) {
 760       if (is_hardwired_primitive&lt;decorators&gt;()) {
 761         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 762         return PreRuntimeDispatch::load_at&lt;expanded_decorators, T&gt;(base, offset);
 763       } else {
 764         return RuntimeDispatch&lt;decorators, T, BARRIER_LOAD_AT&gt;::load_at(base, offset);
 765       }
 766     }
 767 
 768     template &lt;DecoratorSet decorators, typename T&gt;
 769     inline static typename EnableIf&lt;
 770       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 771     atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 772       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 773       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 774         return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);
 775       } else {
 776         return Raw::atomic_cmpxchg(addr, compare_value, new_value);
 777       }
 778     }
 779 
 780     template &lt;DecoratorSet decorators, typename T&gt;
 781     inline static typename EnableIf&lt;
 782       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 783     atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 784       if (UseCompressedOops) {
 785         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 786         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
 787       } else {
 788         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 789         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
 790       }
 791     }
 792 
 793     template &lt;DecoratorSet decorators, typename T&gt;
 794     inline static typename EnableIf&lt;
 795       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 796     atomic_cmpxchg(void* addr, T compare_value, T new_value) {
 797       if (is_hardwired_primitive&lt;decorators&gt;()) {
 798         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 799         return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
 800       } else {
 801         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG&gt;::atomic_cmpxchg(addr, compare_value, new_value);
 802       }
 803     }
 804 
 805     template &lt;DecoratorSet decorators, typename T&gt;
 806     inline static typename EnableIf&lt;
 807       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 808     atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
 809       return atomic_cmpxchg&lt;decorators&gt;(field_addr(base, offset), compare_value, new_value);
 810     }
 811 
 812     template &lt;DecoratorSet decorators, typename T&gt;
 813     inline static typename EnableIf&lt;
 814       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 815     atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
 816       if (is_hardwired_primitive&lt;decorators&gt;()) {
 817         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 818         return PreRuntimeDispatch::atomic_cmpxchg_at&lt;expanded_decorators&gt;(base, offset, compare_value, new_value);
 819       } else {
 820         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_CMPXCHG_AT&gt;::atomic_cmpxchg_at(base, offset, compare_value, new_value);
 821       }
 822     }
 823 
 824     template &lt;DecoratorSet decorators, typename T&gt;
 825     inline static typename EnableIf&lt;
 826       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 827     atomic_xchg(void* addr, T new_value) {
 828       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 829       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
 830         return Raw::oop_atomic_xchg(addr, new_value);
 831       } else {
 832         return Raw::atomic_xchg(addr, new_value);
 833       }
 834     }
 835 
 836     template &lt;DecoratorSet decorators, typename T&gt;
 837     inline static typename EnableIf&lt;
 838       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, T&gt;::type
 839     atomic_xchg(void* addr, T new_value) {
 840       if (UseCompressedOops) {
 841         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
 842         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
 843       } else {
 844         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
 845         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
 846       }
 847     }
 848 
 849     template &lt;DecoratorSet decorators, typename T&gt;
 850     inline static typename EnableIf&lt;
 851       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 852     atomic_xchg(void* addr, T new_value) {
 853       if (is_hardwired_primitive&lt;decorators&gt;()) {
 854         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 855         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
 856       } else {
 857         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG&gt;::atomic_xchg(addr, new_value);
 858       }
 859     }
 860 
 861     template &lt;DecoratorSet decorators, typename T&gt;
 862     inline static typename EnableIf&lt;
 863       HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 864     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 865       return atomic_xchg&lt;decorators&gt;(field_addr(base, offset), new_value);
 866     }
 867 
 868     template &lt;DecoratorSet decorators, typename T&gt;
 869     inline static typename EnableIf&lt;
 870       !HasDecorator&lt;decorators, AS_RAW&gt;::value, T&gt;::type
 871     atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
 872       if (is_hardwired_primitive&lt;decorators&gt;()) {
 873         const DecoratorSet expanded_decorators = decorators | AS_RAW;
 874         return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(base, offset, new_value);
 875       } else {
 876         return RuntimeDispatch&lt;decorators, T, BARRIER_ATOMIC_XCHG_AT&gt;::atomic_xchg_at(base, offset, new_value);
 877       }
 878     }
 879 
 880     template &lt;DecoratorSet decorators, typename T&gt;
 881     inline static typename EnableIf&lt;
<a name="14" id="anc14"></a><span class="line-modified"> 882       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type</span>
 883     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 884               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 885               size_t length) {
 886       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 887       if (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value) {
<a name="15" id="anc15"></a><span class="line-modified"> 888         return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 889                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 890                                   length);</span>
 891       } else {
<a name="16" id="anc16"></a><span class="line-modified"> 892         return Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 893                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 894                               length);</span>
 895       }
 896     }
 897 
 898     template &lt;DecoratorSet decorators, typename T&gt;
 899     inline static typename EnableIf&lt;
<a name="17" id="anc17"></a><span class="line-modified"> 900       HasDecorator&lt;decorators, AS_RAW&gt;::value &amp;&amp; !CanHardwireRaw&lt;decorators&gt;::value, bool&gt;::type</span>
 901     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 902               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 903               size_t length) {
 904       if (UseCompressedOops) {
 905         const DecoratorSet expanded_decorators = decorators | convert_compressed_oops;
<a name="18" id="anc18"></a><span class="line-modified"> 906         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 907                                                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 908                                                                   length);</span>
 909       } else {
 910         const DecoratorSet expanded_decorators = decorators &amp; ~convert_compressed_oops;
<a name="19" id="anc19"></a><span class="line-modified"> 911         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 912                                                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 913                                                                   length);</span>
 914       }
 915     }
 916 
 917     template &lt;DecoratorSet decorators, typename T&gt;
 918     inline static typename EnableIf&lt;
<a name="20" id="anc20"></a><span class="line-modified"> 919       !HasDecorator&lt;decorators, AS_RAW&gt;::value, bool&gt;::type</span>
 920     arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 921               arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 922               size_t length) {
 923       if (is_hardwired_primitive&lt;decorators&gt;()) {
 924         const DecoratorSet expanded_decorators = decorators | AS_RAW;
<a name="21" id="anc21"></a><span class="line-modified"> 925         return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 926                                                                   dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 927                                                                   length);</span>
 928       } else {
<a name="22" id="anc22"></a><span class="line-modified"> 929         return RuntimeDispatch&lt;decorators, T, BARRIER_ARRAYCOPY&gt;::arraycopy(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified"> 930                                                                             dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified"> 931                                                                             length);</span>
 932       }
 933     }
 934 
 935     template &lt;DecoratorSet decorators&gt;
 936     inline static typename EnableIf&lt;
 937       HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 938     clone(oop src, oop dst, size_t size) {
 939       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 940       Raw::clone(src, dst, size);
 941     }
 942 
 943     template &lt;DecoratorSet decorators&gt;
 944     inline static typename EnableIf&lt;
 945       !HasDecorator&lt;decorators, AS_RAW&gt;::value&gt;::type
 946     clone(oop src, oop dst, size_t size) {
 947       RuntimeDispatch&lt;decorators, oop, BARRIER_CLONE&gt;::clone(src, dst, size);
 948     }
 949 
<a name="23" id="anc23"></a>
















 950     template &lt;DecoratorSet decorators&gt;
 951     inline static typename EnableIf&lt;
 952       HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 953     resolve(oop obj) {
 954       typedef RawAccessBarrier&lt;decorators &amp; RAW_DECORATOR_MASK&gt; Raw;
 955       return Raw::resolve(obj);
 956     }
 957 
 958     template &lt;DecoratorSet decorators&gt;
 959     inline static typename EnableIf&lt;
 960       !HasDecorator&lt;decorators, INTERNAL_BT_TO_SPACE_INVARIANT&gt;::value, oop&gt;::type
 961     resolve(oop obj) {
 962       return RuntimeDispatch&lt;decorators, oop, BARRIER_RESOLVE&gt;::resolve(obj);
 963     }
 964   };
 965 
 966   // Step 2: Reduce types.
 967   // Enforce that for non-oop types, T and P have to be strictly the same.
 968   // P is the type of the address and T is the type of the values.
 969   // As for oop types, it is allow to send T in {narrowOop, oop} and
 970   // P in {narrowOop, oop, HeapWord*}. The following rules apply according to
 971   // the subsequent table. (columns are P, rows are T)
 972   // |           | HeapWord  |   oop   | narrowOop |
 973   // |   oop     |  rt-comp  | hw-none |  hw-comp  |
 974   // | narrowOop |     x     |    x    |  hw-none  |
 975   //
 976   // x means not allowed
 977   // rt-comp means it must be checked at runtime whether the oop is compressed.
 978   // hw-none means it is statically known the oop will not be compressed.
 979   // hw-comp means it is statically known the oop will be compressed.
 980 
 981   template &lt;DecoratorSet decorators, typename T&gt;
 982   inline void store_reduce_types(T* addr, T value) {
 983     PreRuntimeDispatch::store&lt;decorators&gt;(addr, value);
 984   }
 985 
 986   template &lt;DecoratorSet decorators&gt;
 987   inline void store_reduce_types(narrowOop* addr, oop value) {
 988     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
 989                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
 990     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 991   }
 992 
 993   template &lt;DecoratorSet decorators&gt;
 994   inline void store_reduce_types(narrowOop* addr, narrowOop value) {
 995     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
 996                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
 997     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
 998   }
 999 
1000   template &lt;DecoratorSet decorators&gt;
1001   inline void store_reduce_types(HeapWord* addr, oop value) {
1002     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1003     PreRuntimeDispatch::store&lt;expanded_decorators&gt;(addr, value);
1004   }
1005 
1006   template &lt;DecoratorSet decorators, typename T&gt;
1007   inline T atomic_cmpxchg_reduce_types(T* addr, T compare_value, T new_value) {
1008     return PreRuntimeDispatch::atomic_cmpxchg&lt;decorators&gt;(addr, compare_value, new_value);
1009   }
1010 
1011   template &lt;DecoratorSet decorators&gt;
1012   inline oop atomic_cmpxchg_reduce_types(narrowOop* addr, oop compare_value, oop new_value) {
1013     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1014                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1015     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
1016   }
1017 
1018   template &lt;DecoratorSet decorators&gt;
1019   inline narrowOop atomic_cmpxchg_reduce_types(narrowOop* addr, narrowOop compare_value, narrowOop new_value) {
1020     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1021                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1022     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
1023   }
1024 
1025   template &lt;DecoratorSet decorators&gt;
1026   inline oop atomic_cmpxchg_reduce_types(HeapWord* addr,
1027                                          oop compare_value,
1028                                          oop new_value) {
1029     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1030     return PreRuntimeDispatch::atomic_cmpxchg&lt;expanded_decorators&gt;(addr, compare_value, new_value);
1031   }
1032 
1033   template &lt;DecoratorSet decorators, typename T&gt;
1034   inline T atomic_xchg_reduce_types(T* addr, T new_value) {
1035     const DecoratorSet expanded_decorators = decorators;
1036     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
1037   }
1038 
1039   template &lt;DecoratorSet decorators&gt;
1040   inline oop atomic_xchg_reduce_types(narrowOop* addr, oop new_value) {
1041     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1042                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1043     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
1044   }
1045 
1046   template &lt;DecoratorSet decorators&gt;
1047   inline narrowOop atomic_xchg_reduce_types(narrowOop* addr, narrowOop new_value) {
1048     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1049                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1050     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
1051   }
1052 
1053   template &lt;DecoratorSet decorators&gt;
1054   inline oop atomic_xchg_reduce_types(HeapWord* addr, oop new_value) {
1055     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1056     return PreRuntimeDispatch::atomic_xchg&lt;expanded_decorators&gt;(addr, new_value);
1057   }
1058 
1059   template &lt;DecoratorSet decorators, typename T&gt;
1060   inline T load_reduce_types(T* addr) {
1061     return PreRuntimeDispatch::load&lt;decorators, T&gt;(addr);
1062   }
1063 
1064   template &lt;DecoratorSet decorators, typename T&gt;
1065   inline typename OopOrNarrowOop&lt;T&gt;::type load_reduce_types(narrowOop* addr) {
1066     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1067                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
1068     return PreRuntimeDispatch::load&lt;expanded_decorators, typename OopOrNarrowOop&lt;T&gt;::type&gt;(addr);
1069   }
1070 
1071   template &lt;DecoratorSet decorators, typename T&gt;
1072   inline oop load_reduce_types(HeapWord* addr) {
1073     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
1074     return PreRuntimeDispatch::load&lt;expanded_decorators, oop&gt;(addr);
1075   }
1076 
1077   template &lt;DecoratorSet decorators, typename T&gt;
<a name="24" id="anc24"></a><span class="line-modified">1078   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
1079                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1080                                      size_t length) {
<a name="25" id="anc25"></a><span class="line-modified">1081     return PreRuntimeDispatch::arraycopy&lt;decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified">1082                                                      dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified">1083                                                      length);</span>
1084   }
1085 
1086   template &lt;DecoratorSet decorators&gt;
<a name="26" id="anc26"></a><span class="line-modified">1087   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, HeapWord* src_raw,</span>
1088                                      arrayOop dst_obj, size_t dst_offset_in_bytes, HeapWord* dst_raw,
1089                                      size_t length) {
1090     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP;
<a name="27" id="anc27"></a><span class="line-modified">1091     return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified">1092                                                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified">1093                                                               length);</span>
1094   }
1095 
1096   template &lt;DecoratorSet decorators&gt;
<a name="28" id="anc28"></a><span class="line-modified">1097   inline bool arraycopy_reduce_types(arrayOop src_obj, size_t src_offset_in_bytes, narrowOop* src_raw,</span>
1098                                      arrayOop dst_obj, size_t dst_offset_in_bytes, narrowOop* dst_raw,
1099                                      size_t length) {
1100     const DecoratorSet expanded_decorators = decorators | INTERNAL_CONVERT_COMPRESSED_OOP |
1101                                              INTERNAL_RT_USE_COMPRESSED_OOPS;
<a name="29" id="anc29"></a><span class="line-modified">1102     return PreRuntimeDispatch::arraycopy&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, src_raw,</span>
<span class="line-modified">1103                                                               dst_obj, dst_offset_in_bytes, dst_raw,</span>
<span class="line-modified">1104                                                               length);</span>
1105   }
1106 
1107   // Step 1: Set default decorators. This step remembers if a type was volatile
1108   // and then sets the MO_RELAXED decorator by default. Otherwise, a default
1109   // memory ordering is set for the access, and the implied decorator rules
1110   // are applied to select sensible defaults for decorators that have not been
1111   // explicitly set. For example, default object referent strength is set to strong.
1112   // This step also decays the types passed in (e.g. getting rid of CV qualifiers
1113   // and references from the types). This step also perform some type verification
1114   // that the passed in types make sense.
1115 
1116   template &lt;DecoratorSet decorators, typename T&gt;
1117   static void verify_types(){
1118     // If this fails to compile, then you have sent in something that is
1119     // not recognized as a valid primitive type to a primitive Access function.
1120     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value || // oops have already been validated
1121                    (IsPointer&lt;T&gt;::value || IsIntegral&lt;T&gt;::value) ||
1122                     IsFloatingPoint&lt;T&gt;::value)); // not allowed primitive type
1123   }
1124 
1125   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1126   inline void store(P* addr, T value) {
1127     verify_types&lt;decorators, T&gt;();
1128     typedef typename Decay&lt;P&gt;::type DecayedP;
1129     typedef typename Decay&lt;T&gt;::type DecayedT;
1130     DecayedT decayed_value = value;
1131     // If a volatile address is passed in but no memory ordering decorator,
1132     // set the memory ordering to MO_RELAXED by default.
1133     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1134       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1135       (MO_RELAXED | decorators) : decorators&gt;::value;
1136     store_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr), decayed_value);
1137   }
1138 
1139   template &lt;DecoratorSet decorators, typename T&gt;
1140   inline void store_at(oop base, ptrdiff_t offset, T value) {
1141     verify_types&lt;decorators, T&gt;();
1142     typedef typename Decay&lt;T&gt;::type DecayedT;
1143     DecayedT decayed_value = value;
1144     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1145                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1146                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1147     PreRuntimeDispatch::store_at&lt;expanded_decorators&gt;(base, offset, decayed_value);
1148   }
1149 
1150   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1151   inline T load(P* addr) {
1152     verify_types&lt;decorators, T&gt;();
1153     typedef typename Decay&lt;P&gt;::type DecayedP;
1154     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1155                                  typename OopOrNarrowOop&lt;T&gt;::type,
1156                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1157     // If a volatile address is passed in but no memory ordering decorator,
1158     // set the memory ordering to MO_RELAXED by default.
1159     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1160       (IsVolatile&lt;P&gt;::value &amp;&amp; !HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1161       (MO_RELAXED | decorators) : decorators&gt;::value;
1162     return load_reduce_types&lt;expanded_decorators, DecayedT&gt;(const_cast&lt;DecayedP*&gt;(addr));
1163   }
1164 
1165   template &lt;DecoratorSet decorators, typename T&gt;
1166   inline T load_at(oop base, ptrdiff_t offset) {
1167     verify_types&lt;decorators, T&gt;();
1168     typedef typename Conditional&lt;HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value,
1169                                  typename OopOrNarrowOop&lt;T&gt;::type,
1170                                  typename Decay&lt;T&gt;::type&gt;::type DecayedT;
1171     // Expand the decorators (figure out sensible defaults)
1172     // Potentially remember if we need compressed oop awareness
1173     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators |
1174                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1175                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1176     return PreRuntimeDispatch::load_at&lt;expanded_decorators, DecayedT&gt;(base, offset);
1177   }
1178 
1179   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1180   inline T atomic_cmpxchg(P* addr, T compare_value, T new_value) {
1181     verify_types&lt;decorators, T&gt;();
1182     typedef typename Decay&lt;P&gt;::type DecayedP;
1183     typedef typename Decay&lt;T&gt;::type DecayedT;
1184     DecayedT new_decayed_value = new_value;
1185     DecayedT compare_decayed_value = compare_value;
1186     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1187       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1188       (MO_SEQ_CST | decorators) : decorators&gt;::value;
1189     return atomic_cmpxchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),
1190                                                             compare_decayed_value,
1191                                                             new_decayed_value);
1192   }
1193 
1194   template &lt;DecoratorSet decorators, typename T&gt;
1195   inline T atomic_cmpxchg_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
1196     verify_types&lt;decorators, T&gt;();
1197     typedef typename Decay&lt;T&gt;::type DecayedT;
1198     DecayedT new_decayed_value = new_value;
1199     DecayedT compare_decayed_value = compare_value;
1200     // Determine default memory ordering
1201     const DecoratorSet expanded_decorators = DecoratorFixup&lt;
1202       (!HasDecorator&lt;decorators, MO_DECORATOR_MASK&gt;::value) ?
1203       (MO_SEQ_CST | decorators) : decorators&gt;::value;
1204     // Potentially remember that we need compressed oop awareness
1205     const DecoratorSet final_decorators = expanded_decorators |
1206                                           (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1207                                            INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE);
1208     return PreRuntimeDispatch::atomic_cmpxchg_at&lt;final_decorators&gt;(base, offset, compare_decayed_value,
1209                                                                    new_decayed_value);
1210   }
1211 
1212   template &lt;DecoratorSet decorators, typename P, typename T&gt;
1213   inline T atomic_xchg(P* addr, T new_value) {
1214     verify_types&lt;decorators, T&gt;();
1215     typedef typename Decay&lt;P&gt;::type DecayedP;
1216     typedef typename Decay&lt;T&gt;::type DecayedT;
1217     DecayedT new_decayed_value = new_value;
1218     // atomic_xchg is only available in SEQ_CST flavour.
1219     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST&gt;::value;
1220     return atomic_xchg_reduce_types&lt;expanded_decorators&gt;(const_cast&lt;DecayedP*&gt;(addr),
1221                                                          new_decayed_value);
1222   }
1223 
1224   template &lt;DecoratorSet decorators, typename T&gt;
1225   inline T atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
1226     verify_types&lt;decorators, T&gt;();
1227     typedef typename Decay&lt;T&gt;::type DecayedT;
1228     DecayedT new_decayed_value = new_value;
1229     // atomic_xchg is only available in SEQ_CST flavour.
1230     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | MO_SEQ_CST |
1231                                              (HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ?
1232                                               INTERNAL_CONVERT_COMPRESSED_OOP : DECORATORS_NONE)&gt;::value;
1233     return PreRuntimeDispatch::atomic_xchg_at&lt;expanded_decorators&gt;(base, offset, new_decayed_value);
1234   }
1235 
1236   template &lt;DecoratorSet decorators, typename T&gt;
<a name="30" id="anc30"></a><span class="line-modified">1237   inline bool arraycopy(arrayOop src_obj, size_t src_offset_in_bytes, const T* src_raw,</span>
1238                         arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
1239                         size_t length) {
1240     STATIC_ASSERT((HasDecorator&lt;decorators, INTERNAL_VALUE_IS_OOP&gt;::value ||
1241                    (IsSame&lt;T, void&gt;::value || IsIntegral&lt;T&gt;::value) ||
1242                     IsFloatingPoint&lt;T&gt;::value)); // arraycopy allows type erased void elements
1243     typedef typename Decay&lt;T&gt;::type DecayedT;
1244     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators | IS_ARRAY | IN_HEAP&gt;::value;
<a name="31" id="anc31"></a><span class="line-modified">1245     return arraycopy_reduce_types&lt;expanded_decorators&gt;(src_obj, src_offset_in_bytes, const_cast&lt;DecayedT*&gt;(src_raw),</span>
<span class="line-modified">1246                                                        dst_obj, dst_offset_in_bytes, const_cast&lt;DecayedT*&gt;(dst_raw),</span>
<span class="line-modified">1247                                                        length);</span>
1248   }
1249 
1250   template &lt;DecoratorSet decorators&gt;
1251   inline void clone(oop src, oop dst, size_t size) {
1252     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1253     PreRuntimeDispatch::clone&lt;expanded_decorators&gt;(src, dst, size);
1254   }
1255 
<a name="32" id="anc32"></a>





1256   template &lt;DecoratorSet decorators&gt;
1257   inline oop resolve(oop obj) {
1258     const DecoratorSet expanded_decorators = DecoratorFixup&lt;decorators&gt;::value;
1259     return PreRuntimeDispatch::resolve&lt;expanded_decorators&gt;(obj);
1260   }
1261 
1262   // Infer the type that should be returned from an Access::oop_load.
1263   template &lt;typename P, DecoratorSet decorators&gt;
1264   class OopLoadProxy: public StackObj {
1265   private:
1266     P *const _addr;
1267   public:
1268     OopLoadProxy(P* addr) : _addr(addr) {}
1269 
1270     inline operator oop() {
1271       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, oop&gt;(_addr);
1272     }
1273 
1274     inline operator narrowOop() {
1275       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, narrowOop&gt;(_addr);
1276     }
1277 
1278     template &lt;typename T&gt;
1279     inline bool operator ==(const T&amp; other) const {
1280       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, T&gt;(_addr) == other;
1281     }
1282 
1283     template &lt;typename T&gt;
1284     inline bool operator !=(const T&amp; other) const {
1285       return load&lt;decorators | INTERNAL_VALUE_IS_OOP, P, T&gt;(_addr) != other;
1286     }
1287   };
1288 
1289   // Infer the type that should be returned from an Access::load_at.
1290   template &lt;DecoratorSet decorators&gt;
1291   class LoadAtProxy: public StackObj {
1292   private:
1293     const oop _base;
1294     const ptrdiff_t _offset;
1295   public:
1296     LoadAtProxy(oop base, ptrdiff_t offset) : _base(base), _offset(offset) {}
1297 
1298     template &lt;typename T&gt;
1299     inline operator T() const {
1300       return load_at&lt;decorators, T&gt;(_base, _offset);
1301     }
1302 
1303     template &lt;typename T&gt;
1304     inline bool operator ==(const T&amp; other) const { return load_at&lt;decorators, T&gt;(_base, _offset) == other; }
1305 
1306     template &lt;typename T&gt;
1307     inline bool operator !=(const T&amp; other) const { return load_at&lt;decorators, T&gt;(_base, _offset) != other; }
1308   };
1309 
1310   // Infer the type that should be returned from an Access::oop_load_at.
1311   template &lt;DecoratorSet decorators&gt;
1312   class OopLoadAtProxy: public StackObj {
1313   private:
1314     const oop _base;
1315     const ptrdiff_t _offset;
1316   public:
1317     OopLoadAtProxy(oop base, ptrdiff_t offset) : _base(base), _offset(offset) {}
1318 
1319     inline operator oop() const {
1320       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, oop&gt;(_base, _offset);
1321     }
1322 
1323     inline operator narrowOop() const {
1324       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, narrowOop&gt;(_base, _offset);
1325     }
1326 
1327     template &lt;typename T&gt;
1328     inline bool operator ==(const T&amp; other) const {
1329       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, T&gt;(_base, _offset) == other;
1330     }
1331 
1332     template &lt;typename T&gt;
1333     inline bool operator !=(const T&amp; other) const {
1334       return load_at&lt;decorators | INTERNAL_VALUE_IS_OOP, T&gt;(_base, _offset) != other;
1335     }
1336   };
1337 }
1338 
1339 #endif // SHARE_OOPS_ACCESSBACKEND_HPP
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>
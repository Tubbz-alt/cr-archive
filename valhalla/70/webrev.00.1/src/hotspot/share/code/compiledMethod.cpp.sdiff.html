<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/compiledMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/compiledMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
271 
272 void CompiledMethod::verify_oop_relocations() {
273   // Ensure sure that the code matches the current oop values
274   RelocIterator iter(this, NULL, NULL);
275   while (iter.next()) {
276     if (iter.type() == relocInfo::oop_type) {
277       oop_Relocation* reloc = iter.oop_reloc();
278       if (!reloc-&gt;oop_is_immediate()) {
279         reloc-&gt;verify_oop_relocation();
280       }
281     }
282   }
283 }
284 
285 
286 ScopeDesc* CompiledMethod::scope_desc_at(address pc) {
287   PcDesc* pd = pc_desc_at(pc);
288   guarantee(pd != NULL, &quot;scope must be present&quot;);
289   return new ScopeDesc(this, pd-&gt;scope_decode_offset(),
290                        pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
<span class="line-modified">291                        pd-&gt;return_oop());</span>
292 }
293 
294 ScopeDesc* CompiledMethod::scope_desc_near(address pc) {
295   PcDesc* pd = pc_desc_near(pc);
296   guarantee(pd != NULL, &quot;scope must be present&quot;);
297   return new ScopeDesc(this, pd-&gt;scope_decode_offset(),
298                        pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
<span class="line-modified">299                        pd-&gt;return_oop());</span>
300 }
301 
302 address CompiledMethod::oops_reloc_begin() const {
303   // If the method is not entrant or zombie then a JMP is plastered over the
304   // first few bytes.  If an oop in the old code was there, that oop
305   // should not get GC&#39;d.  Skip the first few bytes of oops on
306   // not-entrant methods.
307   if (frame_complete_offset() != CodeOffsets::frame_never_safe &amp;&amp;
308       code_begin() + frame_complete_offset() &gt;
309       verified_entry_point() + NativeJump::instruction_size)
310   {
311     // If we have a frame_complete_offset after the native jump, then there
312     // is no point trying to look for oops before that. This is a requirement
313     // for being allowed to scan oops concurrently.
314     return code_begin() + frame_complete_offset();
315   }
316 
317   // It is not safe to read oops concurrently using entry barriers, if their
318   // location depend on whether the nmethod is entrant or not.
319   assert(BarrierSet::barrier_set()-&gt;barrier_set_nmethod() == NULL, &quot;Not safe oop scan&quot;);
</pre>
<hr />
<pre>
339       if (CompiledIC::is_icholder_call_site(iter.virtual_call_reloc(), this)) {
340         CompiledIC *ic = CompiledIC_at(&amp;iter);
341         if (TraceCompiledIC) {
342           tty-&gt;print(&quot;noticed icholder &quot; INTPTR_FORMAT &quot; &quot;, p2i(ic-&gt;cached_icholder()));
343           ic-&gt;print();
344         }
345         assert(ic-&gt;cached_icholder() != NULL, &quot;must be non-NULL&quot;);
346         count++;
347       }
348     }
349   }
350 
351   return count;
352 }
353 
354 // Method that knows how to preserve outgoing arguments at call. This method must be
355 // called with a frame corresponding to a Java invoke
356 void CompiledMethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {
357   if (method() != NULL &amp;&amp; !method()-&gt;is_native()) {
358     address pc = fr.pc();
<span class="line-removed">359     SimpleScopeDesc ssd(this, pc);</span>
<span class="line-removed">360     Bytecode_invoke call(methodHandle(Thread::current(), ssd.method()), ssd.bci());</span>
<span class="line-removed">361     bool has_receiver = call.has_receiver();</span>
<span class="line-removed">362     bool has_appendix = call.has_appendix();</span>
<span class="line-removed">363     Symbol* signature = call.signature();</span>
<span class="line-removed">364 </span>
365     // The method attached by JIT-compilers should be used, if present.
366     // Bytecode can be inaccurate in such case.
367     Method* callee = attached_method_before_pc(pc);



368     if (callee != NULL) {
369       has_receiver = !(callee-&gt;access_flags().is_static());
370       has_appendix = false;
371       signature = callee-&gt;signature();

















372     }
373 
374     fr.oops_compiled_arguments_do(signature, has_receiver, has_appendix, reg_map, f);
375   }
376 }
377 
378 Method* CompiledMethod::attached_method(address call_instr) {
379   assert(code_contains(call_instr), &quot;not part of the nmethod&quot;);
380   RelocIterator iter(this, call_instr, call_instr + 1);
381   while (iter.next()) {
382     if (iter.addr() == call_instr) {
383       switch(iter.type()) {
384         case relocInfo::static_call_type:      return iter.static_call_reloc()-&gt;method_value();
385         case relocInfo::opt_virtual_call_type: return iter.opt_virtual_call_reloc()-&gt;method_value();
386         case relocInfo::virtual_call_type:     return iter.virtual_call_reloc()-&gt;method_value();
387         default:                               break;
388       }
389     }
390   }
391   return NULL; // not found
</pre>
</td>
<td>
<hr />
<pre>
271 
272 void CompiledMethod::verify_oop_relocations() {
273   // Ensure sure that the code matches the current oop values
274   RelocIterator iter(this, NULL, NULL);
275   while (iter.next()) {
276     if (iter.type() == relocInfo::oop_type) {
277       oop_Relocation* reloc = iter.oop_reloc();
278       if (!reloc-&gt;oop_is_immediate()) {
279         reloc-&gt;verify_oop_relocation();
280       }
281     }
282   }
283 }
284 
285 
286 ScopeDesc* CompiledMethod::scope_desc_at(address pc) {
287   PcDesc* pd = pc_desc_at(pc);
288   guarantee(pd != NULL, &quot;scope must be present&quot;);
289   return new ScopeDesc(this, pd-&gt;scope_decode_offset(),
290                        pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
<span class="line-modified">291                        pd-&gt;return_oop(), pd-&gt;return_vt());</span>
292 }
293 
294 ScopeDesc* CompiledMethod::scope_desc_near(address pc) {
295   PcDesc* pd = pc_desc_near(pc);
296   guarantee(pd != NULL, &quot;scope must be present&quot;);
297   return new ScopeDesc(this, pd-&gt;scope_decode_offset(),
298                        pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
<span class="line-modified">299                        pd-&gt;return_oop(), pd-&gt;return_vt());</span>
300 }
301 
302 address CompiledMethod::oops_reloc_begin() const {
303   // If the method is not entrant or zombie then a JMP is plastered over the
304   // first few bytes.  If an oop in the old code was there, that oop
305   // should not get GC&#39;d.  Skip the first few bytes of oops on
306   // not-entrant methods.
307   if (frame_complete_offset() != CodeOffsets::frame_never_safe &amp;&amp;
308       code_begin() + frame_complete_offset() &gt;
309       verified_entry_point() + NativeJump::instruction_size)
310   {
311     // If we have a frame_complete_offset after the native jump, then there
312     // is no point trying to look for oops before that. This is a requirement
313     // for being allowed to scan oops concurrently.
314     return code_begin() + frame_complete_offset();
315   }
316 
317   // It is not safe to read oops concurrently using entry barriers, if their
318   // location depend on whether the nmethod is entrant or not.
319   assert(BarrierSet::barrier_set()-&gt;barrier_set_nmethod() == NULL, &quot;Not safe oop scan&quot;);
</pre>
<hr />
<pre>
339       if (CompiledIC::is_icholder_call_site(iter.virtual_call_reloc(), this)) {
340         CompiledIC *ic = CompiledIC_at(&amp;iter);
341         if (TraceCompiledIC) {
342           tty-&gt;print(&quot;noticed icholder &quot; INTPTR_FORMAT &quot; &quot;, p2i(ic-&gt;cached_icholder()));
343           ic-&gt;print();
344         }
345         assert(ic-&gt;cached_icholder() != NULL, &quot;must be non-NULL&quot;);
346         count++;
347       }
348     }
349   }
350 
351   return count;
352 }
353 
354 // Method that knows how to preserve outgoing arguments at call. This method must be
355 // called with a frame corresponding to a Java invoke
356 void CompiledMethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {
357   if (method() != NULL &amp;&amp; !method()-&gt;is_native()) {
358     address pc = fr.pc();






359     // The method attached by JIT-compilers should be used, if present.
360     // Bytecode can be inaccurate in such case.
361     Method* callee = attached_method_before_pc(pc);
<span class="line-added">362     bool has_receiver = false;</span>
<span class="line-added">363     bool has_appendix = false;</span>
<span class="line-added">364     Symbol* signature = NULL;</span>
365     if (callee != NULL) {
366       has_receiver = !(callee-&gt;access_flags().is_static());
367       has_appendix = false;
368       signature = callee-&gt;signature();
<span class="line-added">369 </span>
<span class="line-added">370       // If value types are passed as fields, use the extended signature</span>
<span class="line-added">371       // which contains the types of all (oop) fields of the value type.</span>
<span class="line-added">372       if (this-&gt;is_compiled_by_c2() &amp;&amp; callee-&gt;has_scalarized_args()) {</span>
<span class="line-added">373         const GrowableArray&lt;SigEntry&gt;* sig = callee-&gt;adapter()-&gt;get_sig_cc();</span>
<span class="line-added">374         assert(sig != NULL, &quot;sig should never be null&quot;);</span>
<span class="line-added">375         TempNewSymbol tmp_sig = SigEntry::create_symbol(sig);</span>
<span class="line-added">376         has_receiver = false; // The extended signature contains the receiver type</span>
<span class="line-added">377         fr.oops_compiled_arguments_do(tmp_sig, has_receiver, has_appendix, reg_map, f);</span>
<span class="line-added">378         return;</span>
<span class="line-added">379       }</span>
<span class="line-added">380     } else {</span>
<span class="line-added">381       SimpleScopeDesc ssd(this, pc);</span>
<span class="line-added">382       Bytecode_invoke call(methodHandle(Thread::current(), ssd.method()), ssd.bci());</span>
<span class="line-added">383       has_receiver = call.has_receiver();</span>
<span class="line-added">384       has_appendix = call.has_appendix();</span>
<span class="line-added">385       signature = call.signature();</span>
386     }
387 
388     fr.oops_compiled_arguments_do(signature, has_receiver, has_appendix, reg_map, f);
389   }
390 }
391 
392 Method* CompiledMethod::attached_method(address call_instr) {
393   assert(code_contains(call_instr), &quot;not part of the nmethod&quot;);
394   RelocIterator iter(this, call_instr, call_instr + 1);
395   while (iter.next()) {
396     if (iter.addr() == call_instr) {
397       switch(iter.type()) {
398         case relocInfo::static_call_type:      return iter.static_call_reloc()-&gt;method_value();
399         case relocInfo::opt_virtual_call_type: return iter.opt_virtual_call_reloc()-&gt;method_value();
400         case relocInfo::virtual_call_type:     return iter.virtual_call_reloc()-&gt;method_value();
401         default:                               break;
402       }
403     }
404   }
405   return NULL; // not found
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
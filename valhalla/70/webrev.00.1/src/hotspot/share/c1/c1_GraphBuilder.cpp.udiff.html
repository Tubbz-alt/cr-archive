<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/stubGenerator_x86_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Instruction.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -31,10 +31,11 @@</span>
  #include &quot;ci/ciCallSite.hpp&quot;
  #include &quot;ci/ciField.hpp&quot;
  #include &quot;ci/ciKlass.hpp&quot;
  #include &quot;ci/ciMemberName.hpp&quot;
  #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;ci/ciValueKlass.hpp&quot;</span>
  #include &quot;compiler/compilationPolicy.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/compilerEvent.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -654,10 +655,21 @@</span>
      } else {
        _fields.at(index)-&gt;kill();
      }
    }
  
<span class="udiff-line-added">+   // Record this newly allocated object</span>
<span class="udiff-line-added">+   void new_instance(NewValueTypeInstance* object) {</span>
<span class="udiff-line-added">+     int index = _newobjects.length();</span>
<span class="udiff-line-added">+     _newobjects.append(object);</span>
<span class="udiff-line-added">+     if (_fields.at_grow(index, NULL) == NULL) {</span>
<span class="udiff-line-added">+       _fields.at_put(index, new FieldBuffer());</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       _fields.at(index)-&gt;kill();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    void store_value(Value value) {
      int index = _newobjects.find(value);
      if (index != -1) {
        // stored a newly allocated object into another object.
        // Assume we&#39;ve lost track of it as separate slice of memory.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -969,38 +981,80 @@</span>
      } else if (index == scope_data()-&gt;jsr_return_address_local()) {
        scope_data()-&gt;set_jsr_return_address_local(-1);
      }
    }
  
<span class="udiff-line-added">+   x-&gt;set_local_index(index);</span>
    state-&gt;store_local(index, round_fp(x));
  }
  
  
  void GraphBuilder::load_indexed(BasicType type) {
    // In case of in block code motion in range check elimination
<span class="udiff-line-modified-removed">-   ValueStack* state_before = copy_state_indexed_access();</span>
<span class="udiff-line-modified-added">+   ValueStack* state_before = NULL;</span>
<span class="udiff-line-added">+   int array_idx = state()-&gt;stack_size() - 2;</span>
<span class="udiff-line-added">+   if (type == T_OBJECT &amp;&amp; state()-&gt;stack_at(array_idx)-&gt;maybe_flattened_array()) {</span>
<span class="udiff-line-added">+     // Save the entire state and re-execute on deopt when accessing flattened arrays</span>
<span class="udiff-line-added">+     state_before = copy_state_before();</span>
<span class="udiff-line-added">+     state_before-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     state_before = copy_state_indexed_access();</span>
<span class="udiff-line-added">+   }</span>
    compilation()-&gt;set_has_access_indexed(true);
    Value index = ipop();
    Value array = apop();
    Value length = NULL;
    if (CSEArrayLength ||
        (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
        (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
      length = append(new ArrayLength(array, state_before));
    }
<span class="udiff-line-modified-removed">-   push(as_ValueType(type), append(new LoadIndexed(array, index, length, type, state_before)));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   LoadIndexed* load_indexed = NULL;</span>
<span class="udiff-line-added">+   Instruction* result = NULL;</span>
<span class="udiff-line-added">+   if (array-&gt;is_loaded_flattened_array()) {</span>
<span class="udiff-line-added">+     ciType* array_type = array-&gt;declared_type();</span>
<span class="udiff-line-added">+     ciValueKlass* elem_klass = array_type-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="udiff-line-added">+     NewValueTypeInstance* new_instance = new NewValueTypeInstance(elem_klass, state_before, false);</span>
<span class="udiff-line-added">+     _memory-&gt;new_instance(new_instance);</span>
<span class="udiff-line-added">+     apush(append_split(new_instance));</span>
<span class="udiff-line-added">+     load_indexed = new LoadIndexed(array, index, length, type, state_before);</span>
<span class="udiff-line-added">+     load_indexed-&gt;set_vt(new_instance);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     load_indexed = new LoadIndexed(array, index, length, type, state_before);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {</span>
<span class="udiff-line-added">+     compilation()-&gt;set_would_profile(true);</span>
<span class="udiff-line-added">+     load_indexed-&gt;set_should_profile(true);</span>
<span class="udiff-line-added">+     load_indexed-&gt;set_profiled_method(method());</span>
<span class="udiff-line-added">+     load_indexed-&gt;set_profiled_bci(bci());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   result = append(load_indexed);</span>
<span class="udiff-line-added">+   assert(!(profile_array_accesses() &amp;&amp; is_reference_type(type)) || load_indexed == result, &quot;should not be optimized out&quot;);</span>
<span class="udiff-line-added">+   if (!array-&gt;is_loaded_flattened_array()) {</span>
<span class="udiff-line-added">+     push(as_ValueType(type), result);</span>
<span class="udiff-line-added">+   }</span>
  }
  
  
  void GraphBuilder::store_indexed(BasicType type) {
    // In case of in block code motion in range check elimination
<span class="udiff-line-modified-removed">-   ValueStack* state_before = copy_state_indexed_access();</span>
<span class="udiff-line-modified-added">+   ValueStack* state_before = NULL;</span>
<span class="udiff-line-added">+   int array_idx = state()-&gt;stack_size() - 3;</span>
<span class="udiff-line-added">+   if (type == T_OBJECT &amp;&amp; state()-&gt;stack_at(array_idx)-&gt;maybe_flattened_array()) {</span>
<span class="udiff-line-added">+     // Save the entire state and re-execute on deopt when accessing flattened arrays</span>
<span class="udiff-line-added">+     state_before = copy_state_before();</span>
<span class="udiff-line-added">+     state_before-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     state_before = copy_state_indexed_access();</span>
<span class="udiff-line-added">+   }</span>
    compilation()-&gt;set_has_access_indexed(true);
    Value value = pop(as_ValueType(type));
    Value index = ipop();
    Value array = apop();
    Value length = NULL;
<span class="udiff-line-added">+   value-&gt;set_escaped();</span>
    if (CSEArrayLength ||
        (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
        (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
      length = append(new ArrayLength(array, state_before));
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1014,24 +1068,22 @@</span>
        value = append(new LogicOp(Bytecodes::_iand, value, mask));
      }
    } else if (type == T_BYTE) {
      check_boolean = true;
    }
<span class="udiff-line-modified-removed">-   StoreIndexed* result = new StoreIndexed(array, index, length, type, value, state_before, check_boolean);</span>
<span class="udiff-line-modified-removed">-   append(result);</span>
<span class="udiff-line-removed">-   _memory-&gt;store_value(value);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (type == T_OBJECT &amp;&amp; is_profiling()) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   StoreIndexed* store_indexed = new StoreIndexed(array, index, length, type, value, state_before, check_boolean);</span>
    if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {
      compilation()-&gt;set_would_profile(true);
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (profile_checkcasts()) {</span>
<span class="udiff-line-modified-removed">-       result-&gt;set_profiled_method(method());</span>
<span class="udiff-line-removed">-       result-&gt;set_profiled_bci(bci());</span>
<span class="udiff-line-removed">-       result-&gt;set_should_profile(true);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     store_indexed-&gt;set_should_profile(true);</span>
<span class="udiff-line-modified-added">+     store_indexed-&gt;set_profiled_method(method());</span>
<span class="udiff-line-modified-added">+     store_indexed-&gt;set_profiled_bci(bci());</span>
    }
<span class="udiff-line-added">+   Instruction* result = append(store_indexed);</span>
<span class="udiff-line-added">+   assert(!store_indexed-&gt;should_profile() || store_indexed == result, &quot;should not be optimized out&quot;);</span>
<span class="udiff-line-added">+   _memory-&gt;store_value(value);</span>
<span class="udiff-line-added">+ </span>
  }
  
  
  void GraphBuilder::stack_op(Bytecodes::Code code) {
    switch (code) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1222,13 +1274,39 @@</span>
  
  void GraphBuilder::if_node(Value x, If::Condition cond, Value y, ValueStack* state_before) {
    BlockBegin* tsux = block_at(stream()-&gt;get_dest());
    BlockBegin* fsux = block_at(stream()-&gt;next_bci());
    bool is_bb = tsux-&gt;bci() &lt; stream()-&gt;cur_bci() || fsux-&gt;bci() &lt; stream()-&gt;cur_bci();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool subst_check = false;</span>
<span class="udiff-line-added">+   if (EnableValhalla &amp;&amp; (stream()-&gt;cur_bc() == Bytecodes::_if_acmpeq || stream()-&gt;cur_bc() == Bytecodes::_if_acmpne) &amp;&amp;</span>
<span class="udiff-line-added">+       method() != ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature())) {</span>
<span class="udiff-line-added">+     // If current method is ValueBootstrapMethods::isSubstitutable(),</span>
<span class="udiff-line-added">+     // compile the acmp as a regular pointer comparison otherwise we</span>
<span class="udiff-line-added">+     // could call ValueBootstrapMethods::isSubstitutable() back</span>
<span class="udiff-line-added">+     ValueType* left_vt = x-&gt;type();</span>
<span class="udiff-line-added">+     ValueType* right_vt = y-&gt;type();</span>
<span class="udiff-line-added">+     if (left_vt-&gt;is_object()) {</span>
<span class="udiff-line-added">+       assert(right_vt-&gt;is_object(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+       ciKlass* left_klass = x-&gt;as_loaded_klass_or_null();</span>
<span class="udiff-line-added">+       ciKlass* right_klass = y-&gt;as_loaded_klass_or_null();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (left_klass == NULL || right_klass == NULL) {</span>
<span class="udiff-line-added">+         // The klass is still unloaded, or came from a Phi node. Go slow case;</span>
<span class="udiff-line-added">+         subst_check = true;</span>
<span class="udiff-line-added">+       } else if (left_klass-&gt;can_be_value_klass() || right_klass-&gt;can_be_value_klass()) {</span>
<span class="udiff-line-added">+         // Either operand may be a value object, but we&#39;re not sure. Go slow case;</span>
<span class="udiff-line-added">+         subst_check = true;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         // No need to do substitutability check</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // In case of loop invariant code motion or predicate insertion
    // before the body of a loop the state is needed
<span class="udiff-line-modified-removed">-   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic()) ? state_before : NULL, is_bb));</span>
<span class="udiff-line-modified-added">+   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic() || subst_check) ? state_before : NULL, is_bb, subst_check));</span>
  
    assert(i-&gt;as_Goto() == NULL ||
           (i-&gt;as_Goto()-&gt;sux_at(0) == tsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == tsux-&gt;bci() &lt; stream()-&gt;cur_bci()) ||
           (i-&gt;as_Goto()-&gt;sux_at(0) == fsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == fsux-&gt;bci() &lt; stream()-&gt;cur_bci()),
           &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1475,11 +1553,11 @@</span>
      call_register_finalizer();
    }
  
    // The conditions for a memory barrier are described in Parse::do_exits().
    bool need_mem_bar = false;
<span class="udiff-line-modified-removed">-   if (method()-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;</span>
<span class="udiff-line-modified-added">+   if (method()-&gt;is_object_constructor() &amp;&amp;</span>
         (scope()-&gt;wrote_final() ||
           (AlwaysSafeConstructors &amp;&amp; scope()-&gt;wrote_fields()) ||
           (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; scope()-&gt;wrote_volatile()))) {
      need_mem_bar = true;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1626,16 +1704,31 @@</span>
      default:
        return new Constant(value);
    }
  }
  
<span class="udiff-line-added">+ void GraphBuilder::copy_value_content(ciValueKlass* vk, Value src, int src_off, Value dest, int dest_off,</span>
<span class="udiff-line-added">+     ValueStack* state_before, bool needs_patching) {</span>
<span class="udiff-line-added">+   src-&gt;set_escaped();</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; vk-&gt;nof_nonstatic_fields(); i++) {</span>
<span class="udiff-line-added">+     ciField* inner_field = vk-&gt;nonstatic_field_at(i);</span>
<span class="udiff-line-added">+     assert(!inner_field-&gt;is_flattened(), &quot;the iteration over nested fields is handled by the loop itself&quot;);</span>
<span class="udiff-line-added">+     int off = inner_field-&gt;offset() - vk-&gt;first_field_offset();</span>
<span class="udiff-line-added">+     LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, needs_patching);</span>
<span class="udiff-line-added">+     Value replacement = append(load);</span>
<span class="udiff-line-added">+     StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, needs_patching);</span>
<span class="udiff-line-added">+     append(store);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void GraphBuilder::access_field(Bytecodes::Code code) {
    bool will_link;
    ciField* field = stream()-&gt;get_field(will_link);
    ciInstanceKlass* holder = field-&gt;holder();
    BasicType field_type = field-&gt;type()-&gt;basic_type();
    ValueType* type = as_ValueType(field_type);
<span class="udiff-line-added">+ </span>
    // call will_link again to determine if the field is valid.
    const bool needs_patching = !holder-&gt;is_loaded() ||
                                !field-&gt;will_link(method(), code) ||
                                PatchALot;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1654,15 +1747,15 @@</span>
      } else {
        obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()));
      }
    }
  
<span class="udiff-line-modified-removed">-   if (field-&gt;is_final() &amp;&amp; (code == Bytecodes::_putfield)) {</span>
<span class="udiff-line-modified-added">+   if (field-&gt;is_final() &amp;&amp; (code == Bytecodes::_putfield || code == Bytecodes::_withfield)) {</span>
      scope()-&gt;set_wrote_final();
    }
  
<span class="udiff-line-modified-removed">-   if (code == Bytecodes::_putfield) {</span>
<span class="udiff-line-modified-added">+   if (code == Bytecodes::_putfield || code == Bytecodes::_withfield) {</span>
      scope()-&gt;set_wrote_fields();
      if (field-&gt;is_volatile()) {
        scope()-&gt;set_wrote_volatile();
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1682,17 +1775,22 @@</span>
          push(type, append(constant));
        } else {
          if (state_before == NULL) {
            state_before = copy_state_for_exception();
          }
<span class="udiff-line-modified-removed">-         push(type, append(new LoadField(append(obj), offset, field, true,</span>
<span class="udiff-line-modified-removed">-                                         state_before, needs_patching)));</span>
<span class="udiff-line-modified-added">+         LoadField* load_field = new LoadField(append(obj), offset, field, true,</span>
<span class="udiff-line-modified-added">+                                         state_before, needs_patching);</span>
<span class="udiff-line-added">+         if (field-&gt;is_flattenable()) {</span>
<span class="udiff-line-added">+           load_field-&gt;set_never_null(true);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         push(type, append(load_field));</span>
        }
        break;
      }
      case Bytecodes::_putstatic: {
        Value val = pop(type);
<span class="udiff-line-added">+       val-&gt;set_escaped();</span>
        if (state_before == NULL) {
          state_before = copy_state_for_exception();
        }
        if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
          Value mask = append(new Constant(new IntConstant(1)));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1702,13 +1800,18 @@</span>
        break;
      }
      case Bytecodes::_getfield: {
        // Check for compile-time constants, i.e., trusted final non-static fields.
        Value constant = NULL;
<span class="udiff-line-added">+       if (state_before == NULL &amp;&amp; field-&gt;is_flattened()) {</span>
<span class="udiff-line-added">+         // Save the entire state and re-execute on deopt when accessing flattened fields</span>
<span class="udiff-line-added">+         assert(Interpreter::bytecode_should_reexecute(code), &quot;should reexecute&quot;);</span>
<span class="udiff-line-added">+         state_before = copy_state_before();</span>
<span class="udiff-line-added">+       }</span>
        obj = apop();
        ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
<span class="udiff-line-modified-removed">-       if (field-&gt;is_constant() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {</span>
<span class="udiff-line-modified-added">+       if (field-&gt;is_constant() &amp;&amp; !field-&gt;is_flattened() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {</span>
          ciObject* const_oop = obj_type-&gt;constant_value();
          if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
            ciConstant field_value = field-&gt;constant_value_of(const_oop);
            if (field_value.is_valid()) {
              constant = make_constant(field_value, field);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1727,61 +1830,197 @@</span>
          push(type, append(constant));
        } else {
          if (state_before == NULL) {
            state_before = copy_state_for_exception();
          }
<span class="udiff-line-modified-removed">-         LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);</span>
<span class="udiff-line-modified-removed">-         Value replacement = !needs_patching ? _memory-&gt;load(load) : load;</span>
<span class="udiff-line-modified-removed">-         if (replacement != load) {</span>
<span class="udiff-line-modified-removed">-           assert(replacement-&gt;is_linked() || !replacement-&gt;can_be_linked(), &quot;should already by linked&quot;);</span>
<span class="udiff-line-modified-removed">-           // Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing</span>
<span class="udiff-line-modified-removed">-           // conversion. Emit an explicit conversion here to get the correct field value after the write.</span>
<span class="udiff-line-modified-removed">-           BasicType bt = field-&gt;type()-&gt;basic_type();</span>
<span class="udiff-line-modified-removed">-           switch (bt) {</span>
<span class="udiff-line-modified-removed">-           case T_BOOLEAN:</span>
<span class="udiff-line-modified-removed">-           case T_BYTE:</span>
<span class="udiff-line-modified-removed">-             replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-removed">-           case T_CHAR:</span>
<span class="udiff-line-modified-removed">-             replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-removed">-           case T_SHORT:</span>
<span class="udiff-line-modified-removed">-             replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-removed">-           default:</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+         if (!field-&gt;is_flattened()) {</span>
<span class="udiff-line-modified-added">+           LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);</span>
<span class="udiff-line-modified-added">+           Value replacement = !needs_patching ? _memory-&gt;load(load) : load;</span>
<span class="udiff-line-modified-added">+           if (replacement != load) {</span>
<span class="udiff-line-modified-added">+             assert(replacement-&gt;is_linked() || !replacement-&gt;can_be_linked(), &quot;should already by linked&quot;);</span>
<span class="udiff-line-modified-added">+             // Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing</span>
<span class="udiff-line-modified-added">+             // conversion. Emit an explicit conversion here to get the correct field value after the write.</span>
<span class="udiff-line-modified-added">+             BasicType bt = field-&gt;type()-&gt;basic_type();</span>
<span class="udiff-line-modified-added">+             switch (bt) {</span>
<span class="udiff-line-modified-added">+             case T_BOOLEAN:</span>
<span class="udiff-line-modified-added">+             case T_BYTE:</span>
<span class="udiff-line-modified-added">+               replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));</span>
<span class="udiff-line-modified-added">+               break;</span>
<span class="udiff-line-modified-added">+             case T_CHAR:</span>
<span class="udiff-line-modified-added">+               replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));</span>
<span class="udiff-line-modified-added">+               break;</span>
<span class="udiff-line-modified-added">+             case T_SHORT:</span>
<span class="udiff-line-modified-added">+               replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));</span>
<span class="udiff-line-modified-added">+               break;</span>
<span class="udiff-line-modified-added">+             default:</span>
<span class="udiff-line-added">+               break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             push(type, replacement);</span>
<span class="udiff-line-added">+           } else {</span>
<span class="udiff-line-added">+             push(type, append(load));</span>
            }
<span class="udiff-line-modified-removed">-           push(type, replacement);</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-           push(type, append(load));</span>
<span class="udiff-line-modified-added">+         } else { // flattened field, not optimized solution: re-instantiate the flattened value</span>
<span class="udiff-line-modified-added">+           assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="udiff-line-modified-added">+           ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();</span>
<span class="udiff-line-added">+           int flattening_offset = field-&gt;offset() - value_klass-&gt;first_field_offset();</span>
<span class="udiff-line-added">+           assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="udiff-line-added">+           scope()-&gt;set_wrote_final();</span>
<span class="udiff-line-added">+           scope()-&gt;set_wrote_fields();</span>
<span class="udiff-line-added">+           NewValueTypeInstance* new_instance = new NewValueTypeInstance(value_klass, state_before, false);</span>
<span class="udiff-line-added">+           _memory-&gt;new_instance(new_instance);</span>
<span class="udiff-line-added">+           apush(append_split(new_instance));</span>
<span class="udiff-line-added">+           copy_value_content(value_klass, obj, field-&gt;offset(), new_instance, value_klass-&gt;first_field_offset(),</span>
<span class="udiff-line-added">+                        state_before, needs_patching);</span>
          }
        }
        break;
      }
<span class="udiff-line-added">+     case Bytecodes::_withfield:</span>
      case Bytecodes::_putfield: {
        Value val = pop(type);
<span class="udiff-line-added">+       val-&gt;set_escaped();</span>
        obj = apop();
        if (state_before == NULL) {
          state_before = copy_state_for_exception();
        }
        if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
          Value mask = append(new Constant(new IntConstant(1)));
          val = append(new LogicOp(Bytecodes::_iand, val, mask));
        }
<span class="udiff-line-modified-removed">-       StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);</span>
<span class="udiff-line-modified-removed">-       if (!needs_patching) store = _memory-&gt;store(store);</span>
<span class="udiff-line-modified-removed">-       if (store != NULL) {</span>
<span class="udiff-line-modified-removed">-         append(store);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       if (!field-&gt;is_flattened()) {</span>
<span class="udiff-line-modified-added">+         StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);</span>
<span class="udiff-line-modified-added">+         if (!needs_patching) store = _memory-&gt;store(store);</span>
<span class="udiff-line-added">+         if (store != NULL) {</span>
<span class="udiff-line-added">+           append(store);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="udiff-line-added">+         ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();</span>
<span class="udiff-line-added">+         int flattening_offset = field-&gt;offset() - value_klass-&gt;first_field_offset();</span>
<span class="udiff-line-added">+         copy_value_content(value_klass, val, value_klass-&gt;first_field_offset(), obj, field-&gt;offset(),</span>
<span class="udiff-line-added">+                    state_before, needs_patching);</span>
        }
        break;
      }
      default:
        ShouldNotReachHere();
        break;
    }
  }
  
<span class="udiff-line-added">+ // Baseline version of withfield, allocate every time</span>
<span class="udiff-line-added">+ void GraphBuilder::withfield(int field_index)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   bool will_link;</span>
<span class="udiff-line-added">+   ciField* field_modify = stream()-&gt;get_field(will_link);</span>
<span class="udiff-line-added">+   ciInstanceKlass* holder = field_modify-&gt;holder();</span>
<span class="udiff-line-added">+   BasicType field_type = field_modify-&gt;type()-&gt;basic_type();</span>
<span class="udiff-line-added">+   ValueType* type = as_ValueType(field_type);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // call will_link again to determine if the field is valid.</span>
<span class="udiff-line-added">+   const bool needs_patching = !holder-&gt;is_loaded() ||</span>
<span class="udiff-line-added">+                               !field_modify-&gt;will_link(method(), Bytecodes::_withfield) ||</span>
<span class="udiff-line-added">+                               PatchALot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   scope()-&gt;set_wrote_final();</span>
<span class="udiff-line-added">+   scope()-&gt;set_wrote_fields();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const int offset = !needs_patching ? field_modify-&gt;offset() : -1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!holder-&gt;is_loaded()</span>
<span class="udiff-line-added">+       || needs_patching /* FIXME: 8228634 - field_modify-&gt;will_link() may incorrectly return false */</span>
<span class="udiff-line-added">+       ) {</span>
<span class="udiff-line-added">+     ValueStack* state_before = copy_state_before();</span>
<span class="udiff-line-added">+     Value val = pop(type);</span>
<span class="udiff-line-added">+     Value obj = apop();</span>
<span class="udiff-line-added">+     apush(append_split(new WithField(state_before)));</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ValueStack* state_before = copy_state_before();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Value val = pop(type);</span>
<span class="udiff-line-added">+   Value obj = apop();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!needs_patching &amp;&amp; obj-&gt;is_optimizable_for_withfield()) {</span>
<span class="udiff-line-added">+     int astore_index;</span>
<span class="udiff-line-added">+     ciBytecodeStream s(method());</span>
<span class="udiff-line-added">+     s.force_bci(bci());</span>
<span class="udiff-line-added">+     s.next();</span>
<span class="udiff-line-added">+     switch (s.cur_bc()) {</span>
<span class="udiff-line-added">+     case Bytecodes::_astore:    astore_index = s.get_index(); break;</span>
<span class="udiff-line-added">+     case Bytecodes::_astore_0:  astore_index = 0; break;</span>
<span class="udiff-line-added">+     case Bytecodes::_astore_1:  astore_index = 1; break;</span>
<span class="udiff-line-added">+     case Bytecodes::_astore_2:  astore_index = 2; break;</span>
<span class="udiff-line-added">+     case Bytecodes::_astore_3:  astore_index = 3; break;</span>
<span class="udiff-line-added">+     default: astore_index = -1;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (astore_index &gt;= 0 &amp;&amp; obj == state()-&gt;local_at(astore_index)) {</span>
<span class="udiff-line-added">+       // We have a sequence like this, where we load a value object from a local slot,</span>
<span class="udiff-line-added">+       // and overwrite the same local slot with a modified copy of the value object.</span>
<span class="udiff-line-added">+       //      defaultvalue #1 // class compiler/valhalla/valuetypes/MyValue1</span>
<span class="udiff-line-added">+       //      astore 9</span>
<span class="udiff-line-added">+       //      ...</span>
<span class="udiff-line-added">+       //      iload_0</span>
<span class="udiff-line-added">+       //      aload 9</span>
<span class="udiff-line-added">+       //      swap</span>
<span class="udiff-line-added">+       //      withfield #7 // Field x:I</span>
<span class="udiff-line-added">+       //      astore 9</span>
<span class="udiff-line-added">+       // If this object was created by defaultvalue, and has not escaped, and is not stored</span>
<span class="udiff-line-added">+       // in any other local slots, we can effectively treat the withfield/astore</span>
<span class="udiff-line-added">+       // sequence as a single putfield bytecode.</span>
<span class="udiff-line-added">+       push(objectType, obj);</span>
<span class="udiff-line-added">+       push(type, val);</span>
<span class="udiff-line-added">+       access_field(Bytecodes::_withfield);</span>
<span class="udiff-line-added">+       stream()-&gt;next(); // skip the next astore/astore_n bytecode.</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(holder-&gt;is_valuetype(), &quot;must be a value klass&quot;);</span>
<span class="udiff-line-added">+   // Save the entire state and re-execute on deopt when executing withfield</span>
<span class="udiff-line-added">+   state_before-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+   NewValueTypeInstance* new_instance = new NewValueTypeInstance(holder-&gt;as_value_klass(), state_before, false);</span>
<span class="udiff-line-added">+   _memory-&gt;new_instance(new_instance);</span>
<span class="udiff-line-added">+   apush(append_split(new_instance));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; holder-&gt;nof_nonstatic_fields(); i++) {</span>
<span class="udiff-line-added">+     ciField* field = holder-&gt;nonstatic_field_at(i);</span>
<span class="udiff-line-added">+     int off = field-&gt;offset();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (field-&gt;offset() != offset) {</span>
<span class="udiff-line-added">+       if (field-&gt;is_flattened()) {</span>
<span class="udiff-line-added">+         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="udiff-line-added">+         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Only value types can be flattened&quot;);</span>
<span class="udiff-line-added">+         ciValueKlass* vk = field-&gt;type()-&gt;as_value_klass();</span>
<span class="udiff-line-added">+         copy_value_content(vk, obj, off, new_instance, vk-&gt;first_field_offset(), state_before, needs_patching);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         // Only load those fields who are not modified</span>
<span class="udiff-line-added">+         LoadField* load = new LoadField(obj, off, field, false, state_before, needs_patching);</span>
<span class="udiff-line-added">+         Value replacement = append(load);</span>
<span class="udiff-line-added">+         StoreField* store = new StoreField(new_instance, off, field, replacement, false, state_before, needs_patching);</span>
<span class="udiff-line-added">+         append(store);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Field to modify</span>
<span class="udiff-line-added">+   if (field_modify-&gt;type()-&gt;basic_type() == T_BOOLEAN) {</span>
<span class="udiff-line-added">+     Value mask = append(new Constant(new IntConstant(1)));</span>
<span class="udiff-line-added">+     val = append(new LogicOp(Bytecodes::_iand, val, mask));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (field_modify-&gt;is_flattened()) {</span>
<span class="udiff-line-added">+     assert(field_modify-&gt;type()-&gt;is_valuetype(), &quot;Only value types can be flattened&quot;);</span>
<span class="udiff-line-added">+     ciValueKlass* vk = field_modify-&gt;type()-&gt;as_value_klass();</span>
<span class="udiff-line-added">+     copy_value_content(vk, val, vk-&gt;first_field_offset(), new_instance, field_modify-&gt;offset(), state_before, needs_patching);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     StoreField* store = new StoreField(new_instance, offset, field_modify, val, false, state_before, needs_patching);</span>
<span class="udiff-line-added">+     append(store);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  Dependencies* GraphBuilder::dependency_recorder() const {
    assert(DeoptC1, &quot;need debug information&quot;);
    return compilation()-&gt;dependency_recorder();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1863,11 +2102,11 @@</span>
        log-&gt;elem(&quot;call method=&#39;%d&#39; instr=&#39;%s&#39;&quot;,
                  log-&gt;identify(target),
                  Bytecodes::name(code));
  
    // invoke-special-super
<span class="udiff-line-modified-removed">-   if (bc_raw == Bytecodes::_invokespecial &amp;&amp; !target-&gt;is_object_initializer()) {</span>
<span class="udiff-line-modified-added">+   if (bc_raw == Bytecodes::_invokespecial &amp;&amp; !target-&gt;is_object_constructor()) {</span>
      ciInstanceKlass* sender_klass =
            calling_klass-&gt;is_unsafe_anonymous() ? calling_klass-&gt;unsafe_anonymous_host() :
                                                   calling_klass;
      if (sender_klass-&gt;is_interface()) {
        int index = state()-&gt;stack_size() - (target-&gt;arg_size_no_receiver() + 1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2135,11 +2374,19 @@</span>
          profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);
        }
      }
    }
  
<span class="udiff-line-modified-removed">-   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before);</span>
<span class="udiff-line-modified-added">+   if (recv != NULL) {</span>
<span class="udiff-line-added">+     recv-&gt;set_escaped();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   for (int i=0; i&lt;args-&gt;length(); i++) {</span>
<span class="udiff-line-added">+     args-&gt;at(0)-&gt;set_escaped();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before,</span>
<span class="udiff-line-added">+                               declared_signature-&gt;returns_never_null());</span>
    // push result
    append_split(result);
  
    if (result_type != voidType) {
      if (method()-&gt;is_strict()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2157,27 +2404,39 @@</span>
  void GraphBuilder::new_instance(int klass_index) {
    ValueStack* state_before = copy_state_exhandling();
    bool will_link;
    ciKlass* klass = stream()-&gt;get_klass(will_link);
    assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
<span class="udiff-line-added">+   assert(!klass-&gt;is_valuetype(), &quot;must not be a value klass&quot;);</span>
    NewInstance* new_instance = new NewInstance(klass-&gt;as_instance_klass(), state_before, stream()-&gt;is_unresolved_klass());
    _memory-&gt;new_instance(new_instance);
    apush(append_split(new_instance));
  }
  
<span class="udiff-line-added">+ void GraphBuilder::default_value(int klass_index) {</span>
<span class="udiff-line-added">+   bool will_link;</span>
<span class="udiff-line-added">+   ciValueKlass* vk = stream()-&gt;get_klass(will_link)-&gt;as_value_klass();</span>
<span class="udiff-line-added">+   if (!stream()-&gt;is_unresolved_klass()) {</span>
<span class="udiff-line-added">+     apush(append(new Constant(new InstanceConstant(vk-&gt;default_value_instance()))));</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     ValueStack* state_before = copy_state_before();</span>
<span class="udiff-line-added">+     apush(append_split(new DefaultValue(state_before)));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  void GraphBuilder::new_type_array() {
    ValueStack* state_before = copy_state_exhandling();
    apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
  }
  
  
  void GraphBuilder::new_object_array() {
    bool will_link;
    ciKlass* klass = stream()-&gt;get_klass(will_link);
<span class="udiff-line-added">+   bool never_null = stream()-&gt;is_klass_never_null();</span>
    ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
<span class="udiff-line-modified-removed">-   NewArray* n = new NewObjectArray(klass, ipop(), state_before);</span>
<span class="udiff-line-modified-added">+   NewArray* n = new NewObjectArray(klass, ipop(), state_before, never_null);</span>
    apush(append_split(n));
  }
  
  
  bool GraphBuilder::direct_compare(ciKlass* k) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2198,12 +2457,13 @@</span>
  
  
  void GraphBuilder::check_cast(int klass_index) {
    bool will_link;
    ciKlass* klass = stream()-&gt;get_klass(will_link);
<span class="udiff-line-added">+   bool never_null = stream()-&gt;is_klass_never_null();</span>
    ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_for_exception();
<span class="udiff-line-modified-removed">-   CheckCast* c = new CheckCast(klass, apop(), state_before);</span>
<span class="udiff-line-modified-added">+   CheckCast* c = new CheckCast(klass, apop(), state_before, never_null);</span>
    apush(append_split(c));
    c-&gt;set_direct_compare(direct_compare(klass));
  
    if (is_profiling()) {
      // Note that we&#39;d collect profile data in this method if we wanted it.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2238,13 +2498,32 @@</span>
    }
  }
  
  
  void GraphBuilder::monitorenter(Value x, int bci) {
<span class="udiff-line-added">+   bool maybe_valuetype = false;</span>
<span class="udiff-line-added">+   if (bci == InvocationEntryBci) {</span>
<span class="udiff-line-added">+     // Called by GraphBuilder::inline_sync_entry.</span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+     ciType* obj_type = x-&gt;declared_type();</span>
<span class="udiff-line-added">+     assert(obj_type == NULL || !obj_type-&gt;is_valuetype(), &quot;valuetypes cannot have synchronized methods&quot;);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // We are compiling a monitorenter bytecode</span>
<span class="udiff-line-added">+     if (EnableValhalla) {</span>
<span class="udiff-line-added">+       ciType* obj_type = x-&gt;declared_type();</span>
<span class="udiff-line-added">+       if (obj_type == NULL || obj_type-&gt;as_klass()-&gt;can_be_value_klass()) {</span>
<span class="udiff-line-added">+         // If we&#39;re (possibly) locking on a valuetype, check for markWord::always_locked_pattern</span>
<span class="udiff-line-added">+         // and throw IMSE. (obj_type is null for Phi nodes, so let&#39;s just be conservative).</span>
<span class="udiff-line-added">+         maybe_valuetype = true;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // save state before locking in case of deoptimization after a NullPointerException
    ValueStack* state_before = copy_state_for_exception_with_bci(bci);
<span class="udiff-line-modified-removed">-   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before), bci);</span>
<span class="udiff-line-modified-added">+   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before, maybe_valuetype), bci);</span>
    kill_all();
  }
  
  
  void GraphBuilder::monitorexit(Value x, int bci) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2902,10 +3181,12 @@</span>
        case Bytecodes::_multianewarray : new_multi_array(s.cur_bcp()[3]); break;
        case Bytecodes::_ifnull         : if_null(objectType, If::eql); break;
        case Bytecodes::_ifnonnull      : if_null(objectType, If::neq); break;
        case Bytecodes::_goto_w         : _goto(s.cur_bci(), s.get_far_dest()); break;
        case Bytecodes::_jsr_w          : jsr(s.get_far_dest()); break;
<span class="udiff-line-added">+       case Bytecodes::_defaultvalue   : default_value(s.get_index_u2()); break;</span>
<span class="udiff-line-added">+       case Bytecodes::_withfield      : withfield(s.get_index_u2()); break;</span>
        case Bytecodes::_breakpoint     : BAILOUT_(&quot;concurrent setting of breakpoint&quot;, NULL);
        default                         : ShouldNotReachHere(); break;
      }
  
      if (log != NULL)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3187,11 +3468,12 @@</span>
  
    // Set up locals for receiver
    int idx = 0;
    if (!method()-&gt;is_static()) {
      // we should always see the receiver
<span class="udiff-line-modified-removed">-     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx, true));</span>
<span class="udiff-line-modified-added">+     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx,</span>
<span class="udiff-line-added">+              /*receiver*/ true, /*never_null*/ method()-&gt;holder()-&gt;is_value_array_klass()));</span>
      idx = 1;
    }
  
    // Set up locals for incoming arguments
    ciSignature* sig = method()-&gt;signature();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3199,11 +3481,11 @@</span>
      ciType* type = sig-&gt;type_at(i);
      BasicType basic_type = type-&gt;basic_type();
      // don&#39;t allow T_ARRAY to propagate into locals types
      if (is_reference_type(basic_type)) basic_type = T_OBJECT;
      ValueType* vt = as_ValueType(basic_type);
<span class="udiff-line-modified-removed">-     state-&gt;store_local(idx, new Local(type, vt, idx, false));</span>
<span class="udiff-line-modified-added">+     state-&gt;store_local(idx, new Local(type, vt, idx, false, sig-&gt;is_never_null_at(i)));</span>
      idx += type-&gt;size();
    }
  
    // lock synchronized method
    if (method()-&gt;is_synchronized()) {
</pre>
<center><a href="../../cpu/x86/stubGenerator_x86_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Instruction.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_INSTRUCTION_HPP
  26 #define SHARE_C1_C1_INSTRUCTION_HPP
  27 
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIR.hpp&quot;
  30 #include &quot;c1/c1_ValueType.hpp&quot;
  31 #include &quot;ci/ciField.hpp&quot;
  32 
  33 // Predefined classes
  34 class ciField;
  35 class ValueStack;
  36 class InstructionPrinter;
  37 class IRScope;
  38 class LIR_OprDesc;
  39 typedef LIR_OprDesc* LIR_Opr;
  40 
  41 
  42 // Instruction class hierarchy
  43 //
  44 // All leaf classes in the class hierarchy are concrete classes
  45 // (i.e., are instantiated). All other classes are abstract and
  46 // serve factoring.
  47 
  48 class Instruction;
  49 class   Phi;
  50 class   Local;
  51 class   Constant;
  52 class   AccessField;
  53 class     LoadField;
  54 class     StoreField;
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
  75 class     NewArray;
  76 class       NewTypeArray;
  77 class       NewObjectArray;
  78 class       NewMultiArray;
  79 class     TypeCheck;
  80 class       CheckCast;
  81 class       InstanceOf;
  82 class     AccessMonitor;
  83 class       MonitorEnter;
  84 class       MonitorExit;
  85 class     Intrinsic;
  86 class     BlockBegin;
  87 class     BlockEnd;
  88 class       Goto;
  89 class       If;
  90 class       IfInstanceOf;
  91 class       Switch;
  92 class         TableSwitch;
  93 class         LookupSwitch;
  94 class       Return;
  95 class       Throw;
  96 class       Base;
  97 class   RoundFP;
  98 class   UnsafeOp;
  99 class     UnsafeRawOp;
 100 class       UnsafeGetRaw;
 101 class       UnsafePutRaw;
 102 class     UnsafeObjectOp;
 103 class       UnsafeGetObject;
 104 class       UnsafePutObject;
 105 class         UnsafeGetAndSetObject;
 106 class   ProfileCall;
 107 class   ProfileReturnType;
 108 class   ProfileInvoke;
 109 class   RuntimeCall;
 110 class   MemBar;
 111 class   RangeCheckPredicate;
 112 #ifdef ASSERT
 113 class   Assert;
 114 #endif
 115 
 116 // A Value is a reference to the instruction creating the value
 117 typedef Instruction* Value;
 118 typedef GrowableArray&lt;Value&gt; Values;
 119 typedef GrowableArray&lt;ValueStack*&gt; ValueStackStack;
 120 
 121 // BlockClosure is the base class for block traversal/iteration.
 122 
 123 class BlockClosure: public CompilationResourceObj {
 124  public:
 125   virtual void block_do(BlockBegin* block)       = 0;
 126 };
 127 
 128 
 129 // A simple closure class for visiting the values of an Instruction
 130 class ValueVisitor: public StackObj {
 131  public:
 132   virtual void visit(Value* v) = 0;
 133 };
 134 
 135 
 136 // Some array and list classes
 137 typedef GrowableArray&lt;BlockBegin*&gt; BlockBeginArray;
 138 
 139 class BlockList: public GrowableArray&lt;BlockBegin*&gt; {
 140  public:
 141   BlockList(): GrowableArray&lt;BlockBegin*&gt;() {}
 142   BlockList(const int size): GrowableArray&lt;BlockBegin*&gt;(size) {}
 143   BlockList(const int size, BlockBegin* init): GrowableArray&lt;BlockBegin*&gt;(size, size, init) {}
 144 
 145   void iterate_forward(BlockClosure* closure);
 146   void iterate_backward(BlockClosure* closure);
 147   void blocks_do(void f(BlockBegin*));
 148   void values_do(ValueVisitor* f);
 149   void print(bool cfg_only = false, bool live_only = false) PRODUCT_RETURN;
 150 };
 151 
 152 
 153 // InstructionVisitors provide type-based dispatch for instructions.
 154 // For each concrete Instruction class X, a virtual function do_X is
 155 // provided. Functionality that needs to be implemented for all classes
 156 // (e.g., printing, code generation) is factored out into a specialised
 157 // visitor instead of added to the Instruction classes itself.
 158 
 159 class InstructionVisitor: public StackObj {
 160  public:
 161   virtual void do_Phi            (Phi*             x) = 0;
 162   virtual void do_Local          (Local*           x) = 0;
 163   virtual void do_Constant       (Constant*        x) = 0;
 164   virtual void do_LoadField      (LoadField*       x) = 0;
 165   virtual void do_StoreField     (StoreField*      x) = 0;
 166   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 167   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 168   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 169   virtual void do_NegateOp       (NegateOp*        x) = 0;
 170   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 171   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 172   virtual void do_LogicOp        (LogicOp*         x) = 0;
 173   virtual void do_CompareOp      (CompareOp*       x) = 0;
 174   virtual void do_IfOp           (IfOp*            x) = 0;
 175   virtual void do_Convert        (Convert*         x) = 0;
 176   virtual void do_NullCheck      (NullCheck*       x) = 0;
 177   virtual void do_TypeCast       (TypeCast*        x) = 0;
 178   virtual void do_Invoke         (Invoke*          x) = 0;
 179   virtual void do_NewInstance    (NewInstance*     x) = 0;
 180   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 181   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 182   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 183   virtual void do_CheckCast      (CheckCast*       x) = 0;
 184   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 185   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 186   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 187   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 188   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 189   virtual void do_Goto           (Goto*            x) = 0;
 190   virtual void do_If             (If*              x) = 0;
 191   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 192   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 193   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 194   virtual void do_Return         (Return*          x) = 0;
 195   virtual void do_Throw          (Throw*           x) = 0;
 196   virtual void do_Base           (Base*            x) = 0;
 197   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 198   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 199   virtual void do_RoundFP        (RoundFP*         x) = 0;
 200   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 201   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 202   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 203   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 204   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 205   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 206   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 207   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 208   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 209   virtual void do_MemBar         (MemBar*          x) = 0;
 210   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 211 #ifdef ASSERT
 212   virtual void do_Assert         (Assert*          x) = 0;
 213 #endif
 214 };
 215 
 216 
 217 // Hashing support
 218 //
 219 // Note: This hash functions affect the performance
 220 //       of ValueMap - make changes carefully!
 221 
 222 #define HASH1(x1            )                    ((intx)(x1))
 223 #define HASH2(x1, x2        )                    ((HASH1(x1        ) &lt;&lt; 7) ^ HASH1(x2))
 224 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2    ) &lt;&lt; 7) ^ HASH1(x3))
 225 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3) &lt;&lt; 7) ^ HASH1(x4))
 226 
 227 
 228 // The following macros are used to implement instruction-specific hashing.
 229 // By default, each instruction implements hash() and is_equal(Value), used
 230 // for value numbering/common subexpression elimination. The default imple-
 231 // mentation disables value numbering. Each instruction which can be value-
 232 // numbered, should define corresponding hash() and is_equal(Value) functions
 233 // via the macros below. The f arguments specify all the values/op codes, etc.
 234 // that need to be identical for two instructions to be identical.
 235 //
 236 // Note: The default implementation of hash() returns 0 in order to indicate
 237 //       that the instruction should not be considered for value numbering.
 238 //       The currently used hash functions do not guarantee that never a 0
 239 //       is produced. While this is still correct, it may be a performance
 240 //       bug (no value numbering for that node). However, this situation is
 241 //       so unlikely, that we are not going to handle it specially.
 242 
 243 #define HASHING1(class_name, enabled, f1)             \
 244   virtual intx hash() const {                         \
 245     return (enabled) ? HASH2(name(), f1) : 0;         \
 246   }                                                   \
 247   virtual bool is_equal(Value v) const {              \
 248     if (!(enabled)  ) return false;                   \
 249     class_name* _v = v-&gt;as_##class_name();            \
 250     if (_v == NULL  ) return false;                   \
 251     if (f1 != _v-&gt;f1) return false;                   \
 252     return true;                                      \
 253   }                                                   \
 254 
 255 
 256 #define HASHING2(class_name, enabled, f1, f2)         \
 257   virtual intx hash() const {                         \
 258     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 259   }                                                   \
 260   virtual bool is_equal(Value v) const {              \
 261     if (!(enabled)  ) return false;                   \
 262     class_name* _v = v-&gt;as_##class_name();            \
 263     if (_v == NULL  ) return false;                   \
 264     if (f1 != _v-&gt;f1) return false;                   \
 265     if (f2 != _v-&gt;f2) return false;                   \
 266     return true;                                      \
 267   }                                                   \
 268 
 269 
 270 #define HASHING3(class_name, enabled, f1, f2, f3)     \
 271   virtual intx hash() const {                         \
 272     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 273   }                                                   \
 274   virtual bool is_equal(Value v) const {              \
 275     if (!(enabled)  ) return false;                   \
 276     class_name* _v = v-&gt;as_##class_name();            \
 277     if (_v == NULL  ) return false;                   \
 278     if (f1 != _v-&gt;f1) return false;                   \
 279     if (f2 != _v-&gt;f2) return false;                   \
 280     if (f3 != _v-&gt;f3) return false;                   \
 281     return true;                                      \
 282   }                                                   \
 283 
 284 
 285 // The mother of all instructions...
 286 
 287 class Instruction: public CompilationResourceObj {
 288  private:
 289   int          _id;                              // the unique instruction id
 290 #ifndef PRODUCT
 291   int          _printable_bci;                   // the bci of the instruction for printing
 292 #endif
 293   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 294   int          _pin_state;                       // set of PinReason describing the reason for pinning
 295   ValueType*   _type;                            // the instruction value type
 296   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 297   Instruction* _subst;                           // the substitution instruction if any
 298   LIR_Opr      _operand;                         // LIR specific information
 299   unsigned int _flags;                           // Flag bits
 300 
 301   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 302   ValueStack*  _exception_state;                 // Copy of state for exception handling
 303   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 304 
 305   friend class UseCountComputer;
 306 
 307   void update_exception_state(ValueStack* state);
 308 
 309  protected:
 310   BlockBegin*  _block;                           // Block that contains this instruction
 311 
 312   void set_type(ValueType* type) {
 313     assert(type != NULL, &quot;type must exist&quot;);
 314     _type = type;
 315   }
 316 
 317   // Helper class to keep track of which arguments need a null check
 318   class ArgsNonNullState {
 319   private:
 320     int _nonnull_state; // mask identifying which args are nonnull
 321   public:
 322     ArgsNonNullState()
 323       : _nonnull_state(AllBits) {}
 324 
 325     // Does argument number i needs a null check?
 326     bool arg_needs_null_check(int i) const {
 327       // No data is kept for arguments starting at position 33 so
 328       // conservatively assume that they need a null check.
 329       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 330         return is_set_nth_bit(_nonnull_state, i);
 331       }
 332       return true;
 333     }
 334 
 335     // Set whether argument number i needs a null check or not
 336     void set_arg_needs_null_check(int i, bool check) {
 337       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 338         if (check) {
 339           _nonnull_state |= nth_bit(i);
 340         } else {
 341           _nonnull_state &amp;= ~(nth_bit(i));
 342         }
 343       }
 344     }
 345   };
 346 
 347  public:
 348   void* operator new(size_t size) throw() {
 349     Compilation* c = Compilation::current();
 350     void* res = c-&gt;arena()-&gt;Amalloc(size);
 351     return res;
 352   }
 353 
 354   static const int no_bci = -99;
 355 
 356   enum InstructionFlag {
 357     NeedsNullCheckFlag = 0,
 358     CanTrapFlag,
 359     DirectCompareFlag,
 360     IsEliminatedFlag,
 361     IsSafepointFlag,
 362     IsStaticFlag,
 363     IsStrictfpFlag,
 364     NeedsStoreCheckFlag,
 365     NeedsWriteBarrierFlag,
 366     PreservesStateFlag,
 367     TargetIsFinalFlag,
 368     TargetIsLoadedFlag,
 369     TargetIsStrictfpFlag,
 370     UnorderedIsTrueFlag,
 371     NeedsPatchingFlag,
 372     ThrowIncompatibleClassChangeErrorFlag,
 373     InvokeSpecialReceiverCheckFlag,
 374     ProfileMDOFlag,
 375     IsLinkedInBlockFlag,
 376     NeedsRangeCheckFlag,
 377     InWorkListFlag,
 378     DeoptimizeOnException,
 379     InstructionLastFlag
 380   };
 381 
 382  public:
 383   bool check_flag(InstructionFlag id) const      { return (_flags &amp; (1 &lt;&lt; id)) != 0;    }
 384   void set_flag(InstructionFlag id, bool f)      { _flags = f ? (_flags | (1 &lt;&lt; id)) : (_flags &amp; ~(1 &lt;&lt; id)); };
 385 
 386   // &#39;globally&#39; used condition values
 387   enum Condition {
 388     eql, neq, lss, leq, gtr, geq, aeq, beq
 389   };
 390 
 391   // Instructions may be pinned for many reasons and under certain conditions
 392   // with enough knowledge it&#39;s possible to safely unpin them.
 393   enum PinReason {
 394       PinUnknown           = 1 &lt;&lt; 0
 395     , PinExplicitNullCheck = 1 &lt;&lt; 3
 396     , PinStackForStateSplit= 1 &lt;&lt; 12
 397     , PinStateSplitConstructor= 1 &lt;&lt; 13
 398     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 399   };
 400 
 401   static Condition mirror(Condition cond);
 402   static Condition negate(Condition cond);
 403 
 404   // initialization
 405   static int number_of_instructions() {
 406     return Compilation::current()-&gt;number_of_instructions();
 407   }
 408 
 409   // creation
 410   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
 411   : _id(Compilation::current()-&gt;get_next_id()),
 412 #ifndef PRODUCT
 413   _printable_bci(-99),
 414 #endif
 415     _use_count(0)
 416   , _pin_state(0)
 417   , _type(type)
 418   , _next(NULL)
 419   , _subst(NULL)
 420   , _operand(LIR_OprFact::illegalOpr)
 421   , _flags(0)
 422   , _state_before(state_before)
 423   , _exception_handlers(NULL)
 424   , _block(NULL)
 425   {
 426     check_state(state_before);
 427     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 428     update_exception_state(_state_before);
 429   }
 430 
 431   // accessors
 432   int id() const                                 { return _id; }
 433 #ifndef PRODUCT
 434   bool has_printable_bci() const                 { return _printable_bci != -99; }
 435   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 436   void set_printable_bci(int bci)                { _printable_bci = bci; }
 437 #endif
 438   int dominator_depth();
 439   int use_count() const                          { return _use_count; }
 440   int pin_state() const                          { return _pin_state; }
 441   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 442   ValueType* type() const                        { return _type; }
 443   BlockBegin *block() const                      { return _block; }
 444   Instruction* prev();                           // use carefully, expensive operation
 445   Instruction* next() const                      { return _next; }
 446   bool has_subst() const                         { return _subst != NULL; }
 447   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 448   LIR_Opr operand() const                        { return _operand; }
 449 
 450   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 451   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 452   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 453   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 454 
 455   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 456 
 457   bool has_uses() const                          { return use_count() &gt; 0; }
 458   ValueStack* state_before() const               { return _state_before; }
 459   ValueStack* exception_state() const            { return _exception_state; }
 460   virtual bool needs_exception_state() const     { return true; }
 461   XHandlers* exception_handlers() const          { return _exception_handlers; }
 462 
 463   // manipulation
 464   void pin(PinReason reason)                     { _pin_state |= reason; }
 465   void pin()                                     { _pin_state |= PinUnknown; }
 466   // DANGEROUS: only used by EliminateStores
 467   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 468 
 469   Instruction* set_next(Instruction* next) {
 470     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 471     assert(next != NULL, &quot;must not be NULL&quot;);
 472     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 473     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 474 
 475     BlockBegin *block = this-&gt;block();
 476     next-&gt;_block = block;
 477 
 478     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 479     _next = next;
 480     return next;
 481   }
 482 
 483   Instruction* set_next(Instruction* next, int bci) {
 484 #ifndef PRODUCT
 485     next-&gt;set_printable_bci(bci);
 486 #endif
 487     return set_next(next);
 488   }
 489 
 490   // when blocks are merged
 491   void fixup_block_pointers() {
 492     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 493     while (cur &amp;&amp; cur-&gt;_block != block()) {
 494       cur-&gt;_block = block();
 495       cur = cur-&gt;next();
 496     }
 497   }
 498 
 499   Instruction *insert_after(Instruction *i) {
 500     Instruction* n = _next;
 501     set_next(i);
 502     i-&gt;set_next(n);
 503     return _next;
 504   }
 505 
 506   Instruction *insert_after_same_bci(Instruction *i) {
 507 #ifndef PRODUCT
 508     i-&gt;set_printable_bci(printable_bci());
 509 #endif
 510     return insert_after(i);
 511   }
 512 
 513   void set_subst(Instruction* subst)             {
 514     assert(subst == NULL ||
 515            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 516            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 517     _subst = subst;
 518   }
 519   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 520   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 521   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 522 
 523   // machine-specifics
 524   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 525   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
 526 
 527   // generic
 528   virtual Instruction*      as_Instruction()     { return this; } // to satisfy HASHING1 macro
 529   virtual Phi*              as_Phi()             { return NULL; }
 530   virtual Local*            as_Local()           { return NULL; }
 531   virtual Constant*         as_Constant()        { return NULL; }
 532   virtual AccessField*      as_AccessField()     { return NULL; }
 533   virtual LoadField*        as_LoadField()       { return NULL; }
 534   virtual StoreField*       as_StoreField()      { return NULL; }
 535   virtual AccessArray*      as_AccessArray()     { return NULL; }
 536   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 537   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 538   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 539   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 540   virtual NegateOp*         as_NegateOp()        { return NULL; }
 541   virtual Op2*              as_Op2()             { return NULL; }
 542   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 543   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 544   virtual LogicOp*          as_LogicOp()         { return NULL; }
 545   virtual CompareOp*        as_CompareOp()       { return NULL; }
 546   virtual IfOp*             as_IfOp()            { return NULL; }
 547   virtual Convert*          as_Convert()         { return NULL; }
 548   virtual NullCheck*        as_NullCheck()       { return NULL; }
 549   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 550   virtual StateSplit*       as_StateSplit()      { return NULL; }
 551   virtual Invoke*           as_Invoke()          { return NULL; }
 552   virtual NewInstance*      as_NewInstance()     { return NULL; }
 553   virtual NewArray*         as_NewArray()        { return NULL; }
 554   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 555   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 556   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 557   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 558   virtual CheckCast*        as_CheckCast()       { return NULL; }
 559   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 560   virtual TypeCast*         as_TypeCast()        { return NULL; }
 561   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 562   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 563   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 564   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 565   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 566   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 567   virtual Goto*             as_Goto()            { return NULL; }
 568   virtual If*               as_If()              { return NULL; }
 569   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 570   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 571   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 572   virtual Return*           as_Return()          { return NULL; }
 573   virtual Throw*            as_Throw()           { return NULL; }
 574   virtual Base*             as_Base()            { return NULL; }
 575   virtual RoundFP*          as_RoundFP()         { return NULL; }
 576   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
 577   virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }
 578   virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }
 579   virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }
 580 
 581 #ifdef ASSERT
 582   virtual Assert*           as_Assert()          { return NULL; }
 583 #endif
 584 
 585   virtual void visit(InstructionVisitor* v)      = 0;
 586 
 587   virtual bool can_trap() const                  { return false; }
 588 
 589   virtual void input_values_do(ValueVisitor* f)   = 0;
 590   virtual void state_values_do(ValueVisitor* f);
 591   virtual void other_values_do(ValueVisitor* f)   { /* usually no other - override on demand */ }
 592           void       values_do(ValueVisitor* f)   { input_values_do(f); state_values_do(f); other_values_do(f); }
 593 
 594   virtual ciType* exact_type() const;
 595   virtual ciType* declared_type() const          { return NULL; }
 596 
 597   // hashing
 598   virtual const char* name() const               = 0;
 599   HASHING1(Instruction, false, id())             // hashing disabled by default
 600 
 601   // debugging
 602   static void check_state(ValueStack* state)     PRODUCT_RETURN;
 603   void print()                                   PRODUCT_RETURN;
 604   void print_line()                              PRODUCT_RETURN;
 605   void print(InstructionPrinter&amp; ip)             PRODUCT_RETURN;
 606 };
 607 
 608 
 609 // The following macros are used to define base (i.e., non-leaf)
 610 // and leaf instruction classes. They define class-name related
 611 // generic functionality in one place.
 612 
 613 #define BASE(class_name, super_class_name)       \
 614   class class_name: public super_class_name {    \
 615    public:                                       \
 616     virtual class_name* as_##class_name()        { return this; }              \
 617 
 618 
 619 #define LEAF(class_name, super_class_name)       \
 620   BASE(class_name, super_class_name)             \
 621    public:                                       \
 622     virtual const char* name() const             { return #class_name; }       \
 623     virtual void visit(InstructionVisitor* v)    { v-&gt;do_##class_name(this); } \
 624 
 625 
 626 // Debugging support
 627 
 628 
 629 #ifdef ASSERT
 630 class AssertValues: public ValueVisitor {
 631   void visit(Value* x)             { assert((*x) != NULL, &quot;value must exist&quot;); }
 632 };
 633   #define ASSERT_VALUES                          { AssertValues assert_value; values_do(&amp;assert_value); }
 634 #else
 635   #define ASSERT_VALUES
 636 #endif // ASSERT
 637 
 638 
 639 // A Phi is a phi function in the sense of SSA form. It stands for
 640 // the value of a local variable at the beginning of a join block.
 641 // A Phi consists of n operands, one for every incoming branch.
 642 
 643 LEAF(Phi, Instruction)
 644  private:
 645   int         _pf_flags; // the flags of the phi function
 646   int         _index;    // to value on operand stack (index &lt; 0) or to local
 647  public:
 648   // creation
 649   Phi(ValueType* type, BlockBegin* b, int index)
 650   : Instruction(type-&gt;base())
 651   , _pf_flags(0)
 652   , _index(index)
 653   {
 654     _block = b;
 655     NOT_PRODUCT(set_printable_bci(Value(b)-&gt;printable_bci()));
 656     if (type-&gt;is_illegal()) {
 657       make_illegal();
 658     }
 659   }
 660 
 661   // flags
 662   enum Flag {
 663     no_flag         = 0,
 664     visited         = 1 &lt;&lt; 0,
 665     cannot_simplify = 1 &lt;&lt; 1
 666   };
 667 
 668   // accessors
 669   bool  is_local() const          { return _index &gt;= 0; }
 670   bool  is_on_stack() const       { return !is_local(); }
 671   int   local_index() const       { assert(is_local(), &quot;&quot;); return _index; }
 672   int   stack_index() const       { assert(is_on_stack(), &quot;&quot;); return -(_index+1); }
 673 
 674   Value operand_at(int i) const;
 675   int   operand_count() const;
 676 
 677   void   set(Flag f)              { _pf_flags |=  f; }
 678   void   clear(Flag f)            { _pf_flags &amp;= ~f; }
 679   bool   is_set(Flag f) const     { return (_pf_flags &amp; f) != 0; }
 680 
 681   // Invalidates phis corresponding to merges of locals of two different types
 682   // (these should never be referenced, otherwise the bytecodes are illegal)
 683   void   make_illegal() {
 684     set(cannot_simplify);
 685     set_type(illegalType);
 686   }
 687 
 688   bool is_illegal() const {
 689     return type()-&gt;is_illegal();
 690   }
 691 
 692   // generic
 693   virtual void input_values_do(ValueVisitor* f) {
 694   }
 695 };
 696 
 697 
 698 // A local is a placeholder for an incoming argument to a function call.
 699 LEAF(Local, Instruction)
 700  private:
 701   int      _java_index;                          // the local index within the method to which the local belongs
 702   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 703   ciType*  _declared_type;
 704  public:
 705   // creation
 706   Local(ciType* declared, ValueType* type, int index, bool receiver)
 707     : Instruction(type)
 708     , _java_index(index)
 709     , _is_receiver(receiver)
 710     , _declared_type(declared)
 711   {
 712     NOT_PRODUCT(set_printable_bci(-1));
 713   }
 714 
 715   // accessors
 716   int java_index() const                         { return _java_index; }
 717   bool is_receiver() const                       { return _is_receiver; }
 718 
 719   virtual ciType* declared_type() const          { return _declared_type; }
 720 
 721   // generic
 722   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 723 };
 724 
 725 
 726 LEAF(Constant, Instruction)
 727  public:
 728   // creation
 729   Constant(ValueType* type):
 730       Instruction(type, NULL, /*type_is_constant*/ true)
 731   {
 732     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 733   }
 734 
 735   Constant(ValueType* type, ValueStack* state_before):
 736     Instruction(type, state_before, /*type_is_constant*/ true)
 737   {
 738     assert(state_before != NULL, &quot;only used for constants which need patching&quot;);
 739     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 740     // since it&#39;s patching it needs to be pinned
 741     pin();
 742   }
 743 
 744   // generic
 745   virtual bool can_trap() const                  { return state_before() != NULL; }
 746   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 747 
 748   virtual intx hash() const;
 749   virtual bool is_equal(Value v) const;
 750 
 751   virtual ciType* exact_type() const;
 752 
 753   enum CompareResult { not_comparable = -1, cond_false, cond_true };
 754 
 755   virtual CompareResult compare(Instruction::Condition condition, Value right) const;
 756   BlockBegin* compare(Instruction::Condition cond, Value right,
 757                       BlockBegin* true_sux, BlockBegin* false_sux) const {
 758     switch (compare(cond, right)) {
 759     case not_comparable:
 760       return NULL;
 761     case cond_false:
 762       return false_sux;
 763     case cond_true:
 764       return true_sux;
 765     default:
 766       ShouldNotReachHere();
 767       return NULL;
 768     }
 769   }
 770 };
 771 
 772 
 773 BASE(AccessField, Instruction)
 774  private:
 775   Value       _obj;
 776   int         _offset;
 777   ciField*    _field;
 778   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 779 
 780  public:
 781   // creation
 782   AccessField(Value obj, int offset, ciField* field, bool is_static,
 783               ValueStack* state_before, bool needs_patching)
 784   : Instruction(as_ValueType(field-&gt;type()-&gt;basic_type()), state_before)
 785   , _obj(obj)
 786   , _offset(offset)
 787   , _field(field)
 788   , _explicit_null_check(NULL)
 789   {
 790     set_needs_null_check(!is_static);
 791     set_flag(IsStaticFlag, is_static);
 792     set_flag(NeedsPatchingFlag, needs_patching);
 793     ASSERT_VALUES
 794     // pin of all instructions with memory access
 795     pin();
 796   }
 797 
 798   // accessors
 799   Value obj() const                              { return _obj; }
 800   int offset() const                             { return _offset; }
 801   ciField* field() const                         { return _field; }
 802   BasicType field_type() const                   { return _field-&gt;type()-&gt;basic_type(); }
 803   bool is_static() const                         { return check_flag(IsStaticFlag); }
 804   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 805   bool needs_patching() const                    { return check_flag(NeedsPatchingFlag); }
 806 
 807   // Unresolved getstatic and putstatic can cause initialization.
 808   // Technically it occurs at the Constant that materializes the base
 809   // of the static fields but it&#39;s simpler to model it here.
 810   bool is_init_point() const                     { return is_static() &amp;&amp; (needs_patching() || !_field-&gt;holder()-&gt;is_initialized()); }
 811 
 812   // manipulation
 813 
 814   // Under certain circumstances, if a previous NullCheck instruction
 815   // proved the target object non-null, we can eliminate the explicit
 816   // null check and do an implicit one, simply specifying the debug
 817   // information from the NullCheck. This field should only be consulted
 818   // if needs_null_check() is true.
 819   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 820 
 821   // generic
 822   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 823   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 824 };
 825 
 826 
 827 LEAF(LoadField, AccessField)
 828  public:
 829   // creation
 830   LoadField(Value obj, int offset, ciField* field, bool is_static,
 831             ValueStack* state_before, bool needs_patching)
 832   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 833   {}
 834 
 835   ciType* declared_type() const;
 836 
 837   // generic; cannot be eliminated if needs patching or if volatile.
 838   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 839 };
 840 
 841 
 842 LEAF(StoreField, AccessField)
 843  private:
 844   Value _value;
 845 
 846  public:
 847   // creation
 848   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 849              ValueStack* state_before, bool needs_patching)
 850   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 851   , _value(value)
 852   {
 853     set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())-&gt;is_object());
 854     ASSERT_VALUES
 855     pin();
 856   }
 857 
 858   // accessors
 859   Value value() const                            { return _value; }
 860   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 861 
 862   // generic
 863   virtual void input_values_do(ValueVisitor* f)   { AccessField::input_values_do(f); f-&gt;visit(&amp;_value); }
 864 };
 865 
 866 
 867 BASE(AccessArray, Instruction)
 868  private:
 869   Value       _array;
 870 
 871  public:
 872   // creation
 873   AccessArray(ValueType* type, Value array, ValueStack* state_before)
 874   : Instruction(type, state_before)
 875   , _array(array)
 876   {
 877     set_needs_null_check(true);
 878     ASSERT_VALUES
 879     pin(); // instruction with side effect (null exception or range check throwing)
 880   }
 881 
 882   Value array() const                            { return _array; }
 883 
 884   // generic
 885   virtual bool can_trap() const                  { return needs_null_check(); }
 886   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_array); }
 887 };
 888 
 889 
 890 LEAF(ArrayLength, AccessArray)
 891  private:
 892   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 893 
 894  public:
 895   // creation
 896   ArrayLength(Value array, ValueStack* state_before)
 897   : AccessArray(intType, array, state_before)
 898   , _explicit_null_check(NULL) {}
 899 
 900   // accessors
 901   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 902 
 903   // setters
 904   // See LoadField::set_explicit_null_check for documentation
 905   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 906 
 907   // generic
 908   HASHING1(ArrayLength, true, array()-&gt;subst())
 909 };
 910 
 911 
 912 BASE(AccessIndexed, AccessArray)
 913  private:
 914   Value     _index;
 915   Value     _length;
 916   BasicType _elt_type;
 917   bool      _mismatched;
 918 
 919  public:
 920   // creation
 921   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 922   : AccessArray(as_ValueType(elt_type), array, state_before)
 923   , _index(index)
 924   , _length(length)
 925   , _elt_type(elt_type)
 926   , _mismatched(mismatched)
 927   {
 928     set_flag(Instruction::NeedsRangeCheckFlag, true);
 929     ASSERT_VALUES
 930   }
 931 
 932   // accessors
 933   Value index() const                            { return _index; }
 934   Value length() const                           { return _length; }
 935   BasicType elt_type() const                     { return _elt_type; }
 936   bool mismatched() const                        { return _mismatched; }
 937 
 938   void clear_length()                            { _length = NULL; }
 939   // perform elimination of range checks involving constants
 940   bool compute_needs_range_check();
 941 
 942   // generic
 943   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 944 };
 945 
 946 
 947 LEAF(LoadIndexed, AccessIndexed)
 948  private:
 949   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 950 
 951  public:
 952   // creation
 953   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
 954   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
 955   , _explicit_null_check(NULL) {}
 956 
 957   // accessors
 958   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 959 
 960   // setters
 961   // See LoadField::set_explicit_null_check for documentation
 962   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 963 
 964   ciType* exact_type() const;
 965   ciType* declared_type() const;
 966 
 967   // generic;
 968   HASHING3(LoadIndexed, true, type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst())
 969 };
 970 
 971 
 972 LEAF(StoreIndexed, AccessIndexed)
 973  private:
 974   Value       _value;
 975 
 976   ciMethod* _profiled_method;
 977   int       _profiled_bci;
 978   bool      _check_boolean;
 979 
 980  public:
 981   // creation
 982   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
 983                bool check_boolean, bool mismatched = false)
 984   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
 985   , _value(value), _profiled_method(NULL), _profiled_bci(0), _check_boolean(check_boolean)
 986   {
 987     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
 988     set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));
 989     ASSERT_VALUES
 990     pin();
 991   }
 992 
 993   // accessors
 994   Value value() const                            { return _value; }
 995   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 996   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
 997   bool check_boolean() const                     { return _check_boolean; }
 998   // Helpers for MethodData* profiling
 999   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1000   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1001   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1002   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1003   ciMethod* profiled_method() const                  { return _profiled_method;     }
1004   int       profiled_bci() const                     { return _profiled_bci;        }
1005   // generic
1006   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1007 };
1008 
1009 
1010 LEAF(NegateOp, Instruction)
1011  private:
1012   Value _x;
1013 
1014  public:
1015   // creation
1016   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1017     ASSERT_VALUES
1018   }
1019 
1020   // accessors
1021   Value x() const                                { return _x; }
1022 
1023   // generic
1024   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
1025 };
1026 
1027 
1028 BASE(Op2, Instruction)
1029  private:
1030   Bytecodes::Code _op;
1031   Value           _x;
1032   Value           _y;
1033 
1034  public:
1035   // creation
1036   Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)
1037   : Instruction(type, state_before)
1038   , _op(op)
1039   , _x(x)
1040   , _y(y)
1041   {
1042     ASSERT_VALUES
1043   }
1044 
1045   // accessors
1046   Bytecodes::Code op() const                     { return _op; }
1047   Value x() const                                { return _x; }
1048   Value y() const                                { return _y; }
1049 
1050   // manipulators
1051   void swap_operands() {
1052     assert(is_commutative(), &quot;operation must be commutative&quot;);
1053     Value t = _x; _x = _y; _y = t;
1054   }
1055 
1056   // generic
1057   virtual bool is_commutative() const            { return false; }
1058   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1059 };
1060 
1061 
1062 LEAF(ArithmeticOp, Op2)
1063  public:
1064   // creation
1065   ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)
1066   : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y, state_before)
1067   {
1068     set_flag(IsStrictfpFlag, is_strictfp);
1069     if (can_trap()) pin();
1070   }
1071 
1072   // accessors
1073   bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }
1074 
1075   // generic
1076   virtual bool is_commutative() const;
1077   virtual bool can_trap() const;
1078   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1079 };
1080 
1081 
1082 LEAF(ShiftOp, Op2)
1083  public:
1084   // creation
1085   ShiftOp(Bytecodes::Code op, Value x, Value s) : Op2(x-&gt;type()-&gt;base(), op, x, s) {}
1086 
1087   // generic
1088   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1089 };
1090 
1091 
1092 LEAF(LogicOp, Op2)
1093  public:
1094   // creation
1095   LogicOp(Bytecodes::Code op, Value x, Value y) : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y) {}
1096 
1097   // generic
1098   virtual bool is_commutative() const;
1099   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1100 };
1101 
1102 
1103 LEAF(CompareOp, Op2)
1104  public:
1105   // creation
1106   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1107   : Op2(intType, op, x, y, state_before)
1108   {}
1109 
1110   // generic
1111   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1112 };
1113 
1114 
1115 LEAF(IfOp, Op2)
1116  private:
1117   Value _tval;
1118   Value _fval;
1119 
1120  public:
1121   // creation
1122   IfOp(Value x, Condition cond, Value y, Value tval, Value fval)
1123   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1124   , _tval(tval)
1125   , _fval(fval)
1126   {
1127     ASSERT_VALUES
1128     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1129   }
1130 
1131   // accessors
1132   virtual bool is_commutative() const;
1133   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1134   Condition cond() const                         { return (Condition)Op2::op(); }
1135   Value tval() const                             { return _tval; }
1136   Value fval() const                             { return _fval; }
1137 
1138   // generic
1139   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1140 };
1141 
1142 
1143 LEAF(Convert, Instruction)
1144  private:
1145   Bytecodes::Code _op;
1146   Value           _value;
1147 
1148  public:
1149   // creation
1150   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1151     ASSERT_VALUES
1152   }
1153 
1154   // accessors
1155   Bytecodes::Code op() const                     { return _op; }
1156   Value value() const                            { return _value; }
1157 
1158   // generic
1159   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_value); }
1160   HASHING2(Convert, true, op(), value()-&gt;subst())
1161 };
1162 
1163 
1164 LEAF(NullCheck, Instruction)
1165  private:
1166   Value       _obj;
1167 
1168  public:
1169   // creation
1170   NullCheck(Value obj, ValueStack* state_before)
1171   : Instruction(obj-&gt;type()-&gt;base(), state_before)
1172   , _obj(obj)
1173   {
1174     ASSERT_VALUES
1175     set_can_trap(true);
1176     assert(_obj-&gt;type()-&gt;is_object(), &quot;null check must be applied to objects only&quot;);
1177     pin(Instruction::PinExplicitNullCheck);
1178   }
1179 
1180   // accessors
1181   Value obj() const                              { return _obj; }
1182 
1183   // setters
1184   void set_can_trap(bool can_trap)               { set_flag(CanTrapFlag, can_trap); }
1185 
1186   // generic
1187   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); /* null-check elimination sets to false */ }
1188   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
1189   HASHING1(NullCheck, true, obj()-&gt;subst())
1190 };
1191 
1192 
1193 // This node is supposed to cast the type of another node to a more precise
1194 // declared type.
1195 LEAF(TypeCast, Instruction)
1196  private:
1197   ciType* _declared_type;
1198   Value   _obj;
1199 
1200  public:
1201   // The type of this node is the same type as the object type (and it might be constant).
1202   TypeCast(ciType* type, Value obj, ValueStack* state_before)
1203   : Instruction(obj-&gt;type(), state_before, obj-&gt;type()-&gt;is_constant()),
1204     _declared_type(type),
1205     _obj(obj) {}
1206 
1207   // accessors
1208   ciType* declared_type() const                  { return _declared_type; }
1209   Value   obj() const                            { return _obj; }
1210 
1211   // generic
1212   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_obj); }
1213 };
1214 
1215 
1216 BASE(StateSplit, Instruction)
1217  private:
1218   ValueStack* _state;
1219 
1220  protected:
1221   static void substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block);
1222 
1223  public:
1224   // creation
1225   StateSplit(ValueType* type, ValueStack* state_before = NULL)
1226   : Instruction(type, state_before)
1227   , _state(NULL)
1228   {
1229     pin(PinStateSplitConstructor);
1230   }
1231 
1232   // accessors
1233   ValueStack* state() const                      { return _state; }
1234   IRScope* scope() const;                        // the state&#39;s scope
1235 
1236   // manipulation
1237   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1238 
1239   // generic
1240   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1241   virtual void state_values_do(ValueVisitor* f);
1242 };
1243 
1244 
1245 LEAF(Invoke, StateSplit)
1246  private:
1247   Bytecodes::Code _code;
1248   Value           _recv;
1249   Values*         _args;
1250   BasicTypeList*  _signature;
1251   int             _vtable_index;
1252   ciMethod*       _target;
1253 
1254  public:
1255   // creation
1256   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
1257          int vtable_index, ciMethod* target, ValueStack* state_before);
1258 
1259   // accessors
1260   Bytecodes::Code code() const                   { return _code; }
1261   Value receiver() const                         { return _recv; }
1262   bool has_receiver() const                      { return receiver() != NULL; }
1263   int number_of_arguments() const                { return _args-&gt;length(); }
1264   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1265   int vtable_index() const                       { return _vtable_index; }
1266   BasicTypeList* signature() const               { return _signature; }
1267   ciMethod* target() const                       { return _target; }
1268 
1269   ciType* declared_type() const;
1270 
1271   // Returns false if target is not loaded
1272   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1273   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1274   // Returns false if target is not loaded
1275   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1276 
1277   // JSR 292 support
1278   bool is_invokedynamic() const                  { return code() == Bytecodes::_invokedynamic; }
1279   bool is_method_handle_intrinsic() const        { return target()-&gt;is_method_handle_intrinsic(); }
1280 
1281   virtual bool needs_exception_state() const     { return false; }
1282 
1283   // generic
1284   virtual bool can_trap() const                  { return true; }
1285   virtual void input_values_do(ValueVisitor* f) {
1286     StateSplit::input_values_do(f);
1287     if (has_receiver()) f-&gt;visit(&amp;_recv);
1288     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1289   }
1290   virtual void state_values_do(ValueVisitor *f);
1291 };
1292 
1293 
1294 LEAF(NewInstance, StateSplit)
1295  private:
1296   ciInstanceKlass* _klass;
1297   bool _is_unresolved;
1298 
1299  public:
1300   // creation
1301   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1302   : StateSplit(instanceType, state_before)
1303   , _klass(klass), _is_unresolved(is_unresolved)
1304   {}
1305 
1306   // accessors
1307   ciInstanceKlass* klass() const                 { return _klass; }
1308   bool is_unresolved() const                     { return _is_unresolved; }
1309 
1310   virtual bool needs_exception_state() const     { return false; }
1311 
1312   // generic
1313   virtual bool can_trap() const                  { return true; }
1314   ciType* exact_type() const;
1315   ciType* declared_type() const;
1316 };
1317 
1318 
1319 BASE(NewArray, StateSplit)
1320  private:
1321   Value       _length;
1322 
1323  public:
1324   // creation
1325   NewArray(Value length, ValueStack* state_before)
1326   : StateSplit(objectType, state_before)
1327   , _length(length)
1328   {
1329     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1330   }
1331 
1332   // accessors
1333   Value length() const                           { return _length; }
1334 
1335   virtual bool needs_exception_state() const     { return false; }
1336 
1337   ciType* exact_type() const                     { return NULL; }
1338   ciType* declared_type() const;
1339 
1340   // generic
1341   virtual bool can_trap() const                  { return true; }
1342   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_length); }
1343 };
1344 
1345 
1346 LEAF(NewTypeArray, NewArray)
1347  private:
1348   BasicType _elt_type;
1349 
1350  public:
1351   // creation
1352   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1353   : NewArray(length, state_before)
1354   , _elt_type(elt_type)
1355   {}
1356 
1357   // accessors
1358   BasicType elt_type() const                     { return _elt_type; }
1359   ciType* exact_type() const;
1360 };
1361 
1362 
1363 LEAF(NewObjectArray, NewArray)
1364  private:
1365   ciKlass* _klass;
1366 
1367  public:
1368   // creation
1369   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before) : NewArray(length, state_before), _klass(klass) {}
1370 
1371   // accessors
1372   ciKlass* klass() const                         { return _klass; }
1373   ciType* exact_type() const;
1374 };
1375 
1376 
1377 LEAF(NewMultiArray, NewArray)
1378  private:
1379   ciKlass* _klass;
1380   Values*  _dims;
1381 
1382  public:
1383   // creation
1384   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1385     ASSERT_VALUES
1386   }
1387 
1388   // accessors
1389   ciKlass* klass() const                         { return _klass; }
1390   Values* dims() const                           { return _dims; }
1391   int rank() const                               { return dims()-&gt;length(); }
1392 
1393   // generic
1394   virtual void input_values_do(ValueVisitor* f) {
1395     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1396     // is meaningless for a multi-dimensional array; passing the
1397     // zeroth element down to NewArray as its length is a bad idea
1398     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1399     // get updated, and the value must not be traversed twice. Was bug
1400     // - kbr 4/10/2001
1401     StateSplit::input_values_do(f);
1402     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1403   }
1404 };
1405 
1406 
1407 BASE(TypeCheck, StateSplit)
1408  private:
1409   ciKlass*    _klass;
1410   Value       _obj;
1411 
1412   ciMethod* _profiled_method;
1413   int       _profiled_bci;
1414 
1415  public:
1416   // creation
1417   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1418   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1419     _profiled_method(NULL), _profiled_bci(0) {
1420     ASSERT_VALUES
1421     set_direct_compare(false);
1422   }
1423 
1424   // accessors
1425   ciKlass* klass() const                         { return _klass; }
1426   Value obj() const                              { return _obj; }
1427   bool is_loaded() const                         { return klass() != NULL; }
1428   bool direct_compare() const                    { return check_flag(DirectCompareFlag); }
1429 
1430   // manipulation
1431   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1432 
1433   // generic
1434   virtual bool can_trap() const                  { return true; }
1435   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1436 
1437   // Helpers for MethodData* profiling
1438   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1439   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1440   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1441   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1442   ciMethod* profiled_method() const                  { return _profiled_method;     }
1443   int       profiled_bci() const                     { return _profiled_bci;        }
1444 };
1445 
1446 
1447 LEAF(CheckCast, TypeCheck)
1448  public:
1449   // creation
1450   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before)
1451   : TypeCheck(klass, obj, objectType, state_before) {}
1452 
1453   void set_incompatible_class_change_check() {
1454     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1455   }
1456   bool is_incompatible_class_change_check() const {
1457     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1458   }
1459   void set_invokespecial_receiver_check() {
1460     set_flag(InvokeSpecialReceiverCheckFlag, true);
1461   }
1462   bool is_invokespecial_receiver_check() const {
1463     return check_flag(InvokeSpecialReceiverCheckFlag);
1464   }
1465 
1466   virtual bool needs_exception_state() const {
1467     return !is_invokespecial_receiver_check();
1468   }
1469 
1470   ciType* declared_type() const;
1471 };
1472 
1473 
1474 LEAF(InstanceOf, TypeCheck)
1475  public:
1476   // creation
1477   InstanceOf(ciKlass* klass, Value obj, ValueStack* state_before) : TypeCheck(klass, obj, intType, state_before) {}
1478 
1479   virtual bool needs_exception_state() const     { return false; }
1480 };
1481 
1482 
1483 BASE(AccessMonitor, StateSplit)
1484  private:
1485   Value       _obj;
1486   int         _monitor_no;
1487 
1488  public:
1489   // creation
1490   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1491   : StateSplit(illegalType, state_before)
1492   , _obj(obj)
1493   , _monitor_no(monitor_no)
1494   {
1495     set_needs_null_check(true);
1496     ASSERT_VALUES
1497   }
1498 
1499   // accessors
1500   Value obj() const                              { return _obj; }
1501   int monitor_no() const                         { return _monitor_no; }
1502 
1503   // generic
1504   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1505 };
1506 
1507 
1508 LEAF(MonitorEnter, AccessMonitor)
1509  public:
1510   // creation
1511   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before)
1512   : AccessMonitor(obj, monitor_no, state_before)
1513   {
1514     ASSERT_VALUES
1515   }
1516 
1517   // generic
1518   virtual bool can_trap() const                  { return true; }
1519 };
1520 
1521 
1522 LEAF(MonitorExit, AccessMonitor)
1523  public:
1524   // creation
1525   MonitorExit(Value obj, int monitor_no)
1526   : AccessMonitor(obj, monitor_no, NULL)
1527   {
1528     ASSERT_VALUES
1529   }
1530 };
1531 
1532 
1533 LEAF(Intrinsic, StateSplit)
1534  private:
1535   vmIntrinsics::ID _id;
1536   Values*          _args;
1537   Value            _recv;
1538   ArgsNonNullState _nonnull_state;
1539 
1540  public:
1541   // preserves_state can be set to true for Intrinsics
1542   // which are guaranteed to preserve register state across any slow
1543   // cases; setting it to true does not mean that the Intrinsic can
1544   // not trap, only that if we continue execution in the same basic
1545   // block after the Intrinsic, all of the registers are intact. This
1546   // allows load elimination and common expression elimination to be
1547   // performed across the Intrinsic.  The default value is false.
1548   Intrinsic(ValueType* type,
1549             vmIntrinsics::ID id,
1550             Values* args,
1551             bool has_receiver,
1552             ValueStack* state_before,
1553             bool preserves_state,
1554             bool cantrap = true)
1555   : StateSplit(type, state_before)
1556   , _id(id)
1557   , _args(args)
1558   , _recv(NULL)
1559   {
1560     assert(args != NULL, &quot;args must exist&quot;);
1561     ASSERT_VALUES
1562     set_flag(PreservesStateFlag, preserves_state);
1563     set_flag(CanTrapFlag,        cantrap);
1564     if (has_receiver) {
1565       _recv = argument_at(0);
1566     }
1567     set_needs_null_check(has_receiver);
1568 
1569     // some intrinsics can&#39;t trap, so don&#39;t force them to be pinned
1570     if (!can_trap() &amp;&amp; !vmIntrinsics::should_be_pinned(_id)) {
1571       unpin(PinStateSplitConstructor);
1572     }
1573   }
1574 
1575   // accessors
1576   vmIntrinsics::ID id() const                    { return _id; }
1577   int number_of_arguments() const                { return _args-&gt;length(); }
1578   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1579 
1580   bool has_receiver() const                      { return (_recv != NULL); }
1581   Value receiver() const                         { assert(has_receiver(), &quot;must have receiver&quot;); return _recv; }
1582   bool preserves_state() const                   { return check_flag(PreservesStateFlag); }
1583 
1584   bool arg_needs_null_check(int i) const {
1585     return _nonnull_state.arg_needs_null_check(i);
1586   }
1587 
1588   void set_arg_needs_null_check(int i, bool check) {
1589     _nonnull_state.set_arg_needs_null_check(i, check);
1590   }
1591 
1592   // generic
1593   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); }
1594   virtual void input_values_do(ValueVisitor* f) {
1595     StateSplit::input_values_do(f);
1596     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1597   }
1598 };
1599 
1600 
1601 class LIR_List;
1602 
1603 LEAF(BlockBegin, StateSplit)
1604  private:
1605   int        _block_id;                          // the unique block id
1606   int        _bci;                               // start-bci of block
1607   int        _depth_first_number;                // number of this block in a depth-first ordering
1608   int        _linear_scan_number;                // number of this block in linear-scan ordering
1609   int        _dominator_depth;
1610   int        _loop_depth;                        // the loop nesting level of this block
1611   int        _loop_index;                        // number of the innermost loop of this block
1612   int        _flags;                             // the flags associated with this block
1613 
1614   // fields used by BlockListBuilder
1615   int            _total_preds;                   // number of predecessors found by BlockListBuilder
1616   ResourceBitMap _stores_to_locals;              // bit is set when a local variable is stored in the block
1617 
1618   // SSA specific fields: (factor out later)
1619   BlockList   _successors;                       // the successors of this block
1620   BlockList   _predecessors;                     // the predecessors of this block
1621   BlockList   _dominates;                        // list of blocks that are dominated by this block
1622   BlockBegin* _dominator;                        // the dominator of this block
1623   // SSA specific ends
1624   BlockEnd*  _end;                               // the last instruction of this block
1625   BlockList  _exception_handlers;                // the exception handlers potentially invoked by this block
1626   ValueStackStack* _exception_states;            // only for xhandler entries: states of all instructions that have an edge to this xhandler
1627   int        _exception_handler_pco;             // if this block is the start of an exception handler,
1628                                                  // this records the PC offset in the assembly code of the
1629                                                  // first instruction in this block
1630   Label      _label;                             // the label associated with this block
1631   LIR_List*  _lir;                               // the low level intermediate representation for this block
1632 
1633   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1634   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1635   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1636   ResourceBitMap _live_kill;                     // set of registers defined in this block
1637 
1638   ResourceBitMap _fpu_register_usage;
1639   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1640   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1641   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1642 
1643   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1644   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1645 
1646   friend class SuxAndWeightAdjuster;
1647 
1648  public:
1649    void* operator new(size_t size) throw() {
1650     Compilation* c = Compilation::current();
1651     void* res = c-&gt;arena()-&gt;Amalloc(size);
1652     return res;
1653   }
1654 
1655   // initialization/counting
1656   static int  number_of_blocks() {
1657     return Compilation::current()-&gt;number_of_blocks();
1658   }
1659 
1660   // creation
1661   BlockBegin(int bci)
1662   : StateSplit(illegalType)
1663   , _block_id(Compilation::current()-&gt;get_next_block_id())
1664   , _bci(bci)
1665   , _depth_first_number(-1)
1666   , _linear_scan_number(-1)
1667   , _dominator_depth(-1)
1668   , _loop_depth(0)
1669   , _loop_index(-1)
1670   , _flags(0)
1671   , _total_preds(0)
1672   , _stores_to_locals()
1673   , _successors(2)
1674   , _predecessors(2)
1675   , _dominates(2)
1676   , _dominator(NULL)
1677   , _end(NULL)
1678   , _exception_handlers(1)
1679   , _exception_states(NULL)
1680   , _exception_handler_pco(-1)
1681   , _lir(NULL)
1682   , _live_in()
1683   , _live_out()
1684   , _live_gen()
1685   , _live_kill()
1686   , _fpu_register_usage()
1687   , _fpu_stack_state(NULL)
1688   , _first_lir_instruction_id(-1)
1689   , _last_lir_instruction_id(-1)
1690   {
1691     _block = this;
1692 #ifndef PRODUCT
1693     set_printable_bci(bci);
1694 #endif
1695   }
1696 
1697   // accessors
1698   int block_id() const                           { return _block_id; }
1699   int bci() const                                { return _bci; }
1700   BlockList* successors()                        { return &amp;_successors; }
1701   BlockList* dominates()                         { return &amp;_dominates; }
1702   BlockBegin* dominator() const                  { return _dominator; }
1703   int loop_depth() const                         { return _loop_depth; }
1704   int dominator_depth() const                    { return _dominator_depth; }
1705   int depth_first_number() const                 { return _depth_first_number; }
1706   int linear_scan_number() const                 { return _linear_scan_number; }
1707   BlockEnd* end() const                          { return _end; }
1708   Label* label()                                 { return &amp;_label; }
1709   LIR_List* lir() const                          { return _lir; }
1710   int exception_handler_pco() const              { return _exception_handler_pco; }
1711   ResourceBitMap&amp; live_in()                      { return _live_in;        }
1712   ResourceBitMap&amp; live_out()                     { return _live_out;       }
1713   ResourceBitMap&amp; live_gen()                     { return _live_gen;       }
1714   ResourceBitMap&amp; live_kill()                    { return _live_kill;      }
1715   ResourceBitMap&amp; fpu_register_usage()           { return _fpu_register_usage; }
1716   intArray* fpu_stack_state() const              { return _fpu_stack_state;    }
1717   int first_lir_instruction_id() const           { return _first_lir_instruction_id; }
1718   int last_lir_instruction_id() const            { return _last_lir_instruction_id; }
1719   int total_preds() const                        { return _total_preds; }
1720   BitMap&amp; stores_to_locals()                     { return _stores_to_locals; }
1721 
1722   // manipulation
1723   void set_dominator(BlockBegin* dom)            { _dominator = dom; }
1724   void set_loop_depth(int d)                     { _loop_depth = d; }
1725   void set_dominator_depth(int d)                { _dominator_depth = d; }
1726   void set_depth_first_number(int dfn)           { _depth_first_number = dfn; }
1727   void set_linear_scan_number(int lsn)           { _linear_scan_number = lsn; }
1728   void set_end(BlockEnd* end);
1729   void clear_end();
1730   void disconnect_from_graph();
1731   static void disconnect_edge(BlockBegin* from, BlockBegin* to);
1732   BlockBegin* insert_block_between(BlockBegin* sux);
1733   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1734   void set_lir(LIR_List* lir)                    { _lir = lir; }
1735   void set_exception_handler_pco(int pco)        { _exception_handler_pco = pco; }
1736   void set_live_in  (const ResourceBitMap&amp; map)  { _live_in = map;   }
1737   void set_live_out (const ResourceBitMap&amp; map)  { _live_out = map;  }
1738   void set_live_gen (const ResourceBitMap&amp; map)  { _live_gen = map;  }
1739   void set_live_kill(const ResourceBitMap&amp; map)  { _live_kill = map; }
1740   void set_fpu_register_usage(const ResourceBitMap&amp; map) { _fpu_register_usage = map; }
1741   void set_fpu_stack_state(intArray* state)      { _fpu_stack_state = state;  }
1742   void set_first_lir_instruction_id(int id)      { _first_lir_instruction_id = id;  }
1743   void set_last_lir_instruction_id(int id)       { _last_lir_instruction_id = id;  }
1744   void increment_total_preds(int n = 1)          { _total_preds += n; }
1745   void init_stores_to_locals(int locals_count)   { _stores_to_locals.initialize(locals_count); }
1746 
1747   // generic
1748   virtual void state_values_do(ValueVisitor* f);
1749 
1750   // successors and predecessors
1751   int number_of_sux() const;
1752   BlockBegin* sux_at(int i) const;
1753   void add_successor(BlockBegin* sux);
1754   void remove_successor(BlockBegin* pred);
1755   bool is_successor(BlockBegin* sux) const       { return _successors.contains(sux); }
1756 
1757   void add_predecessor(BlockBegin* pred);
1758   void remove_predecessor(BlockBegin* pred);
1759   bool is_predecessor(BlockBegin* pred) const    { return _predecessors.contains(pred); }
1760   int number_of_preds() const                    { return _predecessors.length(); }
1761   BlockBegin* pred_at(int i) const               { return _predecessors.at(i); }
1762 
1763   // exception handlers potentially invoked by this block
1764   void add_exception_handler(BlockBegin* b);
1765   bool is_exception_handler(BlockBegin* b) const { return _exception_handlers.contains(b); }
1766   int  number_of_exception_handlers() const      { return _exception_handlers.length(); }
1767   BlockBegin* exception_handler_at(int i) const  { return _exception_handlers.at(i); }
1768 
1769   // states of the instructions that have an edge to this exception handler
1770   int number_of_exception_states()               { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states == NULL ? 0 : _exception_states-&gt;length(); }
1771   ValueStack* exception_state_at(int idx) const  { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states-&gt;at(idx); }
1772   int add_exception_state(ValueStack* state);
1773 
1774   // flags
1775   enum Flag {
1776     no_flag                       = 0,
1777     std_entry_flag                = 1 &lt;&lt; 0,
1778     osr_entry_flag                = 1 &lt;&lt; 1,
1779     exception_entry_flag          = 1 &lt;&lt; 2,
1780     subroutine_entry_flag         = 1 &lt;&lt; 3,
1781     backward_branch_target_flag   = 1 &lt;&lt; 4,
1782     is_on_work_list_flag          = 1 &lt;&lt; 5,
1783     was_visited_flag              = 1 &lt;&lt; 6,
1784     parser_loop_header_flag       = 1 &lt;&lt; 7,  // set by parser to identify blocks where phi functions can not be created on demand
1785     critical_edge_split_flag      = 1 &lt;&lt; 8, // set for all blocks that are introduced when critical edges are split
1786     linear_scan_loop_header_flag  = 1 &lt;&lt; 9, // set during loop-detection for LinearScan
1787     linear_scan_loop_end_flag     = 1 &lt;&lt; 10, // set during loop-detection for LinearScan
1788     donot_eliminate_range_checks  = 1 &lt;&lt; 11  // Should be try to eliminate range checks in this block
1789   };
1790 
1791   void set(Flag f)                               { _flags |= f; }
1792   void clear(Flag f)                             { _flags &amp;= ~f; }
1793   bool is_set(Flag f) const                      { return (_flags &amp; f) != 0; }
1794   bool is_entry_block() const {
1795     const int entry_mask = std_entry_flag | osr_entry_flag | exception_entry_flag;
1796     return (_flags &amp; entry_mask) != 0;
1797   }
1798 
1799   // iteration
1800   void iterate_preorder   (BlockClosure* closure);
1801   void iterate_postorder  (BlockClosure* closure);
1802 
1803   void block_values_do(ValueVisitor* f);
1804 
1805   // loops
1806   void set_loop_index(int ix)                    { _loop_index = ix;        }
1807   int  loop_index() const                        { return _loop_index;      }
1808 
1809   // merging
1810   bool try_merge(ValueStack* state);             // try to merge states at block begin
1811   void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, &quot;merge failed&quot;); }
1812 
1813   // debugging
1814   void print_block()                             PRODUCT_RETURN;
1815   void print_block(InstructionPrinter&amp; ip, bool live_only = false) PRODUCT_RETURN;
1816 };
1817 
1818 
1819 BASE(BlockEnd, StateSplit)
1820  private:
1821   BlockList*  _sux;
1822 
1823  protected:
1824   BlockList* sux() const                         { return _sux; }
1825 
1826   void set_sux(BlockList* sux) {
1827 #ifdef ASSERT
1828     assert(sux != NULL, &quot;sux must exist&quot;);
1829     for (int i = sux-&gt;length() - 1; i &gt;= 0; i--) assert(sux-&gt;at(i) != NULL, &quot;sux must exist&quot;);
1830 #endif
1831     _sux = sux;
1832   }
1833 
1834  public:
1835   // creation
1836   BlockEnd(ValueType* type, ValueStack* state_before, bool is_safepoint)
1837   : StateSplit(type, state_before)
1838   , _sux(NULL)
1839   {
1840     set_flag(IsSafepointFlag, is_safepoint);
1841   }
1842 
1843   // accessors
1844   bool is_safepoint() const                      { return check_flag(IsSafepointFlag); }
1845   // For compatibility with old code, for new code use block()
1846   BlockBegin* begin() const                      { return _block; }
1847 
1848   // manipulation
1849   void set_begin(BlockBegin* begin);
1850 
1851   // successors
1852   int number_of_sux() const                      { return _sux != NULL ? _sux-&gt;length() : 0; }
1853   BlockBegin* sux_at(int i) const                { return _sux-&gt;at(i); }
1854   BlockBegin* default_sux() const                { return sux_at(number_of_sux() - 1); }
1855   BlockBegin** addr_sux_at(int i) const          { return _sux-&gt;adr_at(i); }
1856   int sux_index(BlockBegin* sux) const           { return _sux-&gt;find(sux); }
1857   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1858 };
1859 
1860 
1861 LEAF(Goto, BlockEnd)
1862  public:
1863   enum Direction {
1864     none,            // Just a regular goto
1865     taken, not_taken // Goto produced from If
1866   };
1867  private:
1868   ciMethod*   _profiled_method;
1869   int         _profiled_bci;
1870   Direction   _direction;
1871  public:
1872   // creation
1873   Goto(BlockBegin* sux, ValueStack* state_before, bool is_safepoint = false)
1874     : BlockEnd(illegalType, state_before, is_safepoint)
1875     , _profiled_method(NULL)
1876     , _profiled_bci(0)
1877     , _direction(none) {
1878     BlockList* s = new BlockList(1);
1879     s-&gt;append(sux);
1880     set_sux(s);
1881   }
1882 
1883   Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)
1884                                            , _profiled_method(NULL)
1885                                            , _profiled_bci(0)
1886                                            , _direction(none) {
1887     BlockList* s = new BlockList(1);
1888     s-&gt;append(sux);
1889     set_sux(s);
1890   }
1891 
1892   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
1893   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
1894   int profiled_bci() const                       { return _profiled_bci; }
1895   Direction direction() const                    { return _direction; }
1896 
1897   void set_should_profile(bool value)            { set_flag(ProfileMDOFlag, value); }
1898   void set_profiled_method(ciMethod* method)     { _profiled_method = method; }
1899   void set_profiled_bci(int bci)                 { _profiled_bci = bci; }
1900   void set_direction(Direction d)                { _direction = d; }
1901 };
1902 
1903 #ifdef ASSERT
1904 LEAF(Assert, Instruction)
1905   private:
1906   Value       _x;
1907   Condition   _cond;
1908   Value       _y;
1909   char        *_message;
1910 
1911  public:
1912   // creation
1913   // unordered_is_true is valid for float/double compares only
1914    Assert(Value x, Condition cond, bool unordered_is_true, Value y);
1915 
1916   // accessors
1917   Value x() const                                { return _x; }
1918   Condition cond() const                         { return _cond; }
1919   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
1920   Value y() const                                { return _y; }
1921   const char *message() const                    { return _message; }
1922 
1923   // generic
1924   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1925 };
1926 #endif
1927 
1928 LEAF(RangeCheckPredicate, StateSplit)
1929  private:
1930   Value       _x;
1931   Condition   _cond;
1932   Value       _y;
1933 
1934   void check_state();
1935 
1936  public:
1937   // creation
1938   // unordered_is_true is valid for float/double compares only
1939    RangeCheckPredicate(Value x, Condition cond, bool unordered_is_true, Value y, ValueStack* state) : StateSplit(illegalType)
1940   , _x(x)
1941   , _cond(cond)
1942   , _y(y)
1943   {
1944     ASSERT_VALUES
1945     set_flag(UnorderedIsTrueFlag, unordered_is_true);
1946     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1947     this-&gt;set_state(state);
1948     check_state();
1949   }
1950 
1951   // Always deoptimize
1952   RangeCheckPredicate(ValueStack* state) : StateSplit(illegalType)
1953   {
1954     this-&gt;set_state(state);
1955     _x = _y = NULL;
1956     check_state();
1957   }
1958 
1959   // accessors
1960   Value x() const                                { return _x; }
1961   Condition cond() const                         { return _cond; }
1962   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
1963   Value y() const                                { return _y; }
1964 
1965   void always_fail()                             { _x = _y = NULL; }
1966 
1967   // generic
1968   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1969   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
1970 };
1971 
1972 LEAF(If, BlockEnd)
1973  private:
1974   Value       _x;
1975   Condition   _cond;
1976   Value       _y;
1977   ciMethod*   _profiled_method;
1978   int         _profiled_bci; // Canonicalizer may alter bci of If node
1979   bool        _swapped;      // Is the order reversed with respect to the original If in the
1980                              // bytecode stream?
1981  public:
1982   // creation
1983   // unordered_is_true is valid for float/double compares only
1984   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint)
1985     : BlockEnd(illegalType, state_before, is_safepoint)
1986   , _x(x)
1987   , _cond(cond)
1988   , _y(y)
1989   , _profiled_method(NULL)
1990   , _profiled_bci(0)
1991   , _swapped(false)
1992   {
1993     ASSERT_VALUES
1994     set_flag(UnorderedIsTrueFlag, unordered_is_true);
1995     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1996     BlockList* s = new BlockList(2);
1997     s-&gt;append(tsux);
1998     s-&gt;append(fsux);
1999     set_sux(s);
2000   }
2001 
2002   // accessors
2003   Value x() const                                { return _x; }
2004   Condition cond() const                         { return _cond; }
2005   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2006   Value y() const                                { return _y; }
2007   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2008   BlockBegin* tsux() const                       { return sux_for(true); }
2009   BlockBegin* fsux() const                       { return sux_for(false); }
2010   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2011   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2012   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2013   int profiled_bci() const                       { return _profiled_bci; }    // set for profiled branches and tiered
2014   bool is_swapped() const                        { return _swapped; }
2015 
2016   // manipulation
2017   void swap_operands() {
2018     Value t = _x; _x = _y; _y = t;
2019     _cond = mirror(_cond);
2020   }
2021 
2022   void swap_sux() {
2023     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2024     BlockList* s = sux();
2025     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2026     _cond = negate(_cond);
2027     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2028   }
2029 
2030   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2031   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2032   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2033   void set_swapped(bool value)                    { _swapped = value;         }
2034   // generic
2035   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2036 };
2037 
2038 
2039 LEAF(IfInstanceOf, BlockEnd)
2040  private:
2041   ciKlass* _klass;
2042   Value    _obj;
2043   bool     _test_is_instance;                    // jump if instance
2044   int      _instanceof_bci;
2045 
2046  public:
2047   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2048   : BlockEnd(illegalType, NULL, false) // temporary set to false
2049   , _klass(klass)
2050   , _obj(obj)
2051   , _test_is_instance(test_is_instance)
2052   , _instanceof_bci(instanceof_bci)
2053   {
2054     ASSERT_VALUES
2055     assert(instanceof_bci &gt;= 0, &quot;illegal bci&quot;);
2056     BlockList* s = new BlockList(2);
2057     s-&gt;append(tsux);
2058     s-&gt;append(fsux);
2059     set_sux(s);
2060   }
2061 
2062   // accessors
2063   //
2064   // Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an
2065   //         instance of klass; otherwise it tests if it is *not* and instance
2066   //         of klass.
2067   //
2068   // Note 2: IfInstanceOf instructions are created by combining an InstanceOf
2069   //         and an If instruction. The IfInstanceOf bci() corresponds to the
2070   //         bci that the If would have had; the (this-&gt;) instanceof_bci() is
2071   //         the bci of the original InstanceOf instruction.
2072   ciKlass* klass() const                         { return _klass; }
2073   Value obj() const                              { return _obj; }
2074   int instanceof_bci() const                     { return _instanceof_bci; }
2075   bool test_is_instance() const                  { return _test_is_instance; }
2076   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2077   BlockBegin* tsux() const                       { return sux_for(true); }
2078   BlockBegin* fsux() const                       { return sux_for(false); }
2079 
2080   // manipulation
2081   void swap_sux() {
2082     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2083     BlockList* s = sux();
2084     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2085     _test_is_instance = !_test_is_instance;
2086   }
2087 
2088   // generic
2089   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_obj); }
2090 };
2091 
2092 
2093 BASE(Switch, BlockEnd)
2094  private:
2095   Value       _tag;
2096 
2097  public:
2098   // creation
2099   Switch(Value tag, BlockList* sux, ValueStack* state_before, bool is_safepoint)
2100   : BlockEnd(illegalType, state_before, is_safepoint)
2101   , _tag(tag) {
2102     ASSERT_VALUES
2103     set_sux(sux);
2104   }
2105 
2106   // accessors
2107   Value tag() const                              { return _tag; }
2108   int length() const                             { return number_of_sux() - 1; }
2109 
2110   virtual bool needs_exception_state() const     { return false; }
2111 
2112   // generic
2113   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_tag); }
2114 };
2115 
2116 
2117 LEAF(TableSwitch, Switch)
2118  private:
2119   int _lo_key;
2120 
2121  public:
2122   // creation
2123   TableSwitch(Value tag, BlockList* sux, int lo_key, ValueStack* state_before, bool is_safepoint)
2124     : Switch(tag, sux, state_before, is_safepoint)
2125   , _lo_key(lo_key) { assert(_lo_key &lt;= hi_key(), &quot;integer overflow&quot;); }
2126 
2127   // accessors
2128   int lo_key() const                             { return _lo_key; }
2129   int hi_key() const                             { return _lo_key + (length() - 1); }
2130 };
2131 
2132 
2133 LEAF(LookupSwitch, Switch)
2134  private:
2135   intArray* _keys;
2136 
2137  public:
2138   // creation
2139   LookupSwitch(Value tag, BlockList* sux, intArray* keys, ValueStack* state_before, bool is_safepoint)
2140   : Switch(tag, sux, state_before, is_safepoint)
2141   , _keys(keys) {
2142     assert(keys != NULL, &quot;keys must exist&quot;);
2143     assert(keys-&gt;length() == length(), &quot;sux &amp; keys have incompatible lengths&quot;);
2144   }
2145 
2146   // accessors
2147   int key_at(int i) const                        { return _keys-&gt;at(i); }
2148 };
2149 
2150 
2151 LEAF(Return, BlockEnd)
2152  private:
2153   Value _result;
2154 
2155  public:
2156   // creation
2157   Return(Value result) :
2158     BlockEnd(result == NULL ? voidType : result-&gt;type()-&gt;base(), NULL, true),
2159     _result(result) {}
2160 
2161   // accessors
2162   Value result() const                           { return _result; }
2163   bool has_result() const                        { return result() != NULL; }
2164 
2165   // generic
2166   virtual void input_values_do(ValueVisitor* f) {
2167     BlockEnd::input_values_do(f);
2168     if (has_result()) f-&gt;visit(&amp;_result);
2169   }
2170 };
2171 
2172 
2173 LEAF(Throw, BlockEnd)
2174  private:
2175   Value _exception;
2176 
2177  public:
2178   // creation
2179   Throw(Value exception, ValueStack* state_before) : BlockEnd(illegalType, state_before, true), _exception(exception) {
2180     ASSERT_VALUES
2181   }
2182 
2183   // accessors
2184   Value exception() const                        { return _exception; }
2185 
2186   // generic
2187   virtual bool can_trap() const                  { return true; }
2188   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_exception); }
2189 };
2190 
2191 
2192 LEAF(Base, BlockEnd)
2193  public:
2194   // creation
2195   Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {
2196     assert(std_entry-&gt;is_set(BlockBegin::std_entry_flag), &quot;std entry must be flagged&quot;);
2197     assert(osr_entry == NULL || osr_entry-&gt;is_set(BlockBegin::osr_entry_flag), &quot;osr entry must be flagged&quot;);
2198     BlockList* s = new BlockList(2);
2199     if (osr_entry != NULL) s-&gt;append(osr_entry);
2200     s-&gt;append(std_entry); // must be default sux!
2201     set_sux(s);
2202   }
2203 
2204   // accessors
2205   BlockBegin* std_entry() const                  { return default_sux(); }
2206   BlockBegin* osr_entry() const                  { return number_of_sux() &lt; 2 ? NULL : sux_at(0); }
2207 };
2208 
2209 
2210 LEAF(OsrEntry, Instruction)
2211  public:
2212   // creation
2213 #ifdef _LP64
2214   OsrEntry() : Instruction(longType) { pin(); }
2215 #else
2216   OsrEntry() : Instruction(intType)  { pin(); }
2217 #endif
2218 
2219   // generic
2220   virtual void input_values_do(ValueVisitor* f)   { }
2221 };
2222 
2223 
2224 // Models the incoming exception at a catch site
2225 LEAF(ExceptionObject, Instruction)
2226  public:
2227   // creation
2228   ExceptionObject() : Instruction(objectType) {
2229     pin();
2230   }
2231 
2232   // generic
2233   virtual void input_values_do(ValueVisitor* f)   { }
2234 };
2235 
2236 
2237 // Models needed rounding for floating-point values on Intel.
2238 // Currently only used to represent rounding of double-precision
2239 // values stored into local variables, but could be used to model
2240 // intermediate rounding of single-precision values as well.
2241 LEAF(RoundFP, Instruction)
2242  private:
2243   Value _input;             // floating-point value to be rounded
2244 
2245  public:
2246   RoundFP(Value input)
2247   : Instruction(input-&gt;type()) // Note: should not be used for constants
2248   , _input(input)
2249   {
2250     ASSERT_VALUES
2251   }
2252 
2253   // accessors
2254   Value input() const                            { return _input; }
2255 
2256   // generic
2257   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_input); }
2258 };
2259 
2260 
2261 BASE(UnsafeOp, Instruction)
2262  private:
2263   BasicType _basic_type;    // ValueType can not express byte-sized integers
2264 
2265  protected:
2266   // creation
2267   UnsafeOp(BasicType basic_type, bool is_put)
2268   : Instruction(is_put ? voidType : as_ValueType(basic_type))
2269   , _basic_type(basic_type)
2270   {
2271     //Note:  Unsafe ops are not not guaranteed to throw NPE.
2272     // Convservatively, Unsafe operations must be pinned though we could be
2273     // looser about this if we wanted to..
2274     pin();
2275   }
2276 
2277  public:
2278   // accessors
2279   BasicType basic_type()                         { return _basic_type; }
2280 
2281   // generic
2282   virtual void input_values_do(ValueVisitor* f)   { }
2283 };
2284 
2285 
2286 BASE(UnsafeRawOp, UnsafeOp)
2287  private:
2288   Value _base;                                   // Base address (a Java long)
2289   Value _index;                                  // Index if computed by optimizer; initialized to NULL
2290   int   _log2_scale;                             // Scale factor: 0, 1, 2, or 3.
2291                                                  // Indicates log2 of number of bytes (1, 2, 4, or 8)
2292                                                  // to scale index by.
2293 
2294  protected:
2295   UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)
2296   : UnsafeOp(basic_type, is_put)
2297   , _base(addr)
2298   , _index(NULL)
2299   , _log2_scale(0)
2300   {
2301     // Can not use ASSERT_VALUES because index may be NULL
2302     assert(addr != NULL &amp;&amp; addr-&gt;type()-&gt;is_long(), &quot;just checking&quot;);
2303   }
2304 
2305   UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)
2306   : UnsafeOp(basic_type, is_put)
2307   , _base(base)
2308   , _index(index)
2309   , _log2_scale(log2_scale)
2310   {
2311   }
2312 
2313  public:
2314   // accessors
2315   Value base()                                   { return _base; }
2316   Value index()                                  { return _index; }
2317   bool  has_index()                              { return (_index != NULL); }
2318   int   log2_scale()                             { return _log2_scale; }
2319 
2320   // setters
2321   void set_base (Value base)                     { _base  = base; }
2322   void set_index(Value index)                    { _index = index; }
2323   void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }
2324 
2325   // generic
2326   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2327                                                    f-&gt;visit(&amp;_base);
2328                                                    if (has_index()) f-&gt;visit(&amp;_index); }
2329 };
2330 
2331 
2332 LEAF(UnsafeGetRaw, UnsafeRawOp)
2333  private:
2334  bool _may_be_unaligned, _is_wide;  // For OSREntry
2335 
2336  public:
2337  UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)
2338   : UnsafeRawOp(basic_type, addr, false) {
2339     _may_be_unaligned = may_be_unaligned;
2340     _is_wide = is_wide;
2341   }
2342 
2343  UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)
2344   : UnsafeRawOp(basic_type, base, index, log2_scale, false) {
2345     _may_be_unaligned = may_be_unaligned;
2346     _is_wide = is_wide;
2347   }
2348 
2349   bool may_be_unaligned()                         { return _may_be_unaligned; }
2350   bool is_wide()                                  { return _is_wide; }
2351 };
2352 
2353 
2354 LEAF(UnsafePutRaw, UnsafeRawOp)
2355  private:
2356   Value _value;                                  // Value to be stored
2357 
2358  public:
2359   UnsafePutRaw(BasicType basic_type, Value addr, Value value)
2360   : UnsafeRawOp(basic_type, addr, true)
2361   , _value(value)
2362   {
2363     assert(value != NULL, &quot;just checking&quot;);
2364     ASSERT_VALUES
2365   }
2366 
2367   UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)
2368   : UnsafeRawOp(basic_type, base, index, log2_scale, true)
2369   , _value(value)
2370   {
2371     assert(value != NULL, &quot;just checking&quot;);
2372     ASSERT_VALUES
2373   }
2374 
2375   // accessors
2376   Value value()                                  { return _value; }
2377 
2378   // generic
2379   virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);
2380                                                    f-&gt;visit(&amp;_value); }
2381 };
2382 
2383 
2384 BASE(UnsafeObjectOp, UnsafeOp)
2385  private:
2386   Value _object;                                 // Object to be fetched from or mutated
2387   Value _offset;                                 // Offset within object
2388   bool  _is_volatile;                            // true if volatile - dl/JSR166
2389  public:
2390   UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)
2391     : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)
2392   {
2393   }
2394 
2395   // accessors
2396   Value object()                                 { return _object; }
2397   Value offset()                                 { return _offset; }
2398   bool  is_volatile()                            { return _is_volatile; }
2399   // generic
2400   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2401                                                    f-&gt;visit(&amp;_object);
2402                                                    f-&gt;visit(&amp;_offset); }
2403 };
2404 
2405 
2406 LEAF(UnsafeGetObject, UnsafeObjectOp)
2407  public:
2408   UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)
2409   : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)
2410   {
2411     ASSERT_VALUES
2412   }
2413 };
2414 
2415 
2416 LEAF(UnsafePutObject, UnsafeObjectOp)
2417  private:
2418   Value _value;                                  // Value to be stored
2419  public:
2420   UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)
2421   : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)
2422     , _value(value)
2423   {
2424     ASSERT_VALUES
2425   }
2426 
2427   // accessors
2428   Value value()                                  { return _value; }
2429 
2430   // generic
2431   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2432                                                    f-&gt;visit(&amp;_value); }
2433 };
2434 
2435 LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)
2436  private:
2437   Value _value;                                  // Value to be stored
2438   bool  _is_add;
2439  public:
2440   UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)
2441   : UnsafeObjectOp(basic_type, object, offset, false, false)
2442     , _value(value)
2443     , _is_add(is_add)
2444   {
2445     ASSERT_VALUES
2446   }
2447 
2448   // accessors
2449   bool is_add() const                            { return _is_add; }
2450   Value value()                                  { return _value; }
2451 
2452   // generic
2453   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2454                                                    f-&gt;visit(&amp;_value); }
2455 };
2456 
2457 LEAF(ProfileCall, Instruction)
2458  private:
2459   ciMethod*        _method;
2460   int              _bci_of_invoke;
2461   ciMethod*        _callee;         // the method that is called at the given bci
2462   Value            _recv;
2463   ciKlass*         _known_holder;
2464   Values*          _obj_args;       // arguments for type profiling
2465   ArgsNonNullState _nonnull_state;  // Do we know whether some arguments are never null?
2466   bool             _inlined;        // Are we profiling a call that is inlined
2467 
2468  public:
2469   ProfileCall(ciMethod* method, int bci, ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined)
2470     : Instruction(voidType)
2471     , _method(method)
2472     , _bci_of_invoke(bci)
2473     , _callee(callee)
2474     , _recv(recv)
2475     , _known_holder(known_holder)
2476     , _obj_args(obj_args)
2477     , _inlined(inlined)
2478   {
2479     // The ProfileCall has side-effects and must occur precisely where located
2480     pin();
2481   }
2482 
2483   ciMethod* method()             const { return _method; }
2484   int bci_of_invoke()            const { return _bci_of_invoke; }
2485   ciMethod* callee()             const { return _callee; }
2486   Value recv()                   const { return _recv; }
2487   ciKlass* known_holder()        const { return _known_holder; }
2488   int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args-&gt;length(); }
2489   Value profiled_arg_at(int i)   const { return _obj_args-&gt;at(i); }
2490   bool arg_needs_null_check(int i) const {
2491     return _nonnull_state.arg_needs_null_check(i);
2492   }
2493   bool inlined()                 const { return _inlined; }
2494 
2495   void set_arg_needs_null_check(int i, bool check) {
2496     _nonnull_state.set_arg_needs_null_check(i, check);
2497   }
2498 
2499   virtual void input_values_do(ValueVisitor* f)   {
2500     if (_recv != NULL) {
2501       f-&gt;visit(&amp;_recv);
2502     }
2503     for (int i = 0; i &lt; nb_profiled_args(); i++) {
2504       f-&gt;visit(_obj_args-&gt;adr_at(i));
2505     }
2506   }
2507 };
2508 
2509 LEAF(ProfileReturnType, Instruction)
2510  private:
2511   ciMethod*        _method;
2512   ciMethod*        _callee;
2513   int              _bci_of_invoke;
2514   Value            _ret;
2515 
2516  public:
2517   ProfileReturnType(ciMethod* method, int bci, ciMethod* callee, Value ret)
2518     : Instruction(voidType)
2519     , _method(method)
2520     , _callee(callee)
2521     , _bci_of_invoke(bci)
2522     , _ret(ret)
2523   {
2524     set_needs_null_check(true);
2525     // The ProfileType has side-effects and must occur precisely where located
2526     pin();
2527   }
2528 
2529   ciMethod* method()             const { return _method; }
2530   ciMethod* callee()             const { return _callee; }
2531   int bci_of_invoke()            const { return _bci_of_invoke; }
2532   Value ret()                    const { return _ret; }
2533 
2534   virtual void input_values_do(ValueVisitor* f)   {
2535     if (_ret != NULL) {
2536       f-&gt;visit(&amp;_ret);
2537     }
2538   }
2539 };
2540 
2541 // Call some C runtime function that doesn&#39;t safepoint,
2542 // optionally passing the current thread as the first argument.
2543 LEAF(RuntimeCall, Instruction)
2544  private:
2545   const char* _entry_name;
2546   address     _entry;
2547   Values*     _args;
2548   bool        _pass_thread;  // Pass the JavaThread* as an implicit first argument
2549 
2550  public:
2551   RuntimeCall(ValueType* type, const char* entry_name, address entry, Values* args, bool pass_thread = true)
2552     : Instruction(type)
2553     , _entry_name(entry_name)
2554     , _entry(entry)
2555     , _args(args)
2556     , _pass_thread(pass_thread) {
2557     ASSERT_VALUES
2558     pin();
2559   }
2560 
2561   const char* entry_name() const  { return _entry_name; }
2562   address entry() const           { return _entry; }
2563   int number_of_arguments() const { return _args-&gt;length(); }
2564   Value argument_at(int i) const  { return _args-&gt;at(i); }
2565   bool pass_thread() const        { return _pass_thread; }
2566 
2567   virtual void input_values_do(ValueVisitor* f)   {
2568     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
2569   }
2570 };
2571 
2572 // Use to trip invocation counter of an inlined method
2573 
2574 LEAF(ProfileInvoke, Instruction)
2575  private:
2576   ciMethod*   _inlinee;
2577   ValueStack* _state;
2578 
2579  public:
2580   ProfileInvoke(ciMethod* inlinee,  ValueStack* state)
2581     : Instruction(voidType)
2582     , _inlinee(inlinee)
2583     , _state(state)
2584   {
2585     // The ProfileInvoke has side-effects and must occur precisely where located QQQ???
2586     pin();
2587   }
2588 
2589   ciMethod* inlinee()      { return _inlinee; }
2590   ValueStack* state()      { return _state; }
2591   virtual void input_values_do(ValueVisitor*)   {}
2592   virtual void state_values_do(ValueVisitor*);
2593 };
2594 
2595 LEAF(MemBar, Instruction)
2596  private:
2597   LIR_Code _code;
2598 
2599  public:
2600   MemBar(LIR_Code code)
2601     : Instruction(voidType)
2602     , _code(code)
2603   {
2604     pin();
2605   }
2606 
2607   LIR_Code code()           { return _code; }
2608 
2609   virtual void input_values_do(ValueVisitor*)   {}
2610 };
2611 
2612 class BlockPair: public CompilationResourceObj {
2613  private:
2614   BlockBegin* _from;
2615   BlockBegin* _to;
2616  public:
2617   BlockPair(BlockBegin* from, BlockBegin* to): _from(from), _to(to) {}
2618   BlockBegin* from() const { return _from; }
2619   BlockBegin* to() const   { return _to;   }
2620   bool is_same(BlockBegin* from, BlockBegin* to) const { return  _from == from &amp;&amp; _to == to; }
2621   bool is_same(BlockPair* p) const { return  _from == p-&gt;from() &amp;&amp; _to == p-&gt;to(); }
2622   void set_to(BlockBegin* b)   { _to = b; }
2623   void set_from(BlockBegin* b) { _from = b; }
2624 };
2625 
2626 typedef GrowableArray&lt;BlockPair*&gt; BlockPairList;
2627 
2628 inline int         BlockBegin::number_of_sux() const            { assert(_end == NULL || _end-&gt;number_of_sux() == _successors.length(), &quot;mismatch&quot;); return _successors.length(); }
2629 inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end == NULL || _end-&gt;sux_at(i) == _successors.at(i), &quot;mismatch&quot;);          return _successors.at(i); }
2630 inline void        BlockBegin::add_successor(BlockBegin* sux)   { assert(_end == NULL, &quot;Would create mismatch with successors of BlockEnd&quot;);         _successors.append(sux); }
2631 
2632 #undef ASSERT_VALUES
2633 
2634 #endif // SHARE_C1_C1_INSTRUCTION_HPP
    </pre>
  </body>
</html>
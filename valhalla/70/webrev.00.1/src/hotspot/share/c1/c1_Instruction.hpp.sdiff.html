<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_ValueMap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Instruction.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;

  75 class     NewArray;
  76 class       NewTypeArray;
  77 class       NewObjectArray;
  78 class       NewMultiArray;


  79 class     TypeCheck;
  80 class       CheckCast;
  81 class       InstanceOf;
  82 class     AccessMonitor;
  83 class       MonitorEnter;
  84 class       MonitorExit;
  85 class     Intrinsic;
  86 class     BlockBegin;
  87 class     BlockEnd;
  88 class       Goto;
  89 class       If;
  90 class       IfInstanceOf;
  91 class       Switch;
  92 class         TableSwitch;
  93 class         LookupSwitch;
  94 class       Return;
  95 class       Throw;
  96 class       Base;
  97 class   RoundFP;
  98 class   UnsafeOp;
</pre>
<hr />
<pre>
 160  public:
 161   virtual void do_Phi            (Phi*             x) = 0;
 162   virtual void do_Local          (Local*           x) = 0;
 163   virtual void do_Constant       (Constant*        x) = 0;
 164   virtual void do_LoadField      (LoadField*       x) = 0;
 165   virtual void do_StoreField     (StoreField*      x) = 0;
 166   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 167   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 168   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 169   virtual void do_NegateOp       (NegateOp*        x) = 0;
 170   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 171   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 172   virtual void do_LogicOp        (LogicOp*         x) = 0;
 173   virtual void do_CompareOp      (CompareOp*       x) = 0;
 174   virtual void do_IfOp           (IfOp*            x) = 0;
 175   virtual void do_Convert        (Convert*         x) = 0;
 176   virtual void do_NullCheck      (NullCheck*       x) = 0;
 177   virtual void do_TypeCast       (TypeCast*        x) = 0;
 178   virtual void do_Invoke         (Invoke*          x) = 0;
 179   virtual void do_NewInstance    (NewInstance*     x) = 0;

 180   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 181   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 182   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;


 183   virtual void do_CheckCast      (CheckCast*       x) = 0;
 184   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 185   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 186   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 187   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 188   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 189   virtual void do_Goto           (Goto*            x) = 0;
 190   virtual void do_If             (If*              x) = 0;
 191   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 192   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 193   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 194   virtual void do_Return         (Return*          x) = 0;
 195   virtual void do_Throw          (Throw*           x) = 0;
 196   virtual void do_Base           (Base*            x) = 0;
 197   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 198   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 199   virtual void do_RoundFP        (RoundFP*         x) = 0;
 200   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 201   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 202   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 203   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 204   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 205   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 206   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 207   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 208   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 209   virtual void do_MemBar         (MemBar*          x) = 0;
 210   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 211 #ifdef ASSERT
 212   virtual void do_Assert         (Assert*          x) = 0;
 213 #endif
 214 };
 215 
 216 
 217 // Hashing support
 218 //
 219 // Note: This hash functions affect the performance
 220 //       of ValueMap - make changes carefully!
 221 
 222 #define HASH1(x1            )                    ((intx)(x1))
<span class="line-modified"> 223 #define HASH2(x1, x2        )                    ((HASH1(x1        ) &lt;&lt; 7) ^ HASH1(x2))</span>
<span class="line-modified"> 224 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2    ) &lt;&lt; 7) ^ HASH1(x3))</span>
<span class="line-modified"> 225 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3) &lt;&lt; 7) ^ HASH1(x4))</span>

 226 
 227 
 228 // The following macros are used to implement instruction-specific hashing.
 229 // By default, each instruction implements hash() and is_equal(Value), used
 230 // for value numbering/common subexpression elimination. The default imple-
 231 // mentation disables value numbering. Each instruction which can be value-
 232 // numbered, should define corresponding hash() and is_equal(Value) functions
 233 // via the macros below. The f arguments specify all the values/op codes, etc.
 234 // that need to be identical for two instructions to be identical.
 235 //
 236 // Note: The default implementation of hash() returns 0 in order to indicate
 237 //       that the instruction should not be considered for value numbering.
 238 //       The currently used hash functions do not guarantee that never a 0
 239 //       is produced. While this is still correct, it may be a performance
 240 //       bug (no value numbering for that node). However, this situation is
 241 //       so unlikely, that we are not going to handle it specially.
 242 
 243 #define HASHING1(class_name, enabled, f1)             \
 244   virtual intx hash() const {                         \
 245     return (enabled) ? HASH2(name(), f1) : 0;         \
</pre>
<hr />
<pre>
 264     if (f1 != _v-&gt;f1) return false;                   \
 265     if (f2 != _v-&gt;f2) return false;                   \
 266     return true;                                      \
 267   }                                                   \
 268 
 269 
 270 #define HASHING3(class_name, enabled, f1, f2, f3)     \
 271   virtual intx hash() const {                         \
 272     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 273   }                                                   \
 274   virtual bool is_equal(Value v) const {              \
 275     if (!(enabled)  ) return false;                   \
 276     class_name* _v = v-&gt;as_##class_name();            \
 277     if (_v == NULL  ) return false;                   \
 278     if (f1 != _v-&gt;f1) return false;                   \
 279     if (f2 != _v-&gt;f2) return false;                   \
 280     if (f3 != _v-&gt;f3) return false;                   \
 281     return true;                                      \
 282   }                                                   \
 283 















 284 
 285 // The mother of all instructions...
 286 
 287 class Instruction: public CompilationResourceObj {
 288  private:
 289   int          _id;                              // the unique instruction id
 290 #ifndef PRODUCT
 291   int          _printable_bci;                   // the bci of the instruction for printing
 292 #endif
 293   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 294   int          _pin_state;                       // set of PinReason describing the reason for pinning
 295   ValueType*   _type;                            // the instruction value type
 296   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 297   Instruction* _subst;                           // the substitution instruction if any
 298   LIR_Opr      _operand;                         // LIR specific information
 299   unsigned int _flags;                           // Flag bits
 300 
 301   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 302   ValueStack*  _exception_state;                 // Copy of state for exception handling
 303   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
</pre>
<hr />
<pre>
 338         if (check) {
 339           _nonnull_state |= nth_bit(i);
 340         } else {
 341           _nonnull_state &amp;= ~(nth_bit(i));
 342         }
 343       }
 344     }
 345   };
 346 
 347  public:
 348   void* operator new(size_t size) throw() {
 349     Compilation* c = Compilation::current();
 350     void* res = c-&gt;arena()-&gt;Amalloc(size);
 351     return res;
 352   }
 353 
 354   static const int no_bci = -99;
 355 
 356   enum InstructionFlag {
 357     NeedsNullCheckFlag = 0,

 358     CanTrapFlag,
 359     DirectCompareFlag,
 360     IsEliminatedFlag,
 361     IsSafepointFlag,
 362     IsStaticFlag,
 363     IsStrictfpFlag,
 364     NeedsStoreCheckFlag,
 365     NeedsWriteBarrierFlag,
 366     PreservesStateFlag,
 367     TargetIsFinalFlag,
 368     TargetIsLoadedFlag,
 369     TargetIsStrictfpFlag,
 370     UnorderedIsTrueFlag,
 371     NeedsPatchingFlag,
 372     ThrowIncompatibleClassChangeErrorFlag,
 373     InvokeSpecialReceiverCheckFlag,
 374     ProfileMDOFlag,
 375     IsLinkedInBlockFlag,
 376     NeedsRangeCheckFlag,
 377     InWorkListFlag,
</pre>
<hr />
<pre>
 432   int id() const                                 { return _id; }
 433 #ifndef PRODUCT
 434   bool has_printable_bci() const                 { return _printable_bci != -99; }
 435   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 436   void set_printable_bci(int bci)                { _printable_bci = bci; }
 437 #endif
 438   int dominator_depth();
 439   int use_count() const                          { return _use_count; }
 440   int pin_state() const                          { return _pin_state; }
 441   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 442   ValueType* type() const                        { return _type; }
 443   BlockBegin *block() const                      { return _block; }
 444   Instruction* prev();                           // use carefully, expensive operation
 445   Instruction* next() const                      { return _next; }
 446   bool has_subst() const                         { return _subst != NULL; }
 447   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 448   LIR_Opr operand() const                        { return _operand; }
 449 
 450   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 451   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }


 452   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 453   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 454 
 455   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 456 
 457   bool has_uses() const                          { return use_count() &gt; 0; }
 458   ValueStack* state_before() const               { return _state_before; }
 459   ValueStack* exception_state() const            { return _exception_state; }
 460   virtual bool needs_exception_state() const     { return true; }
 461   XHandlers* exception_handlers() const          { return _exception_handlers; }







 462 
 463   // manipulation
 464   void pin(PinReason reason)                     { _pin_state |= reason; }
 465   void pin()                                     { _pin_state |= PinUnknown; }
 466   // DANGEROUS: only used by EliminateStores
 467   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 468 
 469   Instruction* set_next(Instruction* next) {
 470     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 471     assert(next != NULL, &quot;must not be NULL&quot;);
 472     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 473     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 474 
 475     BlockBegin *block = this-&gt;block();
 476     next-&gt;_block = block;
 477 
 478     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 479     _next = next;
 480     return next;
 481   }
</pre>
<hr />
<pre>
 486 #endif
 487     return set_next(next);
 488   }
 489 
 490   // when blocks are merged
 491   void fixup_block_pointers() {
 492     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 493     while (cur &amp;&amp; cur-&gt;_block != block()) {
 494       cur-&gt;_block = block();
 495       cur = cur-&gt;next();
 496     }
 497   }
 498 
 499   Instruction *insert_after(Instruction *i) {
 500     Instruction* n = _next;
 501     set_next(i);
 502     i-&gt;set_next(n);
 503     return _next;
 504   }
 505 




 506   Instruction *insert_after_same_bci(Instruction *i) {
 507 #ifndef PRODUCT
 508     i-&gt;set_printable_bci(printable_bci());
 509 #endif
 510     return insert_after(i);
 511   }
 512 
 513   void set_subst(Instruction* subst)             {
 514     assert(subst == NULL ||
 515            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 516            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 517     _subst = subst;
 518   }
 519   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 520   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 521   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 522 
 523   // machine-specifics
 524   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 525   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
</pre>
<hr />
<pre>
 533   virtual LoadField*        as_LoadField()       { return NULL; }
 534   virtual StoreField*       as_StoreField()      { return NULL; }
 535   virtual AccessArray*      as_AccessArray()     { return NULL; }
 536   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 537   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 538   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 539   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 540   virtual NegateOp*         as_NegateOp()        { return NULL; }
 541   virtual Op2*              as_Op2()             { return NULL; }
 542   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 543   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 544   virtual LogicOp*          as_LogicOp()         { return NULL; }
 545   virtual CompareOp*        as_CompareOp()       { return NULL; }
 546   virtual IfOp*             as_IfOp()            { return NULL; }
 547   virtual Convert*          as_Convert()         { return NULL; }
 548   virtual NullCheck*        as_NullCheck()       { return NULL; }
 549   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 550   virtual StateSplit*       as_StateSplit()      { return NULL; }
 551   virtual Invoke*           as_Invoke()          { return NULL; }
 552   virtual NewInstance*      as_NewInstance()     { return NULL; }

 553   virtual NewArray*         as_NewArray()        { return NULL; }
 554   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 555   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 556   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }


 557   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 558   virtual CheckCast*        as_CheckCast()       { return NULL; }
 559   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 560   virtual TypeCast*         as_TypeCast()        { return NULL; }
 561   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 562   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 563   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 564   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 565   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 566   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 567   virtual Goto*             as_Goto()            { return NULL; }
 568   virtual If*               as_If()              { return NULL; }
 569   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 570   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 571   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 572   virtual Return*           as_Return()          { return NULL; }
 573   virtual Throw*            as_Throw()           { return NULL; }
 574   virtual Base*             as_Base()            { return NULL; }
 575   virtual RoundFP*          as_RoundFP()         { return NULL; }
 576   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
</pre>
<hr />
<pre>
 686   }
 687 
 688   bool is_illegal() const {
 689     return type()-&gt;is_illegal();
 690   }
 691 
 692   // generic
 693   virtual void input_values_do(ValueVisitor* f) {
 694   }
 695 };
 696 
 697 
 698 // A local is a placeholder for an incoming argument to a function call.
 699 LEAF(Local, Instruction)
 700  private:
 701   int      _java_index;                          // the local index within the method to which the local belongs
 702   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 703   ciType*  _declared_type;
 704  public:
 705   // creation
<span class="line-modified"> 706   Local(ciType* declared, ValueType* type, int index, bool receiver)</span>
 707     : Instruction(type)
 708     , _java_index(index)
 709     , _is_receiver(receiver)
 710     , _declared_type(declared)
 711   {

 712     NOT_PRODUCT(set_printable_bci(-1));
 713   }
 714 
 715   // accessors
 716   int java_index() const                         { return _java_index; }
 717   bool is_receiver() const                       { return _is_receiver; }
 718 
 719   virtual ciType* declared_type() const          { return _declared_type; }
 720 
 721   // generic
 722   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 723 };
 724 
 725 
 726 LEAF(Constant, Instruction)
 727  public:
 728   // creation
 729   Constant(ValueType* type):
 730       Instruction(type, NULL, /*type_is_constant*/ true)
 731   {
</pre>
<hr />
<pre>
 811 
 812   // manipulation
 813 
 814   // Under certain circumstances, if a previous NullCheck instruction
 815   // proved the target object non-null, we can eliminate the explicit
 816   // null check and do an implicit one, simply specifying the debug
 817   // information from the NullCheck. This field should only be consulted
 818   // if needs_null_check() is true.
 819   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 820 
 821   // generic
 822   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 823   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 824 };
 825 
 826 
 827 LEAF(LoadField, AccessField)
 828  public:
 829   // creation
 830   LoadField(Value obj, int offset, ciField* field, bool is_static,
<span class="line-modified"> 831             ValueStack* state_before, bool needs_patching)</span>

 832   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 833   {}
 834 
 835   ciType* declared_type() const;
 836 
 837   // generic; cannot be eliminated if needs patching or if volatile.
 838   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 839 };
 840 
 841 
 842 LEAF(StoreField, AccessField)
 843  private:
 844   Value _value;
 845 
 846  public:
 847   // creation
 848   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 849              ValueStack* state_before, bool needs_patching)
 850   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 851   , _value(value)
</pre>
<hr />
<pre>
 898   , _explicit_null_check(NULL) {}
 899 
 900   // accessors
 901   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 902 
 903   // setters
 904   // See LoadField::set_explicit_null_check for documentation
 905   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 906 
 907   // generic
 908   HASHING1(ArrayLength, true, array()-&gt;subst())
 909 };
 910 
 911 
 912 BASE(AccessIndexed, AccessArray)
 913  private:
 914   Value     _index;
 915   Value     _length;
 916   BasicType _elt_type;
 917   bool      _mismatched;


 918 
 919  public:
 920   // creation
 921   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 922   : AccessArray(as_ValueType(elt_type), array, state_before)
 923   , _index(index)
 924   , _length(length)
 925   , _elt_type(elt_type)
 926   , _mismatched(mismatched)

 927   {
 928     set_flag(Instruction::NeedsRangeCheckFlag, true);
 929     ASSERT_VALUES
 930   }
 931 
 932   // accessors
 933   Value index() const                            { return _index; }
 934   Value length() const                           { return _length; }
 935   BasicType elt_type() const                     { return _elt_type; }
 936   bool mismatched() const                        { return _mismatched; }
 937 
 938   void clear_length()                            { _length = NULL; }
 939   // perform elimination of range checks involving constants
 940   bool compute_needs_range_check();
 941 
<span class="line-modified"> 942   // generic</span>









 943   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 944 };
 945 
 946 
 947 LEAF(LoadIndexed, AccessIndexed)
 948  private:
 949   NullCheck*  _explicit_null_check;              // For explicit null check elimination

 950 
 951  public:
 952   // creation
 953   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
 954   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
<span class="line-modified"> 955   , _explicit_null_check(NULL) {}</span>
 956 
 957   // accessors
 958   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 959 
 960   // setters
 961   // See LoadField::set_explicit_null_check for documentation
 962   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 963 
 964   ciType* exact_type() const;
 965   ciType* declared_type() const;
 966 
<span class="line-modified"> 967   // generic;</span>
<span class="line-modified"> 968   HASHING3(LoadIndexed, true, type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst())</span>



 969 };
 970 
 971 
 972 LEAF(StoreIndexed, AccessIndexed)
 973  private:
 974   Value       _value;
 975 
<span class="line-removed"> 976   ciMethod* _profiled_method;</span>
<span class="line-removed"> 977   int       _profiled_bci;</span>
 978   bool      _check_boolean;
 979 
 980  public:
 981   // creation
 982   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
 983                bool check_boolean, bool mismatched = false)
 984   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
<span class="line-modified"> 985   , _value(value), _profiled_method(NULL), _profiled_bci(0), _check_boolean(check_boolean)</span>
 986   {
 987     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
 988     set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));
 989     ASSERT_VALUES
 990     pin();
 991   }
 992 
 993   // accessors
 994   Value value() const                            { return _value; }
 995   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 996   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
 997   bool check_boolean() const                     { return _check_boolean; }
<span class="line-modified"> 998   // Helpers for MethodData* profiling</span>
<span class="line-modified"> 999   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }</span>
<span class="line-modified">1000   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }</span>
<span class="line-removed">1001   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }</span>
<span class="line-removed">1002   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }</span>
<span class="line-removed">1003   ciMethod* profiled_method() const                  { return _profiled_method;     }</span>
<span class="line-removed">1004   int       profiled_bci() const                     { return _profiled_bci;        }</span>
1005   // generic
1006   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1007 };
1008 
1009 
1010 LEAF(NegateOp, Instruction)
1011  private:
1012   Value _x;
1013 
1014  public:
1015   // creation
1016   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1017     ASSERT_VALUES
1018   }
1019 
1020   // accessors
1021   Value x() const                                { return _x; }
1022 
1023   // generic
1024   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
</pre>
<hr />
<pre>
1099   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1100 };
1101 
1102 
1103 LEAF(CompareOp, Op2)
1104  public:
1105   // creation
1106   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1107   : Op2(intType, op, x, y, state_before)
1108   {}
1109 
1110   // generic
1111   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1112 };
1113 
1114 
1115 LEAF(IfOp, Op2)
1116  private:
1117   Value _tval;
1118   Value _fval;

1119 
1120  public:
1121   // creation
<span class="line-modified">1122   IfOp(Value x, Condition cond, Value y, Value tval, Value fval)</span>
1123   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1124   , _tval(tval)
1125   , _fval(fval)

1126   {
1127     ASSERT_VALUES
1128     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);

1129   }
1130 
1131   // accessors
1132   virtual bool is_commutative() const;
1133   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1134   Condition cond() const                         { return (Condition)Op2::op(); }
1135   Value tval() const                             { return _tval; }
1136   Value fval() const                             { return _fval; }
<span class="line-modified">1137 </span>
1138   // generic
1139   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1140 };
1141 
1142 
1143 LEAF(Convert, Instruction)
1144  private:
1145   Bytecodes::Code _op;
1146   Value           _value;
1147 
1148  public:
1149   // creation
1150   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1151     ASSERT_VALUES
1152   }
1153 
1154   // accessors
1155   Bytecodes::Code op() const                     { return _op; }
1156   Value value() const                            { return _value; }
1157 
</pre>
<hr />
<pre>
1237   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1238 
1239   // generic
1240   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1241   virtual void state_values_do(ValueVisitor* f);
1242 };
1243 
1244 
1245 LEAF(Invoke, StateSplit)
1246  private:
1247   Bytecodes::Code _code;
1248   Value           _recv;
1249   Values*         _args;
1250   BasicTypeList*  _signature;
1251   int             _vtable_index;
1252   ciMethod*       _target;
1253 
1254  public:
1255   // creation
1256   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
<span class="line-modified">1257          int vtable_index, ciMethod* target, ValueStack* state_before);</span>
1258 
1259   // accessors
1260   Bytecodes::Code code() const                   { return _code; }
1261   Value receiver() const                         { return _recv; }
1262   bool has_receiver() const                      { return receiver() != NULL; }
1263   int number_of_arguments() const                { return _args-&gt;length(); }
1264   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1265   int vtable_index() const                       { return _vtable_index; }
1266   BasicTypeList* signature() const               { return _signature; }
1267   ciMethod* target() const                       { return _target; }
1268 
1269   ciType* declared_type() const;
1270 
1271   // Returns false if target is not loaded
1272   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1273   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1274   // Returns false if target is not loaded
1275   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1276 
1277   // JSR 292 support
</pre>
<hr />
<pre>
1298 
1299  public:
1300   // creation
1301   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1302   : StateSplit(instanceType, state_before)
1303   , _klass(klass), _is_unresolved(is_unresolved)
1304   {}
1305 
1306   // accessors
1307   ciInstanceKlass* klass() const                 { return _klass; }
1308   bool is_unresolved() const                     { return _is_unresolved; }
1309 
1310   virtual bool needs_exception_state() const     { return false; }
1311 
1312   // generic
1313   virtual bool can_trap() const                  { return true; }
1314   ciType* exact_type() const;
1315   ciType* declared_type() const;
1316 };
1317 























































1318 
1319 BASE(NewArray, StateSplit)
1320  private:
1321   Value       _length;
1322 
1323  public:
1324   // creation
1325   NewArray(Value length, ValueStack* state_before)
1326   : StateSplit(objectType, state_before)
1327   , _length(length)
1328   {
1329     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1330   }
1331 
1332   // accessors
1333   Value length() const                           { return _length; }
1334 
1335   virtual bool needs_exception_state() const     { return false; }
1336 
1337   ciType* exact_type() const                     { return NULL; }
</pre>
<hr />
<pre>
1349 
1350  public:
1351   // creation
1352   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1353   : NewArray(length, state_before)
1354   , _elt_type(elt_type)
1355   {}
1356 
1357   // accessors
1358   BasicType elt_type() const                     { return _elt_type; }
1359   ciType* exact_type() const;
1360 };
1361 
1362 
1363 LEAF(NewObjectArray, NewArray)
1364  private:
1365   ciKlass* _klass;
1366 
1367  public:
1368   // creation
<span class="line-modified">1369   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before) : NewArray(length, state_before), _klass(klass) {}</span>



1370 
1371   // accessors
1372   ciKlass* klass() const                         { return _klass; }
1373   ciType* exact_type() const;
1374 };
1375 
1376 
1377 LEAF(NewMultiArray, NewArray)
1378  private:
1379   ciKlass* _klass;
1380   Values*  _dims;
1381 
1382  public:
1383   // creation
1384   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1385     ASSERT_VALUES
1386   }
1387 
1388   // accessors
1389   ciKlass* klass() const                         { return _klass; }
1390   Values* dims() const                           { return _dims; }
1391   int rank() const                               { return dims()-&gt;length(); }
1392 
1393   // generic
1394   virtual void input_values_do(ValueVisitor* f) {
1395     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1396     // is meaningless for a multi-dimensional array; passing the
1397     // zeroth element down to NewArray as its length is a bad idea
1398     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1399     // get updated, and the value must not be traversed twice. Was bug
1400     // - kbr 4/10/2001
1401     StateSplit::input_values_do(f);
1402     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1403   }


1404 };
1405 













1406 
1407 BASE(TypeCheck, StateSplit)
1408  private:
1409   ciKlass*    _klass;
1410   Value       _obj;
1411 
1412   ciMethod* _profiled_method;
1413   int       _profiled_bci;
1414 
1415  public:
1416   // creation
1417   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1418   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1419     _profiled_method(NULL), _profiled_bci(0) {
1420     ASSERT_VALUES
1421     set_direct_compare(false);
1422   }
1423 
1424   // accessors
1425   ciKlass* klass() const                         { return _klass; }
</pre>
<hr />
<pre>
1430   // manipulation
1431   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1432 
1433   // generic
1434   virtual bool can_trap() const                  { return true; }
1435   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1436 
1437   // Helpers for MethodData* profiling
1438   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1439   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1440   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1441   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1442   ciMethod* profiled_method() const                  { return _profiled_method;     }
1443   int       profiled_bci() const                     { return _profiled_bci;        }
1444 };
1445 
1446 
1447 LEAF(CheckCast, TypeCheck)
1448  public:
1449   // creation
<span class="line-modified">1450   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before)</span>
<span class="line-modified">1451   : TypeCheck(klass, obj, objectType, state_before) {}</span>


1452 
1453   void set_incompatible_class_change_check() {
1454     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1455   }
1456   bool is_incompatible_class_change_check() const {
1457     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1458   }
1459   void set_invokespecial_receiver_check() {
1460     set_flag(InvokeSpecialReceiverCheckFlag, true);
1461   }
1462   bool is_invokespecial_receiver_check() const {
1463     return check_flag(InvokeSpecialReceiverCheckFlag);
1464   }
1465 
1466   virtual bool needs_exception_state() const {
1467     return !is_invokespecial_receiver_check();
1468   }
1469 
1470   ciType* declared_type() const;
1471 };
</pre>
<hr />
<pre>
1489   // creation
1490   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1491   : StateSplit(illegalType, state_before)
1492   , _obj(obj)
1493   , _monitor_no(monitor_no)
1494   {
1495     set_needs_null_check(true);
1496     ASSERT_VALUES
1497   }
1498 
1499   // accessors
1500   Value obj() const                              { return _obj; }
1501   int monitor_no() const                         { return _monitor_no; }
1502 
1503   // generic
1504   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1505 };
1506 
1507 
1508 LEAF(MonitorEnter, AccessMonitor)

1509  public:
1510   // creation
<span class="line-modified">1511   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before)</span>
1512   : AccessMonitor(obj, monitor_no, state_before)

1513   {
1514     ASSERT_VALUES
1515   }
1516 



1517   // generic
1518   virtual bool can_trap() const                  { return true; }
1519 };
1520 
1521 
1522 LEAF(MonitorExit, AccessMonitor)
1523  public:
1524   // creation
1525   MonitorExit(Value obj, int monitor_no)
1526   : AccessMonitor(obj, monitor_no, NULL)
1527   {
1528     ASSERT_VALUES
1529   }
1530 };
1531 
1532 
1533 LEAF(Intrinsic, StateSplit)
1534  private:
1535   vmIntrinsics::ID _id;
1536   Values*          _args;
</pre>
<hr />
<pre>
1961   Condition cond() const                         { return _cond; }
1962   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
1963   Value y() const                                { return _y; }
1964 
1965   void always_fail()                             { _x = _y = NULL; }
1966 
1967   // generic
1968   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1969   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
1970 };
1971 
1972 LEAF(If, BlockEnd)
1973  private:
1974   Value       _x;
1975   Condition   _cond;
1976   Value       _y;
1977   ciMethod*   _profiled_method;
1978   int         _profiled_bci; // Canonicalizer may alter bci of If node
1979   bool        _swapped;      // Is the order reversed with respect to the original If in the
1980                              // bytecode stream?

1981  public:
1982   // creation
1983   // unordered_is_true is valid for float/double compares only
<span class="line-modified">1984   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint)</span>
1985     : BlockEnd(illegalType, state_before, is_safepoint)
1986   , _x(x)
1987   , _cond(cond)
1988   , _y(y)
1989   , _profiled_method(NULL)
1990   , _profiled_bci(0)
1991   , _swapped(false)

1992   {
1993     ASSERT_VALUES
1994     set_flag(UnorderedIsTrueFlag, unordered_is_true);
1995     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1996     BlockList* s = new BlockList(2);
1997     s-&gt;append(tsux);
1998     s-&gt;append(fsux);
1999     set_sux(s);
2000   }
2001 
2002   // accessors
2003   Value x() const                                { return _x; }
2004   Condition cond() const                         { return _cond; }
2005   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2006   Value y() const                                { return _y; }
2007   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2008   BlockBegin* tsux() const                       { return sux_for(true); }
2009   BlockBegin* fsux() const                       { return sux_for(false); }
2010   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2011   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
</pre>
<hr />
<pre>
2014   bool is_swapped() const                        { return _swapped; }
2015 
2016   // manipulation
2017   void swap_operands() {
2018     Value t = _x; _x = _y; _y = t;
2019     _cond = mirror(_cond);
2020   }
2021 
2022   void swap_sux() {
2023     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2024     BlockList* s = sux();
2025     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2026     _cond = negate(_cond);
2027     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2028   }
2029 
2030   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2031   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2032   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2033   void set_swapped(bool value)                    { _swapped = value;         }

2034   // generic
2035   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2036 };
2037 
2038 
2039 LEAF(IfInstanceOf, BlockEnd)
2040  private:
2041   ciKlass* _klass;
2042   Value    _obj;
2043   bool     _test_is_instance;                    // jump if instance
2044   int      _instanceof_bci;
2045 
2046  public:
2047   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2048   : BlockEnd(illegalType, NULL, false) // temporary set to false
2049   , _klass(klass)
2050   , _obj(obj)
2051   , _test_is_instance(test_is_instance)
2052   , _instanceof_bci(instanceof_bci)
2053   {
</pre>
</td>
<td>
<hr />
<pre>
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
<span class="line-added">  75 class     NewValueTypeInstance;</span>
  76 class     NewArray;
  77 class       NewTypeArray;
  78 class       NewObjectArray;
  79 class       NewMultiArray;
<span class="line-added">  80 class     WithField;</span>
<span class="line-added">  81 class     DefaultValue;</span>
  82 class     TypeCheck;
  83 class       CheckCast;
  84 class       InstanceOf;
  85 class     AccessMonitor;
  86 class       MonitorEnter;
  87 class       MonitorExit;
  88 class     Intrinsic;
  89 class     BlockBegin;
  90 class     BlockEnd;
  91 class       Goto;
  92 class       If;
  93 class       IfInstanceOf;
  94 class       Switch;
  95 class         TableSwitch;
  96 class         LookupSwitch;
  97 class       Return;
  98 class       Throw;
  99 class       Base;
 100 class   RoundFP;
 101 class   UnsafeOp;
</pre>
<hr />
<pre>
 163  public:
 164   virtual void do_Phi            (Phi*             x) = 0;
 165   virtual void do_Local          (Local*           x) = 0;
 166   virtual void do_Constant       (Constant*        x) = 0;
 167   virtual void do_LoadField      (LoadField*       x) = 0;
 168   virtual void do_StoreField     (StoreField*      x) = 0;
 169   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 170   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 171   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 172   virtual void do_NegateOp       (NegateOp*        x) = 0;
 173   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 174   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 175   virtual void do_LogicOp        (LogicOp*         x) = 0;
 176   virtual void do_CompareOp      (CompareOp*       x) = 0;
 177   virtual void do_IfOp           (IfOp*            x) = 0;
 178   virtual void do_Convert        (Convert*         x) = 0;
 179   virtual void do_NullCheck      (NullCheck*       x) = 0;
 180   virtual void do_TypeCast       (TypeCast*        x) = 0;
 181   virtual void do_Invoke         (Invoke*          x) = 0;
 182   virtual void do_NewInstance    (NewInstance*     x) = 0;
<span class="line-added"> 183   virtual void do_NewValueTypeInstance(NewValueTypeInstance* x) = 0;</span>
 184   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 185   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 186   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
<span class="line-added"> 187   virtual void do_WithField      (WithField*       x) = 0;</span>
<span class="line-added"> 188   virtual void do_DefaultValue   (DefaultValue*    x) = 0;</span>
 189   virtual void do_CheckCast      (CheckCast*       x) = 0;
 190   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 191   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 192   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 193   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 194   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 195   virtual void do_Goto           (Goto*            x) = 0;
 196   virtual void do_If             (If*              x) = 0;
 197   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 198   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 199   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 200   virtual void do_Return         (Return*          x) = 0;
 201   virtual void do_Throw          (Throw*           x) = 0;
 202   virtual void do_Base           (Base*            x) = 0;
 203   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 204   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 205   virtual void do_RoundFP        (RoundFP*         x) = 0;
 206   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 207   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 208   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 209   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 210   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 211   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 212   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 213   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 214   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 215   virtual void do_MemBar         (MemBar*          x) = 0;
 216   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 217 #ifdef ASSERT
 218   virtual void do_Assert         (Assert*          x) = 0;
 219 #endif
 220 };
 221 
 222 
 223 // Hashing support
 224 //
 225 // Note: This hash functions affect the performance
 226 //       of ValueMap - make changes carefully!
 227 
 228 #define HASH1(x1            )                    ((intx)(x1))
<span class="line-modified"> 229 #define HASH2(x1, x2        )                    ((HASH1(x1            ) &lt;&lt; 7) ^ HASH1(x2))</span>
<span class="line-modified"> 230 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2        ) &lt;&lt; 7) ^ HASH1(x3))</span>
<span class="line-modified"> 231 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3    ) &lt;&lt; 7) ^ HASH1(x4))</span>
<span class="line-added"> 232 #define HASH5(x1, x2, x3, x4, x5)                ((HASH4(x1, x2, x3, x4) &lt;&lt; 7) ^ HASH1(x5))</span>
 233 
 234 
 235 // The following macros are used to implement instruction-specific hashing.
 236 // By default, each instruction implements hash() and is_equal(Value), used
 237 // for value numbering/common subexpression elimination. The default imple-
 238 // mentation disables value numbering. Each instruction which can be value-
 239 // numbered, should define corresponding hash() and is_equal(Value) functions
 240 // via the macros below. The f arguments specify all the values/op codes, etc.
 241 // that need to be identical for two instructions to be identical.
 242 //
 243 // Note: The default implementation of hash() returns 0 in order to indicate
 244 //       that the instruction should not be considered for value numbering.
 245 //       The currently used hash functions do not guarantee that never a 0
 246 //       is produced. While this is still correct, it may be a performance
 247 //       bug (no value numbering for that node). However, this situation is
 248 //       so unlikely, that we are not going to handle it specially.
 249 
 250 #define HASHING1(class_name, enabled, f1)             \
 251   virtual intx hash() const {                         \
 252     return (enabled) ? HASH2(name(), f1) : 0;         \
</pre>
<hr />
<pre>
 271     if (f1 != _v-&gt;f1) return false;                   \
 272     if (f2 != _v-&gt;f2) return false;                   \
 273     return true;                                      \
 274   }                                                   \
 275 
 276 
 277 #define HASHING3(class_name, enabled, f1, f2, f3)     \
 278   virtual intx hash() const {                         \
 279     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 280   }                                                   \
 281   virtual bool is_equal(Value v) const {              \
 282     if (!(enabled)  ) return false;                   \
 283     class_name* _v = v-&gt;as_##class_name();            \
 284     if (_v == NULL  ) return false;                   \
 285     if (f1 != _v-&gt;f1) return false;                   \
 286     if (f2 != _v-&gt;f2) return false;                   \
 287     if (f3 != _v-&gt;f3) return false;                   \
 288     return true;                                      \
 289   }                                                   \
 290 
<span class="line-added"> 291 #define HASHING4(class_name, enabled, f1, f2, f3, f4) \</span>
<span class="line-added"> 292   virtual intx hash() const {                         \</span>
<span class="line-added"> 293     return (enabled) ? HASH5(name(), f1, f2, f3, f4) : 0; \</span>
<span class="line-added"> 294   }                                                   \</span>
<span class="line-added"> 295   virtual bool is_equal(Value v) const {              \</span>
<span class="line-added"> 296     if (!(enabled)  ) return false;                   \</span>
<span class="line-added"> 297     class_name* _v = v-&gt;as_##class_name();            \</span>
<span class="line-added"> 298     if (_v == NULL  ) return false;                   \</span>
<span class="line-added"> 299     if (f1 != _v-&gt;f1) return false;                   \</span>
<span class="line-added"> 300     if (f2 != _v-&gt;f2) return false;                   \</span>
<span class="line-added"> 301     if (f3 != _v-&gt;f3) return false;                   \</span>
<span class="line-added"> 302     if (f4 != _v-&gt;f4) return false;                   \</span>
<span class="line-added"> 303     return true;                                      \</span>
<span class="line-added"> 304   }                                                   \</span>
<span class="line-added"> 305 </span>
 306 
 307 // The mother of all instructions...
 308 
 309 class Instruction: public CompilationResourceObj {
 310  private:
 311   int          _id;                              // the unique instruction id
 312 #ifndef PRODUCT
 313   int          _printable_bci;                   // the bci of the instruction for printing
 314 #endif
 315   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 316   int          _pin_state;                       // set of PinReason describing the reason for pinning
 317   ValueType*   _type;                            // the instruction value type
 318   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 319   Instruction* _subst;                           // the substitution instruction if any
 320   LIR_Opr      _operand;                         // LIR specific information
 321   unsigned int _flags;                           // Flag bits
 322 
 323   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 324   ValueStack*  _exception_state;                 // Copy of state for exception handling
 325   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
</pre>
<hr />
<pre>
 360         if (check) {
 361           _nonnull_state |= nth_bit(i);
 362         } else {
 363           _nonnull_state &amp;= ~(nth_bit(i));
 364         }
 365       }
 366     }
 367   };
 368 
 369  public:
 370   void* operator new(size_t size) throw() {
 371     Compilation* c = Compilation::current();
 372     void* res = c-&gt;arena()-&gt;Amalloc(size);
 373     return res;
 374   }
 375 
 376   static const int no_bci = -99;
 377 
 378   enum InstructionFlag {
 379     NeedsNullCheckFlag = 0,
<span class="line-added"> 380     NeverNullFlag,          // For &quot;Q&quot; signatures</span>
 381     CanTrapFlag,
 382     DirectCompareFlag,
 383     IsEliminatedFlag,
 384     IsSafepointFlag,
 385     IsStaticFlag,
 386     IsStrictfpFlag,
 387     NeedsStoreCheckFlag,
 388     NeedsWriteBarrierFlag,
 389     PreservesStateFlag,
 390     TargetIsFinalFlag,
 391     TargetIsLoadedFlag,
 392     TargetIsStrictfpFlag,
 393     UnorderedIsTrueFlag,
 394     NeedsPatchingFlag,
 395     ThrowIncompatibleClassChangeErrorFlag,
 396     InvokeSpecialReceiverCheckFlag,
 397     ProfileMDOFlag,
 398     IsLinkedInBlockFlag,
 399     NeedsRangeCheckFlag,
 400     InWorkListFlag,
</pre>
<hr />
<pre>
 455   int id() const                                 { return _id; }
 456 #ifndef PRODUCT
 457   bool has_printable_bci() const                 { return _printable_bci != -99; }
 458   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 459   void set_printable_bci(int bci)                { _printable_bci = bci; }
 460 #endif
 461   int dominator_depth();
 462   int use_count() const                          { return _use_count; }
 463   int pin_state() const                          { return _pin_state; }
 464   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 465   ValueType* type() const                        { return _type; }
 466   BlockBegin *block() const                      { return _block; }
 467   Instruction* prev();                           // use carefully, expensive operation
 468   Instruction* next() const                      { return _next; }
 469   bool has_subst() const                         { return _subst != NULL; }
 470   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 471   LIR_Opr operand() const                        { return _operand; }
 472 
 473   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 474   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
<span class="line-added"> 475   void set_never_null(bool f)                    { set_flag(NeverNullFlag, f); }</span>
<span class="line-added"> 476   bool is_never_null() const                     { return check_flag(NeverNullFlag); }</span>
 477   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 478   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 479 
 480   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 481 
 482   bool has_uses() const                          { return use_count() &gt; 0; }
 483   ValueStack* state_before() const               { return _state_before; }
 484   ValueStack* exception_state() const            { return _exception_state; }
 485   virtual bool needs_exception_state() const     { return true; }
 486   XHandlers* exception_handlers() const          { return _exception_handlers; }
<span class="line-added"> 487   ciKlass* as_loaded_klass_or_null() const;</span>
<span class="line-added"> 488 </span>
<span class="line-added"> 489   // withfield optimization</span>
<span class="line-added"> 490   virtual void set_escaped()                     { }</span>
<span class="line-added"> 491   virtual void set_local_index(int index)        { }</span>
<span class="line-added"> 492   virtual bool is_optimizable_for_withfield() const { return false; }</span>
<span class="line-added"> 493 </span>
 494 
 495   // manipulation
 496   void pin(PinReason reason)                     { _pin_state |= reason; }
 497   void pin()                                     { _pin_state |= PinUnknown; }
 498   // DANGEROUS: only used by EliminateStores
 499   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 500 
 501   Instruction* set_next(Instruction* next) {
 502     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 503     assert(next != NULL, &quot;must not be NULL&quot;);
 504     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 505     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 506 
 507     BlockBegin *block = this-&gt;block();
 508     next-&gt;_block = block;
 509 
 510     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 511     _next = next;
 512     return next;
 513   }
</pre>
<hr />
<pre>
 518 #endif
 519     return set_next(next);
 520   }
 521 
 522   // when blocks are merged
 523   void fixup_block_pointers() {
 524     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 525     while (cur &amp;&amp; cur-&gt;_block != block()) {
 526       cur-&gt;_block = block();
 527       cur = cur-&gt;next();
 528     }
 529   }
 530 
 531   Instruction *insert_after(Instruction *i) {
 532     Instruction* n = _next;
 533     set_next(i);
 534     i-&gt;set_next(n);
 535     return _next;
 536   }
 537 
<span class="line-added"> 538   bool is_loaded_flattened_array() const;</span>
<span class="line-added"> 539   bool maybe_flattened_array();</span>
<span class="line-added"> 540   bool maybe_null_free_array();</span>
<span class="line-added"> 541 </span>
 542   Instruction *insert_after_same_bci(Instruction *i) {
 543 #ifndef PRODUCT
 544     i-&gt;set_printable_bci(printable_bci());
 545 #endif
 546     return insert_after(i);
 547   }
 548 
 549   void set_subst(Instruction* subst)             {
 550     assert(subst == NULL ||
 551            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 552            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 553     _subst = subst;
 554   }
 555   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 556   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 557   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 558 
 559   // machine-specifics
 560   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 561   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
</pre>
<hr />
<pre>
 569   virtual LoadField*        as_LoadField()       { return NULL; }
 570   virtual StoreField*       as_StoreField()      { return NULL; }
 571   virtual AccessArray*      as_AccessArray()     { return NULL; }
 572   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 573   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 574   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 575   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 576   virtual NegateOp*         as_NegateOp()        { return NULL; }
 577   virtual Op2*              as_Op2()             { return NULL; }
 578   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 579   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 580   virtual LogicOp*          as_LogicOp()         { return NULL; }
 581   virtual CompareOp*        as_CompareOp()       { return NULL; }
 582   virtual IfOp*             as_IfOp()            { return NULL; }
 583   virtual Convert*          as_Convert()         { return NULL; }
 584   virtual NullCheck*        as_NullCheck()       { return NULL; }
 585   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 586   virtual StateSplit*       as_StateSplit()      { return NULL; }
 587   virtual Invoke*           as_Invoke()          { return NULL; }
 588   virtual NewInstance*      as_NewInstance()     { return NULL; }
<span class="line-added"> 589   virtual NewValueTypeInstance* as_NewValueTypeInstance() { return NULL; }</span>
 590   virtual NewArray*         as_NewArray()        { return NULL; }
 591   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 592   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 593   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
<span class="line-added"> 594   virtual WithField*        as_WithField()       { return NULL; }</span>
<span class="line-added"> 595   virtual DefaultValue*     as_DefaultValue()    { return NULL; }</span>
 596   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 597   virtual CheckCast*        as_CheckCast()       { return NULL; }
 598   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 599   virtual TypeCast*         as_TypeCast()        { return NULL; }
 600   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 601   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 602   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 603   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 604   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 605   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 606   virtual Goto*             as_Goto()            { return NULL; }
 607   virtual If*               as_If()              { return NULL; }
 608   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 609   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 610   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 611   virtual Return*           as_Return()          { return NULL; }
 612   virtual Throw*            as_Throw()           { return NULL; }
 613   virtual Base*             as_Base()            { return NULL; }
 614   virtual RoundFP*          as_RoundFP()         { return NULL; }
 615   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
</pre>
<hr />
<pre>
 725   }
 726 
 727   bool is_illegal() const {
 728     return type()-&gt;is_illegal();
 729   }
 730 
 731   // generic
 732   virtual void input_values_do(ValueVisitor* f) {
 733   }
 734 };
 735 
 736 
 737 // A local is a placeholder for an incoming argument to a function call.
 738 LEAF(Local, Instruction)
 739  private:
 740   int      _java_index;                          // the local index within the method to which the local belongs
 741   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 742   ciType*  _declared_type;
 743  public:
 744   // creation
<span class="line-modified"> 745   Local(ciType* declared, ValueType* type, int index, bool receiver, bool never_null)</span>
 746     : Instruction(type)
 747     , _java_index(index)
 748     , _is_receiver(receiver)
 749     , _declared_type(declared)
 750   {
<span class="line-added"> 751     set_never_null(never_null);</span>
 752     NOT_PRODUCT(set_printable_bci(-1));
 753   }
 754 
 755   // accessors
 756   int java_index() const                         { return _java_index; }
 757   bool is_receiver() const                       { return _is_receiver; }
 758 
 759   virtual ciType* declared_type() const          { return _declared_type; }
 760 
 761   // generic
 762   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 763 };
 764 
 765 
 766 LEAF(Constant, Instruction)
 767  public:
 768   // creation
 769   Constant(ValueType* type):
 770       Instruction(type, NULL, /*type_is_constant*/ true)
 771   {
</pre>
<hr />
<pre>
 851 
 852   // manipulation
 853 
 854   // Under certain circumstances, if a previous NullCheck instruction
 855   // proved the target object non-null, we can eliminate the explicit
 856   // null check and do an implicit one, simply specifying the debug
 857   // information from the NullCheck. This field should only be consulted
 858   // if needs_null_check() is true.
 859   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 860 
 861   // generic
 862   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 863   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 864 };
 865 
 866 
 867 LEAF(LoadField, AccessField)
 868  public:
 869   // creation
 870   LoadField(Value obj, int offset, ciField* field, bool is_static,
<span class="line-modified"> 871             ValueStack* state_before, bool needs_patching,</span>
<span class="line-added"> 872             ciValueKlass* value_klass = NULL, Value default_value = NULL )</span>
 873   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 874   {}
 875 
 876   ciType* declared_type() const;
 877 
 878   // generic; cannot be eliminated if needs patching or if volatile.
 879   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 880 };
 881 
 882 
 883 LEAF(StoreField, AccessField)
 884  private:
 885   Value _value;
 886 
 887  public:
 888   // creation
 889   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 890              ValueStack* state_before, bool needs_patching)
 891   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 892   , _value(value)
</pre>
<hr />
<pre>
 939   , _explicit_null_check(NULL) {}
 940 
 941   // accessors
 942   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 943 
 944   // setters
 945   // See LoadField::set_explicit_null_check for documentation
 946   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 947 
 948   // generic
 949   HASHING1(ArrayLength, true, array()-&gt;subst())
 950 };
 951 
 952 
 953 BASE(AccessIndexed, AccessArray)
 954  private:
 955   Value     _index;
 956   Value     _length;
 957   BasicType _elt_type;
 958   bool      _mismatched;
<span class="line-added"> 959   ciMethod* _profiled_method;</span>
<span class="line-added"> 960   int       _profiled_bci;</span>
 961 
 962  public:
 963   // creation
 964   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 965   : AccessArray(as_ValueType(elt_type), array, state_before)
 966   , _index(index)
 967   , _length(length)
 968   , _elt_type(elt_type)
 969   , _mismatched(mismatched)
<span class="line-added"> 970   , _profiled_method(NULL), _profiled_bci(0)</span>
 971   {
 972     set_flag(Instruction::NeedsRangeCheckFlag, true);
 973     ASSERT_VALUES
 974   }
 975 
 976   // accessors
 977   Value index() const                            { return _index; }
 978   Value length() const                           { return _length; }
 979   BasicType elt_type() const                     { return _elt_type; }
 980   bool mismatched() const                        { return _mismatched; }
 981 
 982   void clear_length()                            { _length = NULL; }
 983   // perform elimination of range checks involving constants
 984   bool compute_needs_range_check();
 985 
<span class="line-modified"> 986   // Helpers for MethodData* profiling</span>
<span class="line-added"> 987   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }</span>
<span class="line-added"> 988   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }</span>
<span class="line-added"> 989   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }</span>
<span class="line-added"> 990   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }</span>
<span class="line-added"> 991   ciMethod* profiled_method() const                  { return _profiled_method;     }</span>
<span class="line-added"> 992   int       profiled_bci() const                     { return _profiled_bci;        }</span>
<span class="line-added"> 993 </span>
<span class="line-added"> 994 </span>
<span class="line-added"> 995 // generic</span>
 996   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 997 };
 998 
 999 
1000 LEAF(LoadIndexed, AccessIndexed)
1001  private:
1002   NullCheck*  _explicit_null_check;              // For explicit null check elimination
<span class="line-added">1003   NewValueTypeInstance* _vt;</span>
1004 
1005  public:
1006   // creation
1007   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
1008   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
<span class="line-modified">1009   , _explicit_null_check(NULL), _vt(NULL) {}</span>
1010 
1011   // accessors
1012   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
1013 
1014   // setters
1015   // See LoadField::set_explicit_null_check for documentation
1016   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
1017 
1018   ciType* exact_type() const;
1019   ciType* declared_type() const;
1020 
<span class="line-modified">1021   NewValueTypeInstance* vt() const { return _vt; }</span>
<span class="line-modified">1022   void set_vt(NewValueTypeInstance* vt) { _vt = vt; }</span>
<span class="line-added">1023 </span>
<span class="line-added">1024   // generic</span>
<span class="line-added">1025   HASHING4(LoadIndexed, !should_profile(), type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst(), vt())</span>
1026 };
1027 
1028 
1029 LEAF(StoreIndexed, AccessIndexed)
1030  private:
1031   Value       _value;
1032 


1033   bool      _check_boolean;
1034 
1035  public:
1036   // creation
1037   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
1038                bool check_boolean, bool mismatched = false)
1039   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
<span class="line-modified">1040   , _value(value), _check_boolean(check_boolean)</span>
1041   {
1042     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
1043     set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));
1044     ASSERT_VALUES
1045     pin();
1046   }
1047 
1048   // accessors
1049   Value value() const                            { return _value; }
1050   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
1051   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
1052   bool check_boolean() const                     { return _check_boolean; }
<span class="line-modified">1053 </span>
<span class="line-modified">1054   // Flattened array support</span>
<span class="line-modified">1055   bool is_exact_flattened_array_store() const;</span>




1056   // generic
1057   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1058 };
1059 
1060 
1061 LEAF(NegateOp, Instruction)
1062  private:
1063   Value _x;
1064 
1065  public:
1066   // creation
1067   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1068     ASSERT_VALUES
1069   }
1070 
1071   // accessors
1072   Value x() const                                { return _x; }
1073 
1074   // generic
1075   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
</pre>
<hr />
<pre>
1150   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1151 };
1152 
1153 
1154 LEAF(CompareOp, Op2)
1155  public:
1156   // creation
1157   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1158   : Op2(intType, op, x, y, state_before)
1159   {}
1160 
1161   // generic
1162   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1163 };
1164 
1165 
1166 LEAF(IfOp, Op2)
1167  private:
1168   Value _tval;
1169   Value _fval;
<span class="line-added">1170   bool _substitutability_check;</span>
1171 
1172  public:
1173   // creation
<span class="line-modified">1174   IfOp(Value x, Condition cond, Value y, Value tval, Value fval, ValueStack* state_before, bool substitutability_check)</span>
1175   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1176   , _tval(tval)
1177   , _fval(fval)
<span class="line-added">1178   , _substitutability_check(substitutability_check)</span>
1179   {
1180     ASSERT_VALUES
1181     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
<span class="line-added">1182     set_state_before(state_before);</span>
1183   }
1184 
1185   // accessors
1186   virtual bool is_commutative() const;
1187   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1188   Condition cond() const                         { return (Condition)Op2::op(); }
1189   Value tval() const                             { return _tval; }
1190   Value fval() const                             { return _fval; }
<span class="line-modified">1191   bool substitutability_check() const             { return _substitutability_check; }</span>
1192   // generic
1193   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1194 };
1195 
1196 
1197 LEAF(Convert, Instruction)
1198  private:
1199   Bytecodes::Code _op;
1200   Value           _value;
1201 
1202  public:
1203   // creation
1204   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1205     ASSERT_VALUES
1206   }
1207 
1208   // accessors
1209   Bytecodes::Code op() const                     { return _op; }
1210   Value value() const                            { return _value; }
1211 
</pre>
<hr />
<pre>
1291   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1292 
1293   // generic
1294   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1295   virtual void state_values_do(ValueVisitor* f);
1296 };
1297 
1298 
1299 LEAF(Invoke, StateSplit)
1300  private:
1301   Bytecodes::Code _code;
1302   Value           _recv;
1303   Values*         _args;
1304   BasicTypeList*  _signature;
1305   int             _vtable_index;
1306   ciMethod*       _target;
1307 
1308  public:
1309   // creation
1310   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
<span class="line-modified">1311          int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null);</span>
1312 
1313   // accessors
1314   Bytecodes::Code code() const                   { return _code; }
1315   Value receiver() const                         { return _recv; }
1316   bool has_receiver() const                      { return receiver() != NULL; }
1317   int number_of_arguments() const                { return _args-&gt;length(); }
1318   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1319   int vtable_index() const                       { return _vtable_index; }
1320   BasicTypeList* signature() const               { return _signature; }
1321   ciMethod* target() const                       { return _target; }
1322 
1323   ciType* declared_type() const;
1324 
1325   // Returns false if target is not loaded
1326   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1327   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1328   // Returns false if target is not loaded
1329   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1330 
1331   // JSR 292 support
</pre>
<hr />
<pre>
1352 
1353  public:
1354   // creation
1355   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1356   : StateSplit(instanceType, state_before)
1357   , _klass(klass), _is_unresolved(is_unresolved)
1358   {}
1359 
1360   // accessors
1361   ciInstanceKlass* klass() const                 { return _klass; }
1362   bool is_unresolved() const                     { return _is_unresolved; }
1363 
1364   virtual bool needs_exception_state() const     { return false; }
1365 
1366   // generic
1367   virtual bool can_trap() const                  { return true; }
1368   ciType* exact_type() const;
1369   ciType* declared_type() const;
1370 };
1371 
<span class="line-added">1372 LEAF(NewValueTypeInstance, StateSplit)</span>
<span class="line-added">1373   bool _is_unresolved;</span>
<span class="line-added">1374   ciValueKlass* _klass;</span>
<span class="line-added">1375   Value _depends_on;      // Link to instance on with withfield was called on</span>
<span class="line-added">1376   bool _is_optimizable_for_withfield;</span>
<span class="line-added">1377   int _first_local_index;</span>
<span class="line-added">1378 public:</span>
<span class="line-added">1379 </span>
<span class="line-added">1380   // Default creation, always allocated for now</span>
<span class="line-added">1381   NewValueTypeInstance(ciValueKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)</span>
<span class="line-added">1382   : StateSplit(instanceType, state_before)</span>
<span class="line-added">1383    , _is_unresolved(is_unresolved)</span>
<span class="line-added">1384    , _klass(klass)</span>
<span class="line-added">1385    , _is_optimizable_for_withfield(from_default_value)</span>
<span class="line-added">1386    , _first_local_index(-1)</span>
<span class="line-added">1387   {</span>
<span class="line-added">1388     if (depends_on == NULL) {</span>
<span class="line-added">1389       _depends_on = this;</span>
<span class="line-added">1390     } else {</span>
<span class="line-added">1391       _depends_on = depends_on;</span>
<span class="line-added">1392     }</span>
<span class="line-added">1393     set_never_null(true);</span>
<span class="line-added">1394   }</span>
<span class="line-added">1395 </span>
<span class="line-added">1396   // accessors</span>
<span class="line-added">1397   bool is_unresolved() const                     { return _is_unresolved; }</span>
<span class="line-added">1398   Value depends_on();</span>
<span class="line-added">1399 </span>
<span class="line-added">1400   ciValueKlass* klass() const { return _klass; }</span>
<span class="line-added">1401 </span>
<span class="line-added">1402   virtual bool needs_exception_state() const     { return false; }</span>
<span class="line-added">1403 </span>
<span class="line-added">1404   // generic</span>
<span class="line-added">1405   virtual bool can_trap() const                  { return true; }</span>
<span class="line-added">1406   ciType* exact_type() const;</span>
<span class="line-added">1407   ciType* declared_type() const;</span>
<span class="line-added">1408 </span>
<span class="line-added">1409   // Only done in LIR Generator -&gt; map everything to object</span>
<span class="line-added">1410   void set_to_object_type() { set_type(instanceType); }</span>
<span class="line-added">1411 </span>
<span class="line-added">1412   // withfield optimization</span>
<span class="line-added">1413   virtual void set_escaped() {</span>
<span class="line-added">1414     _is_optimizable_for_withfield = false;</span>
<span class="line-added">1415   }</span>
<span class="line-added">1416   virtual void set_local_index(int index) {</span>
<span class="line-added">1417     if (_first_local_index != index) {</span>
<span class="line-added">1418       if (_first_local_index == -1) {</span>
<span class="line-added">1419         _first_local_index = index;</span>
<span class="line-added">1420       } else {</span>
<span class="line-added">1421         _is_optimizable_for_withfield = false;</span>
<span class="line-added">1422       }</span>
<span class="line-added">1423     }</span>
<span class="line-added">1424   }</span>
<span class="line-added">1425   virtual bool is_optimizable_for_withfield() const {  return _is_optimizable_for_withfield; }</span>
<span class="line-added">1426 };</span>
1427 
1428 BASE(NewArray, StateSplit)
1429  private:
1430   Value       _length;
1431 
1432  public:
1433   // creation
1434   NewArray(Value length, ValueStack* state_before)
1435   : StateSplit(objectType, state_before)
1436   , _length(length)
1437   {
1438     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1439   }
1440 
1441   // accessors
1442   Value length() const                           { return _length; }
1443 
1444   virtual bool needs_exception_state() const     { return false; }
1445 
1446   ciType* exact_type() const                     { return NULL; }
</pre>
<hr />
<pre>
1458 
1459  public:
1460   // creation
1461   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1462   : NewArray(length, state_before)
1463   , _elt_type(elt_type)
1464   {}
1465 
1466   // accessors
1467   BasicType elt_type() const                     { return _elt_type; }
1468   ciType* exact_type() const;
1469 };
1470 
1471 
1472 LEAF(NewObjectArray, NewArray)
1473  private:
1474   ciKlass* _klass;
1475 
1476  public:
1477   // creation
<span class="line-modified">1478   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool never_null)</span>
<span class="line-added">1479   : NewArray(length, state_before), _klass(klass) {</span>
<span class="line-added">1480     set_never_null(never_null);</span>
<span class="line-added">1481   }</span>
1482 
1483   // accessors
1484   ciKlass* klass() const                         { return _klass; }
1485   ciType* exact_type() const;
1486 };
1487 
1488 
1489 LEAF(NewMultiArray, NewArray)
1490  private:
1491   ciKlass* _klass;
1492   Values*  _dims;
1493 
1494  public:
1495   // creation
1496   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1497     ASSERT_VALUES
1498   }
1499 
1500   // accessors
1501   ciKlass* klass() const                         { return _klass; }
1502   Values* dims() const                           { return _dims; }
1503   int rank() const                               { return dims()-&gt;length(); }
1504 
1505   // generic
1506   virtual void input_values_do(ValueVisitor* f) {
1507     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1508     // is meaningless for a multi-dimensional array; passing the
1509     // zeroth element down to NewArray as its length is a bad idea
1510     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1511     // get updated, and the value must not be traversed twice. Was bug
1512     // - kbr 4/10/2001
1513     StateSplit::input_values_do(f);
1514     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1515   }
<span class="line-added">1516 </span>
<span class="line-added">1517   ciType* exact_type() const;</span>
1518 };
1519 
<span class="line-added">1520 LEAF(WithField, StateSplit)</span>
<span class="line-added">1521  public:</span>
<span class="line-added">1522   // creation</span>
<span class="line-added">1523   WithField(ValueStack* state_before)</span>
<span class="line-added">1524   : StateSplit(objectType, state_before) {}</span>
<span class="line-added">1525 };</span>
<span class="line-added">1526 </span>
<span class="line-added">1527 LEAF(DefaultValue, StateSplit)</span>
<span class="line-added">1528  public:</span>
<span class="line-added">1529   // creation</span>
<span class="line-added">1530   DefaultValue(ValueStack* state_before)</span>
<span class="line-added">1531   : StateSplit(objectType, state_before) {}</span>
<span class="line-added">1532 };</span>
1533 
1534 BASE(TypeCheck, StateSplit)
1535  private:
1536   ciKlass*    _klass;
1537   Value       _obj;
1538 
1539   ciMethod* _profiled_method;
1540   int       _profiled_bci;
1541 
1542  public:
1543   // creation
1544   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1545   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1546     _profiled_method(NULL), _profiled_bci(0) {
1547     ASSERT_VALUES
1548     set_direct_compare(false);
1549   }
1550 
1551   // accessors
1552   ciKlass* klass() const                         { return _klass; }
</pre>
<hr />
<pre>
1557   // manipulation
1558   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1559 
1560   // generic
1561   virtual bool can_trap() const                  { return true; }
1562   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1563 
1564   // Helpers for MethodData* profiling
1565   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1566   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1567   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1568   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1569   ciMethod* profiled_method() const                  { return _profiled_method;     }
1570   int       profiled_bci() const                     { return _profiled_bci;        }
1571 };
1572 
1573 
1574 LEAF(CheckCast, TypeCheck)
1575  public:
1576   // creation
<span class="line-modified">1577   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool never_null = false)</span>
<span class="line-modified">1578   : TypeCheck(klass, obj, objectType, state_before) {</span>
<span class="line-added">1579     set_never_null(never_null);</span>
<span class="line-added">1580   }</span>
1581 
1582   void set_incompatible_class_change_check() {
1583     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1584   }
1585   bool is_incompatible_class_change_check() const {
1586     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1587   }
1588   void set_invokespecial_receiver_check() {
1589     set_flag(InvokeSpecialReceiverCheckFlag, true);
1590   }
1591   bool is_invokespecial_receiver_check() const {
1592     return check_flag(InvokeSpecialReceiverCheckFlag);
1593   }
1594 
1595   virtual bool needs_exception_state() const {
1596     return !is_invokespecial_receiver_check();
1597   }
1598 
1599   ciType* declared_type() const;
1600 };
</pre>
<hr />
<pre>
1618   // creation
1619   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1620   : StateSplit(illegalType, state_before)
1621   , _obj(obj)
1622   , _monitor_no(monitor_no)
1623   {
1624     set_needs_null_check(true);
1625     ASSERT_VALUES
1626   }
1627 
1628   // accessors
1629   Value obj() const                              { return _obj; }
1630   int monitor_no() const                         { return _monitor_no; }
1631 
1632   // generic
1633   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1634 };
1635 
1636 
1637 LEAF(MonitorEnter, AccessMonitor)
<span class="line-added">1638   bool _maybe_valuetype;</span>
1639  public:
1640   // creation
<span class="line-modified">1641   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_valuetype)</span>
1642   : AccessMonitor(obj, monitor_no, state_before)
<span class="line-added">1643   , _maybe_valuetype(maybe_valuetype)</span>
1644   {
1645     ASSERT_VALUES
1646   }
1647 
<span class="line-added">1648   // accessors</span>
<span class="line-added">1649   bool maybe_valuetype() const                   { return _maybe_valuetype; }</span>
<span class="line-added">1650 </span>
1651   // generic
1652   virtual bool can_trap() const                  { return true; }
1653 };
1654 
1655 
1656 LEAF(MonitorExit, AccessMonitor)
1657  public:
1658   // creation
1659   MonitorExit(Value obj, int monitor_no)
1660   : AccessMonitor(obj, monitor_no, NULL)
1661   {
1662     ASSERT_VALUES
1663   }
1664 };
1665 
1666 
1667 LEAF(Intrinsic, StateSplit)
1668  private:
1669   vmIntrinsics::ID _id;
1670   Values*          _args;
</pre>
<hr />
<pre>
2095   Condition cond() const                         { return _cond; }
2096   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2097   Value y() const                                { return _y; }
2098 
2099   void always_fail()                             { _x = _y = NULL; }
2100 
2101   // generic
2102   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2103   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
2104 };
2105 
2106 LEAF(If, BlockEnd)
2107  private:
2108   Value       _x;
2109   Condition   _cond;
2110   Value       _y;
2111   ciMethod*   _profiled_method;
2112   int         _profiled_bci; // Canonicalizer may alter bci of If node
2113   bool        _swapped;      // Is the order reversed with respect to the original If in the
2114                              // bytecode stream?
<span class="line-added">2115   bool        _substitutability_check;</span>
2116  public:
2117   // creation
2118   // unordered_is_true is valid for float/double compares only
<span class="line-modified">2119   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint, bool substitutability_check=false)</span>
2120     : BlockEnd(illegalType, state_before, is_safepoint)
2121   , _x(x)
2122   , _cond(cond)
2123   , _y(y)
2124   , _profiled_method(NULL)
2125   , _profiled_bci(0)
2126   , _swapped(false)
<span class="line-added">2127   , _substitutability_check(substitutability_check)</span>
2128   {
2129     ASSERT_VALUES
2130     set_flag(UnorderedIsTrueFlag, unordered_is_true);
2131     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
2132     BlockList* s = new BlockList(2);
2133     s-&gt;append(tsux);
2134     s-&gt;append(fsux);
2135     set_sux(s);
2136   }
2137 
2138   // accessors
2139   Value x() const                                { return _x; }
2140   Condition cond() const                         { return _cond; }
2141   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2142   Value y() const                                { return _y; }
2143   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2144   BlockBegin* tsux() const                       { return sux_for(true); }
2145   BlockBegin* fsux() const                       { return sux_for(false); }
2146   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2147   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
</pre>
<hr />
<pre>
2150   bool is_swapped() const                        { return _swapped; }
2151 
2152   // manipulation
2153   void swap_operands() {
2154     Value t = _x; _x = _y; _y = t;
2155     _cond = mirror(_cond);
2156   }
2157 
2158   void swap_sux() {
2159     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2160     BlockList* s = sux();
2161     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2162     _cond = negate(_cond);
2163     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2164   }
2165 
2166   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2167   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2168   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2169   void set_swapped(bool value)                    { _swapped = value;         }
<span class="line-added">2170   bool substitutability_check() const              { return _substitutability_check; }</span>
2171   // generic
2172   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2173 };
2174 
2175 
2176 LEAF(IfInstanceOf, BlockEnd)
2177  private:
2178   ciKlass* _klass;
2179   Value    _obj;
2180   bool     _test_is_instance;                    // jump if instance
2181   int      _instanceof_bci;
2182 
2183  public:
2184   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2185   : BlockEnd(illegalType, NULL, false) // temporary set to false
2186   , _klass(klass)
2187   , _obj(obj)
2188   , _test_is_instance(test_is_instance)
2189   , _instanceof_bci(instanceof_bci)
2190   {
</pre>
</td>
</tr>
</table>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_ValueMap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
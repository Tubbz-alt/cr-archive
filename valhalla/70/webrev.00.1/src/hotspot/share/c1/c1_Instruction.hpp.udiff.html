<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_GraphBuilder.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_ValueMap.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Instruction.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -70,14 +70,17 @@</span>
  class   OsrEntry;
  class   ExceptionObject;
  class   StateSplit;
  class     Invoke;
  class     NewInstance;
<span class="udiff-line-added">+ class     NewValueTypeInstance;</span>
  class     NewArray;
  class       NewTypeArray;
  class       NewObjectArray;
  class       NewMultiArray;
<span class="udiff-line-added">+ class     WithField;</span>
<span class="udiff-line-added">+ class     DefaultValue;</span>
  class     TypeCheck;
  class       CheckCast;
  class       InstanceOf;
  class     AccessMonitor;
  class       MonitorEnter;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -175,13 +178,16 @@</span>
    virtual void do_Convert        (Convert*         x) = 0;
    virtual void do_NullCheck      (NullCheck*       x) = 0;
    virtual void do_TypeCast       (TypeCast*        x) = 0;
    virtual void do_Invoke         (Invoke*          x) = 0;
    virtual void do_NewInstance    (NewInstance*     x) = 0;
<span class="udiff-line-added">+   virtual void do_NewValueTypeInstance(NewValueTypeInstance* x) = 0;</span>
    virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
    virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
    virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
<span class="udiff-line-added">+   virtual void do_WithField      (WithField*       x) = 0;</span>
<span class="udiff-line-added">+   virtual void do_DefaultValue   (DefaultValue*    x) = 0;</span>
    virtual void do_CheckCast      (CheckCast*       x) = 0;
    virtual void do_InstanceOf     (InstanceOf*      x) = 0;
    virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
    virtual void do_MonitorExit    (MonitorExit*     x) = 0;
    virtual void do_Intrinsic      (Intrinsic*       x) = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -218,13 +224,14 @@</span>
  //
  // Note: This hash functions affect the performance
  //       of ValueMap - make changes carefully!
  
  #define HASH1(x1            )                    ((intx)(x1))
<span class="udiff-line-modified-removed">- #define HASH2(x1, x2        )                    ((HASH1(x1        ) &lt;&lt; 7) ^ HASH1(x2))</span>
<span class="udiff-line-modified-removed">- #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2    ) &lt;&lt; 7) ^ HASH1(x3))</span>
<span class="udiff-line-modified-removed">- #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3) &lt;&lt; 7) ^ HASH1(x4))</span>
<span class="udiff-line-modified-added">+ #define HASH2(x1, x2        )                    ((HASH1(x1            ) &lt;&lt; 7) ^ HASH1(x2))</span>
<span class="udiff-line-modified-added">+ #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2        ) &lt;&lt; 7) ^ HASH1(x3))</span>
<span class="udiff-line-modified-added">+ #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3    ) &lt;&lt; 7) ^ HASH1(x4))</span>
<span class="udiff-line-added">+ #define HASH5(x1, x2, x3, x4, x5)                ((HASH4(x1, x2, x3, x4) &lt;&lt; 7) ^ HASH1(x5))</span>
  
  
  // The following macros are used to implement instruction-specific hashing.
  // By default, each instruction implements hash() and is_equal(Value), used
  // for value numbering/common subexpression elimination. The default imple-
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -279,10 +286,25 @@</span>
      if (f2 != _v-&gt;f2) return false;                   \
      if (f3 != _v-&gt;f3) return false;                   \
      return true;                                      \
    }                                                   \
  
<span class="udiff-line-added">+ #define HASHING4(class_name, enabled, f1, f2, f3, f4) \</span>
<span class="udiff-line-added">+   virtual intx hash() const {                         \</span>
<span class="udiff-line-added">+     return (enabled) ? HASH5(name(), f1, f2, f3, f4) : 0; \</span>
<span class="udiff-line-added">+   }                                                   \</span>
<span class="udiff-line-added">+   virtual bool is_equal(Value v) const {              \</span>
<span class="udiff-line-added">+     if (!(enabled)  ) return false;                   \</span>
<span class="udiff-line-added">+     class_name* _v = v-&gt;as_##class_name();            \</span>
<span class="udiff-line-added">+     if (_v == NULL  ) return false;                   \</span>
<span class="udiff-line-added">+     if (f1 != _v-&gt;f1) return false;                   \</span>
<span class="udiff-line-added">+     if (f2 != _v-&gt;f2) return false;                   \</span>
<span class="udiff-line-added">+     if (f3 != _v-&gt;f3) return false;                   \</span>
<span class="udiff-line-added">+     if (f4 != _v-&gt;f4) return false;                   \</span>
<span class="udiff-line-added">+     return true;                                      \</span>
<span class="udiff-line-added">+   }                                                   \</span>
<span class="udiff-line-added">+ </span>
  
  // The mother of all instructions...
  
  class Instruction: public CompilationResourceObj {
   private:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -353,10 +375,11 @@</span>
  
    static const int no_bci = -99;
  
    enum InstructionFlag {
      NeedsNullCheckFlag = 0,
<span class="udiff-line-added">+     NeverNullFlag,          // For &quot;Q&quot; signatures</span>
      CanTrapFlag,
      DirectCompareFlag,
      IsEliminatedFlag,
      IsSafepointFlag,
      IsStaticFlag,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -447,20 +470,29 @@</span>
    Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
    LIR_Opr operand() const                        { return _operand; }
  
    void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
    bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
<span class="udiff-line-added">+   void set_never_null(bool f)                    { set_flag(NeverNullFlag, f); }</span>
<span class="udiff-line-added">+   bool is_never_null() const                     { return check_flag(NeverNullFlag); }</span>
    bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
    bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
  
    bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
  
    bool has_uses() const                          { return use_count() &gt; 0; }
    ValueStack* state_before() const               { return _state_before; }
    ValueStack* exception_state() const            { return _exception_state; }
    virtual bool needs_exception_state() const     { return true; }
    XHandlers* exception_handlers() const          { return _exception_handlers; }
<span class="udiff-line-added">+   ciKlass* as_loaded_klass_or_null() const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // withfield optimization</span>
<span class="udiff-line-added">+   virtual void set_escaped()                     { }</span>
<span class="udiff-line-added">+   virtual void set_local_index(int index)        { }</span>
<span class="udiff-line-added">+   virtual bool is_optimizable_for_withfield() const { return false; }</span>
<span class="udiff-line-added">+ </span>
  
    // manipulation
    void pin(PinReason reason)                     { _pin_state |= reason; }
    void pin()                                     { _pin_state |= PinUnknown; }
    // DANGEROUS: only used by EliminateStores
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -501,10 +533,14 @@</span>
      set_next(i);
      i-&gt;set_next(n);
      return _next;
    }
  
<span class="udiff-line-added">+   bool is_loaded_flattened_array() const;</span>
<span class="udiff-line-added">+   bool maybe_flattened_array();</span>
<span class="udiff-line-added">+   bool maybe_null_free_array();</span>
<span class="udiff-line-added">+ </span>
    Instruction *insert_after_same_bci(Instruction *i) {
  #ifndef PRODUCT
      i-&gt;set_printable_bci(printable_bci());
  #endif
      return insert_after(i);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -548,14 +584,17 @@</span>
    virtual NullCheck*        as_NullCheck()       { return NULL; }
    virtual OsrEntry*         as_OsrEntry()        { return NULL; }
    virtual StateSplit*       as_StateSplit()      { return NULL; }
    virtual Invoke*           as_Invoke()          { return NULL; }
    virtual NewInstance*      as_NewInstance()     { return NULL; }
<span class="udiff-line-added">+   virtual NewValueTypeInstance* as_NewValueTypeInstance() { return NULL; }</span>
    virtual NewArray*         as_NewArray()        { return NULL; }
    virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
    virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
    virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
<span class="udiff-line-added">+   virtual WithField*        as_WithField()       { return NULL; }</span>
<span class="udiff-line-added">+   virtual DefaultValue*     as_DefaultValue()    { return NULL; }</span>
    virtual TypeCheck*        as_TypeCheck()       { return NULL; }
    virtual CheckCast*        as_CheckCast()       { return NULL; }
    virtual InstanceOf*       as_InstanceOf()      { return NULL; }
    virtual TypeCast*         as_TypeCast()        { return NULL; }
    virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -701,16 +740,17 @@</span>
    int      _java_index;                          // the local index within the method to which the local belongs
    bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
    ciType*  _declared_type;
   public:
    // creation
<span class="udiff-line-modified-removed">-   Local(ciType* declared, ValueType* type, int index, bool receiver)</span>
<span class="udiff-line-modified-added">+   Local(ciType* declared, ValueType* type, int index, bool receiver, bool never_null)</span>
      : Instruction(type)
      , _java_index(index)
      , _is_receiver(receiver)
      , _declared_type(declared)
    {
<span class="udiff-line-added">+     set_never_null(never_null);</span>
      NOT_PRODUCT(set_printable_bci(-1));
    }
  
    // accessors
    int java_index() const                         { return _java_index; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -826,11 +866,12 @@</span>
  
  LEAF(LoadField, AccessField)
   public:
    // creation
    LoadField(Value obj, int offset, ciField* field, bool is_static,
<span class="udiff-line-modified-removed">-             ValueStack* state_before, bool needs_patching)</span>
<span class="udiff-line-modified-added">+             ValueStack* state_before, bool needs_patching,</span>
<span class="udiff-line-added">+             ciValueKlass* value_klass = NULL, Value default_value = NULL )</span>
    : AccessField(obj, offset, field, is_static, state_before, needs_patching)
    {}
  
    ciType* declared_type() const;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -913,19 +954,22 @@</span>
   private:
    Value     _index;
    Value     _length;
    BasicType _elt_type;
    bool      _mismatched;
<span class="udiff-line-added">+   ciMethod* _profiled_method;</span>
<span class="udiff-line-added">+   int       _profiled_bci;</span>
  
   public:
    // creation
    AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
    : AccessArray(as_ValueType(elt_type), array, state_before)
    , _index(index)
    , _length(length)
    , _elt_type(elt_type)
    , _mismatched(mismatched)
<span class="udiff-line-added">+   , _profiled_method(NULL), _profiled_bci(0)</span>
    {
      set_flag(Instruction::NeedsRangeCheckFlag, true);
      ASSERT_VALUES
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -937,24 +981,34 @@</span>
  
    void clear_length()                            { _length = NULL; }
    // perform elimination of range checks involving constants
    bool compute_needs_range_check();
  
<span class="udiff-line-modified-removed">-   // generic</span>
<span class="udiff-line-modified-added">+   // Helpers for MethodData* profiling</span>
<span class="udiff-line-added">+   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }</span>
<span class="udiff-line-added">+   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }</span>
<span class="udiff-line-added">+   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }</span>
<span class="udiff-line-added">+   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }</span>
<span class="udiff-line-added">+   ciMethod* profiled_method() const                  { return _profiled_method;     }</span>
<span class="udiff-line-added">+   int       profiled_bci() const                     { return _profiled_bci;        }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // generic</span>
    virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
  };
  
  
  LEAF(LoadIndexed, AccessIndexed)
   private:
    NullCheck*  _explicit_null_check;              // For explicit null check elimination
<span class="udiff-line-added">+   NewValueTypeInstance* _vt;</span>
  
   public:
    // creation
    LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
    : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
<span class="udiff-line-modified-removed">-   , _explicit_null_check(NULL) {}</span>
<span class="udiff-line-modified-added">+   , _explicit_null_check(NULL), _vt(NULL) {}</span>
  
    // accessors
    NullCheck* explicit_null_check() const         { return _explicit_null_check; }
  
    // setters
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -962,29 +1016,30 @@</span>
    void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
  
    ciType* exact_type() const;
    ciType* declared_type() const;
  
<span class="udiff-line-modified-removed">-   // generic;</span>
<span class="udiff-line-modified-removed">-   HASHING3(LoadIndexed, true, type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst())</span>
<span class="udiff-line-modified-added">+   NewValueTypeInstance* vt() const { return _vt; }</span>
<span class="udiff-line-modified-added">+   void set_vt(NewValueTypeInstance* vt) { _vt = vt; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // generic</span>
<span class="udiff-line-added">+   HASHING4(LoadIndexed, !should_profile(), type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst(), vt())</span>
  };
  
  
  LEAF(StoreIndexed, AccessIndexed)
   private:
    Value       _value;
  
<span class="udiff-line-removed">-   ciMethod* _profiled_method;</span>
<span class="udiff-line-removed">-   int       _profiled_bci;</span>
    bool      _check_boolean;
  
   public:
    // creation
    StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
                 bool check_boolean, bool mismatched = false)
    : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
<span class="udiff-line-modified-removed">-   , _value(value), _profiled_method(NULL), _profiled_bci(0), _check_boolean(check_boolean)</span>
<span class="udiff-line-modified-added">+   , _value(value), _check_boolean(check_boolean)</span>
    {
      set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
      set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));
      ASSERT_VALUES
      pin();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -993,17 +1048,13 @@</span>
    // accessors
    Value value() const                            { return _value; }
    bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
    bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
    bool check_boolean() const                     { return _check_boolean; }
<span class="udiff-line-modified-removed">-   // Helpers for MethodData* profiling</span>
<span class="udiff-line-modified-removed">-   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }</span>
<span class="udiff-line-modified-removed">-   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }</span>
<span class="udiff-line-removed">-   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }</span>
<span class="udiff-line-removed">-   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }</span>
<span class="udiff-line-removed">-   ciMethod* profiled_method() const                  { return _profiled_method;     }</span>
<span class="udiff-line-removed">-   int       profiled_bci() const                     { return _profiled_bci;        }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Flattened array support</span>
<span class="udiff-line-modified-added">+   bool is_exact_flattened_array_store() const;</span>
    // generic
    virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
  };
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1114,29 +1165,32 @@</span>
  
  LEAF(IfOp, Op2)
   private:
    Value _tval;
    Value _fval;
<span class="udiff-line-added">+   bool _substitutability_check;</span>
  
   public:
    // creation
<span class="udiff-line-modified-removed">-   IfOp(Value x, Condition cond, Value y, Value tval, Value fval)</span>
<span class="udiff-line-modified-added">+   IfOp(Value x, Condition cond, Value y, Value tval, Value fval, ValueStack* state_before, bool substitutability_check)</span>
    : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
    , _tval(tval)
    , _fval(fval)
<span class="udiff-line-added">+   , _substitutability_check(substitutability_check)</span>
    {
      ASSERT_VALUES
      assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
<span class="udiff-line-added">+     set_state_before(state_before);</span>
    }
  
    // accessors
    virtual bool is_commutative() const;
    Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
    Condition cond() const                         { return (Condition)Op2::op(); }
    Value tval() const                             { return _tval; }
    Value fval() const                             { return _fval; }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+   bool substitutability_check() const             { return _substitutability_check; }</span>
    // generic
    virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
  };
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1252,11 +1306,11 @@</span>
    ciMethod*       _target;
  
   public:
    // creation
    Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
<span class="udiff-line-modified-removed">-          int vtable_index, ciMethod* target, ValueStack* state_before);</span>
<span class="udiff-line-modified-added">+          int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null);</span>
  
    // accessors
    Bytecodes::Code code() const                   { return _code; }
    Value receiver() const                         { return _recv; }
    bool has_receiver() const                      { return receiver() != NULL; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1313,10 +1367,65 @@</span>
    virtual bool can_trap() const                  { return true; }
    ciType* exact_type() const;
    ciType* declared_type() const;
  };
  
<span class="udiff-line-added">+ LEAF(NewValueTypeInstance, StateSplit)</span>
<span class="udiff-line-added">+   bool _is_unresolved;</span>
<span class="udiff-line-added">+   ciValueKlass* _klass;</span>
<span class="udiff-line-added">+   Value _depends_on;      // Link to instance on with withfield was called on</span>
<span class="udiff-line-added">+   bool _is_optimizable_for_withfield;</span>
<span class="udiff-line-added">+   int _first_local_index;</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Default creation, always allocated for now</span>
<span class="udiff-line-added">+   NewValueTypeInstance(ciValueKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)</span>
<span class="udiff-line-added">+   : StateSplit(instanceType, state_before)</span>
<span class="udiff-line-added">+    , _is_unresolved(is_unresolved)</span>
<span class="udiff-line-added">+    , _klass(klass)</span>
<span class="udiff-line-added">+    , _is_optimizable_for_withfield(from_default_value)</span>
<span class="udiff-line-added">+    , _first_local_index(-1)</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     if (depends_on == NULL) {</span>
<span class="udiff-line-added">+       _depends_on = this;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       _depends_on = depends_on;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     set_never_null(true);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // accessors</span>
<span class="udiff-line-added">+   bool is_unresolved() const                     { return _is_unresolved; }</span>
<span class="udiff-line-added">+   Value depends_on();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ciValueKlass* klass() const { return _klass; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   virtual bool needs_exception_state() const     { return false; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // generic</span>
<span class="udiff-line-added">+   virtual bool can_trap() const                  { return true; }</span>
<span class="udiff-line-added">+   ciType* exact_type() const;</span>
<span class="udiff-line-added">+   ciType* declared_type() const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Only done in LIR Generator -&gt; map everything to object</span>
<span class="udiff-line-added">+   void set_to_object_type() { set_type(instanceType); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // withfield optimization</span>
<span class="udiff-line-added">+   virtual void set_escaped() {</span>
<span class="udiff-line-added">+     _is_optimizable_for_withfield = false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   virtual void set_local_index(int index) {</span>
<span class="udiff-line-added">+     if (_first_local_index != index) {</span>
<span class="udiff-line-added">+       if (_first_local_index == -1) {</span>
<span class="udiff-line-added">+         _first_local_index = index;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         _is_optimizable_for_withfield = false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   virtual bool is_optimizable_for_withfield() const {  return _is_optimizable_for_withfield; }</span>
<span class="udiff-line-added">+ };</span>
  
  BASE(NewArray, StateSplit)
   private:
    Value       _length;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1364,11 +1473,14 @@</span>
   private:
    ciKlass* _klass;
  
   public:
    // creation
<span class="udiff-line-modified-removed">-   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before) : NewArray(length, state_before), _klass(klass) {}</span>
<span class="udiff-line-modified-added">+   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool never_null)</span>
<span class="udiff-line-added">+   : NewArray(length, state_before), _klass(klass) {</span>
<span class="udiff-line-added">+     set_never_null(never_null);</span>
<span class="udiff-line-added">+   }</span>
  
    // accessors
    ciKlass* klass() const                         { return _klass; }
    ciType* exact_type() const;
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1399,12 +1511,27 @@</span>
      // get updated, and the value must not be traversed twice. Was bug
      // - kbr 4/10/2001
      StateSplit::input_values_do(f);
      for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ciType* exact_type() const;</span>
  };
  
<span class="udiff-line-added">+ LEAF(WithField, StateSplit)</span>
<span class="udiff-line-added">+  public:</span>
<span class="udiff-line-added">+   // creation</span>
<span class="udiff-line-added">+   WithField(ValueStack* state_before)</span>
<span class="udiff-line-added">+   : StateSplit(objectType, state_before) {}</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ LEAF(DefaultValue, StateSplit)</span>
<span class="udiff-line-added">+  public:</span>
<span class="udiff-line-added">+   // creation</span>
<span class="udiff-line-added">+   DefaultValue(ValueStack* state_before)</span>
<span class="udiff-line-added">+   : StateSplit(objectType, state_before) {}</span>
<span class="udiff-line-added">+ };</span>
  
  BASE(TypeCheck, StateSplit)
   private:
    ciKlass*    _klass;
    Value       _obj;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1445,12 +1572,14 @@</span>
  
  
  LEAF(CheckCast, TypeCheck)
   public:
    // creation
<span class="udiff-line-modified-removed">-   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before)</span>
<span class="udiff-line-modified-removed">-   : TypeCheck(klass, obj, objectType, state_before) {}</span>
<span class="udiff-line-modified-added">+   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool never_null = false)</span>
<span class="udiff-line-modified-added">+   : TypeCheck(klass, obj, objectType, state_before) {</span>
<span class="udiff-line-added">+     set_never_null(never_null);</span>
<span class="udiff-line-added">+   }</span>
  
    void set_incompatible_class_change_check() {
      set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
    }
    bool is_incompatible_class_change_check() const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1504,18 +1633,23 @@</span>
    virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
  };
  
  
  LEAF(MonitorEnter, AccessMonitor)
<span class="udiff-line-added">+   bool _maybe_valuetype;</span>
   public:
    // creation
<span class="udiff-line-modified-removed">-   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before)</span>
<span class="udiff-line-modified-added">+   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before, bool maybe_valuetype)</span>
    : AccessMonitor(obj, monitor_no, state_before)
<span class="udiff-line-added">+   , _maybe_valuetype(maybe_valuetype)</span>
    {
      ASSERT_VALUES
    }
  
<span class="udiff-line-added">+   // accessors</span>
<span class="udiff-line-added">+   bool maybe_valuetype() const                   { return _maybe_valuetype; }</span>
<span class="udiff-line-added">+ </span>
    // generic
    virtual bool can_trap() const                  { return true; }
  };
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1976,21 +2110,23 @@</span>
    Value       _y;
    ciMethod*   _profiled_method;
    int         _profiled_bci; // Canonicalizer may alter bci of If node
    bool        _swapped;      // Is the order reversed with respect to the original If in the
                               // bytecode stream?
<span class="udiff-line-added">+   bool        _substitutability_check;</span>
   public:
    // creation
    // unordered_is_true is valid for float/double compares only
<span class="udiff-line-modified-removed">-   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint)</span>
<span class="udiff-line-modified-added">+   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint, bool substitutability_check=false)</span>
      : BlockEnd(illegalType, state_before, is_safepoint)
    , _x(x)
    , _cond(cond)
    , _y(y)
    , _profiled_method(NULL)
    , _profiled_bci(0)
    , _swapped(false)
<span class="udiff-line-added">+   , _substitutability_check(substitutability_check)</span>
    {
      ASSERT_VALUES
      set_flag(UnorderedIsTrueFlag, unordered_is_true);
      assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
      BlockList* s = new BlockList(2);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2029,10 +2165,11 @@</span>
  
    void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
    void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
    void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
    void set_swapped(bool value)                    { _swapped = value;         }
<span class="udiff-line-added">+   bool substitutability_check() const              { return _substitutability_check; }</span>
    // generic
    virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
  };
  
  
</pre>
<center><a href="c1_GraphBuilder.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_ValueMap.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
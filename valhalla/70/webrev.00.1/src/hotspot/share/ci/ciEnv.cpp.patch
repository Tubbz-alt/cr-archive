diff a/src/hotspot/share/ci/ciEnv.cpp b/src/hotspot/share/ci/ciEnv.cpp
--- a/src/hotspot/share/ci/ciEnv.cpp
+++ b/src/hotspot/share/ci/ciEnv.cpp
@@ -31,10 +31,11 @@
 #include "ci/ciInstanceKlass.hpp"
 #include "ci/ciMethod.hpp"
 #include "ci/ciNullObject.hpp"
 #include "ci/ciReplay.hpp"
 #include "ci/ciUtilities.inline.hpp"
+#include "ci/ciValueKlass.hpp"
 #include "classfile/symbolTable.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "code/codeCache.hpp"
 #include "code/scopeDesc.hpp"
@@ -464,11 +465,13 @@
   // In either case, if we can find the element type in the system dictionary,
   // we must build an array type around it.  The CI requires array klasses
   // to be loaded if their element klasses are loaded, except when memory
   // is exhausted.
   if (Signature::is_array(sym) &&
-      (sym->char_at(1) == JVM_SIGNATURE_ARRAY || sym->char_at(1) == JVM_SIGNATURE_CLASS)) {
+      (sym->char_at(1) == JVM_SIGNATURE_ARRAY ||
+       sym->char_at(1) == JVM_SIGNATURE_CLASS ||
+       sym->char_at(1) == JVM_SIGNATURE_VALUETYPE )) {
     // We have an unloaded array.
     // Build it on the fly if the element class exists.
     SignatureStream ss(sym, false);
     ss.skip_array_prefix(1);
     // Get element ciKlass recursively.
@@ -477,11 +480,11 @@
                              cpool,
                              get_symbol(ss.as_symbol()),
                              require_local);
     if (elem_klass != NULL && elem_klass->is_loaded()) {
       // Now make an array for it
-      return ciObjArrayKlass::make_impl(elem_klass);
+      return ciArrayKlass::make(elem_klass);
     }
   }
 
   if (found_klass == NULL && !cpool.is_null() && cpool->has_preresolution()) {
     // Look inside the constant pool for pre-resolved class entries.
@@ -503,10 +506,25 @@
 
   if (require_local)  return NULL;
 
   // Not yet loaded into the VM, or not governed by loader constraints.
   // Make a CI representative for it.
+  int i = 0;
+  while (sym->char_at(i) == JVM_SIGNATURE_ARRAY) {
+    i++;
+  }
+  if (i > 0 && sym->char_at(i) == JVM_SIGNATURE_VALUETYPE) {
+    // An unloaded array class of value types is an ObjArrayKlass, an
+    // unloaded value type class is an InstanceKlass. For consistency,
+    // make the signature of the unloaded array of value type use L
+    // rather than Q.
+    char *new_name = CURRENT_THREAD_ENV->name_buffer(sym->utf8_length()+1);
+    strncpy(new_name, (char*)sym->base(), sym->utf8_length());
+    new_name[i] = JVM_SIGNATURE_CLASS;
+    new_name[sym->utf8_length()] = '\0';
+    return get_unloaded_klass(accessing_klass, ciSymbol::make(new_name));
+  }
   return get_unloaded_klass(accessing_klass, name);
 }
 
 // ------------------------------------------------------------------
 // ciEnv::get_klass_by_name
@@ -533,11 +551,11 @@
 
   if (cpool->tag_at(index).is_symbol()) {
     klass_name = cpool->symbol_at(index);
   } else {
     // Check if it's resolved if it's not a symbol constant pool entry.
-    klass =  ConstantPool::klass_at_if_loaded(cpool, index);
+    klass = ConstantPool::klass_at_if_loaded(cpool, index);
     // Try to look it up by name.
     if (klass == NULL) {
       klass_name = cpool->klass_name_at(index);
     }
   }
@@ -585,10 +603,18 @@
                                    bool& is_accessible,
                                    ciInstanceKlass* accessor) {
   GUARDED_VM_ENTRY(return get_klass_by_index_impl(cpool, index, is_accessible, accessor);)
 }
 
+// ------------------------------------------------------------------
+// ciEnv::is_klass_never_null
+//
+// Get information about nullability from the constant pool.
+bool ciEnv::is_klass_never_null(const constantPoolHandle& cpool, int index) {
+  GUARDED_VM_ENTRY(return cpool->klass_name_at(index)->is_Q_signature();)
+}
+
 // ------------------------------------------------------------------
 // ciEnv::get_constant_by_index_impl
 //
 // Implementation of get_constant_by_index().
 ciConstant ciEnv::get_constant_by_index_impl(const constantPoolHandle& cpool,

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../c1/c1_ValueMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/bytecodeAssembler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciEnv.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;ci/ciConstant.hpp&quot;
  28 #include &quot;ci/ciEnv.hpp&quot;
  29 #include &quot;ci/ciField.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;
  31 #include &quot;ci/ciInstanceKlass.hpp&quot;
  32 #include &quot;ci/ciMethod.hpp&quot;
  33 #include &quot;ci/ciNullObject.hpp&quot;
  34 #include &quot;ci/ciReplay.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;

  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;code/codeCache.hpp&quot;
  40 #include &quot;code/scopeDesc.hpp&quot;
  41 #include &quot;compiler/compileBroker.hpp&quot;
  42 #include &quot;compiler/compilerEvent.hpp&quot;
  43 #include &quot;compiler/compileLog.hpp&quot;
  44 #include &quot;compiler/disassembler.hpp&quot;
  45 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  46 #include &quot;interpreter/linkResolver.hpp&quot;
  47 #include &quot;jfr/jfrEvents.hpp&quot;
  48 #include &quot;logging/log.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/oopFactory.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/constantPool.inline.hpp&quot;
  54 #include &quot;oops/cpCache.inline.hpp&quot;
  55 #include &quot;oops/method.inline.hpp&quot;
</pre>
<hr />
<pre>
 449     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems
 450     MutexLocker ml(Compile_lock);
 451     Klass* kls;
 452     if (!require_local) {
 453       kls = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader,
 454                                                                        KILL_COMPILE_ON_FATAL_(fail_type));
 455     } else {
 456       kls = SystemDictionary::find_instance_or_array_klass(sym, loader, domain,
 457                                                            KILL_COMPILE_ON_FATAL_(fail_type));
 458     }
 459     found_klass = kls;
 460   }
 461 
 462   // If we fail to find an array klass, look again for its element type.
 463   // The element type may be available either locally or via constraints.
 464   // In either case, if we can find the element type in the system dictionary,
 465   // we must build an array type around it.  The CI requires array klasses
 466   // to be loaded if their element klasses are loaded, except when memory
 467   // is exhausted.
 468   if (Signature::is_array(sym) &amp;&amp;
<span class="line-modified"> 469       (sym-&gt;char_at(1) == JVM_SIGNATURE_ARRAY || sym-&gt;char_at(1) == JVM_SIGNATURE_CLASS)) {</span>


 470     // We have an unloaded array.
 471     // Build it on the fly if the element class exists.
 472     SignatureStream ss(sym, false);
 473     ss.skip_array_prefix(1);
 474     // Get element ciKlass recursively.
 475     ciKlass* elem_klass =
 476       get_klass_by_name_impl(accessing_klass,
 477                              cpool,
 478                              get_symbol(ss.as_symbol()),
 479                              require_local);
 480     if (elem_klass != NULL &amp;&amp; elem_klass-&gt;is_loaded()) {
 481       // Now make an array for it
<span class="line-modified"> 482       return ciObjArrayKlass::make_impl(elem_klass);</span>
 483     }
 484   }
 485 
 486   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {
 487     // Look inside the constant pool for pre-resolved class entries.
 488     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {
 489       if (cpool-&gt;tag_at(i).is_klass()) {
 490         Klass* kls = cpool-&gt;resolved_klass_at(i);
 491         if (kls-&gt;name() == sym) {
 492           found_klass = kls;
 493           break;
 494         }
 495       }
 496     }
 497   }
 498 
 499   if (found_klass != NULL) {
 500     // Found it.  Build a CI handle.
 501     return get_klass(found_klass);
 502   }
 503 
 504   if (require_local)  return NULL;
 505 
 506   // Not yet loaded into the VM, or not governed by loader constraints.
 507   // Make a CI representative for it.















 508   return get_unloaded_klass(accessing_klass, name);
 509 }
 510 
 511 // ------------------------------------------------------------------
 512 // ciEnv::get_klass_by_name
 513 ciKlass* ciEnv::get_klass_by_name(ciKlass* accessing_klass,
 514                                   ciSymbol* klass_name,
 515                                   bool require_local) {
 516   GUARDED_VM_ENTRY(return get_klass_by_name_impl(accessing_klass,
 517                                                  constantPoolHandle(),
 518                                                  klass_name,
 519                                                  require_local);)
 520 }
 521 
 522 // ------------------------------------------------------------------
 523 // ciEnv::get_klass_by_index_impl
 524 //
 525 // Implementation of get_klass_by_index.
 526 ciKlass* ciEnv::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
 527                                         int index,
 528                                         bool&amp; is_accessible,
 529                                         ciInstanceKlass* accessor) {
 530   EXCEPTION_CONTEXT;
 531   Klass* klass = NULL;
 532   Symbol* klass_name = NULL;
 533 
 534   if (cpool-&gt;tag_at(index).is_symbol()) {
 535     klass_name = cpool-&gt;symbol_at(index);
 536   } else {
 537     // Check if it&#39;s resolved if it&#39;s not a symbol constant pool entry.
<span class="line-modified"> 538     klass =  ConstantPool::klass_at_if_loaded(cpool, index);</span>
 539     // Try to look it up by name.
 540     if (klass == NULL) {
 541       klass_name = cpool-&gt;klass_name_at(index);
 542     }
 543   }
 544 
 545   if (klass == NULL) {
 546     // Not found in constant pool.  Use the name to do the lookup.
 547     ciKlass* k = get_klass_by_name_impl(accessor,
 548                                         cpool,
 549                                         get_symbol(klass_name),
 550                                         false);
 551     // Calculate accessibility the hard way.
 552     if (!k-&gt;is_loaded()) {
 553       is_accessible = false;
 554     } else if (k-&gt;loader() != accessor-&gt;loader() &amp;&amp;
 555                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {
 556       // Loaded only remotely.  Not linked yet.
 557       is_accessible = false;
 558     } else {
</pre>
<hr />
<pre>
 570     is_accessible = false;
 571     return unloaded_klass;
 572   }
 573 
 574   // It is known to be accessible, since it was found in the constant pool.
 575   is_accessible = true;
 576   return get_klass(klass);
 577 }
 578 
 579 // ------------------------------------------------------------------
 580 // ciEnv::get_klass_by_index
 581 //
 582 // Get a klass from the constant pool.
 583 ciKlass* ciEnv::get_klass_by_index(const constantPoolHandle&amp; cpool,
 584                                    int index,
 585                                    bool&amp; is_accessible,
 586                                    ciInstanceKlass* accessor) {
 587   GUARDED_VM_ENTRY(return get_klass_by_index_impl(cpool, index, is_accessible, accessor);)
 588 }
 589 








 590 // ------------------------------------------------------------------
 591 // ciEnv::get_constant_by_index_impl
 592 //
 593 // Implementation of get_constant_by_index().
 594 ciConstant ciEnv::get_constant_by_index_impl(const constantPoolHandle&amp; cpool,
 595                                              int pool_index, int cache_index,
 596                                              ciInstanceKlass* accessor) {
 597   bool ignore_will_link;
 598   EXCEPTION_CONTEXT;
 599   int index = pool_index;
 600   if (cache_index &gt;= 0) {
 601     assert(index &lt; 0, &quot;only one kind of index at a time&quot;);
 602     index = cpool-&gt;object_to_cp_index(cache_index);
 603     oop obj = cpool-&gt;resolved_references()-&gt;obj_at(cache_index);
 604     if (obj != NULL) {
 605       if (obj == Universe::the_null_sentinel()) {
 606         return ciConstant(T_OBJECT, get_object(NULL));
 607       }
 608       BasicType bt = T_OBJECT;
 609       if (cpool-&gt;tag_at(index).is_dynamic_constant())
</pre>
</td>
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;ci/ciConstant.hpp&quot;
  28 #include &quot;ci/ciEnv.hpp&quot;
  29 #include &quot;ci/ciField.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;
  31 #include &quot;ci/ciInstanceKlass.hpp&quot;
  32 #include &quot;ci/ciMethod.hpp&quot;
  33 #include &quot;ci/ciNullObject.hpp&quot;
  34 #include &quot;ci/ciReplay.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="line-added">  36 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;code/codeCache.hpp&quot;
  41 #include &quot;code/scopeDesc.hpp&quot;
  42 #include &quot;compiler/compileBroker.hpp&quot;
  43 #include &quot;compiler/compilerEvent.hpp&quot;
  44 #include &quot;compiler/compileLog.hpp&quot;
  45 #include &quot;compiler/disassembler.hpp&quot;
  46 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  47 #include &quot;interpreter/linkResolver.hpp&quot;
  48 #include &quot;jfr/jfrEvents.hpp&quot;
  49 #include &quot;logging/log.hpp&quot;
  50 #include &quot;memory/allocation.inline.hpp&quot;
  51 #include &quot;memory/oopFactory.hpp&quot;
  52 #include &quot;memory/resourceArea.hpp&quot;
  53 #include &quot;memory/universe.hpp&quot;
  54 #include &quot;oops/constantPool.inline.hpp&quot;
  55 #include &quot;oops/cpCache.inline.hpp&quot;
  56 #include &quot;oops/method.inline.hpp&quot;
</pre>
<hr />
<pre>
 450     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems
 451     MutexLocker ml(Compile_lock);
 452     Klass* kls;
 453     if (!require_local) {
 454       kls = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader,
 455                                                                        KILL_COMPILE_ON_FATAL_(fail_type));
 456     } else {
 457       kls = SystemDictionary::find_instance_or_array_klass(sym, loader, domain,
 458                                                            KILL_COMPILE_ON_FATAL_(fail_type));
 459     }
 460     found_klass = kls;
 461   }
 462 
 463   // If we fail to find an array klass, look again for its element type.
 464   // The element type may be available either locally or via constraints.
 465   // In either case, if we can find the element type in the system dictionary,
 466   // we must build an array type around it.  The CI requires array klasses
 467   // to be loaded if their element klasses are loaded, except when memory
 468   // is exhausted.
 469   if (Signature::is_array(sym) &amp;&amp;
<span class="line-modified"> 470       (sym-&gt;char_at(1) == JVM_SIGNATURE_ARRAY ||</span>
<span class="line-added"> 471        sym-&gt;char_at(1) == JVM_SIGNATURE_CLASS ||</span>
<span class="line-added"> 472        sym-&gt;char_at(1) == JVM_SIGNATURE_VALUETYPE )) {</span>
 473     // We have an unloaded array.
 474     // Build it on the fly if the element class exists.
 475     SignatureStream ss(sym, false);
 476     ss.skip_array_prefix(1);
 477     // Get element ciKlass recursively.
 478     ciKlass* elem_klass =
 479       get_klass_by_name_impl(accessing_klass,
 480                              cpool,
 481                              get_symbol(ss.as_symbol()),
 482                              require_local);
 483     if (elem_klass != NULL &amp;&amp; elem_klass-&gt;is_loaded()) {
 484       // Now make an array for it
<span class="line-modified"> 485       return ciArrayKlass::make(elem_klass);</span>
 486     }
 487   }
 488 
 489   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {
 490     // Look inside the constant pool for pre-resolved class entries.
 491     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {
 492       if (cpool-&gt;tag_at(i).is_klass()) {
 493         Klass* kls = cpool-&gt;resolved_klass_at(i);
 494         if (kls-&gt;name() == sym) {
 495           found_klass = kls;
 496           break;
 497         }
 498       }
 499     }
 500   }
 501 
 502   if (found_klass != NULL) {
 503     // Found it.  Build a CI handle.
 504     return get_klass(found_klass);
 505   }
 506 
 507   if (require_local)  return NULL;
 508 
 509   // Not yet loaded into the VM, or not governed by loader constraints.
 510   // Make a CI representative for it.
<span class="line-added"> 511   int i = 0;</span>
<span class="line-added"> 512   while (sym-&gt;char_at(i) == JVM_SIGNATURE_ARRAY) {</span>
<span class="line-added"> 513     i++;</span>
<span class="line-added"> 514   }</span>
<span class="line-added"> 515   if (i &gt; 0 &amp;&amp; sym-&gt;char_at(i) == JVM_SIGNATURE_VALUETYPE) {</span>
<span class="line-added"> 516     // An unloaded array class of value types is an ObjArrayKlass, an</span>
<span class="line-added"> 517     // unloaded value type class is an InstanceKlass. For consistency,</span>
<span class="line-added"> 518     // make the signature of the unloaded array of value type use L</span>
<span class="line-added"> 519     // rather than Q.</span>
<span class="line-added"> 520     char *new_name = CURRENT_THREAD_ENV-&gt;name_buffer(sym-&gt;utf8_length()+1);</span>
<span class="line-added"> 521     strncpy(new_name, (char*)sym-&gt;base(), sym-&gt;utf8_length());</span>
<span class="line-added"> 522     new_name[i] = JVM_SIGNATURE_CLASS;</span>
<span class="line-added"> 523     new_name[sym-&gt;utf8_length()] = &#39;\0&#39;;</span>
<span class="line-added"> 524     return get_unloaded_klass(accessing_klass, ciSymbol::make(new_name));</span>
<span class="line-added"> 525   }</span>
 526   return get_unloaded_klass(accessing_klass, name);
 527 }
 528 
 529 // ------------------------------------------------------------------
 530 // ciEnv::get_klass_by_name
 531 ciKlass* ciEnv::get_klass_by_name(ciKlass* accessing_klass,
 532                                   ciSymbol* klass_name,
 533                                   bool require_local) {
 534   GUARDED_VM_ENTRY(return get_klass_by_name_impl(accessing_klass,
 535                                                  constantPoolHandle(),
 536                                                  klass_name,
 537                                                  require_local);)
 538 }
 539 
 540 // ------------------------------------------------------------------
 541 // ciEnv::get_klass_by_index_impl
 542 //
 543 // Implementation of get_klass_by_index.
 544 ciKlass* ciEnv::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
 545                                         int index,
 546                                         bool&amp; is_accessible,
 547                                         ciInstanceKlass* accessor) {
 548   EXCEPTION_CONTEXT;
 549   Klass* klass = NULL;
 550   Symbol* klass_name = NULL;
 551 
 552   if (cpool-&gt;tag_at(index).is_symbol()) {
 553     klass_name = cpool-&gt;symbol_at(index);
 554   } else {
 555     // Check if it&#39;s resolved if it&#39;s not a symbol constant pool entry.
<span class="line-modified"> 556     klass = ConstantPool::klass_at_if_loaded(cpool, index);</span>
 557     // Try to look it up by name.
 558     if (klass == NULL) {
 559       klass_name = cpool-&gt;klass_name_at(index);
 560     }
 561   }
 562 
 563   if (klass == NULL) {
 564     // Not found in constant pool.  Use the name to do the lookup.
 565     ciKlass* k = get_klass_by_name_impl(accessor,
 566                                         cpool,
 567                                         get_symbol(klass_name),
 568                                         false);
 569     // Calculate accessibility the hard way.
 570     if (!k-&gt;is_loaded()) {
 571       is_accessible = false;
 572     } else if (k-&gt;loader() != accessor-&gt;loader() &amp;&amp;
 573                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {
 574       // Loaded only remotely.  Not linked yet.
 575       is_accessible = false;
 576     } else {
</pre>
<hr />
<pre>
 588     is_accessible = false;
 589     return unloaded_klass;
 590   }
 591 
 592   // It is known to be accessible, since it was found in the constant pool.
 593   is_accessible = true;
 594   return get_klass(klass);
 595 }
 596 
 597 // ------------------------------------------------------------------
 598 // ciEnv::get_klass_by_index
 599 //
 600 // Get a klass from the constant pool.
 601 ciKlass* ciEnv::get_klass_by_index(const constantPoolHandle&amp; cpool,
 602                                    int index,
 603                                    bool&amp; is_accessible,
 604                                    ciInstanceKlass* accessor) {
 605   GUARDED_VM_ENTRY(return get_klass_by_index_impl(cpool, index, is_accessible, accessor);)
 606 }
 607 
<span class="line-added"> 608 // ------------------------------------------------------------------</span>
<span class="line-added"> 609 // ciEnv::is_klass_never_null</span>
<span class="line-added"> 610 //</span>
<span class="line-added"> 611 // Get information about nullability from the constant pool.</span>
<span class="line-added"> 612 bool ciEnv::is_klass_never_null(const constantPoolHandle&amp; cpool, int index) {</span>
<span class="line-added"> 613   GUARDED_VM_ENTRY(return cpool-&gt;klass_name_at(index)-&gt;is_Q_signature();)</span>
<span class="line-added"> 614 }</span>
<span class="line-added"> 615 </span>
 616 // ------------------------------------------------------------------
 617 // ciEnv::get_constant_by_index_impl
 618 //
 619 // Implementation of get_constant_by_index().
 620 ciConstant ciEnv::get_constant_by_index_impl(const constantPoolHandle&amp; cpool,
 621                                              int pool_index, int cache_index,
 622                                              ciInstanceKlass* accessor) {
 623   bool ignore_will_link;
 624   EXCEPTION_CONTEXT;
 625   int index = pool_index;
 626   if (cache_index &gt;= 0) {
 627     assert(index &lt; 0, &quot;only one kind of index at a time&quot;);
 628     index = cpool-&gt;object_to_cp_index(cache_index);
 629     oop obj = cpool-&gt;resolved_references()-&gt;obj_at(cache_index);
 630     if (obj != NULL) {
 631       if (obj == Universe::the_null_sentinel()) {
 632         return ciConstant(T_OBJECT, get_object(NULL));
 633       }
 634       BasicType bt = T_OBJECT;
 635       if (cpool-&gt;tag_at(index).is_dynamic_constant())
</pre>
</td>
</tr>
</table>
<center><a href="../c1/c1_ValueMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/bytecodeAssembler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
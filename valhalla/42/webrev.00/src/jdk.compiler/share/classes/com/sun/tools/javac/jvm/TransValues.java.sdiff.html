<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
262     /* Note: 1. Assignop does not call for any translation, since value instance fields are final and
263        so cannot be AssignedOped. 2. Any redundantly qualified this would have been lowered already.
264     */
265     @Override
266     public void visitAssign(JCAssign tree) {
267         if (constructingValue()) {
268             Symbol symbol = null;
269             switch(tree.lhs.getTag()) {
270                 case IDENT:
271                     symbol = ((JCIdent)tree.lhs).sym;
272                     break;
273                 case SELECT:
274                     JCFieldAccess fieldAccess = (JCFieldAccess) tree.lhs;
275                     if (fieldAccess.selected.hasTag(IDENT) &amp;&amp; ((JCIdent)fieldAccess.selected).name == names._this) {
276                         symbol = fieldAccess.sym;
277                     }
278                     break;
279                 default:
280                     break;
281             }
<span class="line-modified">282             if (isInstanceAccess(symbol)) {</span>
283                 final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);
284                 result = make.Assign(facHandle, make.WithField(make.Select(facHandle, symbol), translate(tree.rhs)).setType(currentClass.type)).setType(currentClass.type);
285                 if (requireRVal) {
286                     result = make.Select(make.Parens((JCExpression) result).setType(currentClass.type), symbol);
287                 }
288                 return;
289             }
290         }
291         super.visitAssign(tree);
292     }
293 
294     @Override
295     public void visitExec(JCExpressionStatement tree) {
296         if (constructingValue()) {
297             tree.expr = translate(tree.expr, false);
298             result = tree;
299         } else {
300             super.visitExec(tree);
301         }
302     }
303 
304     @Override
305     public void visitIdent(JCIdent ident) {
306         if (constructingValue()) {
307             Symbol symbol = ident.sym;
<span class="line-modified">308             if (isInstanceAccess(symbol)) {</span>
309                 final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);
310                 result = make.Select(facHandle, symbol);
311                 return;



312             }
313         }
314         super.visitIdent(ident);
315     }
316 
317     @Override
318     public void visitSelect(JCFieldAccess fieldAccess) {
319         if (constructingValue()) { // Qualified this would have been lowered already.
320             if (fieldAccess.selected.hasTag(IDENT) &amp;&amp; ((JCIdent)fieldAccess.selected).name == names._this) {
321                 Symbol symbol = fieldAccess.sym;
<span class="line-modified">322                 if (isInstanceAccess(symbol)) {</span>
323                     final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);
324                     result = make.Select(facHandle, symbol);
325                     return;
326                 }
327             }
328         }
329         // Rewrite any accesses of the form V.ref.member to ((V) V.ref).member
330         fieldAccess.selected = translate(fieldAccess.selected);
331         if (fieldAccess.name != names._class &amp;&amp; fieldAccess.name != names._default) {  // TODO: this and super ??
332             Symbol sym = TreeInfo.symbol(fieldAccess);
333             TypeSymbol selectedType = fieldAccess.selected.type.tsym;
334             if (selectedType.isReferenceProjection()) {
335                 switch (sym.kind) {
336                     case MTH:
337                     case VAR:
338                         fieldAccess.selected =
339                                 make.TypeCast(types.erasure(selectedType.valueProjection().type), fieldAccess.selected);
340                         if (sym.owner.isReferenceProjection()) // is an empty class file.
341                             sym = sym.valueProjection();
342                         break;
</pre>
<hr />
<pre>
359             Assert.check(tree.def == null);
360             MethodSymbol sFactory = getValueFactory((MethodSymbol) tree.constructor);
361             make.at(tree.pos());
362             JCExpression declClass = make.Type(tree.constructor.owner.type);
363             JCExpression meth = make.Select(declClass, sFactory);
364             meth.type = types.erasure(meth.type);
365             final JCMethodInvocation apply = make.Apply(tree.typeargs, meth, tree.args);
366             apply.varargsElement = tree.varargsElement;
367             apply.type = meth.type.getReturnType();
368             result = apply;
369             return;
370         }
371         super.visitNewClass(tree);
372     }
373 
374     // Utility methods ...
375     private boolean constructingValue() {
376         return currentClass != null &amp;&amp; (currentClass.sym.flags() &amp; Flags.VALUE) != 0 &amp;&amp; currentMethod != null &amp;&amp; currentMethod.sym.isConstructor();
377     }
378 
<span class="line-modified">379     private boolean isInstanceAccess(Symbol symbol) {</span>
<span class="line-modified">380         return symbol != null &amp;&amp; (symbol.kind == VAR || symbol.kind == MTH) &amp;&amp; symbol.owner == currentClass.sym &amp;&amp; !symbol.isStatic();</span>



381     }
382 
383     private MethodSymbol getValueFactory(MethodSymbol init) {
384         Assert.check(init.name.equals(names.init));
385         Assert.check(types.isValue(init.owner.type));
386         MethodSymbol factory = init2factory.get(init);
387         if (factory != null)
388             return factory;
389 
390         MethodType factoryType = new MethodType(init.erasure(types).getParameterTypes(),
391                                                 init.owner.type,
392                                                 init.type.getThrownTypes(),
393                                                 init.owner.type.tsym);
394         factory = new MethodSymbol(init.flags_field | STATIC,
395                                         names.init,
396                                         factoryType,
397                                         init.owner);
398         factory.setAttributes(init);
399         init2factory.put(init, factory);
400         return factory;
</pre>
</td>
<td>
<hr />
<pre>
262     /* Note: 1. Assignop does not call for any translation, since value instance fields are final and
263        so cannot be AssignedOped. 2. Any redundantly qualified this would have been lowered already.
264     */
265     @Override
266     public void visitAssign(JCAssign tree) {
267         if (constructingValue()) {
268             Symbol symbol = null;
269             switch(tree.lhs.getTag()) {
270                 case IDENT:
271                     symbol = ((JCIdent)tree.lhs).sym;
272                     break;
273                 case SELECT:
274                     JCFieldAccess fieldAccess = (JCFieldAccess) tree.lhs;
275                     if (fieldAccess.selected.hasTag(IDENT) &amp;&amp; ((JCIdent)fieldAccess.selected).name == names._this) {
276                         symbol = fieldAccess.sym;
277                     }
278                     break;
279                 default:
280                     break;
281             }
<span class="line-modified">282             if (isInstanceMemberAccess(symbol)) {</span>
283                 final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);
284                 result = make.Assign(facHandle, make.WithField(make.Select(facHandle, symbol), translate(tree.rhs)).setType(currentClass.type)).setType(currentClass.type);
285                 if (requireRVal) {
286                     result = make.Select(make.Parens((JCExpression) result).setType(currentClass.type), symbol);
287                 }
288                 return;
289             }
290         }
291         super.visitAssign(tree);
292     }
293 
294     @Override
295     public void visitExec(JCExpressionStatement tree) {
296         if (constructingValue()) {
297             tree.expr = translate(tree.expr, false);
298             result = tree;
299         } else {
300             super.visitExec(tree);
301         }
302     }
303 
304     @Override
305     public void visitIdent(JCIdent ident) {
306         if (constructingValue()) {
307             Symbol symbol = ident.sym;
<span class="line-modified">308             if (isInstanceMemberAccess(symbol)) {</span>
309                 final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);
310                 result = make.Select(facHandle, symbol);
311                 return;
<span class="line-added">312             } else if (symbol.name == names._this) {</span>
<span class="line-added">313                 result = make.Ident(currentMethod.factoryProduct);</span>
<span class="line-added">314                 return;</span>
315             }
316         }
317         super.visitIdent(ident);
318     }
319 
320     @Override
321     public void visitSelect(JCFieldAccess fieldAccess) {
322         if (constructingValue()) { // Qualified this would have been lowered already.
323             if (fieldAccess.selected.hasTag(IDENT) &amp;&amp; ((JCIdent)fieldAccess.selected).name == names._this) {
324                 Symbol symbol = fieldAccess.sym;
<span class="line-modified">325                 if (isInstanceMemberAccess(symbol)) {</span>
326                     final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);
327                     result = make.Select(facHandle, symbol);
328                     return;
329                 }
330             }
331         }
332         // Rewrite any accesses of the form V.ref.member to ((V) V.ref).member
333         fieldAccess.selected = translate(fieldAccess.selected);
334         if (fieldAccess.name != names._class &amp;&amp; fieldAccess.name != names._default) {  // TODO: this and super ??
335             Symbol sym = TreeInfo.symbol(fieldAccess);
336             TypeSymbol selectedType = fieldAccess.selected.type.tsym;
337             if (selectedType.isReferenceProjection()) {
338                 switch (sym.kind) {
339                     case MTH:
340                     case VAR:
341                         fieldAccess.selected =
342                                 make.TypeCast(types.erasure(selectedType.valueProjection().type), fieldAccess.selected);
343                         if (sym.owner.isReferenceProjection()) // is an empty class file.
344                             sym = sym.valueProjection();
345                         break;
</pre>
<hr />
<pre>
362             Assert.check(tree.def == null);
363             MethodSymbol sFactory = getValueFactory((MethodSymbol) tree.constructor);
364             make.at(tree.pos());
365             JCExpression declClass = make.Type(tree.constructor.owner.type);
366             JCExpression meth = make.Select(declClass, sFactory);
367             meth.type = types.erasure(meth.type);
368             final JCMethodInvocation apply = make.Apply(tree.typeargs, meth, tree.args);
369             apply.varargsElement = tree.varargsElement;
370             apply.type = meth.type.getReturnType();
371             result = apply;
372             return;
373         }
374         super.visitNewClass(tree);
375     }
376 
377     // Utility methods ...
378     private boolean constructingValue() {
379         return currentClass != null &amp;&amp; (currentClass.sym.flags() &amp; Flags.VALUE) != 0 &amp;&amp; currentMethod != null &amp;&amp; currentMethod.sym.isConstructor();
380     }
381 
<span class="line-modified">382     private boolean isInstanceMemberAccess(Symbol symbol) {</span>
<span class="line-modified">383         return symbol != null</span>
<span class="line-added">384                 &amp;&amp; (symbol.name != names._this &amp;&amp; symbol.name != names._super)</span>
<span class="line-added">385                 &amp;&amp; (symbol.kind == VAR || symbol.kind == MTH)</span>
<span class="line-added">386                 &amp;&amp; symbol.owner == currentClass.sym &amp;&amp; !symbol.isStatic();</span>
387     }
388 
389     private MethodSymbol getValueFactory(MethodSymbol init) {
390         Assert.check(init.name.equals(names.init));
391         Assert.check(types.isValue(init.owner.type));
392         MethodSymbol factory = init2factory.get(init);
393         if (factory != null)
394             return factory;
395 
396         MethodType factoryType = new MethodType(init.erasure(types).getParameterTypes(),
397                                                 init.owner.type,
398                                                 init.type.getThrownTypes(),
399                                                 init.owner.type.tsym);
400         factory = new MethodSymbol(init.flags_field | STATIC,
401                                         names.init,
402                                         factoryType,
403                                         init.owner);
404         factory.setAttributes(init);
405         init2factory.put(init, factory);
406         return factory;
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
diff a/src/hotspot/share/oops/valueArrayOop.inline.hpp b/src/hotspot/share/oops/valueArrayOop.inline.hpp
--- a/src/hotspot/share/oops/valueArrayOop.inline.hpp
+++ b/src/hotspot/share/oops/valueArrayOop.inline.hpp
@@ -47,11 +47,11 @@
 }
 
 inline oop valueArrayOopDesc::value_alloc_copy_from_index(valueArrayHandle vah, int index, TRAPS) {
   ValueArrayKlass* vaklass = ValueArrayKlass::cast(vah->klass());
   ValueKlass* vklass = vaklass->element_klass();
-  if (vklass->is_empty_value()) {
+  if (vklass->is_empty_inline_type()) {
     return vklass->default_value();
   } else {
     oop buf = vklass->allocate_instance(CHECK_NULL);
     vklass->value_copy_payload_to_new_oop(vah->value_at_addr(index, vaklass->layout_helper()) ,buf);
     return buf;
@@ -59,22 +59,22 @@
 }
 
 inline void valueArrayOopDesc::value_copy_from_index(int index, oop dst) const {
   ValueArrayKlass* vaklass = ValueArrayKlass::cast(klass());
   ValueKlass* vklass = vaklass->element_klass();
-  if (vklass->is_empty_value()) {
+  if (vklass->is_empty_inline_type()) {
     return; // Assumes dst was a new and clean buffer (OptoRuntime::load_unknown_value())
   } else {
     void* src = value_at_addr(index, vaklass->layout_helper());
     return vklass->value_copy_payload_to_new_oop(src ,dst);
   }
 }
 
 inline void valueArrayOopDesc::value_copy_to_index(oop src, int index) const {
   ValueArrayKlass* vaklass = ValueArrayKlass::cast(klass());
   ValueKlass* vklass = vaklass->element_klass();
-  if (vklass->is_empty_value()) {
+  if (vklass->is_empty_inline_type()) {
     return;
   }
   void* dst = value_at_addr(index, vaklass->layout_helper());
   vklass->value_copy_oop_to_payload(src, dst);
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayOop.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 135 
 136 struct JvmtiCachedClassFileData;
 137 
 138 class SigEntry;
 139 
 140 class ValueKlassFixedBlock {
 141   Array&lt;SigEntry&gt;** _extended_sig;
 142   Array&lt;VMRegPair&gt;** _return_regs;
 143   address* _pack_handler;
 144   address* _pack_handler_jobject;
 145   address* _unpack_handler;
 146   int* _default_value_offset;
 147   Klass** _value_array_klass;
 148   int _alignment;
 149   int _first_field_offset;
 150   int _exact_size_in_bytes;
 151 
 152   friend class ValueKlass;
 153 };
 154 
<span class="line-modified"> 155 class ValueTypes {</span>
 156 public:
 157   u2 _class_info_index;
 158   Symbol* _class_name;
 159 };
 160 
 161 class InstanceKlass: public Klass {
 162   friend class VMStructs;
 163   friend class JVMCIVMStructs;
 164   friend class ClassFileParser;
 165   friend class CompileReplay;
 166   friend class TemplateTable;
 167 
 168  public:
 169   static const KlassID ID = InstanceKlassID;
 170 
 171  protected:
 172   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 173 
 174  public:
 175   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
</pre>
<hr />
<pre>
 209   // last two shorts [class_index, method_index] of the array. If only
 210   // the InnerClasses attribute exists, the _inner_classes array length is
 211   // number_of_inner_classes * 4. If the class has both InnerClasses
 212   // and EnclosingMethod attributes the _inner_classes array length is
 213   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 214   Array&lt;jushort&gt;* _inner_classes;
 215 
 216   // The NestMembers attribute. An array of shorts, where each is a
 217   // class info index for the class that is a nest member. This data
 218   // has not been validated.
 219   Array&lt;jushort&gt;* _nest_members;
 220 
 221   // The NestHost attribute. The class info index for the class
 222   // that is the nest-host of this class. This data has not been validated.
 223   jushort _nest_host_index;
 224 
 225   // Resolved nest-host klass: either true nest-host or self if we are not nested.
 226   // By always being set it makes nest-member access checks simpler.
 227   InstanceKlass* _nest_host;
 228 
<span class="line-modified"> 229   Array&lt;ValueTypes&gt;* _value_types;</span>
 230 
 231   // The contents of the Record attribute.
 232   Array&lt;RecordComponent*&gt;* _record_components;
 233 
 234   // the source debug extension for this klass, NULL if not specified.
 235   // Specified as UTF-8 string without terminating zero byte in the classfile,
 236   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 237   const char*     _source_debug_extension;
 238   // Array name derived from this class which needs unreferencing
 239   // if this class is unloaded.
 240   Symbol*         _array_name;
 241 
 242   // Number of heapOopSize words used by non-static fields in this klass
 243   // (including inherited fields but after header_size()).
 244   int             _nonstatic_field_size;
 245   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 246   // Constant pool index to the utf8 entry of the Generic signature,
 247   // or 0 if none.
 248   u2              _generic_signature_index;
 249   // Constant pool index to the utf8 entry for the name of source file
</pre>
<hr />
<pre>
 253   u2              _java_fields_count;    // The number of declared Java fields
 254   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 255 
 256   int             _itable_len;           // length of Java itable (in words)
 257   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 258   // _misc_flags.
 259   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 260 
 261   // The low three bits of _misc_flags contains the kind field.
 262   // This can be used to quickly discriminate among the five kinds of
 263   // InstanceKlass.
 264 
 265   static const unsigned _misc_kind_field_size = 3;
 266   static const unsigned _misc_kind_field_pos  = 0;
 267   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 268 
 269   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 270   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 271   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 272   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
<span class="line-modified"> 273   static const unsigned _misc_kind_value_type   = 4; // ValueKlass</span>
 274 
 275   // Start after _misc_kind field.
 276   enum {
 277     _misc_rewritten                           = 1 &lt;&lt; 3,  // methods rewritten.
 278     _misc_has_nonstatic_fields                = 1 &lt;&lt; 4,  // for sizing with UseCompressedOops
 279     _misc_should_verify_class                 = 1 &lt;&lt; 5,  // allow caching of preverification
 280     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 6,  // has embedded _unsafe_anonymous_host field
 281     _misc_is_contended                        = 1 &lt;&lt; 7,  // marked with contended annotation
 282     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 8,  // class/superclass/implemented interfaces has non-static, concrete methods
 283     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 9,  // directly declares non-static, concrete methods
 284     _misc_has_been_redefined                  = 1 &lt;&lt; 10,  // class has been redefined
 285     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 11, // when this class was loaded, the fingerprint computed from its
 286                                                          // code source was found to be matching the value recorded by AOT.
 287     _misc_is_scratch_class                    = 1 &lt;&lt; 12, // class is the redefined scratch class
 288     _misc_is_shared_boot_class                = 1 &lt;&lt; 13, // defining class loader is boot class loader
 289     _misc_is_shared_platform_class            = 1 &lt;&lt; 14, // defining class loader is platform class loader
 290     _misc_is_shared_app_class                 = 1 &lt;&lt; 15, // defining class loader is app class loader
 291     _misc_has_resolved_methods                = 1 &lt;&lt; 16, // resolved methods table entries added for this class
 292     _misc_is_being_redefined                  = 1 &lt;&lt; 17, // used for locking redefinition
 293     _misc_has_contended_annotations           = 1 &lt;&lt; 18, // has @Contended annotation
<span class="line-modified"> 294     _misc_has_value_fields                    = 1 &lt;&lt; 19, // has value fields and related embedded section is not empty</span>
<span class="line-modified"> 295     _misc_is_empty_value                      = 1 &lt;&lt; 20, // empty value type</span>
 296     _misc_is_naturally_atomic                 = 1 &lt;&lt; 21, // loaded/stored in one instruction
 297     _misc_is_declared_atomic                  = 1 &lt;&lt; 22, // implements jl.NonTearable
 298     _misc_invalid_inline_super                = 1 &lt;&lt; 23, // invalid super type for an inline type
 299     _misc_invalid_identity_super              = 1 &lt;&lt; 24, // invalid super type for an identity type
 300     _misc_has_injected_identityObject         = 1 &lt;&lt; 25  // IdentityObject has been injected by the JVM
 301   };
 302   u2 shared_loader_type_bits() const {
 303     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 304   }
 305   u4              _misc_flags;
 306   u2              _minor_version;        // minor version number of class file
 307   u2              _major_version;        // major version number of class file
 308   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 309   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 310   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 311   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 312   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 313   uint64_t        volatile _dep_context_last_cleaned;
 314   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 315 #if INCLUDE_JVMTI
</pre>
<hr />
<pre>
 408     return (_misc_flags &amp; shared_loader_type_bits()) == 0;
 409   }
 410 
 411   void clear_shared_class_loader_type() {
 412     _misc_flags &amp;= ~shared_loader_type_bits();
 413   }
 414 
 415   void set_shared_class_loader_type(s2 loader_type);
 416 
 417   bool has_nonstatic_fields() const        {
 418     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 419   }
 420   void set_has_nonstatic_fields(bool b)    {
 421     if (b) {
 422       _misc_flags |= _misc_has_nonstatic_fields;
 423     } else {
 424       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 425     }
 426   }
 427 
<span class="line-modified"> 428   bool has_value_fields() const          {</span>
<span class="line-modified"> 429     return (_misc_flags &amp; _misc_has_value_fields) != 0;</span>
 430   }
<span class="line-modified"> 431   void set_has_value_fields()  {</span>
<span class="line-modified"> 432     _misc_flags |= _misc_has_value_fields;</span>
 433   }
 434 
<span class="line-modified"> 435   bool is_empty_value() const {</span>
<span class="line-modified"> 436     return (_misc_flags &amp; _misc_is_empty_value) != 0;</span>
 437   }
<span class="line-modified"> 438   void set_is_empty_value() {</span>
<span class="line-modified"> 439     _misc_flags |= _misc_is_empty_value;</span>
 440   }
 441 
 442   // Note:  The naturally_atomic property only applies to
 443   // inline classes; it is never true on identity classes.
 444   // The bit is placed on instanceKlass for convenience.
 445 
 446   // Query if h/w provides atomic load/store for instances.
 447   bool is_naturally_atomic() const {
 448     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;
 449   }
 450   // Initialized in the class file parser, not changed later.
 451   void set_is_naturally_atomic() {
 452     _misc_flags |= _misc_is_naturally_atomic;
 453   }
 454 
 455   // Query if this class implements jl.NonTearable or was
 456   // mentioned in the JVM option AlwaysAtomicValueTypes.
 457   // This bit can occur anywhere, but is only significant
 458   // for inline classes *and* their super types.
 459   // It inherits from supers along with NonTearable.
</pre>
<hr />
<pre>
 645   ClassState  init_state()                 { return (ClassState)_init_state; }
 646   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 647 
 648   // defineClass specified verification
 649   bool should_verify_class() const         {
 650     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 651   }
 652   void set_should_verify_class(bool value) {
 653     if (value) {
 654       _misc_flags |= _misc_should_verify_class;
 655     } else {
 656       _misc_flags &amp;= ~_misc_should_verify_class;
 657     }
 658   }
 659 
 660   // marking
 661   bool is_marked_dependent() const         { return _is_marked_dependent; }
 662   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 663 
 664   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }
<span class="line-modified"> 665   static u4 misc_flags_is_empty_value() { return _misc_is_empty_value; }</span>
 666 
 667   // initialization (virtuals from Klass)
 668   bool should_be_initialized() const;  // means that initialize should be called
 669   void initialize(TRAPS);
 670   void link_class(TRAPS);
 671   bool link_class_or_fail(TRAPS); // returns false on failure
 672   void rewrite_class(TRAPS);
 673   void link_methods(TRAPS);
 674   Method* class_initializer() const;
 675 
 676   // set the class to initialized if no static initializer is present
 677   void eager_initialize(Thread *thread);
 678 
 679   // reference type
 680   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 681   void set_reference_type(ReferenceType t) {
 682     assert(t == (u1)t, &quot;overflow&quot;);
 683     _reference_type = (u1)t;
 684   }
 685 
</pre>
<hr />
<pre>
 948 
 949   void set_kind(unsigned kind) {
 950     assert(kind &lt;= _misc_kind_field_mask, &quot;Invalid InstanceKlass kind&quot;);
 951     unsigned fmask = _misc_kind_field_mask &lt;&lt; _misc_kind_field_pos;
 952     unsigned flags = _misc_flags &amp; ~fmask;
 953     _misc_flags = (flags | (kind &lt;&lt; _misc_kind_field_pos));
 954   }
 955 
 956   bool is_kind(unsigned desired) const {
 957     unsigned kind = (_misc_flags &gt;&gt; _misc_kind_field_pos) &amp; _misc_kind_field_mask;
 958     return kind == desired;
 959   }
 960 
 961 public:
 962 
 963   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 964   bool is_other_instance_klass() const        { return is_kind(_misc_kind_other); }
 965   bool is_reference_instance_klass() const    { return is_kind(_misc_kind_reference); }
 966   bool is_mirror_instance_klass() const       { return is_kind(_misc_kind_mirror); }
 967   bool is_class_loader_instance_klass() const { return is_kind(_misc_kind_class_loader); }
<span class="line-modified"> 968   bool is_value_type_klass()            const { return is_kind(_misc_kind_value_type); }</span>
 969 
 970 #if INCLUDE_JVMTI
 971 
 972   void init_previous_versions() {
 973     _previous_versions = NULL;
 974   }
 975 
 976  private:
 977   static bool  _has_previous_versions;
 978  public:
 979   static void purge_previous_versions(InstanceKlass* ik) {
 980     if (ik-&gt;has_been_redefined()) {
 981       ik-&gt;purge_previous_version_list();
 982     }
 983   }
 984 
 985   static bool has_previous_versions_and_reset();
 986   static bool has_previous_versions() { return _has_previous_versions; }
 987 
 988   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
</pre>
<hr />
<pre>
1183   static InstanceKlass* cast(Klass* k) {
1184     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1185   }
1186 
1187   static const InstanceKlass* cast(const Klass* k) {
1188     assert(k != NULL, &quot;k should not be null&quot;);
1189     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1190     return static_cast&lt;const InstanceKlass*&gt;(k);
1191   }
1192 
1193   virtual InstanceKlass* java_super() const {
1194     return (super() == NULL) ? NULL : cast(super());
1195   }
1196 
1197   // Sizing (in words)
1198   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1199 
1200   static int size(int vtable_length, int itable_length,
1201                   int nonstatic_oop_map_size,
1202                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint,
<span class="line-modified">1203                   int java_fields, bool is_value_type) {</span>
1204     return align_metadata_size(header_size() +
1205            vtable_length +
1206            itable_length +
1207            nonstatic_oop_map_size +
1208            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1209            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
1210            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0) +
1211            (java_fields * (int)sizeof(Klass*)/wordSize) +
<span class="line-modified">1212            (is_value_type ? (int)sizeof(ValueKlassFixedBlock) : 0));</span>
1213   }
1214   int size() const                    { return size(vtable_length(),
1215                                                itable_length(),
1216                                                nonstatic_oop_map_size(),
1217                                                is_interface(),
1218                                                is_unsafe_anonymous(),
1219                                                has_stored_fingerprint(),
<span class="line-modified">1220                                                has_value_fields() ? java_fields_count() : 0,</span>
1221                                                is_value());
1222   }
1223 
1224   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1225   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1226 
1227   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1228 
1229   oop static_field_base_raw() { return java_mirror(); }
1230 
1231   bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;
1232 
1233   OopMapBlock* start_of_nonstatic_oop_maps() const {
1234     return (OopMapBlock*)(start_of_itable() + itable_length());
1235   }
1236 
1237   Klass** end_of_nonstatic_oop_maps() const {
1238     return (Klass**)(start_of_nonstatic_oop_maps() +
1239                      nonstatic_oop_map_count());
1240   }
</pre>
<hr />
<pre>
1262 
1263   address adr_fingerprint() const {
1264     if (has_stored_fingerprint()) {
1265       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1266       if (adr_host != NULL) {
1267         return (address)(adr_host + 1);
1268       }
1269 
1270       Klass* volatile* adr_impl = adr_implementor();
1271       if (adr_impl != NULL) {
1272         return (address)(adr_impl + 1);
1273       }
1274 
1275       return (address)end_of_nonstatic_oop_maps();
1276     } else {
1277       return NULL;
1278     }
1279   }
1280 
1281   address adr_value_fields_klasses() const {
<span class="line-modified">1282     if (has_value_fields()) {</span>
1283       address adr_fing = adr_fingerprint();
1284       if (adr_fing != NULL) {
1285         return adr_fingerprint() + sizeof(u8);
1286       }
1287 
1288       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1289       if (adr_host != NULL) {
1290         return (address)(adr_host + 1);
1291       }
1292 
1293       Klass* volatile* adr_impl = adr_implementor();
1294       if (adr_impl != NULL) {
1295         return (address)(adr_impl + 1);
1296       }
1297 
1298       return (address)end_of_nonstatic_oop_maps();
1299     } else {
1300       return NULL;
1301     }
1302   }
1303 
1304   Klass* get_value_field_klass(int idx) const {
<span class="line-modified">1305     assert(has_value_fields(), &quot;Sanity checking&quot;);</span>
1306     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];
1307     assert(k != NULL, &quot;Should always be set before being read&quot;);
<span class="line-modified">1308     assert(k-&gt;is_value(), &quot;Must be a value type&quot;);</span>
1309     return k;
1310   }
1311 
1312   Klass* get_value_field_klass_or_null(int idx) const {
<span class="line-modified">1313     assert(has_value_fields(), &quot;Sanity checking&quot;);</span>
1314     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];
<span class="line-modified">1315     assert(k == NULL || k-&gt;is_value(), &quot;Must be a value type&quot;);</span>
1316     return k;
1317   }
1318 
1319   void set_value_field_klass(int idx, Klass* k) {
<span class="line-modified">1320     assert(has_value_fields(), &quot;Sanity checking&quot;);</span>
1321     assert(k != NULL, &quot;Should not be set to NULL&quot;);
1322     assert(((Klass**)adr_value_fields_klasses())[idx] == NULL, &quot;Should not be set twice&quot;);
1323     ((Klass**)adr_value_fields_klasses())[idx] = k;
1324   }
1325 
1326   // Use this to return the size of an instance in heap words:
1327   virtual int size_helper() const {
1328     return layout_helper_to_size_helper(layout_helper());
1329   }
1330 
1331   // This bit is initialized in classFileParser.cpp.
1332   // It is false under any of the following conditions:
1333   //  - the class is abstract (including any interface)
1334   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1335   //  - the class size is larger than FastAllocateSizeLimit
1336   //  - the class is java/lang/Class, which cannot be allocated directly
1337   bool can_be_fastpath_allocated() const {
1338     return !layout_helper_needs_slow_path(layout_helper());
1339   }
1340 
</pre>
</td>
<td>
<hr />
<pre>
 135 
 136 struct JvmtiCachedClassFileData;
 137 
 138 class SigEntry;
 139 
 140 class ValueKlassFixedBlock {
 141   Array&lt;SigEntry&gt;** _extended_sig;
 142   Array&lt;VMRegPair&gt;** _return_regs;
 143   address* _pack_handler;
 144   address* _pack_handler_jobject;
 145   address* _unpack_handler;
 146   int* _default_value_offset;
 147   Klass** _value_array_klass;
 148   int _alignment;
 149   int _first_field_offset;
 150   int _exact_size_in_bytes;
 151 
 152   friend class ValueKlass;
 153 };
 154 
<span class="line-modified"> 155 class InlineTypes {</span>
 156 public:
 157   u2 _class_info_index;
 158   Symbol* _class_name;
 159 };
 160 
 161 class InstanceKlass: public Klass {
 162   friend class VMStructs;
 163   friend class JVMCIVMStructs;
 164   friend class ClassFileParser;
 165   friend class CompileReplay;
 166   friend class TemplateTable;
 167 
 168  public:
 169   static const KlassID ID = InstanceKlassID;
 170 
 171  protected:
 172   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 173 
 174  public:
 175   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
</pre>
<hr />
<pre>
 209   // last two shorts [class_index, method_index] of the array. If only
 210   // the InnerClasses attribute exists, the _inner_classes array length is
 211   // number_of_inner_classes * 4. If the class has both InnerClasses
 212   // and EnclosingMethod attributes the _inner_classes array length is
 213   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 214   Array&lt;jushort&gt;* _inner_classes;
 215 
 216   // The NestMembers attribute. An array of shorts, where each is a
 217   // class info index for the class that is a nest member. This data
 218   // has not been validated.
 219   Array&lt;jushort&gt;* _nest_members;
 220 
 221   // The NestHost attribute. The class info index for the class
 222   // that is the nest-host of this class. This data has not been validated.
 223   jushort _nest_host_index;
 224 
 225   // Resolved nest-host klass: either true nest-host or self if we are not nested.
 226   // By always being set it makes nest-member access checks simpler.
 227   InstanceKlass* _nest_host;
 228 
<span class="line-modified"> 229   Array&lt;InlineTypes&gt;* _inline_types;</span>
 230 
 231   // The contents of the Record attribute.
 232   Array&lt;RecordComponent*&gt;* _record_components;
 233 
 234   // the source debug extension for this klass, NULL if not specified.
 235   // Specified as UTF-8 string without terminating zero byte in the classfile,
 236   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 237   const char*     _source_debug_extension;
 238   // Array name derived from this class which needs unreferencing
 239   // if this class is unloaded.
 240   Symbol*         _array_name;
 241 
 242   // Number of heapOopSize words used by non-static fields in this klass
 243   // (including inherited fields but after header_size()).
 244   int             _nonstatic_field_size;
 245   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 246   // Constant pool index to the utf8 entry of the Generic signature,
 247   // or 0 if none.
 248   u2              _generic_signature_index;
 249   // Constant pool index to the utf8 entry for the name of source file
</pre>
<hr />
<pre>
 253   u2              _java_fields_count;    // The number of declared Java fields
 254   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 255 
 256   int             _itable_len;           // length of Java itable (in words)
 257   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 258   // _misc_flags.
 259   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 260 
 261   // The low three bits of _misc_flags contains the kind field.
 262   // This can be used to quickly discriminate among the five kinds of
 263   // InstanceKlass.
 264 
 265   static const unsigned _misc_kind_field_size = 3;
 266   static const unsigned _misc_kind_field_pos  = 0;
 267   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 268 
 269   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 270   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 271   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 272   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
<span class="line-modified"> 273   static const unsigned _misc_kind_inline_type  = 4; // InlineKlass</span>
 274 
 275   // Start after _misc_kind field.
 276   enum {
 277     _misc_rewritten                           = 1 &lt;&lt; 3,  // methods rewritten.
 278     _misc_has_nonstatic_fields                = 1 &lt;&lt; 4,  // for sizing with UseCompressedOops
 279     _misc_should_verify_class                 = 1 &lt;&lt; 5,  // allow caching of preverification
 280     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 6,  // has embedded _unsafe_anonymous_host field
 281     _misc_is_contended                        = 1 &lt;&lt; 7,  // marked with contended annotation
 282     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 8,  // class/superclass/implemented interfaces has non-static, concrete methods
 283     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 9,  // directly declares non-static, concrete methods
 284     _misc_has_been_redefined                  = 1 &lt;&lt; 10,  // class has been redefined
 285     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 11, // when this class was loaded, the fingerprint computed from its
 286                                                          // code source was found to be matching the value recorded by AOT.
 287     _misc_is_scratch_class                    = 1 &lt;&lt; 12, // class is the redefined scratch class
 288     _misc_is_shared_boot_class                = 1 &lt;&lt; 13, // defining class loader is boot class loader
 289     _misc_is_shared_platform_class            = 1 &lt;&lt; 14, // defining class loader is platform class loader
 290     _misc_is_shared_app_class                 = 1 &lt;&lt; 15, // defining class loader is app class loader
 291     _misc_has_resolved_methods                = 1 &lt;&lt; 16, // resolved methods table entries added for this class
 292     _misc_is_being_redefined                  = 1 &lt;&lt; 17, // used for locking redefinition
 293     _misc_has_contended_annotations           = 1 &lt;&lt; 18, // has @Contended annotation
<span class="line-modified"> 294     _misc_has_inline_fields                   = 1 &lt;&lt; 19, // has inline fields and related embedded section is not empty</span>
<span class="line-modified"> 295     _misc_is_empty_inline_type                = 1 &lt;&lt; 20, // empty inline type</span>
 296     _misc_is_naturally_atomic                 = 1 &lt;&lt; 21, // loaded/stored in one instruction
 297     _misc_is_declared_atomic                  = 1 &lt;&lt; 22, // implements jl.NonTearable
 298     _misc_invalid_inline_super                = 1 &lt;&lt; 23, // invalid super type for an inline type
 299     _misc_invalid_identity_super              = 1 &lt;&lt; 24, // invalid super type for an identity type
 300     _misc_has_injected_identityObject         = 1 &lt;&lt; 25  // IdentityObject has been injected by the JVM
 301   };
 302   u2 shared_loader_type_bits() const {
 303     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 304   }
 305   u4              _misc_flags;
 306   u2              _minor_version;        // minor version number of class file
 307   u2              _major_version;        // major version number of class file
 308   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 309   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 310   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 311   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 312   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 313   uint64_t        volatile _dep_context_last_cleaned;
 314   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 315 #if INCLUDE_JVMTI
</pre>
<hr />
<pre>
 408     return (_misc_flags &amp; shared_loader_type_bits()) == 0;
 409   }
 410 
 411   void clear_shared_class_loader_type() {
 412     _misc_flags &amp;= ~shared_loader_type_bits();
 413   }
 414 
 415   void set_shared_class_loader_type(s2 loader_type);
 416 
 417   bool has_nonstatic_fields() const        {
 418     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 419   }
 420   void set_has_nonstatic_fields(bool b)    {
 421     if (b) {
 422       _misc_flags |= _misc_has_nonstatic_fields;
 423     } else {
 424       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 425     }
 426   }
 427 
<span class="line-modified"> 428   bool has_inline_fields() const          {</span>
<span class="line-modified"> 429     return (_misc_flags &amp; _misc_has_inline_fields) != 0;</span>
 430   }
<span class="line-modified"> 431   void set_has_inline_fields()  {</span>
<span class="line-modified"> 432     _misc_flags |= _misc_has_inline_fields;</span>
 433   }
 434 
<span class="line-modified"> 435   bool is_empty_inline_type() const {</span>
<span class="line-modified"> 436     return (_misc_flags &amp; _misc_is_empty_inline_type) != 0;</span>
 437   }
<span class="line-modified"> 438   void set_is_empty_inline_type() {</span>
<span class="line-modified"> 439     _misc_flags |= _misc_is_empty_inline_type;</span>
 440   }
 441 
 442   // Note:  The naturally_atomic property only applies to
 443   // inline classes; it is never true on identity classes.
 444   // The bit is placed on instanceKlass for convenience.
 445 
 446   // Query if h/w provides atomic load/store for instances.
 447   bool is_naturally_atomic() const {
 448     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;
 449   }
 450   // Initialized in the class file parser, not changed later.
 451   void set_is_naturally_atomic() {
 452     _misc_flags |= _misc_is_naturally_atomic;
 453   }
 454 
 455   // Query if this class implements jl.NonTearable or was
 456   // mentioned in the JVM option AlwaysAtomicValueTypes.
 457   // This bit can occur anywhere, but is only significant
 458   // for inline classes *and* their super types.
 459   // It inherits from supers along with NonTearable.
</pre>
<hr />
<pre>
 645   ClassState  init_state()                 { return (ClassState)_init_state; }
 646   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 647 
 648   // defineClass specified verification
 649   bool should_verify_class() const         {
 650     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 651   }
 652   void set_should_verify_class(bool value) {
 653     if (value) {
 654       _misc_flags |= _misc_should_verify_class;
 655     } else {
 656       _misc_flags &amp;= ~_misc_should_verify_class;
 657     }
 658   }
 659 
 660   // marking
 661   bool is_marked_dependent() const         { return _is_marked_dependent; }
 662   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 663 
 664   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }
<span class="line-modified"> 665   static u4 misc_flags_is_empty_inline_type() { return _misc_is_empty_inline_type; }</span>
 666 
 667   // initialization (virtuals from Klass)
 668   bool should_be_initialized() const;  // means that initialize should be called
 669   void initialize(TRAPS);
 670   void link_class(TRAPS);
 671   bool link_class_or_fail(TRAPS); // returns false on failure
 672   void rewrite_class(TRAPS);
 673   void link_methods(TRAPS);
 674   Method* class_initializer() const;
 675 
 676   // set the class to initialized if no static initializer is present
 677   void eager_initialize(Thread *thread);
 678 
 679   // reference type
 680   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 681   void set_reference_type(ReferenceType t) {
 682     assert(t == (u1)t, &quot;overflow&quot;);
 683     _reference_type = (u1)t;
 684   }
 685 
</pre>
<hr />
<pre>
 948 
 949   void set_kind(unsigned kind) {
 950     assert(kind &lt;= _misc_kind_field_mask, &quot;Invalid InstanceKlass kind&quot;);
 951     unsigned fmask = _misc_kind_field_mask &lt;&lt; _misc_kind_field_pos;
 952     unsigned flags = _misc_flags &amp; ~fmask;
 953     _misc_flags = (flags | (kind &lt;&lt; _misc_kind_field_pos));
 954   }
 955 
 956   bool is_kind(unsigned desired) const {
 957     unsigned kind = (_misc_flags &gt;&gt; _misc_kind_field_pos) &amp; _misc_kind_field_mask;
 958     return kind == desired;
 959   }
 960 
 961 public:
 962 
 963   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 964   bool is_other_instance_klass() const        { return is_kind(_misc_kind_other); }
 965   bool is_reference_instance_klass() const    { return is_kind(_misc_kind_reference); }
 966   bool is_mirror_instance_klass() const       { return is_kind(_misc_kind_mirror); }
 967   bool is_class_loader_instance_klass() const { return is_kind(_misc_kind_class_loader); }
<span class="line-modified"> 968   bool is_inline_type_klass()           const { return is_kind(_misc_kind_inline_type); }</span>
 969 
 970 #if INCLUDE_JVMTI
 971 
 972   void init_previous_versions() {
 973     _previous_versions = NULL;
 974   }
 975 
 976  private:
 977   static bool  _has_previous_versions;
 978  public:
 979   static void purge_previous_versions(InstanceKlass* ik) {
 980     if (ik-&gt;has_been_redefined()) {
 981       ik-&gt;purge_previous_version_list();
 982     }
 983   }
 984 
 985   static bool has_previous_versions_and_reset();
 986   static bool has_previous_versions() { return _has_previous_versions; }
 987 
 988   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
</pre>
<hr />
<pre>
1183   static InstanceKlass* cast(Klass* k) {
1184     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1185   }
1186 
1187   static const InstanceKlass* cast(const Klass* k) {
1188     assert(k != NULL, &quot;k should not be null&quot;);
1189     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1190     return static_cast&lt;const InstanceKlass*&gt;(k);
1191   }
1192 
1193   virtual InstanceKlass* java_super() const {
1194     return (super() == NULL) ? NULL : cast(super());
1195   }
1196 
1197   // Sizing (in words)
1198   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1199 
1200   static int size(int vtable_length, int itable_length,
1201                   int nonstatic_oop_map_size,
1202                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint,
<span class="line-modified">1203                   int java_fields, bool is_inline_type) {</span>
1204     return align_metadata_size(header_size() +
1205            vtable_length +
1206            itable_length +
1207            nonstatic_oop_map_size +
1208            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1209            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
1210            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0) +
1211            (java_fields * (int)sizeof(Klass*)/wordSize) +
<span class="line-modified">1212            (is_inline_type ? (int)sizeof(ValueKlassFixedBlock) : 0));</span>
1213   }
1214   int size() const                    { return size(vtable_length(),
1215                                                itable_length(),
1216                                                nonstatic_oop_map_size(),
1217                                                is_interface(),
1218                                                is_unsafe_anonymous(),
1219                                                has_stored_fingerprint(),
<span class="line-modified">1220                                                has_inline_fields() ? java_fields_count() : 0,</span>
1221                                                is_value());
1222   }
1223 
1224   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1225   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1226 
1227   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1228 
1229   oop static_field_base_raw() { return java_mirror(); }
1230 
1231   bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;
1232 
1233   OopMapBlock* start_of_nonstatic_oop_maps() const {
1234     return (OopMapBlock*)(start_of_itable() + itable_length());
1235   }
1236 
1237   Klass** end_of_nonstatic_oop_maps() const {
1238     return (Klass**)(start_of_nonstatic_oop_maps() +
1239                      nonstatic_oop_map_count());
1240   }
</pre>
<hr />
<pre>
1262 
1263   address adr_fingerprint() const {
1264     if (has_stored_fingerprint()) {
1265       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1266       if (adr_host != NULL) {
1267         return (address)(adr_host + 1);
1268       }
1269 
1270       Klass* volatile* adr_impl = adr_implementor();
1271       if (adr_impl != NULL) {
1272         return (address)(adr_impl + 1);
1273       }
1274 
1275       return (address)end_of_nonstatic_oop_maps();
1276     } else {
1277       return NULL;
1278     }
1279   }
1280 
1281   address adr_value_fields_klasses() const {
<span class="line-modified">1282     if (has_inline_fields()) {</span>
1283       address adr_fing = adr_fingerprint();
1284       if (adr_fing != NULL) {
1285         return adr_fingerprint() + sizeof(u8);
1286       }
1287 
1288       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1289       if (adr_host != NULL) {
1290         return (address)(adr_host + 1);
1291       }
1292 
1293       Klass* volatile* adr_impl = adr_implementor();
1294       if (adr_impl != NULL) {
1295         return (address)(adr_impl + 1);
1296       }
1297 
1298       return (address)end_of_nonstatic_oop_maps();
1299     } else {
1300       return NULL;
1301     }
1302   }
1303 
1304   Klass* get_value_field_klass(int idx) const {
<span class="line-modified">1305     assert(has_inline_fields(), &quot;Sanity checking&quot;);</span>
1306     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];
1307     assert(k != NULL, &quot;Should always be set before being read&quot;);
<span class="line-modified">1308     assert(k-&gt;is_value(), &quot;Must be a inline type&quot;);</span>
1309     return k;
1310   }
1311 
1312   Klass* get_value_field_klass_or_null(int idx) const {
<span class="line-modified">1313     assert(has_inline_fields(), &quot;Sanity checking&quot;);</span>
1314     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];
<span class="line-modified">1315     assert(k == NULL || k-&gt;is_value(), &quot;Must be a inline type&quot;);</span>
1316     return k;
1317   }
1318 
1319   void set_value_field_klass(int idx, Klass* k) {
<span class="line-modified">1320     assert(has_inline_fields(), &quot;Sanity checking&quot;);</span>
1321     assert(k != NULL, &quot;Should not be set to NULL&quot;);
1322     assert(((Klass**)adr_value_fields_klasses())[idx] == NULL, &quot;Should not be set twice&quot;);
1323     ((Klass**)adr_value_fields_klasses())[idx] = k;
1324   }
1325 
1326   // Use this to return the size of an instance in heap words:
1327   virtual int size_helper() const {
1328     return layout_helper_to_size_helper(layout_helper());
1329   }
1330 
1331   // This bit is initialized in classFileParser.cpp.
1332   // It is false under any of the following conditions:
1333   //  - the class is abstract (including any interface)
1334   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1335   //  - the class size is larger than FastAllocateSizeLimit
1336   //  - the class is java/lang/Class, which cannot be allocated directly
1337   bool can_be_fastpath_allocated() const {
1338     return !layout_helper_needs_slow_path(layout_helper());
1339   }
1340 
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayOop.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
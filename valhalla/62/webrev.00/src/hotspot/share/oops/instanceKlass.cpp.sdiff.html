<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 359 
 360   if (log_is_enabled(Trace, class, nestmates)) {
 361     ResourceMark rm(THREAD);
 362     log_trace(class, nestmates)(&quot;Class %s does %shave nestmate access to %s&quot;,
 363                                 this-&gt;external_name(),
 364                                 access ? &quot;&quot; : &quot;NOT &quot;,
 365                                 k-&gt;external_name());
 366   }
 367 
 368   return access;
 369 }
 370 
 371 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 372   const int size = InstanceKlass::size(parser.vtable_size(),
 373                                        parser.itable_size(),
 374                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 375                                        parser.is_interface(),
 376                                        parser.is_unsafe_anonymous(),
 377                                        should_store_fingerprint(parser.is_unsafe_anonymous()),
 378                                        parser.has_flattenable_fields() ? parser.java_fields_count() : 0,
<span class="line-modified"> 379                                        parser.is_value_type());</span>
 380 
 381   const Symbol* const class_name = parser.class_name();
 382   assert(class_name != NULL, &quot;invariant&quot;);
 383   ClassLoaderData* loader_data = parser.loader_data();
 384   assert(loader_data != NULL, &quot;invariant&quot;);
 385 
 386   InstanceKlass* ik;
 387 
 388   // Allocation
 389   if (REF_NONE == parser.reference_type()) {
 390     if (class_name == vmSymbols::java_lang_Class()) {
 391       // mirror
 392       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
 393     } else if (is_class_loader(class_name, parser)) {
 394       // class loader
 395       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
<span class="line-modified"> 396     } else if (parser.is_value_type()) {</span>
<span class="line-modified"> 397       // value type</span>
 398       ik = new (loader_data, size, THREAD) ValueKlass(parser);
 399     } else {
 400       // normal
 401       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other);
 402     }
 403   } else {
 404     // reference
 405     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 406   }
 407 
 408   // Check for pending exception before adding to the loader data and incrementing
 409   // class count.  Can get OOM here.
 410   if (HAS_PENDING_EXCEPTION) {
 411     return NULL;
 412   }
 413 
 414 #ifdef ASSERT
 415   assert(ik-&gt;size() == size, &quot;&quot;);
 416   ik-&gt;bounds_check((address) ik-&gt;start_of_vtable(), false, size);
 417   ik-&gt;bounds_check((address) ik-&gt;start_of_itable(), false, size);
</pre>
<hr />
<pre>
 471   _nest_members(NULL),
 472   _nest_host_index(0),
 473   _nest_host(NULL),
 474   _record_components(NULL),
 475   _static_field_size(parser.static_field_size()),
 476   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 477   _itable_len(parser.itable_size()),
 478   _init_thread(NULL),
 479   _init_state(allocated),
 480   _reference_type(parser.reference_type()),
 481   _value_field_klasses(NULL),
 482   _adr_valueklass_fixed_block(NULL)
 483 {
 484   set_vtable_length(parser.vtable_size());
 485   set_kind(kind);
 486   set_access_flags(parser.access_flags());
 487   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 488   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 489                                                     false));
 490     if (parser.has_flattenable_fields()) {
<span class="line-modified"> 491       set_has_value_fields();</span>
 492     }
 493     _java_fields_count = parser.java_fields_count();
 494 
 495     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
 496     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
 497     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
 498 
 499   if (Arguments::is_dumping_archive()) {
 500       SystemDictionaryShared::init_dumptime_info(this);
 501     }
 502 
 503   // Set biased locking bit for all instances of this class; it will be
 504   // cleared if revocation occurs too often for this type
 505   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 506     set_prototype_header(markWord::biased_locking_prototype());
 507   }
<span class="line-modified"> 508   if (has_value_fields()) {</span>
 509     _value_field_klasses = (const Klass**) adr_value_fields_klasses();
 510   }
 511 }
 512 
 513 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 514                                        Array&lt;Method*&gt;* methods) {
 515   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 516       !methods-&gt;is_shared()) {
 517     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 518       Method* method = methods-&gt;at(i);
 519       if (method == NULL) continue;  // maybe null if error processing
 520       // Only want to delete methods that are not executing for RedefineClasses.
 521       // The previous version will point to them so they&#39;re not totally dangling
 522       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 523       MetadataFactory::free_metadata(loader_data, method);
 524     }
 525     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 526   }
 527 }
 528 
</pre>
<hr />
<pre>
 845         &quot;class %s has interface %s as super class&quot;,
 846         external_name(),
 847         super_klass-&gt;external_name()
 848       );
 849       return false;
 850     }
 851 
 852     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 853     ik_super-&gt;link_class_impl(CHECK_false);
 854   }
 855 
 856   // link all interfaces implemented by this class before linking this class
 857   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 858   int num_interfaces = interfaces-&gt;length();
 859   for (int index = 0; index &lt; num_interfaces; index++) {
 860     InstanceKlass* interk = interfaces-&gt;at(index);
 861     interk-&gt;link_class_impl(CHECK_false);
 862   }
 863 
 864 
<span class="line-modified"> 865   // If a class declares a method that uses a value class as an argument</span>
<span class="line-modified"> 866   // type or return value type, this value class must be loaded during the</span>
<span class="line-modified"> 867   // linking of this class because size and properties of the value class</span>
<span class="line-modified"> 868   // must be known in order to be able to perform value type optimizations.</span>
 869   // The implementation below is an approximation of this rule, the code
 870   // iterates over all methods of the current class (including overridden
 871   // methods), not only the methods declared by this class. This
 872   // approximation makes the code simpler, and doesn&#39;t change the semantic
 873   // because classes declaring methods overridden by the current class are
 874   // linked (and have performed their own pre-loading) before the linking
 875   // of the current class.
<span class="line-removed"> 876   // This is also the moment to detect potential mismatch between the</span>
<span class="line-removed"> 877   // ValueTypes attribute and the kind of the class effectively loaded.</span>
 878 
 879 
 880   // Note:
<span class="line-modified"> 881   // Value class types used for flattenable fields are loaded during</span>
 882   // the loading phase (see ClassFileParser::post_process_parsed_stream()).
<span class="line-modified"> 883   // Value class types used as element types for array creation</span>
 884   // are not pre-loaded. Their loading is triggered by either anewarray
 885   // or multianewarray bytecodes.
 886 
 887   // Could it be possible to do the following processing only if the
<span class="line-modified"> 888   // class uses value types?</span>
 889   {
 890     ResourceMark rm(THREAD);
 891     for (int i = 0; i &lt; methods()-&gt;length(); i++) {
 892       Method* m = methods()-&gt;at(i);
 893       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {
 894         if (ss.is_reference()) {
 895           if (ss.is_array()) {
 896             ss.skip_array_prefix();
 897           }
 898           if (ss.type() == T_VALUETYPE) {
 899             Symbol* symb = ss.as_symbol();
 900 
 901             oop loader = class_loader();
 902             oop protection_domain = this-&gt;protection_domain();
 903             Klass* klass = SystemDictionary::resolve_or_fail(symb,
 904                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,
 905                                                              CHECK_false);
 906             if (klass == NULL) {
 907               THROW_(vmSymbols::java_lang_LinkageError(), false);
 908             }
</pre>
<hr />
<pre>
2709 
2710 #if INCLUDE_JVMTI
2711   // Deallocate breakpoint records
2712   if (breakpoints() != 0x0) {
2713     methods_do(clear_all_breakpoints);
2714     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2715   }
2716 
2717   // deallocate the cached class file
2718   if (_cached_class_file != NULL) {
2719     os::free(_cached_class_file);
2720     _cached_class_file = NULL;
2721   }
2722 #endif
2723 
2724   // Decrement symbol reference counts associated with the unloaded class.
2725   if (_name != NULL) _name-&gt;decrement_refcount();
2726   // unreference array name derived from this class name (arrays of an unloaded
2727   // class can&#39;t be referenced anymore).
2728   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
<span class="line-modified">2729   if (_value_types != NULL) {</span>
<span class="line-modified">2730     for (int i = 0; i &lt; _value_types-&gt;length(); i++) {</span>
<span class="line-modified">2731       Symbol* s = _value_types-&gt;at(i)._class_name;</span>
2732       if (s != NULL) {
2733         s-&gt;decrement_refcount();
2734       }
2735     }
2736   }
2737   FREE_C_HEAP_ARRAY(char, _source_debug_extension);
2738 }
2739 
2740 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2741   if (array == NULL) {
2742     _source_debug_extension = NULL;
2743   } else {
2744     // Adding one to the attribute length in order to store a null terminator
2745     // character could cause an overflow because the attribute length is
2746     // already coded with an u4 in the classfile, but in practice, it&#39;s
2747     // unlikely to happen.
2748     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
2749     char* sde = NEW_C_HEAP_ARRAY(char, (length + 1), mtClass);
2750     for (int i = 0; i &lt; length; i++) {
2751       sde[i] = array[i];
</pre>
</td>
<td>
<hr />
<pre>
 359 
 360   if (log_is_enabled(Trace, class, nestmates)) {
 361     ResourceMark rm(THREAD);
 362     log_trace(class, nestmates)(&quot;Class %s does %shave nestmate access to %s&quot;,
 363                                 this-&gt;external_name(),
 364                                 access ? &quot;&quot; : &quot;NOT &quot;,
 365                                 k-&gt;external_name());
 366   }
 367 
 368   return access;
 369 }
 370 
 371 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 372   const int size = InstanceKlass::size(parser.vtable_size(),
 373                                        parser.itable_size(),
 374                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 375                                        parser.is_interface(),
 376                                        parser.is_unsafe_anonymous(),
 377                                        should_store_fingerprint(parser.is_unsafe_anonymous()),
 378                                        parser.has_flattenable_fields() ? parser.java_fields_count() : 0,
<span class="line-modified"> 379                                        parser.is_inline_type());</span>
 380 
 381   const Symbol* const class_name = parser.class_name();
 382   assert(class_name != NULL, &quot;invariant&quot;);
 383   ClassLoaderData* loader_data = parser.loader_data();
 384   assert(loader_data != NULL, &quot;invariant&quot;);
 385 
 386   InstanceKlass* ik;
 387 
 388   // Allocation
 389   if (REF_NONE == parser.reference_type()) {
 390     if (class_name == vmSymbols::java_lang_Class()) {
 391       // mirror
 392       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
 393     } else if (is_class_loader(class_name, parser)) {
 394       // class loader
 395       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
<span class="line-modified"> 396     } else if (parser.is_inline_type()) {</span>
<span class="line-modified"> 397       // inline type</span>
 398       ik = new (loader_data, size, THREAD) ValueKlass(parser);
 399     } else {
 400       // normal
 401       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other);
 402     }
 403   } else {
 404     // reference
 405     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 406   }
 407 
 408   // Check for pending exception before adding to the loader data and incrementing
 409   // class count.  Can get OOM here.
 410   if (HAS_PENDING_EXCEPTION) {
 411     return NULL;
 412   }
 413 
 414 #ifdef ASSERT
 415   assert(ik-&gt;size() == size, &quot;&quot;);
 416   ik-&gt;bounds_check((address) ik-&gt;start_of_vtable(), false, size);
 417   ik-&gt;bounds_check((address) ik-&gt;start_of_itable(), false, size);
</pre>
<hr />
<pre>
 471   _nest_members(NULL),
 472   _nest_host_index(0),
 473   _nest_host(NULL),
 474   _record_components(NULL),
 475   _static_field_size(parser.static_field_size()),
 476   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 477   _itable_len(parser.itable_size()),
 478   _init_thread(NULL),
 479   _init_state(allocated),
 480   _reference_type(parser.reference_type()),
 481   _value_field_klasses(NULL),
 482   _adr_valueklass_fixed_block(NULL)
 483 {
 484   set_vtable_length(parser.vtable_size());
 485   set_kind(kind);
 486   set_access_flags(parser.access_flags());
 487   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 488   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 489                                                     false));
 490     if (parser.has_flattenable_fields()) {
<span class="line-modified"> 491       set_has_inline_fields();</span>
 492     }
 493     _java_fields_count = parser.java_fields_count();
 494 
 495     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
 496     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
 497     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
 498 
 499   if (Arguments::is_dumping_archive()) {
 500       SystemDictionaryShared::init_dumptime_info(this);
 501     }
 502 
 503   // Set biased locking bit for all instances of this class; it will be
 504   // cleared if revocation occurs too often for this type
 505   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 506     set_prototype_header(markWord::biased_locking_prototype());
 507   }
<span class="line-modified"> 508   if (has_inline_fields()) {</span>
 509     _value_field_klasses = (const Klass**) adr_value_fields_klasses();
 510   }
 511 }
 512 
 513 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 514                                        Array&lt;Method*&gt;* methods) {
 515   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 516       !methods-&gt;is_shared()) {
 517     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 518       Method* method = methods-&gt;at(i);
 519       if (method == NULL) continue;  // maybe null if error processing
 520       // Only want to delete methods that are not executing for RedefineClasses.
 521       // The previous version will point to them so they&#39;re not totally dangling
 522       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 523       MetadataFactory::free_metadata(loader_data, method);
 524     }
 525     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 526   }
 527 }
 528 
</pre>
<hr />
<pre>
 845         &quot;class %s has interface %s as super class&quot;,
 846         external_name(),
 847         super_klass-&gt;external_name()
 848       );
 849       return false;
 850     }
 851 
 852     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 853     ik_super-&gt;link_class_impl(CHECK_false);
 854   }
 855 
 856   // link all interfaces implemented by this class before linking this class
 857   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 858   int num_interfaces = interfaces-&gt;length();
 859   for (int index = 0; index &lt; num_interfaces; index++) {
 860     InstanceKlass* interk = interfaces-&gt;at(index);
 861     interk-&gt;link_class_impl(CHECK_false);
 862   }
 863 
 864 
<span class="line-modified"> 865   // If a class declares a method that uses an inline class as an argument</span>
<span class="line-modified"> 866   // type or return inline type, this inline class must be loaded during the</span>
<span class="line-modified"> 867   // linking of this class because size and properties of the inline class</span>
<span class="line-modified"> 868   // must be known in order to be able to perform inline type optimizations.</span>
 869   // The implementation below is an approximation of this rule, the code
 870   // iterates over all methods of the current class (including overridden
 871   // methods), not only the methods declared by this class. This
 872   // approximation makes the code simpler, and doesn&#39;t change the semantic
 873   // because classes declaring methods overridden by the current class are
 874   // linked (and have performed their own pre-loading) before the linking
 875   // of the current class.


 876 
 877 
 878   // Note:
<span class="line-modified"> 879   // Inline class types used for flattenable fields are loaded during</span>
 880   // the loading phase (see ClassFileParser::post_process_parsed_stream()).
<span class="line-modified"> 881   // Inline class types used as element types for array creation</span>
 882   // are not pre-loaded. Their loading is triggered by either anewarray
 883   // or multianewarray bytecodes.
 884 
 885   // Could it be possible to do the following processing only if the
<span class="line-modified"> 886   // class uses inline types?</span>
 887   {
 888     ResourceMark rm(THREAD);
 889     for (int i = 0; i &lt; methods()-&gt;length(); i++) {
 890       Method* m = methods()-&gt;at(i);
 891       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {
 892         if (ss.is_reference()) {
 893           if (ss.is_array()) {
 894             ss.skip_array_prefix();
 895           }
 896           if (ss.type() == T_VALUETYPE) {
 897             Symbol* symb = ss.as_symbol();
 898 
 899             oop loader = class_loader();
 900             oop protection_domain = this-&gt;protection_domain();
 901             Klass* klass = SystemDictionary::resolve_or_fail(symb,
 902                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,
 903                                                              CHECK_false);
 904             if (klass == NULL) {
 905               THROW_(vmSymbols::java_lang_LinkageError(), false);
 906             }
</pre>
<hr />
<pre>
2707 
2708 #if INCLUDE_JVMTI
2709   // Deallocate breakpoint records
2710   if (breakpoints() != 0x0) {
2711     methods_do(clear_all_breakpoints);
2712     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2713   }
2714 
2715   // deallocate the cached class file
2716   if (_cached_class_file != NULL) {
2717     os::free(_cached_class_file);
2718     _cached_class_file = NULL;
2719   }
2720 #endif
2721 
2722   // Decrement symbol reference counts associated with the unloaded class.
2723   if (_name != NULL) _name-&gt;decrement_refcount();
2724   // unreference array name derived from this class name (arrays of an unloaded
2725   // class can&#39;t be referenced anymore).
2726   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
<span class="line-modified">2727   if (_inline_types != NULL) {</span>
<span class="line-modified">2728     for (int i = 0; i &lt; _inline_types-&gt;length(); i++) {</span>
<span class="line-modified">2729       Symbol* s = _inline_types-&gt;at(i)._class_name;</span>
2730       if (s != NULL) {
2731         s-&gt;decrement_refcount();
2732       }
2733     }
2734   }
2735   FREE_C_HEAP_ARRAY(char, _source_debug_extension);
2736 }
2737 
2738 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2739   if (array == NULL) {
2740     _source_debug_extension = NULL;
2741   } else {
2742     // Adding one to the attribute length in order to store a null terminator
2743     // character could cause an overflow because the attribute length is
2744     // already coded with an u4 in the classfile, but in practice, it&#39;s
2745     // unlikely to happen.
2746     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
2747     char* sde = NEW_C_HEAP_ARRAY(char, (length + 1), mtClass);
2748     for (int i = 0; i &lt; length; i++) {
2749       sde[i] = array[i];
</pre>
</td>
</tr>
</table>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
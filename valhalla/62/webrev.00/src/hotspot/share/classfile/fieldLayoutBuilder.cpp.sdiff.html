<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/fieldLayoutBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/fieldLayoutBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 501       break;
 502     }
 503     case LayoutRawBlock::EMPTY:
 504       output-&gt;print_cr(&quot; @%d %d/1 %s&quot;,
 505                        b-&gt;offset(),
 506                        b-&gt;size(),
 507                        &quot;EMPTY&quot;);
 508       break;
 509     case LayoutRawBlock::PADDING:
 510       output-&gt;print_cr(&quot; @%d %d/1 %s&quot;,
 511                        b-&gt;offset(),
 512                        b-&gt;size(),
 513                        &quot;PADDING&quot;);
 514       break;
 515     }
 516     b = b-&gt;next_block();
 517   }
 518 }
 519 
 520 FieldLayoutBuilder::FieldLayoutBuilder(const Symbol* classname, const InstanceKlass* super_klass, ConstantPool* constant_pool,
<span class="line-modified"> 521                                        Array&lt;u2&gt;* fields, bool is_contended, bool is_value_type, ClassLoaderData* class_loader_data,</span>
 522                                        Handle protection_domain, FieldLayoutInfo* info) :
 523   _classname(classname),
 524   _super_klass(super_klass),
 525   _constant_pool(constant_pool),
 526   _fields(fields),
 527   _info(info),
 528   _root_group(NULL),
 529   _contended_groups(GrowableArray&lt;FieldGroup*&gt;(8)),
 530   _static_fields(NULL),
 531   _layout(NULL),
 532   _static_layout(NULL),
 533   _class_loader_data(class_loader_data),
 534   _protection_domain(protection_domain),
 535   _nonstatic_oopmap_count(0),
 536   _alignment(-1),
 537   _first_field_offset(-1),
 538   _exact_size_in_bytes(-1),
 539   _has_nonstatic_fields(false),
 540   _is_contended(is_contended),
<span class="line-modified"> 541   _is_value_type(is_value_type),</span>
<span class="line-modified"> 542   _has_flattening_information(is_value_type),</span>
 543   _has_nonatomic_values(false),
 544   _atomic_field_count(0)
 545  {}
 546 
 547 FieldGroup* FieldLayoutBuilder::get_or_create_contended_group(int g) {
 548   assert(g &gt; 0, &quot;must only be called for named contended groups&quot;);
 549   FieldGroup* fg = NULL;
 550   for (int i = 0; i &lt; _contended_groups.length(); i++) {
 551     fg = _contended_groups.at(i);
 552     if (fg-&gt;contended_group() == g) return fg;
 553   }
 554   fg = new FieldGroup(g);
 555   _contended_groups.append(fg);
 556   return fg;
 557 }
 558 
 559 void FieldLayoutBuilder::prologue() {
 560   _layout = new FieldLayout(_fields, _constant_pool);
 561   const InstanceKlass* super_klass = _super_klass;
 562   _layout-&gt;initialize_instance_layout(super_klass);
</pre>
<hr />
<pre>
 661   _static_fields-&gt;sort_by_size();
 662   if (!_contended_groups.is_empty()) {
 663     for (int i = 0; i &lt; _contended_groups.length(); i++) {
 664       _contended_groups.at(i)-&gt;sort_by_size();
 665     }
 666   }
 667 }
 668 
 669 /* Field sorting for inline classes:
 670  *   - because inline classes are immutable, the @Contended annotation is ignored
 671  *     when computing their layout (with only read operation, there&#39;s no false
 672  *     sharing issue)
 673  *   - this method also records the alignment of the field with the most
 674  *     constraining alignment, this value is then used as the alignment
 675  *     constraint when flattening this inline type into another container
 676  *   - field flattening decisions are taken in this method (those decisions are
 677  *     currently only based in the size of the fields to be flattened, the size
 678  *     of the resulting instance is not considered)
 679  */
 680 void FieldLayoutBuilder::inline_class_field_sorting(TRAPS) {
<span class="line-modified"> 681   assert(_is_value_type, &quot;Should only be used for inline classes&quot;);</span>
 682   int alignment = 1;
 683   for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {
 684     FieldGroup* group = NULL;
 685     int field_alignment = 1;
 686     if (fs.access_flags().is_static()) {
 687       group = _static_fields;
 688     } else {
 689       _has_nonstatic_fields = true;
 690       _atomic_field_count++;  // we might decrement this
 691       group = _root_group;
 692     }
 693     assert(group != NULL, &quot;invariant&quot;);
 694     BasicType type = Signature::basic_type(fs.signature());
 695     switch(type) {
 696     case T_BYTE:
 697     case T_CHAR:
 698     case T_DOUBLE:
 699     case T_FLOAT:
 700     case T_INT:
 701     case T_LONG:
</pre>
<hr />
<pre>
 991       }
 992     }
 993   }
 994 
 995   nonstatic_oop_maps-&gt;compact();
 996 
 997   int instance_end = align_up(_layout-&gt;last_block()-&gt;offset(), wordSize);
 998   int static_fields_end = align_up(_static_layout-&gt;last_block()-&gt;offset(), wordSize);
 999   int static_fields_size = (static_fields_end -
1000       InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
1001   int nonstatic_field_end = align_up(_layout-&gt;last_block()-&gt;offset(), heapOopSize);
1002 
1003   // Pass back information needed for InstanceKlass creation
1004 
1005   _info-&gt;oop_map_blocks = nonstatic_oop_maps;
1006   _info-&gt;_instance_size = align_object_size(instance_end / wordSize);
1007   _info-&gt;_static_field_size = static_fields_size;
1008   _info-&gt;_nonstatic_field_size = (nonstatic_field_end - instanceOopDesc::base_offset_in_bytes()) / heapOopSize;
1009   _info-&gt;_has_nonstatic_fields = _has_nonstatic_fields;
1010 
<span class="line-modified">1011   // A value type is naturally atomic if it has just one field, and</span>
1012   // that field is simple enough.
<span class="line-modified">1013   _info-&gt;_is_naturally_atomic = (_is_value_type &amp;&amp;</span>
1014                                  (_atomic_field_count &lt;= 1) &amp;&amp;
1015                                  !_has_nonatomic_values &amp;&amp;
1016                                  _contended_groups.is_empty());
1017   // This may be too restrictive, since if all the fields fit in 64
1018   // bits we could make the decision to align instances of this class
1019   // to 64-bit boundaries, and load and store them as single words.
1020   // And on machines which supported larger atomics we could similarly
1021   // allow larger values to be atomic, if properly aligned.
1022 
1023 
1024   if (PrintFieldLayout) {
1025     ResourceMark rm;
1026     tty-&gt;print_cr(&quot;Layout of class %s&quot;, _classname-&gt;as_C_string());
1027     tty-&gt;print_cr(&quot;Instance fields:&quot;);
1028     _layout-&gt;print(tty, false, _super_klass);
1029     tty-&gt;print_cr(&quot;Static fields:&quot;);
1030     _static_layout-&gt;print(tty, true, NULL);
1031     tty-&gt;print_cr(&quot;Instance size = %d bytes&quot;, _info-&gt;_instance_size * wordSize);
<span class="line-modified">1032     if (_is_value_type) {</span>
1033       tty-&gt;print_cr(&quot;First field offset = %d&quot;, _first_field_offset);
1034       tty-&gt;print_cr(&quot;Alignment = %d bytes&quot;, _alignment);
1035       tty-&gt;print_cr(&quot;Exact size = %d bytes&quot;, _exact_size_in_bytes);
1036     }
1037     tty-&gt;print_cr(&quot;---&quot;);
1038   }
1039 }
1040 
1041 void FieldLayoutBuilder::build_layout(TRAPS) {
1042   if (_classname == vmSymbols::java_lang_ref_Reference()) {
1043     compute_java_lang_ref_Reference_layout();
1044   } else if (_classname == vmSymbols::java_lang_Boolean() ||
1045              _classname == vmSymbols::java_lang_Character() ||
1046              _classname == vmSymbols::java_lang_Float() ||
1047              _classname == vmSymbols::java_lang_Double() ||
1048              _classname == vmSymbols::java_lang_Byte() ||
1049              _classname == vmSymbols::java_lang_Short() ||
1050              _classname == vmSymbols::java_lang_Integer() ||
1051              _classname == vmSymbols::java_lang_Long()) {
1052       compute_boxing_class_layout();
<span class="line-modified">1053   } else if (_is_value_type) {</span>
1054     compute_inline_class_layout(CHECK);
1055   } else {
1056     compute_regular_layout();
1057   }
1058 }
</pre>
</td>
<td>
<hr />
<pre>
 501       break;
 502     }
 503     case LayoutRawBlock::EMPTY:
 504       output-&gt;print_cr(&quot; @%d %d/1 %s&quot;,
 505                        b-&gt;offset(),
 506                        b-&gt;size(),
 507                        &quot;EMPTY&quot;);
 508       break;
 509     case LayoutRawBlock::PADDING:
 510       output-&gt;print_cr(&quot; @%d %d/1 %s&quot;,
 511                        b-&gt;offset(),
 512                        b-&gt;size(),
 513                        &quot;PADDING&quot;);
 514       break;
 515     }
 516     b = b-&gt;next_block();
 517   }
 518 }
 519 
 520 FieldLayoutBuilder::FieldLayoutBuilder(const Symbol* classname, const InstanceKlass* super_klass, ConstantPool* constant_pool,
<span class="line-modified"> 521                                        Array&lt;u2&gt;* fields, bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,</span>
 522                                        Handle protection_domain, FieldLayoutInfo* info) :
 523   _classname(classname),
 524   _super_klass(super_klass),
 525   _constant_pool(constant_pool),
 526   _fields(fields),
 527   _info(info),
 528   _root_group(NULL),
 529   _contended_groups(GrowableArray&lt;FieldGroup*&gt;(8)),
 530   _static_fields(NULL),
 531   _layout(NULL),
 532   _static_layout(NULL),
 533   _class_loader_data(class_loader_data),
 534   _protection_domain(protection_domain),
 535   _nonstatic_oopmap_count(0),
 536   _alignment(-1),
 537   _first_field_offset(-1),
 538   _exact_size_in_bytes(-1),
 539   _has_nonstatic_fields(false),
 540   _is_contended(is_contended),
<span class="line-modified"> 541   _is_inline_type(is_inline_type),</span>
<span class="line-modified"> 542   _has_flattening_information(is_inline_type),</span>
 543   _has_nonatomic_values(false),
 544   _atomic_field_count(0)
 545  {}
 546 
 547 FieldGroup* FieldLayoutBuilder::get_or_create_contended_group(int g) {
 548   assert(g &gt; 0, &quot;must only be called for named contended groups&quot;);
 549   FieldGroup* fg = NULL;
 550   for (int i = 0; i &lt; _contended_groups.length(); i++) {
 551     fg = _contended_groups.at(i);
 552     if (fg-&gt;contended_group() == g) return fg;
 553   }
 554   fg = new FieldGroup(g);
 555   _contended_groups.append(fg);
 556   return fg;
 557 }
 558 
 559 void FieldLayoutBuilder::prologue() {
 560   _layout = new FieldLayout(_fields, _constant_pool);
 561   const InstanceKlass* super_klass = _super_klass;
 562   _layout-&gt;initialize_instance_layout(super_klass);
</pre>
<hr />
<pre>
 661   _static_fields-&gt;sort_by_size();
 662   if (!_contended_groups.is_empty()) {
 663     for (int i = 0; i &lt; _contended_groups.length(); i++) {
 664       _contended_groups.at(i)-&gt;sort_by_size();
 665     }
 666   }
 667 }
 668 
 669 /* Field sorting for inline classes:
 670  *   - because inline classes are immutable, the @Contended annotation is ignored
 671  *     when computing their layout (with only read operation, there&#39;s no false
 672  *     sharing issue)
 673  *   - this method also records the alignment of the field with the most
 674  *     constraining alignment, this value is then used as the alignment
 675  *     constraint when flattening this inline type into another container
 676  *   - field flattening decisions are taken in this method (those decisions are
 677  *     currently only based in the size of the fields to be flattened, the size
 678  *     of the resulting instance is not considered)
 679  */
 680 void FieldLayoutBuilder::inline_class_field_sorting(TRAPS) {
<span class="line-modified"> 681   assert(_is_inline_type, &quot;Should only be used for inline classes&quot;);</span>
 682   int alignment = 1;
 683   for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {
 684     FieldGroup* group = NULL;
 685     int field_alignment = 1;
 686     if (fs.access_flags().is_static()) {
 687       group = _static_fields;
 688     } else {
 689       _has_nonstatic_fields = true;
 690       _atomic_field_count++;  // we might decrement this
 691       group = _root_group;
 692     }
 693     assert(group != NULL, &quot;invariant&quot;);
 694     BasicType type = Signature::basic_type(fs.signature());
 695     switch(type) {
 696     case T_BYTE:
 697     case T_CHAR:
 698     case T_DOUBLE:
 699     case T_FLOAT:
 700     case T_INT:
 701     case T_LONG:
</pre>
<hr />
<pre>
 991       }
 992     }
 993   }
 994 
 995   nonstatic_oop_maps-&gt;compact();
 996 
 997   int instance_end = align_up(_layout-&gt;last_block()-&gt;offset(), wordSize);
 998   int static_fields_end = align_up(_static_layout-&gt;last_block()-&gt;offset(), wordSize);
 999   int static_fields_size = (static_fields_end -
1000       InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
1001   int nonstatic_field_end = align_up(_layout-&gt;last_block()-&gt;offset(), heapOopSize);
1002 
1003   // Pass back information needed for InstanceKlass creation
1004 
1005   _info-&gt;oop_map_blocks = nonstatic_oop_maps;
1006   _info-&gt;_instance_size = align_object_size(instance_end / wordSize);
1007   _info-&gt;_static_field_size = static_fields_size;
1008   _info-&gt;_nonstatic_field_size = (nonstatic_field_end - instanceOopDesc::base_offset_in_bytes()) / heapOopSize;
1009   _info-&gt;_has_nonstatic_fields = _has_nonstatic_fields;
1010 
<span class="line-modified">1011   // An inline type is naturally atomic if it has just one field, and</span>
1012   // that field is simple enough.
<span class="line-modified">1013   _info-&gt;_is_naturally_atomic = (_is_inline_type &amp;&amp;</span>
1014                                  (_atomic_field_count &lt;= 1) &amp;&amp;
1015                                  !_has_nonatomic_values &amp;&amp;
1016                                  _contended_groups.is_empty());
1017   // This may be too restrictive, since if all the fields fit in 64
1018   // bits we could make the decision to align instances of this class
1019   // to 64-bit boundaries, and load and store them as single words.
1020   // And on machines which supported larger atomics we could similarly
1021   // allow larger values to be atomic, if properly aligned.
1022 
1023 
1024   if (PrintFieldLayout) {
1025     ResourceMark rm;
1026     tty-&gt;print_cr(&quot;Layout of class %s&quot;, _classname-&gt;as_C_string());
1027     tty-&gt;print_cr(&quot;Instance fields:&quot;);
1028     _layout-&gt;print(tty, false, _super_klass);
1029     tty-&gt;print_cr(&quot;Static fields:&quot;);
1030     _static_layout-&gt;print(tty, true, NULL);
1031     tty-&gt;print_cr(&quot;Instance size = %d bytes&quot;, _info-&gt;_instance_size * wordSize);
<span class="line-modified">1032     if (_is_inline_type) {</span>
1033       tty-&gt;print_cr(&quot;First field offset = %d&quot;, _first_field_offset);
1034       tty-&gt;print_cr(&quot;Alignment = %d bytes&quot;, _alignment);
1035       tty-&gt;print_cr(&quot;Exact size = %d bytes&quot;, _exact_size_in_bytes);
1036     }
1037     tty-&gt;print_cr(&quot;---&quot;);
1038   }
1039 }
1040 
1041 void FieldLayoutBuilder::build_layout(TRAPS) {
1042   if (_classname == vmSymbols::java_lang_ref_Reference()) {
1043     compute_java_lang_ref_Reference_layout();
1044   } else if (_classname == vmSymbols::java_lang_Boolean() ||
1045              _classname == vmSymbols::java_lang_Character() ||
1046              _classname == vmSymbols::java_lang_Float() ||
1047              _classname == vmSymbols::java_lang_Double() ||
1048              _classname == vmSymbols::java_lang_Byte() ||
1049              _classname == vmSymbols::java_lang_Short() ||
1050              _classname == vmSymbols::java_lang_Integer() ||
1051              _classname == vmSymbols::java_lang_Long()) {
1052       compute_boxing_class_layout();
<span class="line-modified">1053   } else if (_is_inline_type) {</span>
1054     compute_inline_class_layout(CHECK);
1055   } else {
1056     compute_regular_layout();
1057   }
1058 }
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
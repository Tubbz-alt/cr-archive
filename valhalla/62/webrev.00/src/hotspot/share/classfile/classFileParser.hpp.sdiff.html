<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
184   u2 _sourcefile_index;
185   u2 _generic_signature_index;
186 
187   u2 _major_version;
188   u2 _minor_version;
189   u2 _this_class_index;
190   u2 _super_class_index;
191   u2 _itfs_len;
192   u2 _java_fields_count;
193 
194   bool _need_verify;
195   bool _relax_verify;
196 
197   bool _has_nonstatic_concrete_methods;
198   bool _declares_nonstatic_concrete_methods;
199   bool _has_final_method;
200   bool _has_contended_fields;
201 
202   bool _has_flattenable_fields;
203   bool _has_nonstatic_fields;
<span class="line-modified">204   bool _is_empty_value;</span>
205   bool _is_naturally_atomic;
206   bool _is_declared_atomic;
207   bool _invalid_inline_super;   // if true, invalid super type for an inline type.
208   bool _invalid_identity_super; // if true, invalid super type for an identity type.
209   bool _implements_identityObject;
210   bool _has_injected_identityObject;
211 
212   // precomputed flags
213   bool _has_finalizer;
214   bool _has_empty_finalizer;
215   bool _has_vanilla_constructor;
216   int _max_bootstrap_specifier_index;  // detects BSS values
217 
218   void parse_stream(const ClassFileStream* const stream, TRAPS);
219 
220   void post_process_parsed_stream(const ClassFileStream* const stream,
221                                   ConstantPool* cp,
222                                   TRAPS);
223 
224   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
</pre>
<hr />
<pre>
260                         TRAPS);
261 
262   const InstanceKlass* parse_super_class(ConstantPool* const cp,
263                                          const int super_class_index,
264                                          const bool need_verify,
265                                          TRAPS);
266 
267   // Field parsing
268   void parse_field_attributes(const ClassFileStream* const cfs,
269                               u2 attributes_count,
270                               bool is_static,
271                               u2 signature_index,
272                               u2* const constantvalue_index_addr,
273                               bool* const is_synthetic_addr,
274                               u2* const generic_signature_index_addr,
275                               FieldAnnotationCollector* parsed_annotations,
276                               TRAPS);
277 
278   void parse_fields(const ClassFileStream* const cfs,
279                     bool is_interface,
<span class="line-modified">280                     bool is_value_type,</span>
281                     FieldAllocationCount* const fac,
282                     ConstantPool* cp,
283                     const int cp_size,
284                     u2* const java_fields_count_ptr,
285                     TRAPS);
286 
287   // Method parsing
288   Method* parse_method(const ClassFileStream* const cfs,
289                        bool is_interface,
<span class="line-modified">290                        bool is_value_type,</span>
291                        const ConstantPool* cp,
292                        AccessFlags* const promoted_flags,
293                        TRAPS);
294 
295   void parse_methods(const ClassFileStream* const cfs,
296                      bool is_interface,
<span class="line-modified">297                      bool is_value_type,</span>
298                      AccessFlags* const promoted_flags,
299                      bool* const has_final_method,
300                      bool* const declares_nonstatic_concrete_methods,
301                      TRAPS);
302 
303   const unsafe_u2* parse_exception_table(const ClassFileStream* const stream,
304                                          u4 code_length,
305                                          u4 exception_table_length,
306                                          TRAPS);
307 
308   void parse_linenumber_table(u4 code_attribute_length,
309                               u4 code_length,
310                               CompressedLineNumberWriteStream**const write_stream,
311                               TRAPS);
312 
313   const unsafe_u2* parse_localvariable_table(const ClassFileStream* const cfs,
314                                              u4 code_length,
315                                              u2 max_locals,
316                                              u4 code_attribute_length,
317                                              u2* const localvariable_table_length,
</pre>
<hr />
<pre>
434   inline void guarantee_property(bool b,
435                                  const char* msg,
436                                  const char *name,
437                                  TRAPS) const {
438     if (!b) { classfile_parse_error(msg, name, CHECK); }
439   }
440 
441   inline void guarantee_property(bool b,
442                                  const char* msg,
443                                  int index,
444                                  const char *name,
445                                  TRAPS) const {
446     if (!b) { classfile_parse_error(msg, index, name, CHECK); }
447   }
448 
449   void throwIllegalSignature(const char* type,
450                              const Symbol* name,
451                              const Symbol* sig,
452                              TRAPS) const;
453 
<span class="line-modified">454   void throwValueTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-modified">455                                 const char* msg,</span>
<span class="line-modified">456                                 const Symbol* name = NULL,</span>
<span class="line-modified">457                                 const Symbol* sig  = NULL) const;</span>
458 
459   void verify_constantvalue(const ConstantPool* const cp,
460                             int constantvalue_index,
461                             int signature_index,
462                             TRAPS) const;
463 
464   void verify_legal_utf8(const unsigned char* buffer, int length, TRAPS) const;
465   void verify_legal_class_name(const Symbol* name, TRAPS) const;
466   void verify_legal_field_name(const Symbol* name, TRAPS) const;
467   void verify_legal_method_name(const Symbol* name, TRAPS) const;
468 
469   void verify_legal_field_signature(const Symbol* fieldname,
470                                     const Symbol* signature,
471                                     TRAPS) const;
472   int  verify_legal_method_signature(const Symbol* methodname,
473                                      const Symbol* signature,
474                                      TRAPS) const;
475 
476   void verify_legal_class_modifiers(jint flags, TRAPS) const;
477   void verify_legal_field_modifiers(jint flags,
478                                     bool is_interface,
<span class="line-modified">479                                     bool is_value_type,</span>
480                                     TRAPS) const;
481   void verify_legal_method_modifiers(jint flags,
482                                      bool is_interface,
<span class="line-modified">483                                      bool is_value_type,</span>
484                                      const Symbol* name,
485                                      TRAPS) const;
486 
487   const char* skip_over_field_signature(const char* signature,
488                                         bool void_ok,
489                                         unsigned int length,
490                                         TRAPS) const;
491 
492   bool has_cp_patch_at(int index) const {
493     assert(index &gt;= 0, &quot;oob&quot;);
494     return (_cp_patches != NULL
495             &amp;&amp; index &lt; _cp_patches-&gt;length()
496             &amp;&amp; _cp_patches-&gt;adr_at(index)-&gt;not_null());
497   }
498 
499   Handle cp_patch_at(int index) const {
500     assert(has_cp_patch_at(index), &quot;oob&quot;);
501     return _cp_patches-&gt;at(index);
502   }
503 
</pre>
<hr />
<pre>
542                                int runtime_visible_parameter_annotations_length,
543                                const u1* runtime_invisible_parameter_annotations,
544                                int runtime_invisible_parameter_annotations_length,
545                                const u1* runtime_visible_type_annotations,
546                                int runtime_visible_type_annotations_length,
547                                const u1* runtime_invisible_type_annotations,
548                                int runtime_invisible_type_annotations_length,
549                                const u1* annotation_default,
550                                int annotation_default_length,
551                                TRAPS);
552 
553   // lays out fields in class and returns the total oopmap count
554   void layout_fields(ConstantPool* cp,
555                      const FieldAllocationCount* fac,
556                      const ClassAnnotationCollector* parsed_annotations,
557                      FieldLayoutInfo* info,
558                      TRAPS);
559 
560    void update_class_name(Symbol* new_name);
561 
<span class="line-modified">562   // Check if the class file supports value types</span>
<span class="line-modified">563   bool supports_value_types() const;</span>
564 
565  public:
566   ClassFileParser(ClassFileStream* stream,
567                   Symbol* name,
568                   ClassLoaderData* loader_data,
569                   Handle protection_domain,
570                   const InstanceKlass* unsafe_anonymous_host,
571                   GrowableArray&lt;Handle&gt;* cp_patches,
572                   Publicity pub_level,
573                   TRAPS);
574 
575   ~ClassFileParser();
576 
577   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, TRAPS);
578 
579   const ClassFileStream* clone_stream() const;
580 
581   void set_klass_to_deallocate(InstanceKlass* klass);
582 
583   int static_field_size() const;
584   int total_oop_map_count() const;
585   jint layout_size() const;
586 
587   int vtable_size() const { return _vtable_size; }
588   int itable_size() const { return _itable_size; }
589 
590   u2 this_class_index() const { return _this_class_index; }
591 
592   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
593   bool is_interface() const { return _access_flags.is_interface(); }
<span class="line-modified">594   bool is_value_type() const { return _access_flags.is_value_type(); }</span>
595   bool is_value_capable_class() const;
596   bool has_flattenable_fields() const { return _has_flattenable_fields; }
597   bool invalid_inline_super() const { return _invalid_inline_super; }
598   void set_invalid_inline_super() { _invalid_inline_super = true; }
599   bool invalid_identity_super() const { return _invalid_identity_super; }
600   void set_invalid_identity_super() { _invalid_identity_super = true; }
601   bool is_invalid_super_for_inline_type();
602 
603   u2 java_fields_count() const { return _java_fields_count; }
604 
605   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
606   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
607   ClassLoaderData* loader_data() const { return _loader_data; }
608   const Symbol* class_name() const { return _class_name; }
609   const InstanceKlass* super_klass() const { return _super_klass; }
610 
611   ReferenceType reference_type() const { return _rt; }
612   AccessFlags access_flags() const { return _access_flags; }
613 
614   bool is_internal() const { return INTERNAL == _pub_level; }
</pre>
</td>
<td>
<hr />
<pre>
184   u2 _sourcefile_index;
185   u2 _generic_signature_index;
186 
187   u2 _major_version;
188   u2 _minor_version;
189   u2 _this_class_index;
190   u2 _super_class_index;
191   u2 _itfs_len;
192   u2 _java_fields_count;
193 
194   bool _need_verify;
195   bool _relax_verify;
196 
197   bool _has_nonstatic_concrete_methods;
198   bool _declares_nonstatic_concrete_methods;
199   bool _has_final_method;
200   bool _has_contended_fields;
201 
202   bool _has_flattenable_fields;
203   bool _has_nonstatic_fields;
<span class="line-modified">204   bool _is_empty_inline_type;</span>
205   bool _is_naturally_atomic;
206   bool _is_declared_atomic;
207   bool _invalid_inline_super;   // if true, invalid super type for an inline type.
208   bool _invalid_identity_super; // if true, invalid super type for an identity type.
209   bool _implements_identityObject;
210   bool _has_injected_identityObject;
211 
212   // precomputed flags
213   bool _has_finalizer;
214   bool _has_empty_finalizer;
215   bool _has_vanilla_constructor;
216   int _max_bootstrap_specifier_index;  // detects BSS values
217 
218   void parse_stream(const ClassFileStream* const stream, TRAPS);
219 
220   void post_process_parsed_stream(const ClassFileStream* const stream,
221                                   ConstantPool* cp,
222                                   TRAPS);
223 
224   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
</pre>
<hr />
<pre>
260                         TRAPS);
261 
262   const InstanceKlass* parse_super_class(ConstantPool* const cp,
263                                          const int super_class_index,
264                                          const bool need_verify,
265                                          TRAPS);
266 
267   // Field parsing
268   void parse_field_attributes(const ClassFileStream* const cfs,
269                               u2 attributes_count,
270                               bool is_static,
271                               u2 signature_index,
272                               u2* const constantvalue_index_addr,
273                               bool* const is_synthetic_addr,
274                               u2* const generic_signature_index_addr,
275                               FieldAnnotationCollector* parsed_annotations,
276                               TRAPS);
277 
278   void parse_fields(const ClassFileStream* const cfs,
279                     bool is_interface,
<span class="line-modified">280                     bool is_inline_type,</span>
281                     FieldAllocationCount* const fac,
282                     ConstantPool* cp,
283                     const int cp_size,
284                     u2* const java_fields_count_ptr,
285                     TRAPS);
286 
287   // Method parsing
288   Method* parse_method(const ClassFileStream* const cfs,
289                        bool is_interface,
<span class="line-modified">290                        bool is_inline_type,</span>
291                        const ConstantPool* cp,
292                        AccessFlags* const promoted_flags,
293                        TRAPS);
294 
295   void parse_methods(const ClassFileStream* const cfs,
296                      bool is_interface,
<span class="line-modified">297                      bool is_inline_type,</span>
298                      AccessFlags* const promoted_flags,
299                      bool* const has_final_method,
300                      bool* const declares_nonstatic_concrete_methods,
301                      TRAPS);
302 
303   const unsafe_u2* parse_exception_table(const ClassFileStream* const stream,
304                                          u4 code_length,
305                                          u4 exception_table_length,
306                                          TRAPS);
307 
308   void parse_linenumber_table(u4 code_attribute_length,
309                               u4 code_length,
310                               CompressedLineNumberWriteStream**const write_stream,
311                               TRAPS);
312 
313   const unsafe_u2* parse_localvariable_table(const ClassFileStream* const cfs,
314                                              u4 code_length,
315                                              u2 max_locals,
316                                              u4 code_attribute_length,
317                                              u2* const localvariable_table_length,
</pre>
<hr />
<pre>
434   inline void guarantee_property(bool b,
435                                  const char* msg,
436                                  const char *name,
437                                  TRAPS) const {
438     if (!b) { classfile_parse_error(msg, name, CHECK); }
439   }
440 
441   inline void guarantee_property(bool b,
442                                  const char* msg,
443                                  int index,
444                                  const char *name,
445                                  TRAPS) const {
446     if (!b) { classfile_parse_error(msg, index, name, CHECK); }
447   }
448 
449   void throwIllegalSignature(const char* type,
450                              const Symbol* name,
451                              const Symbol* sig,
452                              TRAPS) const;
453 
<span class="line-modified">454   void throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-modified">455                                  const char* msg,</span>
<span class="line-modified">456                                  const Symbol* name = NULL,</span>
<span class="line-modified">457                                  const Symbol* sig  = NULL) const;</span>
458 
459   void verify_constantvalue(const ConstantPool* const cp,
460                             int constantvalue_index,
461                             int signature_index,
462                             TRAPS) const;
463 
464   void verify_legal_utf8(const unsigned char* buffer, int length, TRAPS) const;
465   void verify_legal_class_name(const Symbol* name, TRAPS) const;
466   void verify_legal_field_name(const Symbol* name, TRAPS) const;
467   void verify_legal_method_name(const Symbol* name, TRAPS) const;
468 
469   void verify_legal_field_signature(const Symbol* fieldname,
470                                     const Symbol* signature,
471                                     TRAPS) const;
472   int  verify_legal_method_signature(const Symbol* methodname,
473                                      const Symbol* signature,
474                                      TRAPS) const;
475 
476   void verify_legal_class_modifiers(jint flags, TRAPS) const;
477   void verify_legal_field_modifiers(jint flags,
478                                     bool is_interface,
<span class="line-modified">479                                     bool is_inline_type,</span>
480                                     TRAPS) const;
481   void verify_legal_method_modifiers(jint flags,
482                                      bool is_interface,
<span class="line-modified">483                                      bool is_inline_type,</span>
484                                      const Symbol* name,
485                                      TRAPS) const;
486 
487   const char* skip_over_field_signature(const char* signature,
488                                         bool void_ok,
489                                         unsigned int length,
490                                         TRAPS) const;
491 
492   bool has_cp_patch_at(int index) const {
493     assert(index &gt;= 0, &quot;oob&quot;);
494     return (_cp_patches != NULL
495             &amp;&amp; index &lt; _cp_patches-&gt;length()
496             &amp;&amp; _cp_patches-&gt;adr_at(index)-&gt;not_null());
497   }
498 
499   Handle cp_patch_at(int index) const {
500     assert(has_cp_patch_at(index), &quot;oob&quot;);
501     return _cp_patches-&gt;at(index);
502   }
503 
</pre>
<hr />
<pre>
542                                int runtime_visible_parameter_annotations_length,
543                                const u1* runtime_invisible_parameter_annotations,
544                                int runtime_invisible_parameter_annotations_length,
545                                const u1* runtime_visible_type_annotations,
546                                int runtime_visible_type_annotations_length,
547                                const u1* runtime_invisible_type_annotations,
548                                int runtime_invisible_type_annotations_length,
549                                const u1* annotation_default,
550                                int annotation_default_length,
551                                TRAPS);
552 
553   // lays out fields in class and returns the total oopmap count
554   void layout_fields(ConstantPool* cp,
555                      const FieldAllocationCount* fac,
556                      const ClassAnnotationCollector* parsed_annotations,
557                      FieldLayoutInfo* info,
558                      TRAPS);
559 
560    void update_class_name(Symbol* new_name);
561 
<span class="line-modified">562   // Check if the class file supports inline types</span>
<span class="line-modified">563   bool supports_inline_types() const;</span>
564 
565  public:
566   ClassFileParser(ClassFileStream* stream,
567                   Symbol* name,
568                   ClassLoaderData* loader_data,
569                   Handle protection_domain,
570                   const InstanceKlass* unsafe_anonymous_host,
571                   GrowableArray&lt;Handle&gt;* cp_patches,
572                   Publicity pub_level,
573                   TRAPS);
574 
575   ~ClassFileParser();
576 
577   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, TRAPS);
578 
579   const ClassFileStream* clone_stream() const;
580 
581   void set_klass_to_deallocate(InstanceKlass* klass);
582 
583   int static_field_size() const;
584   int total_oop_map_count() const;
585   jint layout_size() const;
586 
587   int vtable_size() const { return _vtable_size; }
588   int itable_size() const { return _itable_size; }
589 
590   u2 this_class_index() const { return _this_class_index; }
591 
592   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
593   bool is_interface() const { return _access_flags.is_interface(); }
<span class="line-modified">594   bool is_inline_type() const { return _access_flags.is_inline_type(); }</span>
595   bool is_value_capable_class() const;
596   bool has_flattenable_fields() const { return _has_flattenable_fields; }
597   bool invalid_inline_super() const { return _invalid_inline_super; }
598   void set_invalid_inline_super() { _invalid_inline_super = true; }
599   bool invalid_identity_super() const { return _invalid_identity_super; }
600   void set_invalid_identity_super() { _invalid_identity_super = true; }
601   bool is_invalid_super_for_inline_type();
602 
603   u2 java_fields_count() const { return _java_fields_count; }
604 
605   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
606   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
607   ClassLoaderData* loader_data() const { return _loader_data; }
608   const Symbol* class_name() const { return _class_name; }
609   const InstanceKlass* super_klass() const { return _super_klass; }
610 
611   ReferenceType reference_type() const { return _rt; }
612   AccessFlags access_flags() const { return _access_flags; }
613 
614   bool is_internal() const { return INTERNAL == _pub_level; }
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
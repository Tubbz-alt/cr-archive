<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1590     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1591       count[i] = 0;
1592     }
1593   }
1594 
1595   FieldAllocationType update(bool is_static, BasicType type, bool is_flattenable) {
1596     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_flattenable);
1597     if (atype != BAD_ALLOCATION_TYPE) {
1598       // Make sure there is no overflow with injected fields.
1599       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1600       count[atype]++;
1601     }
1602     return atype;
1603   }
1604 };
1605 
1606 // Side-effects: populates the _fields, _fields_annotations,
1607 // _fields_type_annotations fields
1608 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1609                                    bool is_interface,
<span class="line-modified">1610                                    bool is_value_type,</span>
1611                                    FieldAllocationCount* const fac,
1612                                    ConstantPool* cp,
1613                                    const int cp_size,
1614                                    u2* const java_fields_count_ptr,
1615                                    TRAPS) {
1616 
1617   assert(cfs != NULL, &quot;invariant&quot;);
1618   assert(fac != NULL, &quot;invariant&quot;);
1619   assert(cp != NULL, &quot;invariant&quot;);
1620   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1621 
1622   assert(NULL == _fields, &quot;invariant&quot;);
1623   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1624   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1625 
1626   cfs-&gt;guarantee_more(2, CHECK);  // length
1627   const u2 length = cfs-&gt;get_u2_fast();
1628   *java_fields_count_ptr = length;
1629 
1630   int num_injected = 0;
1631   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1632                                                                   &amp;num_injected);
1633 
1634   // two more slots are required for inline classes:
1635   // one for the static field with a reference to the pre-allocated default value
1636   // one for the field the JVM injects when detecting an empty inline class
<span class="line-modified">1637   const int total_fields = length + num_injected + (is_value_type ? 2 : 0);</span>
1638 
1639   // The field array starts with tuples of shorts
1640   // [access, name index, sig index, initial value index, byte offset].
1641   // A generic signature slot only exists for field with generic
1642   // signature attribute. And the access flag is set with
1643   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1644   // signature slots are at the end of the field array and after all
1645   // other fields data.
1646   //
1647   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1648   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1649   //       ...
1650   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1651   //       [generic signature index]
1652   //       [generic signature index]
1653   //       ...
1654   //
1655   // Allocate a temporary resource array for field data. For each field,
1656   // a slot is reserved in the temporary array for the generic signature
1657   // index. After parsing all fields, the data are copied to a permanent
1658   // array and any unused slots will be discarded.
1659   ResourceMark rm(THREAD);
1660   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1661                                               u2,
1662                                               total_fields * (FieldInfo::field_slots + 1));
1663 
1664   // The generic signature slots start after all other fields&#39; data.
1665   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1666   int num_generic_signature = 0;
1667   int instance_fields_count = 0;
1668   for (int n = 0; n &lt; length; n++) {
1669     // access_flags, name_index, descriptor_index, attributes_count
1670     cfs-&gt;guarantee_more(8, CHECK);
1671 
1672     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;
1673 
1674     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
<span class="line-modified">1675     verify_legal_field_modifiers(flags, is_interface, is_value_type, CHECK);</span>
1676     AccessFlags access_flags;
1677     access_flags.set_flags(flags);
1678 
1679     const u2 name_index = cfs-&gt;get_u2_fast();
1680     check_property(valid_symbol_at(name_index),
1681       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1682       name_index, CHECK);
1683     const Symbol* const name = cp-&gt;symbol_at(name_index);
1684     verify_legal_field_name(name, CHECK);
1685 
1686     const u2 signature_index = cfs-&gt;get_u2_fast();
1687     check_property(valid_symbol_at(signature_index),
1688       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1689       signature_index, CHECK);
1690     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1691     verify_legal_field_signature(name, sig, CHECK);
1692     assert(!access_flags.is_flattenable(), &quot;ACC_FLATTENABLE should have been filtered out&quot;);
1693     if (sig-&gt;is_Q_signature()) {
1694       // assert(_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS, &quot;Q-descriptors are only supported in recent classfiles&quot;);
1695       access_flags.set_is_flattenable();
</pre>
<hr />
<pre>
1799           continue;
1800         }
1801       }
1802 
1803       // Injected field
1804       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1805       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1806                         injected[n].name_index,
1807                         injected[n].signature_index,
1808                         0);
1809 
1810       const BasicType type = Signature::basic_type(injected[n].signature());
1811 
1812       // Remember how many oops we encountered and compute allocation type
1813       const FieldAllocationType atype = fac-&gt;update(false, type, false);
1814       field-&gt;set_allocation_type(atype);
1815       index++;
1816     }
1817   }
1818 
<span class="line-modified">1819   if (is_value_type) {</span>
1820     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1821     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,
1822                       vmSymbols::default_value_name_enum,
1823                       vmSymbols::object_signature_enum,
1824                       0);
1825     const BasicType type = Signature::basic_type(vmSymbols::object_signature());
1826     const FieldAllocationType atype = fac-&gt;update(true, type, false);
1827     field-&gt;set_allocation_type(atype);
1828     index++;
1829   }
1830 
<span class="line-modified">1831   if (is_value_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-modified">1832     _is_empty_value = true;</span>
1833     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1834     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1835         vmSymbols::empty_marker_name_enum,
1836         vmSymbols::byte_signature_enum,
1837         0);
1838     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());
1839     const FieldAllocationType atype = fac-&gt;update(false, type, false);
1840     field-&gt;set_allocation_type(atype);
1841     index++;
1842   }
1843 
1844   if (instance_fields_count &gt; 0) {
1845     _has_nonstatic_fields = true;
1846   }
1847 
1848   assert(NULL == _fields, &quot;invariant&quot;);
1849 
1850   _fields =
1851     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1852                                    index * FieldInfo::field_slots + num_generic_signature,
</pre>
<hr />
<pre>
2144         checked_exception, CHECK_NULL);
2145     }
2146   }
2147   // check exceptions attribute length
2148   if (_need_verify) {
2149     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2150                                                    sizeof(u2) * size),
2151                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2152   }
2153   return checked_exceptions_start;
2154 }
2155 
2156 void ClassFileParser::throwIllegalSignature(const char* type,
2157                                             const Symbol* name,
2158                                             const Symbol* sig,
2159                                             TRAPS) const {
2160   assert(name != NULL, &quot;invariant&quot;);
2161   assert(sig != NULL, &quot;invariant&quot;);
2162 
2163   const char* class_note = &quot;&quot;;
<span class="line-modified">2164   if (is_value_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
2165     class_note = &quot; (an inline class)&quot;;
2166   }
2167 
2168   ResourceMark rm(THREAD);
2169   Exceptions::fthrow(THREAD_AND_LOCATION,
2170       vmSymbols::java_lang_ClassFormatError(),
2171       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,
2172       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());
2173 }
2174 
2175 AnnotationCollector::ID
2176 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2177                                       const Symbol* name) {
2178   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2179   // Privileged code can use all annotations.  Other code silently drops some.
2180   const bool privileged = loader_data-&gt;is_the_null_class_loader_data() ||
2181                           loader_data-&gt;is_platform_class_loader_data() ||
2182                           loader_data-&gt;is_unsafe_anonymous();
2183   switch (sid) {
2184     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
</pre>
<hr />
<pre>
2416                              runtime_visible_type_annotations_length,
2417                              runtime_invisible_type_annotations,
2418                              runtime_invisible_type_annotations_length,
2419                              CHECK);
2420     cm-&gt;set_type_annotations(a);
2421   }
2422 }
2423 
2424 
2425 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2426 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2427 // Method* to save footprint, so we only know the size of the resulting Method* when the
2428 // entire method attribute is parsed.
2429 //
2430 // The promoted_flags parameter is used to pass relevant access_flags
2431 // from the method back up to the containing klass. These flag values
2432 // are added to klass&#39;s access_flags.
2433 
2434 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2435                                       bool is_interface,
<span class="line-modified">2436                                       bool is_value_type,</span>
2437                                       const ConstantPool* cp,
2438                                       AccessFlags* const promoted_flags,
2439                                       TRAPS) {
2440   assert(cfs != NULL, &quot;invariant&quot;);
2441   assert(cp != NULL, &quot;invariant&quot;);
2442   assert(promoted_flags != NULL, &quot;invariant&quot;);
2443 
2444   ResourceMark rm(THREAD);
2445   // Parse fixed parts:
2446   // access_flags, name_index, descriptor_index, attributes_count
2447   cfs-&gt;guarantee_more(8, CHECK_NULL);
2448 
2449   int flags = cfs-&gt;get_u2_fast();
2450   const u2 name_index = cfs-&gt;get_u2_fast();
2451   const int cp_size = cp-&gt;length();
2452   check_property(
2453     valid_symbol_at(name_index),
2454     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2455     name_index, CHECK_NULL);
2456   const Symbol* const name = cp-&gt;symbol_at(name_index);
2457   verify_legal_method_name(name, CHECK_NULL);
2458 
2459   const u2 signature_index = cfs-&gt;get_u2_fast();
2460   guarantee_property(
2461     valid_symbol_at(signature_index),
2462     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2463     signature_index, CHECK_NULL);
2464   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2465 
2466   if (name == vmSymbols::class_initializer_name()) {
2467     // We ignore the other access flags for a valid class initializer.
2468     // (JVM Spec 2nd ed., chapter 4.6)
2469     if (_major_version &lt; 51) { // backward compatibility
2470       flags = JVM_ACC_STATIC;
2471     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2472       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2473     } else {
2474       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2475     }
2476   } else {
<span class="line-modified">2477     verify_legal_method_modifiers(flags, is_interface, is_value_type, name, CHECK_NULL);</span>
2478   }
2479 
2480   if (name == vmSymbols::object_initializer_name()) {
2481     if (is_interface) {
2482       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
<span class="line-modified">2483     } else if (!is_value_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
2484       // OK, a constructor
<span class="line-modified">2485     } else if (is_value_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
2486       // also OK, a static factory, as long as the return value is good
2487       bool ok = false;
2488       SignatureStream ss((Symbol*) signature, true);
2489       while (!ss.at_return_type())  ss.next();
2490       if (ss.is_reference()) {
2491         Symbol* ret = ss.as_symbol();
2492         const Symbol* required = class_name();
2493         if (is_unsafe_anonymous()) {
2494           // The original class name in the UAC byte stream gets changed.  So
2495           // using the original name in the return type is no longer valid.
2496           required = vmSymbols::java_lang_Object();
2497         }
2498         ok = (ret == required);
2499       }
2500       if (!ok) {
2501         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2502       }
2503     } else {
2504       // not OK, so throw the same error as in verify_legal_method_signature.
2505       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
</pre>
<hr />
<pre>
3049       _has_finalizer = true;
3050     }
3051   }
3052   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3053       signature == vmSymbols::void_method_signature() &amp;&amp;
3054       m-&gt;is_vanilla_constructor()) {
3055     _has_vanilla_constructor = true;
3056   }
3057 
3058   NOT_PRODUCT(m-&gt;verify());
3059   return m;
3060 }
3061 
3062 
3063 // The promoted_flags parameter is used to pass relevant access_flags
3064 // from the methods back up to the containing klass. These flag values
3065 // are added to klass&#39;s access_flags.
3066 // Side-effects: populates the _methods field in the parser
3067 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3068                                     bool is_interface,
<span class="line-modified">3069                                     bool is_value_type,</span>
3070                                     AccessFlags* promoted_flags,
3071                                     bool* has_final_method,
3072                                     bool* declares_nonstatic_concrete_methods,
3073                                     TRAPS) {
3074   assert(cfs != NULL, &quot;invariant&quot;);
3075   assert(promoted_flags != NULL, &quot;invariant&quot;);
3076   assert(has_final_method != NULL, &quot;invariant&quot;);
3077   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3078 
3079   assert(NULL == _methods, &quot;invariant&quot;);
3080 
3081   cfs-&gt;guarantee_more(2, CHECK);  // length
3082   const u2 length = cfs-&gt;get_u2_fast();
3083   if (length == 0) {
3084     _methods = Universe::the_empty_method_array();
3085   } else {
3086     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3087                                                    length,
3088                                                    NULL,
3089                                                    CHECK);
3090 
3091     for (int index = 0; index &lt; length; index++) {
3092       Method* method = parse_method(cfs,
3093                                     is_interface,
<span class="line-modified">3094                                     is_value_type,</span>
3095                                     _cp,
3096                                     promoted_flags,
3097                                     CHECK);
3098 
3099       if (method-&gt;is_final()) {
3100         *has_final_method = true;
3101       }
3102       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3103       // used for interface initialization, and default method inheritance analysis
3104       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3105         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3106         *declares_nonstatic_concrete_methods = true;
3107       }
3108       _methods-&gt;at_put(index, method);
3109     }
3110 
3111     if (_need_verify &amp;&amp; length &gt; 1) {
3112       // Check duplicated methods
3113       ResourceMark rm(THREAD);
3114       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3274         valid_klass_reference_at(outer_class_info_index),
3275       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3276       outer_class_info_index, CHECK_0);
3277     // Inner class name
3278     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3279     check_property(
3280       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3281       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3282       inner_name_index, CHECK_0);
3283     if (_need_verify) {
3284       guarantee_property(inner_class_info_index != outer_class_info_index,
3285                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3286     }
3287 
3288     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;
3289     // JVM_ACC_MODULE is defined in JDK-9 and later.
3290     if (_major_version &gt;= JAVA_9_VERSION) {
3291       recognized_modifiers |= JVM_ACC_MODULE;
3292     }
3293     // JVM_ACC_VALUE is defined for class file version 55 and later
<span class="line-modified">3294     if (supports_value_types()) {</span>
3295       recognized_modifiers |= JVM_ACC_VALUE;
3296     }
3297 
3298     // Access flags
3299     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
3300 
3301     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3302       // Set abstract bit for old class files for backward compatibility
3303       flags |= JVM_ACC_ABSTRACT;
3304     }
3305     verify_legal_class_modifiers(flags, CHECK_0);
3306     AccessFlags inner_access_flags(flags);
3307 
3308     inner_classes-&gt;at_put(index++, inner_class_info_index);
3309     inner_classes-&gt;at_put(index++, outer_class_info_index);
3310     inner_classes-&gt;at_put(index++, inner_name_index);
3311     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3312   }
3313 
3314   // 4347400: make sure there&#39;s no duplicate entry in the classes array
</pre>
<hr />
<pre>
3657   bool parsed_sourcefile_attribute = false;
3658   bool parsed_innerclasses_attribute = false;
3659   bool parsed_nest_members_attribute = false;
3660   bool parsed_nest_host_attribute = false;
3661   bool parsed_record_attribute = false;
3662   bool parsed_enclosingmethod_attribute = false;
3663   bool parsed_bootstrap_methods_attribute = false;
3664   const u1* runtime_visible_annotations = NULL;
3665   int runtime_visible_annotations_length = 0;
3666   const u1* runtime_invisible_annotations = NULL;
3667   int runtime_invisible_annotations_length = 0;
3668   const u1* runtime_visible_type_annotations = NULL;
3669   int runtime_visible_type_annotations_length = 0;
3670   const u1* runtime_invisible_type_annotations = NULL;
3671   int runtime_invisible_type_annotations_length = 0;
3672   bool runtime_invisible_type_annotations_exists = false;
3673   bool runtime_invisible_annotations_exists = false;
3674   bool parsed_source_debug_ext_annotations_exist = false;
3675   const u1* inner_classes_attribute_start = NULL;
3676   u4  inner_classes_attribute_length = 0;
<span class="line-removed">3677   const u1* value_types_attribute_start = NULL;</span>
<span class="line-removed">3678   u4 value_types_attribute_length = 0;</span>
3679   u2  enclosing_method_class_index = 0;
3680   u2  enclosing_method_method_index = 0;
3681   const u1* nest_members_attribute_start = NULL;
3682   u4  nest_members_attribute_length = 0;
3683   const u1* record_attribute_start = NULL;
3684   u4  record_attribute_length = 0;
3685 
3686   // Iterate over attributes
3687   while (attributes_count--) {
3688     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3689     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3690     const u4 attribute_length = cfs-&gt;get_u4_fast();
3691     check_property(
3692       valid_symbol_at(attribute_name_index),
3693       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3694       attribute_name_index, CHECK);
3695     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3696     if (tag == vmSymbols::tag_source_file()) {
3697       // Check for SourceFile tag
3698       if (_need_verify) {
</pre>
<hr />
<pre>
4243 }
4244 
4245 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4246   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4247   if (_nonstatic_oop_map_count &gt; 0) {
4248     OopMapBlock* map = _nonstatic_oop_maps;
4249     OopMapBlock* last_map = last_oop_map();
4250     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4251     while (map &lt;= last_map) {
4252       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4253                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4254       map++;
4255     }
4256   }
4257 }
4258 
4259 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4260   print_on(st);
4261 }
4262 
<span class="line-modified">4263 void ClassFileParser::throwValueTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-modified">4264                                                const char* msg,</span>
<span class="line-modified">4265                                                const Symbol* name,</span>
<span class="line-modified">4266                                                const Symbol* sig) const {</span>
4267 
4268   ResourceMark rm(THREAD);
4269   if (name == NULL || sig == NULL) {
4270     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4271         vmSymbols::java_lang_ClassFormatError(),
4272         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);
4273   }
4274   else {
4275     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4276         vmSymbols::java_lang_ClassFormatError(),
4277         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),
4278         _class_name-&gt;as_C_string(), msg);
4279   }
4280 }
4281 
4282 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4283 void ClassFileParser::layout_fields(ConstantPool* cp,
4284                                     const FieldAllocationCount* fac,
4285                                     const ClassAnnotationCollector* parsed_annotations,
4286                                     FieldLayoutInfo* info,
4287                                     TRAPS) {
4288 
4289   assert(cp != NULL, &quot;invariant&quot;);
4290 
4291   // Field size and offset computation
4292   int nonstatic_field_size = _super_klass == NULL ? 0 :
4293                                _super_klass-&gt;nonstatic_field_size();
<span class="line-modified">4294   int next_nonstatic_valuetype_offset = 0;</span>
<span class="line-modified">4295   int first_nonstatic_valuetype_offset = 0;</span>
4296 
<span class="line-modified">4297   // Fields that are value types are handled differently depending if they are static or not:</span>
4298   // - static fields are oops
4299   // - non-static fields are embedded
4300 
4301   // Count the contended fields by type.
4302   //
4303   // We ignore static fields, because @Contended is not supported for them.
4304   // The layout code below will also ignore the static fields.
4305   int nonstatic_contended_count = 0;
4306   FieldAllocationCount fac_contended;
4307   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4308     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4309     if (fs.is_contended()) {
4310       fac_contended.count[atype]++;
4311       if (!fs.access_flags().is_static()) {
4312         nonstatic_contended_count++;
4313       }
4314     }
4315   }
4316 
4317 
4318   // Calculate the starting byte offsets
4319   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<span class="line-modified">4320   // Value types in static fields are not embedded, they are handled with oops</span>
4321   int next_static_double_offset = next_static_oop_offset +
4322                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);
4323   if (fac-&gt;count[STATIC_DOUBLE]) {
4324     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4325   }
4326 
4327   int next_static_word_offset   = next_static_double_offset +
4328                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4329   int next_static_short_offset  = next_static_word_offset +
4330                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4331   int next_static_byte_offset   = next_static_short_offset +
4332                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4333 
4334   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4335                                 nonstatic_field_size * heapOopSize;
4336 
<span class="line-modified">4337   // First field of value types is aligned on a long boundary in order to ease</span>
<span class="line-modified">4338   // in-lining of value types (with header removal) in packed arrays and</span>
<span class="line-modified">4339   // flatten value types</span>
<span class="line-modified">4340   int initial_value_type_padding = 0;</span>
<span class="line-modified">4341   if (is_value_type()) {</span>
4342     int old = nonstatic_fields_start;
4343     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);
<span class="line-modified">4344     initial_value_type_padding = nonstatic_fields_start - old;</span>
4345   }
4346 
4347   int next_nonstatic_field_offset = nonstatic_fields_start;
4348 
4349   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4350 
4351   // Class is contended, pad before all the fields
4352   if (is_contended_class) {
4353     next_nonstatic_field_offset += ContendedPaddingWidth;
4354   }
4355 
<span class="line-modified">4356   // Temporary value types restrictions</span>
<span class="line-modified">4357   if (is_value_type()) {</span>
4358     if (is_contended_class) {
<span class="line-modified">4359       throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
4360       return;
4361     }
4362   }
4363 
4364   // Compute the non-contended fields count.
4365   // The packing code below relies on these counts to determine if some field
4366   // can be squeezed into the alignment gap. Contended fields are obviously
4367   // exempt from that.
4368   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4369   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4370   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4371   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4372   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4373 
<span class="line-modified">4374   int static_value_type_count = 0;</span>
<span class="line-modified">4375   int nonstatic_value_type_count = 0;</span>
<span class="line-modified">4376   int* nonstatic_value_type_indexes = NULL;</span>
<span class="line-modified">4377   Klass** nonstatic_value_type_klasses = NULL;</span>
<span class="line-modified">4378   unsigned int value_type_oop_map_count = 0;</span>
<span class="line-modified">4379   int not_flattened_value_types = 0;</span>
<span class="line-modified">4380   int not_atomic_value_types = 0;</span>
4381 
<span class="line-modified">4382   int max_nonstatic_value_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
4383 
<span class="line-modified">4384   nonstatic_value_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-modified">4385                                                               max_nonstatic_value_type);</span>
<span class="line-modified">4386   for (int i = 0; i &lt; max_nonstatic_value_type; i++) {</span>
<span class="line-modified">4387     nonstatic_value_type_indexes[i] = -1;</span>
4388   }
<span class="line-modified">4389   nonstatic_value_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-modified">4390                                                               max_nonstatic_value_type);</span>
4391 
4392   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
4393     if (fs.allocation_type() == STATIC_FLATTENABLE) {
4394       ResourceMark rm;
4395       if (!fs.signature()-&gt;is_Q_signature()) {
4396         THROW(vmSymbols::java_lang_ClassFormatError());
4397       }
<span class="line-modified">4398       static_value_type_count++;</span>
4399     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {
<span class="line-modified">4400       // Pre-resolve the flattenable field and check for value type circularity issues.</span>
4401       ResourceMark rm;
4402       if (!fs.signature()-&gt;is_Q_signature()) {
4403         THROW(vmSymbols::java_lang_ClassFormatError());
4404       }
4405       Klass* klass =
4406         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
4407                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4408                                                             _protection_domain, true, CHECK);
4409       assert(klass != NULL, &quot;Sanity check&quot;);
<span class="line-modified">4410       if (!klass-&gt;access_flags().is_value_type()) {</span>
4411         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4412       }
4413       ValueKlass* vk = ValueKlass::cast(klass);
4414       // Conditions to apply flattening or not should be defined in a single place
4415       bool too_big_to_flatten = (ValueFieldMaxFlatSize &gt;= 0 &amp;&amp;
4416                                  (vk-&gt;size_helper() * HeapWordSize) &gt; ValueFieldMaxFlatSize);
4417       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
4418       bool too_volatile_to_flatten = fs.access_flags().is_volatile();
4419       if (vk-&gt;is_naturally_atomic()) {
4420         too_atomic_to_flatten = false;
4421         //too_volatile_to_flatten = false; //FIXME
4422         // volatile fields are currently never flattened, this could change in the future
4423       }
4424       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
<span class="line-modified">4425         nonstatic_value_type_indexes[nonstatic_value_type_count] = fs.index();</span>
<span class="line-modified">4426         nonstatic_value_type_klasses[nonstatic_value_type_count] = klass;</span>
<span class="line-modified">4427         nonstatic_value_type_count++;</span>
4428 
4429         ValueKlass* vklass = ValueKlass::cast(klass);
4430         if (vklass-&gt;contains_oops()) {
<span class="line-modified">4431           value_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
4432         }
4433         fs.set_flattened(true);
4434         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
<span class="line-modified">4435           not_atomic_value_types++;</span>
4436         }
4437       } else {
<span class="line-modified">4438         not_flattened_value_types++;</span>
4439         fs.set_flattened(false);
4440       }
4441     }
4442   }
4443 
<span class="line-modified">4444   // Adjusting non_static_oop_count to take into account not flattened value types;</span>
<span class="line-modified">4445   nonstatic_oop_count += not_flattened_value_types;</span>
4446 
4447   // Total non-static fields count, including every contended field
4448   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4449                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4450                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];
4451 
4452   const bool super_has_nonstatic_fields =
4453           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4454   const bool has_nonstatic_fields =
4455     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-modified">4456   const bool has_nonstatic_value_fields = nonstatic_value_type_count &gt; 0;</span>
4457 
<span class="line-modified">4458   if (is_value_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
4459     // There are a number of fixes required throughout the type system and JIT
<span class="line-modified">4460     throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
4461     return;
4462   }
4463 
4464   // Prepare list of oops for oop map generation.
4465   //
4466   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4467   // regions. offset[i] is the start of the i-th region, which then has
4468   // count[i] oops following. Before we know how many regions are required,
4469   // we pessimistically allocate the maps to fit all the oops into the
4470   // distinct regions.
4471   //
4472   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
4473   int max_oop_map_count =
4474       super_oop_map_count +
4475       fac-&gt;count[NONSTATIC_OOP] +
<span class="line-modified">4476       value_type_oop_map_count +</span>
<span class="line-modified">4477       not_flattened_value_types;</span>
4478 
4479   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4480   if (super_oop_map_count &gt; 0) {
4481     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4482                                                     _super_klass-&gt;nonstatic_oop_map_count());
4483   }
4484 
4485   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4486 
4487   bool compact_fields  = true;
4488   bool allocate_oops_first = false;
4489 
4490   // The next classes have predefined hard-coded fields offsets
4491   // (see in JavaClasses::compute_hard_coded_offsets()).
4492   // Use default fields allocation order for them.
4493   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;
4494       (_class_name == vmSymbols::java_lang_ref_Reference() ||
4495        _class_name == vmSymbols::java_lang_Boolean() ||
4496        _class_name == vmSymbols::java_lang_Character() ||
4497        _class_name == vmSymbols::java_lang_Float() ||
</pre>
<hr />
<pre>
4569   }
4570 
4571   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4572                                      (nonstatic_double_count * BytesPerLong);
4573   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4574                                       (nonstatic_word_count * BytesPerInt);
4575   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4576                                      (nonstatic_short_count * BytesPerShort);
4577   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4578                                        nonstatic_byte_count;
4579 
4580   // let oops jump before padding with this allocation style
4581   if (!allocate_oops_first) {
4582     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4583     if( nonstatic_oop_count &gt; 0 ) {
4584       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4585     }
4586     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4587   }
4588 
<span class="line-modified">4589   // Aligning embedded value types</span>
<span class="line-modified">4590   // bug below, the current algorithm to layout embedded value types always put them at the</span>
4591   // end of the layout, which doesn&#39;t match the different allocation policies the VM is
4592   // supposed to provide =&gt; FixMe
<span class="line-modified">4593   // Note also that the current alignment policy is to make each value type starting on a</span>
4594   // 64 bits boundary. This could be optimized later. For instance, it could be nice to
<span class="line-modified">4595   // align value types according to their most constrained internal type.</span>
<span class="line-modified">4596   next_nonstatic_valuetype_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-modified">4597   int next_value_type_index = 0;</span>
4598 
4599   // Iterate over fields again and compute correct offsets.
4600   // The field allocation type was temporarily stored in the offset slot.
4601   // oop fields are located before non-oop fields (static and non-static).
4602   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4603 
4604     // skip already laid out fields
4605     if (fs.is_offset_set()) continue;
4606 
4607     // contended instance fields are handled below
4608     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4609 
4610     int real_offset = 0;
4611     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4612 
4613     // pack the rest of the fields
4614     switch (atype) {
<span class="line-modified">4615       // Value types in static fields are handled with oops</span>
4616       case STATIC_FLATTENABLE:   // Fallthrough
4617       case STATIC_OOP:
4618         real_offset = next_static_oop_offset;
4619         next_static_oop_offset += heapOopSize;
4620         break;
4621       case STATIC_BYTE:
4622         real_offset = next_static_byte_offset;
4623         next_static_byte_offset += 1;
4624         break;
4625       case STATIC_SHORT:
4626         real_offset = next_static_short_offset;
4627         next_static_short_offset += BytesPerShort;
4628         break;
4629       case STATIC_WORD:
4630         real_offset = next_static_word_offset;
4631         next_static_word_offset += BytesPerInt;
4632         break;
4633       case STATIC_DOUBLE:
4634         real_offset = next_static_double_offset;
4635         next_static_double_offset += BytesPerLong;
4636         break;
4637       case NONSTATIC_FLATTENABLE:
4638         if (fs.is_flattened()) {
<span class="line-modified">4639           Klass* klass = nonstatic_value_type_klasses[next_value_type_index];</span>
4640           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);
<span class="line-modified">4641           assert(klass-&gt;access_flags().is_value_type(),&quot;Must be a value type&quot;);</span>
4642           ValueKlass* vklass = ValueKlass::cast(klass);
<span class="line-modified">4643           real_offset = next_nonstatic_valuetype_offset;</span>
<span class="line-modified">4644           next_nonstatic_valuetype_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-modified">4645           // aligning next value type on a 64 bits boundary</span>
<span class="line-modified">4646           next_nonstatic_valuetype_offset = align_up(next_nonstatic_valuetype_offset, BytesPerLong);</span>
<span class="line-modified">4647           next_value_type_index += 1;</span>
4648 
4649           if (vklass-&gt;contains_oops()) { // add flatten oop maps
4650             int diff = real_offset - vklass-&gt;first_field_offset();
4651             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();
4652             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();
4653             while (map &lt; last_map) {
4654               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());
4655               map++;
4656             }
4657           }
4658           break;
4659         } else {
4660           // Fall through
4661         }
4662       case NONSTATIC_OOP:
4663         if( nonstatic_oop_space_count &gt; 0 ) {
4664           real_offset = nonstatic_oop_space_offset;
4665           nonstatic_oop_space_offset += heapOopSize;
4666           nonstatic_oop_space_count  -= 1;
4667         } else {
</pre>
<hr />
<pre>
4760             break;
4761 
4762           case NONSTATIC_SHORT:
4763             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4764             real_offset = next_nonstatic_padded_offset;
4765             next_nonstatic_padded_offset += BytesPerShort;
4766             break;
4767 
4768           case NONSTATIC_WORD:
4769             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4770             real_offset = next_nonstatic_padded_offset;
4771             next_nonstatic_padded_offset += BytesPerInt;
4772             break;
4773 
4774           case NONSTATIC_DOUBLE:
4775             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4776             real_offset = next_nonstatic_padded_offset;
4777             next_nonstatic_padded_offset += BytesPerLong;
4778             break;
4779 
<span class="line-modified">4780             // Value types in static fields are handled with oops</span>
4781           case NONSTATIC_FLATTENABLE:
<span class="line-modified">4782             throwValueTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-modified">4783                                      &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
4784             return;
4785 
4786           case NONSTATIC_OOP:
4787             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4788             real_offset = next_nonstatic_padded_offset;
4789             next_nonstatic_padded_offset += heapOopSize;
4790             nonstatic_oop_maps-&gt;add(real_offset, 1);
4791             break;
4792 
4793           default:
4794             ShouldNotReachHere();
4795         }
4796 
4797         if (fs.contended_group() == 0) {
4798           // Contended group defines the equivalence class over the fields:
4799           // the fields within the same contended group are not inter-padded.
4800           // The only exception is default group, which does not incur the
4801           // equivalence, and so requires intra-padding.
4802           next_nonstatic_padded_offset += ContendedPaddingWidth;
4803         }
</pre>
<hr />
<pre>
4805         fs.set_offset(real_offset);
4806       } // for
4807 
4808       // Start laying out the next group.
4809       // Note that this will effectively pad the last group in the back;
4810       // this is expected to alleviate memory contention effects for
4811       // subclass fields and/or adjacent object.
4812       // If this was the default group, the padding is already in place.
4813       if (current_group != 0) {
4814         next_nonstatic_padded_offset += ContendedPaddingWidth;
4815       }
4816     }
4817 
4818     // handle static fields
4819   }
4820 
4821   // Entire class is contended, pad in the back.
4822   // This helps to alleviate memory contention effects for subclass fields
4823   // and/or adjacent object.
4824   if (is_contended_class) {
<span class="line-modified">4825     assert(!is_value_type(), &quot;@Contended not supported for value types yet&quot;);</span>
4826     next_nonstatic_padded_offset += ContendedPaddingWidth;
4827   }
4828 
4829   int notaligned_nonstatic_fields_end;
<span class="line-modified">4830   if (nonstatic_value_type_count != 0) {</span>
<span class="line-modified">4831     notaligned_nonstatic_fields_end = next_nonstatic_valuetype_offset;</span>
4832   } else {
4833     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
4834   }
4835 
4836   int nonstatic_field_sz_align = heapOopSize;
<span class="line-modified">4837   if (is_value_type()) {</span>
4838     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {
4839       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy
4840     }
4841   }
4842   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);
4843   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4844   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4845 
4846   int static_field_size         = (static_fields_end -
4847                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4848   nonstatic_field_size          = nonstatic_field_size +
4849                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4850 
4851   int instance_size             = align_object_size(instance_end / wordSize);
4852 
4853   assert(instance_size == align_object_size(align_up(
4854          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
<span class="line-modified">4855          + initial_value_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
4856 
4857 
4858   // Invariant: nonstatic_field end/start should only change if there are
4859   // nonstatic fields in the class, or if the class is contended. We compare
4860   // against the non-aligned value, so that end alignment will not fail the
4861   // assert without actually having the fields.
4862   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4863          is_contended_class ||
4864          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4865 
4866   // Number of non-static oop map blocks allocated at end of klass.
4867   nonstatic_oop_maps-&gt;compact();
4868 
4869 #ifndef PRODUCT
<span class="line-modified">4870   if ((PrintFieldLayout &amp;&amp; !is_value_type()) ||</span>
<span class="line-modified">4871       (PrintValueLayout &amp;&amp; (is_value_type() || has_nonstatic_value_fields))) {</span>
4872     print_field_layout(_class_name,
4873           _fields,
4874           cp,
4875           instance_size,
4876           nonstatic_fields_start,
4877           nonstatic_fields_end,
4878           static_fields_end);
4879     nonstatic_oop_maps-&gt;print_on(tty);
4880     tty-&gt;print(&quot;\n&quot;);
4881     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4882     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4883     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4884     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4885     tty-&gt;print_cr(&quot;---&quot;);
4886   }
4887 
4888 #endif
4889   // Pass back information needed for InstanceKlass creation
4890   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4891   info-&gt;_instance_size = instance_size;
4892   info-&gt;_static_field_size = static_field_size;
4893   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4894   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
4895 
<span class="line-modified">4896   // A value type is naturally atomic if it has just one field, and</span>
4897   // that field is simple enough.
<span class="line-modified">4898   info-&gt;_is_naturally_atomic = (is_value_type() &amp;&amp;</span>
4899                                 !super_has_nonstatic_fields &amp;&amp;
4900                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;
<span class="line-modified">4901                                 (not_atomic_value_types == 0) &amp;&amp;</span>
4902                                 (nonstatic_contended_count == 0));
4903   // This may be too restrictive, since if all the fields fit in 64
4904   // bits we could make the decision to align instances of this class
4905   // to 64-bit boundaries, and load and store them as single words.
4906   // And on machines which supported larger atomics we could similarly
4907   // allow larger values to be atomic, if properly aligned.
4908 }
4909 
4910 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4911   assert(ik != NULL, &quot;invariant&quot;);
4912 
4913   const Klass* const super = ik-&gt;super();
4914 
4915   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4916   // in which case we don&#39;t have to register objects as finalizable
4917   if (!_has_empty_finalizer) {
4918     if (_has_finalizer ||
4919         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4920       ik-&gt;set_has_finalizer();
4921     }
</pre>
<hr />
<pre>
4925   bool f = false;
4926   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4927                                            vmSymbols::void_method_signature());
4928   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4929       f = true;
4930   }
4931 
4932   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4933   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4934   // will not work as expected we shouldn&#39;t abort vm in this case
4935   if (!ik-&gt;has_redefined_this_or_super()) {
4936     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4937   }
4938 #endif
4939 
4940   // Check if this klass supports the java.lang.Cloneable interface
4941   if (SystemDictionary::Cloneable_klass_loaded()) {
4942     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
4943       if (ik-&gt;is_value()) {
4944         Thread *THREAD = Thread::current();
<span class="line-modified">4945         throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
4946         return;
4947       }
4948       ik-&gt;set_is_cloneable();
4949     }
4950   }
4951 
4952   // Check if this klass has a vanilla default constructor
4953   if (super == NULL) {
4954     // java.lang.Object has empty default constructor
4955     ik-&gt;set_has_vanilla_constructor();
4956   } else {
4957     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4958         _has_vanilla_constructor) {
4959       ik-&gt;set_has_vanilla_constructor();
4960     }
4961 #ifdef ASSERT
4962     bool v = false;
4963     if (super-&gt;has_vanilla_constructor()) {
4964       const Method* const constructor =
4965         ik-&gt;find_method(vmSymbols::object_initializer_name(),
</pre>
<hr />
<pre>
4968         v = true;
4969       }
4970     }
4971     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4972 #endif
4973   }
4974 
4975   // If it cannot be fast-path allocated, set a bit in the layout helper.
4976   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4977   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4978   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4979       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4980       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4981       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4982     // Forbid fast-path allocation.
4983     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4984     ik-&gt;set_layout_helper(lh);
4985   }
4986 }
4987 
<span class="line-modified">4988 bool ClassFileParser::supports_value_types() const {</span>
<span class="line-modified">4989   // Value types are only supported by class file version 55 and later</span>
4990   return _major_version &gt;= JAVA_11_VERSION;
4991 }
4992 
4993 // utility methods for appending an array with check for duplicates
4994 
4995 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4996                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4997   // iterate over new interfaces
4998   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4999     InstanceKlass* const e = ifs-&gt;at(i);
5000     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
5001     // add new interface
5002     result-&gt;append_if_missing(e);
5003   }
5004 }
5005 
5006 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
5007                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
5008                                                             ClassLoaderData* loader_data,
5009                                                             TRAPS) {
</pre>
<hr />
<pre>
5242     const Method* const m = methods-&gt;at(index);
5243     // if m is static and not the init method, throw a verify error
5244     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
5245       ResourceMark rm(THREAD);
5246       Exceptions::fthrow(
5247         THREAD_AND_LOCATION,
5248         vmSymbols::java_lang_VerifyError(),
5249         &quot;Illegal static method %s in interface %s&quot;,
5250         m-&gt;name()-&gt;as_C_string(),
5251         this_klass-&gt;external_name()
5252       );
5253       return;
5254     }
5255   }
5256 }
5257 
5258 // utility methods for format checking
5259 
5260 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
5261   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-modified">5262   const bool is_value_type = (flags &amp; JVM_ACC_VALUE) != 0;</span>
5263   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-modified">5264   assert(supports_value_types() || !is_value_type, &quot;JVM_ACC_VALUE should not be set&quot;);</span>
5265   if (is_module) {
5266     ResourceMark rm(THREAD);
5267     Exceptions::fthrow(
5268       THREAD_AND_LOCATION,
5269       vmSymbols::java_lang_NoClassDefFoundError(),
5270       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
5271       _class_name-&gt;as_C_string());
5272     return;
5273   }
5274 
<span class="line-modified">5275   if (is_value_type &amp;&amp; !EnableValhalla) {</span>
5276     ResourceMark rm(THREAD);
5277     Exceptions::fthrow(
5278       THREAD_AND_LOCATION,
5279       vmSymbols::java_lang_ClassFormatError(),
5280       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,
5281       _class_name-&gt;as_C_string()
5282     );
5283   }
5284 
5285   if (!_need_verify) { return; }
5286 
5287   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
5288   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
5289   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
5290   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
5291   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
5292   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5293   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5294   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5295 
5296   if ((is_abstract &amp;&amp; is_final) ||
5297       (is_interface &amp;&amp; !is_abstract) ||
5298       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
5299       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||
<span class="line-modified">5300       (is_value_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
5301     ResourceMark rm(THREAD);
5302     const char* class_note = &quot;&quot;;
<span class="line-modified">5303     if (is_value_type)  class_note = &quot; (an inline class)&quot;;</span>
5304     Exceptions::fthrow(
5305       THREAD_AND_LOCATION,
5306       vmSymbols::java_lang_ClassFormatError(),
5307       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,
5308       _class_name-&gt;as_C_string(), class_note, flags
5309     );
5310     return;
5311   }
5312 }
5313 
5314 static bool has_illegal_visibility(jint flags) {
5315   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5316   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5317   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5318 
5319   return ((is_public &amp;&amp; is_protected) ||
5320           (is_public &amp;&amp; is_private) ||
5321           (is_protected &amp;&amp; is_private));
5322 }
5323 
</pre>
<hr />
<pre>
5367     if (!Arguments::enable_preview()) {
5368       Exceptions::fthrow(
5369         THREAD_AND_LOCATION,
5370         vmSymbols::java_lang_UnsupportedClassVersionError(),
5371         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5372         class_name-&gt;as_C_string(), major, minor);
5373       return;
5374     }
5375 
5376   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5377     Exceptions::fthrow(
5378         THREAD_AND_LOCATION,
5379         vmSymbols::java_lang_UnsupportedClassVersionError(),
5380         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5381         class_name-&gt;as_C_string(), major, minor);
5382   }
5383 }
5384 
5385 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5386                                                    bool is_interface,
<span class="line-modified">5387                                                    bool is_value_type,</span>
5388                                                    TRAPS) const {
5389   if (!_need_verify) { return; }
5390 
5391   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5392   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5393   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5394   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5395   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5396   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5397   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5398   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5399   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5400 
5401   bool is_illegal = false;
5402 
5403   if (is_interface) {
5404     if (!is_public || !is_static || !is_final || is_private ||
5405         is_protected || is_volatile || is_transient ||
5406         (major_gte_1_5 &amp;&amp; is_enum)) {
5407       is_illegal = true;
5408     }
5409   } else { // not interface
5410     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5411       is_illegal = true;
5412     } else {
<span class="line-modified">5413       if (is_value_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
5414         is_illegal = true;
5415       }
5416     }
5417   }
5418 
5419   if (is_illegal) {
5420     ResourceMark rm(THREAD);
5421     Exceptions::fthrow(
5422       THREAD_AND_LOCATION,
5423       vmSymbols::java_lang_ClassFormatError(),
5424       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5425       _class_name-&gt;as_C_string(), flags);
5426     return;
5427   }
5428 }
5429 
5430 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5431                                                     bool is_interface,
<span class="line-modified">5432                                                     bool is_value_type,</span>
5433                                                     const Symbol* name,
5434                                                     TRAPS) const {
5435   if (!_need_verify) { return; }
5436 
5437   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5438   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5439   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5440   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5441   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5442   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5443   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5444   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5445   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5446   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5447   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5448   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5449   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5450 
5451   bool is_illegal = false;
5452 
</pre>
<hr />
<pre>
5473       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5474       if (!is_public || is_private || is_protected || is_static || is_final ||
5475           is_synchronized || is_native || !is_abstract || is_strict) {
5476         is_illegal = true;
5477       }
5478     } else {
5479       // Class file version is pre-JAVA_1_5_VERSION
5480       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5481         is_illegal = true;
5482       }
5483     }
5484   } else { // not interface
5485     if (has_illegal_visibility(flags)) {
5486       is_illegal = true;
5487     } else {
5488       if (is_initializer) {
5489         if (is_final || is_synchronized || is_native ||
5490             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5491           is_illegal = true;
5492         }
<span class="line-modified">5493         if (!is_static &amp;&amp; !is_value_type) {</span>
5494           // OK, an object constructor in a regular class
<span class="line-modified">5495         } else if (is_static &amp;&amp; is_value_type) {</span>
5496           // OK, a static init factory in an inline class
5497         } else {
5498           // but no other combinations are allowed
5499           is_illegal = true;
<span class="line-modified">5500           class_note = (is_value_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
5501         }
5502       } else { // not initializer
<span class="line-modified">5503         if (is_value_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
5504           is_illegal = true;
5505           class_note = &quot; (an inline class)&quot;;
5506         } else {
5507           if (is_abstract) {
5508             if ((is_final || is_native || is_private || is_static ||
5509                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {
5510               is_illegal = true;
5511             }
5512           }
5513         }
5514       }
5515     }
5516   }
5517 
5518   if (is_illegal) {
5519     ResourceMark rm(THREAD);
5520     Exceptions::fthrow(
5521       THREAD_AND_LOCATION,
5522       vmSymbols::java_lang_ClassFormatError(),
5523       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,
</pre>
<hr />
<pre>
6135 
6136   set_klass_to_deallocate(ik);
6137 
6138   assert(_field_info != NULL, &quot;invariant&quot;);
6139   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6140   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6141          &quot;sanity&quot;);
6142 
6143   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6144   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6145 
6146   // Fill in information already parsed
6147   ik-&gt;set_should_verify_class(_need_verify);
6148 
6149   // Not yet: supers are done below to support the new subtype-checking fields
6150   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6151   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
6152   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
6153     ik-&gt;set_is_naturally_atomic();
6154   }
<span class="line-modified">6155   if (_is_empty_value) {</span>
<span class="line-modified">6156     ik-&gt;set_is_empty_value();</span>
6157   }
6158 
6159   if (this-&gt;_invalid_inline_super) {
6160     ik-&gt;set_invalid_inline_super();
6161   }
6162 
6163   if (_has_injected_identityObject) {
6164     ik-&gt;set_has_injected_identityObject();
6165   }
6166 
6167   assert(_fac != NULL, &quot;invariant&quot;);
6168   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6169 
6170   // this transfers ownership of a lot of arrays from
6171   // the parser onto the InstanceKlass*
6172   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6173 
6174   // note that is not safe to use the fields in the parser from this point on
6175   assert(NULL == _cp, &quot;invariant&quot;);
6176   assert(NULL == _fields, &quot;invariant&quot;);
</pre>
<hr />
<pre>
6312   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6313   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6314       !module_entry-&gt;has_default_read_edges()) {
6315     if (!module_entry-&gt;set_has_default_read_edges()) {
6316       // We won a potential race
6317       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6318     }
6319   }
6320 
6321   int nfields = ik-&gt;java_fields_count();
6322   if (ik-&gt;is_value()) nfields++;
6323   for (int i = 0; i &lt; nfields; i++) {
6324     if (ik-&gt;field_is_flattenable(i)) {
6325       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);
6326       // Inline classes for instance fields must have been pre-loaded
6327       // Inline classes for static fields might not have been loaded yet
6328       Klass* klass = SystemDictionary::find(klass_name,
6329           Handle(THREAD, ik-&gt;class_loader()),
6330           Handle(THREAD, ik-&gt;protection_domain()), CHECK);
6331       if (klass != NULL) {
<span class="line-modified">6332         assert(klass-&gt;access_flags().is_value_type(), &quot;Value type expected&quot;);</span>
6333         ik-&gt;set_value_field_klass(i, klass);
6334       }
6335       klass_name-&gt;decrement_refcount();
6336     } else
<span class="line-modified">6337       if (is_value_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
6338         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
6339       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
6340     }
6341   }
6342 
<span class="line-modified">6343   if (is_value_type()) {</span>
6344     ValueKlass* vk = ValueKlass::cast(ik);
6345     if (UseNewFieldLayout) {
6346       vk-&gt;set_alignment(_alignment);
6347       vk-&gt;set_first_field_offset(_first_field_offset);
6348       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);
6349     } else {
6350       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());
6351     }
6352     ValueKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);
6353   }
6354 
6355   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6356 
6357   if (!is_internal()) {
6358     if (log_is_enabled(Info, class, load)) {
6359       ResourceMark rm;
6360       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6361       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6362     }
6363 
</pre>
<hr />
<pre>
6533   _bad_constant_seen(0),
6534   _synthetic_flag(false),
6535   _sde_length(false),
6536   _sde_buffer(NULL),
6537   _sourcefile_index(0),
6538   _generic_signature_index(0),
6539   _major_version(0),
6540   _minor_version(0),
6541   _this_class_index(0),
6542   _super_class_index(0),
6543   _itfs_len(0),
6544   _java_fields_count(0),
6545   _need_verify(false),
6546   _relax_verify(false),
6547   _has_nonstatic_concrete_methods(false),
6548   _declares_nonstatic_concrete_methods(false),
6549   _has_final_method(false),
6550   _has_contended_fields(false),
6551   _has_flattenable_fields(false),
6552   _has_nonstatic_fields(false),
<span class="line-modified">6553   _is_empty_value(false),</span>
6554   _is_naturally_atomic(false),
6555   _is_declared_atomic(false),
6556   _invalid_inline_super(false),
6557   _invalid_identity_super(false),
6558   _implements_identityObject(false),
6559   _has_injected_identityObject(false),
6560   _has_finalizer(false),
6561   _has_empty_finalizer(false),
6562   _has_vanilla_constructor(false),
6563   _max_bootstrap_specifier_index(-1) {
6564 
6565   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6566   _class_name-&gt;increment_refcount();
6567 
6568   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6569   assert(_loader_data != NULL, &quot;invariant&quot;);
6570   assert(stream != NULL, &quot;invariant&quot;);
6571   assert(_stream != NULL, &quot;invariant&quot;);
6572   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6573   assert(_class_name != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
6746 
6747   _cp = ConstantPool::allocate(_loader_data,
6748                                cp_size,
6749                                CHECK);
6750 
6751   ConstantPool* const cp = _cp;
6752 
6753   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6754 
6755   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6756 
6757   // ACCESS FLAGS
6758   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6759 
6760   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;
6761   // JVM_ACC_MODULE is defined in JDK-9 and later.
6762   if (_major_version &gt;= JAVA_9_VERSION) {
6763     recognized_modifiers |= JVM_ACC_MODULE;
6764   }
6765   // JVM_ACC_VALUE is defined for class file version 55 and later
<span class="line-modified">6766   if (supports_value_types()) {</span>
6767     recognized_modifiers |= JVM_ACC_VALUE;
6768   }
6769 
6770   // Access flags
6771   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;
6772 
6773   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6774     // Set abstract bit for old class files for backward compatibility
6775     flags |= JVM_ACC_ABSTRACT;
6776   }
6777 
6778   verify_legal_class_modifiers(flags, CHECK);
6779 
6780   short bad_constant = class_bad_constant_seen();
6781   if (bad_constant != 0) {
6782     // Do not throw CFE until after the access_flags are checked because if
6783     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6784     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6785   }
6786 
</pre>
<hr />
<pre>
6878           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6879           classlist_file-&gt;flush();
6880         }
6881       }
6882     }
6883 #endif
6884   }
6885 
6886   // SUPERKLASS
6887   _super_class_index = stream-&gt;get_u2_fast();
6888   _super_klass = parse_super_class(cp,
6889                                    _super_class_index,
6890                                    _need_verify,
6891                                    CHECK);
6892 
6893   // Interfaces
6894   _itfs_len = stream-&gt;get_u2_fast();
6895   parse_interfaces(stream,
6896                    _itfs_len,
6897                    cp,
<span class="line-modified">6898                    is_value_type(),</span>
6899                    &amp;_has_nonstatic_concrete_methods,
6900                    &amp;_is_declared_atomic,
6901                    CHECK);
6902 
6903   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);
6904 
6905   // Fields (offsets are filled in later)
6906   _fac = new FieldAllocationCount();
6907   parse_fields(stream,
6908                is_interface(),
<span class="line-modified">6909                is_value_type(),</span>
6910                _fac,
6911                cp,
6912                cp_size,
6913                &amp;_java_fields_count,
6914                CHECK);
6915 
6916   assert(_fields != NULL, &quot;invariant&quot;);
6917 
6918   // Methods
6919   AccessFlags promoted_flags;
6920   parse_methods(stream,
6921                 is_interface(),
<span class="line-modified">6922                 is_value_type(),</span>
6923                 &amp;promoted_flags,
6924                 &amp;_has_final_method,
6925                 &amp;_declares_nonstatic_concrete_methods,
6926                 CHECK);
6927 
6928   assert(_methods != NULL, &quot;invariant&quot;);
6929 
6930   // promote flags from parse_methods() to the klass&#39; flags
6931   _access_flags.add_promoted_flags(promoted_flags.as_int());
6932 
6933   if (_declares_nonstatic_concrete_methods) {
6934     _has_nonstatic_concrete_methods = true;
6935   }
6936 
6937   // Additional attributes/annotations
6938   _parsed_annotations = new ClassAnnotationCollector();
6939   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6940 
6941   assert(_inner_classes != NULL, &quot;invariant&quot;);
6942 
</pre>
<hr />
<pre>
6995 
6996     if (_super_klass-&gt;is_interface()) {
6997       ResourceMark rm(THREAD);
6998       Exceptions::fthrow(
6999         THREAD_AND_LOCATION,
7000         vmSymbols::java_lang_IncompatibleClassChangeError(),
7001         &quot;class %s has interface %s as super class&quot;,
7002         _class_name-&gt;as_klass_external_name(),
7003         _super_klass-&gt;external_name()
7004       );
7005       return;
7006     }
7007 
7008     // Make sure super class is not final
7009     if (_super_klass-&gt;is_final()) {
7010       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
7011     }
7012 
7013     // For an inline class, only java/lang/Object or special abstract classes
7014     // are acceptable super classes.
<span class="line-modified">7015     if (is_value_type()) {</span>
7016       const InstanceKlass* super_ik = _super_klass;
7017       if (super_ik-&gt;invalid_inline_super()) {
7018         ResourceMark rm(THREAD);
7019         Exceptions::fthrow(
7020           THREAD_AND_LOCATION,
7021           vmSymbols::java_lang_IncompatibleClassChangeError(),
7022           &quot;inline class %s has an invalid super class %s&quot;,
7023           _class_name-&gt;as_klass_external_name(),
7024           _super_klass-&gt;external_name());
7025         return;
7026       }
7027     }
7028   }
7029 
7030   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
7031     // This is the original source of this condition.
7032     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
7033     _is_declared_atomic = true;
7034   } else if (*ForceNonTearable != &#39;\0&#39;) {
7035     // Allow a command line switch to force the same atomicity property:
7036     const char* class_name_str = _class_name-&gt;as_C_string();
7037     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
7038       _is_declared_atomic = true;
7039     }
7040   }
7041 
7042   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,
7043   // if super is marked invalid, or if is_invalid_super_for_inline_type()
7044   // returns true
7045   if (invalid_inline_super() ||
7046       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||
7047       is_invalid_super_for_inline_type()) {
7048     set_invalid_inline_super();
7049   }
7050 
<span class="line-modified">7051   if (!is_value_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
7052       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {
7053     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());
7054     _has_injected_identityObject = true;
7055   }
7056   int itfs_len = _temp_local_interfaces-&gt;length();
7057   if (itfs_len == 0) {
7058     _local_interfaces = Universe::the_empty_instance_klass_array();
7059   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {
7060     _local_interfaces = Universe::the_single_IdentityObject_klass_array();
7061   } else {
7062     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
7063     for (int i = 0; i &lt; itfs_len; i++) {
7064       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));
7065     }
7066   }
7067   _temp_local_interfaces = NULL;
7068   assert(_local_interfaces != NULL, &quot;invariant&quot;);
7069 
7070   // Compute the transitive list of all unique interfaces implemented by this class
7071   _transitive_interfaces =
</pre>
<hr />
<pre>
7092                                                     loader,
7093                                                     _class_name,
7094                                                     _local_interfaces,
7095                                                     CHECK);
7096 
7097   // Size of Java itable (in words)
7098   _itable_size = is_interface() ? 0 :
7099     klassItable::compute_itable_size(_transitive_interfaces);
7100 
7101   assert(_fac != NULL, &quot;invariant&quot;);
7102   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7103 
7104 
7105   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
7106     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {
7107       // Pre-load value class
7108       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
7109           Handle(THREAD, _loader_data-&gt;class_loader()),
7110           _protection_domain, true, CHECK);
7111       assert(klass != NULL, &quot;Sanity check&quot;);
<span class="line-modified">7112       assert(klass-&gt;access_flags().is_value_type(), &quot;Value type expected&quot;);</span>
7113       _has_flattenable_fields = true;
7114     }
7115   }
7116 
7117   _field_info = new FieldLayoutInfo();
7118   if (UseNewFieldLayout) {
7119     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">7120         _parsed_annotations-&gt;is_contended(), is_value_type(),</span>
7121         loader_data(), _protection_domain, _field_info);
7122     lb.build_layout(CHECK);
<span class="line-modified">7123     if (is_value_type()) {</span>
7124       _alignment = lb.get_alignment();
7125       _first_field_offset = lb.get_first_field_offset();
7126       _exact_size_in_bytes = lb.get_exact_size_in_byte();
7127     }
7128   } else {
7129     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7130   }
7131 
7132   // Compute reference type
7133   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
7134 }
7135 
7136 void ClassFileParser::set_klass(InstanceKlass* klass) {
7137 
7138 #ifdef ASSERT
7139   if (klass != NULL) {
7140     assert(NULL == _klass, &quot;leaking?&quot;);
7141   }
7142 #endif
7143 
</pre>
</td>
<td>
<hr />
<pre>
1590     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1591       count[i] = 0;
1592     }
1593   }
1594 
1595   FieldAllocationType update(bool is_static, BasicType type, bool is_flattenable) {
1596     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_flattenable);
1597     if (atype != BAD_ALLOCATION_TYPE) {
1598       // Make sure there is no overflow with injected fields.
1599       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1600       count[atype]++;
1601     }
1602     return atype;
1603   }
1604 };
1605 
1606 // Side-effects: populates the _fields, _fields_annotations,
1607 // _fields_type_annotations fields
1608 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1609                                    bool is_interface,
<span class="line-modified">1610                                    bool is_inline_type,</span>
1611                                    FieldAllocationCount* const fac,
1612                                    ConstantPool* cp,
1613                                    const int cp_size,
1614                                    u2* const java_fields_count_ptr,
1615                                    TRAPS) {
1616 
1617   assert(cfs != NULL, &quot;invariant&quot;);
1618   assert(fac != NULL, &quot;invariant&quot;);
1619   assert(cp != NULL, &quot;invariant&quot;);
1620   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1621 
1622   assert(NULL == _fields, &quot;invariant&quot;);
1623   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1624   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1625 
1626   cfs-&gt;guarantee_more(2, CHECK);  // length
1627   const u2 length = cfs-&gt;get_u2_fast();
1628   *java_fields_count_ptr = length;
1629 
1630   int num_injected = 0;
1631   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1632                                                                   &amp;num_injected);
1633 
1634   // two more slots are required for inline classes:
1635   // one for the static field with a reference to the pre-allocated default value
1636   // one for the field the JVM injects when detecting an empty inline class
<span class="line-modified">1637   const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);</span>
1638 
1639   // The field array starts with tuples of shorts
1640   // [access, name index, sig index, initial value index, byte offset].
1641   // A generic signature slot only exists for field with generic
1642   // signature attribute. And the access flag is set with
1643   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1644   // signature slots are at the end of the field array and after all
1645   // other fields data.
1646   //
1647   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1648   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1649   //       ...
1650   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1651   //       [generic signature index]
1652   //       [generic signature index]
1653   //       ...
1654   //
1655   // Allocate a temporary resource array for field data. For each field,
1656   // a slot is reserved in the temporary array for the generic signature
1657   // index. After parsing all fields, the data are copied to a permanent
1658   // array and any unused slots will be discarded.
1659   ResourceMark rm(THREAD);
1660   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1661                                               u2,
1662                                               total_fields * (FieldInfo::field_slots + 1));
1663 
1664   // The generic signature slots start after all other fields&#39; data.
1665   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1666   int num_generic_signature = 0;
1667   int instance_fields_count = 0;
1668   for (int n = 0; n &lt; length; n++) {
1669     // access_flags, name_index, descriptor_index, attributes_count
1670     cfs-&gt;guarantee_more(8, CHECK);
1671 
1672     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;
1673 
1674     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
<span class="line-modified">1675     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);</span>
1676     AccessFlags access_flags;
1677     access_flags.set_flags(flags);
1678 
1679     const u2 name_index = cfs-&gt;get_u2_fast();
1680     check_property(valid_symbol_at(name_index),
1681       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1682       name_index, CHECK);
1683     const Symbol* const name = cp-&gt;symbol_at(name_index);
1684     verify_legal_field_name(name, CHECK);
1685 
1686     const u2 signature_index = cfs-&gt;get_u2_fast();
1687     check_property(valid_symbol_at(signature_index),
1688       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1689       signature_index, CHECK);
1690     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1691     verify_legal_field_signature(name, sig, CHECK);
1692     assert(!access_flags.is_flattenable(), &quot;ACC_FLATTENABLE should have been filtered out&quot;);
1693     if (sig-&gt;is_Q_signature()) {
1694       // assert(_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS, &quot;Q-descriptors are only supported in recent classfiles&quot;);
1695       access_flags.set_is_flattenable();
</pre>
<hr />
<pre>
1799           continue;
1800         }
1801       }
1802 
1803       // Injected field
1804       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1805       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1806                         injected[n].name_index,
1807                         injected[n].signature_index,
1808                         0);
1809 
1810       const BasicType type = Signature::basic_type(injected[n].signature());
1811 
1812       // Remember how many oops we encountered and compute allocation type
1813       const FieldAllocationType atype = fac-&gt;update(false, type, false);
1814       field-&gt;set_allocation_type(atype);
1815       index++;
1816     }
1817   }
1818 
<span class="line-modified">1819   if (is_inline_type) {</span>
1820     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1821     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,
1822                       vmSymbols::default_value_name_enum,
1823                       vmSymbols::object_signature_enum,
1824                       0);
1825     const BasicType type = Signature::basic_type(vmSymbols::object_signature());
1826     const FieldAllocationType atype = fac-&gt;update(true, type, false);
1827     field-&gt;set_allocation_type(atype);
1828     index++;
1829   }
1830 
<span class="line-modified">1831   if (is_inline_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-modified">1832     _is_empty_inline_type = true;</span>
1833     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1834     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1835         vmSymbols::empty_marker_name_enum,
1836         vmSymbols::byte_signature_enum,
1837         0);
1838     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());
1839     const FieldAllocationType atype = fac-&gt;update(false, type, false);
1840     field-&gt;set_allocation_type(atype);
1841     index++;
1842   }
1843 
1844   if (instance_fields_count &gt; 0) {
1845     _has_nonstatic_fields = true;
1846   }
1847 
1848   assert(NULL == _fields, &quot;invariant&quot;);
1849 
1850   _fields =
1851     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1852                                    index * FieldInfo::field_slots + num_generic_signature,
</pre>
<hr />
<pre>
2144         checked_exception, CHECK_NULL);
2145     }
2146   }
2147   // check exceptions attribute length
2148   if (_need_verify) {
2149     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2150                                                    sizeof(u2) * size),
2151                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2152   }
2153   return checked_exceptions_start;
2154 }
2155 
2156 void ClassFileParser::throwIllegalSignature(const char* type,
2157                                             const Symbol* name,
2158                                             const Symbol* sig,
2159                                             TRAPS) const {
2160   assert(name != NULL, &quot;invariant&quot;);
2161   assert(sig != NULL, &quot;invariant&quot;);
2162 
2163   const char* class_note = &quot;&quot;;
<span class="line-modified">2164   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
2165     class_note = &quot; (an inline class)&quot;;
2166   }
2167 
2168   ResourceMark rm(THREAD);
2169   Exceptions::fthrow(THREAD_AND_LOCATION,
2170       vmSymbols::java_lang_ClassFormatError(),
2171       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,
2172       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());
2173 }
2174 
2175 AnnotationCollector::ID
2176 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2177                                       const Symbol* name) {
2178   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2179   // Privileged code can use all annotations.  Other code silently drops some.
2180   const bool privileged = loader_data-&gt;is_the_null_class_loader_data() ||
2181                           loader_data-&gt;is_platform_class_loader_data() ||
2182                           loader_data-&gt;is_unsafe_anonymous();
2183   switch (sid) {
2184     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
</pre>
<hr />
<pre>
2416                              runtime_visible_type_annotations_length,
2417                              runtime_invisible_type_annotations,
2418                              runtime_invisible_type_annotations_length,
2419                              CHECK);
2420     cm-&gt;set_type_annotations(a);
2421   }
2422 }
2423 
2424 
2425 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2426 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2427 // Method* to save footprint, so we only know the size of the resulting Method* when the
2428 // entire method attribute is parsed.
2429 //
2430 // The promoted_flags parameter is used to pass relevant access_flags
2431 // from the method back up to the containing klass. These flag values
2432 // are added to klass&#39;s access_flags.
2433 
2434 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2435                                       bool is_interface,
<span class="line-modified">2436                                       bool is_inline_type,</span>
2437                                       const ConstantPool* cp,
2438                                       AccessFlags* const promoted_flags,
2439                                       TRAPS) {
2440   assert(cfs != NULL, &quot;invariant&quot;);
2441   assert(cp != NULL, &quot;invariant&quot;);
2442   assert(promoted_flags != NULL, &quot;invariant&quot;);
2443 
2444   ResourceMark rm(THREAD);
2445   // Parse fixed parts:
2446   // access_flags, name_index, descriptor_index, attributes_count
2447   cfs-&gt;guarantee_more(8, CHECK_NULL);
2448 
2449   int flags = cfs-&gt;get_u2_fast();
2450   const u2 name_index = cfs-&gt;get_u2_fast();
2451   const int cp_size = cp-&gt;length();
2452   check_property(
2453     valid_symbol_at(name_index),
2454     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2455     name_index, CHECK_NULL);
2456   const Symbol* const name = cp-&gt;symbol_at(name_index);
2457   verify_legal_method_name(name, CHECK_NULL);
2458 
2459   const u2 signature_index = cfs-&gt;get_u2_fast();
2460   guarantee_property(
2461     valid_symbol_at(signature_index),
2462     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2463     signature_index, CHECK_NULL);
2464   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2465 
2466   if (name == vmSymbols::class_initializer_name()) {
2467     // We ignore the other access flags for a valid class initializer.
2468     // (JVM Spec 2nd ed., chapter 4.6)
2469     if (_major_version &lt; 51) { // backward compatibility
2470       flags = JVM_ACC_STATIC;
2471     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2472       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2473     } else {
2474       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2475     }
2476   } else {
<span class="line-modified">2477     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);</span>
2478   }
2479 
2480   if (name == vmSymbols::object_initializer_name()) {
2481     if (is_interface) {
2482       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
<span class="line-modified">2483     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
2484       // OK, a constructor
<span class="line-modified">2485     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
2486       // also OK, a static factory, as long as the return value is good
2487       bool ok = false;
2488       SignatureStream ss((Symbol*) signature, true);
2489       while (!ss.at_return_type())  ss.next();
2490       if (ss.is_reference()) {
2491         Symbol* ret = ss.as_symbol();
2492         const Symbol* required = class_name();
2493         if (is_unsafe_anonymous()) {
2494           // The original class name in the UAC byte stream gets changed.  So
2495           // using the original name in the return type is no longer valid.
2496           required = vmSymbols::java_lang_Object();
2497         }
2498         ok = (ret == required);
2499       }
2500       if (!ok) {
2501         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2502       }
2503     } else {
2504       // not OK, so throw the same error as in verify_legal_method_signature.
2505       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
</pre>
<hr />
<pre>
3049       _has_finalizer = true;
3050     }
3051   }
3052   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3053       signature == vmSymbols::void_method_signature() &amp;&amp;
3054       m-&gt;is_vanilla_constructor()) {
3055     _has_vanilla_constructor = true;
3056   }
3057 
3058   NOT_PRODUCT(m-&gt;verify());
3059   return m;
3060 }
3061 
3062 
3063 // The promoted_flags parameter is used to pass relevant access_flags
3064 // from the methods back up to the containing klass. These flag values
3065 // are added to klass&#39;s access_flags.
3066 // Side-effects: populates the _methods field in the parser
3067 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3068                                     bool is_interface,
<span class="line-modified">3069                                     bool is_inline_type,</span>
3070                                     AccessFlags* promoted_flags,
3071                                     bool* has_final_method,
3072                                     bool* declares_nonstatic_concrete_methods,
3073                                     TRAPS) {
3074   assert(cfs != NULL, &quot;invariant&quot;);
3075   assert(promoted_flags != NULL, &quot;invariant&quot;);
3076   assert(has_final_method != NULL, &quot;invariant&quot;);
3077   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3078 
3079   assert(NULL == _methods, &quot;invariant&quot;);
3080 
3081   cfs-&gt;guarantee_more(2, CHECK);  // length
3082   const u2 length = cfs-&gt;get_u2_fast();
3083   if (length == 0) {
3084     _methods = Universe::the_empty_method_array();
3085   } else {
3086     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3087                                                    length,
3088                                                    NULL,
3089                                                    CHECK);
3090 
3091     for (int index = 0; index &lt; length; index++) {
3092       Method* method = parse_method(cfs,
3093                                     is_interface,
<span class="line-modified">3094                                     is_inline_type,</span>
3095                                     _cp,
3096                                     promoted_flags,
3097                                     CHECK);
3098 
3099       if (method-&gt;is_final()) {
3100         *has_final_method = true;
3101       }
3102       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3103       // used for interface initialization, and default method inheritance analysis
3104       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3105         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3106         *declares_nonstatic_concrete_methods = true;
3107       }
3108       _methods-&gt;at_put(index, method);
3109     }
3110 
3111     if (_need_verify &amp;&amp; length &gt; 1) {
3112       // Check duplicated methods
3113       ResourceMark rm(THREAD);
3114       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3274         valid_klass_reference_at(outer_class_info_index),
3275       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3276       outer_class_info_index, CHECK_0);
3277     // Inner class name
3278     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3279     check_property(
3280       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3281       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3282       inner_name_index, CHECK_0);
3283     if (_need_verify) {
3284       guarantee_property(inner_class_info_index != outer_class_info_index,
3285                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3286     }
3287 
3288     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;
3289     // JVM_ACC_MODULE is defined in JDK-9 and later.
3290     if (_major_version &gt;= JAVA_9_VERSION) {
3291       recognized_modifiers |= JVM_ACC_MODULE;
3292     }
3293     // JVM_ACC_VALUE is defined for class file version 55 and later
<span class="line-modified">3294     if (supports_inline_types()) {</span>
3295       recognized_modifiers |= JVM_ACC_VALUE;
3296     }
3297 
3298     // Access flags
3299     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
3300 
3301     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3302       // Set abstract bit for old class files for backward compatibility
3303       flags |= JVM_ACC_ABSTRACT;
3304     }
3305     verify_legal_class_modifiers(flags, CHECK_0);
3306     AccessFlags inner_access_flags(flags);
3307 
3308     inner_classes-&gt;at_put(index++, inner_class_info_index);
3309     inner_classes-&gt;at_put(index++, outer_class_info_index);
3310     inner_classes-&gt;at_put(index++, inner_name_index);
3311     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3312   }
3313 
3314   // 4347400: make sure there&#39;s no duplicate entry in the classes array
</pre>
<hr />
<pre>
3657   bool parsed_sourcefile_attribute = false;
3658   bool parsed_innerclasses_attribute = false;
3659   bool parsed_nest_members_attribute = false;
3660   bool parsed_nest_host_attribute = false;
3661   bool parsed_record_attribute = false;
3662   bool parsed_enclosingmethod_attribute = false;
3663   bool parsed_bootstrap_methods_attribute = false;
3664   const u1* runtime_visible_annotations = NULL;
3665   int runtime_visible_annotations_length = 0;
3666   const u1* runtime_invisible_annotations = NULL;
3667   int runtime_invisible_annotations_length = 0;
3668   const u1* runtime_visible_type_annotations = NULL;
3669   int runtime_visible_type_annotations_length = 0;
3670   const u1* runtime_invisible_type_annotations = NULL;
3671   int runtime_invisible_type_annotations_length = 0;
3672   bool runtime_invisible_type_annotations_exists = false;
3673   bool runtime_invisible_annotations_exists = false;
3674   bool parsed_source_debug_ext_annotations_exist = false;
3675   const u1* inner_classes_attribute_start = NULL;
3676   u4  inner_classes_attribute_length = 0;


3677   u2  enclosing_method_class_index = 0;
3678   u2  enclosing_method_method_index = 0;
3679   const u1* nest_members_attribute_start = NULL;
3680   u4  nest_members_attribute_length = 0;
3681   const u1* record_attribute_start = NULL;
3682   u4  record_attribute_length = 0;
3683 
3684   // Iterate over attributes
3685   while (attributes_count--) {
3686     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3687     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3688     const u4 attribute_length = cfs-&gt;get_u4_fast();
3689     check_property(
3690       valid_symbol_at(attribute_name_index),
3691       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3692       attribute_name_index, CHECK);
3693     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3694     if (tag == vmSymbols::tag_source_file()) {
3695       // Check for SourceFile tag
3696       if (_need_verify) {
</pre>
<hr />
<pre>
4241 }
4242 
4243 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4244   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4245   if (_nonstatic_oop_map_count &gt; 0) {
4246     OopMapBlock* map = _nonstatic_oop_maps;
4247     OopMapBlock* last_map = last_oop_map();
4248     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4249     while (map &lt;= last_map) {
4250       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4251                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4252       map++;
4253     }
4254   }
4255 }
4256 
4257 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4258   print_on(st);
4259 }
4260 
<span class="line-modified">4261 void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-modified">4262                                                 const char* msg,</span>
<span class="line-modified">4263                                                 const Symbol* name,</span>
<span class="line-modified">4264                                                 const Symbol* sig) const {</span>
4265 
4266   ResourceMark rm(THREAD);
4267   if (name == NULL || sig == NULL) {
4268     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4269         vmSymbols::java_lang_ClassFormatError(),
4270         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);
4271   }
4272   else {
4273     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4274         vmSymbols::java_lang_ClassFormatError(),
4275         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),
4276         _class_name-&gt;as_C_string(), msg);
4277   }
4278 }
4279 
4280 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4281 void ClassFileParser::layout_fields(ConstantPool* cp,
4282                                     const FieldAllocationCount* fac,
4283                                     const ClassAnnotationCollector* parsed_annotations,
4284                                     FieldLayoutInfo* info,
4285                                     TRAPS) {
4286 
4287   assert(cp != NULL, &quot;invariant&quot;);
4288 
4289   // Field size and offset computation
4290   int nonstatic_field_size = _super_klass == NULL ? 0 :
4291                                _super_klass-&gt;nonstatic_field_size();
<span class="line-modified">4292   int next_nonstatic_inline_type_offset = 0;</span>
<span class="line-modified">4293   int first_nonstatic_inline_type_offset = 0;</span>
4294 
<span class="line-modified">4295   // Fields that are inline types are handled differently depending if they are static or not:</span>
4296   // - static fields are oops
4297   // - non-static fields are embedded
4298 
4299   // Count the contended fields by type.
4300   //
4301   // We ignore static fields, because @Contended is not supported for them.
4302   // The layout code below will also ignore the static fields.
4303   int nonstatic_contended_count = 0;
4304   FieldAllocationCount fac_contended;
4305   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4306     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4307     if (fs.is_contended()) {
4308       fac_contended.count[atype]++;
4309       if (!fs.access_flags().is_static()) {
4310         nonstatic_contended_count++;
4311       }
4312     }
4313   }
4314 
4315 
4316   // Calculate the starting byte offsets
4317   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<span class="line-modified">4318   // Inline types in static fields are not embedded, they are handled with oops</span>
4319   int next_static_double_offset = next_static_oop_offset +
4320                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);
4321   if (fac-&gt;count[STATIC_DOUBLE]) {
4322     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4323   }
4324 
4325   int next_static_word_offset   = next_static_double_offset +
4326                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4327   int next_static_short_offset  = next_static_word_offset +
4328                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4329   int next_static_byte_offset   = next_static_short_offset +
4330                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4331 
4332   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4333                                 nonstatic_field_size * heapOopSize;
4334 
<span class="line-modified">4335   // First field of inline types is aligned on a long boundary in order to ease</span>
<span class="line-modified">4336   // in-lining of inline types (with header removal) in packed arrays and</span>
<span class="line-modified">4337   // flatten inline types</span>
<span class="line-modified">4338   int initial_inline_type_padding = 0;</span>
<span class="line-modified">4339   if (is_inline_type()) {</span>
4340     int old = nonstatic_fields_start;
4341     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);
<span class="line-modified">4342     initial_inline_type_padding = nonstatic_fields_start - old;</span>
4343   }
4344 
4345   int next_nonstatic_field_offset = nonstatic_fields_start;
4346 
4347   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4348 
4349   // Class is contended, pad before all the fields
4350   if (is_contended_class) {
4351     next_nonstatic_field_offset += ContendedPaddingWidth;
4352   }
4353 
<span class="line-modified">4354   // Temporary inline types restrictions</span>
<span class="line-modified">4355   if (is_inline_type()) {</span>
4356     if (is_contended_class) {
<span class="line-modified">4357       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
4358       return;
4359     }
4360   }
4361 
4362   // Compute the non-contended fields count.
4363   // The packing code below relies on these counts to determine if some field
4364   // can be squeezed into the alignment gap. Contended fields are obviously
4365   // exempt from that.
4366   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4367   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4368   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4369   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4370   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4371 
<span class="line-modified">4372   int static_inline_type_count = 0;</span>
<span class="line-modified">4373   int nonstatic_inline_type_count = 0;</span>
<span class="line-modified">4374   int* nonstatic_inline_type_indexes = NULL;</span>
<span class="line-modified">4375   Klass** nonstatic_inline_type_klasses = NULL;</span>
<span class="line-modified">4376   unsigned int inline_type_oop_map_count = 0;</span>
<span class="line-modified">4377   int not_flattened_inline_types = 0;</span>
<span class="line-modified">4378   int not_atomic_inline_types = 0;</span>
4379 
<span class="line-modified">4380   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
4381 
<span class="line-modified">4382   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-modified">4383                                                                max_nonstatic_inline_type);</span>
<span class="line-modified">4384   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {</span>
<span class="line-modified">4385     nonstatic_inline_type_indexes[i] = -1;</span>
4386   }
<span class="line-modified">4387   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-modified">4388                                                                max_nonstatic_inline_type);</span>
4389 
4390   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
4391     if (fs.allocation_type() == STATIC_FLATTENABLE) {
4392       ResourceMark rm;
4393       if (!fs.signature()-&gt;is_Q_signature()) {
4394         THROW(vmSymbols::java_lang_ClassFormatError());
4395       }
<span class="line-modified">4396       static_inline_type_count++;</span>
4397     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {
<span class="line-modified">4398       // Pre-resolve the flattenable field and check for inline type circularity issues.</span>
4399       ResourceMark rm;
4400       if (!fs.signature()-&gt;is_Q_signature()) {
4401         THROW(vmSymbols::java_lang_ClassFormatError());
4402       }
4403       Klass* klass =
4404         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
4405                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4406                                                             _protection_domain, true, CHECK);
4407       assert(klass != NULL, &quot;Sanity check&quot;);
<span class="line-modified">4408       if (!klass-&gt;access_flags().is_inline_type()) {</span>
4409         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4410       }
4411       ValueKlass* vk = ValueKlass::cast(klass);
4412       // Conditions to apply flattening or not should be defined in a single place
4413       bool too_big_to_flatten = (ValueFieldMaxFlatSize &gt;= 0 &amp;&amp;
4414                                  (vk-&gt;size_helper() * HeapWordSize) &gt; ValueFieldMaxFlatSize);
4415       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
4416       bool too_volatile_to_flatten = fs.access_flags().is_volatile();
4417       if (vk-&gt;is_naturally_atomic()) {
4418         too_atomic_to_flatten = false;
4419         //too_volatile_to_flatten = false; //FIXME
4420         // volatile fields are currently never flattened, this could change in the future
4421       }
4422       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
<span class="line-modified">4423         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();</span>
<span class="line-modified">4424         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;</span>
<span class="line-modified">4425         nonstatic_inline_type_count++;</span>
4426 
4427         ValueKlass* vklass = ValueKlass::cast(klass);
4428         if (vklass-&gt;contains_oops()) {
<span class="line-modified">4429           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
4430         }
4431         fs.set_flattened(true);
4432         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
<span class="line-modified">4433           not_atomic_inline_types++;</span>
4434         }
4435       } else {
<span class="line-modified">4436         not_flattened_inline_types++;</span>
4437         fs.set_flattened(false);
4438       }
4439     }
4440   }
4441 
<span class="line-modified">4442   // Adjusting non_static_oop_count to take into account not flattened inline types;</span>
<span class="line-modified">4443   nonstatic_oop_count += not_flattened_inline_types;</span>
4444 
4445   // Total non-static fields count, including every contended field
4446   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4447                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4448                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];
4449 
4450   const bool super_has_nonstatic_fields =
4451           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4452   const bool has_nonstatic_fields =
4453     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-modified">4454   const bool has_nonstatic_value_fields = nonstatic_inline_type_count &gt; 0;</span>
4455 
<span class="line-modified">4456   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
4457     // There are a number of fixes required throughout the type system and JIT
<span class="line-modified">4458     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
4459     return;
4460   }
4461 
4462   // Prepare list of oops for oop map generation.
4463   //
4464   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4465   // regions. offset[i] is the start of the i-th region, which then has
4466   // count[i] oops following. Before we know how many regions are required,
4467   // we pessimistically allocate the maps to fit all the oops into the
4468   // distinct regions.
4469   //
4470   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
4471   int max_oop_map_count =
4472       super_oop_map_count +
4473       fac-&gt;count[NONSTATIC_OOP] +
<span class="line-modified">4474       inline_type_oop_map_count +</span>
<span class="line-modified">4475       not_flattened_inline_types;</span>
4476 
4477   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4478   if (super_oop_map_count &gt; 0) {
4479     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4480                                                     _super_klass-&gt;nonstatic_oop_map_count());
4481   }
4482 
4483   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4484 
4485   bool compact_fields  = true;
4486   bool allocate_oops_first = false;
4487 
4488   // The next classes have predefined hard-coded fields offsets
4489   // (see in JavaClasses::compute_hard_coded_offsets()).
4490   // Use default fields allocation order for them.
4491   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;
4492       (_class_name == vmSymbols::java_lang_ref_Reference() ||
4493        _class_name == vmSymbols::java_lang_Boolean() ||
4494        _class_name == vmSymbols::java_lang_Character() ||
4495        _class_name == vmSymbols::java_lang_Float() ||
</pre>
<hr />
<pre>
4567   }
4568 
4569   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4570                                      (nonstatic_double_count * BytesPerLong);
4571   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4572                                       (nonstatic_word_count * BytesPerInt);
4573   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4574                                      (nonstatic_short_count * BytesPerShort);
4575   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4576                                        nonstatic_byte_count;
4577 
4578   // let oops jump before padding with this allocation style
4579   if (!allocate_oops_first) {
4580     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4581     if( nonstatic_oop_count &gt; 0 ) {
4582       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4583     }
4584     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4585   }
4586 
<span class="line-modified">4587   // Aligning embedded inline types</span>
<span class="line-modified">4588   // bug below, the current algorithm to layout embedded inline types always put them at the</span>
4589   // end of the layout, which doesn&#39;t match the different allocation policies the VM is
4590   // supposed to provide =&gt; FixMe
<span class="line-modified">4591   // Note also that the current alignment policy is to make each inline type starting on a</span>
4592   // 64 bits boundary. This could be optimized later. For instance, it could be nice to
<span class="line-modified">4593   // align inline types according to their most constrained internal type.</span>
<span class="line-modified">4594   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-modified">4595   int next_inline_type_index = 0;</span>
4596 
4597   // Iterate over fields again and compute correct offsets.
4598   // The field allocation type was temporarily stored in the offset slot.
4599   // oop fields are located before non-oop fields (static and non-static).
4600   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4601 
4602     // skip already laid out fields
4603     if (fs.is_offset_set()) continue;
4604 
4605     // contended instance fields are handled below
4606     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4607 
4608     int real_offset = 0;
4609     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4610 
4611     // pack the rest of the fields
4612     switch (atype) {
<span class="line-modified">4613       // Inline types in static fields are handled with oops</span>
4614       case STATIC_FLATTENABLE:   // Fallthrough
4615       case STATIC_OOP:
4616         real_offset = next_static_oop_offset;
4617         next_static_oop_offset += heapOopSize;
4618         break;
4619       case STATIC_BYTE:
4620         real_offset = next_static_byte_offset;
4621         next_static_byte_offset += 1;
4622         break;
4623       case STATIC_SHORT:
4624         real_offset = next_static_short_offset;
4625         next_static_short_offset += BytesPerShort;
4626         break;
4627       case STATIC_WORD:
4628         real_offset = next_static_word_offset;
4629         next_static_word_offset += BytesPerInt;
4630         break;
4631       case STATIC_DOUBLE:
4632         real_offset = next_static_double_offset;
4633         next_static_double_offset += BytesPerLong;
4634         break;
4635       case NONSTATIC_FLATTENABLE:
4636         if (fs.is_flattened()) {
<span class="line-modified">4637           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];</span>
4638           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);
<span class="line-modified">4639           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);</span>
4640           ValueKlass* vklass = ValueKlass::cast(klass);
<span class="line-modified">4641           real_offset = next_nonstatic_inline_type_offset;</span>
<span class="line-modified">4642           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-modified">4643           // aligning next inline type on a 64 bits boundary</span>
<span class="line-modified">4644           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);</span>
<span class="line-modified">4645           next_inline_type_index += 1;</span>
4646 
4647           if (vklass-&gt;contains_oops()) { // add flatten oop maps
4648             int diff = real_offset - vklass-&gt;first_field_offset();
4649             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();
4650             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();
4651             while (map &lt; last_map) {
4652               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());
4653               map++;
4654             }
4655           }
4656           break;
4657         } else {
4658           // Fall through
4659         }
4660       case NONSTATIC_OOP:
4661         if( nonstatic_oop_space_count &gt; 0 ) {
4662           real_offset = nonstatic_oop_space_offset;
4663           nonstatic_oop_space_offset += heapOopSize;
4664           nonstatic_oop_space_count  -= 1;
4665         } else {
</pre>
<hr />
<pre>
4758             break;
4759 
4760           case NONSTATIC_SHORT:
4761             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4762             real_offset = next_nonstatic_padded_offset;
4763             next_nonstatic_padded_offset += BytesPerShort;
4764             break;
4765 
4766           case NONSTATIC_WORD:
4767             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4768             real_offset = next_nonstatic_padded_offset;
4769             next_nonstatic_padded_offset += BytesPerInt;
4770             break;
4771 
4772           case NONSTATIC_DOUBLE:
4773             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4774             real_offset = next_nonstatic_padded_offset;
4775             next_nonstatic_padded_offset += BytesPerLong;
4776             break;
4777 
<span class="line-modified">4778             // Inline types in static fields are handled with oops</span>
4779           case NONSTATIC_FLATTENABLE:
<span class="line-modified">4780             throwInlineTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-modified">4781                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
4782             return;
4783 
4784           case NONSTATIC_OOP:
4785             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4786             real_offset = next_nonstatic_padded_offset;
4787             next_nonstatic_padded_offset += heapOopSize;
4788             nonstatic_oop_maps-&gt;add(real_offset, 1);
4789             break;
4790 
4791           default:
4792             ShouldNotReachHere();
4793         }
4794 
4795         if (fs.contended_group() == 0) {
4796           // Contended group defines the equivalence class over the fields:
4797           // the fields within the same contended group are not inter-padded.
4798           // The only exception is default group, which does not incur the
4799           // equivalence, and so requires intra-padding.
4800           next_nonstatic_padded_offset += ContendedPaddingWidth;
4801         }
</pre>
<hr />
<pre>
4803         fs.set_offset(real_offset);
4804       } // for
4805 
4806       // Start laying out the next group.
4807       // Note that this will effectively pad the last group in the back;
4808       // this is expected to alleviate memory contention effects for
4809       // subclass fields and/or adjacent object.
4810       // If this was the default group, the padding is already in place.
4811       if (current_group != 0) {
4812         next_nonstatic_padded_offset += ContendedPaddingWidth;
4813       }
4814     }
4815 
4816     // handle static fields
4817   }
4818 
4819   // Entire class is contended, pad in the back.
4820   // This helps to alleviate memory contention effects for subclass fields
4821   // and/or adjacent object.
4822   if (is_contended_class) {
<span class="line-modified">4823     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);</span>
4824     next_nonstatic_padded_offset += ContendedPaddingWidth;
4825   }
4826 
4827   int notaligned_nonstatic_fields_end;
<span class="line-modified">4828   if (nonstatic_inline_type_count != 0) {</span>
<span class="line-modified">4829     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;</span>
4830   } else {
4831     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
4832   }
4833 
4834   int nonstatic_field_sz_align = heapOopSize;
<span class="line-modified">4835   if (is_inline_type()) {</span>
4836     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {
4837       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy
4838     }
4839   }
4840   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);
4841   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4842   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4843 
4844   int static_field_size         = (static_fields_end -
4845                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4846   nonstatic_field_size          = nonstatic_field_size +
4847                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4848 
4849   int instance_size             = align_object_size(instance_end / wordSize);
4850 
4851   assert(instance_size == align_object_size(align_up(
4852          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
<span class="line-modified">4853          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
4854 
4855 
4856   // Invariant: nonstatic_field end/start should only change if there are
4857   // nonstatic fields in the class, or if the class is contended. We compare
4858   // against the non-aligned value, so that end alignment will not fail the
4859   // assert without actually having the fields.
4860   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4861          is_contended_class ||
4862          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4863 
4864   // Number of non-static oop map blocks allocated at end of klass.
4865   nonstatic_oop_maps-&gt;compact();
4866 
4867 #ifndef PRODUCT
<span class="line-modified">4868   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||</span>
<span class="line-modified">4869       (PrintValueLayout &amp;&amp; (is_inline_type() || has_nonstatic_value_fields))) {</span>
4870     print_field_layout(_class_name,
4871           _fields,
4872           cp,
4873           instance_size,
4874           nonstatic_fields_start,
4875           nonstatic_fields_end,
4876           static_fields_end);
4877     nonstatic_oop_maps-&gt;print_on(tty);
4878     tty-&gt;print(&quot;\n&quot;);
4879     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4880     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4881     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4882     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4883     tty-&gt;print_cr(&quot;---&quot;);
4884   }
4885 
4886 #endif
4887   // Pass back information needed for InstanceKlass creation
4888   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4889   info-&gt;_instance_size = instance_size;
4890   info-&gt;_static_field_size = static_field_size;
4891   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4892   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
4893 
<span class="line-modified">4894   // An inline type is naturally atomic if it has just one field, and</span>
4895   // that field is simple enough.
<span class="line-modified">4896   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;</span>
4897                                 !super_has_nonstatic_fields &amp;&amp;
4898                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;
<span class="line-modified">4899                                 (not_atomic_inline_types == 0) &amp;&amp;</span>
4900                                 (nonstatic_contended_count == 0));
4901   // This may be too restrictive, since if all the fields fit in 64
4902   // bits we could make the decision to align instances of this class
4903   // to 64-bit boundaries, and load and store them as single words.
4904   // And on machines which supported larger atomics we could similarly
4905   // allow larger values to be atomic, if properly aligned.
4906 }
4907 
4908 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4909   assert(ik != NULL, &quot;invariant&quot;);
4910 
4911   const Klass* const super = ik-&gt;super();
4912 
4913   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4914   // in which case we don&#39;t have to register objects as finalizable
4915   if (!_has_empty_finalizer) {
4916     if (_has_finalizer ||
4917         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4918       ik-&gt;set_has_finalizer();
4919     }
</pre>
<hr />
<pre>
4923   bool f = false;
4924   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4925                                            vmSymbols::void_method_signature());
4926   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4927       f = true;
4928   }
4929 
4930   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4931   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4932   // will not work as expected we shouldn&#39;t abort vm in this case
4933   if (!ik-&gt;has_redefined_this_or_super()) {
4934     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4935   }
4936 #endif
4937 
4938   // Check if this klass supports the java.lang.Cloneable interface
4939   if (SystemDictionary::Cloneable_klass_loaded()) {
4940     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
4941       if (ik-&gt;is_value()) {
4942         Thread *THREAD = Thread::current();
<span class="line-modified">4943         throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
4944         return;
4945       }
4946       ik-&gt;set_is_cloneable();
4947     }
4948   }
4949 
4950   // Check if this klass has a vanilla default constructor
4951   if (super == NULL) {
4952     // java.lang.Object has empty default constructor
4953     ik-&gt;set_has_vanilla_constructor();
4954   } else {
4955     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4956         _has_vanilla_constructor) {
4957       ik-&gt;set_has_vanilla_constructor();
4958     }
4959 #ifdef ASSERT
4960     bool v = false;
4961     if (super-&gt;has_vanilla_constructor()) {
4962       const Method* const constructor =
4963         ik-&gt;find_method(vmSymbols::object_initializer_name(),
</pre>
<hr />
<pre>
4966         v = true;
4967       }
4968     }
4969     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4970 #endif
4971   }
4972 
4973   // If it cannot be fast-path allocated, set a bit in the layout helper.
4974   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4975   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4976   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4977       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4978       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4979       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4980     // Forbid fast-path allocation.
4981     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4982     ik-&gt;set_layout_helper(lh);
4983   }
4984 }
4985 
<span class="line-modified">4986 bool ClassFileParser::supports_inline_types() const {</span>
<span class="line-modified">4987   // Inline types are only supported by class file version 55 and later</span>
4988   return _major_version &gt;= JAVA_11_VERSION;
4989 }
4990 
4991 // utility methods for appending an array with check for duplicates
4992 
4993 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4994                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4995   // iterate over new interfaces
4996   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4997     InstanceKlass* const e = ifs-&gt;at(i);
4998     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4999     // add new interface
5000     result-&gt;append_if_missing(e);
5001   }
5002 }
5003 
5004 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
5005                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
5006                                                             ClassLoaderData* loader_data,
5007                                                             TRAPS) {
</pre>
<hr />
<pre>
5240     const Method* const m = methods-&gt;at(index);
5241     // if m is static and not the init method, throw a verify error
5242     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
5243       ResourceMark rm(THREAD);
5244       Exceptions::fthrow(
5245         THREAD_AND_LOCATION,
5246         vmSymbols::java_lang_VerifyError(),
5247         &quot;Illegal static method %s in interface %s&quot;,
5248         m-&gt;name()-&gt;as_C_string(),
5249         this_klass-&gt;external_name()
5250       );
5251       return;
5252     }
5253   }
5254 }
5255 
5256 // utility methods for format checking
5257 
5258 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
5259   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-modified">5260   const bool is_inline_type = (flags &amp; JVM_ACC_VALUE) != 0;</span>
5261   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-modified">5262   assert(supports_inline_types() || !is_inline_type, &quot;JVM_ACC_VALUE should not be set&quot;);</span>
5263   if (is_module) {
5264     ResourceMark rm(THREAD);
5265     Exceptions::fthrow(
5266       THREAD_AND_LOCATION,
5267       vmSymbols::java_lang_NoClassDefFoundError(),
5268       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
5269       _class_name-&gt;as_C_string());
5270     return;
5271   }
5272 
<span class="line-modified">5273   if (is_inline_type &amp;&amp; !EnableValhalla) {</span>
5274     ResourceMark rm(THREAD);
5275     Exceptions::fthrow(
5276       THREAD_AND_LOCATION,
5277       vmSymbols::java_lang_ClassFormatError(),
5278       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,
5279       _class_name-&gt;as_C_string()
5280     );
5281   }
5282 
5283   if (!_need_verify) { return; }
5284 
5285   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
5286   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
5287   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
5288   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
5289   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
5290   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5291   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5292   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5293 
5294   if ((is_abstract &amp;&amp; is_final) ||
5295       (is_interface &amp;&amp; !is_abstract) ||
5296       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
5297       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||
<span class="line-modified">5298       (is_inline_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
5299     ResourceMark rm(THREAD);
5300     const char* class_note = &quot;&quot;;
<span class="line-modified">5301     if (is_inline_type)  class_note = &quot; (an inline class)&quot;;</span>
5302     Exceptions::fthrow(
5303       THREAD_AND_LOCATION,
5304       vmSymbols::java_lang_ClassFormatError(),
5305       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,
5306       _class_name-&gt;as_C_string(), class_note, flags
5307     );
5308     return;
5309   }
5310 }
5311 
5312 static bool has_illegal_visibility(jint flags) {
5313   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5314   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5315   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5316 
5317   return ((is_public &amp;&amp; is_protected) ||
5318           (is_public &amp;&amp; is_private) ||
5319           (is_protected &amp;&amp; is_private));
5320 }
5321 
</pre>
<hr />
<pre>
5365     if (!Arguments::enable_preview()) {
5366       Exceptions::fthrow(
5367         THREAD_AND_LOCATION,
5368         vmSymbols::java_lang_UnsupportedClassVersionError(),
5369         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5370         class_name-&gt;as_C_string(), major, minor);
5371       return;
5372     }
5373 
5374   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5375     Exceptions::fthrow(
5376         THREAD_AND_LOCATION,
5377         vmSymbols::java_lang_UnsupportedClassVersionError(),
5378         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5379         class_name-&gt;as_C_string(), major, minor);
5380   }
5381 }
5382 
5383 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5384                                                    bool is_interface,
<span class="line-modified">5385                                                    bool is_inline_type,</span>
5386                                                    TRAPS) const {
5387   if (!_need_verify) { return; }
5388 
5389   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5390   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5391   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5392   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5393   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5394   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5395   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5396   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5397   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5398 
5399   bool is_illegal = false;
5400 
5401   if (is_interface) {
5402     if (!is_public || !is_static || !is_final || is_private ||
5403         is_protected || is_volatile || is_transient ||
5404         (major_gte_1_5 &amp;&amp; is_enum)) {
5405       is_illegal = true;
5406     }
5407   } else { // not interface
5408     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5409       is_illegal = true;
5410     } else {
<span class="line-modified">5411       if (is_inline_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
5412         is_illegal = true;
5413       }
5414     }
5415   }
5416 
5417   if (is_illegal) {
5418     ResourceMark rm(THREAD);
5419     Exceptions::fthrow(
5420       THREAD_AND_LOCATION,
5421       vmSymbols::java_lang_ClassFormatError(),
5422       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5423       _class_name-&gt;as_C_string(), flags);
5424     return;
5425   }
5426 }
5427 
5428 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5429                                                     bool is_interface,
<span class="line-modified">5430                                                     bool is_inline_type,</span>
5431                                                     const Symbol* name,
5432                                                     TRAPS) const {
5433   if (!_need_verify) { return; }
5434 
5435   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5436   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5437   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5438   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5439   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5440   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5441   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5442   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5443   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5444   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5445   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5446   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5447   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5448 
5449   bool is_illegal = false;
5450 
</pre>
<hr />
<pre>
5471       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5472       if (!is_public || is_private || is_protected || is_static || is_final ||
5473           is_synchronized || is_native || !is_abstract || is_strict) {
5474         is_illegal = true;
5475       }
5476     } else {
5477       // Class file version is pre-JAVA_1_5_VERSION
5478       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5479         is_illegal = true;
5480       }
5481     }
5482   } else { // not interface
5483     if (has_illegal_visibility(flags)) {
5484       is_illegal = true;
5485     } else {
5486       if (is_initializer) {
5487         if (is_final || is_synchronized || is_native ||
5488             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5489           is_illegal = true;
5490         }
<span class="line-modified">5491         if (!is_static &amp;&amp; !is_inline_type) {</span>
5492           // OK, an object constructor in a regular class
<span class="line-modified">5493         } else if (is_static &amp;&amp; is_inline_type) {</span>
5494           // OK, a static init factory in an inline class
5495         } else {
5496           // but no other combinations are allowed
5497           is_illegal = true;
<span class="line-modified">5498           class_note = (is_inline_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
5499         }
5500       } else { // not initializer
<span class="line-modified">5501         if (is_inline_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
5502           is_illegal = true;
5503           class_note = &quot; (an inline class)&quot;;
5504         } else {
5505           if (is_abstract) {
5506             if ((is_final || is_native || is_private || is_static ||
5507                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {
5508               is_illegal = true;
5509             }
5510           }
5511         }
5512       }
5513     }
5514   }
5515 
5516   if (is_illegal) {
5517     ResourceMark rm(THREAD);
5518     Exceptions::fthrow(
5519       THREAD_AND_LOCATION,
5520       vmSymbols::java_lang_ClassFormatError(),
5521       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,
</pre>
<hr />
<pre>
6133 
6134   set_klass_to_deallocate(ik);
6135 
6136   assert(_field_info != NULL, &quot;invariant&quot;);
6137   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6138   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6139          &quot;sanity&quot;);
6140 
6141   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6142   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6143 
6144   // Fill in information already parsed
6145   ik-&gt;set_should_verify_class(_need_verify);
6146 
6147   // Not yet: supers are done below to support the new subtype-checking fields
6148   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6149   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
6150   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
6151     ik-&gt;set_is_naturally_atomic();
6152   }
<span class="line-modified">6153   if (_is_empty_inline_type) {</span>
<span class="line-modified">6154     ik-&gt;set_is_empty_inline_type();</span>
6155   }
6156 
6157   if (this-&gt;_invalid_inline_super) {
6158     ik-&gt;set_invalid_inline_super();
6159   }
6160 
6161   if (_has_injected_identityObject) {
6162     ik-&gt;set_has_injected_identityObject();
6163   }
6164 
6165   assert(_fac != NULL, &quot;invariant&quot;);
6166   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6167 
6168   // this transfers ownership of a lot of arrays from
6169   // the parser onto the InstanceKlass*
6170   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6171 
6172   // note that is not safe to use the fields in the parser from this point on
6173   assert(NULL == _cp, &quot;invariant&quot;);
6174   assert(NULL == _fields, &quot;invariant&quot;);
</pre>
<hr />
<pre>
6310   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6311   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6312       !module_entry-&gt;has_default_read_edges()) {
6313     if (!module_entry-&gt;set_has_default_read_edges()) {
6314       // We won a potential race
6315       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6316     }
6317   }
6318 
6319   int nfields = ik-&gt;java_fields_count();
6320   if (ik-&gt;is_value()) nfields++;
6321   for (int i = 0; i &lt; nfields; i++) {
6322     if (ik-&gt;field_is_flattenable(i)) {
6323       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);
6324       // Inline classes for instance fields must have been pre-loaded
6325       // Inline classes for static fields might not have been loaded yet
6326       Klass* klass = SystemDictionary::find(klass_name,
6327           Handle(THREAD, ik-&gt;class_loader()),
6328           Handle(THREAD, ik-&gt;protection_domain()), CHECK);
6329       if (klass != NULL) {
<span class="line-modified">6330         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
6331         ik-&gt;set_value_field_klass(i, klass);
6332       }
6333       klass_name-&gt;decrement_refcount();
6334     } else
<span class="line-modified">6335       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
6336         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
6337       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
6338     }
6339   }
6340 
<span class="line-modified">6341   if (is_inline_type()) {</span>
6342     ValueKlass* vk = ValueKlass::cast(ik);
6343     if (UseNewFieldLayout) {
6344       vk-&gt;set_alignment(_alignment);
6345       vk-&gt;set_first_field_offset(_first_field_offset);
6346       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);
6347     } else {
6348       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());
6349     }
6350     ValueKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);
6351   }
6352 
6353   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6354 
6355   if (!is_internal()) {
6356     if (log_is_enabled(Info, class, load)) {
6357       ResourceMark rm;
6358       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6359       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6360     }
6361 
</pre>
<hr />
<pre>
6531   _bad_constant_seen(0),
6532   _synthetic_flag(false),
6533   _sde_length(false),
6534   _sde_buffer(NULL),
6535   _sourcefile_index(0),
6536   _generic_signature_index(0),
6537   _major_version(0),
6538   _minor_version(0),
6539   _this_class_index(0),
6540   _super_class_index(0),
6541   _itfs_len(0),
6542   _java_fields_count(0),
6543   _need_verify(false),
6544   _relax_verify(false),
6545   _has_nonstatic_concrete_methods(false),
6546   _declares_nonstatic_concrete_methods(false),
6547   _has_final_method(false),
6548   _has_contended_fields(false),
6549   _has_flattenable_fields(false),
6550   _has_nonstatic_fields(false),
<span class="line-modified">6551   _is_empty_inline_type(false),</span>
6552   _is_naturally_atomic(false),
6553   _is_declared_atomic(false),
6554   _invalid_inline_super(false),
6555   _invalid_identity_super(false),
6556   _implements_identityObject(false),
6557   _has_injected_identityObject(false),
6558   _has_finalizer(false),
6559   _has_empty_finalizer(false),
6560   _has_vanilla_constructor(false),
6561   _max_bootstrap_specifier_index(-1) {
6562 
6563   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6564   _class_name-&gt;increment_refcount();
6565 
6566   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6567   assert(_loader_data != NULL, &quot;invariant&quot;);
6568   assert(stream != NULL, &quot;invariant&quot;);
6569   assert(_stream != NULL, &quot;invariant&quot;);
6570   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6571   assert(_class_name != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
6744 
6745   _cp = ConstantPool::allocate(_loader_data,
6746                                cp_size,
6747                                CHECK);
6748 
6749   ConstantPool* const cp = _cp;
6750 
6751   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6752 
6753   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6754 
6755   // ACCESS FLAGS
6756   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6757 
6758   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;
6759   // JVM_ACC_MODULE is defined in JDK-9 and later.
6760   if (_major_version &gt;= JAVA_9_VERSION) {
6761     recognized_modifiers |= JVM_ACC_MODULE;
6762   }
6763   // JVM_ACC_VALUE is defined for class file version 55 and later
<span class="line-modified">6764   if (supports_inline_types()) {</span>
6765     recognized_modifiers |= JVM_ACC_VALUE;
6766   }
6767 
6768   // Access flags
6769   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;
6770 
6771   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6772     // Set abstract bit for old class files for backward compatibility
6773     flags |= JVM_ACC_ABSTRACT;
6774   }
6775 
6776   verify_legal_class_modifiers(flags, CHECK);
6777 
6778   short bad_constant = class_bad_constant_seen();
6779   if (bad_constant != 0) {
6780     // Do not throw CFE until after the access_flags are checked because if
6781     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6782     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6783   }
6784 
</pre>
<hr />
<pre>
6876           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6877           classlist_file-&gt;flush();
6878         }
6879       }
6880     }
6881 #endif
6882   }
6883 
6884   // SUPERKLASS
6885   _super_class_index = stream-&gt;get_u2_fast();
6886   _super_klass = parse_super_class(cp,
6887                                    _super_class_index,
6888                                    _need_verify,
6889                                    CHECK);
6890 
6891   // Interfaces
6892   _itfs_len = stream-&gt;get_u2_fast();
6893   parse_interfaces(stream,
6894                    _itfs_len,
6895                    cp,
<span class="line-modified">6896                    is_inline_type(),</span>
6897                    &amp;_has_nonstatic_concrete_methods,
6898                    &amp;_is_declared_atomic,
6899                    CHECK);
6900 
6901   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);
6902 
6903   // Fields (offsets are filled in later)
6904   _fac = new FieldAllocationCount();
6905   parse_fields(stream,
6906                is_interface(),
<span class="line-modified">6907                is_inline_type(),</span>
6908                _fac,
6909                cp,
6910                cp_size,
6911                &amp;_java_fields_count,
6912                CHECK);
6913 
6914   assert(_fields != NULL, &quot;invariant&quot;);
6915 
6916   // Methods
6917   AccessFlags promoted_flags;
6918   parse_methods(stream,
6919                 is_interface(),
<span class="line-modified">6920                 is_inline_type(),</span>
6921                 &amp;promoted_flags,
6922                 &amp;_has_final_method,
6923                 &amp;_declares_nonstatic_concrete_methods,
6924                 CHECK);
6925 
6926   assert(_methods != NULL, &quot;invariant&quot;);
6927 
6928   // promote flags from parse_methods() to the klass&#39; flags
6929   _access_flags.add_promoted_flags(promoted_flags.as_int());
6930 
6931   if (_declares_nonstatic_concrete_methods) {
6932     _has_nonstatic_concrete_methods = true;
6933   }
6934 
6935   // Additional attributes/annotations
6936   _parsed_annotations = new ClassAnnotationCollector();
6937   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6938 
6939   assert(_inner_classes != NULL, &quot;invariant&quot;);
6940 
</pre>
<hr />
<pre>
6993 
6994     if (_super_klass-&gt;is_interface()) {
6995       ResourceMark rm(THREAD);
6996       Exceptions::fthrow(
6997         THREAD_AND_LOCATION,
6998         vmSymbols::java_lang_IncompatibleClassChangeError(),
6999         &quot;class %s has interface %s as super class&quot;,
7000         _class_name-&gt;as_klass_external_name(),
7001         _super_klass-&gt;external_name()
7002       );
7003       return;
7004     }
7005 
7006     // Make sure super class is not final
7007     if (_super_klass-&gt;is_final()) {
7008       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
7009     }
7010 
7011     // For an inline class, only java/lang/Object or special abstract classes
7012     // are acceptable super classes.
<span class="line-modified">7013     if (is_inline_type()) {</span>
7014       const InstanceKlass* super_ik = _super_klass;
7015       if (super_ik-&gt;invalid_inline_super()) {
7016         ResourceMark rm(THREAD);
7017         Exceptions::fthrow(
7018           THREAD_AND_LOCATION,
7019           vmSymbols::java_lang_IncompatibleClassChangeError(),
7020           &quot;inline class %s has an invalid super class %s&quot;,
7021           _class_name-&gt;as_klass_external_name(),
7022           _super_klass-&gt;external_name());
7023         return;
7024       }
7025     }
7026   }
7027 
7028   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
7029     // This is the original source of this condition.
7030     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
7031     _is_declared_atomic = true;
7032   } else if (*ForceNonTearable != &#39;\0&#39;) {
7033     // Allow a command line switch to force the same atomicity property:
7034     const char* class_name_str = _class_name-&gt;as_C_string();
7035     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
7036       _is_declared_atomic = true;
7037     }
7038   }
7039 
7040   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,
7041   // if super is marked invalid, or if is_invalid_super_for_inline_type()
7042   // returns true
7043   if (invalid_inline_super() ||
7044       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||
7045       is_invalid_super_for_inline_type()) {
7046     set_invalid_inline_super();
7047   }
7048 
<span class="line-modified">7049   if (!is_inline_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
7050       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {
7051     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());
7052     _has_injected_identityObject = true;
7053   }
7054   int itfs_len = _temp_local_interfaces-&gt;length();
7055   if (itfs_len == 0) {
7056     _local_interfaces = Universe::the_empty_instance_klass_array();
7057   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {
7058     _local_interfaces = Universe::the_single_IdentityObject_klass_array();
7059   } else {
7060     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
7061     for (int i = 0; i &lt; itfs_len; i++) {
7062       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));
7063     }
7064   }
7065   _temp_local_interfaces = NULL;
7066   assert(_local_interfaces != NULL, &quot;invariant&quot;);
7067 
7068   // Compute the transitive list of all unique interfaces implemented by this class
7069   _transitive_interfaces =
</pre>
<hr />
<pre>
7090                                                     loader,
7091                                                     _class_name,
7092                                                     _local_interfaces,
7093                                                     CHECK);
7094 
7095   // Size of Java itable (in words)
7096   _itable_size = is_interface() ? 0 :
7097     klassItable::compute_itable_size(_transitive_interfaces);
7098 
7099   assert(_fac != NULL, &quot;invariant&quot;);
7100   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7101 
7102 
7103   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
7104     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {
7105       // Pre-load value class
7106       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
7107           Handle(THREAD, _loader_data-&gt;class_loader()),
7108           _protection_domain, true, CHECK);
7109       assert(klass != NULL, &quot;Sanity check&quot;);
<span class="line-modified">7110       assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
7111       _has_flattenable_fields = true;
7112     }
7113   }
7114 
7115   _field_info = new FieldLayoutInfo();
7116   if (UseNewFieldLayout) {
7117     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">7118         _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
7119         loader_data(), _protection_domain, _field_info);
7120     lb.build_layout(CHECK);
<span class="line-modified">7121     if (is_inline_type()) {</span>
7122       _alignment = lb.get_alignment();
7123       _first_field_offset = lb.get_first_field_offset();
7124       _exact_size_in_bytes = lb.get_exact_size_in_byte();
7125     }
7126   } else {
7127     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7128   }
7129 
7130   // Compute reference type
7131   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
7132 }
7133 
7134 void ClassFileParser::set_klass(InstanceKlass* klass) {
7135 
7136 #ifdef ASSERT
7137   if (klass != NULL) {
7138     assert(NULL == _klass, &quot;leaking?&quot;);
7139   }
7140 #endif
7141 
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/x86/templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
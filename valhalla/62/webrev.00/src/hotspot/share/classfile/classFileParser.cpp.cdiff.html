<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/templateTable_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1605,11 ***</span>
  
  // Side-effects: populates the _fields, _fields_annotations,
  // _fields_type_annotations fields
  void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
                                     bool is_interface,
<span class="line-modified">!                                    bool is_value_type,</span>
                                     FieldAllocationCount* const fac,
                                     ConstantPool* cp,
                                     const int cp_size,
                                     u2* const java_fields_count_ptr,
                                     TRAPS) {
<span class="line-new-header">--- 1605,11 ---</span>
  
  // Side-effects: populates the _fields, _fields_annotations,
  // _fields_type_annotations fields
  void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
                                     bool is_interface,
<span class="line-modified">!                                    bool is_inline_type,</span>
                                     FieldAllocationCount* const fac,
                                     ConstantPool* cp,
                                     const int cp_size,
                                     u2* const java_fields_count_ptr,
                                     TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1632,11 ***</span>
                                                                    &amp;num_injected);
  
    // two more slots are required for inline classes:
    // one for the static field with a reference to the pre-allocated default value
    // one for the field the JVM injects when detecting an empty inline class
<span class="line-modified">!   const int total_fields = length + num_injected + (is_value_type ? 2 : 0);</span>
  
    // The field array starts with tuples of shorts
    // [access, name index, sig index, initial value index, byte offset].
    // A generic signature slot only exists for field with generic
    // signature attribute. And the access flag is set with
<span class="line-new-header">--- 1632,11 ---</span>
                                                                    &amp;num_injected);
  
    // two more slots are required for inline classes:
    // one for the static field with a reference to the pre-allocated default value
    // one for the field the JVM injects when detecting an empty inline class
<span class="line-modified">!   const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);</span>
  
    // The field array starts with tuples of shorts
    // [access, name index, sig index, initial value index, byte offset].
    // A generic signature slot only exists for field with generic
    // signature attribute. And the access flag is set with
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1670,11 ***</span>
      cfs-&gt;guarantee_more(8, CHECK);
  
      jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;
  
      const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
<span class="line-modified">!     verify_legal_field_modifiers(flags, is_interface, is_value_type, CHECK);</span>
      AccessFlags access_flags;
      access_flags.set_flags(flags);
  
      const u2 name_index = cfs-&gt;get_u2_fast();
      check_property(valid_symbol_at(name_index),
<span class="line-new-header">--- 1670,11 ---</span>
      cfs-&gt;guarantee_more(8, CHECK);
  
      jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;
  
      const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
<span class="line-modified">!     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);</span>
      AccessFlags access_flags;
      access_flags.set_flags(flags);
  
      const u2 name_index = cfs-&gt;get_u2_fast();
      check_property(valid_symbol_at(name_index),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1814,11 ***</span>
        field-&gt;set_allocation_type(atype);
        index++;
      }
    }
  
<span class="line-modified">!   if (is_value_type) {</span>
      FieldInfo* const field = FieldInfo::from_field_array(fa, index);
      field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,
                        vmSymbols::default_value_name_enum,
                        vmSymbols::object_signature_enum,
                        0);
<span class="line-new-header">--- 1814,11 ---</span>
        field-&gt;set_allocation_type(atype);
        index++;
      }
    }
  
<span class="line-modified">!   if (is_inline_type) {</span>
      FieldInfo* const field = FieldInfo::from_field_array(fa, index);
      field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,
                        vmSymbols::default_value_name_enum,
                        vmSymbols::object_signature_enum,
                        0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1826,12 ***</span>
      const FieldAllocationType atype = fac-&gt;update(true, type, false);
      field-&gt;set_allocation_type(atype);
      index++;
    }
  
<span class="line-modified">!   if (is_value_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-modified">!     _is_empty_value = true;</span>
      FieldInfo* const field = FieldInfo::from_field_array(fa, index);
      field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
          vmSymbols::empty_marker_name_enum,
          vmSymbols::byte_signature_enum,
          0);
<span class="line-new-header">--- 1826,12 ---</span>
      const FieldAllocationType atype = fac-&gt;update(true, type, false);
      field-&gt;set_allocation_type(atype);
      index++;
    }
  
<span class="line-modified">!   if (is_inline_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-modified">!     _is_empty_inline_type = true;</span>
      FieldInfo* const field = FieldInfo::from_field_array(fa, index);
      field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
          vmSymbols::empty_marker_name_enum,
          vmSymbols::byte_signature_enum,
          0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2159,11 ***</span>
                                              TRAPS) const {
    assert(name != NULL, &quot;invariant&quot;);
    assert(sig != NULL, &quot;invariant&quot;);
  
    const char* class_note = &quot;&quot;;
<span class="line-modified">!   if (is_value_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
      class_note = &quot; (an inline class)&quot;;
    }
  
    ResourceMark rm(THREAD);
    Exceptions::fthrow(THREAD_AND_LOCATION,
<span class="line-new-header">--- 2159,11 ---</span>
                                              TRAPS) const {
    assert(name != NULL, &quot;invariant&quot;);
    assert(sig != NULL, &quot;invariant&quot;);
  
    const char* class_note = &quot;&quot;;
<span class="line-modified">!   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
      class_note = &quot; (an inline class)&quot;;
    }
  
    ResourceMark rm(THREAD);
    Exceptions::fthrow(THREAD_AND_LOCATION,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2431,11 ***</span>
  // from the method back up to the containing klass. These flag values
  // are added to klass&#39;s access_flags.
  
  Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
                                        bool is_interface,
<span class="line-modified">!                                       bool is_value_type,</span>
                                        const ConstantPool* cp,
                                        AccessFlags* const promoted_flags,
                                        TRAPS) {
    assert(cfs != NULL, &quot;invariant&quot;);
    assert(cp != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 2431,11 ---</span>
  // from the method back up to the containing klass. These flag values
  // are added to klass&#39;s access_flags.
  
  Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
                                        bool is_interface,
<span class="line-modified">!                                       bool is_inline_type,</span>
                                        const ConstantPool* cp,
                                        AccessFlags* const promoted_flags,
                                        TRAPS) {
    assert(cfs != NULL, &quot;invariant&quot;);
    assert(cp != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2472,19 ***</span>
        flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
      } else {
        classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
      }
    } else {
<span class="line-modified">!     verify_legal_method_modifiers(flags, is_interface, is_value_type, name, CHECK_NULL);</span>
    }
  
    if (name == vmSymbols::object_initializer_name()) {
      if (is_interface) {
        classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
<span class="line-modified">!     } else if (!is_value_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
        // OK, a constructor
<span class="line-modified">!     } else if (is_value_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
        // also OK, a static factory, as long as the return value is good
        bool ok = false;
        SignatureStream ss((Symbol*) signature, true);
        while (!ss.at_return_type())  ss.next();
        if (ss.is_reference()) {
<span class="line-new-header">--- 2472,19 ---</span>
        flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
      } else {
        classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
      }
    } else {
<span class="line-modified">!     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);</span>
    }
  
    if (name == vmSymbols::object_initializer_name()) {
      if (is_interface) {
        classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
<span class="line-modified">!     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
        // OK, a constructor
<span class="line-modified">!     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
        // also OK, a static factory, as long as the return value is good
        bool ok = false;
        SignatureStream ss((Symbol*) signature, true);
        while (!ss.at_return_type())  ss.next();
        if (ss.is_reference()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3064,11 ***</span>
  // from the methods back up to the containing klass. These flag values
  // are added to klass&#39;s access_flags.
  // Side-effects: populates the _methods field in the parser
  void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
                                      bool is_interface,
<span class="line-modified">!                                     bool is_value_type,</span>
                                      AccessFlags* promoted_flags,
                                      bool* has_final_method,
                                      bool* declares_nonstatic_concrete_methods,
                                      TRAPS) {
    assert(cfs != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 3064,11 ---</span>
  // from the methods back up to the containing klass. These flag values
  // are added to klass&#39;s access_flags.
  // Side-effects: populates the _methods field in the parser
  void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
                                      bool is_interface,
<span class="line-modified">!                                     bool is_inline_type,</span>
                                      AccessFlags* promoted_flags,
                                      bool* has_final_method,
                                      bool* declares_nonstatic_concrete_methods,
                                      TRAPS) {
    assert(cfs != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3089,11 ***</span>
                                                     CHECK);
  
      for (int index = 0; index &lt; length; index++) {
        Method* method = parse_method(cfs,
                                      is_interface,
<span class="line-modified">!                                     is_value_type,</span>
                                      _cp,
                                      promoted_flags,
                                      CHECK);
  
        if (method-&gt;is_final()) {
<span class="line-new-header">--- 3089,11 ---</span>
                                                     CHECK);
  
      for (int index = 0; index &lt; length; index++) {
        Method* method = parse_method(cfs,
                                      is_interface,
<span class="line-modified">!                                     is_inline_type,</span>
                                      _cp,
                                      promoted_flags,
                                      CHECK);
  
        if (method-&gt;is_final()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3289,11 ***</span>
      // JVM_ACC_MODULE is defined in JDK-9 and later.
      if (_major_version &gt;= JAVA_9_VERSION) {
        recognized_modifiers |= JVM_ACC_MODULE;
      }
      // JVM_ACC_VALUE is defined for class file version 55 and later
<span class="line-modified">!     if (supports_value_types()) {</span>
        recognized_modifiers |= JVM_ACC_VALUE;
      }
  
      // Access flags
      jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
<span class="line-new-header">--- 3289,11 ---</span>
      // JVM_ACC_MODULE is defined in JDK-9 and later.
      if (_major_version &gt;= JAVA_9_VERSION) {
        recognized_modifiers |= JVM_ACC_MODULE;
      }
      // JVM_ACC_VALUE is defined for class file version 55 and later
<span class="line-modified">!     if (supports_inline_types()) {</span>
        recognized_modifiers |= JVM_ACC_VALUE;
      }
  
      // Access flags
      jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3672,12 ***</span>
    bool runtime_invisible_type_annotations_exists = false;
    bool runtime_invisible_annotations_exists = false;
    bool parsed_source_debug_ext_annotations_exist = false;
    const u1* inner_classes_attribute_start = NULL;
    u4  inner_classes_attribute_length = 0;
<span class="line-removed">-   const u1* value_types_attribute_start = NULL;</span>
<span class="line-removed">-   u4 value_types_attribute_length = 0;</span>
    u2  enclosing_method_class_index = 0;
    u2  enclosing_method_method_index = 0;
    const u1* nest_members_attribute_start = NULL;
    u4  nest_members_attribute_length = 0;
    const u1* record_attribute_start = NULL;
<span class="line-new-header">--- 3672,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4258,14 ***</span>
  
  void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
    print_on(st);
  }
  
<span class="line-modified">! void ClassFileParser::throwValueTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-modified">!                                                const char* msg,</span>
<span class="line-modified">!                                                const Symbol* name,</span>
<span class="line-modified">!                                                const Symbol* sig) const {</span>
  
    ResourceMark rm(THREAD);
    if (name == NULL || sig == NULL) {
      Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
          vmSymbols::java_lang_ClassFormatError(),
<span class="line-new-header">--- 4256,14 ---</span>
  
  void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
    print_on(st);
  }
  
<span class="line-modified">! void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-modified">!                                                 const char* msg,</span>
<span class="line-modified">!                                                 const Symbol* name,</span>
<span class="line-modified">!                                                 const Symbol* sig) const {</span>
  
    ResourceMark rm(THREAD);
    if (name == NULL || sig == NULL) {
      Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
          vmSymbols::java_lang_ClassFormatError(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4289,14 ***</span>
    assert(cp != NULL, &quot;invariant&quot;);
  
    // Field size and offset computation
    int nonstatic_field_size = _super_klass == NULL ? 0 :
                                 _super_klass-&gt;nonstatic_field_size();
<span class="line-modified">!   int next_nonstatic_valuetype_offset = 0;</span>
<span class="line-modified">!   int first_nonstatic_valuetype_offset = 0;</span>
  
<span class="line-modified">!   // Fields that are value types are handled differently depending if they are static or not:</span>
    // - static fields are oops
    // - non-static fields are embedded
  
    // Count the contended fields by type.
    //
<span class="line-new-header">--- 4287,14 ---</span>
    assert(cp != NULL, &quot;invariant&quot;);
  
    // Field size and offset computation
    int nonstatic_field_size = _super_klass == NULL ? 0 :
                                 _super_klass-&gt;nonstatic_field_size();
<span class="line-modified">!   int next_nonstatic_inline_type_offset = 0;</span>
<span class="line-modified">!   int first_nonstatic_inline_type_offset = 0;</span>
  
<span class="line-modified">!   // Fields that are inline types are handled differently depending if they are static or not:</span>
    // - static fields are oops
    // - non-static fields are embedded
  
    // Count the contended fields by type.
    //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4315,11 ***</span>
    }
  
  
    // Calculate the starting byte offsets
    int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<span class="line-modified">!   // Value types in static fields are not embedded, they are handled with oops</span>
    int next_static_double_offset = next_static_oop_offset +
                                    ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);
    if (fac-&gt;count[STATIC_DOUBLE]) {
      next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
    }
<span class="line-new-header">--- 4313,11 ---</span>
    }
  
  
    // Calculate the starting byte offsets
    int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<span class="line-modified">!   // Inline types in static fields are not embedded, they are handled with oops</span>
    int next_static_double_offset = next_static_oop_offset +
                                    ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);
    if (fac-&gt;count[STATIC_DOUBLE]) {
      next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4332,18 ***</span>
                                    ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
  
    int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
                                  nonstatic_field_size * heapOopSize;
  
<span class="line-modified">!   // First field of value types is aligned on a long boundary in order to ease</span>
<span class="line-modified">!   // in-lining of value types (with header removal) in packed arrays and</span>
<span class="line-modified">!   // flatten value types</span>
<span class="line-modified">!   int initial_value_type_padding = 0;</span>
<span class="line-modified">!   if (is_value_type()) {</span>
      int old = nonstatic_fields_start;
      nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);
<span class="line-modified">!     initial_value_type_padding = nonstatic_fields_start - old;</span>
    }
  
    int next_nonstatic_field_offset = nonstatic_fields_start;
  
    const bool is_contended_class     = parsed_annotations-&gt;is_contended();
<span class="line-new-header">--- 4330,18 ---</span>
                                    ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
  
    int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
                                  nonstatic_field_size * heapOopSize;
  
<span class="line-modified">!   // First field of inline types is aligned on a long boundary in order to ease</span>
<span class="line-modified">!   // in-lining of inline types (with header removal) in packed arrays and</span>
<span class="line-modified">!   // flatten inline types</span>
<span class="line-modified">!   int initial_inline_type_padding = 0;</span>
<span class="line-modified">!   if (is_inline_type()) {</span>
      int old = nonstatic_fields_start;
      nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);
<span class="line-modified">!     initial_inline_type_padding = nonstatic_fields_start - old;</span>
    }
  
    int next_nonstatic_field_offset = nonstatic_fields_start;
  
    const bool is_contended_class     = parsed_annotations-&gt;is_contended();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4351,14 ***</span>
    // Class is contended, pad before all the fields
    if (is_contended_class) {
      next_nonstatic_field_offset += ContendedPaddingWidth;
    }
  
<span class="line-modified">!   // Temporary value types restrictions</span>
<span class="line-modified">!   if (is_value_type()) {</span>
      if (is_contended_class) {
<span class="line-modified">!       throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
        return;
      }
    }
  
    // Compute the non-contended fields count.
<span class="line-new-header">--- 4349,14 ---</span>
    // Class is contended, pad before all the fields
    if (is_contended_class) {
      next_nonstatic_field_offset += ContendedPaddingWidth;
    }
  
<span class="line-modified">!   // Temporary inline types restrictions</span>
<span class="line-modified">!   if (is_inline_type()) {</span>
      if (is_contended_class) {
<span class="line-modified">!       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
        return;
      }
    }
  
    // Compute the non-contended fields count.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4369,47 ***</span>
    unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
    unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
    unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
    unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
  
<span class="line-modified">!   int static_value_type_count = 0;</span>
<span class="line-modified">!   int nonstatic_value_type_count = 0;</span>
<span class="line-modified">!   int* nonstatic_value_type_indexes = NULL;</span>
<span class="line-modified">!   Klass** nonstatic_value_type_klasses = NULL;</span>
<span class="line-modified">!   unsigned int value_type_oop_map_count = 0;</span>
<span class="line-modified">!   int not_flattened_value_types = 0;</span>
<span class="line-modified">!   int not_atomic_value_types = 0;</span>
  
<span class="line-modified">!   int max_nonstatic_value_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
  
<span class="line-modified">!   nonstatic_value_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-modified">!                                                               max_nonstatic_value_type);</span>
<span class="line-modified">!   for (int i = 0; i &lt; max_nonstatic_value_type; i++) {</span>
<span class="line-modified">!     nonstatic_value_type_indexes[i] = -1;</span>
    }
<span class="line-modified">!   nonstatic_value_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-modified">!                                                               max_nonstatic_value_type);</span>
  
    for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
      if (fs.allocation_type() == STATIC_FLATTENABLE) {
        ResourceMark rm;
        if (!fs.signature()-&gt;is_Q_signature()) {
          THROW(vmSymbols::java_lang_ClassFormatError());
        }
<span class="line-modified">!       static_value_type_count++;</span>
      } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {
<span class="line-modified">!       // Pre-resolve the flattenable field and check for value type circularity issues.</span>
        ResourceMark rm;
        if (!fs.signature()-&gt;is_Q_signature()) {
          THROW(vmSymbols::java_lang_ClassFormatError());
        }
        Klass* klass =
          SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
                                                              Handle(THREAD, _loader_data-&gt;class_loader()),
                                                              _protection_domain, true, CHECK);
        assert(klass != NULL, &quot;Sanity check&quot;);
<span class="line-modified">!       if (!klass-&gt;access_flags().is_value_type()) {</span>
          THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
        }
        ValueKlass* vk = ValueKlass::cast(klass);
        // Conditions to apply flattening or not should be defined in a single place
        bool too_big_to_flatten = (ValueFieldMaxFlatSize &gt;= 0 &amp;&amp;
<span class="line-new-header">--- 4367,47 ---</span>
    unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
    unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
    unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
    unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
  
<span class="line-modified">!   int static_inline_type_count = 0;</span>
<span class="line-modified">!   int nonstatic_inline_type_count = 0;</span>
<span class="line-modified">!   int* nonstatic_inline_type_indexes = NULL;</span>
<span class="line-modified">!   Klass** nonstatic_inline_type_klasses = NULL;</span>
<span class="line-modified">!   unsigned int inline_type_oop_map_count = 0;</span>
<span class="line-modified">!   int not_flattened_inline_types = 0;</span>
<span class="line-modified">!   int not_atomic_inline_types = 0;</span>
  
<span class="line-modified">!   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
  
<span class="line-modified">!   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-modified">!                                                                max_nonstatic_inline_type);</span>
<span class="line-modified">!   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {</span>
<span class="line-modified">!     nonstatic_inline_type_indexes[i] = -1;</span>
    }
<span class="line-modified">!   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-modified">!                                                                max_nonstatic_inline_type);</span>
  
    for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
      if (fs.allocation_type() == STATIC_FLATTENABLE) {
        ResourceMark rm;
        if (!fs.signature()-&gt;is_Q_signature()) {
          THROW(vmSymbols::java_lang_ClassFormatError());
        }
<span class="line-modified">!       static_inline_type_count++;</span>
      } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {
<span class="line-modified">!       // Pre-resolve the flattenable field and check for inline type circularity issues.</span>
        ResourceMark rm;
        if (!fs.signature()-&gt;is_Q_signature()) {
          THROW(vmSymbols::java_lang_ClassFormatError());
        }
        Klass* klass =
          SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
                                                              Handle(THREAD, _loader_data-&gt;class_loader()),
                                                              _protection_domain, true, CHECK);
        assert(klass != NULL, &quot;Sanity check&quot;);
<span class="line-modified">!       if (!klass-&gt;access_flags().is_inline_type()) {</span>
          THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
        }
        ValueKlass* vk = ValueKlass::cast(klass);
        // Conditions to apply flattening or not should be defined in a single place
        bool too_big_to_flatten = (ValueFieldMaxFlatSize &gt;= 0 &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4420,46 ***</span>
          too_atomic_to_flatten = false;
          //too_volatile_to_flatten = false; //FIXME
          // volatile fields are currently never flattened, this could change in the future
        }
        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
<span class="line-modified">!         nonstatic_value_type_indexes[nonstatic_value_type_count] = fs.index();</span>
<span class="line-modified">!         nonstatic_value_type_klasses[nonstatic_value_type_count] = klass;</span>
<span class="line-modified">!         nonstatic_value_type_count++;</span>
  
          ValueKlass* vklass = ValueKlass::cast(klass);
          if (vklass-&gt;contains_oops()) {
<span class="line-modified">!           value_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
          }
          fs.set_flattened(true);
          if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
<span class="line-modified">!           not_atomic_value_types++;</span>
          }
        } else {
<span class="line-modified">!         not_flattened_value_types++;</span>
          fs.set_flattened(false);
        }
      }
    }
  
<span class="line-modified">!   // Adjusting non_static_oop_count to take into account not flattened value types;</span>
<span class="line-modified">!   nonstatic_oop_count += not_flattened_value_types;</span>
  
    // Total non-static fields count, including every contended field
    unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
                                          fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
                                          fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];
  
    const bool super_has_nonstatic_fields =
            (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
    const bool has_nonstatic_fields =
      super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-modified">!   const bool has_nonstatic_value_fields = nonstatic_value_type_count &gt; 0;</span>
  
<span class="line-modified">!   if (is_value_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
      // There are a number of fixes required throughout the type system and JIT
<span class="line-modified">!     throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
      return;
    }
  
    // Prepare list of oops for oop map generation.
    //
<span class="line-new-header">--- 4418,46 ---</span>
          too_atomic_to_flatten = false;
          //too_volatile_to_flatten = false; //FIXME
          // volatile fields are currently never flattened, this could change in the future
        }
        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
<span class="line-modified">!         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();</span>
<span class="line-modified">!         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;</span>
<span class="line-modified">!         nonstatic_inline_type_count++;</span>
  
          ValueKlass* vklass = ValueKlass::cast(klass);
          if (vklass-&gt;contains_oops()) {
<span class="line-modified">!           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
          }
          fs.set_flattened(true);
          if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
<span class="line-modified">!           not_atomic_inline_types++;</span>
          }
        } else {
<span class="line-modified">!         not_flattened_inline_types++;</span>
          fs.set_flattened(false);
        }
      }
    }
  
<span class="line-modified">!   // Adjusting non_static_oop_count to take into account not flattened inline types;</span>
<span class="line-modified">!   nonstatic_oop_count += not_flattened_inline_types;</span>
  
    // Total non-static fields count, including every contended field
    unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
                                          fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
                                          fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];
  
    const bool super_has_nonstatic_fields =
            (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
    const bool has_nonstatic_fields =
      super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-modified">!   const bool has_nonstatic_value_fields = nonstatic_inline_type_count &gt; 0;</span>
  
<span class="line-modified">!   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
      // There are a number of fixes required throughout the type system and JIT
<span class="line-modified">!     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
      return;
    }
  
    // Prepare list of oops for oop map generation.
    //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4471,12 ***</span>
    //
    int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
    int max_oop_map_count =
        super_oop_map_count +
        fac-&gt;count[NONSTATIC_OOP] +
<span class="line-modified">!       value_type_oop_map_count +</span>
<span class="line-modified">!       not_flattened_value_types;</span>
  
    OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
    if (super_oop_map_count &gt; 0) {
      nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
                                                      _super_klass-&gt;nonstatic_oop_map_count());
<span class="line-new-header">--- 4469,12 ---</span>
    //
    int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
    int max_oop_map_count =
        super_oop_map_count +
        fac-&gt;count[NONSTATIC_OOP] +
<span class="line-modified">!       inline_type_oop_map_count +</span>
<span class="line-modified">!       not_flattened_inline_types;</span>
  
    OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
    if (super_oop_map_count &gt; 0) {
      nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
                                                      _super_klass-&gt;nonstatic_oop_map_count());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4584,19 ***</span>
        next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
      }
      next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
    }
  
<span class="line-modified">!   // Aligning embedded value types</span>
<span class="line-modified">!   // bug below, the current algorithm to layout embedded value types always put them at the</span>
    // end of the layout, which doesn&#39;t match the different allocation policies the VM is
    // supposed to provide =&gt; FixMe
<span class="line-modified">!   // Note also that the current alignment policy is to make each value type starting on a</span>
    // 64 bits boundary. This could be optimized later. For instance, it could be nice to
<span class="line-modified">!   // align value types according to their most constrained internal type.</span>
<span class="line-modified">!   next_nonstatic_valuetype_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-modified">!   int next_value_type_index = 0;</span>
  
    // Iterate over fields again and compute correct offsets.
    // The field allocation type was temporarily stored in the offset slot.
    // oop fields are located before non-oop fields (static and non-static).
    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
<span class="line-new-header">--- 4582,19 ---</span>
        next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
      }
      next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
    }
  
<span class="line-modified">!   // Aligning embedded inline types</span>
<span class="line-modified">!   // bug below, the current algorithm to layout embedded inline types always put them at the</span>
    // end of the layout, which doesn&#39;t match the different allocation policies the VM is
    // supposed to provide =&gt; FixMe
<span class="line-modified">!   // Note also that the current alignment policy is to make each inline type starting on a</span>
    // 64 bits boundary. This could be optimized later. For instance, it could be nice to
<span class="line-modified">!   // align inline types according to their most constrained internal type.</span>
<span class="line-modified">!   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-modified">!   int next_inline_type_index = 0;</span>
  
    // Iterate over fields again and compute correct offsets.
    // The field allocation type was temporarily stored in the offset slot.
    // oop fields are located before non-oop fields (static and non-static).
    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4610,11 ***</span>
      int real_offset = 0;
      const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
  
      // pack the rest of the fields
      switch (atype) {
<span class="line-modified">!       // Value types in static fields are handled with oops</span>
        case STATIC_FLATTENABLE:   // Fallthrough
        case STATIC_OOP:
          real_offset = next_static_oop_offset;
          next_static_oop_offset += heapOopSize;
          break;
<span class="line-new-header">--- 4608,11 ---</span>
      int real_offset = 0;
      const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
  
      // pack the rest of the fields
      switch (atype) {
<span class="line-modified">!       // Inline types in static fields are handled with oops</span>
        case STATIC_FLATTENABLE:   // Fallthrough
        case STATIC_OOP:
          real_offset = next_static_oop_offset;
          next_static_oop_offset += heapOopSize;
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4634,19 ***</span>
          real_offset = next_static_double_offset;
          next_static_double_offset += BytesPerLong;
          break;
        case NONSTATIC_FLATTENABLE:
          if (fs.is_flattened()) {
<span class="line-modified">!           Klass* klass = nonstatic_value_type_klasses[next_value_type_index];</span>
            assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);
<span class="line-modified">!           assert(klass-&gt;access_flags().is_value_type(),&quot;Must be a value type&quot;);</span>
            ValueKlass* vklass = ValueKlass::cast(klass);
<span class="line-modified">!           real_offset = next_nonstatic_valuetype_offset;</span>
<span class="line-modified">!           next_nonstatic_valuetype_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-modified">!           // aligning next value type on a 64 bits boundary</span>
<span class="line-modified">!           next_nonstatic_valuetype_offset = align_up(next_nonstatic_valuetype_offset, BytesPerLong);</span>
<span class="line-modified">!           next_value_type_index += 1;</span>
  
            if (vklass-&gt;contains_oops()) { // add flatten oop maps
              int diff = real_offset - vklass-&gt;first_field_offset();
              const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();
              const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();
<span class="line-new-header">--- 4632,19 ---</span>
          real_offset = next_static_double_offset;
          next_static_double_offset += BytesPerLong;
          break;
        case NONSTATIC_FLATTENABLE:
          if (fs.is_flattened()) {
<span class="line-modified">!           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];</span>
            assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);
<span class="line-modified">!           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);</span>
            ValueKlass* vklass = ValueKlass::cast(klass);
<span class="line-modified">!           real_offset = next_nonstatic_inline_type_offset;</span>
<span class="line-modified">!           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-modified">!           // aligning next inline type on a 64 bits boundary</span>
<span class="line-modified">!           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);</span>
<span class="line-modified">!           next_inline_type_index += 1;</span>
  
            if (vklass-&gt;contains_oops()) { // add flatten oop maps
              int diff = real_offset - vklass-&gt;first_field_offset();
              const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();
              const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4775,14 ***</span>
              next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
              real_offset = next_nonstatic_padded_offset;
              next_nonstatic_padded_offset += BytesPerLong;
              break;
  
<span class="line-modified">!             // Value types in static fields are handled with oops</span>
            case NONSTATIC_FLATTENABLE:
<span class="line-modified">!             throwValueTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-modified">!                                      &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
              return;
  
            case NONSTATIC_OOP:
              next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
              real_offset = next_nonstatic_padded_offset;
<span class="line-new-header">--- 4773,14 ---</span>
              next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
              real_offset = next_nonstatic_padded_offset;
              next_nonstatic_padded_offset += BytesPerLong;
              break;
  
<span class="line-modified">!             // Inline types in static fields are handled with oops</span>
            case NONSTATIC_FLATTENABLE:
<span class="line-modified">!             throwInlineTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-modified">!                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
              return;
  
            case NONSTATIC_OOP:
              next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
              real_offset = next_nonstatic_padded_offset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4820,23 ***</span>
  
    // Entire class is contended, pad in the back.
    // This helps to alleviate memory contention effects for subclass fields
    // and/or adjacent object.
    if (is_contended_class) {
<span class="line-modified">!     assert(!is_value_type(), &quot;@Contended not supported for value types yet&quot;);</span>
      next_nonstatic_padded_offset += ContendedPaddingWidth;
    }
  
    int notaligned_nonstatic_fields_end;
<span class="line-modified">!   if (nonstatic_value_type_count != 0) {</span>
<span class="line-modified">!     notaligned_nonstatic_fields_end = next_nonstatic_valuetype_offset;</span>
    } else {
      notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
    }
  
    int nonstatic_field_sz_align = heapOopSize;
<span class="line-modified">!   if (is_value_type()) {</span>
      if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {
        nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy
      }
    }
    int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);
<span class="line-new-header">--- 4818,23 ---</span>
  
    // Entire class is contended, pad in the back.
    // This helps to alleviate memory contention effects for subclass fields
    // and/or adjacent object.
    if (is_contended_class) {
<span class="line-modified">!     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);</span>
      next_nonstatic_padded_offset += ContendedPaddingWidth;
    }
  
    int notaligned_nonstatic_fields_end;
<span class="line-modified">!   if (nonstatic_inline_type_count != 0) {</span>
<span class="line-modified">!     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;</span>
    } else {
      notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
    }
  
    int nonstatic_field_sz_align = heapOopSize;
<span class="line-modified">!   if (is_inline_type()) {</span>
      if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {
        nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy
      }
    }
    int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4850,11 ***</span>
  
    int instance_size             = align_object_size(instance_end / wordSize);
  
    assert(instance_size == align_object_size(align_up(
           (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
<span class="line-modified">!          + initial_value_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
  
  
    // Invariant: nonstatic_field end/start should only change if there are
    // nonstatic fields in the class, or if the class is contended. We compare
    // against the non-aligned value, so that end alignment will not fail the
<span class="line-new-header">--- 4848,11 ---</span>
  
    int instance_size             = align_object_size(instance_end / wordSize);
  
    assert(instance_size == align_object_size(align_up(
           (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
<span class="line-modified">!          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
  
  
    // Invariant: nonstatic_field end/start should only change if there are
    // nonstatic fields in the class, or if the class is contended. We compare
    // against the non-aligned value, so that end alignment will not fail the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4865,12 ***</span>
  
    // Number of non-static oop map blocks allocated at end of klass.
    nonstatic_oop_maps-&gt;compact();
  
  #ifndef PRODUCT
<span class="line-modified">!   if ((PrintFieldLayout &amp;&amp; !is_value_type()) ||</span>
<span class="line-modified">!       (PrintValueLayout &amp;&amp; (is_value_type() || has_nonstatic_value_fields))) {</span>
      print_field_layout(_class_name,
            _fields,
            cp,
            instance_size,
            nonstatic_fields_start,
<span class="line-new-header">--- 4863,12 ---</span>
  
    // Number of non-static oop map blocks allocated at end of klass.
    nonstatic_oop_maps-&gt;compact();
  
  #ifndef PRODUCT
<span class="line-modified">!   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||</span>
<span class="line-modified">!       (PrintValueLayout &amp;&amp; (is_inline_type() || has_nonstatic_value_fields))) {</span>
      print_field_layout(_class_name,
            _fields,
            cp,
            instance_size,
            nonstatic_fields_start,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4891,16 ***</span>
    info-&gt;_instance_size = instance_size;
    info-&gt;_static_field_size = static_field_size;
    info-&gt;_nonstatic_field_size = nonstatic_field_size;
    info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
  
<span class="line-modified">!   // A value type is naturally atomic if it has just one field, and</span>
    // that field is simple enough.
<span class="line-modified">!   info-&gt;_is_naturally_atomic = (is_value_type() &amp;&amp;</span>
                                  !super_has_nonstatic_fields &amp;&amp;
                                  (nonstatic_fields_count &lt;= 1) &amp;&amp;
<span class="line-modified">!                                 (not_atomic_value_types == 0) &amp;&amp;</span>
                                  (nonstatic_contended_count == 0));
    // This may be too restrictive, since if all the fields fit in 64
    // bits we could make the decision to align instances of this class
    // to 64-bit boundaries, and load and store them as single words.
    // And on machines which supported larger atomics we could similarly
<span class="line-new-header">--- 4889,16 ---</span>
    info-&gt;_instance_size = instance_size;
    info-&gt;_static_field_size = static_field_size;
    info-&gt;_nonstatic_field_size = nonstatic_field_size;
    info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
  
<span class="line-modified">!   // An inline type is naturally atomic if it has just one field, and</span>
    // that field is simple enough.
<span class="line-modified">!   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;</span>
                                  !super_has_nonstatic_fields &amp;&amp;
                                  (nonstatic_fields_count &lt;= 1) &amp;&amp;
<span class="line-modified">!                                 (not_atomic_inline_types == 0) &amp;&amp;</span>
                                  (nonstatic_contended_count == 0));
    // This may be too restrictive, since if all the fields fit in 64
    // bits we could make the decision to align instances of this class
    // to 64-bit boundaries, and load and store them as single words.
    // And on machines which supported larger atomics we could similarly
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4940,11 ***</span>
    // Check if this klass supports the java.lang.Cloneable interface
    if (SystemDictionary::Cloneable_klass_loaded()) {
      if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
        if (ik-&gt;is_value()) {
          Thread *THREAD = Thread::current();
<span class="line-modified">!         throwValueTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
          return;
        }
        ik-&gt;set_is_cloneable();
      }
    }
<span class="line-new-header">--- 4938,11 ---</span>
    // Check if this klass supports the java.lang.Cloneable interface
    if (SystemDictionary::Cloneable_klass_loaded()) {
      if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
        if (ik-&gt;is_value()) {
          Thread *THREAD = Thread::current();
<span class="line-modified">!         throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
          return;
        }
        ik-&gt;set_is_cloneable();
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4983,12 ***</span>
      const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
      ik-&gt;set_layout_helper(lh);
    }
  }
  
<span class="line-modified">! bool ClassFileParser::supports_value_types() const {</span>
<span class="line-modified">!   // Value types are only supported by class file version 55 and later</span>
    return _major_version &gt;= JAVA_11_VERSION;
  }
  
  // utility methods for appending an array with check for duplicates
  
<span class="line-new-header">--- 4981,12 ---</span>
      const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
      ik-&gt;set_layout_helper(lh);
    }
  }
  
<span class="line-modified">! bool ClassFileParser::supports_inline_types() const {</span>
<span class="line-modified">!   // Inline types are only supported by class file version 55 and later</span>
    return _major_version &gt;= JAVA_11_VERSION;
  }
  
  // utility methods for appending an array with check for duplicates
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5257,24 ***</span>
  
  // utility methods for format checking
  
  void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
    const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-modified">!   const bool is_value_type = (flags &amp; JVM_ACC_VALUE) != 0;</span>
    assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-modified">!   assert(supports_value_types() || !is_value_type, &quot;JVM_ACC_VALUE should not be set&quot;);</span>
    if (is_module) {
      ResourceMark rm(THREAD);
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_NoClassDefFoundError(),
        &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
        _class_name-&gt;as_C_string());
      return;
    }
  
<span class="line-modified">!   if (is_value_type &amp;&amp; !EnableValhalla) {</span>
      ResourceMark rm(THREAD);
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
        &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,
<span class="line-new-header">--- 5255,24 ---</span>
  
  // utility methods for format checking
  
  void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
    const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-modified">!   const bool is_inline_type = (flags &amp; JVM_ACC_VALUE) != 0;</span>
    assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-modified">!   assert(supports_inline_types() || !is_inline_type, &quot;JVM_ACC_VALUE should not be set&quot;);</span>
    if (is_module) {
      ResourceMark rm(THREAD);
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_NoClassDefFoundError(),
        &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
        _class_name-&gt;as_C_string());
      return;
    }
  
<span class="line-modified">!   if (is_inline_type &amp;&amp; !EnableValhalla) {</span>
      ResourceMark rm(THREAD);
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
        &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5295,14 ***</span>
  
    if ((is_abstract &amp;&amp; is_final) ||
        (is_interface &amp;&amp; !is_abstract) ||
        (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
        (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||
<span class="line-modified">!       (is_value_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
      ResourceMark rm(THREAD);
      const char* class_note = &quot;&quot;;
<span class="line-modified">!     if (is_value_type)  class_note = &quot; (an inline class)&quot;;</span>
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
        &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,
        _class_name-&gt;as_C_string(), class_note, flags
<span class="line-new-header">--- 5293,14 ---</span>
  
    if ((is_abstract &amp;&amp; is_final) ||
        (is_interface &amp;&amp; !is_abstract) ||
        (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
        (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||
<span class="line-modified">!       (is_inline_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
      ResourceMark rm(THREAD);
      const char* class_note = &quot;&quot;;
<span class="line-modified">!     if (is_inline_type)  class_note = &quot; (an inline class)&quot;;</span>
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
        &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,
        _class_name-&gt;as_C_string(), class_note, flags
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5382,11 ***</span>
    }
  }
  
  void ClassFileParser::verify_legal_field_modifiers(jint flags,
                                                     bool is_interface,
<span class="line-modified">!                                                    bool is_value_type,</span>
                                                     TRAPS) const {
    if (!_need_verify) { return; }
  
    const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
    const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
<span class="line-new-header">--- 5380,11 ---</span>
    }
  }
  
  void ClassFileParser::verify_legal_field_modifiers(jint flags,
                                                     bool is_interface,
<span class="line-modified">!                                                    bool is_inline_type,</span>
                                                     TRAPS) const {
    if (!_need_verify) { return; }
  
    const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
    const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5408,11 ***</span>
      }
    } else { // not interface
      if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
        is_illegal = true;
      } else {
<span class="line-modified">!       if (is_value_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
          is_illegal = true;
        }
      }
    }
  
<span class="line-new-header">--- 5406,11 ---</span>
      }
    } else { // not interface
      if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
        is_illegal = true;
      } else {
<span class="line-modified">!       if (is_inline_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
          is_illegal = true;
        }
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5427,11 ***</span>
    }
  }
  
  void ClassFileParser::verify_legal_method_modifiers(jint flags,
                                                      bool is_interface,
<span class="line-modified">!                                                     bool is_value_type,</span>
                                                      const Symbol* name,
                                                      TRAPS) const {
    if (!_need_verify) { return; }
  
    const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
<span class="line-new-header">--- 5425,11 ---</span>
    }
  }
  
  void ClassFileParser::verify_legal_method_modifiers(jint flags,
                                                      bool is_interface,
<span class="line-modified">!                                                     bool is_inline_type,</span>
                                                      const Symbol* name,
                                                      TRAPS) const {
    if (!_need_verify) { return; }
  
    const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5488,21 ***</span>
        if (is_initializer) {
          if (is_final || is_synchronized || is_native ||
              is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
            is_illegal = true;
          }
<span class="line-modified">!         if (!is_static &amp;&amp; !is_value_type) {</span>
            // OK, an object constructor in a regular class
<span class="line-modified">!         } else if (is_static &amp;&amp; is_value_type) {</span>
            // OK, a static init factory in an inline class
          } else {
            // but no other combinations are allowed
            is_illegal = true;
<span class="line-modified">!           class_note = (is_value_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
          }
        } else { // not initializer
<span class="line-modified">!         if (is_value_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
            is_illegal = true;
            class_note = &quot; (an inline class)&quot;;
          } else {
            if (is_abstract) {
              if ((is_final || is_native || is_private || is_static ||
<span class="line-new-header">--- 5486,21 ---</span>
        if (is_initializer) {
          if (is_final || is_synchronized || is_native ||
              is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
            is_illegal = true;
          }
<span class="line-modified">!         if (!is_static &amp;&amp; !is_inline_type) {</span>
            // OK, an object constructor in a regular class
<span class="line-modified">!         } else if (is_static &amp;&amp; is_inline_type) {</span>
            // OK, a static init factory in an inline class
          } else {
            // but no other combinations are allowed
            is_illegal = true;
<span class="line-modified">!           class_note = (is_inline_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
          }
        } else { // not initializer
<span class="line-modified">!         if (is_inline_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
            is_illegal = true;
            class_note = &quot; (an inline class)&quot;;
          } else {
            if (is_abstract) {
              if ((is_final || is_native || is_private || is_static ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6150,12 ***</span>
    ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
    ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
    if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
      ik-&gt;set_is_naturally_atomic();
    }
<span class="line-modified">!   if (_is_empty_value) {</span>
<span class="line-modified">!     ik-&gt;set_is_empty_value();</span>
    }
  
    if (this-&gt;_invalid_inline_super) {
      ik-&gt;set_invalid_inline_super();
    }
<span class="line-new-header">--- 6148,12 ---</span>
    ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
    ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
    if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
      ik-&gt;set_is_naturally_atomic();
    }
<span class="line-modified">!   if (_is_empty_inline_type) {</span>
<span class="line-modified">!     ik-&gt;set_is_empty_inline_type();</span>
    }
  
    if (this-&gt;_invalid_inline_super) {
      ik-&gt;set_invalid_inline_super();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6327,22 ***</span>
        // Inline classes for static fields might not have been loaded yet
        Klass* klass = SystemDictionary::find(klass_name,
            Handle(THREAD, ik-&gt;class_loader()),
            Handle(THREAD, ik-&gt;protection_domain()), CHECK);
        if (klass != NULL) {
<span class="line-modified">!         assert(klass-&gt;access_flags().is_value_type(), &quot;Value type expected&quot;);</span>
          ik-&gt;set_value_field_klass(i, klass);
        }
        klass_name-&gt;decrement_refcount();
      } else
<span class="line-modified">!       if (is_value_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
          &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
        ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
      }
    }
  
<span class="line-modified">!   if (is_value_type()) {</span>
      ValueKlass* vk = ValueKlass::cast(ik);
      if (UseNewFieldLayout) {
        vk-&gt;set_alignment(_alignment);
        vk-&gt;set_first_field_offset(_first_field_offset);
        vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);
<span class="line-new-header">--- 6325,22 ---</span>
        // Inline classes for static fields might not have been loaded yet
        Klass* klass = SystemDictionary::find(klass_name,
            Handle(THREAD, ik-&gt;class_loader()),
            Handle(THREAD, ik-&gt;protection_domain()), CHECK);
        if (klass != NULL) {
<span class="line-modified">!         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
          ik-&gt;set_value_field_klass(i, klass);
        }
        klass_name-&gt;decrement_refcount();
      } else
<span class="line-modified">!       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
          &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
        ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
      }
    }
  
<span class="line-modified">!   if (is_inline_type()) {</span>
      ValueKlass* vk = ValueKlass::cast(ik);
      if (UseNewFieldLayout) {
        vk-&gt;set_alignment(_alignment);
        vk-&gt;set_first_field_offset(_first_field_offset);
        vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6548,11 ***</span>
    _declares_nonstatic_concrete_methods(false),
    _has_final_method(false),
    _has_contended_fields(false),
    _has_flattenable_fields(false),
    _has_nonstatic_fields(false),
<span class="line-modified">!   _is_empty_value(false),</span>
    _is_naturally_atomic(false),
    _is_declared_atomic(false),
    _invalid_inline_super(false),
    _invalid_identity_super(false),
    _implements_identityObject(false),
<span class="line-new-header">--- 6546,11 ---</span>
    _declares_nonstatic_concrete_methods(false),
    _has_final_method(false),
    _has_contended_fields(false),
    _has_flattenable_fields(false),
    _has_nonstatic_fields(false),
<span class="line-modified">!   _is_empty_inline_type(false),</span>
    _is_naturally_atomic(false),
    _is_declared_atomic(false),
    _invalid_inline_super(false),
    _invalid_identity_super(false),
    _implements_identityObject(false),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6761,11 ***</span>
    // JVM_ACC_MODULE is defined in JDK-9 and later.
    if (_major_version &gt;= JAVA_9_VERSION) {
      recognized_modifiers |= JVM_ACC_MODULE;
    }
    // JVM_ACC_VALUE is defined for class file version 55 and later
<span class="line-modified">!   if (supports_value_types()) {</span>
      recognized_modifiers |= JVM_ACC_VALUE;
    }
  
    // Access flags
    jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;
<span class="line-new-header">--- 6759,11 ---</span>
    // JVM_ACC_MODULE is defined in JDK-9 and later.
    if (_major_version &gt;= JAVA_9_VERSION) {
      recognized_modifiers |= JVM_ACC_MODULE;
    }
    // JVM_ACC_VALUE is defined for class file version 55 and later
<span class="line-modified">!   if (supports_inline_types()) {</span>
      recognized_modifiers |= JVM_ACC_VALUE;
    }
  
    // Access flags
    jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6893,22 ***</span>
    // Interfaces
    _itfs_len = stream-&gt;get_u2_fast();
    parse_interfaces(stream,
                     _itfs_len,
                     cp,
<span class="line-modified">!                    is_value_type(),</span>
                     &amp;_has_nonstatic_concrete_methods,
                     &amp;_is_declared_atomic,
                     CHECK);
  
    assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);
  
    // Fields (offsets are filled in later)
    _fac = new FieldAllocationCount();
    parse_fields(stream,
                 is_interface(),
<span class="line-modified">!                is_value_type(),</span>
                 _fac,
                 cp,
                 cp_size,
                 &amp;_java_fields_count,
                 CHECK);
<span class="line-new-header">--- 6891,22 ---</span>
    // Interfaces
    _itfs_len = stream-&gt;get_u2_fast();
    parse_interfaces(stream,
                     _itfs_len,
                     cp,
<span class="line-modified">!                    is_inline_type(),</span>
                     &amp;_has_nonstatic_concrete_methods,
                     &amp;_is_declared_atomic,
                     CHECK);
  
    assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);
  
    // Fields (offsets are filled in later)
    _fac = new FieldAllocationCount();
    parse_fields(stream,
                 is_interface(),
<span class="line-modified">!                is_inline_type(),</span>
                 _fac,
                 cp,
                 cp_size,
                 &amp;_java_fields_count,
                 CHECK);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6917,11 ***</span>
  
    // Methods
    AccessFlags promoted_flags;
    parse_methods(stream,
                  is_interface(),
<span class="line-modified">!                 is_value_type(),</span>
                  &amp;promoted_flags,
                  &amp;_has_final_method,
                  &amp;_declares_nonstatic_concrete_methods,
                  CHECK);
  
<span class="line-new-header">--- 6915,11 ---</span>
  
    // Methods
    AccessFlags promoted_flags;
    parse_methods(stream,
                  is_interface(),
<span class="line-modified">!                 is_inline_type(),</span>
                  &amp;promoted_flags,
                  &amp;_has_final_method,
                  &amp;_declares_nonstatic_concrete_methods,
                  CHECK);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7010,11 ***</span>
        THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
      }
  
      // For an inline class, only java/lang/Object or special abstract classes
      // are acceptable super classes.
<span class="line-modified">!     if (is_value_type()) {</span>
        const InstanceKlass* super_ik = _super_klass;
        if (super_ik-&gt;invalid_inline_super()) {
          ResourceMark rm(THREAD);
          Exceptions::fthrow(
            THREAD_AND_LOCATION,
<span class="line-new-header">--- 7008,11 ---</span>
        THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
      }
  
      // For an inline class, only java/lang/Object or special abstract classes
      // are acceptable super classes.
<span class="line-modified">!     if (is_inline_type()) {</span>
        const InstanceKlass* super_ik = _super_klass;
        if (super_ik-&gt;invalid_inline_super()) {
          ResourceMark rm(THREAD);
          Exceptions::fthrow(
            THREAD_AND_LOCATION,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7046,11 ***</span>
        (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||
        is_invalid_super_for_inline_type()) {
      set_invalid_inline_super();
    }
  
<span class="line-modified">!   if (!is_value_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
        &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {
      _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());
      _has_injected_identityObject = true;
    }
    int itfs_len = _temp_local_interfaces-&gt;length();
<span class="line-new-header">--- 7044,11 ---</span>
        (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||
        is_invalid_super_for_inline_type()) {
      set_invalid_inline_super();
    }
  
<span class="line-modified">!   if (!is_inline_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
        &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {
      _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());
      _has_injected_identityObject = true;
    }
    int itfs_len = _temp_local_interfaces-&gt;length();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7107,22 ***</span>
        // Pre-load value class
        Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
            Handle(THREAD, _loader_data-&gt;class_loader()),
            _protection_domain, true, CHECK);
        assert(klass != NULL, &quot;Sanity check&quot;);
<span class="line-modified">!       assert(klass-&gt;access_flags().is_value_type(), &quot;Value type expected&quot;);</span>
        _has_flattenable_fields = true;
      }
    }
  
    _field_info = new FieldLayoutInfo();
    if (UseNewFieldLayout) {
      FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">!         _parsed_annotations-&gt;is_contended(), is_value_type(),</span>
          loader_data(), _protection_domain, _field_info);
      lb.build_layout(CHECK);
<span class="line-modified">!     if (is_value_type()) {</span>
        _alignment = lb.get_alignment();
        _first_field_offset = lb.get_first_field_offset();
        _exact_size_in_bytes = lb.get_exact_size_in_byte();
      }
    } else {
<span class="line-new-header">--- 7105,22 ---</span>
        // Pre-load value class
        Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
            Handle(THREAD, _loader_data-&gt;class_loader()),
            _protection_domain, true, CHECK);
        assert(klass != NULL, &quot;Sanity check&quot;);
<span class="line-modified">!       assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
        _has_flattenable_fields = true;
      }
    }
  
    _field_info = new FieldLayoutInfo();
    if (UseNewFieldLayout) {
      FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">!         _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
          loader_data(), _protection_domain, _field_info);
      lb.build_layout(CHECK);
<span class="line-modified">!     if (is_inline_type()) {</span>
        _alignment = lb.get_alignment();
        _first_field_offset = lb.get_first_field_offset();
        _exact_size_in_bytes = lb.get_exact_size_in_byte();
      }
    } else {
</pre>
<center><a href="../../cpu/x86/templateTable_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
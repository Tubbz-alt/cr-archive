<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/callnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../c1/c1_LIRAssembler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/callnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 681 }
 682 
 683 void CallNode::dump_spec(outputStream *st) const {
 684   st-&gt;print(&quot; &quot;);
 685   if (tf() != NULL)  tf()-&gt;dump_on(st);
 686   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
 687   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
 688 }
 689 #endif
 690 
 691 const Type *CallNode::bottom_type() const { return tf()-&gt;range_cc(); }
 692 const Type* CallNode::Value(PhaseGVN* phase) const {
 693   if (!in(0) || phase-&gt;type(in(0)) == Type::TOP) {
 694     return Type::TOP;
 695   }
 696   return tf()-&gt;range_cc();
 697 }
 698 
 699 //------------------------------calling_convention-----------------------------
 700 void CallNode::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {
<span class="line-modified"> 701   if (_entry_point == StubRoutines::store_value_type_fields_to_buf()) {</span>
 702     // The call to that stub is a special case: its inputs are
 703     // multiple values returned from a call and so it should follow
 704     // the return convention.
 705     SharedRuntime::java_return_convention(sig_bt, parm_regs, argcnt);
 706     return;
 707   }
 708   // Use the standard compiler calling convention
 709   Matcher::calling_convention( sig_bt, parm_regs, argcnt, true );
 710 }
 711 
 712 
 713 //------------------------------match------------------------------------------
 714 // Construct projections for control, I/O, memory-fields, ..., and
 715 // return result(s) along with their RegMask info
 716 Node *CallNode::match(const ProjNode *proj, const Matcher *match, const RegMask* mask) {
 717   uint con = proj-&gt;_con;
 718   const TypeTuple *range_cc = tf()-&gt;range_cc();
 719   if (con &gt;= TypeFunc::Parms) {
 720     if (is_CallRuntime()) {
 721       if (con == TypeFunc::Parms) {
</pre>
</td>
<td>
<hr />
<pre>
 681 }
 682 
 683 void CallNode::dump_spec(outputStream *st) const {
 684   st-&gt;print(&quot; &quot;);
 685   if (tf() != NULL)  tf()-&gt;dump_on(st);
 686   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
 687   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
 688 }
 689 #endif
 690 
 691 const Type *CallNode::bottom_type() const { return tf()-&gt;range_cc(); }
 692 const Type* CallNode::Value(PhaseGVN* phase) const {
 693   if (!in(0) || phase-&gt;type(in(0)) == Type::TOP) {
 694     return Type::TOP;
 695   }
 696   return tf()-&gt;range_cc();
 697 }
 698 
 699 //------------------------------calling_convention-----------------------------
 700 void CallNode::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {
<span class="line-modified"> 701   if (_entry_point == StubRoutines::store_inline_type_fields_to_buf()) {</span>
 702     // The call to that stub is a special case: its inputs are
 703     // multiple values returned from a call and so it should follow
 704     // the return convention.
 705     SharedRuntime::java_return_convention(sig_bt, parm_regs, argcnt);
 706     return;
 707   }
 708   // Use the standard compiler calling convention
 709   Matcher::calling_convention( sig_bt, parm_regs, argcnt, true );
 710 }
 711 
 712 
 713 //------------------------------match------------------------------------------
 714 // Construct projections for control, I/O, memory-fields, ..., and
 715 // return result(s) along with their RegMask info
 716 Node *CallNode::match(const ProjNode *proj, const Matcher *match, const RegMask* mask) {
 717   uint con = proj-&gt;_con;
 718   const TypeTuple *range_cc = tf()-&gt;range_cc();
 719   if (con &gt;= TypeFunc::Parms) {
 720     if (is_CallRuntime()) {
 721       if (con == TypeFunc::Parms) {
</pre>
</td>
</tr>
</table>
<center><a href="../c1/c1_LIRAssembler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
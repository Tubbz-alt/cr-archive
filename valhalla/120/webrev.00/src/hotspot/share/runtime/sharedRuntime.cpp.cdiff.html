<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/macro.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 3659,11 ***</span>
  }
  JRT_END
  
  // We&#39;re returning from an interpreted method: load each field into a
  // register following the calling convention
<span class="line-modified">! JRT_LEAF(void, SharedRuntime::load_value_type_fields_in_regs(JavaThread* thread, oopDesc* res))</span>
  {
    assert(res-&gt;klass()-&gt;is_inline_klass(), &quot;only inline types here&quot;);
    ResourceMark rm;
    RegisterMap reg_map(thread);
    frame stubFrame = thread-&gt;last_frame();
<span class="line-new-header">--- 3659,11 ---</span>
  }
  JRT_END
  
  // We&#39;re returning from an interpreted method: load each field into a
  // register following the calling convention
<span class="line-modified">! JRT_LEAF(void, SharedRuntime::load_inline_type_fields_in_regs(JavaThread* thread, oopDesc* res))</span>
  {
    assert(res-&gt;klass()-&gt;is_inline_klass(), &quot;only inline types here&quot;);
    ResourceMark rm;
    RegisterMap reg_map(thread);
    frame stubFrame = thread-&gt;last_frame();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3674,11 ***</span>
  
    const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
    const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
  
    if (regs == NULL) {
<span class="line-modified">!     // The fields of the value klass don&#39;t fit in registers, bail out</span>
      return;
    }
  
    int j = 1;
    for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
<span class="line-new-header">--- 3674,11 ---</span>
  
    const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
    const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
  
    if (regs == NULL) {
<span class="line-modified">!     // The fields of the inline klass don&#39;t fit in registers, bail out</span>
      return;
    }
  
    int j = 1;
    for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3748,13 ***</span>
    thread-&gt;set_vm_result(res);
  }
  JRT_END
  
  // We&#39;ve returned to an interpreted method, the interpreter needs a
<span class="line-modified">! // reference to a value type instance. Allocate it and initialize it</span>
  // from field&#39;s values in registers.
<span class="line-modified">! JRT_BLOCK_ENTRY(void, SharedRuntime::store_value_type_fields_to_buf(JavaThread* thread, intptr_t res))</span>
  {
    ResourceMark rm;
    RegisterMap reg_map(thread);
    frame stubFrame = thread-&gt;last_frame();
    frame callerFrame = stubFrame.sender(&amp;reg_map);
<span class="line-new-header">--- 3748,13 ---</span>
    thread-&gt;set_vm_result(res);
  }
  JRT_END
  
  // We&#39;ve returned to an interpreted method, the interpreter needs a
<span class="line-modified">! // reference to an inline type instance. Allocate it and initialize it</span>
  // from field&#39;s values in registers.
<span class="line-modified">! JRT_BLOCK_ENTRY(void, SharedRuntime::store_inline_type_fields_to_buf(JavaThread* thread, intptr_t res))</span>
  {
    ResourceMark rm;
    RegisterMap reg_map(thread);
    frame stubFrame = thread-&gt;last_frame();
    frame callerFrame = stubFrame.sender(&amp;reg_map);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3762,12 ***</span>
  #ifdef ASSERT
    InlineKlass* verif_vk = InlineKlass::returned_inline_klass(reg_map);
  #endif
  
    if (!is_set_nth_bit(res, 0)) {
<span class="line-modified">!     // We&#39;re not returning with value type fields in registers (the</span>
<span class="line-modified">!     // calling convention didn&#39;t allow it for this value klass)</span>
      assert(!Metaspace::contains((void*)res), &quot;should be oop or pointer in buffer area&quot;);
      thread-&gt;set_vm_result((oopDesc*)res);
      assert(verif_vk == NULL, &quot;broken calling convention&quot;);
      return;
    }
<span class="line-new-header">--- 3762,12 ---</span>
  #ifdef ASSERT
    InlineKlass* verif_vk = InlineKlass::returned_inline_klass(reg_map);
  #endif
  
    if (!is_set_nth_bit(res, 0)) {
<span class="line-modified">!     // We&#39;re not returning with inline type fields in registers (the</span>
<span class="line-modified">!     // calling convention didn&#39;t allow it for this inline klass)</span>
      assert(!Metaspace::contains((void*)res), &quot;should be oop or pointer in buffer area&quot;);
      thread-&gt;set_vm_result((oopDesc*)res);
      assert(verif_vk == NULL, &quot;broken calling convention&quot;);
      return;
    }
</pre>
<center><a href="../opto/macro.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
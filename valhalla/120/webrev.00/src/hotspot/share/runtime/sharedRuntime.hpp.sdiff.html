<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sharedRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutines.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
518   static void block_for_jni_critical(JavaThread* thread);
519 
520   // Pin/Unpin object
521   static oopDesc* pin_object(JavaThread* thread, oopDesc* obj);
522   static void unpin_object(JavaThread* thread, oopDesc* obj);
523 
524   // A compiled caller has just called the interpreter, but compiled code
525   // exists.  Patch the caller so he no longer calls into the interpreter.
526   static void fixup_callers_callsite(Method* moop, address ret_pc);
527   static bool should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb);
528 
529   // Slow-path Locking and Unlocking
530   static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
531   static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
532 
533   // Resolving of calls
534   static address resolve_static_call_C     (JavaThread *thread);
535   static address resolve_virtual_call_C    (JavaThread *thread);
536   static address resolve_opt_virtual_call_C(JavaThread *thread);
537 
<span class="line-modified">538   static void load_value_type_fields_in_regs(JavaThread *thread, oopDesc* res);</span>
<span class="line-modified">539   static void store_value_type_fields_to_buf(JavaThread *thread, intptr_t res);</span>
540 
541   // arraycopy, the non-leaf version.  (See StubRoutines for all the leaf calls.)
542   static void slow_arraycopy_C(oopDesc* src,  jint src_pos,
543                                oopDesc* dest, jint dest_pos,
544                                jint length, JavaThread* thread);
545 
546   // handle ic miss with caller being compiled code
547   // wrong method handling (inline cache misses, zombie methods)
548   static address handle_wrong_method(JavaThread* thread);
549   static address handle_wrong_method_abstract(JavaThread* thread);
550   static address handle_wrong_method_ic_miss(JavaThread* thread);
551   static void allocate_value_types(JavaThread* thread, Method* callee, bool allocate_receiver);
552   static oop allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS);
553   static void apply_post_barriers(JavaThread* thread, objArrayOopDesc* array);
554 
555   static address handle_unsafe_access(JavaThread* thread, address next_pc);
556 
557   static BufferedValueTypeBlob* generate_buffered_inline_type_adapter(const InlineKlass* vk);
558 #ifndef PRODUCT
559 
</pre>
</td>
<td>
<hr />
<pre>
518   static void block_for_jni_critical(JavaThread* thread);
519 
520   // Pin/Unpin object
521   static oopDesc* pin_object(JavaThread* thread, oopDesc* obj);
522   static void unpin_object(JavaThread* thread, oopDesc* obj);
523 
524   // A compiled caller has just called the interpreter, but compiled code
525   // exists.  Patch the caller so he no longer calls into the interpreter.
526   static void fixup_callers_callsite(Method* moop, address ret_pc);
527   static bool should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb);
528 
529   // Slow-path Locking and Unlocking
530   static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
531   static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
532 
533   // Resolving of calls
534   static address resolve_static_call_C     (JavaThread *thread);
535   static address resolve_virtual_call_C    (JavaThread *thread);
536   static address resolve_opt_virtual_call_C(JavaThread *thread);
537 
<span class="line-modified">538   static void load_inline_type_fields_in_regs(JavaThread *thread, oopDesc* res);</span>
<span class="line-modified">539   static void store_inline_type_fields_to_buf(JavaThread *thread, intptr_t res);</span>
540 
541   // arraycopy, the non-leaf version.  (See StubRoutines for all the leaf calls.)
542   static void slow_arraycopy_C(oopDesc* src,  jint src_pos,
543                                oopDesc* dest, jint dest_pos,
544                                jint length, JavaThread* thread);
545 
546   // handle ic miss with caller being compiled code
547   // wrong method handling (inline cache misses, zombie methods)
548   static address handle_wrong_method(JavaThread* thread);
549   static address handle_wrong_method_abstract(JavaThread* thread);
550   static address handle_wrong_method_ic_miss(JavaThread* thread);
551   static void allocate_value_types(JavaThread* thread, Method* callee, bool allocate_receiver);
552   static oop allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS);
553   static void apply_post_barriers(JavaThread* thread, objArrayOopDesc* array);
554 
555   static address handle_unsafe_access(JavaThread* thread, address next_pc);
556 
557   static BufferedValueTypeBlob* generate_buffered_inline_type_adapter(const InlineKlass* vk);
558 #ifndef PRODUCT
559 
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutines.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
5247 
5248 // n.b. frame size includes space for return pc and rfp
5249   const long framesize = C-&gt;frame_size_in_bytes();
5250   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2 * wordSize alignment&quot;);
5251 
5252   // insert a nop at the start of the prolog so we can patch in a
5253   // branch if we need to invalidate the method later
5254   nop();
5255 
5256   int bangsize = C-&gt;bang_size_in_bytes();
5257   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)
5258      generate_stack_overflow_check(bangsize);
5259 
5260   build_frame(framesize);
5261 
5262   if (VerifyStackAtCalls) {
5263     Unimplemented();
5264   }
5265 }
5266 
<span class="line-modified">5267 int MacroAssembler::store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {</span>
<span class="line-modified">5268   // A value type might be returned. If fields are in registers we</span>
<span class="line-modified">5269   // need to allocate a value type instance and initialize it with</span>
5270   // the value of the fields.
5271   Label skip;
5272   // We only need a new buffered value if a new one is not returned
5273   cmp(r0, (u1) 1);
5274   br(Assembler::EQ, skip);
5275   int call_offset = -1;
5276 
5277   Label slow_case;
5278 
5279   // Try to allocate a new buffered value (from the heap)
5280   if (UseTLAB) {
5281 
5282     if (vk != NULL) {
5283       // Called from C1, where the return type is statically known.
5284       mov(r1, (intptr_t)vk-&gt;get_InlineKlass());
5285       jint lh = vk-&gt;layout_helper();
5286       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);
5287       mov(r14, lh);
5288     } else {
5289        // Call from interpreter. R0 contains ((the InlineKlass* of the return type) | 0x01)
</pre>
<hr />
<pre>
5327         // We have our new buffered value, initialize its fields with a
5328         // value class specific handler
5329         ldr(r1, Address(r0, InstanceKlass::adr_inlineklass_fixed_block_offset()));
5330         ldr(r1, Address(r1, InlineKlass::pack_handler_offset()));
5331 
5332         // Mov new class to r0 and call pack_handler
5333         mov(r0, r13);
5334         blr(r1);
5335       }
5336       b(skip);
5337   }
5338 
5339   bind(slow_case);
5340   // We failed to allocate a new value, fall back to a runtime
5341   // call. Some oop field may be live in some registers but we can&#39;t
5342   // tell. That runtime call will take care of preserving them
5343   // across a GC if there&#39;s one.
5344 
5345 
5346   if (from_interpreter) {
<span class="line-modified">5347     super_call_VM_leaf(StubRoutines::store_value_type_fields_to_buf());</span>
5348   } else {
<span class="line-modified">5349     ldr(rscratch1, RuntimeAddress(StubRoutines::store_value_type_fields_to_buf()));</span>
5350     blr(rscratch1);
5351     call_offset = offset();
5352   }
5353 
5354   bind(skip);
5355   return call_offset;
5356 }
5357 
5358 // Move a value between registers/stack slots and update the reg_state
5359 bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {
5360   if (reg_state[to-&gt;value()] == reg_written) {
5361     return true; // Already written
5362   }
5363 
5364   if (from != to &amp;&amp; bt != T_VOID) {
5365     if (reg_state[to-&gt;value()] == reg_readonly) {
5366       return false; // Not yet writable
5367     }
5368     if (from-&gt;is_reg()) {
5369       if (to-&gt;is_reg()) {
</pre>
</td>
<td>
<hr />
<pre>
5247 
5248 // n.b. frame size includes space for return pc and rfp
5249   const long framesize = C-&gt;frame_size_in_bytes();
5250   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2 * wordSize alignment&quot;);
5251 
5252   // insert a nop at the start of the prolog so we can patch in a
5253   // branch if we need to invalidate the method later
5254   nop();
5255 
5256   int bangsize = C-&gt;bang_size_in_bytes();
5257   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)
5258      generate_stack_overflow_check(bangsize);
5259 
5260   build_frame(framesize);
5261 
5262   if (VerifyStackAtCalls) {
5263     Unimplemented();
5264   }
5265 }
5266 
<span class="line-modified">5267 int MacroAssembler::store_inline_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {</span>
<span class="line-modified">5268   // An inline type might be returned. If fields are in registers we</span>
<span class="line-modified">5269   // need to allocate an inline type instance and initialize it with</span>
5270   // the value of the fields.
5271   Label skip;
5272   // We only need a new buffered value if a new one is not returned
5273   cmp(r0, (u1) 1);
5274   br(Assembler::EQ, skip);
5275   int call_offset = -1;
5276 
5277   Label slow_case;
5278 
5279   // Try to allocate a new buffered value (from the heap)
5280   if (UseTLAB) {
5281 
5282     if (vk != NULL) {
5283       // Called from C1, where the return type is statically known.
5284       mov(r1, (intptr_t)vk-&gt;get_InlineKlass());
5285       jint lh = vk-&gt;layout_helper();
5286       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);
5287       mov(r14, lh);
5288     } else {
5289        // Call from interpreter. R0 contains ((the InlineKlass* of the return type) | 0x01)
</pre>
<hr />
<pre>
5327         // We have our new buffered value, initialize its fields with a
5328         // value class specific handler
5329         ldr(r1, Address(r0, InstanceKlass::adr_inlineklass_fixed_block_offset()));
5330         ldr(r1, Address(r1, InlineKlass::pack_handler_offset()));
5331 
5332         // Mov new class to r0 and call pack_handler
5333         mov(r0, r13);
5334         blr(r1);
5335       }
5336       b(skip);
5337   }
5338 
5339   bind(slow_case);
5340   // We failed to allocate a new value, fall back to a runtime
5341   // call. Some oop field may be live in some registers but we can&#39;t
5342   // tell. That runtime call will take care of preserving them
5343   // across a GC if there&#39;s one.
5344 
5345 
5346   if (from_interpreter) {
<span class="line-modified">5347     super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());</span>
5348   } else {
<span class="line-modified">5349     ldr(rscratch1, RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));</span>
5350     blr(rscratch1);
5351     call_offset = offset();
5352   }
5353 
5354   bind(skip);
5355   return call_offset;
5356 }
5357 
5358 // Move a value between registers/stack slots and update the reg_state
5359 bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {
5360   if (reg_state[to-&gt;value()] == reg_written) {
5361     return true; // Already written
5362   }
5363 
5364   if (from != to &amp;&amp; bt != T_VOID) {
5365     if (reg_state[to-&gt;value()] == reg_readonly) {
5366       return false; // Not yet writable
5367     }
5368     if (from-&gt;is_reg()) {
5369       if (to-&gt;is_reg()) {
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1182   }
1183 
1184   WRAP(adds) WRAP(addsw) WRAP(subs) WRAP(subsw)
1185 
1186   void add(Register Rd, Register Rn, RegisterOrConstant increment);
1187   void addw(Register Rd, Register Rn, RegisterOrConstant increment);
1188   void sub(Register Rd, Register Rn, RegisterOrConstant decrement);
1189   void subw(Register Rd, Register Rn, RegisterOrConstant decrement);
1190 
1191   void adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset);
1192 
1193 
1194   enum RegState {
1195      reg_readonly,
1196      reg_writable,
1197      reg_written
1198   };
1199 
1200   void verified_entry(Compile* C, int sp_inc);
1201 
<span class="line-modified">1202   int store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter = true);</span>
1203 
1204 // Unpack all value type arguments passed as oops
1205   void unpack_value_args(Compile* C, bool receiver_only);
1206   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);
1207   bool unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,
1208                            RegState reg_state[], int ret_off, int extra_stack_offset);
1209   bool pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
1210                          VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
1211                          int ret_off, int extra_stack_offset);
1212   void restore_stack(Compile* C);
1213 
1214   int shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,
1215                          BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
1216                          int args_passed, int args_on_stack, VMRegPair* regs,
1217                          int args_passed_to, int args_on_stack_to, VMRegPair* regs_to);
1218   bool shuffle_value_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
1219                                 VMRegPair* regs_from, int from_index, int regs_from_count,
1220                                 RegState* reg_state, int sp_inc, int extra_stack_offset);
1221   VMReg spill_reg_for(VMReg reg);
1222 
</pre>
</td>
<td>
<hr />
<pre>
1182   }
1183 
1184   WRAP(adds) WRAP(addsw) WRAP(subs) WRAP(subsw)
1185 
1186   void add(Register Rd, Register Rn, RegisterOrConstant increment);
1187   void addw(Register Rd, Register Rn, RegisterOrConstant increment);
1188   void sub(Register Rd, Register Rn, RegisterOrConstant decrement);
1189   void subw(Register Rd, Register Rn, RegisterOrConstant decrement);
1190 
1191   void adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset);
1192 
1193 
1194   enum RegState {
1195      reg_readonly,
1196      reg_writable,
1197      reg_written
1198   };
1199 
1200   void verified_entry(Compile* C, int sp_inc);
1201 
<span class="line-modified">1202   int store_inline_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter = true);</span>
1203 
1204 // Unpack all value type arguments passed as oops
1205   void unpack_value_args(Compile* C, bool receiver_only);
1206   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);
1207   bool unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,
1208                            RegState reg_state[], int ret_off, int extra_stack_offset);
1209   bool pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
1210                          VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
1211                          int ret_off, int extra_stack_offset);
1212   void restore_stack(Compile* C);
1213 
1214   int shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,
1215                          BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
1216                          int args_passed, int args_on_stack, VMRegPair* regs,
1217                          int args_passed_to, int args_on_stack_to, VMRegPair* regs_to);
1218   bool shuffle_value_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
1219                                 VMRegPair* regs_from, int from_index, int regs_from_count,
1220                                 RegState* reg_state, int sp_inc, int extra_stack_offset);
1221   VMReg spill_reg_for(VMReg reg);
1222 
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
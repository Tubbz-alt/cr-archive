<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
5188   } else {
5189     movdqu(Address(base,  0), xtmp);
5190     movdqu(Address(base, 16), xtmp);
5191   }
5192   addptr(base, 32);
5193   subptr(cnt, 4);
5194 
5195   BIND(L_tail);
5196   addptr(cnt, 4);
5197   jccb(Assembler::lessEqual, L_end);
5198   decrement(cnt);
5199 
5200   BIND(L_sloop);
5201   movq(Address(base, 0), xtmp);
5202   addptr(base, 8);
5203   decrement(cnt);
5204   jccb(Assembler::greaterEqual, L_sloop);
5205   BIND(L_end);
5206 }
5207 
<span class="line-modified">5208 int MacroAssembler::store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {</span>
<span class="line-modified">5209   // A value type might be returned. If fields are in registers we</span>
<span class="line-modified">5210   // need to allocate a value type instance and initialize it with</span>
5211   // the value of the fields.
5212   Label skip;
5213   // We only need a new buffered value if a new one is not returned
5214   testptr(rax, 1);
5215   jcc(Assembler::zero, skip);
5216   int call_offset = -1;
5217 
5218 #ifdef _LP64
5219   Label slow_case;
5220 
5221   // Try to allocate a new buffered value (from the heap)
5222   if (UseTLAB) {
5223     // FIXME -- for smaller code, the inline allocation (and the slow case) should be moved inside the pack handler.
5224     if (vk != NULL) {
5225       // Called from C1, where the return type is statically known.
5226       movptr(rbx, (intptr_t)vk-&gt;get_ValueKlass());
5227       jint lh = vk-&gt;layout_helper();
5228       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);
5229       movl(r14, lh);
5230     } else {
</pre>
<hr />
<pre>
5257       // FIXME -- do the packing in-line to avoid the runtime call
5258       mov(rax, r13);
5259       call(RuntimeAddress(vk-&gt;pack_handler())); // no need for call info as this will not safepoint.
5260     } else {
5261       movptr(rbx, Address(rax, InstanceKlass::adr_inlineklass_fixed_block_offset()));
5262       movptr(rbx, Address(rbx, InlineKlass::pack_handler_offset()));
5263       mov(rax, r13);
5264       call(rbx);
5265     }
5266     jmp(skip);
5267   }
5268 
5269   bind(slow_case);
5270   // We failed to allocate a new value, fall back to a runtime
5271   // call. Some oop field may be live in some registers but we can&#39;t
5272   // tell. That runtime call will take care of preserving them
5273   // across a GC if there&#39;s one.
5274 #endif
5275 
5276   if (from_interpreter) {
<span class="line-modified">5277     super_call_VM_leaf(StubRoutines::store_value_type_fields_to_buf());</span>
5278   } else {
<span class="line-modified">5279     call(RuntimeAddress(StubRoutines::store_value_type_fields_to_buf()));</span>
5280     call_offset = offset();
5281   }
5282 
5283   bind(skip);
5284   return call_offset;
5285 }
5286 
5287 
5288 // Move a value between registers/stack slots and update the reg_state
5289 bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {
5290   if (reg_state[to-&gt;value()] == reg_written) {
5291     return true; // Already written
5292   }
5293   if (from != to &amp;&amp; bt != T_VOID) {
5294     if (reg_state[to-&gt;value()] == reg_readonly) {
5295       return false; // Not yet writable
5296     }
5297     if (from-&gt;is_reg()) {
5298       if (to-&gt;is_reg()) {
5299         if (from-&gt;is_XMMRegister()) {
</pre>
</td>
<td>
<hr />
<pre>
5188   } else {
5189     movdqu(Address(base,  0), xtmp);
5190     movdqu(Address(base, 16), xtmp);
5191   }
5192   addptr(base, 32);
5193   subptr(cnt, 4);
5194 
5195   BIND(L_tail);
5196   addptr(cnt, 4);
5197   jccb(Assembler::lessEqual, L_end);
5198   decrement(cnt);
5199 
5200   BIND(L_sloop);
5201   movq(Address(base, 0), xtmp);
5202   addptr(base, 8);
5203   decrement(cnt);
5204   jccb(Assembler::greaterEqual, L_sloop);
5205   BIND(L_end);
5206 }
5207 
<span class="line-modified">5208 int MacroAssembler::store_inline_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {</span>
<span class="line-modified">5209   // An inline type might be returned. If fields are in registers we</span>
<span class="line-modified">5210   // need to allocate an inline type instance and initialize it with</span>
5211   // the value of the fields.
5212   Label skip;
5213   // We only need a new buffered value if a new one is not returned
5214   testptr(rax, 1);
5215   jcc(Assembler::zero, skip);
5216   int call_offset = -1;
5217 
5218 #ifdef _LP64
5219   Label slow_case;
5220 
5221   // Try to allocate a new buffered value (from the heap)
5222   if (UseTLAB) {
5223     // FIXME -- for smaller code, the inline allocation (and the slow case) should be moved inside the pack handler.
5224     if (vk != NULL) {
5225       // Called from C1, where the return type is statically known.
5226       movptr(rbx, (intptr_t)vk-&gt;get_ValueKlass());
5227       jint lh = vk-&gt;layout_helper();
5228       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);
5229       movl(r14, lh);
5230     } else {
</pre>
<hr />
<pre>
5257       // FIXME -- do the packing in-line to avoid the runtime call
5258       mov(rax, r13);
5259       call(RuntimeAddress(vk-&gt;pack_handler())); // no need for call info as this will not safepoint.
5260     } else {
5261       movptr(rbx, Address(rax, InstanceKlass::adr_inlineklass_fixed_block_offset()));
5262       movptr(rbx, Address(rbx, InlineKlass::pack_handler_offset()));
5263       mov(rax, r13);
5264       call(rbx);
5265     }
5266     jmp(skip);
5267   }
5268 
5269   bind(slow_case);
5270   // We failed to allocate a new value, fall back to a runtime
5271   // call. Some oop field may be live in some registers but we can&#39;t
5272   // tell. That runtime call will take care of preserving them
5273   // across a GC if there&#39;s one.
5274 #endif
5275 
5276   if (from_interpreter) {
<span class="line-modified">5277     super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());</span>
5278   } else {
<span class="line-modified">5279     call(RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));</span>
5280     call_offset = offset();
5281   }
5282 
5283   bind(skip);
5284   return call_offset;
5285 }
5286 
5287 
5288 // Move a value between registers/stack slots and update the reg_state
5289 bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {
5290   if (reg_state[to-&gt;value()] == reg_written) {
5291     return true; // Already written
5292   }
5293   if (from != to &amp;&amp; bt != T_VOID) {
5294     if (reg_state[to-&gt;value()] == reg_readonly) {
5295       return false; // Not yet writable
5296     }
5297     if (from-&gt;is_reg()) {
5298       if (to-&gt;is_reg()) {
5299         if (from-&gt;is_XMMRegister()) {
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
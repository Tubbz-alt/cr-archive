<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1637   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1638 
1639   void pushoop(jobject obj);
1640   void pushklass(Metadata* obj);
1641 
1642   // sign extend as need a l to ptr sized element
1643   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1644   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1645 
1646 
1647  public:
1648   // C2 compiled method&#39;s prolog code.
1649   void verified_entry(Compile* C, int sp_inc = 0);
1650 
1651   enum RegState {
1652     reg_readonly,
1653     reg_writable,
1654     reg_written
1655   };
1656 
<span class="line-modified">1657   int store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter = true);</span>
1658 
1659   // Unpack all value type arguments passed as oops
1660   void unpack_value_args(Compile* C, bool receiver_only);
1661   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);
1662   bool unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,
1663                            RegState reg_state[], int ret_off, int extra_stack_offset);
1664   bool pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
1665                          VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
1666                          int ret_off, int extra_stack_offset);
1667   void remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset);
1668 
1669   void shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,
1670                           BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
1671                           int args_passed, int args_on_stack, VMRegPair* regs,
1672                           int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc);
1673   bool shuffle_value_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
1674                                 VMRegPair* regs_from, int from_index, int regs_from_count,
1675                                 RegState* reg_state, int sp_inc, int extra_stack_offset);
1676   VMReg spill_reg_for(VMReg reg);
1677 
</pre>
</td>
<td>
<hr />
<pre>
1637   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1638 
1639   void pushoop(jobject obj);
1640   void pushklass(Metadata* obj);
1641 
1642   // sign extend as need a l to ptr sized element
1643   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1644   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1645 
1646 
1647  public:
1648   // C2 compiled method&#39;s prolog code.
1649   void verified_entry(Compile* C, int sp_inc = 0);
1650 
1651   enum RegState {
1652     reg_readonly,
1653     reg_writable,
1654     reg_written
1655   };
1656 
<span class="line-modified">1657   int store_inline_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter = true);</span>
1658 
1659   // Unpack all value type arguments passed as oops
1660   void unpack_value_args(Compile* C, bool receiver_only);
1661   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);
1662   bool unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,
1663                            RegState reg_state[], int ret_off, int extra_stack_offset);
1664   bool pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
1665                          VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
1666                          int ret_off, int extra_stack_offset);
1667   void remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset);
1668 
1669   void shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,
1670                           BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
1671                           int args_passed, int args_on_stack, VMRegPair* regs,
1672                           int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc);
1673   bool shuffle_value_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,
1674                                 VMRegPair* regs_from, int from_index, int regs_from_count,
1675                                 RegState* reg_state, int sp_inc, int extra_stack_offset);
1676   VMReg spill_reg_for(VMReg reg);
1677 
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
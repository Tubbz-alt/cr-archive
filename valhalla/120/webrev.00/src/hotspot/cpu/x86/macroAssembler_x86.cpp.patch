diff a/src/hotspot/cpu/x86/macroAssembler_x86.cpp b/src/hotspot/cpu/x86/macroAssembler_x86.cpp
--- a/src/hotspot/cpu/x86/macroAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/macroAssembler_x86.cpp
@@ -5203,13 +5203,13 @@
   decrement(cnt);
   jccb(Assembler::greaterEqual, L_sloop);
   BIND(L_end);
 }
 
-int MacroAssembler::store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {
-  // A value type might be returned. If fields are in registers we
-  // need to allocate a value type instance and initialize it with
+int MacroAssembler::store_inline_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {
+  // An inline type might be returned. If fields are in registers we
+  // need to allocate an inline type instance and initialize it with
   // the value of the fields.
   Label skip;
   // We only need a new buffered value if a new one is not returned
   testptr(rax, 1);
   jcc(Assembler::zero, skip);
@@ -5272,13 +5272,13 @@
   // tell. That runtime call will take care of preserving them
   // across a GC if there's one.
 #endif
 
   if (from_interpreter) {
-    super_call_VM_leaf(StubRoutines::store_value_type_fields_to_buf());
+    super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());
   } else {
-    call(RuntimeAddress(StubRoutines::store_value_type_fields_to_buf()));
+    call(RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));
     call_offset = offset();
   }
 
   bind(skip);
   return call_offset;

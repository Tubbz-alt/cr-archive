<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciInstanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciInstanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 50 //
 51 // Loaded instance klass.
 52 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 53   ciKlass(k)
 54 {
 55   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 56   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 57   InstanceKlass* ik = get_instanceKlass();
 58 
 59   AccessFlags access_flags = ik-&gt;access_flags();
 60   _flags = ciFlags(access_flags);
 61   _has_finalizer = access_flags.has_finalizer();
 62   _has_subklass = flags().is_final() ? subklass_false : subklass_unknown;
 63   _init_state = ik-&gt;init_state();
 64   _nonstatic_field_size = ik-&gt;nonstatic_field_size();
 65   _has_nonstatic_fields = ik-&gt;has_nonstatic_fields();
 66   _has_nonstatic_concrete_methods = ik-&gt;has_nonstatic_concrete_methods();
 67   _is_unsafe_anonymous = ik-&gt;is_unsafe_anonymous();
 68   _nonstatic_fields = NULL;            // initialized lazily by compute_nonstatic_fields
 69   _has_injected_fields = -1;
<span class="line-removed"> 70   _vcc_klass = NULL;</span>
 71   _implementor = NULL; // we will fill these lazily
 72 
 73   // Ensure that the metadata wrapped by the ciMetadata is kept alive by GC.
 74   // This is primarily useful for metadata which is considered as weak roots
 75   // by the GC but need to be strong roots if reachable from a current compilation.
 76   // InstanceKlass are created for both weak and strong metadata.  Ensuring this metadata
 77   // alive covers the cases where there are weak roots without performance cost.
 78   oop holder = ik-&gt;klass_holder();
 79   if (ik-&gt;is_unsafe_anonymous()) {
 80     // Though ciInstanceKlass records class loader oop, it&#39;s not enough to keep
 81     // VM unsafe anonymous classes alive (loader == NULL). Klass holder should
 82     // be used instead. It is enough to record a ciObject, since cached elements are never removed
 83     // during ciObjectFactory lifetime. ciObjectFactory itself is created for
 84     // every compilation and lives for the whole duration of the compilation.
 85     assert(holder != NULL, &quot;holder of unsafe anonymous class is the mirror which is never null&quot;);
 86     (void)CURRENT_ENV-&gt;get_object(holder);
 87   }
 88 
 89   Thread *thread = Thread::current();
 90   if (ciObjectFactory::is_initialized()) {
</pre>
<hr />
<pre>
109       super();
110     }
111     //compute_nonstatic_fields();  // done outside of constructor
112   }
113 
114   _field_cache = NULL;
115 }
116 
117 // Version for unloaded classes:
118 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
119                                  jobject loader, jobject protection_domain,
120                                  BasicType bt)
121   : ciKlass(name, bt)
122 {
123   assert(name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY, &quot;not an instance klass&quot;);
124   _init_state = (InstanceKlass::ClassState)0;
125   _nonstatic_field_size = -1;
126   _has_nonstatic_fields = false;
127   _nonstatic_fields = NULL;            // initialized lazily by compute_nonstatic_fields
128   _has_injected_fields = -1;
<span class="line-removed">129   _vcc_klass = NULL;</span>
130   _is_unsafe_anonymous = false;
131   _loader = loader;
132   _protection_domain = protection_domain;
133   _is_shared = false;
134   _super = NULL;
135   _java_mirror = NULL;
136   _field_cache = NULL;
137 }
138 
139 
140 
141 // ------------------------------------------------------------------
142 // ciInstanceKlass::compute_shared_is_initialized
143 void ciInstanceKlass::compute_shared_init_state() {
144   GUARDED_VM_ENTRY(
145     InstanceKlass* ik = get_instanceKlass();
146     _init_state = ik-&gt;init_state();
147   )
148 }
149 
</pre>
<hr />
<pre>
655       VM_ENTRY_MARK;
656       MutexLocker ml(Compile_lock);
657       Klass* k = get_instanceKlass()-&gt;implementor();
658       if (k != NULL) {
659         if (k == get_instanceKlass()) {
660           // More than one implementors. Use &#39;this&#39; in this case.
661           impl = this;
662         } else {
663           impl = CURRENT_THREAD_ENV-&gt;get_instance_klass(k);
664         }
665       }
666     }
667     // Memoize this result.
668     if (!is_shared()) {
669       _implementor = impl;
670     }
671   }
672   return impl;
673 }
674 






























675 ciInstanceKlass* ciInstanceKlass::unsafe_anonymous_host() {
676   assert(is_loaded(), &quot;must be loaded&quot;);
677   if (is_unsafe_anonymous()) {
678     VM_ENTRY_MARK
679     Klass* unsafe_anonymous_host = get_instanceKlass()-&gt;unsafe_anonymous_host();
680     return CURRENT_ENV-&gt;get_instance_klass(unsafe_anonymous_host);
681   }
682   return NULL;
683 }
684 
<span class="line-removed">685 ciInstanceKlass* ciInstanceKlass::vcc_klass() {</span>
<span class="line-removed">686   return NULL;</span>
<span class="line-removed">687 }</span>
<span class="line-removed">688 </span>
689 // Utility class for printing of the contents of the static fields for
690 // use by compilation replay.  It only prints out the information that
691 // could be consumed by the compiler, so for primitive types it prints
692 // out the actual value.  For Strings it&#39;s the actual string value.
693 // For array types it it&#39;s first level array size since that&#39;s the
694 // only value which statically unchangeable.  For all other reference
695 // types it simply prints out the dynamic type.
696 
697 class StaticFieldPrinter : public FieldClosure {
698 protected:
699   outputStream* _out;
700 public:
701   StaticFieldPrinter(outputStream* out) :
702     _out(out) {
703   }
704   void do_field_helper(fieldDescriptor* fd, oop obj, bool flattened);
705 };
706 
707 class StaticFinalFieldPrinter : public StaticFieldPrinter {
708   const char*   _holder;
</pre>
</td>
<td>
<hr />
<pre>
 50 //
 51 // Loaded instance klass.
 52 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 53   ciKlass(k)
 54 {
 55   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 56   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 57   InstanceKlass* ik = get_instanceKlass();
 58 
 59   AccessFlags access_flags = ik-&gt;access_flags();
 60   _flags = ciFlags(access_flags);
 61   _has_finalizer = access_flags.has_finalizer();
 62   _has_subklass = flags().is_final() ? subklass_false : subklass_unknown;
 63   _init_state = ik-&gt;init_state();
 64   _nonstatic_field_size = ik-&gt;nonstatic_field_size();
 65   _has_nonstatic_fields = ik-&gt;has_nonstatic_fields();
 66   _has_nonstatic_concrete_methods = ik-&gt;has_nonstatic_concrete_methods();
 67   _is_unsafe_anonymous = ik-&gt;is_unsafe_anonymous();
 68   _nonstatic_fields = NULL;            // initialized lazily by compute_nonstatic_fields
 69   _has_injected_fields = -1;

 70   _implementor = NULL; // we will fill these lazily
 71 
 72   // Ensure that the metadata wrapped by the ciMetadata is kept alive by GC.
 73   // This is primarily useful for metadata which is considered as weak roots
 74   // by the GC but need to be strong roots if reachable from a current compilation.
 75   // InstanceKlass are created for both weak and strong metadata.  Ensuring this metadata
 76   // alive covers the cases where there are weak roots without performance cost.
 77   oop holder = ik-&gt;klass_holder();
 78   if (ik-&gt;is_unsafe_anonymous()) {
 79     // Though ciInstanceKlass records class loader oop, it&#39;s not enough to keep
 80     // VM unsafe anonymous classes alive (loader == NULL). Klass holder should
 81     // be used instead. It is enough to record a ciObject, since cached elements are never removed
 82     // during ciObjectFactory lifetime. ciObjectFactory itself is created for
 83     // every compilation and lives for the whole duration of the compilation.
 84     assert(holder != NULL, &quot;holder of unsafe anonymous class is the mirror which is never null&quot;);
 85     (void)CURRENT_ENV-&gt;get_object(holder);
 86   }
 87 
 88   Thread *thread = Thread::current();
 89   if (ciObjectFactory::is_initialized()) {
</pre>
<hr />
<pre>
108       super();
109     }
110     //compute_nonstatic_fields();  // done outside of constructor
111   }
112 
113   _field_cache = NULL;
114 }
115 
116 // Version for unloaded classes:
117 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
118                                  jobject loader, jobject protection_domain,
119                                  BasicType bt)
120   : ciKlass(name, bt)
121 {
122   assert(name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY, &quot;not an instance klass&quot;);
123   _init_state = (InstanceKlass::ClassState)0;
124   _nonstatic_field_size = -1;
125   _has_nonstatic_fields = false;
126   _nonstatic_fields = NULL;            // initialized lazily by compute_nonstatic_fields
127   _has_injected_fields = -1;

128   _is_unsafe_anonymous = false;
129   _loader = loader;
130   _protection_domain = protection_domain;
131   _is_shared = false;
132   _super = NULL;
133   _java_mirror = NULL;
134   _field_cache = NULL;
135 }
136 
137 
138 
139 // ------------------------------------------------------------------
140 // ciInstanceKlass::compute_shared_is_initialized
141 void ciInstanceKlass::compute_shared_init_state() {
142   GUARDED_VM_ENTRY(
143     InstanceKlass* ik = get_instanceKlass();
144     _init_state = ik-&gt;init_state();
145   )
146 }
147 
</pre>
<hr />
<pre>
653       VM_ENTRY_MARK;
654       MutexLocker ml(Compile_lock);
655       Klass* k = get_instanceKlass()-&gt;implementor();
656       if (k != NULL) {
657         if (k == get_instanceKlass()) {
658           // More than one implementors. Use &#39;this&#39; in this case.
659           impl = this;
660         } else {
661           impl = CURRENT_THREAD_ENV-&gt;get_instance_klass(k);
662         }
663       }
664     }
665     // Memoize this result.
666     if (!is_shared()) {
667       _implementor = impl;
668     }
669   }
670   return impl;
671 }
672 
<span class="line-added">673 bool ciInstanceKlass::can_be_value_klass(bool is_exact) {</span>
<span class="line-added">674   if (!EnableValhalla) {</span>
<span class="line-added">675     return false;</span>
<span class="line-added">676   }</span>
<span class="line-added">677   if (!is_loaded() ||   // Not loaded, might be a value klass</span>
<span class="line-added">678       is_valuetype() || // Known to be a value klass</span>
<span class="line-added">679       // Non-exact j.l.Object or interface klass</span>
<span class="line-added">680       ((is_java_lang_Object() || is_interface()) &amp;&amp; !is_exact)) {</span>
<span class="line-added">681     return true;</span>
<span class="line-added">682   }</span>
<span class="line-added">683   if (is_abstract() &amp;&amp; !has_nonstatic_fields()) {</span>
<span class="line-added">684     // TODO Factor out and re-use similar code from the ClassFileParser</span>
<span class="line-added">685     // An abstract class can only be implemented by a value type if it has no instance</span>
<span class="line-added">686     // fields, no synchronized instance methods and an empty, no-arg constructor.</span>
<span class="line-added">687     VM_ENTRY_MARK;</span>
<span class="line-added">688     Array&lt;Method*&gt;* methods = get_instanceKlass()-&gt;methods();</span>
<span class="line-added">689     for (int i = 0; i &lt; methods-&gt;length(); i++) {</span>
<span class="line-added">690       Method* m = methods-&gt;at(i);</span>
<span class="line-added">691       if ((m-&gt;is_synchronized() &amp;&amp; !m-&gt;is_static()) ||</span>
<span class="line-added">692           (m-&gt;is_object_constructor() &amp;&amp;</span>
<span class="line-added">693            (m-&gt;signature() != vmSymbols::void_method_signature() ||</span>
<span class="line-added">694             !m-&gt;is_vanilla_constructor()))) {</span>
<span class="line-added">695         return false;</span>
<span class="line-added">696       }</span>
<span class="line-added">697     }</span>
<span class="line-added">698     return true;</span>
<span class="line-added">699   }</span>
<span class="line-added">700   return false;</span>
<span class="line-added">701 }</span>
<span class="line-added">702 </span>
703 ciInstanceKlass* ciInstanceKlass::unsafe_anonymous_host() {
704   assert(is_loaded(), &quot;must be loaded&quot;);
705   if (is_unsafe_anonymous()) {
706     VM_ENTRY_MARK
707     Klass* unsafe_anonymous_host = get_instanceKlass()-&gt;unsafe_anonymous_host();
708     return CURRENT_ENV-&gt;get_instance_klass(unsafe_anonymous_host);
709   }
710   return NULL;
711 }
712 




713 // Utility class for printing of the contents of the static fields for
714 // use by compilation replay.  It only prints out the information that
715 // could be consumed by the compiler, so for primitive types it prints
716 // out the actual value.  For Strings it&#39;s the actual string value.
717 // For array types it it&#39;s first level array size since that&#39;s the
718 // only value which statically unchangeable.  For all other reference
719 // types it simply prints out the dynamic type.
720 
721 class StaticFieldPrinter : public FieldClosure {
722 protected:
723   outputStream* _out;
724 public:
725   StaticFieldPrinter(outputStream* out) :
726     _out(out) {
727   }
728   void do_field_helper(fieldDescriptor* fd, oop obj, bool flattened);
729 };
730 
731 class StaticFinalFieldPrinter : public StaticFieldPrinter {
732   const char*   _holder;
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
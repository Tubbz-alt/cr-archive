<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.net.URI;
  30 import java.net.URISyntaxException;
  31 import java.nio.CharBuffer;
  32 import java.nio.file.ClosedFileSystemException;
  33 import java.util.Arrays;
  34 import java.util.EnumSet;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Map;
  38 import java.util.Set;
  39 import java.util.function.IntFunction;
  40 
  41 import javax.lang.model.element.Modifier;
  42 import javax.lang.model.element.NestingKind;
  43 import javax.tools.JavaFileManager;
  44 import javax.tools.JavaFileObject;
  45 
  46 import com.sun.tools.javac.code.Source.Feature;
  47 import com.sun.tools.javac.comp.Annotate;
  48 import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
  49 import com.sun.tools.javac.code.*;
  50 import com.sun.tools.javac.code.Directive.*;
  51 import com.sun.tools.javac.code.Lint.LintCategory;
  52 import com.sun.tools.javac.code.Scope.WriteableScope;
  53 import com.sun.tools.javac.code.Symbol.*;
  54 import com.sun.tools.javac.code.Symtab;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  57 import com.sun.tools.javac.file.BaseFileManager;
  58 import com.sun.tools.javac.file.PathFileObject;
  59 import com.sun.tools.javac.jvm.ClassFile.Version;
  60 import com.sun.tools.javac.jvm.PoolConstant.NameAndType;
  61 import com.sun.tools.javac.main.Option;
  62 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  63 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  64 import com.sun.tools.javac.util.*;
  65 import com.sun.tools.javac.util.DefinedBy.Api;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 import static com.sun.tools.javac.code.Flags.*;
  69 import static com.sun.tools.javac.code.Kinds.Kind.*;
  70 
  71 import com.sun.tools.javac.code.Scope.LookupKind;
  72 
  73 import static com.sun.tools.javac.code.TypeTag.ARRAY;
  74 import static com.sun.tools.javac.code.TypeTag.CLASS;
  75 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  76 import static com.sun.tools.javac.jvm.ClassFile.*;
  77 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
  78 
  79 import static com.sun.tools.javac.main.Option.PARAMETERS;
  80 
  81 /** This class provides operations to read a classfile into an internal
  82  *  representation. The internal representation is anchored in a
  83  *  ClassSymbol which contains in its scope symbol representations
  84  *  for all other definitions in the classfile. Top-level Classes themselves
  85  *  appear as members of the scopes of PackageSymbols.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
 108     /** Switch: allow inline types.
 109      */
 110     boolean allowInlineTypes;
 111 
 112     /** Switch: allow sealed
 113      */
 114     boolean allowSealedTypes;
 115 
 116     /** Switch: allow records
 117      */
 118     boolean allowRecords;
 119 
 120    /** Lint option: warn about classfile issues
 121      */
 122     boolean lintClassfile;
 123 
 124     /** Switch: preserve parameter names from the variable table.
 125      */
 126     public boolean saveParameterNames;
 127 
 128     /** Switch: Should javac recongnize and handle value based classes specially ?
 129      */
 130     private boolean allowValueBasedClasses;
 131 
 132     /**
 133      * The currently selected profile.
 134      */
 135     public final Profile profile;
 136 
 137     /** The log to use for verbose output
 138      */
 139     final Log log;
 140 
 141     /** The symbol table. */
 142     Symtab syms;
 143 
 144     Types types;
 145 
 146     /** The name table. */
 147     final Names names;
 148 
 149     /** Access to files
 150      */
 151     private final JavaFileManager fileManager;
 152 
 153     /** Factory for diagnostics
 154      */
 155     JCDiagnostic.Factory diagFactory;
 156 
 157     DeferredCompletionFailureHandler dcfh;
 158 
 159     /**
 160      * Support for preview language features.
 161      */
 162     Preview preview;
 163 
 164     /** The current scope where type variables are entered.
 165      */
 166     protected WriteableScope typevars;
 167 
 168     private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
 169     private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
 170 
 171     /** The path name of the class file currently being read.
 172      */
 173     protected JavaFileObject currentClassFile = null;
 174 
 175     /** The class or method currently being read.
 176      */
 177     protected Symbol currentOwner = null;
 178 
 179     /** The module containing the class currently being read.
 180      */
 181     protected ModuleSymbol currentModule = null;
 182 
 183     /** The buffer containing the currently read class file.
 184      */
 185     ByteBuffer buf = new ByteBuffer(INITIAL_BUFFER_SIZE);
 186 
 187     /** The current input pointer.
 188      */
 189     protected int bp;
 190 
 191     /** The pool reader.
 192      */
 193     PoolReader poolReader;
 194 
 195     /** The major version number of the class file being read. */
 196     int majorVersion;
 197     /** The minor version number of the class file being read. */
 198     int minorVersion;
 199 
 200     /** A table to hold the constant pool indices for method parameter
 201      * names, as given in LocalVariableTable attributes.
 202      */
 203     int[] parameterNameIndices;
 204 
 205     /**
 206      * A table to hold annotations for method parameters.
 207      */
 208     ParameterAnnotations[] parameterAnnotations;
 209 
 210     /**
 211      * A holder for parameter annotations.
 212      */
 213     static class ParameterAnnotations {
 214         List&lt;CompoundAnnotationProxy&gt; proxies;
 215 
 216         void add(List&lt;CompoundAnnotationProxy&gt; newAnnotations) {
 217             if (proxies == null) {
 218                 proxies = newAnnotations;
 219             } else {
 220                 proxies = proxies.prependList(newAnnotations);
 221             }
 222         }
 223     }
 224 
 225     /**
 226      * Whether or not any parameter names have been found.
 227      */
 228     boolean haveParameterNameIndices;
 229 
 230     /** Set this to false every time we start reading a method
 231      * and are saving parameter names.  Set it to true when we see
 232      * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
 233      * then we ignore the parameter names from the LVT.
 234      */
 235     boolean sawMethodParameters;
 236 
 237     /**
 238      * The set of attribute names for which warnings have been generated for the current class
 239      */
 240     Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();
 241 
 242     /**
 243      * The prototype @Target Attribute.Compound if this class is an annotation annotated with
 244      * @Target
 245      */
 246     CompoundAnnotationProxy target;
 247 
 248     /**
 249      * The prototype @Repeatable Attribute.Compound if this class is an annotation annotated with
 250      * @Repeatable
 251      */
 252     CompoundAnnotationProxy repeatable;
 253 
 254     /** Get the ClassReader instance for this invocation. */
 255     public static ClassReader instance(Context context) {
 256         ClassReader instance = context.get(classReaderKey);
 257         if (instance == null)
 258             instance = new ClassReader(context);
 259         return instance;
 260     }
 261 
 262     /** Construct a new class reader. */
 263     protected ClassReader(Context context) {
 264         context.put(classReaderKey, this);
 265         annotate = Annotate.instance(context);
 266         names = Names.instance(context);
 267         syms = Symtab.instance(context);
 268         types = Types.instance(context);
 269         fileManager = context.get(JavaFileManager.class);
 270         if (fileManager == null)
 271             throw new AssertionError(&quot;FileManager initialization error&quot;);
 272         diagFactory = JCDiagnostic.Factory.instance(context);
 273         dcfh = DeferredCompletionFailureHandler.instance(context);
 274 
 275         log = Log.instance(context);
 276 
 277         Options options = Options.instance(context);
 278         verbose         = options.isSet(Option.VERBOSE);
 279 
 280         Source source = Source.instance(context);
 281         preview = Preview.instance(context);
 282         allowModules     = Feature.MODULES.allowedInSource(source);
 283         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);
 284         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 285                 Feature.RECORDS.allowedInSource(source);
 286         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 287                 Feature.SEALED_CLASSES.allowedInSource(source);
 288 
 289         saveParameterNames = options.isSet(PARAMETERS);
 290         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 291 
 292         profile = Profile.instance(context);
 293 
 294         typevars = WriteableScope.create(syms.noSymbol);
 295 
 296         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 297 
 298         initAttributeReaders();
 299     }
 300 
 301     /** Add member to class unless it is synthetic.
 302      */
 303     private void enterMember(ClassSymbol c, Symbol sym) {
 304         // Synthetic members are not entered -- reason lost to history (optimization?).
 305         // Lambda methods must be entered because they may have inner classes (which reference them)
<a name="1" id="anc1"></a><span class="line-modified"> 306         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))</span>

 307             c.members_field.enter(sym);
<a name="2" id="anc2"></a>

















 308     }
 309 
 310 /************************************************************************
 311  * Error Diagnoses
 312  ***********************************************************************/
 313 
 314     public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
 315         return new ClassFinder.BadClassFile (
 316             currentOwner.enclClass(),
 317             currentClassFile,
 318             diagFactory.fragment(key, args),
 319             diagFactory,
 320             dcfh);
 321     }
 322 
 323     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 324         return new ClassFinder.BadEnclosingMethodAttr (
 325             currentOwner.enclClass(),
 326             currentClassFile,
 327             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
 328             diagFactory,
 329             dcfh);
 330     }
 331 
 332 /************************************************************************
 333  * Buffer Access
 334  ***********************************************************************/
 335 
 336     /** Read a character.
 337      */
 338     char nextChar() {
 339         char res = buf.getChar(bp);
 340         bp += 2;
 341         return res;
 342     }
 343 
 344     /** Read a byte.
 345      */
 346     int nextByte() {
 347         return buf.getByte(bp++) &amp; 0xFF;
 348     }
 349 
 350     /** Read an integer.
 351      */
 352     int nextInt() {
 353         int res = buf.getInt(bp);
 354         bp += 4;
 355         return res;
 356     }
 357 
 358 /************************************************************************
 359  * Constant Pool Access
 360  ***********************************************************************/
 361 
 362     /** Read module_flags.
 363      */
 364     Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
 365         Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
 366         for (ModuleFlags f : ModuleFlags.values()) {
 367             if ((flags &amp; f.value) != 0)
 368                 set.add(f);
 369         }
 370         return set;
 371     }
 372 
 373     /** Read resolution_flags.
 374      */
 375     Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
 376         Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
 377         for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
 378             if ((flags &amp; f.value) != 0)
 379                 set.add(f);
 380         }
 381         return set;
 382     }
 383 
 384     /** Read exports_flags.
 385      */
 386     Set&lt;ExportsFlag&gt; readExportsFlags(int flags) {
 387         Set&lt;ExportsFlag&gt; set = EnumSet.noneOf(ExportsFlag.class);
 388         for (ExportsFlag f: ExportsFlag.values()) {
 389             if ((flags &amp; f.value) != 0)
 390                 set.add(f);
 391         }
 392         return set;
 393     }
 394 
 395     /** Read opens_flags.
 396      */
 397     Set&lt;OpensFlag&gt; readOpensFlags(int flags) {
 398         Set&lt;OpensFlag&gt; set = EnumSet.noneOf(OpensFlag.class);
 399         for (OpensFlag f: OpensFlag.values()) {
 400             if ((flags &amp; f.value) != 0)
 401                 set.add(f);
 402         }
 403         return set;
 404     }
 405 
 406     /** Read requires_flags.
 407      */
 408     Set&lt;RequiresFlag&gt; readRequiresFlags(int flags) {
 409         Set&lt;RequiresFlag&gt; set = EnumSet.noneOf(RequiresFlag.class);
 410         for (RequiresFlag f: RequiresFlag.values()) {
 411             if ((flags &amp; f.value) != 0)
 412                 set.add(f);
 413         }
 414         return set;
 415     }
 416 
 417 /************************************************************************
 418  * Reading Types
 419  ***********************************************************************/
 420 
 421     /** The unread portion of the currently read type is
 422      *  signature[sigp..siglimit-1].
 423      */
 424     byte[] signature;
 425     int sigp;
 426     int siglimit;
 427     boolean sigEnterPhase = false;
 428 
 429     /** Convert signature to type, where signature is a byte array segment.
 430      */
 431     Type sigToType(byte[] sig, int offset, int len) {
 432         signature = sig;
 433         sigp = offset;
 434         siglimit = offset + len;
 435         return sigToType();
 436     }
 437 
 438     /** Convert signature to type, where signature is implicit.
 439      */
 440     Type sigToType() {
 441         switch ((char) signature[sigp]) {
 442         case &#39;T&#39;:
 443             sigp++;
 444             int start = sigp;
 445             while (signature[sigp] != &#39;;&#39;) sigp++;
 446             sigp++;
 447             return sigEnterPhase
 448                 ? Type.noType
 449                 : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));
 450         case &#39;+&#39;: {
 451             sigp++;
 452             Type t = sigToType();
 453             return new WildcardType(t, BoundKind.EXTENDS, syms.boundClass);
 454         }
 455         case &#39;*&#39;:
 456             sigp++;
 457             return new WildcardType(syms.objectType, BoundKind.UNBOUND,
 458                                     syms.boundClass);
 459         case &#39;-&#39;: {
 460             sigp++;
 461             Type t = sigToType();
 462             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 463         }
 464         case &#39;B&#39;:
 465             sigp++;
 466             return syms.byteType;
 467         case &#39;C&#39;:
 468             sigp++;
 469             return syms.charType;
 470         case &#39;D&#39;:
 471             sigp++;
 472             return syms.doubleType;
 473         case &#39;F&#39;:
 474             sigp++;
 475             return syms.floatType;
 476         case &#39;I&#39;:
 477             sigp++;
 478             return syms.intType;
 479         case &#39;J&#39;:
 480             sigp++;
 481             return syms.longType;
 482         case &#39;Q&#39;:
 483         case &#39;L&#39;:
 484             {
 485                 // int oldsigp = sigp;
 486                 Type t = classSigToType();
 487                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 488                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 489                                        &quot;(please recompile from source)&quot;);
 490                 /*
 491                 System.err.println(&quot; decoded &quot; +
 492                                    new String(signature, oldsigp, sigp-oldsigp) +
 493                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 494                 */
 495                 return t;
 496             }
 497         case &#39;S&#39;:
 498             sigp++;
 499             return syms.shortType;
 500         case &#39;V&#39;:
 501             sigp++;
 502             return syms.voidType;
 503         case &#39;Z&#39;:
 504             sigp++;
 505             return syms.booleanType;
 506         case &#39;[&#39;:
 507             sigp++;
 508             return new ArrayType(sigToType(), syms.arrayClass);
 509         case &#39;(&#39;:
 510             sigp++;
 511             List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
 512             Type restype = sigToType();
 513             List&lt;Type&gt; thrown = List.nil();
 514             while (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;^&#39;) {
 515                 sigp++;
 516                 thrown = thrown.prepend(sigToType());
 517             }
 518             // if there is a typevar in the throws clause we should state it.
 519             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
 520                 if (l.head.hasTag(TYPEVAR)) {
 521                     l.head.tsym.flags_field |= THROWS;
 522                 }
 523             }
 524             return new MethodType(argtypes,
 525                                   restype,
 526                                   thrown.reverse(),
 527                                   syms.methodClass);
 528         case &#39;&lt;&#39;:
 529             typevars = typevars.dup(currentOwner);
 530             Type poly = new ForAll(sigToTypeParams(), sigToType());
 531             typevars = typevars.leave();
 532             return poly;
 533         default:
 534             throw badClassFile(&quot;bad.signature&quot;,
 535                                Convert.utf2string(signature, sigp, 10));
 536         }
 537     }
 538 
 539     byte[] signatureBuffer = new byte[0];
 540     int sbp = 0;
 541     /** Convert class signature to type, where signature is implicit.
 542      */
 543     Type classSigToType() {
 544         if (signature[sigp] != &#39;L&#39; &amp;&amp; signature[sigp] != &#39;Q&#39;)
 545             throw badClassFile(&quot;bad.class.signature&quot;,
 546                                Convert.utf2string(signature, sigp, 10));
 547         sigp++;
 548         Type outer = Type.noType;
 549         int startSbp = sbp;
 550 
 551         while (true) {
 552             final byte c = signature[sigp++];
 553             switch (c) {
 554 
 555             case &#39;;&#39;: {         // end
 556                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 557                                                          startSbp,
 558                                                          sbp - startSbp));
 559 
 560                 try {
 561                     return (outer == Type.noType) ?
 562                             t.erasure(types) :
 563                         new ClassType(outer, List.nil(), t);
 564                 } finally {
 565                     sbp = startSbp;
 566                 }
 567             }
 568 
 569             case &#39;&lt;&#39;:           // generic arguments
 570                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 571                                                          startSbp,
 572                                                          sbp - startSbp));
 573                 outer = new ClassType(outer, sigToTypes(&#39;&gt;&#39;), t) {
 574                         boolean completed = false;
 575                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 576                         public Type getEnclosingType() {
 577                             if (!completed) {
 578                                 completed = true;
 579                                 tsym.complete();
 580                                 Type enclosingType = tsym.type.getEnclosingType();
 581                                 if (enclosingType != Type.noType) {
 582                                     List&lt;Type&gt; typeArgs =
 583                                         super.getEnclosingType().allparams();
 584                                     List&lt;Type&gt; typeParams =
 585                                         enclosingType.allparams();
 586                                     if (typeParams.length() != typeArgs.length()) {
 587                                         // no &quot;rare&quot; types
 588                                         super.setEnclosingType(types.erasure(enclosingType));
 589                                     } else {
 590                                         super.setEnclosingType(types.subst(enclosingType,
 591                                                                            typeParams,
 592                                                                            typeArgs));
 593                                     }
 594                                 } else {
 595                                     super.setEnclosingType(Type.noType);
 596                                 }
 597                             }
 598                             return super.getEnclosingType();
 599                         }
 600                         @Override
 601                         public void setEnclosingType(Type outer) {
 602                             throw new UnsupportedOperationException();
 603                         }
 604                     };
 605                 switch (signature[sigp++]) {
 606                 case &#39;;&#39;:
 607                     if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;) {
 608                         // support old-style GJC signatures
 609                         // The signature produced was
 610                         // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
 611                         // rather than say
 612                         // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
 613                         // so we skip past &quot;.Lfoo/Outer$&quot;
 614                         sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
 615                             3;  // &quot;.L&quot; and &quot;$&quot;
 616                         signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 617                         break;
 618                     } else {
 619                         sbp = startSbp;
 620                         return outer;
 621                     }
 622                 case &#39;.&#39;:
 623                     signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 624                     break;
 625                 default:
 626                     throw new AssertionError(signature[sigp-1]);
 627                 }
 628                 continue;
 629 
 630             case &#39;.&#39;:
 631                 //we have seen an enclosing non-generic class
 632                 if (outer != Type.noType) {
 633                     t = enterClass(names.fromUtf(signatureBuffer,
 634                                                  startSbp,
 635                                                  sbp - startSbp));
 636                     outer = new ClassType(outer, List.nil(), t);
 637                 }
 638                 signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 639                 continue;
 640             case &#39;/&#39;:
 641                 signatureBuffer[sbp++] = (byte)&#39;.&#39;;
 642                 continue;
 643             default:
 644                 signatureBuffer[sbp++] = c;
 645                 continue;
 646             }
 647         }
 648     }
 649 
 650     /** Convert (implicit) signature to list of types
 651      *  until `terminator&#39; is encountered.
 652      */
 653     List&lt;Type&gt; sigToTypes(char terminator) {
 654         List&lt;Type&gt; head = List.of(null);
 655         List&lt;Type&gt; tail = head;
 656         while (signature[sigp] != terminator)
 657             tail = tail.setTail(List.of(sigToType()));
 658         sigp++;
 659         return head.tail;
 660     }
 661 
 662     /** Convert signature to type parameters, where signature is a byte
 663      *  array segment.
 664      */
 665     List&lt;Type&gt; sigToTypeParams(byte[] sig, int offset, int len) {
 666         signature = sig;
 667         sigp = offset;
 668         siglimit = offset + len;
 669         return sigToTypeParams();
 670     }
 671 
 672     /** Convert signature to type parameters, where signature is implicit.
 673      */
 674     List&lt;Type&gt; sigToTypeParams() {
 675         List&lt;Type&gt; tvars = List.nil();
 676         if (signature[sigp] == &#39;&lt;&#39;) {
 677             sigp++;
 678             int start = sigp;
 679             sigEnterPhase = true;
 680             while (signature[sigp] != &#39;&gt;&#39;)
 681                 tvars = tvars.prepend(sigToTypeParam());
 682             sigEnterPhase = false;
 683             sigp = start;
 684             while (signature[sigp] != &#39;&gt;&#39;)
 685                 sigToTypeParam();
 686             sigp++;
 687         }
 688         return tvars.reverse();
 689     }
 690 
 691     /** Convert (implicit) signature to type parameter.
 692      */
 693     Type sigToTypeParam() {
 694         int start = sigp;
 695         while (signature[sigp] != &#39;:&#39;) sigp++;
 696         Name name = names.fromUtf(signature, start, sigp - start);
 697         TypeVar tvar;
 698         if (sigEnterPhase) {
 699             tvar = new TypeVar(name, currentOwner, syms.botType);
 700             typevars.enter(tvar.tsym);
 701         } else {
 702             tvar = (TypeVar)findTypeVar(name);
 703         }
 704         List&lt;Type&gt; bounds = List.nil();
 705         boolean allInterfaces = false;
 706         if (signature[sigp] == &#39;:&#39; &amp;&amp; signature[sigp+1] == &#39;:&#39;) {
 707             sigp++;
 708             allInterfaces = true;
 709         }
 710         while (signature[sigp] == &#39;:&#39;) {
 711             sigp++;
 712             bounds = bounds.prepend(sigToType());
 713         }
 714         if (!sigEnterPhase) {
 715             types.setBounds(tvar, bounds.reverse(), allInterfaces);
 716         }
 717         return tvar;
 718     }
 719 
 720     /** Find type variable with given name in `typevars&#39; scope.
 721      */
 722     Type findTypeVar(Name name) {
 723         Symbol s = typevars.findFirst(name);
 724         if (s != null) {
 725             return s.type;
 726         } else {
 727             if (readingClassAttr) {
 728                 // While reading the class attribute, the supertypes
 729                 // might refer to a type variable from an enclosing element
 730                 // (method or class).
 731                 // If the type variable is defined in the enclosing class,
 732                 // we can actually find it in
 733                 // currentOwner.owner.type.getTypeArguments()
 734                 // However, until we have read the enclosing method attribute
 735                 // we don&#39;t know for sure if this owner is correct.  It could
 736                 // be a method and there is no way to tell before reading the
 737                 // enclosing method attribute.
 738                 TypeVar t = new TypeVar(name, currentOwner, syms.botType);
 739                 missingTypeVariables = missingTypeVariables.prepend(t);
 740                 // System.err.println(&quot;Missing type var &quot; + name);
 741                 return t;
 742             }
 743             throw badClassFile(&quot;undecl.type.var&quot;, name);
 744         }
 745     }
 746 
 747 /************************************************************************
 748  * Reading Attributes
 749  ***********************************************************************/
 750 
 751     protected enum AttributeKind { CLASS, MEMBER }
 752 
 753     protected abstract class AttributeReader {
 754         protected AttributeReader(Name name, ClassFile.Version version, Set&lt;AttributeKind&gt; kinds) {
 755             this.name = name;
 756             this.version = version;
 757             this.kinds = kinds;
 758         }
 759 
 760         protected boolean accepts(AttributeKind kind) {
 761             if (kinds.contains(kind)) {
 762                 if (majorVersion &gt; version.major || (majorVersion == version.major &amp;&amp; minorVersion &gt;= version.minor))
 763                     return true;
 764 
 765                 if (lintClassfile &amp;&amp; !warnedAttrs.contains(name)) {
 766                     JavaFileObject prev = log.useSource(currentClassFile);
 767                     try {
 768                         log.warning(LintCategory.CLASSFILE, (DiagnosticPosition) null,
 769                                     Warnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));
 770                     } finally {
 771                         log.useSource(prev);
 772                     }
 773                     warnedAttrs.add(name);
 774                 }
 775             }
 776             return false;
 777         }
 778 
 779         protected abstract void read(Symbol sym, int attrLen);
 780 
 781         protected final Name name;
 782         protected final ClassFile.Version version;
 783         protected final Set&lt;AttributeKind&gt; kinds;
 784     }
 785 
 786     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 787             EnumSet.of(AttributeKind.CLASS);
 788     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 789             EnumSet.of(AttributeKind.MEMBER);
 790     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 791             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 792 
 793     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 794 
 795     private void initAttributeReaders() {
 796         AttributeReader[] readers = {
 797             // v45.3 attributes
 798 
 799             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 800                 protected void read(Symbol sym, int attrLen) {
 801                     if (allowInlineTypes) {
 802                         if (sym.isConstructor()  &amp;&amp; ((MethodSymbol) sym).type.getParameterTypes().size() == 0) {
 803                             int code_length = buf.getInt(bp + 4);
 804                             if ((code_length == 1 &amp;&amp; buf.getByte( bp + 8) == (byte) ByteCodes.return_) ||
 805                                     (code_length == 5 &amp;&amp; buf.getByte(bp + 8) == ByteCodes.aload_0 &amp;&amp;
 806                                         buf.getByte( bp + 9) == (byte) ByteCodes.invokespecial &amp;&amp;
 807                                                 buf.getByte( bp + 12) == (byte) ByteCodes.return_)) {
 808                                     sym.flags_field |= EMPTYNOARGCONSTR;
 809                             }
 810                         }
 811                     }
 812                     if (saveParameterNames)
 813                         ((MethodSymbol)sym).code = readCode(sym);
 814                     else
 815                         bp = bp + attrLen;
 816                 }
 817             },
 818 
 819             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 820                 protected void read(Symbol sym, int attrLen) {
 821                     Object v = poolReader.getConstant(nextChar());
 822                     // Ignore ConstantValue attribute if field not final.
 823                     if ((sym.flags() &amp; FINAL) == 0) {
 824                         return;
 825                     }
 826                     VarSymbol var = (VarSymbol) sym;
 827                     switch (var.type.getTag()) {
 828                        case BOOLEAN:
 829                        case BYTE:
 830                        case CHAR:
 831                        case SHORT:
 832                        case INT:
 833                            checkType(var, Integer.class, v);
 834                            break;
 835                        case LONG:
 836                            checkType(var, Long.class, v);
 837                            break;
 838                        case FLOAT:
 839                            checkType(var, Float.class, v);
 840                            break;
 841                        case DOUBLE:
 842                            checkType(var, Double.class, v);
 843                            break;
 844                        case CLASS:
 845                            if (var.type.tsym == syms.stringType.tsym) {
 846                                checkType(var, String.class, v);
 847                            } else {
 848                                throw badClassFile(&quot;bad.constant.value.type&quot;, var.type);
 849                            }
 850                            break;
 851                        default:
 852                            // ignore ConstantValue attribute if type is not primitive or String
 853                            return;
 854                     }
 855                     if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
 856                         throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
 857                     }
 858                     var.setData(v);
 859                 }
 860 
 861                 void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {
 862                     if (!clazz.isInstance(value)) {
 863                         throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
 864                     }
 865                 }
 866             },
 867 
 868             new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 869                 protected void read(Symbol sym, int attrLen) {
 870                     Symbol s = sym.owner.kind == MDL ? sym.owner : sym;
 871 
 872                     s.flags_field |= DEPRECATED;
 873                 }
 874             },
 875 
 876             new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 877                 protected void read(Symbol sym, int attrLen) {
 878                     int nexceptions = nextChar();
 879                     List&lt;Type&gt; thrown = List.nil();
 880                     for (int j = 0; j &lt; nexceptions; j++)
 881                         thrown = thrown.prepend(poolReader.getClass(nextChar()).type);
 882                     if (sym.type.getThrownTypes().isEmpty())
 883                         sym.type.asMethodType().thrown = thrown.reverse();
 884                 }
 885             },
 886 
 887             new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {
 888                 protected void read(Symbol sym, int attrLen) {
 889                     ClassSymbol c = (ClassSymbol) sym;
 890                     if (currentModule.module_info == c) {
 891                         //prevent entering the classes too soon:
 892                         skipInnerClasses();
 893                     } else {
 894                         readInnerClasses(c);
 895                     }
 896                 }
 897             },
 898 
 899             new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 900                 protected void read(Symbol sym, int attrLen) {
 901                     int newbp = bp + attrLen;
 902                     if (saveParameterNames &amp;&amp; !sawMethodParameters) {
 903                         // Pick up parameter names from the variable table.
 904                         // Parameter names are not explicitly identified as such,
 905                         // but all parameter name entries in the LocalVariableTable
 906                         // have a start_pc of 0.  Therefore, we record the name
 907                         // indices of all slots with a start_pc of zero in the
 908                         // parameterNameIndices array.
 909                         // Note that this implicitly honors the JVMS spec that
 910                         // there may be more than one LocalVariableTable, and that
 911                         // there is no specified ordering for the entries.
 912                         int numEntries = nextChar();
 913                         for (int i = 0; i &lt; numEntries; i++) {
 914                             int start_pc = nextChar();
 915                             int length = nextChar();
 916                             int nameIndex = nextChar();
 917                             int sigIndex = nextChar();
 918                             int register = nextChar();
 919                             if (start_pc == 0) {
 920                                 // ensure array large enough
 921                                 if (register &gt;= parameterNameIndices.length) {
 922                                     int newSize =
 923                                             Math.max(register + 1, parameterNameIndices.length + 8);
 924                                     parameterNameIndices =
 925                                             Arrays.copyOf(parameterNameIndices, newSize);
 926                                 }
 927                                 parameterNameIndices[register] = nameIndex;
 928                                 haveParameterNameIndices = true;
 929                             }
 930                         }
 931                     }
 932                     bp = newbp;
 933                 }
 934             },
 935 
 936             new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
 937                 protected void read(Symbol sym, int attrLen) {
 938                     ClassSymbol c = (ClassSymbol) sym;
 939                     Name n = poolReader.getName(nextChar());
 940                     c.sourcefile = new SourceFileObject(n);
 941                     // If the class is a toplevel class, originating from a Java source file,
 942                     // but the class name does not match the file name, then it is
 943                     // an auxiliary class.
 944                     String sn = n.toString();
 945                     if (c.owner.kind == PCK &amp;&amp;
 946                         sn.endsWith(&quot;.java&quot;) &amp;&amp;
 947                         !sn.equals(c.name.toString()+&quot;.java&quot;)) {
 948                         c.flags_field |= AUXILIARY;
 949                     }
 950                 }
 951             },
 952 
 953             new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 954                 protected void read(Symbol sym, int attrLen) {
 955                     sym.flags_field |= SYNTHETIC;
 956                 }
 957             },
 958 
 959             // standard v49 attributes
 960 
 961             new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {
 962                 protected void read(Symbol sym, int attrLen) {
 963                     int newbp = bp + attrLen;
 964                     readEnclosingMethodAttr(sym);
 965                     bp = newbp;
 966                 }
 967             },
 968 
 969             new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 970                 protected void read(Symbol sym, int attrLen) {
 971                     if (sym.kind == TYP) {
 972                         ClassSymbol c = (ClassSymbol) sym;
 973                         readingClassAttr = true;
 974                         try {
 975                             ClassType ct1 = (ClassType)c.type;
 976                             Assert.check(c == currentOwner);
 977                             ct1.typarams_field = poolReader.getName(nextChar())
 978                                     .map(ClassReader.this::sigToTypeParams);
 979                             ct1.supertype_field = sigToType();
 980                             ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
 981                             while (sigp != siglimit) is.append(sigToType());
 982                             ct1.interfaces_field = is.toList();
 983                         } finally {
 984                             readingClassAttr = false;
 985                         }
 986                     } else {
 987                         List&lt;Type&gt; thrown = sym.type.getThrownTypes();
 988                         sym.type = poolReader.getType(nextChar());
 989                         //- System.err.println(&quot; # &quot; + sym.type);
 990                         if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
 991                             sym.type.asMethodType().thrown = thrown;
 992 
 993                     }
 994                 }
 995             },
 996 
 997             // v49 annotation attributes
 998 
 999             new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1000                 protected void read(Symbol sym, int attrLen) {
1001                     attachAnnotationDefault(sym);
1002                 }
1003             },
1004 
1005             new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1006                 protected void read(Symbol sym, int attrLen) {
1007                     attachAnnotations(sym);
1008                 }
1009             },
1010 
1011             new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1012                 protected void read(Symbol sym, int attrLen) {
1013                     readParameterAnnotations(sym);
1014                 }
1015             },
1016 
1017             new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1018                 protected void read(Symbol sym, int attrLen) {
1019                     attachAnnotations(sym);
1020                 }
1021             },
1022 
1023             new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1024                 protected void read(Symbol sym, int attrLen) {
1025                     readParameterAnnotations(sym);
1026                 }
1027             },
1028 
1029             // additional &quot;legacy&quot; v49 attributes, superseded by flags
1030 
1031             new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1032                 protected void read(Symbol sym, int attrLen) {
1033                     sym.flags_field |= ANNOTATION;
1034                 }
1035             },
1036 
1037             new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {
1038                 protected void read(Symbol sym, int attrLen) {
1039                     sym.flags_field |= BRIDGE;
1040                 }
1041             },
1042 
1043             new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1044                 protected void read(Symbol sym, int attrLen) {
1045                     sym.flags_field |= ENUM;
1046                 }
1047             },
1048 
1049             new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1050                 protected void read(Symbol sym, int attrLen) {
1051                     sym.flags_field |= VARARGS;
1052                 }
1053             },
1054 
1055             new AttributeReader(names.RuntimeVisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1056                 protected void read(Symbol sym, int attrLen) {
1057                     attachTypeAnnotations(sym);
1058                 }
1059             },
1060 
1061             new AttributeReader(names.RuntimeInvisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1062                 protected void read(Symbol sym, int attrLen) {
1063                     attachTypeAnnotations(sym);
1064                 }
1065             },
1066 
1067             // The following attributes for a Code attribute are not currently handled
1068             // StackMapTable
1069             // SourceDebugExtension
1070             // LineNumberTable
1071             // LocalVariableTypeTable
1072 
1073             // standard v52 attributes
1074 
1075             new AttributeReader(names.MethodParameters, V52, MEMBER_ATTRIBUTE) {
1076                 protected void read(Symbol sym, int attrlen) {
1077                     int newbp = bp + attrlen;
1078                     if (saveParameterNames) {
1079                         sawMethodParameters = true;
1080                         int numEntries = nextByte();
1081                         parameterNameIndices = new int[numEntries];
1082                         haveParameterNameIndices = true;
1083                         int index = 0;
1084                         for (int i = 0; i &lt; numEntries; i++) {
1085                             int nameIndex = nextChar();
1086                             int flags = nextChar();
1087                             if ((flags &amp; (Flags.MANDATED | Flags.SYNTHETIC)) != 0) {
1088                                 continue;
1089                             }
1090                             parameterNameIndices[index++] = nameIndex;
1091                         }
1092                     }
1093                     bp = newbp;
1094                 }
1095             },
1096 
1097             // standard v53 attributes
1098 
1099             new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {
1100                 @Override
1101                 protected boolean accepts(AttributeKind kind) {
1102                     return super.accepts(kind) &amp;&amp; allowModules;
1103                 }
1104                 protected void read(Symbol sym, int attrLen) {
1105                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1106                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1107                         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
1108 
1109                         Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);
1110                         if (currentModule.name != moduleName) {
1111                             throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
1112                         }
1113 
1114                         Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
1115                         msym.flags.addAll(moduleFlags);
1116                         msym.version = optPoolEntry(nextChar(), poolReader::getName, null);
1117 
1118                         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
1119                         int nrequires = nextChar();
1120                         for (int i = 0; i &lt; nrequires; i++) {
1121                             ModuleSymbol rsym = poolReader.getModule(nextChar());
1122                             Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
1123                             if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
1124                                 if (flags.contains(RequiresFlag.TRANSITIVE)) {
1125                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
1126                                 }
1127                                 if (flags.contains(RequiresFlag.STATIC_PHASE)) {
1128                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
1129                                 }
1130                             }
1131                             nextChar(); // skip compiled version
1132                             requires.add(new RequiresDirective(rsym, flags));
1133                         }
1134                         msym.requires = requires.toList();
1135                         directives.addAll(msym.requires);
1136 
1137                         ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
1138                         int nexports = nextChar();
1139                         for (int i = 0; i &lt; nexports; i++) {
1140                             PackageSymbol p = poolReader.getPackage(nextChar());
1141                             Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
1142                             int nto = nextChar();
1143                             List&lt;ModuleSymbol&gt; to;
1144                             if (nto == 0) {
1145                                 to = null;
1146                             } else {
1147                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1148                                 for (int t = 0; t &lt; nto; t++)
1149                                     lb.append(poolReader.getModule(nextChar()));
1150                                 to = lb.toList();
1151                             }
1152                             exports.add(new ExportsDirective(p, to, flags));
1153                         }
1154                         msym.exports = exports.toList();
1155                         directives.addAll(msym.exports);
1156                         ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
1157                         int nopens = nextChar();
1158                         if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
1159                             throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
1160                         }
1161                         for (int i = 0; i &lt; nopens; i++) {
1162                             PackageSymbol p = poolReader.getPackage(nextChar());
1163                             Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
1164                             int nto = nextChar();
1165                             List&lt;ModuleSymbol&gt; to;
1166                             if (nto == 0) {
1167                                 to = null;
1168                             } else {
1169                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1170                                 for (int t = 0; t &lt; nto; t++)
1171                                     lb.append(poolReader.getModule(nextChar()));
1172                                 to = lb.toList();
1173                             }
1174                             opens.add(new OpensDirective(p, to, flags));
1175                         }
1176                         msym.opens = opens.toList();
1177                         directives.addAll(msym.opens);
1178 
1179                         msym.directives = directives.toList();
1180 
1181                         ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
1182                         int nuses = nextChar();
1183                         for (int i = 0; i &lt; nuses; i++) {
1184                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1185                             uses.add(new InterimUsesDirective(srvc));
1186                         }
1187                         interimUses = uses.toList();
1188 
1189                         ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
1190                         int nprovides = nextChar();
1191                         for (int p = 0; p &lt; nprovides; p++) {
1192                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1193                             int nimpls = nextChar();
1194                             ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
1195                             for (int i = 0; i &lt; nimpls; i++) {
1196                                 impls.append(poolReader.peekClassName(nextChar(), this::classNameMapper));
1197                             provides.add(new InterimProvidesDirective(srvc, impls.toList()));
1198                             }
1199                         }
1200                         interimProvides = provides.toList();
1201                     }
1202                 }
1203 
1204                 private Name classNameMapper(byte[] arr, int offset, int length) {
1205                     return names.fromUtf(ClassFile.internalize(arr, offset, length));
1206                 }
1207             },
1208 
1209             new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
1210                 @Override
1211                 protected boolean accepts(AttributeKind kind) {
1212                     return super.accepts(kind) &amp;&amp; allowModules;
1213                 }
1214                 protected void read(Symbol sym, int attrLen) {
1215                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1216                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1217                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1218                     }
1219                 }
1220             },
1221 
1222             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1223                 @Override
1224                 protected boolean accepts(AttributeKind kind) {
1225                     return super.accepts(kind) &amp;&amp; allowRecords;
1226                 }
1227                 protected void read(Symbol sym, int attrLen) {
1228                     if (sym.kind == TYP) {
1229                         sym.flags_field |= RECORD;
1230                     }
1231                     bp = bp + attrLen;
1232                 }
1233             },
1234             new AttributeReader(names.PermittedSubclasses, V59, CLASS_ATTRIBUTE) {
1235                 @Override
1236                 protected boolean accepts(AttributeKind kind) {
1237                     return super.accepts(kind) &amp;&amp; allowSealedTypes;
1238                 }
1239                 protected void read(Symbol sym, int attrLen) {
1240                     if (sym.kind == TYP) {
1241                         ListBuffer&lt;Symbol&gt; subtypes = new ListBuffer&lt;&gt;();
1242                         int numberOfPermittedSubtypes = nextChar();
1243                         for (int i = 0; i &lt; numberOfPermittedSubtypes; i++) {
1244                             subtypes.add(poolReader.getClass(nextChar()));
1245                         }
1246                         ((ClassSymbol)sym).permitted = subtypes.toList();
1247                     }
1248                 }
1249             },
1250         };
1251 
1252         for (AttributeReader r: readers)
1253             attributeReaders.put(r.name, r);
1254     }
1255 
1256     protected void readEnclosingMethodAttr(Symbol sym) {
1257         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1258         // remove sym from it&#39;s current owners scope and place it in
1259         // the scope specified by the attribute
1260         sym.owner.members().remove(sym);
1261         ClassSymbol self = (ClassSymbol)sym;
1262         ClassSymbol c = poolReader.getClass(nextChar());
1263         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1264 
1265         if (c.members_field == null || c.kind != TYP)
1266             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1267 
1268         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1269         if (nt != null &amp;&amp; m == null)
1270             throw badEnclosingMethod(self);
1271 
1272         self.name = simpleBinaryName(self.flatname, c.flatname) ;
1273         self.owner = m != null ? m : c;
1274         if (self.name.isEmpty())
1275             self.fullname = names.empty;
1276         else
1277             self.fullname = ClassSymbol.formFullName(self.name, self.owner);
1278 
1279         if (m != null) {
1280             ((ClassType)sym.type).setEnclosingType(m.type);
1281         } else if ((self.flags_field &amp; STATIC) == 0) {
1282             ((ClassType)sym.type).setEnclosingType(c.type);
1283         } else {
1284             ((ClassType)sym.type).setEnclosingType(Type.noType);
1285         }
1286         enterTypevars(self, self.type);
1287         if (!missingTypeVariables.isEmpty()) {
1288             ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();
1289             for (Type typevar : missingTypeVariables) {
1290                 typeVars.append(findTypeVar(typevar.tsym.name));
1291             }
1292             foundTypeVariables = typeVars.toList();
1293         } else {
1294             foundTypeVariables = List.nil();
1295         }
1296     }
1297 
1298     // See java.lang.Class
1299     private Name simpleBinaryName(Name self, Name enclosing) {
1300         if (!self.startsWith(enclosing)) {
1301             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1302         }
1303 
1304         String simpleBinaryName = self.toString().substring(enclosing.toString().length());
1305         if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
1306             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1307         int index = 1;
1308         while (index &lt; simpleBinaryName.length() &amp;&amp;
1309                isAsciiDigit(simpleBinaryName.charAt(index)))
1310             index++;
1311         return names.fromString(simpleBinaryName.substring(index));
1312     }
1313 
1314     private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
1315         if (nt == null)
1316             return null;
1317 
1318         MethodType type = nt.type.asMethodType();
1319 
1320         for (Symbol sym : scope.getSymbolsByName(nt.name)) {
1321             if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
1322                 return (MethodSymbol)sym;
1323         }
1324 
1325         if (nt.name != names.init)
1326             // not a constructor
1327             return null;
1328         if ((flags &amp; INTERFACE) != 0)
1329             // no enclosing instance
1330             return null;
1331         if (nt.type.getParameterTypes().isEmpty())
1332             // no parameters
1333             return null;
1334 
1335         // A constructor of an inner class.
1336         // Remove the first argument (the enclosing instance)
1337         nt = new NameAndType(nt.name, new MethodType(nt.type.getParameterTypes().tail,
1338                                  nt.type.getReturnType(),
1339                                  nt.type.getThrownTypes(),
1340                                  syms.methodClass));
1341         // Try searching again
1342         return findMethod(nt, scope, flags);
1343     }
1344 
1345     /** Similar to Types.isSameType but avoids completion */
1346     private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {
1347         List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())
1348             .prepend(types.erasure(mt1.getReturnType()));
1349         List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());
1350         while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {
1351             if (types1.head.tsym != types2.head.tsym)
1352                 return false;
1353             types1 = types1.tail;
1354             types2 = types2.tail;
1355         }
1356         return types1.isEmpty() &amp;&amp; types2.isEmpty();
1357     }
1358 
1359     /**
1360      * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
1361      * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
1362      */
1363     private static boolean isAsciiDigit(char c) {
1364         return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
1365     }
1366 
1367     /** Read member attributes.
1368      */
1369     void readMemberAttrs(Symbol sym) {
1370         readAttrs(sym, AttributeKind.MEMBER);
1371     }
1372 
1373     void readAttrs(Symbol sym, AttributeKind kind) {
1374         char ac = nextChar();
1375         for (int i = 0; i &lt; ac; i++) {
1376             Name attrName = poolReader.getName(nextChar());
1377             int attrLen = nextInt();
1378             AttributeReader r = attributeReaders.get(attrName);
1379             if (r != null &amp;&amp; r.accepts(kind))
1380                 r.read(sym, attrLen);
1381             else  {
1382                 bp = bp + attrLen;
1383             }
1384         }
1385     }
1386 
1387     private boolean readingClassAttr = false;
1388     private List&lt;Type&gt; missingTypeVariables = List.nil();
1389     private List&lt;Type&gt; foundTypeVariables = List.nil();
1390 
1391     /** Read class attributes.
1392      */
1393     void readClassAttrs(ClassSymbol c) {
1394         readAttrs(c, AttributeKind.CLASS);
1395     }
1396 
1397     /** Read code block.
1398      */
1399     Code readCode(Symbol owner) {
1400         nextChar(); // max_stack
1401         nextChar(); // max_locals
1402         final int  code_length = nextInt();
1403         bp += code_length;
1404         final char exception_table_length = nextChar();
1405         bp += exception_table_length * 8;
1406         readMemberAttrs(owner);
1407         return null;
1408     }
1409 
1410 /************************************************************************
1411  * Reading Java-language annotations
1412  ***********************************************************************/
1413 
1414     /**
1415      * Save annotations.
1416      */
1417     List&lt;CompoundAnnotationProxy&gt; readAnnotations() {
1418         int numAttributes = nextChar();
1419         ListBuffer&lt;CompoundAnnotationProxy&gt; annotations = new ListBuffer&lt;&gt;();
1420         for (int i = 0; i &lt; numAttributes; i++) {
1421             annotations.append(readCompoundAnnotation());
1422         }
1423         return annotations.toList();
1424     }
1425 
1426     /** Attach annotations.
1427      */
1428     void attachAnnotations(final Symbol sym) {
1429         attachAnnotations(sym, readAnnotations());
1430     }
1431 
1432     /**
1433      * Attach annotations.
1434      */
1435     void attachAnnotations(final Symbol sym, List&lt;CompoundAnnotationProxy&gt; annotations) {
1436         if (annotations.isEmpty()) {
1437             return;
1438         }
1439         ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1440         for (CompoundAnnotationProxy proxy : annotations) {
1441             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1442                 sym.flags_field |= PROPRIETARY;
1443             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1444                 if (profile != Profile.DEFAULT) {
1445                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1446                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1447                             Attribute.Constant c = (Attribute.Constant)v.snd;
1448                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1449                                 sym.flags_field |= NOT_IN_PROFILE;
1450                             }
1451                         }
1452                     }
1453                 }
1454             } else {
1455                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1456                     target = proxy;
1457                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1458                     repeatable = proxy;
1459                 } else if (allowValueBasedClasses &amp;&amp; sym.kind == TYP &amp;&amp; proxy.type.tsym == syms.valueBasedType.tsym) {
1460                     sym.flags_field |= VALUEBASED;
1461                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1462                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1463                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1464                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1465                     sym.flags_field |= PREVIEW_API;
1466                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1467                 }
1468                 proxies.append(proxy);
1469             }
1470         }
1471         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1472     }
1473     //where:
1474         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1475             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1476                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1477                     Attribute.Constant c = (Attribute.Constant)v.snd;
1478                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1479                         sym.flags_field |= flag;
1480                     }
1481                 }
1482             }
1483         }
1484 
1485     /** Read parameter annotations.
1486      */
1487     void readParameterAnnotations(Symbol meth) {
1488         int numParameters = buf.getByte(bp++) &amp; 0xFF;
1489         if (parameterAnnotations == null) {
1490             parameterAnnotations = new ParameterAnnotations[numParameters];
1491         } else if (parameterAnnotations.length != numParameters) {
1492             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
1493         }
1494         for (int pnum = 0; pnum &lt; numParameters; pnum++) {
1495             if (parameterAnnotations[pnum] == null) {
1496                 parameterAnnotations[pnum] = new ParameterAnnotations();
1497             }
1498             parameterAnnotations[pnum].add(readAnnotations());
1499         }
1500     }
1501 
1502     void attachTypeAnnotations(final Symbol sym) {
1503         int numAttributes = nextChar();
1504         if (numAttributes != 0) {
1505             ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1506             for (int i = 0; i &lt; numAttributes; i++)
1507                 proxies.append(readTypeAnnotation());
1508             annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));
1509         }
1510     }
1511 
1512     /** Attach the default value for an annotation element.
1513      */
1514     void attachAnnotationDefault(final Symbol sym) {
1515         final MethodSymbol meth = (MethodSymbol)sym; // only on methods
1516         final Attribute value = readAttributeValue();
1517 
1518         // The default value is set later during annotation. It might
1519         // be the case that the Symbol sym is annotated _after_ the
1520         // repeating instances that depend on this default value,
1521         // because of this we set an interim value that tells us this
1522         // element (most likely) has a default.
1523         //
1524         // Set interim value for now, reset just before we do this
1525         // properly at annotate time.
1526         meth.defaultValue = value;
1527         annotate.normal(new AnnotationDefaultCompleter(meth, value));
1528     }
1529 
1530     Type readTypeOrClassSymbol(int i) {
1531         // support preliminary jsr175-format class files
1532         if (poolReader.hasTag(i, CONSTANT_Class))
1533             return poolReader.getClass(i).type;
1534         return readTypeToProxy(i);
1535     }
1536     Type readTypeToProxy(int i) {
1537         if (currentModule.module_info == currentOwner) {
1538             return new ProxyType(i);
1539         } else {
1540             return poolReader.getType(i);
1541         }
1542     }
1543 
1544     CompoundAnnotationProxy readCompoundAnnotation() {
1545         Type t;
1546         if (currentModule.module_info == currentOwner) {
1547             int cpIndex = nextChar();
1548             t = new ProxyType(cpIndex);
1549         } else {
1550             t = readTypeOrClassSymbol(nextChar());
1551         }
1552         int numFields = nextChar();
1553         ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
1554         for (int i=0; i&lt;numFields; i++) {
1555             Name name = poolReader.getName(nextChar());
1556             Attribute value = readAttributeValue();
1557             pairs.append(new Pair&lt;&gt;(name, value));
1558         }
1559         return new CompoundAnnotationProxy(t, pairs.toList());
1560     }
1561 
1562     TypeAnnotationProxy readTypeAnnotation() {
1563         TypeAnnotationPosition position = readPosition();
1564         CompoundAnnotationProxy proxy = readCompoundAnnotation();
1565 
1566         return new TypeAnnotationProxy(proxy, position);
1567     }
1568 
1569     TypeAnnotationPosition readPosition() {
1570         int tag = nextByte(); // TargetType tag is a byte
1571 
1572         if (!TargetType.isValidTargetTypeValue(tag))
1573             throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
1574 
1575         TargetType type = TargetType.fromTargetTypeValue(tag);
1576 
1577         switch (type) {
1578         // instanceof
1579         case INSTANCEOF: {
1580             final int offset = nextChar();
1581             final TypeAnnotationPosition position =
1582                 TypeAnnotationPosition.instanceOf(readTypePath());
1583             position.offset = offset;
1584             return position;
1585         }
1586         // new expression
1587         case NEW: {
1588             final int offset = nextChar();
1589             final TypeAnnotationPosition position =
1590                 TypeAnnotationPosition.newObj(readTypePath());
1591             position.offset = offset;
1592             return position;
1593         }
1594         // constructor/method reference receiver
1595         case CONSTRUCTOR_REFERENCE: {
1596             final int offset = nextChar();
1597             final TypeAnnotationPosition position =
1598                 TypeAnnotationPosition.constructorRef(readTypePath());
1599             position.offset = offset;
1600             return position;
1601         }
1602         case METHOD_REFERENCE: {
1603             final int offset = nextChar();
1604             final TypeAnnotationPosition position =
1605                 TypeAnnotationPosition.methodRef(readTypePath());
1606             position.offset = offset;
1607             return position;
1608         }
1609         // local variable
1610         case LOCAL_VARIABLE: {
1611             final int table_length = nextChar();
1612             final int[] newLvarOffset = new int[table_length];
1613             final int[] newLvarLength = new int[table_length];
1614             final int[] newLvarIndex = new int[table_length];
1615 
1616             for (int i = 0; i &lt; table_length; ++i) {
1617                 newLvarOffset[i] = nextChar();
1618                 newLvarLength[i] = nextChar();
1619                 newLvarIndex[i] = nextChar();
1620             }
1621 
1622             final TypeAnnotationPosition position =
1623                     TypeAnnotationPosition.localVariable(readTypePath());
1624             position.lvarOffset = newLvarOffset;
1625             position.lvarLength = newLvarLength;
1626             position.lvarIndex = newLvarIndex;
1627             return position;
1628         }
1629         // resource variable
1630         case RESOURCE_VARIABLE: {
1631             final int table_length = nextChar();
1632             final int[] newLvarOffset = new int[table_length];
1633             final int[] newLvarLength = new int[table_length];
1634             final int[] newLvarIndex = new int[table_length];
1635 
1636             for (int i = 0; i &lt; table_length; ++i) {
1637                 newLvarOffset[i] = nextChar();
1638                 newLvarLength[i] = nextChar();
1639                 newLvarIndex[i] = nextChar();
1640             }
1641 
1642             final TypeAnnotationPosition position =
1643                     TypeAnnotationPosition.resourceVariable(readTypePath());
1644             position.lvarOffset = newLvarOffset;
1645             position.lvarLength = newLvarLength;
1646             position.lvarIndex = newLvarIndex;
1647             return position;
1648         }
1649         // exception parameter
1650         case EXCEPTION_PARAMETER: {
1651             final int exception_index = nextChar();
1652             final TypeAnnotationPosition position =
1653                 TypeAnnotationPosition.exceptionParameter(readTypePath());
1654             position.setExceptionIndex(exception_index);
1655             return position;
1656         }
1657         // method receiver
1658         case METHOD_RECEIVER:
1659             return TypeAnnotationPosition.methodReceiver(readTypePath());
1660         // type parameter
1661         case CLASS_TYPE_PARAMETER: {
1662             final int parameter_index = nextByte();
1663             return TypeAnnotationPosition
1664                 .typeParameter(readTypePath(), parameter_index);
1665         }
1666         case METHOD_TYPE_PARAMETER: {
1667             final int parameter_index = nextByte();
1668             return TypeAnnotationPosition
1669                 .methodTypeParameter(readTypePath(), parameter_index);
1670         }
1671         // type parameter bound
1672         case CLASS_TYPE_PARAMETER_BOUND: {
1673             final int parameter_index = nextByte();
1674             final int bound_index = nextByte();
1675             return TypeAnnotationPosition
1676                 .typeParameterBound(readTypePath(), parameter_index,
1677                                     bound_index);
1678         }
1679         case METHOD_TYPE_PARAMETER_BOUND: {
1680             final int parameter_index = nextByte();
1681             final int bound_index = nextByte();
1682             return TypeAnnotationPosition
1683                 .methodTypeParameterBound(readTypePath(), parameter_index,
1684                                           bound_index);
1685         }
1686         // class extends or implements clause
1687         case CLASS_EXTENDS: {
1688             final int type_index = nextChar();
1689             return TypeAnnotationPosition.classExtends(readTypePath(),
1690                                                        type_index);
1691         }
1692         // throws
1693         case THROWS: {
1694             final int type_index = nextChar();
1695             return TypeAnnotationPosition.methodThrows(readTypePath(),
1696                                                        type_index);
1697         }
1698         // method parameter
1699         case METHOD_FORMAL_PARAMETER: {
1700             final int parameter_index = nextByte();
1701             return TypeAnnotationPosition.methodParameter(readTypePath(),
1702                                                           parameter_index);
1703         }
1704         // type cast
1705         case CAST: {
1706             final int offset = nextChar();
1707             final int type_index = nextByte();
1708             final TypeAnnotationPosition position =
1709                 TypeAnnotationPosition.typeCast(readTypePath(), type_index);
1710             position.offset = offset;
1711             return position;
1712         }
1713         // method/constructor/reference type argument
1714         case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: {
1715             final int offset = nextChar();
1716             final int type_index = nextByte();
1717             final TypeAnnotationPosition position = TypeAnnotationPosition
1718                 .constructorInvocationTypeArg(readTypePath(), type_index);
1719             position.offset = offset;
1720             return position;
1721         }
1722         case METHOD_INVOCATION_TYPE_ARGUMENT: {
1723             final int offset = nextChar();
1724             final int type_index = nextByte();
1725             final TypeAnnotationPosition position = TypeAnnotationPosition
1726                 .methodInvocationTypeArg(readTypePath(), type_index);
1727             position.offset = offset;
1728             return position;
1729         }
1730         case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: {
1731             final int offset = nextChar();
1732             final int type_index = nextByte();
1733             final TypeAnnotationPosition position = TypeAnnotationPosition
1734                 .constructorRefTypeArg(readTypePath(), type_index);
1735             position.offset = offset;
1736             return position;
1737         }
1738         case METHOD_REFERENCE_TYPE_ARGUMENT: {
1739             final int offset = nextChar();
1740             final int type_index = nextByte();
1741             final TypeAnnotationPosition position = TypeAnnotationPosition
1742                 .methodRefTypeArg(readTypePath(), type_index);
1743             position.offset = offset;
1744             return position;
1745         }
1746         // We don&#39;t need to worry about these
1747         case METHOD_RETURN:
1748             return TypeAnnotationPosition.methodReturn(readTypePath());
1749         case FIELD:
1750             return TypeAnnotationPosition.field(readTypePath());
1751         case UNKNOWN:
1752             throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
1753         default:
1754             throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);
1755         }
1756     }
1757 
1758     List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
1759         int len = nextByte();
1760         ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();
1761         for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)
1762             loc = loc.append(nextByte());
1763 
1764         return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
1765 
1766     }
1767 
1768     /**
1769      * Helper function to read an optional pool entry (with given function); this is used while parsing
1770      * InnerClasses and EnclosingMethod attributes, as well as when parsing supertype descriptor,
1771      * as per JVMS.
1772      */
1773     &lt;Z&gt; Z optPoolEntry(int index, IntFunction&lt;Z&gt; poolFunc, Z defaultValue) {
1774         return (index == 0) ?
1775                 defaultValue :
1776                 poolFunc.apply(index);
1777     }
1778 
1779     Attribute readAttributeValue() {
1780         char c = (char) buf.getByte(bp++);
1781         switch (c) {
1782         case &#39;B&#39;:
1783             return new Attribute.Constant(syms.byteType, poolReader.getConstant(nextChar()));
1784         case &#39;C&#39;:
1785             return new Attribute.Constant(syms.charType, poolReader.getConstant(nextChar()));
1786         case &#39;D&#39;:
1787             return new Attribute.Constant(syms.doubleType, poolReader.getConstant(nextChar()));
1788         case &#39;F&#39;:
1789             return new Attribute.Constant(syms.floatType, poolReader.getConstant(nextChar()));
1790         case &#39;I&#39;:
1791             return new Attribute.Constant(syms.intType, poolReader.getConstant(nextChar()));
1792         case &#39;J&#39;:
1793             return new Attribute.Constant(syms.longType, poolReader.getConstant(nextChar()));
1794         case &#39;S&#39;:
1795             return new Attribute.Constant(syms.shortType, poolReader.getConstant(nextChar()));
1796         case &#39;Z&#39;:
1797             return new Attribute.Constant(syms.booleanType, poolReader.getConstant(nextChar()));
1798         case &#39;s&#39;:
1799             return new Attribute.Constant(syms.stringType, poolReader.getName(nextChar()).toString());
1800         case &#39;e&#39;:
1801             return new EnumAttributeProxy(readTypeToProxy(nextChar()), poolReader.getName(nextChar()));
1802         case &#39;c&#39;:
1803             return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
1804         case &#39;[&#39;: {
1805             int n = nextChar();
1806             ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
1807             for (int i=0; i&lt;n; i++)
1808                 l.append(readAttributeValue());
1809             return new ArrayAttributeProxy(l.toList());
1810         }
1811         case &#39;@&#39;:
1812             return readCompoundAnnotation();
1813         default:
1814             throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);
1815         }
1816     }
1817 
1818     interface ProxyVisitor extends Attribute.Visitor {
1819         void visitEnumAttributeProxy(EnumAttributeProxy proxy);
1820         void visitClassAttributeProxy(ClassAttributeProxy proxy);
1821         void visitArrayAttributeProxy(ArrayAttributeProxy proxy);
1822         void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy);
1823     }
1824 
1825     static class EnumAttributeProxy extends Attribute {
1826         Type enumType;
1827         Name enumerator;
1828         public EnumAttributeProxy(Type enumType, Name enumerator) {
1829             super(null);
1830             this.enumType = enumType;
1831             this.enumerator = enumerator;
1832         }
1833         public void accept(Visitor v) { ((ProxyVisitor)v).visitEnumAttributeProxy(this); }
1834         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1835         public String toString() {
1836             return &quot;/*proxy enum*/&quot; + enumType + &quot;.&quot; + enumerator;
1837         }
1838     }
1839 
1840     static class ClassAttributeProxy extends Attribute {
1841         Type classType;
1842         public ClassAttributeProxy(Type classType) {
1843             super(null);
1844             this.classType = classType;
1845         }
1846         public void accept(Visitor v) { ((ProxyVisitor)v).visitClassAttributeProxy(this); }
1847         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1848         public String toString() {
1849             return &quot;/*proxy class*/&quot; + classType + &quot;.class&quot;;
1850         }
1851     }
1852 
1853     static class ArrayAttributeProxy extends Attribute {
1854         List&lt;Attribute&gt; values;
1855         ArrayAttributeProxy(List&lt;Attribute&gt; values) {
1856             super(null);
1857             this.values = values;
1858         }
1859         public void accept(Visitor v) { ((ProxyVisitor)v).visitArrayAttributeProxy(this); }
1860         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1861         public String toString() {
1862             return &quot;{&quot; + values + &quot;}&quot;;
1863         }
1864     }
1865 
1866     /** A temporary proxy representing a compound attribute.
1867      */
1868     static class CompoundAnnotationProxy extends Attribute {
1869         final List&lt;Pair&lt;Name,Attribute&gt;&gt; values;
1870         public CompoundAnnotationProxy(Type type,
1871                                       List&lt;Pair&lt;Name,Attribute&gt;&gt; values) {
1872             super(type);
1873             this.values = values;
1874         }
1875         public void accept(Visitor v) { ((ProxyVisitor)v).visitCompoundAnnotationProxy(this); }
1876         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1877         public String toString() {
1878             StringBuilder buf = new StringBuilder();
1879             buf.append(&quot;@&quot;);
1880             buf.append(type.tsym.getQualifiedName());
1881             buf.append(&quot;/*proxy*/{&quot;);
1882             boolean first = true;
1883             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; v = values;
1884                  v.nonEmpty(); v = v.tail) {
1885                 Pair&lt;Name,Attribute&gt; value = v.head;
1886                 if (!first) buf.append(&quot;,&quot;);
1887                 first = false;
1888                 buf.append(value.fst);
1889                 buf.append(&quot;=&quot;);
1890                 buf.append(value.snd);
1891             }
1892             buf.append(&quot;}&quot;);
1893             return buf.toString();
1894         }
1895     }
1896 
1897     /** A temporary proxy representing a type annotation.
1898      */
1899     static class TypeAnnotationProxy {
1900         final CompoundAnnotationProxy compound;
1901         final TypeAnnotationPosition position;
1902         public TypeAnnotationProxy(CompoundAnnotationProxy compound,
1903                 TypeAnnotationPosition position) {
1904             this.compound = compound;
1905             this.position = position;
1906         }
1907     }
1908 
1909     class AnnotationDeproxy implements ProxyVisitor {
1910         private ClassSymbol requestingOwner;
1911 
1912         AnnotationDeproxy(ClassSymbol owner) {
1913             this.requestingOwner = owner;
1914         }
1915 
1916         List&lt;Attribute.Compound&gt; deproxyCompoundList(List&lt;CompoundAnnotationProxy&gt; pl) {
1917             // also must fill in types!!!!
1918             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
1919             for (List&lt;CompoundAnnotationProxy&gt; l = pl; l.nonEmpty(); l=l.tail) {
1920                 buf.append(deproxyCompound(l.head));
1921             }
1922             return buf.toList();
1923         }
1924 
1925         Attribute.Compound deproxyCompound(CompoundAnnotationProxy a) {
1926             Type annotationType = resolvePossibleProxyType(a.type);
1927             ListBuffer&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; buf = new ListBuffer&lt;&gt;();
1928             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; l = a.values;
1929                  l.nonEmpty();
1930                  l = l.tail) {
1931                 MethodSymbol meth = findAccessMethod(annotationType, l.head.fst);
1932                 buf.append(new Pair&lt;&gt;(meth, deproxy(meth.type.getReturnType(), l.head.snd)));
1933             }
1934             return new Attribute.Compound(annotationType, buf.toList());
1935         }
1936 
1937         MethodSymbol findAccessMethod(Type container, Name name) {
1938             CompletionFailure failure = null;
1939             try {
1940                 for (Symbol sym : container.tsym.members().getSymbolsByName(name)) {
1941                     if (sym.kind == MTH &amp;&amp; sym.type.getParameterTypes().length() == 0)
1942                         return (MethodSymbol) sym;
1943                 }
1944             } catch (CompletionFailure ex) {
1945                 failure = ex;
1946             }
1947             // The method wasn&#39;t found: emit a warning and recover
1948             JavaFileObject prevSource = log.useSource(requestingOwner.classfile);
1949             try {
1950                 if (lintClassfile) {
1951                     if (failure == null) {
1952                         log.warning(Warnings.AnnotationMethodNotFound(container, name));
1953                     } else {
1954                         log.warning(Warnings.AnnotationMethodNotFoundReason(container,
1955                                                                             name,
1956                                                                             failure.getDetailValue()));//diagnostic, if present
1957                     }
1958                 }
1959             } finally {
1960                 log.useSource(prevSource);
1961             }
1962             // Construct a new method type and symbol.  Use bottom
1963             // type (typeof null) as return type because this type is
1964             // a subtype of all reference types and can be converted
1965             // to primitive types by unboxing.
1966             MethodType mt = new MethodType(List.nil(),
1967                                            syms.botType,
1968                                            List.nil(),
1969                                            syms.methodClass);
1970             return new MethodSymbol(PUBLIC | ABSTRACT, name, mt, container.tsym);
1971         }
1972 
1973         Attribute result;
1974         Type type;
1975         Attribute deproxy(Type t, Attribute a) {
1976             Type oldType = type;
1977             try {
1978                 type = t;
1979                 a.accept(this);
1980                 return result;
1981             } finally {
1982                 type = oldType;
1983             }
1984         }
1985 
1986         // implement Attribute.Visitor below
1987 
1988         public void visitConstant(Attribute.Constant value) {
1989             // assert value.type == type;
1990             result = value;
1991         }
1992 
1993         public void visitClass(Attribute.Class clazz) {
1994             result = clazz;
1995         }
1996 
1997         public void visitEnum(Attribute.Enum e) {
1998             throw new AssertionError(); // shouldn&#39;t happen
1999         }
2000 
2001         public void visitCompound(Attribute.Compound compound) {
2002             throw new AssertionError(); // shouldn&#39;t happen
2003         }
2004 
2005         public void visitArray(Attribute.Array array) {
2006             throw new AssertionError(); // shouldn&#39;t happen
2007         }
2008 
2009         public void visitError(Attribute.Error e) {
2010             throw new AssertionError(); // shouldn&#39;t happen
2011         }
2012 
2013         public void visitEnumAttributeProxy(EnumAttributeProxy proxy) {
2014             // type.tsym.flatName() should == proxy.enumFlatName
2015             Type enumType = resolvePossibleProxyType(proxy.enumType);
2016             TypeSymbol enumTypeSym = enumType.tsym;
2017             VarSymbol enumerator = null;
2018             CompletionFailure failure = null;
2019             try {
2020                 for (Symbol sym : enumTypeSym.members().getSymbolsByName(proxy.enumerator)) {
2021                     if (sym.kind == VAR) {
2022                         enumerator = (VarSymbol)sym;
2023                         break;
2024                     }
2025                 }
2026             }
2027             catch (CompletionFailure ex) {
2028                 failure = ex;
2029             }
2030             if (enumerator == null) {
2031                 if (failure != null) {
2032                     log.warning(Warnings.UnknownEnumConstantReason(currentClassFile,
2033                                                                    enumTypeSym,
2034                                                                    proxy.enumerator,
2035                                                                    failure.getDiagnostic()));
2036                 } else {
2037                     log.warning(Warnings.UnknownEnumConstant(currentClassFile,
2038                                                              enumTypeSym,
2039                                                              proxy.enumerator));
2040                 }
2041                 result = new Attribute.Enum(enumTypeSym.type,
2042                         new VarSymbol(0, proxy.enumerator, syms.botType, enumTypeSym));
2043             } else {
2044                 result = new Attribute.Enum(enumTypeSym.type, enumerator);
2045             }
2046         }
2047 
2048         @Override
2049         public void visitClassAttributeProxy(ClassAttributeProxy proxy) {
2050             Type classType = resolvePossibleProxyType(proxy.classType);
2051             result = new Attribute.Class(types, classType);
2052         }
2053 
2054         public void visitArrayAttributeProxy(ArrayAttributeProxy proxy) {
2055             int length = proxy.values.length();
2056             Attribute[] ats = new Attribute[length];
2057             Type elemtype = types.elemtype(type);
2058             int i = 0;
2059             for (List&lt;Attribute&gt; p = proxy.values; p.nonEmpty(); p = p.tail) {
2060                 ats[i++] = deproxy(elemtype, p.head);
2061             }
2062             result = new Attribute.Array(type, ats);
2063         }
2064 
2065         public void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy) {
2066             result = deproxyCompound(proxy);
2067         }
2068 
2069         Type resolvePossibleProxyType(Type t) {
2070             if (t instanceof ProxyType) {
2071                 Assert.check(requestingOwner.owner.kind == MDL);
2072                 ModuleSymbol prevCurrentModule = currentModule;
2073                 currentModule = (ModuleSymbol) requestingOwner.owner;
2074                 try {
2075                     return ((ProxyType) t).resolve();
2076                 } finally {
2077                     currentModule = prevCurrentModule;
2078                 }
2079             } else {
2080                 return t;
2081             }
2082         }
2083     }
2084 
2085     class AnnotationDefaultCompleter extends AnnotationDeproxy implements Runnable {
2086         final MethodSymbol sym;
2087         final Attribute value;
2088         final JavaFileObject classFile = currentClassFile;
2089 
2090         AnnotationDefaultCompleter(MethodSymbol sym, Attribute value) {
2091             super(currentOwner.kind == MTH
2092                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2093             this.sym = sym;
2094             this.value = value;
2095         }
2096 
2097         @Override
2098         public void run() {
2099             JavaFileObject previousClassFile = currentClassFile;
2100             try {
2101                 // Reset the interim value set earlier in
2102                 // attachAnnotationDefault().
2103                 sym.defaultValue = null;
2104                 currentClassFile = classFile;
2105                 sym.defaultValue = deproxy(sym.type.getReturnType(), value);
2106             } finally {
2107                 currentClassFile = previousClassFile;
2108             }
2109         }
2110 
2111         @Override
2112         public String toString() {
2113             return &quot; ClassReader store default for &quot; + sym.owner + &quot;.&quot; + sym + &quot; is &quot; + value;
2114         }
2115     }
2116 
2117     class AnnotationCompleter extends AnnotationDeproxy implements Runnable {
2118         final Symbol sym;
2119         final List&lt;CompoundAnnotationProxy&gt; l;
2120         final JavaFileObject classFile;
2121 
2122         AnnotationCompleter(Symbol sym, List&lt;CompoundAnnotationProxy&gt; l) {
2123             super(currentOwner.kind == MTH
2124                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2125             if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
2126                 this.sym = sym.owner;
2127             } else {
2128                 this.sym = sym;
2129             }
2130             this.l = l;
2131             this.classFile = currentClassFile;
2132         }
2133 
2134         @Override
2135         public void run() {
2136             JavaFileObject previousClassFile = currentClassFile;
2137             try {
2138                 currentClassFile = classFile;
2139                 List&lt;Attribute.Compound&gt; newList = deproxyCompoundList(l);
2140                 for (Attribute.Compound attr : newList) {
2141                     if (attr.type.tsym == syms.deprecatedType.tsym) {
2142                         sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
2143                         Attribute forRemoval = attr.member(names.forRemoval);
2144                         if (forRemoval instanceof Attribute.Constant) {
2145                             Attribute.Constant c = (Attribute.Constant) forRemoval;
2146                             if (c.type == syms.booleanType &amp;&amp; ((Integer) c.value) != 0) {
2147                                 sym.flags_field |= DEPRECATED_REMOVAL;
2148                             }
2149                         }
2150                     }
2151                 }
2152                 if (sym.annotationsPendingCompletion()) {
2153                     sym.setDeclarationAttributes(newList);
2154                 } else {
2155                     sym.appendAttributes(newList);
2156                 }
2157             } finally {
2158                 currentClassFile = previousClassFile;
2159             }
2160         }
2161 
2162         @Override
2163         public String toString() {
2164             return &quot; ClassReader annotate &quot; + sym.owner + &quot;.&quot; + sym + &quot; with &quot; + l;
2165         }
2166     }
2167 
2168     class TypeAnnotationCompleter extends AnnotationCompleter {
2169 
2170         List&lt;TypeAnnotationProxy&gt; proxies;
2171 
2172         TypeAnnotationCompleter(Symbol sym,
2173                 List&lt;TypeAnnotationProxy&gt; proxies) {
2174             super(sym, List.nil());
2175             this.proxies = proxies;
2176         }
2177 
2178         List&lt;Attribute.TypeCompound&gt; deproxyTypeCompoundList(List&lt;TypeAnnotationProxy&gt; proxies) {
2179             ListBuffer&lt;Attribute.TypeCompound&gt; buf = new ListBuffer&lt;&gt;();
2180             for (TypeAnnotationProxy proxy: proxies) {
2181                 Attribute.Compound compound = deproxyCompound(proxy.compound);
2182                 Attribute.TypeCompound typeCompound = new Attribute.TypeCompound(compound, proxy.position);
2183                 buf.add(typeCompound);
2184             }
2185             return buf.toList();
2186         }
2187 
2188         @Override
2189         public void run() {
2190             JavaFileObject previousClassFile = currentClassFile;
2191             try {
2192                 currentClassFile = classFile;
2193                 List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
2194                 sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
2195             } finally {
2196                 currentClassFile = previousClassFile;
2197             }
2198         }
2199     }
2200 
2201 
2202 /************************************************************************
2203  * Reading Symbols
2204  ***********************************************************************/
2205 
2206     /** Read a field.
2207      */
2208     VarSymbol readField() {
2209         long flags = adjustFieldFlags(nextChar());
2210         Name name = poolReader.getName(nextChar());
2211         Type type = poolReader.getType(nextChar());
2212         VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
2213         readMemberAttrs(v);
2214         return v;
2215     }
2216 
2217     /** Read a method.
2218      */
2219     MethodSymbol readMethod() {
2220         long flags = adjustMethodFlags(nextChar());
2221         Name name = poolReader.getName(nextChar());
2222         Type type = poolReader.getType(nextChar());
2223         if (currentOwner.isInterface() &amp;&amp;
2224                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2225             if (majorVersion &gt; Version.V52.major ||
2226                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2227                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2228                     currentOwner.flags_field |= DEFAULT;
2229                     flags |= DEFAULT | ABSTRACT;
2230                 }
2231             } else {
2232                 //protect against ill-formed classfiles
2233                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2234                                    Integer.toString(majorVersion),
2235                                    Integer.toString(minorVersion));
2236             }
2237         }
2238         if (name == names.init &amp;&amp; ((flags &amp; STATIC) != 0)) {
2239             flags &amp;= ~STATIC;
2240             type = new MethodType(type.getParameterTypes(),
2241                     syms.voidType,
2242                     type.getThrownTypes(),
2243                     syms.methodClass);
2244         }
2245         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2246             // Sometimes anonymous classes don&#39;t have an outer
2247             // instance, however, there is no reliable way to tell so
2248             // we never strip this$n
2249             // ditto for local classes. Local classes that have an enclosing method set
2250             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2251             // enclosing method (i.e. from initializers) will pass that check.
2252             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2253             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2254                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2255                                       type.getReturnType(),
2256                                       type.getThrownTypes(),
2257                                       syms.methodClass);
2258         }
2259         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2260         if (types.isSignaturePolymorphic(m)) {
2261             m.flags_field |= SIGNATURE_POLYMORPHIC;
2262         }
2263         if (saveParameterNames)
2264             initParameterNames(m);
2265         Symbol prevOwner = currentOwner;
2266         currentOwner = m;
2267         try {
2268             readMemberAttrs(m);
2269         } finally {
2270             currentOwner = prevOwner;
2271         }
2272         setParameters(m, type);
2273 
2274         if ((flags &amp; VARARGS) != 0) {
2275             final Type last = type.getParameterTypes().last();
2276             if (last == null || !last.hasTag(ARRAY)) {
2277                 m.flags_field &amp;= ~VARARGS;
2278                 throw badClassFile(&quot;malformed.vararg.method&quot;, m);
2279             }
2280         }
2281 
2282         return m;
2283     }
2284 
2285     private List&lt;Type&gt; adjustMethodParams(long flags, List&lt;Type&gt; args) {
2286         if (args.isEmpty()) {
2287             return args;
2288         }
2289         boolean isVarargs = (flags &amp; VARARGS) != 0;
2290         if (isVarargs) {
2291             Type varargsElem = args.last();
2292             ListBuffer&lt;Type&gt; adjustedArgs = new ListBuffer&lt;&gt;();
2293             for (Type t : args) {
2294                 adjustedArgs.append(t != varargsElem ?
2295                     t :
2296                     ((ArrayType)t).makeVarargs());
2297             }
2298             args = adjustedArgs.toList();
2299         }
2300         return args.tail;
2301     }
2302 
2303     /**
2304      * Init the parameter names array.
2305      * Parameter names are currently inferred from the names in the
2306      * LocalVariableTable attributes of a Code attribute.
2307      * (Note: this means parameter names are currently not available for
2308      * methods without a Code attribute.)
2309      * This method initializes an array in which to store the name indexes
2310      * of parameter names found in LocalVariableTable attributes. It is
2311      * slightly supersized to allow for additional slots with a start_pc of 0.
2312      */
2313     void initParameterNames(MethodSymbol sym) {
2314         // make allowance for synthetic parameters.
2315         final int excessSlots = 4;
2316         int expectedParameterSlots =
2317                 Code.width(sym.type.getParameterTypes()) + excessSlots;
2318         if (parameterNameIndices == null
2319                 || parameterNameIndices.length &lt; expectedParameterSlots) {
2320             parameterNameIndices = new int[expectedParameterSlots];
2321         } else
2322             Arrays.fill(parameterNameIndices, 0);
2323         haveParameterNameIndices = false;
2324         sawMethodParameters = false;
2325     }
2326 
2327     /**
2328      * Set the parameters for a method symbol, including any names and
2329      * annotations that were read.
2330      *
2331      * &lt;p&gt;The type of the symbol may have changed while reading the
2332      * method attributes (see the Signature attribute). This may be
2333      * because of generic information or because anonymous synthetic
2334      * parameters were added.   The original type (as read from the
2335      * method descriptor) is used to help guess the existence of
2336      * anonymous synthetic parameters.
2337      */
2338     void setParameters(MethodSymbol sym, Type jvmType) {
2339         // If we get parameter names from MethodParameters, then we
2340         // don&#39;t need to skip.
2341         int firstParam = 0;
2342         if (!sawMethodParameters) {
2343             firstParam = ((sym.flags() &amp; STATIC) == 0) ? 1 : 0;
2344             // the code in readMethod may have skipped the first
2345             // parameter when setting up the MethodType. If so, we
2346             // make a corresponding allowance here for the position of
2347             // the first parameter.  Note that this assumes the
2348             // skipped parameter has a width of 1 -- i.e. it is not
2349             // a double width type (long or double.)
2350             if (sym.name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2351                 // Sometimes anonymous classes don&#39;t have an outer
2352                 // instance, however, there is no reliable way to tell so
2353                 // we never strip this$n
2354                 if (!currentOwner.name.isEmpty())
2355                     firstParam += 1;
2356             }
2357 
2358             if (sym.type != jvmType) {
2359                 // reading the method attributes has caused the
2360                 // symbol&#39;s type to be changed. (i.e. the Signature
2361                 // attribute.)  This may happen if there are hidden
2362                 // (synthetic) parameters in the descriptor, but not
2363                 // in the Signature.  The position of these hidden
2364                 // parameters is unspecified; for now, assume they are
2365                 // at the beginning, and so skip over them. The
2366                 // primary case for this is two hidden parameters
2367                 // passed into Enum constructors.
2368                 int skip = Code.width(jvmType.getParameterTypes())
2369                         - Code.width(sym.type.getParameterTypes());
2370                 firstParam += skip;
2371             }
2372         }
2373         Set&lt;Name&gt; paramNames = new HashSet&lt;&gt;();
2374         ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
2375         int nameIndex = firstParam;
2376         int annotationIndex = 0;
2377         for (Type t: sym.type.getParameterTypes()) {
2378             VarSymbol param = parameter(nameIndex, t, sym, paramNames);
2379             params.append(param);
2380             if (parameterAnnotations != null) {
2381                 ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
2382                 if (annotations != null &amp;&amp; annotations.proxies != null
2383                         &amp;&amp; !annotations.proxies.isEmpty()) {
2384                     annotate.normal(new AnnotationCompleter(param, annotations.proxies));
2385                 }
2386             }
2387             nameIndex += sawMethodParameters ? 1 : Code.width(t);
2388             annotationIndex++;
2389         }
2390         if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
2391             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
2392         }
2393         Assert.checkNull(sym.params);
2394         sym.params = params.toList();
2395         parameterAnnotations = null;
2396         parameterNameIndices = null;
2397     }
2398 
2399 
2400     // Returns the name for the parameter at position &#39;index&#39;, either using
2401     // names read from the MethodParameters, or by synthesizing a name that
2402     // is not on the &#39;exclude&#39; list.
2403     private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set&lt;Name&gt; exclude) {
2404         long flags = PARAMETER;
2405         Name argName;
2406         if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
2407                 &amp;&amp; parameterNameIndices[index] != 0) {
2408             argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);
2409             flags |= NAME_FILLED;
2410         } else {
2411             String prefix = &quot;arg&quot;;
2412             while (true) {
2413                 argName = names.fromString(prefix + exclude.size());
2414                 if (!exclude.contains(argName))
2415                     break;
2416                 prefix += &quot;$&quot;;
2417             }
2418         }
2419         exclude.add(argName);
2420         return new ParamSymbol(flags, argName, t, owner);
2421     }
2422 
2423     /**
2424      * skip n bytes
2425      */
2426     void skipBytes(int n) {
2427         bp = bp + n;
2428     }
2429 
2430     /** Skip a field or method
2431      */
2432     void skipMember() {
2433         bp = bp + 6;
2434         char ac = nextChar();
2435         for (int i = 0; i &lt; ac; i++) {
2436             bp = bp + 2;
2437             int attrLen = nextInt();
2438             bp = bp + attrLen;
2439         }
2440     }
2441 
2442     void skipInnerClasses() {
2443         int n = nextChar();
2444         for (int i = 0; i &lt; n; i++) {
2445             nextChar();
2446             nextChar();
2447             nextChar();
2448             nextChar();
2449         }
2450     }
2451 
2452     /** Enter type variables of this classtype and all enclosing ones in
2453      *  `typevars&#39;.
2454      */
2455     protected void enterTypevars(Symbol sym, Type t) {
2456         if (t.getEnclosingType() != null) {
2457             if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
2458                 enterTypevars(sym.owner, t.getEnclosingType());
2459             }
2460         } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
2461             enterTypevars(sym.owner, sym.owner.type);
2462         }
2463         for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
2464             typevars.enter(xs.head.tsym);
2465         }
2466     }
2467 
2468     protected ClassSymbol enterClass(Name name) {
<a name="3" id="anc3"></a>



2469         return syms.enterClass(currentModule, name);
2470     }
2471 
2472     protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
2473         return syms.enterClass(currentModule, name, owner);
2474     }
2475 
2476     /** Read contents of a given class symbol `c&#39;. Both external and internal
2477      *  versions of an inner class are read.
2478      */
2479     void readClass(ClassSymbol c) {
2480         ClassType ct = (ClassType)c.type;
2481 
2482         // allocate scope for members
2483         c.members_field = WriteableScope.create(c);
2484 
2485         // prepare type variable table
2486         typevars = typevars.dup(currentOwner);
2487         if (ct.getEnclosingType().hasTag(CLASS))
2488             enterTypevars(c.owner, ct.getEnclosingType());
2489 
2490         // read flags, or skip if this is an inner class
2491         long f = nextChar();
2492         long flags = adjustClassFlags(f);
2493         if ((flags &amp; MODULE) == 0) {
2494             if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
2495             // read own class name and check that it matches
2496             currentModule = c.packge().modle;
2497             ClassSymbol self = poolReader.getClass(nextChar());
2498             if (c != self) {
2499                 throw badClassFile(&quot;class.file.wrong.class&quot;,
2500                                    self.flatname);
2501             }
2502         } else {
2503             if (majorVersion &lt; Version.V53.major) {
2504                 throw badClassFile(&quot;anachronistic.module.info&quot;,
2505                         Integer.toString(majorVersion),
2506                         Integer.toString(minorVersion));
2507             }
2508             c.flags_field = flags;
2509             currentModule = (ModuleSymbol) c.owner;
2510             int this_class = nextChar();
2511             // temp, no check on this_class
2512         }
2513 
2514         // class attributes must be read before class
2515         // skip ahead to read class attributes
2516         int startbp = bp;
2517         nextChar();
2518         char interfaceCount = nextChar();
2519         bp += interfaceCount * 2;
2520         char fieldCount = nextChar();
2521         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2522         char methodCount = nextChar();
2523         for (int i = 0; i &lt; methodCount; i++) skipMember();
2524         readClassAttrs(c);
2525 
2526         if (c.permitted != null &amp;&amp; !c.permitted.isEmpty()) {
2527             c.flags_field |= SEALED;
2528         }
2529 
2530         // reset and read rest of classinfo
2531         bp = startbp;
2532         int n = nextChar();
2533         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2534             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2535         }
2536         if (ct.supertype_field == null)
2537             ct.supertype_field =
2538                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2539         n = nextChar();
2540         List&lt;Type&gt; is = List.nil();
2541         for (int i = 0; i &lt; n; i++) {
2542             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2543             is = is.prepend(_inter);
2544         }
2545         if (ct.interfaces_field == null)
2546             ct.interfaces_field = is.reverse();
2547 
2548         Assert.check(fieldCount == nextChar());
2549         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
2550         Assert.check(methodCount == nextChar());
2551         for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
2552 
2553         typevars = typevars.leave();
2554     }
2555 
2556     /** Read inner class info. For each inner/outer pair allocate a
2557      *  member class.
2558      */
2559     void readInnerClasses(ClassSymbol c) {
2560         int n = nextChar();
2561         for (int i = 0; i &lt; n; i++) {
2562             nextChar(); // skip inner class symbol
2563             int outerIdx = nextChar();
2564             int nameIdx = nextChar();
2565             ClassSymbol outer = optPoolEntry(outerIdx, poolReader::getClass, null);
2566             Name name = optPoolEntry(nameIdx, poolReader::getName, names.empty);
2567             if (name == null) name = names.empty;
2568             long flags = adjustClassFlags(nextChar());
2569             if (outer != null) { // we have a member class
2570                 if (name == names.empty)
2571                     name = names.one;
2572                 ClassSymbol member = enterClass(name, outer);
2573                 if ((flags &amp; STATIC) == 0) {
2574                     ((ClassType)member.type).setEnclosingType(outer.type);
2575                     if (member.erasure_field != null)
2576                         ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));
2577                 }
2578                 if (c == outer) {
2579                     member.flags_field = flags;
2580                     enterMember(c, member);
2581                 }
2582             }
2583         }
2584     }
2585 
2586     /** Read a class definition from the bytes in buf.
2587      */
2588     private void readClassBuffer(ClassSymbol c) throws IOException {
2589         int magic = nextInt();
2590         if (magic != JAVA_MAGIC)
2591             throw badClassFile(&quot;illegal.start.of.class.file&quot;);
2592 
2593         minorVersion = nextChar();
2594         majorVersion = nextChar();
2595         int maxMajor = Version.MAX().major;
2596         int maxMinor = Version.MAX().minor;
2597         if (majorVersion &gt; maxMajor ||
2598             majorVersion * 1000 + minorVersion &lt;
2599             Version.MIN().major * 1000 + Version.MIN().minor) {
2600             if (majorVersion == (maxMajor + 1))
2601                 log.warning(Warnings.BigMajorVersion(currentClassFile,
2602                                                      majorVersion,
2603                                                      maxMajor));
2604             else
2605                 throw badClassFile(&quot;wrong.version&quot;,
2606                                    Integer.toString(majorVersion),
2607                                    Integer.toString(minorVersion),
2608                                    Integer.toString(maxMajor),
2609                                    Integer.toString(maxMinor));
2610         }
2611 
2612         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2613             if (!preview.isEnabled()) {
2614                 log.error(preview.disabledError(currentClassFile, majorVersion));
2615             } else {
2616                 preview.warnPreview(c.classfile, majorVersion);
2617             }
2618         }
2619 
2620         poolReader = new PoolReader(this, names, syms);
2621         bp = poolReader.readPool(buf, bp);
2622         if (signatureBuffer.length &lt; bp) {
2623             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2624             signatureBuffer = new byte[ns];
2625         }
2626         readClass(c);
2627     }
2628 
2629     public void readClassFile(ClassSymbol c) {
2630         readClassFileInternal(c);
2631         if (c.isValue()) {
2632             /* http://cr.openjdk.java.net/~briangoetz/valhalla/sov/04-translation.html
2633                The relationship of value and reference projections differs between the language model
2634                and the VM model. In the language, the value projection is not a subtype of the
2635                reference projection; instead, the two are related by inline narrowing and widening
2636                conversions, whereas in the VM, the two are related by actual subtyping.
2637                Sever the subtyping relationship by rewiring the supertypes here and now.
2638              */
2639 
2640             Name flatname = TypeSymbol.formFlatName(names.ref, c);
2641             ClassSymbol referenceProjection = syms.getClass(currentModule, flatname);
2642             if (referenceProjection != null) {
2643                 if (referenceProjection.name != names.ref &amp;&amp; referenceProjection.owner.kind == PCK) {
2644                     readClassFileInternal(referenceProjection);
2645                     ClassType classType = (ClassType) c.type;
2646                     classType.supertype_field = ((ClassType) referenceProjection.type).supertype_field;
2647                     classType.interfaces_field = ((ClassType) referenceProjection.type).interfaces_field;
2648                     // Discard the projection, it will be recomputed on the fly.
2649                     referenceProjection.owner.members().remove(referenceProjection);
2650                 }
2651             }
2652         }
2653     }
2654 
2655     private void readClassFileInternal(ClassSymbol c) {
2656         currentOwner = c;
2657         currentClassFile = c.classfile;
2658         warnedAttrs.clear();
2659         filling = true;
2660         target = null;
2661         repeatable = null;
2662         try {
2663             bp = 0;
2664             buf.reset();
2665             buf.appendStream(c.classfile.openInputStream());
2666             readClassBuffer(c);
2667             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2668                 List&lt;Type&gt; missing = missingTypeVariables;
2669                 List&lt;Type&gt; found = foundTypeVariables;
2670                 missingTypeVariables = List.nil();
2671                 foundTypeVariables = List.nil();
2672                 interimUses = List.nil();
2673                 interimProvides = List.nil();
2674                 filling = false;
2675                 ClassType ct = (ClassType)currentOwner.type;
2676                 ct.supertype_field =
2677                     types.subst(ct.supertype_field, missing, found);
2678                 ct.interfaces_field =
2679                     types.subst(ct.interfaces_field, missing, found);
2680                 ct.typarams_field =
2681                     types.substBounds(ct.typarams_field, missing, found);
2682                 for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {
2683                     types.head.tsym.type = types.head;
2684                 }
2685             } else if (missingTypeVariables.isEmpty() !=
2686                        foundTypeVariables.isEmpty()) {
2687                 Name name = missingTypeVariables.head.tsym.name;
2688                 throw badClassFile(&quot;undecl.type.var&quot;, name);
2689             }
2690 
2691             if ((c.flags_field &amp; Flags.ANNOTATION) != 0) {
2692                 c.setAnnotationTypeMetadata(new AnnotationTypeMetadata(c, new CompleterDeproxy(c, target, repeatable)));
2693             } else {
2694                 c.setAnnotationTypeMetadata(AnnotationTypeMetadata.notAnAnnotationType());
2695             }
2696 
2697             if (c == currentModule.module_info) {
2698                 if (interimUses.nonEmpty() || interimProvides.nonEmpty()) {
2699                     Assert.check(currentModule.isCompleted());
2700                     currentModule.usesProvidesCompleter =
2701                             new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
2702                 } else {
2703                     currentModule.uses = List.nil();
2704                     currentModule.provides = List.nil();
2705                 }
2706             }
2707         } catch (IOException | ClosedFileSystemException ex) {
2708             throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
2709         } catch (ArrayIndexOutOfBoundsException ex) {
2710             throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
2711         } finally {
2712             interimUses = List.nil();
2713             interimProvides = List.nil();
2714             missingTypeVariables = List.nil();
2715             foundTypeVariables = List.nil();
2716             filling = false;
2717         }
2718     }
2719 
2720     /** We can only read a single class file at a time; this
2721      *  flag keeps track of when we are currently reading a class
2722      *  file.
2723      */
2724     public boolean filling = false;
2725 
2726 /************************************************************************
2727  * Adjusting flags
2728  ***********************************************************************/
2729 
2730     long adjustFieldFlags(long flags) {
2731         return flags;
2732     }
2733 
2734     long adjustMethodFlags(long flags) {
2735         if ((flags &amp; ACC_BRIDGE) != 0) {
2736             flags &amp;= ~ACC_BRIDGE;
2737             flags |= BRIDGE;
2738         }
2739         if ((flags &amp; ACC_VARARGS) != 0) {
2740             flags &amp;= ~ACC_VARARGS;
2741             flags |= VARARGS;
2742         }
2743         return flags;
2744     }
2745 
2746     long adjustClassFlags(long flags) {
2747         if ((flags &amp; ACC_MODULE) != 0) {
2748             flags &amp;= ~ACC_MODULE;
2749             flags |= MODULE;
2750         }
2751         if ((flags &amp; ACC_VALUE) != 0) {
2752             flags &amp;= ~ACC_VALUE;
2753             flags |= allowInlineTypes ? VALUE : allowValueBasedClasses ? VALUEBASED : 0;
2754         }
2755         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2756     }
2757 
2758     /**
2759      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2760      * The attribute is only the last component of the original filename, so is unlikely
2761      * to be valid as is, so operations other than those to access the name throw
2762      * UnsupportedOperationException
2763      */
2764     private static class SourceFileObject implements JavaFileObject {
2765 
2766         /** The file&#39;s name.
2767          */
2768         private final Name name;
2769 
2770         public SourceFileObject(Name name) {
2771             this.name = name;
2772         }
2773 
2774         @Override @DefinedBy(Api.COMPILER)
2775         public URI toUri() {
2776             try {
2777                 return new URI(null, name.toString(), null);
2778             } catch (URISyntaxException e) {
2779                 throw new PathFileObject.CannotCreateUriError(name.toString(), e);
2780             }
2781         }
2782 
2783         @Override @DefinedBy(Api.COMPILER)
2784         public String getName() {
2785             return name.toString();
2786         }
2787 
2788         @Override @DefinedBy(Api.COMPILER)
2789         public JavaFileObject.Kind getKind() {
2790             return BaseFileManager.getKind(getName());
2791         }
2792 
2793         @Override @DefinedBy(Api.COMPILER)
2794         public InputStream openInputStream() {
2795             throw new UnsupportedOperationException();
2796         }
2797 
2798         @Override @DefinedBy(Api.COMPILER)
2799         public OutputStream openOutputStream() {
2800             throw new UnsupportedOperationException();
2801         }
2802 
2803         @Override @DefinedBy(Api.COMPILER)
2804         public CharBuffer getCharContent(boolean ignoreEncodingErrors) {
2805             throw new UnsupportedOperationException();
2806         }
2807 
2808         @Override @DefinedBy(Api.COMPILER)
2809         public Reader openReader(boolean ignoreEncodingErrors) {
2810             throw new UnsupportedOperationException();
2811         }
2812 
2813         @Override @DefinedBy(Api.COMPILER)
2814         public Writer openWriter() {
2815             throw new UnsupportedOperationException();
2816         }
2817 
2818         @Override @DefinedBy(Api.COMPILER)
2819         public long getLastModified() {
2820             throw new UnsupportedOperationException();
2821         }
2822 
2823         @Override @DefinedBy(Api.COMPILER)
2824         public boolean delete() {
2825             throw new UnsupportedOperationException();
2826         }
2827 
2828         @Override @DefinedBy(Api.COMPILER)
2829         public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {
2830             return true; // fail-safe mode
2831         }
2832 
2833         @Override @DefinedBy(Api.COMPILER)
2834         public NestingKind getNestingKind() {
2835             return null;
2836         }
2837 
2838         @Override @DefinedBy(Api.COMPILER)
2839         public Modifier getAccessLevel() {
2840             return null;
2841         }
2842 
2843         /**
2844          * Check if two file objects are equal.
2845          * SourceFileObjects are just placeholder objects for the value of a
2846          * SourceFile attribute, and do not directly represent specific files.
2847          * Two SourceFileObjects are equal if their names are equal.
2848          */
2849         @Override
2850         public boolean equals(Object other) {
2851             if (this == other)
2852                 return true;
2853 
2854             if (!(other instanceof SourceFileObject))
2855                 return false;
2856 
2857             SourceFileObject o = (SourceFileObject) other;
2858             return name.equals(o.name);
2859         }
2860 
2861         @Override
2862         public int hashCode() {
2863             return name.hashCode();
2864         }
2865     }
2866 
2867     private class CompleterDeproxy implements AnnotationTypeCompleter {
2868         ClassSymbol proxyOn;
2869         CompoundAnnotationProxy target;
2870         CompoundAnnotationProxy repeatable;
2871 
2872         public CompleterDeproxy(ClassSymbol c, CompoundAnnotationProxy target,
2873                 CompoundAnnotationProxy repeatable)
2874         {
2875             this.proxyOn = c;
2876             this.target = target;
2877             this.repeatable = repeatable;
2878         }
2879 
2880         @Override
2881         public void complete(ClassSymbol sym) {
2882             Assert.check(proxyOn == sym);
2883             Attribute.Compound theTarget = null, theRepeatable = null;
2884             AnnotationDeproxy deproxy;
2885 
2886             try {
2887                 if (target != null) {
2888                     deproxy = new AnnotationDeproxy(proxyOn);
2889                     theTarget = deproxy.deproxyCompound(target);
2890                 }
2891 
2892                 if (repeatable != null) {
2893                     deproxy = new AnnotationDeproxy(proxyOn);
2894                     theRepeatable = deproxy.deproxyCompound(repeatable);
2895                 }
2896             } catch (Exception e) {
2897                 throw new CompletionFailure(sym,
2898                                             () -&gt; ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),
2899                                             dcfh);
2900             }
2901 
2902             sym.getAnnotationTypeMetadata().setTarget(theTarget);
2903             sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
2904         }
2905     }
2906 
2907     private class ProxyType extends Type {
2908 
2909         private final Name name;
2910 
2911         public ProxyType(int index) {
2912             super(syms.noSymbol, TypeMetadata.EMPTY);
2913             this.name = poolReader.getName(index);
2914         }
2915 
2916         @Override
2917         public TypeTag getTag() {
2918             return TypeTag.NONE;
2919         }
2920 
2921         @Override
2922         public Type cloneWithMetadata(TypeMetadata metadata) {
2923             throw new UnsupportedOperationException();
2924         }
2925 
2926         public Type resolve() {
2927             return name.map(ClassReader.this::sigToType);
2928         }
2929 
2930         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2931         public String toString() {
2932             return &quot;&lt;ProxyType&gt;&quot;;
2933         }
2934 
2935     }
2936 
2937     private static final class InterimUsesDirective {
2938         public final Name service;
2939 
2940         public InterimUsesDirective(Name service) {
2941             this.service = service;
2942         }
2943 
2944     }
2945 
2946     private static final class InterimProvidesDirective {
2947         public final Name service;
2948         public final List&lt;Name&gt; impls;
2949 
2950         public InterimProvidesDirective(Name service, List&lt;Name&gt; impls) {
2951             this.service = service;
2952             this.impls = impls;
2953         }
2954 
2955     }
2956 
2957     private final class UsesProvidesCompleter implements Completer {
2958         private final ModuleSymbol currentModule;
2959         private final List&lt;InterimUsesDirective&gt; interimUsesCopy;
2960         private final List&lt;InterimProvidesDirective&gt; interimProvidesCopy;
2961 
2962         public UsesProvidesCompleter(ModuleSymbol currentModule, List&lt;InterimUsesDirective&gt; interimUsesCopy, List&lt;InterimProvidesDirective&gt; interimProvidesCopy) {
2963             this.currentModule = currentModule;
2964             this.interimUsesCopy = interimUsesCopy;
2965             this.interimProvidesCopy = interimProvidesCopy;
2966         }
2967 
2968         @Override
2969         public void complete(Symbol sym) throws CompletionFailure {
2970             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
2971             directives.addAll(currentModule.directives);
2972             ListBuffer&lt;UsesDirective&gt; uses = new ListBuffer&lt;&gt;();
2973             for (InterimUsesDirective interim : interimUsesCopy) {
2974                 UsesDirective d = new UsesDirective(syms.enterClass(currentModule, interim.service));
2975                 uses.add(d);
2976                 directives.add(d);
2977             }
2978             currentModule.uses = uses.toList();
2979             ListBuffer&lt;ProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
2980             for (InterimProvidesDirective interim : interimProvidesCopy) {
2981                 ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
2982                 for (Name impl : interim.impls) {
2983                     impls.append(syms.enterClass(currentModule, impl));
2984                 }
2985                 ProvidesDirective d = new ProvidesDirective(syms.enterClass(currentModule, interim.service),
2986                                                             impls.toList());
2987                 provides.add(d);
2988                 directives.add(d);
2989             }
2990             currentModule.provides = provides.toList();
2991             currentModule.directives = directives.toList();
2992         }
2993     }
2994 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
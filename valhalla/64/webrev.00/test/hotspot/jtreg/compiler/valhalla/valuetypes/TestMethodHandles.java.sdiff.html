<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestMethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestLWorld.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestNullableValueTypes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestMethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
129             e.printStackTrace();
130             throw new RuntimeException(&quot;Method handle lookup failed&quot;);
131         }
132     }
133 
134     public static void main(String[] args) throws Throwable {
135         TestMethodHandles test = new TestMethodHandles();
136         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class, MyValue3.class, MyValue3Inline.class);
137     }
138 
139     // Everything inlined
140     final MyValue3 test1_vt = MyValue3.create();
141 
142     @ForceInline
143     MyValue3 test1_target() {
144         return test1_vt;
145     }
146 
147     static final MethodHandle test1_mh;
148 
<span class="line-modified">149     @Test(valid = ValueTypeReturnedAsFieldsOn, failOn = ALLOC + STORE + CALL)</span>
<span class="line-modified">150     @Test(valid = ValueTypeReturnedAsFieldsOff, match = { ALLOC, STORE }, matchCount = { 1, 14 })</span>
151     public MyValue3 test1() throws Throwable {
152         return (MyValue3)test1_mh.invokeExact(this);
153     }
154 
155     @DontCompile
156     public void test1_verifier(boolean warmup) throws Throwable {
157         MyValue3 vt = test1();
158         test1_vt.verify(vt);
159     }
160 
161     // Leaf method not inlined but returned type is known
162     final MyValue3 test2_vt = MyValue3.create();
163     @DontInline
164     MyValue3 test2_target() {
165         return test2_vt;
166     }
167 
168     static final MethodHandle test2_mh;
169 
170     @Test
</pre>
<hr />
<pre>
257     final MyValue3 test6_vt1 = MyValue3.create();
258     @ForceInline
259     MyValue3 test6_target1() {
260         return test6_vt1;
261     }
262 
263     final MyValue3 test6_vt2 = MyValue3.create();
264     @ForceInline
265     MyValue3 test6_target2() {
266         return test6_vt2;
267     }
268 
269     boolean test6_bool = true;
270     @ForceInline
271     boolean test6_test() {
272         return test6_bool;
273     }
274 
275     static final MethodHandle test6_mh;
276 
<span class="line-modified">277     @Test(valid = ValueTypeReturnedAsFieldsOn, failOn = ALLOC + ALLOCA + STORE + STOREVALUETYPEFIELDS)</span>
<span class="line-modified">278     @Test(valid = ValueTypeReturnedAsFieldsOff)</span>
279     public MyValue3 test6() throws Throwable {
280         return (MyValue3)test6_mh.invokeExact(this);
281     }
282 
283     @DontCompile
284     public void test6_verifier(boolean warmup) throws Throwable {
285         test6_bool = !test6_bool;
286         MyValue3 vt = test6();
287         vt.verify(test6_bool ? test6_vt1 : test6_vt2);
288     }
289 
290     // Similar as above but with the method handle for target1 not
291     // constant. Shouldn&#39;t cause any allocation.
292     @ForceInline
293     static MyValue2 test7_target1() {
294         return MyValue2.createWithFieldsInline(rI, true);
295     }
296 
297     @ForceInline
298     static MyValue2 test7_target2() {
</pre>
<hr />
<pre>
370     final MyValue3 test9_vt3 = MyValue3.create();
371     @ForceInline
372     MyValue3 test9_target3() {
373         return test9_vt3;
374     }
375 
376     boolean test9_bool1 = true;
377     @ForceInline
378     boolean test9_test1() {
379         return test9_bool1;
380     }
381 
382     boolean test9_bool2 = true;
383     @ForceInline
384     boolean test9_test2() {
385         return test9_bool2;
386     }
387 
388     static final MethodHandle test9_mh;
389 
<span class="line-modified">390     @Test(valid = ValueTypeReturnedAsFieldsOn, failOn = ALLOC + ALLOCA + STORE + STOREVALUETYPEFIELDS)</span>
<span class="line-modified">391     @Test(valid = ValueTypeReturnedAsFieldsOff)</span>
392     public MyValue3 test9() throws Throwable {
393         return (MyValue3)test9_mh.invokeExact(this);
394     }
395 
396     static int test9_i = 0;
397     @DontCompile
398     public void test9_verifier(boolean warmup) throws Throwable {
399         test9_i++;
400         test9_bool1 = (test9_i % 2) == 0;
401         test9_bool2 = (test9_i % 3) == 0;
402         MyValue3 vt = test9();
403         vt.verify(test9_bool1 ? test9_vt1 : (test9_bool2 ? test9_vt2 : test9_vt3));
404     }
405 
406     // Same as above but with non constant target2 and target3
407     @ForceInline
408     static MyValue2 test10_target1() {
409         return MyValue2.createWithFieldsInline(rI, true);
410     }
411 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
129             e.printStackTrace();
130             throw new RuntimeException(&quot;Method handle lookup failed&quot;);
131         }
132     }
133 
134     public static void main(String[] args) throws Throwable {
135         TestMethodHandles test = new TestMethodHandles();
136         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class, MyValue3.class, MyValue3Inline.class);
137     }
138 
139     // Everything inlined
140     final MyValue3 test1_vt = MyValue3.create();
141 
142     @ForceInline
143     MyValue3 test1_target() {
144         return test1_vt;
145     }
146 
147     static final MethodHandle test1_mh;
148 
<span class="line-modified">149     @Test(valid = InlineTypeReturnedAsFieldsOn, failOn = ALLOC + STORE + CALL)</span>
<span class="line-modified">150     @Test(valid = InlineTypeReturnedAsFieldsOff, match = { ALLOC, STORE }, matchCount = { 1, 14 })</span>
151     public MyValue3 test1() throws Throwable {
152         return (MyValue3)test1_mh.invokeExact(this);
153     }
154 
155     @DontCompile
156     public void test1_verifier(boolean warmup) throws Throwable {
157         MyValue3 vt = test1();
158         test1_vt.verify(vt);
159     }
160 
161     // Leaf method not inlined but returned type is known
162     final MyValue3 test2_vt = MyValue3.create();
163     @DontInline
164     MyValue3 test2_target() {
165         return test2_vt;
166     }
167 
168     static final MethodHandle test2_mh;
169 
170     @Test
</pre>
<hr />
<pre>
257     final MyValue3 test6_vt1 = MyValue3.create();
258     @ForceInline
259     MyValue3 test6_target1() {
260         return test6_vt1;
261     }
262 
263     final MyValue3 test6_vt2 = MyValue3.create();
264     @ForceInline
265     MyValue3 test6_target2() {
266         return test6_vt2;
267     }
268 
269     boolean test6_bool = true;
270     @ForceInline
271     boolean test6_test() {
272         return test6_bool;
273     }
274 
275     static final MethodHandle test6_mh;
276 
<span class="line-modified">277     @Test(valid = InlineTypeReturnedAsFieldsOn, failOn = ALLOC + ALLOCA + STORE + STOREVALUETYPEFIELDS)</span>
<span class="line-modified">278     @Test(valid = InlineTypeReturnedAsFieldsOff)</span>
279     public MyValue3 test6() throws Throwable {
280         return (MyValue3)test6_mh.invokeExact(this);
281     }
282 
283     @DontCompile
284     public void test6_verifier(boolean warmup) throws Throwable {
285         test6_bool = !test6_bool;
286         MyValue3 vt = test6();
287         vt.verify(test6_bool ? test6_vt1 : test6_vt2);
288     }
289 
290     // Similar as above but with the method handle for target1 not
291     // constant. Shouldn&#39;t cause any allocation.
292     @ForceInline
293     static MyValue2 test7_target1() {
294         return MyValue2.createWithFieldsInline(rI, true);
295     }
296 
297     @ForceInline
298     static MyValue2 test7_target2() {
</pre>
<hr />
<pre>
370     final MyValue3 test9_vt3 = MyValue3.create();
371     @ForceInline
372     MyValue3 test9_target3() {
373         return test9_vt3;
374     }
375 
376     boolean test9_bool1 = true;
377     @ForceInline
378     boolean test9_test1() {
379         return test9_bool1;
380     }
381 
382     boolean test9_bool2 = true;
383     @ForceInline
384     boolean test9_test2() {
385         return test9_bool2;
386     }
387 
388     static final MethodHandle test9_mh;
389 
<span class="line-modified">390     @Test(valid = InlineTypeReturnedAsFieldsOn, failOn = ALLOC + ALLOCA + STORE + STOREVALUETYPEFIELDS)</span>
<span class="line-modified">391     @Test(valid = InlineTypeReturnedAsFieldsOff)</span>
392     public MyValue3 test9() throws Throwable {
393         return (MyValue3)test9_mh.invokeExact(this);
394     }
395 
396     static int test9_i = 0;
397     @DontCompile
398     public void test9_verifier(boolean warmup) throws Throwable {
399         test9_i++;
400         test9_bool1 = (test9_i % 2) == 0;
401         test9_bool2 = (test9_i % 3) == 0;
402         MyValue3 vt = test9();
403         vt.verify(test9_bool1 ? test9_vt1 : (test9_bool2 ? test9_vt2 : test9_vt3));
404     }
405 
406     // Same as above but with non constant target2 and target3
407     @ForceInline
408     static MyValue2 test10_target1() {
409         return MyValue2.createWithFieldsInline(rI, true);
410     }
411 
</pre>
</td>
</tr>
</table>
<center><a href="TestLWorld.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestNullableValueTypes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestUnresolvedValueClass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../runtime/valhalla/valuetypes/FlattenableSemanticTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
146 
147     // &quot;jtreg -DXcomp=true&quot; runs all the scenarios with -Xcomp. This is faster than &quot;jtreg -javaoptions:-Xcomp&quot;.
148     protected static final boolean RUN_SCENARIOS_WITH_XCOMP = Boolean.parseBoolean(System.getProperty(&quot;Xcomp&quot;, &quot;false&quot;));
149 
150     // Pre-defined settings
151     private static final String[] defaultFlags = {
152         &quot;-XX:-BackgroundCompilation&quot;};
153     private static final String[] compileCommandFlags = {
154         &quot;-XX:CompileCommand=quiet&quot;,
155         &quot;-XX:CompileCommand=compileonly,java.lang.invoke.*::*&quot;,
156         &quot;-XX:CompileCommand=compileonly,java.lang.Long::sum&quot;,
157         &quot;-XX:CompileCommand=compileonly,java.lang.Object::&lt;init&gt;&quot;,
158         &quot;-XX:CompileCommand=inline,compiler.valhalla.valuetypes.MyValue*::&lt;init&gt;&quot;,
159         &quot;-XX:CompileCommand=compileonly,compiler.valhalla.valuetypes.*::*&quot;};
160     private static final String[] printFlags = {
161         &quot;-XX:+PrintCompilation&quot;, &quot;-XX:+PrintIdeal&quot;, &quot;-XX:+UnlockDiagnosticVMOptions&quot;, &quot;-XX:+PrintOptoAssembly&quot;};
162     private static final String[] verifyFlags = {
163         &quot;-XX:+VerifyOops&quot;, &quot;-XX:+VerifyStack&quot;, &quot;-XX:+VerifyLastFrame&quot;, &quot;-XX:+VerifyBeforeGC&quot;, &quot;-XX:+VerifyAfterGC&quot;,
164         &quot;-XX:+VerifyDuringGC&quot;, &quot;-XX:+VerifyAdapterSharing&quot;};
165 
<span class="line-modified">166     protected static final int ValueTypePassFieldsAsArgsOn = 0x1;</span>
<span class="line-modified">167     protected static final int ValueTypePassFieldsAsArgsOff = 0x2;</span>
168     protected static final int ValueTypeArrayFlattenOn = 0x4;
169     protected static final int ValueTypeArrayFlattenOff = 0x8;
<span class="line-modified">170     protected static final int ValueTypeReturnedAsFieldsOn = 0x10;</span>
<span class="line-modified">171     protected static final int ValueTypeReturnedAsFieldsOff = 0x20;</span>
172     protected static final int AlwaysIncrementalInlineOn = 0x40;
173     protected static final int AlwaysIncrementalInlineOff = 0x80;
174     protected static final int G1GCOn = 0x100;
175     protected static final int G1GCOff = 0x200;
176     protected static final int ZGCOn = 0x400;
177     protected static final int ZGCOff = 0x800;
178     protected static final int ArrayLoadStoreProfileOn = 0x1000;
179     protected static final int ArrayLoadStoreProfileOff = 0x2000;
180     protected static final int TypeProfileOn = 0x4000;
181     protected static final int TypeProfileOff = 0x8000;
<span class="line-modified">182     protected static final boolean ValueTypePassFieldsAsArgs = (Boolean)WHITE_BOX.getVMFlag(&quot;ValueTypePassFieldsAsArgs&quot;);</span>
<span class="line-modified">183     protected static final boolean ValueTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag(&quot;ValueArrayElemMaxFlatSize&quot;) == -1); // FIXME - fix this if default of ValueArrayElemMaxFlatSize is changed</span>
<span class="line-modified">184     protected static final boolean ValueTypeReturnedAsFields = (Boolean)WHITE_BOX.getVMFlag(&quot;ValueTypeReturnedAsFields&quot;);</span>
185     protected static final boolean AlwaysIncrementalInline = (Boolean)WHITE_BOX.getVMFlag(&quot;AlwaysIncrementalInline&quot;);
186     protected static final boolean G1GC = (Boolean)WHITE_BOX.getVMFlag(&quot;UseG1GC&quot;);
187     protected static final boolean ZGC = (Boolean)WHITE_BOX.getVMFlag(&quot;UseZGC&quot;);
188     protected static final boolean VerifyOops = (Boolean)WHITE_BOX.getVMFlag(&quot;VerifyOops&quot;);
189     protected static final boolean UseArrayLoadStoreProfile = (Boolean)WHITE_BOX.getVMFlag(&quot;UseArrayLoadStoreProfile&quot;);
190     protected static final long TypeProfileLevel = (Long)WHITE_BOX.getVMFlag(&quot;TypeProfileLevel&quot;);
191 
192     protected static final Hashtable&lt;String, Method&gt; tests = new Hashtable&lt;String, Method&gt;();
193     protected static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(&quot;UseCompiler&quot;);
194     protected static final boolean PRINT_IDEAL  = WHITE_BOX.getBooleanVMFlag(&quot;PrintIdeal&quot;);
195 
196     // Regular expressions used to match nodes in the PrintIdeal output
197     protected static final String START = &quot;(\\d+\\t(.*&quot;;
198     protected static final String MID = &quot;.*)+\\t===.*&quot;;
199     protected static final String END = &quot;)|&quot;;
200     // Generic allocation
201     protected static final String ALLOC_G  = &quot;(.*call,static  wrapper for: _new_instance_Java&quot; + END;
202     protected static final String ALLOCA_G = &quot;(.*call,static  wrapper for: _new_array_Java&quot; + END;
203     // Value type allocation
204     protected static final String ALLOC  = &quot;(.*precise klass compiler/valhalla/valuetypes/MyValue.*\\R(.*(movl|xorl|nop|spill).*\\R)*.*_new_instance_Java&quot; + END;
</pre>
<hr />
<pre>
240         return list.toArray(new String[list.size()]);
241     }
242 
243     /**
244      * Override getNumScenarios and getVMParameters if you want to run with more than
245      * the 6 built-in scenarios
246      */
247     public int getNumScenarios() {
248         return 6;
249     }
250 
251     /**
252      * VM parameters for the 5 built-in test scenarios. If your test needs to append
253      * extra parameters for (some of) these scenarios, override getExtraVMParameters().
254      */
255     public String[] getVMParameters(int scenario) {
256         switch (scenario) {
257         case 0: return new String[] {
258                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
259                 &quot;-XX:+AlwaysIncrementalInline&quot;,
<span class="line-modified">260                 &quot;-XX:ValueArrayElemMaxFlatOops=5&quot;,</span>
<span class="line-modified">261                 &quot;-XX:ValueArrayElemMaxFlatSize=-1&quot;,</span>
<span class="line-modified">262                 &quot;-XX:ValueFieldMaxFlatSize=-1&quot;,</span>
<span class="line-modified">263                 &quot;-XX:+ValueTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">264                 &quot;-XX:+ValueTypeReturnedAsFields&quot;};</span>
265         case 1: return new String[] {
266                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
267                 &quot;-XX:-UseCompressedOops&quot;,
<span class="line-modified">268                 &quot;-XX:ValueArrayElemMaxFlatOops=5&quot;,</span>
<span class="line-modified">269                 &quot;-XX:ValueArrayElemMaxFlatSize=-1&quot;,</span>
<span class="line-modified">270                 &quot;-XX:ValueFieldMaxFlatSize=-1&quot;,</span>
<span class="line-modified">271                 &quot;-XX:-ValueTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">272                 &quot;-XX:-ValueTypeReturnedAsFields&quot;};</span>
273         case 2: return new String[] {
274                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
275                 &quot;-XX:-UseCompressedOops&quot;,
<span class="line-modified">276                 &quot;-XX:ValueArrayElemMaxFlatOops=0&quot;,</span>
<span class="line-modified">277                 &quot;-XX:ValueArrayElemMaxFlatSize=0&quot;,</span>
<span class="line-modified">278                 &quot;-XX:ValueFieldMaxFlatSize=-1&quot;,</span>
<span class="line-modified">279                 &quot;-XX:+ValueTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">280                 &quot;-XX:+ValueTypeReturnedAsFields&quot;,</span>
<span class="line-modified">281                 &quot;-XX:+StressValueTypeReturnedAsFields&quot;};</span>
282         case 3: return new String[] {
283                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
284                 &quot;-DVerifyIR=false&quot;,
285                 &quot;-XX:+AlwaysIncrementalInline&quot;,
<span class="line-modified">286                 &quot;-XX:ValueArrayElemMaxFlatOops=0&quot;,</span>
<span class="line-modified">287                 &quot;-XX:ValueArrayElemMaxFlatSize=0&quot;,</span>
<span class="line-modified">288                 &quot;-XX:ValueFieldMaxFlatSize=0&quot;,</span>
<span class="line-modified">289                 &quot;-XX:+ValueTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">290                 &quot;-XX:+ValueTypeReturnedAsFields&quot;};</span>
291         case 4: return new String[] {
292                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
293                 &quot;-DVerifyIR=false&quot;,
<span class="line-modified">294                 &quot;-XX:ValueArrayElemMaxFlatOops=-1&quot;,</span>
<span class="line-modified">295                 &quot;-XX:ValueArrayElemMaxFlatSize=-1&quot;,</span>
<span class="line-modified">296                 &quot;-XX:ValueFieldMaxFlatSize=0&quot;,</span>
<span class="line-modified">297                 &quot;-XX:+ValueTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">298                 &quot;-XX:-ValueTypeReturnedAsFields&quot;,</span>
299                 &quot;-XX:-ReduceInitialCardMarks&quot;};
300         case 5: return new String[] {
301                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
302                 &quot;-XX:+AlwaysIncrementalInline&quot;,
<span class="line-modified">303                 &quot;-XX:ValueArrayElemMaxFlatOops=5&quot;,</span>
<span class="line-modified">304                 &quot;-XX:ValueArrayElemMaxFlatSize=-1&quot;,</span>
<span class="line-modified">305                 &quot;-XX:ValueFieldMaxFlatSize=-1&quot;,</span>
<span class="line-modified">306                 &quot;-XX:-ValueTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">307                 &quot;-XX:-ValueTypeReturnedAsFields&quot;};</span>
308         }
309         return null;
310     }
311 
312     /**
313      * Override this method and return a non-null reason if the given scenario should be
314      * ignored (due to an existing bug, etc).
315      */
316     String isScenarioIgnored(int scenario) {
317         return null;
318     }
319 
320     /**
321      * Override this method to provide extra parameters for selected scenarios
322      */
323     public String[] getExtraVMParameters(int scenario) {
324         return null;
325     }
326 
327     public static void main(String[] args) throws Throwable {
</pre>
<hr />
<pre>
456         cmds = concat(cmds, getClass().getName(), &quot;run&quot;);
457         OutputAnalyzer oa = ProcessTools.executeTestJvm(cmds);
458         // If ideal graph printing is enabled/supported, verify output
459         String output = oa.getOutput();
460         oa.shouldHaveExitValue(0);
461         if (VERIFY_IR) {
462             if (output.contains(&quot;PrintIdeal enabled&quot;)) {
463                 parseOutput(output);
464             } else {
465                 System.out.println(output);
466                 System.out.println(&quot;WARNING: IR verification failed! Running with -Xint, -Xcomp or release build?&quot;);
467             }
468         }
469     }
470 
471     static final class TestAnnotation {
472         private final int flag;
473         private final BooleanSupplier predicate;
474 
475         private static final TestAnnotation testAnnotations[] = {
<span class="line-modified">476             new TestAnnotation(ValueTypePassFieldsAsArgsOn, () -&gt; ValueTypePassFieldsAsArgs),</span>
<span class="line-modified">477             new TestAnnotation(ValueTypePassFieldsAsArgsOff, () -&gt; !ValueTypePassFieldsAsArgs),</span>
478             new TestAnnotation(ValueTypeArrayFlattenOn, () -&gt; ValueTypeArrayFlatten),
479             new TestAnnotation(ValueTypeArrayFlattenOff, () -&gt; !ValueTypeArrayFlatten),
<span class="line-modified">480             new TestAnnotation(ValueTypeReturnedAsFieldsOn, () -&gt; ValueTypeReturnedAsFields),</span>
<span class="line-modified">481             new TestAnnotation(ValueTypeReturnedAsFieldsOff, () -&gt; !ValueTypeReturnedAsFields),</span>
482             new TestAnnotation(AlwaysIncrementalInlineOn, () -&gt; AlwaysIncrementalInline),
483             new TestAnnotation(AlwaysIncrementalInlineOff, () -&gt; !AlwaysIncrementalInline),
484             new TestAnnotation(G1GCOn, () -&gt; G1GC),
485             new TestAnnotation(G1GCOff, () -&gt; !G1GC),
486             new TestAnnotation(ZGCOn, () -&gt; ZGC),
487             new TestAnnotation(ZGCOff, () -&gt; !ZGC),
488             new TestAnnotation(ArrayLoadStoreProfileOn, () -&gt; UseArrayLoadStoreProfile),
489             new TestAnnotation(ArrayLoadStoreProfileOff, () -&gt; !UseArrayLoadStoreProfile),
490             new TestAnnotation(TypeProfileOn, () -&gt; TypeProfileLevel == 222),
491             new TestAnnotation(TypeProfileOff, () -&gt; TypeProfileLevel == 0),
492         };
493 
494         private TestAnnotation(int flag, BooleanSupplier predicate) {
495             this.flag = flag;
496             this.predicate = predicate;
497         }
498 
499         private boolean match(Test a) {
500             return (a.valid() &amp; flag) != 0 &amp;&amp; predicate.getAsBoolean();
501         }
</pre>
</td>
<td>
<hr />
<pre>
146 
147     // &quot;jtreg -DXcomp=true&quot; runs all the scenarios with -Xcomp. This is faster than &quot;jtreg -javaoptions:-Xcomp&quot;.
148     protected static final boolean RUN_SCENARIOS_WITH_XCOMP = Boolean.parseBoolean(System.getProperty(&quot;Xcomp&quot;, &quot;false&quot;));
149 
150     // Pre-defined settings
151     private static final String[] defaultFlags = {
152         &quot;-XX:-BackgroundCompilation&quot;};
153     private static final String[] compileCommandFlags = {
154         &quot;-XX:CompileCommand=quiet&quot;,
155         &quot;-XX:CompileCommand=compileonly,java.lang.invoke.*::*&quot;,
156         &quot;-XX:CompileCommand=compileonly,java.lang.Long::sum&quot;,
157         &quot;-XX:CompileCommand=compileonly,java.lang.Object::&lt;init&gt;&quot;,
158         &quot;-XX:CompileCommand=inline,compiler.valhalla.valuetypes.MyValue*::&lt;init&gt;&quot;,
159         &quot;-XX:CompileCommand=compileonly,compiler.valhalla.valuetypes.*::*&quot;};
160     private static final String[] printFlags = {
161         &quot;-XX:+PrintCompilation&quot;, &quot;-XX:+PrintIdeal&quot;, &quot;-XX:+UnlockDiagnosticVMOptions&quot;, &quot;-XX:+PrintOptoAssembly&quot;};
162     private static final String[] verifyFlags = {
163         &quot;-XX:+VerifyOops&quot;, &quot;-XX:+VerifyStack&quot;, &quot;-XX:+VerifyLastFrame&quot;, &quot;-XX:+VerifyBeforeGC&quot;, &quot;-XX:+VerifyAfterGC&quot;,
164         &quot;-XX:+VerifyDuringGC&quot;, &quot;-XX:+VerifyAdapterSharing&quot;};
165 
<span class="line-modified">166     protected static final int InlineTypePassFieldsAsArgsOn = 0x1;</span>
<span class="line-modified">167     protected static final int InlineTypePassFieldsAsArgsOff = 0x2;</span>
168     protected static final int ValueTypeArrayFlattenOn = 0x4;
169     protected static final int ValueTypeArrayFlattenOff = 0x8;
<span class="line-modified">170     protected static final int InlineTypeReturnedAsFieldsOn = 0x10;</span>
<span class="line-modified">171     protected static final int InlineTypeReturnedAsFieldsOff = 0x20;</span>
172     protected static final int AlwaysIncrementalInlineOn = 0x40;
173     protected static final int AlwaysIncrementalInlineOff = 0x80;
174     protected static final int G1GCOn = 0x100;
175     protected static final int G1GCOff = 0x200;
176     protected static final int ZGCOn = 0x400;
177     protected static final int ZGCOff = 0x800;
178     protected static final int ArrayLoadStoreProfileOn = 0x1000;
179     protected static final int ArrayLoadStoreProfileOff = 0x2000;
180     protected static final int TypeProfileOn = 0x4000;
181     protected static final int TypeProfileOff = 0x8000;
<span class="line-modified">182     protected static final boolean InlineTypePassFieldsAsArgs = (Boolean)WHITE_BOX.getVMFlag(&quot;InlineTypePassFieldsAsArgs&quot;);</span>
<span class="line-modified">183     protected static final boolean ValueTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag(&quot;InlineArrayElemMaxFlatSize&quot;) == -1); // FIXME - fix this if default of InlineArrayElemMaxFlatSize is changed</span>
<span class="line-modified">184     protected static final boolean InlineTypeReturnedAsFields = (Boolean)WHITE_BOX.getVMFlag(&quot;InlineTypeReturnedAsFields&quot;);</span>
185     protected static final boolean AlwaysIncrementalInline = (Boolean)WHITE_BOX.getVMFlag(&quot;AlwaysIncrementalInline&quot;);
186     protected static final boolean G1GC = (Boolean)WHITE_BOX.getVMFlag(&quot;UseG1GC&quot;);
187     protected static final boolean ZGC = (Boolean)WHITE_BOX.getVMFlag(&quot;UseZGC&quot;);
188     protected static final boolean VerifyOops = (Boolean)WHITE_BOX.getVMFlag(&quot;VerifyOops&quot;);
189     protected static final boolean UseArrayLoadStoreProfile = (Boolean)WHITE_BOX.getVMFlag(&quot;UseArrayLoadStoreProfile&quot;);
190     protected static final long TypeProfileLevel = (Long)WHITE_BOX.getVMFlag(&quot;TypeProfileLevel&quot;);
191 
192     protected static final Hashtable&lt;String, Method&gt; tests = new Hashtable&lt;String, Method&gt;();
193     protected static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(&quot;UseCompiler&quot;);
194     protected static final boolean PRINT_IDEAL  = WHITE_BOX.getBooleanVMFlag(&quot;PrintIdeal&quot;);
195 
196     // Regular expressions used to match nodes in the PrintIdeal output
197     protected static final String START = &quot;(\\d+\\t(.*&quot;;
198     protected static final String MID = &quot;.*)+\\t===.*&quot;;
199     protected static final String END = &quot;)|&quot;;
200     // Generic allocation
201     protected static final String ALLOC_G  = &quot;(.*call,static  wrapper for: _new_instance_Java&quot; + END;
202     protected static final String ALLOCA_G = &quot;(.*call,static  wrapper for: _new_array_Java&quot; + END;
203     // Value type allocation
204     protected static final String ALLOC  = &quot;(.*precise klass compiler/valhalla/valuetypes/MyValue.*\\R(.*(movl|xorl|nop|spill).*\\R)*.*_new_instance_Java&quot; + END;
</pre>
<hr />
<pre>
240         return list.toArray(new String[list.size()]);
241     }
242 
243     /**
244      * Override getNumScenarios and getVMParameters if you want to run with more than
245      * the 6 built-in scenarios
246      */
247     public int getNumScenarios() {
248         return 6;
249     }
250 
251     /**
252      * VM parameters for the 5 built-in test scenarios. If your test needs to append
253      * extra parameters for (some of) these scenarios, override getExtraVMParameters().
254      */
255     public String[] getVMParameters(int scenario) {
256         switch (scenario) {
257         case 0: return new String[] {
258                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
259                 &quot;-XX:+AlwaysIncrementalInline&quot;,
<span class="line-modified">260                 &quot;-XX:InlineArrayElemMaxFlatOops=5&quot;,</span>
<span class="line-modified">261                 &quot;-XX:InlineArrayElemMaxFlatSize=-1&quot;,</span>
<span class="line-modified">262                 &quot;-XX:InlineFiledMaxFlatSize=-1&quot;,</span>
<span class="line-modified">263                 &quot;-XX:+InlineTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">264                 &quot;-XX:+InlineTypeReturnedAsFields&quot;};</span>
265         case 1: return new String[] {
266                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
267                 &quot;-XX:-UseCompressedOops&quot;,
<span class="line-modified">268                 &quot;-XX:InlineArrayElemMaxFlatOops=5&quot;,</span>
<span class="line-modified">269                 &quot;-XX:InlineArrayElemMaxFlatSize=-1&quot;,</span>
<span class="line-modified">270                 &quot;-XX:InlineFiledMaxFlatSize=-1&quot;,</span>
<span class="line-modified">271                 &quot;-XX:-InlineTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">272                 &quot;-XX:-InlineTypeReturnedAsFields&quot;};</span>
273         case 2: return new String[] {
274                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
275                 &quot;-XX:-UseCompressedOops&quot;,
<span class="line-modified">276                 &quot;-XX:InlineArrayElemMaxFlatOops=0&quot;,</span>
<span class="line-modified">277                 &quot;-XX:InlineArrayElemMaxFlatSize=0&quot;,</span>
<span class="line-modified">278                 &quot;-XX:InlineFiledMaxFlatSize=-1&quot;,</span>
<span class="line-modified">279                 &quot;-XX:+InlineTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">280                 &quot;-XX:+InlineTypeReturnedAsFields&quot;,</span>
<span class="line-modified">281                 &quot;-XX:+StressInlineTypeReturnedAsFields&quot;};</span>
282         case 3: return new String[] {
283                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
284                 &quot;-DVerifyIR=false&quot;,
285                 &quot;-XX:+AlwaysIncrementalInline&quot;,
<span class="line-modified">286                 &quot;-XX:InlineArrayElemMaxFlatOops=0&quot;,</span>
<span class="line-modified">287                 &quot;-XX:InlineArrayElemMaxFlatSize=0&quot;,</span>
<span class="line-modified">288                 &quot;-XX:InlineFiledMaxFlatSize=0&quot;,</span>
<span class="line-modified">289                 &quot;-XX:+InlineTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">290                 &quot;-XX:+InlineTypeReturnedAsFields&quot;};</span>
291         case 4: return new String[] {
292                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
293                 &quot;-DVerifyIR=false&quot;,
<span class="line-modified">294                 &quot;-XX:InlineArrayElemMaxFlatOops=-1&quot;,</span>
<span class="line-modified">295                 &quot;-XX:InlineArrayElemMaxFlatSize=-1&quot;,</span>
<span class="line-modified">296                 &quot;-XX:InlineFiledMaxFlatSize=0&quot;,</span>
<span class="line-modified">297                 &quot;-XX:+InlineTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">298                 &quot;-XX:-InlineTypeReturnedAsFields&quot;,</span>
299                 &quot;-XX:-ReduceInitialCardMarks&quot;};
300         case 5: return new String[] {
301                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
302                 &quot;-XX:+AlwaysIncrementalInline&quot;,
<span class="line-modified">303                 &quot;-XX:InlineArrayElemMaxFlatOops=5&quot;,</span>
<span class="line-modified">304                 &quot;-XX:InlineArrayElemMaxFlatSize=-1&quot;,</span>
<span class="line-modified">305                 &quot;-XX:InlineFiledMaxFlatSize=-1&quot;,</span>
<span class="line-modified">306                 &quot;-XX:-InlineTypePassFieldsAsArgs&quot;,</span>
<span class="line-modified">307                 &quot;-XX:-InlineTypeReturnedAsFields&quot;};</span>
308         }
309         return null;
310     }
311 
312     /**
313      * Override this method and return a non-null reason if the given scenario should be
314      * ignored (due to an existing bug, etc).
315      */
316     String isScenarioIgnored(int scenario) {
317         return null;
318     }
319 
320     /**
321      * Override this method to provide extra parameters for selected scenarios
322      */
323     public String[] getExtraVMParameters(int scenario) {
324         return null;
325     }
326 
327     public static void main(String[] args) throws Throwable {
</pre>
<hr />
<pre>
456         cmds = concat(cmds, getClass().getName(), &quot;run&quot;);
457         OutputAnalyzer oa = ProcessTools.executeTestJvm(cmds);
458         // If ideal graph printing is enabled/supported, verify output
459         String output = oa.getOutput();
460         oa.shouldHaveExitValue(0);
461         if (VERIFY_IR) {
462             if (output.contains(&quot;PrintIdeal enabled&quot;)) {
463                 parseOutput(output);
464             } else {
465                 System.out.println(output);
466                 System.out.println(&quot;WARNING: IR verification failed! Running with -Xint, -Xcomp or release build?&quot;);
467             }
468         }
469     }
470 
471     static final class TestAnnotation {
472         private final int flag;
473         private final BooleanSupplier predicate;
474 
475         private static final TestAnnotation testAnnotations[] = {
<span class="line-modified">476             new TestAnnotation(InlineTypePassFieldsAsArgsOn, () -&gt; InlineTypePassFieldsAsArgs),</span>
<span class="line-modified">477             new TestAnnotation(InlineTypePassFieldsAsArgsOff, () -&gt; !InlineTypePassFieldsAsArgs),</span>
478             new TestAnnotation(ValueTypeArrayFlattenOn, () -&gt; ValueTypeArrayFlatten),
479             new TestAnnotation(ValueTypeArrayFlattenOff, () -&gt; !ValueTypeArrayFlatten),
<span class="line-modified">480             new TestAnnotation(InlineTypeReturnedAsFieldsOn, () -&gt; InlineTypeReturnedAsFields),</span>
<span class="line-modified">481             new TestAnnotation(InlineTypeReturnedAsFieldsOff, () -&gt; !InlineTypeReturnedAsFields),</span>
482             new TestAnnotation(AlwaysIncrementalInlineOn, () -&gt; AlwaysIncrementalInline),
483             new TestAnnotation(AlwaysIncrementalInlineOff, () -&gt; !AlwaysIncrementalInline),
484             new TestAnnotation(G1GCOn, () -&gt; G1GC),
485             new TestAnnotation(G1GCOff, () -&gt; !G1GC),
486             new TestAnnotation(ZGCOn, () -&gt; ZGC),
487             new TestAnnotation(ZGCOff, () -&gt; !ZGC),
488             new TestAnnotation(ArrayLoadStoreProfileOn, () -&gt; UseArrayLoadStoreProfile),
489             new TestAnnotation(ArrayLoadStoreProfileOff, () -&gt; !UseArrayLoadStoreProfile),
490             new TestAnnotation(TypeProfileOn, () -&gt; TypeProfileLevel == 222),
491             new TestAnnotation(TypeProfileOff, () -&gt; TypeProfileLevel == 0),
492         };
493 
494         private TestAnnotation(int flag, BooleanSupplier predicate) {
495             this.flag = flag;
496             this.predicate = predicate;
497         }
498 
499         private boolean match(Test a) {
500             return (a.valid() &amp; flag) != 0 &amp;&amp; predicate.getAsBoolean();
501         }
</pre>
</td>
</tr>
</table>
<center><a href="TestUnresolvedValueClass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../runtime/valhalla/valuetypes/FlattenableSemanticTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
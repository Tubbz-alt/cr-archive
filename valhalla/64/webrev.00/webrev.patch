diff a/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
@@ -496,11 +496,11 @@
 void LIR_Assembler::return_op(LIR_Opr result) {
   assert(result->is_illegal() || !result->is_single_cpu() || result->as_register() == r0, "word returns are in r0,");
 
   ciMethod* method = compilation()->method();
 
-  if (ValueTypeReturnedAsFields && method->signature()->returns_never_null()) {
+  if (InlineTypeReturnedAsFields && method->signature()->returns_never_null()) {
     ciType* return_type = method->return_type();
     if (return_type->is_valuetype()) {
       ciValueKlass* vk = return_type->as_value_klass();
       if (vk->can_be_returned_as_fields()) {
         address unpack_handler = vk->unpack_handler();
@@ -1584,11 +1584,11 @@
 
 }
 
 void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {
   // This is called when we use aastore into a an array declared as "[LVT;",
-  // where we know VT is not flattenable (due to ValueArrayElemMaxFlatOops, etc).
+  // where we know VT is not flattenable (due to InlineArrayElemMaxFlatSize, etc).
   // However, we need to do a NULL check if the actual array is a "[QVT;".
 
   __ load_storage_props(op->tmp()->as_register(), op->array()->as_register());
   __ mov(rscratch1, (uint64_t) ArrayStorageProperties::null_free_value);
   __ cmp(op->tmp()->as_register(), rscratch1);
diff a/src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -375,11 +375,11 @@
   // build frame
   // verify_FPU(0, "method_entry");
 }
 
 int C1_MacroAssembler::scalarized_entry(const CompiledEntrySignature *ces, int frame_size_in_bytes, int bang_size_in_bytes, Label& verified_value_entry_label, bool is_value_ro_entry) {
-  // This function required to support for ValueTypePassFieldsAsArgs
+  // This function required to support for InlineTypePassFieldsAsArgs
   if (C1Breakpoint || VerifyFPU || !UseStackBanging) {
     // Verified Entry first instruction should be 5 bytes long for correct
     // patching by patch_verified_entry().
     //
     // C1Breakpoint and VerifyFPU have one byte first instruction.
@@ -390,11 +390,11 @@
   }
 
   nop();
   // verify_FPU(0, "method_entry");
 
-  assert(ValueTypePassFieldsAsArgs, "sanity");
+  assert(InlineTypePassFieldsAsArgs, "sanity");
 
   GrowableArray<SigEntry>* sig   = &ces->sig();
   GrowableArray<SigEntry>* sig_cc = is_value_ro_entry ? &ces->sig_cc_ro() : &ces->sig_cc();
   VMRegPair* regs      = ces->regs();
   VMRegPair* regs_cc   = is_value_ro_entry ? ces->regs_cc_ro() : ces->regs_cc();
diff a/src/hotspot/cpu/aarch64/globals_aarch64.hpp b/src/hotspot/cpu/aarch64/globals_aarch64.hpp
--- a/src/hotspot/cpu/aarch64/globals_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/globals_aarch64.hpp
@@ -62,12 +62,12 @@
 define_pd_global(bool, RewriteBytecodes,     true);
 define_pd_global(bool, RewriteFrequentPairs, true);
 
 define_pd_global(bool, PreserveFramePointer, false);
 
-define_pd_global(bool, ValueTypePassFieldsAsArgs, false);
-define_pd_global(bool, ValueTypeReturnedAsFields, false);
+define_pd_global(bool, InlineTypePassFieldsAsArgs, false);
+define_pd_global(bool, InlineTypeReturnedAsFields, false);
 
 define_pd_global(uintx, TypeProfileLevel, 111);
 
 define_pd_global(bool, CompactStrings, true);
 
diff a/src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp b/src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp
@@ -685,11 +685,11 @@
 
     bind(no_reserved_zone_enabling);
   }
 
 
-  if (state == atos && ValueTypeReturnedAsFields) {
+  if (state == atos && InlineTypeReturnedAsFields) {
     Label skip;
     // Test if the return type is a value type
     ldr(rscratch1, Address(rfp, frame::interpreter_frame_method_offset * wordSize));
     ldr(rscratch1, Address(rscratch1, Method::const_offset()));
     ldrb(rscratch1, Address(rscratch1, ConstMethod::result_type_offset()));
diff a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
@@ -442,11 +442,11 @@
 // the value type. This utility function computes the number of
 // arguments for the call if value types are passed by reference (the
 // calling convention the interpreter expects).
 static int compute_total_args_passed_int(const GrowableArray<SigEntry>* sig_extended) {
   int total_args_passed = 0;
-  if (ValueTypePassFieldsAsArgs) {
+  if (InlineTypePassFieldsAsArgs) {
      for (int i = 0; i < sig_extended->length(); i++) {
        BasicType bt = sig_extended->at(i)._bt;
        if (SigEntry::is_reserved_entry(sig_extended, i)) {
          // Ignore reserved entry
        } else if (bt == T_VALUETYPE) {
@@ -485,11 +485,11 @@
 }
 
 
 static void gen_c2i_adapter_helper(MacroAssembler* masm, BasicType bt, const VMRegPair& reg_pair, int extraspace, const Address& to) {
 
-    assert(bt != T_VALUETYPE || !ValueTypePassFieldsAsArgs, "no value type here");
+    assert(bt != T_VALUETYPE || !InlineTypePassFieldsAsArgs, "no inline type here");
 
     // Say 4 args:
     // i   st_off
     // 0   32 T_LONG
     // 1   24 T_VOID
@@ -558,12 +558,12 @@
 
   __ bind(skip_fixup);
 
   bool has_value_argument = false;
 
-  if (ValueTypePassFieldsAsArgs) {
-      // Is there a value type argument?
+  if (InlineTypePassFieldsAsArgs) {
+      // Is there an inline type argument?
      for (int i = 0; i < sig_extended->length() && !has_value_argument; i++) {
        has_value_argument = (sig_extended->at(i)._bt == T_VALUETYPE);
      }
      if (has_value_argument) {
       // There is at least a value type argument: we're coming from
@@ -628,11 +628,11 @@
   for (int next_arg_comp = 0; next_arg_comp < total_args_passed; next_arg_comp++) {
     BasicType bt = sig_extended->at(next_arg_comp)._bt;
     // offset to start parameters
     int st_off   = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;
 
-    if (!ValueTypePassFieldsAsArgs || bt != T_VALUETYPE) {
+    if (!InlineTypePassFieldsAsArgs || bt != T_VALUETYPE) {
 
             if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
                continue; // Ignore reserved entry
             }
 
diff a/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp b/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -367,11 +367,11 @@
     __ leave();
     __ ret(lr);
 
     // handle return types different from T_INT
     __ BIND(is_value);
-    if (ValueTypeReturnedAsFields) {
+    if (InlineTypeReturnedAsFields) {
       // Check for flattened return value
       __ cbz(r0, is_long);
       // Initialize pre-allocated buffer
       __ mov(r1, r0);
       __ andr(r1, r1, -2);
diff a/src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp b/src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -435,11 +435,11 @@
   // Restore stack bottom in case i2c adjusted stack
   __ ldr(esp, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
   // and NULL it as marker that esp is now tos until next java call
   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
 
-  if (state == atos && ValueTypeReturnedAsFields) {
+  if (state == atos && InlineTypeReturnedAsFields) {
     __ store_value_type_fields_to_buf(NULL, true);
   }
 
   __ restore_bcp();
   __ restore_locals();
diff a/src/hotspot/cpu/ppc/globals_ppc.hpp b/src/hotspot/cpu/ppc/globals_ppc.hpp
--- a/src/hotspot/cpu/ppc/globals_ppc.hpp
+++ b/src/hotspot/cpu/ppc/globals_ppc.hpp
@@ -65,12 +65,12 @@
 define_pd_global(bool, RewriteBytecodes,      true);
 define_pd_global(bool, RewriteFrequentPairs,  true);
 
 define_pd_global(bool, PreserveFramePointer,  false);
 
-define_pd_global(bool, ValueTypePassFieldsAsArgs, false);
-define_pd_global(bool, ValueTypeReturnedAsFields, false);
+define_pd_global(bool, InlineTypePassFieldsAsArgs, false);
+define_pd_global(bool, InlineTypeReturnedAsFields, false);
 
 define_pd_global(uintx, TypeProfileLevel, 111);
 
 define_pd_global(bool, CompactStrings, true);
 
diff a/src/hotspot/cpu/sparc/globals_sparc.hpp b/src/hotspot/cpu/sparc/globals_sparc.hpp
--- a/src/hotspot/cpu/sparc/globals_sparc.hpp
+++ b/src/hotspot/cpu/sparc/globals_sparc.hpp
@@ -72,12 +72,12 @@
 define_pd_global(bool, RewriteBytecodes,     true);
 define_pd_global(bool, RewriteFrequentPairs, true);
 
 define_pd_global(bool, PreserveFramePointer, false);
 
-define_pd_global(bool, ValueTypePassFieldsAsArgs, false);
-define_pd_global(bool, ValueTypeReturnedAsFields, false);
+define_pd_global(bool, InlineTypePassFieldsAsArgs, false);
+define_pd_global(bool, InlineTypeReturnedAsFields, false);
 
 define_pd_global(uintx, TypeProfileLevel, 111);
 
 define_pd_global(bool, CompactStrings, true);
 
diff a/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp b/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp
--- a/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp
@@ -526,11 +526,11 @@
   if (!result->is_illegal() && result->is_float_kind() && !result->is_xmm_register()) {
     assert(result->fpu() == 0, "result must already be on TOS");
   }
 
   ciMethod* method = compilation()->method();
-  if (ValueTypeReturnedAsFields && method->signature()->returns_never_null()) {
+  if (InlineTypeReturnedAsFields && method->signature()->returns_never_null()) {
     ciType* return_type = method->return_type();
     if (return_type->is_valuetype()) {
       ciValueKlass* vk = return_type->as_value_klass();
       if (vk->can_be_returned_as_fields()) {
 #ifndef _LP64
diff a/src/hotspot/cpu/x86/c1_MacroAssembler_x86.cpp b/src/hotspot/cpu/x86/c1_MacroAssembler_x86.cpp
--- a/src/hotspot/cpu/x86/c1_MacroAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/c1_MacroAssembler_x86.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -380,11 +380,11 @@
   // build frame
   IA32_ONLY( verify_FPU(0, "method_entry"); )
 }
 
 int C1_MacroAssembler::scalarized_entry(const CompiledEntrySignature *ces, int frame_size_in_bytes, int bang_size_in_bytes, int sp_offset_for_orig_pc, Label& verified_value_entry_label, bool is_value_ro_entry) {
-  assert(ValueTypePassFieldsAsArgs, "sanity");
+  assert(InlineTypePassFieldsAsArgs, "sanity");
   // Make sure there is enough stack space for this method's activation.
   assert(bang_size_in_bytes >= frame_size_in_bytes, "stack bang size incorrect");
   generate_stack_overflow_check(bang_size_in_bytes);
 
   GrowableArray<SigEntry>* sig    = &ces->sig();
diff a/src/hotspot/cpu/x86/c1_Runtime1_x86.cpp b/src/hotspot/cpu/x86/c1_Runtime1_x86.cpp
--- a/src/hotspot/cpu/x86/c1_Runtime1_x86.cpp
+++ b/src/hotspot/cpu/x86/c1_Runtime1_x86.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -1157,11 +1157,11 @@
             break;
           case new_value_array_id:
             // new "[QVT;"
             __ cmpl(t0, Klass::_lh_array_tag_vt_value);  // the array can be flattened.
             __ jcc(Assembler::equal, ok);
-            __ cmpl(t0, Klass::_lh_array_tag_obj_value); // the array cannot be flattened (due to ValueArrayElemMaxFlatSize, etc)
+            __ cmpl(t0, Klass::_lh_array_tag_obj_value); // the array cannot be flattened (due to InlineArrayElementMaxFlatSize, etc)
             __ jcc(Assembler::equal, ok);
             __ stop("assert(is an object or value array klass)");
             break;
           default:  ShouldNotReachHere();
           }
diff a/src/hotspot/cpu/x86/globals_x86.hpp b/src/hotspot/cpu/x86/globals_x86.hpp
--- a/src/hotspot/cpu/x86/globals_x86.hpp
+++ b/src/hotspot/cpu/x86/globals_x86.hpp
@@ -87,12 +87,12 @@
 
 define_pd_global(bool, PreserveFramePointer, false);
 
 define_pd_global(intx, InitArrayShortSize, 8*BytesPerLong);
 
-define_pd_global(bool, ValueTypePassFieldsAsArgs, LP64_ONLY(true) NOT_LP64(false));
-define_pd_global(bool, ValueTypeReturnedAsFields, LP64_ONLY(true) NOT_LP64(false));
+define_pd_global(bool, InlineTypePassFieldsAsArgs, LP64_ONLY(true) NOT_LP64(false));
+define_pd_global(bool, InlineTypeReturnedAsFields, LP64_ONLY(true) NOT_LP64(false));
 
 #define ARCH_FLAGS(develop, \
                    product, \
                    diagnostic, \
                    experimental, \
diff a/src/hotspot/cpu/x86/interp_masm_x86.cpp b/src/hotspot/cpu/x86/interp_masm_x86.cpp
--- a/src/hotspot/cpu/x86/interp_masm_x86.cpp
+++ b/src/hotspot/cpu/x86/interp_masm_x86.cpp
@@ -1151,13 +1151,13 @@
   // remove activation
   // get sender sp
   movptr(rbx,
          Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));
 
-  if (state == atos && ValueTypeReturnedAsFields) {
+  if (state == atos && InlineTypeReturnedAsFields) {
     Label skip;
-    // Test if the return type is a value type
+    // Test if the return type is an inline type
     movptr(rdi, Address(rbp, frame::interpreter_frame_method_offset * wordSize));
     movptr(rdi, Address(rdi, Method::const_offset()));
     load_unsigned_byte(rdi, Address(rdi, ConstMethod::result_type_offset()));
     cmpl(rdi, T_VALUETYPE);
     jcc(Assembler::notEqual, skip);
diff a/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp b/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp
--- a/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp
+++ b/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp
@@ -656,11 +656,11 @@
 // the value type. This utility function computes the number of
 // arguments for the call if value types are passed by reference (the
 // calling convention the interpreter expects).
 static int compute_total_args_passed_int(const GrowableArray<SigEntry>* sig_extended) {
   int total_args_passed = 0;
-  if (ValueTypePassFieldsAsArgs) {
+  if (InlineTypePassFieldsAsArgs) {
     for (int i = 0; i < sig_extended->length(); i++) {
       BasicType bt = sig_extended->at(i)._bt;
       if (SigEntry::is_reserved_entry(sig_extended, i)) {
         // Ignore reserved entry
       } else if (bt == T_VALUETYPE) {
@@ -704,11 +704,11 @@
                                    size_t size_in_bytes,
                                    const VMRegPair& reg_pair,
                                    const Address& to,
                                    int extraspace,
                                    bool is_oop) {
-  assert(bt != T_VALUETYPE || !ValueTypePassFieldsAsArgs, "no value type here");
+  assert(bt != T_VALUETYPE || !InlineTypePassFieldsAsArgs, "no inline type here");
   if (bt == T_VOID) {
     assert(prev_bt == T_LONG || prev_bt == T_DOUBLE, "missing half");
     return;
   }
 
@@ -777,12 +777,12 @@
   // compiled target.  If there is one, we need to patch the caller's call.
   patch_callers_callsite(masm);
 
   __ bind(skip_fixup);
 
-  if (ValueTypePassFieldsAsArgs) {
-    // Is there a value type argument?
+  if (InlineTypePassFieldsAsArgs) {
+    // Is there an inline type argument?
     bool has_value_argument = false;
     for (int i = 0; i < sig_extended->length() && !has_value_argument; i++) {
       has_value_argument = (sig_extended->at(i)._bt == T_VALUETYPE);
     }
     if (has_value_argument) {
@@ -858,11 +858,11 @@
        next_arg_comp < sig_extended->length(); next_arg_comp++) {
     assert(ignored <= next_arg_comp, "shouldn't skip over more slots than there are arguments");
     assert(next_arg_int <= total_args_passed, "more arguments for the interpreter than expected?");
     BasicType bt = sig_extended->at(next_arg_comp)._bt;
     int st_off = (total_args_passed - next_arg_int) * Interpreter::stackElementSize;
-    if (!ValueTypePassFieldsAsArgs || bt != T_VALUETYPE) {
+    if (!InlineTypePassFieldsAsArgs || bt != T_VALUETYPE) {
       if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
         continue; // Ignore reserved entry
       }
       int next_off = st_off - Interpreter::stackElementSize;
       const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
@@ -4420,11 +4420,11 @@
     }
     j++;
   }
   assert(j == regs->length(), "missed a field?");
 
-  if (StressValueTypeReturnedAsFields) {
+  if (StressInlineTypeReturnedAsFields) {
     __ load_klass(rax, rax);
     __ orptr(rax, 1);
   }
 
   __ ret(0);
diff a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp
--- a/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp
+++ b/src/hotspot/cpu/x86/stubGenerator_x86_64.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -413,11 +413,11 @@
     __ pop(rbp);
     __ ret(0);
 
     // handle return types different from T_INT
     __ BIND(is_value);
-    if (ValueTypeReturnedAsFields) {
+    if (InlineTypeReturnedAsFields) {
       // Check for flattened return value
       __ testptr(rax, 1);
       __ jcc(Assembler::zero, is_long);
       // Load pack handler address
       __ andptr(rax, -2);
diff a/src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp b/src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp
--- a/src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp
+++ b/src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -204,11 +204,11 @@
   // Restore stack bottom in case i2c adjusted stack
   __ movptr(rsp, Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize));
   // and NULL it as marker that esp is now tos until next java call
   __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);
 
-  if (state == atos && ValueTypeReturnedAsFields) {
+  if (state == atos && InlineTypeReturnedAsFields) {
     __ store_value_type_fields_to_buf(NULL);
   }
 
   __ restore_bcp();
   __ restore_locals();
diff a/src/hotspot/cpu/zero/globals_zero.hpp b/src/hotspot/cpu/zero/globals_zero.hpp
--- a/src/hotspot/cpu/zero/globals_zero.hpp
+++ b/src/hotspot/cpu/zero/globals_zero.hpp
@@ -68,12 +68,12 @@
 
 define_pd_global(uintx, TypeProfileLevel, 0);
 
 define_pd_global(bool, PreserveFramePointer, false);
 
-define_pd_global(bool, ValueTypePassFieldsAsArgs, false);
-define_pd_global(bool, ValueTypeReturnedAsFields, false);
+define_pd_global(bool, InlineTypePassFieldsAsArgs, false);
+define_pd_global(bool, InlineTypeReturnedAsFields, false);
 
 // No performance work done here yet.
 define_pd_global(bool, CompactStrings, false);
 
 #define ARCH_FLAGS(develop, \
diff a/src/hotspot/share/c1/c1_LIR.cpp b/src/hotspot/share/c1/c1_LIR.cpp
--- a/src/hotspot/share/c1/c1_LIR.cpp
+++ b/src/hotspot/share/c1/c1_LIR.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -1042,11 +1042,11 @@
 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
   masm->emit_call(this);
 }
 
 bool LIR_OpJavaCall::maybe_return_as_fields(ciValueKlass** vk_ret) const {
-  if (ValueTypeReturnedAsFields) {
+  if (InlineTypeReturnedAsFields) {
     if (method()->signature()->maybe_returns_never_null()) {
       ciType* return_type = method()->return_type();
       if (return_type->is_valuetype()) {
         ciValueKlass* vk = return_type->as_value_klass();
         if (vk->can_be_returned_as_fields()) {
diff a/src/hotspot/share/c1/c1_LIRAssembler.cpp b/src/hotspot/share/c1/c1_LIRAssembler.cpp
--- a/src/hotspot/share/c1/c1_LIRAssembler.cpp
+++ b/src/hotspot/share/c1/c1_LIRAssembler.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -649,11 +649,11 @@
   offsets()->set_value(CodeOffsets::OSR_Entry, _masm->offset());
 
   _masm->align(CodeEntryAlignment);
   const CompiledEntrySignature* ces = compilation()->compiled_entry_signature();
   if (ces->has_scalarized_args()) {
-    assert(ValueTypePassFieldsAsArgs && method()->get_Method()->has_scalarized_args(), "must be");
+    assert(InlineTypePassFieldsAsArgs && method()->get_Method()->has_scalarized_args(), "must be");
     CodeOffsets::Entries ro_entry_type = ces->c1_value_ro_entry_type();
 
     // UEP: check icache and fall-through
     if (ro_entry_type != CodeOffsets::Verified_Value_Entry) {
       offsets()->set_value(CodeOffsets::Entry, _masm->offset());
diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -4417,12 +4417,12 @@
       if (!klass->access_flags().is_inline_type()) {
         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
       }
       ValueKlass* vk = ValueKlass::cast(klass);
       // Conditions to apply flattening or not should be defined in a single place
-      bool too_big_to_flatten = (ValueFieldMaxFlatSize >= 0 &&
-                                 (vk->size_helper() * HeapWordSize) > ValueFieldMaxFlatSize);
+      bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&
+                                 (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);
       bool too_atomic_to_flatten = vk->is_declared_atomic();
       bool too_volatile_to_flatten = fs.access_flags().is_volatile();
       if (vk->is_naturally_atomic()) {
         too_atomic_to_flatten = false;
         //too_volatile_to_flatten = false; //FIXME
@@ -4873,11 +4873,11 @@
   // Number of non-static oop map blocks allocated at end of klass.
   nonstatic_oop_maps->compact();
 
 #ifndef PRODUCT
   if ((PrintFieldLayout && !is_inline_type()) ||
-      (PrintValueLayout && (is_inline_type() || has_nonstatic_value_fields))) {
+      (PrintInlineLayout && (is_inline_type() || has_nonstatic_value_fields))) {
     print_field_layout(_class_name,
           _fields,
           cp,
           instance_size,
           nonstatic_fields_start,
diff a/src/hotspot/share/classfile/fieldLayoutBuilder.cpp b/src/hotspot/share/classfile/fieldLayoutBuilder.cpp
--- a/src/hotspot/share/classfile/fieldLayoutBuilder.cpp
+++ b/src/hotspot/share/classfile/fieldLayoutBuilder.cpp
@@ -628,12 +628,12 @@
             SystemDictionary::resolve_flattenable_field_or_fail(&fs,
                                                                 Handle(THREAD, _class_loader_data->class_loader()),
                                                                 _protection_domain, true, THREAD);
         assert(klass != NULL, "Sanity check");
         ValueKlass* vk = ValueKlass::cast(klass);
-        bool too_big_to_flatten = (ValueFieldMaxFlatSize >= 0 &&
-                                   (vk->size_helper() * HeapWordSize) > ValueFieldMaxFlatSize);
+        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&
+                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);
         bool too_atomic_to_flatten = vk->is_declared_atomic();
         bool too_volatile_to_flatten = fs.access_flags().is_volatile();
         if (vk->is_naturally_atomic()) {
           too_atomic_to_flatten = false;
           //too_volatile_to_flatten = false; //FIXME
@@ -728,12 +728,12 @@
             SystemDictionary::resolve_flattenable_field_or_fail(&fs,
                 Handle(THREAD, _class_loader_data->class_loader()),
                 _protection_domain, true, CHECK);
         assert(klass != NULL, "Sanity check");
         ValueKlass* vk = ValueKlass::cast(klass);
-        bool too_big_to_flatten = (ValueFieldMaxFlatSize >= 0 &&
-                                   (vk->size_helper() * HeapWordSize) > ValueFieldMaxFlatSize);
+        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&
+                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);
         bool too_atomic_to_flatten = vk->is_declared_atomic();
         bool too_volatile_to_flatten = fs.access_flags().is_volatile();
         if (vk->is_naturally_atomic()) {
           too_atomic_to_flatten = false;
           //too_volatile_to_flatten = false; //FIXME
diff a/src/hotspot/share/oops/valueArrayKlass.cpp b/src/hotspot/share/oops/valueArrayKlass.cpp
--- a/src/hotspot/share/oops/valueArrayKlass.cpp
+++ b/src/hotspot/share/oops/valueArrayKlass.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -65,11 +65,11 @@
   assert(is_array_klass(), "sanity");
   assert(is_valueArray_klass(), "sanity");
 
   CMH("tweak name symbol refcnt ?")
 #ifndef PRODUCT
-  if (PrintValueArrayLayout) {
+  if (PrintInlineArrayLayout) {
     print();
   }
 #endif
 }
 
@@ -82,11 +82,11 @@
 }
 
 ValueArrayKlass* ValueArrayKlass::allocate_klass(Klass* element_klass, TRAPS) {
   guarantee((!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()), "Really ?!");
   assert(ValueArrayFlatten, "Flatten array required");
-  assert(ValueKlass::cast(element_klass)->is_naturally_atomic() || (!ValueArrayAtomicAccess), "Atomic by-default");
+  assert(ValueKlass::cast(element_klass)->is_naturally_atomic() || (!InlineArrayAtomicAccess), "Atomic by-default");
 
   /*
    *  MVT->LWorld, now need to allocate secondaries array types, just like objArrayKlass...
    *  ...so now we are trying out covariant array types, just copy objArrayKlass
    *  TODO refactor any remaining commonality
diff a/src/hotspot/share/oops/valueKlass.cpp b/src/hotspot/share/oops/valueKlass.cpp
--- a/src/hotspot/share/oops/valueKlass.cpp
+++ b/src/hotspot/share/oops/valueKlass.cpp
@@ -180,23 +180,23 @@
   if (!ValueArrayFlatten) {
     return false;
   }
   // Too big
   int elem_bytes = raw_value_byte_size();
-  if ((ValueArrayElemMaxFlatSize >= 0) && (elem_bytes > ValueArrayElemMaxFlatSize)) {
+  if ((InlineArrayElemMaxFlatSize >= 0) && (elem_bytes > InlineArrayElemMaxFlatSize)) {
     return false;
   }
   // Too many embedded oops
-  if ((ValueArrayElemMaxFlatOops >= 0) && (nonstatic_oop_count() > ValueArrayElemMaxFlatOops)) {
+  if ((InlineArrayElemMaxFlatOops >= 0) && (nonstatic_oop_count() > InlineArrayElemMaxFlatOops)) {
     return false;
   }
   // Declared atomic but not naturally atomic.
   if (is_declared_atomic() && !is_naturally_atomic()) {
     return false;
   }
-  // VM enforcing ValueArrayAtomicAccess only...
-  if (ValueArrayAtomicAccess && (!is_naturally_atomic())) {
+  // VM enforcing InlineArrayAtomicAccess only...
+  if (InlineArrayAtomicAccess && (!is_naturally_atomic())) {
     return false;
   }
   return true;
 }
 
@@ -314,21 +314,21 @@
 
 void ValueKlass::initialize_calling_convention(TRAPS) {
   // Because the pack and unpack handler addresses need to be loadable from generated code,
   // they are stored at a fixed offset in the klass metadata. Since value type klasses do
   // not have a vtable, the vtable offset is used to store these addresses.
-  if (is_scalarizable() && (ValueTypeReturnedAsFields || ValueTypePassFieldsAsArgs)) {
+  if (is_scalarizable() && (InlineTypeReturnedAsFields || InlineTypePassFieldsAsArgs)) {
     ResourceMark rm;
     GrowableArray<SigEntry> sig_vk;
     int nb_fields = collect_fields(&sig_vk);
     Array<SigEntry>* extended_sig = MetadataFactory::new_array<SigEntry>(class_loader_data(), sig_vk.length(), CHECK);
     *((Array<SigEntry>**)adr_extended_sig()) = extended_sig;
     for (int i = 0; i < sig_vk.length(); i++) {
       extended_sig->at_put(i, sig_vk.at(i));
     }
 
-    if (ValueTypeReturnedAsFields) {
+    if (InlineTypeReturnedAsFields) {
       nb_fields++;
       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, nb_fields);
       sig_bt[0] = T_METADATA;
       SigEntry::fill_sig_bt(&sig_vk, sig_bt+1);
       VMRegPair* regs = NEW_RESOURCE_ARRAY(VMRegPair, nb_fields);
@@ -375,13 +375,13 @@
     *((address*)adr_pack_handler_jobject()) = NULL;
     *((address*)adr_unpack_handler()) = NULL;
   }
 }
 
-// Can this value type be scalarized?
+// Can this inline type be scalarized?
 bool ValueKlass::is_scalarizable() const {
-  return ScalarizeValueTypes;
+  return ScalarizeInlineTypes;
 }
 
 // Can this value type be returned as multiple values?
 bool ValueKlass::can_be_returned_as_fields() const {
   return return_regs() != NULL;
@@ -417,11 +417,11 @@
   assert(j == regs->length(), "missed a field?");
 }
 
 // Update oop fields in registers from handles after a safepoint
 void ValueKlass::restore_oop_results(RegisterMap& reg_map, GrowableArray<Handle>& handles) const {
-  assert(ValueTypeReturnedAsFields, "inconsistent");
+  assert(InlineTypeReturnedAsFields, "inconsistent");
   const Array<SigEntry>* sig_vk = extended_sig();
   const Array<VMRegPair>* regs = return_regs();
   assert(regs != NULL, "inconsistent");
 
   int j = 1;
diff a/src/hotspot/share/opto/callGenerator.cpp b/src/hotspot/share/opto/callGenerator.cpp
--- a/src/hotspot/share/opto/callGenerator.cpp
+++ b/src/hotspot/share/opto/callGenerator.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -124,11 +124,11 @@
   DirectCallGenerator(ciMethod* method, bool separate_io_proj)
     : CallGenerator(method),
       _call_node(NULL),
       _separate_io_proj(separate_io_proj)
   {
-    if (ValueTypeReturnedAsFields && method->is_method_handle_intrinsic()) {
+    if (InlineTypeReturnedAsFields && method->is_method_handle_intrinsic()) {
       // If that call has not been optimized by the time optimizations are over,
       // we'll need to add a call to create a value type instance from the klass
       // returned by the call (see PhaseMacroExpand::expand_mh_intrinsic_return).
       // Separating memory and I/O projections for exceptions is required to
       // perform that graph transformation.
diff a/src/hotspot/share/opto/callnode.cpp b/src/hotspot/share/opto/callnode.cpp
--- a/src/hotspot/share/opto/callnode.cpp
+++ b/src/hotspot/share/opto/callnode.cpp
@@ -732,11 +732,11 @@
         return new MachProjNode(this,con, RegMask::Empty, (uint)OptoReg::Bad);
       }
     } else {
       // The Call may return multiple values (value type fields): we
       // create one projection per returned values.
-      assert(con <= TypeFunc::Parms+1 || ValueTypeReturnedAsFields, "only for multi value return");
+      assert(con <= TypeFunc::Parms+1 || InlineTypeReturnedAsFields, "only for multi value return");
       uint ideal_reg = range_cc->field_at(con)->ideal_reg();
       return new MachProjNode(this, con, mask[con-TypeFunc::Parms], ideal_reg);
     }
   }
 
diff a/src/hotspot/share/opto/callnode.hpp b/src/hotspot/share/opto/callnode.hpp
--- a/src/hotspot/share/opto/callnode.hpp
+++ b/src/hotspot/share/opto/callnode.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -658,11 +658,11 @@
   virtual uint match_edge(uint idx) const;
 
   bool is_call_to_arraycopystub() const;
 
   virtual void copy_call_debug_info(PhaseIterGVN* phase, CallNode *oldcall) {}
-  
+
 #ifndef PRODUCT
   virtual void        dump_req(outputStream *st = tty) const;
   virtual void        dump_spec(outputStream *st) const;
 #endif
 };
@@ -731,11 +731,11 @@
     if (C->eliminate_boxing() && (method != NULL) && method->is_boxing_method()) {
       init_flags(Flag_is_macro);
       C->add_macro_node(this);
     }
     const TypeTuple *r = tf->range_sig();
-    if (ValueTypeReturnedAsFields &&
+    if (InlineTypeReturnedAsFields &&
         method != NULL &&
         method->is_method_handle_intrinsic() &&
         r->cnt() > TypeFunc::Parms &&
         r->field_at(TypeFunc::Parms)->isa_oopptr() &&
         r->field_at(TypeFunc::Parms)->is_oopptr()->can_be_value_type()) {
diff a/src/hotspot/share/opto/matcher.cpp b/src/hotspot/share/opto/matcher.cpp
--- a/src/hotspot/share/opto/matcher.cpp
+++ b/src/hotspot/share/opto/matcher.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -179,11 +179,11 @@
   if (cnt == 0) {
     return NULL;
   }
   RegMask* mask = NEW_RESOURCE_ARRAY(RegMask, cnt);
 
-  if (!ValueTypeReturnedAsFields) {
+  if (!InlineTypeReturnedAsFields) {
     // Get ideal-register return type
     uint ireg = range->field_at(TypeFunc::Parms)->ideal_reg();
     // Get machine return register
     OptoRegPair regs = return_value(ireg, false);
 
diff a/src/hotspot/share/opto/parse1.cpp b/src/hotspot/share/opto/parse1.cpp
--- a/src/hotspot/share/opto/parse1.cpp
+++ b/src/hotspot/share/opto/parse1.cpp
@@ -931,11 +931,11 @@
       // Multiple return values (value type fields): add as many edges
       // to the Return node as returned values.
       assert(res->is_ValueType(), "what else supports multi value return?");
       ValueTypeNode* vt = res->as_ValueType();
       ret->add_req_batch(NULL, tf()->range_cc()->cnt() - TypeFunc::Parms);
-      if (vt->is_allocated(&kit.gvn()) && !StressValueTypeReturnedAsFields) {
+      if (vt->is_allocated(&kit.gvn()) && !StressInlineTypeReturnedAsFields) {
         ret->init_req(TypeFunc::Parms, vt->get_oop());
       } else {
         ret->init_req(TypeFunc::Parms, vt->tagged_klass(kit.gvn()));
       }
       const Array<SigEntry>* sig_array = vt->type()->value_klass()->extended_sig();
diff a/src/hotspot/share/runtime/arguments.cpp b/src/hotspot/share/runtime/arguments.cpp
--- a/src/hotspot/share/runtime/arguments.cpp
+++ b/src/hotspot/share/runtime/arguments.cpp
@@ -2122,18 +2122,18 @@
   }
 #endif
 
   status = status && GCArguments::check_args_consistency();
 
-  if (AMD64_ONLY(false &&) !FLAG_IS_DEFAULT(ValueTypePassFieldsAsArgs)) {
-    FLAG_SET_CMDLINE(ValueTypePassFieldsAsArgs, false);
-    warning("ValueTypePassFieldsAsArgs is not supported on this platform");
+  if (AMD64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypePassFieldsAsArgs)) {
+    FLAG_SET_CMDLINE(InlineTypePassFieldsAsArgs, false);
+    warning("InlineTypePassFieldsAsArgs is not supported on this platform");
   }
 
-  if (AMD64_ONLY(false &&) !FLAG_IS_DEFAULT(ValueTypeReturnedAsFields)) {
-    FLAG_SET_CMDLINE(ValueTypeReturnedAsFields, false);
-    warning("ValueTypeReturnedAsFields is not supported on this platform");
+  if (AMD64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypeReturnedAsFields)) {
+    FLAG_SET_CMDLINE(InlineTypeReturnedAsFields, false);
+    warning("InlineTypeReturnedAsFields is not supported on this platform");
   }
 
   return status;
 }
 
@@ -4137,12 +4137,12 @@
     log_info(verification)("Turning on remote verification because local verification is on");
     FLAG_SET_DEFAULT(BytecodeVerificationRemote, true);
   }
   if (!EnableValhalla || (is_interpreter_only() && !is_dumping_archive())) {
     // Disable calling convention optimizations if value types are not supported
-    ValueTypePassFieldsAsArgs = false;
-    ValueTypeReturnedAsFields = false;
+    InlineTypePassFieldsAsArgs = false;
+    InlineTypeReturnedAsFields = false;
   }
 
 #ifndef PRODUCT
   if (!LogVMOutput && FLAG_IS_DEFAULT(LogVMOutput)) {
     if (use_vm_log()) {
diff a/src/hotspot/share/runtime/globals.hpp b/src/hotspot/share/runtime/globals.hpp
--- a/src/hotspot/share/runtime/globals.hpp
+++ b/src/hotspot/share/runtime/globals.hpp
@@ -763,27 +763,27 @@
           "Use SSE2 MOVQ instruction for Arraycopy")                        \
                                                                             \
   notproduct(bool, PrintFieldLayout, false,                                 \
           "Print field layout for each class")                              \
                                                                             \
-  notproduct(bool, PrintValueLayout, false,                                 \
-          "Print field layout for each value type")                         \
+  notproduct(bool, PrintInlineLayout, false,                                \
+          "Print field layout for each inline type")                        \
                                                                             \
-  notproduct(bool, PrintValueArrayLayout, false,                            \
-          "Print array layout for each value type array")                   \
+  notproduct(bool, PrintInlineArrayLayout, false,                           \
+          "Print array layout for each inline type array")                  \
                                                                             \
-  product(intx, ValueArrayElemMaxFlatSize, -1,                              \
-          "Max size for flattening value array elements, <0 no limit")      \
+  product(intx, InlineArrayElemMaxFlatSize, -1,                             \
+          "Max size for flattening inline array elements, <0 no limit")     \
                                                                             \
-  product(intx, ValueFieldMaxFlatSize, 128,                                 \
-          "Max size for flattening value type fields, <0 no limit")         \
+  product(intx, InlineFieldMaxFlatSize, 128,                                \
+          "Max size for flattening inline type fields, <0 no limit")        \
                                                                             \
-  product(intx, ValueArrayElemMaxFlatOops, 4,                               \
-          "Max nof embedded object references in a value type to flatten, <0 no limit")  \
+  product(intx, InlineArrayElemMaxFlatOops, 4,                              \
+          "Max nof embedded object references in an inline type to flatten, <0 no limit")  \
                                                                             \
-  product(bool, ValueArrayAtomicAccess, false,                              \
-          "Atomic value array accesses by-default, for all value arrays")   \
+  product(bool, InlineArrayAtomicAccess, false,                             \
+          "Atomic inline array accesses by-default, for all inline arrays") \
                                                                             \
   /* Need to limit the extent of the padding to reasonable size.          */\
   /* 8K is well beyond the reasonable HW cache line size, even with       */\
   /* aggressive prefetching, while still leaving the room for segregating */\
   /* among the distinct pages.                                            */\
@@ -2496,21 +2496,21 @@
           "Use platform unstable time where supported for timestamps only") \
                                                                             \
   product(bool, EnableValhalla, true,                                       \
           "Enable experimental Valhalla features")                          \
                                                                             \
-  product_pd(bool, ValueTypePassFieldsAsArgs,                               \
-          "Pass each value type field as an argument at calls")             \
+  product_pd(bool, InlineTypePassFieldsAsArgs,                              \
+          "Pass each inline type field as an argument at calls")            \
                                                                             \
-  product_pd(bool, ValueTypeReturnedAsFields,                               \
-          "Return fields instead of a value type reference")                \
+  product_pd(bool, InlineTypeReturnedAsFields,                              \
+          "Return fields instead of an inline type reference")              \
                                                                             \
-  develop(bool, StressValueTypeReturnedAsFields, false,                     \
-          "Stress return of fields instead of a value type reference")      \
+  develop(bool, StressInlineTypeReturnedAsFields, false,                    \
+          "Stress return of fields instead of an inline type reference")    \
                                                                             \
-  develop(bool, ScalarizeValueTypes, true,                                  \
-          "Scalarize value types in compiled code")                         \
+  develop(bool, ScalarizeInlineTypes, true,                                 \
+          "Scalarize inline types in compiled code")                        \
                                                                             \
   diagnostic(ccstrlist, ForceNonTearable, "",                               \
           "List of inline classes which are forced to be atomic "           \
           "(whitespace and commas separate names, "                         \
           "and leading and trailing stars '*' are wildcards)")              \
diff a/src/hotspot/share/runtime/javaCalls.cpp b/src/hotspot/share/runtime/javaCalls.cpp
--- a/src/hotspot/share/runtime/javaCalls.cpp
+++ b/src/hotspot/share/runtime/javaCalls.cpp
@@ -440,11 +440,11 @@
     }
   }
 #endif
 
   jobject value_buffer = NULL;
-  if (ValueTypeReturnedAsFields && result->get_type() == T_VALUETYPE) {
+  if (InlineTypeReturnedAsFields && result->get_type() == T_VALUETYPE) {
     // Pre allocate buffered value in case the result is returned
     // flattened by compiled code
     ValueKlass* vk = method->returned_value_type(thread);
     if (vk->can_be_returned_as_fields()) {
       oop instance = vk->allocate_instance(CHECK);
diff a/src/hotspot/share/runtime/safepoint.cpp b/src/hotspot/share/runtime/safepoint.cpp
--- a/src/hotspot/share/runtime/safepoint.cpp
+++ b/src/hotspot/share/runtime/safepoint.cpp
@@ -1042,11 +1042,11 @@
     bool return_oop = method->is_returning_oop();
 
     GrowableArray<Handle> return_values;
     ValueKlass* vk = NULL;
 
-    if (return_oop && ValueTypeReturnedAsFields) {
+    if (return_oop && InlineTypeReturnedAsFields) {
       SignatureStream ss(method->signature());
       while (!ss.at_return_type()) {
         ss.next();
       }
       if (ss.type() == T_VALUETYPE) {
diff a/src/hotspot/share/runtime/sharedRuntime.cpp b/src/hotspot/share/runtime/sharedRuntime.cpp
--- a/src/hotspot/share/runtime/sharedRuntime.cpp
+++ b/src/hotspot/share/runtime/sharedRuntime.cpp
@@ -1282,12 +1282,12 @@
   bool is_nmethod = caller_nm->is_nmethod();
   bool caller_is_c1 = caller_nm->is_compiled_by_c1();
 
   if (is_virtual) {
     Klass* receiver_klass = NULL;
-    if (ValueTypePassFieldsAsArgs && !caller_is_c1 && callee_method->method_holder()->is_value()) {
-      // If the receiver is a value type that is passed as fields, no oop is available
+    if (InlineTypePassFieldsAsArgs && !caller_is_c1 && callee_method->method_holder()->is_value()) {
+      // If the receiver is an inline type that is passed as fields, no oop is available
       receiver_klass = callee_method->method_holder();
     } else {
       assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, "sanity check");
       receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver->klass();
     }
@@ -2358,23 +2358,23 @@
       case T_BOOLEAN:
       case T_BYTE:
       case T_SHORT:
       case T_CHAR: {
         if (is_valuetype) {
-          // Do not widen value type field types
-          assert(ValueTypePassFieldsAsArgs, "must be enabled");
+          // Do not widen inline type field types
+          assert(InlineTypePassFieldsAsArgs, "must be enabled");
           return in;
         } else {
           // They are all promoted to T_INT in the calling convention
           return T_INT;
         }
       }
 
       case T_VALUETYPE: {
-        // If value types are passed as fields, return 'in' to differentiate
+        // If inline types are passed as fields, return 'in' to differentiate
         // between a T_VALUETYPE and a T_OBJECT in the signature.
-        return ValueTypePassFieldsAsArgs ? in : adapter_encoding(T_OBJECT, false);
+        return InlineTypePassFieldsAsArgs ? in : adapter_encoding(T_OBJECT, false);
       }
 
       case T_OBJECT:
       case T_ARRAY:
         // In other words, we assume that any register good enough for
@@ -2426,21 +2426,21 @@
       int value = 0;
       for (int byte = 0; byte < _basic_types_per_int; byte++) {
         int bt = 0;
         if (sig_index < total_args_passed) {
           BasicType sbt = sig->at(sig_index++)._bt;
-          if (ValueTypePassFieldsAsArgs && sbt == T_VALUETYPE) {
-            // Found start of value type in signature
+          if (InlineTypePassFieldsAsArgs && sbt == T_VALUETYPE) {
+            // Found start of inline type in signature
             vt_count++;
             if (sig_index == 1 && has_ro_adapter) {
               // With a ro_adapter, replace receiver value type delimiter by T_VOID to prevent matching
               // with other adapters that have the same value type as first argument and no receiver.
               sbt = T_VOID;
             }
-          } else if (ValueTypePassFieldsAsArgs && sbt == T_VOID &&
+          } else if (InlineTypePassFieldsAsArgs && sbt == T_VOID &&
                      prev_sbt != T_LONG && prev_sbt != T_DOUBLE) {
-            // Found end of value type in signature
+            // Found end of inline type in signature
             vt_count--;
             assert(vt_count >= 0, "invalid vt_count");
           }
           bt = adapter_encoding(sbt, vt_count > 0);
           prev_sbt = sbt;
@@ -2846,11 +2846,11 @@
       }
       bt = T_OBJECT;
     }
     SigEntry::add_entry(_sig, bt);
   }
-  if (_method->is_abstract() && !(ValueTypePassFieldsAsArgs && has_value_arg())) {
+  if (_method->is_abstract() && !(InlineTypePassFieldsAsArgs && has_value_arg())) {
     return;
   }
 
   // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage
   _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig->length());
@@ -2862,11 +2862,11 @@
   _regs_cc = _regs;
   _regs_cc_ro = _regs;
   _args_on_stack_cc = _args_on_stack;
   _args_on_stack_cc_ro = _args_on_stack;
 
-  if (ValueTypePassFieldsAsArgs && has_value_arg() && !_method->is_native()) {
+  if (InlineTypePassFieldsAsArgs && has_value_arg() && !_method->is_native()) {
     _args_on_stack_cc = compute_scalarized_cc(_sig_cc, _regs_cc, /* scalar_receiver = */ true);
 
     _sig_cc_ro = _sig_cc;
     _regs_cc_ro = _regs_cc;
     _args_on_stack_cc_ro = _args_on_stack_cc;
@@ -3577,11 +3577,11 @@
 // We are at a compiled code to interpreter call. We need backing
 // buffers for all value type arguments. Allocate an object array to
 // hold them (convenient because once we're done with it we don't have
 // to worry about freeing it).
 oop SharedRuntime::allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS) {
-  assert(ValueTypePassFieldsAsArgs, "no reason to call this");
+  assert(InlineTypePassFieldsAsArgs, "no reason to call this");
   ResourceMark rm;
 
   int nb_slots = 0;
   InstanceKlass* holder = callee->method_holder();
   allocate_receiver &= !callee->is_static() && holder->is_value();
@@ -3623,11 +3623,11 @@
 // TODO remove this once the AARCH64 dependency is gone
 // Iterate over the array of heap allocated value types and apply the GC post barrier to all reference fields.
 // This is called from the C2I adapter after value type arguments are heap allocated and initialized.
 JRT_LEAF(void, SharedRuntime::apply_post_barriers(JavaThread* thread, objArrayOopDesc* array))
 {
-  assert(ValueTypePassFieldsAsArgs, "no reason to call this");
+  assert(InlineTypePassFieldsAsArgs, "no reason to call this");
   assert(oopDesc::is_oop(array), "should be oop");
   for (int i = 0; i < array->length(); ++i) {
     instanceOop valueOop = (instanceOop)array->obj_at(i);
     ValueKlass* vk = ValueKlass::cast(valueOop->klass());
     if (vk->contains_oops()) {
diff a/src/hotspot/share/utilities/globalDefinitions.hpp b/src/hotspot/share/utilities/globalDefinitions.hpp
--- a/src/hotspot/share/utilities/globalDefinitions.hpp
+++ b/src/hotspot/share/utilities/globalDefinitions.hpp
@@ -1218,11 +1218,11 @@
   return k0 == k1;
 }
 
 // TEMP!!!!
 // This should be removed after LW2 arrays are implemented (JDK-8220790).
-// It's an alias to (EnableValhalla && (ValueArrayElemMaxFlatSize != 0)),
+// It's an alias to (EnableValhalla && (InlineArrayElemMaxFlatSize != 0)),
 // which is actually not 100% correct, but works for the current set of C1/C2
 // implementation and test cases.
-#define ValueArrayFlatten (EnableValhalla && (ValueArrayElemMaxFlatSize != 0))
+#define ValueArrayFlatten (EnableValhalla && (InlineArrayElemMaxFlatSize != 0))
 
 #endif // SHARE_UTILITIES_GLOBALDEFINITIONS_HPP
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
@@ -59,11 +59,11 @@
     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
     @Override
     public String[] getExtraVMParameters(int scenario) {
         switch (scenario) {
         case 2: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:-UncommonNullCast", "-XX:+StressArrayCopyMacroNode"};
-        case 3: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:ValueArrayElemMaxFlatSize=-1", "-XX:-UncommonNullCast"};
+        case 3: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:InlineArrayElemMaxFlatSize=-1", "-XX:-UncommonNullCast"};
         case 4: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:-UncommonNullCast"};
         case 5: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:-UncommonNullCast", "-XX:+StressArrayCopyMacroNode"};
         }
         return null;
     }
@@ -1914,12 +1914,12 @@
         Asserts.assertEquals(array2[2], i);
         Asserts.assertEquals(result, i);
     }
 
     // Verify that writing an object of a non-flattenable inline type to an array marks the array as not-flat
-    @Test(valid = ValueTypePassFieldsAsArgsOn, failOn = ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE)
-    @Test(valid = ValueTypePassFieldsAsArgsOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE)
+    @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE)
+    @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE)
     public Object test82(Object[] array, NotFlattenable vt, Object o, int i) {
         array[0] = vt;
         array[1] = array[0];
         array[2] = o;
         return array[i];
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBasicFunctionality.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBasicFunctionality.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBasicFunctionality.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBasicFunctionality.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -41,11 +41,11 @@
     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
     @Override
     public String[] getExtraVMParameters(int scenario) {
         switch (scenario) {
         case 2: return new String[] {"-DVerifyIR=false"};
-        case 3: return new String[] {"-XX:ValueArrayElemMaxFlatSize=0"};
+        case 3: return new String[] {"-XX:InlineArrayElemMaxFlatSize=0"};
         }
         return null;
     }
 
     public static void main(String[] args) throws Throwable {
@@ -88,12 +88,12 @@
         long result = test2(v);
         Asserts.assertEQ(result, hash());
     }
 
     // Return incoming value type without accessing fields
-    @Test(valid = ValueTypePassFieldsAsArgsOn, match = {ALLOC, STORE}, matchCount = {1, 14}, failOn = LOAD + TRAP)
-    @Test(valid = ValueTypePassFieldsAsArgsOff, failOn = ALLOC + LOAD + STORE + TRAP)
+    @Test(valid = InlineTypePassFieldsAsArgsOn, match = {ALLOC, STORE}, matchCount = {1, 14}, failOn = LOAD + TRAP)
+    @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = ALLOC + LOAD + STORE + TRAP)
     public MyValue1 test3(MyValue1 v) {
         return v;
     }
 
     @DontCompile
@@ -137,12 +137,12 @@
         Asserts.assertEQ(result, hash());
     }
 
     // Create a value type in compiled code and pass it to
     // the interpreter via a call.
-    @Test(valid = ValueTypePassFieldsAsArgsOn, failOn = LOAD + TRAP + ALLOC)
-    @Test(valid = ValueTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD + TRAP)
+    @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = LOAD + TRAP + ALLOC)
+    @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD + TRAP)
     public long test6() {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
         // Pass to interpreter
         return v.hashInterpreted();
     }
@@ -183,12 +183,12 @@
         Asserts.assertEQ(test8(true), hash());
         Asserts.assertEQ(test8(false), hash(rI + 1, rL + 1));
     }
 
     // Merge value types created from two branches
-    @Test(valid = ValueTypePassFieldsAsArgsOn, match = {LOAD}, matchCount = {12}, failOn = TRAP + ALLOC + STORE)
-    @Test(valid = ValueTypePassFieldsAsArgsOff, match = {ALLOC, STORE}, matchCount = {1, 12}, failOn = LOAD + TRAP)
+    @Test(valid = InlineTypePassFieldsAsArgsOn, match = {LOAD}, matchCount = {12}, failOn = TRAP + ALLOC + STORE)
+    @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC, STORE}, matchCount = {1, 12}, failOn = LOAD + TRAP)
     public MyValue1 test9(boolean b, int localrI, long localrL) {
         MyValue1 v;
         if (b) {
             // Value type is not allocated
             // Do not use rI/rL directly here as null values may cause
@@ -312,12 +312,12 @@
         Asserts.assertEQ(result, warmup ? rL + (1000 * rI) : ((Math.abs(rI) % 10) + 1) * hash());
     }
 
     // Create a value type in a non-inlined method and then call a
     // non-inlined method on that value type.
-    @Test(valid = ValueTypePassFieldsAsArgsOn, failOn = (ALLOC + STORE + TRAP), match = {LOAD}, matchCount = {12})
-    @Test(valid = ValueTypePassFieldsAsArgsOff, failOn = (ALLOC + LOAD + STORE + TRAP))
+    @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = (ALLOC + STORE + TRAP), match = {LOAD}, matchCount = {12})
+    @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = (ALLOC + LOAD + STORE + TRAP))
     public long test14() {
         MyValue1 v = MyValue1.createWithFieldsDontInline(rI, rL);
         return v.hashInterpreted();
     }
 
@@ -327,12 +327,12 @@
         Asserts.assertEQ(result, hash());
     }
 
     // Create a value type in an inlined method and then call a
     // non-inlined method on that value type.
-    @Test(valid = ValueTypePassFieldsAsArgsOn, failOn = (LOAD + TRAP + ALLOC))
-    @Test(valid = ValueTypePassFieldsAsArgsOff, failOn = (LOAD + TRAP), match = {ALLOC}, matchCount = {1})
+    @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = (LOAD + TRAP + ALLOC))
+    @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = (LOAD + TRAP), match = {ALLOC}, matchCount = {1})
     public long test15() {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
         return v.hashInterpreted();
     }
 
@@ -371,12 +371,12 @@
     }
 
     // Create a value type in compiled code and pass it to the
     // interpreter via a call. The value is live at the first call so
     // debug info should include a reference to all its fields.
-    @Test(valid = ValueTypePassFieldsAsArgsOn, failOn = ALLOC + LOAD + TRAP)
-    @Test(valid = ValueTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD + TRAP)
+    @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = ALLOC + LOAD + TRAP)
+    @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD + TRAP)
     public long test18() {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
         v.hashInterpreted();
         return v.hashInterpreted();
     }
@@ -388,12 +388,12 @@
     }
 
     // Create a value type in compiled code and pass it to the
     // interpreter via a call. The value type is passed twice but
     // should only be allocated once.
-    @Test(valid = ValueTypePassFieldsAsArgsOn, failOn = ALLOC + LOAD + TRAP)
-    @Test(valid = ValueTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD + TRAP)
+    @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = ALLOC + LOAD + TRAP)
+    @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD + TRAP)
     public long test19() {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
         return sumValue(v, v);
     }
 
@@ -410,12 +410,12 @@
 
     // Create a value type (array) in compiled code and pass it to the
     // interpreter via a call. The value type is live at the uncommon
     // trap: verify that deoptimization causes the value type to be
     // correctly allocated.
-    @Test(valid = ValueTypePassFieldsAsArgsOn, failOn = LOAD + ALLOC + STORE)
-    @Test(valid = ValueTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD)
+    @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = LOAD + ALLOC + STORE)
+    @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC}, matchCount = {1}, failOn = LOAD)
     public long test20(boolean deopt) {
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
         MyValue2[] va = new MyValue2[3];
         if (deopt) {
             // uncommon trap
@@ -629,12 +629,12 @@
         staticVal3.verify(vt);
         staticVal3.verify(va[0]);
     }
 
     // Verify that C2 recognizes value type loads and re-uses the oop to avoid allocations
-    @Test(valid = ValueTypeReturnedAsFieldsOn)
-    @Test(valid = ValueTypeReturnedAsFieldsOff, failOn = ALLOC + ALLOCA + STORE)
+    @Test(valid = InlineTypeReturnedAsFieldsOn)
+    @Test(valid = InlineTypeReturnedAsFieldsOff, failOn = ALLOC + ALLOCA + STORE)
     public MyValue3 test31(MyValue3[] va) {
         // C2 can re-use the oop returned by createDontInline()
         // because the corresponding value type is equal to 'copy'.
         MyValue3 copy = MyValue3.copy(MyValue3.createDontInline());
         va[0] = copy;
@@ -650,12 +650,12 @@
         staticVal3.verify(vt);
         staticVal3.verify(va[0]);
     }
 
     // Verify that C2 recognizes value type loads and re-uses the oop to avoid allocations
-    @Test(valid = ValueTypePassFieldsAsArgsOn)
-    @Test(valid = ValueTypePassFieldsAsArgsOff, failOn = ALLOC + ALLOCA + STORE)
+    @Test(valid = InlineTypePassFieldsAsArgsOn)
+    @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = ALLOC + ALLOCA + STORE)
     public MyValue3 test32(MyValue3 vt, MyValue3[] va) {
         // C2 can re-use the oop of vt because vt is equal to 'copy'.
         MyValue3 copy = MyValue3.copy(vt);
         va[0] = copy;
         staticVal3 = copy;
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBufferTearing.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBufferTearing.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBufferTearing.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBufferTearing.java
@@ -33,22 +33,22 @@
 /**
  * @test TestBufferTearing
  * @summary Detect tearing on value type buffer writes due to missing barriers.
  * @library /testlibrary /test/lib /compiler/whitebox /
  * @modules java.base/jdk.internal.misc
- * @run main/othervm -XX:ValueFieldMaxFlatSize=0 -XX:ValueArrayElemMaxFlatSize=0
+ * @run main/othervm -XX:InlineFieldMaxFlatSize=0 -XX:InlineArrayElemMaxFlatSize=0
  *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM
  *                   compiler.valhalla.valuetypes.TestBufferTearing
- * @run main/othervm -XX:ValueFieldMaxFlatSize=0 -XX:ValueArrayElemMaxFlatSize=0
+ * @run main/othervm -XX:InlineFieldMaxFlatSize=0 -XX:InlineArrayElemMaxFlatSize=0
  *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM
  *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline
  *                   compiler.valhalla.valuetypes.TestBufferTearing
- * @run main/othervm -XX:ValueFieldMaxFlatSize=0 -XX:ValueArrayElemMaxFlatSize=0
+ * @run main/othervm -XX:InlineFieldMaxFlatSize=0 -XX:InlineArrayElemMaxFlatSize=0
  *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*
  *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM
  *                   compiler.valhalla.valuetypes.TestBufferTearing
- * @run main/othervm -XX:ValueFieldMaxFlatSize=0 -XX:ValueArrayElemMaxFlatSize=0
+ * @run main/othervm -XX:InlineFieldMaxFlatSize=0 -XX:InlineArrayElemMaxFlatSize=0
  *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*
  *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM
  *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline
  *                   compiler.valhalla.valuetypes.TestBufferTearing
  */
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java
@@ -45,11 +45,11 @@
     @Override
     public String[] getExtraVMParameters(int scenario) {
         switch (scenario) {
         case 0: return new String[] {"-Dsun.reflect.inflationThreshold=10000"}; // Don't generate bytecodes but call through runtime for reflective calls
         case 1: return new String[] {"-Dsun.reflect.inflationThreshold=10000"};
-        case 3: return new String[] {"-XX:ValueArrayElemMaxFlatSize=0"};
+        case 3: return new String[] {"-XX:InlineArrayElemMaxFlatSize=0"};
         }
         return null;
     }
 
     static {
@@ -307,12 +307,12 @@
     public MyValue3 test15_interp() {
         return test15_vt;
     }
 
     MyValue3 test15_vt2;
-    @Test(valid = ValueTypeReturnedAsFieldsOn, failOn = ALLOC + LOAD + TRAP)
-    @Test(valid = ValueTypeReturnedAsFieldsOff)
+    @Test(valid = InlineTypeReturnedAsFieldsOn, failOn = ALLOC + LOAD + TRAP)
+    @Test(valid = InlineTypeReturnedAsFieldsOff)
     public void test15() {
         test15_vt2 = test15_interp();
     }
 
     @DontCompile
@@ -321,12 +321,12 @@
         test15_vt.verify(test15_vt2);
     }
 
     // Return value types in registers from compiled -> interpreter
     final MyValue3 test16_vt = MyValue3.create();
-    @Test(valid = ValueTypeReturnedAsFieldsOn, failOn = ALLOC + STORE + TRAP)
-    @Test(valid = ValueTypeReturnedAsFieldsOff)
+    @Test(valid = InlineTypeReturnedAsFieldsOn, failOn = ALLOC + STORE + TRAP)
+    @Test(valid = InlineTypeReturnedAsFieldsOff)
     public MyValue3 test16() {
         return test16_vt;
     }
 
     @DontCompile
@@ -341,12 +341,12 @@
     public MyValue3 test17_comp() {
         return test17_vt;
     }
 
     MyValue3 test17_vt2;
-    @Test(valid = ValueTypeReturnedAsFieldsOn, failOn = ALLOC + LOAD + TRAP)
-    @Test(valid = ValueTypeReturnedAsFieldsOff)
+    @Test(valid = InlineTypeReturnedAsFieldsOn, failOn = ALLOC + LOAD + TRAP)
+    @Test(valid = InlineTypeReturnedAsFieldsOff)
     public void test17() {
         test17_vt2 = test17_comp();
     }
 
     @DontCompile
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConventionC1.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConventionC1.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConventionC1.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConventionC1.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -59,11 +59,11 @@
         case 1: return new String[] {
                 // Default: both C1 and C2 are enabled, tiered compilation enabled
                 "-XX:CICompilerCount=2",
                 "-XX:TieredStopAtLevel=4",
                 "-XX:+TieredCompilation",
-                "-XX:+StressValueTypeReturnedAsFields"
+                "-XX:+StressInlineTypeReturnedAsFields"
             };
         case 2: return new String[] {
                 // Same as above, but flip all the compLevel=C1 and compLevel=C2, so we test
                 // the compliment of the above scenario.
                 "-XX:CICompilerCount=2",
@@ -437,11 +437,11 @@
 
     static RefPoint refPointField1 = new RefPoint(12, 34);
     static RefPoint refPointField2 = new RefPoint(56789, 0x12345678);
 
     // This inline class has too many fields to fit in registers on x64 for
-    // ValueTypeReturnedAsFields.
+    // InlineTypeReturnedAsFields.
     static inline class TooBigToReturnAsFields {
         int a0 = 0;
         int a1 = 1;
         int a2 = 2;
         int a3 = 3;
@@ -1584,13 +1584,13 @@
             Asserts.assertEQ(result, n);
         }
     }
 
     //-------------------------------------------------------------------------------
-    // Tests for how C1 handles ValueTypeReturnedAsFields in both calls and returns
+    // Tests for how C1 handles InlineTypeReturnedAsFields in both calls and returns
     //-------------------------------------------------------------------------------
-    // C2->C1 invokestatic with ValueTypeReturnedAsFields (Point)
+    // C2->C1 invokestatic with InlineTypeReturnedAsFields (Point)
     @Test(compLevel = C2)
     public int test78(Point p) {
         Point np = test78_helper(p);
         return np.x + np.y;
     }
@@ -1606,11 +1606,11 @@
         int result = test78(pointField1);
         int n = pointField1.x + pointField1.y;
         Asserts.assertEQ(result, n);
     }
 
-    // C2->C1 invokestatic with ValueTypeReturnedAsFields (RefPoint)
+    // C2->C1 invokestatic with InlineTypeReturnedAsFields (RefPoint)
     @Test(compLevel = C2)
     public int test79(RefPoint p) {
         RefPoint np = test79_helper(p);
         return np.x.n + np.y.n;
     }
@@ -1626,11 +1626,11 @@
         int result = test79(refPointField1);
         int n = refPointField1.x.n + refPointField1.y.n;
         Asserts.assertEQ(result, n);
     }
 
-    // C1->C2 invokestatic with ValueTypeReturnedAsFields (RefPoint)
+    // C1->C2 invokestatic with InlineTypeReturnedAsFields (RefPoint)
     @Test(compLevel = C1)
     public int test80(RefPoint p) {
         RefPoint np = test80_helper(p);
         return np.x.n + np.y.n;
     }
@@ -1646,11 +1646,11 @@
         int result = test80(refPointField1);
         int n = refPointField1.x.n + refPointField1.y.n;
         Asserts.assertEQ(result, n);
     }
 
-    // Interpreter->C1 invokestatic with ValueTypeReturnedAsFields (Point)
+    // Interpreter->C1 invokestatic with InlineTypeReturnedAsFields (Point)
     @Test(compLevel = C1)
     public Point test81(Point p) {
         return p;
     }
 
@@ -1662,11 +1662,11 @@
         p = test81(pointField2);
         Asserts.assertEQ(p.x, pointField2.x);
         Asserts.assertEQ(p.y, pointField2.y);
     }
 
-    // C1->Interpreter invokestatic with ValueTypeReturnedAsFields (RefPoint)
+    // C1->Interpreter invokestatic with InlineTypeReturnedAsFields (RefPoint)
     @Test(compLevel = C1)
     public int test82(RefPoint p) {
         RefPoint np = test82_helper(p);
         return np.x.n + np.y.n;
     }
@@ -1682,14 +1682,14 @@
         int n = refPointField1.x.n + refPointField1.y.n;
         Asserts.assertEQ(result, n);
     }
 
     //-------------------------------------------------------------------------------
-    // Tests for ValueTypeReturnedAsFields vs the inline class TooBigToReturnAsFields
+    // Tests for InlineTypeReturnedAsFields vs the inline class TooBigToReturnAsFields
     //-------------------------------------------------------------------------------
 
-    // C2->C1 invokestatic with ValueTypeReturnedAsFields (TooBigToReturnAsFields)
+    // C2->C1 invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)
     @Test(compLevel = C2)
     public int test83(TooBigToReturnAsFields p) {
         TooBigToReturnAsFields np = test83_helper(p);
         return p.a0 + p.a5;
     }
@@ -1705,11 +1705,11 @@
         int result = test83(tooBig);
         int n = tooBig.a0 + tooBig.a5;
         Asserts.assertEQ(result, n);
     }
 
-    // C1->C2 invokestatic with ValueTypeReturnedAsFields (TooBigToReturnAsFields)
+    // C1->C2 invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)
     @Test(compLevel = C1)
     public int test84(TooBigToReturnAsFields p) {
         TooBigToReturnAsFields np = test84_helper(p);
         return p.a0 + p.a5;
     }
@@ -1725,11 +1725,11 @@
         int result = test84(tooBig);
         int n = tooBig.a0 + tooBig.a5;
         Asserts.assertEQ(result, n);
     }
 
-    // Interpreter->C1 invokestatic with ValueTypeReturnedAsFields (TooBigToReturnAsFields)
+    // Interpreter->C1 invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)
     @Test(compLevel = C1)
     public TooBigToReturnAsFields test85(TooBigToReturnAsFields p) {
         return p;
     }
 
@@ -1738,11 +1738,11 @@
         TooBigToReturnAsFields p = test85(tooBig);
         Asserts.assertEQ(p.a0, tooBig.a0);
         Asserts.assertEQ(p.a2, tooBig.a2);
     }
 
-    // C1->Interpreter invokestatic with ValueTypeReturnedAsFields (TooBigToReturnAsFields)
+    // C1->Interpreter invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)
     @Test(compLevel = C1)
     public int test86(TooBigToReturnAsFields p) {
         TooBigToReturnAsFields np = test86_helper(p);
         return p.a0 + p.a5;
     }
@@ -1758,14 +1758,14 @@
         int n = tooBig.a0 + tooBig.a5;
         Asserts.assertEQ(result, n);
     }
 
     //-------------------------------------------------------------------------------
-    // Tests for how C1 handles ValueTypeReturnedAsFields in both calls and returns (RefPoint?)
+    // Tests for how C1 handles InlineTypeReturnedAsFields in both calls and returns (RefPoint?)
     //-------------------------------------------------------------------------------
 
-    // C2->C1 invokestatic with ValueTypeReturnedAsFields (RefPoint.ref)
+    // C2->C1 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref)
     @Test(compLevel = C2)
     public RefPoint.ref test87(RefPoint.ref p) {
         return test87_helper(p);
     }
 
@@ -1779,11 +1779,11 @@
     public void test87_verifier(boolean warmup) {
         Object result = test87(null);
         Asserts.assertEQ(result, null);
     }
 
-    // C2->C1 invokestatic with ValueTypeReturnedAsFields (RefPoint.ref with constant null)
+    // C2->C1 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref with constant null)
     @Test(compLevel = C2)
     public RefPoint.ref test88() {
         return test88_helper();
     }
 
@@ -1797,11 +1797,11 @@
     public void test88_verifier(boolean warmup) {
         Object result = test88();
         Asserts.assertEQ(result, null);
     }
 
-    // C1->C2 invokestatic with ValueTypeReturnedAsFields (RefPoint.ref)
+    // C1->C2 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref)
     @Test(compLevel = C1)
     public RefPoint.ref test89(RefPoint.ref p) {
         return test89_helper(p);
     }
 
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestDeoptimizationWhenBuffering.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestDeoptimizationWhenBuffering.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestDeoptimizationWhenBuffering.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestDeoptimizationWhenBuffering.java
@@ -42,36 +42,36 @@
  * @run main/othervm -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
  *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch
  *                   compiler.valhalla.valuetypes.TestDeoptimizationWhenBuffering
  * @run main/othervm -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
  *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:-AlwaysIncrementalInline
- *                   -XX:-ValueTypePassFieldsAsArgs -XX:-ValueTypeReturnedAsFields -XX:ValueArrayElemMaxFlatSize=1
+ *                   -XX:-InlineTypePassFieldsAsArgs -XX:-InlineTypeReturnedAsFields -XX:InlineArrayElemMaxFlatSize=1
  *                   -XX:CompileCommand=dontinline,compiler.valhalla.valuetypes.*::test*
  *                   compiler.valhalla.valuetypes.TestDeoptimizationWhenBuffering
  * @run main/othervm -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
  *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:+AlwaysIncrementalInline
- *                   -XX:-ValueTypePassFieldsAsArgs -XX:-ValueTypeReturnedAsFields -XX:ValueArrayElemMaxFlatSize=1
+ *                   -XX:-InlineTypePassFieldsAsArgs -XX:-InlineTypeReturnedAsFields -XX:InlineArrayElemMaxFlatSize=1
  *                   -XX:CompileCommand=dontinline,compiler.valhalla.valuetypes.*::test*
  *                   compiler.valhalla.valuetypes.TestDeoptimizationWhenBuffering
  * @run main/othervm -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
  *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:-AlwaysIncrementalInline
- *                   -XX:+ValueTypePassFieldsAsArgs -XX:+ValueTypeReturnedAsFields -XX:ValueArrayElemMaxFlatSize=-1
+ *                   -XX:+InlineTypePassFieldsAsArgs -XX:+InlineTypeReturnedAsFields -XX:InlineArrayElemMaxFlatSize=-1
  *                   -XX:CompileCommand=dontinline,compiler.valhalla.valuetypes.*::test*
  *                   compiler.valhalla.valuetypes.TestDeoptimizationWhenBuffering
  * @run main/othervm -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
  *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:+AlwaysIncrementalInline
- *                   -XX:+ValueTypePassFieldsAsArgs -XX:+ValueTypeReturnedAsFields -XX:ValueArrayElemMaxFlatSize=-1
+ *                   -XX:+InlineTypePassFieldsAsArgs -XX:+InlineTypeReturnedAsFields -XX:InlineArrayElemMaxFlatSize=-1
  *                   -XX:CompileCommand=dontinline,compiler.valhalla.valuetypes.*::test*
  *                   compiler.valhalla.valuetypes.TestDeoptimizationWhenBuffering
  * @run main/othervm -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
  *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:-AlwaysIncrementalInline
- *                   -XX:+ValueTypePassFieldsAsArgs -XX:+ValueTypeReturnedAsFields -XX:ValueArrayElemMaxFlatSize=-1 -XX:ValueFieldMaxFlatSize=0
+ *                   -XX:+InlineTypePassFieldsAsArgs -XX:+InlineTypeReturnedAsFields -XX:InlineArrayElemMaxFlatSize=-1 -XX:InlineFieldMaxFlatSize=0
  *                   -XX:CompileCommand=dontinline,compiler.valhalla.valuetypes.*::test*
  *                   compiler.valhalla.valuetypes.TestDeoptimizationWhenBuffering
  * @run main/othervm -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
  *                   -XX:+DeoptimizeALot -XX:-UseTLAB -Xbatch -XX:-MonomorphicArrayCheck -XX:+AlwaysIncrementalInline
- *                   -XX:+ValueTypePassFieldsAsArgs -XX:+ValueTypeReturnedAsFields -XX:ValueArrayElemMaxFlatSize=-1 -XX:ValueFieldMaxFlatSize=0
+ *                   -XX:+InlineTypePassFieldsAsArgs -XX:+InlineTypeReturnedAsFields -XX:InlineArrayElemMaxFlatSize=-1 -XX:InlineFieldMaxFlatSize=0
  *                   -XX:CompileCommand=dontinline,compiler.valhalla.valuetypes.*::test*
  *                   compiler.valhalla.valuetypes.TestDeoptimizationWhenBuffering
  */
 
 final inline class MyValue1 {
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestFlatArrayThreshold.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestFlatArrayThreshold.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestFlatArrayThreshold.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestFlatArrayThreshold.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,12 +24,12 @@
 /**
  * @test
  * @summary Test accessing value type arrays that exceed the flattening threshold.
  * @library /test/lib
  * @run main/othervm -Xbatch TestFlatArrayThreshold
- * @run main/othervm -XX:ValueArrayElemMaxFlatOops=1 -Xbatch TestFlatArrayThreshold
- * @run main/othervm -XX:ValueArrayElemMaxFlatSize=1 -Xbatch TestFlatArrayThreshold
+ * @run main/othervm -XX:InlineArrayElemMaxFlatOops=1 -Xbatch TestFlatArrayThreshold
+ * @run main/othervm -XX:InlineArrayElemMaxFlatSize=1 -Xbatch TestFlatArrayThreshold
  */
 
 import jdk.test.lib.Asserts;
 
 final inline class MyValue1 {
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
@@ -47,11 +47,11 @@
 public class TestIntrinsics extends ValueTypeTest {
     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
     @Override
     public String[] getExtraVMParameters(int scenario) {
         switch (scenario) {
-        case 3: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:ValueArrayElemMaxFlatSize=-1"};
+        case 3: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:InlineArrayElemMaxFlatSize=-1"};
         case 4: return new String[] {"-XX:-MonomorphicArrayCheck"};
         }
         return null;
     }
 
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
@@ -48,11 +48,11 @@
     @Override
     public String[] getExtraVMParameters(int scenario) {
         switch (scenario) {
         case 1: return new String[] {"-XX:-UseOptoBiasInlining"};
         case 2: return new String[] {"-DVerifyIR=false", "-XX:-UseBiasedLocking"};
-        case 3: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:-UseBiasedLocking", "-XX:ValueArrayElemMaxFlatSize=-1"};
+        case 3: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:-UseBiasedLocking", "-XX:InlineArrayElemMaxFlatSize=-1"};
         case 4: return new String[] {"-XX:-MonomorphicArrayCheck"};
         }
         return null;
     }
 
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestMethodHandles.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestMethodHandles.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestMethodHandles.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestMethodHandles.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -144,12 +144,12 @@
         return test1_vt;
     }
 
     static final MethodHandle test1_mh;
 
-    @Test(valid = ValueTypeReturnedAsFieldsOn, failOn = ALLOC + STORE + CALL)
-    @Test(valid = ValueTypeReturnedAsFieldsOff, match = { ALLOC, STORE }, matchCount = { 1, 14 })
+    @Test(valid = InlineTypeReturnedAsFieldsOn, failOn = ALLOC + STORE + CALL)
+    @Test(valid = InlineTypeReturnedAsFieldsOff, match = { ALLOC, STORE }, matchCount = { 1, 14 })
     public MyValue3 test1() throws Throwable {
         return (MyValue3)test1_mh.invokeExact(this);
     }
 
     @DontCompile
@@ -272,12 +272,12 @@
         return test6_bool;
     }
 
     static final MethodHandle test6_mh;
 
-    @Test(valid = ValueTypeReturnedAsFieldsOn, failOn = ALLOC + ALLOCA + STORE + STOREVALUETYPEFIELDS)
-    @Test(valid = ValueTypeReturnedAsFieldsOff)
+    @Test(valid = InlineTypeReturnedAsFieldsOn, failOn = ALLOC + ALLOCA + STORE + STOREVALUETYPEFIELDS)
+    @Test(valid = InlineTypeReturnedAsFieldsOff)
     public MyValue3 test6() throws Throwable {
         return (MyValue3)test6_mh.invokeExact(this);
     }
 
     @DontCompile
@@ -385,12 +385,12 @@
         return test9_bool2;
     }
 
     static final MethodHandle test9_mh;
 
-    @Test(valid = ValueTypeReturnedAsFieldsOn, failOn = ALLOC + ALLOCA + STORE + STOREVALUETYPEFIELDS)
-    @Test(valid = ValueTypeReturnedAsFieldsOff)
+    @Test(valid = InlineTypeReturnedAsFieldsOn, failOn = ALLOC + ALLOCA + STORE + STOREVALUETYPEFIELDS)
+    @Test(valid = InlineTypeReturnedAsFieldsOff)
     public MyValue3 test9() throws Throwable {
         return (MyValue3)test9_mh.invokeExact(this);
     }
 
     static int test9_i = 0;
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableValueTypes.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableValueTypes.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableValueTypes.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableValueTypes.java
@@ -45,11 +45,11 @@
     @Override
     public String[] getExtraVMParameters(int scenario) {
         switch (scenario) {
         case 1: return new String[] {"-XX:-UseOptoBiasInlining"};
         case 2: return new String[] {"-XX:-UseBiasedLocking"};
-        case 3: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:-UseBiasedLocking", "-XX:ValueArrayElemMaxFlatSize=-1"};
+        case 3: return new String[] {"-XX:-MonomorphicArrayCheck", "-XX:-UseBiasedLocking", "-XX:InlineArrayElemMaxFlatSize=-1"};
         case 4: return new String[] {"-XX:-MonomorphicArrayCheck"};
         }
         return null;
     }
 
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestOnStackReplacement.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestOnStackReplacement.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestOnStackReplacement.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestOnStackReplacement.java
@@ -41,11 +41,11 @@
 public class TestOnStackReplacement extends ValueTypeTest {
     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
     @Override
     public String[] getExtraVMParameters(int scenario) {
         switch (scenario) {
-        case 3: return new String[] {"-XX:ValueArrayElemMaxFlatSize=0"};
+        case 3: return new String[] {"-XX:InlineArrayElemMaxFlatSize=0"};
         }
         return null;
     }
 
     public static void main(String[] args) throws Throwable {
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeArray.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeArray.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeArray.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeArray.java
@@ -27,26 +27,26 @@
  * @library /test/lib
  * @summary Test the handling of arrays of unloaded value classes.
  * @run main/othervm -Xcomp
  *                   -XX:CompileCommand=compileonly,TestUnloadedValueTypeArray::test*
  *                   TestUnloadedValueTypeArray
- * @run main/othervm -Xcomp -XX:ValueArrayElemMaxFlatSize=0
+ * @run main/othervm -Xcomp -XX:InlineArrayElemMaxFlatSize=0
  *                   -XX:CompileCommand=compileonly,TestUnloadedValueTypeArray::test*
  *                   TestUnloadedValueTypeArray
  * @run main/othervm -Xcomp
  *                   TestUnloadedValueTypeArray
- * @run main/othervm -Xcomp -XX:ValueArrayElemMaxFlatSize=0
+ * @run main/othervm -Xcomp -XX:InlineArrayElemMaxFlatSize=0
  *                   TestUnloadedValueTypeArray
  * @run main/othervm -Xcomp -XX:-TieredCompilation
  *                   -XX:CompileCommand=compileonly,TestUnloadedValueTypeArray::test*
  *                   TestUnloadedValueTypeArray
- * @run main/othervm -Xcomp -XX:-TieredCompilation -XX:ValueArrayElemMaxFlatSize=0
+ * @run main/othervm -Xcomp -XX:-TieredCompilation -XX:InlineArrayElemMaxFlatSize=0
  *                   -XX:CompileCommand=compileonly,TestUnloadedValueTypeArray::test*
  *                   TestUnloadedValueTypeArray
  * @run main/othervm -Xcomp -XX:-TieredCompilation
  *                   TestUnloadedValueTypeArray
- * @run main/othervm -Xcomp -XX:-TieredCompilation -XX:ValueArrayElemMaxFlatSize=0
+ * @run main/othervm -Xcomp -XX:-TieredCompilation -XX:InlineArrayElemMaxFlatSize=0
  *                   TestUnloadedValueTypeArray
  */
 
 import jdk.test.lib.Asserts;
 
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeField.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeField.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeField.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeField.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -43,11 +43,11 @@
         test.run(args);
     }
 
     static final String[][] scenarios = {
         {},
-        {"-XX:ValueFieldMaxFlatSize=0"}
+        {"-XX:InlineFieldMaxFlatSize=0"}
     };
 
     @Override
     public int getNumScenarios() {
         return scenarios.length;
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnresolvedValueClass.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnresolvedValueClass.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnresolvedValueClass.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnresolvedValueClass.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -49,11 +49,11 @@
             if (!unresolved.exists() || !unresolved.delete()) {
                 throw new RuntimeException("Could not delete: " + unresolved);
             }
 
             // Run test in new VM instance
-            String[] arg = {"-XX:+ValueTypePassFieldsAsArgs", "TestUnresolvedValueClass", "run"};
+            String[] arg = {"-XX:+InlineTypePassFieldsAsArgs", "TestUnresolvedValueClass", "run"};
             OutputAnalyzer oa = ProcessTools.executeTestJvm(arg);
 
             // Adapter creation for TestUnresolvedValueClass::test1 should fail with a
             // ClassNotFoundException because the class for argument 'vt' was not found.
             String output = oa.getOutput();
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java
@@ -161,29 +161,29 @@
         "-XX:+PrintCompilation", "-XX:+PrintIdeal", "-XX:+UnlockDiagnosticVMOptions", "-XX:+PrintOptoAssembly"};
     private static final String[] verifyFlags = {
         "-XX:+VerifyOops", "-XX:+VerifyStack", "-XX:+VerifyLastFrame", "-XX:+VerifyBeforeGC", "-XX:+VerifyAfterGC",
         "-XX:+VerifyDuringGC", "-XX:+VerifyAdapterSharing"};
 
-    protected static final int ValueTypePassFieldsAsArgsOn = 0x1;
-    protected static final int ValueTypePassFieldsAsArgsOff = 0x2;
+    protected static final int InlineTypePassFieldsAsArgsOn = 0x1;
+    protected static final int InlineTypePassFieldsAsArgsOff = 0x2;
     protected static final int ValueTypeArrayFlattenOn = 0x4;
     protected static final int ValueTypeArrayFlattenOff = 0x8;
-    protected static final int ValueTypeReturnedAsFieldsOn = 0x10;
-    protected static final int ValueTypeReturnedAsFieldsOff = 0x20;
+    protected static final int InlineTypeReturnedAsFieldsOn = 0x10;
+    protected static final int InlineTypeReturnedAsFieldsOff = 0x20;
     protected static final int AlwaysIncrementalInlineOn = 0x40;
     protected static final int AlwaysIncrementalInlineOff = 0x80;
     protected static final int G1GCOn = 0x100;
     protected static final int G1GCOff = 0x200;
     protected static final int ZGCOn = 0x400;
     protected static final int ZGCOff = 0x800;
     protected static final int ArrayLoadStoreProfileOn = 0x1000;
     protected static final int ArrayLoadStoreProfileOff = 0x2000;
     protected static final int TypeProfileOn = 0x4000;
     protected static final int TypeProfileOff = 0x8000;
-    protected static final boolean ValueTypePassFieldsAsArgs = (Boolean)WHITE_BOX.getVMFlag("ValueTypePassFieldsAsArgs");
-    protected static final boolean ValueTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag("ValueArrayElemMaxFlatSize") == -1); // FIXME - fix this if default of ValueArrayElemMaxFlatSize is changed
-    protected static final boolean ValueTypeReturnedAsFields = (Boolean)WHITE_BOX.getVMFlag("ValueTypeReturnedAsFields");
+    protected static final boolean InlineTypePassFieldsAsArgs = (Boolean)WHITE_BOX.getVMFlag("InlineTypePassFieldsAsArgs");
+    protected static final boolean ValueTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag("InlineArrayElemMaxFlatSize") == -1); // FIXME - fix this if default of InlineArrayElemMaxFlatSize is changed
+    protected static final boolean InlineTypeReturnedAsFields = (Boolean)WHITE_BOX.getVMFlag("InlineTypeReturnedAsFields");
     protected static final boolean AlwaysIncrementalInline = (Boolean)WHITE_BOX.getVMFlag("AlwaysIncrementalInline");
     protected static final boolean G1GC = (Boolean)WHITE_BOX.getVMFlag("UseG1GC");
     protected static final boolean ZGC = (Boolean)WHITE_BOX.getVMFlag("UseZGC");
     protected static final boolean VerifyOops = (Boolean)WHITE_BOX.getVMFlag("VerifyOops");
     protected static final boolean UseArrayLoadStoreProfile = (Boolean)WHITE_BOX.getVMFlag("UseArrayLoadStoreProfile");
@@ -255,58 +255,58 @@
     public String[] getVMParameters(int scenario) {
         switch (scenario) {
         case 0: return new String[] {
                 "-XX:-UseArrayLoadStoreProfile",
                 "-XX:+AlwaysIncrementalInline",
-                "-XX:ValueArrayElemMaxFlatOops=5",
-                "-XX:ValueArrayElemMaxFlatSize=-1",
-                "-XX:ValueFieldMaxFlatSize=-1",
-                "-XX:+ValueTypePassFieldsAsArgs",
-                "-XX:+ValueTypeReturnedAsFields"};
+                "-XX:InlineArrayElemMaxFlatOops=5",
+                "-XX:InlineArrayElemMaxFlatSize=-1",
+                "-XX:InlineFiledMaxFlatSize=-1",
+                "-XX:+InlineTypePassFieldsAsArgs",
+                "-XX:+InlineTypeReturnedAsFields"};
         case 1: return new String[] {
                 "-XX:-UseArrayLoadStoreProfile",
                 "-XX:-UseCompressedOops",
-                "-XX:ValueArrayElemMaxFlatOops=5",
-                "-XX:ValueArrayElemMaxFlatSize=-1",
-                "-XX:ValueFieldMaxFlatSize=-1",
-                "-XX:-ValueTypePassFieldsAsArgs",
-                "-XX:-ValueTypeReturnedAsFields"};
+                "-XX:InlineArrayElemMaxFlatOops=5",
+                "-XX:InlineArrayElemMaxFlatSize=-1",
+                "-XX:InlineFiledMaxFlatSize=-1",
+                "-XX:-InlineTypePassFieldsAsArgs",
+                "-XX:-InlineTypeReturnedAsFields"};
         case 2: return new String[] {
                 "-XX:-UseArrayLoadStoreProfile",
                 "-XX:-UseCompressedOops",
-                "-XX:ValueArrayElemMaxFlatOops=0",
-                "-XX:ValueArrayElemMaxFlatSize=0",
-                "-XX:ValueFieldMaxFlatSize=-1",
-                "-XX:+ValueTypePassFieldsAsArgs",
-                "-XX:+ValueTypeReturnedAsFields",
-                "-XX:+StressValueTypeReturnedAsFields"};
+                "-XX:InlineArrayElemMaxFlatOops=0",
+                "-XX:InlineArrayElemMaxFlatSize=0",
+                "-XX:InlineFiledMaxFlatSize=-1",
+                "-XX:+InlineTypePassFieldsAsArgs",
+                "-XX:+InlineTypeReturnedAsFields",
+                "-XX:+StressInlineTypeReturnedAsFields"};
         case 3: return new String[] {
                 "-XX:-UseArrayLoadStoreProfile",
                 "-DVerifyIR=false",
                 "-XX:+AlwaysIncrementalInline",
-                "-XX:ValueArrayElemMaxFlatOops=0",
-                "-XX:ValueArrayElemMaxFlatSize=0",
-                "-XX:ValueFieldMaxFlatSize=0",
-                "-XX:+ValueTypePassFieldsAsArgs",
-                "-XX:+ValueTypeReturnedAsFields"};
+                "-XX:InlineArrayElemMaxFlatOops=0",
+                "-XX:InlineArrayElemMaxFlatSize=0",
+                "-XX:InlineFiledMaxFlatSize=0",
+                "-XX:+InlineTypePassFieldsAsArgs",
+                "-XX:+InlineTypeReturnedAsFields"};
         case 4: return new String[] {
                 "-XX:-UseArrayLoadStoreProfile",
                 "-DVerifyIR=false",
-                "-XX:ValueArrayElemMaxFlatOops=-1",
-                "-XX:ValueArrayElemMaxFlatSize=-1",
-                "-XX:ValueFieldMaxFlatSize=0",
-                "-XX:+ValueTypePassFieldsAsArgs",
-                "-XX:-ValueTypeReturnedAsFields",
+                "-XX:InlineArrayElemMaxFlatOops=-1",
+                "-XX:InlineArrayElemMaxFlatSize=-1",
+                "-XX:InlineFiledMaxFlatSize=0",
+                "-XX:+InlineTypePassFieldsAsArgs",
+                "-XX:-InlineTypeReturnedAsFields",
                 "-XX:-ReduceInitialCardMarks"};
         case 5: return new String[] {
                 "-XX:-UseArrayLoadStoreProfile",
                 "-XX:+AlwaysIncrementalInline",
-                "-XX:ValueArrayElemMaxFlatOops=5",
-                "-XX:ValueArrayElemMaxFlatSize=-1",
-                "-XX:ValueFieldMaxFlatSize=-1",
-                "-XX:-ValueTypePassFieldsAsArgs",
-                "-XX:-ValueTypeReturnedAsFields"};
+                "-XX:InlineArrayElemMaxFlatOops=5",
+                "-XX:InlineArrayElemMaxFlatSize=-1",
+                "-XX:InlineFiledMaxFlatSize=-1",
+                "-XX:-InlineTypePassFieldsAsArgs",
+                "-XX:-InlineTypeReturnedAsFields"};
         }
         return null;
     }
 
     /**
@@ -471,16 +471,16 @@
     static final class TestAnnotation {
         private final int flag;
         private final BooleanSupplier predicate;
 
         private static final TestAnnotation testAnnotations[] = {
-            new TestAnnotation(ValueTypePassFieldsAsArgsOn, () -> ValueTypePassFieldsAsArgs),
-            new TestAnnotation(ValueTypePassFieldsAsArgsOff, () -> !ValueTypePassFieldsAsArgs),
+            new TestAnnotation(InlineTypePassFieldsAsArgsOn, () -> InlineTypePassFieldsAsArgs),
+            new TestAnnotation(InlineTypePassFieldsAsArgsOff, () -> !InlineTypePassFieldsAsArgs),
             new TestAnnotation(ValueTypeArrayFlattenOn, () -> ValueTypeArrayFlatten),
             new TestAnnotation(ValueTypeArrayFlattenOff, () -> !ValueTypeArrayFlatten),
-            new TestAnnotation(ValueTypeReturnedAsFieldsOn, () -> ValueTypeReturnedAsFields),
-            new TestAnnotation(ValueTypeReturnedAsFieldsOff, () -> !ValueTypeReturnedAsFields),
+            new TestAnnotation(InlineTypeReturnedAsFieldsOn, () -> InlineTypeReturnedAsFields),
+            new TestAnnotation(InlineTypeReturnedAsFieldsOff, () -> !InlineTypeReturnedAsFields),
             new TestAnnotation(AlwaysIncrementalInlineOn, () -> AlwaysIncrementalInline),
             new TestAnnotation(AlwaysIncrementalInlineOff, () -> !AlwaysIncrementalInline),
             new TestAnnotation(G1GCOn, () -> G1GC),
             new TestAnnotation(G1GCOff, () -> !G1GC),
             new TestAnnotation(ZGCOn, () -> ZGC),
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/FlattenableSemanticTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/FlattenableSemanticTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/FlattenableSemanticTest.java
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/FlattenableSemanticTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -34,15 +34,15 @@
  * @modules java.base/jdk.experimental.bytecode
  *          java.base/jdk.experimental.value
  * @library /test/lib
  * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator Point.java JumboValue.java
  * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator FlattenableSemanticTest.java
- * @run main/othervm -Xint -XX:ValueFieldMaxFlatSize=64 runtime.valhalla.valuetypes.FlattenableSemanticTest
+ * @run main/othervm -Xint -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.valuetypes.FlattenableSemanticTest
  * @run main/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.valuetypes.FlattenableSemanticTest
- * @run main/othervm -Xcomp -XX:ValueFieldMaxFlatSize=64 runtime.valhalla.valuetypes.FlattenableSemanticTest
+ * @run main/othervm -Xcomp -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.valuetypes.FlattenableSemanticTest
  * @run main/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.valuetypes.FlattenableSemanticTest
- * // debug: -XX:+PrintValueLayout -XX:-ShowMessageBoxOnError
+ * // debug: -XX:+PrintInlineLayout -XX:-ShowMessageBoxOnError
  */
 public class FlattenableSemanticTest {
 
     static Point.ref nfsp;
     static Point fsp;
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestFieldNullability.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestFieldNullability.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestFieldNullability.java
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestFieldNullability.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,11 +23,11 @@
 
 /**
  * @test TestFieldNullability
  * @library /test/lib
  * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator TestFieldNullability.java
- * @run main/othervm -Xint -Xmx128m -XX:-ShowMessageBoxOnError -XX:ValueFieldMaxFlatSize=32
+ * @run main/othervm -Xint -Xmx128m -XX:-ShowMessageBoxOnError -XX:InlineFieldMaxFlatSize=32
  *                   runtime.valhalla.valuetypes.TestFieldNullability
  */
 
 package runtime.valhalla.valuetypes;
 
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestJNIArrays.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestJNIArrays.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestJNIArrays.java
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/TestJNIArrays.java
@@ -38,12 +38,12 @@
  * @modules java.base/jdk.internal.misc java.base/jdk.internal.vm.jni
  * @library /testlibrary /test/lib
  * @requires (os.simpleArch == "x64")
  * @requires (os.family == "linux" | os.family == "mac")
  * @compile -XDallowWithFieldOperator TestJNIArrays.java
- * @run main/othervm/native/timeout=3000 -XX:ValueArrayElemMaxFlatSize=128 -XX:+PrintFlattenableLayouts -XX:+UseCompressedOops TestJNIArrays
- * @run main/othervm/native/timeout=3000 -XX:ValueArrayElemMaxFlatSize=128 -XX:+PrintFlattenableLayouts -XX:-UseCompressedOops TestJNIArrays
+ * @run main/othervm/native/timeout=3000 -XX:InlineArrayElemMaxFlatSize=128 -XX:+PrintFlattenableLayouts -XX:+UseCompressedOops TestJNIArrays
+ * @run main/othervm/native/timeout=3000 -XX:InlineArrayElemMaxFlatSize=128 -XX:+PrintFlattenableLayouts -XX:-UseCompressedOops TestJNIArrays
  */
 public class TestJNIArrays {
 
     static final Unsafe U = Unsafe.getUnsafe();
 
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/UninitializedValueFieldsTest.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/UninitializedValueFieldsTest.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/UninitializedValueFieldsTest.java
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/UninitializedValueFieldsTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,12 +27,12 @@
 /*
  * @test
  * @summary Uninitialized inline fields test
  * @library /test/lib
  * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator -XDallowFlattenabilityModifiers Point.java JumboValue.java UninitializedValueFieldsTest.java
- * @run main/othervm -Xint -XX:ValueFieldMaxFlatSize=64 runtime.valhalla.valuetypes.UninitializedValueFieldsTest
- * @run main/othervm -Xcomp -XX:ValueFieldMaxFlatSize=64 runtime.valhalla.valuetypes.UninitializedValueFieldsTest
+ * @run main/othervm -Xint -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.valuetypes.UninitializedValueFieldsTest
+ * @run main/othervm -Xcomp -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.valuetypes.UninitializedValueFieldsTest
  */
 public class UninitializedValueFieldsTest {
     static Point.ref nonFlattenableStaticPoint;
     static Point staticPoint;
 
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
@@ -33,14 +33,14 @@
 /*
  * @test ValueTypeArray
  * @summary Plain array test for Inline Types
  * @library /test/lib
  * @compile ValueTypeArray.java Point.java Long8Value.java Person.java
- * @run main/othervm -Xint  -XX:ValueArrayElemMaxFlatSize=-1 runtime.valhalla.valuetypes.ValueTypeArray
- * @run main/othervm -Xint  -XX:ValueArrayElemMaxFlatSize=0  runtime.valhalla.valuetypes.ValueTypeArray
- * @run main/othervm -Xcomp -XX:ValueArrayElemMaxFlatSize=-1 runtime.valhalla.valuetypes.ValueTypeArray
- * @run main/othervm -Xcomp -XX:ValueArrayElemMaxFlatSize=0  runtime.valhalla.valuetypes.ValueTypeArray
+ * @run main/othervm -Xint  -XX:InlineArrayElemMaxFlatSize=-1 runtime.valhalla.valuetypes.ValueTypeArray
+ * @run main/othervm -Xint  -XX:InlineArrayElemMaxFlatSize=0  runtime.valhalla.valuetypes.ValueTypeArray
+ * @run main/othervm -Xcomp -XX:InlineArrayElemMaxFlatSize=-1 runtime.valhalla.valuetypes.ValueTypeArray
+ * @run main/othervm -Xcomp -XX:InlineArrayElemMaxFlatSize=0  runtime.valhalla.valuetypes.ValueTypeArray
  * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.valuetypes.ValueTypeArray
  */
 public class ValueTypeArray {
     public static void main(String[] args) {
         ValueTypeArray valueTypeArray = new ValueTypeArray();
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeDensity.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeDensity.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeDensity.java
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeDensity.java
@@ -31,14 +31,14 @@
  * @test ValueTypeDensity
  * @summary Heap density test for ValueTypes
  * @library /test/lib
  * @compile -XDemitQtypes -XDenableValueTypes -XDallowWithFieldOperator ValueTypeDensity.java
  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- * @run main/othervm -Xint -XX:ValueArrayElemMaxFlatSize=-1
+ * @run main/othervm -Xint -XX:InlineArrayElemMaxFlatSize=-1
  *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
  *                    -XX:+WhiteBoxAPI ValueTypeDensity
- * @run main/othervm -Xcomp -XX:ValueArrayElemMaxFlatSize=-1
+ * @run main/othervm -Xcomp -XX:InlineArrayElemMaxFlatSize=-1
  *                   -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
  *                   -XX:+WhiteBoxAPI ValueTypeDensity
  * @run main/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions
  *                   -Xbootclasspath/a:. -XX:ForceNonTearable=*
  *                   -XX:+WhiteBoxAPI ValueTypeDensity
@@ -47,12 +47,12 @@
 public class ValueTypeDensity {
 
     private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
 
     public ValueTypeDensity() {
-        if (WHITE_BOX.getIntxVMFlag("ValueArrayElemMaxFlatSize") != -1) {
-            throw new IllegalStateException("ValueArrayElemMaxFlatSize should be -1");
+        if (WHITE_BOX.getIntxVMFlag("InlineArrayElemMaxFlatSize") != -1) {
+            throw new IllegalStateException("InlineArrayElemMaxFlatSize should be -1");
         }
     }
 
     interface LocalDate {
         public int getYear();
diff a/test/jdk/valhalla/valuetypes/ArrayElementVarHandleTest.java b/test/jdk/valhalla/valuetypes/ArrayElementVarHandleTest.java
--- a/test/jdk/valhalla/valuetypes/ArrayElementVarHandleTest.java
+++ b/test/jdk/valhalla/valuetypes/ArrayElementVarHandleTest.java
@@ -23,12 +23,12 @@
 
 
 /*
  * @test
  * @summary test VarHandle on inline class array
- * @run testng/othervm -XX:ValueArrayElemMaxFlatSize=-1 ArrayElementVarHandleTest
- * @run testng/othervm -XX:ValueArrayElemMaxFlatSize=0  ArrayElementVarHandleTest
+ * @run testng/othervm -XX:InlineArrayElemMaxFlatSize=-1 ArrayElementVarHandleTest
+ * @run testng/othervm -XX:InlineArrayElemMaxFlatSize=0  ArrayElementVarHandleTest
  */
 
 import java.lang.invoke.*;
 
 import org.testng.annotations.DataProvider;
diff a/test/jdk/valhalla/valuetypes/ObjectMethods.java b/test/jdk/valhalla/valuetypes/ObjectMethods.java
--- a/test/jdk/valhalla/valuetypes/ObjectMethods.java
+++ b/test/jdk/valhalla/valuetypes/ObjectMethods.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,11 +25,11 @@
 /*
  * @test
  * @summary test Object methods on inline types
  * @run testng/othervm -Xint -Dvalue.bsm.salt=1 ObjectMethods
  * @run testng/othervm -Xcomp -Dvalue.bsm.salt=1 ObjectMethods
- * @run testng/othervm -Dvalue.bsm.salt=1 -XX:ValueFieldMaxFlatSize=0 ObjectMethods
+ * @run testng/othervm -Dvalue.bsm.salt=1 -XX:InlineFieldMaxFlatSize=0 ObjectMethods
  */
 
 import java.lang.reflect.Modifier;
 import java.util.Arrays;
 import java.util.List;
diff a/test/jdk/valhalla/valuetypes/ValueArray.java b/test/jdk/valhalla/valuetypes/ValueArray.java
--- a/test/jdk/valhalla/valuetypes/ValueArray.java
+++ b/test/jdk/valhalla/valuetypes/ValueArray.java
@@ -22,12 +22,12 @@
  */
 
 /*
  * @test
  * @summary Basic test for Array::get, Array::set, Arrays::setAll on inline class array
- * @run testng/othervm -XX:ValueArrayElemMaxFlatSize=-1 ValueArray
- * @run testng/othervm -XX:ValueArrayElemMaxFlatSize=0  ValueArray
+ * @run testng/othervm -XX:InlineArrayElemMaxFlatSize=-1 ValueArray
+ * @run testng/othervm -XX:InlineArrayElemMaxFlatSize=0  ValueArray
  */
 
 import java.lang.reflect.Array;
 import java.util.Arrays;
 

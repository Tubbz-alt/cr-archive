<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../c1/c1_LIRAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4402       if (!fs.signature()-&gt;is_Q_signature()) {
4403         THROW(vmSymbols::java_lang_ClassFormatError());
4404       }
4405       static_inline_type_count++;
4406     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {
4407       // Pre-resolve the flattenable field and check for inline type circularity issues.
4408       ResourceMark rm;
4409       if (!fs.signature()-&gt;is_Q_signature()) {
4410         THROW(vmSymbols::java_lang_ClassFormatError());
4411       }
4412       Klass* klass =
4413         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
4414                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4415                                                             _protection_domain, true, CHECK);
4416       assert(klass != NULL, &quot;Sanity check&quot;);
4417       if (!klass-&gt;access_flags().is_inline_type()) {
4418         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4419       }
4420       ValueKlass* vk = ValueKlass::cast(klass);
4421       // Conditions to apply flattening or not should be defined in a single place
<span class="line-modified">4422       bool too_big_to_flatten = (ValueFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-modified">4423                                  (vk-&gt;size_helper() * HeapWordSize) &gt; ValueFieldMaxFlatSize);</span>
4424       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
4425       bool too_volatile_to_flatten = fs.access_flags().is_volatile();
4426       if (vk-&gt;is_naturally_atomic()) {
4427         too_atomic_to_flatten = false;
4428         //too_volatile_to_flatten = false; //FIXME
4429         // volatile fields are currently never flattened, this could change in the future
4430       }
4431       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
4432         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();
4433         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;
4434         nonstatic_inline_type_count++;
4435 
4436         ValueKlass* vklass = ValueKlass::cast(klass);
4437         if (vklass-&gt;contains_oops()) {
4438           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();
4439         }
4440         fs.set_flattened(true);
4441         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
4442           not_atomic_inline_types++;
4443         }
</pre>
<hr />
<pre>
4858   int instance_size             = align_object_size(instance_end / wordSize);
4859 
4860   assert(instance_size == align_object_size(align_up(
4861          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
4862          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4863 
4864 
4865   // Invariant: nonstatic_field end/start should only change if there are
4866   // nonstatic fields in the class, or if the class is contended. We compare
4867   // against the non-aligned value, so that end alignment will not fail the
4868   // assert without actually having the fields.
4869   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4870          is_contended_class ||
4871          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4872 
4873   // Number of non-static oop map blocks allocated at end of klass.
4874   nonstatic_oop_maps-&gt;compact();
4875 
4876 #ifndef PRODUCT
4877   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||
<span class="line-modified">4878       (PrintValueLayout &amp;&amp; (is_inline_type() || has_nonstatic_value_fields))) {</span>
4879     print_field_layout(_class_name,
4880           _fields,
4881           cp,
4882           instance_size,
4883           nonstatic_fields_start,
4884           nonstatic_fields_end,
4885           static_fields_end);
4886     nonstatic_oop_maps-&gt;print_on(tty);
4887     tty-&gt;print(&quot;\n&quot;);
4888     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4889     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4890     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4891     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4892     tty-&gt;print_cr(&quot;---&quot;);
4893   }
4894 
4895 #endif
4896   // Pass back information needed for InstanceKlass creation
4897   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4898   info-&gt;_instance_size = instance_size;
</pre>
</td>
<td>
<hr />
<pre>
4402       if (!fs.signature()-&gt;is_Q_signature()) {
4403         THROW(vmSymbols::java_lang_ClassFormatError());
4404       }
4405       static_inline_type_count++;
4406     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {
4407       // Pre-resolve the flattenable field and check for inline type circularity issues.
4408       ResourceMark rm;
4409       if (!fs.signature()-&gt;is_Q_signature()) {
4410         THROW(vmSymbols::java_lang_ClassFormatError());
4411       }
4412       Klass* klass =
4413         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
4414                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4415                                                             _protection_domain, true, CHECK);
4416       assert(klass != NULL, &quot;Sanity check&quot;);
4417       if (!klass-&gt;access_flags().is_inline_type()) {
4418         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4419       }
4420       ValueKlass* vk = ValueKlass::cast(klass);
4421       // Conditions to apply flattening or not should be defined in a single place
<span class="line-modified">4422       bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-modified">4423                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
4424       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
4425       bool too_volatile_to_flatten = fs.access_flags().is_volatile();
4426       if (vk-&gt;is_naturally_atomic()) {
4427         too_atomic_to_flatten = false;
4428         //too_volatile_to_flatten = false; //FIXME
4429         // volatile fields are currently never flattened, this could change in the future
4430       }
4431       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
4432         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();
4433         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;
4434         nonstatic_inline_type_count++;
4435 
4436         ValueKlass* vklass = ValueKlass::cast(klass);
4437         if (vklass-&gt;contains_oops()) {
4438           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();
4439         }
4440         fs.set_flattened(true);
4441         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
4442           not_atomic_inline_types++;
4443         }
</pre>
<hr />
<pre>
4858   int instance_size             = align_object_size(instance_end / wordSize);
4859 
4860   assert(instance_size == align_object_size(align_up(
4861          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
4862          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4863 
4864 
4865   // Invariant: nonstatic_field end/start should only change if there are
4866   // nonstatic fields in the class, or if the class is contended. We compare
4867   // against the non-aligned value, so that end alignment will not fail the
4868   // assert without actually having the fields.
4869   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4870          is_contended_class ||
4871          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4872 
4873   // Number of non-static oop map blocks allocated at end of klass.
4874   nonstatic_oop_maps-&gt;compact();
4875 
4876 #ifndef PRODUCT
4877   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||
<span class="line-modified">4878       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_value_fields))) {</span>
4879     print_field_layout(_class_name,
4880           _fields,
4881           cp,
4882           instance_size,
4883           nonstatic_fields_start,
4884           nonstatic_fields_end,
4885           static_fields_end);
4886     nonstatic_oop_maps-&gt;print_on(tty);
4887     tty-&gt;print(&quot;\n&quot;);
4888     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4889     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4890     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4891     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4892     tty-&gt;print_cr(&quot;---&quot;);
4893   }
4894 
4895 #endif
4896   // Pass back information needed for InstanceKlass creation
4897   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4898   info-&gt;_instance_size = instance_size;
</pre>
</td>
</tr>
</table>
<center><a href="../c1/c1_LIRAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
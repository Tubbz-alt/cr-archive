diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -4417,12 +4417,12 @@
       if (!klass->access_flags().is_inline_type()) {
         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
       }
       ValueKlass* vk = ValueKlass::cast(klass);
       // Conditions to apply flattening or not should be defined in a single place
-      bool too_big_to_flatten = (ValueFieldMaxFlatSize >= 0 &&
-                                 (vk->size_helper() * HeapWordSize) > ValueFieldMaxFlatSize);
+      bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&
+                                 (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);
       bool too_atomic_to_flatten = vk->is_declared_atomic();
       bool too_volatile_to_flatten = fs.access_flags().is_volatile();
       if (vk->is_naturally_atomic()) {
         too_atomic_to_flatten = false;
         //too_volatile_to_flatten = false; //FIXME
@@ -4873,11 +4873,11 @@
   // Number of non-static oop map blocks allocated at end of klass.
   nonstatic_oop_maps->compact();
 
 #ifndef PRODUCT
   if ((PrintFieldLayout && !is_inline_type()) ||
-      (PrintValueLayout && (is_inline_type() || has_nonstatic_value_fields))) {
+      (PrintInlineLayout && (is_inline_type() || has_nonstatic_value_fields))) {
     print_field_layout(_class_name,
           _fields,
           cp,
           instance_size,
           nonstatic_fields_start,

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/fieldLayoutBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/valueArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/fieldLayoutBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 613       if (group != _static_fields) _nonstatic_oopmap_count++;
 614       group-&gt;add_oop_field(fs);
 615       break;
 616     case T_VALUETYPE:
 617       if (group == _static_fields) {
 618         // static fields are never flattened
 619         group-&gt;add_oop_field(fs);
 620       } else {
 621         _has_flattening_information = true;
 622         // Flattening decision to be taken here
 623         // This code assumes all verification have been performed before
 624         // (field is a flattenable field, field&#39;s type has been loaded
 625         // and it is an inline klass
 626         Thread* THREAD = Thread::current();
 627         Klass* klass =
 628             SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
 629                                                                 Handle(THREAD, _class_loader_data-&gt;class_loader()),
 630                                                                 _protection_domain, true, THREAD);
 631         assert(klass != NULL, &quot;Sanity check&quot;);
 632         ValueKlass* vk = ValueKlass::cast(klass);
<span class="line-modified"> 633         bool too_big_to_flatten = (ValueFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-modified"> 634                                    (vk-&gt;size_helper() * HeapWordSize) &gt; ValueFieldMaxFlatSize);</span>
 635         bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
 636         bool too_volatile_to_flatten = fs.access_flags().is_volatile();
 637         if (vk-&gt;is_naturally_atomic()) {
 638           too_atomic_to_flatten = false;
 639           //too_volatile_to_flatten = false; //FIXME
 640           // volatile fields are currently never flattened, this could change in the future
 641         }
 642         if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
 643           group-&gt;add_flattened_field(fs, vk);
 644           _nonstatic_oopmap_count += vk-&gt;nonstatic_oop_map_count();
 645           fs.set_flattened(true);
 646           if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
 647             _has_nonatomic_values = true;
 648             _atomic_field_count--;  // every other field is atomic but this one
 649           }
 650         } else {
 651           _nonstatic_oopmap_count++;
 652           group-&gt;add_oop_field(fs);
 653         }
 654       }
</pre>
<hr />
<pre>
 713         field_alignment = type2aelembytes(type); // alignment == size for oops
 714       }
 715       group-&gt;add_oop_field(fs);
 716       break;
 717     case T_VALUETYPE: {
 718       if (group == _static_fields) {
 719         // static fields are never flattened
 720         group-&gt;add_oop_field(fs);
 721       } else {
 722         // Flattening decision to be taken here
 723         // This code assumes all verifications have been performed before
 724         // (field is a flattenable field, field&#39;s type has been loaded
 725         // and it is an inline klass
 726         Thread* THREAD = Thread::current();
 727         Klass* klass =
 728             SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
 729                 Handle(THREAD, _class_loader_data-&gt;class_loader()),
 730                 _protection_domain, true, CHECK);
 731         assert(klass != NULL, &quot;Sanity check&quot;);
 732         ValueKlass* vk = ValueKlass::cast(klass);
<span class="line-modified"> 733         bool too_big_to_flatten = (ValueFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-modified"> 734                                    (vk-&gt;size_helper() * HeapWordSize) &gt; ValueFieldMaxFlatSize);</span>
 735         bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
 736         bool too_volatile_to_flatten = fs.access_flags().is_volatile();
 737         if (vk-&gt;is_naturally_atomic()) {
 738           too_atomic_to_flatten = false;
 739           //too_volatile_to_flatten = false; //FIXME
 740           // volatile fields are currently never flattened, this could change in the future
 741         }
 742         if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
 743           group-&gt;add_flattened_field(fs, vk);
 744           _nonstatic_oopmap_count += vk-&gt;nonstatic_oop_map_count();
 745           field_alignment = vk-&gt;get_alignment();
 746           fs.set_flattened(true);
 747           if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
 748             _has_nonatomic_values = true;
 749             _atomic_field_count--;  // every other field is atomic but this one
 750           }
 751         } else {
 752           _nonstatic_oopmap_count++;
 753           field_alignment = type2aelembytes(T_OBJECT);
 754           group-&gt;add_oop_field(fs);
</pre>
</td>
<td>
<hr />
<pre>
 613       if (group != _static_fields) _nonstatic_oopmap_count++;
 614       group-&gt;add_oop_field(fs);
 615       break;
 616     case T_VALUETYPE:
 617       if (group == _static_fields) {
 618         // static fields are never flattened
 619         group-&gt;add_oop_field(fs);
 620       } else {
 621         _has_flattening_information = true;
 622         // Flattening decision to be taken here
 623         // This code assumes all verification have been performed before
 624         // (field is a flattenable field, field&#39;s type has been loaded
 625         // and it is an inline klass
 626         Thread* THREAD = Thread::current();
 627         Klass* klass =
 628             SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
 629                                                                 Handle(THREAD, _class_loader_data-&gt;class_loader()),
 630                                                                 _protection_domain, true, THREAD);
 631         assert(klass != NULL, &quot;Sanity check&quot;);
 632         ValueKlass* vk = ValueKlass::cast(klass);
<span class="line-modified"> 633         bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-modified"> 634                                    (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
 635         bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
 636         bool too_volatile_to_flatten = fs.access_flags().is_volatile();
 637         if (vk-&gt;is_naturally_atomic()) {
 638           too_atomic_to_flatten = false;
 639           //too_volatile_to_flatten = false; //FIXME
 640           // volatile fields are currently never flattened, this could change in the future
 641         }
 642         if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
 643           group-&gt;add_flattened_field(fs, vk);
 644           _nonstatic_oopmap_count += vk-&gt;nonstatic_oop_map_count();
 645           fs.set_flattened(true);
 646           if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
 647             _has_nonatomic_values = true;
 648             _atomic_field_count--;  // every other field is atomic but this one
 649           }
 650         } else {
 651           _nonstatic_oopmap_count++;
 652           group-&gt;add_oop_field(fs);
 653         }
 654       }
</pre>
<hr />
<pre>
 713         field_alignment = type2aelembytes(type); // alignment == size for oops
 714       }
 715       group-&gt;add_oop_field(fs);
 716       break;
 717     case T_VALUETYPE: {
 718       if (group == _static_fields) {
 719         // static fields are never flattened
 720         group-&gt;add_oop_field(fs);
 721       } else {
 722         // Flattening decision to be taken here
 723         // This code assumes all verifications have been performed before
 724         // (field is a flattenable field, field&#39;s type has been loaded
 725         // and it is an inline klass
 726         Thread* THREAD = Thread::current();
 727         Klass* klass =
 728             SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,
 729                 Handle(THREAD, _class_loader_data-&gt;class_loader()),
 730                 _protection_domain, true, CHECK);
 731         assert(klass != NULL, &quot;Sanity check&quot;);
 732         ValueKlass* vk = ValueKlass::cast(klass);
<span class="line-modified"> 733         bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-modified"> 734                                    (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
 735         bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
 736         bool too_volatile_to_flatten = fs.access_flags().is_volatile();
 737         if (vk-&gt;is_naturally_atomic()) {
 738           too_atomic_to_flatten = false;
 739           //too_volatile_to_flatten = false; //FIXME
 740           // volatile fields are currently never flattened, this could change in the future
 741         }
 742         if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
 743           group-&gt;add_flattened_field(fs, vk);
 744           _nonstatic_oopmap_count += vk-&gt;nonstatic_oop_map_count();
 745           field_alignment = vk-&gt;get_alignment();
 746           fs.set_flattened(true);
 747           if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
 748             _has_nonatomic_values = true;
 749             _atomic_field_count--;  // every other field is atomic but this one
 750           }
 751         } else {
 752           _nonstatic_oopmap_count++;
 753           field_alignment = type2aelembytes(T_OBJECT);
 754           group-&gt;add_oop_field(fs);
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/valueArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/callnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="callGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="callnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/callnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 717   uint con = proj-&gt;_con;
 718   const TypeTuple *range_cc = tf()-&gt;range_cc();
 719   if (con &gt;= TypeFunc::Parms) {
 720     if (is_CallRuntime()) {
 721       if (con == TypeFunc::Parms) {
 722         uint ideal_reg = range_cc-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();
 723         OptoRegPair regs = match-&gt;c_return_value(ideal_reg,true);
 724         RegMask rm = RegMask(regs.first());
 725         if (OptoReg::is_valid(regs.second())) {
 726           rm.Insert(regs.second());
 727         }
 728         return new MachProjNode(this,con,rm,ideal_reg);
 729       } else {
 730         assert(con == TypeFunc::Parms+1, &quot;only one return value&quot;);
 731         assert(range_cc-&gt;field_at(TypeFunc::Parms+1) == Type::HALF, &quot;&quot;);
 732         return new MachProjNode(this,con, RegMask::Empty, (uint)OptoReg::Bad);
 733       }
 734     } else {
 735       // The Call may return multiple values (value type fields): we
 736       // create one projection per returned values.
<span class="line-modified"> 737       assert(con &lt;= TypeFunc::Parms+1 || ValueTypeReturnedAsFields, &quot;only for multi value return&quot;);</span>
 738       uint ideal_reg = range_cc-&gt;field_at(con)-&gt;ideal_reg();
 739       return new MachProjNode(this, con, mask[con-TypeFunc::Parms], ideal_reg);
 740     }
 741   }
 742 
 743   switch (con) {
 744   case TypeFunc::Control:
 745   case TypeFunc::I_O:
 746   case TypeFunc::Memory:
 747     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
 748 
 749   case TypeFunc::ReturnAdr:
 750   case TypeFunc::FramePtr:
 751   default:
 752     ShouldNotReachHere();
 753   }
 754   return NULL;
 755 }
 756 
 757 // Do we Match on this edge index or not?  Match no edges
</pre>
</td>
<td>
<hr />
<pre>
 717   uint con = proj-&gt;_con;
 718   const TypeTuple *range_cc = tf()-&gt;range_cc();
 719   if (con &gt;= TypeFunc::Parms) {
 720     if (is_CallRuntime()) {
 721       if (con == TypeFunc::Parms) {
 722         uint ideal_reg = range_cc-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();
 723         OptoRegPair regs = match-&gt;c_return_value(ideal_reg,true);
 724         RegMask rm = RegMask(regs.first());
 725         if (OptoReg::is_valid(regs.second())) {
 726           rm.Insert(regs.second());
 727         }
 728         return new MachProjNode(this,con,rm,ideal_reg);
 729       } else {
 730         assert(con == TypeFunc::Parms+1, &quot;only one return value&quot;);
 731         assert(range_cc-&gt;field_at(TypeFunc::Parms+1) == Type::HALF, &quot;&quot;);
 732         return new MachProjNode(this,con, RegMask::Empty, (uint)OptoReg::Bad);
 733       }
 734     } else {
 735       // The Call may return multiple values (value type fields): we
 736       // create one projection per returned values.
<span class="line-modified"> 737       assert(con &lt;= TypeFunc::Parms+1 || InlineTypeReturnedAsFields, &quot;only for multi value return&quot;);</span>
 738       uint ideal_reg = range_cc-&gt;field_at(con)-&gt;ideal_reg();
 739       return new MachProjNode(this, con, mask[con-TypeFunc::Parms], ideal_reg);
 740     }
 741   }
 742 
 743   switch (con) {
 744   case TypeFunc::Control:
 745   case TypeFunc::I_O:
 746   case TypeFunc::Memory:
 747     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
 748 
 749   case TypeFunc::ReturnAdr:
 750   case TypeFunc::FramePtr:
 751   default:
 752     ShouldNotReachHere();
 753   }
 754   return NULL;
 755 }
 756 
 757 // Do we Match on this edge index or not?  Match no edges
</pre>
</td>
</tr>
</table>
<center><a href="callGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="callnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
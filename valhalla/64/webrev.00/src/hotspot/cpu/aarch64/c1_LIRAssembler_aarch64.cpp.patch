diff a/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
@@ -496,11 +496,11 @@
 void LIR_Assembler::return_op(LIR_Opr result) {
   assert(result->is_illegal() || !result->is_single_cpu() || result->as_register() == r0, "word returns are in r0,");
 
   ciMethod* method = compilation()->method();
 
-  if (ValueTypeReturnedAsFields && method->signature()->returns_never_null()) {
+  if (InlineTypeReturnedAsFields && method->signature()->returns_never_null()) {
     ciType* return_type = method->return_type();
     if (return_type->is_valuetype()) {
       ciValueKlass* vk = return_type->as_value_klass();
       if (vk->can_be_returned_as_fields()) {
         address unpack_handler = vk->unpack_handler();
@@ -1584,11 +1584,11 @@
 
 }
 
 void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {
   // This is called when we use aastore into a an array declared as "[LVT;",
-  // where we know VT is not flattenable (due to ValueArrayElemMaxFlatOops, etc).
+  // where we know VT is not flattenable (due to InlineArrayElemMaxFlatSize, etc).
   // However, we need to do a NULL check if the actual array is a "[QVT;".
 
   __ load_storage_props(op->tmp()->as_register(), op->array()->as_register());
   __ mov(rscratch1, (uint64_t) ArrayStorageProperties::null_free_value);
   __ cmp(op->tmp()->as_register(), rscratch1);

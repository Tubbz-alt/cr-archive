<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../hotspot/share/runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  34 import sun.invoke.util.Wrapper;
  35 
  36 import java.lang.ref.WeakReference;
  37 import java.util.Arrays;
  38 import java.util.Objects;
  39 
  40 import static java.lang.invoke.LambdaForm.*;
  41 import static java.lang.invoke.LambdaForm.Kind.*;
  42 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  44 import static java.lang.invoke.MethodHandleStatics.newInternalError;
  45 import static java.lang.invoke.MethodTypeForm.*;
  46 
  47 /**
  48  * The flavor of method handle which implements a constant reference
  49  * to a class member.
  50  * @author jrose
  51  */
  52 class DirectMethodHandle extends MethodHandle {
  53     final MemberName member;

  54 
  55     // Constructors and factory methods in this class *must* be package scoped or private.
<span class="line-modified">  56     private DirectMethodHandle(MethodType mtype, LambdaForm form, MemberName member) {</span>
  57         super(mtype, form);
  58         if (!member.isResolved())  throw new InternalError();
  59 
  60         if (member.getDeclaringClass().isInterface() &amp;&amp;
  61             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
  62             member.isMethod() &amp;&amp; !member.isAbstract()) {
  63             // Check for corner case: invokeinterface of Object method
  64             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
  65             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
  66             if (m != null &amp;&amp; m.isPublic()) {
  67                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
  68                 member = m;
  69             }
  70         }
  71 
  72         this.member = member;

  73     }
  74 
  75     // Factory methods:
  76     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
  77         MethodType mtype = member.getMethodOrFieldType();
  78         if (!member.isStatic()) {
  79             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())
  80                 throw new InternalError(member.toString());
  81             mtype = mtype.insertParameterTypes(0, refc);
  82         }
  83         if (!member.isField()) {
  84             // refKind reflects the original type of lookup via findSpecial or
  85             // findVirtual etc.
  86             switch (refKind) {
  87                 case REF_invokeSpecial: {
  88                     member = member.asSpecial();
  89                     // if caller is an interface we need to adapt to get the
  90                     // receiver check inserted
  91                     if (callerClass == null) {
  92                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
  93                     }
  94                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
<span class="line-modified">  95                     return new Special(mtype, lform, member, callerClass);</span>
  96                 }
  97                 case REF_invokeInterface: {
  98                     // for interfaces we always need the receiver typecheck,
  99                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 100                     // to include the REF_invokeSpecial case
 101                     LambdaForm lform = preparedLambdaForm(member, true);
<span class="line-modified"> 102                     return new Interface(mtype, lform, member, refc);</span>
 103                 }
 104                 default: {
 105                     LambdaForm lform = preparedLambdaForm(member);
<span class="line-modified"> 106                     return new DirectMethodHandle(mtype, lform, member);</span>
 107                 }
 108             }
 109         } else {
 110             LambdaForm lform = preparedFieldLambdaForm(member);
 111             if (member.isStatic()) {
 112                 long offset = MethodHandleNatives.staticFieldOffset(member);
 113                 Object base = MethodHandleNatives.staticFieldBase(member);
 114                 return member.isIndirect() ? new IndirectStaticAccessor(mtype, lform, member, base, offset)
 115                                            : new InlineStaticAccessor(mtype, lform, member, base, offset);
 116             } else {
 117                 long offset = MethodHandleNatives.objectFieldOffset(member);
 118                 assert(offset == (int)offset);
 119                 return  member.isIndirect() ? new IndirectAccessor(mtype, lform, member, (int)offset)
 120                                             : new InlineAccessor(mtype, lform, member, (int)offset);
 121             }
 122         }
 123     }
 124     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
 125         byte refKind = member.getReferenceKind();
 126         if (refKind == REF_invokeSpecial)
 127             refKind =  REF_invokeVirtual;
 128         return make(refKind, refc, member, null /* no callerClass context */);
 129     }
 130     static DirectMethodHandle make(MemberName member) {
 131         if (member.isObjectConstructor() &amp;&amp; member.getReturnType() == void.class)
 132             return makeAllocator(member);
 133         return make(member.getDeclaringClass(), member);
 134     }
 135     private static DirectMethodHandle makeAllocator(MemberName ctor) {
 136         assert(ctor.isObjectConstructor() &amp;&amp; !ctor.getDeclaringClass().isInlineClass()) : ctor;
 137 
 138         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
 139         ctor = ctor.asObjectConstructor();
 140         assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;
 141         MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
 142         LambdaForm lform = preparedLambdaForm(ctor);
 143         MemberName init = ctor.asSpecial();
 144         assert(init.getMethodType().returnType() == void.class);
<span class="line-modified"> 145         return new Constructor(mtype, lform, ctor, init, instanceClass);</span>
 146     }
 147 
 148     @Override
 149     BoundMethodHandle rebind() {
 150         return BoundMethodHandle.makeReinvoker(this);
 151     }
 152 
 153     @Override
 154     MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 155         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
<span class="line-modified"> 156         return new DirectMethodHandle(mt, lf, member);</span>















 157     }
 158 
 159     @Override
 160     String internalProperties() {
 161         return &quot;\n&amp; DMH.MN=&quot;+internalMemberName();
 162     }
 163 
 164     //// Implementation methods.
 165     @Override
 166     @ForceInline
 167     MemberName internalMemberName() {
 168         return member;
 169     }
 170 
 171     private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
 172 
 173     /**
 174      * Create a LF which can invoke the given method.
 175      * Cache and share this structure among all methods with
 176      * the same basicType and refKind.
</pre>
<hr />
<pre>
 392                 // Yes, we are running it; keep the barrier for now.
 393                 return false;
 394         } else {
 395             // We are in a random thread.  Block.
 396             UNSAFE.ensureClassInitialized(defc);
 397         }
 398         assert(!UNSAFE.shouldBeInitialized(defc));
 399         // put it into the final state
 400         EnsureInitialized.INSTANCE.remove(defc);
 401         return true;
 402     }
 403 
 404     /*non-public*/
 405     static void ensureInitialized(Object mh) {
 406         ((DirectMethodHandle)mh).ensureInitialized();
 407     }
 408 
 409     /** This subclass represents invokespecial instructions. */
 410     static class Special extends DirectMethodHandle {
 411         private final Class&lt;?&gt; caller;
<span class="line-modified"> 412         private Special(MethodType mtype, LambdaForm form, MemberName member, Class&lt;?&gt; caller) {</span>
<span class="line-modified"> 413             super(mtype, form, member);</span>
 414             this.caller = caller;
 415         }
 416         @Override
 417         boolean isInvokeSpecial() {
 418             return true;
 419         }
 420         @Override
 421         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 422             return new Special(mt, lf, member, caller);</span>





 423         }
 424         Object checkReceiver(Object recv) {
 425             if (!caller.isInstance(recv)) {
 426                 String msg = String.format(&quot;Receiver class %s is not a subclass of caller class %s&quot;,
 427                                            recv.getClass().getName(), caller.getName());
 428                 throw new IncompatibleClassChangeError(msg);
 429             }
 430             return recv;
 431         }
 432     }
 433 
 434     /** This subclass represents invokeinterface instructions. */
 435     static class Interface extends DirectMethodHandle {
 436         private final Class&lt;?&gt; refc;
<span class="line-modified"> 437         private Interface(MethodType mtype, LambdaForm form, MemberName member, Class&lt;?&gt; refc) {</span>
<span class="line-modified"> 438             super(mtype, form, member);</span>
<span class="line-modified"> 439             assert refc.isInterface() : refc;</span>
 440             this.refc = refc;
 441         }
 442         @Override
 443         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 444             return new Interface(mt, lf, member, refc);</span>





 445         }
 446         @Override
 447         Object checkReceiver(Object recv) {
 448             if (!refc.isInstance(recv)) {
 449                 String msg = String.format(&quot;Receiver class %s does not implement the requested interface %s&quot;,
 450                                            recv.getClass().getName(), refc.getName());
 451                 throw new IncompatibleClassChangeError(msg);
 452             }
 453             return recv;
 454         }
 455     }
 456 
 457     /** Used for interface receiver type checks, by Interface and Special modes. */
 458     Object checkReceiver(Object recv) {
 459         throw new InternalError(&quot;Should only be invoked on a subclass&quot;);
 460     }
 461 
<span class="line-removed"> 462 </span>
 463     /** This subclass handles constructor references. */
 464     static class Constructor extends DirectMethodHandle {
 465         final MemberName initMethod;
 466         final Class&lt;?&gt;   instanceClass;
 467 
 468         private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
<span class="line-modified"> 469                             MemberName initMethod, Class&lt;?&gt; instanceClass) {</span>
<span class="line-modified"> 470             super(mtype, form, constructor);</span>
 471             this.initMethod = initMethod;
 472             this.instanceClass = instanceClass;
 473             assert(initMethod.isResolved());
 474         }
 475         @Override
 476         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 477             return new Constructor(mt, lf, member, initMethod, instanceClass);</span>





 478         }
 479     }
 480 
 481     /*non-public*/
 482     static Object constructorMethod(Object mh) {
 483         Constructor dmh = (Constructor)mh;
 484         return dmh.initMethod;
 485     }
 486 
 487     /*non-public*/
 488     static Object allocateInstance(Object mh) throws InstantiationException {
 489         Constructor dmh = (Constructor)mh;
 490         return UNSAFE.allocateInstance(dmh.instanceClass);
 491     }
 492 
 493     /** This subclass handles non-static field references. */
 494     static abstract class Accessor extends DirectMethodHandle {
 495         final Class&lt;?&gt; fieldType;
<span class="line-modified"> 496         final int fieldOffset;</span>
<span class="line-modified"> 497 </span>
<span class="line-modified"> 498         protected Accessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-modified"> 499                            int fieldOffset) {</span>
<span class="line-modified"> 500             super(mtype, form, member);</span>
<span class="line-removed"> 501             this.fieldType = member.getFieldType();</span>
 502             this.fieldOffset = fieldOffset;
 503         }
 504         abstract Object checkCast(Object obj);
 505         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
 506     }
 507 
 508     /** This subclass handles non-static field references of indirect type */
 509     static class IndirectAccessor extends Accessor {
 510         private IndirectAccessor(MethodType mtype, LambdaForm form, MemberName member,
 511                                  int fieldOffset) {
<span class="line-modified"> 512             super(mtype, form, member, fieldOffset);</span>
 513         }
 514 
 515         @Override Object checkCast(Object obj) {
 516             return fieldType.cast(obj);
 517         }
 518         @Override
 519         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 520             return new IndirectAccessor(mt, lf, member, fieldOffset);
 521         }





 522     }
 523 
 524     /** This subclass handles non-static field references of inline type */
 525     static class InlineAccessor extends Accessor {
 526         private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
 527                                int fieldOffset) {
<span class="line-modified"> 528             super(mtype, form, member, fieldOffset);</span>
 529         }
 530 
 531         @Override Object checkCast(Object obj) {
 532             return fieldType.cast(Objects.requireNonNull(obj));
 533         }
 534         @Override
 535         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 536             return new InlineAccessor(mt, lf, member, fieldOffset);
 537         }
 538     }
 539 
 540     @ForceInline
 541     /*non-public*/
 542     static long fieldOffset(Object accessorObj) {
 543         // Note: We return a long because that is what Unsafe.getObject likes.
 544         // We store a plain int because it is more compact.
 545         return ((Accessor)accessorObj).fieldOffset;
 546     }
 547 
 548     @ForceInline
 549     /*non-public*/
 550     static Object checkBase(Object obj) {
 551         // Note that the object&#39;s class has already been verified,
 552         // since the parameter type of the Accessor method handle
 553         // is either member.getDeclaringClass or a subclass.
 554         // This was verified in DirectMethodHandle.make.
 555         // Therefore, the only remaining check is for null.
 556         // Since this check is *not* guaranteed by Unsafe.getInt
 557         // and its siblings, we need to make an explicit one here.
 558         return Objects.requireNonNull(obj);
 559     }
 560 
 561     static abstract class StaticAccessor extends DirectMethodHandle {
 562         final Class&lt;?&gt; fieldType;
 563         final Object staticBase;
 564         final long staticOffset;
 565 
<span class="line-modified"> 566         protected StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-modified"> 567                                  Object staticBase, long staticOffset) {</span>
<span class="line-modified"> 568             super(mtype, form, member);</span>
<span class="line-modified"> 569             this.fieldType = member.getFieldType();</span>
<span class="line-modified"> 570             this.staticBase = staticBase;</span>
 571             this.staticOffset = staticOffset;
 572         }
 573         abstract Object checkCast(Object obj);
 574         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
 575     }
 576 
 577     /** This subclass handles static field references of indirect type. */
 578     static class IndirectStaticAccessor extends StaticAccessor {
 579         private IndirectStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 580                                      Object staticBase, long staticOffset) {
<span class="line-modified"> 581             super(mtype, form, member, staticBase, staticOffset);</span>
 582         }
 583 
 584         // indirect type is always nullable
 585         @Override Object checkCast(Object obj) {
 586             return fieldType.cast(obj);
 587         }
 588         @Override
 589         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 590             return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);
 591         }





 592     }
 593 
 594     /** This subclass handles static field references of inline type . */
 595     static class InlineStaticAccessor extends StaticAccessor {
 596         private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 597                                      Object staticBase, long staticOffset) {
<span class="line-modified"> 598             super(mtype, form, member, staticBase, staticOffset);</span>
 599         }
 600 
 601         // zero-default inline type is not-nullable
 602         @Override Object checkCast(Object obj) {
 603             assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;
 604             return fieldType.cast(Objects.requireNonNull(obj));
 605         }
 606         @Override
 607         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 608             return new InlineStaticAccessor(mt, lf, member, staticBase, staticOffset);
 609         }
 610     }
 611 
 612     @ForceInline
 613     /*non-public*/
 614     static Object nullCheck(Object obj) {
 615         return Objects.requireNonNull(obj);
 616     }
 617 
 618     @ForceInline
</pre>
</td>
<td>
<hr />
<pre>
  34 import sun.invoke.util.Wrapper;
  35 
  36 import java.lang.ref.WeakReference;
  37 import java.util.Arrays;
  38 import java.util.Objects;
  39 
  40 import static java.lang.invoke.LambdaForm.*;
  41 import static java.lang.invoke.LambdaForm.Kind.*;
  42 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  44 import static java.lang.invoke.MethodHandleStatics.newInternalError;
  45 import static java.lang.invoke.MethodTypeForm.*;
  46 
  47 /**
  48  * The flavor of method handle which implements a constant reference
  49  * to a class member.
  50  * @author jrose
  51  */
  52 class DirectMethodHandle extends MethodHandle {
  53     final MemberName member;
<span class="line-added">  54     final boolean crackable;</span>
  55 
  56     // Constructors and factory methods in this class *must* be package scoped or private.
<span class="line-modified">  57     private DirectMethodHandle(MethodType mtype, LambdaForm form, MemberName member, boolean crackable) {</span>
  58         super(mtype, form);
  59         if (!member.isResolved())  throw new InternalError();
  60 
  61         if (member.getDeclaringClass().isInterface() &amp;&amp;
  62             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
  63             member.isMethod() &amp;&amp; !member.isAbstract()) {
  64             // Check for corner case: invokeinterface of Object method
  65             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
  66             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
  67             if (m != null &amp;&amp; m.isPublic()) {
  68                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
  69                 member = m;
  70             }
  71         }
  72 
  73         this.member = member;
<span class="line-added">  74         this.crackable = crackable;</span>
  75     }
  76 
  77     // Factory methods:
  78     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
  79         MethodType mtype = member.getMethodOrFieldType();
  80         if (!member.isStatic()) {
  81             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())
  82                 throw new InternalError(member.toString());
  83             mtype = mtype.insertParameterTypes(0, refc);
  84         }
  85         if (!member.isField()) {
  86             // refKind reflects the original type of lookup via findSpecial or
  87             // findVirtual etc.
  88             switch (refKind) {
  89                 case REF_invokeSpecial: {
  90                     member = member.asSpecial();
  91                     // if caller is an interface we need to adapt to get the
  92                     // receiver check inserted
  93                     if (callerClass == null) {
  94                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
  95                     }
  96                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
<span class="line-modified">  97                     return new Special(mtype, lform, member, true, callerClass);</span>
  98                 }
  99                 case REF_invokeInterface: {
 100                     // for interfaces we always need the receiver typecheck,
 101                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 102                     // to include the REF_invokeSpecial case
 103                     LambdaForm lform = preparedLambdaForm(member, true);
<span class="line-modified"> 104                     return new Interface(mtype, lform, member, true, refc);</span>
 105                 }
 106                 default: {
 107                     LambdaForm lform = preparedLambdaForm(member);
<span class="line-modified"> 108                     return new DirectMethodHandle(mtype, lform, member, true);</span>
 109                 }
 110             }
 111         } else {
 112             LambdaForm lform = preparedFieldLambdaForm(member);
 113             if (member.isStatic()) {
 114                 long offset = MethodHandleNatives.staticFieldOffset(member);
 115                 Object base = MethodHandleNatives.staticFieldBase(member);
 116                 return member.isIndirect() ? new IndirectStaticAccessor(mtype, lform, member, base, offset)
 117                                            : new InlineStaticAccessor(mtype, lform, member, base, offset);
 118             } else {
 119                 long offset = MethodHandleNatives.objectFieldOffset(member);
 120                 assert(offset == (int)offset);
 121                 return  member.isIndirect() ? new IndirectAccessor(mtype, lform, member, (int)offset)
 122                                             : new InlineAccessor(mtype, lform, member, (int)offset);
 123             }
 124         }
 125     }
 126     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
 127         byte refKind = member.getReferenceKind();
 128         if (refKind == REF_invokeSpecial)
 129             refKind =  REF_invokeVirtual;
 130         return make(refKind, refc, member, null /* no callerClass context */);
 131     }
 132     static DirectMethodHandle make(MemberName member) {
 133         if (member.isObjectConstructor() &amp;&amp; member.getReturnType() == void.class)
 134             return makeAllocator(member);
 135         return make(member.getDeclaringClass(), member);
 136     }
 137     private static DirectMethodHandle makeAllocator(MemberName ctor) {
 138         assert(ctor.isObjectConstructor() &amp;&amp; !ctor.getDeclaringClass().isInlineClass()) : ctor;
 139 
 140         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
 141         ctor = ctor.asObjectConstructor();
 142         assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;
 143         MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
 144         LambdaForm lform = preparedLambdaForm(ctor);
 145         MemberName init = ctor.asSpecial();
 146         assert(init.getMethodType().returnType() == void.class);
<span class="line-modified"> 147         return new Constructor(mtype, lform, ctor, true, init, instanceClass);</span>
 148     }
 149 
 150     @Override
 151     BoundMethodHandle rebind() {
 152         return BoundMethodHandle.makeReinvoker(this);
 153     }
 154 
 155     @Override
 156     MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 157         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
<span class="line-modified"> 158         return new DirectMethodHandle(mt, lf, member, crackable);</span>
<span class="line-added"> 159     }</span>
<span class="line-added"> 160 </span>
<span class="line-added"> 161     @Override</span>
<span class="line-added"> 162     MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 163         // No actual conversions, just a new view of the same method.</span>
<span class="line-added"> 164         // However, we must not expose a DMH that is crackable into a</span>
<span class="line-added"> 165         // MethodHandleInfo, so we return a cloned, uncrackable DMH</span>
<span class="line-added"> 166         assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 167         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses</span>
<span class="line-added"> 168         return new DirectMethodHandle(newType, form, member, false);</span>
<span class="line-added"> 169     }</span>
<span class="line-added"> 170 </span>
<span class="line-added"> 171     @Override</span>
<span class="line-added"> 172     boolean isCrackable() {</span>
<span class="line-added"> 173         return crackable;</span>
 174     }
 175 
 176     @Override
 177     String internalProperties() {
 178         return &quot;\n&amp; DMH.MN=&quot;+internalMemberName();
 179     }
 180 
 181     //// Implementation methods.
 182     @Override
 183     @ForceInline
 184     MemberName internalMemberName() {
 185         return member;
 186     }
 187 
 188     private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
 189 
 190     /**
 191      * Create a LF which can invoke the given method.
 192      * Cache and share this structure among all methods with
 193      * the same basicType and refKind.
</pre>
<hr />
<pre>
 409                 // Yes, we are running it; keep the barrier for now.
 410                 return false;
 411         } else {
 412             // We are in a random thread.  Block.
 413             UNSAFE.ensureClassInitialized(defc);
 414         }
 415         assert(!UNSAFE.shouldBeInitialized(defc));
 416         // put it into the final state
 417         EnsureInitialized.INSTANCE.remove(defc);
 418         return true;
 419     }
 420 
 421     /*non-public*/
 422     static void ensureInitialized(Object mh) {
 423         ((DirectMethodHandle)mh).ensureInitialized();
 424     }
 425 
 426     /** This subclass represents invokespecial instructions. */
 427     static class Special extends DirectMethodHandle {
 428         private final Class&lt;?&gt; caller;
<span class="line-modified"> 429         private Special(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; caller) {</span>
<span class="line-modified"> 430             super(mtype, form, member, crackable);</span>
 431             this.caller = caller;
 432         }
 433         @Override
 434         boolean isInvokeSpecial() {
 435             return true;
 436         }
 437         @Override
 438         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 439             return new Special(mt, lf, member, crackable, caller);</span>
<span class="line-added"> 440         }</span>
<span class="line-added"> 441         @Override</span>
<span class="line-added"> 442         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 443             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 444             return new Special(newType, form, member, false, caller);</span>
 445         }
 446         Object checkReceiver(Object recv) {
 447             if (!caller.isInstance(recv)) {
 448                 String msg = String.format(&quot;Receiver class %s is not a subclass of caller class %s&quot;,
 449                                            recv.getClass().getName(), caller.getName());
 450                 throw new IncompatibleClassChangeError(msg);
 451             }
 452             return recv;
 453         }
 454     }
 455 
 456     /** This subclass represents invokeinterface instructions. */
 457     static class Interface extends DirectMethodHandle {
 458         private final Class&lt;?&gt; refc;
<span class="line-modified"> 459         private Interface(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; refc) {</span>
<span class="line-modified"> 460             super(mtype, form, member, crackable);</span>
<span class="line-modified"> 461             assert(refc.isInterface()) : refc;</span>
 462             this.refc = refc;
 463         }
 464         @Override
 465         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 466             return new Interface(mt, lf, member, crackable, refc);</span>
<span class="line-added"> 467         }</span>
<span class="line-added"> 468         @Override</span>
<span class="line-added"> 469         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 470             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 471             return new Interface(newType, form, member, false, refc);</span>
 472         }
 473         @Override
 474         Object checkReceiver(Object recv) {
 475             if (!refc.isInstance(recv)) {
 476                 String msg = String.format(&quot;Receiver class %s does not implement the requested interface %s&quot;,
 477                                            recv.getClass().getName(), refc.getName());
 478                 throw new IncompatibleClassChangeError(msg);
 479             }
 480             return recv;
 481         }
 482     }
 483 
 484     /** Used for interface receiver type checks, by Interface and Special modes. */
 485     Object checkReceiver(Object recv) {
 486         throw new InternalError(&quot;Should only be invoked on a subclass&quot;);
 487     }
 488 

 489     /** This subclass handles constructor references. */
 490     static class Constructor extends DirectMethodHandle {
 491         final MemberName initMethod;
 492         final Class&lt;?&gt;   instanceClass;
 493 
 494         private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
<span class="line-modified"> 495                             boolean crackable, MemberName initMethod, Class&lt;?&gt; instanceClass) {</span>
<span class="line-modified"> 496             super(mtype, form, constructor, crackable);</span>
 497             this.initMethod = initMethod;
 498             this.instanceClass = instanceClass;
 499             assert(initMethod.isResolved());
 500         }
 501         @Override
 502         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 503             return new Constructor(mt, lf, member, crackable, initMethod, instanceClass);</span>
<span class="line-added"> 504         }</span>
<span class="line-added"> 505         @Override</span>
<span class="line-added"> 506         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 507             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 508             return new Constructor(newType, form, member, false, initMethod, instanceClass);</span>
 509         }
 510     }
 511 
 512     /*non-public*/
 513     static Object constructorMethod(Object mh) {
 514         Constructor dmh = (Constructor)mh;
 515         return dmh.initMethod;
 516     }
 517 
 518     /*non-public*/
 519     static Object allocateInstance(Object mh) throws InstantiationException {
 520         Constructor dmh = (Constructor)mh;
 521         return UNSAFE.allocateInstance(dmh.instanceClass);
 522     }
 523 
 524     /** This subclass handles non-static field references. */
 525     static abstract class Accessor extends DirectMethodHandle {
 526         final Class&lt;?&gt; fieldType;
<span class="line-modified"> 527         final int      fieldOffset;</span>
<span class="line-modified"> 528         private Accessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-modified"> 529                          boolean crackable, int fieldOffset) {</span>
<span class="line-modified"> 530             super(mtype, form, member, crackable);</span>
<span class="line-modified"> 531             this.fieldType   = member.getFieldType();</span>

 532             this.fieldOffset = fieldOffset;
 533         }
 534         abstract Object checkCast(Object obj);
 535         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
 536     }
 537 
 538     /** This subclass handles non-static field references of indirect type */
 539     static class IndirectAccessor extends Accessor {
 540         private IndirectAccessor(MethodType mtype, LambdaForm form, MemberName member,
 541                                  int fieldOffset) {
<span class="line-modified"> 542             super(mtype, form, member, true, fieldOffset);</span>
 543         }
 544 
 545         @Override Object checkCast(Object obj) {
 546             return fieldType.cast(obj);
 547         }
 548         @Override
 549         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 550             return new IndirectAccessor(mt, lf, member, fieldOffset);
 551         }
<span class="line-added"> 552         @Override</span>
<span class="line-added"> 553         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 554             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 555             return new IndirectAccessor(newType, form, member, fieldOffset);</span>
<span class="line-added"> 556         }</span>
 557     }
 558 
 559     /** This subclass handles non-static field references of inline type */
 560     static class InlineAccessor extends Accessor {
 561         private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
 562                                int fieldOffset) {
<span class="line-modified"> 563             super(mtype, form, member, true, fieldOffset);</span>
 564         }
 565 
 566         @Override Object checkCast(Object obj) {
 567             return fieldType.cast(Objects.requireNonNull(obj));
 568         }
 569         @Override
 570         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 571             return new InlineAccessor(mt, lf, member, fieldOffset);
 572         }
 573     }
 574 
 575     @ForceInline
 576     /*non-public*/
 577     static long fieldOffset(Object accessorObj) {
 578         // Note: We return a long because that is what Unsafe.getObject likes.
 579         // We store a plain int because it is more compact.
 580         return ((Accessor)accessorObj).fieldOffset;
 581     }
 582 
 583     @ForceInline
 584     /*non-public*/
 585     static Object checkBase(Object obj) {
 586         // Note that the object&#39;s class has already been verified,
 587         // since the parameter type of the Accessor method handle
 588         // is either member.getDeclaringClass or a subclass.
 589         // This was verified in DirectMethodHandle.make.
 590         // Therefore, the only remaining check is for null.
 591         // Since this check is *not* guaranteed by Unsafe.getInt
 592         // and its siblings, we need to make an explicit one here.
 593         return Objects.requireNonNull(obj);
 594     }
 595 
 596     static abstract class StaticAccessor extends DirectMethodHandle {
 597         final Class&lt;?&gt; fieldType;
 598         final Object staticBase;
 599         final long staticOffset;
 600 
<span class="line-modified"> 601         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-modified"> 602                                boolean crackable, Object staticBase, long staticOffset) {</span>
<span class="line-modified"> 603             super(mtype, form, member, crackable);</span>
<span class="line-modified"> 604             this.fieldType    = member.getFieldType();</span>
<span class="line-modified"> 605             this.staticBase   = staticBase;</span>
 606             this.staticOffset = staticOffset;
 607         }
 608         abstract Object checkCast(Object obj);
 609         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
 610     }
 611 
 612     /** This subclass handles static field references of indirect type. */
 613     static class IndirectStaticAccessor extends StaticAccessor {
 614         private IndirectStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 615                                      Object staticBase, long staticOffset) {
<span class="line-modified"> 616             super(mtype, form, member, true, staticBase, staticOffset);</span>
 617         }
 618 
 619         // indirect type is always nullable
 620         @Override Object checkCast(Object obj) {
 621             return fieldType.cast(obj);
 622         }
 623         @Override
 624         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 625             return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);
 626         }
<span class="line-added"> 627         @Override</span>
<span class="line-added"> 628         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 629             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 630             return new IndirectStaticAccessor(newType, form, member, staticBase, staticOffset);</span>
<span class="line-added"> 631         }</span>
 632     }
 633 
 634     /** This subclass handles static field references of inline type . */
 635     static class InlineStaticAccessor extends StaticAccessor {
 636         private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 637                                      Object staticBase, long staticOffset) {
<span class="line-modified"> 638             super(mtype, form, member, true, staticBase, staticOffset);</span>
 639         }
 640 
 641         // zero-default inline type is not-nullable
 642         @Override Object checkCast(Object obj) {
 643             assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;
 644             return fieldType.cast(Objects.requireNonNull(obj));
 645         }
 646         @Override
 647         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 648             return new InlineStaticAccessor(mt, lf, member, staticBase, staticOffset);
 649         }
 650     }
 651 
 652     @ForceInline
 653     /*non-public*/
 654     static Object nullCheck(Object obj) {
 655         return Objects.requireNonNull(obj);
 656     }
 657 
 658     @ForceInline
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../hotspot/share/runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
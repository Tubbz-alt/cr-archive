<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.misc.Unsafe;
  29 import jdk.internal.vm.annotation.ForceInline;
  30 import jdk.internal.vm.annotation.Stable;
  31 import sun.invoke.util.ValueConversions;
  32 import sun.invoke.util.VerifyAccess;
  33 import sun.invoke.util.VerifyType;
  34 import sun.invoke.util.Wrapper;
  35 
  36 import java.lang.ref.WeakReference;
  37 import java.util.Arrays;
  38 import java.util.Objects;
  39 
  40 import static java.lang.invoke.LambdaForm.*;
  41 import static java.lang.invoke.LambdaForm.Kind.*;
  42 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  44 import static java.lang.invoke.MethodHandleStatics.newInternalError;
  45 import static java.lang.invoke.MethodTypeForm.*;
  46 
  47 /**
  48  * The flavor of method handle which implements a constant reference
  49  * to a class member.
  50  * @author jrose
  51  */
  52 class DirectMethodHandle extends MethodHandle {
  53     final MemberName member;
<a name="1" id="anc1"></a><span class="line-added">  54     final boolean crackable;</span>
  55 
  56     // Constructors and factory methods in this class *must* be package scoped or private.
<a name="2" id="anc2"></a><span class="line-modified">  57     private DirectMethodHandle(MethodType mtype, LambdaForm form, MemberName member, boolean crackable) {</span>
  58         super(mtype, form);
  59         if (!member.isResolved())  throw new InternalError();
  60 
  61         if (member.getDeclaringClass().isInterface() &amp;&amp;
  62             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
  63             member.isMethod() &amp;&amp; !member.isAbstract()) {
  64             // Check for corner case: invokeinterface of Object method
  65             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
  66             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
  67             if (m != null &amp;&amp; m.isPublic()) {
  68                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
  69                 member = m;
  70             }
  71         }
  72 
  73         this.member = member;
<a name="3" id="anc3"></a><span class="line-added">  74         this.crackable = crackable;</span>
  75     }
  76 
  77     // Factory methods:
  78     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
  79         MethodType mtype = member.getMethodOrFieldType();
  80         if (!member.isStatic()) {
  81             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())
  82                 throw new InternalError(member.toString());
  83             mtype = mtype.insertParameterTypes(0, refc);
  84         }
  85         if (!member.isField()) {
  86             // refKind reflects the original type of lookup via findSpecial or
  87             // findVirtual etc.
  88             switch (refKind) {
  89                 case REF_invokeSpecial: {
  90                     member = member.asSpecial();
  91                     // if caller is an interface we need to adapt to get the
  92                     // receiver check inserted
  93                     if (callerClass == null) {
  94                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
  95                     }
  96                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
<a name="4" id="anc4"></a><span class="line-modified">  97                     return new Special(mtype, lform, member, true, callerClass);</span>
  98                 }
  99                 case REF_invokeInterface: {
 100                     // for interfaces we always need the receiver typecheck,
 101                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 102                     // to include the REF_invokeSpecial case
 103                     LambdaForm lform = preparedLambdaForm(member, true);
<a name="5" id="anc5"></a><span class="line-modified"> 104                     return new Interface(mtype, lform, member, true, refc);</span>
 105                 }
 106                 default: {
 107                     LambdaForm lform = preparedLambdaForm(member);
<a name="6" id="anc6"></a><span class="line-modified"> 108                     return new DirectMethodHandle(mtype, lform, member, true);</span>
 109                 }
 110             }
 111         } else {
 112             LambdaForm lform = preparedFieldLambdaForm(member);
 113             if (member.isStatic()) {
 114                 long offset = MethodHandleNatives.staticFieldOffset(member);
 115                 Object base = MethodHandleNatives.staticFieldBase(member);
 116                 return member.isIndirect() ? new IndirectStaticAccessor(mtype, lform, member, base, offset)
 117                                            : new InlineStaticAccessor(mtype, lform, member, base, offset);
 118             } else {
 119                 long offset = MethodHandleNatives.objectFieldOffset(member);
 120                 assert(offset == (int)offset);
 121                 return  member.isIndirect() ? new IndirectAccessor(mtype, lform, member, (int)offset)
 122                                             : new InlineAccessor(mtype, lform, member, (int)offset);
 123             }
 124         }
 125     }
 126     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
 127         byte refKind = member.getReferenceKind();
 128         if (refKind == REF_invokeSpecial)
 129             refKind =  REF_invokeVirtual;
 130         return make(refKind, refc, member, null /* no callerClass context */);
 131     }
 132     static DirectMethodHandle make(MemberName member) {
 133         if (member.isObjectConstructor() &amp;&amp; member.getReturnType() == void.class)
 134             return makeAllocator(member);
 135         return make(member.getDeclaringClass(), member);
 136     }
 137     private static DirectMethodHandle makeAllocator(MemberName ctor) {
 138         assert(ctor.isObjectConstructor() &amp;&amp; !ctor.getDeclaringClass().isInlineClass()) : ctor;
 139 
 140         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
 141         ctor = ctor.asObjectConstructor();
 142         assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;
 143         MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
 144         LambdaForm lform = preparedLambdaForm(ctor);
 145         MemberName init = ctor.asSpecial();
 146         assert(init.getMethodType().returnType() == void.class);
<a name="7" id="anc7"></a><span class="line-modified"> 147         return new Constructor(mtype, lform, ctor, true, init, instanceClass);</span>
 148     }
 149 
 150     @Override
 151     BoundMethodHandle rebind() {
 152         return BoundMethodHandle.makeReinvoker(this);
 153     }
 154 
 155     @Override
 156     MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 157         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
<a name="8" id="anc8"></a><span class="line-modified"> 158         return new DirectMethodHandle(mt, lf, member, crackable);</span>
<span class="line-added"> 159     }</span>
<span class="line-added"> 160 </span>
<span class="line-added"> 161     @Override</span>
<span class="line-added"> 162     MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 163         // No actual conversions, just a new view of the same method.</span>
<span class="line-added"> 164         // However, we must not expose a DMH that is crackable into a</span>
<span class="line-added"> 165         // MethodHandleInfo, so we return a cloned, uncrackable DMH</span>
<span class="line-added"> 166         assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 167         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses</span>
<span class="line-added"> 168         return new DirectMethodHandle(newType, form, member, false);</span>
<span class="line-added"> 169     }</span>
<span class="line-added"> 170 </span>
<span class="line-added"> 171     @Override</span>
<span class="line-added"> 172     boolean isCrackable() {</span>
<span class="line-added"> 173         return crackable;</span>
 174     }
 175 
 176     @Override
 177     String internalProperties() {
 178         return &quot;\n&amp; DMH.MN=&quot;+internalMemberName();
 179     }
 180 
 181     //// Implementation methods.
 182     @Override
 183     @ForceInline
 184     MemberName internalMemberName() {
 185         return member;
 186     }
 187 
 188     private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
 189 
 190     /**
 191      * Create a LF which can invoke the given method.
 192      * Cache and share this structure among all methods with
 193      * the same basicType and refKind.
 194      */
 195     private static LambdaForm preparedLambdaForm(MemberName m, boolean adaptToSpecialIfc) {
 196         assert(m.isInvocable()) : m;  // call preparedFieldLambdaForm instead
 197         MethodType mtype = m.getInvocationType().basicType();
 198         assert(!m.isMethodHandleInvoke()) : m;
 199         int which;
 200         // MemberName.getReferenceKind represents the JVM optimized form of the call
 201         // as distinct from the &quot;kind&quot; passed to DMH.make which represents the original
 202         // bytecode-equivalent request. Specifically private/final methods that use a direct
 203         // call have getReferenceKind adapted to REF_invokeSpecial, even though the actual
 204         // invocation mode may be invokevirtual or invokeinterface.
 205         switch (m.getReferenceKind()) {
 206         case REF_invokeVirtual:    which = LF_INVVIRTUAL;    break;
 207         case REF_invokeStatic:     which = LF_INVSTATIC;     break;
 208         case REF_invokeSpecial:    which = LF_INVSPECIAL;    break;
 209         case REF_invokeInterface:  which = LF_INVINTERFACE;  break;
 210         case REF_newInvokeSpecial: which = LF_NEWINVSPECIAL; break;
 211         default:  throw new InternalError(m.toString());
 212         }
 213         if (which == LF_INVSTATIC &amp;&amp; shouldBeInitialized(m)) {
 214             // precompute the barrier-free version:
 215             preparedLambdaForm(mtype, which);
 216             which = LF_INVSTATIC_INIT;
 217         }
 218         if (which == LF_INVSPECIAL &amp;&amp; adaptToSpecialIfc) {
 219             which = LF_INVSPECIAL_IFC;
 220         }
 221         LambdaForm lform = preparedLambdaForm(mtype, which);
 222         maybeCompile(lform, m);
 223         assert(lform.methodType().dropParameterTypes(0, 1)
 224                 .equals(m.getInvocationType().basicType()))
 225                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
 226         return lform;
 227     }
 228 
 229     private static LambdaForm preparedLambdaForm(MemberName m) {
 230         return preparedLambdaForm(m, false);
 231     }
 232 
 233     private static LambdaForm preparedLambdaForm(MethodType mtype, int which) {
 234         LambdaForm lform = mtype.form().cachedLambdaForm(which);
 235         if (lform != null)  return lform;
 236         lform = makePreparedLambdaForm(mtype, which);
 237         return mtype.form().setCachedLambdaForm(which, lform);
 238     }
 239 
 240     static LambdaForm makePreparedLambdaForm(MethodType mtype, int which) {
 241         boolean needsInit = (which == LF_INVSTATIC_INIT);
 242         boolean doesAlloc = (which == LF_NEWINVSPECIAL);
 243         boolean needsReceiverCheck = (which == LF_INVINTERFACE ||
 244                                       which == LF_INVSPECIAL_IFC);
 245 
 246         String linkerName;
 247         LambdaForm.Kind kind;
 248         switch (which) {
 249         case LF_INVVIRTUAL:    linkerName = &quot;linkToVirtual&quot;;   kind = DIRECT_INVOKE_VIRTUAL;     break;
 250         case LF_INVSTATIC:     linkerName = &quot;linkToStatic&quot;;    kind = DIRECT_INVOKE_STATIC;      break;
 251         case LF_INVSTATIC_INIT:linkerName = &quot;linkToStatic&quot;;    kind = DIRECT_INVOKE_STATIC_INIT; break;
 252         case LF_INVSPECIAL_IFC:linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_INVOKE_SPECIAL_IFC; break;
 253         case LF_INVSPECIAL:    linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_INVOKE_SPECIAL;     break;
 254         case LF_INVINTERFACE:  linkerName = &quot;linkToInterface&quot;; kind = DIRECT_INVOKE_INTERFACE;   break;
 255         case LF_NEWINVSPECIAL: linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_NEW_INVOKE_SPECIAL; break;
 256         default:  throw new InternalError(&quot;which=&quot;+which);
 257         }
 258 
 259         MethodType mtypeWithArg = mtype.appendParameterTypes(MemberName.class);
 260         if (doesAlloc)
 261             mtypeWithArg = mtypeWithArg
 262                     .insertParameterTypes(0, Object.class)  // insert newly allocated obj
 263                     .changeReturnType(void.class);          // &lt;init&gt; returns void
 264         MemberName linker = new MemberName(MethodHandle.class, linkerName, mtypeWithArg, REF_invokeStatic);
 265         try {
 266             linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, NoSuchMethodException.class);
 267         } catch (ReflectiveOperationException ex) {
 268             throw newInternalError(ex);
 269         }
 270         final int DMH_THIS    = 0;
 271         final int ARG_BASE    = 1;
 272         final int ARG_LIMIT   = ARG_BASE + mtype.parameterCount();
 273         int nameCursor = ARG_LIMIT;
 274         final int NEW_OBJ     = (doesAlloc ? nameCursor++ : -1);
 275         final int GET_MEMBER  = nameCursor++;
 276         final int CHECK_RECEIVER = (needsReceiverCheck ? nameCursor++ : -1);
 277         final int LINKER_CALL = nameCursor++;
 278         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
 279         assert(names.length == nameCursor);
 280         if (doesAlloc) {
 281             // names = { argx,y,z,... new C, init method }
 282             names[NEW_OBJ] = new Name(getFunction(NF_allocateInstance), names[DMH_THIS]);
 283             names[GET_MEMBER] = new Name(getFunction(NF_constructorMethod), names[DMH_THIS]);
 284         } else if (needsInit) {
 285             names[GET_MEMBER] = new Name(getFunction(NF_internalMemberNameEnsureInit), names[DMH_THIS]);
 286         } else {
 287             names[GET_MEMBER] = new Name(getFunction(NF_internalMemberName), names[DMH_THIS]);
 288         }
 289         assert(findDirectMethodHandle(names[GET_MEMBER]) == names[DMH_THIS]);
 290         Object[] outArgs = Arrays.copyOfRange(names, ARG_BASE, GET_MEMBER+1, Object[].class);
 291         if (needsReceiverCheck) {
 292             names[CHECK_RECEIVER] = new Name(getFunction(NF_checkReceiver), names[DMH_THIS], names[ARG_BASE]);
 293             outArgs[0] = names[CHECK_RECEIVER];
 294         }
 295         assert(outArgs[outArgs.length-1] == names[GET_MEMBER]);  // look, shifted args!
 296         int result = LAST_RESULT;
 297         if (doesAlloc) {
 298             assert(outArgs[outArgs.length-2] == names[NEW_OBJ]);  // got to move this one
 299             System.arraycopy(outArgs, 0, outArgs, 1, outArgs.length-2);
 300             outArgs[0] = names[NEW_OBJ];
 301             result = NEW_OBJ;
 302         }
 303         names[LINKER_CALL] = new Name(linker, outArgs);
 304         LambdaForm lform = new LambdaForm(ARG_LIMIT, names, result, kind);
 305 
 306         // This is a tricky bit of code.  Don&#39;t send it through the LF interpreter.
 307         lform.compileToBytecode();
 308         return lform;
 309     }
 310 
 311     /* assert */ static Object findDirectMethodHandle(Name name) {
 312         if (name.function.equals(getFunction(NF_internalMemberName)) ||
 313             name.function.equals(getFunction(NF_internalMemberNameEnsureInit)) ||
 314             name.function.equals(getFunction(NF_constructorMethod))) {
 315             assert(name.arguments.length == 1);
 316             return name.arguments[0];
 317         }
 318         return null;
 319     }
 320 
 321     private static void maybeCompile(LambdaForm lform, MemberName m) {
 322         if (lform.vmentry == null &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), MethodHandle.class))
 323             // Help along bootstrapping...
 324             lform.compileToBytecode();
 325     }
 326 
 327     /** Static wrapper for DirectMethodHandle.internalMemberName. */
 328     @ForceInline
 329     /*non-public*/
 330     static Object internalMemberName(Object mh) {
 331         return ((DirectMethodHandle)mh).member;
 332     }
 333 
 334     /** Static wrapper for DirectMethodHandle.internalMemberName.
 335      * This one also forces initialization.
 336      */
 337     /*non-public*/
 338     static Object internalMemberNameEnsureInit(Object mh) {
 339         DirectMethodHandle dmh = (DirectMethodHandle)mh;
 340         dmh.ensureInitialized();
 341         return dmh.member;
 342     }
 343 
 344     /*non-public*/
 345     static boolean shouldBeInitialized(MemberName member) {
 346         switch (member.getReferenceKind()) {
 347         case REF_invokeStatic:
 348         case REF_getStatic:
 349         case REF_putStatic:
 350         case REF_newInvokeSpecial:
 351             break;
 352         default:
 353             // No need to initialize the class on this kind of member.
 354             return false;
 355         }
 356         Class&lt;?&gt; cls = member.getDeclaringClass();
 357         if (cls == ValueConversions.class ||
 358             cls == MethodHandleImpl.class ||
 359             cls == Invokers.class) {
 360             // These guys have lots of &lt;clinit&gt; DMH creation but we know
 361             // the MHs will not be used until the system is booted.
 362             return false;
 363         }
 364         if (VerifyAccess.isSamePackage(MethodHandle.class, cls) ||
 365             VerifyAccess.isSamePackage(ValueConversions.class, cls)) {
 366             // It is a system class.  It is probably in the process of
 367             // being initialized, but we will help it along just to be safe.
 368             if (UNSAFE.shouldBeInitialized(cls)) {
 369                 UNSAFE.ensureClassInitialized(cls);
 370             }
 371             return false;
 372         }
 373         return UNSAFE.shouldBeInitialized(cls);
 374     }
 375 
 376     private static class EnsureInitialized extends ClassValue&lt;WeakReference&lt;Thread&gt;&gt; {
 377         @Override
 378         protected WeakReference&lt;Thread&gt; computeValue(Class&lt;?&gt; type) {
 379             UNSAFE.ensureClassInitialized(type);
 380             if (UNSAFE.shouldBeInitialized(type))
 381                 // If the previous call didn&#39;t block, this can happen.
 382                 // We are executing inside &lt;clinit&gt;.
 383                 return new WeakReference&lt;&gt;(Thread.currentThread());
 384             return null;
 385         }
 386         static final EnsureInitialized INSTANCE = new EnsureInitialized();
 387     }
 388 
 389     private void ensureInitialized() {
 390         if (checkInitialized(member)) {
 391             // The coast is clear.  Delete the &lt;clinit&gt; barrier.
 392             if (member.isField())
 393                 updateForm(preparedFieldLambdaForm(member));
 394             else
 395                 updateForm(preparedLambdaForm(member));
 396         }
 397     }
 398     private static boolean checkInitialized(MemberName member) {
 399         Class&lt;?&gt; defc = member.getDeclaringClass();
 400         WeakReference&lt;Thread&gt; ref = EnsureInitialized.INSTANCE.get(defc);
 401         if (ref == null) {
 402             return true;  // the final state
 403         }
 404         Thread clinitThread = ref.get();
 405         // Somebody may still be running defc.&lt;clinit&gt;.
 406         if (clinitThread == Thread.currentThread()) {
 407             // If anybody is running defc.&lt;clinit&gt;, it is this thread.
 408             if (UNSAFE.shouldBeInitialized(defc))
 409                 // Yes, we are running it; keep the barrier for now.
 410                 return false;
 411         } else {
 412             // We are in a random thread.  Block.
 413             UNSAFE.ensureClassInitialized(defc);
 414         }
 415         assert(!UNSAFE.shouldBeInitialized(defc));
 416         // put it into the final state
 417         EnsureInitialized.INSTANCE.remove(defc);
 418         return true;
 419     }
 420 
 421     /*non-public*/
 422     static void ensureInitialized(Object mh) {
 423         ((DirectMethodHandle)mh).ensureInitialized();
 424     }
 425 
 426     /** This subclass represents invokespecial instructions. */
 427     static class Special extends DirectMethodHandle {
 428         private final Class&lt;?&gt; caller;
<a name="9" id="anc9"></a><span class="line-modified"> 429         private Special(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; caller) {</span>
<span class="line-modified"> 430             super(mtype, form, member, crackable);</span>
 431             this.caller = caller;
 432         }
 433         @Override
 434         boolean isInvokeSpecial() {
 435             return true;
 436         }
 437         @Override
 438         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<a name="10" id="anc10"></a><span class="line-modified"> 439             return new Special(mt, lf, member, crackable, caller);</span>
<span class="line-added"> 440         }</span>
<span class="line-added"> 441         @Override</span>
<span class="line-added"> 442         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 443             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 444             return new Special(newType, form, member, false, caller);</span>
 445         }
 446         Object checkReceiver(Object recv) {
 447             if (!caller.isInstance(recv)) {
 448                 String msg = String.format(&quot;Receiver class %s is not a subclass of caller class %s&quot;,
 449                                            recv.getClass().getName(), caller.getName());
 450                 throw new IncompatibleClassChangeError(msg);
 451             }
 452             return recv;
 453         }
 454     }
 455 
 456     /** This subclass represents invokeinterface instructions. */
 457     static class Interface extends DirectMethodHandle {
 458         private final Class&lt;?&gt; refc;
<a name="11" id="anc11"></a><span class="line-modified"> 459         private Interface(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; refc) {</span>
<span class="line-modified"> 460             super(mtype, form, member, crackable);</span>
<span class="line-modified"> 461             assert(refc.isInterface()) : refc;</span>
 462             this.refc = refc;
 463         }
 464         @Override
 465         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<a name="12" id="anc12"></a><span class="line-modified"> 466             return new Interface(mt, lf, member, crackable, refc);</span>
<span class="line-added"> 467         }</span>
<span class="line-added"> 468         @Override</span>
<span class="line-added"> 469         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 470             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 471             return new Interface(newType, form, member, false, refc);</span>
 472         }
 473         @Override
 474         Object checkReceiver(Object recv) {
 475             if (!refc.isInstance(recv)) {
 476                 String msg = String.format(&quot;Receiver class %s does not implement the requested interface %s&quot;,
 477                                            recv.getClass().getName(), refc.getName());
 478                 throw new IncompatibleClassChangeError(msg);
 479             }
 480             return recv;
 481         }
 482     }
 483 
 484     /** Used for interface receiver type checks, by Interface and Special modes. */
 485     Object checkReceiver(Object recv) {
 486         throw new InternalError(&quot;Should only be invoked on a subclass&quot;);
 487     }
 488 
<a name="13" id="anc13"></a>
 489     /** This subclass handles constructor references. */
 490     static class Constructor extends DirectMethodHandle {
 491         final MemberName initMethod;
 492         final Class&lt;?&gt;   instanceClass;
 493 
 494         private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
<a name="14" id="anc14"></a><span class="line-modified"> 495                             boolean crackable, MemberName initMethod, Class&lt;?&gt; instanceClass) {</span>
<span class="line-modified"> 496             super(mtype, form, constructor, crackable);</span>
 497             this.initMethod = initMethod;
 498             this.instanceClass = instanceClass;
 499             assert(initMethod.isResolved());
 500         }
 501         @Override
 502         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<a name="15" id="anc15"></a><span class="line-modified"> 503             return new Constructor(mt, lf, member, crackable, initMethod, instanceClass);</span>
<span class="line-added"> 504         }</span>
<span class="line-added"> 505         @Override</span>
<span class="line-added"> 506         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 507             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 508             return new Constructor(newType, form, member, false, initMethod, instanceClass);</span>
 509         }
 510     }
 511 
 512     /*non-public*/
 513     static Object constructorMethod(Object mh) {
 514         Constructor dmh = (Constructor)mh;
 515         return dmh.initMethod;
 516     }
 517 
 518     /*non-public*/
 519     static Object allocateInstance(Object mh) throws InstantiationException {
 520         Constructor dmh = (Constructor)mh;
 521         return UNSAFE.allocateInstance(dmh.instanceClass);
 522     }
 523 
 524     /** This subclass handles non-static field references. */
 525     static abstract class Accessor extends DirectMethodHandle {
 526         final Class&lt;?&gt; fieldType;
<a name="16" id="anc16"></a><span class="line-modified"> 527         final int      fieldOffset;</span>
<span class="line-modified"> 528         private Accessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-modified"> 529                          boolean crackable, int fieldOffset) {</span>
<span class="line-modified"> 530             super(mtype, form, member, crackable);</span>
<span class="line-modified"> 531             this.fieldType   = member.getFieldType();</span>

 532             this.fieldOffset = fieldOffset;
 533         }
 534         abstract Object checkCast(Object obj);
 535         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
 536     }
 537 
 538     /** This subclass handles non-static field references of indirect type */
 539     static class IndirectAccessor extends Accessor {
 540         private IndirectAccessor(MethodType mtype, LambdaForm form, MemberName member,
 541                                  int fieldOffset) {
<a name="17" id="anc17"></a><span class="line-modified"> 542             super(mtype, form, member, true, fieldOffset);</span>
 543         }
 544 
 545         @Override Object checkCast(Object obj) {
 546             return fieldType.cast(obj);
 547         }
 548         @Override
 549         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 550             return new IndirectAccessor(mt, lf, member, fieldOffset);
 551         }
<a name="18" id="anc18"></a><span class="line-added"> 552         @Override</span>
<span class="line-added"> 553         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 554             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 555             return new IndirectAccessor(newType, form, member, fieldOffset);</span>
<span class="line-added"> 556         }</span>
 557     }
 558 
 559     /** This subclass handles non-static field references of inline type */
 560     static class InlineAccessor extends Accessor {
 561         private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
 562                                int fieldOffset) {
<a name="19" id="anc19"></a><span class="line-modified"> 563             super(mtype, form, member, true, fieldOffset);</span>
 564         }
 565 
 566         @Override Object checkCast(Object obj) {
 567             return fieldType.cast(Objects.requireNonNull(obj));
 568         }
 569         @Override
 570         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 571             return new InlineAccessor(mt, lf, member, fieldOffset);
 572         }
 573     }
 574 
 575     @ForceInline
 576     /*non-public*/
 577     static long fieldOffset(Object accessorObj) {
 578         // Note: We return a long because that is what Unsafe.getObject likes.
 579         // We store a plain int because it is more compact.
 580         return ((Accessor)accessorObj).fieldOffset;
 581     }
 582 
 583     @ForceInline
 584     /*non-public*/
 585     static Object checkBase(Object obj) {
 586         // Note that the object&#39;s class has already been verified,
 587         // since the parameter type of the Accessor method handle
 588         // is either member.getDeclaringClass or a subclass.
 589         // This was verified in DirectMethodHandle.make.
 590         // Therefore, the only remaining check is for null.
 591         // Since this check is *not* guaranteed by Unsafe.getInt
 592         // and its siblings, we need to make an explicit one here.
 593         return Objects.requireNonNull(obj);
 594     }
 595 
 596     static abstract class StaticAccessor extends DirectMethodHandle {
 597         final Class&lt;?&gt; fieldType;
 598         final Object staticBase;
 599         final long staticOffset;
 600 
<a name="20" id="anc20"></a><span class="line-modified"> 601         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-modified"> 602                                boolean crackable, Object staticBase, long staticOffset) {</span>
<span class="line-modified"> 603             super(mtype, form, member, crackable);</span>
<span class="line-modified"> 604             this.fieldType    = member.getFieldType();</span>
<span class="line-modified"> 605             this.staticBase   = staticBase;</span>
 606             this.staticOffset = staticOffset;
 607         }
 608         abstract Object checkCast(Object obj);
 609         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
 610     }
 611 
 612     /** This subclass handles static field references of indirect type. */
 613     static class IndirectStaticAccessor extends StaticAccessor {
 614         private IndirectStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 615                                      Object staticBase, long staticOffset) {
<a name="21" id="anc21"></a><span class="line-modified"> 616             super(mtype, form, member, true, staticBase, staticOffset);</span>
 617         }
 618 
 619         // indirect type is always nullable
 620         @Override Object checkCast(Object obj) {
 621             return fieldType.cast(obj);
 622         }
 623         @Override
 624         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 625             return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);
 626         }
<a name="22" id="anc22"></a><span class="line-added"> 627         @Override</span>
<span class="line-added"> 628         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 629             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 630             return new IndirectStaticAccessor(newType, form, member, staticBase, staticOffset);</span>
<span class="line-added"> 631         }</span>
 632     }
 633 
 634     /** This subclass handles static field references of inline type . */
 635     static class InlineStaticAccessor extends StaticAccessor {
 636         private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 637                                      Object staticBase, long staticOffset) {
<a name="23" id="anc23"></a><span class="line-modified"> 638             super(mtype, form, member, true, staticBase, staticOffset);</span>
 639         }
 640 
 641         // zero-default inline type is not-nullable
 642         @Override Object checkCast(Object obj) {
 643             assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;
 644             return fieldType.cast(Objects.requireNonNull(obj));
 645         }
 646         @Override
 647         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 648             return new InlineStaticAccessor(mt, lf, member, staticBase, staticOffset);
 649         }
 650     }
 651 
 652     @ForceInline
 653     /*non-public*/
 654     static Object nullCheck(Object obj) {
 655         return Objects.requireNonNull(obj);
 656     }
 657 
 658     @ForceInline
 659     /*non-public*/
 660     static Object staticBase(Object accessorObj) {
 661         return ((StaticAccessor)accessorObj).staticBase;
 662     }
 663 
 664     @ForceInline
 665     /*non-public*/
 666     static long staticOffset(Object accessorObj) {
 667         return ((StaticAccessor)accessorObj).staticOffset;
 668     }
 669 
 670     @ForceInline
 671     /*non-public*/
 672     static Object checkCast(Object mh, Object obj) {
 673         return ((DirectMethodHandle) mh).checkCast(obj);
 674     }
 675 
 676     @ForceInline
 677     /*non-public*/ static Class&lt;?&gt; fieldType(Object accessorObj) {
 678         return ((Accessor) accessorObj).fieldType;
 679     }
 680 
 681     @ForceInline
 682     /*non-public*/ static Class&lt;?&gt; staticFieldType(Object accessorObj) {
 683         return ((StaticAccessor) accessorObj).fieldType;
 684     }
 685 
 686     Object checkCast(Object obj) {
 687         return member.getReturnType().cast(obj);
 688     }
 689 
 690     // Caching machinery for field accessors:
 691     static final byte
 692             AF_GETFIELD        = 0,
 693             AF_PUTFIELD        = 1,
 694             AF_GETSTATIC       = 2,
 695             AF_PUTSTATIC       = 3,
 696             AF_GETSTATIC_INIT  = 4,
 697             AF_PUTSTATIC_INIT  = 5,
 698             AF_LIMIT           = 6;
 699     // Enumerate the different field kinds using Wrapper,
 700     // with an extra case added for checked references and value field access
 701     static final int
 702             FT_LAST_WRAPPER     = Wrapper.COUNT-1,
 703             FT_UNCHECKED_REF    = Wrapper.OBJECT.ordinal(),
 704             FT_CHECKED_REF      = FT_LAST_WRAPPER+1,
 705             FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  // flattened and non-flattened
 706             FT_LIMIT            = FT_LAST_WRAPPER+4;
 707     private static int afIndex(byte formOp, boolean isVolatile, boolean isFlatValue, int ftypeKind) {
 708         return ((formOp * FT_LIMIT * 2)
 709                 + (isVolatile ? FT_LIMIT : 0)
 710                 + (isFlatValue ? 1 : 0)
 711                 + ftypeKind);
 712     }
 713     @Stable
 714     private static final LambdaForm[] ACCESSOR_FORMS
 715             = new LambdaForm[afIndex(AF_LIMIT, false, false, 0)];
 716     static int ftypeKind(Class&lt;?&gt; ftype, boolean isValue) {
 717         if (ftype.isPrimitive())
 718             return Wrapper.forPrimitiveType(ftype).ordinal();
 719         else if (VerifyType.isNullReferenceConversion(Object.class, ftype)) {
 720             return FT_UNCHECKED_REF;
 721         } else
 722             // null check for value type in addition to check cast
 723             return isValue ? FT_CHECKED_VALUE : FT_CHECKED_REF;
 724     }
 725 
 726     /**
 727      * Create a LF which can access the given field.
 728      * Cache and share this structure among all fields with
 729      * the same basicType and refKind.
 730      */
 731     private static LambdaForm preparedFieldLambdaForm(MemberName m) {
 732         Class&lt;?&gt; ftype = m.getFieldType();
 733         byte formOp;
 734         switch (m.getReferenceKind()) {
 735         case REF_getField:      formOp = AF_GETFIELD;    break;
 736         case REF_putField:      formOp = AF_PUTFIELD;    break;
 737         case REF_getStatic:     formOp = AF_GETSTATIC;   break;
 738         case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
 739         default:  throw new InternalError(m.toString());
 740         }
 741         if (shouldBeInitialized(m)) {
 742             // precompute the barrier-free version:
 743             preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineable(), m.isFlattened(), ftype);
 744             assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
 745                    (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
 746             formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
 747         }
 748         LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineable(), m.isFlattened(), ftype);
 749         maybeCompile(lform, m);
 750         assert(lform.methodType().dropParameterTypes(0, 1)
 751                 .equals(m.getInvocationType().basicType()))
 752                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
 753         return lform;
 754     }
 755 
 756     private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, Class&lt;?&gt; ftype) {
 757         int ftypeKind = ftypeKind(ftype, isValue);
 758         int afIndex = afIndex(formOp, isVolatile, isFlatValue, ftypeKind);
 759         LambdaForm lform = ACCESSOR_FORMS[afIndex];
 760         if (lform != null)  return lform;
 761         lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlatValue, ftypeKind);
 762         ACCESSOR_FORMS[afIndex] = lform;  // don&#39;t bother with a CAS
 763         return lform;
 764     }
 765 
 766     private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();
 767 
 768     private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlatValue, Wrapper wrapper) {
 769         if (isGetter) {
 770             if (isVolatile) {
 771                 switch (wrapper) {
 772                     case BOOLEAN: return GET_BOOLEAN_VOLATILE;
 773                     case BYTE:    return GET_BYTE_VOLATILE;
 774                     case SHORT:   return GET_SHORT_VOLATILE;
 775                     case CHAR:    return GET_CHAR_VOLATILE;
 776                     case INT:     return GET_INT_VOLATILE;
 777                     case LONG:    return GET_LONG_VOLATILE;
 778                     case FLOAT:   return GET_FLOAT_VOLATILE;
 779                     case DOUBLE:  return GET_DOUBLE_VOLATILE;
 780                     case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;
 781                 }
 782             } else {
 783                 switch (wrapper) {
 784                     case BOOLEAN: return GET_BOOLEAN;
 785                     case BYTE:    return GET_BYTE;
 786                     case SHORT:   return GET_SHORT;
 787                     case CHAR:    return GET_CHAR;
 788                     case INT:     return GET_INT;
 789                     case LONG:    return GET_LONG;
 790                     case FLOAT:   return GET_FLOAT;
 791                     case DOUBLE:  return GET_DOUBLE;
 792                     case OBJECT:  return isFlatValue ? GET_VALUE : GET_REFERENCE;
 793                 }
 794             }
 795         } else {
 796             if (isVolatile) {
 797                 switch (wrapper) {
 798                     case BOOLEAN: return PUT_BOOLEAN_VOLATILE;
 799                     case BYTE:    return PUT_BYTE_VOLATILE;
 800                     case SHORT:   return PUT_SHORT_VOLATILE;
 801                     case CHAR:    return PUT_CHAR_VOLATILE;
 802                     case INT:     return PUT_INT_VOLATILE;
 803                     case LONG:    return PUT_LONG_VOLATILE;
 804                     case FLOAT:   return PUT_FLOAT_VOLATILE;
 805                     case DOUBLE:  return PUT_DOUBLE_VOLATILE;
 806                     case OBJECT:  return isFlatValue ? PUT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;
 807                 }
 808             } else {
 809                 switch (wrapper) {
 810                     case BOOLEAN: return PUT_BOOLEAN;
 811                     case BYTE:    return PUT_BYTE;
 812                     case SHORT:   return PUT_SHORT;
 813                     case CHAR:    return PUT_CHAR;
 814                     case INT:     return PUT_INT;
 815                     case LONG:    return PUT_LONG;
 816                     case FLOAT:   return PUT_FLOAT;
 817                     case DOUBLE:  return PUT_DOUBLE;
 818                     case OBJECT:  return isFlatValue ? PUT_VALUE : PUT_REFERENCE;
 819                 }
 820             }
 821         }
 822         throw new AssertionError(&quot;Invalid arguments&quot;);
 823     }
 824 
 825     /** invoked by GenerateJLIClassesHelper */
 826     static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftype) {
 827         return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);
 828     }
 829 
 830     private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, int ftypeKind) {
 831         boolean isGetter  = (formOp &amp; 1) == (AF_GETFIELD &amp; 1);
 832         boolean isStatic  = (formOp &gt;= AF_GETSTATIC);
 833         boolean needsInit = (formOp &gt;= AF_GETSTATIC_INIT);
 834         boolean needsCast = (ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_VALUE);
 835         Wrapper fw = (needsCast ? Wrapper.OBJECT : ALL_WRAPPERS[ftypeKind]);
 836         Class&lt;?&gt; ft = fw.primitiveType();
 837         assert(needsCast ? true : ftypeKind(ft, isValue) == ftypeKind);
 838 
 839         // getObject, putIntVolatile, etc.
 840         Kind kind = getFieldKind(isGetter, isVolatile, isFlatValue, fw);
 841 
 842         MethodType linkerType;
 843         boolean hasValueTypeArg = isGetter ? isValue : isFlatValue;
 844         if (isGetter) {
 845             linkerType = isValue ? MethodType.methodType(ft, Object.class, long.class, Class.class)
 846                                  : MethodType.methodType(ft, Object.class, long.class);
 847         } else {
 848             linkerType = isFlatValue ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)
 849                                      : MethodType.methodType(void.class, Object.class, long.class, ft);
 850         }
 851         MemberName linker = new MemberName(Unsafe.class, kind.methodName, linkerType, REF_invokeVirtual);
 852         try {
 853             linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, NoSuchMethodException.class);
 854         } catch (ReflectiveOperationException ex) {
 855             throw newInternalError(ex);
 856         }
 857 
 858         // What is the external type of the lambda form?
 859         MethodType mtype;
 860         if (isGetter)
 861             mtype = MethodType.methodType(ft);
 862         else
 863             mtype = MethodType.methodType(void.class, ft);
 864         mtype = mtype.basicType();  // erase short to int, etc.
 865         if (!isStatic)
 866             mtype = mtype.insertParameterTypes(0, Object.class);
 867         final int DMH_THIS  = 0;
 868         final int ARG_BASE  = 1;
 869         final int ARG_LIMIT = ARG_BASE + mtype.parameterCount();
 870         // if this is for non-static access, the base pointer is stored at this index:
 871         final int OBJ_BASE  = isStatic ? -1 : ARG_BASE;
 872         // if this is for write access, the value to be written is stored at this index:
 873         final int SET_VALUE  = isGetter ? -1 : ARG_LIMIT - 1;
 874         int nameCursor = ARG_LIMIT;
 875         final int F_HOLDER  = (isStatic ? nameCursor++ : -1);  // static base if any
 876         final int F_OFFSET  = nameCursor++;  // Either static offset or field offset.
 877         final int OBJ_CHECK = (OBJ_BASE &gt;= 0 ? nameCursor++ : -1);
 878         final int U_HOLDER  = nameCursor++;  // UNSAFE holder
 879         final int INIT_BAR  = (needsInit ? nameCursor++ : -1);
 880         final int VALUE_TYPE = (hasValueTypeArg ? nameCursor++ : -1);
 881         final int PRE_CAST  = (needsCast &amp;&amp; !isGetter ? nameCursor++ : -1);
 882         final int LINKER_CALL = nameCursor++;
 883         final int POST_CAST = (needsCast &amp;&amp; isGetter ? nameCursor++ : -1);
 884         final int RESULT    = nameCursor-1;  // either the call or the cast
 885         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
 886         if (needsInit)
 887             names[INIT_BAR] = new Name(getFunction(NF_ensureInitialized), names[DMH_THIS]);
 888         if (needsCast &amp;&amp; !isGetter)
 889             names[PRE_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[SET_VALUE]);
 890         Object[] outArgs = new Object[1 + linkerType.parameterCount()];
 891         assert (outArgs.length == (isGetter ? 3 : 4) + (hasValueTypeArg ? 1 : 0));
 892         outArgs[0] = names[U_HOLDER] = new Name(getFunction(NF_UNSAFE));
 893         if (isStatic) {
 894             outArgs[1] = names[F_HOLDER]  = new Name(getFunction(NF_staticBase), names[DMH_THIS]);
 895             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_staticOffset), names[DMH_THIS]);
 896         } else {
 897             outArgs[1] = names[OBJ_CHECK] = new Name(getFunction(NF_checkBase), names[OBJ_BASE]);
 898             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_fieldOffset), names[DMH_THIS]);
 899         }
 900         int x = 3;
 901         if (hasValueTypeArg) {
 902             outArgs[x++] = names[VALUE_TYPE] = isStatic ? new Name(getFunction(NF_staticFieldType), names[DMH_THIS])
 903                                                         : new Name(getFunction(NF_fieldType), names[DMH_THIS]);
 904         }
 905         if (!isGetter) {
 906             outArgs[x] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);
 907         }
 908         for (Object a : outArgs)  assert(a != null);
 909         names[LINKER_CALL] = new Name(linker, outArgs);
 910         if (needsCast &amp;&amp; isGetter)
 911             names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[LINKER_CALL]);
 912         for (Name n : names)  assert(n != null);
 913 
 914         LambdaForm form;
 915         if (needsCast || needsInit) {
 916             // can&#39;t use the pre-generated form when casting and/or initializing
 917             form = new LambdaForm(ARG_LIMIT, names, RESULT);
 918         } else {
 919             form = new LambdaForm(ARG_LIMIT, names, RESULT, kind);
 920         }
 921 
 922         if (LambdaForm.debugNames()) {
 923             // add some detail to the lambdaForm debugname,
 924             // significant only for debugging
 925             StringBuilder nameBuilder = new StringBuilder(kind.methodName);
 926             if (isStatic) {
 927                 nameBuilder.append(&quot;Static&quot;);
 928             } else {
 929                 nameBuilder.append(&quot;Field&quot;);
 930             }
 931             if (needsCast) {
 932                 nameBuilder.append(&quot;Cast&quot;);
 933             }
 934             if (needsInit) {
 935                 nameBuilder.append(&quot;Init&quot;);
 936             }
 937             LambdaForm.associateWithDebugName(form, nameBuilder.toString());
 938         }
 939         return form;
 940     }
 941 
 942     /**
 943      * Pre-initialized NamedFunctions for bootstrapping purposes.
 944      */
 945     static final byte NF_internalMemberName = 0,
 946             NF_internalMemberNameEnsureInit = 1,
 947             NF_ensureInitialized = 2,
 948             NF_fieldOffset = 3,
 949             NF_checkBase = 4,
 950             NF_staticBase = 5,
 951             NF_staticOffset = 6,
 952             NF_checkCast = 7,
 953             NF_allocateInstance = 8,
 954             NF_constructorMethod = 9,
 955             NF_UNSAFE = 10,
 956             NF_checkReceiver = 11,
 957             NF_fieldType = 12,
 958             NF_staticFieldType = 13,
 959             NF_LIMIT = 14;
 960 
 961     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
 962 
 963     private static NamedFunction getFunction(byte func) {
 964         NamedFunction nf = NFS[func];
 965         if (nf != null) {
 966             return nf;
 967         }
 968         // Each nf must be statically invocable or we get tied up in our bootstraps.
 969         nf = NFS[func] = createFunction(func);
 970         assert(InvokerBytecodeGenerator.isStaticallyInvocable(nf));
 971         return nf;
 972     }
 973 
 974     private static final MethodType CLS_OBJ_TYPE = MethodType.methodType(Class.class, Object.class);
 975 
 976     private static final MethodType OBJ_OBJ_TYPE = MethodType.methodType(Object.class, Object.class);
 977 
 978     private static final MethodType LONG_OBJ_TYPE = MethodType.methodType(long.class, Object.class);
 979 
 980     private static NamedFunction createFunction(byte func) {
 981         try {
 982             switch (func) {
 983                 case NF_internalMemberName:
 984                     return getNamedFunction(&quot;internalMemberName&quot;, OBJ_OBJ_TYPE);
 985                 case NF_internalMemberNameEnsureInit:
 986                     return getNamedFunction(&quot;internalMemberNameEnsureInit&quot;, OBJ_OBJ_TYPE);
 987                 case NF_ensureInitialized:
 988                     return getNamedFunction(&quot;ensureInitialized&quot;, MethodType.methodType(void.class, Object.class));
 989                 case NF_fieldOffset:
 990                     return getNamedFunction(&quot;fieldOffset&quot;, LONG_OBJ_TYPE);
 991                 case NF_checkBase:
 992                     return getNamedFunction(&quot;checkBase&quot;, OBJ_OBJ_TYPE);
 993                 case NF_staticBase:
 994                     return getNamedFunction(&quot;staticBase&quot;, OBJ_OBJ_TYPE);
 995                 case NF_staticOffset:
 996                     return getNamedFunction(&quot;staticOffset&quot;, LONG_OBJ_TYPE);
 997                 case NF_checkCast:
 998                     return getNamedFunction(&quot;checkCast&quot;, MethodType.methodType(Object.class, Object.class, Object.class));
 999                 case NF_allocateInstance:
1000                     return getNamedFunction(&quot;allocateInstance&quot;, OBJ_OBJ_TYPE);
1001                 case NF_constructorMethod:
1002                     return getNamedFunction(&quot;constructorMethod&quot;, OBJ_OBJ_TYPE);
1003                 case NF_UNSAFE:
1004                     MemberName member = new MemberName(MethodHandleStatics.class, &quot;UNSAFE&quot;, Unsafe.class, REF_getField);
1005                     return new NamedFunction(
1006                             MemberName.getFactory()
1007                                     .resolveOrFail(REF_getField, member, DirectMethodHandle.class, NoSuchMethodException.class));
1008                 case NF_checkReceiver:
1009                     member = new MemberName(DirectMethodHandle.class, &quot;checkReceiver&quot;, OBJ_OBJ_TYPE, REF_invokeVirtual);
1010                     return new NamedFunction(
1011                         MemberName.getFactory()
1012                             .resolveOrFail(REF_invokeVirtual, member, DirectMethodHandle.class, NoSuchMethodException.class));
1013                 case NF_fieldType:
1014                     return getNamedFunction(&quot;fieldType&quot;, CLS_OBJ_TYPE);
1015                 case NF_staticFieldType:
1016                     return getNamedFunction(&quot;staticFieldType&quot;, CLS_OBJ_TYPE);
1017                 default:
1018                     throw newInternalError(&quot;Unknown function: &quot; + func);
1019             }
1020         } catch (ReflectiveOperationException ex) {
1021             throw newInternalError(ex);
1022         }
1023     }
1024 
1025     private static NamedFunction getNamedFunction(String name, MethodType type)
1026         throws ReflectiveOperationException
1027     {
1028         MemberName member = new MemberName(DirectMethodHandle.class, name, type, REF_invokeStatic);
1029         return new NamedFunction(
1030             MemberName.getFactory()
1031                 .resolveOrFail(REF_invokeStatic, member, DirectMethodHandle.class, NoSuchMethodException.class));
1032     }
1033 
1034     static {
1035         // The Holder class will contain pre-generated DirectMethodHandles resolved
1036         // speculatively using MemberName.getFactory().resolveOrNull. However, that
1037         // doesn&#39;t initialize the class, which subtly breaks inlining etc. By forcing
1038         // initialization of the Holder class we avoid these issues.
1039         UNSAFE.ensureClassInitialized(Holder.class);
1040     }
1041 
1042     /* Placeholder class for DirectMethodHandles generated ahead of time */
1043     final class Holder {}
1044 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
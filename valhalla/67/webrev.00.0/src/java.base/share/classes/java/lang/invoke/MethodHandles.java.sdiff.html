<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DirectMethodHandle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/Objects.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3289 
3290         /**
3291          * Cracks a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
3292          * created by this lookup object or a similar one.
3293          * Security and access checks are performed to ensure that this lookup object
3294          * is capable of reproducing the target method handle.
3295          * This means that the cracking may fail if target is a direct method handle
3296          * but was created by an unrelated lookup object.
3297          * This can happen if the method handle is &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt;
3298          * and was created by a lookup object for a different class.
3299          * @param target a direct method handle to crack into symbolic reference components
3300          * @return a symbolic reference which can be used to reconstruct this method handle from this lookup object
3301          * @throws    SecurityException if a security manager is present and it
3302          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
3303          * @throws IllegalArgumentException if the target is not a direct method handle or if access checking fails
3304          * @throws    NullPointerException if the target is {@code null}
3305          * @see MethodHandleInfo
3306          * @since 1.8
3307          */
3308         public MethodHandleInfo revealDirect(MethodHandle target) {
<span class="line-modified">3309             MemberName member = target.internalMemberName();</span>
<span class="line-removed">3310             if (member == null || (!member.isResolved() &amp;&amp;</span>
<span class="line-removed">3311                                    !member.isMethodHandleInvoke() &amp;&amp;</span>
<span class="line-removed">3312                                    !member.isVarHandleMethodInvoke()))</span>
3313                 throw newIllegalArgumentException(&quot;not a direct method handle&quot;);


3314             Class&lt;?&gt; defc = member.getDeclaringClass();
3315             byte refKind = member.getReferenceKind();
3316             assert(MethodHandleNatives.refKindIsValid(refKind));
3317             if (refKind == REF_invokeSpecial &amp;&amp; !target.isInvokeSpecial())
3318                 // Devirtualized method invocation is usually formally virtual.
3319                 // To avoid creating extra MemberName objects for this common case,
3320                 // we encode this extra degree of freedom using MH.isInvokeSpecial.
3321                 refKind = REF_invokeVirtual;
3322             if (refKind == REF_invokeVirtual &amp;&amp; defc.isInterface())
3323                 // Symbolic reference is through interface but resolves to Object method (toString, etc.)
3324                 refKind = REF_invokeInterface;
3325             // Check SM permissions and member access before cracking.
3326             try {
3327                 checkAccess(refKind, defc, member);
3328                 checkSecurityManager(defc, member);
3329             } catch (IllegalAccessException ex) {
3330                 throw new IllegalArgumentException(ex);
3331             }
3332             if (allowedModes != TRUSTED &amp;&amp; member.isCallerSensitive()) {
3333                 Class&lt;?&gt; callerClass = target.internalCallerClass();
</pre>
</td>
<td>
<hr />
<pre>
3289 
3290         /**
3291          * Cracks a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
3292          * created by this lookup object or a similar one.
3293          * Security and access checks are performed to ensure that this lookup object
3294          * is capable of reproducing the target method handle.
3295          * This means that the cracking may fail if target is a direct method handle
3296          * but was created by an unrelated lookup object.
3297          * This can happen if the method handle is &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt;
3298          * and was created by a lookup object for a different class.
3299          * @param target a direct method handle to crack into symbolic reference components
3300          * @return a symbolic reference which can be used to reconstruct this method handle from this lookup object
3301          * @throws    SecurityException if a security manager is present and it
3302          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
3303          * @throws IllegalArgumentException if the target is not a direct method handle or if access checking fails
3304          * @throws    NullPointerException if the target is {@code null}
3305          * @see MethodHandleInfo
3306          * @since 1.8
3307          */
3308         public MethodHandleInfo revealDirect(MethodHandle target) {
<span class="line-modified">3309             if (!target.isCrackable()) {</span>



3310                 throw newIllegalArgumentException(&quot;not a direct method handle&quot;);
<span class="line-added">3311             }</span>
<span class="line-added">3312             MemberName member = target.internalMemberName();</span>
3313             Class&lt;?&gt; defc = member.getDeclaringClass();
3314             byte refKind = member.getReferenceKind();
3315             assert(MethodHandleNatives.refKindIsValid(refKind));
3316             if (refKind == REF_invokeSpecial &amp;&amp; !target.isInvokeSpecial())
3317                 // Devirtualized method invocation is usually formally virtual.
3318                 // To avoid creating extra MemberName objects for this common case,
3319                 // we encode this extra degree of freedom using MH.isInvokeSpecial.
3320                 refKind = REF_invokeVirtual;
3321             if (refKind == REF_invokeVirtual &amp;&amp; defc.isInterface())
3322                 // Symbolic reference is through interface but resolves to Object method (toString, etc.)
3323                 refKind = REF_invokeInterface;
3324             // Check SM permissions and member access before cracking.
3325             try {
3326                 checkAccess(refKind, defc, member);
3327                 checkSecurityManager(defc, member);
3328             } catch (IllegalAccessException ex) {
3329                 throw new IllegalArgumentException(ex);
3330             }
3331             if (allowedModes != TRUSTED &amp;&amp; member.isCallerSensitive()) {
3332                 Class&lt;?&gt; callerClass = target.internalCallerClass();
</pre>
</td>
</tr>
</table>
<center><a href="DirectMethodHandle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/Objects.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
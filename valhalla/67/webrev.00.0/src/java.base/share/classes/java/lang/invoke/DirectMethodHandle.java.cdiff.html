<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../hotspot/share/runtime/vmStructs.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 49,13 ***</span>
   * to a class member.
   * @author jrose
   */
  class DirectMethodHandle extends MethodHandle {
      final MemberName member;
  
      // Constructors and factory methods in this class *must* be package scoped or private.
<span class="line-modified">!     private DirectMethodHandle(MethodType mtype, LambdaForm form, MemberName member) {</span>
          super(mtype, form);
          if (!member.isResolved())  throw new InternalError();
  
          if (member.getDeclaringClass().isInterface() &amp;&amp;
              member.getReferenceKind() == REF_invokeInterface &amp;&amp;
<span class="line-new-header">--- 49,14 ---</span>
   * to a class member.
   * @author jrose
   */
  class DirectMethodHandle extends MethodHandle {
      final MemberName member;
<span class="line-added">+     final boolean crackable;</span>
  
      // Constructors and factory methods in this class *must* be package scoped or private.
<span class="line-modified">!     private DirectMethodHandle(MethodType mtype, LambdaForm form, MemberName member, boolean crackable) {</span>
          super(mtype, form);
          if (!member.isResolved())  throw new InternalError();
  
          if (member.getDeclaringClass().isInterface() &amp;&amp;
              member.getReferenceKind() == REF_invokeInterface &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,10 ***</span>
<span class="line-new-header">--- 69,11 ---</span>
                  member = m;
              }
          }
  
          this.member = member;
<span class="line-added">+         this.crackable = crackable;</span>
      }
  
      // Factory methods:
      static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
          MethodType mtype = member.getMethodOrFieldType();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,22 ***</span>
                      // receiver check inserted
                      if (callerClass == null) {
                          throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
                      }
                      LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
<span class="line-modified">!                     return new Special(mtype, lform, member, callerClass);</span>
                  }
                  case REF_invokeInterface: {
                      // for interfaces we always need the receiver typecheck,
                      // so we always pass &#39;true&#39; to ensure we adapt if needed
                      // to include the REF_invokeSpecial case
                      LambdaForm lform = preparedLambdaForm(member, true);
<span class="line-modified">!                     return new Interface(mtype, lform, member, refc);</span>
                  }
                  default: {
                      LambdaForm lform = preparedLambdaForm(member);
<span class="line-modified">!                     return new DirectMethodHandle(mtype, lform, member);</span>
                  }
              }
          } else {
              LambdaForm lform = preparedFieldLambdaForm(member);
              if (member.isStatic()) {
<span class="line-new-header">--- 92,22 ---</span>
                      // receiver check inserted
                      if (callerClass == null) {
                          throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
                      }
                      LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
<span class="line-modified">!                     return new Special(mtype, lform, member, true, callerClass);</span>
                  }
                  case REF_invokeInterface: {
                      // for interfaces we always need the receiver typecheck,
                      // so we always pass &#39;true&#39; to ensure we adapt if needed
                      // to include the REF_invokeSpecial case
                      LambdaForm lform = preparedLambdaForm(member, true);
<span class="line-modified">!                     return new Interface(mtype, lform, member, true, refc);</span>
                  }
                  default: {
                      LambdaForm lform = preparedLambdaForm(member);
<span class="line-modified">!                     return new DirectMethodHandle(mtype, lform, member, true);</span>
                  }
              }
          } else {
              LambdaForm lform = preparedFieldLambdaForm(member);
              if (member.isStatic()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,22 ***</span>
          assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;
          MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
          LambdaForm lform = preparedLambdaForm(ctor);
          MemberName init = ctor.asSpecial();
          assert(init.getMethodType().returnType() == void.class);
<span class="line-modified">!         return new Constructor(mtype, lform, ctor, init, instanceClass);</span>
      }
  
      @Override
      BoundMethodHandle rebind() {
          return BoundMethodHandle.makeReinvoker(this);
      }
  
      @Override
      MethodHandle copyWith(MethodType mt, LambdaForm lf) {
          assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
<span class="line-modified">!         return new DirectMethodHandle(mt, lf, member);</span>
      }
  
      @Override
      String internalProperties() {
          return &quot;\n&amp; DMH.MN=&quot;+internalMemberName();
<span class="line-new-header">--- 142,37 ---</span>
          assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;
          MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
          LambdaForm lform = preparedLambdaForm(ctor);
          MemberName init = ctor.asSpecial();
          assert(init.getMethodType().returnType() == void.class);
<span class="line-modified">!         return new Constructor(mtype, lform, ctor, true, init, instanceClass);</span>
      }
  
      @Override
      BoundMethodHandle rebind() {
          return BoundMethodHandle.makeReinvoker(this);
      }
  
      @Override
      MethodHandle copyWith(MethodType mt, LambdaForm lf) {
          assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
<span class="line-modified">!         return new DirectMethodHandle(mt, lf, member, crackable);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added">+         // No actual conversions, just a new view of the same method.</span>
<span class="line-added">+         // However, we must not expose a DMH that is crackable into a</span>
<span class="line-added">+         // MethodHandleInfo, so we return a cloned, uncrackable DMH</span>
<span class="line-added">+         assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added">+         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses</span>
<span class="line-added">+         return new DirectMethodHandle(newType, form, member, false);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     boolean isCrackable() {</span>
<span class="line-added">+         return crackable;</span>
      }
  
      @Override
      String internalProperties() {
          return &quot;\n&amp; DMH.MN=&quot;+internalMemberName();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,21 ***</span>
      }
  
      /** This subclass represents invokespecial instructions. */
      static class Special extends DirectMethodHandle {
          private final Class&lt;?&gt; caller;
<span class="line-modified">!         private Special(MethodType mtype, LambdaForm form, MemberName member, Class&lt;?&gt; caller) {</span>
<span class="line-modified">!             super(mtype, form, member);</span>
              this.caller = caller;
          }
          @Override
          boolean isInvokeSpecial() {
              return true;
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new Special(mt, lf, member, caller);</span>
          }
          Object checkReceiver(Object recv) {
              if (!caller.isInstance(recv)) {
                  String msg = String.format(&quot;Receiver class %s is not a subclass of caller class %s&quot;,
                                             recv.getClass().getName(), caller.getName());
<span class="line-new-header">--- 424,26 ---</span>
      }
  
      /** This subclass represents invokespecial instructions. */
      static class Special extends DirectMethodHandle {
          private final Class&lt;?&gt; caller;
<span class="line-modified">!         private Special(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; caller) {</span>
<span class="line-modified">!             super(mtype, form, member, crackable);</span>
              this.caller = caller;
          }
          @Override
          boolean isInvokeSpecial() {
              return true;
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new Special(mt, lf, member, crackable, caller);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added">+             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added">+             return new Special(newType, form, member, false, caller);</span>
          }
          Object checkReceiver(Object recv) {
              if (!caller.isInstance(recv)) {
                  String msg = String.format(&quot;Receiver class %s is not a subclass of caller class %s&quot;,
                                             recv.getClass().getName(), caller.getName());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 432,18 ***</span>
      }
  
      /** This subclass represents invokeinterface instructions. */
      static class Interface extends DirectMethodHandle {
          private final Class&lt;?&gt; refc;
<span class="line-modified">!         private Interface(MethodType mtype, LambdaForm form, MemberName member, Class&lt;?&gt; refc) {</span>
<span class="line-modified">!             super(mtype, form, member);</span>
<span class="line-modified">!             assert refc.isInterface() : refc;</span>
              this.refc = refc;
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new Interface(mt, lf, member, refc);</span>
          }
          @Override
          Object checkReceiver(Object recv) {
              if (!refc.isInstance(recv)) {
                  String msg = String.format(&quot;Receiver class %s does not implement the requested interface %s&quot;,
<span class="line-new-header">--- 454,23 ---</span>
      }
  
      /** This subclass represents invokeinterface instructions. */
      static class Interface extends DirectMethodHandle {
          private final Class&lt;?&gt; refc;
<span class="line-modified">!         private Interface(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; refc) {</span>
<span class="line-modified">!             super(mtype, form, member, crackable);</span>
<span class="line-modified">!             assert(refc.isInterface()) : refc;</span>
              this.refc = refc;
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new Interface(mt, lf, member, crackable, refc);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added">+             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added">+             return new Interface(newType, form, member, false, refc);</span>
          }
          @Override
          Object checkReceiver(Object recv) {
              if (!refc.isInstance(recv)) {
                  String msg = String.format(&quot;Receiver class %s does not implement the requested interface %s&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 457,26 ***</span>
      /** Used for interface receiver type checks, by Interface and Special modes. */
      Object checkReceiver(Object recv) {
          throw new InternalError(&quot;Should only be invoked on a subclass&quot;);
      }
  
<span class="line-removed">- </span>
      /** This subclass handles constructor references. */
      static class Constructor extends DirectMethodHandle {
          final MemberName initMethod;
          final Class&lt;?&gt;   instanceClass;
  
          private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
<span class="line-modified">!                             MemberName initMethod, Class&lt;?&gt; instanceClass) {</span>
<span class="line-modified">!             super(mtype, form, constructor);</span>
              this.initMethod = initMethod;
              this.instanceClass = instanceClass;
              assert(initMethod.isResolved());
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new Constructor(mt, lf, member, initMethod, instanceClass);</span>
          }
      }
  
      /*non-public*/
      static Object constructorMethod(Object mh) {
<span class="line-new-header">--- 484,30 ---</span>
      /** Used for interface receiver type checks, by Interface and Special modes. */
      Object checkReceiver(Object recv) {
          throw new InternalError(&quot;Should only be invoked on a subclass&quot;);
      }
  
      /** This subclass handles constructor references. */
      static class Constructor extends DirectMethodHandle {
          final MemberName initMethod;
          final Class&lt;?&gt;   instanceClass;
  
          private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
<span class="line-modified">!                             boolean crackable, MemberName initMethod, Class&lt;?&gt; instanceClass) {</span>
<span class="line-modified">!             super(mtype, form, constructor, crackable);</span>
              this.initMethod = initMethod;
              this.instanceClass = instanceClass;
              assert(initMethod.isResolved());
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified">!             return new Constructor(mt, lf, member, crackable, initMethod, instanceClass);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added">+             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added">+             return new Constructor(newType, form, member, false, initMethod, instanceClass);</span>
          }
      }
  
      /*non-public*/
      static Object constructorMethod(Object mh) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 491,43 ***</span>
      }
  
      /** This subclass handles non-static field references. */
      static abstract class Accessor extends DirectMethodHandle {
          final Class&lt;?&gt; fieldType;
<span class="line-modified">!         final int fieldOffset;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         protected Accessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-modified">!                            int fieldOffset) {</span>
<span class="line-modified">!             super(mtype, form, member);</span>
<span class="line-removed">-             this.fieldType = member.getFieldType();</span>
              this.fieldOffset = fieldOffset;
          }
          abstract Object checkCast(Object obj);
          abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
      }
  
      /** This subclass handles non-static field references of indirect type */
      static class IndirectAccessor extends Accessor {
          private IndirectAccessor(MethodType mtype, LambdaForm form, MemberName member,
                                   int fieldOffset) {
<span class="line-modified">!             super(mtype, form, member, fieldOffset);</span>
          }
  
          @Override Object checkCast(Object obj) {
              return fieldType.cast(obj);
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
              return new IndirectAccessor(mt, lf, member, fieldOffset);
          }
      }
  
      /** This subclass handles non-static field references of inline type */
      static class InlineAccessor extends Accessor {
          private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
                                 int fieldOffset) {
<span class="line-modified">!             super(mtype, form, member, fieldOffset);</span>
          }
  
          @Override Object checkCast(Object obj) {
              return fieldType.cast(Objects.requireNonNull(obj));
          }
<span class="line-new-header">--- 522,47 ---</span>
      }
  
      /** This subclass handles non-static field references. */
      static abstract class Accessor extends DirectMethodHandle {
          final Class&lt;?&gt; fieldType;
<span class="line-modified">!         final int      fieldOffset;</span>
<span class="line-modified">!         private Accessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-modified">!                          boolean crackable, int fieldOffset) {</span>
<span class="line-modified">!             super(mtype, form, member, crackable);</span>
<span class="line-modified">!             this.fieldType   = member.getFieldType();</span>
              this.fieldOffset = fieldOffset;
          }
          abstract Object checkCast(Object obj);
          abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
      }
  
      /** This subclass handles non-static field references of indirect type */
      static class IndirectAccessor extends Accessor {
          private IndirectAccessor(MethodType mtype, LambdaForm form, MemberName member,
                                   int fieldOffset) {
<span class="line-modified">!             super(mtype, form, member, true, fieldOffset);</span>
          }
  
          @Override Object checkCast(Object obj) {
              return fieldType.cast(obj);
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
              return new IndirectAccessor(mt, lf, member, fieldOffset);
          }
<span class="line-added">+         @Override</span>
<span class="line-added">+         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added">+             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added">+             return new IndirectAccessor(newType, form, member, fieldOffset);</span>
<span class="line-added">+         }</span>
      }
  
      /** This subclass handles non-static field references of inline type */
      static class InlineAccessor extends Accessor {
          private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
                                 int fieldOffset) {
<span class="line-modified">!             super(mtype, form, member, true, fieldOffset);</span>
          }
  
          @Override Object checkCast(Object obj) {
              return fieldType.cast(Objects.requireNonNull(obj));
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 561,43 ***</span>
      static abstract class StaticAccessor extends DirectMethodHandle {
          final Class&lt;?&gt; fieldType;
          final Object staticBase;
          final long staticOffset;
  
<span class="line-modified">!         protected StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-modified">!                                  Object staticBase, long staticOffset) {</span>
<span class="line-modified">!             super(mtype, form, member);</span>
<span class="line-modified">!             this.fieldType = member.getFieldType();</span>
<span class="line-modified">!             this.staticBase = staticBase;</span>
              this.staticOffset = staticOffset;
          }
          abstract Object checkCast(Object obj);
          abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
      }
  
      /** This subclass handles static field references of indirect type. */
      static class IndirectStaticAccessor extends StaticAccessor {
          private IndirectStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
                                       Object staticBase, long staticOffset) {
<span class="line-modified">!             super(mtype, form, member, staticBase, staticOffset);</span>
          }
  
          // indirect type is always nullable
          @Override Object checkCast(Object obj) {
              return fieldType.cast(obj);
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
              return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);
          }
      }
  
      /** This subclass handles static field references of inline type . */
      static class InlineStaticAccessor extends StaticAccessor {
          private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
                                       Object staticBase, long staticOffset) {
<span class="line-modified">!             super(mtype, form, member, staticBase, staticOffset);</span>
          }
  
          // zero-default inline type is not-nullable
          @Override Object checkCast(Object obj) {
              assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;
<span class="line-new-header">--- 596,48 ---</span>
      static abstract class StaticAccessor extends DirectMethodHandle {
          final Class&lt;?&gt; fieldType;
          final Object staticBase;
          final long staticOffset;
  
<span class="line-modified">!         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-modified">!                                boolean crackable, Object staticBase, long staticOffset) {</span>
<span class="line-modified">!             super(mtype, form, member, crackable);</span>
<span class="line-modified">!             this.fieldType    = member.getFieldType();</span>
<span class="line-modified">!             this.staticBase   = staticBase;</span>
              this.staticOffset = staticOffset;
          }
          abstract Object checkCast(Object obj);
          abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
      }
  
      /** This subclass handles static field references of indirect type. */
      static class IndirectStaticAccessor extends StaticAccessor {
          private IndirectStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
                                       Object staticBase, long staticOffset) {
<span class="line-modified">!             super(mtype, form, member, true, staticBase, staticOffset);</span>
          }
  
          // indirect type is always nullable
          @Override Object checkCast(Object obj) {
              return fieldType.cast(obj);
          }
          @Override
          MethodHandle copyWith(MethodType mt, LambdaForm lf) {
              return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);
          }
<span class="line-added">+         @Override</span>
<span class="line-added">+         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added">+             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added">+             return new IndirectStaticAccessor(newType, form, member, staticBase, staticOffset);</span>
<span class="line-added">+         }</span>
      }
  
      /** This subclass handles static field references of inline type . */
      static class InlineStaticAccessor extends StaticAccessor {
          private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
                                       Object staticBase, long staticOffset) {
<span class="line-modified">!             super(mtype, form, member, true, staticBase, staticOffset);</span>
          }
  
          // zero-default inline type is not-nullable
          @Override Object checkCast(Object obj) {
              assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;
</pre>
<center><a href="../../../../../../hotspot/share/runtime/vmStructs.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
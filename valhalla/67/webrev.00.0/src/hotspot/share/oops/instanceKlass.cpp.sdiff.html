<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arrayKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 529   _init_thread(NULL),
 530   _value_field_klasses(NULL),
 531   _adr_valueklass_fixed_block(NULL)
 532 {
 533   set_vtable_length(parser.vtable_size());
 534   set_kind(kind);
 535   set_access_flags(parser.access_flags());
 536   if (parser.is_hidden()) set_is_hidden();
 537   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 538   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 539                                                     false));
 540     if (parser.has_flattenable_fields()) {
 541       set_has_inline_fields();
 542     }
 543     _java_fields_count = parser.java_fields_count();
 544 
 545     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
 546     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
 547     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
 548 
<span class="line-removed"> 549   if (Arguments::is_dumping_archive()) {</span>
<span class="line-removed"> 550       SystemDictionaryShared::init_dumptime_info(this);</span>
<span class="line-removed"> 551     }</span>
<span class="line-removed"> 552 </span>
 553   // Set biased locking bit for all instances of this class; it will be
 554   // cleared if revocation occurs too often for this type
 555   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 556     set_prototype_header(markWord::biased_locking_prototype());
 557   }
 558   if (has_inline_fields()) {
 559     _value_field_klasses = (const Klass**) adr_value_fields_klasses();
 560   }
 561 }
 562 
 563 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 564                                        Array&lt;Method*&gt;* methods) {
 565   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 566       !methods-&gt;is_shared()) {
 567     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 568       Method* method = methods-&gt;at(i);
 569       if (method == NULL) continue;  // maybe null if error processing
 570       // Only want to delete methods that are not executing for RedefineClasses.
 571       // The previous version will point to them so they&#39;re not totally dangling
 572       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
</pre>
<hr />
<pre>
1004         // (which can sometimes happen since the verifier loads classes
1005         // using custom class loaders, which are free to initialize things)
1006         if (is_linked()) {
1007           return true;
1008         }
1009 
1010         // also sets rewritten
1011         rewrite_class(CHECK_false);
1012       } else if (is_shared()) {
1013         SystemDictionaryShared::check_verification_constraints(this, CHECK_false);
1014       }
1015 
1016       // relocate jsrs and link methods after they are all rewritten
1017       link_methods(CHECK_false);
1018 
1019       // Initialize the vtable and interface table after
1020       // methods have been rewritten since rewrite may
1021       // fabricate new Method*s.
1022       // also does loader constraint checking
1023       //
<span class="line-modified">1024       // initialize_vtable and initialize_itable need to be rerun for</span>
<span class="line-modified">1025       // a shared class if the class is not loaded by the NULL classloader.</span>
<span class="line-modified">1026       ClassLoaderData * loader_data = class_loader_data();</span>
<span class="line-modified">1027       if (!(is_shared() &amp;&amp;</span>
<span class="line-modified">1028             loader_data-&gt;is_the_null_class_loader_data())) {</span>




1029         vtable().initialize_vtable(true, CHECK_false);
1030         itable().initialize_itable(true, CHECK_false);
1031       }
1032 #ifdef ASSERT
<span class="line-modified">1033       else {</span>
<span class="line-modified">1034         vtable().verify(tty, true);</span>
<span class="line-modified">1035         // In case itable verification is ever added.</span>
<span class="line-removed">1036         // itable().verify(tty, true);</span>
<span class="line-removed">1037       }</span>
1038 #endif
1039 
1040       set_init_state(linked);
1041       if (JvmtiExport::should_post_class_prepare()) {
1042         Thread *thread = THREAD;
1043         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1044         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
1045       }
1046     }
1047   }
1048   return true;
1049 }
1050 
1051 // Rewrite the byte codes of all of the methods of a class.
1052 // The rewriter must be called exactly once. Rewriting must happen after
1053 // verification but before the first method of the class is executed.
1054 void InstanceKlass::rewrite_class(TRAPS) {
1055   assert(is_loaded(), &quot;must be loaded&quot;);
1056   if (is_rewritten()) {
1057     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
</pre>
<hr />
<pre>
1495   if (this == SystemDictionary::Class_klass()) {
1496     ResourceMark rm(THREAD);
1497     THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()
1498               : vmSymbols::java_lang_IllegalAccessException(), external_name());
1499   }
1500 }
1501 
1502 Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {
1503   // Need load-acquire for lock-free read
1504   if (array_klasses_acquire() == NULL) {
1505     if (or_null) return NULL;
1506 
1507     ResourceMark rm(THREAD);
1508     JavaThread *jt = (JavaThread *)THREAD;
1509     {
1510       // Atomic creation of array_klasses
1511       MutexLocker ma(THREAD, MultiArray_lock);
1512 
1513       // Check if update has already taken place
1514       if (array_klasses() == NULL) {
<span class="line-modified">1515         Klass*    k = ObjArrayKlass::allocate_objArray_klass(1, this, CHECK_NULL);</span>
1516         // use &#39;release&#39; to pair with lock-free load
1517         release_set_array_klasses(k);
1518       }
1519     }
1520   }
1521   // _this will always be set at this point
<span class="line-modified">1522   ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();</span>
1523   if (or_null) {
1524     return oak-&gt;array_klass_or_null(n);
1525   }
1526   return oak-&gt;array_klass(n, THREAD);
1527 }
1528 
1529 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1530   return array_klass_impl(or_null, 1, THREAD);
1531 }
1532 
1533 static int call_class_initializer_counter = 0;   // for debugging
1534 
1535 Method* InstanceKlass::class_initializer() const {
1536   Method* clinit = find_method(
1537       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
1538   if (clinit != NULL &amp;&amp; clinit-&gt;is_class_initializer()) {
1539     return clinit;
1540   }
1541   return NULL;
1542 }
</pre>
<hr />
<pre>
1743     if (!fd.is_static()) {
1744       fields_sorted[j + 0] = fd.offset();
1745       fields_sorted[j + 1] = i;
1746       j += 2;
1747     }
1748   }
1749   if (j &gt; 0) {
1750     length = j;
1751     // _sort_Fn is defined in growableArray.hpp.
1752     qsort(fields_sorted, length/2, 2*sizeof(int), (_sort_Fn)compare_fields_by_offset);
1753     for (int i = 0; i &lt; length; i += 2) {
1754       fd.reinitialize(this, fields_sorted[i + 1]);
1755       assert(!fd.is_static() &amp;&amp; fd.offset() == fields_sorted[i], &quot;only nonstatic fields&quot;);
1756       cl-&gt;do_field(&amp;fd);
1757     }
1758   }
1759   FREE_C_HEAP_ARRAY(int, fields_sorted);
1760 }
1761 
1762 





1763 void InstanceKlass::array_klasses_do(void f(Klass* k)) {
1764   if (array_klasses() != NULL)
<span class="line-modified">1765     ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f);</span>
1766 }
1767 
1768 #ifdef ASSERT
1769 static int linear_search(const Array&lt;Method*&gt;* methods,
1770                          const Symbol* name,
1771                          const Symbol* signature) {
1772   const int len = methods-&gt;length();
1773   for (int index = 0; index &lt; len; index++) {
1774     const Method* const m = methods-&gt;at(index);
1775     assert(m-&gt;is_method(), &quot;must be method&quot;);
1776     if (m-&gt;signature() == signature &amp;&amp; m-&gt;name() == name) {
1777        return index;
1778     }
1779   }
1780   return -1;
1781 }
1782 #endif
1783 
1784 bool InstanceKlass::_disable_method_binary_search = false;
1785 
</pre>
<hr />
<pre>
2635   int num_methods = methods-&gt;length();
2636   for (int index = 0; index &lt; num_methods; ++index) {
2637     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2638   }
2639   if (JvmtiExport::has_redefined_a_class()) {
2640     // Reinitialize vtable because RedefineClasses may have changed some
2641     // entries in this vtable for super classes so the CDS vtable might
2642     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2643     // vtables in the shared system dictionary, only the main one.
2644     // It also redefines the itable too so fix that too.
2645     vtable().initialize_vtable(false, CHECK);
2646     itable().initialize_itable(false, CHECK);
2647   }
2648 
2649   // restore constant pool resolved references
2650   constants()-&gt;restore_unshareable_info(CHECK);
2651 
2652   if (array_klasses() != NULL) {
2653     // Array classes have null protection domain.
2654     // --&gt; see ArrayKlass::complete_create_array_klass()
<span class="line-modified">2655     ArrayKlass::cast(array_klasses())-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);</span>
2656   }
2657 
2658   // Initialize current biased locking state.
2659   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {
2660     set_prototype_header(markWord::biased_locking_prototype());
2661   }
2662 }
2663 
2664 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2665   switch (loader_type) {
2666   case ClassLoader::BOOT_LOADER:
2667     _misc_flags |= _misc_is_shared_boot_class;
2668     break;
2669   case ClassLoader::PLATFORM_LOADER:
2670     _misc_flags |= _misc_is_shared_platform_class;
2671     break;
2672   case ClassLoader::APP_LOADER:
2673     _misc_flags |= _misc_is_shared_app_class;
2674     break;
2675   default:
</pre>
<hr />
<pre>
3861 
3862   // Verify default methods
3863   if (default_methods() != NULL) {
3864     Array&lt;Method*&gt;* methods = this-&gt;default_methods();
3865     for (int j = 0; j &lt; methods-&gt;length(); j++) {
3866       guarantee(methods-&gt;at(j)-&gt;is_method(), &quot;non-method in methods array&quot;);
3867     }
3868     for (int j = 0; j &lt; methods-&gt;length() - 1; j++) {
3869       Method* m1 = methods-&gt;at(j);
3870       Method* m2 = methods-&gt;at(j + 1);
3871       guarantee(m1-&gt;name()-&gt;fast_compare(m2-&gt;name()) &lt;= 0, &quot;methods not sorted correctly&quot;);
3872     }
3873   }
3874 
3875   // Verify JNI static field identifiers
3876   if (jni_ids() != NULL) {
3877     jni_ids()-&gt;verify(this);
3878   }
3879 
3880   // Verify other fields
<span class="line-removed">3881   if (array_klasses() != NULL) {</span>
<span class="line-removed">3882     guarantee(array_klasses()-&gt;is_klass(), &quot;should be klass&quot;);</span>
<span class="line-removed">3883   }</span>
3884   if (constants() != NULL) {
3885     guarantee(constants()-&gt;is_constantPool(), &quot;should be constant pool&quot;);
3886   }
3887   const Klass* anonymous_host = unsafe_anonymous_host();
3888   if (anonymous_host != NULL) {
3889     guarantee(anonymous_host-&gt;is_klass(), &quot;should be klass&quot;);
3890   }
3891 }
3892 
3893 void InstanceKlass::oop_verify_on(oop obj, outputStream* st) {
3894   Klass::oop_verify_on(obj, st);
3895   VerifyFieldClosure blk;
3896   obj-&gt;oop_iterate(&amp;blk);
3897 }
3898 
3899 
3900 // JNIid class for jfieldIDs only
3901 // Note to reviewers:
3902 // These JNI functions are just moved over to column 1 and not changed
3903 // in the compressed oops workspace.
</pre>
</td>
<td>
<hr />
<pre>
 529   _init_thread(NULL),
 530   _value_field_klasses(NULL),
 531   _adr_valueklass_fixed_block(NULL)
 532 {
 533   set_vtable_length(parser.vtable_size());
 534   set_kind(kind);
 535   set_access_flags(parser.access_flags());
 536   if (parser.is_hidden()) set_is_hidden();
 537   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 538   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 539                                                     false));
 540     if (parser.has_flattenable_fields()) {
 541       set_has_inline_fields();
 542     }
 543     _java_fields_count = parser.java_fields_count();
 544 
 545     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
 546     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
 547     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
 548 




 549   // Set biased locking bit for all instances of this class; it will be
 550   // cleared if revocation occurs too often for this type
 551   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 552     set_prototype_header(markWord::biased_locking_prototype());
 553   }
 554   if (has_inline_fields()) {
 555     _value_field_klasses = (const Klass**) adr_value_fields_klasses();
 556   }
 557 }
 558 
 559 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 560                                        Array&lt;Method*&gt;* methods) {
 561   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 562       !methods-&gt;is_shared()) {
 563     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 564       Method* method = methods-&gt;at(i);
 565       if (method == NULL) continue;  // maybe null if error processing
 566       // Only want to delete methods that are not executing for RedefineClasses.
 567       // The previous version will point to them so they&#39;re not totally dangling
 568       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
</pre>
<hr />
<pre>
1000         // (which can sometimes happen since the verifier loads classes
1001         // using custom class loaders, which are free to initialize things)
1002         if (is_linked()) {
1003           return true;
1004         }
1005 
1006         // also sets rewritten
1007         rewrite_class(CHECK_false);
1008       } else if (is_shared()) {
1009         SystemDictionaryShared::check_verification_constraints(this, CHECK_false);
1010       }
1011 
1012       // relocate jsrs and link methods after they are all rewritten
1013       link_methods(CHECK_false);
1014 
1015       // Initialize the vtable and interface table after
1016       // methods have been rewritten since rewrite may
1017       // fabricate new Method*s.
1018       // also does loader constraint checking
1019       //
<span class="line-modified">1020       // initialize_vtable and initialize_itable need to be rerun</span>
<span class="line-modified">1021       // for a shared class if</span>
<span class="line-modified">1022       // 1) the class is loaded by custom class loader or</span>
<span class="line-modified">1023       // 2) the class is loaded by built-in class loader but failed to add archived loader constraints</span>
<span class="line-modified">1024       bool need_init_table = true;</span>
<span class="line-added">1025       if (is_shared() &amp;&amp; SystemDictionaryShared::check_linking_constraints(this, THREAD)) {</span>
<span class="line-added">1026         need_init_table = false;</span>
<span class="line-added">1027       }</span>
<span class="line-added">1028       if (need_init_table) {</span>
1029         vtable().initialize_vtable(true, CHECK_false);
1030         itable().initialize_itable(true, CHECK_false);
1031       }
1032 #ifdef ASSERT
<span class="line-modified">1033       vtable().verify(tty, true);</span>
<span class="line-modified">1034       // In case itable verification is ever added.</span>
<span class="line-modified">1035       // itable().verify(tty, true);</span>


1036 #endif
1037 
1038       set_init_state(linked);
1039       if (JvmtiExport::should_post_class_prepare()) {
1040         Thread *thread = THREAD;
1041         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1042         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
1043       }
1044     }
1045   }
1046   return true;
1047 }
1048 
1049 // Rewrite the byte codes of all of the methods of a class.
1050 // The rewriter must be called exactly once. Rewriting must happen after
1051 // verification but before the first method of the class is executed.
1052 void InstanceKlass::rewrite_class(TRAPS) {
1053   assert(is_loaded(), &quot;must be loaded&quot;);
1054   if (is_rewritten()) {
1055     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
</pre>
<hr />
<pre>
1493   if (this == SystemDictionary::Class_klass()) {
1494     ResourceMark rm(THREAD);
1495     THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()
1496               : vmSymbols::java_lang_IllegalAccessException(), external_name());
1497   }
1498 }
1499 
1500 Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {
1501   // Need load-acquire for lock-free read
1502   if (array_klasses_acquire() == NULL) {
1503     if (or_null) return NULL;
1504 
1505     ResourceMark rm(THREAD);
1506     JavaThread *jt = (JavaThread *)THREAD;
1507     {
1508       // Atomic creation of array_klasses
1509       MutexLocker ma(THREAD, MultiArray_lock);
1510 
1511       // Check if update has already taken place
1512       if (array_klasses() == NULL) {
<span class="line-modified">1513         ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);</span>
1514         // use &#39;release&#39; to pair with lock-free load
1515         release_set_array_klasses(k);
1516       }
1517     }
1518   }
1519   // _this will always be set at this point
<span class="line-modified">1520   ObjArrayKlass* oak = array_klasses();</span>
1521   if (or_null) {
1522     return oak-&gt;array_klass_or_null(n);
1523   }
1524   return oak-&gt;array_klass(n, THREAD);
1525 }
1526 
1527 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1528   return array_klass_impl(or_null, 1, THREAD);
1529 }
1530 
1531 static int call_class_initializer_counter = 0;   // for debugging
1532 
1533 Method* InstanceKlass::class_initializer() const {
1534   Method* clinit = find_method(
1535       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
1536   if (clinit != NULL &amp;&amp; clinit-&gt;is_class_initializer()) {
1537     return clinit;
1538   }
1539   return NULL;
1540 }
</pre>
<hr />
<pre>
1741     if (!fd.is_static()) {
1742       fields_sorted[j + 0] = fd.offset();
1743       fields_sorted[j + 1] = i;
1744       j += 2;
1745     }
1746   }
1747   if (j &gt; 0) {
1748     length = j;
1749     // _sort_Fn is defined in growableArray.hpp.
1750     qsort(fields_sorted, length/2, 2*sizeof(int), (_sort_Fn)compare_fields_by_offset);
1751     for (int i = 0; i &lt; length; i += 2) {
1752       fd.reinitialize(this, fields_sorted[i + 1]);
1753       assert(!fd.is_static() &amp;&amp; fd.offset() == fields_sorted[i], &quot;only nonstatic fields&quot;);
1754       cl-&gt;do_field(&amp;fd);
1755     }
1756   }
1757   FREE_C_HEAP_ARRAY(int, fields_sorted);
1758 }
1759 
1760 
<span class="line-added">1761 void InstanceKlass::array_klasses_do(void f(Klass* k, TRAPS), TRAPS) {</span>
<span class="line-added">1762   if (array_klasses() != NULL)</span>
<span class="line-added">1763     array_klasses()-&gt;array_klasses_do(f, THREAD);</span>
<span class="line-added">1764 }</span>
<span class="line-added">1765 </span>
1766 void InstanceKlass::array_klasses_do(void f(Klass* k)) {
1767   if (array_klasses() != NULL)
<span class="line-modified">1768     array_klasses()-&gt;array_klasses_do(f);</span>
1769 }
1770 
1771 #ifdef ASSERT
1772 static int linear_search(const Array&lt;Method*&gt;* methods,
1773                          const Symbol* name,
1774                          const Symbol* signature) {
1775   const int len = methods-&gt;length();
1776   for (int index = 0; index &lt; len; index++) {
1777     const Method* const m = methods-&gt;at(index);
1778     assert(m-&gt;is_method(), &quot;must be method&quot;);
1779     if (m-&gt;signature() == signature &amp;&amp; m-&gt;name() == name) {
1780        return index;
1781     }
1782   }
1783   return -1;
1784 }
1785 #endif
1786 
1787 bool InstanceKlass::_disable_method_binary_search = false;
1788 
</pre>
<hr />
<pre>
2638   int num_methods = methods-&gt;length();
2639   for (int index = 0; index &lt; num_methods; ++index) {
2640     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2641   }
2642   if (JvmtiExport::has_redefined_a_class()) {
2643     // Reinitialize vtable because RedefineClasses may have changed some
2644     // entries in this vtable for super classes so the CDS vtable might
2645     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2646     // vtables in the shared system dictionary, only the main one.
2647     // It also redefines the itable too so fix that too.
2648     vtable().initialize_vtable(false, CHECK);
2649     itable().initialize_itable(false, CHECK);
2650   }
2651 
2652   // restore constant pool resolved references
2653   constants()-&gt;restore_unshareable_info(CHECK);
2654 
2655   if (array_klasses() != NULL) {
2656     // Array classes have null protection domain.
2657     // --&gt; see ArrayKlass::complete_create_array_klass()
<span class="line-modified">2658     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);</span>
2659   }
2660 
2661   // Initialize current biased locking state.
2662   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {
2663     set_prototype_header(markWord::biased_locking_prototype());
2664   }
2665 }
2666 
2667 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2668   switch (loader_type) {
2669   case ClassLoader::BOOT_LOADER:
2670     _misc_flags |= _misc_is_shared_boot_class;
2671     break;
2672   case ClassLoader::PLATFORM_LOADER:
2673     _misc_flags |= _misc_is_shared_platform_class;
2674     break;
2675   case ClassLoader::APP_LOADER:
2676     _misc_flags |= _misc_is_shared_app_class;
2677     break;
2678   default:
</pre>
<hr />
<pre>
3864 
3865   // Verify default methods
3866   if (default_methods() != NULL) {
3867     Array&lt;Method*&gt;* methods = this-&gt;default_methods();
3868     for (int j = 0; j &lt; methods-&gt;length(); j++) {
3869       guarantee(methods-&gt;at(j)-&gt;is_method(), &quot;non-method in methods array&quot;);
3870     }
3871     for (int j = 0; j &lt; methods-&gt;length() - 1; j++) {
3872       Method* m1 = methods-&gt;at(j);
3873       Method* m2 = methods-&gt;at(j + 1);
3874       guarantee(m1-&gt;name()-&gt;fast_compare(m2-&gt;name()) &lt;= 0, &quot;methods not sorted correctly&quot;);
3875     }
3876   }
3877 
3878   // Verify JNI static field identifiers
3879   if (jni_ids() != NULL) {
3880     jni_ids()-&gt;verify(this);
3881   }
3882 
3883   // Verify other fields



3884   if (constants() != NULL) {
3885     guarantee(constants()-&gt;is_constantPool(), &quot;should be constant pool&quot;);
3886   }
3887   const Klass* anonymous_host = unsafe_anonymous_host();
3888   if (anonymous_host != NULL) {
3889     guarantee(anonymous_host-&gt;is_klass(), &quot;should be klass&quot;);
3890   }
3891 }
3892 
3893 void InstanceKlass::oop_verify_on(oop obj, outputStream* st) {
3894   Klass::oop_verify_on(obj, st);
3895   VerifyFieldClosure blk;
3896   obj-&gt;oop_iterate(&amp;blk);
3897 }
3898 
3899 
3900 // JNIid class for jfieldIDs only
3901 // Note to reviewers:
3902 // These JNI functions are just moved over to column 1 and not changed
3903 // in the compressed oops workspace.
</pre>
</td>
</tr>
</table>
<center><a href="arrayKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
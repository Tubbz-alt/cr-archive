<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/valueKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="valueArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/valueKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
239     ResourceMark rm;
240     {
241       // Atomic creation of array_klasses
242       MutexLocker ma(THREAD, MultiArray_lock);
243       if (get_value_array_klass() == NULL) {
244         vak = allocate_value_array_klass(CHECK_NULL);
245         Atomic::release_store((Klass**)adr_value_array_klass(), vak);
246       }
247     }
248   }
249   if (or_null) {
250     return vak-&gt;array_klass_or_null(rank);
251   }
252   return vak-&gt;array_klass(rank, THREAD);
253 }
254 
255 Klass* ValueKlass::allocate_value_array_klass(TRAPS) {
256   if (flatten_array()) {
257     return ValueArrayKlass::allocate_klass(this, THREAD);
258   }
<span class="line-modified">259   return ObjArrayKlass::allocate_objArray_klass(1, this, THREAD);</span>






260 }
261 
262 void ValueKlass::array_klasses_do(void f(Klass* k)) {
263   InstanceKlass::array_klasses_do(f);
264   if (get_value_array_klass() != NULL)
265     ArrayKlass::cast(get_value_array_klass())-&gt;array_klasses_do(f);
266 }
267 
268 // Value type arguments are not passed by reference, instead each
269 // field of the value type is passed as an argument. This helper
270 // function collects the fields of the value types (including embedded
271 // value type&#39;s fields) in a list. Included with the field&#39;s type is
272 // the offset of each field in the value type: i2c and c2i adapters
273 // need that to load or store fields. Finally, the list of fields is
274 // sorted in order of increasing offsets: the adapters and the
275 // compiled code need to agree upon the order of fields.
276 //
277 // The list of basic types that is returned starts with a T_VALUETYPE
278 // and ends with an extra T_VOID. T_VALUETYPE/T_VOID pairs are used as
279 // delimiters. Every entry between the two is a field of the value
</pre>
</td>
<td>
<hr />
<pre>
239     ResourceMark rm;
240     {
241       // Atomic creation of array_klasses
242       MutexLocker ma(THREAD, MultiArray_lock);
243       if (get_value_array_klass() == NULL) {
244         vak = allocate_value_array_klass(CHECK_NULL);
245         Atomic::release_store((Klass**)adr_value_array_klass(), vak);
246       }
247     }
248   }
249   if (or_null) {
250     return vak-&gt;array_klass_or_null(rank);
251   }
252   return vak-&gt;array_klass(rank, THREAD);
253 }
254 
255 Klass* ValueKlass::allocate_value_array_klass(TRAPS) {
256   if (flatten_array()) {
257     return ValueArrayKlass::allocate_klass(this, THREAD);
258   }
<span class="line-modified">259   return ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, THREAD);</span>
<span class="line-added">260 }</span>
<span class="line-added">261 </span>
<span class="line-added">262 void ValueKlass::array_klasses_do(void f(Klass* k, TRAPS), TRAPS) {</span>
<span class="line-added">263   InstanceKlass::array_klasses_do(f, THREAD);</span>
<span class="line-added">264   if (get_value_array_klass() != NULL)</span>
<span class="line-added">265     ArrayKlass::cast(get_value_array_klass())-&gt;array_klasses_do(f, THREAD);</span>
266 }
267 
268 void ValueKlass::array_klasses_do(void f(Klass* k)) {
269   InstanceKlass::array_klasses_do(f);
270   if (get_value_array_klass() != NULL)
271     ArrayKlass::cast(get_value_array_klass())-&gt;array_klasses_do(f);
272 }
273 
274 // Value type arguments are not passed by reference, instead each
275 // field of the value type is passed as an argument. This helper
276 // function collects the fields of the value types (including embedded
277 // value type&#39;s fields) in a list. Included with the field&#39;s type is
278 // the offset of each field in the value type: i2c and c2i adapters
279 // need that to load or store fields. Finally, the list of fields is
280 // sorted in order of increasing offsets: the adapters and the
281 // compiled code need to agree upon the order of fields.
282 //
283 // The list of basic types that is returned starts with a T_VALUETYPE
284 // and ends with an extra T_VOID. T_VALUETYPE/T_VOID pairs are used as
285 // delimiters. Every entry between the two is a field of the value
</pre>
</td>
</tr>
</table>
<center><a href="valueArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
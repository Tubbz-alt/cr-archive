<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/valueArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="typeArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/valueArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
329 
330 
331 Klass* ValueArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
332   assert(dimension() &lt;= n, &quot;check order of chain&quot;);
333   int dim = dimension();
334   if (dim == n) return this;
335 
336   if (higher_dimension_acquire() == NULL) {
337     if (or_null)  return NULL;
338 
339     ResourceMark rm;
340     {
341       // Ensure atomic creation of higher dimensions
342       MutexLocker mu(THREAD, MultiArray_lock);
343 
344       // Check if another thread beat us
345       if (higher_dimension() == NULL) {
346 
347         // Create multi-dim klass object and link them together
348         Klass* k =
<span class="line-modified">349           ObjArrayKlass::allocate_objArray_klass(dim + 1, this, CHECK_NULL);</span>
350         ObjArrayKlass* ak = ObjArrayKlass::cast(k);
351         ak-&gt;set_lower_dimension(this);
352         OrderAccess::storestore();
353         release_set_higher_dimension(ak);
354         assert(ak-&gt;is_objArray_klass(), &quot;incorrect initialization of ObjArrayKlass&quot;);
355       }
356     }
357   } else {
358     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());
359   }
360 
361   ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
362   if (or_null) {
363     return ak-&gt;array_klass_or_null(n);
364   }
365   return ak-&gt;array_klass(n, THREAD);
366 }
367 
368 Klass* ValueArrayKlass::array_klass_impl(bool or_null, TRAPS) {
369   return array_klass_impl(or_null, dimension() +  1, THREAD);
</pre>
</td>
<td>
<hr />
<pre>
329 
330 
331 Klass* ValueArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
332   assert(dimension() &lt;= n, &quot;check order of chain&quot;);
333   int dim = dimension();
334   if (dim == n) return this;
335 
336   if (higher_dimension_acquire() == NULL) {
337     if (or_null)  return NULL;
338 
339     ResourceMark rm;
340     {
341       // Ensure atomic creation of higher dimensions
342       MutexLocker mu(THREAD, MultiArray_lock);
343 
344       // Check if another thread beat us
345       if (higher_dimension() == NULL) {
346 
347         // Create multi-dim klass object and link them together
348         Klass* k =
<span class="line-modified">349           ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);</span>
350         ObjArrayKlass* ak = ObjArrayKlass::cast(k);
351         ak-&gt;set_lower_dimension(this);
352         OrderAccess::storestore();
353         release_set_higher_dimension(ak);
354         assert(ak-&gt;is_objArray_klass(), &quot;incorrect initialization of ObjArrayKlass&quot;);
355       }
356     }
357   } else {
358     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());
359   }
360 
361   ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
362   if (or_null) {
363     return ak-&gt;array_klass_or_null(n);
364   }
365   return ak-&gt;array_klass(n, THREAD);
366 }
367 
368 Klass* ValueArrayKlass::array_klass_impl(bool or_null, TRAPS) {
369   return array_klass_impl(or_null, dimension() +  1, THREAD);
</pre>
</td>
</tr>
</table>
<center><a href="typeArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
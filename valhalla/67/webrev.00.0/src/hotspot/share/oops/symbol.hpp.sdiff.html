<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/symbol.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="symbol.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="typeArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/symbol.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
151 
152   // Symbols should be stored in the read-only region of CDS archive.
153   static bool is_read_only_by_default() { return true; }
154 
155   // Returns the largest size symbol we can safely hold.
156   static int max_length() { return max_symbol_length; }
157   unsigned identity_hash() const {
158     unsigned addr_bits = (unsigned)((uintptr_t)this &gt;&gt; (LogMinObjAlignmentInBytes + 3));
159     return ((unsigned)extract_hash(_hash_and_refcount) &amp; 0xffff) |
160            ((addr_bits ^ (length() &lt;&lt; 8) ^ (( _body[0] &lt;&lt; 8) | _body[1])) &lt;&lt; 16);
161   }
162 
163   // Reference counting.  See comments above this class for when to use.
164   int refcount() const { return extract_refcount(_hash_and_refcount); }
165   bool try_increment_refcount();
166   void increment_refcount();
167   void decrement_refcount();
168   bool is_permanent() const {
169     return (refcount() == PERM_REFCOUNT);
170   }
<span class="line-modified">171   void set_permanent();</span>

172   void make_permanent();
173 
174   // Function char_at() returns the Symbol&#39;s selected u1 byte as a char type.
175   //
176   // Note that all multi-byte chars have the sign bit set on all their bytes.
177   // No single byte chars have their sign bit set.
178   char char_at(int index) const {
179     assert(index &gt;=0 &amp;&amp; index &lt; length(), &quot;symbol index overflow&quot;);
180     return (char)base()[index];
181   }
182 
183   const u1* bytes() const { return base(); }
184 
185   int utf8_length() const { return length(); }
186 
187   // Compares the symbol with a string.
188   bool equals(const char* str, int len) const {
189     int l = utf8_length();
190     if (l != len) return false;
191     return contains_utf8_at(0, str, len);
</pre>
</td>
<td>
<hr />
<pre>
151 
152   // Symbols should be stored in the read-only region of CDS archive.
153   static bool is_read_only_by_default() { return true; }
154 
155   // Returns the largest size symbol we can safely hold.
156   static int max_length() { return max_symbol_length; }
157   unsigned identity_hash() const {
158     unsigned addr_bits = (unsigned)((uintptr_t)this &gt;&gt; (LogMinObjAlignmentInBytes + 3));
159     return ((unsigned)extract_hash(_hash_and_refcount) &amp; 0xffff) |
160            ((addr_bits ^ (length() &lt;&lt; 8) ^ (( _body[0] &lt;&lt; 8) | _body[1])) &lt;&lt; 16);
161   }
162 
163   // Reference counting.  See comments above this class for when to use.
164   int refcount() const { return extract_refcount(_hash_and_refcount); }
165   bool try_increment_refcount();
166   void increment_refcount();
167   void decrement_refcount();
168   bool is_permanent() const {
169     return (refcount() == PERM_REFCOUNT);
170   }
<span class="line-modified">171   void update_identity_hash() NOT_CDS_RETURN;</span>
<span class="line-added">172   void set_permanent() NOT_CDS_RETURN;</span>
173   void make_permanent();
174 
175   // Function char_at() returns the Symbol&#39;s selected u1 byte as a char type.
176   //
177   // Note that all multi-byte chars have the sign bit set on all their bytes.
178   // No single byte chars have their sign bit set.
179   char char_at(int index) const {
180     assert(index &gt;=0 &amp;&amp; index &lt; length(), &quot;symbol index overflow&quot;);
181     return (char)base()[index];
182   }
183 
184   const u1* bytes() const { return base(); }
185 
186   int utf8_length() const { return length(); }
187 
188   // Compares the symbol with a string.
189   bool equals(const char* str, int len) const {
190     int l = utf8_length();
191     if (l != len) return false;
192     return contains_utf8_at(0, str, len);
</pre>
</td>
</tr>
</table>
<center><a href="symbol.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="typeArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
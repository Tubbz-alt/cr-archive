<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/globals.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_RUNTIME_GLOBALS_HPP
  26 #define SHARE_RUNTIME_GLOBALS_HPP
  27 
  28 #include &quot;compiler/compiler_globals.hpp&quot;
  29 #include &quot;gc/shared/gc_globals.hpp&quot;
  30 #include &quot;runtime/globals_shared.hpp&quot;
  31 #include &quot;utilities/align.hpp&quot;
  32 #include &quot;utilities/globalDefinitions.hpp&quot;
  33 #include &quot;utilities/macros.hpp&quot;
  34 #include CPU_HEADER(globals)
  35 #include OS_HEADER(globals)
  36 #include OS_CPU_HEADER(globals)
  37 
  38 // develop flags are settable / visible only during development and are constant in the PRODUCT version
  39 // product flags are always settable / visible
  40 // notproduct flags are settable / visible only during development and are not declared in the PRODUCT version
  41 
  42 // A flag must be declared with one of the following types:
  43 // bool, int, uint, intx, uintx, size_t, ccstr, ccstrlist, double, or uint64_t.
  44 // The type &quot;ccstr&quot; and &quot;ccstrlist&quot; are an alias for &quot;const char*&quot; and is used
  45 // only in this file, because the macrology requires single-token type names.
  46 
  47 // Note: Diagnostic options not meant for VM tuning or for product modes.
  48 // They are to be used for VM quality assurance or field diagnosis
  49 // of VM bugs.  They are hidden so that users will not be encouraged to
  50 // try them as if they were VM ordinary execution options.  However, they
  51 // are available in the product version of the VM.  Under instruction
  52 // from support engineers, VM customers can turn them on to collect
  53 // diagnostic information about VM problems.  To use a VM diagnostic
  54 // option, you must first specify +UnlockDiagnosticVMOptions.
  55 // (This master switch also affects the behavior of -Xprintflags.)
  56 //
  57 // experimental flags are in support of features that are not
  58 //    part of the officially supported product, but are available
  59 //    for experimenting with. They could, for example, be performance
  60 //    features that may not have undergone full or rigorous QA, but which may
  61 //    help performance in some cases and released for experimentation
  62 //    by the community of users and developers. This flag also allows one to
  63 //    be able to build a fully supported product that nonetheless also
  64 //    ships with some unsupported, lightly tested, experimental features.
  65 //    Like the UnlockDiagnosticVMOptions flag above, there is a corresponding
  66 //    UnlockExperimentalVMOptions flag, which allows the control and
  67 //    modification of the experimental flags.
  68 //
  69 // Nota bene: neither diagnostic nor experimental options should be used casually,
  70 //    and they are not supported on production loads, except under explicit
  71 //    direction from support engineers.
  72 //
  73 // manageable flags are writeable external product flags.
  74 //    They are dynamically writeable through the JDK management interface
  75 //    (com.sun.management.HotSpotDiagnosticMXBean API) and also through JConsole.
  76 //    These flags are external exported interface (see CCC).  The list of
  77 //    manageable flags can be queried programmatically through the management
  78 //    interface.
  79 //
  80 //    A flag can be made as &quot;manageable&quot; only if
  81 //    - the flag is defined in a CCC as an external exported interface.
  82 //    - the VM implementation supports dynamic setting of the flag.
  83 //      This implies that the VM must *always* query the flag variable
  84 //      and not reuse state related to the flag state at any given time.
  85 //    - you want the flag to be queried programmatically by the customers.
  86 //
  87 // product_rw flags are writeable internal product flags.
  88 //    They are like &quot;manageable&quot; flags but for internal/private use.
  89 //    The list of product_rw flags are internal/private flags which
  90 //    may be changed/removed in a future release.  It can be set
  91 //    through the management interface to get/set value
  92 //    when the name of flag is supplied.
  93 //
  94 //    A flag can be made as &quot;product_rw&quot; only if
  95 //    - the VM implementation supports dynamic setting of the flag.
  96 //      This implies that the VM must *always* query the flag variable
  97 //      and not reuse state related to the flag state at any given time.
  98 //
  99 // Note that when there is a need to support develop flags to be writeable,
 100 // it can be done in the same way as product_rw.
 101 //
 102 // range is a macro that will expand to min and max arguments for range
 103 //    checking code if provided - see jvmFlagRangeList.hpp
 104 //
 105 // constraint is a macro that will expand to custom function call
 106 //    for constraint checking if provided - see jvmFlagConstraintList.hpp
 107 
 108 // Default and minimum StringTable and SymbolTable size values
 109 // Must be powers of 2
 110 const size_t defaultStringTableSize = NOT_LP64(1024) LP64_ONLY(65536);
 111 const size_t minimumStringTableSize = 128;
 112 const size_t defaultSymbolTableSize = 32768; // 2^15
 113 const size_t minimumSymbolTableSize = 1024;
 114 
 115 #define RUNTIME_FLAGS(develop, \
 116                       develop_pd, \
 117                       product, \
 118                       product_pd, \
 119                       diagnostic, \
 120                       diagnostic_pd, \
 121                       experimental, \
 122                       notproduct, \
 123                       manageable, \
 124                       product_rw, \
 125                       lp64_product, \
 126                       range, \
 127                       constraint) \
 128                                                                             \
 129   lp64_product(bool, UseCompressedOops, false,                              \
 130           &quot;Use 32-bit object references in 64-bit VM. &quot;                     \
 131           &quot;lp64_product means flag is always constant in 32 bit VM&quot;)        \
 132                                                                             \
 133   lp64_product(bool, UseCompressedClassPointers, false,                     \
 134           &quot;Use 32-bit class pointers in 64-bit VM. &quot;                        \
 135           &quot;lp64_product means flag is always constant in 32 bit VM&quot;)        \
 136                                                                             \
 137   notproduct(bool, CheckCompressedOops, true,                               \
 138           &quot;Generate checks in encoding/decoding code in debug VM&quot;)          \
 139                                                                             \
 140   product(uintx, HeapSearchSteps, 3 PPC64_ONLY(+17),                        \
 141           &quot;Heap allocation steps through preferred address regions to find&quot; \
 142           &quot; where it can allocate the heap. Number of steps to take per &quot;   \
 143           &quot;region.&quot;)                                                        \
 144           range(1, max_uintx)                                               \
 145                                                                             \
 146   lp64_product(intx, ObjectAlignmentInBytes, 8,                             \
 147           &quot;Default object alignment in bytes, 8 is minimum&quot;)                \
 148           range(8, 256)                                                     \
 149           constraint(ObjectAlignmentInBytesConstraintFunc,AtParse)          \
 150                                                                             \
 151   develop(bool, CleanChunkPoolAsync, true,                                  \
 152           &quot;Clean the chunk pool asynchronously&quot;)                            \
 153                                                                             \
 154   diagnostic(uint, HandshakeTimeout, 0,                                     \
 155           &quot;If nonzero set a timeout in milliseconds for handshakes&quot;)        \
 156                                                                             \
 157   experimental(bool, AlwaysSafeConstructors, false,                         \
 158           &quot;Force safe construction, as if all fields are final.&quot;)           \
 159                                                                             \
 160   diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \
 161           &quot;Enable normal processing of flags relating to field diagnostics&quot;)\
 162                                                                             \
 163   experimental(bool, UnlockExperimentalVMOptions, false,                    \
 164           &quot;Enable normal processing of flags relating to experimental &quot;     \
 165           &quot;features&quot;)                                                       \
 166                                                                             \
 167   product(bool, JavaMonitorsInStackTrace, true,                             \
 168           &quot;Print information about Java monitor locks when the stacks are&quot;  \
 169           &quot;dumped&quot;)                                                         \
 170                                                                             \
 171   product_pd(bool, UseLargePages,                                           \
 172           &quot;Use large page memory&quot;)                                          \
 173                                                                             \
 174   product_pd(bool, UseLargePagesIndividualAllocation,                       \
 175           &quot;Allocate large pages individually for better affinity&quot;)          \
 176                                                                             \
 177   develop(bool, LargePagesIndividualAllocationInjectError, false,           \
 178           &quot;Fail large pages individual allocation&quot;)                         \
 179                                                                             \
 180   product(bool, UseLargePagesInMetaspace, false,                            \
 181           &quot;Use large page memory in metaspace. &quot;                            \
 182           &quot;Only used if UseLargePages is enabled.&quot;)                         \
 183                                                                             \
 184   product(bool, UseNUMA, false,                                             \
 185           &quot;Use NUMA if available&quot;)                                          \
 186                                                                             \
 187   product(bool, UseNUMAInterleaving, false,                                 \
 188           &quot;Interleave memory across NUMA nodes if available&quot;)               \
 189                                                                             \
 190   product(size_t, NUMAInterleaveGranularity, 2*M,                           \
 191           &quot;Granularity to use for NUMA interleaving on Windows OS&quot;)         \
 192           range(os::vm_allocation_granularity(), NOT_LP64(2*G) LP64_ONLY(8192*G)) \
 193                                                                             \
 194   product(bool, ForceNUMA, false,                                           \
<a name="1" id="anc1"></a><span class="line-modified"> 195           &quot;Force NUMA optimizations on single-node/UMA systems&quot;)            \</span>
 196                                                                             \
 197   product(uintx, NUMAChunkResizeWeight, 20,                                 \
 198           &quot;Percentage (0-100) used to weight the current sample when &quot;      \
 199           &quot;computing exponentially decaying average for &quot;                   \
 200           &quot;AdaptiveNUMAChunkSizing&quot;)                                        \
 201           range(0, 100)                                                     \
 202                                                                             \
 203   product(size_t, NUMASpaceResizeRate, 1*G,                                 \
 204           &quot;Do not reallocate more than this amount per collection&quot;)         \
 205           range(0, max_uintx)                                               \
 206                                                                             \
 207   product(bool, UseAdaptiveNUMAChunkSizing, true,                           \
 208           &quot;Enable adaptive chunk sizing for NUMA&quot;)                          \
 209                                                                             \
 210   product(bool, NUMAStats, false,                                           \
 211           &quot;Print NUMA stats in detailed heap information&quot;)                  \
 212                                                                             \
 213   product(uintx, NUMAPageScanRate, 256,                                     \
 214           &quot;Maximum number of pages to include in the page scan procedure&quot;)  \
 215           range(0, max_uintx)                                               \
 216                                                                             \
 217   product(bool, UseAES, false,                                              \
 218           &quot;Control whether AES instructions are used when available&quot;)       \
 219                                                                             \
 220   product(bool, UseFMA, false,                                              \
 221           &quot;Control whether FMA instructions are used when available&quot;)       \
 222                                                                             \
 223   product(bool, UseSHA, false,                                              \
 224           &quot;Control whether SHA instructions are used when available&quot;)       \
 225                                                                             \
 226   diagnostic(bool, UseGHASHIntrinsics, false,                               \
 227           &quot;Use intrinsics for GHASH versions of crypto&quot;)                    \
 228                                                                             \
 229   product(bool, UseBASE64Intrinsics, false,                                 \
 230           &quot;Use intrinsics for java.util.Base64&quot;)                            \
 231                                                                             \
 232   product(size_t, LargePageSizeInBytes, 0,                                  \
 233           &quot;Large page size (0 to let VM choose the page size)&quot;)             \
 234           range(0, max_uintx)                                               \
 235                                                                             \
 236   product(size_t, LargePageHeapSizeThreshold, 128*M,                        \
 237           &quot;Use large pages if maximum heap is at least this big&quot;)           \
 238           range(0, max_uintx)                                               \
 239                                                                             \
 240   product(bool, ForceTimeHighResolution, false,                             \
 241           &quot;Using high time resolution (for Win32 only)&quot;)                    \
 242                                                                             \
 243   develop(bool, TracePcPatching, false,                                     \
 244           &quot;Trace usage of frame::patch_pc&quot;)                                 \
 245                                                                             \
 246   develop(bool, TraceRelocator, false,                                      \
 247           &quot;Trace the bytecode relocator&quot;)                                   \
 248                                                                             \
 249   develop(bool, TraceLongCompiles, false,                                   \
 250           &quot;Print out every time compilation is longer than &quot;                \
 251           &quot;a given threshold&quot;)                                              \
 252                                                                             \
 253   diagnostic(bool, SafepointALot, false,                                    \
 254           &quot;Generate a lot of safepoints. This works with &quot;                  \
 255           &quot;GuaranteedSafepointInterval&quot;)                                    \
 256                                                                             \
 257   diagnostic(bool, HandshakeALot, false,                                    \
 258           &quot;Generate a lot of handshakes. This works with &quot;                  \
 259           &quot;GuaranteedSafepointInterval&quot;)                                    \
 260                                                                             \
 261   product_pd(bool, BackgroundCompilation,                                   \
 262           &quot;A thread requesting compilation is not blocked during &quot;          \
 263           &quot;compilation&quot;)                                                    \
 264                                                                             \
 265   product(bool, PrintVMQWaitTime, false,                                    \
 266           &quot;(Deprecated) Print out the waiting time in VM operation queue&quot;)  \
 267                                                                             \
 268   product(bool, MethodFlushing, true,                                       \
 269           &quot;Reclamation of zombie and not-entrant methods&quot;)                  \
 270                                                                             \
 271   develop(bool, VerifyStack, false,                                         \
 272           &quot;Verify stack of each thread when it is entering a runtime call&quot;) \
 273                                                                             \
 274   diagnostic(bool, ForceUnreachable, false,                                 \
 275           &quot;Make all non code cache addresses to be unreachable by &quot;         \
 276           &quot;forcing use of 64bit literal fixups&quot;)                            \
 277                                                                             \
 278   notproduct(bool, StressDerivedPointers, false,                            \
 279           &quot;Force scavenge when a derived pointer is detected on stack &quot;     \
 280           &quot;after rtm call&quot;)                                                 \
 281                                                                             \
 282   develop(bool, TraceDerivedPointers, false,                                \
 283           &quot;Trace traversal of derived pointers on stack&quot;)                   \
 284                                                                             \
 285   notproduct(bool, TraceCodeBlobStacks, false,                              \
 286           &quot;Trace stack-walk of codeblobs&quot;)                                  \
 287                                                                             \
 288   notproduct(bool, PrintRewrites, false,                                    \
 289           &quot;Print methods that are being rewritten&quot;)                         \
 290                                                                             \
 291   product(bool, UseInlineCaches, true,                                      \
 292           &quot;Use Inline Caches for virtual calls &quot;)                           \
 293                                                                             \
 294   diagnostic(bool, InlineArrayCopy, true,                                   \
 295           &quot;Inline arraycopy native that is known to be part of &quot;            \
 296           &quot;base library DLL&quot;)                                               \
 297                                                                             \
 298   diagnostic(bool, InlineObjectHash, true,                                  \
 299           &quot;Inline Object::hashCode() native that is known to be part &quot;      \
 300           &quot;of base library DLL&quot;)                                            \
 301                                                                             \
 302   diagnostic(bool, InlineNatives, true,                                     \
 303           &quot;Inline natives that are known to be part of base library DLL&quot;)   \
 304                                                                             \
 305   diagnostic(bool, InlineMathNatives, true,                                 \
 306           &quot;Inline SinD, CosD, etc.&quot;)                                        \
 307                                                                             \
 308   diagnostic(bool, InlineClassNatives, true,                                \
 309           &quot;Inline Class.isInstance, etc&quot;)                                   \
 310                                                                             \
 311   diagnostic(bool, InlineThreadNatives, true,                               \
 312           &quot;Inline Thread.currentThread, etc&quot;)                               \
 313                                                                             \
 314   diagnostic(bool, InlineUnsafeOps, true,                                   \
 315           &quot;Inline memory ops (native methods) from Unsafe&quot;)                 \
 316                                                                             \
 317   product(bool, CriticalJNINatives, true,                                   \
 318           &quot;Check for critical JNI entry points&quot;)                            \
 319                                                                             \
 320   notproduct(bool, StressCriticalJNINatives, false,                         \
 321           &quot;Exercise register saving code in critical natives&quot;)              \
 322                                                                             \
 323   diagnostic(bool, UseAESIntrinsics, false,                                 \
 324           &quot;Use intrinsics for AES versions of crypto&quot;)                      \
 325                                                                             \
 326   diagnostic(bool, UseAESCTRIntrinsics, false,                              \
 327           &quot;Use intrinsics for the paralleled version of AES/CTR crypto&quot;)    \
 328                                                                             \
 329   diagnostic(bool, UseSHA1Intrinsics, false,                                \
 330           &quot;Use intrinsics for SHA-1 crypto hash function. &quot;                 \
 331           &quot;Requires that UseSHA is enabled.&quot;)                               \
 332                                                                             \
 333   diagnostic(bool, UseSHA256Intrinsics, false,                              \
 334           &quot;Use intrinsics for SHA-224 and SHA-256 crypto hash functions. &quot;  \
 335           &quot;Requires that UseSHA is enabled.&quot;)                               \
 336                                                                             \
 337   diagnostic(bool, UseSHA512Intrinsics, false,                              \
 338           &quot;Use intrinsics for SHA-384 and SHA-512 crypto hash functions. &quot;  \
 339           &quot;Requires that UseSHA is enabled.&quot;)                               \
 340                                                                             \
 341   diagnostic(bool, UseCRC32Intrinsics, false,                               \
 342           &quot;use intrinsics for java.util.zip.CRC32&quot;)                         \
 343                                                                             \
 344   diagnostic(bool, UseCRC32CIntrinsics, false,                              \
 345           &quot;use intrinsics for java.util.zip.CRC32C&quot;)                        \
 346                                                                             \
 347   diagnostic(bool, UseAdler32Intrinsics, false,                             \
 348           &quot;use intrinsics for java.util.zip.Adler32&quot;)                       \
 349                                                                             \
 350   diagnostic(bool, UseVectorizedMismatchIntrinsic, false,                   \
 351           &quot;Enables intrinsification of ArraysSupport.vectorizedMismatch()&quot;) \
 352                                                                             \
 353   diagnostic(ccstrlist, DisableIntrinsic, &quot;&quot;,                               \
 354          &quot;do not expand intrinsics whose (internal) names appear here&quot;)     \
 355                                                                             \
 356   develop(bool, TraceCallFixup, false,                                      \
 357           &quot;Trace all call fixups&quot;)                                          \
 358                                                                             \
 359   develop(bool, DeoptimizeALot, false,                                      \
 360           &quot;Deoptimize at every exit from the runtime system&quot;)               \
 361                                                                             \
 362   notproduct(ccstrlist, DeoptimizeOnlyAt, &quot;&quot;,                               \
 363           &quot;A comma separated list of bcis to deoptimize at&quot;)                \
 364                                                                             \
 365   develop(bool, DeoptimizeRandom, false,                                    \
 366           &quot;Deoptimize random frames on random exit from the runtime system&quot;)\
 367                                                                             \
 368   notproduct(bool, ZombieALot, false,                                       \
 369           &quot;Create zombies (non-entrant) at exit from the runtime system&quot;)   \
 370                                                                             \
 371   notproduct(bool, WalkStackALot, false,                                    \
 372           &quot;Trace stack (no print) at every exit from the runtime system&quot;)   \
 373                                                                             \
 374   product(bool, Debugging, false,                                           \
 375           &quot;Set when executing debug methods in debug.cpp &quot;                  \
 376           &quot;(to prevent triggering assertions)&quot;)                             \
 377                                                                             \
 378   notproduct(bool, VerifyLastFrame, false,                                  \
 379           &quot;Verify oops on last frame on entry to VM&quot;)                       \
 380                                                                             \
 381   product(bool, SafepointTimeout, false,                                    \
 382           &quot;Time out and warn or fail after SafepointTimeoutDelay &quot;          \
 383           &quot;milliseconds if failed to reach safepoint&quot;)                      \
 384                                                                             \
 385   diagnostic(bool, AbortVMOnSafepointTimeout, false,                        \
 386           &quot;Abort upon failure to reach safepoint (see SafepointTimeout)&quot;)   \
 387                                                                             \
 388   diagnostic(bool, AbortVMOnVMOperationTimeout, false,                      \
 389           &quot;Abort upon failure to complete VM operation promptly&quot;)           \
 390                                                                             \
 391   diagnostic(intx, AbortVMOnVMOperationTimeoutDelay, 1000,                  \
 392           &quot;Delay in milliseconds for option AbortVMOnVMOperationTimeout&quot;)   \
 393           range(0, max_intx)                                                \
 394                                                                             \
 395   /* 50 retries * (5 * current_retry_count) millis = ~6.375 seconds */      \
 396   /* typically, at most a few retries are needed                    */      \
 397   product(intx, SuspendRetryCount, 50,                                      \
 398           &quot;Maximum retry count for an external suspend request&quot;)            \
 399           range(0, max_intx)                                                \
 400                                                                             \
 401   product(intx, SuspendRetryDelay, 5,                                       \
 402           &quot;Milliseconds to delay per retry (* current_retry_count)&quot;)        \
 403           range(0, max_intx)                                                \
 404                                                                             \
 405   product(bool, AssertOnSuspendWaitFailure, false,                          \
 406           &quot;Assert/Guarantee on external suspend wait failure&quot;)              \
 407                                                                             \
 408   product(bool, TraceSuspendWaitFailures, false,                            \
 409           &quot;Trace external suspend wait failures&quot;)                           \
 410                                                                             \
 411   product(bool, MaxFDLimit, true,                                           \
 412           &quot;Bump the number of file descriptors to maximum in Solaris&quot;)      \
 413                                                                             \
 414   diagnostic(bool, LogEvents, true,                                         \
 415           &quot;Enable the various ring buffer event logs&quot;)                      \
 416                                                                             \
 417   diagnostic(uintx, LogEventsBufferEntries, 20,                             \
 418           &quot;Number of ring buffer event logs&quot;)                               \
 419           range(1, NOT_LP64(1*K) LP64_ONLY(1*M))                            \
 420                                                                             \
 421   diagnostic(bool, BytecodeVerificationRemote, true,                        \
 422           &quot;Enable the Java bytecode verifier for remote classes&quot;)           \
 423                                                                             \
 424   diagnostic(bool, BytecodeVerificationLocal, false,                        \
 425           &quot;Enable the Java bytecode verifier for local classes&quot;)            \
 426                                                                             \
 427   develop(bool, ForceFloatExceptions, trueInDebug,                          \
 428           &quot;Force exceptions on FP stack under/overflow&quot;)                    \
 429                                                                             \
 430   develop(bool, VerifyStackAtCalls, false,                                  \
 431           &quot;Verify that the stack pointer is unchanged after calls&quot;)         \
 432                                                                             \
 433   develop(bool, TraceJavaAssertions, false,                                 \
 434           &quot;Trace java language assertions&quot;)                                 \
 435                                                                             \
 436   notproduct(bool, VerifyCodeCache, false,                                  \
 437           &quot;Verify code cache on memory allocation/deallocation&quot;)            \
 438                                                                             \
 439   develop(bool, UseMallocOnly, false,                                       \
 440           &quot;Use only malloc/free for allocation (no resource area/arena)&quot;)   \
 441                                                                             \
 442   develop(bool, ZapResourceArea, trueInDebug,                               \
 443           &quot;Zap freed resource/arena space with 0xABABABAB&quot;)                 \
 444                                                                             \
 445   notproduct(bool, ZapVMHandleArea, trueInDebug,                            \
 446           &quot;Zap freed VM handle space with 0xBCBCBCBC&quot;)                      \
 447                                                                             \
 448   notproduct(bool, ZapStackSegments, trueInDebug,                           \
 449           &quot;Zap allocated/freed stack segments with 0xFADFADED&quot;)             \
 450                                                                             \
 451   develop(bool, ZapUnusedHeapArea, trueInDebug,                             \
 452           &quot;Zap unused heap space with 0xBAADBABE&quot;)                          \
 453                                                                             \
 454   develop(bool, CheckZapUnusedHeapArea, false,                              \
 455           &quot;Check zapping of unused heap space&quot;)                             \
 456                                                                             \
 457   develop(bool, ZapFillerObjects, trueInDebug,                              \
 458           &quot;Zap filler objects with 0xDEAFBABE&quot;)                             \
 459                                                                             \
 460   develop(bool, PrintVMMessages, true,                                      \
 461           &quot;Print VM messages on console&quot;)                                   \
 462                                                                             \
 463   notproduct(uintx, ErrorHandlerTest, 0,                                    \
 464           &quot;If &gt; 0, provokes an error after VM initialization; the value &quot;   \
 465           &quot;determines which error to provoke. See test_error_handler() &quot;    \
 466           &quot;in vmError.cpp.&quot;)                                                \
 467                                                                             \
 468   notproduct(uintx, TestCrashInErrorHandler, 0,                             \
 469           &quot;If &gt; 0, provokes an error inside VM error handler (a secondary &quot; \
 470           &quot;crash). see test_error_handler() in vmError.cpp&quot;)                \
 471                                                                             \
 472   notproduct(bool, TestSafeFetchInErrorHandler, false,                      \
 473           &quot;If true, tests SafeFetch inside error handler.&quot;)                 \
 474                                                                             \
 475   notproduct(bool, TestUnresponsiveErrorHandler, false,                     \
 476           &quot;If true, simulates an unresponsive error handler.&quot;)              \
 477                                                                             \
 478   develop(bool, Verbose, false,                                             \
 479           &quot;Print additional debugging information from other modes&quot;)        \
 480                                                                             \
 481   develop(bool, PrintMiscellaneous, false,                                  \
 482           &quot;Print uncategorized debugging information (requires +Verbose)&quot;)  \
 483                                                                             \
 484   develop(bool, WizardMode, false,                                          \
 485           &quot;Print much more debugging information&quot;)                          \
 486                                                                             \
 487   product(bool, ShowMessageBoxOnError, false,                               \
 488           &quot;Keep process alive on VM fatal error&quot;)                           \
 489                                                                             \
 490   product(bool, CreateCoredumpOnCrash, true,                                \
 491           &quot;Create core/mini dump on VM fatal error&quot;)                        \
 492                                                                             \
 493   product(uint64_t, ErrorLogTimeout, 2 * 60,                                \
 494           &quot;Timeout, in seconds, to limit the time spent on writing an &quot;     \
 495           &quot;error log in case of a crash.&quot;)                                  \
 496           range(0, (uint64_t)max_jlong/1000)                                \
 497                                                                             \
 498   product_pd(bool, UseOSErrorReporting,                                     \
 499           &quot;Let VM fatal error propagate to the OS (ie. WER on Windows)&quot;)    \
 500                                                                             \
 501   product(bool, SuppressFatalErrorMessage, false,                           \
 502           &quot;Report NO fatal error message (avoid deadlock)&quot;)                 \
 503                                                                             \
 504   product(ccstrlist, OnError, &quot;&quot;,                                           \
 505           &quot;Run user-defined commands on fatal error; see VMError.cpp &quot;      \
 506           &quot;for examples&quot;)                                                   \
 507                                                                             \
 508   product(ccstrlist, OnOutOfMemoryError, &quot;&quot;,                                \
 509           &quot;Run user-defined commands on first java.lang.OutOfMemoryError&quot;)  \
 510                                                                             \
 511   manageable(bool, HeapDumpBeforeFullGC, false,                             \
 512           &quot;Dump heap to file before any major stop-the-world GC&quot;)           \
 513                                                                             \
 514   manageable(bool, HeapDumpAfterFullGC, false,                              \
 515           &quot;Dump heap to file after any major stop-the-world GC&quot;)            \
 516                                                                             \
 517   manageable(bool, HeapDumpOnOutOfMemoryError, false,                       \
 518           &quot;Dump heap to file when java.lang.OutOfMemoryError is thrown&quot;)    \
 519                                                                             \
 520   manageable(ccstr, HeapDumpPath, NULL,                                     \
 521           &quot;When HeapDumpOnOutOfMemoryError is on, the path (filename or &quot;   \
 522           &quot;directory) of the dump file (defaults to java_pid&lt;pid&gt;.hprof &quot;   \
 523           &quot;in the working directory)&quot;)                                      \
 524                                                                             \
 525   develop(bool, BreakAtWarning, false,                                      \
 526           &quot;Execute breakpoint upon encountering VM warning&quot;)                \
 527                                                                             \
 528   product(ccstr, NativeMemoryTracking, &quot;off&quot;,                               \
 529           &quot;Native memory tracking options&quot;)                                 \
 530                                                                             \
 531   diagnostic(bool, PrintNMTStatistics, false,                               \
 532           &quot;Print native memory tracking summary data if it is on&quot;)          \
 533                                                                             \
 534   diagnostic(bool, LogCompilation, false,                                   \
 535           &quot;Log compilation activity in detail to LogFile&quot;)                  \
 536                                                                             \
 537   product(bool, PrintCompilation, false,                                    \
 538           &quot;Print compilations&quot;)                                             \
 539                                                                             \
 540   product(bool, PrintExtendedThreadInfo, false,                             \
 541           &quot;Print more information in thread dump&quot;)                          \
 542                                                                             \
 543   diagnostic(intx, ScavengeRootsInCode, 2,                                  \
 544           &quot;0: do not allow scavengable oops in the code cache; &quot;            \
 545           &quot;1: allow scavenging from the code cache; &quot;                       \
 546           &quot;2: emit as many constants as the compiler can see&quot;)              \
 547           range(0, 2)                                                       \
 548                                                                             \
 549   product(bool, AlwaysRestoreFPU, false,                                    \
 550           &quot;Restore the FPU control word after every JNI call (expensive)&quot;)  \
 551                                                                             \
 552   diagnostic(bool, PrintCompilation2, false,                                \
 553           &quot;Print additional statistics per compilation&quot;)                    \
 554                                                                             \
 555   diagnostic(bool, PrintAdapterHandlers, false,                             \
 556           &quot;Print code generated for i2c/c2i adapters&quot;)                      \
 557                                                                             \
 558   diagnostic(bool, VerifyAdapterCalls, trueInDebug,                         \
 559           &quot;Verify that i2c/c2i adapters are called properly&quot;)               \
 560                                                                             \
 561   develop(bool, VerifyAdapterSharing, false,                                \
 562           &quot;Verify that the code for shared adapters is the equivalent&quot;)     \
 563                                                                             \
 564   diagnostic(bool, PrintAssembly, false,                                    \
 565           &quot;Print assembly code (using external disassembler.so)&quot;)           \
 566                                                                             \
 567   diagnostic(ccstr, PrintAssemblyOptions, NULL,                             \
 568           &quot;Print options string passed to disassembler.so&quot;)                 \
 569                                                                             \
 570   notproduct(bool, PrintNMethodStatistics, false,                           \
 571           &quot;Print a summary statistic for the generated nmethods&quot;)           \
 572                                                                             \
 573   diagnostic(bool, PrintNMethods, false,                                    \
 574           &quot;Print assembly code for nmethods when generated&quot;)                \
 575                                                                             \
 576   diagnostic(bool, PrintNativeNMethods, false,                              \
 577           &quot;Print assembly code for native nmethods when generated&quot;)         \
 578                                                                             \
 579   develop(bool, PrintDebugInfo, false,                                      \
 580           &quot;Print debug information for all nmethods when generated&quot;)        \
 581                                                                             \
 582   develop(bool, PrintRelocations, false,                                    \
 583           &quot;Print relocation information for all nmethods when generated&quot;)   \
 584                                                                             \
 585   develop(bool, PrintDependencies, false,                                   \
 586           &quot;Print dependency information for all nmethods when generated&quot;)   \
 587                                                                             \
 588   develop(bool, PrintExceptionHandlers, false,                              \
 589           &quot;Print exception handler tables for all nmethods when generated&quot;) \
 590                                                                             \
 591   develop(bool, StressCompiledExceptionHandlers, false,                     \
 592           &quot;Exercise compiled exception handlers&quot;)                           \
 593                                                                             \
 594   develop(bool, InterceptOSException, false,                                \
 595           &quot;Start debugger when an implicit OS (e.g. NULL) &quot;                 \
 596           &quot;exception happens&quot;)                                              \
 597                                                                             \
 598   product(bool, PrintCodeCache, false,                                      \
 599           &quot;Print the code cache memory usage when exiting&quot;)                 \
 600                                                                             \
 601   develop(bool, PrintCodeCache2, false,                                     \
 602           &quot;Print detailed usage information on the code cache when exiting&quot;)\
 603                                                                             \
 604   product(bool, PrintCodeCacheOnCompilation, false,                         \
 605           &quot;Print the code cache memory usage each time a method is &quot;        \
 606           &quot;compiled&quot;)                                                       \
 607                                                                             \
 608   diagnostic(bool, PrintCodeHeapAnalytics, false,                           \
 609           &quot;Print code heap usage statistics on exit and on full condition&quot;) \
 610                                                                             \
 611   diagnostic(bool, PrintStubCode, false,                                    \
 612           &quot;Print generated stub code&quot;)                                      \
 613                                                                             \
 614   product(bool, StackTraceInThrowable, true,                                \
 615           &quot;Collect backtrace in throwable when exception happens&quot;)          \
 616                                                                             \
 617   product(bool, OmitStackTraceInFastThrow, true,                            \
 618           &quot;Omit backtraces for some &#39;hot&#39; exceptions in optimized code&quot;)    \
 619                                                                             \
 620   manageable(bool, ShowCodeDetailsInExceptionMessages, false,               \
 621           &quot;Show exception messages from RuntimeExceptions that contain &quot;    \
 622           &quot;snippets of the failing code. Disable this to improve privacy.&quot;) \
 623                                                                             \
 624   product(bool, PrintWarnings, true,                                        \
 625           &quot;Print JVM warnings to output stream&quot;)                            \
 626                                                                             \
 627   notproduct(uintx, WarnOnStalledSpinLock, 0,                               \
 628           &quot;Print warnings for stalled SpinLocks&quot;)                           \
 629                                                                             \
 630   product(bool, RegisterFinalizersAtInit, true,                             \
 631           &quot;Register finalizable objects at end of Object.&lt;init&gt; or &quot;        \
 632           &quot;after allocation&quot;)                                               \
 633                                                                             \
 634   develop(bool, RegisterReferences, true,                                   \
 635           &quot;Tell whether the VM should register soft/weak/final/phantom &quot;    \
 636           &quot;references&quot;)                                                     \
 637                                                                             \
 638   develop(bool, IgnoreRewrites, false,                                      \
 639           &quot;Suppress rewrites of bytecodes in the oopmap generator. &quot;        \
 640           &quot;This is unsafe!&quot;)                                                \
 641                                                                             \
 642   develop(bool, PrintCodeCacheExtension, false,                             \
 643           &quot;Print extension of code cache&quot;)                                  \
 644                                                                             \
 645   develop(bool, UsePrivilegedStack, true,                                   \
 646           &quot;Enable the security JVM functions&quot;)                              \
 647                                                                             \
 648   develop(bool, ProtectionDomainVerification, true,                         \
 649           &quot;Verify protection domain before resolution in system dictionary&quot;)\
 650                                                                             \
 651   product(bool, ClassUnloading, true,                                       \
 652           &quot;Do unloading of classes&quot;)                                        \
 653                                                                             \
 654   product(bool, ClassUnloadingWithConcurrentMark, true,                     \
 655           &quot;Do unloading of classes with a concurrent marking cycle&quot;)        \
 656                                                                             \
 657   develop(bool, DisableStartThread, false,                                  \
 658           &quot;Disable starting of additional Java threads &quot;                    \
 659           &quot;(for debugging only)&quot;)                                           \
 660                                                                             \
 661   develop(bool, MemProfiling, false,                                        \
 662           &quot;Write memory usage profiling to log file&quot;)                       \
 663                                                                             \
 664   notproduct(bool, PrintSystemDictionaryAtExit, false,                      \
 665           &quot;Print the system dictionary at exit&quot;)                            \
 666                                                                             \
 667   diagnostic(bool, DynamicallyResizeSystemDictionaries, true,               \
 668           &quot;Dynamically resize system dictionaries as needed&quot;)               \
 669                                                                             \
 670   product(bool, AlwaysLockClassLoader, false,                               \
 671           &quot;Require the VM to acquire the class loader lock before calling &quot; \
 672           &quot;loadClass() even for class loaders registering &quot;                 \
 673           &quot;as parallel capable&quot;)                                            \
 674                                                                             \
 675   product(bool, AllowParallelDefineClass, false,                            \
 676           &quot;Allow parallel defineClass requests for class loaders &quot;          \
 677           &quot;registering as parallel capable&quot;)                                \
 678                                                                             \
 679   product_pd(bool, DontYieldALot,                                           \
 680           &quot;Throw away obvious excess yield calls&quot;)                          \
 681                                                                             \
 682   develop(bool, UseDetachedThreads, true,                                   \
 683           &quot;Use detached threads that are recycled upon termination &quot;        \
 684           &quot;(for Solaris only)&quot;)                                             \
 685                                                                             \
 686   experimental(bool, DisablePrimordialThreadGuardPages, false,              \
 687                &quot;Disable the use of stack guard pages if the JVM is loaded &quot; \
 688                &quot;on the primordial process thread&quot;)                          \
 689                                                                             \
 690   product(bool, UseLWPSynchronization, true,                                \
 691           &quot;Use LWP-based instead of libthread-based synchronization &quot;       \
 692           &quot;(SPARC only)&quot;)                                                   \
 693                                                                             \
<a name="2" id="anc2"></a><span class="line-removed"> 694   product(intx, MonitorBound, 0, &quot;(Deprecated) Bound Monitor population&quot;)   \</span>
<span class="line-removed"> 695           range(0, max_jint)                                                \</span>
<span class="line-removed"> 696                                                                             \</span>
 697   experimental(intx, MonitorUsedDeflationThreshold, 90,                     \
 698                 &quot;Percentage of used monitors before triggering cleanup &quot;    \
 699                 &quot;safepoint which deflates monitors (0 is off). &quot;            \
 700                 &quot;The check is performed on GuaranteedSafepointInterval.&quot;)   \
 701                 range(0, 100)                                               \
 702                                                                             \
 703   experimental(intx, hashCode, 5,                                           \
 704                &quot;(Unstable) select hashCode generation algorithm&quot;)           \
 705                                                                             \
 706   product(bool, FilterSpuriousWakeups, true,                                \
 707           &quot;When true prevents OS-level spurious, or premature, wakeups &quot;    \
 708           &quot;from Object.wait (Ignored for Windows)&quot;)                         \
 709                                                                             \
 710   develop(bool, UsePthreads, false,                                         \
 711           &quot;Use pthread-based instead of libthread-based synchronization &quot;   \
 712           &quot;(SPARC only)&quot;)                                                   \
 713                                                                             \
 714   product(bool, ReduceSignalUsage, false,                                   \
 715           &quot;Reduce the use of OS signals in Java and/or the VM&quot;)             \
 716                                                                             \
 717   develop(bool, LoadLineNumberTables, true,                                 \
 718           &quot;Tell whether the class file parser loads line number tables&quot;)    \
 719                                                                             \
 720   develop(bool, LoadLocalVariableTables, true,                              \
 721           &quot;Tell whether the class file parser loads local variable tables&quot;) \
 722                                                                             \
 723   develop(bool, LoadLocalVariableTypeTables, true,                          \
 724           &quot;Tell whether the class file parser loads local variable type&quot;    \
 725           &quot;tables&quot;)                                                         \
 726                                                                             \
 727   product(bool, AllowUserSignalHandlers, false,                             \
 728           &quot;Do not complain if the application installs signal handlers &quot;    \
 729           &quot;(Solaris &amp; Linux only)&quot;)                                         \
 730                                                                             \
 731   product(bool, UseSignalChaining, true,                                    \
 732           &quot;Use signal-chaining to invoke signal handlers installed &quot;        \
 733           &quot;by the application (Solaris &amp; Linux only)&quot;)                      \
 734                                                                             \
 735   product(bool, RestoreMXCSROnJNICalls, false,                              \
 736           &quot;Restore MXCSR when returning from JNI calls&quot;)                    \
 737                                                                             \
 738   product(bool, CheckJNICalls, false,                                       \
 739           &quot;Verify all arguments to JNI calls&quot;)                              \
 740                                                                             \
 741   product(bool, UseFastJNIAccessors, true,                                  \
 742           &quot;Use optimized versions of Get&lt;Primitive&gt;Field&quot;)                  \
 743                                                                             \
 744   product(intx, MaxJNILocalCapacity, 65536,                                 \
 745           &quot;Maximum allowable local JNI handle capacity to &quot;                 \
 746           &quot;EnsureLocalCapacity() and PushLocalFrame(), &quot;                    \
 747           &quot;where &lt;= 0 is unlimited, default: 65536&quot;)                        \
 748           range(min_intx, max_intx)                                         \
 749                                                                             \
 750   product(bool, EagerXrunInit, false,                                       \
 751           &quot;Eagerly initialize -Xrun libraries; allows startup profiling, &quot;  \
 752           &quot;but not all -Xrun libraries may support the state of the VM &quot;    \
 753           &quot;at this time&quot;)                                                   \
 754                                                                             \
 755   product(bool, PreserveAllAnnotations, false,                              \
 756           &quot;Preserve RuntimeInvisibleAnnotations as well &quot;                   \
 757           &quot;as RuntimeVisibleAnnotations&quot;)                                   \
 758                                                                             \
 759   develop(uintx, PreallocatedOutOfMemoryErrorCount, 4,                      \
 760           &quot;Number of OutOfMemoryErrors preallocated with backtrace&quot;)        \
 761                                                                             \
 762   product(bool, UseXMMForArrayCopy, false,                                  \
 763           &quot;Use SSE2 MOVQ instruction for Arraycopy&quot;)                        \
 764                                                                             \
 765   notproduct(bool, PrintFieldLayout, false,                                 \
 766           &quot;Print field layout for each class&quot;)                              \
 767                                                                             \
 768   notproduct(bool, PrintInlineLayout, false,                                \
 769           &quot;Print field layout for each inline type&quot;)                        \
 770                                                                             \
 771   notproduct(bool, PrintInlineArrayLayout, false,                           \
 772           &quot;Print array layout for each inline type array&quot;)                  \
 773                                                                             \
 774   product(intx, InlineArrayElemMaxFlatSize, -1,                             \
 775           &quot;Max size for flattening inline array elements, &lt;0 no limit&quot;)     \
 776                                                                             \
 777   product(intx, InlineFieldMaxFlatSize, 128,                                \
 778           &quot;Max size for flattening inline type fields, &lt;0 no limit&quot;)        \
 779                                                                             \
 780   product(intx, InlineArrayElemMaxFlatOops, 4,                              \
 781           &quot;Max nof embedded object references in an inline type to flatten, &lt;0 no limit&quot;)  \
 782                                                                             \
 783   product(bool, InlineArrayAtomicAccess, false,                             \
 784           &quot;Atomic inline array accesses by-default, for all inline arrays&quot;) \
 785                                                                             \
 786   /* Need to limit the extent of the padding to reasonable size.          */\
 787   /* 8K is well beyond the reasonable HW cache line size, even with       */\
 788   /* aggressive prefetching, while still leaving the room for segregating */\
 789   /* among the distinct pages.                                            */\
 790   product(intx, ContendedPaddingWidth, 128,                                 \
 791           &quot;How many bytes to pad the fields/classes marked @Contended with&quot;)\
 792           range(0, 8192)                                                    \
 793           constraint(ContendedPaddingWidthConstraintFunc,AfterErgo)         \
 794                                                                             \
 795   product(bool, EnableContended, true,                                      \
 796           &quot;Enable @Contended annotation support&quot;)                           \
 797                                                                             \
 798   product(bool, RestrictContended, true,                                    \
 799           &quot;Restrict @Contended to trusted classes&quot;)                         \
 800                                                                             \
 801   product(bool, UseBiasedLocking, true,                                     \
 802           &quot;Enable biased locking in JVM&quot;)                                   \
 803                                                                             \
 804   product(intx, BiasedLockingStartupDelay, 0,                               \
 805           &quot;Number of milliseconds to wait before enabling biased locking&quot;)  \
 806           range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \
 807           constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \
 808                                                                             \
 809   diagnostic(bool, PrintBiasedLockingStatistics, false,                     \
 810           &quot;Print statistics of biased locking in JVM&quot;)                      \
 811                                                                             \
 812   product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \
 813           &quot;Threshold of number of revocations per type to try to &quot;          \
 814           &quot;rebias all objects in the heap of that type&quot;)                    \
 815           range(0, max_intx)                                                \
 816           constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \
 817                                                                             \
 818   product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \
 819           &quot;Threshold of number of revocations per type to permanently &quot;     \
 820           &quot;revoke biases of all objects in the heap of that type&quot;)          \
 821           range(0, max_intx)                                                \
 822           constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \
 823                                                                             \
 824   product(intx, BiasedLockingDecayTime, 25000,                              \
 825           &quot;Decay time (in milliseconds) to re-enable bulk rebiasing of a &quot;  \
 826           &quot;type after previous bulk rebias&quot;)                                \
 827           range(500, max_intx)                                              \
 828           constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \
 829                                                                             \
 830   product(bool, ExitOnOutOfMemoryError, false,                              \
 831           &quot;JVM exits on the first occurrence of an out-of-memory error&quot;)    \
 832                                                                             \
 833   product(bool, CrashOnOutOfMemoryError, false,                             \
 834           &quot;JVM aborts, producing an error log and core/mini dump, on the &quot;  \
 835           &quot;first occurrence of an out-of-memory error&quot;)                     \
 836                                                                             \
 837   /* tracing */                                                             \
 838                                                                             \
 839   develop(bool, StressRewriter, false,                                      \
 840           &quot;Stress linktime bytecode rewriting&quot;)                             \
 841                                                                             \
 842   product(ccstr, TraceJVMTI, NULL,                                          \
 843           &quot;Trace flags for JVMTI functions and events&quot;)                     \
 844                                                                             \
 845   /* This option can change an EMCP method into an obsolete method. */      \
 846   /* This can affect tests that except specific methods to be EMCP. */      \
 847   /* This option should be used with caution.                       */      \
 848   product(bool, StressLdcRewrite, false,                                    \
 849           &quot;Force ldc -&gt; ldc_w rewrite during RedefineClasses&quot;)              \
 850                                                                             \
 851   /* change to false by default sometime after Mustang */                   \
 852   product(bool, VerifyMergedCPBytecodes, true,                              \
 853           &quot;Verify bytecodes after RedefineClasses constant pool merging&quot;)   \
 854                                                                             \
 855   product(bool, AllowRedefinitionToAddDeleteMethods, false,                 \
 856           &quot;(Deprecated) Allow redefinition to add and delete private &quot;      \
 857           &quot;static or final methods for compatibility with old releases&quot;)    \
 858                                                                             \
 859   develop(bool, TraceBytecodes, false,                                      \
 860           &quot;Trace bytecode execution&quot;)                                       \
 861                                                                             \
 862   develop(bool, TraceICs, false,                                            \
 863           &quot;Trace inline cache changes&quot;)                                     \
 864                                                                             \
 865   notproduct(bool, TraceInvocationCounterOverflow, false,                   \
 866           &quot;Trace method invocation counter overflow&quot;)                       \
 867                                                                             \
 868   develop(bool, TraceInlineCacheClearing, false,                            \
 869           &quot;Trace clearing of inline caches in nmethods&quot;)                    \
 870                                                                             \
 871   develop(bool, TraceDependencies, false,                                   \
 872           &quot;Trace dependencies&quot;)                                             \
 873                                                                             \
 874   develop(bool, VerifyDependencies, trueInDebug,                            \
 875           &quot;Exercise and verify the compilation dependency mechanism&quot;)       \
 876                                                                             \
 877   develop(bool, TraceNewOopMapGeneration, false,                            \
 878           &quot;Trace OopMapGeneration&quot;)                                         \
 879                                                                             \
 880   develop(bool, TraceNewOopMapGenerationDetailed, false,                    \
 881           &quot;Trace OopMapGeneration: print detailed cell states&quot;)             \
 882                                                                             \
 883   develop(bool, TimeOopMap, false,                                          \
 884           &quot;Time calls to GenerateOopMap::compute_map() in sum&quot;)             \
 885                                                                             \
 886   develop(bool, TimeOopMap2, false,                                         \
 887           &quot;Time calls to GenerateOopMap::compute_map() individually&quot;)       \
 888                                                                             \
 889   develop(bool, TraceOopMapRewrites, false,                                 \
 890           &quot;Trace rewriting of method oops during oop map generation&quot;)       \
 891                                                                             \
 892   develop(bool, TraceICBuffer, false,                                       \
 893           &quot;Trace usage of IC buffer&quot;)                                       \
 894                                                                             \
 895   develop(bool, TraceCompiledIC, false,                                     \
 896           &quot;Trace changes of compiled IC&quot;)                                   \
 897                                                                             \
 898   develop(bool, FLSVerifyDictionary, false,                                 \
 899           &quot;Do lots of (expensive) FLS dictionary verification&quot;)             \
 900                                                                             \
 901                                                                             \
 902   notproduct(bool, CheckMemoryInitialization, false,                        \
 903           &quot;Check memory initialization&quot;)                                    \
 904                                                                             \
 905   product(uintx, ProcessDistributionStride, 4,                              \
 906           &quot;Stride through processors when distributing processes&quot;)          \
 907           range(0, max_juint)                                               \
 908                                                                             \
 909   develop(bool, TraceFinalizerRegistration, false,                          \
 910           &quot;Trace registration of final references&quot;)                         \
 911                                                                             \
 912   product(bool, IgnoreEmptyClassPaths, false,                               \
 913           &quot;Ignore empty path elements in -classpath&quot;)                       \
 914                                                                             \
 915   product(size_t, InitialBootClassLoaderMetaspaceSize,                      \
 916           NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \
 917           &quot;Initial size of the boot class loader data metaspace&quot;)           \
 918           range(30*K, max_uintx/BytesPerWord)                               \
 919           constraint(InitialBootClassLoaderMetaspaceSizeConstraintFunc, AfterErgo)\
 920                                                                             \
 921   product(bool, PrintHeapAtSIGBREAK, true,                                  \
 922           &quot;Print heap layout in response to SIGBREAK&quot;)                      \
 923                                                                             \
 924   manageable(bool, PrintClassHistogram, false,                              \
 925           &quot;Print a histogram of class instances&quot;)                           \
 926                                                                             \
 927   experimental(double, ObjectCountCutOffPercent, 0.5,                       \
 928           &quot;The percentage of the used heap that the instances of a class &quot;  \
 929           &quot;must occupy for the class to generate a trace event&quot;)            \
 930           range(0.0, 100.0)                                                 \
 931                                                                             \
 932   /* JVMTI heap profiling */                                                \
 933                                                                             \
 934   diagnostic(bool, TraceJVMTIObjectTagging, false,                          \
 935           &quot;Trace JVMTI object tagging calls&quot;)                               \
 936                                                                             \
 937   diagnostic(bool, VerifyBeforeIteration, false,                            \
 938           &quot;Verify memory system before JVMTI iteration&quot;)                    \
 939                                                                             \
 940   /* compiler interface */                                                  \
 941                                                                             \
 942   develop(bool, CIPrintCompilerName, false,                                 \
 943           &quot;when CIPrint is active, print the name of the active compiler&quot;)  \
 944                                                                             \
 945   diagnostic(bool, CIPrintCompileQueue, false,                              \
 946           &quot;display the contents of the compile queue whenever a &quot;           \
 947           &quot;compilation is enqueued&quot;)                                        \
 948                                                                             \
 949   develop(bool, CIPrintRequests, false,                                     \
 950           &quot;display every request for compilation&quot;)                          \
 951                                                                             \
 952   product(bool, CITime, false,                                              \
 953           &quot;collect timing information for compilation&quot;)                     \
 954                                                                             \
 955   develop(bool, CITimeVerbose, false,                                       \
 956           &quot;be more verbose in compilation timings&quot;)                         \
 957                                                                             \
 958   develop(bool, CITimeEach, false,                                          \
 959           &quot;display timing information after each successful compilation&quot;)   \
 960                                                                             \
 961   develop(bool, CICountOSR, false,                                          \
 962           &quot;use a separate counter when assigning ids to osr compilations&quot;)  \
 963                                                                             \
 964   develop(bool, CICompileNatives, true,                                     \
 965           &quot;compile native methods if supported by the compiler&quot;)            \
 966                                                                             \
 967   develop_pd(bool, CICompileOSR,                                            \
 968           &quot;compile on stack replacement methods if supported by the &quot;       \
 969           &quot;compiler&quot;)                                                       \
 970                                                                             \
 971   develop(bool, CIPrintMethodCodes, false,                                  \
 972           &quot;print method bytecodes of the compiled code&quot;)                    \
 973                                                                             \
 974   develop(bool, CIPrintTypeFlow, false,                                     \
 975           &quot;print the results of ciTypeFlow analysis&quot;)                       \
 976                                                                             \
 977   develop(bool, CITraceTypeFlow, false,                                     \
 978           &quot;detailed per-bytecode tracing of ciTypeFlow analysis&quot;)           \
 979                                                                             \
 980   develop(intx, OSROnlyBCI, -1,                                             \
 981           &quot;OSR only at this bci.  Negative values mean exclude that bci&quot;)   \
 982                                                                             \
 983   /* compiler */                                                            \
 984                                                                             \
 985   /* notice: the max range value here is max_jint, not max_intx  */         \
 986   /* because of overflow issue                                   */         \
 987   product(intx, CICompilerCount, CI_COMPILER_COUNT,                         \
 988           &quot;Number of compiler threads to run&quot;)                              \
 989           range(0, max_jint)                                                \
 990           constraint(CICompilerCountConstraintFunc, AfterErgo)              \
 991                                                                             \
 992   product(bool, UseDynamicNumberOfCompilerThreads, true,                    \
 993           &quot;Dynamically choose the number of parallel compiler threads&quot;)     \
 994                                                                             \
 995   diagnostic(bool, ReduceNumberOfCompilerThreads, true,                     \
 996              &quot;Reduce the number of parallel compiler threads when they &quot;    \
 997              &quot;are not used&quot;)                                                \
 998                                                                             \
 999   diagnostic(bool, TraceCompilerThreads, false,                             \
1000              &quot;Trace creation and removal of compiler threads&quot;)              \
1001                                                                             \
1002   develop(bool, InjectCompilerCreationFailure, false,                       \
1003           &quot;Inject thread creation failures for &quot;                            \
1004           &quot;UseDynamicNumberOfCompilerThreads&quot;)                              \
1005                                                                             \
1006   develop(bool, UseStackBanging, true,                                      \
1007           &quot;use stack banging for stack overflow checks (required for &quot;      \
1008           &quot;proper StackOverflow handling; disable only to measure cost &quot;    \
1009           &quot;of stackbanging)&quot;)                                               \
1010                                                                             \
1011   develop(bool, GenerateSynchronizationCode, true,                          \
1012           &quot;generate locking/unlocking code for synchronized methods and &quot;   \
1013           &quot;monitors&quot;)                                                       \
1014                                                                             \
1015   develop(bool, GenerateRangeChecks, true,                                  \
1016           &quot;Generate range checks for array accesses&quot;)                       \
1017                                                                             \
1018   diagnostic_pd(bool, ImplicitNullChecks,                                   \
1019           &quot;Generate code for implicit null checks&quot;)                         \
1020                                                                             \
1021   product_pd(bool, TrapBasedNullChecks,                                     \
1022           &quot;Generate code for null checks that uses a cmp and trap &quot;         \
1023           &quot;instruction raising SIGTRAP.  This is only used if an access to&quot; \
1024           &quot;null (+offset) will not raise a SIGSEGV, i.e.,&quot;                  \
1025           &quot;ImplicitNullChecks don&#39;t work (PPC64).&quot;)                         \
1026                                                                             \
1027   diagnostic(bool, EnableThreadSMRExtraValidityChecks, true,                \
1028              &quot;Enable Thread SMR extra validity checks&quot;)                     \
1029                                                                             \
1030   diagnostic(bool, EnableThreadSMRStatistics, trueInDebug,                  \
1031              &quot;Enable Thread SMR Statistics&quot;)                                \
1032                                                                             \
1033   product(bool, UseNotificationThread, true,                                \
1034           &quot;Use Notification Thread&quot;)                                        \
1035                                                                             \
1036   product(bool, Inline, true,                                               \
1037           &quot;Enable inlining&quot;)                                                \
1038                                                                             \
1039   product(bool, ClipInlining, true,                                         \
1040           &quot;Clip inlining if aggregate method exceeds DesiredMethodLimit&quot;)   \
1041                                                                             \
1042   develop(bool, UseCHA, true,                                               \
1043           &quot;Enable CHA&quot;)                                                     \
1044                                                                             \
1045   product(bool, UseTypeProfile, true,                                       \
1046           &quot;Check interpreter profile for historically monomorphic calls&quot;)   \
1047                                                                             \
1048   diagnostic(bool, PrintInlining, false,                                    \
1049           &quot;Print inlining optimizations&quot;)                                   \
1050                                                                             \
1051   product(bool, UsePopCountInstruction, false,                              \
1052           &quot;Use population count instruction&quot;)                               \
1053                                                                             \
1054   develop(bool, EagerInitialization, false,                                 \
1055           &quot;Eagerly initialize classes if possible&quot;)                         \
1056                                                                             \
1057   diagnostic(bool, LogTouchedMethods, false,                                \
1058           &quot;Log methods which have been ever touched in runtime&quot;)            \
1059                                                                             \
1060   diagnostic(bool, PrintTouchedMethodsAtExit, false,                        \
1061           &quot;Print all methods that have been ever touched in runtime&quot;)       \
1062                                                                             \
1063   develop(bool, TraceMethodReplacement, false,                              \
1064           &quot;Print when methods are replaced do to recompilation&quot;)            \
1065                                                                             \
1066   develop(bool, PrintMethodFlushing, false,                                 \
1067           &quot;Print the nmethods being flushed&quot;)                               \
1068                                                                             \
1069   diagnostic(bool, PrintMethodFlushingStatistics, false,                    \
1070           &quot;print statistics about method flushing&quot;)                         \
1071                                                                             \
1072   diagnostic(intx, HotMethodDetectionLimit, 100000,                         \
1073           &quot;Number of compiled code invocations after which &quot;                \
1074           &quot;the method is considered as hot by the flusher&quot;)                 \
1075           range(1, max_jint)                                                \
1076                                                                             \
1077   diagnostic(intx, MinPassesBeforeFlush, 10,                                \
1078           &quot;Minimum number of sweeper passes before an nmethod &quot;             \
1079           &quot;can be flushed&quot;)                                                 \
1080           range(0, max_intx)                                                \
1081                                                                             \
1082   product(bool, UseCodeAging, true,                                         \
1083           &quot;Insert counter to detect warm methods&quot;)                          \
1084                                                                             \
1085   diagnostic(bool, StressCodeAging, false,                                  \
1086           &quot;Start with counters compiled in&quot;)                                \
1087                                                                             \
1088   develop(bool, StressCodeBuffers, false,                                   \
1089           &quot;Exercise code buffer expansion and other rare state changes&quot;)    \
1090                                                                             \
1091   diagnostic(bool, DebugNonSafepoints, trueInDebug,                         \
1092           &quot;Generate extra debugging information for non-safepoints in &quot;     \
1093           &quot;nmethods&quot;)                                                       \
1094                                                                             \
1095   product(bool, PrintVMOptions, false,                                      \
1096           &quot;Print flags that appeared on the command line&quot;)                  \
1097                                                                             \
1098   product(bool, IgnoreUnrecognizedVMOptions, false,                         \
1099           &quot;Ignore unrecognized VM options&quot;)                                 \
1100                                                                             \
1101   product(bool, PrintCommandLineFlags, false,                               \
1102           &quot;Print flags specified on command line or set by ergonomics&quot;)     \
1103                                                                             \
1104   product(bool, PrintFlagsInitial, false,                                   \
1105           &quot;Print all VM flags before argument processing and exit VM&quot;)      \
1106                                                                             \
1107   product(bool, PrintFlagsFinal, false,                                     \
1108           &quot;Print all VM flags after argument and ergonomic processing&quot;)     \
1109                                                                             \
1110   notproduct(bool, PrintFlagsWithComments, false,                           \
1111           &quot;Print all VM flags with default values and descriptions and &quot;    \
1112           &quot;exit&quot;)                                                           \
1113                                                                             \
1114   product(bool, PrintFlagsRanges, false,                                    \
1115           &quot;Print VM flags and their ranges&quot;)                                \
1116                                                                             \
1117   diagnostic(bool, SerializeVMOutput, true,                                 \
1118           &quot;Use a mutex to serialize output to tty and LogFile&quot;)             \
1119                                                                             \
1120   diagnostic(bool, DisplayVMOutput, true,                                   \
1121           &quot;Display all VM output on the tty, independently of LogVMOutput&quot;) \
1122                                                                             \
1123   diagnostic(bool, LogVMOutput, false,                                      \
1124           &quot;Save VM output to LogFile&quot;)                                      \
1125                                                                             \
1126   diagnostic(ccstr, LogFile, NULL,                                          \
1127           &quot;If LogVMOutput or LogCompilation is on, save VM output to &quot;      \
1128           &quot;this file [default: ./hotspot_pid%p.log] (%p replaced with pid)&quot;)\
1129                                                                             \
1130   product(ccstr, ErrorFile, NULL,                                           \
1131           &quot;If an error occurs, save the error data to this file &quot;           \
1132           &quot;[default: ./hs_err_pid%p.log] (%p replaced with pid)&quot;)           \
1133                                                                             \
1134   product(bool, ExtensiveErrorReports,                                      \
1135           PRODUCT_ONLY(false) NOT_PRODUCT(true),                            \
1136           &quot;Error reports are more extensive.&quot;)                              \
1137                                                                             \
1138   product(bool, DisplayVMOutputToStderr, false,                             \
1139           &quot;If DisplayVMOutput is true, display all VM output to stderr&quot;)    \
1140                                                                             \
1141   product(bool, DisplayVMOutputToStdout, false,                             \
1142           &quot;If DisplayVMOutput is true, display all VM output to stdout&quot;)    \
1143                                                                             \
1144   product(bool, ErrorFileToStderr, false,                                   \
1145           &quot;If true, error data is printed to stderr instead of a file&quot;)     \
1146                                                                             \
1147   product(bool, ErrorFileToStdout, false,                                   \
1148           &quot;If true, error data is printed to stdout instead of a file&quot;)     \
1149                                                                             \
1150   product(bool, UseHeavyMonitors, false,                                    \
1151           &quot;use heavyweight instead of lightweight Java monitors&quot;)           \
1152                                                                             \
1153   product(bool, PrintStringTableStatistics, false,                          \
1154           &quot;print statistics about the StringTable and SymbolTable&quot;)         \
1155                                                                             \
1156   diagnostic(bool, VerifyStringTableAtExit, false,                          \
1157           &quot;verify StringTable contents at exit&quot;)                            \
1158                                                                             \
1159   notproduct(bool, PrintSymbolTableSizeHistogram, false,                    \
1160           &quot;print histogram of the symbol table&quot;)                            \
1161                                                                             \
1162   notproduct(bool, ExitVMOnVerifyError, false,                              \
1163           &quot;standard exit from VM if bytecode verify error &quot;                 \
1164           &quot;(only in debug mode)&quot;)                                           \
1165                                                                             \
1166   diagnostic(ccstr, AbortVMOnException, NULL,                               \
1167           &quot;Call fatal if this exception is thrown.  Example: &quot;              \
1168           &quot;java -XX:AbortVMOnException=java.lang.NullPointerException Foo&quot;) \
1169                                                                             \
1170   diagnostic(ccstr, AbortVMOnExceptionMessage, NULL,                        \
1171           &quot;Call fatal if the exception pointed by AbortVMOnException &quot;      \
1172           &quot;has this message&quot;)                                               \
1173                                                                             \
1174   develop(bool, DebugVtables, false,                                        \
1175           &quot;add debugging code to vtable dispatch&quot;)                          \
1176                                                                             \
1177   notproduct(bool, PrintVtableStats, false,                                 \
1178           &quot;print vtables stats at end of run&quot;)                              \
1179                                                                             \
1180   develop(bool, TraceCreateZombies, false,                                  \
1181           &quot;trace creation of zombie nmethods&quot;)                              \
1182                                                                             \
1183   product(bool, RangeCheckElimination, true,                                \
1184           &quot;Eliminate range checks&quot;)                                         \
1185                                                                             \
1186   develop_pd(bool, UncommonNullCast,                                        \
1187           &quot;track occurrences of null in casts; adjust compiler tactics&quot;)    \
1188                                                                             \
1189   develop(bool, TypeProfileCasts,  true,                                    \
1190           &quot;treat casts like calls for purposes of type profiling&quot;)          \
1191                                                                             \
1192   develop(bool, TraceLivenessGen, false,                                    \
1193           &quot;Trace the generation of liveness analysis information&quot;)          \
1194                                                                             \
1195   notproduct(bool, TraceLivenessQuery, false,                               \
1196           &quot;Trace queries of liveness analysis information&quot;)                 \
1197                                                                             \
1198   notproduct(bool, CollectIndexSetStatistics, false,                        \
1199           &quot;Collect information about IndexSets&quot;)                            \
1200                                                                             \
1201   develop(bool, UseLoopSafepoints, true,                                    \
1202           &quot;Generate Safepoint nodes in every loop&quot;)                         \
1203                                                                             \
1204   develop(intx, FastAllocateSizeLimit, 128*K,                               \
1205           /* Note:  This value is zero mod 1&lt;&lt;13 for a cheap sparc set. */  \
1206           &quot;Inline allocations larger than this in doublewords must go slow&quot;)\
1207                                                                             \
1208   product_pd(bool, CompactStrings,                                          \
1209           &quot;Enable Strings to use single byte chars in backing store&quot;)       \
1210                                                                             \
1211   product_pd(uintx, TypeProfileLevel,                                       \
1212           &quot;=XYZ, with Z: Type profiling of arguments at call; &quot;             \
1213                      &quot;Y: Type profiling of return value at call; &quot;          \
1214                      &quot;X: Type profiling of parameters to methods; &quot;         \
1215           &quot;X, Y and Z in 0=off ; 1=jsr292 only; 2=all methods&quot;)             \
1216           constraint(TypeProfileLevelConstraintFunc, AfterErgo)             \
1217                                                                             \
1218   product(intx, TypeProfileArgsLimit,     2,                                \
1219           &quot;max number of call arguments to consider for type profiling&quot;)    \
1220           range(0, 16)                                                      \
1221                                                                             \
1222   product(intx, TypeProfileParmsLimit,    2,                                \
1223           &quot;max number of incoming parameters to consider for type profiling&quot;\
1224           &quot;, -1 for all&quot;)                                                   \
1225           range(-1, 64)                                                     \
1226                                                                             \
1227   /* statistics */                                                          \
1228   develop(bool, CountCompiledCalls, false,                                  \
1229           &quot;Count method invocations&quot;)                                       \
1230                                                                             \
1231   notproduct(bool, CountRuntimeCalls, false,                                \
1232           &quot;Count VM runtime calls&quot;)                                         \
1233                                                                             \
1234   develop(bool, CountJNICalls, false,                                       \
1235           &quot;Count jni method invocations&quot;)                                   \
1236                                                                             \
1237   notproduct(bool, CountJVMCalls, false,                                    \
1238           &quot;Count jvm method invocations&quot;)                                   \
1239                                                                             \
1240   notproduct(bool, CountRemovableExceptions, false,                         \
1241           &quot;Count exceptions that could be replaced by branches due to &quot;     \
1242           &quot;inlining&quot;)                                                       \
1243                                                                             \
1244   notproduct(bool, ICMissHistogram, false,                                  \
1245           &quot;Produce histogram of IC misses&quot;)                                 \
1246                                                                             \
1247   /* interpreter */                                                         \
1248   product_pd(bool, RewriteBytecodes,                                        \
1249           &quot;Allow rewriting of bytecodes (bytecodes are not immutable)&quot;)     \
1250                                                                             \
1251   product_pd(bool, RewriteFrequentPairs,                                    \
1252           &quot;Rewrite frequently used bytecode pairs into a single bytecode&quot;)  \
1253                                                                             \
1254   diagnostic(bool, PrintInterpreter, false,                                 \
1255           &quot;Print the generated interpreter code&quot;)                           \
1256                                                                             \
1257   product(bool, UseInterpreter, true,                                       \
1258           &quot;Use interpreter for non-compiled methods&quot;)                       \
1259                                                                             \
1260   develop(bool, UseFastSignatureHandlers, true,                             \
1261           &quot;Use fast signature handlers for native calls&quot;)                   \
1262                                                                             \
1263   product(bool, UseLoopCounter, true,                                       \
1264           &quot;Increment invocation counter on backward branch&quot;)                \
1265                                                                             \
1266   product_pd(bool, UseOnStackReplacement,                                   \
1267           &quot;Use on stack replacement, calls runtime if invoc. counter &quot;      \
1268           &quot;overflows in loop&quot;)                                              \
1269                                                                             \
1270   notproduct(bool, TraceOnStackReplacement, false,                          \
1271           &quot;Trace on stack replacement&quot;)                                     \
1272                                                                             \
1273   product_pd(bool, PreferInterpreterNativeStubs,                            \
1274           &quot;Use always interpreter stubs for native methods invoked via &quot;    \
1275           &quot;interpreter&quot;)                                                    \
1276                                                                             \
1277   develop(bool, CountBytecodes, false,                                      \
1278           &quot;Count number of bytecodes executed&quot;)                             \
1279                                                                             \
1280   develop(bool, PrintBytecodeHistogram, false,                              \
1281           &quot;Print histogram of the executed bytecodes&quot;)                      \
1282                                                                             \
1283   develop(bool, PrintBytecodePairHistogram, false,                          \
1284           &quot;Print histogram of the executed bytecode pairs&quot;)                 \
1285                                                                             \
1286   diagnostic(bool, PrintSignatureHandlers, false,                           \
1287           &quot;Print code generated for native method signature handlers&quot;)      \
1288                                                                             \
1289   develop(bool, VerifyOops, false,                                          \
1290           &quot;Do plausibility checks for oops&quot;)                                \
1291                                                                             \
1292   develop(bool, CheckUnhandledOops, false,                                  \
1293           &quot;Check for unhandled oops in VM code&quot;)                            \
1294                                                                             \
1295   develop(bool, VerifyJNIFields, trueInDebug,                               \
1296           &quot;Verify jfieldIDs for instance fields&quot;)                           \
1297                                                                             \
1298   notproduct(bool, VerifyJNIEnvThread, false,                               \
1299           &quot;Verify JNIEnv.thread == Thread::current() when entering VM &quot;     \
1300           &quot;from JNI&quot;)                                                       \
1301                                                                             \
1302   develop(bool, VerifyFPU, false,                                           \
1303           &quot;Verify FPU state (check for NaN&#39;s, etc.)&quot;)                       \
1304                                                                             \
1305   develop(bool, VerifyThread, false,                                        \
1306           &quot;Watch the thread register for corruption (SPARC only)&quot;)          \
1307                                                                             \
1308   develop(bool, VerifyActivationFrameSize, false,                           \
1309           &quot;Verify that activation frame didn&#39;t become smaller than its &quot;    \
1310           &quot;minimal size&quot;)                                                   \
1311                                                                             \
1312   develop(bool, TraceFrequencyInlining, false,                              \
1313           &quot;Trace frequency based inlining&quot;)                                 \
1314                                                                             \
1315   develop_pd(bool, InlineIntrinsics,                                        \
1316           &quot;Inline intrinsics that can be statically resolved&quot;)              \
1317                                                                             \
1318   product_pd(bool, ProfileInterpreter,                                      \
1319           &quot;Profile at the bytecode level during interpretation&quot;)            \
1320                                                                             \
1321   develop(bool, TraceProfileInterpreter, false,                             \
1322           &quot;Trace profiling at the bytecode level during interpretation. &quot;   \
1323           &quot;This outputs the profiling information collected to improve &quot;    \
1324           &quot;jit compilation.&quot;)                                               \
1325                                                                             \
1326   develop_pd(bool, ProfileTraps,                                            \
1327           &quot;Profile deoptimization traps at the bytecode level&quot;)             \
1328                                                                             \
1329   product(intx, ProfileMaturityPercentage, 20,                              \
1330           &quot;number of method invocations/branches (expressed as % of &quot;       \
1331           &quot;CompileThreshold) before using the method&#39;s profile&quot;)            \
1332           range(0, 100)                                                     \
1333                                                                             \
1334   diagnostic(bool, PrintMethodData, false,                                  \
1335           &quot;Print the results of +ProfileInterpreter at end of run&quot;)         \
1336                                                                             \
1337   develop(bool, VerifyDataPointer, trueInDebug,                             \
1338           &quot;Verify the method data pointer during interpreter profiling&quot;)    \
1339                                                                             \
1340   develop(bool, VerifyCompiledCode, false,                                  \
1341           &quot;Include miscellaneous runtime verifications in nmethod code; &quot;   \
1342           &quot;default off because it disturbs nmethod size heuristics&quot;)        \
1343                                                                             \
1344   notproduct(bool, CrashGCForDumpingJavaThread, false,                      \
1345           &quot;Manually make GC thread crash then dump java stack trace;  &quot;     \
1346           &quot;Test only&quot;)                                                      \
1347                                                                             \
1348   /* compilation */                                                         \
1349   product(bool, UseCompiler, true,                                          \
1350           &quot;Use Just-In-Time compilation&quot;)                                   \
1351                                                                             \
1352   product(bool, UseCounterDecay, true,                                      \
1353           &quot;Adjust recompilation counters&quot;)                                  \
1354                                                                             \
1355   develop(intx, CounterHalfLifeTime,    30,                                 \
1356           &quot;Half-life time of invocation counters (in seconds)&quot;)             \
1357                                                                             \
1358   develop(intx, CounterDecayMinIntervalLength,   500,                       \
1359           &quot;The minimum interval (in milliseconds) between invocation of &quot;   \
1360           &quot;CounterDecay&quot;)                                                   \
1361                                                                             \
1362   product(bool, AlwaysCompileLoopMethods, false,                            \
1363           &quot;When using recompilation, never interpret methods &quot;              \
1364           &quot;containing loops&quot;)                                               \
1365                                                                             \
1366   product(bool, DontCompileHugeMethods, true,                               \
1367           &quot;Do not compile methods &gt; HugeMethodLimit&quot;)                       \
1368                                                                             \
1369   /* Bytecode escape analysis estimation. */                                \
1370   product(bool, EstimateArgEscape, true,                                    \
1371           &quot;Analyze bytecodes to estimate escape state of arguments&quot;)        \
1372                                                                             \
1373   product(intx, BCEATraceLevel, 0,                                          \
1374           &quot;How much tracing to do of bytecode escape analysis estimates &quot;   \
1375           &quot;(0-3)&quot;)                                                          \
1376           range(0, 3)                                                       \
1377                                                                             \
1378   product(intx, MaxBCEAEstimateLevel, 5,                                    \
1379           &quot;Maximum number of nested calls that are analyzed by BC EA&quot;)      \
1380           range(0, max_jint)                                                \
1381                                                                             \
1382   product(intx, MaxBCEAEstimateSize, 150,                                   \
1383           &quot;Maximum bytecode size of a method to be analyzed by BC EA&quot;)      \
1384           range(0, max_jint)                                                \
1385                                                                             \
1386   product(intx,  AllocatePrefetchStyle, 1,                                  \
1387           &quot;0 = no prefetch, &quot;                                               \
1388           &quot;1 = generate prefetch instructions for each allocation, &quot;        \
1389           &quot;2 = use TLAB watermark to gate allocation prefetch, &quot;            \
1390           &quot;3 = generate one prefetch instruction per cache line&quot;)           \
1391           range(0, 3)                                                       \
1392                                                                             \
1393   product(intx,  AllocatePrefetchDistance, -1,                              \
1394           &quot;Distance to prefetch ahead of allocation pointer. &quot;              \
1395           &quot;-1: use system-specific value (automatically determined&quot;)        \
1396           constraint(AllocatePrefetchDistanceConstraintFunc,AfterMemoryInit)\
1397                                                                             \
1398   product(intx,  AllocatePrefetchLines, 3,                                  \
1399           &quot;Number of lines to prefetch ahead of array allocation pointer&quot;)  \
1400           range(1, 64)                                                      \
1401                                                                             \
1402   product(intx,  AllocateInstancePrefetchLines, 1,                          \
1403           &quot;Number of lines to prefetch ahead of instance allocation &quot;       \
1404           &quot;pointer&quot;)                                                        \
1405           range(1, 64)                                                      \
1406                                                                             \
1407   product(intx,  AllocatePrefetchStepSize, 16,                              \
1408           &quot;Step size in bytes of sequential prefetch instructions&quot;)         \
1409           range(1, 512)                                                     \
1410           constraint(AllocatePrefetchStepSizeConstraintFunc,AfterMemoryInit)\
1411                                                                             \
1412   product(intx,  AllocatePrefetchInstr, 0,                                  \
1413           &quot;Select instruction to prefetch ahead of allocation pointer&quot;)     \
1414           constraint(AllocatePrefetchInstrConstraintFunc, AfterMemoryInit)  \
1415                                                                             \
1416   /* deoptimization */                                                      \
1417   develop(bool, TraceDeoptimization, false,                                 \
1418           &quot;Trace deoptimization&quot;)                                           \
1419                                                                             \
1420   develop(bool, PrintDeoptimizationDetails, false,                          \
1421           &quot;Print more information about deoptimization&quot;)                    \
1422                                                                             \
1423   develop(bool, DebugDeoptimization, false,                                 \
1424           &quot;Tracing various information while debugging deoptimization&quot;)     \
1425                                                                             \
1426   product(intx, SelfDestructTimer, 0,                                       \
1427           &quot;Will cause VM to terminate after a given time (in minutes) &quot;     \
1428           &quot;(0 means off)&quot;)                                                  \
1429           range(0, max_intx)                                                \
1430                                                                             \
1431   product(intx, MaxJavaStackTraceDepth, 1024,                               \
1432           &quot;The maximum number of lines in the stack trace for Java &quot;        \
1433           &quot;exceptions (0 means all)&quot;)                                       \
1434           range(0, max_jint/2)                                              \
1435                                                                             \
1436   /* notice: the max range value here is max_jint, not max_intx  */         \
1437   /* because of overflow issue                                   */         \
1438   diagnostic(intx, GuaranteedSafepointInterval, 1000,                       \
1439           &quot;Guarantee a safepoint (at least) every so many milliseconds &quot;    \
1440           &quot;(0 means none)&quot;)                                                 \
1441           range(0, max_jint)                                                \
1442                                                                             \
1443   product(intx, SafepointTimeoutDelay, 10000,                               \
1444           &quot;Delay in milliseconds for option SafepointTimeout&quot;)              \
1445   LP64_ONLY(range(0, max_intx/MICROUNITS))                                  \
1446   NOT_LP64(range(0, max_intx))                                              \
1447                                                                             \
1448   product(intx, NmethodSweepActivity, 10,                                   \
1449           &quot;Removes cold nmethods from code cache if &gt; 0. Higher values &quot;    \
1450           &quot;result in more aggressive sweeping&quot;)                             \
1451           range(0, 2000)                                                    \
1452                                                                             \
1453   notproduct(bool, LogSweeper, false,                                       \
1454           &quot;Keep a ring buffer of sweeper activity&quot;)                         \
1455                                                                             \
1456   notproduct(intx, SweeperLogEntries, 1024,                                 \
1457           &quot;Number of records in the ring buffer of sweeper activity&quot;)       \
1458                                                                             \
1459   notproduct(intx, MemProfilingInterval, 500,                               \
1460           &quot;Time between each invocation of the MemProfiler&quot;)                \
1461                                                                             \
1462   develop(intx, MallocCatchPtr, -1,                                         \
1463           &quot;Hit breakpoint when mallocing/freeing this pointer&quot;)             \
1464                                                                             \
1465   notproduct(ccstrlist, SuppressErrorAt, &quot;&quot;,                                \
1466           &quot;List of assertions (file:line) to muzzle&quot;)                       \
1467                                                                             \
1468   develop(intx, StackPrintLimit, 100,                                       \
1469           &quot;number of stack frames to print in VM-level stack dump&quot;)         \
1470                                                                             \
1471   notproduct(intx, MaxElementPrintSize, 256,                                \
1472           &quot;maximum number of elements to print&quot;)                            \
1473                                                                             \
1474   notproduct(intx, MaxSubklassPrintSize, 4,                                 \
1475           &quot;maximum number of subklasses to print when printing klass&quot;)      \
1476                                                                             \
1477   product(intx, MaxInlineLevel, 15,                                         \
1478           &quot;maximum number of nested calls that are inlined&quot;)                \
1479           range(0, max_jint)                                                \
1480                                                                             \
1481   product(intx, MaxRecursiveInlineLevel, 1,                                 \
1482           &quot;maximum number of nested recursive calls that are inlined&quot;)      \
1483           range(0, max_jint)                                                \
1484                                                                             \
1485   develop(intx, MaxForceInlineLevel, 100,                                   \
1486           &quot;maximum number of nested calls that are forced for inlining &quot;    \
1487           &quot;(using CompileCommand or marked w/ @ForceInline)&quot;)               \
1488           range(0, max_jint)                                                \
1489                                                                             \
1490   product_pd(intx, InlineSmallCode,                                         \
1491           &quot;Only inline already compiled methods if their code size is &quot;     \
1492           &quot;less than this&quot;)                                                 \
1493           range(0, max_jint)                                                \
1494                                                                             \
1495   product(intx, MaxInlineSize, 35,                                          \
1496           &quot;The maximum bytecode size of a method to be inlined&quot;)            \
1497           range(0, max_jint)                                                \
1498                                                                             \
1499   product_pd(intx, FreqInlineSize,                                          \
1500           &quot;The maximum bytecode size of a frequent method to be inlined&quot;)   \
1501           range(0, max_jint)                                                \
1502                                                                             \
1503   product(intx, MaxTrivialSize, 6,                                          \
1504           &quot;The maximum bytecode size of a trivial method to be inlined&quot;)    \
1505           range(0, max_jint)                                                \
1506                                                                             \
1507   product(intx, MinInliningThreshold, 250,                                  \
1508           &quot;The minimum invocation count a method needs to have to be &quot;      \
1509           &quot;inlined&quot;)                                                        \
1510           range(0, max_jint)                                                \
1511                                                                             \
1512   develop(intx, MethodHistogramCutoff, 100,                                 \
1513           &quot;The cutoff value for method invocation histogram (+CountCalls)&quot;) \
1514                                                                             \
1515   develop(intx, DontYieldALotInterval,    10,                               \
1516           &quot;Interval between which yields will be dropped (milliseconds)&quot;)   \
1517                                                                             \
1518   notproduct(intx, DeoptimizeALotInterval,     5,                           \
1519           &quot;Number of exits until DeoptimizeALot kicks in&quot;)                  \
1520                                                                             \
1521   notproduct(intx, ZombieALotInterval,     5,                               \
1522           &quot;Number of exits until ZombieALot kicks in&quot;)                      \
1523                                                                             \
1524   diagnostic(uintx, MallocMaxTestWords,     0,                              \
1525           &quot;If non-zero, maximum number of words that malloc/realloc can &quot;   \
1526           &quot;allocate (for testing only)&quot;)                                    \
1527           range(0, max_uintx)                                               \
1528                                                                             \
1529   product(intx, TypeProfileWidth, 2,                                        \
1530           &quot;Number of receiver types to record in call/cast profile&quot;)        \
1531           range(0, 8)                                                       \
1532                                                                             \
1533   develop(intx, BciProfileWidth,      2,                                    \
1534           &quot;Number of return bci&#39;s to record in ret profile&quot;)                \
1535                                                                             \
1536   product(intx, PerMethodRecompilationCutoff, 400,                          \
1537           &quot;After recompiling N times, stay in the interpreter (-1=&gt;&#39;Inf&#39;)&quot;) \
1538           range(-1, max_intx)                                               \
1539                                                                             \
1540   product(intx, PerBytecodeRecompilationCutoff, 200,                        \
1541           &quot;Per-BCI limit on repeated recompilation (-1=&gt;&#39;Inf&#39;)&quot;)            \
1542           range(-1, max_intx)                                               \
1543                                                                             \
1544   product(intx, PerMethodTrapLimit,  100,                                   \
1545           &quot;Limit on traps (of one kind) in a method (includes inlines)&quot;)    \
1546           range(0, max_jint)                                                \
1547                                                                             \
1548   experimental(intx, PerMethodSpecTrapLimit,  5000,                         \
1549           &quot;Limit on speculative traps (of one kind) in a method &quot;           \
1550           &quot;(includes inlines)&quot;)                                             \
1551           range(0, max_jint)                                                \
1552                                                                             \
1553   product(intx, PerBytecodeTrapLimit,  4,                                   \
1554           &quot;Limit on traps (of one kind) at a particular BCI&quot;)               \
1555           range(0, max_jint)                                                \
1556                                                                             \
1557   experimental(intx, SpecTrapLimitExtraEntries,  3,                         \
1558           &quot;Extra method data trap entries for speculation&quot;)                 \
1559                                                                             \
1560   develop(intx, InlineFrequencyRatio,    20,                                \
1561           &quot;Ratio of call site execution to caller method invocation&quot;)       \
1562           range(0, max_jint)                                                \
1563                                                                             \
1564   diagnostic_pd(intx, InlineFrequencyCount,                                 \
1565           &quot;Count of call site execution necessary to trigger frequent &quot;     \
1566           &quot;inlining&quot;)                                                       \
1567           range(0, max_jint)                                                \
1568                                                                             \
1569   develop(intx, InlineThrowCount,    50,                                    \
1570           &quot;Force inlining of interpreted methods that throw this often&quot;)    \
1571           range(0, max_jint)                                                \
1572                                                                             \
1573   develop(intx, InlineThrowMaxSize,   200,                                  \
1574           &quot;Force inlining of throwing methods smaller than this&quot;)           \
1575           range(0, max_jint)                                                \
1576                                                                             \
1577   develop(intx, ProfilerNodeSize,  1024,                                    \
1578           &quot;Size in K to allocate for the Profile Nodes of each thread&quot;)     \
1579           range(0, 1024)                                                    \
1580                                                                             \
1581   product_pd(size_t, MetaspaceSize,                                         \
1582           &quot;Initial threshold (in bytes) at which a garbage collection &quot;     \
1583           &quot;is done to reduce Metaspace usage&quot;)                              \
1584           constraint(MetaspaceSizeConstraintFunc,AfterErgo)                 \
1585                                                                             \
1586   product(size_t, MaxMetaspaceSize, max_uintx,                              \
1587           &quot;Maximum size of Metaspaces (in bytes)&quot;)                          \
1588           constraint(MaxMetaspaceSizeConstraintFunc,AfterErgo)              \
1589                                                                             \
1590   product(size_t, CompressedClassSpaceSize, 1*G,                            \
1591           &quot;Maximum size of class area in Metaspace when compressed &quot;        \
1592           &quot;class pointers are used&quot;)                                        \
1593           range(1*M, 3*G)                                                   \
1594                                                                             \
1595   manageable(uintx, MinHeapFreeRatio, 40,                                   \
1596           &quot;The minimum percentage of heap free after GC to avoid expansion.&quot;\
1597           &quot; For most GCs this applies to the old generation. In G1 and&quot;     \
1598           &quot; ParallelGC it applies to the whole heap.&quot;)                      \
1599           range(0, 100)                                                     \
1600           constraint(MinHeapFreeRatioConstraintFunc,AfterErgo)              \
1601                                                                             \
1602   manageable(uintx, MaxHeapFreeRatio, 70,                                   \
1603           &quot;The maximum percentage of heap free after GC to avoid shrinking.&quot;\
1604           &quot; For most GCs this applies to the old generation. In G1 and&quot;     \
1605           &quot; ParallelGC it applies to the whole heap.&quot;)                      \
1606           range(0, 100)                                                     \
1607           constraint(MaxHeapFreeRatioConstraintFunc,AfterErgo)              \
1608                                                                             \
1609   product(bool, ShrinkHeapInSteps, true,                                    \
1610           &quot;When disabled, informs the GC to shrink the java heap directly&quot;  \
1611           &quot; to the target size at the next full GC rather than requiring&quot;   \
1612           &quot; smaller steps during multiple full GCs.&quot;)                       \
1613                                                                             \
1614   product(intx, SoftRefLRUPolicyMSPerMB, 1000,                              \
1615           &quot;Number of milliseconds per MB of free space in the heap&quot;)        \
1616           range(0, max_intx)                                                \
1617           constraint(SoftRefLRUPolicyMSPerMBConstraintFunc,AfterMemoryInit) \
1618                                                                             \
1619   product(size_t, MinHeapDeltaBytes, ScaleForWordSize(128*K),               \
1620           &quot;The minimum change in heap space due to GC (in bytes)&quot;)          \
1621           range(0, max_uintx)                                               \
1622                                                                             \
1623   product(size_t, MinMetaspaceExpansion, ScaleForWordSize(256*K),           \
1624           &quot;The minimum expansion of Metaspace (in bytes)&quot;)                  \
1625           range(0, max_uintx)                                               \
1626                                                                             \
1627   product(uintx, MaxMetaspaceFreeRatio,    70,                              \
1628           &quot;The maximum percentage of Metaspace free after GC to avoid &quot;     \
1629           &quot;shrinking&quot;)                                                      \
1630           range(0, 100)                                                     \
1631           constraint(MaxMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
1632                                                                             \
1633   product(uintx, MinMetaspaceFreeRatio,    40,                              \
1634           &quot;The minimum percentage of Metaspace free after GC to avoid &quot;     \
1635           &quot;expansion&quot;)                                                      \
1636           range(0, 99)                                                      \
1637           constraint(MinMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
1638                                                                             \
1639   product(size_t, MaxMetaspaceExpansion, ScaleForWordSize(4*M),             \
1640           &quot;The maximum expansion of Metaspace without full GC (in bytes)&quot;)  \
1641           range(0, max_uintx)                                               \
1642                                                                             \
1643   /* stack parameters */                                                    \
1644   product_pd(intx, StackYellowPages,                                        \
1645           &quot;Number of yellow zone (recoverable overflows) pages of size &quot;    \
1646           &quot;4KB. If pages are bigger yellow zone is aligned up.&quot;)            \
1647           range(MIN_STACK_YELLOW_PAGES, (DEFAULT_STACK_YELLOW_PAGES+5))     \
1648                                                                             \
1649   product_pd(intx, StackRedPages,                                           \
1650           &quot;Number of red zone (unrecoverable overflows) pages of size &quot;     \
1651           &quot;4KB. If pages are bigger red zone is aligned up.&quot;)               \
1652           range(MIN_STACK_RED_PAGES, (DEFAULT_STACK_RED_PAGES+2))           \
1653                                                                             \
1654   product_pd(intx, StackReservedPages,                                      \
1655           &quot;Number of reserved zone (reserved to annotated methods) pages&quot;   \
1656           &quot; of size 4KB. If pages are bigger reserved zone is aligned up.&quot;) \
1657           range(MIN_STACK_RESERVED_PAGES, (DEFAULT_STACK_RESERVED_PAGES+10))\
1658                                                                             \
1659   product(bool, RestrictReservedStack, true,                                \
1660           &quot;Restrict @ReservedStackAccess to trusted classes&quot;)               \
1661                                                                             \
1662   /* greater stack shadow pages can&#39;t generate instruction to bang stack */ \
1663   product_pd(intx, StackShadowPages,                                        \
1664           &quot;Number of shadow zone (for overflow checking) pages of size &quot;    \
1665           &quot;4KB. If pages are bigger shadow zone is aligned up. &quot;            \
1666           &quot;This should exceed the depth of the VM and native call stack.&quot;)  \
1667           range(MIN_STACK_SHADOW_PAGES, (DEFAULT_STACK_SHADOW_PAGES+30))    \
1668                                                                             \
1669   product_pd(intx, ThreadStackSize,                                         \
1670           &quot;Thread Stack Size (in Kbytes)&quot;)                                  \
1671           range(0, 1 * M)                                                   \
1672                                                                             \
1673   product_pd(intx, VMThreadStackSize,                                       \
1674           &quot;Non-Java Thread Stack Size (in Kbytes)&quot;)                         \
1675           range(0, max_intx/(1 * K))                                        \
1676                                                                             \
1677   product_pd(intx, CompilerThreadStackSize,                                 \
1678           &quot;Compiler Thread Stack Size (in Kbytes)&quot;)                         \
1679           range(0, max_intx/(1 * K))                                        \
1680                                                                             \
1681   develop_pd(size_t, JVMInvokeMethodSlack,                                  \
1682           &quot;Stack space (bytes) required for JVM_InvokeMethod to complete&quot;)  \
1683                                                                             \
1684   /* code cache parameters                                    */            \
1685   develop_pd(uintx, CodeCacheSegmentSize,                                   \
1686           &quot;Code cache segment size (in bytes) - smallest unit of &quot;          \
1687           &quot;allocation&quot;)                                                     \
1688           range(1, 1024)                                                    \
1689           constraint(CodeCacheSegmentSizeConstraintFunc, AfterErgo)         \
1690                                                                             \
1691   develop_pd(intx, CodeEntryAlignment,                                      \
1692           &quot;Code entry alignment for generated code (in bytes)&quot;)             \
1693           constraint(CodeEntryAlignmentConstraintFunc, AfterErgo)           \
1694                                                                             \
1695   product_pd(intx, OptoLoopAlignment,                                       \
1696           &quot;Align inner loops to zero relative to this modulus&quot;)             \
1697           range(1, 16)                                                      \
1698           constraint(OptoLoopAlignmentConstraintFunc, AfterErgo)            \
1699                                                                             \
1700   product_pd(uintx, InitialCodeCacheSize,                                   \
1701           &quot;Initial code cache size (in bytes)&quot;)                             \
1702           range(os::vm_page_size(), max_uintx)                              \
1703                                                                             \
1704   develop_pd(uintx, CodeCacheMinimumUseSpace,                               \
1705           &quot;Minimum code cache size (in bytes) required to start VM.&quot;)       \
1706           range(0, max_uintx)                                               \
1707                                                                             \
1708   product(bool, SegmentedCodeCache, false,                                  \
1709           &quot;Use a segmented code cache&quot;)                                     \
1710                                                                             \
1711   product_pd(uintx, ReservedCodeCacheSize,                                  \
1712           &quot;Reserved code cache size (in bytes) - maximum code cache size&quot;)  \
1713           range(os::vm_page_size(), max_uintx)                              \
1714                                                                             \
1715   product_pd(uintx, NonProfiledCodeHeapSize,                                \
1716           &quot;Size of code heap with non-profiled methods (in bytes)&quot;)         \
1717           range(0, max_uintx)                                               \
1718                                                                             \
1719   product_pd(uintx, ProfiledCodeHeapSize,                                   \
1720           &quot;Size of code heap with profiled methods (in bytes)&quot;)             \
1721           range(0, max_uintx)                                               \
1722                                                                             \
1723   product_pd(uintx, NonNMethodCodeHeapSize,                                 \
1724           &quot;Size of code heap with non-nmethods (in bytes)&quot;)                 \
1725           range(os::vm_page_size(), max_uintx)                              \
1726                                                                             \
1727   product_pd(uintx, CodeCacheExpansionSize,                                 \
1728           &quot;Code cache expansion size (in bytes)&quot;)                           \
1729           range(32*K, max_uintx)                                            \
1730                                                                             \
1731   diagnostic_pd(uintx, CodeCacheMinBlockLength,                             \
1732           &quot;Minimum number of segments in a code cache block&quot;)               \
1733           range(1, 100)                                                     \
1734                                                                             \
1735   notproduct(bool, ExitOnFullCodeCache, false,                              \
1736           &quot;Exit the VM if we fill the code cache&quot;)                          \
1737                                                                             \
1738   product(bool, UseCodeCacheFlushing, true,                                 \
1739           &quot;Remove cold/old nmethods from the code cache&quot;)                   \
1740                                                                             \
1741   product(uintx, StartAggressiveSweepingAt, 10,                             \
1742           &quot;Start aggressive sweeping if X[%] of the code cache is free.&quot;    \
1743           &quot;Segmented code cache: X[%] of the non-profiled heap.&quot;            \
1744           &quot;Non-segmented code cache: X[%] of the total code cache&quot;)         \
1745           range(0, 100)                                                     \
1746                                                                             \
1747   /* AOT parameters */                                                      \
1748   experimental(bool, UseAOT, false,                                         \
1749           &quot;Use AOT compiled files&quot;)                                         \
1750                                                                             \
1751   experimental(ccstrlist, AOTLibrary, NULL,                                 \
1752           &quot;AOT library&quot;)                                                    \
1753                                                                             \
1754   experimental(bool, PrintAOT, false,                                       \
1755           &quot;Print used AOT klasses and methods&quot;)                             \
1756                                                                             \
1757   notproduct(bool, PrintAOTStatistics, false,                               \
1758           &quot;Print AOT statistics&quot;)                                           \
1759                                                                             \
1760   diagnostic(bool, UseAOTStrictLoading, false,                              \
1761           &quot;Exit the VM if any of the AOT libraries has invalid config&quot;)     \
1762                                                                             \
1763   product(bool, CalculateClassFingerprint, false,                           \
1764           &quot;Calculate class fingerprint&quot;)                                    \
1765                                                                             \
1766   /* interpreter debugging */                                               \
1767   develop(intx, BinarySwitchThreshold, 5,                                   \
1768           &quot;Minimal number of lookupswitch entries for rewriting to binary &quot; \
1769           &quot;switch&quot;)                                                         \
1770                                                                             \
1771   develop(intx, StopInterpreterAt, 0,                                       \
1772           &quot;Stop interpreter execution at specified bytecode number&quot;)        \
1773                                                                             \
1774   develop(intx, TraceBytecodesAt, 0,                                        \
1775           &quot;Trace bytecodes starting with specified bytecode number&quot;)        \
1776                                                                             \
1777   /* compiler interface */                                                  \
1778   develop(intx, CIStart, 0,                                                 \
1779           &quot;The id of the first compilation to permit&quot;)                      \
1780                                                                             \
1781   develop(intx, CIStop, max_jint,                                           \
1782           &quot;The id of the last compilation to permit&quot;)                       \
1783                                                                             \
1784   develop(intx, CIStartOSR, 0,                                              \
1785           &quot;The id of the first osr compilation to permit &quot;                  \
1786           &quot;(CICountOSR must be on)&quot;)                                        \
1787                                                                             \
1788   develop(intx, CIStopOSR, max_jint,                                        \
1789           &quot;The id of the last osr compilation to permit &quot;                   \
1790           &quot;(CICountOSR must be on)&quot;)                                        \
1791                                                                             \
1792   develop(intx, CIBreakAtOSR, -1,                                           \
1793           &quot;The id of osr compilation to break at&quot;)                          \
1794                                                                             \
1795   develop(intx, CIBreakAt, -1,                                              \
1796           &quot;The id of compilation to break at&quot;)                              \
1797                                                                             \
1798   product(ccstrlist, CompileOnly, &quot;&quot;,                                       \
1799           &quot;List of methods (pkg/class.name) to restrict compilation to&quot;)    \
1800                                                                             \
1801   product(ccstr, CompileCommandFile, NULL,                                  \
1802           &quot;Read compiler commands from this file [.hotspot_compiler]&quot;)      \
1803                                                                             \
1804   diagnostic(ccstr, CompilerDirectivesFile, NULL,                           \
1805           &quot;Read compiler directives from this file&quot;)                        \
1806                                                                             \
1807   product(ccstrlist, CompileCommand, &quot;&quot;,                                    \
1808           &quot;Prepend to .hotspot_compiler; e.g. log,java/lang/String.&lt;init&gt;&quot;) \
1809                                                                             \
1810   develop(bool, ReplayCompiles, false,                                      \
1811           &quot;Enable replay of compilations from ReplayDataFile&quot;)              \
1812                                                                             \
1813   product(ccstr, ReplayDataFile, NULL,                                      \
1814           &quot;File containing compilation replay information&quot;                  \
1815           &quot;[default: ./replay_pid%p.log] (%p replaced with pid)&quot;)           \
1816                                                                             \
1817    product(ccstr, InlineDataFile, NULL,                                     \
1818           &quot;File containing inlining replay information&quot;                     \
1819           &quot;[default: ./inline_pid%p.log] (%p replaced with pid)&quot;)           \
1820                                                                             \
1821   develop(intx, ReplaySuppressInitializers, 2,                              \
1822           &quot;Control handling of class initialization during replay: &quot;        \
1823           &quot;0 - don&#39;t do anything special; &quot;                                 \
1824           &quot;1 - treat all class initializers as empty; &quot;                     \
1825           &quot;2 - treat class initializers for application classes as empty; &quot; \
1826           &quot;3 - allow all class initializers to run during bootstrap but &quot;   \
1827           &quot;    pretend they are empty after starting replay&quot;)               \
1828           range(0, 3)                                                       \
1829                                                                             \
1830   develop(bool, ReplayIgnoreInitErrors, false,                              \
1831           &quot;Ignore exceptions thrown during initialization for replay&quot;)      \
1832                                                                             \
1833   product(bool, DumpReplayDataOnError, true,                                \
1834           &quot;Record replay data for crashing compiler threads&quot;)               \
1835                                                                             \
1836   product(bool, CICompilerCountPerCPU, false,                               \
1837           &quot;1 compiler thread for log(N CPUs)&quot;)                              \
1838                                                                             \
1839   notproduct(intx, CICrashAt, -1,                                           \
1840           &quot;id of compilation to trigger assert in compiler thread for &quot;     \
1841           &quot;the purpose of testing, e.g. generation of replay data&quot;)         \
1842   notproduct(bool, CIObjectFactoryVerify, false,                            \
1843           &quot;enable potentially expensive verification in ciObjectFactory&quot;)   \
1844                                                                             \
1845   diagnostic(bool, AbortVMOnCompilationFailure, false,                      \
1846           &quot;Abort VM when method had failed to compile.&quot;)                    \
1847                                                                             \
1848   /* Priorities */                                                          \
1849   product_pd(bool, UseThreadPriorities,  &quot;Use native thread priorities&quot;)    \
1850                                                                             \
1851   product(intx, ThreadPriorityPolicy, 0,                                    \
1852           &quot;0 : Normal.                                                     &quot;\
1853           &quot;    VM chooses priorities that are appropriate for normal       &quot;\
1854           &quot;    applications. On Solaris NORM_PRIORITY and above are mapped &quot;\
1855           &quot;    to normal native priority. Java priorities below &quot;           \
1856           &quot;    NORM_PRIORITY map to lower native priority values. On       &quot;\
1857           &quot;    Windows applications are allowed to use higher native       &quot;\
1858           &quot;    priorities. However, with ThreadPriorityPolicy=0, VM will   &quot;\
1859           &quot;    not use the highest possible native priority,               &quot;\
1860           &quot;    THREAD_PRIORITY_TIME_CRITICAL, as it may interfere with     &quot;\
1861           &quot;    system threads. On Linux thread priorities are ignored      &quot;\
1862           &quot;    because the OS does not support static priority in          &quot;\
1863           &quot;    SCHED_OTHER scheduling class which is the only choice for   &quot;\
1864           &quot;    non-root, non-realtime applications.                        &quot;\
1865           &quot;1 : Aggressive.                                                 &quot;\
1866           &quot;    Java thread priorities map over to the entire range of      &quot;\
1867           &quot;    native thread priorities. Higher Java thread priorities map &quot;\
1868           &quot;    to higher native thread priorities. This policy should be   &quot;\
1869           &quot;    used with care, as sometimes it can cause performance       &quot;\
1870           &quot;    degradation in the application and/or the entire system. On &quot;\
1871           &quot;    Linux/BSD/macOS this policy requires root privilege or an   &quot;\
1872           &quot;    extended capability.&quot;)                                       \
1873           range(0, 1)                                                       \
1874                                                                             \
1875   product(bool, ThreadPriorityVerbose, false,                               \
1876           &quot;Print priority changes&quot;)                                         \
1877                                                                             \
1878   product(intx, CompilerThreadPriority, -1,                                 \
1879           &quot;The native priority at which compiler threads should run &quot;       \
1880           &quot;(-1 means no change)&quot;)                                           \
1881           range(min_jint, max_jint)                                         \
1882           constraint(CompilerThreadPriorityConstraintFunc, AfterErgo)       \
1883                                                                             \
1884   product(intx, VMThreadPriority, -1,                                       \
1885           &quot;The native priority at which the VM thread should run &quot;          \
1886           &quot;(-1 means no change)&quot;)                                           \
1887           range(-1, 127)                                                    \
1888                                                                             \
1889   product(intx, JavaPriority1_To_OSPriority, -1,                            \
1890           &quot;Map Java priorities to OS priorities&quot;)                           \
1891           range(-1, 127)                                                    \
1892                                                                             \
1893   product(intx, JavaPriority2_To_OSPriority, -1,                            \
1894           &quot;Map Java priorities to OS priorities&quot;)                           \
1895           range(-1, 127)                                                    \
1896                                                                             \
1897   product(intx, JavaPriority3_To_OSPriority, -1,                            \
1898           &quot;Map Java priorities to OS priorities&quot;)                           \
1899           range(-1, 127)                                                    \
1900                                                                             \
1901   product(intx, JavaPriority4_To_OSPriority, -1,                            \
1902           &quot;Map Java priorities to OS priorities&quot;)                           \
1903           range(-1, 127)                                                    \
1904                                                                             \
1905   product(intx, JavaPriority5_To_OSPriority, -1,                            \
1906           &quot;Map Java priorities to OS priorities&quot;)                           \
1907           range(-1, 127)                                                    \
1908                                                                             \
1909   product(intx, JavaPriority6_To_OSPriority, -1,                            \
1910           &quot;Map Java priorities to OS priorities&quot;)                           \
1911           range(-1, 127)                                                    \
1912                                                                             \
1913   product(intx, JavaPriority7_To_OSPriority, -1,                            \
1914           &quot;Map Java priorities to OS priorities&quot;)                           \
1915           range(-1, 127)                                                    \
1916                                                                             \
1917   product(intx, JavaPriority8_To_OSPriority, -1,                            \
1918           &quot;Map Java priorities to OS priorities&quot;)                           \
1919           range(-1, 127)                                                    \
1920                                                                             \
1921   product(intx, JavaPriority9_To_OSPriority, -1,                            \
1922           &quot;Map Java priorities to OS priorities&quot;)                           \
1923           range(-1, 127)                                                    \
1924                                                                             \
1925   product(intx, JavaPriority10_To_OSPriority,-1,                            \
1926           &quot;Map Java priorities to OS priorities&quot;)                           \
1927           range(-1, 127)                                                    \
1928                                                                             \
1929   experimental(bool, UseCriticalJavaThreadPriority, false,                  \
1930           &quot;Java thread priority 10 maps to critical scheduling priority&quot;)   \
1931                                                                             \
1932   experimental(bool, UseCriticalCompilerThreadPriority, false,              \
1933           &quot;Compiler thread(s) run at critical scheduling priority&quot;)         \
1934                                                                             \
1935   develop(intx, NewCodeParameter,      0,                                   \
1936           &quot;Testing Only: Create a dedicated integer parameter before &quot;      \
1937           &quot;putback&quot;)                                                        \
1938                                                                             \
1939   /* new oopmap storage allocation */                                       \
1940   develop(intx, MinOopMapAllocation,     8,                                 \
1941           &quot;Minimum number of OopMap entries in an OopMapSet&quot;)               \
1942                                                                             \
1943   /* Background Compilation */                                              \
1944   develop(intx, LongCompileThreshold,     50,                               \
1945           &quot;Used with +TraceLongCompiles&quot;)                                   \
1946                                                                             \
1947   /* recompilation */                                                       \
1948   product_pd(intx, CompileThreshold,                                        \
1949           &quot;number of interpreted method invocations before (re-)compiling&quot;) \
1950           constraint(CompileThresholdConstraintFunc, AfterErgo)             \
1951                                                                             \
1952   product(double, CompileThresholdScaling, 1.0,                             \
1953           &quot;Factor to control when first compilation happens &quot;               \
1954           &quot;(both with and without tiered compilation): &quot;                    \
1955           &quot;values greater than 1.0 delay counter overflow, &quot;                \
1956           &quot;values between 0 and 1.0 rush counter overflow, &quot;                \
1957           &quot;value of 1.0 leaves compilation thresholds unchanged &quot;           \
1958           &quot;value of 0.0 is equivalent to -Xint. &quot;                           \
1959           &quot;&quot;                                                                \
1960           &quot;Flag can be set as per-method option. &quot;                          \
1961           &quot;If a value is specified for a method, compilation thresholds &quot;   \
1962           &quot;for that method are scaled by both the value of the global flag &quot;\
1963           &quot;and the value of the per-method flag.&quot;)                          \
1964           range(0.0, DBL_MAX)                                               \
1965                                                                             \
1966   product(intx, Tier0InvokeNotifyFreqLog, 7,                                \
1967           &quot;Interpreter (tier 0) invocation notification frequency&quot;)         \
1968           range(0, 30)                                                      \
1969                                                                             \
1970   product(intx, Tier2InvokeNotifyFreqLog, 11,                               \
1971           &quot;C1 without MDO (tier 2) invocation notification frequency&quot;)      \
1972           range(0, 30)                                                      \
1973                                                                             \
1974   product(intx, Tier3InvokeNotifyFreqLog, 10,                               \
1975           &quot;C1 with MDO profiling (tier 3) invocation notification &quot;         \
1976           &quot;frequency&quot;)                                                      \
1977           range(0, 30)                                                      \
1978                                                                             \
1979   product(intx, Tier23InlineeNotifyFreqLog, 20,                             \
1980           &quot;Inlinee invocation (tiers 2 and 3) notification frequency&quot;)      \
1981           range(0, 30)                                                      \
1982                                                                             \
1983   product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \
1984           &quot;Interpreter (tier 0) invocation notification frequency&quot;)         \
1985           range(0, 30)                                                      \
1986                                                                             \
1987   product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \
1988           &quot;C1 without MDO (tier 2) invocation notification frequency&quot;)      \
1989           range(0, 30)                                                      \
1990                                                                             \
1991   product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \
1992           &quot;C1 with MDO profiling (tier 3) invocation notification &quot;         \
1993           &quot;frequency&quot;)                                                      \
1994           range(0, 30)                                                      \
1995                                                                             \
1996   product(intx, Tier2CompileThreshold, 0,                                   \
1997           &quot;threshold at which tier 2 compilation is invoked&quot;)               \
1998           range(0, max_jint)                                                \
1999                                                                             \
2000   product(intx, Tier2BackEdgeThreshold, 0,                                  \
2001           &quot;Back edge threshold at which tier 2 compilation is invoked&quot;)     \
2002           range(0, max_jint)                                                \
2003                                                                             \
2004   product(intx, Tier3InvocationThreshold, 200,                              \
2005           &quot;Compile if number of method invocations crosses this &quot;           \
2006           &quot;threshold&quot;)                                                      \
2007           range(0, max_jint)                                                \
2008                                                                             \
2009   product(intx, Tier3MinInvocationThreshold, 100,                           \
2010           &quot;Minimum invocation to compile at tier 3&quot;)                        \
2011           range(0, max_jint)                                                \
2012                                                                             \
2013   product(intx, Tier3CompileThreshold, 2000,                                \
2014           &quot;Threshold at which tier 3 compilation is invoked (invocation &quot;   \
2015           &quot;minimum must be satisfied)&quot;)                                     \
2016           range(0, max_jint)                                                \
2017                                                                             \
2018   product(intx, Tier3BackEdgeThreshold,  60000,                             \
2019           &quot;Back edge threshold at which tier 3 OSR compilation is invoked&quot;) \
2020           range(0, max_jint)                                                \
2021                                                                             \
2022   product(intx, Tier3AOTInvocationThreshold, 10000,                         \
2023           &quot;Compile if number of method invocations crosses this &quot;           \
2024           &quot;threshold if coming from AOT&quot;)                                   \
2025           range(0, max_jint)                                                \
2026                                                                             \
2027   product(intx, Tier3AOTMinInvocationThreshold, 1000,                       \
2028           &quot;Minimum invocation to compile at tier 3 if coming from AOT&quot;)     \
2029           range(0, max_jint)                                                \
2030                                                                             \
2031   product(intx, Tier3AOTCompileThreshold, 15000,                            \
2032           &quot;Threshold at which tier 3 compilation is invoked (invocation &quot;   \
2033           &quot;minimum must be satisfied) if coming from AOT&quot;)                  \
2034           range(0, max_jint)                                                \
2035                                                                             \
2036   product(intx, Tier3AOTBackEdgeThreshold,  120000,                         \
2037           &quot;Back edge threshold at which tier 3 OSR compilation is invoked &quot; \
2038           &quot;if coming from AOT&quot;)                                             \
2039           range(0, max_jint)                                                \
2040                                                                             \
2041   diagnostic(intx, Tier0AOTInvocationThreshold, 200,                        \
2042           &quot;Switch to interpreter to profile if the number of method &quot;       \
2043           &quot;invocations crosses this threshold if coming from AOT &quot;          \
2044           &quot;(applicable only with &quot;                                          \
2045           &quot;CompilationMode=high-only|high-only-quick-internal)&quot;)            \
2046           range(0, max_jint)                                                \
2047                                                                             \
2048   diagnostic(intx, Tier0AOTMinInvocationThreshold, 100,                     \
2049           &quot;Minimum number of invocations to switch to interpreter &quot;         \
2050           &quot;to profile if coming from AOT &quot;                                  \
2051           &quot;(applicable only with &quot;                                          \
2052           &quot;CompilationMode=high-only|high-only-quick-internal)&quot;)            \
2053           range(0, max_jint)                                                \
2054                                                                             \
2055   diagnostic(intx, Tier0AOTCompileThreshold, 2000,                          \
2056           &quot;Threshold at which to switch to interpreter to profile &quot;         \
2057           &quot;if coming from AOT &quot;                                             \
2058           &quot;(invocation minimum must be satisfied, &quot;                         \
2059           &quot;applicable only with &quot;                                           \
2060           &quot;CompilationMode=high-only|high-only-quick-internal)&quot;)            \
2061           range(0, max_jint)                                                \
2062                                                                             \
2063   diagnostic(intx, Tier0AOTBackEdgeThreshold,  60000,                       \
2064           &quot;Back edge threshold at which to switch to interpreter &quot;          \
2065           &quot;to profile if coming from AOT &quot;                                  \
2066           &quot;(applicable only with &quot;                                          \
2067           &quot;CompilationMode=high-only|high-only-quick-internal)&quot;)            \
2068           range(0, max_jint)                                                \
2069                                                                             \
2070   product(intx, Tier4InvocationThreshold, 5000,                             \
2071           &quot;Compile if number of method invocations crosses this &quot;           \
2072           &quot;threshold&quot;)                                                      \
2073           range(0, max_jint)                                                \
2074                                                                             \
2075   product(intx, Tier4MinInvocationThreshold, 600,                           \
2076           &quot;Minimum invocation to compile at tier 4&quot;)                        \
2077           range(0, max_jint)                                                \
2078                                                                             \
2079   product(intx, Tier4CompileThreshold, 15000,                               \
2080           &quot;Threshold at which tier 4 compilation is invoked (invocation &quot;   \
2081           &quot;minimum must be satisfied)&quot;)                                     \
2082           range(0, max_jint)                                                \
2083                                                                             \
2084   product(intx, Tier4BackEdgeThreshold, 40000,                              \
2085           &quot;Back edge threshold at which tier 4 OSR compilation is invoked&quot;) \
2086           range(0, max_jint)                                                \
2087                                                                             \
2088   diagnostic(intx, Tier40InvocationThreshold, 5000,                         \
2089           &quot;Compile if number of method invocations crosses this &quot;           \
2090           &quot;threshold (applicable only with &quot;                                \
2091           &quot;CompilationMode=high-only|high-only-quick-internal)&quot;)            \
2092           range(0, max_jint)                                                \
2093                                                                             \
2094   diagnostic(intx, Tier40MinInvocationThreshold, 600,                       \
2095           &quot;Minimum number of invocations to compile at tier 4 &quot;             \
2096           &quot;(applicable only with &quot;                                          \
2097           &quot;CompilationMode=high-only|high-only-quick-internal)&quot;)            \
2098           range(0, max_jint)                                                \
2099                                                                             \
2100   diagnostic(intx, Tier40CompileThreshold, 10000,                           \
2101           &quot;Threshold at which tier 4 compilation is invoked (invocation &quot;   \
2102           &quot;minimum must be satisfied, applicable only with &quot;                \
2103           &quot;CompilationMode=high-only|high-only-quick-internal)&quot;)            \
2104           range(0, max_jint)                                                \
2105                                                                             \
2106   diagnostic(intx, Tier40BackEdgeThreshold, 15000,                          \
2107           &quot;Back edge threshold at which tier 4 OSR compilation is invoked &quot; \
2108           &quot;(applicable only with &quot;                                          \
2109           &quot;CompilationMode=high-only|high-only-quick-internal)&quot;)            \
2110           range(0, max_jint)                                                \
2111                                                                             \
2112   diagnostic(intx, Tier0Delay, 5,                                           \
2113           &quot;If C2 queue size grows over this amount per compiler thread &quot;    \
2114           &quot;do not start profiling in the interpreter &quot;                      \
2115           &quot;(applicable only with &quot;                                          \
2116           &quot;CompilationMode=high-only|high-only-quick-internal)&quot;)            \
2117           range(0, max_jint)                                                \
2118                                                                             \
2119   product(intx, Tier3DelayOn, 5,                                            \
2120           &quot;If C2 queue size grows over this amount per compiler thread &quot;    \
2121           &quot;stop compiling at tier 3 and start compiling at tier 2&quot;)         \
2122           range(0, max_jint)                                                \
2123                                                                             \
2124   product(intx, Tier3DelayOff, 2,                                           \
2125           &quot;If C2 queue size is less than this amount per compiler thread &quot;  \
2126           &quot;allow methods compiled at tier 2 transition to tier 3&quot;)          \
2127           range(0, max_jint)                                                \
2128                                                                             \
2129   product(intx, Tier3LoadFeedback, 5,                                       \
2130           &quot;Tier 3 thresholds will increase twofold when C1 queue size &quot;     \
2131           &quot;reaches this amount per compiler thread&quot;)                        \
2132           range(0, max_jint)                                                \
2133                                                                             \
2134   product(intx, Tier4LoadFeedback, 3,                                       \
2135           &quot;Tier 4 thresholds will increase twofold when C2 queue size &quot;     \
2136           &quot;reaches this amount per compiler thread&quot;)                        \
2137           range(0, max_jint)                                                \
2138                                                                             \
2139   product(intx, TieredCompileTaskTimeout, 50,                               \
2140           &quot;Kill compile task if method was not used within &quot;                \
2141           &quot;given timeout in milliseconds&quot;)                                  \
2142           range(0, max_intx)                                                \
2143                                                                             \
2144   product(intx, TieredStopAtLevel, 4,                                       \
2145           &quot;Stop at given compilation level&quot;)                                \
2146           range(0, 4)                                                       \
2147                                                                             \
2148   product(intx, Tier0ProfilingStartPercentage, 200,                         \
2149           &quot;Start profiling in interpreter if the counters exceed tier 3 &quot;   \
2150           &quot;thresholds (tier 4 thresholds with &quot;                             \
2151           &quot;CompilationMode=high-only|high-only-quick-internal)&quot;             \
2152           &quot;by the specified percentage&quot;)                                    \
2153           range(0, max_jint)                                                \
2154                                                                             \
2155   product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \
2156           &quot;Increase the compile threshold for C1 compilation if the code &quot;  \
2157           &quot;cache is filled by the specified percentage&quot;)                    \
2158           range(0, 99)                                                      \
2159                                                                             \
2160   product(intx, TieredRateUpdateMinTime, 1,                                 \
2161           &quot;Minimum rate sampling interval (in milliseconds)&quot;)               \
2162           range(0, max_intx)                                                \
2163                                                                             \
2164   product(intx, TieredRateUpdateMaxTime, 25,                                \
2165           &quot;Maximum rate sampling interval (in milliseconds)&quot;)               \
2166           range(0, max_intx)                                                \
2167                                                                             \
2168   product(ccstr, CompilationMode, &quot;default&quot;,                                \
2169           &quot;Compilation modes: &quot;                                             \
2170           &quot;default: normal tiered compilation; &quot;                            \
2171           &quot;quick-only: C1-only mode; &quot;                                      \
2172           &quot;high-only: C2/JVMCI-only mode; &quot;                                 \
2173           &quot;high-only-quick-internal: C2/JVMCI-only mode, &quot;                  \
2174           &quot;with JVMCI compiler compiled with C1.&quot;)                          \
2175                                                                             \
2176   product_pd(bool, TieredCompilation,                                       \
2177           &quot;Enable tiered compilation&quot;)                                      \
2178                                                                             \
2179   product(bool, PrintTieredEvents, false,                                   \
2180           &quot;Print tiered events notifications&quot;)                              \
2181                                                                             \
2182   product_pd(intx, OnStackReplacePercentage,                                \
2183           &quot;NON_TIERED number of method invocations/branches (expressed as &quot; \
2184           &quot;% of CompileThreshold) before (re-)compiling OSR code&quot;)          \
2185           constraint(OnStackReplacePercentageConstraintFunc, AfterErgo)     \
2186                                                                             \
2187   product(intx, InterpreterProfilePercentage, 33,                           \
2188           &quot;NON_TIERED number of method invocations/branches (expressed as &quot; \
2189           &quot;% of CompileThreshold) before profiling in the interpreter&quot;)     \
2190           range(0, 100)                                                     \
2191                                                                             \
2192   develop(intx, DesiredMethodLimit,  8000,                                  \
2193           &quot;The desired maximum method size (in bytecodes) after inlining&quot;)  \
2194                                                                             \
2195   develop(intx, HugeMethodLimit,  8000,                                     \
2196           &quot;Don&#39;t compile methods larger than this if &quot;                      \
2197           &quot;+DontCompileHugeMethods&quot;)                                        \
2198                                                                             \
2199   /* Properties for Java libraries  */                                      \
2200                                                                             \
2201   product(uint64_t, MaxDirectMemorySize, 0,                                 \
2202           &quot;Maximum total size of NIO direct-buffer allocations&quot;)            \
2203           range(0, max_jlong)                                               \
2204                                                                             \
2205   /* Flags used for temporary code during development  */                   \
2206                                                                             \
2207   diagnostic(bool, UseNewCode, false,                                       \
2208           &quot;Testing Only: Use the new version while testing&quot;)                \
2209                                                                             \
2210   diagnostic(bool, UseNewCode2, false,                                      \
2211           &quot;Testing Only: Use the new version while testing&quot;)                \
2212                                                                             \
2213   diagnostic(bool, UseNewCode3, false,                                      \
2214           &quot;Testing Only: Use the new version while testing&quot;)                \
2215                                                                             \
2216   /* flags for performance data collection */                               \
2217                                                                             \
2218   product(bool, UsePerfData, true,                                          \
2219           &quot;Flag to disable jvmstat instrumentation for performance testing &quot;\
2220           &quot;and problem isolation purposes&quot;)                                 \
2221                                                                             \
2222   product(bool, PerfDataSaveToFile, false,                                  \
2223           &quot;Save PerfData memory to hsperfdata_&lt;pid&gt; file on exit&quot;)          \
2224                                                                             \
2225   product(ccstr, PerfDataSaveFile, NULL,                                    \
2226           &quot;Save PerfData memory to the specified absolute pathname. &quot;       \
2227           &quot;The string %p in the file name (if present) &quot;                    \
2228           &quot;will be replaced by pid&quot;)                                        \
2229                                                                             \
2230   product(intx, PerfDataSamplingInterval, 50,                               \
2231           &quot;Data sampling interval (in milliseconds)&quot;)                       \
2232           range(PeriodicTask::min_interval, max_jint)                       \
2233           constraint(PerfDataSamplingIntervalFunc, AfterErgo)               \
2234                                                                             \
2235   product(bool, PerfDisableSharedMem, false,                                \
2236           &quot;Store performance data in standard memory&quot;)                      \
2237                                                                             \
2238   product(intx, PerfDataMemorySize, 32*K,                                   \
2239           &quot;Size of performance data memory region. Will be rounded &quot;        \
2240           &quot;up to a multiple of the native os page size.&quot;)                   \
2241           range(128, 32*64*K)                                               \
2242                                                                             \
2243   product(intx, PerfMaxStringConstLength, 1024,                             \
2244           &quot;Maximum PerfStringConstant string length before truncation&quot;)     \
2245           range(32, 32*K)                                                   \
2246                                                                             \
2247   product(bool, PerfAllowAtExitRegistration, false,                         \
2248           &quot;Allow registration of atexit() methods&quot;)                         \
2249                                                                             \
2250   product(bool, PerfBypassFileSystemCheck, false,                           \
2251           &quot;Bypass Win32 file system criteria checks (Windows Only)&quot;)        \
2252                                                                             \
2253   product(intx, UnguardOnExecutionViolation, 0,                             \
2254           &quot;Unguard page and retry on no-execute fault (Win32 only) &quot;        \
2255           &quot;0=off, 1=conservative, 2=aggressive&quot;)                            \
2256           range(0, 2)                                                       \
2257                                                                             \
2258   /* Serviceability Support */                                              \
2259                                                                             \
2260   product(bool, ManagementServer, false,                                    \
2261           &quot;Create JMX Management Server&quot;)                                   \
2262                                                                             \
2263   product(bool, DisableAttachMechanism, false,                              \
2264           &quot;Disable mechanism that allows tools to attach to this VM&quot;)       \
2265                                                                             \
2266   product(bool, StartAttachListener, false,                                 \
2267           &quot;Always start Attach Listener at VM startup&quot;)                     \
2268                                                                             \
2269   product(bool, EnableDynamicAgentLoading, true,                            \
2270           &quot;Allow tools to load agents with the attach mechanism&quot;)           \
2271                                                                             \
2272   manageable(bool, PrintConcurrentLocks, false,                             \
2273           &quot;Print java.util.concurrent locks in thread dump&quot;)                \
2274                                                                             \
2275   /* Shared spaces */                                                       \
2276                                                                             \
2277   product(bool, UseSharedSpaces, true,                                      \
2278           &quot;Use shared spaces for metadata&quot;)                                 \
2279                                                                             \
2280   product(bool, VerifySharedSpaces, false,                                  \
2281           &quot;Verify integrity of shared spaces&quot;)                              \
2282                                                                             \
2283   product(bool, RequireSharedSpaces, false,                                 \
2284           &quot;Require shared spaces for metadata&quot;)                             \
2285                                                                             \
2286   product(bool, DumpSharedSpaces, false,                                    \
2287           &quot;Special mode: JVM reads a class list, loads classes, builds &quot;    \
2288           &quot;shared spaces, and dumps the shared spaces to a file to be &quot;     \
2289           &quot;used in future JVM runs&quot;)                                        \
2290                                                                             \
2291   product(bool, DynamicDumpSharedSpaces, false,                             \
2292           &quot;Dynamic archive&quot;)                                                \
2293                                                                             \
2294   product(bool, PrintSharedArchiveAndExit, false,                           \
2295           &quot;Print shared archive file contents&quot;)                             \
2296                                                                             \
2297   product(bool, PrintSharedDictionary, false,                               \
2298           &quot;If PrintSharedArchiveAndExit is true, also print the shared &quot;    \
2299           &quot;dictionary&quot;)                                                     \
2300                                                                             \
2301   product(size_t, SharedBaseAddress, LP64_ONLY(32*G)                        \
2302           NOT_LP64(LINUX_ONLY(2*G) NOT_LINUX(0)),                           \
2303           &quot;Address to allocate shared memory region for class data&quot;)        \
2304           range(0, SIZE_MAX)                                                \
2305                                                                             \
2306   product(ccstr, SharedArchiveConfigFile, NULL,                             \
2307           &quot;Data to add to the CDS archive file&quot;)                            \
2308                                                                             \
2309   product(uintx, SharedSymbolTableBucketSize, 4,                            \
2310           &quot;Average number of symbols per bucket in shared table&quot;)           \
2311           range(2, 246)                                                     \
2312                                                                             \
2313   diagnostic(bool, AllowArchivingWithJavaAgent, false,                      \
2314           &quot;Allow Java agent to be run with CDS dumping&quot;)                    \
2315                                                                             \
2316   diagnostic(bool, PrintMethodHandleStubs, false,                           \
2317           &quot;Print generated stub code for method handles&quot;)                   \
2318                                                                             \
2319   diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \
2320           &quot;perform extra checks when constructing method handles&quot;)          \
2321                                                                             \
2322   diagnostic(bool, ShowHiddenFrames, false,                                 \
2323           &quot;show method handle implementation frames (usually hidden)&quot;)      \
2324                                                                             \
2325   experimental(bool, TrustFinalNonStaticFields, false,                      \
2326           &quot;trust final non-static declarations for constant folding&quot;)       \
2327                                                                             \
2328   diagnostic(bool, FoldStableValues, true,                                  \
2329           &quot;Optimize loads from stable fields (marked w/ @Stable)&quot;)          \
2330                                                                             \
2331   diagnostic(int, UseBootstrapCallInfo, 1,                                  \
2332           &quot;0: when resolving InDy or ConDy, force all BSM arguments to be &quot; \
2333           &quot;resolved before the bootstrap method is called; 1: when a BSM &quot;  \
2334           &quot;that may accept a BootstrapCallInfo is detected, use that API &quot;  \
2335           &quot;to pass BSM arguments, which allows the BSM to delay their &quot;     \
2336           &quot;resolution; 2+: stress test the BCI API by calling more BSMs &quot;   \
2337           &quot;via that API, instead of with the eagerly-resolved array.&quot;)      \
2338                                                                             \
2339   diagnostic(bool, PauseAtStartup,      false,                              \
2340           &quot;Causes the VM to pause at startup time and wait for the pause &quot;  \
2341           &quot;file to be removed (default: ./vm.paused.&lt;pid&gt;)&quot;)                \
2342                                                                             \
2343   diagnostic(ccstr, PauseAtStartupFile, NULL,                               \
2344           &quot;The file to create and for whose removal to await when pausing &quot; \
2345           &quot;at startup. (default: ./vm.paused.&lt;pid&gt;)&quot;)                       \
2346                                                                             \
2347   diagnostic(bool, PauseAtExit, false,                                      \
2348           &quot;Pause and wait for keypress on exit if a debugger is attached&quot;)  \
2349                                                                             \
2350   product(bool, ExtendedDTraceProbes,    false,                             \
2351           &quot;Enable performance-impacting dtrace probes&quot;)                     \
2352                                                                             \
2353   product(bool, DTraceMethodProbes, false,                                  \
2354           &quot;Enable dtrace probes for method-entry and method-exit&quot;)          \
2355                                                                             \
2356   product(bool, DTraceAllocProbes, false,                                   \
2357           &quot;Enable dtrace probes for object allocation&quot;)                     \
2358                                                                             \
2359   product(bool, DTraceMonitorProbes, false,                                 \
2360           &quot;Enable dtrace probes for monitor events&quot;)                        \
2361                                                                             \
2362   product(bool, RelaxAccessControlCheck, false,                             \
2363           &quot;Relax the access control checks in the verifier&quot;)                \
2364                                                                             \
2365   product(uintx, StringTableSize, defaultStringTableSize,                   \
2366           &quot;Number of buckets in the interned String table &quot;                 \
2367           &quot;(will be rounded to nearest higher power of 2)&quot;)                 \
2368           range(minimumStringTableSize, 16777216ul /* 2^24 */)              \
2369                                                                             \
2370   experimental(uintx, SymbolTableSize, defaultSymbolTableSize,              \
2371           &quot;Number of buckets in the JVM internal Symbol table&quot;)             \
2372           range(minimumSymbolTableSize, 16777216ul /* 2^24 */)              \
2373                                                                             \
2374   product(bool, UseStringDeduplication, false,                              \
2375           &quot;Use string deduplication&quot;)                                       \
2376                                                                             \
2377   product(uintx, StringDeduplicationAgeThreshold, 3,                        \
2378           &quot;A string must reach this age (or be promoted to an old region) &quot; \
2379           &quot;to be considered for deduplication&quot;)                             \
2380           range(1, markWord::max_age)                                       \
2381                                                                             \
2382   diagnostic(bool, StringDeduplicationResizeALot, false,                    \
2383           &quot;Force table resize every time the table is scanned&quot;)             \
2384                                                                             \
2385   diagnostic(bool, StringDeduplicationRehashALot, false,                    \
2386           &quot;Force table rehash every time the table is scanned&quot;)             \
2387                                                                             \
2388   diagnostic(bool, WhiteBoxAPI, false,                                      \
2389           &quot;Enable internal testing APIs&quot;)                                   \
2390                                                                             \
2391   experimental(intx, SurvivorAlignmentInBytes, 0,                           \
2392            &quot;Default survivor space alignment in bytes&quot;)                     \
2393            range(8, 256)                                                    \
2394            constraint(SurvivorAlignmentInBytesConstraintFunc,AfterErgo)     \
2395                                                                             \
2396   product(ccstr, DumpLoadedClassList, NULL,                                 \
2397           &quot;Dump the names all loaded classes, that could be stored into &quot;   \
2398           &quot;the CDS archive, in the specified file&quot;)                         \
2399                                                                             \
2400   product(ccstr, SharedClassListFile, NULL,                                 \
2401           &quot;Override the default CDS class list&quot;)                            \
2402                                                                             \
2403   product(ccstr, SharedArchiveFile, NULL,                                   \
2404           &quot;Override the default location of the CDS archive file&quot;)          \
2405                                                                             \
2406   product(ccstr, ArchiveClassesAtExit, NULL,                                \
2407           &quot;The path and name of the dynamic archive file&quot;)                  \
2408                                                                             \
2409   product(ccstr, ExtraSharedClassListFile, NULL,                            \
2410           &quot;Extra classlist for building the CDS archive file&quot;)              \
2411                                                                             \
2412   diagnostic(intx, ArchiveRelocationMode, 0,                                \
2413            &quot;(0) first map at preferred address, and if &quot;                    \
2414            &quot;unsuccessful, map at alternative address (default); &quot;           \
2415            &quot;(1) always map at alternative address; &quot;                        \
2416            &quot;(2) always map at preferred address, and if unsuccessful, &quot;     \
2417            &quot;do not map the archive&quot;)                                        \
2418            range(0, 2)                                                      \
2419                                                                             \
2420   experimental(size_t, ArrayAllocatorMallocLimit,                           \
2421           SOLARIS_ONLY(64*K) NOT_SOLARIS((size_t)-1),                       \
2422           &quot;Allocation less than this value will be allocated &quot;              \
2423           &quot;using malloc. Larger allocations will use mmap.&quot;)                \
2424                                                                             \
2425   experimental(bool, AlwaysAtomicAccesses, false,                           \
2426           &quot;Accesses to all variables should always be atomic&quot;)              \
2427                                                                             \
2428   diagnostic(bool, UseUnalignedAccesses, false,                             \
2429           &quot;Use unaligned memory accesses in Unsafe&quot;)                        \
2430                                                                             \
2431   product_pd(bool, PreserveFramePointer,                                    \
2432              &quot;Use the FP register for holding the frame pointer &quot;           \
2433              &quot;and not as a general purpose register.&quot;)                      \
2434                                                                             \
2435   diagnostic(bool, CheckIntrinsics, true,                                   \
2436              &quot;When a class C is loaded, check that &quot;                        \
2437              &quot;(1) all intrinsics defined by the VM for class C are present &quot;\
2438              &quot;in the loaded class file and are marked with the &quot;            \
2439              &quot;@HotSpotIntrinsicCandidate annotation, that &quot;                 \
2440              &quot;(2) there is an intrinsic registered for all loaded methods &quot; \
2441              &quot;that are annotated with the @HotSpotIntrinsicCandidate &quot;      \
2442              &quot;annotation, and that &quot;                                        \
2443              &quot;(3) no orphan methods exist for class C (i.e., methods for &quot;  \
2444              &quot;which the VM declares an intrinsic but that are not declared &quot;\
2445              &quot;in the loaded class C. &quot;                                      \
2446              &quot;Check (3) is available only in debug builds.&quot;)                \
2447                                                                             \
2448   diagnostic_pd(intx, InitArrayShortSize,                                   \
2449           &quot;Threshold small size (in bytes) for clearing arrays. &quot;           \
2450           &quot;Anything this size or smaller may get converted to discrete &quot;    \
2451           &quot;scalar stores.&quot;)                                                 \
2452           range(0, max_intx)                                                \
2453           constraint(InitArrayShortSizeConstraintFunc, AfterErgo)           \
2454                                                                             \
2455   diagnostic(bool, CompilerDirectivesIgnoreCompileCommands, false,          \
2456              &quot;Disable backwards compatibility for compile commands.&quot;)       \
2457                                                                             \
2458   diagnostic(bool, CompilerDirectivesPrint, false,                          \
2459              &quot;Print compiler directives on installation.&quot;)                  \
2460   diagnostic(int,  CompilerDirectivesLimit, 50,                             \
2461              &quot;Limit on number of compiler directives.&quot;)                     \
2462                                                                             \
2463   product(ccstr, AllocateHeapAt, NULL,                                      \
2464           &quot;Path to the directoy where a temporary file will be created &quot;    \
2465           &quot;to use as the backing store for Java Heap.&quot;)                     \
2466                                                                             \
2467   experimental(ccstr, AllocateOldGenAt, NULL,                               \
2468           &quot;Path to the directoy where a temporary file will be &quot;            \
2469           &quot;created to use as the backing store for old generation.&quot;         \
2470           &quot;File of size Xmx is pre-allocated for performance reason, so&quot;    \
2471           &quot;we need that much space available&quot;)                              \
2472                                                                             \
2473   develop(int, VerifyMetaspaceInterval, DEBUG_ONLY(500) NOT_DEBUG(0),       \
2474                &quot;Run periodic metaspace verifications (0 - none, &quot;           \
2475                &quot;1 - always, &gt;1 every nth interval)&quot;)                        \
2476                                                                             \
2477   diagnostic(bool, ShowRegistersOnAssert, true,                             \
2478           &quot;On internal errors, include registers in error report.&quot;)         \
2479                                                                             \
2480   diagnostic(bool, UseSwitchProfiling, true,                                \
2481           &quot;leverage profiling for table/lookup switch&quot;)                     \
2482                                                                             \
2483   develop(bool, TraceMemoryWriteback, false,                                \
2484           &quot;Trace memory writeback operations&quot;)                              \
2485                                                                             \
2486   JFR_ONLY(product(bool, FlightRecorder, false,                             \
2487           &quot;(Deprecated) Enable Flight Recorder&quot;))                           \
2488                                                                             \
2489   JFR_ONLY(product(ccstr, FlightRecorderOptions, NULL,                      \
2490           &quot;Flight Recorder options&quot;))                                       \
2491                                                                             \
2492   JFR_ONLY(product(ccstr, StartFlightRecording, NULL,                       \
2493           &quot;Start flight recording with options&quot;))                           \
2494                                                                             \
2495   experimental(bool, UseFastUnorderedTimeStamps, false,                     \
2496           &quot;Use platform unstable time where supported for timestamps only&quot;) \
2497                                                                             \
2498   product(bool, EnableValhalla, true,                                       \
2499           &quot;Enable experimental Valhalla features&quot;)                          \
2500                                                                             \
2501   product_pd(bool, InlineTypePassFieldsAsArgs,                              \
2502           &quot;Pass each inline type field as an argument at calls&quot;)            \
2503                                                                             \
2504   product_pd(bool, InlineTypeReturnedAsFields,                              \
2505           &quot;Return fields instead of an inline type reference&quot;)              \
2506                                                                             \
2507   develop(bool, StressInlineTypeReturnedAsFields, false,                    \
2508           &quot;Stress return of fields instead of an inline type reference&quot;)    \
2509                                                                             \
2510   develop(bool, ScalarizeInlineTypes, true,                                 \
2511           &quot;Scalarize inline types in compiled code&quot;)                        \
2512                                                                             \
2513   diagnostic(ccstrlist, ForceNonTearable, &quot;&quot;,                               \
2514           &quot;List of inline classes which are forced to be atomic &quot;           \
2515           &quot;(whitespace and commas separate names, &quot;                         \
2516           &quot;and leading and trailing stars &#39;*&#39; are wildcards)&quot;)              \
2517                                                                             \
2518   product(bool, PrintNewLayout, false,                                      \
2519                &quot;Print layout compute by new algorithm&quot;)                     \
2520                                                                             \
2521   product(bool, PrintFlattenableLayouts, false,                             \
2522                 &quot;Print layout of inline classes and classes with &quot;          \
2523                 &quot;flattenable fields&quot;)                                       \
2524                                                                             \
2525   product(bool, UseNewFieldLayout, true,                                    \
2526                 &quot;(Deprecated) Use new algorithm to compute field layouts&quot;)  \
2527                                                                             \
2528   product(bool, UseEmptySlotsInSupers, true,                                \
2529                 &quot;Allow allocating fields in empty slots of super-classes&quot;)  \
2530                                                                             \
2531   diagnostic(bool, DeoptimizeNMethodBarriersALot, false,                    \
2532                 &quot;Make nmethod barriers deoptimise a lot.&quot;)                  \
2533 
2534 
2535 // Interface macros
2536 #define DECLARE_PRODUCT_FLAG(type, name, value, doc)      extern &quot;C&quot; type name;
2537 #define DECLARE_PD_PRODUCT_FLAG(type, name, doc)          extern &quot;C&quot; type name;
2538 #define DECLARE_DIAGNOSTIC_FLAG(type, name, value, doc)   extern &quot;C&quot; type name;
2539 #define DECLARE_PD_DIAGNOSTIC_FLAG(type, name, doc)       extern &quot;C&quot; type name;
2540 #define DECLARE_EXPERIMENTAL_FLAG(type, name, value, doc) extern &quot;C&quot; type name;
2541 #define DECLARE_MANAGEABLE_FLAG(type, name, value, doc)   extern &quot;C&quot; type name;
2542 #define DECLARE_PRODUCT_RW_FLAG(type, name, value, doc)   extern &quot;C&quot; type name;
2543 #ifdef PRODUCT
2544 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    const type name = value;
2545 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        const type name = pd_##name;
2546 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   const type name = value;
2547 #else
2548 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern &quot;C&quot; type name;
2549 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern &quot;C&quot; type name;
2550 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern &quot;C&quot; type name;
2551 #endif // PRODUCT
2552 // Special LP64 flags, product only needed for now.
2553 #ifdef _LP64
2554 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) extern &quot;C&quot; type name;
2555 #else
2556 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) const type name = value;
2557 #endif // _LP64
2558 
2559 ALL_FLAGS(DECLARE_DEVELOPER_FLAG,     \
2560           DECLARE_PD_DEVELOPER_FLAG,  \
2561           DECLARE_PRODUCT_FLAG,       \
2562           DECLARE_PD_PRODUCT_FLAG,    \
2563           DECLARE_DIAGNOSTIC_FLAG,    \
2564           DECLARE_PD_DIAGNOSTIC_FLAG, \
2565           DECLARE_EXPERIMENTAL_FLAG,  \
2566           DECLARE_NOTPRODUCT_FLAG,    \
2567           DECLARE_MANAGEABLE_FLAG,    \
2568           DECLARE_PRODUCT_RW_FLAG,    \
2569           DECLARE_LP64_PRODUCT_FLAG,  \
2570           IGNORE_RANGE,               \
2571           IGNORE_CONSTRAINT)
2572 
2573 #endif // SHARE_RUNTIME_GLOBALS_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
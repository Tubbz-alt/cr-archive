<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/synchronizer.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="synchronizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
128   static void release_monitors_owned_by_thread(TRAPS);
129   static void monitors_iterate(MonitorClosure* m);
130 
131   // GC: we current use aggressive monitor deflation policy
132   // Basically we deflate all monitors that are not busy.
133   // An adaptive profile-based deflation policy could be used if needed
134   static void deflate_idle_monitors(DeflateMonitorCounters* counters);
135   static void deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters);
136   static void prepare_deflate_idle_monitors(DeflateMonitorCounters* counters);
137   static void finish_deflate_idle_monitors(DeflateMonitorCounters* counters);
138 
139   // For a given monitor list: global or per-thread, deflate idle monitors
140   static int deflate_monitor_list(ObjectMonitor** list_p,
141                                   int* count_p,
142                                   ObjectMonitor** free_head_p,
143                                   ObjectMonitor** free_tail_p);
144   static bool deflate_monitor(ObjectMonitor* mid, oop obj,
145                               ObjectMonitor** free_head_p,
146                               ObjectMonitor** free_tail_p);
147   static bool is_cleanup_needed();
<span class="line-removed">148   static bool needs_monitor_scavenge();</span>
149   static void oops_do(OopClosure* f);
150   // Process oops in thread local used monitors
151   static void thread_local_used_oops_do(Thread* thread, OopClosure* f);
152 
153   // debugging
154   static void audit_and_print_stats(bool on_exit);
155   static void chk_free_entry(JavaThread* jt, ObjectMonitor* n,
156                              outputStream * out, int *error_cnt_p);
157   static void chk_global_free_list_and_count(outputStream * out,
158                                              int *error_cnt_p);
159   static void chk_global_in_use_list_and_count(outputStream * out,
160                                                int *error_cnt_p);
161   static void chk_in_use_entry(JavaThread* jt, ObjectMonitor* n,
162                                outputStream * out, int *error_cnt_p);
163   static void chk_per_thread_in_use_list_and_count(JavaThread *jt,
164                                                    outputStream * out,
165                                                    int *error_cnt_p);
166   static void chk_per_thread_free_list_and_count(JavaThread *jt,
167                                                  outputStream * out,
168                                                  int *error_cnt_p);
</pre>
</td>
<td>
<hr />
<pre>
128   static void release_monitors_owned_by_thread(TRAPS);
129   static void monitors_iterate(MonitorClosure* m);
130 
131   // GC: we current use aggressive monitor deflation policy
132   // Basically we deflate all monitors that are not busy.
133   // An adaptive profile-based deflation policy could be used if needed
134   static void deflate_idle_monitors(DeflateMonitorCounters* counters);
135   static void deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters);
136   static void prepare_deflate_idle_monitors(DeflateMonitorCounters* counters);
137   static void finish_deflate_idle_monitors(DeflateMonitorCounters* counters);
138 
139   // For a given monitor list: global or per-thread, deflate idle monitors
140   static int deflate_monitor_list(ObjectMonitor** list_p,
141                                   int* count_p,
142                                   ObjectMonitor** free_head_p,
143                                   ObjectMonitor** free_tail_p);
144   static bool deflate_monitor(ObjectMonitor* mid, oop obj,
145                               ObjectMonitor** free_head_p,
146                               ObjectMonitor** free_tail_p);
147   static bool is_cleanup_needed();

148   static void oops_do(OopClosure* f);
149   // Process oops in thread local used monitors
150   static void thread_local_used_oops_do(Thread* thread, OopClosure* f);
151 
152   // debugging
153   static void audit_and_print_stats(bool on_exit);
154   static void chk_free_entry(JavaThread* jt, ObjectMonitor* n,
155                              outputStream * out, int *error_cnt_p);
156   static void chk_global_free_list_and_count(outputStream * out,
157                                              int *error_cnt_p);
158   static void chk_global_in_use_list_and_count(outputStream * out,
159                                                int *error_cnt_p);
160   static void chk_in_use_entry(JavaThread* jt, ObjectMonitor* n,
161                                outputStream * out, int *error_cnt_p);
162   static void chk_per_thread_in_use_list_and_count(JavaThread *jt,
163                                                    outputStream * out,
164                                                    int *error_cnt_p);
165   static void chk_per_thread_free_list_and_count(JavaThread *jt,
166                                                  outputStream * out,
167                                                  int *error_cnt_p);
</pre>
</td>
</tr>
</table>
<center><a href="synchronizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="safepoint.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -807,11 +807,10 @@</span>
    volatile int hc_sequence;
    DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(volatile int));
  };
  
  static SharedGlobals GVars;
<span class="udiff-line-removed">- static int _forceMonitorScavenge = 0; // Scavenge required and pending</span>
  
  static markWord read_stable_mark(oop obj) {
    markWord mark = obj-&gt;mark();
    if (!mark.is_being_inflated()) {
      return mark;       // normal fast-path return
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1201,30 +1200,11 @@</span>
      return monitor_usage &gt; MonitorUsedDeflationThreshold;
    }
    return false;
  }
  
<span class="udiff-line-modified-removed">- // Returns true if MonitorBound is set (&gt; 0) and if the specified</span>
<span class="udiff-line-removed">- // cnt is &gt; MonitorBound. Otherwise returns false.</span>
<span class="udiff-line-removed">- static bool is_MonitorBound_exceeded(const int cnt) {</span>
<span class="udiff-line-removed">-   const int mx = MonitorBound;</span>
<span class="udiff-line-removed">-   return mx &gt; 0 &amp;&amp; cnt &gt; mx;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ObjectSynchronizer::is_cleanup_needed() {</span>
<span class="udiff-line-removed">-   if (monitors_used_above_threshold()) {</span>
<span class="udiff-line-removed">-     // Too many monitors in use.</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return needs_monitor_scavenge();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ObjectSynchronizer::needs_monitor_scavenge() {</span>
<span class="udiff-line-removed">-   if (Atomic::load(&amp;_forceMonitorScavenge) == 1) {</span>
<span class="udiff-line-removed">-     log_info(monitorinflation)(&quot;Monitor scavenge needed, triggering safepoint cleanup.&quot;);</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ bool ObjectSynchronizer::is_cleanup_needed() {</span>
    return monitors_used_above_threshold();
  }
  
  void ObjectSynchronizer::oops_do(OopClosure* f) {
    // We only scan the global used list here (for moribund threads), and
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1268,45 +1248,10 @@</span>
  // --   unassigned and on the om_list_globals._free_list
  // --   unassigned and on a per-thread free list
  // --   assigned to an object.  The object is inflated and the mark refers
  //      to the ObjectMonitor.
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Constraining monitor pool growth via MonitorBound ...</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // If MonitorBound is not set (&lt;= 0), MonitorBound checks are disabled.</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // The monitor pool is grow-only.  We scavenge at STW safepoint-time, but the</span>
<span class="udiff-line-removed">- // the rate of scavenging is driven primarily by GC.  As such,  we can find</span>
<span class="udiff-line-removed">- // an inordinate number of monitors in circulation.</span>
<span class="udiff-line-removed">- // To avoid that scenario we can artificially induce a STW safepoint</span>
<span class="udiff-line-removed">- // if the pool appears to be growing past some reasonable bound.</span>
<span class="udiff-line-removed">- // Generally we favor time in space-time tradeoffs, but as there&#39;s no</span>
<span class="udiff-line-removed">- // natural back-pressure on the # of extant monitors we need to impose some</span>
<span class="udiff-line-removed">- // type of limit.  Beware that if MonitorBound is set to too low a value</span>
<span class="udiff-line-removed">- // we could just loop. In addition, if MonitorBound is set to a low value</span>
<span class="udiff-line-removed">- // we&#39;ll incur more safepoints, which are harmful to performance.</span>
<span class="udiff-line-removed">- // See also: GuaranteedSafepointInterval</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // If MonitorBound is set, the boundry applies to</span>
<span class="udiff-line-removed">- //     (om_list_globals._population - om_list_globals._free_count)</span>
<span class="udiff-line-removed">- // i.e., if there are not enough ObjectMonitors on the global free list,</span>
<span class="udiff-line-removed">- // then a safepoint deflation is induced. Picking a good MonitorBound value</span>
<span class="udiff-line-removed">- // is non-trivial.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void InduceScavenge(Thread* self, const char * Whence) {</span>
<span class="udiff-line-removed">-   // Induce STW safepoint to trim monitors</span>
<span class="udiff-line-removed">-   // Ultimately, this results in a call to deflate_idle_monitors() in the near future.</span>
<span class="udiff-line-removed">-   // More precisely, trigger a cleanup safepoint as the number</span>
<span class="udiff-line-removed">-   // of active monitors passes the specified threshold.</span>
<span class="udiff-line-removed">-   // TODO: assert thread state is reasonable</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (Atomic::xchg(&amp;_forceMonitorScavenge, 1) == 0) {</span>
<span class="udiff-line-removed">-     VMThread::check_for_forced_cleanup();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  ObjectMonitor* ObjectSynchronizer::om_alloc(Thread* self) {
    // A large MAXPRIVATE value reduces both list lock contention
    // and list coherency traffic, but also tends to increase the
    // number of ObjectMonitors in circulation as well as the STW
    // scavenge costs.  As usual, we lean toward time in space-time
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1346,19 +1291,10 @@</span>
          take-&gt;Recycle();
          om_release(self, take, false);
        }
        self-&gt;om_free_provision += 1 + (self-&gt;om_free_provision / 2);
        if (self-&gt;om_free_provision &gt; MAXPRIVATE) self-&gt;om_free_provision = MAXPRIVATE;
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (is_MonitorBound_exceeded(Atomic::load(&amp;om_list_globals._population) -</span>
<span class="udiff-line-removed">-                                    Atomic::load(&amp;om_list_globals._free_count))) {</span>
<span class="udiff-line-removed">-         // Not enough ObjectMonitors on the global free list.</span>
<span class="udiff-line-removed">-         // We can&#39;t safely induce a STW safepoint from om_alloc() as our thread</span>
<span class="udiff-line-removed">-         // state may not be appropriate for such activities and callers may hold</span>
<span class="udiff-line-removed">-         // naked oops, so instead we defer the action.</span>
<span class="udiff-line-removed">-         InduceScavenge(self, &quot;om_alloc&quot;);</span>
<span class="udiff-line-removed">-       }</span>
        continue;
      }
  
      // 3: allocate a block of new ObjectMonitors
      // Both the local and global free lists are empty -- resort to malloc().
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2060,12 +1996,10 @@</span>
                                 Atomic::load(&amp;om_list_globals._population),
                                 Atomic::load(&amp;om_list_globals._in_use_count),
                                 Atomic::load(&amp;om_list_globals._free_count));
    }
  
<span class="udiff-line-removed">-   Atomic::store(&amp;_forceMonitorScavenge, 0);    // Reset</span>
<span class="udiff-line-removed">- </span>
    OM_PERFDATA_OP(Deflations, inc(counters-&gt;n_scavenged));
    OM_PERFDATA_OP(MonExtant, set_value(counters-&gt;n_in_circulation));
  
    GVars.stw_random = os::random();
    GVars.stw_cycle++;
</pre>
<center><a href="safepoint.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
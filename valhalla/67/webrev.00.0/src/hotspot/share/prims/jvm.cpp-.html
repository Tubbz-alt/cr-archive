<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/javaAssertions.hpp&quot;
  31 #include &quot;classfile/javaClasses.inline.hpp&quot;
  32 #include &quot;classfile/moduleEntry.hpp&quot;
  33 #include &quot;classfile/modules.hpp&quot;
  34 #include &quot;classfile/packageEntry.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/valueArrayKlass.hpp&quot;
  59 #include &quot;prims/jvm_misc.hpp&quot;
  60 #include &quot;prims/jvmtiExport.hpp&quot;
  61 #include &quot;prims/jvmtiThreadState.hpp&quot;
  62 #include &quot;prims/nativeLookup.hpp&quot;
  63 #include &quot;prims/stackwalk.hpp&quot;
  64 #include &quot;runtime/arguments.hpp&quot;
  65 #include &quot;runtime/atomic.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/init.hpp&quot;
  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  69 #include &quot;runtime/deoptimization.hpp&quot;
  70 #include &quot;runtime/handshake.hpp&quot;
  71 #include &quot;runtime/java.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/os.inline.hpp&quot;
  76 #include &quot;runtime/perfData.hpp&quot;
  77 #include &quot;runtime/reflection.hpp&quot;
  78 #include &quot;runtime/thread.inline.hpp&quot;
  79 #include &quot;runtime/threadSMR.hpp&quot;
  80 #include &quot;runtime/vframe.inline.hpp&quot;
  81 #include &quot;runtime/vmOperations.hpp&quot;
  82 #include &quot;runtime/vm_version.hpp&quot;
  83 #include &quot;services/attachListener.hpp&quot;
  84 #include &quot;services/management.hpp&quot;
  85 #include &quot;services/threadService.hpp&quot;
  86 #include &quot;utilities/copy.hpp&quot;
  87 #include &quot;utilities/defaultStream.hpp&quot;
  88 #include &quot;utilities/dtrace.hpp&quot;
  89 #include &quot;utilities/events.hpp&quot;
  90 #include &quot;utilities/histogram.hpp&quot;
  91 #include &quot;utilities/macros.hpp&quot;
  92 #include &quot;utilities/utf8.hpp&quot;
  93 #if INCLUDE_CDS
  94 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  95 #endif
  96 
  97 #include &lt;errno.h&gt;
  98 #include &lt;jfr/recorder/jfrRecorder.hpp&gt;
  99 
 100 /*
 101   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
 102   such ctors and calls MUST NOT come between an oop declaration/init and its
 103   usage because if objects are move this may cause various memory stomps, bus
 104   errors and segfaults. Here is a cookbook for causing so called &quot;naked oop
 105   failures&quot;:
 106 
 107       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
 108           JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
 109 
 110           // Object address to be held directly in mirror &amp; not visible to GC
 111           oop mirror = JNIHandles::resolve_non_null(ofClass);
 112 
 113           // If this ctor can hit a safepoint, moving objects around, then
 114           ComplexConstructor foo;
 115 
 116           // Boom! mirror may point to JUNK instead of the intended object
 117           (some dereference of mirror)
 118 
 119           // Here&#39;s another call that may block for GC, making mirror stale
 120           MutexLocker ml(some_lock);
 121 
 122           // And here&#39;s an initializer that can result in a stale oop
 123           // all in one step.
 124           oop o = call_that_can_throw_exception(TRAPS);
 125 
 126 
 127   The solution is to keep the oop declaration BELOW the ctor or function
 128   call that might cause a GC, do another resolve to reassign the oop, or
 129   consider use of a Handle instead of an oop so there is immunity from object
 130   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 131   and thus can only support use of handles passed in.
 132 */
 133 
 134 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 135   ResourceMark rm;
 136   int line_number = -1;
 137   const char * source_file = NULL;
 138   const char * trace = &quot;explicit&quot;;
 139   InstanceKlass* caller = NULL;
 140   JavaThread* jthread = JavaThread::current();
 141   if (jthread-&gt;has_last_Java_frame()) {
 142     vframeStream vfst(jthread);
 143 
 144     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 145     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);
 146     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 147     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);
 148     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 149 
 150     Method* last_caller = NULL;
 151 
 152     while (!vfst.at_end()) {
 153       Method* m = vfst.method();
 154       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 155           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 156           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 157         break;
 158       }
 159       last_caller = m;
 160       vfst.next();
 161     }
 162     // if this is called from Class.forName0 and that is called from Class.forName,
 163     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 164     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 165     bool found_it = false;
 166     if (!vfst.at_end() &amp;&amp;
 167         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 168         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 169       vfst.next();
 170       if (!vfst.at_end() &amp;&amp;
 171           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 172           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 173         vfst.next();
 174         found_it = true;
 175       }
 176     } else if (last_caller != NULL &amp;&amp;
 177                last_caller-&gt;method_holder()-&gt;name() ==
 178                  vmSymbols::java_lang_ClassLoader() &amp;&amp;
 179                last_caller-&gt;name() == vmSymbols::loadClass_name()) {
 180       found_it = true;
 181     } else if (!vfst.at_end()) {
 182       if (vfst.method()-&gt;is_native()) {
 183         // JNI call
 184         found_it = true;
 185       }
 186     }
 187     if (found_it &amp;&amp; !vfst.at_end()) {
 188       // found the caller
 189       caller = vfst.method()-&gt;method_holder();
 190       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 191       if (line_number == -1) {
 192         // show method name if it&#39;s a native method
 193         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 194       }
 195       Symbol* s = caller-&gt;source_file_name();
 196       if (s != NULL) {
 197         source_file = s-&gt;as_C_string();
 198       }
 199     }
 200   }
 201   if (caller != NULL) {
 202     if (to_class != caller) {
 203       const char * from = caller-&gt;external_name();
 204       const char * to = to_class-&gt;external_name();
 205       // print in a single call to reduce interleaving between threads
 206       if (source_file != NULL) {
 207         log_debug(class, resolve)(&quot;%s %s %s:%d (%s)&quot;, from, to, source_file, line_number, trace);
 208       } else {
 209         log_debug(class, resolve)(&quot;%s %s (%s)&quot;, from, to, trace);
 210       }
 211     }
 212   }
 213 }
 214 
 215 void trace_class_resolution(Klass* to_class) {
 216   EXCEPTION_MARK;
 217   trace_class_resolution_impl(to_class, THREAD);
 218   if (HAS_PENDING_EXCEPTION) {
 219     CLEAR_PENDING_EXCEPTION;
 220   }
 221 }
 222 
 223 // Wrapper to trace JVM functions
 224 
 225 #ifdef ASSERT
 226   Histogram* JVMHistogram;
 227   volatile int JVMHistogram_lock = 0;
 228 
 229   class JVMHistogramElement : public HistogramElement {
 230     public:
 231      JVMHistogramElement(const char* name);
 232   };
 233 
 234   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 235     _name = elementName;
 236     uintx count = 0;
 237 
 238     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {
 239       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {
 240         count +=1;
 241         if ( (WarnOnStalledSpinLock &gt; 0)
 242           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 243           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 244         }
 245       }
 246      }
 247 
 248     if(JVMHistogram == NULL)
 249       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 250 
 251     JVMHistogram-&gt;add_element(this);
 252     Atomic::dec(&amp;JVMHistogram_lock);
 253   }
 254 
 255   #define JVMCountWrapper(arg) \
 256       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 257       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 258 
 259   #define JVMWrapper(arg) JVMCountWrapper(arg);
 260 #else
 261   #define JVMWrapper(arg)
 262 #endif
 263 
 264 
 265 // Interface version /////////////////////////////////////////////////////////////////////
 266 
 267 
 268 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 269   return JVM_INTERFACE_VERSION;
 270 JVM_END
 271 
 272 
 273 // java.lang.System //////////////////////////////////////////////////////////////////////
 274 
 275 
 276 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 277   JVMWrapper(&quot;JVM_CurrentTimeMillis&quot;);
 278   return os::javaTimeMillis();
 279 JVM_END
 280 
 281 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 282   JVMWrapper(&quot;JVM_NanoTime&quot;);
 283   return os::javaTimeNanos();
 284 JVM_END
 285 
 286 // The function below is actually exposed by jdk.internal.misc.VM and not
 287 // java.lang.System, but we choose to keep it here so that it stays next
 288 // to JVM_CurrentTimeMillis and JVM_NanoTime
 289 
 290 const jlong MAX_DIFF_SECS = CONST64(0x0100000000); //  2^32
 291 const jlong MIN_DIFF_SECS = -MAX_DIFF_SECS; // -2^32
 292 
 293 JVM_LEAF(jlong, JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs))
 294   JVMWrapper(&quot;JVM_GetNanoTimeAdjustment&quot;);
 295   jlong seconds;
 296   jlong nanos;
 297 
 298   os::javaTimeSystemUTC(seconds, nanos);
 299 
 300   // We&#39;re going to verify that the result can fit in a long.
 301   // For that we need the difference in seconds between &#39;seconds&#39;
 302   // and &#39;offset_secs&#39; to be such that:
 303   //     |seconds - offset_secs| &lt; (2^63/10^9)
 304   // We&#39;re going to approximate 10^9 ~&lt; 2^30 (1000^3 ~&lt; 1024^3)
 305   // which makes |seconds - offset_secs| &lt; 2^33
 306   // and we will prefer +/- 2^32 as the maximum acceptable diff
 307   // as 2^32 has a more natural feel than 2^33...
 308   //
 309   // So if |seconds - offset_secs| &gt;= 2^32 - we return a special
 310   // sentinel value (-1) which the caller should take as an
 311   // exception value indicating that the offset given to us is
 312   // too far from range of the current time - leading to too big
 313   // a nano adjustment. The caller is expected to recover by
 314   // computing a more accurate offset and calling this method
 315   // again. (For the record 2^32 secs is ~136 years, so that
 316   // should rarely happen)
 317   //
 318   jlong diff = seconds - offset_secs;
 319   if (diff &gt;= MAX_DIFF_SECS || diff &lt;= MIN_DIFF_SECS) {
 320      return -1; // sentinel value: the offset is too far off the target
 321   }
 322 
 323   // return the adjustment. If you compute a time by adding
 324   // this number of nanoseconds along with the number of seconds
 325   // in the offset you should get the current UTC time.
 326   return (diff * (jlong)1000000000) + nanos;
 327 JVM_END
 328 
 329 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 330                                jobject dst, jint dst_pos, jint length))
 331   JVMWrapper(&quot;JVM_ArrayCopy&quot;);
 332   // Check if we have null pointers
 333   if (src == NULL || dst == NULL) {
 334     THROW(vmSymbols::java_lang_NullPointerException());
 335   }
 336   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 337   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 338   assert(oopDesc::is_oop(s), &quot;JVM_ArrayCopy: src not an oop&quot;);
 339   assert(oopDesc::is_oop(d), &quot;JVM_ArrayCopy: dst not an oop&quot;);
 340   // Do copy
 341   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 342 JVM_END
 343 
 344 
 345 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 346   JavaValue r(T_OBJECT);
 347   // public synchronized Object put(Object key, Object value);
 348   HandleMark hm(THREAD);
 349   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 350   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK);
 351   JavaCalls::call_virtual(&amp;r,
 352                           props,
 353                           SystemDictionary::Properties_klass(),
 354                           vmSymbols::put_name(),
 355                           vmSymbols::object_object_object_signature(),
 356                           key_str,
 357                           value_str,
 358                           THREAD);
 359 }
 360 
 361 
 362 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 363 
 364 /*
 365  * Return all of the system properties in a Java String array with alternating
 366  * names and values from the jvm SystemProperty.
 367  * Which includes some internal and all commandline -D defined properties.
 368  */
 369 JVM_ENTRY(jobjectArray, JVM_GetProperties(JNIEnv *env))
 370   JVMWrapper(&quot;JVM_GetProperties&quot;);
 371   ResourceMark rm(THREAD);
 372   HandleMark hm(THREAD);
 373   int ndx = 0;
 374   int fixedCount = 2;
 375 
 376   SystemProperty* p = Arguments::system_properties();
 377   int count = Arguments::PropertyList_count(p);
 378 
 379   // Allocate result String array
 380   InstanceKlass* ik = SystemDictionary::String_klass();
 381   objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);
 382   objArrayHandle result_h(THREAD, r);
 383 
 384   while (p != NULL) {
 385     const char * key = p-&gt;key();
 386     if (strcmp(key, &quot;sun.nio.MaxDirectMemorySize&quot;) != 0) {
 387         const char * value = p-&gt;value();
 388         Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);
 389         Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK_NULL);
 390         result_h-&gt;obj_at_put(ndx * 2,  key_str());
 391         result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 392         ndx++;
 393     }
 394     p = p-&gt;next();
 395   }
 396 
 397   // Convert the -XX:MaxDirectMemorySize= command line flag
 398   // to the sun.nio.MaxDirectMemorySize property.
 399   // Do this after setting user properties to prevent people
 400   // from setting the value with a -D option, as requested.
 401   // Leave empty if not supplied
 402   if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 403     char as_chars[256];
 404     jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);
 405     Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.nio.MaxDirectMemorySize&quot;, CHECK_NULL);
 406     Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);
 407     result_h-&gt;obj_at_put(ndx * 2,  key_str());
 408     result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 409     ndx++;
 410   }
 411 
 412   // JVM monitoring and management support
 413   // Add the sun.management.compiler property for the compiler&#39;s name
 414   {
 415 #undef CSIZE
 416 #if defined(_LP64) || defined(_WIN64)
 417   #define CSIZE &quot;64-Bit &quot;
 418 #else
 419   #define CSIZE
 420 #endif // 64bit
 421 
 422 #ifdef TIERED
 423     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Tiered Compilers&quot;;
 424 #else
 425 #if defined(COMPILER1)
 426     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Client Compiler&quot;;
 427 #elif defined(COMPILER2)
 428     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Server Compiler&quot;;
 429 #elif INCLUDE_JVMCI
 430     #error &quot;INCLUDE_JVMCI should imply TIERED&quot;
 431 #else
 432     const char* compiler_name = &quot;&quot;;
 433 #endif // compilers
 434 #endif // TIERED
 435 
 436     if (*compiler_name != &#39;\0&#39; &amp;&amp;
 437         (Arguments::mode() != Arguments::_int)) {
 438       Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.management.compiler&quot;, CHECK_NULL);
 439       Handle value_str  = java_lang_String::create_from_platform_dependent_str(compiler_name, CHECK_NULL);
 440       result_h-&gt;obj_at_put(ndx * 2,  key_str());
 441       result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 442       ndx++;
 443     }
 444   }
 445 
 446   return (jobjectArray) JNIHandles::make_local(env, result_h());
 447 JVM_END
 448 
 449 
 450 /*
 451  * Return the temporary directory that the VM uses for the attach
 452  * and perf data files.
 453  *
 454  * It is important that this directory is well-known and the
 455  * same for all VM instances. It cannot be affected by configuration
 456  * variables such as java.io.tmpdir.
 457  */
 458 JVM_ENTRY(jstring, JVM_GetTemporaryDirectory(JNIEnv *env))
 459   JVMWrapper(&quot;JVM_GetTemporaryDirectory&quot;);
 460   HandleMark hm(THREAD);
 461   const char* temp_dir = os::get_temp_directory();
 462   Handle h = java_lang_String::create_from_platform_dependent_str(temp_dir, CHECK_NULL);
 463   return (jstring) JNIHandles::make_local(env, h());
 464 JVM_END
 465 
 466 
 467 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 468 
 469 extern volatile jint vm_created;
 470 
 471 JVM_ENTRY_NO_ENV(void, JVM_BeforeHalt())
 472   JVMWrapper(&quot;JVM_BeforeHalt&quot;);
 473   // Link all classes for dynamic CDS dumping before vm exit.
 474   if (DynamicDumpSharedSpaces) {
 475     MetaspaceShared::link_and_cleanup_shared_classes(THREAD);
 476   }
 477   EventShutdown event;
 478   if (event.should_commit()) {
 479     event.set_reason(&quot;Shutdown requested from Java&quot;);
 480     event.commit();
 481   }
 482 JVM_END
 483 
 484 
 485 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 486   before_exit(thread);
 487   vm_exit(code);
 488 JVM_END
 489 
 490 
 491 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 492   JVMWrapper(&quot;JVM_GC&quot;);
 493   if (!DisableExplicitGC) {
 494     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 495   }
 496 JVM_END
 497 
 498 
 499 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 500   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 501   return Universe::heap()-&gt;millis_since_last_gc();
 502 JVM_END
 503 
 504 
 505 static inline jlong convert_size_t_to_jlong(size_t val) {
 506   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 507   NOT_LP64 (return (jlong)val;)
 508   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 509 }
 510 
 511 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 512   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 513   size_t n = Universe::heap()-&gt;capacity();
 514   return convert_size_t_to_jlong(n);
 515 JVM_END
 516 
 517 
 518 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 519   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 520   size_t n = Universe::heap()-&gt;unused();
 521   return convert_size_t_to_jlong(n);
 522 JVM_END
 523 
 524 
 525 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 526   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 527   size_t n = Universe::heap()-&gt;max_capacity();
 528   return convert_size_t_to_jlong(n);
 529 JVM_END
 530 
 531 
 532 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 533   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 534   return os::active_processor_count();
 535 JVM_END
 536 
 537 
 538 
 539 // java.lang.Throwable //////////////////////////////////////////////////////
 540 
 541 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 542   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 543   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 544   java_lang_Throwable::fill_in_stack_trace(exception);
 545 JVM_END
 546 
 547 // java.lang.NullPointerException ///////////////////////////////////////////
 548 
 549 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 550   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 551 
 552   oop exc = JNIHandles::resolve_non_null(throwable);
 553 
 554   Method* method;
 555   int bci;
 556   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 557     return NULL;
 558   }
 559   if (method-&gt;is_native()) {
 560     return NULL;
 561   }
 562 
 563   stringStream ss;
 564   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);
 565   if (ok) {
 566     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_NULL);
 567     return (jstring) JNIHandles::make_local(env, result);
 568   } else {
 569     return NULL;
 570   }
 571 JVM_END
 572 
 573 // java.lang.StackTraceElement //////////////////////////////////////////////
 574 
 575 
 576 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 577   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 578   Handle exception(THREAD, JNIHandles::resolve(throwable));
 579   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 580   objArrayHandle stack_trace(THREAD, st);
 581   // Fill in the allocated stack trace
 582   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 583 JVM_END
 584 
 585 
 586 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 587   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 588   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 589   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 590   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 591 JVM_END
 592 
 593 
 594 // java.lang.StackWalker //////////////////////////////////////////////////////
 595 
 596 
 597 JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 598                                      jint skip_frames, jint frame_count, jint start_index,
 599                                      jobjectArray frames))
 600   JVMWrapper(&quot;JVM_CallStackWalk&quot;);
 601   JavaThread* jt = (JavaThread*) THREAD;
 602   if (!jt-&gt;is_Java_thread() || !jt-&gt;has_last_Java_frame()) {
 603     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;doStackWalk: no stack trace&quot;, NULL);
 604   }
 605 
 606   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 607 
 608   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 609   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 610   // be null.
 611   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 612   objArrayHandle frames_array_h(THREAD, fa);
 613 
 614   int limit = start_index + frame_count;
 615   if (frames_array_h-&gt;length() &lt; limit) {
 616     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;, NULL);
 617   }
 618 
 619   oop result = StackWalk::walk(stackStream_h, mode, skip_frames, frame_count,
 620                                start_index, frames_array_h, CHECK_NULL);
 621   return JNIHandles::make_local(env, result);
 622 JVM_END
 623 
 624 
 625 JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 626                                   jint frame_count, jint start_index,
 627                                   jobjectArray frames))
 628   JVMWrapper(&quot;JVM_MoreStackWalk&quot;);
 629   JavaThread* jt = (JavaThread*) THREAD;
 630 
 631   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 632   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 633   // be null.
 634   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 635   objArrayHandle frames_array_h(THREAD, fa);
 636 
 637   int limit = start_index+frame_count;
 638   if (frames_array_h-&gt;length() &lt; limit) {
 639     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 640   }
 641 
 642   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 643   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 644                                    start_index, frames_array_h, THREAD);
 645 JVM_END
 646 
 647 // java.lang.Object ///////////////////////////////////////////////
 648 
 649 
 650 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 651   JVMWrapper(&quot;JVM_IHashCode&quot;);
 652   // as implemented in the classic virtual machine; return 0 if object is NULL
 653   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 654 JVM_END
 655 
 656 
 657 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 658   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 659   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 660   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 661   if (JvmtiExport::should_post_monitor_wait()) {
 662     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 663 
 664     // The current thread already owns the monitor and it has not yet
 665     // been added to the wait queue so the current thread cannot be
 666     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 667     // event handler cannot accidentally consume an unpark() meant for
 668     // the ParkEvent associated with this ObjectMonitor.
 669   }
 670   ObjectSynchronizer::wait(obj, ms, CHECK);
 671 JVM_END
 672 
 673 
 674 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 675   JVMWrapper(&quot;JVM_MonitorNotify&quot;);
 676   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 677   ObjectSynchronizer::notify(obj, CHECK);
 678 JVM_END
 679 
 680 
 681 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 682   JVMWrapper(&quot;JVM_MonitorNotifyAll&quot;);
 683   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 684   ObjectSynchronizer::notifyall(obj, CHECK);
 685 JVM_END
 686 
 687 
 688 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 689   JVMWrapper(&quot;JVM_Clone&quot;);
 690   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 691   Klass* klass = obj-&gt;klass();
 692   JvmtiVMObjectAllocEventCollector oam;
 693 
 694 #ifdef ASSERT
 695   // Just checking that the cloneable flag is set correct
 696   if (obj-&gt;is_array()) {
 697     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 698   } else {
 699     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 700     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 701     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 702   }
 703 #endif
 704 
 705   // Check if class of obj supports the Cloneable interface.
 706   // All arrays are considered to be cloneable (See JLS 20.1.5).
 707   // All j.l.r.Reference classes are considered non-cloneable.
 708   if (!klass-&gt;is_cloneable() ||
 709        klass-&gt;is_value() ||
 710       (klass-&gt;is_instance_klass() &amp;&amp;
 711        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 712     ResourceMark rm(THREAD);
 713     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 714   }
 715 
 716   // Make shallow object copy
 717   const int size = obj-&gt;size();
 718   oop new_obj_oop = NULL;
 719   if (obj-&gt;is_array()) {
 720     const int length = ((arrayOop)obj())-&gt;length();
 721     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 722                                                    /* do_zero */ true, CHECK_NULL);
 723   } else {
 724     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 725   }
 726 
 727   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 728 
 729   Handle new_obj(THREAD, new_obj_oop);
 730   // Caution: this involves a java upcall, so the clone should be
 731   // &quot;gc-robust&quot; by this stage.
 732   if (klass-&gt;has_finalizer()) {
 733     assert(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 734     new_obj_oop = InstanceKlass::register_finalizer(instanceOop(new_obj()), CHECK_NULL);
 735     new_obj = Handle(THREAD, new_obj_oop);
 736   }
 737 
 738   return JNIHandles::make_local(env, new_obj());
 739 JVM_END
 740 
 741 // java.io.File ///////////////////////////////////////////////////////////////
 742 
 743 JVM_LEAF(char*, JVM_NativePath(char* path))
 744   JVMWrapper(&quot;JVM_NativePath&quot;);
 745   return os::native_path(path);
 746 JVM_END
 747 
 748 
 749 // Misc. class handling ///////////////////////////////////////////////////////////
 750 
 751 
 752 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env))
 753   JVMWrapper(&quot;JVM_GetCallerClass&quot;);
 754 
 755   // Getting the class of the caller frame.
 756   //
 757   // The call stack at this point looks something like this:
 758   //
 759   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 760   // [1] [ @CallerSensitive API.method                                   ]
 761   // [.] [ (skipped intermediate frames)                                 ]
 762   // [n] [ caller                                                        ]
 763   vframeStream vfst(thread);
 764   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 765   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 766     Method* m = vfst.method();
 767     assert(m != NULL, &quot;sanity&quot;);
 768     switch (n) {
 769     case 0:
 770       // This must only be called from Reflection.getCallerClass
 771       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 772         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&quot;);
 773       }
 774       // fall-through
 775     case 1:
 776       // Frame 0 and 1 must be caller sensitive.
 777       if (!m-&gt;caller_sensitive()) {
 778         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 779       }
 780       break;
 781     default:
 782       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 783         // We have reached the desired frame; return the holder class.
 784         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 785       }
 786       break;
 787     }
 788   }
 789   return NULL;
 790 JVM_END
 791 
 792 
 793 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 794   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 795   oop mirror = NULL;
 796   BasicType t = name2type(utf);
 797   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {
 798     mirror = Universe::java_mirror(t);
 799   }
 800   if (mirror == NULL) {
 801     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 802   } else {
 803     return (jclass) JNIHandles::make_local(env, mirror);
 804   }
 805 JVM_END
 806 
 807 
 808 // Returns a class loaded by the bootstrap class loader; or null
 809 // if not found.  ClassNotFoundException is not thrown.
 810 // FindClassFromBootLoader is exported to the launcher for windows.
 811 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 812                                               const char* name))
 813   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 814 
 815   // Java libraries should ensure that name is never null...
 816   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 817     // It&#39;s impossible to create this class;  the name cannot fit
 818     // into the constant pool.
 819     return NULL;
 820   }
 821 
 822   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 823   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 824   if (k == NULL) {
 825     return NULL;
 826   }
 827 
 828   if (log_is_enabled(Debug, class, resolve)) {
 829     trace_class_resolution(k);
 830   }
 831   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 832 JVM_END
 833 
 834 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 835 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 836                                           jboolean init, jobject loader,
 837                                           jclass caller))
 838   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 839   // Java libraries should ensure that name is never null...
 840   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 841     // It&#39;s impossible to create this class;  the name cannot fit
 842     // into the constant pool.
 843     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
 844   }
 845 
 846   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 847 
 848   oop loader_oop = JNIHandles::resolve(loader);
 849   oop from_class = JNIHandles::resolve(caller);
 850   oop protection_domain = NULL;
 851   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 852   // NPE. Put it in another way, the bootstrap class loader has all permission and
 853   // thus no checkPackageAccess equivalence in the VM class loader.
 854   // The caller is also passed as NULL by the java code if there is no security
 855   // manager to avoid the performance cost of getting the calling class.
 856   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 857     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 858   }
 859 
 860   Handle h_loader(THREAD, loader_oop);
 861   Handle h_prot(THREAD, protection_domain);
 862   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 863                                                h_prot, false, THREAD);
 864 
 865   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 866     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 867   }
 868   return result;
 869 JVM_END
 870 
 871 // Currently only called from the old verifier.
 872 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 873                                          jboolean init, jclass from))
 874   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 875   if (name == NULL) {
 876     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 877   }
 878   if ((int)strlen(name) &gt; Symbol::max_length()) {
 879     // It&#39;s impossible to create this class;  the name cannot fit
 880     // into the constant pool.
 881     Exceptions::fthrow(THREAD_AND_LOCATION,
 882                        vmSymbols::java_lang_NoClassDefFoundError(),
 883                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 884                        Symbol::max_length(),
 885                        name);
 886     return 0;
 887   }
 888   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 889   oop from_class_oop = JNIHandles::resolve(from);
 890   Klass* from_class = (from_class_oop == NULL)
 891                            ? (Klass*)NULL
 892                            : java_lang_Class::as_Klass(from_class_oop);
 893   oop class_loader = NULL;
 894   oop protection_domain = NULL;
 895   if (from_class != NULL) {
 896     class_loader = from_class-&gt;class_loader();
 897     protection_domain = from_class-&gt;protection_domain();
 898   }
 899   Handle h_loader(THREAD, class_loader);
 900   Handle h_prot  (THREAD, protection_domain);
 901   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 902                                                h_prot, true, thread);
 903 
 904   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 905     // this function is generally only used for class loading during verification.
 906     ResourceMark rm;
 907     oop from_mirror = JNIHandles::resolve_non_null(from);
 908     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 909     const char * from_name = from_class-&gt;external_name();
 910 
 911     oop mirror = JNIHandles::resolve_non_null(result);
 912     Klass* to_class = java_lang_Class::as_Klass(mirror);
 913     const char * to = to_class-&gt;external_name();
 914     log_debug(class, resolve)(&quot;%s %s (verification)&quot;, from_name, to);
 915   }
 916 
 917   return result;
 918 JVM_END
 919 
 920 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 921   if (loader.is_null()) {
 922     return;
 923   }
 924 
 925   // check whether the current caller thread holds the lock or not.
 926   // If not, increment the corresponding counter
 927   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 928       ObjectSynchronizer::owner_self) {
 929     counter-&gt;inc();
 930   }
 931 }
 932 
 933 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 934 static jclass jvm_define_class_common(JNIEnv *env, const char *name,
 935                                       jobject loader, const jbyte *buf,
 936                                       jsize len, jobject pd, const char *source,
 937                                       TRAPS) {
 938   if (source == NULL)  source = &quot;__JVM_DefineClass__&quot;;
 939 
 940   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 941   JavaThread* jt = (JavaThread*) THREAD;
 942 
 943   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 944                              ClassLoader::perf_define_appclass_selftime(),
 945                              ClassLoader::perf_define_appclasses(),
 946                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 947                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 948                              PerfClassTraceTime::DEFINE_CLASS);
 949 
 950   if (UsePerfData) {
 951     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 952   }
 953 
 954   // Since exceptions can be thrown, class initialization can take place
 955   // if name is NULL no check for class name in .class stream has to be made.
 956   TempNewSymbol class_name = NULL;
 957   if (name != NULL) {
 958     const int str_len = (int)strlen(name);
 959     if (str_len &gt; Symbol::max_length()) {
 960       // It&#39;s impossible to create this class;  the name cannot fit
 961       // into the constant pool.
 962       Exceptions::fthrow(THREAD_AND_LOCATION,
 963                          vmSymbols::java_lang_NoClassDefFoundError(),
 964                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 965                          Symbol::max_length(),
 966                          name);
 967       return 0;
 968     }
 969     class_name = SymbolTable::new_symbol(name, str_len);
 970   }
 971 
 972   ResourceMark rm(THREAD);
 973   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 974   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 975   if (UsePerfData) {
 976     is_lock_held_by_thread(class_loader,
 977                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 978                            THREAD);
 979   }
 980   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 981   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 982                                                    class_loader,
 983                                                    protection_domain,
 984                                                    &amp;st,
 985                                                    CHECK_NULL);
 986 
 987   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 988     trace_class_resolution(k);
 989   }
 990 
 991   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 992 }
 993 
 994 enum {
 995   NESTMATE              = java_lang_invoke_MemberName::MN_NESTMATE_CLASS,
 996   HIDDEN_CLASS          = java_lang_invoke_MemberName::MN_HIDDEN_CLASS,
 997   STRONG_LOADER_LINK    = java_lang_invoke_MemberName::MN_STRONG_LOADER_LINK,
 998   ACCESS_VM_ANNOTATIONS = java_lang_invoke_MemberName::MN_ACCESS_VM_ANNOTATIONS
 999 };
1000 
1001 /*
1002  * Define a class with the specified flags that indicates if it&#39;s a nestmate,
1003  * hidden, or strongly referenced from class loader.
1004  */
1005 static jclass jvm_lookup_define_class(JNIEnv *env, jclass lookup, const char *name,
1006                                       const jbyte *buf, jsize len, jobject pd,
1007                                       jboolean init, int flags, jobject classData, TRAPS) {
1008   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1009   JavaThread* jt = (JavaThread*) THREAD;
1010   ResourceMark rm(THREAD);
1011 
1012   Klass* lookup_k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(lookup));
1013   // Lookup class must be a non-null instance
1014   if (lookup_k == NULL) {
1015     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
1016   }
1017   assert(lookup_k-&gt;is_instance_klass(), &quot;Lookup class must be an instance klass&quot;);
1018 
1019   Handle class_loader (THREAD, lookup_k-&gt;class_loader());
1020 
1021   bool is_nestmate = (flags &amp; NESTMATE) == NESTMATE;
1022   bool is_hidden = (flags &amp; HIDDEN_CLASS) == HIDDEN_CLASS;
1023   bool is_strong = (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK;
1024   bool vm_annotations = (flags &amp; ACCESS_VM_ANNOTATIONS) == ACCESS_VM_ANNOTATIONS;
1025 
1026   InstanceKlass* host_class = NULL;
1027   if (is_nestmate) {
1028     host_class = InstanceKlass::cast(lookup_k)-&gt;nest_host(CHECK_NULL);
1029   }
1030 
1031   log_info(class, nestmates)(&quot;LookupDefineClass: %s - %s%s, %s, %s, %s&quot;,
1032                              name,
1033                              is_nestmate ? &quot;with dynamic nest-host &quot; : &quot;non-nestmate&quot;,
1034                              is_nestmate ? host_class-&gt;external_name() : &quot;&quot;,
1035                              is_hidden ? &quot;hidden&quot; : &quot;not hidden&quot;,
1036                              is_strong ? &quot;strong&quot; : &quot;weak&quot;,
1037                              vm_annotations ? &quot;with vm annotations&quot; : &quot;without vm annotation&quot;);
1038 
1039   if (!is_hidden) {
1040     // classData is only applicable for hidden classes
1041     if (classData != NULL) {
1042       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;classData is only applicable for hidden classes&quot;);
1043     }
1044     if (is_nestmate) {
1045       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;dynamic nestmate is only applicable for hidden classes&quot;);
1046     }
1047     if (!is_strong) {
1048       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;an ordinary class must be strongly referenced by its defining loader&quot;);
1049     }
1050     if (vm_annotations) {
1051       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;vm annotations only allowed for hidden classes&quot;);
1052     }
1053     if (flags != STRONG_LOADER_LINK) {
1054       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1055                   err_msg(&quot;invalid flag 0x%x&quot;, flags));
1056     }
1057   }
1058 
1059 
1060   // Since exceptions can be thrown, class initialization can take place
1061   // if name is NULL no check for class name in .class stream has to be made.
1062   TempNewSymbol class_name = NULL;
1063   if (name != NULL) {
1064     const int str_len = (int)strlen(name);
1065     if (str_len &gt; Symbol::max_length()) {
1066       // It&#39;s impossible to create this class;  the name cannot fit
1067       // into the constant pool.
1068       Exceptions::fthrow(THREAD_AND_LOCATION,
1069                          vmSymbols::java_lang_NoClassDefFoundError(),
1070                          &quot;Class name exceeds maximum length of %d: %s&quot;,
1071                          Symbol::max_length(),
1072                          name);
1073       return 0;
1074     }
1075     class_name = SymbolTable::new_symbol(name, str_len);
1076   }
1077 
1078   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
1079   const char* source = is_nestmate ? host_class-&gt;external_name() : &quot;__JVM_LookupDefineClass__&quot;;
1080   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
1081 
1082   Klass* defined_k;
1083   InstanceKlass* ik = NULL;
1084   if (!is_hidden) {
1085     defined_k = SystemDictionary::resolve_from_stream(class_name,
1086                                                       class_loader,
1087                                                       protection_domain,
1088                                                       &amp;st,
1089                                                       CHECK_NULL);
1090 
1091     if (log_is_enabled(Debug, class, resolve) &amp;&amp; defined_k != NULL) {
1092       trace_class_resolution(defined_k);
1093     }
1094     ik = InstanceKlass::cast(defined_k);
1095   } else { // hidden
1096     Handle classData_h(THREAD, JNIHandles::resolve(classData));
1097     ClassLoadInfo cl_info(protection_domain,
1098                           NULL, // unsafe_anonymous_host
1099                           NULL, // cp_patches
1100                           host_class,
1101                           classData_h,
1102                           is_hidden,
1103                           is_strong,
1104                           vm_annotations);
1105     defined_k = SystemDictionary::parse_stream(class_name,
1106                                                class_loader,
1107                                                &amp;st,
1108                                                cl_info,
1109                                                CHECK_NULL);
1110     if (defined_k == NULL) {
1111       THROW_MSG_0(vmSymbols::java_lang_Error(), &quot;Failure to define a hidden class&quot;);
1112     }
1113 
1114     ik = InstanceKlass::cast(defined_k);
1115 
1116     // The hidden class loader data has been artificially been kept alive to
1117     // this point. The mirror and any instances of this class have to keep
1118     // it alive afterwards.
1119     ik-&gt;class_loader_data()-&gt;dec_keep_alive();
1120 
1121     if (is_nestmate &amp;&amp; log_is_enabled(Debug, class, nestmates)) {
1122       ModuleEntry* module = ik-&gt;module();
1123       const char * module_name = module-&gt;is_named() ? module-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
1124       log_debug(class, nestmates)(&quot;Dynamic nestmate: %s/%s, nest_host %s, %s&quot;,
1125                                   module_name,
1126                                   ik-&gt;external_name(),
1127                                   host_class-&gt;external_name(),
1128                                   ik-&gt;is_hidden() ? &quot;is hidden&quot; : &quot;is not hidden&quot;);
1129     }
1130   }
1131   assert(Reflection::is_same_class_package(lookup_k, defined_k),
1132          &quot;lookup class and defined class are in different packages&quot;);
1133 
1134   if (init) {
1135     ik-&gt;initialize(CHECK_NULL);
1136   } else {
1137     ik-&gt;link_class(CHECK_NULL);
1138   }
1139 
1140   return (jclass) JNIHandles::make_local(env, defined_k-&gt;java_mirror());
1141 }
1142 
1143 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
1144   JVMWrapper(&quot;JVM_DefineClass&quot;);
1145 
1146   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
1147 JVM_END
1148 
1149 /*
1150  * Define a class with the specified lookup class.
1151  *  lookup:  Lookup class
1152  *  name:    the name of the class
1153  *  buf:     class bytes
1154  *  len:     length of class bytes
1155  *  pd:      protection domain
1156  *  init:    initialize the class
1157  *  flags:   properties of the class
1158  *  classData: private static pre-initialized field
1159  */
1160 JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
1161           jsize len, jobject pd, jboolean initialize, int flags, jobject classData))
1162   JVMWrapper(&quot;JVM_LookupDefineClass&quot;);
1163 
1164   if (lookup == NULL) {
1165     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
1166   }
1167 
1168   assert(buf != NULL, &quot;buf must not be NULL&quot;);
1169 
1170   return jvm_lookup_define_class(env, lookup, name, buf, len, pd, initialize, flags, classData, THREAD);
1171 JVM_END
1172 
1173 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
1174   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
1175 
1176   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
1177 JVM_END
1178 
1179 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1180   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1181   ResourceMark rm(THREAD);
1182 
1183   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
1184   char* str = java_lang_String::as_utf8_string(h_name());
1185 
1186   // Sanity check, don&#39;t expect null
1187   if (str == NULL) return NULL;
1188 
1189   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.
1190   char* p = (char*)str;
1191   while (*p != &#39;\0&#39;) {
1192       if (*p == &#39;.&#39;) {
1193           *p = &#39;/&#39;;
1194       }
1195       p++;
1196   }
1197 
1198   const int str_len = (int)(p - str);
1199   if (str_len &gt; Symbol::max_length()) {
1200     // It&#39;s impossible to create this class;  the name cannot fit
1201     // into the constant pool.
1202     return NULL;
1203   }
1204   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);
1205 
1206   // Security Note:
1207   //   The Java level wrapper will perform the necessary security check allowing
1208   //   us to pass the NULL as the initiating class loader.
1209   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1210   if (UsePerfData) {
1211     is_lock_held_by_thread(h_loader,
1212                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1213                            THREAD);
1214   }
1215 
1216   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1217                                                               h_loader,
1218                                                               Handle(),
1219                                                               CHECK_NULL);
1220 #if INCLUDE_CDS
1221   if (k == NULL) {
1222     // If the class is not already loaded, try to see if it&#39;s in the shared
1223     // archive for the current classloader (h_loader).
1224     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
1225   }
1226 #endif
1227   return (k == NULL) ? NULL :
1228             (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1229 JVM_END
1230 
1231 // Module support //////////////////////////////////////////////////////////////////////////////
1232 
1233 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
1234                                  jstring location, jobjectArray packages))
1235   JVMWrapper(&quot;JVM_DefineModule&quot;);
1236   Modules::define_module(module, is_open, version, location, packages, CHECK);
1237 JVM_END
1238 
1239 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
1240   JVMWrapper(&quot;JVM_SetBootLoaderUnnamedModule&quot;);
1241   Modules::set_bootloader_unnamed_module(module, CHECK);
1242 JVM_END
1243 
1244 JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module))
1245   JVMWrapper(&quot;JVM_AddModuleExports&quot;);
1246   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1247 JVM_END
1248 
1249 JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package))
1250   JVMWrapper(&quot;JVM_AddModuleExportsToAllUnnamed&quot;);
1251   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
1252 JVM_END
1253 
1254 JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package))
1255   JVMWrapper(&quot;JVM_AddModuleExportsToAll&quot;);
1256   Modules::add_module_exports(from_module, package, NULL, CHECK);
1257 JVM_END
1258 
1259 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
1260   JVMWrapper(&quot;JVM_AddReadsModule&quot;);
1261   Modules::add_reads_module(from_module, source_module, CHECK);
1262 JVM_END
1263 
1264 // Reflection support //////////////////////////////////////////////////////////////////////////////
1265 
1266 JVM_ENTRY(jstring, JVM_InitClassName(JNIEnv *env, jclass cls))
1267   assert (cls != NULL, &quot;illegal class&quot;);
1268   JVMWrapper(&quot;JVM_InitClassName&quot;);
1269   JvmtiVMObjectAllocEventCollector oam;
1270   ResourceMark rm(THREAD);
1271   HandleMark hm(THREAD);
1272   Handle java_class(THREAD, JNIHandles::resolve(cls));
1273   oop result = java_lang_Class::name(java_class, CHECK_NULL);
1274   return (jstring) JNIHandles::make_local(env, result);
1275 JVM_END
1276 
1277 
1278 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1279   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1280   JvmtiVMObjectAllocEventCollector oam;
1281   oop mirror = JNIHandles::resolve_non_null(cls);
1282 
1283   // Special handling for primitive objects
1284   if (java_lang_Class::is_primitive(mirror)) {
1285     // Primitive objects does not have any interfaces
1286     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1287     return (jobjectArray) JNIHandles::make_local(env, r);
1288   }
1289 
1290   Klass* klass = java_lang_Class::as_Klass(mirror);
1291   // Figure size of result array
1292   int size;
1293   if (klass-&gt;is_instance_klass()) {
1294     InstanceKlass* ik = InstanceKlass::cast(klass);
1295     size = ik-&gt;local_interfaces()-&gt;length();
1296     if (ik-&gt;has_injected_identityObject()) {
1297       size--;
1298     }
1299   } else {
1300     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
1301     size = 3;
1302   }
1303 
1304   // Allocate result array
1305   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1306   objArrayHandle result (THREAD, r);
1307   // Fill in result
1308   if (klass-&gt;is_instance_klass()) {
1309     // Regular instance klass, fill in all local interfaces
1310     int cursor = 0;
1311     for (int index = 0; index &lt; size; index++) {
1312       InstanceKlass* ik = InstanceKlass::cast(klass);
1313       Klass* k = ik-&gt;local_interfaces()-&gt;at(index);
1314       if (!ik-&gt;has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {
1315         result-&gt;obj_at_put(cursor++, k-&gt;java_mirror());
1316       }
1317     }
1318   } else {
1319     // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject
1320     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1321     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1322     result-&gt;obj_at_put(2, SystemDictionary::IdentityObject_klass()-&gt;java_mirror());
1323   }
1324   return (jobjectArray) JNIHandles::make_local(env, result());
1325 JVM_END
1326 
1327 
1328 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1329   JVMWrapper(&quot;JVM_IsInterface&quot;);
1330   oop mirror = JNIHandles::resolve_non_null(cls);
1331   if (java_lang_Class::is_primitive(mirror)) {
1332     return JNI_FALSE;
1333   }
1334   Klass* k = java_lang_Class::as_Klass(mirror);
1335   jboolean result = k-&gt;is_interface();
1336   assert(!result || k-&gt;is_instance_klass(),
1337          &quot;all interfaces are instance types&quot;);
1338   // The compiler intrinsic for isInterface tests the
1339   // Klass::_access_flags bits in the same way.
1340   return result;
1341 JVM_END
1342 
1343 JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))
1344   JVMWrapper(&quot;JVM_IsHiddenClass&quot;);
1345   oop mirror = JNIHandles::resolve_non_null(cls);
1346   if (java_lang_Class::is_primitive(mirror)) {
1347     return JNI_FALSE;
1348   }
1349   Klass* k = java_lang_Class::as_Klass(mirror);
1350   return k-&gt;is_hidden();
1351 JVM_END
1352 
1353 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1354   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1355   JvmtiVMObjectAllocEventCollector oam;
1356   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1357     // There are no signers for primitive types
1358     return NULL;
1359   }
1360 
1361   objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));
1362 
1363   // If there are no signers set in the class, or if the class
1364   // is an array, return NULL.
1365   if (signers == NULL) return NULL;
1366 
1367   // copy of the signers array
1368   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1369   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1370   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1371     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1372   }
1373 
1374   // return the copy
1375   return (jobjectArray) JNIHandles::make_local(env, signers_copy);
1376 JVM_END
1377 
1378 
1379 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1380   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
1381   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1382     // This call is ignored for primitive types and arrays.
1383     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1384     // be called with an array.  Only the bootstrap loader creates arrays.
1385     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1386     if (k-&gt;is_instance_klass()) {
1387       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1388     }
1389   }
1390 JVM_END
1391 
1392 
1393 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1394   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
1395   if (JNIHandles::resolve(cls) == NULL) {
1396     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1397   }
1398 
1399   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1400     // Primitive types does not have a protection domain.
1401     return NULL;
1402   }
1403 
1404   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
1405   return (jobject) JNIHandles::make_local(env, pd);
1406 JVM_END
1407 
1408 
1409 // Returns the inherited_access_control_context field of the running thread.
1410 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1411   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1412   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1413   return JNIHandles::make_local(env, result);
1414 JVM_END
1415 
1416 class RegisterArrayForGC {
1417  private:
1418   JavaThread *_thread;
1419  public:
1420   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1421     _thread = thread;
1422     _thread-&gt;register_array_for_gc(array);
1423   }
1424 
1425   ~RegisterArrayForGC() {
1426     _thread-&gt;register_array_for_gc(NULL);
1427   }
1428 };
1429 
1430 
1431 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1432   JVMWrapper(&quot;JVM_GetStackAccessControlContext&quot;);
1433   if (!UsePrivilegedStack) return NULL;
1434 
1435   ResourceMark rm(THREAD);
1436   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1437   JvmtiVMObjectAllocEventCollector oam;
1438 
1439   // count the protection domains on the execution stack. We collapse
1440   // duplicate consecutive protection domains into a single one, as
1441   // well as stopping when we hit a privileged frame.
1442 
1443   oop previous_protection_domain = NULL;
1444   Handle privileged_context(thread, NULL);
1445   bool is_privileged = false;
1446   oop protection_domain = NULL;
1447 
1448   // Iterate through Java frames
1449   vframeStream vfst(thread);
1450   for(; !vfst.at_end(); vfst.next()) {
1451     // get method of frame
1452     Method* method = vfst.method();
1453 
1454     // stop at the first privileged frame
1455     if (method-&gt;method_holder() == SystemDictionary::AccessController_klass() &amp;&amp;
1456       method-&gt;name() == vmSymbols::executePrivileged_name())
1457     {
1458       // this frame is privileged
1459       is_privileged = true;
1460 
1461       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1462 
1463       StackValueCollection* locals = priv-&gt;locals();
1464       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1465       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1466       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1467       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1468       privileged_context    = ctx_sv-&gt;get_obj();
1469       Handle caller         = clr_sv-&gt;get_obj();
1470 
1471       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1472       protection_domain  = caller_klass-&gt;protection_domain();
1473     } else {
1474       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1475     }
1476 
1477     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1478       local_array-&gt;push(protection_domain);
1479       previous_protection_domain = protection_domain;
1480     }
1481 
1482     if (is_privileged) break;
1483   }
1484 
1485 
1486   // either all the domains on the stack were system domains, or
1487   // we had a privileged system domain
1488   if (local_array-&gt;is_empty()) {
1489     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1490 
1491     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1492     return JNIHandles::make_local(env, result);
1493   }
1494 
1495   // the resource area must be registered in case of a gc
1496   RegisterArrayForGC ragc(thread, local_array);
1497   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1498                                                  local_array-&gt;length(), CHECK_NULL);
1499   objArrayHandle h_context(thread, context);
1500   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1501     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1502   }
1503 
1504   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1505 
1506   return JNIHandles::make_local(env, result);
1507 JVM_END
1508 
1509 
1510 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1511   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1512   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1513   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1514 JVM_END
1515 
1516 
1517 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1518   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1519   oop mirror = JNIHandles::resolve_non_null(cls);
1520   return (jboolean) java_lang_Class::is_primitive(mirror);
1521 JVM_END
1522 
1523 
1524 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1525   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1526   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1527     // Primitive type
1528     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1529   }
1530 
1531   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1532   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1533   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1534   return k-&gt;modifier_flags();
1535 JVM_END
1536 
1537 
1538 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1539 
1540 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1541   JvmtiVMObjectAllocEventCollector oam;
1542   // ofClass is a reference to a java_lang_Class object. The mirror object
1543   // of an InstanceKlass
1544 
1545   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1546       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1547     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1548     return (jobjectArray)JNIHandles::make_local(env, result);
1549   }
1550 
1551   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1552   InnerClassesIterator iter(k);
1553 
1554   if (iter.length() == 0) {
1555     // Neither an inner nor outer class
1556     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1557     return (jobjectArray)JNIHandles::make_local(env, result);
1558   }
1559 
1560   // find inner class info
1561   constantPoolHandle cp(thread, k-&gt;constants());
1562   int length = iter.length();
1563 
1564   // Allocate temp. result array
1565   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1566   objArrayHandle result (THREAD, r);
1567   int members = 0;
1568 
1569   for (; !iter.done(); iter.next()) {
1570     int ioff = iter.inner_class_info_index();
1571     int ooff = iter.outer_class_info_index();
1572 
1573     if (ioff != 0 &amp;&amp; ooff != 0) {
1574       // Check to see if the name matches the class we&#39;re looking for
1575       // before attempting to find the class.
1576       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1577         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1578         if (outer_klass == k) {
1579            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1580            InstanceKlass* inner_klass = InstanceKlass::cast(ik);
1581 
1582            // Throws an exception if outer klass has not declared k as
1583            // an inner klass
1584            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1585 
1586            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1587            members++;
1588         }
1589       }
1590     }
1591   }
1592 
1593   if (members != length) {
1594     // Return array of right length
1595     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1596     for(int i = 0; i &lt; members; i++) {
1597       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1598     }
1599     return (jobjectArray)JNIHandles::make_local(env, res);
1600   }
1601 
1602   return (jobjectArray)JNIHandles::make_local(env, result());
1603 JVM_END
1604 
1605 
1606 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1607 {
1608   // ofClass is a reference to a java_lang_Class object.
1609   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1610       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1611     return NULL;
1612   }
1613 
1614   bool inner_is_member = false;
1615   Klass* outer_klass
1616     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
1617                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);
1618   if (outer_klass == NULL)  return NULL;  // already a top-level class
1619   if (!inner_is_member)  return NULL;     // a hidden or unsafe anonymous class (inside a method)
1620   return (jclass) JNIHandles::make_local(env, outer_klass-&gt;java_mirror());
1621 }
1622 JVM_END
1623 
1624 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1625 {
1626   oop mirror = JNIHandles::resolve_non_null(cls);
1627   if (java_lang_Class::is_primitive(mirror) ||
1628       !java_lang_Class::as_Klass(mirror)-&gt;is_instance_klass()) {
1629     return NULL;
1630   }
1631   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1632   int ooff = 0, noff = 0;
1633   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1634     if (noff != 0) {
1635       constantPoolHandle i_cp(thread, k-&gt;constants());
1636       Symbol* name = i_cp-&gt;symbol_at(noff);
1637       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1638       return (jstring) JNIHandles::make_local(env, str());
1639     }
1640   }
1641   return NULL;
1642 }
1643 JVM_END
1644 
1645 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1646   assert (cls != NULL, &quot;illegal class&quot;);
1647   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1648   JvmtiVMObjectAllocEventCollector oam;
1649   ResourceMark rm(THREAD);
1650   // Return null for arrays and primatives
1651   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1652     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1653     if (k-&gt;is_instance_klass()) {
1654       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1655       if (sym == NULL) return NULL;
1656       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1657       return (jstring) JNIHandles::make_local(env, str());
1658     }
1659   }
1660   return NULL;
1661 JVM_END
1662 
1663 
1664 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1665   assert (cls != NULL, &quot;illegal class&quot;);
1666   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
1667 
1668   // Return null for arrays and primitives
1669   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1670     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1671     if (k-&gt;is_instance_klass()) {
1672       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1673       return (jbyteArray) JNIHandles::make_local(env, a);
1674     }
1675   }
1676   return NULL;
1677 JVM_END
1678 
1679 
1680 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1681   // some of this code was adapted from from jni_FromReflectedField
1682 
1683   oop reflected = JNIHandles::resolve_non_null(field);
1684   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1685   Klass* k    = java_lang_Class::as_Klass(mirror);
1686   int slot      = java_lang_reflect_Field::slot(reflected);
1687   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1688 
1689   InstanceKlass* ik = InstanceKlass::cast(k);
1690   intptr_t offset = ik-&gt;field_offset(slot);
1691 
1692   if (modifiers &amp; JVM_ACC_STATIC) {
1693     // for static fields we only look in the current class
1694     if (!ik-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1695       assert(false, &quot;cannot find static field&quot;);
1696       return false;
1697     }
1698   } else {
1699     // for instance fields we start with the current class and work
1700     // our way up through the superclass chain
1701     if (!ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1702       assert(false, &quot;cannot find instance field&quot;);
1703       return false;
1704     }
1705   }
1706   return true;
1707 }
1708 
1709 static Method* jvm_get_method_common(jobject method) {
1710   // some of this code was adapted from from jni_FromReflectedMethod
1711 
1712   oop reflected = JNIHandles::resolve_non_null(method);
1713   oop mirror    = NULL;
1714   int slot      = 0;
1715 
1716   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1717     mirror = java_lang_reflect_Constructor::clazz(reflected);
1718     slot   = java_lang_reflect_Constructor::slot(reflected);
1719   } else {
1720     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1721            &quot;wrong type&quot;);
1722     mirror = java_lang_reflect_Method::clazz(reflected);
1723     slot   = java_lang_reflect_Method::slot(reflected);
1724   }
1725   Klass* k = java_lang_Class::as_Klass(mirror);
1726 
1727   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1728   assert(m != NULL, &quot;cannot find method&quot;);
1729   return m;  // caller has to deal with NULL in product mode
1730 }
1731 
1732 /* Type use annotations support (JDK 1.8) */
1733 
1734 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1735   assert (cls != NULL, &quot;illegal class&quot;);
1736   JVMWrapper(&quot;JVM_GetClassTypeAnnotations&quot;);
1737   ResourceMark rm(THREAD);
1738   // Return null for arrays and primitives
1739   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1740     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1741     if (k-&gt;is_instance_klass()) {
1742       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1743       if (type_annotations != NULL) {
1744         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1745         return (jbyteArray) JNIHandles::make_local(env, a);
1746       }
1747     }
1748   }
1749   return NULL;
1750 JVM_END
1751 
1752 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1753   assert (method != NULL, &quot;illegal method&quot;);
1754   JVMWrapper(&quot;JVM_GetMethodTypeAnnotations&quot;);
1755 
1756   // method is a handle to a java.lang.reflect.Method object
1757   Method* m = jvm_get_method_common(method);
1758   if (m == NULL) {
1759     return NULL;
1760   }
1761 
1762   AnnotationArray* type_annotations = m-&gt;type_annotations();
1763   if (type_annotations != NULL) {
1764     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1765     return (jbyteArray) JNIHandles::make_local(env, a);
1766   }
1767 
1768   return NULL;
1769 JVM_END
1770 
1771 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1772   assert (field != NULL, &quot;illegal field&quot;);
1773   JVMWrapper(&quot;JVM_GetFieldTypeAnnotations&quot;);
1774 
1775   fieldDescriptor fd;
1776   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1777   if (!gotFd) {
1778     return NULL;
1779   }
1780 
1781   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));
1782 JVM_END
1783 
1784 static void bounds_check(const constantPoolHandle&amp; cp, jint index, TRAPS) {
1785   if (!cp-&gt;is_within_bounds(index)) {
1786     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool index out of bounds&quot;);
1787   }
1788 }
1789 
1790 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1791 {
1792   JVMWrapper(&quot;JVM_GetMethodParameters&quot;);
1793   // method is a handle to a java.lang.reflect.Method object
1794   Method* method_ptr = jvm_get_method_common(method);
1795   methodHandle mh (THREAD, method_ptr);
1796   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1797   const int num_params = mh-&gt;method_parameters_length();
1798 
1799   if (num_params &lt; 0) {
1800     // A -1 return value from method_parameters_length means there is no
1801     // parameter data.  Return null to indicate this to the reflection
1802     // API.
1803     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1804     return (jobjectArray)NULL;
1805   } else {
1806     // Otherwise, we return something up to reflection, even if it is
1807     // a zero-length array.  Why?  Because in some cases this can
1808     // trigger a MalformedParametersException.
1809 
1810     // make sure all the symbols are properly formatted
1811     for (int i = 0; i &lt; num_params; i++) {
1812       MethodParametersElement* params = mh-&gt;method_parameters_start();
1813       int index = params[i].name_cp_index;
1814       constantPoolHandle cp(THREAD, mh-&gt;constants());
1815       bounds_check(cp, index, CHECK_NULL);
1816 
1817       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1818         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1819                     &quot;Wrong type at constant pool index&quot;);
1820       }
1821 
1822     }
1823 
1824     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1825     objArrayHandle result (THREAD, result_oop);
1826 
1827     for (int i = 0; i &lt; num_params; i++) {
1828       MethodParametersElement* params = mh-&gt;method_parameters_start();
1829       // For a 0 index, give a NULL symbol
1830       Symbol* sym = 0 != params[i].name_cp_index ?
1831         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1832       int flags = params[i].flags;
1833       oop param = Reflection::new_parameter(reflected_method, i, sym,
1834                                             flags, CHECK_NULL);
1835       result-&gt;obj_at_put(i, param);
1836     }
1837     return (jobjectArray)JNIHandles::make_local(env, result());
1838   }
1839 }
1840 JVM_END
1841 
1842 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1843 
1844 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1845 {
1846   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1847   JvmtiVMObjectAllocEventCollector oam;
1848 
1849   // Exclude primitive types and array types
1850   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1851       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1852     // Return empty array
1853     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1854     return (jobjectArray) JNIHandles::make_local(env, res);
1855   }
1856 
1857   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1858   constantPoolHandle cp(THREAD, k-&gt;constants());
1859 
1860   // Ensure class is linked
1861   k-&gt;link_class(CHECK_NULL);
1862 
1863   // Allocate result
1864   int num_fields;
1865 
1866   if (publicOnly) {
1867     num_fields = 0;
1868     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1869       if (fs.access_flags().is_public()) ++num_fields;
1870     }
1871   } else {
1872     num_fields = k-&gt;java_fields_count();
1873   }
1874 
1875   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1876   objArrayHandle result (THREAD, r);
1877 
1878   int out_idx = 0;
1879   fieldDescriptor fd;
1880   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1881     if (!publicOnly || fs.access_flags().is_public()) {
1882       fd.reinitialize(k, fs.index());
1883       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1884       result-&gt;obj_at_put(out_idx, field);
1885       ++out_idx;
1886     }
1887   }
1888   assert(out_idx == num_fields, &quot;just checking&quot;);
1889   return (jobjectArray) JNIHandles::make_local(env, result());
1890 }
1891 JVM_END
1892 
1893 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))
1894 {
1895   JVMWrapper(&quot;JVM_IsRecord&quot;);
1896   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1897   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
1898     InstanceKlass* ik = InstanceKlass::cast(k);
1899     return ik-&gt;is_record();
1900   } else {
1901     return false;
1902   }
1903 }
1904 JVM_END
1905 
1906 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))
1907 {
1908   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);
1909   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));
1910   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1911   InstanceKlass* ik = InstanceKlass::cast(c);
1912 
1913   if (ik-&gt;is_record()) {
1914     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();
1915     assert(components != NULL, &quot;components should not be NULL&quot;);
1916     {
1917       JvmtiVMObjectAllocEventCollector oam;
1918       constantPoolHandle cp(THREAD, ik-&gt;constants());
1919       int length = components-&gt;length();
1920       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);
1921       objArrayOop record_components =
1922         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1923       objArrayHandle components_h (THREAD, record_components);
1924 
1925       for (int x = 0; x &lt; length; x++) {
1926         RecordComponent* component = components-&gt;at(x);
1927         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1928         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1929         components_h-&gt;obj_at_put(x, component_oop);
1930       }
1931       return (jobjectArray)JNIHandles::make_local(components_h());
1932     }
1933   }
1934 
1935   // Return empty array if ofClass is not a record.
1936   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1937   return (jobjectArray)JNIHandles::make_local(env, result);
1938 }
1939 JVM_END
1940 
1941 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1942   bool is_ctor = (method-&gt;is_object_constructor() ||
1943                   method-&gt;is_static_init_factory());
1944   if (want_constructor) {
1945     return is_ctor;
1946   } else {
1947     return (!is_ctor &amp;&amp;
1948             !method-&gt;is_class_initializer() &amp;&amp;
1949             !method-&gt;is_overpass());
1950   }
1951 }
1952 
1953 static jobjectArray get_class_declared_methods_helper(
1954                                   JNIEnv *env,
1955                                   jclass ofClass, jboolean publicOnly,
1956                                   bool want_constructor,
1957                                   Klass* klass, TRAPS) {
1958 
1959   JvmtiVMObjectAllocEventCollector oam;
1960 
1961   // Exclude primitive types and array types
1962   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1963       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1964     // Return empty array
1965     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1966     return (jobjectArray) JNIHandles::make_local(env, res);
1967   }
1968 
1969   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1970 
1971   // Ensure class is linked
1972   k-&gt;link_class(CHECK_NULL);
1973 
1974   Array&lt;Method*&gt;* methods = k-&gt;methods();
1975   int methods_length = methods-&gt;length();
1976 
1977   // Save original method_idnum in case of redefinition, which can change
1978   // the idnum of obsolete methods.  The new method will have the same idnum
1979   // but if we refresh the methods array, the counts will be wrong.
1980   ResourceMark rm(THREAD);
1981   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1982   int num_methods = 0;
1983 
1984   for (int i = 0; i &lt; methods_length; i++) {
1985     methodHandle method(THREAD, methods-&gt;at(i));
1986     if (select_method(method, want_constructor)) {
1987       if (!publicOnly || method-&gt;is_public()) {
1988         idnums-&gt;push(method-&gt;method_idnum());
1989         ++num_methods;
1990       }
1991     }
1992   }
1993 
1994   // Allocate result
1995   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1996   objArrayHandle result (THREAD, r);
1997 
1998   // Now just put the methods that we selected above, but go by their idnum
1999   // in case of redefinition.  The methods can be redefined at any safepoint,
2000   // so above when allocating the oop array and below when creating reflect
2001   // objects.
2002   for (int i = 0; i &lt; num_methods; i++) {
2003     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
2004     if (method.is_null()) {
2005       // Method may have been deleted and seems this API can handle null
2006       // Otherwise should probably put a method that throws NSME
2007       result-&gt;obj_at_put(i, NULL);
2008     } else {
2009       oop m;
2010       if (want_constructor) {
2011         assert(method-&gt;is_object_constructor() ||
2012                method-&gt;is_static_init_factory(), &quot;must be&quot;);
2013         m = Reflection::new_constructor(method, CHECK_NULL);
2014       } else {
2015         m = Reflection::new_method(method, false, CHECK_NULL);
2016       }
2017       result-&gt;obj_at_put(i, m);
2018     }
2019   }
2020 
2021   return (jobjectArray) JNIHandles::make_local(env, result());
2022 }
2023 
2024 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2025 {
2026   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
2027   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2028                                            /*want_constructor*/ false,
2029                                            SystemDictionary::reflect_Method_klass(), THREAD);
2030 }
2031 JVM_END
2032 
2033 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2034 {
2035   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
2036   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2037                                            /*want_constructor*/ true,
2038                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
2039 }
2040 JVM_END
2041 
2042 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
2043 {
2044   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
2045   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
2046     // Primitive type
2047     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
2048   }
2049 
2050   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2051   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
2052 }
2053 JVM_END
2054 
2055 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
2056 {
2057   JVMWrapper(&quot;JVM_AreNestMates&quot;);
2058   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2059   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2060   InstanceKlass* ck = InstanceKlass::cast(c);
2061   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
2062   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
2063   InstanceKlass* mk = InstanceKlass::cast(m);
2064   return ck-&gt;has_nestmate_access_to(mk, THREAD);
2065 }
2066 JVM_END
2067 
2068 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
2069 {
2070   // current is not a primitive or array class
2071   JVMWrapper(&quot;JVM_GetNestHost&quot;);
2072   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2073   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2074   InstanceKlass* ck = InstanceKlass::cast(c);
2075   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2076   return (jclass) (host == NULL ? NULL :
2077                    JNIHandles::make_local(THREAD, host-&gt;java_mirror()));
2078 }
2079 JVM_END
2080 
2081 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
2082 {
2083   // current is not a primitive or array class
2084   JVMWrapper(&quot;JVM_GetNestMembers&quot;);
2085   ResourceMark rm(THREAD);
2086   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2087   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2088   InstanceKlass* ck = InstanceKlass::cast(c);
2089   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2090 
2091   log_trace(class, nestmates)(&quot;Calling GetNestMembers for type %s with nest-host %s&quot;,
2092                               ck-&gt;external_name(), host-&gt;external_name());
2093   {
2094     JvmtiVMObjectAllocEventCollector oam;
2095     Array&lt;u2&gt;* members = host-&gt;nest_members();
2096     int length = members == NULL ? 0 : members-&gt;length();
2097 
2098     log_trace(class, nestmates)(&quot; - host has %d listed nest members&quot;, length);
2099 
2100     // nest host is first in the array so make it one bigger
2101     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2102                                              length + 1, CHECK_NULL);
2103     objArrayHandle result(THREAD, r);
2104     result-&gt;obj_at_put(0, host-&gt;java_mirror());
2105     if (length != 0) {
2106       int count = 0;
2107       for (int i = 0; i &lt; length; i++) {
2108         int cp_index = members-&gt;at(i);
2109         Klass* k = host-&gt;constants()-&gt;klass_at(cp_index, THREAD);
2110         if (HAS_PENDING_EXCEPTION) {
2111           if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass())) {
2112             return NULL; // propagate VMEs
2113           }
2114           if (log_is_enabled(Trace, class, nestmates)) {
2115             stringStream ss;
2116             char* target_member_class = host-&gt;constants()-&gt;klass_name_at(cp_index)-&gt;as_C_string();
2117             ss.print(&quot; - resolution of nest member %s failed: &quot;, target_member_class);
2118             java_lang_Throwable::print(PENDING_EXCEPTION, &amp;ss);
2119             log_trace(class, nestmates)(&quot;%s&quot;, ss.as_string());
2120           }
2121           CLEAR_PENDING_EXCEPTION;
2122           continue;
2123         }
2124         if (k-&gt;is_instance_klass()) {
2125           InstanceKlass* ik = InstanceKlass::cast(k);
2126           InstanceKlass* nest_host_k = ik-&gt;nest_host(CHECK_NULL);
2127           if (nest_host_k == host) {
2128             result-&gt;obj_at_put(count+1, k-&gt;java_mirror());
2129             count++;
2130             log_trace(class, nestmates)(&quot; - [%d] = %s&quot;, count, ik-&gt;external_name());
2131           } else {
2132             log_trace(class, nestmates)(&quot; - skipping member %s with different host %s&quot;,
2133                                         ik-&gt;external_name(), nest_host_k-&gt;external_name());
2134           }
2135         } else {
2136           log_trace(class, nestmates)(&quot; - skipping member %s that is not an instance class&quot;,
2137                                       k-&gt;external_name());
2138         }
2139       }
2140       if (count &lt; length) {
2141         // we had invalid entries so we need to compact the array
2142         log_trace(class, nestmates)(&quot; - compacting array from length %d to %d&quot;,
2143                                     length + 1, count + 1);
2144 
2145         objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2146                                                   count + 1, CHECK_NULL);
2147         objArrayHandle result2(THREAD, r2);
2148         for (int i = 0; i &lt; count + 1; i++) {
2149           result2-&gt;obj_at_put(i, result-&gt;obj_at(i));
2150         }
2151         return (jobjectArray)JNIHandles::make_local(THREAD, result2());
2152       }
2153     }
2154     else {
2155       assert(host == ck || ck-&gt;is_hidden(), &quot;must be singleton nest or dynamic nestmate&quot;);
2156     }
2157     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2158   }
2159 }
2160 JVM_END
2161 
2162 // Constant pool access //////////////////////////////////////////////////////////
2163 
2164 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
2165 {
2166   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
2167   JvmtiVMObjectAllocEventCollector oam;
2168 
2169   // Return null for primitives and arrays
2170   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
2171     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2172     if (k-&gt;is_instance_klass()) {
2173       InstanceKlass* k_h = InstanceKlass::cast(k);
2174       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
2175       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
2176       return JNIHandles::make_local(jcp());
2177     }
2178   }
2179   return NULL;
2180 }
2181 JVM_END
2182 
2183 
2184 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
2185 {
2186   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
2187   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2188   return cp-&gt;length();
2189 }
2190 JVM_END
2191 
2192 
2193 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2194 {
2195   JVMWrapper(&quot;JVM_ConstantPoolGetClassAt&quot;);
2196   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2197   bounds_check(cp, index, CHECK_NULL);
2198   constantTag tag = cp-&gt;tag_at(index);
2199   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2200     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2201   }
2202   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
2203   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2204 }
2205 JVM_END
2206 
2207 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2208 {
2209   JVMWrapper(&quot;JVM_ConstantPoolGetClassAtIfLoaded&quot;);
2210   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2211   bounds_check(cp, index, CHECK_NULL);
2212   constantTag tag = cp-&gt;tag_at(index);
2213   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2214     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2215   }
2216   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2217   if (k == NULL) return NULL;
2218   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2219 }
2220 JVM_END
2221 
2222 static jobject get_method_at_helper(const constantPoolHandle&amp; cp, jint index, bool force_resolution, TRAPS) {
2223   constantTag tag = cp-&gt;tag_at(index);
2224   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2225     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2226   }
2227   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2228   Klass* k_o;
2229   if (force_resolution) {
2230     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2231   } else {
2232     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2233     if (k_o == NULL) return NULL;
2234   }
2235   InstanceKlass* k = InstanceKlass::cast(k_o);
2236   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2237   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2238   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2239   if (m.is_null()) {
2240     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2241   }
2242   oop method;
2243   if (m-&gt;is_object_constructor()) {
2244     method = Reflection::new_constructor(m, CHECK_NULL);
2245   } else {
2246     method = Reflection::new_method(m, true, CHECK_NULL);
2247   }
2248   return JNIHandles::make_local(method);
2249 }
2250 
2251 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2252 {
2253   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2254   JvmtiVMObjectAllocEventCollector oam;
2255   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2256   bounds_check(cp, index, CHECK_NULL);
2257   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2258   return res;
2259 }
2260 JVM_END
2261 
2262 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2263 {
2264   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2265   JvmtiVMObjectAllocEventCollector oam;
2266   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2267   bounds_check(cp, index, CHECK_NULL);
2268   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2269   return res;
2270 }
2271 JVM_END
2272 
2273 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2274   constantTag tag = cp-&gt;tag_at(index);
2275   if (!tag.is_field()) {
2276     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2277   }
2278   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2279   Klass* k_o;
2280   if (force_resolution) {
2281     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2282   } else {
2283     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2284     if (k_o == NULL) return NULL;
2285   }
2286   InstanceKlass* k = InstanceKlass::cast(k_o);
2287   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2288   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2289   fieldDescriptor fd;
2290   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2291   if (target_klass == NULL) {
2292     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up field in target class&quot;);
2293   }
2294   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2295   return JNIHandles::make_local(field);
2296 }
2297 
2298 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2299 {
2300   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAt&quot;);
2301   JvmtiVMObjectAllocEventCollector oam;
2302   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2303   bounds_check(cp, index, CHECK_NULL);
2304   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2305   return res;
2306 }
2307 JVM_END
2308 
2309 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2310 {
2311   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAtIfLoaded&quot;);
2312   JvmtiVMObjectAllocEventCollector oam;
2313   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2314   bounds_check(cp, index, CHECK_NULL);
2315   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2316   return res;
2317 }
2318 JVM_END
2319 
2320 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2321 {
2322   JVMWrapper(&quot;JVM_ConstantPoolGetMemberRefInfoAt&quot;);
2323   JvmtiVMObjectAllocEventCollector oam;
2324   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2325   bounds_check(cp, index, CHECK_NULL);
2326   constantTag tag = cp-&gt;tag_at(index);
2327   if (!tag.is_field_or_method()) {
2328     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2329   }
2330   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2331   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2332   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2333   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2334   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2335   objArrayHandle dest(THREAD, dest_o);
2336   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2337   dest-&gt;obj_at_put(0, str());
2338   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2339   dest-&gt;obj_at_put(1, str());
2340   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2341   dest-&gt;obj_at_put(2, str());
2342   return (jobjectArray) JNIHandles::make_local(dest());
2343 }
2344 JVM_END
2345 
2346 JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2347 {
2348   JVMWrapper(&quot;JVM_ConstantPoolGetClassRefIndexAt&quot;);
2349   JvmtiVMObjectAllocEventCollector oam;
2350   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2351   bounds_check(cp, index, CHECK_0);
2352   constantTag tag = cp-&gt;tag_at(index);
2353   if (!tag.is_field_or_method()) {
2354     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2355   }
2356   return (jint) cp-&gt;uncached_klass_ref_index_at(index);
2357 }
2358 JVM_END
2359 
2360 JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2361 {
2362   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefIndexAt&quot;);
2363   JvmtiVMObjectAllocEventCollector oam;
2364   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2365   bounds_check(cp, index, CHECK_0);
2366   constantTag tag = cp-&gt;tag_at(index);
2367   if (!tag.is_invoke_dynamic() &amp;&amp; !tag.is_field_or_method()) {
2368     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2369   }
2370   return (jint) cp-&gt;uncached_name_and_type_ref_index_at(index);
2371 }
2372 JVM_END
2373 
2374 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2375 {
2376   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefInfoAt&quot;);
2377   JvmtiVMObjectAllocEventCollector oam;
2378   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2379   bounds_check(cp, index, CHECK_NULL);
2380   constantTag tag = cp-&gt;tag_at(index);
2381   if (!tag.is_name_and_type()) {
2382     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2383   }
2384   Symbol* member_name = cp-&gt;symbol_at(cp-&gt;name_ref_index_at(index));
2385   Symbol* member_sig = cp-&gt;symbol_at(cp-&gt;signature_ref_index_at(index));
2386   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
2387   objArrayHandle dest(THREAD, dest_o);
2388   Handle str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2389   dest-&gt;obj_at_put(0, str());
2390   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2391   dest-&gt;obj_at_put(1, str());
2392   return (jobjectArray) JNIHandles::make_local(dest());
2393 }
2394 JVM_END
2395 
2396 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2397 {
2398   JVMWrapper(&quot;JVM_ConstantPoolGetIntAt&quot;);
2399   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2400   bounds_check(cp, index, CHECK_0);
2401   constantTag tag = cp-&gt;tag_at(index);
2402   if (!tag.is_int()) {
2403     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2404   }
2405   return cp-&gt;int_at(index);
2406 }
2407 JVM_END
2408 
2409 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2410 {
2411   JVMWrapper(&quot;JVM_ConstantPoolGetLongAt&quot;);
2412   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2413   bounds_check(cp, index, CHECK_(0L));
2414   constantTag tag = cp-&gt;tag_at(index);
2415   if (!tag.is_long()) {
2416     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2417   }
2418   return cp-&gt;long_at(index);
2419 }
2420 JVM_END
2421 
2422 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2423 {
2424   JVMWrapper(&quot;JVM_ConstantPoolGetFloatAt&quot;);
2425   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2426   bounds_check(cp, index, CHECK_(0.0f));
2427   constantTag tag = cp-&gt;tag_at(index);
2428   if (!tag.is_float()) {
2429     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2430   }
2431   return cp-&gt;float_at(index);
2432 }
2433 JVM_END
2434 
2435 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2436 {
2437   JVMWrapper(&quot;JVM_ConstantPoolGetDoubleAt&quot;);
2438   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2439   bounds_check(cp, index, CHECK_(0.0));
2440   constantTag tag = cp-&gt;tag_at(index);
2441   if (!tag.is_double()) {
2442     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2443   }
2444   return cp-&gt;double_at(index);
2445 }
2446 JVM_END
2447 
2448 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2449 {
2450   JVMWrapper(&quot;JVM_ConstantPoolGetStringAt&quot;);
2451   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2452   bounds_check(cp, index, CHECK_NULL);
2453   constantTag tag = cp-&gt;tag_at(index);
2454   if (!tag.is_string()) {
2455     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2456   }
2457   oop str = cp-&gt;string_at(index, CHECK_NULL);
2458   return (jstring) JNIHandles::make_local(str);
2459 }
2460 JVM_END
2461 
2462 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2463 {
2464   JVMWrapper(&quot;JVM_ConstantPoolGetUTF8At&quot;);
2465   JvmtiVMObjectAllocEventCollector oam;
2466   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2467   bounds_check(cp, index, CHECK_NULL);
2468   constantTag tag = cp-&gt;tag_at(index);
2469   if (!tag.is_symbol()) {
2470     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2471   }
2472   Symbol* sym = cp-&gt;symbol_at(index);
2473   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2474   return (jstring) JNIHandles::make_local(str());
2475 }
2476 JVM_END
2477 
2478 JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2479 {
2480   JVMWrapper(&quot;JVM_ConstantPoolGetTagAt&quot;);
2481   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2482   bounds_check(cp, index, CHECK_0);
2483   constantTag tag = cp-&gt;tag_at(index);
2484   jbyte result = tag.value();
2485   // If returned tag values are not from the JVM spec, e.g. tags from 100 to 105,
2486   // they are changed to the corresponding tags from the JVM spec, so that java code in
2487   // sun.reflect.ConstantPool will return only tags from the JVM spec, not internal ones.
2488   if (tag.is_klass_or_reference()) {
2489       result = JVM_CONSTANT_Class;
2490   } else if (tag.is_string_index()) {
2491       result = JVM_CONSTANT_String;
2492   } else if (tag.is_method_type_in_error()) {
2493       result = JVM_CONSTANT_MethodType;
2494   } else if (tag.is_method_handle_in_error()) {
2495       result = JVM_CONSTANT_MethodHandle;
2496   } else if (tag.is_dynamic_constant_in_error()) {
2497       result = JVM_CONSTANT_Dynamic;
2498   }
2499   return result;
2500 }
2501 JVM_END
2502 
2503 // Assertion support. //////////////////////////////////////////////////////////
2504 
2505 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2506   JVMWrapper(&quot;JVM_DesiredAssertionStatus&quot;);
2507   assert(cls != NULL, &quot;bad class&quot;);
2508 
2509   oop r = JNIHandles::resolve(cls);
2510   assert(! java_lang_Class::is_primitive(r), &quot;primitive classes not allowed&quot;);
2511   if (java_lang_Class::is_primitive(r)) return false;
2512 
2513   Klass* k = java_lang_Class::as_Klass(r);
2514   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2515   if (!k-&gt;is_instance_klass()) return false;
2516 
2517   ResourceMark rm(THREAD);
2518   const char* name = k-&gt;name()-&gt;as_C_string();
2519   bool system_class = k-&gt;class_loader() == NULL;
2520   return JavaAssertions::enabled(name, system_class);
2521 
2522 JVM_END
2523 
2524 
2525 // Return a new AssertionStatusDirectives object with the fields filled in with
2526 // command-line assertion arguments (i.e., -ea, -da).
2527 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2528   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2529   JvmtiVMObjectAllocEventCollector oam;
2530   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2531   return JNIHandles::make_local(env, asd);
2532 JVM_END
2533 
2534 // Arrays support /////////////////////////////////////////////////////////////
2535 
2536 JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))
2537   JVMWrapper(&quot;JVM_ArrayIsAccessAtomic&quot;);
2538   oop o = JNIHandles::resolve(array);
2539   Klass* k = o-&gt;klass();
2540   if ((o == NULL) || (!k-&gt;is_array_klass())) {
2541     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
2542   }
2543   return ArrayKlass::cast(k)-&gt;element_access_is_atomic();
2544 JVM_END
2545 
2546 JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))
2547   JVMWrapper(&quot;JVM_ArrayEnsureAccessAtomic&quot;);
2548   oop o = JNIHandles::resolve(array);
2549   Klass* k = o-&gt;klass();
2550   if ((o == NULL) || (!k-&gt;is_array_klass())) {
2551     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
2552   }
2553   if (k-&gt;is_valueArray_klass()) {
2554     ValueArrayKlass* vk = ValueArrayKlass::cast(k);
2555     if (!vk-&gt;element_access_is_atomic()) {
2556       /**
2557        * Need to decide how to implement:
2558        *
2559        * 1) Change to objArrayOop layout, therefore oop-&gt;klass() differs so
2560        * then &quot;&lt;atomic&gt;[Qfoo;&quot; klass needs to subclass &quot;[Qfoo;&quot; to pass through
2561        * &quot;checkcast&quot; &amp; &quot;instanceof&quot;
2562        *
2563        * 2) Use extra header in the valueArrayOop to flag atomicity required and
2564        * possibly per instance lock structure. Said info, could be placed in
2565        * &quot;trailer&quot; rather than disturb the current arrayOop
2566        */
2567       Unimplemented();
2568     }
2569   }
2570   return array;
2571 JVM_END
2572 
2573 // Verification ////////////////////////////////////////////////////////////////////////////////
2574 
2575 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2576 
2577 // RedefineClasses support: bug 6214132 caused verification to fail.
2578 // All functions from this section should call the jvmtiThreadSate function:
2579 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2580 // The function returns a Klass* of the _scratch_class if the verifier
2581 // was invoked in the middle of the class redefinition.
2582 // Otherwise it returns its argument value which is the _the_class Klass*.
2583 // Please, refer to the description in the jvmtiThreadSate.hpp.
2584 
2585 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2586   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2587   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2588   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2589   return k-&gt;name()-&gt;as_utf8();
2590 JVM_END
2591 
2592 
2593 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2594   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2595   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2596   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2597   // types will have length zero if this is not an InstanceKlass
2598   // (length is determined by call to JVM_GetClassCPEntriesCount)
2599   if (k-&gt;is_instance_klass()) {
2600     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2601     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2602       constantTag tag = cp-&gt;tag_at(index);
2603       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();
2604     }
2605   }
2606 JVM_END
2607 
2608 
2609 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2610   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2611   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2612   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2613   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2614 JVM_END
2615 
2616 
2617 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2618   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2619   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2620   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2621   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2622 JVM_END
2623 
2624 
2625 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2626   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2627   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2628   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2629   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2630 JVM_END
2631 
2632 
2633 // The following methods, used for the verifier, are never called with
2634 // array klasses, so a direct cast to InstanceKlass is safe.
2635 // Typically, these methods are called in a loop with bounds determined
2636 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2637 // zero for arrays.
2638 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2639   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2640   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2641   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2642   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2643   int length = method-&gt;checked_exceptions_length();
2644   if (length &gt; 0) {
2645     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2646     for (int i = 0; i &lt; length; i++) {
2647       exceptions[i] = table[i].class_cp_index;
2648     }
2649   }
2650 JVM_END
2651 
2652 
2653 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2654   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2655   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2656   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2657   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2658   return method-&gt;checked_exceptions_length();
2659 JVM_END
2660 
2661 
2662 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2663   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2664   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2665   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2666   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2667   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2668 JVM_END
2669 
2670 
2671 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2672   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2673   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2674   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2675   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2676   return method-&gt;code_size();
2677 JVM_END
2678 
2679 
2680 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2681   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2682   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2683   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2684   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2685   ExceptionTable extable(method);
2686   entry-&gt;start_pc   = extable.start_pc(entry_index);
2687   entry-&gt;end_pc     = extable.end_pc(entry_index);
2688   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2689   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2690 JVM_END
2691 
2692 
2693 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2694   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2695   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2696   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2697   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2698   return method-&gt;exception_table_length();
2699 JVM_END
2700 
2701 
2702 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2703   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2704   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2705   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2706   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2707   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2708 JVM_END
2709 
2710 
2711 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2712   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2713   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2714   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2715   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2716 JVM_END
2717 
2718 
2719 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2720   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2721   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2722   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2723   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2724   return method-&gt;max_locals();
2725 JVM_END
2726 
2727 
2728 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2729   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2730   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2731   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2732   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2733   return method-&gt;size_of_parameters();
2734 JVM_END
2735 
2736 
2737 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2738   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2739   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2740   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2741   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2742   return method-&gt;verifier_max_stack();
2743 JVM_END
2744 
2745 
2746 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2747   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2748   ResourceMark rm(THREAD);
2749   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2750   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2751   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2752   return method-&gt;is_object_constructor();
2753 JVM_END
2754 
2755 
2756 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2757   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2758   ResourceMark rm(THREAD);
2759   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2760   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2761   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2762   return method-&gt;is_overpass();
2763 JVM_END
2764 
2765 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2766   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2767   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2768   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2769   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2770   return method-&gt;name()-&gt;as_utf8();
2771 JVM_END
2772 
2773 
2774 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2775   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2776   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2777   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2778   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2779   return method-&gt;signature()-&gt;as_utf8();
2780 JVM_END
2781 
2782 /**
2783  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2784  * read entries in the constant pool.  Since the old verifier always
2785  * works on a copy of the code, it will not see any rewriting that
2786  * may possibly occur in the middle of verification.  So it is important
2787  * that nothing it calls tries to use the cpCache instead of the raw
2788  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2789  */
2790 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2791   JVMWrapper(&quot;JVM_GetCPFieldNameUTF&quot;);
2792   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2793   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2794   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2795   switch (cp-&gt;tag_at(cp_index).value()) {
2796     case JVM_CONSTANT_Fieldref:
2797       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2798     default:
2799       fatal(&quot;JVM_GetCPFieldNameUTF: illegal constant&quot;);
2800   }
2801   ShouldNotReachHere();
2802   return NULL;
2803 JVM_END
2804 
2805 
2806 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2807   JVMWrapper(&quot;JVM_GetCPMethodNameUTF&quot;);
2808   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2809   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2810   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2811   switch (cp-&gt;tag_at(cp_index).value()) {
2812     case JVM_CONSTANT_InterfaceMethodref:
2813     case JVM_CONSTANT_Methodref:
2814       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2815     default:
2816       fatal(&quot;JVM_GetCPMethodNameUTF: illegal constant&quot;);
2817   }
2818   ShouldNotReachHere();
2819   return NULL;
2820 JVM_END
2821 
2822 
2823 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2824   JVMWrapper(&quot;JVM_GetCPMethodSignatureUTF&quot;);
2825   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2826   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2827   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2828   switch (cp-&gt;tag_at(cp_index).value()) {
2829     case JVM_CONSTANT_InterfaceMethodref:
2830     case JVM_CONSTANT_Methodref:
2831       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2832     default:
2833       fatal(&quot;JVM_GetCPMethodSignatureUTF: illegal constant&quot;);
2834   }
2835   ShouldNotReachHere();
2836   return NULL;
2837 JVM_END
2838 
2839 
2840 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2841   JVMWrapper(&quot;JVM_GetCPFieldSignatureUTF&quot;);
2842   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2843   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2844   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2845   switch (cp-&gt;tag_at(cp_index).value()) {
2846     case JVM_CONSTANT_Fieldref:
2847       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2848     default:
2849       fatal(&quot;JVM_GetCPFieldSignatureUTF: illegal constant&quot;);
2850   }
2851   ShouldNotReachHere();
2852   return NULL;
2853 JVM_END
2854 
2855 
2856 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2857   JVMWrapper(&quot;JVM_GetCPClassNameUTF&quot;);
2858   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2859   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2860   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2861   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2862   return classname-&gt;as_utf8();
2863 JVM_END
2864 
2865 
2866 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2867   JVMWrapper(&quot;JVM_GetCPFieldClassNameUTF&quot;);
2868   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2869   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2870   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2871   switch (cp-&gt;tag_at(cp_index).value()) {
2872     case JVM_CONSTANT_Fieldref: {
2873       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2874       Symbol* classname = cp-&gt;klass_name_at(class_index);
2875       return classname-&gt;as_utf8();
2876     }
2877     default:
2878       fatal(&quot;JVM_GetCPFieldClassNameUTF: illegal constant&quot;);
2879   }
2880   ShouldNotReachHere();
2881   return NULL;
2882 JVM_END
2883 
2884 
2885 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2886   JVMWrapper(&quot;JVM_GetCPMethodClassNameUTF&quot;);
2887   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2888   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2889   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2890   switch (cp-&gt;tag_at(cp_index).value()) {
2891     case JVM_CONSTANT_Methodref:
2892     case JVM_CONSTANT_InterfaceMethodref: {
2893       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2894       Symbol* classname = cp-&gt;klass_name_at(class_index);
2895       return classname-&gt;as_utf8();
2896     }
2897     default:
2898       fatal(&quot;JVM_GetCPMethodClassNameUTF: illegal constant&quot;);
2899   }
2900   ShouldNotReachHere();
2901   return NULL;
2902 JVM_END
2903 
2904 
2905 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2906   JVMWrapper(&quot;JVM_GetCPFieldModifiers&quot;);
2907   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2908   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2909   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2910   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2911   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2912   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2913   switch (cp-&gt;tag_at(cp_index).value()) {
2914     case JVM_CONSTANT_Fieldref: {
2915       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2916       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2917       InstanceKlass* ik = InstanceKlass::cast(k_called);
2918       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2919         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2920           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2921         }
2922       }
2923       return -1;
2924     }
2925     default:
2926       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2927   }
2928   ShouldNotReachHere();
2929   return 0;
2930 JVM_END
2931 
2932 
2933 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2934   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2935   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2936   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2937   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2938   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2939   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2940   switch (cp-&gt;tag_at(cp_index).value()) {
2941     case JVM_CONSTANT_Methodref:
2942     case JVM_CONSTANT_InterfaceMethodref: {
2943       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2944       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2945       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2946       int methods_count = methods-&gt;length();
2947       for (int i = 0; i &lt; methods_count; i++) {
2948         Method* method = methods-&gt;at(i);
2949         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2950             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2951         }
2952       }
2953       return -1;
2954     }
2955     default:
2956       fatal(&quot;JVM_GetCPMethodModifiers: illegal constant&quot;);
2957   }
2958   ShouldNotReachHere();
2959   return 0;
2960 JVM_END
2961 
2962 
2963 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2964 
2965 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2966   // So long as UTF8::convert_to_utf8 returns resource strings, we don&#39;t have to do anything
2967 JVM_END
2968 
2969 
2970 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2971   JVMWrapper(&quot;JVM_IsSameClassPackage&quot;);
2972   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2973   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2974   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2975   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2976   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2977 JVM_END
2978 
2979 // Printing support //////////////////////////////////////////////////
2980 extern &quot;C&quot; {
2981 
2982 ATTRIBUTE_PRINTF(3, 0)
2983 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2984   // Reject count values that are negative signed values converted to
2985   // unsigned; see bug 4399518, 4417214
2986   if ((intptr_t)count &lt;= 0) return -1;
2987 
2988   int result = os::vsnprintf(str, count, fmt, args);
2989   if (result &gt; 0 &amp;&amp; (size_t)result &gt;= count) {
2990     result = -1;
2991   }
2992 
2993   return result;
2994 }
2995 
2996 ATTRIBUTE_PRINTF(3, 4)
2997 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
2998   va_list args;
2999   int len;
3000   va_start(args, fmt);
3001   len = jio_vsnprintf(str, count, fmt, args);
3002   va_end(args);
3003   return len;
3004 }
3005 
3006 ATTRIBUTE_PRINTF(2, 3)
3007 int jio_fprintf(FILE* f, const char *fmt, ...) {
3008   int len;
3009   va_list args;
3010   va_start(args, fmt);
3011   len = jio_vfprintf(f, fmt, args);
3012   va_end(args);
3013   return len;
3014 }
3015 
3016 ATTRIBUTE_PRINTF(2, 0)
3017 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
3018   if (Arguments::vfprintf_hook() != NULL) {
3019      return Arguments::vfprintf_hook()(f, fmt, args);
3020   } else {
3021     return vfprintf(f, fmt, args);
3022   }
3023 }
3024 
3025 ATTRIBUTE_PRINTF(1, 2)
3026 JNIEXPORT int jio_printf(const char *fmt, ...) {
3027   int len;
3028   va_list args;
3029   va_start(args, fmt);
3030   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
3031   va_end(args);
3032   return len;
3033 }
3034 
3035 // HotSpot specific jio method
3036 void jio_print(const char* s, size_t len) {
3037   // Try to make this function as atomic as possible.
3038   if (Arguments::vfprintf_hook() != NULL) {
3039     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
3040   } else {
3041     // Make an unused local variable to avoid warning from gcc compiler.
3042     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
3043   }
3044 }
3045 
3046 } // Extern C
3047 
3048 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
3049 
3050 // In most of the JVM thread support functions we need to access the
3051 // thread through a ThreadsListHandle to prevent it from exiting and
3052 // being reclaimed while we try to operate on it. The exceptions to this
3053 // rule are when operating on the current thread, or if the monitor of
3054 // the target java.lang.Thread is locked at the Java level - in both
3055 // cases the target cannot exit.
3056 
3057 static void thread_entry(JavaThread* thread, TRAPS) {
3058   HandleMark hm(THREAD);
3059   Handle obj(THREAD, thread-&gt;threadObj());
3060   JavaValue result(T_VOID);
3061   JavaCalls::call_virtual(&amp;result,
3062                           obj,
3063                           SystemDictionary::Thread_klass(),
3064                           vmSymbols::run_method_name(),
3065                           vmSymbols::void_method_signature(),
3066                           THREAD);
3067 }
3068 
3069 
3070 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
3071   JVMWrapper(&quot;JVM_StartThread&quot;);
3072   JavaThread *native_thread = NULL;
3073 
3074   // We cannot hold the Threads_lock when we throw an exception,
3075   // due to rank ordering issues. Example:  we might need to grab the
3076   // Heap_lock while we construct the exception.
3077   bool throw_illegal_thread_state = false;
3078 
3079   // We must release the Threads_lock before we can post a jvmti event
3080   // in Thread::start.
3081   {
3082     // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before
3083     // we operate.
3084     MutexLocker mu(Threads_lock);
3085 
3086     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
3087     // re-starting an already started thread, so we should usually find
3088     // that the JavaThread is null. However for a JNI attached thread
3089     // there is a small window between the Thread object being created
3090     // (with its JavaThread set) and the update to its threadStatus, so we
3091     // have to check for this
3092     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
3093       throw_illegal_thread_state = true;
3094     } else {
3095       // We could also check the stillborn flag to see if this thread was already stopped, but
3096       // for historical reasons we let the thread detect that itself when it starts running
3097 
3098       jlong size =
3099              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
3100       // Allocate the C++ Thread structure and create the native thread.  The
3101       // stack size retrieved from java is 64-bit signed, but the constructor takes
3102       // size_t (an unsigned type), which may be 32 or 64-bit depending on the platform.
3103       //  - Avoid truncating on 32-bit platforms if size is greater than UINT_MAX.
3104       //  - Avoid passing negative values which would result in really large stacks.
3105       NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;)
3106       size_t sz = size &gt; 0 ? (size_t) size : 0;
3107       native_thread = new JavaThread(&amp;thread_entry, sz);
3108 
3109       // At this point it may be possible that no osthread was created for the
3110       // JavaThread due to lack of memory. Check for this situation and throw
3111       // an exception if necessary. Eventually we may want to change this so
3112       // that we only grab the lock if the thread was created successfully -
3113       // then we can also do this check and throw the exception in the
3114       // JavaThread constructor.
3115       if (native_thread-&gt;osthread() != NULL) {
3116         // Note: the current thread is not being used within &quot;prepare&quot;.
3117         native_thread-&gt;prepare(jthread);
3118       }
3119     }
3120   }
3121 
3122   if (throw_illegal_thread_state) {
3123     THROW(vmSymbols::java_lang_IllegalThreadStateException());
3124   }
3125 
3126   assert(native_thread != NULL, &quot;Starting null thread?&quot;);
3127 
3128   if (native_thread-&gt;osthread() == NULL) {
3129     // No one should hold a reference to the &#39;native_thread&#39;.
3130     native_thread-&gt;smr_delete();
3131     if (JvmtiExport::should_post_resource_exhausted()) {
3132       JvmtiExport::post_resource_exhausted(
3133         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
3134         os::native_thread_creation_failed_msg());
3135     }
3136     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
3137               os::native_thread_creation_failed_msg());
3138   }
3139 
3140 #if INCLUDE_JFR
3141   if (JfrRecorder::is_recording() &amp;&amp; EventThreadStart::is_enabled() &amp;&amp;
3142       EventThreadStart::is_stacktrace_enabled()) {
3143     JfrThreadLocal* tl = native_thread-&gt;jfr_thread_local();
3144     // skip Thread.start() and Thread.start0()
3145     tl-&gt;set_cached_stack_trace_id(JfrStackTraceRepository::record(thread, 2));
3146   }
3147 #endif
3148 
3149   Thread::start(native_thread);
3150 
3151 JVM_END
3152 
3153 
3154 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
3155 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
3156 // but is thought to be reliable and simple. In the case, where the receiver is the
3157 // same thread as the sender, no VM_Operation is needed.
3158 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
3159   JVMWrapper(&quot;JVM_StopThread&quot;);
3160 
3161   // A nested ThreadsListHandle will grab the Threads_lock so create
3162   // tlh before we resolve throwable.
3163   ThreadsListHandle tlh(thread);
3164   oop java_throwable = JNIHandles::resolve(throwable);
3165   if (java_throwable == NULL) {
3166     THROW(vmSymbols::java_lang_NullPointerException());
3167   }
3168   oop java_thread = NULL;
3169   JavaThread* receiver = NULL;
3170   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3171   Events::log_exception(thread,
3172                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
3173                         p2i(receiver), p2i(java_thread), p2i(throwable));
3174 
3175   if (is_alive) {
3176     // jthread refers to a live JavaThread.
3177     if (thread == receiver) {
3178       // Exception is getting thrown at self so no VM_Operation needed.
3179       THROW_OOP(java_throwable);
3180     } else {
3181       // Use a VM_Operation to throw the exception.
3182       Thread::send_async_exception(java_thread, java_throwable);
3183     }
3184   } else {
3185     // Either:
3186     // - target thread has not been started before being stopped, or
3187     // - target thread already terminated
3188     // We could read the threadStatus to determine which case it is
3189     // but that is overkill as it doesn&#39;t matter. We must set the
3190     // stillborn flag for the first case, and if the thread has already
3191     // exited setting this flag has no effect.
3192     java_lang_Thread::set_stillborn(java_thread);
3193   }
3194 JVM_END
3195 
3196 
3197 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
3198   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
3199 
3200   oop thread_oop = JNIHandles::resolve_non_null(jthread);
3201   return java_lang_Thread::is_alive(thread_oop);
3202 JVM_END
3203 
3204 
3205 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
3206   JVMWrapper(&quot;JVM_SuspendThread&quot;);
3207 
3208   ThreadsListHandle tlh(thread);
3209   JavaThread* receiver = NULL;
3210   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3211   if (is_alive) {
3212     // jthread refers to a live JavaThread.
3213     {
3214       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
3215       if (receiver-&gt;is_external_suspend()) {
3216         // Don&#39;t allow nested external suspend requests. We can&#39;t return
3217         // an error from this interface so just ignore the problem.
3218         return;
3219       }
3220       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
3221         return;
3222       }
3223       receiver-&gt;set_external_suspend();
3224     }
3225 
3226     // java_suspend() will catch threads in the process of exiting
3227     // and will ignore them.
3228     receiver-&gt;java_suspend();
3229 
3230     // It would be nice to have the following assertion in all the
3231     // time, but it is possible for a racing resume request to have
3232     // resumed this thread right after we suspended it. Temporarily
3233     // enable this assertion if you are chasing a different kind of
3234     // bug.
3235     //
3236     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
3237     //   receiver-&gt;is_being_ext_suspended(), &quot;thread is not suspended&quot;);
3238   }
3239 JVM_END
3240 
3241 
3242 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
3243   JVMWrapper(&quot;JVM_ResumeThread&quot;);
3244 
3245   ThreadsListHandle tlh(thread);
3246   JavaThread* receiver = NULL;
3247   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3248   if (is_alive) {
3249     // jthread refers to a live JavaThread.
3250 
3251     // This is the original comment for this Threads_lock grab:
3252     //   We need to *always* get the threads lock here, since this operation cannot be allowed during
3253     //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
3254     //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code
3255     //   looks at it.
3256     //
3257     // The above comment dates back to when we had both internal and
3258     // external suspend APIs that shared a common underlying mechanism.
3259     // External suspend is now entirely cooperative and doesn&#39;t share
3260     // anything with internal suspend. That said, there are some
3261     // assumptions in the VM that an external resume grabs the
3262     // Threads_lock. We can&#39;t drop the Threads_lock grab here until we
3263     // resolve the assumptions that exist elsewhere.
3264     //
3265     MutexLocker ml(Threads_lock);
3266     receiver-&gt;java_resume();
3267   }
3268 JVM_END
3269 
3270 
3271 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3272   JVMWrapper(&quot;JVM_SetThreadPriority&quot;);
3273 
3274   ThreadsListHandle tlh(thread);
3275   oop java_thread = NULL;
3276   JavaThread* receiver = NULL;
3277   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3278   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3279 
3280   if (is_alive) {
3281     // jthread refers to a live JavaThread.
3282     Thread::set_priority(receiver, (ThreadPriority)prio);
3283   }
3284   // Implied else: If the JavaThread hasn&#39;t started yet, then the
3285   // priority set in the java.lang.Thread object above will be pushed
3286   // down when it does start.
3287 JVM_END
3288 
3289 
3290 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3291   JVMWrapper(&quot;JVM_Yield&quot;);
3292   if (os::dont_yield()) return;
3293   HOTSPOT_THREAD_YIELD();
3294   os::naked_yield();
3295 JVM_END
3296 
3297 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3298   assert(event != NULL, &quot;invariant&quot;);
3299   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3300   event-&gt;set_time(millis);
3301   event-&gt;commit();
3302 }
3303 
3304 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3305   JVMWrapper(&quot;JVM_Sleep&quot;);
3306 
3307   if (millis &lt; 0) {
3308     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3309   }
3310 
3311   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3312     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3313   }
3314 
3315   // Save current thread state and restore it at the end of this block.
3316   // And set new thread state to SLEEPING.
3317   JavaThreadSleepState jtss(thread);
3318 
3319   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3320   EventThreadSleep event;
3321 
3322   if (millis == 0) {
3323     os::naked_yield();
3324   } else {
3325     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3326     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3327     if (!thread-&gt;sleep(millis)) { // interrupted
3328       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3329       // us while we were sleeping. We do not overwrite those.
3330       if (!HAS_PENDING_EXCEPTION) {
3331         if (event.should_commit()) {
3332           post_thread_sleep_event(&amp;event, millis);
3333         }
3334         HOTSPOT_THREAD_SLEEP_END(1);
3335 
3336         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3337         // to properly restore the thread state.  That&#39;s likely wrong.
3338         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3339       }
3340     }
3341     thread-&gt;osthread()-&gt;set_state(old_state);
3342   }
3343   if (event.should_commit()) {
3344     post_thread_sleep_event(&amp;event, millis);
3345   }
3346   HOTSPOT_THREAD_SLEEP_END(0);
3347 JVM_END
3348 
3349 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3350   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3351   oop jthread = thread-&gt;threadObj();
3352   assert (thread != NULL, &quot;no current thread!&quot;);
3353   return JNIHandles::make_local(env, jthread);
3354 JVM_END
3355 
3356 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3357   JVMWrapper(&quot;JVM_Interrupt&quot;);
3358 
3359   ThreadsListHandle tlh(thread);
3360   JavaThread* receiver = NULL;
3361   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3362   if (is_alive) {
3363     // jthread refers to a live JavaThread.
3364     receiver-&gt;interrupt();
3365   }
3366 JVM_END
3367 
3368 
3369 // Return true iff the current thread has locked the object passed in
3370 
3371 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3372   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3373   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3374   if (obj == NULL) {
3375     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3376   }
3377   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3378   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3379 JVM_END
3380 
3381 
3382 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3383   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3384   VM_PrintThreads op;
3385   VMThread::execute(&amp;op);
3386   if (JvmtiExport::should_post_data_dump()) {
3387     JvmtiExport::post_data_dump();
3388   }
3389 JVM_END
3390 
3391 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3392   JVMWrapper(&quot;JVM_SetNativeThreadName&quot;);
3393 
3394   // We don&#39;t use a ThreadsListHandle here because the current thread
3395   // must be alive.
3396   oop java_thread = JNIHandles::resolve_non_null(jthread);
3397   JavaThread* thr = java_lang_Thread::thread(java_thread);
3398   if (thread == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3399     // Thread naming is only supported for the current thread and
3400     // we don&#39;t set the name of an attached thread to avoid stepping
3401     // on other programs.
3402     ResourceMark rm(thread);
3403     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3404     os::set_native_thread_name(thread_name);
3405   }
3406 JVM_END
3407 
3408 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3409 
3410 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3411   JVMWrapper(&quot;JVM_GetClassContext&quot;);
3412   ResourceMark rm(THREAD);
3413   JvmtiVMObjectAllocEventCollector oam;
3414   vframeStream vfst(thread);
3415 
3416   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3417     // This must only be called from SecurityManager.getClassContext
3418     Method* m = vfst.method();
3419     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3420           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3421           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3422       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetClassContext must only be called from SecurityManager.getClassContext&quot;);
3423     }
3424   }
3425 
3426   // Collect method holders
3427   GrowableArray&lt;Klass*&gt;* klass_array = new GrowableArray&lt;Klass*&gt;();
3428   for (; !vfst.at_end(); vfst.security_next()) {
3429     Method* m = vfst.method();
3430     // Native frames are not returned
3431     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3432       Klass* holder = m-&gt;method_holder();
3433       assert(holder-&gt;is_klass(), &quot;just checking&quot;);
3434       klass_array-&gt;append(holder);
3435     }
3436   }
3437 
3438   // Create result array of type [Ljava/lang/Class;
3439   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3440   // Fill in mirrors corresponding to method holders
3441   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3442     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3443   }
3444 
3445   return (jobjectArray) JNIHandles::make_local(env, result);
3446 JVM_END
3447 
3448 
3449 // java.lang.Package ////////////////////////////////////////////////////////////////
3450 
3451 
3452 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3453   JVMWrapper(&quot;JVM_GetSystemPackage&quot;);
3454   ResourceMark rm(THREAD);
3455   JvmtiVMObjectAllocEventCollector oam;
3456   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3457   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3458   return (jstring) JNIHandles::make_local(result);
3459 JVM_END
3460 
3461 
3462 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3463   JVMWrapper(&quot;JVM_GetSystemPackages&quot;);
3464   JvmtiVMObjectAllocEventCollector oam;
3465   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3466   return (jobjectArray) JNIHandles::make_local(result);
3467 JVM_END
3468 
3469 
3470 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3471 
3472 
3473 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3474   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3475 
3476   MonitorLocker ml(Heap_lock);
3477   oop ref = Universe::reference_pending_list();
3478   if (ref != NULL) {
3479     Universe::set_reference_pending_list(NULL);
3480   }
3481   return JNIHandles::make_local(env, ref);
3482 JVM_END
3483 
3484 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3485   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
3486   MonitorLocker ml(Heap_lock);
3487   return Universe::has_reference_pending_list();
3488 JVM_END
3489 
3490 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3491   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
3492   MonitorLocker ml(Heap_lock);
3493   while (!Universe::has_reference_pending_list()) {
3494     ml.wait();
3495   }
3496 JVM_END
3497 
3498 
3499 // ObjectInputStream ///////////////////////////////////////////////////////////////
3500 
3501 // Return the first user-defined class loader up the execution stack, or null
3502 // if only code from the bootstrap or platform class loader is on the stack.
3503 
3504 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3505   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3506     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3507     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3508     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3509       return JNIHandles::make_local(env, loader);
3510     }
3511   }
3512   return NULL;
3513 JVM_END
3514 
3515 
3516 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3517 
3518 
3519 // resolve array handle and check arguments
3520 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3521   if (arr == NULL) {
3522     THROW_0(vmSymbols::java_lang_NullPointerException());
3523   }
3524   oop a = JNIHandles::resolve_non_null(arr);
3525   if (!a-&gt;is_array()) {
3526     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array&quot;);
3527   } else if (type_array_only &amp;&amp; !a-&gt;is_typeArray()) {
3528     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array of primitive type&quot;);
3529   }
3530   return arrayOop(a);
3531 }
3532 
3533 
3534 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3535   JVMWrapper(&quot;JVM_GetArrayLength&quot;);
3536   arrayOop a = check_array(env, arr, false, CHECK_0);
3537   return a-&gt;length();
3538 JVM_END
3539 
3540 
3541 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3542   JVMWrapper(&quot;JVM_Array_Get&quot;);
3543   JvmtiVMObjectAllocEventCollector oam;
3544   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3545   jvalue value;
3546   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3547   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3548   return JNIHandles::make_local(env, box);
3549 JVM_END
3550 
3551 
3552 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3553   JVMWrapper(&quot;JVM_GetPrimitiveArrayElement&quot;);
3554   jvalue value;
3555   value.i = 0; // to initialize value before getting used in CHECK
3556   arrayOop a = check_array(env, arr, true, CHECK_(value));
3557   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3558   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3559   BasicType wide_type = (BasicType) wCode;
3560   if (type != wide_type) {
3561     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3562   }
3563   return value;
3564 JVM_END
3565 
3566 
3567 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3568   JVMWrapper(&quot;JVM_SetArrayElement&quot;);
3569   arrayOop a = check_array(env, arr, false, CHECK);
3570   oop box = JNIHandles::resolve(val);
3571   jvalue value;
3572   value.i = 0; // to initialize value before getting used in CHECK
3573   BasicType value_type;
3574   if (a-&gt;is_objArray()) {
3575     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3576     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3577   } else {
3578     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3579   }
3580   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3581 JVM_END
3582 
3583 
3584 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3585   JVMWrapper(&quot;JVM_SetPrimitiveArrayElement&quot;);
3586   arrayOop a = check_array(env, arr, true, CHECK);
3587   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3588   BasicType value_type = (BasicType) vCode;
3589   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3590 JVM_END
3591 
3592 
3593 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3594   JVMWrapper(&quot;JVM_NewArray&quot;);
3595   JvmtiVMObjectAllocEventCollector oam;
3596   oop element_mirror = JNIHandles::resolve(eltClass);
3597   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3598   return JNIHandles::make_local(env, result);
3599 JVM_END
3600 
3601 
3602 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3603   JVMWrapper(&quot;JVM_NewMultiArray&quot;);
3604   JvmtiVMObjectAllocEventCollector oam;
3605   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3606   oop element_mirror = JNIHandles::resolve(eltClass);
3607   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
3608   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3609   return JNIHandles::make_local(env, result);
3610 JVM_END
3611 
3612 
3613 // Library support ///////////////////////////////////////////////////////////////////////////
3614 
3615 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3616   //%note jvm_ct
3617   JVMWrapper(&quot;JVM_LoadLibrary&quot;);
3618   char ebuf[1024];
3619   void *load_result;
3620   {
3621     ThreadToNativeFromVM ttnfvm(thread);
3622     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3623   }
3624   if (load_result == NULL) {
3625     char msg[1024];
3626     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3627     // Since &#39;ebuf&#39; may contain a string encoded using
3628     // platform encoding scheme, we need to pass
3629     // Exceptions::unsafe_to_utf8 to the new_exception method
3630     // as the last argument. See bug 6367357.
3631     Handle h_exception =
3632       Exceptions::new_exception(thread,
3633                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3634                                 msg, Exceptions::unsafe_to_utf8);
3635 
3636     THROW_HANDLE_0(h_exception);
3637   }
3638   log_info(library)(&quot;Loaded library %s, handle &quot; INTPTR_FORMAT, name, p2i(load_result));
3639   return load_result;
3640 JVM_END
3641 
3642 
3643 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3644   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3645   os::dll_unload(handle);
3646   log_info(library)(&quot;Unloaded library with handle &quot; INTPTR_FORMAT, p2i(handle));
3647 JVM_END
3648 
3649 
3650 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3651   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
3652   void* find_result = os::dll_lookup(handle, name);
3653   log_info(library)(&quot;%s %s in library with handle &quot; INTPTR_FORMAT,
3654                     find_result != NULL ? &quot;Found&quot; : &quot;Failed to find&quot;,
3655                     name, p2i(handle));
3656   return find_result;
3657 JVM_END
3658 
3659 
3660 // JNI version ///////////////////////////////////////////////////////////////////////////////
3661 
3662 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3663   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3664   return Threads::is_supported_jni_version_including_1_1(version);
3665 JVM_END
3666 
3667 
3668 // String support ///////////////////////////////////////////////////////////////////////////
3669 
3670 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3671   JVMWrapper(&quot;JVM_InternString&quot;);
3672   JvmtiVMObjectAllocEventCollector oam;
3673   if (str == NULL) return NULL;
3674   oop string = JNIHandles::resolve_non_null(str);
3675   oop result = StringTable::intern(string, CHECK_NULL);
3676   return (jstring) JNIHandles::make_local(env, result);
3677 JVM_END
3678 
3679 
3680 // VM Raw monitor support //////////////////////////////////////////////////////////////////////
3681 
3682 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion
3683 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK
3684 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate
3685 // in the safepoint protocol, thread suspension, thread interruption, or anything of that
3686 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.
3687 
3688 
3689 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3690   VM_Exit::block_if_vm_exited();
3691   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
3692   return new os::PlatformMutex();
3693 }
3694 
3695 
3696 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3697   VM_Exit::block_if_vm_exited();
3698   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3699   delete ((os::PlatformMutex*) mon);
3700 }
3701 
3702 
3703 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3704   VM_Exit::block_if_vm_exited();
3705   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
3706   ((os::PlatformMutex*) mon)-&gt;lock();
3707   return 0;
3708 }
3709 
3710 
3711 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3712   VM_Exit::block_if_vm_exited();
3713   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3714   ((os::PlatformMutex*) mon)-&gt;unlock();
3715 }
3716 
3717 
3718 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3719 
3720 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3721                                     Handle loader, Handle protection_domain,
3722                                     jboolean throwError, TRAPS) {
3723   // Security Note:
3724   //   The Java level wrapper will perform the necessary security check allowing
3725   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3726   //   the checkPackageAccess relative to the initiating class loader via the
3727   //   protection_domain. The protection_domain is passed as NULL by the java code
3728   //   if there is no security manager in 3-arg Class.forName().
3729   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3730 
3731   // Check if we should initialize the class
3732   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3733     klass-&gt;initialize(CHECK_NULL);
3734   }
3735   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3736 }
3737 
3738 
3739 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3740 
3741 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3742   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3743   Handle method_handle;
3744   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3745     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3746     Handle receiver(THREAD, JNIHandles::resolve(obj));
3747     objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);
3748     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3749     jobject res = JNIHandles::make_local(env, result);
3750     if (JvmtiExport::should_post_vm_object_alloc()) {
3751       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3752       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3753       if (java_lang_Class::is_primitive(ret_type)) {
3754         // Only for primitive type vm allocates memory for java object.
3755         // See box() method.
3756         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3757       }
3758     }
3759     return res;
3760   } else {
3761     THROW_0(vmSymbols::java_lang_StackOverflowError());
3762   }
3763 JVM_END
3764 
3765 
3766 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3767   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
3768   objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);
3769   oop constructor_mirror = JNIHandles::resolve(c);
3770   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3771   jobject res = JNIHandles::make_local(env, result);
3772   if (JvmtiExport::should_post_vm_object_alloc()) {
3773     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3774   }
3775   return res;
3776 JVM_END
3777 
3778 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3779 
3780 JVM_LEAF(jboolean, JVM_SupportsCX8())
3781   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3782   return VM_Version::supports_cx8();
3783 JVM_END
3784 
3785 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3786   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3787   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3788   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3789   HeapShared::initialize_from_archived_subgraph(k);
3790 JVM_END
3791 
3792 // Returns an array of all live Thread objects (VM internal JavaThreads,
3793 // jvmti agent threads, and JNI attaching threads  are skipped)
3794 // See CR 6404306 regarding JNI attaching threads
3795 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
3796   ResourceMark rm(THREAD);
3797   ThreadsListEnumerator tle(THREAD, false, false);
3798   JvmtiVMObjectAllocEventCollector oam;
3799 
3800   int num_threads = tle.num_threads();
3801   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
3802   objArrayHandle threads_ah(THREAD, r);
3803 
3804   for (int i = 0; i &lt; num_threads; i++) {
3805     Handle h = tle.get_threadObj(i);
3806     threads_ah-&gt;obj_at_put(i, h());
3807   }
3808 
3809   return (jobjectArray) JNIHandles::make_local(env, threads_ah());
3810 JVM_END
3811 
3812 
3813 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
3814 // Return StackTraceElement[][], each element is the stack trace of a thread in
3815 // the corresponding entry in the given threads array
3816 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
3817   JVMWrapper(&quot;JVM_DumpThreads&quot;);
3818   JvmtiVMObjectAllocEventCollector oam;
3819 
3820   // Check if threads is null
3821   if (threads == NULL) {
3822     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
3823   }
3824 
3825   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
3826   objArrayHandle ah(THREAD, a);
3827   int num_threads = ah-&gt;length();
3828   // check if threads is non-empty array
3829   if (num_threads == 0) {
3830     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3831   }
3832 
3833   // check if threads is not an array of objects of Thread class
3834   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
3835   if (k != SystemDictionary::Thread_klass()) {
3836     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3837   }
3838 
3839   ResourceMark rm(THREAD);
3840 
3841   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
3842   for (int i = 0; i &lt; num_threads; i++) {
3843     oop thread_obj = ah-&gt;obj_at(i);
3844     instanceHandle h(THREAD, (instanceOop) thread_obj);
3845     thread_handle_array-&gt;append(h);
3846   }
3847 
3848   // The JavaThread references in thread_handle_array are validated
3849   // in VM_ThreadDump::doit().
3850   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
3851   return (jobjectArray)JNIHandles::make_local(env, stacktraces());
3852 
3853 JVM_END
3854 
3855 // JVM monitoring and management support
3856 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
3857   return Management::get_jmm_interface(version);
3858 JVM_END
3859 
3860 // com.sun.tools.attach.VirtualMachine agent properties support
3861 //
3862 // Initialize the agent properties with the properties maintained in the VM
3863 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
3864   JVMWrapper(&quot;JVM_InitAgentProperties&quot;);
3865   ResourceMark rm;
3866 
3867   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
3868 
3869   PUTPROP(props, &quot;sun.java.command&quot;, Arguments::java_command());
3870   PUTPROP(props, &quot;sun.jvm.flags&quot;, Arguments::jvm_flags());
3871   PUTPROP(props, &quot;sun.jvm.args&quot;, Arguments::jvm_args());
3872   return properties;
3873 JVM_END
3874 
3875 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
3876 {
3877   JVMWrapper(&quot;JVM_GetEnclosingMethodInfo&quot;);
3878   JvmtiVMObjectAllocEventCollector oam;
3879 
3880   if (ofClass == NULL) {
3881     return NULL;
3882   }
3883   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
3884   // Special handling for primitive objects
3885   if (java_lang_Class::is_primitive(mirror())) {
3886     return NULL;
3887   }
3888   Klass* k = java_lang_Class::as_Klass(mirror());
3889   if (!k-&gt;is_instance_klass()) {
3890     return NULL;
3891   }
3892   InstanceKlass* ik = InstanceKlass::cast(k);
3893   int encl_method_class_idx = ik-&gt;enclosing_method_class_index();
3894   if (encl_method_class_idx == 0) {
3895     return NULL;
3896   }
3897   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
3898   objArrayHandle dest(THREAD, dest_o);
3899   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3900   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
3901   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
3902   if (encl_method_method_idx != 0) {
3903     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
3904                         extract_low_short_from_int(
3905                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3906     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3907     dest-&gt;obj_at_put(1, str());
3908     sym = ik-&gt;constants()-&gt;symbol_at(
3909               extract_high_short_from_int(
3910                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3911     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3912     dest-&gt;obj_at_put(2, str());
3913   }
3914   return (jobjectArray) JNIHandles::make_local(dest());
3915 }
3916 JVM_END
3917 
3918 // Returns an array of java.lang.String objects containing the input arguments to the VM.
3919 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
3920   ResourceMark rm(THREAD);
3921 
3922   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
3923     return NULL;
3924   }
3925 
3926   char** vm_flags = Arguments::jvm_flags_array();
3927   char** vm_args = Arguments::jvm_args_array();
3928   int num_flags = Arguments::num_jvm_flags();
3929   int num_args = Arguments::num_jvm_args();
3930 
3931   InstanceKlass* ik = SystemDictionary::String_klass();
3932   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
3933   objArrayHandle result_h(THREAD, r);
3934 
3935   int index = 0;
3936   for (int j = 0; j &lt; num_flags; j++, index++) {
3937     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
3938     result_h-&gt;obj_at_put(index, h());
3939   }
3940   for (int i = 0; i &lt; num_args; i++, index++) {
3941     Handle h = java_lang_String::create_from_platform_dependent_str(vm_args[i], CHECK_NULL);
3942     result_h-&gt;obj_at_put(index, h());
3943   }
3944   return (jobjectArray) JNIHandles::make_local(env, result_h());
3945 JVM_END
3946 
3947 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
3948   return os::get_signal_number(name);
3949 JVM_END
    </pre>
  </body>
</html>
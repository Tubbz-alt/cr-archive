<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/valueKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2865         break;
2866       case Op_MacroLogicV:
2867         // Ordering of inputs may change during evaluation of sub-tree
2868         // containing MacroLogic node as a child node, thus a re-evaluation
2869         // makes sure that function is evaluated in context of current
2870         // inputs.
2871         res = eval_macro_logic_op(n-&gt;in(4)-&gt;get_int(), func1, func2, func3);
2872         break;
2873 
2874       default: assert(false, &quot;not supported: %s&quot;, n-&gt;Name());
2875     }
2876     assert(res &lt;= 0xFF, &quot;invalid&quot;);
2877     eval_map.put(n, res);
2878   }
2879   return res;
2880 }
2881 
2882 bool Compile::compute_logic_cone(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {
2883   assert(partition.size() == 0, &quot;not empty&quot;);
2884   assert(inputs.size() == 0, &quot;not empty&quot;);
<span class="line-modified">2885   assert(!is_vector_ternary_bitwise_op(n), &quot;not supported&quot;);</span>


2886 
2887   bool is_unary_op = is_vector_unary_bitwise_op(n);
2888   if (is_unary_op) {
2889     assert(collect_unique_inputs(n, partition, inputs) == 1, &quot;not unary&quot;);
2890     return false; // too few inputs
2891   }
2892 
2893   assert(is_vector_binary_bitwise_op(n), &quot;not binary&quot;);
2894   Node* in1 = n-&gt;in(1);
2895   Node* in2 = n-&gt;in(2);
2896 
2897   int in1_unique_inputs_cnt = collect_unique_inputs(in1, partition, inputs);
2898   int in2_unique_inputs_cnt = collect_unique_inputs(in2, partition, inputs);
2899   partition.push(n);
2900 
2901   // Too many inputs?
2902   if (inputs.size() &gt; 3) {
2903     partition.clear();
2904     inputs.clear();
2905     { // Recompute in2 inputs
</pre>
<hr />
<pre>
2907       in2_unique_inputs_cnt = collect_unique_inputs(in2, not_used, not_used);
2908     }
2909     // Pick the node with minimum number of inputs.
2910     if (in1_unique_inputs_cnt &gt;= 3 &amp;&amp; in2_unique_inputs_cnt &gt;= 3) {
2911       return false; // still too many inputs
2912     }
2913     // Recompute partition &amp; inputs.
2914     Node* child       = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in1 : in2);
2915     collect_unique_inputs(child, partition, inputs);
2916 
2917     Node* other_input = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in2 : in1);
2918     inputs.push(other_input);
2919 
2920     partition.push(n);
2921   }
2922 
2923   return (partition.size() == 2 || partition.size() == 3) &amp;&amp;
2924          (inputs.size()    == 2 || inputs.size()    == 3);
2925 }
2926 

2927 void Compile::process_logic_cone_root(PhaseIterGVN &amp;igvn, Node *n, VectorSet &amp;visited) {
2928   assert(is_vector_bitwise_op(n), &quot;not a root&quot;);
2929 
2930   visited.set(n-&gt;_idx);
2931 
2932   // 1) Do a DFS walk over the logic cone.
2933   for (uint i = 1; i &lt; n-&gt;req(); i++) {
2934     Node* in = n-&gt;in(i);
2935     if (!visited.test(in-&gt;_idx) &amp;&amp; is_vector_bitwise_op(in)) {
2936       process_logic_cone_root(igvn, in, visited);
2937     }
2938   }
2939 
2940   // 2) Bottom up traversal: Merge node[s] with
2941   // the parent to form macro logic node.
2942   Unique_Node_List partition;
2943   Unique_Node_List inputs;
2944   if (compute_logic_cone(n, partition, inputs)) {
2945     const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();
2946     Node* macro_logic = xform_to_MacroLogicV(igvn, vt, partition, inputs);
</pre>
</td>
<td>
<hr />
<pre>
2865         break;
2866       case Op_MacroLogicV:
2867         // Ordering of inputs may change during evaluation of sub-tree
2868         // containing MacroLogic node as a child node, thus a re-evaluation
2869         // makes sure that function is evaluated in context of current
2870         // inputs.
2871         res = eval_macro_logic_op(n-&gt;in(4)-&gt;get_int(), func1, func2, func3);
2872         break;
2873 
2874       default: assert(false, &quot;not supported: %s&quot;, n-&gt;Name());
2875     }
2876     assert(res &lt;= 0xFF, &quot;invalid&quot;);
2877     eval_map.put(n, res);
2878   }
2879   return res;
2880 }
2881 
2882 bool Compile::compute_logic_cone(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {
2883   assert(partition.size() == 0, &quot;not empty&quot;);
2884   assert(inputs.size() == 0, &quot;not empty&quot;);
<span class="line-modified">2885   if (is_vector_ternary_bitwise_op(n)) {</span>
<span class="line-added">2886     return false;</span>
<span class="line-added">2887   }</span>
2888 
2889   bool is_unary_op = is_vector_unary_bitwise_op(n);
2890   if (is_unary_op) {
2891     assert(collect_unique_inputs(n, partition, inputs) == 1, &quot;not unary&quot;);
2892     return false; // too few inputs
2893   }
2894 
2895   assert(is_vector_binary_bitwise_op(n), &quot;not binary&quot;);
2896   Node* in1 = n-&gt;in(1);
2897   Node* in2 = n-&gt;in(2);
2898 
2899   int in1_unique_inputs_cnt = collect_unique_inputs(in1, partition, inputs);
2900   int in2_unique_inputs_cnt = collect_unique_inputs(in2, partition, inputs);
2901   partition.push(n);
2902 
2903   // Too many inputs?
2904   if (inputs.size() &gt; 3) {
2905     partition.clear();
2906     inputs.clear();
2907     { // Recompute in2 inputs
</pre>
<hr />
<pre>
2909       in2_unique_inputs_cnt = collect_unique_inputs(in2, not_used, not_used);
2910     }
2911     // Pick the node with minimum number of inputs.
2912     if (in1_unique_inputs_cnt &gt;= 3 &amp;&amp; in2_unique_inputs_cnt &gt;= 3) {
2913       return false; // still too many inputs
2914     }
2915     // Recompute partition &amp; inputs.
2916     Node* child       = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in1 : in2);
2917     collect_unique_inputs(child, partition, inputs);
2918 
2919     Node* other_input = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in2 : in1);
2920     inputs.push(other_input);
2921 
2922     partition.push(n);
2923   }
2924 
2925   return (partition.size() == 2 || partition.size() == 3) &amp;&amp;
2926          (inputs.size()    == 2 || inputs.size()    == 3);
2927 }
2928 
<span class="line-added">2929 </span>
2930 void Compile::process_logic_cone_root(PhaseIterGVN &amp;igvn, Node *n, VectorSet &amp;visited) {
2931   assert(is_vector_bitwise_op(n), &quot;not a root&quot;);
2932 
2933   visited.set(n-&gt;_idx);
2934 
2935   // 1) Do a DFS walk over the logic cone.
2936   for (uint i = 1; i &lt; n-&gt;req(); i++) {
2937     Node* in = n-&gt;in(i);
2938     if (!visited.test(in-&gt;_idx) &amp;&amp; is_vector_bitwise_op(in)) {
2939       process_logic_cone_root(igvn, in, visited);
2940     }
2941   }
2942 
2943   // 2) Bottom up traversal: Merge node[s] with
2944   // the parent to form macro logic node.
2945   Unique_Node_List partition;
2946   Unique_Node_List inputs;
2947   if (compute_logic_cone(n, partition, inputs)) {
2948     const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();
2949     Node* macro_logic = xform_to_MacroLogicV(igvn, vt, partition, inputs);
</pre>
</td>
</tr>
</table>
<center><a href="../oops/valueKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
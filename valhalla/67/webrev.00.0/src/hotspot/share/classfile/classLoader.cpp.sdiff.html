<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/aarch64/aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  78 
  79 typedef int (*canonicalize_fn_t)(const char *orig, char *out, int len);
  80 
  81 static canonicalize_fn_t CanonicalizeEntry  = NULL;
  82 
  83 // Entry points in zip.dll for loading zip/jar file entries
  84 
  85 typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);
  86 typedef void     (*ZipClose_t)(jzfile *zip);
  87 typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
  88 typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
  89 typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);
  90 typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);
  91 
  92 static ZipOpen_t         ZipOpen            = NULL;
  93 static ZipClose_t        ZipClose           = NULL;
  94 static FindEntry_t       FindEntry          = NULL;
  95 static ReadEntry_t       ReadEntry          = NULL;
  96 static GetNextEntry_t    GetNextEntry       = NULL;
  97 static Crc32_t           Crc32              = NULL;

  98 
  99 // Entry points for jimage.dll for loading jimage file entries
 100 
 101 static JImageOpen_t                    JImageOpen             = NULL;
 102 static JImageClose_t                   JImageClose            = NULL;
 103 static JImagePackageToModule_t         JImagePackageToModule  = NULL;
 104 static JImageFindResource_t            JImageFindResource     = NULL;
 105 static JImageGetResource_t             JImageGetResource      = NULL;
 106 static JImageResourceIterator_t        JImageResourceIterator = NULL;
 107 
 108 // Globals
 109 
 110 PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;
 111 PerfCounter*    ClassLoader::_perf_classes_inited = NULL;
 112 PerfCounter*    ClassLoader::_perf_class_init_time = NULL;
 113 PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;
 114 PerfCounter*    ClassLoader::_perf_classes_verified = NULL;
 115 PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;
 116 PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;
 117 PerfCounter*    ClassLoader::_perf_classes_linked = NULL;
</pre>
<hr />
<pre>
 730     char* canonical_path = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, JVM_MAXPATHLEN);
 731     if (!get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 732       // This matches the classic VM
 733       if (throw_exception) {
 734         THROW_MSG_(vmSymbols::java_io_IOException(), &quot;Bad pathname&quot;, NULL);
 735       } else {
 736         return NULL;
 737       }
 738     }
 739     jint error;
 740     JImageFile* jimage =(*JImageOpen)(canonical_path, &amp;error);
 741     if (jimage != NULL) {
 742       new_entry = new ClassPathImageEntry(jimage, canonical_path);
 743     } else {
 744       char* error_msg = NULL;
 745       jzfile* zip;
 746       {
 747         // enable call to C land
 748         ThreadToNativeFromVM ttn(thread);
 749         HandleMark hm(thread);

 750         zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 751       }
 752       if (zip != NULL &amp;&amp; error_msg == NULL) {
 753         new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr);
 754       } else {
 755         char *msg;
 756         if (error_msg == NULL) {
 757           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(path) + 128); ;
 758           jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
 759         } else {
 760           int len = (int)(strlen(path) + strlen(error_msg) + 128);
 761           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, len); ;
 762           jio_snprintf(msg, len - 1, &quot;error in opening JAR file &lt;%s&gt; %s&quot;, error_msg, path);
 763         }
 764         // Don&#39;t complain about bad jar files added via -Xbootclasspath/a:.
 765         if (throw_exception &amp;&amp; is_init_completed()) {
 766           THROW_MSG_(vmSymbols::java_lang_ClassNotFoundException(), msg, NULL);
 767         } else {
 768           return NULL;
 769         }
</pre>
<hr />
<pre>
 779   return new_entry;
 780 }
 781 
 782 
 783 // Create a class path zip entry for a given path (return NULL if not found
 784 // or zip/JAR file cannot be opened)
 785 ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bool is_boot_append) {
 786   // check for a regular file
 787   struct stat st;
 788   if (os::stat(path, &amp;st) == 0) {
 789     if ((st.st_mode &amp; S_IFMT) == S_IFREG) {
 790       char canonical_path[JVM_MAXPATHLEN];
 791       if (get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 792         char* error_msg = NULL;
 793         jzfile* zip;
 794         {
 795           // enable call to C land
 796           JavaThread* thread = JavaThread::current();
 797           ThreadToNativeFromVM ttn(thread);
 798           HandleMark hm(thread);

 799           zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 800         }
 801         if (zip != NULL &amp;&amp; error_msg == NULL) {
 802           // create using canonical path
 803           return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false);
 804         }
 805       }
 806     }
 807   }
 808   return NULL;
 809 }
 810 
 811 // returns true if entry already on class path
 812 bool ClassLoader::contains_append_entry(const char* name) {
 813   ClassPathEntry* e = _first_append_entry;
 814   while (e != NULL) {
 815     // assume zip entries have been canonicalized
 816     if (strcmp(name, e-&gt;name()) == 0) {
 817       return true;
 818     }
</pre>
<hr />
<pre>
 950 void* ClassLoader::dll_lookup(void* lib, const char* name, const char* path) {
 951   void* func = os::dll_lookup(lib, name);
 952   if (func == NULL) {
 953     char msg[256] = &quot;&quot;;
 954     jio_snprintf(msg, sizeof(msg), &quot;Could not resolve \&quot;%s\&quot;&quot;, name);
 955     vm_exit_during_initialization(msg, path);
 956   }
 957   return func;
 958 }
 959 
 960 void ClassLoader::load_java_library() {
 961   assert(CanonicalizeEntry == NULL, &quot;should not load java library twice&quot;);
 962   void *javalib_handle = os::native_java_library();
 963   if (javalib_handle == NULL) {
 964     vm_exit_during_initialization(&quot;Unable to load java library&quot;, NULL);
 965   }
 966 
 967   CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, &quot;JDK_Canonicalize&quot;, NULL));
 968 }
 969 








 970 void ClassLoader::load_zip_library() {
 971   assert(ZipOpen == NULL, &quot;should not load zip library twice&quot;);
 972   char path[JVM_MAXPATHLEN];
 973   char ebuf[1024];
 974   void* handle = NULL;
 975   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;zip&quot;)) {
 976     handle = os::dll_load(path, ebuf, sizeof ebuf);
 977   }
 978   if (handle == NULL) {
 979     vm_exit_during_initialization(&quot;Unable to load zip library&quot;, path);
 980   }
 981 
 982   ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(handle, &quot;ZIP_Open&quot;, path));
 983   ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(handle, &quot;ZIP_Close&quot;, path));
 984   FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(handle, &quot;ZIP_FindEntry&quot;, path));
 985   ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(handle, &quot;ZIP_ReadEntry&quot;, path));
 986   GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, dll_lookup(handle, &quot;ZIP_GetNextEntry&quot;, path));
 987   Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(handle, &quot;ZIP_CRC32&quot;, path));
 988 }
 989 
</pre>
<hr />
<pre>
 991   assert(JImageOpen == NULL, &quot;should not load jimage library twice&quot;);
 992   char path[JVM_MAXPATHLEN];
 993   char ebuf[1024];
 994   void* handle = NULL;
 995   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
 996     handle = os::dll_load(path, ebuf, sizeof ebuf);
 997   }
 998   if (handle == NULL) {
 999     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1000   }
1001 
1002   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));
1003   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));
1004   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));
1005   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));
1006   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));
1007   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));
1008 }
1009 
1010 int ClassLoader::crc32(int crc, const char* buf, int len) {

1011   return (*Crc32)(crc, (const jbyte*)buf, len);
1012 }
1013 
1014 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1015   // Look up the name in the boot loader&#39;s package entry table.
1016   if (name != NULL) {
1017     TempNewSymbol package_sym = SymbolTable::new_symbol(name);
1018     // Look for the package entry in the boot loader&#39;s package entry table.
1019     PackageEntry* package =
1020       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1021 
1022     // Return NULL if package does not exist or if no classes in that package
1023     // have been loaded.
1024     if (package != NULL &amp;&amp; package-&gt;has_loaded_class()) {
1025       ModuleEntry* module = package-&gt;module();
1026       if (module-&gt;location() != NULL) {
1027         ResourceMark rm(THREAD);
1028         Handle ml = java_lang_String::create_from_str(
1029           module-&gt;location()-&gt;as_C_string(), THREAD);
1030         return ml();
</pre>
<hr />
<pre>
1449     // the behavior of system &amp; user-defined classloader lock, whether
1450     // ClassLoader.loadClass/findClass is being called synchronized or not.
1451     NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,
1452                         &quot;systemLoaderLockContentionRate&quot;);
1453     NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,
1454                         &quot;nonSystemLoaderLockContentionRate&quot;);
1455     NEWPERFEVENTCOUNTER(_sync_JVMFindLoadedClassLockFreeCounter, SUN_CLS,
1456                         &quot;jvmFindLoadedClassNoLockCalls&quot;);
1457     NEWPERFEVENTCOUNTER(_sync_JVMDefineClassLockFreeCounter, SUN_CLS,
1458                         &quot;jvmDefineClassNoLockCalls&quot;);
1459 
1460     NEWPERFEVENTCOUNTER(_sync_JNIDefineClassLockFreeCounter, SUN_CLS,
1461                         &quot;jniDefineClassNoLockCalls&quot;);
1462 
1463     NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS,
1464                         &quot;unsafeDefineClassCalls&quot;);
1465   }
1466 
1467   // lookup java library entry points
1468   load_java_library();
<span class="line-removed">1469   // lookup zip library entry points</span>
<span class="line-removed">1470   load_zip_library();</span>
1471   // jimage library entry points are loaded below, in lookup_vm_options
1472   setup_bootstrap_search_path();
1473 }
1474 
1475 char* lookup_vm_resource(JImageFile *jimage, const char *jimage_version, const char *path) {
1476   jlong size;
1477   JImageLocationRef location = (*JImageFindResource)(jimage, &quot;java.base&quot;, jimage_version, path, &amp;size);
1478   if (location == 0)
1479     return NULL;
1480   char *val = NEW_C_HEAP_ARRAY(char, size+1, mtClass);
1481   (*JImageGetResource)(jimage, location, val, size);
1482   val[size] = &#39;\0&#39;;
1483   return val;
1484 }
1485 
1486 // Lookup VM options embedded in the modules jimage file
1487 char* ClassLoader::lookup_vm_options() {
1488   jint error;
1489   char modules_path[JVM_MAXPATHLEN];
1490   const char* fileSep = os::file_separator();
</pre>
</td>
<td>
<hr />
<pre>
  78 
  79 typedef int (*canonicalize_fn_t)(const char *orig, char *out, int len);
  80 
  81 static canonicalize_fn_t CanonicalizeEntry  = NULL;
  82 
  83 // Entry points in zip.dll for loading zip/jar file entries
  84 
  85 typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);
  86 typedef void     (*ZipClose_t)(jzfile *zip);
  87 typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
  88 typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
  89 typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);
  90 typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);
  91 
  92 static ZipOpen_t         ZipOpen            = NULL;
  93 static ZipClose_t        ZipClose           = NULL;
  94 static FindEntry_t       FindEntry          = NULL;
  95 static ReadEntry_t       ReadEntry          = NULL;
  96 static GetNextEntry_t    GetNextEntry       = NULL;
  97 static Crc32_t           Crc32              = NULL;
<span class="line-added">  98 int ClassLoader::_libzip_loaded = 0;</span>
  99 
 100 // Entry points for jimage.dll for loading jimage file entries
 101 
 102 static JImageOpen_t                    JImageOpen             = NULL;
 103 static JImageClose_t                   JImageClose            = NULL;
 104 static JImagePackageToModule_t         JImagePackageToModule  = NULL;
 105 static JImageFindResource_t            JImageFindResource     = NULL;
 106 static JImageGetResource_t             JImageGetResource      = NULL;
 107 static JImageResourceIterator_t        JImageResourceIterator = NULL;
 108 
 109 // Globals
 110 
 111 PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;
 112 PerfCounter*    ClassLoader::_perf_classes_inited = NULL;
 113 PerfCounter*    ClassLoader::_perf_class_init_time = NULL;
 114 PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;
 115 PerfCounter*    ClassLoader::_perf_classes_verified = NULL;
 116 PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;
 117 PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;
 118 PerfCounter*    ClassLoader::_perf_classes_linked = NULL;
</pre>
<hr />
<pre>
 731     char* canonical_path = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, JVM_MAXPATHLEN);
 732     if (!get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 733       // This matches the classic VM
 734       if (throw_exception) {
 735         THROW_MSG_(vmSymbols::java_io_IOException(), &quot;Bad pathname&quot;, NULL);
 736       } else {
 737         return NULL;
 738       }
 739     }
 740     jint error;
 741     JImageFile* jimage =(*JImageOpen)(canonical_path, &amp;error);
 742     if (jimage != NULL) {
 743       new_entry = new ClassPathImageEntry(jimage, canonical_path);
 744     } else {
 745       char* error_msg = NULL;
 746       jzfile* zip;
 747       {
 748         // enable call to C land
 749         ThreadToNativeFromVM ttn(thread);
 750         HandleMark hm(thread);
<span class="line-added"> 751         load_zip_library_if_needed();</span>
 752         zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 753       }
 754       if (zip != NULL &amp;&amp; error_msg == NULL) {
 755         new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr);
 756       } else {
 757         char *msg;
 758         if (error_msg == NULL) {
 759           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(path) + 128); ;
 760           jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
 761         } else {
 762           int len = (int)(strlen(path) + strlen(error_msg) + 128);
 763           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, len); ;
 764           jio_snprintf(msg, len - 1, &quot;error in opening JAR file &lt;%s&gt; %s&quot;, error_msg, path);
 765         }
 766         // Don&#39;t complain about bad jar files added via -Xbootclasspath/a:.
 767         if (throw_exception &amp;&amp; is_init_completed()) {
 768           THROW_MSG_(vmSymbols::java_lang_ClassNotFoundException(), msg, NULL);
 769         } else {
 770           return NULL;
 771         }
</pre>
<hr />
<pre>
 781   return new_entry;
 782 }
 783 
 784 
 785 // Create a class path zip entry for a given path (return NULL if not found
 786 // or zip/JAR file cannot be opened)
 787 ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bool is_boot_append) {
 788   // check for a regular file
 789   struct stat st;
 790   if (os::stat(path, &amp;st) == 0) {
 791     if ((st.st_mode &amp; S_IFMT) == S_IFREG) {
 792       char canonical_path[JVM_MAXPATHLEN];
 793       if (get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 794         char* error_msg = NULL;
 795         jzfile* zip;
 796         {
 797           // enable call to C land
 798           JavaThread* thread = JavaThread::current();
 799           ThreadToNativeFromVM ttn(thread);
 800           HandleMark hm(thread);
<span class="line-added"> 801           load_zip_library_if_needed();</span>
 802           zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 803         }
 804         if (zip != NULL &amp;&amp; error_msg == NULL) {
 805           // create using canonical path
 806           return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false);
 807         }
 808       }
 809     }
 810   }
 811   return NULL;
 812 }
 813 
 814 // returns true if entry already on class path
 815 bool ClassLoader::contains_append_entry(const char* name) {
 816   ClassPathEntry* e = _first_append_entry;
 817   while (e != NULL) {
 818     // assume zip entries have been canonicalized
 819     if (strcmp(name, e-&gt;name()) == 0) {
 820       return true;
 821     }
</pre>
<hr />
<pre>
 953 void* ClassLoader::dll_lookup(void* lib, const char* name, const char* path) {
 954   void* func = os::dll_lookup(lib, name);
 955   if (func == NULL) {
 956     char msg[256] = &quot;&quot;;
 957     jio_snprintf(msg, sizeof(msg), &quot;Could not resolve \&quot;%s\&quot;&quot;, name);
 958     vm_exit_during_initialization(msg, path);
 959   }
 960   return func;
 961 }
 962 
 963 void ClassLoader::load_java_library() {
 964   assert(CanonicalizeEntry == NULL, &quot;should not load java library twice&quot;);
 965   void *javalib_handle = os::native_java_library();
 966   if (javalib_handle == NULL) {
 967     vm_exit_during_initialization(&quot;Unable to load java library&quot;, NULL);
 968   }
 969 
 970   CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, &quot;JDK_Canonicalize&quot;, NULL));
 971 }
 972 
<span class="line-added"> 973 void ClassLoader::release_load_zip_library() {</span>
<span class="line-added"> 974   MutexLocker locker(Zip_lock, Monitor::_no_safepoint_check_flag);</span>
<span class="line-added"> 975   if (_libzip_loaded == 0) {</span>
<span class="line-added"> 976     load_zip_library();</span>
<span class="line-added"> 977     Atomic::release_store(&amp;_libzip_loaded, 1);</span>
<span class="line-added"> 978   }</span>
<span class="line-added"> 979 }</span>
<span class="line-added"> 980 </span>
 981 void ClassLoader::load_zip_library() {
 982   assert(ZipOpen == NULL, &quot;should not load zip library twice&quot;);
 983   char path[JVM_MAXPATHLEN];
 984   char ebuf[1024];
 985   void* handle = NULL;
 986   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;zip&quot;)) {
 987     handle = os::dll_load(path, ebuf, sizeof ebuf);
 988   }
 989   if (handle == NULL) {
 990     vm_exit_during_initialization(&quot;Unable to load zip library&quot;, path);
 991   }
 992 
 993   ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(handle, &quot;ZIP_Open&quot;, path));
 994   ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(handle, &quot;ZIP_Close&quot;, path));
 995   FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(handle, &quot;ZIP_FindEntry&quot;, path));
 996   ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(handle, &quot;ZIP_ReadEntry&quot;, path));
 997   GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, dll_lookup(handle, &quot;ZIP_GetNextEntry&quot;, path));
 998   Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(handle, &quot;ZIP_CRC32&quot;, path));
 999 }
1000 
</pre>
<hr />
<pre>
1002   assert(JImageOpen == NULL, &quot;should not load jimage library twice&quot;);
1003   char path[JVM_MAXPATHLEN];
1004   char ebuf[1024];
1005   void* handle = NULL;
1006   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
1007     handle = os::dll_load(path, ebuf, sizeof ebuf);
1008   }
1009   if (handle == NULL) {
1010     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1011   }
1012 
1013   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));
1014   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));
1015   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));
1016   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));
1017   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));
1018   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));
1019 }
1020 
1021 int ClassLoader::crc32(int crc, const char* buf, int len) {
<span class="line-added">1022   load_zip_library_if_needed();</span>
1023   return (*Crc32)(crc, (const jbyte*)buf, len);
1024 }
1025 
1026 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1027   // Look up the name in the boot loader&#39;s package entry table.
1028   if (name != NULL) {
1029     TempNewSymbol package_sym = SymbolTable::new_symbol(name);
1030     // Look for the package entry in the boot loader&#39;s package entry table.
1031     PackageEntry* package =
1032       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1033 
1034     // Return NULL if package does not exist or if no classes in that package
1035     // have been loaded.
1036     if (package != NULL &amp;&amp; package-&gt;has_loaded_class()) {
1037       ModuleEntry* module = package-&gt;module();
1038       if (module-&gt;location() != NULL) {
1039         ResourceMark rm(THREAD);
1040         Handle ml = java_lang_String::create_from_str(
1041           module-&gt;location()-&gt;as_C_string(), THREAD);
1042         return ml();
</pre>
<hr />
<pre>
1461     // the behavior of system &amp; user-defined classloader lock, whether
1462     // ClassLoader.loadClass/findClass is being called synchronized or not.
1463     NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,
1464                         &quot;systemLoaderLockContentionRate&quot;);
1465     NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,
1466                         &quot;nonSystemLoaderLockContentionRate&quot;);
1467     NEWPERFEVENTCOUNTER(_sync_JVMFindLoadedClassLockFreeCounter, SUN_CLS,
1468                         &quot;jvmFindLoadedClassNoLockCalls&quot;);
1469     NEWPERFEVENTCOUNTER(_sync_JVMDefineClassLockFreeCounter, SUN_CLS,
1470                         &quot;jvmDefineClassNoLockCalls&quot;);
1471 
1472     NEWPERFEVENTCOUNTER(_sync_JNIDefineClassLockFreeCounter, SUN_CLS,
1473                         &quot;jniDefineClassNoLockCalls&quot;);
1474 
1475     NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS,
1476                         &quot;unsafeDefineClassCalls&quot;);
1477   }
1478 
1479   // lookup java library entry points
1480   load_java_library();


1481   // jimage library entry points are loaded below, in lookup_vm_options
1482   setup_bootstrap_search_path();
1483 }
1484 
1485 char* lookup_vm_resource(JImageFile *jimage, const char *jimage_version, const char *path) {
1486   jlong size;
1487   JImageLocationRef location = (*JImageFindResource)(jimage, &quot;java.base&quot;, jimage_version, path, &amp;size);
1488   if (location == 0)
1489     return NULL;
1490   char *val = NEW_C_HEAP_ARRAY(char, size+1, mtClass);
1491   (*JImageGetResource)(jimage, location, val, size);
1492   val[size] = &#39;\0&#39;;
1493   return val;
1494 }
1495 
1496 // Lookup VM options embedded in the modules jimage file
1497 char* ClassLoader::lookup_vm_options() {
1498   jint error;
1499   char modules_path[JVM_MAXPATHLEN];
1500   const char* fileSep = os::file_separator();
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/aarch64/aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
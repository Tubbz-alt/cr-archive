<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  50 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  51 #include &quot;interpreter/bytecodeStream.hpp&quot;
  52 #include &quot;interpreter/interpreter.hpp&quot;
  53 #include &quot;jfr/jfrEvents.hpp&quot;
  54 #include &quot;logging/log.hpp&quot;
  55 #include &quot;logging/logStream.hpp&quot;
  56 #include &quot;memory/filemap.hpp&quot;
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/access.inline.hpp&quot;
  63 #include &quot;oops/fieldStreams.inline.hpp&quot;
  64 #include &quot;oops/instanceKlass.hpp&quot;
  65 #include &quot;oops/instanceRefKlass.hpp&quot;
  66 #include &quot;oops/klass.inline.hpp&quot;
  67 #include &quot;oops/method.inline.hpp&quot;
  68 #include &quot;oops/methodData.hpp&quot;
  69 #include &quot;oops/objArrayKlass.hpp&quot;
  70 #include &quot;oops/objArrayOop.inline.hpp&quot;
  71 #include &quot;oops/oop.inline.hpp&quot;
  72 #include &quot;oops/symbol.hpp&quot;
  73 #include &quot;oops/typeArrayKlass.hpp&quot;
  74 #include &quot;oops/valueKlass.hpp&quot;
  75 #include &quot;prims/jvmtiExport.hpp&quot;
  76 #include &quot;prims/methodHandles.hpp&quot;
  77 #include &quot;runtime/arguments.hpp&quot;
  78 #include &quot;runtime/biasedLocking.hpp&quot;
  79 #include &quot;runtime/handles.inline.hpp&quot;
  80 #include &quot;runtime/java.hpp&quot;
  81 #include &quot;runtime/javaCalls.hpp&quot;
  82 #include &quot;runtime/mutexLocker.hpp&quot;
  83 #include &quot;runtime/os.hpp&quot;
  84 #include &quot;runtime/sharedRuntime.hpp&quot;
  85 #include &quot;runtime/signature.hpp&quot;
  86 #include &quot;services/classLoadingService.hpp&quot;
  87 #include &quot;services/diagnosticCommand.hpp&quot;
  88 #include &quot;services/threadService.hpp&quot;
  89 #include &quot;utilities/macros.hpp&quot;
  90 #if INCLUDE_CDS
  91 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  92 #endif
  93 #if INCLUDE_JFR
  94 #include &quot;jfr/jfr.hpp&quot;
  95 #endif
  96 
  97 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  98 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  99 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 100 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 101 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 102 
 103 oop         SystemDictionary::_system_loader_lock_obj     =  NULL;
 104 
 105 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 106                                                           =  { NULL /*, NULL...*/ };
 107 
 108 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 109 
 110 oop         SystemDictionary::_java_system_loader         =  NULL;
 111 oop         SystemDictionary::_java_platform_loader       =  NULL;
 112 
 113 // Default ProtectionDomainCacheSize value
 114 
 115 const int defaultProtectionDomainCacheSize = 1009;
 116 
 117 ClassLoadInfo::ClassLoadInfo() {
 118   _protection_domain = Handle();
 119   _unsafe_anonymous_host = NULL;
 120   _cp_patches = NULL;
 121   _class_hidden_info._dynamic_nest_host = NULL;
 122   _class_hidden_info._class_data = Handle();
 123   _is_hidden = false;
 124   _is_strong_hidden = false;
 125   _can_access_vm_annotations = false;
 126 }
 127 
 128 ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {
 129   _protection_domain = protection_domain;
 130   _unsafe_anonymous_host = NULL;
 131   _cp_patches = NULL;
 132   _class_hidden_info._dynamic_nest_host = NULL;
 133   _class_hidden_info._class_data = Handle();
 134   _is_hidden = false;
 135   _is_strong_hidden = false;
 136   _can_access_vm_annotations = false;
 137 }
 138 
 139 ClassLoadInfo::ClassLoadInfo(Handle protection_domain,
 140                              const InstanceKlass* unsafe_anonymous_host,
 141                              GrowableArray&lt;Handle&gt;* cp_patches,
 142                              InstanceKlass* dynamic_nest_host,
 143                              Handle class_data,
 144                              bool is_hidden,
 145                              bool is_strong_hidden,
 146                              bool can_access_vm_annotations) {
 147   _protection_domain = protection_domain;
 148   _unsafe_anonymous_host = unsafe_anonymous_host;
 149   _cp_patches = cp_patches;
 150   _class_hidden_info._dynamic_nest_host = dynamic_nest_host;
 151   _class_hidden_info._class_data = class_data;
 152   _is_hidden = is_hidden;
 153   _is_strong_hidden = is_strong_hidden;
 154   _can_access_vm_annotations = can_access_vm_annotations;
 155 }
 156 
 157 // ----------------------------------------------------------------------------
 158 // Java-level SystemLoader and PlatformLoader
 159 
 160 oop SystemDictionary::java_system_loader() {
 161   return _java_system_loader;
 162 }
 163 
 164 oop SystemDictionary::java_platform_loader() {
 165   return _java_platform_loader;
 166 }
 167 
 168 void SystemDictionary::compute_java_loaders(TRAPS) {
 169   JavaValue result(T_OBJECT);
 170   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 171   JavaCalls::call_static(&amp;result,
 172                          class_loader_klass,
 173                          vmSymbols::getSystemClassLoader_name(),
 174                          vmSymbols::void_classloader_signature(),
 175                          CHECK);
 176 
 177   _java_system_loader = (oop)result.get_jobject();
 178 
 179   JavaCalls::call_static(&amp;result,
 180                          class_loader_klass,
 181                          vmSymbols::getPlatformClassLoader_name(),
 182                          vmSymbols::void_classloader_signature(),
 183                          CHECK);
 184 
 185   _java_platform_loader = (oop)result.get_jobject();
 186 }
 187 
 188 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader) {
 189   if (class_loader.is_null()) return ClassLoaderData::the_null_class_loader_data();
 190   return ClassLoaderDataGraph::find_or_create(class_loader);
 191 }
 192 
 193 // ----------------------------------------------------------------------------
 194 // Parallel class loading check
 195 
 196 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 197   if (class_loader.is_null()) return true;
 198   if (AlwaysLockClassLoader) return false;
 199   return java_lang_ClassLoader::parallelCapable(class_loader());
 200 }
 201 // ----------------------------------------------------------------------------
 202 // ParallelDefineClass flag does not apply to bootclass loader
 203 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 204    if (class_loader.is_null()) return false;
 205    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 206      return true;
 207    }
 208    return false;
 209 }
 210 
 211 // Returns true if the passed class loader is the builtin application class loader
 212 // or a custom system class loader. A customer system class loader can be
 213 // specified via -Djava.system.class.loader.
 214 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 215   if (class_loader == NULL) {
 216     return false;
 217   }
 218   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
 219          class_loader == _java_system_loader);
 220 }
 221 
 222 // Returns true if the passed class loader is the platform class loader.
 223 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 224   if (class_loader == NULL) {
 225     return false;
 226   }
 227   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 228 }
 229 
 230 // ----------------------------------------------------------------------------
 231 // Resolving of classes
 232 
 233 // Forwards to resolve_or_null
 234 
 235 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {
 236   Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);
 237   if (HAS_PENDING_EXCEPTION || klass == NULL) {
 238     // can return a null klass
 239     klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);
 240   }
 241   return klass;
 242 }
 243 
 244 Klass* SystemDictionary::handle_resolution_exception(Symbol* class_name,
 245                                                      bool throw_error,
 246                                                      Klass* klass, TRAPS) {
 247   if (HAS_PENDING_EXCEPTION) {
 248     // If we have a pending exception we forward it to the caller, unless throw_error is true,
 249     // in which case we have to check whether the pending exception is a ClassNotFoundException,
 250     // and if so convert it to a NoClassDefFoundError
 251     // And chain the original ClassNotFoundException
 252     if (throw_error &amp;&amp; PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass())) {
 253       ResourceMark rm(THREAD);
 254       assert(klass == NULL, &quot;Should not have result with exception pending&quot;);
 255       Handle e(THREAD, PENDING_EXCEPTION);
 256       CLEAR_PENDING_EXCEPTION;
 257       THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string(), e);
 258     } else {
 259       return NULL;
 260     }
 261   }
 262   // Class not found, throw appropriate error or exception depending on value of throw_error
 263   if (klass == NULL) {
 264     ResourceMark rm(THREAD);
 265     if (throw_error) {
 266       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 267     } else {
 268       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 269     }
 270   }
 271   return klass;
 272 }
 273 
 274 
 275 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 276                                            bool throw_error, TRAPS)
 277 {
 278   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 279 }
 280 
 281 
 282 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 283 
 284 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 285   if (Signature::is_array(class_name)) {
 286     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 287   } else {
 288     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 289   }
 290 }
 291 
 292 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 293 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 294                                                                        Handle class_loader,
 295                                                                        Handle protection_domain,
 296                                                                        TRAPS) {
 297   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 298   if (Signature::has_envelope(class_name)) {
 299     ResourceMark rm(THREAD);
 300     // Ignore wrapping L and ;. (and Q and ; for value types);
 301     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 302                                                  class_name-&gt;utf8_length() - 2);
 303     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 304   } else {
 305     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 306   }
 307 }
 308 
 309 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 310   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 311 }
 312 
 313 // Forwards to resolve_instance_class_or_null
 314 
 315 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 316                                                      Handle class_loader,
 317                                                      Handle protection_domain,
 318                                                      TRAPS) {
 319   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 320   ResourceMark rm(THREAD);
 321   SignatureStream ss(class_name, false);
 322   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 323   Klass* k = NULL;
 324   BasicType t = ss.type();
 325   if (ss.has_envelope()) {
 326     Symbol* obj_class = ss.as_symbol();
 327     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 328                                                          class_loader,
 329                                                          protection_domain,
 330                                                          CHECK_NULL);
 331     if (k != NULL) {
 332       k = k-&gt;array_klass(ndims, CHECK_NULL);
 333     }
 334   } else {
 335     k = Universe::typeArrayKlassObj(t);
 336     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 337   }
 338   return k;
 339 }
 340 
 341 // Must be called for any super-class or super-interface resolution
 342 // during class definition to allow class circularity checking
 343 // super-interface callers:
 344 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 345 // super-class callers:
 346 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 347 //   load_shared_class - while loading a class from shared archive
 348 //   resolve_instance_class_or_null:
 349 //     via: handle_parallel_super_load
 350 //      when resolving a class that has an existing placeholder with
 351 //      a saved superclass [i.e. a defineClass is currently in progress]
 352 //      if another thread is trying to resolve the class, it must do
 353 //      super-class checks on its own thread to catch class circularity
 354 // This last call is critical in class circularity checking for cases
 355 // where classloading is delegated to different threads and the
 356 // classloader lock is released.
 357 // Take the case: Base-&gt;Super-&gt;Base
 358 //   1. If thread T1 tries to do a defineClass of class Base
 359 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 360 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
 361 //    so it tries to load Super
 362 //   3. If we load the class internally, or user classloader uses same thread
 363 //      loadClassFromxxx or defineClass via parseClassFile Super ...
 364 //      3.1 resolve_super_or_fail creates placeholder: T1, Super (super Base)
 365 //      3.3 resolve_instance_class_or_null Base, finds placeholder for Base
 366 //      3.4 calls resolve_super_or_fail Base
 367 //      3.5 finds T1,Base -&gt; throws class circularity
 368 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 369 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 370 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 371 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 372 //      4.4 finds T2, Super -&gt; throws class circularity
 373 // Must be called, even if superclass is null, since this is
 374 // where the placeholder entry is created which claims this
 375 // thread is loading this class/classloader.
 376 // Be careful when modifying this code: once you have run
 377 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 378 // you need to find_and_remove it before returning.
 379 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 380 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 381                                                        Symbol* super_name,
 382                                                        Handle class_loader,
 383                                                        Handle protection_domain,
 384                                                        bool is_superclass,
 385                                                        TRAPS) {
 386   assert(!Signature::is_array(super_name), &quot;invalid super class name&quot;);
 387 #if INCLUDE_CDS
 388   if (DumpSharedSpaces) {
 389     // Special processing for handling UNREGISTERED shared classes.
 390     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 391         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 392     if (k) {
 393       return k;
 394     }
 395   }
 396 #endif // INCLUDE_CDS
 397 
 398   // Double-check, if child class is already loaded, just return super-class,interface
 399   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 400   // dictionary.
 401   // Make sure there&#39;s a placeholder for the *child* before resolving.
 402   // Used as a claim that this thread is currently loading superclass/classloader
 403   // Used here for ClassCircularity checks and also for heap verification
 404   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 405   // Must check ClassCircularity before checking if super class is already loaded.
 406   //
 407   // We might not already have a placeholder if this child_name was
 408   // first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);
 409   // the name of the class might not be known until the stream is actually
 410   // parsed.
 411   // Bugs 4643874, 4715493
 412 
 413   ClassLoaderData* loader_data = class_loader_data(class_loader);
 414   Dictionary* dictionary = loader_data-&gt;dictionary();
 415   unsigned int d_hash = dictionary-&gt;compute_hash(child_name);
 416   unsigned int p_hash = placeholders()-&gt;compute_hash(child_name);
 417   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 418   // can&#39;t throw error holding a lock
 419   bool child_already_loaded = false;
 420   bool throw_circularity_error = false;
 421   {
 422     MutexLocker mu(THREAD, SystemDictionary_lock);
 423     InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
 424     InstanceKlass* quicksuperk;
 425     // to support // loading: if child done loading, just return superclass
 426     // if super_name, &amp; class_loader don&#39;t match:
 427     // if initial define, SD update will give LinkageError
 428     // if redefine: compare_class_versions will give HIERARCHY_CHANGED
 429     // so we don&#39;t throw an exception here.
 430     // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
 431     if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
 432         ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
 433          ((quicksuperk-&gt;name() == super_name) &amp;&amp;
 434             (quicksuperk-&gt;class_loader() == class_loader()))) {
 435            return quicksuperk;
 436     } else {
 437       PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
 438       if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
 439           throw_circularity_error = true;
 440       }
 441     }
 442     if (!throw_circularity_error) {
 443       // Be careful not to exit resolve_super
 444       PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);
 445     }
 446   }
 447   if (throw_circularity_error) {
 448       ResourceMark rm(THREAD);
 449       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name-&gt;as_C_string());
 450   }
 451 
 452 // java.lang.Object should have been found above
 453   assert(super_name != NULL, &quot;null super class for resolving&quot;);
 454   // Resolve the super class or interface, check results on return
 455   InstanceKlass* superk =
 456     SystemDictionary::resolve_instance_class_or_null_helper(super_name,
 457                                                             class_loader,
 458                                                             protection_domain,
 459                                                             THREAD);
 460 
 461   // Clean up of placeholders moved so that each classloadAction registrar self-cleans up
 462   // It is no longer necessary to keep the placeholder table alive until update_dictionary
 463   // or error. GC used to walk the placeholder table as strong roots.
 464   // The instanceKlass is kept alive because the class loader is on the stack,
 465   // which keeps the loader_data alive, as well as all instanceKlasses in
 466   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 467   {
 468     MutexLocker mu(THREAD, SystemDictionary_lock);
 469     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 470     SystemDictionary_lock-&gt;notify_all();
 471   }
 472   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 473     // can null superk
 474     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 475     assert(k == NULL || k == superk, &quot;must be&quot;);
 476     if (k == NULL) {
 477       superk = NULL;
 478     }
 479   }
 480 
 481   return superk;
 482 }
 483 
 484 Klass* SystemDictionary::resolve_flattenable_field_or_fail(AllFieldStream* fs,
 485                                                            Handle class_loader,
 486                                                            Handle protection_domain,
 487                                                            bool throw_error,
 488                                                            TRAPS) {
 489   Symbol* class_name = fs-&gt;signature()-&gt;fundamental_name(THREAD);
 490   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 491   ClassLoaderData* loader_data = class_loader_data(class_loader);
 492   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
 493   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 494   bool throw_circularity_error = false;
 495   PlaceholderEntry* oldprobe;
 496 
 497   {
 498     MutexLocker mu(THREAD, SystemDictionary_lock);
 499     oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, class_name, loader_data);
 500     if (oldprobe != NULL &amp;&amp;
 501       oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::FLATTENABLE_FIELD)) {
 502       throw_circularity_error = true;
 503 
 504     } else {
 505       placeholders()-&gt;find_and_add(p_index, p_hash, class_name, loader_data,
 506                                    PlaceholderTable::FLATTENABLE_FIELD, NULL, THREAD);
 507     }
 508   }
 509 
 510   Klass* klass = NULL;
 511   if (!throw_circularity_error) {
 512     klass = SystemDictionary::resolve_or_fail(class_name, class_loader,
 513                                                protection_domain, true, THREAD);
 514   } else {
 515     ResourceMark rm(THREAD);
 516     THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name-&gt;as_C_string());
 517   }
 518 
 519   {
 520     MutexLocker mu(THREAD, SystemDictionary_lock);
 521     placeholders()-&gt;find_and_remove(p_index, p_hash, class_name, loader_data,
 522                                     PlaceholderTable::FLATTENABLE_FIELD, THREAD);
 523   }
 524 
 525   class_name-&gt;decrement_refcount();
 526   return klass;
 527 }
 528 
 529 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 530                                                   Handle class_loader,
 531                                                   Handle protection_domain,
 532                                                   TRAPS) {
 533   // Now we have to call back to java to check if the initating class has access
 534   JavaValue result(T_VOID);
 535   LogTarget(Debug, protectiondomain) lt;
 536   if (lt.is_enabled()) {
 537     ResourceMark rm(THREAD);
 538     // Print out trace information
 539     LogStream ls(lt);
 540     ls.print_cr(&quot;Checking package access&quot;);
 541     if (class_loader() != NULL) {
 542       ls.print(&quot;class loader: &quot;);
 543       class_loader()-&gt;print_value_on(&amp;ls);
 544     } else {
 545       ls.print_cr(&quot;class loader: NULL&quot;);
 546     }
 547     if (protection_domain() != NULL) {
 548       ls.print(&quot; protection domain: &quot;);
 549       protection_domain()-&gt;print_value_on(&amp;ls);
 550     } else {
 551       ls.print_cr(&quot; protection domain: NULL&quot;);
 552     }
 553     ls.print(&quot; loading: &quot;); klass-&gt;print_value_on(&amp;ls);
 554     ls.cr();
 555   }
 556 
 557   // This handle and the class_loader handle passed in keeps this class from
 558   // being unloaded through several GC points.
 559   // The class_loader handle passed in is the initiating loader.
 560   Handle mirror(THREAD, klass-&gt;java_mirror());
 561 
 562   InstanceKlass* system_loader = SystemDictionary::ClassLoader_klass();
 563   JavaCalls::call_special(&amp;result,
 564                          class_loader,
 565                          system_loader,
 566                          vmSymbols::checkPackageAccess_name(),
 567                          vmSymbols::class_protectiondomain_signature(),
 568                          mirror,
 569                          protection_domain,
 570                          THREAD);
 571 
 572   if (HAS_PENDING_EXCEPTION) {
 573     log_debug(protectiondomain)(&quot;DENIED !!!!!!!!!!!!!!!!!!!!!&quot;);
 574   } else {
 575    log_debug(protectiondomain)(&quot;granted&quot;);
 576   }
 577 
 578   if (HAS_PENDING_EXCEPTION) return;
 579 
 580   // If no exception has been thrown, we have validated the protection domain
 581   // Insert the protection domain of the initiating class into the set.
 582   {
 583     ClassLoaderData* loader_data = class_loader_data(class_loader);
 584     Dictionary* dictionary = loader_data-&gt;dictionary();
 585 
 586     Symbol*  kn = klass-&gt;name();
 587     unsigned int d_hash = dictionary-&gt;compute_hash(kn);
 588 
 589     MutexLocker mu(THREAD, SystemDictionary_lock);
 590     int d_index = dictionary-&gt;hash_to_index(d_hash);
 591     dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
 592                                       protection_domain, THREAD);
 593   }
 594 }
 595 
 596 // We only get here if this thread finds that another thread
 597 // has already claimed the placeholder token for the current operation,
 598 // but that other thread either never owned or gave up the
 599 // object lock
 600 // Waits on SystemDictionary_lock to indicate placeholder table updated
 601 // On return, caller must recheck placeholder table state
 602 //
 603 // We only get here if
 604 //  1) custom classLoader, i.e. not bootstrap classloader
 605 //  2) custom classLoader has broken the class loader objectLock
 606 //     so another thread got here in parallel
 607 //
 608 // lockObject must be held.
 609 // Complicated dance due to lock ordering:
 610 // Must first release the classloader object lock to
 611 // allow initial definer to complete the class definition
 612 // and to avoid deadlock
 613 // Reclaim classloader lock object with same original recursion count
 614 // Must release SystemDictionary_lock after notify, since
 615 // class loader lock must be claimed before SystemDictionary_lock
 616 // to prevent deadlocks
 617 //
 618 // The notify allows applications that did an untimed wait() on
 619 // the classloader object lock to not hang.
 620 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 621   assert_lock_strong(SystemDictionary_lock);
 622 
 623   bool calledholdinglock
 624       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 625   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
 626   assert((lockObject() != _system_loader_lock_obj &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);
 627   ObjectSynchronizer::notifyall(lockObject, THREAD);
 628   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 629   SystemDictionary_lock-&gt;wait();
 630   SystemDictionary_lock-&gt;unlock();
 631   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 632   SystemDictionary_lock-&gt;lock();
 633 }
 634 
 635 // If the class in is in the placeholder table, class loading is in progress
 636 // For cases where the application changes threads to load classes, it
 637 // is critical to ClassCircularity detection that we try loading
 638 // the superclass on the same thread internally, so we do parallel
 639 // super class loading here.
 640 // This also is critical in cases where the original thread gets stalled
 641 // even in non-circularity situations.
 642 // Note: must call resolve_super_or_fail even if null super -
 643 // to force placeholder entry creation for this class for circularity detection
 644 // Caller must check for pending exception
 645 // Returns non-null Klass* if other thread has completed load
 646 // and we are done,
 647 // If return null Klass* and no pending exception, the caller must load the class
 648 InstanceKlass* SystemDictionary::handle_parallel_super_load(
 649     Symbol* name, Symbol* superclassname, Handle class_loader,
 650     Handle protection_domain, Handle lockObject, TRAPS) {
 651 
 652   ClassLoaderData* loader_data = class_loader_data(class_loader);
 653   Dictionary* dictionary = loader_data-&gt;dictionary();
 654   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 655   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 656   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 657 
 658   // superk is not used, resolve_super called for circularity check only
 659   // This code is reached in two situations. One if this thread
 660   // is loading the same class twice (e.g. ClassCircularity, or
 661   // java.lang.instrument).
 662   // The second is if another thread started the resolve_super first
 663   // and has not yet finished.
 664   // In both cases the original caller will clean up the placeholder
 665   // entry on error.
 666   Klass* superk = SystemDictionary::resolve_super_or_fail(name,
 667                                                           superclassname,
 668                                                           class_loader,
 669                                                           protection_domain,
 670                                                           true,
 671                                                           CHECK_NULL);
 672 
 673   // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
 674   // Serial class loaders and bootstrap classloader do wait for superclass loads
 675  if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
 676     MutexLocker mu(THREAD, SystemDictionary_lock);
 677     // Check if classloading completed while we were loading superclass or waiting
 678     return find_class(d_hash, name, dictionary);
 679   }
 680 
 681   // must loop to both handle other placeholder updates
 682   // and spurious notifications
 683   bool super_load_in_progress = true;
 684   PlaceholderEntry* placeholder;
 685   while (super_load_in_progress) {
 686     MutexLocker mu(THREAD, SystemDictionary_lock);
 687     // Check if classloading completed while we were loading superclass or waiting
 688     InstanceKlass* check = find_class(d_hash, name, dictionary);
 689     if (check != NULL) {
 690       // Klass is already loaded, so just return it
 691       return check;
 692     } else {
 693       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 694       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress() ){
 695         // We only get here if the application has released the
 696         // classloader lock when another thread was in the middle of loading a
 697         // superclass/superinterface for this class, and now
 698         // this thread is also trying to load this class.
 699         // To minimize surprises, the first thread that started to
 700         // load a class should be the one to complete the loading
 701         // with the classfile it initially expected.
 702         // This logic has the current thread wait once it has done
 703         // all the superclass/superinterface loading it can, until
 704         // the original thread completes the class loading or fails
 705         // If it completes we will use the resulting InstanceKlass
 706         // which we will find below in the systemDictionary.
 707         // We also get here for parallel bootstrap classloader
 708         if (class_loader.is_null()) {
 709           SystemDictionary_lock-&gt;wait();
 710         } else {
 711           double_lock_wait(lockObject, THREAD);
 712         }
 713       } else {
 714         // If not in SD and not in PH, other thread&#39;s load must have failed
 715         super_load_in_progress = false;
 716       }
 717     }
 718   }
 719   return NULL;
 720 }
 721 
 722 static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {
 723   assert(event != NULL, &quot;invariant&quot;);
 724   assert(k != NULL, &quot;invariant&quot;);
 725   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 726   event-&gt;set_loadedClass(k);
 727   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 728   event-&gt;set_initiatingClassLoader(init_cld);
 729   event-&gt;commit();
 730 }
 731 
 732 
 733 // Be careful when modifying this code: once you have run
 734 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 735 // you need to find_and_remove it before returning.
 736 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 737 //
 738 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 739 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 740                                                                 Handle class_loader,
 741                                                                 Handle protection_domain,
 742                                                                 TRAPS) {
 743   assert(name != NULL &amp;&amp; !Signature::is_array(name) &amp;&amp;
 744          !Signature::has_envelope(name), &quot;invalid class name&quot;);
 745 
 746   EventClassLoad class_load_start_event;
 747 
 748   HandleMark hm(THREAD);
 749 
 750   // Fix for 4474172; see evaluation for more details
 751   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 752   ClassLoaderData* loader_data = register_loader(class_loader);
 753   Dictionary* dictionary = loader_data-&gt;dictionary();
 754   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 755 
 756   // Do lookup to see if class already exist and the protection domain
 757   // has the right access
 758   // This call uses find which checks protection domain already matches
 759   // All subsequent calls use find_class, and set has_loaded_class so that
 760   // before we return a result we call out to java to check for valid protection domain
 761   // to allow returning the Klass* and add it to the pd_set if it is valid
 762   {
 763     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 764     if (probe != NULL) return probe;
 765   }
 766 
 767   // Non-bootstrap class loaders will call out to class loader and
 768   // define via jvm/jni_DefineClass which will acquire the
 769   // class loader object lock to protect against multiple threads
 770   // defining the class in parallel by accident.
 771   // This lock must be acquired here so the waiter will find
 772   // any successful result in the SystemDictionary and not attempt
 773   // the define.
 774   // ParallelCapable Classloaders and the bootstrap classloader
 775   // do not acquire lock here.
 776   bool DoObjectLock = true;
 777   if (is_parallelCapable(class_loader)) {
 778     DoObjectLock = false;
 779   }
 780 
 781   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 782   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 783 
 784   // Class is not in SystemDictionary so we have to do loading.
 785   // Make sure we are synchronized on the class loader before we proceed
 786   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 787   check_loader_lock_contention(lockObject, THREAD);
 788   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 789 
 790   // Check again (after locking) if class already exist in SystemDictionary
 791   bool class_has_been_loaded   = false;
 792   bool super_load_in_progress  = false;
 793   bool havesupername = false;
 794   InstanceKlass* k = NULL;
 795   PlaceholderEntry* placeholder;
 796   Symbol* superclassname = NULL;
 797 
 798   assert(THREAD-&gt;can_call_java(),
 799          &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
 800          name-&gt;as_C_string(),
 801          class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
 802   {
 803     MutexLocker mu(THREAD, SystemDictionary_lock);
 804     InstanceKlass* check = find_class(d_hash, name, dictionary);
 805     if (check != NULL) {
 806       // InstanceKlass is already loaded, so just return it
 807       class_has_been_loaded = true;
 808       k = check;
 809     } else {
 810       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 811       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress()) {
 812          super_load_in_progress = true;
 813          if (placeholder-&gt;havesupername() == true) {
 814            superclassname = placeholder-&gt;supername();
 815            havesupername = true;
 816          }
 817       }
 818     }
 819   }
 820 
 821   // If the class is in the placeholder table, class loading is in progress
 822   if (super_load_in_progress &amp;&amp; havesupername==true) {
 823     k = handle_parallel_super_load(name,
 824                                    superclassname,
 825                                    class_loader,
 826                                    protection_domain,
 827                                    lockObject, THREAD);
 828     if (HAS_PENDING_EXCEPTION) {
 829       return NULL;
 830     }
 831     if (k != NULL) {
 832       class_has_been_loaded = true;
 833     }
 834   }
 835 
 836   bool throw_circularity_error = false;
 837   if (!class_has_been_loaded) {
 838     bool load_instance_added = false;
 839 
 840     // add placeholder entry to record loading instance class
 841     // Five cases:
 842     // All cases need to prevent modifying bootclasssearchpath
 843     // in parallel with a classload of same classname
 844     // Redefineclasses uses existence of the placeholder for the duration
 845     // of the class load to prevent concurrent redefinition of not completely
 846     // defined classes.
 847     // case 1. traditional classloaders that rely on the classloader object lock
 848     //   - no other need for LOAD_INSTANCE
 849     // case 2. traditional classloaders that break the classloader object lock
 850     //    as a deadlock workaround. Detection of this case requires that
 851     //    this check is done while holding the classloader object lock,
 852     //    and that lock is still held when calling classloader&#39;s loadClass.
 853     //    For these classloaders, we ensure that the first requestor
 854     //    completes the load and other requestors wait for completion.
 855     // case 3. Bootstrap classloader - don&#39;t own objectLocker
 856     //    This classloader supports parallelism at the classloader level,
 857     //    but only allows a single load of a class/classloader pair.
 858     //    No performance benefit and no deadlock issues.
 859     // case 4. parallelCapable user level classloaders - without objectLocker
 860     //    Allow parallel classloading of a class/classloader pair
 861 
 862     {
 863       MutexLocker mu(THREAD, SystemDictionary_lock);
 864       if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
 865         PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 866         if (oldprobe) {
 867           // only need check_seen_thread once, not on each loop
 868           // 6341374 java/lang/Instrument with -Xcomp
 869           if (oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {
 870             throw_circularity_error = true;
 871           } else {
 872             // case 1: traditional: should never see load_in_progress.
 873             while (!class_has_been_loaded &amp;&amp; oldprobe &amp;&amp; oldprobe-&gt;instance_load_in_progress()) {
 874 
 875               // case 3: bootstrap classloader: prevent futile classloading,
 876               // wait on first requestor
 877               if (class_loader.is_null()) {
 878                 SystemDictionary_lock-&gt;wait();
 879               } else {
 880               // case 2: traditional with broken classloader lock. wait on first
 881               // requestor.
 882                 double_lock_wait(lockObject, THREAD);
 883               }
 884               // Check if classloading completed while we were waiting
 885               InstanceKlass* check = find_class(d_hash, name, dictionary);
 886               if (check != NULL) {
 887                 // Klass is already loaded, so just return it
 888                 k = check;
 889                 class_has_been_loaded = true;
 890               }
 891               // check if other thread failed to load and cleaned up
 892               oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 893             }
 894           }
 895         }
 896       }
 897       // All cases: add LOAD_INSTANCE holding SystemDictionary_lock
 898       // case 4: parallelCapable: allow competing threads to try
 899       // LOAD_INSTANCE in parallel
 900 
 901       if (!throw_circularity_error &amp;&amp; !class_has_been_loaded) {
 902         PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);
 903         load_instance_added = true;
 904         // For class loaders that do not acquire the classloader object lock,
 905         // if they did not catch another thread holding LOAD_INSTANCE,
 906         // need a check analogous to the acquire ObjectLocker/find_class
 907         // i.e. now that we hold the LOAD_INSTANCE token on loading this class/CL
 908         // one final check if the load has already completed
 909         // class loaders holding the ObjectLock shouldn&#39;t find the class here
 910         InstanceKlass* check = find_class(d_hash, name, dictionary);
 911         if (check != NULL) {
 912           // Klass is already loaded, so return it after checking/adding protection domain
 913           k = check;
 914           class_has_been_loaded = true;
 915         }
 916       }
 917     }
 918 
 919     // must throw error outside of owning lock
 920     if (throw_circularity_error) {
 921       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 922       ResourceMark rm(THREAD);
 923       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 924     }
 925 
 926     if (!class_has_been_loaded) {
 927 
 928       // Do actual loading
 929       k = load_instance_class(name, class_loader, THREAD);
 930 
 931       // If everything was OK (no exceptions, no null return value), and
 932       // class_loader is NOT the defining loader, do a little more bookkeeping.
 933       if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
 934         k-&gt;class_loader() != class_loader()) {
 935 
 936         check_constraints(d_hash, k, class_loader, false, THREAD);
 937 
 938         // Need to check for a PENDING_EXCEPTION again; check_constraints
 939         // can throw but we may have to remove entry from the placeholder table below.
 940         if (!HAS_PENDING_EXCEPTION) {
 941           // Record dependency for non-parent delegation.
 942           // This recording keeps the defining class loader of the klass (k) found
 943           // from being unloaded while the initiating class loader is loaded
 944           // even if the reference to the defining class loader is dropped
 945           // before references to the initiating class loader.
 946           loader_data-&gt;record_dependency(k);
 947 
 948           { // Grabbing the Compile_lock prevents systemDictionary updates
 949             // during compilations.
 950             MutexLocker mu(THREAD, Compile_lock);
 951             update_dictionary(d_hash, p_index, p_hash,
 952               k, class_loader, THREAD);
 953           }
 954 
 955           if (JvmtiExport::should_post_class_load()) {
 956             Thread *thread = THREAD;
 957             assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 958             JvmtiExport::post_class_load((JavaThread *) thread, k);
 959           }
 960         }
 961       }
 962     } // load_instance_class
 963 
 964     if (load_instance_added == true) {
 965       // clean up placeholder entries for LOAD_INSTANCE success or error
 966       // This brackets the SystemDictionary updates for both defining
 967       // and initiating loaders
 968       MutexLocker mu(THREAD, SystemDictionary_lock);
 969       placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
 970       SystemDictionary_lock-&gt;notify_all();
 971     }
 972   }
 973 
 974   if (HAS_PENDING_EXCEPTION || k == NULL) {
 975     return NULL;
 976   }
 977   if (class_load_start_event.should_commit()) {
 978     post_class_load_event(&amp;class_load_start_event, k, loader_data);
 979   }
 980 #ifdef ASSERT
 981   {
 982     ClassLoaderData* loader_data = k-&gt;class_loader_data();
 983     MutexLocker mu(THREAD, SystemDictionary_lock);
 984     InstanceKlass* kk = find_class(name, loader_data);
 985     assert(kk == k, &quot;should be present in dictionary&quot;);
 986   }
 987 #endif
 988 
 989   // return if the protection domain in NULL
 990   if (protection_domain() == NULL) return k;
 991 
 992   // Check the protection domain has the right access
 993   if (dictionary-&gt;is_valid_protection_domain(d_hash, name,
 994                                              protection_domain)) {
 995     return k;
 996   }
 997 
 998   // Verify protection domain. If it fails an exception is thrown
 999   validate_protection_domain(k, class_loader, protection_domain, CHECK_NULL);
1000 
1001   return k;
1002 }
1003 
1004 
1005 // This routine does not lock the system dictionary.
1006 //
1007 // Since readers don&#39;t hold a lock, we must make sure that system
1008 // dictionary entries are only removed at a safepoint (when only one
1009 // thread is running), and are added to in a safe way (all links must
1010 // be updated in an MT-safe manner).
1011 //
1012 // Callers should be aware that an entry could be added just after
1013 // _dictionary-&gt;bucket(index) is read here, so the caller will not see
1014 // the new entry.
1015 
1016 Klass* SystemDictionary::find(Symbol* class_name,
1017                               Handle class_loader,
1018                               Handle protection_domain,
1019                               TRAPS) {
1020 
1021   // The result of this call should be consistent with the result
1022   // of the call to resolve_instance_class_or_null().
1023   // See evaluation 6790209 and 4474172 for more details.
1024   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
1025   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());
1026 
1027   if (loader_data == NULL) {
1028     // If the ClassLoaderData has not been setup,
1029     // then the class loader has no entries in the dictionary.
1030     return NULL;
1031   }
1032 
1033   Dictionary* dictionary = loader_data-&gt;dictionary();
1034   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1035   return dictionary-&gt;find(d_hash, class_name,
1036                           protection_domain);
1037 }
1038 
1039 
1040 // Look for a loaded instance or array klass by name.  Do not do any loading.
1041 // return NULL in case of error.
1042 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1043                                                       Handle class_loader,
1044                                                       Handle protection_domain,
1045                                                       TRAPS) {
1046   Klass* k = NULL;
1047   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1048 
1049   if (Signature::is_array(class_name)) {
1050     // The name refers to an array.  Parse the name.
1051     // dimension and object_key in FieldArrayInfo are assigned as a
1052     // side-effect of this call
1053     SignatureStream ss(class_name, false);
1054     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1055     BasicType t = ss.type();
1056     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
1057       k = Universe::typeArrayKlassObj(t);
1058     } else {
1059       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1060     }
1061     if (k != NULL) {
1062       k = k-&gt;array_klass_or_null(ndims);
1063     }
1064   } else {
1065     k = find(class_name, class_loader, protection_domain, THREAD);
1066   }
1067   return k;
1068 }
1069 
1070 // Note: this method is much like resolve_from_stream, but
1071 // does not publish the classes via the SystemDictionary.
1072 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1073 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1074 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1075                                               Handle class_loader,
1076                                               ClassFileStream* st,
1077                                               const ClassLoadInfo&amp; cl_info,
1078                                               TRAPS) {
1079 
1080   EventClassLoad class_load_start_event;
1081 
1082   ClassLoaderData* loader_data;
1083 
1084   bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;
1085 
1086   if (is_unsafe_anon_class) {
1087     // - for unsafe anonymous class: create a new CLD whith a class holder that uses
1088     //                               the same class loader as the unsafe_anonymous_host.
1089     guarantee(cl_info.unsafe_anonymous_host()-&gt;class_loader() == class_loader(),
1090               &quot;should be the same&quot;);
1091     loader_data = ClassLoaderData::has_class_mirror_holder_cld(class_loader);
1092   } else if (cl_info.is_hidden()) {
1093     // - for hidden classes that are not strong: create a new CLD that has a class holder and
1094     //                                           whose loader is the Lookup class&#39; loader.
1095     // - for hidden class: add the class to the Lookup class&#39; loader&#39;s CLD.
1096     if (!cl_info.is_strong_hidden()) {
1097       loader_data = ClassLoaderData::has_class_mirror_holder_cld(class_loader);
1098     } else {
1099       // This hidden class goes into the regular CLD pool for this loader.
1100       loader_data = register_loader(class_loader);
1101     }
1102   } else {
1103     loader_data = ClassLoaderData::class_loader_data(class_loader());
1104   }
1105 
1106   assert(st != NULL, &quot;invariant&quot;);
1107   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1108 
1109   // Parse stream and create a klass.
1110   // Note that we do this even though this klass might
1111   // already be present in the SystemDictionary, otherwise we would not
1112   // throw potential ClassFormatErrors.
1113 
1114   InstanceKlass* k = KlassFactory::create_from_stream(st,
1115                                                       class_name,
1116                                                       loader_data,
1117                                                       cl_info,
1118                                                       CHECK_NULL);
1119 
1120   if ((cl_info.is_hidden() || is_unsafe_anon_class) &amp;&amp; k != NULL) {
1121     // Hidden classes that are not strong and unsafe anonymous classes must update
1122     // ClassLoaderData holder so that they can be unloaded when the mirror is no
1123     // longer referenced.
1124     if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {
1125       k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
1126     }
1127 
1128     {
1129       MutexLocker mu_r(THREAD, Compile_lock);
1130 
1131       // Add to class hierarchy, initialize vtables, and do possible
1132       // deoptimizations.
1133       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
1134       // But, do not add to dictionary.
1135     }
1136 
1137     // Rewrite and patch constant pool here.
1138     k-&gt;link_class(CHECK_NULL);
1139     if (cl_info.cp_patches() != NULL) {
1140       k-&gt;constants()-&gt;patch_resolved_references(cl_info.cp_patches());
1141     }
1142 
1143     // If it&#39;s anonymous, initialize it now, since nobody else will.
1144     if (is_unsafe_anon_class) {
1145       k-&gt;eager_initialize(CHECK_NULL);
1146     }
1147 
1148     // notify jvmti
1149     if (JvmtiExport::should_post_class_load()) {
1150         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1151         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1152     }
1153     if (class_load_start_event.should_commit()) {
1154       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1155     }
1156   }
1157   assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),
1158          &quot;cp_patches only found with unsafe_anonymous_host&quot;);
1159 
1160   return k;
1161 }
1162 
1163 // Add a klass to the system from a stream (called by jni_DefineClass and
1164 // JVM_DefineClass).
1165 // Note: class_name can be NULL. In that case we do not know the name of
1166 // the class until we have parsed the stream.
1167 
1168 InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,
1169                                                      Handle class_loader,
1170                                                      Handle protection_domain,
1171                                                      ClassFileStream* st,
1172                                                      TRAPS) {
1173 
1174   HandleMark hm(THREAD);
1175 
1176   // Classloaders that support parallelism, e.g. bootstrap classloader,
1177   // do not acquire lock here
1178   bool DoObjectLock = true;
1179   if (is_parallelCapable(class_loader)) {
1180     DoObjectLock = false;
1181   }
1182 
1183   ClassLoaderData* loader_data = register_loader(class_loader);
1184 
1185   // Make sure we are synchronized on the class loader before we proceed
1186   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1187   check_loader_lock_contention(lockObject, THREAD);
1188   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
1189 
1190   assert(st != NULL, &quot;invariant&quot;);
1191 
1192   // Parse the stream and create a klass.
1193   // Note that we do this even though this klass might
1194   // already be present in the SystemDictionary, otherwise we would not
1195   // throw potential ClassFormatErrors.
1196  InstanceKlass* k = NULL;
1197 
1198 #if INCLUDE_CDS
1199   if (!DumpSharedSpaces) {
1200     k = SystemDictionaryShared::lookup_from_stream(class_name,
1201                                                    class_loader,
1202                                                    protection_domain,
1203                                                    st,
1204                                                    CHECK_NULL);
1205   }
1206 #endif
1207 
1208   if (k == NULL) {
1209     if (st-&gt;buffer() == NULL) {
1210       return NULL;
1211     }
1212     ClassLoadInfo cl_info(protection_domain);
1213     k = KlassFactory::create_from_stream(st, class_name, loader_data, cl_info, CHECK_NULL);
1214   }
1215 
1216   assert(k != NULL, &quot;no klass created&quot;);
1217   Symbol* h_name = k-&gt;name();
1218   assert(class_name == NULL || class_name == h_name, &quot;name mismatch&quot;);
1219 
1220   // Add class just loaded
1221   // If a class loader supports parallel classloading handle parallel define requests
1222   // find_or_define_instance_class may return a different InstanceKlass
1223   if (is_parallelCapable(class_loader)) {
1224     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1225     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1226       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1227       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1228       loader_data-&gt;add_to_deallocate_list(k);
1229       k = defined_k;
1230     }
1231   } else {
1232     define_instance_class(k, THREAD);
1233   }
1234 
1235   // If defining the class throws an exception register &#39;k&#39; for cleanup.
1236   if (HAS_PENDING_EXCEPTION) {
1237     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1238     loader_data-&gt;add_to_deallocate_list(k);
1239     return NULL;
1240   }
1241 
1242   // Make sure we have an entry in the SystemDictionary on success
1243   debug_only( {
1244     MutexLocker mu(THREAD, SystemDictionary_lock);
1245 
1246     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1247     assert(check == k, &quot;should be present in the dictionary&quot;);
1248   } );
1249 
1250   return k;
1251 }
1252 
1253 #if INCLUDE_CDS
1254 // Load a class for boot loader from the shared spaces. This also
1255 // forces the super class and all interfaces to be loaded.
1256 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
1257                                                         PackageEntry* pkg_entry,
1258                                                         TRAPS) {
1259   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1260   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
1261     return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);
1262   }
1263   return NULL;
1264 }
1265 
1266 // Check if a shared class can be loaded by the specific classloader:
1267 //
1268 // NULL classloader:
1269 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1270 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1271 //     be defined in an unnamed module.
1272 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1273                                                InstanceKlass* ik,
1274                                                PackageEntry* pkg_entry,
1275                                                Handle class_loader, TRAPS) {
1276   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1277          &quot;Cannot use sharing if java.base is patched&quot;);
1278   ResourceMark rm(THREAD);
1279   int path_index = ik-&gt;shared_classpath_index();
1280   ClassLoaderData* loader_data = class_loader_data(class_loader);
1281   if (path_index &lt; 0) {
1282     // path_index &lt; 0 indicates that the class is intended for a custom loader
1283     // and should not be loaded by boot/platform/app loaders
1284     if (loader_data-&gt;is_builtin_class_loader_data()) {
1285       return false;
1286     } else {
1287       return true;
1288     }
1289   }
1290   SharedClassPathEntry* ent =
1291             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1292   if (!Universe::is_module_initialized()) {
1293     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1294            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1295     assert(class_loader.is_null(), &quot;sanity&quot;);
1296     return true;
1297   }
1298   // Get the pkg_entry from the classloader
1299   ModuleEntry* mod_entry = NULL;
1300   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() :
1301                                                ClassLoader::package_from_class_name(class_name);
1302   if (pkg_name != NULL) {
1303     if (loader_data != NULL) {
1304       if (pkg_entry != NULL) {
1305         mod_entry = pkg_entry-&gt;module();
1306         // If the archived class is from a module that has been patched at runtime,
1307         // the class cannot be loaded from the archive.
1308         if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {
1309           return false;
1310         }
1311       }
1312     }
1313   }
1314 
1315   if (class_loader.is_null()) {
1316     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1317     // The NULL classloader can load archived class originated from the
1318     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1319     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1320     // by the NULL classloader.
1321     if (mod_entry != NULL) {
1322       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1323       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
1324       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
1325         return true; // Module class from the &quot;module&quot; jimage
1326       }
1327     }
1328 
1329     // If the archived class is not from the &quot;module&quot; jimage, the class can be
1330     // loaded by the NULL classloader if
1331     //
1332     // 1. the class is from the unamed package
1333     // 2. or, the class is not from a module defined in the NULL classloader
1334     // 3. or, the class is from an unamed module
1335     if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
1336       // the class is from the -Xbootclasspath/a
1337       if (pkg_name == NULL ||
1338           pkg_entry == NULL ||
1339           pkg_entry-&gt;in_unnamed_module()) {
1340         assert(mod_entry == NULL ||
1341                mod_entry == loader_data-&gt;unnamed_module(),
1342                &quot;the unnamed module is not defined in the classloader&quot;);
1343         return true;
1344       }
1345     }
1346     return false;
1347   } else {
1348     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
1349               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));
1350     return res;
1351   }
1352 }
1353 
1354 bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,
1355                                                      Handle class_loader,  Handle protection_domain,
1356                                                      bool is_superclass, TRAPS) {
1357   assert(super_type-&gt;is_shared(), &quot;must be&quot;);
1358 
1359   Klass *found = resolve_super_or_fail(child-&gt;name(), super_type-&gt;name(),
1360                                        class_loader, protection_domain, is_superclass, CHECK_0);
1361   if (found == super_type) {
1362     return true;
1363   } else {
1364     // The dynamically resolved super type is not the same as the one we used during dump time,
1365     // so we cannot use the child class.
1366     return false;
1367   }
1368 }
1369 
1370 bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
1371                                                       Handle protection_domain, TRAPS) {
1372   // Check the superclass and interfaces. They must be the same
1373   // as in dump time, because the layout of &lt;ik&gt; depends on
1374   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1375   //
1376   // If unexpected superclass or interfaces are found, we cannot
1377   // load &lt;ik&gt; from the shared archive.
1378 
1379   if (ik-&gt;super() != NULL &amp;&amp;
1380       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1381                                      class_loader, protection_domain, true, THREAD)) {
1382     return false;
1383   }
1384 
1385   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1386   int num_interfaces = interfaces-&gt;length();
1387   for (int index = 0; index &lt; num_interfaces; index++) {
1388     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1389       return false;
1390     }
1391   }
1392 
1393   return true;
1394 }
1395 
1396 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1397                                                    Handle class_loader,
1398                                                    Handle protection_domain,
1399                                                    const ClassFileStream *cfs,
1400                                                    PackageEntry* pkg_entry,
1401                                                    TRAPS) {
1402   assert(ik != NULL, &quot;sanity&quot;);
1403   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1404   Symbol* class_name = ik-&gt;name();
1405 
1406   bool visible = is_shared_class_visible(
1407                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1408   if (!visible) {
1409     return NULL;
1410   }
1411 
1412   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1413     return NULL;
1414   }
1415 
1416   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1417       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1418   if (new_ik != NULL) {
1419     // The class is changed by CFLH. Return the new class. The shared class is
1420     // not used.
1421     return new_ik;
1422   }
1423 
1424   // Adjust methods to recover missing data.  They need addresses for
1425   // interpreter entry points and their default native method address
1426   // must be reset.
1427 
1428   // Updating methods must be done under a lock so multiple
1429   // threads don&#39;t update these in parallel
1430   //
1431   // Shared classes are all currently loaded by either the bootstrap or
1432   // internal parallel class loaders, so this will never cause a deadlock
1433   // on a custom class loader lock.
1434 
1435   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1436   {
1437     HandleMark hm(THREAD);
1438     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1439     check_loader_lock_contention(lockObject, THREAD);
1440     ObjectLocker ol(lockObject, THREAD, true);
1441     // prohibited package check assumes all classes loaded from archive call
1442     // restore_unshareable_info which calls ik-&gt;set_package()
1443     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1444   }
1445 
1446   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1447   return ik;
1448 }
1449 
1450 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1451   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1452 
1453   // For boot loader, ensure that GetSystemPackage knows that a class in this
1454   // package was loaded.
1455   if (loader_data-&gt;is_the_null_class_loader_data()) {
1456     int path_index = ik-&gt;shared_classpath_index();
1457     ik-&gt;set_classpath_index(path_index, THREAD);
1458   }
1459 
1460   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1461     // Only dump the classes that can be stored into CDS archive
1462     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1463       ResourceMark rm(THREAD);
1464       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1465       classlist_file-&gt;flush();
1466     }
1467   }
1468 
1469   // notify a class loaded from shared object
1470   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1471 
1472   ik-&gt;set_has_passed_fingerprint_check(false);
1473   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1474     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1475     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1476     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1477       // This class matches with a class saved in an AOT library
1478       ik-&gt;set_has_passed_fingerprint_check(true);
1479     } else {
1480       if (log_is_enabled(Info, class, fingerprint)) {
1481         ResourceMark rm(THREAD);
1482         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1483       }
1484     }
1485   }
1486 }
1487 
1488 void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {
1489   assert(!Universe::is_fully_initialized(), &quot;We can make short cuts only during VM initialization&quot;);
1490   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1491   if (klass-&gt;class_loader_data() != NULL) {
1492     return;
1493   }
1494 
1495   // add super and interfaces first
1496   Klass* super = klass-&gt;super();
1497   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1498     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1499     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1500   }
1501 
1502   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1503   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1504     InstanceKlass* ik = ifs-&gt;at(i);
1505     if (ik-&gt;class_loader_data()  == NULL) {
1506       quick_resolve(ik, loader_data, domain, CHECK);
1507     }
1508   }
1509 
1510   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1511   load_shared_class_misc(klass, loader_data, CHECK);
1512   Dictionary* dictionary = loader_data-&gt;dictionary();
1513   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1514   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1515   add_to_hierarchy(klass, CHECK);
1516   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1517 }
1518 #endif // INCLUDE_CDS
1519 
1520 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1521 
1522   if (class_loader.is_null()) {
1523     ResourceMark rm(THREAD);
1524     PackageEntry* pkg_entry = NULL;
1525     bool search_only_bootloader_append = false;
1526     ClassLoaderData *loader_data = class_loader_data(class_loader);
1527 
1528     // Find the package in the boot loader&#39;s package entry table.
1529     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
1530     if (pkg_name != NULL) {
1531       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1532     }
1533 
1534     // Prior to attempting to load the class, enforce the boot loader&#39;s
1535     // visibility boundaries.
1536     if (!Universe::is_module_initialized()) {
1537       // During bootstrapping, prior to module initialization, any
1538       // class attempting to be loaded must be checked against the
1539       // java.base packages in the boot loader&#39;s PackageEntryTable.
1540       // No class outside of java.base is allowed to be loaded during
1541       // this bootstrapping window.
1542       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1543         // Class is either in the unnamed package or in
1544         // a named package within the unnamed module.  Either
1545         // case is outside of java.base, do not attempt to
1546         // load the class post java.base definition.  If
1547         // java.base has not been defined, let the class load
1548         // and its package will be checked later by
1549         // ModuleEntryTable::verify_javabase_packages.
1550         if (ModuleEntryTable::javabase_defined()) {
1551           return NULL;
1552         }
1553       } else {
1554         // Check that the class&#39; package is defined within java.base.
1555         ModuleEntry* mod_entry = pkg_entry-&gt;module();
1556         Symbol* mod_entry_name = mod_entry-&gt;name();
1557         if (mod_entry_name-&gt;fast_compare(vmSymbols::java_base()) != 0) {
1558           return NULL;
1559         }
1560       }
1561     } else {
1562       // After the module system has been initialized, check if the class&#39;
1563       // package is in a module defined to the boot loader.
1564       if (pkg_name == NULL || pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1565         // Class is either in the unnamed package, in a named package
1566         // within a module not defined to the boot loader or in a
1567         // a named package within the unnamed module.  In all cases,
1568         // limit visibility to search for the class only in the boot
1569         // loader&#39;s append path.
1570         if (!ClassLoader::has_bootclasspath_append()) {
1571            // If there is no bootclasspath append entry, no need to continue
1572            // searching.
1573            return NULL;
1574         }
1575         search_only_bootloader_append = true;
1576       }
1577     }
1578 
1579     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1580     // of the boot loader&#39;s module path
1581     assert(Universe::is_module_initialized() ||
1582            !search_only_bootloader_append,
1583            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1584 
1585     // Search for classes in the CDS archive.
1586     InstanceKlass* k = NULL;
1587     {
1588 #if INCLUDE_CDS
1589       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
1590       k = load_shared_boot_class(class_name, pkg_entry, THREAD);
1591 #endif
1592     }
1593 
1594     if (k == NULL) {
1595       // Use VM class loader
1596       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1597       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1598     }
1599 
1600     // find_or_define_instance_class may return a different InstanceKlass
1601     if (k != NULL) {
1602       InstanceKlass* defined_k =
1603         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1604       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1605         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1606         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1607         loader_data-&gt;add_to_deallocate_list(k);
1608         k = defined_k;
1609       } else if (HAS_PENDING_EXCEPTION) {
1610         loader_data-&gt;add_to_deallocate_list(k);
1611         return NULL;
1612       }
1613     }
1614     return k;
1615   } else {
1616     // Use user specified class loader to load class. Call loadClass operation on class_loader.
1617     ResourceMark rm(THREAD);
1618 
1619     assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1620     JavaThread* jt = (JavaThread*) THREAD;
1621 
1622     PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),
1623                                ClassLoader::perf_app_classload_selftime(),
1624                                ClassLoader::perf_app_classload_count(),
1625                                jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1626                                jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1627                                PerfClassTraceTime::CLASS_LOAD);
1628 
1629     Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);
1630     // Translate to external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
1631     Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);
1632 
1633     JavaValue result(T_OBJECT);
1634 
1635     InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass();
1636 
1637     // Call public unsynchronized loadClass(String) directly for all class loaders.
1638     // For parallelCapable class loaders, JDK &gt;=7, loadClass(String, boolean) will
1639     // acquire a class-name based lock rather than the class loader object lock.
1640     // JDK &lt; 7 already acquire the class loader lock in loadClass(String, boolean).
1641     JavaCalls::call_virtual(&amp;result,
1642                             class_loader,
1643                             spec_klass,
1644                             vmSymbols::loadClass_name(),
1645                             vmSymbols::string_class_signature(),
1646                             string,
1647                             CHECK_NULL);
1648 
1649     assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);
1650     oop obj = (oop) result.get_jobject();
1651 
1652     // Primitive classes return null since forName() can not be
1653     // used to obtain any of the Class objects representing primitives or void
1654     if ((obj != NULL) &amp;&amp; !(java_lang_Class::is_primitive(obj))) {
1655       InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));
1656       // For user defined Java class loaders, check that the name returned is
1657       // the same as that requested.  This check is done for the bootstrap
1658       // loader when parsing the class file.
1659       if (class_name == k-&gt;name()) {
1660         return k;
1661       }
1662     }
1663     // Class is not found or has the wrong name, return NULL
1664     return NULL;
1665   }
1666 }
1667 
1668 static void post_class_define_event(InstanceKlass* k, const ClassLoaderData* def_cld) {
1669   EventClassDefine event;
1670   if (event.should_commit()) {
1671     event.set_definedClass(k);
1672     event.set_definingClassLoader(def_cld);
1673     event.commit();
1674   }
1675 }
1676 
1677 void SystemDictionary::define_instance_class(InstanceKlass* k, TRAPS) {
1678 
1679   HandleMark hm(THREAD);
1680   ClassLoaderData* loader_data = k-&gt;class_loader_data();
1681   Handle class_loader_h(THREAD, loader_data-&gt;class_loader());
1682 
1683  // for bootstrap and other parallel classloaders don&#39;t acquire lock,
1684  // use placeholder token
1685  // If a parallelCapable class loader calls define_instance_class instead of
1686  // find_or_define_instance_class to get here, we have a timing
1687  // hole with systemDictionary updates and check_constraints
1688  if (!class_loader_h.is_null() &amp;&amp; !is_parallelCapable(class_loader_h)) {
1689     assert(ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD,
1690          compute_loader_lock_object(class_loader_h, THREAD)),
1691          &quot;define called without lock&quot;);
1692   }
1693 
1694   // Check class-loading constraints. Throw exception if violation is detected.
1695   // Grabs and releases SystemDictionary_lock
1696   // The check_constraints/find_class call and update_dictionary sequence
1697   // must be &quot;atomic&quot; for a specific class/classloader pair so we never
1698   // define two different instanceKlasses for that class/classloader pair.
1699   // Existing classloaders will call define_instance_class with the
1700   // classloader lock held
1701   // Parallel classloaders will call find_or_define_instance_class
1702   // which will require a token to perform the define class
1703   Symbol*  name_h = k-&gt;name();
1704   Dictionary* dictionary = loader_data-&gt;dictionary();
1705   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1706   check_constraints(d_hash, k, class_loader_h, true, CHECK);
1707 
1708   // Register class just loaded with class loader (placed in ArrayList)
1709   // Note we do this before updating the dictionary, as this can
1710   // fail with an OutOfMemoryError (if it does, we will *not* put this
1711   // class in the dictionary and will not update the class hierarchy).
1712   // JVMTI FollowReferences needs to find the classes this way.
1713   if (k-&gt;class_loader() != NULL) {
1714     methodHandle m(THREAD, Universe::loader_addClass_method());
1715     JavaValue result(T_VOID);
1716     JavaCallArguments args(class_loader_h);
1717     args.push_oop(Handle(THREAD, k-&gt;java_mirror()));
1718     JavaCalls::call(&amp;result, m, &amp;args, CHECK);
1719   }
1720 
1721   // Add the new class. We need recompile lock during update of CHA.
1722   {
1723     unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1724     int p_index = placeholders()-&gt;hash_to_index(p_hash);
1725 
1726     MutexLocker mu_r(THREAD, Compile_lock);
1727 
1728     // Add to class hierarchy, initialize vtables, and do possible
1729     // deoptimizations.
1730     add_to_hierarchy(k, CHECK); // No exception, but can block
1731 
1732     // Add to systemDictionary - so other classes can see it.
1733     // Grabs and releases SystemDictionary_lock
1734     update_dictionary(d_hash, p_index, p_hash,
1735                       k, class_loader_h, THREAD);
1736   }
1737   k-&gt;eager_initialize(THREAD);
1738 
1739   // notify jvmti
1740   if (JvmtiExport::should_post_class_load()) {
1741       assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1742       JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1743 
1744   }
1745   post_class_define_event(k, loader_data);
1746 }
1747 
1748 // Support parallel classloading
1749 // All parallel class loaders, including bootstrap classloader
1750 // lock a placeholder entry for this class/class_loader pair
1751 // to allow parallel defines of different classes for this class loader
1752 // With AllowParallelDefine flag==true, in case they do not synchronize around
1753 // FindLoadedClass/DefineClass, calls, we check for parallel
1754 // loading for them, wait if a defineClass is in progress
1755 // and return the initial requestor&#39;s results
1756 // This flag does not apply to the bootstrap classloader.
1757 // With AllowParallelDefine flag==false, call through to define_instance_class
1758 // which will throw LinkageError: duplicate class definition.
1759 // False is the requested default.
1760 // For better performance, the class loaders should synchronize
1761 // findClass(), i.e. FindLoadedClass/DefineClassIfAbsent or they
1762 // potentially waste time reading and parsing the bytestream.
1763 // Note: VM callers should ensure consistency of k/class_name,class_loader
1764 // Be careful when modifying this code: once you have run
1765 // placeholders()-&gt;find_and_add(PlaceholderTable::DEFINE_CLASS),
1766 // you need to find_and_remove it before returning.
1767 // So be careful to not exit with a CHECK_ macro betweeen these calls.
1768 InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,
1769                                                                InstanceKlass* k, TRAPS) {
1770 
1771   Symbol*  name_h = k-&gt;name(); // passed in class_name may be null
1772   ClassLoaderData* loader_data = class_loader_data(class_loader);
1773   Dictionary* dictionary = loader_data-&gt;dictionary();
1774 
1775   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1776 
1777   // Hold SD lock around find_class and placeholder creation for DEFINE_CLASS
1778   unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1779   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1780   PlaceholderEntry* probe;
1781 
1782   {
1783     MutexLocker mu(THREAD, SystemDictionary_lock);
1784     // First check if class already defined
1785     if (is_parallelDefine(class_loader)) {
1786       InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1787       if (check != NULL) {
1788         return check;
1789       }
1790     }
1791 
1792     // Acquire define token for this class/classloader
1793     probe = placeholders()-&gt;find_and_add(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, NULL, THREAD);
1794     // Wait if another thread defining in parallel
1795     // All threads wait - even those that will throw duplicate class: otherwise
1796     // caller is surprised by LinkageError: duplicate, but findLoadedClass fails
1797     // if other thread has not finished updating dictionary
1798     while (probe-&gt;definer() != NULL) {
1799       SystemDictionary_lock-&gt;wait();
1800     }
1801     // Only special cases allow parallel defines and can use other thread&#39;s results
1802     // Other cases fall through, and may run into duplicate defines
1803     // caught by finding an entry in the SystemDictionary
1804     if (is_parallelDefine(class_loader) &amp;&amp; (probe-&gt;instance_klass() != NULL)) {
1805         placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1806         SystemDictionary_lock-&gt;notify_all();
1807 #ifdef ASSERT
1808         InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1809         assert(check != NULL, &quot;definer missed recording success&quot;);
1810 #endif
1811         return probe-&gt;instance_klass();
1812     } else {
1813       // This thread will define the class (even if earlier thread tried and had an error)
1814       probe-&gt;set_definer(THREAD);
1815     }
1816   }
1817 
1818   define_instance_class(k, THREAD);
1819 
1820   Handle linkage_exception = Handle(); // null handle
1821 
1822   // definer must notify any waiting threads
1823   {
1824     MutexLocker mu(THREAD, SystemDictionary_lock);
1825     PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
1826     assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
1827     if (probe != NULL) {
1828       if (HAS_PENDING_EXCEPTION) {
1829         linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
1830         CLEAR_PENDING_EXCEPTION;
1831       } else {
1832         probe-&gt;set_instance_klass(k);
1833       }
1834       probe-&gt;set_definer(NULL);
1835       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1836       SystemDictionary_lock-&gt;notify_all();
1837     }
1838   }
1839 
1840   // Can&#39;t throw exception while holding lock due to rank ordering
1841   if (linkage_exception() != NULL) {
1842     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1843   }
1844 
1845   return k;
1846 }
1847 
1848 Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
1849   // If class_loader is NULL we synchronize on _system_loader_lock_obj
1850   if (class_loader.is_null()) {
1851     return Handle(THREAD, _system_loader_lock_obj);
1852   } else {
1853     return class_loader;
1854   }
1855 }
1856 
1857 // This method is added to check how often we have to wait to grab loader
1858 // lock. The results are being recorded in the performance counters defined in
1859 // ClassLoader::_sync_systemLoaderLockContentionRate and
1860 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1861 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1862   if (!UsePerfData) {
1863     return;
1864   }
1865 
1866   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1867 
1868   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1869       == ObjectSynchronizer::owner_other) {
1870     // contention will likely happen, so increment the corresponding
1871     // contention counter.
1872     if (loader_lock() == _system_loader_lock_obj) {
1873       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1874     } else {
1875       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1876     }
1877   }
1878 }
1879 
1880 // ----------------------------------------------------------------------------
1881 // Lookup
1882 
1883 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
1884                                             Symbol* class_name,
1885                                             Dictionary* dictionary) {
1886   assert_locked_or_safepoint(SystemDictionary_lock);
1887   int index = dictionary-&gt;hash_to_index(hash);
1888   return dictionary-&gt;find_class(index, hash, class_name);
1889 }
1890 
1891 
1892 // Basic find on classes in the midst of being loaded
1893 Symbol* SystemDictionary::find_placeholder(Symbol* class_name,
1894                                            ClassLoaderData* loader_data) {
1895   assert_locked_or_safepoint(SystemDictionary_lock);
1896   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
1897   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1898   return placeholders()-&gt;find_entry(p_index, p_hash, class_name, loader_data);
1899 }
1900 
1901 
1902 // Used for assertions and verification only
1903 // Precalculating the hash and index is an optimization because there are many lookups
1904 // before adding the class.
1905 InstanceKlass* SystemDictionary::find_class(Symbol* class_name, ClassLoaderData* loader_data) {
1906   assert_locked_or_safepoint(SystemDictionary_lock);
1907   #ifndef ASSERT
1908   guarantee(VerifyBeforeGC      ||
1909             VerifyDuringGC      ||
1910             VerifyBeforeExit    ||
1911             VerifyDuringStartup ||
1912             VerifyAfterGC, &quot;too expensive&quot;);
1913   #endif
1914 
1915   Dictionary* dictionary = loader_data-&gt;dictionary();
1916   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1917   return find_class(d_hash, class_name, dictionary);
1918 }
1919 
1920 
1921 // ----------------------------------------------------------------------------
1922 // Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock
1923 // is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in
1924 // before a new class is used.
1925 
1926 void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {
1927   assert(k != NULL, &quot;just checking&quot;);
1928   if (Universe::is_fully_initialized()) {
1929     assert_locked_or_safepoint(Compile_lock);
1930   }
1931 
1932   k-&gt;set_init_state(InstanceKlass::loaded);
1933   // make sure init_state store is already done.
1934   // The compiler reads the hierarchy outside of the Compile_lock.
1935   // Access ordering is used to add to hierarchy.
1936 
1937   // Link into hierachy.
1938   k-&gt;append_to_sibling_list();                    // add to superklass/sibling list
1939   k-&gt;process_interfaces(THREAD);                  // handle all &quot;implements&quot; declarations
1940 
1941   // Now flush all code that depended on old class hierarchy.
1942   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
1943   if (Universe::is_fully_initialized()) {
1944     CodeCache::flush_dependents_on(k);
1945   }
1946 }
1947 
1948 // ----------------------------------------------------------------------------
1949 // GC support
1950 
1951 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
1952 // Note: anonymous classes are not in the SD.
1953 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
1954 
1955   bool unloading_occurred;
1956   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
1957   {
1958     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
1959     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
1960     // First, mark for unload all ClassLoaderData referencing a dead class loader.
1961     unloading_occurred = ClassLoaderDataGraph::do_unloading();
1962     if (unloading_occurred) {
1963       MutexLocker ml2(is_concurrent ? Module_lock : NULL);
1964       JFR_ONLY(Jfr::on_unloading_classes();)
1965 
1966       MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);
1967       ClassLoaderDataGraph::clean_module_and_package_info();
1968       constraints()-&gt;purge_loader_constraints();
1969       resolution_errors()-&gt;purge_resolution_errors();
1970     }
1971   }
1972 
1973   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
1974 
1975   if (unloading_occurred) {
1976     SymbolTable::trigger_cleanup();
1977 
1978     // Oops referenced by the protection domain cache table may get unreachable independently
1979     // of the class loader (eg. cached protection domain oops). So we need to
1980     // explicitly unlink them here.
1981     // All protection domain oops are linked to the caller class, so if nothing
1982     // unloads, this is not needed.
1983     _pd_cache_table-&gt;trigger_cleanup();
1984   }
1985 
1986   return unloading_occurred;
1987 }
1988 
1989 void SystemDictionary::oops_do(OopClosure* f, bool include_handles) {
1990   f-&gt;do_oop(&amp;_java_system_loader);
1991   f-&gt;do_oop(&amp;_java_platform_loader);
1992   f-&gt;do_oop(&amp;_system_loader_lock_obj);
1993   CDS_ONLY(SystemDictionaryShared::oops_do(f);)
1994 
1995   // Visit extra methods
1996   invoke_method_table()-&gt;oops_do(f);
1997 
1998   if (include_handles) {
1999     OopStorageSet::vm_global()-&gt;oops_do(f);
2000   }
2001 }
2002 
2003 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
2004 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
2005   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
2006     it-&gt;push(well_known_klass_addr((WKID)id));
2007   }
2008 }
2009 
2010 void SystemDictionary::methods_do(void f(Method*)) {
2011   // Walk methods in loaded classes
2012   MutexLocker ml(ClassLoaderDataGraph_lock);
2013   ClassLoaderDataGraph::methods_do(f);
2014   // Walk method handle intrinsics
2015   invoke_method_table()-&gt;methods_do(f);
2016 }
2017 
2018 // ----------------------------------------------------------------------------
2019 // Initialization
2020 
2021 void SystemDictionary::initialize(TRAPS) {
2022   // Allocate arrays
2023   _placeholders        = new PlaceholderTable(_placeholder_table_size);
2024   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
2025   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
2026   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
2027   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
2028 
2029   // Allocate private object used as system class loader lock
2030   _system_loader_lock_obj = oopFactory::new_intArray(0, CHECK);
2031   // Initialize basic classes
2032   resolve_well_known_classes(CHECK);
2033 }
2034 
2035 // Compact table of directions on the initialization of klasses:
2036 static const short wk_init_info[] = {
2037   #define WK_KLASS_INIT_INFO(name, symbol) \
2038     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
2039 
2040   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
2041   #undef WK_KLASS_INIT_INFO
2042   0
2043 };
2044 
2045 #ifdef ASSERT
2046 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
2047   int sid;
2048   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
2049     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2050     if (class_name == symbol) {
2051       return true;
2052     }
2053   }
2054   return false;
2055 }
2056 #endif
2057 
2058 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
2059   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2060   int sid = wk_init_info[id - FIRST_WKID];
2061   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2062   InstanceKlass** klassp = &amp;_well_known_klasses[id];
2063 
2064 #if INCLUDE_CDS
2065   if (UseSharedSpaces &amp;&amp; !JvmtiExport::should_post_class_prepare()) {
2066     InstanceKlass* k = *klassp;
2067     assert(k-&gt;is_shared_boot_class(), &quot;must be&quot;);
2068 
2069     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
2070     quick_resolve(k, loader_data, Handle(), CHECK_false);
2071     return true;
2072   }
2073 #endif // INCLUDE_CDS
2074 
2075   if (!is_wk_klass_loaded(*klassp)) {
2076     Klass* k = resolve_or_fail(symbol, true, CHECK_false);
2077     (*klassp) = InstanceKlass::cast(k);
2078   }
2079   return ((*klassp) != NULL);
2080 }
2081 
2082 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
2083   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
2084   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
2085     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2086     resolve_wk_klass((WKID)id, CHECK);
2087   }
2088 
2089   // move the starting value forward to the limit:
2090   start_id = limit_id;
2091 }
2092 
2093 void SystemDictionary::resolve_well_known_classes(TRAPS) {
2094   assert(!Object_klass_loaded(), &quot;well-known classes should only be initialized once&quot;);
2095 
2096   // Create the ModuleEntry for java.base.  This call needs to be done here,
2097   // after vmSymbols::initialize() is called but before any classes are pre-loaded.
2098   ClassLoader::classLoader_init2(CHECK);
2099 
2100   // Preload commonly used klasses
2101   WKID scan = FIRST_WKID;
2102   // first do Object, then String, Class
2103 #if INCLUDE_CDS
2104   if (UseSharedSpaces) {
2105     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);
2106 
2107     // It&#39;s unsafe to access the archived heap regions before they
2108     // are fixed up, so we must do the fixup as early as possible
2109     // before the archived java objects are accessed by functions
2110     // such as java_lang_Class::restore_archived_mirror and
2111     // ConstantPool::restore_unshareable_info (restores the archived
2112     // resolved_references array object).
2113     //
2114     // HeapShared::fixup_mapped_heap_regions() fills the empty
2115     // spaces in the archived heap regions and may use
2116     // SystemDictionary::Object_klass(), so we can do this only after
2117     // Object_klass is resolved. See the above resolve_wk_klasses_through()
2118     // call. No mirror objects are accessed/restored in the above call.
2119     // Mirrors are restored after java.lang.Class is loaded.
2120     HeapShared::fixup_mapped_heap_regions();
2121 
2122     // Initialize the constant pool for the Object_class
2123     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
2124     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
2125     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2126   } else
2127 #endif
2128   {
2129     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2130   }
2131 
2132   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);
2133 
2134   java_lang_Object::register_natives(CHECK);
2135 
2136   // Calculate offsets for String and Class classes since they are loaded and
2137   // can be used after this point.
2138   java_lang_String::compute_offsets();
2139   java_lang_Class::compute_offsets();
2140 
2141   // Fixup mirrors for classes loaded before java.lang.Class.
2142   Universe::initialize_basic_type_mirrors(CHECK);
2143   Universe::fixup_mirrors(CHECK);
2144 
2145   // do a bunch more:
2146   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
2147 
2148   // Preload ref klasses and set reference types
2149   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);
2150   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2151 
2152   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
2153   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);
2154   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);
2155   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);
2156   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);
2157 
2158   // JSR 292 classes
2159   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2160   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2161   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2162   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
2163   WKID last = WKID_LIMIT;
2164   resolve_wk_klasses_until(last, scan, CHECK);
2165 
2166   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2167   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2168   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2169   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2170   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2171   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2172   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2173   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2174   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2175   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2176 
2177 #ifdef ASSERT
2178   if (UseSharedSpaces) {
2179     JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),
2180                       &quot;All well known classes must be resolved in JVMTI early phase&quot;));
2181     for (int i = FIRST_WKID; i &lt; last; i++) {
2182       InstanceKlass* k = _well_known_klasses[i];
2183       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2184     }
2185   }
2186 #endif
2187 }
2188 
2189 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2190 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2191 BasicType SystemDictionary::box_klass_type(Klass* k) {
2192   assert(k != NULL, &quot;&quot;);
2193   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2194     if (_box_klasses[i] == k)
2195       return (BasicType)i;
2196   }
2197   return T_OBJECT;
2198 }
2199 
2200 // Constraints on class loaders. The details of the algorithm can be
2201 // found in the OOPSLA&#39;98 paper &quot;Dynamic Class Loading in the Java
2202 // Virtual Machine&quot; by Sheng Liang and Gilad Bracha.  The basic idea is
2203 // that the dictionary needs to maintain a set of contraints that
2204 // must be satisfied by all classes in the dictionary.
2205 // if defining is true, then LinkageError if already in dictionary
2206 // if initiating loader, then ok if InstanceKlass matches existing entry
2207 
2208 void SystemDictionary::check_constraints(unsigned int d_hash,
2209                                          InstanceKlass* k,
2210                                          Handle class_loader,
2211                                          bool defining,
2212                                          TRAPS) {
2213   ResourceMark rm(THREAD);
2214   stringStream ss;
2215   bool throwException = false;
2216 
2217   {
2218     Symbol *name = k-&gt;name();
2219     ClassLoaderData *loader_data = class_loader_data(class_loader);
2220 
2221     MutexLocker mu(THREAD, SystemDictionary_lock);
2222 
2223     InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
2224     if (check != NULL) {
2225       // If different InstanceKlass - duplicate class definition,
2226       // else - ok, class loaded by a different thread in parallel.
2227       // We should only have found it if it was done loading and ok to use.
2228       // The dictionary only holds instance classes, placeholders
2229       // also hold array classes.
2230 
2231       assert(check-&gt;is_instance_klass(), &quot;noninstance in systemdictionary&quot;);
2232       if ((defining == true) || (k != check)) {
2233         throwException = true;
2234         ss.print(&quot;loader %s&quot;, loader_data-&gt;loader_name_and_id());
2235         ss.print(&quot; attempted duplicate %s definition for %s. (%s)&quot;,
2236                  k-&gt;external_kind(), k-&gt;external_name(), k-&gt;class_in_module_of_loader(false, true));
2237       } else {
2238         return;
2239       }
2240     }
2241 
2242 #ifdef ASSERT
2243     Symbol* ph_check = find_placeholder(name, loader_data);
2244     assert(ph_check == NULL || ph_check == name, &quot;invalid symbol&quot;);
2245 #endif
2246 
2247     if (throwException == false) {
2248       if (constraints()-&gt;check_or_update(k, class_loader, name) == false) {
2249         throwException = true;
2250         ss.print(&quot;loader constraint violation: loader %s&quot;, loader_data-&gt;loader_name_and_id());
2251         ss.print(&quot; wants to load %s %s.&quot;,
2252                  k-&gt;external_kind(), k-&gt;external_name());
2253         Klass *existing_klass = constraints()-&gt;find_constrained_klass(name, class_loader);
2254         if (existing_klass != NULL &amp;&amp; existing_klass-&gt;class_loader() != class_loader()) {
2255           ss.print(&quot; A different %s with the same name was previously loaded by %s. (%s)&quot;,
2256                    existing_klass-&gt;external_kind(),
2257                    existing_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
2258                    existing_klass-&gt;class_in_module_of_loader(false, true));
2259         } else {
2260           ss.print(&quot; (%s)&quot;, k-&gt;class_in_module_of_loader(false, true));
2261         }
2262       }
2263     }
2264   }
2265 
2266   // Throw error now if needed (cannot throw while holding
2267   // SystemDictionary_lock because of rank ordering)
2268   if (throwException == true) {
2269     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
2270   }
2271 }
2272 
2273 // Update class loader data dictionary - done after check_constraint and add_to_hierachy
2274 // have been called.
2275 void SystemDictionary::update_dictionary(unsigned int d_hash,
2276                                          int p_index, unsigned int p_hash,
2277                                          InstanceKlass* k,
2278                                          Handle class_loader,
2279                                          TRAPS) {
2280   // Compile_lock prevents systemDictionary updates during compilations
2281   assert_locked_or_safepoint(Compile_lock);
2282   Symbol*  name  = k-&gt;name();
2283   ClassLoaderData *loader_data = class_loader_data(class_loader);
2284 
2285   {
2286     MutexLocker mu1(THREAD, SystemDictionary_lock);
2287 
2288     // Make a new dictionary entry.
2289     Dictionary* dictionary = loader_data-&gt;dictionary();
2290     InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
2291     if (sd_check == NULL) {
2292       dictionary-&gt;add_klass(d_hash, name, k);
2293     }
2294   #ifdef ASSERT
2295     sd_check = find_class(d_hash, name, dictionary);
2296     assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
2297     // Note: there may be a placeholder entry: for circularity testing
2298     // or for parallel defines
2299   #endif
2300     SystemDictionary_lock-&gt;notify_all();
2301   }
2302 }
2303 
2304 
2305 // Try to find a class name using the loader constraints.  The
2306 // loader constraints might know about a class that isn&#39;t fully loaded
2307 // yet and these will be ignored.
2308 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2309                     Symbol* class_name, Handle class_loader, TRAPS) {
2310 
2311   // First see if it has been loaded directly.
2312   // Force the protection domain to be null.  (This removes protection checks.)
2313   Handle no_protection_domain;
2314   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2315                                               no_protection_domain, CHECK_NULL);
2316   if (klass != NULL)
2317     return klass;
2318 
2319   // Now look to see if it has been loaded elsewhere, and is subject to
2320   // a loader constraint that would require this loader to return the
2321   // klass that is already loaded.
2322   if (Signature::is_array(class_name)) {
2323     // For array classes, their Klass*s are not kept in the
2324     // constraint table. The element Klass*s are.
2325     SignatureStream ss(class_name, false);
2326     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2327     BasicType t = ss.type();
2328     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
2329       klass = Universe::typeArrayKlassObj(t);
2330     } else {
2331       MutexLocker mu(THREAD, SystemDictionary_lock);
2332       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2333     }
2334     // If element class already loaded, allocate array klass
2335     if (klass != NULL) {
2336       klass = klass-&gt;array_klass_or_null(ndims);
2337     }
2338   } else {
2339     MutexLocker mu(THREAD, SystemDictionary_lock);
2340     // Non-array classes are easy: simply check the constraint table.
2341     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2342   }
2343 
2344   return klass;
2345 }
2346 
<a name="1" id="anc1"></a><span class="line-modified">2347 bool SystemDictionary::add_loader_constraint(Symbol* class_name,</span>
2348                                              Klass* klass_being_linked,
2349                                              Handle class_loader1,
2350                                              Handle class_loader2,
2351                                              Thread* THREAD) {
2352   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2353   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2354 
2355   Symbol* constraint_name = NULL;
2356 
2357   if (!Signature::is_array(class_name)) {
2358     constraint_name = class_name;
2359   } else {
2360     // For array classes, their Klass*s are not kept in the
2361     // constraint table. The element classes are.
2362     SignatureStream ss(class_name, false);
2363     ss.skip_array_prefix();  // skip all &#39;[&#39;s
2364     if (!ss.has_envelope()) {
2365       return true;     // primitive types always pass
2366     }
2367     constraint_name = ss.as_symbol();
2368     // Increment refcount to keep constraint_name alive after
2369     // SignatureStream is destructed. It will be decremented below
2370     // before returning.
2371     constraint_name-&gt;increment_refcount();
2372   }
2373 
2374   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2375   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2376 
2377   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2378   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2379 
2380   {
2381     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2382     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2383     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
2384     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,
2385                                            klass2, class_loader2);
<a name="2" id="anc2"></a><span class="line-added">2386 #if INCLUDE_CDS</span>
<span class="line-added">2387     if (Arguments::is_dumping_archive() &amp;&amp; klass_being_linked != NULL &amp;&amp;</span>
<span class="line-added">2388         !klass_being_linked-&gt;is_shared()) {</span>
<span class="line-added">2389          SystemDictionaryShared::record_linking_constraint(constraint_name,</span>
<span class="line-added">2390                                      InstanceKlass::cast(klass_being_linked),</span>
<span class="line-added">2391                                      class_loader1, class_loader2, THREAD);</span>
<span class="line-added">2392     }</span>
<span class="line-added">2393 #endif // INCLUDE_CDS</span>
2394     if (Signature::is_array(class_name)) {
2395       constraint_name-&gt;decrement_refcount();
2396     }
2397     return result;
2398   }
2399 }
2400 
2401 // Add entry to resolution error table to record the error when the first
2402 // attempt to resolve a reference to a class has failed.
2403 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2404                                             Symbol* error, Symbol* message) {
2405   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2406   int index = resolution_errors()-&gt;hash_to_index(hash);
2407   {
2408     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2409     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2410   }
2411 }
2412 
2413 // Delete a resolution error for RedefineClasses for a constant pool is going away
2414 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2415   resolution_errors()-&gt;delete_entry(pool);
2416 }
2417 
2418 // Lookup resolution error table. Returns error if found, otherwise NULL.
2419 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2420                                                 Symbol** message) {
2421   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2422   int index = resolution_errors()-&gt;hash_to_index(hash);
2423   {
2424     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2425     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2426     if (entry != NULL) {
2427       *message = entry-&gt;message();
2428       return entry-&gt;error();
2429     } else {
2430       return NULL;
2431     }
2432   }
2433 }
2434 
2435 // Add an entry to resolution error table to record an error in resolving or
2436 // validating a nest host. This is used to construct informative error
2437 // messages when IllegalAccessError&#39;s occur. If an entry already exists it will
2438 // be updated with the nest host error message.
2439 void SystemDictionary::add_nest_host_error(const constantPoolHandle&amp; pool,
2440                                            int which,
2441                                            const char* message) {
2442   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2443   int index = resolution_errors()-&gt;hash_to_index(hash);
2444   {
2445     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2446     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2447     if (entry != NULL) {
2448       assert(entry-&gt;nest_host_error() == NULL, &quot;Nest host error message already set!&quot;);
2449       entry-&gt;set_nest_host_error(message);
2450     } else {
2451       resolution_errors()-&gt;add_entry(index, hash, pool, which, message);
2452     }
2453   }
2454 }
2455 
2456 // Lookup any nest host error
2457 const char* SystemDictionary::find_nest_host_error(const constantPoolHandle&amp; pool, int which) {
2458   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2459   int index = resolution_errors()-&gt;hash_to_index(hash);
2460   {
2461     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2462     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2463     if (entry != NULL) {
2464       return entry-&gt;nest_host_error();
2465     } else {
2466       return NULL;
2467     }
2468   }
2469 }
2470 
2471 
2472 // Signature constraints ensure that callers and callees agree about
2473 // the meaning of type names in their signatures.  This routine is the
2474 // intake for constraints.  It collects them from several places:
2475 //
2476 //  * LinkResolver::resolve_method (if check_access is true) requires
2477 //    that the resolving class (the caller) and the defining class of
2478 //    the resolved method (the callee) agree on each type in the
2479 //    method&#39;s signature.
2480 //
2481 //  * LinkResolver::resolve_interface_method performs exactly the same
2482 //    checks.
2483 //
2484 //  * LinkResolver::resolve_field requires that the constant pool
2485 //    attempting to link to a field agree with the field&#39;s defining
2486 //    class about the type of the field signature.
2487 //
2488 //  * klassVtable::initialize_vtable requires that, when a class
2489 //    overrides a vtable entry allocated by a superclass, that the
2490 //    overriding method (i.e., the callee) agree with the superclass
2491 //    on each type in the method&#39;s signature.
2492 //
2493 //  * klassItable::initialize_itable requires that, when a class fills
2494 //    in its itables, for each non-abstract method installed in an
2495 //    itable, the method (i.e., the callee) agree with the interface
2496 //    on each type in the method&#39;s signature.
2497 //
2498 // All those methods have a boolean (check_access, checkconstraints)
2499 // which turns off the checks.  This is used from specialized contexts
2500 // such as bootstrapping, dumping, and debugging.
2501 //
2502 // No direct constraint is placed between the class and its
2503 // supertypes.  Constraints are only placed along linked relations
2504 // between callers and callees.  When a method overrides or implements
2505 // an abstract method in a supertype (superclass or interface), the
2506 // constraints are placed as if the supertype were the caller to the
2507 // overriding method.  (This works well, since callers to the
2508 // supertype have already established agreement between themselves and
2509 // the supertype.)  As a result of all this, a class can disagree with
2510 // its supertype about the meaning of a type name, as long as that
2511 // class neither calls a relevant method of the supertype, nor is
2512 // called (perhaps via an override) from the supertype.
2513 //
2514 //
<a name="3" id="anc3"></a><span class="line-modified">2515 // SystemDictionary::check_signature_loaders(sig, klass_being_linked, l1, l2)</span>
2516 //
2517 // Make sure all class components (including arrays) in the given
2518 // signature will be resolved to the same class in both loaders.
2519 // Returns the name of the type that failed a loader constraint check, or
2520 // NULL if no constraint failed.  No exception except OOME is thrown.
2521 // Arrays are not added to the loader constraint table, their elements are.
2522 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
<a name="4" id="anc4"></a><span class="line-added">2523                                                Klass* klass_being_linked,</span>
2524                                                Handle loader1, Handle loader2,
2525                                                bool is_method, TRAPS)  {
2526   // Nothing to do if loaders are the same.
2527   if (loader1() == loader2()) {
2528     return NULL;
2529   }
2530 
2531   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {
2532     if (ss.is_reference()) {
2533       Symbol* sig = ss.as_symbol();
2534       // Note: In the future, if template-like types can take
2535       // arguments, we will want to recognize them and dig out class
2536       // names hiding inside the argument lists.
<a name="5" id="anc5"></a><span class="line-modified">2537       if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2, THREAD)) {</span>
2538         return sig;
2539       }
2540     }
2541   }
2542   return NULL;
2543 }
2544 
<a name="6" id="anc6"></a>
2545 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2546                                                        Symbol* signature,
2547                                                        TRAPS) {
2548   methodHandle empty;
2549   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2550          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2551          iid != vmIntrinsics::_invokeGeneric,
2552          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2553 
2554   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2555   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2556   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2557   methodHandle m;
2558   if (spe == NULL || spe-&gt;method() == NULL) {
2559     spe = NULL;
2560     // Must create lots of stuff here, but outside of the SystemDictionary lock.
2561     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);
2562     if (!Arguments::is_interpreter_only()) {
2563       // Generate a compiled form of the MH intrinsic.
2564       AdapterHandlerLibrary::create_native_wrapper(m);
2565       // Check if have the compiled code.
2566       if (!m-&gt;has_compiled_code()) {
2567         THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),
2568                        &quot;Out of space in CodeCache for method handle intrinsic&quot;);
2569       }
2570     }
2571     // Now grab the lock.  We might have to throw away the new method,
2572     // if a racing thread has managed to install one at the same time.
2573     {
2574       MutexLocker ml(THREAD, SystemDictionary_lock);
2575       spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2576       if (spe == NULL)
2577         spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
2578       if (spe-&gt;method() == NULL)
2579         spe-&gt;set_method(m());
2580     }
2581   }
2582 
2583   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2584   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2585          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2586          &quot;MH intrinsic invariant&quot;);
2587   return spe-&gt;method();
2588 }
2589 
2590 // Helper for unpacking the return value from linkMethod and linkCallSite.
2591 static Method* unpack_method_and_appendix(Handle mname,
2592                                           Klass* accessing_klass,
2593                                           objArrayHandle appendix_box,
2594                                           Handle* appendix_result,
2595                                           TRAPS) {
2596   if (mname.not_null()) {
2597     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2598     if (m != NULL) {
2599       oop appendix = appendix_box-&gt;obj_at(0);
2600       LogTarget(Info, methodhandles) lt;
2601       if (lt.develop_is_enabled()) {
2602         ResourceMark rm(THREAD);
2603         LogStream ls(lt);
2604         ls.print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));
2605         m-&gt;print_on(&amp;ls);
2606         if (appendix != NULL) { ls.print(&quot;appendix = &quot;); appendix-&gt;print_on(&amp;ls); }
2607         ls.cr();
2608       }
2609 
2610       (*appendix_result) = Handle(THREAD, appendix);
2611       // the target is stored in the cpCache and if a reference to this
2612       // MemberName is dropped we need a way to make sure the
2613       // class_loader containing this method is kept alive.
2614       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2615       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2616       this_key-&gt;record_dependency(m-&gt;method_holder());
2617       return mh();
2618     }
2619   }
2620   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2621 }
2622 
2623 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2624                                                      Symbol* name,
2625                                                      Symbol* signature,
2626                                                           Klass* accessing_klass,
2627                                                           Handle *appendix_result,
2628                                                           TRAPS) {
2629   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2630   Handle method_type =
2631     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);
2632 
2633   int ref_kind = JVM_REF_invokeVirtual;
2634   oop name_oop = StringTable::intern(name, CHECK_NULL);
2635   Handle name_str (THREAD, name_oop);
2636   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);
2637   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2638 
2639   // This should not happen.  JDK code should take care of that.
2640   if (accessing_klass == NULL || method_type.is_null()) {
2641     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);
2642   }
2643 
2644   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2645   JavaCallArguments args;
2646   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2647   args.push_int(ref_kind);
2648   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
2649   args.push_oop(name_str);
2650   args.push_oop(method_type);
2651   args.push_oop(appendix_box);
2652   JavaValue result(T_OBJECT);
2653   JavaCalls::call_static(&amp;result,
2654                          SystemDictionary::MethodHandleNatives_klass(),
2655                          vmSymbols::linkMethod_name(),
2656                          vmSymbols::linkMethod_signature(),
2657                          &amp;args, CHECK_NULL);
2658   Handle mname(THREAD, (oop) result.get_jobject());
2659   return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
2660 }
2661 
2662 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2663 // We must ensure that all class loaders everywhere will reach this class, for any client.
2664 // This is a safe bet for public classes in java.lang, such as Object and String.
2665 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2666 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2667 static bool is_always_visible_class(oop mirror) {
2668   Klass* klass = java_lang_Class::as_Klass(mirror);
2669   if (klass-&gt;is_objArray_klass()) {
2670     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2671   }
2672   if (klass-&gt;is_typeArray_klass()) {
2673     return true; // primitive array
2674   }
2675   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2676   return klass-&gt;is_public() &amp;&amp;
2677          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2678           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2679 }
2680 
2681 // Find or construct the Java mirror (java.lang.Class instance) for
2682 // the given field type signature, as interpreted relative to the
2683 // given class loader.  Handles primitives, void, references, arrays,
2684 // and all other reflectable types, except method types.
2685 // N.B.  Code in reflection should use this entry point.
2686 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2687                                                    Klass* accessing_klass,
2688                                                    Handle class_loader,
2689                                                    Handle protection_domain,
2690                                                    SignatureStream::FailureMode failure_mode,
2691                                                    TRAPS) {
2692   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2693          &quot;one or the other, or perhaps neither&quot;);
2694 
2695   // What we have here must be a valid field descriptor,
2696   // and all valid field descriptors are supported.
2697   // Produce the same java.lang.Class that reflection reports.
2698   if (accessing_klass != NULL) {
2699     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2700     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2701   }
2702   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);
2703   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);
2704   if (mirror_oop == NULL) {
2705     return Handle();  // report failure this way
2706   }
2707   Handle mirror(THREAD, mirror_oop);
2708 
2709   if (accessing_klass != NULL) {
2710     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2711     Klass* sel_klass = java_lang_Class::as_Klass(mirror());
2712     if (sel_klass != NULL) {
2713       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_NH);
2714     }
2715   }
2716   return mirror;
2717 }
2718 
2719 
2720 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2721 // signature, as interpreted relative to the given class loader.
2722 // Because of class loader constraints, all method handle usage must be
2723 // consistent with this loader.
2724 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2725                                                  Klass* accessing_klass,
2726                                                  TRAPS) {
2727   Handle empty;
2728   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2729   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2730   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2731   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2732   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2733     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
2734     return Handle(THREAD, spe-&gt;method_type());
2735   } else if (!THREAD-&gt;can_call_java()) {
2736     warning(&quot;SystemDictionary::find_method_handle_type called from compiler thread&quot;);  // FIXME
2737     return Handle();  // do not attempt from within compiler, unless it was cached
2738   }
2739 
2740   Handle class_loader, protection_domain;
2741   if (accessing_klass != NULL) {
2742     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2743     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2744   }
2745   bool can_be_cached = true;
2746   int npts = ArgumentCount(signature).size();
2747   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2748   int arg = 0;
2749   Handle rt; // the return type from the signature
2750   ResourceMark rm(THREAD);
2751   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2752     oop mirror = NULL;
2753     if (can_be_cached) {
2754       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2755       mirror = ss.as_java_mirror(Handle(), Handle(),
2756                                  SignatureStream::ReturnNull, CHECK_(empty));
2757       if (mirror == NULL || (ss.is_reference() &amp;&amp; !is_always_visible_class(mirror))) {
2758         // Fall back to accessing_klass context.
2759         can_be_cached = false;
2760       }
2761     }
2762     if (!can_be_cached) {
2763       // Resolve, throwing a real error if it doesn&#39;t work.
2764       mirror = ss.as_java_mirror(class_loader, protection_domain,
2765                                  SignatureStream::NCDFError, CHECK_(empty));
2766     }
2767     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2768     if (ss.at_return_type())
2769       rt = Handle(THREAD, mirror);
2770     else
2771       pts-&gt;obj_at_put(arg++, mirror);
2772 
2773     // Check accessibility.
2774     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2775       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2776       mirror = NULL;  // safety
2777       // Emulate ConstantPool::verify_constant_pool_resolve.
2778       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_(empty));
2779     }
2780   }
2781   assert(arg == npts, &quot;&quot;);
2782 
2783   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2784   JavaCallArguments args(Handle(THREAD, rt()));
2785   args.push_oop(pts);
2786   JavaValue result(T_OBJECT);
2787   JavaCalls::call_static(&amp;result,
2788                          SystemDictionary::MethodHandleNatives_klass(),
2789                          vmSymbols::findMethodHandleType_name(),
2790                          vmSymbols::findMethodHandleType_signature(),
2791                          &amp;args, CHECK_(empty));
2792   Handle method_type(THREAD, (oop) result.get_jobject());
2793 
2794   if (can_be_cached) {
2795     // We can cache this MethodType inside the JVM.
2796     MutexLocker ml(THREAD, SystemDictionary_lock);
2797     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2798     if (spe == NULL)
2799       spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
2800     if (spe-&gt;method_type() == NULL) {
2801       spe-&gt;set_method_type(method_type());
2802     }
2803   }
2804 
2805   // report back to the caller with the MethodType
2806   return method_type;
2807 }
2808 
2809 Handle SystemDictionary::find_field_handle_type(Symbol* signature,
2810                                                 Klass* accessing_klass,
2811                                                 TRAPS) {
2812   Handle empty;
2813   ResourceMark rm(THREAD);
2814   SignatureStream ss(signature, /*is_method=*/ false);
2815   if (!ss.is_done()) {
2816     Handle class_loader, protection_domain;
2817     if (accessing_klass != NULL) {
2818       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2819       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2820     }
2821     oop mirror = ss.as_java_mirror(class_loader, protection_domain, SignatureStream::NCDFError, CHECK_(empty));
2822     ss.next();
2823     if (ss.is_done()) {
2824       return Handle(THREAD, mirror);
2825     }
2826   }
2827   return empty;
2828 }
2829 
2830 // Ask Java code to find or construct a method handle constant.
2831 Handle SystemDictionary::link_method_handle_constant(Klass* caller,
2832                                                      int ref_kind, //e.g., JVM_REF_invokeVirtual
2833                                                      Klass* callee,
2834                                                      Symbol* name,
2835                                                      Symbol* signature,
2836                                                      TRAPS) {
2837   Handle empty;
2838   if (caller == NULL) {
2839     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MH constant&quot;, empty);
2840   }
2841   Handle name_str      = java_lang_String::create_from_symbol(name,      CHECK_(empty));
2842   Handle signature_str = java_lang_String::create_from_symbol(signature, CHECK_(empty));
2843 
2844   // Put symbolic info from the MH constant into freshly created MemberName and resolve it.
2845   Handle mname = MemberName_klass()-&gt;allocate_instance_handle(CHECK_(empty));
2846   java_lang_invoke_MemberName::set_clazz(mname(), callee-&gt;java_mirror());
2847   java_lang_invoke_MemberName::set_name (mname(), name_str());
2848   java_lang_invoke_MemberName::set_type (mname(), signature_str());
2849   java_lang_invoke_MemberName::set_flags(mname(), MethodHandles::ref_kind_to_flags(ref_kind));
2850 
2851   if (ref_kind == JVM_REF_invokeVirtual &amp;&amp;
2852       MethodHandles::is_signature_polymorphic_public_name(callee, name)) {
2853     // Skip resolution for public signature polymorphic methods such as
2854     // j.l.i.MethodHandle.invoke()/invokeExact() and those on VarHandle
2855     // They require appendix argument which MemberName resolution doesn&#39;t handle.
2856     // There&#39;s special logic on JDK side to handle them
2857     // (see MethodHandles.linkMethodHandleConstant() and MethodHandles.findVirtualForMH()).
2858   } else {
2859     MethodHandles::resolve_MemberName(mname, caller, /*speculative_resolve*/false, CHECK_(empty));
2860   }
2861 
2862   // After method/field resolution succeeded, it&#39;s safe to resolve MH signature as well.
2863   Handle type = MethodHandles::resolve_MemberName_type(mname, caller, CHECK_(empty));
2864 
2865   // call java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant(Class caller, int refKind, Class callee, String name, Object type) -&gt; MethodHandle
2866   JavaCallArguments args;
2867   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));  // the referring class
2868   args.push_int(ref_kind);
2869   args.push_oop(Handle(THREAD, callee-&gt;java_mirror()));  // the target class
2870   args.push_oop(name_str);
2871   args.push_oop(type);
2872   JavaValue result(T_OBJECT);
2873   JavaCalls::call_static(&amp;result,
2874                          SystemDictionary::MethodHandleNatives_klass(),
2875                          vmSymbols::linkMethodHandleConstant_name(),
2876                          vmSymbols::linkMethodHandleConstant_signature(),
2877                          &amp;args, CHECK_(empty));
2878   return Handle(THREAD, (oop) result.get_jobject());
2879 }
2880 
2881 // Ask Java to run a bootstrap method, in order to create a dynamic call site
2882 // while linking an invokedynamic op, or compute a constant for Dynamic_info CP entry
2883 // with linkage results being stored back into the bootstrap specifier.
2884 void SystemDictionary::invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS) {
2885   // Resolve the bootstrap specifier, its name, type, and static arguments
2886   bootstrap_specifier.resolve_bsm(CHECK);
2887 
2888   // This should not happen.  JDK code should take care of that.
2889   if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {
2890     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;Invalid bootstrap method invocation with no caller or type argument&quot;);
2891   }
2892 
2893   bool is_indy = bootstrap_specifier.is_method_call();
2894   objArrayHandle appendix_box;
2895   if (is_indy) {
2896     // Some method calls may require an appendix argument.  Arrange to receive it.
2897     appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK);
2898     assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2899   }
2900 
2901   // call condy: java.lang.invoke.MethodHandleNatives::linkDynamicConstant(caller, condy_index, bsm, type, info)
2902   //       indy: java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)
2903   JavaCallArguments args;
2904   args.push_oop(Handle(THREAD, bootstrap_specifier.caller_mirror()));
2905   args.push_int(bootstrap_specifier.bss_index());
2906   args.push_oop(bootstrap_specifier.bsm());
2907   args.push_oop(bootstrap_specifier.name_arg());
2908   args.push_oop(bootstrap_specifier.type_arg());
2909   args.push_oop(bootstrap_specifier.arg_values());
2910   if (is_indy) {
2911     args.push_oop(appendix_box);
2912   }
2913   JavaValue result(T_OBJECT);
2914   JavaCalls::call_static(&amp;result,
2915                          SystemDictionary::MethodHandleNatives_klass(),
2916                          is_indy ? vmSymbols::linkCallSite_name() : vmSymbols::linkDynamicConstant_name(),
2917                          is_indy ? vmSymbols::linkCallSite_signature() : vmSymbols::linkDynamicConstant_signature(),
2918                          &amp;args, CHECK);
2919 
2920   Handle value(THREAD, (oop) result.get_jobject());
2921   if (is_indy) {
2922     Handle appendix;
2923     Method* method = unpack_method_and_appendix(value,
2924                                                 bootstrap_specifier.caller(),
2925                                                 appendix_box,
2926                                                 &amp;appendix, CHECK);
2927     methodHandle mh(THREAD, method);
2928     bootstrap_specifier.set_resolved_method(mh, appendix);
2929   } else {
2930     bootstrap_specifier.set_resolved_value(value);
2931   }
2932 
2933   // sanity check
2934   assert(bootstrap_specifier.is_resolved() ||
2935          (bootstrap_specifier.is_method_call() &amp;&amp;
2936           bootstrap_specifier.resolved_method().not_null()), &quot;bootstrap method call failed&quot;);
2937 }
2938 
2939 // Protection domain cache table handling
2940 
2941 ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
2942   return _pd_cache_table-&gt;get(protection_domain);
2943 }
2944 
2945 // ----------------------------------------------------------------------------
2946 
2947 void SystemDictionary::print_on(outputStream *st) {
2948   CDS_ONLY(SystemDictionaryShared::print_on(st));
2949   GCMutexLocker mu(SystemDictionary_lock);
2950 
2951   ClassLoaderDataGraph::print_dictionary(st);
2952 
2953   // Placeholders
2954   placeholders()-&gt;print_on(st);
2955   st-&gt;cr();
2956 
2957   // loader constraints - print under SD_lock
2958   constraints()-&gt;print_on(st);
2959   st-&gt;cr();
2960 
2961   _pd_cache_table-&gt;print_on(st);
2962   st-&gt;cr();
2963 }
2964 
2965 void SystemDictionary::print() { print_on(tty); }
2966 
2967 void SystemDictionary::verify() {
2968   guarantee(constraints() != NULL,
2969             &quot;Verify of loader constraints failed&quot;);
2970   guarantee(placeholders()-&gt;number_of_entries() &gt;= 0,
2971             &quot;Verify of placeholders failed&quot;);
2972 
2973   GCMutexLocker mu(SystemDictionary_lock);
2974 
2975   // Verify dictionary
2976   ClassLoaderDataGraph::verify_dictionary();
2977 
2978   placeholders()-&gt;verify();
2979 
2980   // Verify constraint table
2981   guarantee(constraints() != NULL, &quot;Verify of loader constraints failed&quot;);
2982   constraints()-&gt;verify(placeholders());
2983 
2984   _pd_cache_table-&gt;verify();
2985 }
2986 
2987 void SystemDictionary::dump(outputStream *st, bool verbose) {
2988   assert_locked_or_safepoint(SystemDictionary_lock);
2989   if (verbose) {
2990     print_on(st);
2991   } else {
2992     CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
2993     ClassLoaderDataGraph::print_table_statistics(st);
2994     placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
2995     constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
2996     pd_cache_table()-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);
2997   }
2998 }
2999 
3000 TableStatistics SystemDictionary::placeholders_statistics() {
3001   MutexLocker ml(SystemDictionary_lock);
3002   return placeholders()-&gt;statistics_calculate();
3003 }
3004 
3005 TableStatistics SystemDictionary::loader_constraints_statistics() {
3006   MutexLocker ml(SystemDictionary_lock);
3007   return constraints()-&gt;statistics_calculate();
3008 }
3009 
3010 TableStatistics SystemDictionary::protection_domain_cache_statistics() {
3011   MutexLocker ml(SystemDictionary_lock);
3012   return pd_cache_table()-&gt;statistics_calculate();
3013 }
3014 
3015 // Utility for dumping dictionaries.
3016 SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
3017                                  DCmdWithParser(output, heap),
3018   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
3019            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
3020   _dcmdparser.add_dcmd_option(&amp;_verbose);
3021 }
3022 
3023 void SystemDictionaryDCmd::execute(DCmdSource source, TRAPS) {
3024   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpSysDict,
3025                          _verbose.value());
3026   VMThread::execute(&amp;dumper);
3027 }
3028 
3029 int SystemDictionaryDCmd::num_arguments() {
3030   ResourceMark rm;
3031   SystemDictionaryDCmd* dcmd = new SystemDictionaryDCmd(NULL, false);
3032   if (dcmd != NULL) {
3033     DCmdMark mark(dcmd);
3034     return dcmd-&gt;_dcmdparser.num_arguments();
3035   } else {
3036     return 0;
3037   }
3038 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
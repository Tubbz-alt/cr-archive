<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2327     BasicType t = ss.type();
2328     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
2329       klass = Universe::typeArrayKlassObj(t);
2330     } else {
2331       MutexLocker mu(THREAD, SystemDictionary_lock);
2332       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2333     }
2334     // If element class already loaded, allocate array klass
2335     if (klass != NULL) {
2336       klass = klass-&gt;array_klass_or_null(ndims);
2337     }
2338   } else {
2339     MutexLocker mu(THREAD, SystemDictionary_lock);
2340     // Non-array classes are easy: simply check the constraint table.
2341     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2342   }
2343 
2344   return klass;
2345 }
2346 
<span class="line-modified">2347 </span>
2348 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2349                                              Handle class_loader1,
2350                                              Handle class_loader2,
2351                                              Thread* THREAD) {
2352   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2353   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2354 
2355   Symbol* constraint_name = NULL;
2356 
2357   if (!Signature::is_array(class_name)) {
2358     constraint_name = class_name;
2359   } else {
2360     // For array classes, their Klass*s are not kept in the
2361     // constraint table. The element classes are.
2362     SignatureStream ss(class_name, false);
2363     ss.skip_array_prefix();  // skip all &#39;[&#39;s
2364     if (!ss.has_envelope()) {
2365       return true;     // primitive types always pass
2366     }
2367     constraint_name = ss.as_symbol();
2368     // Increment refcount to keep constraint_name alive after
2369     // SignatureStream is destructed. It will be decremented below
2370     // before returning.
2371     constraint_name-&gt;increment_refcount();
2372   }
2373 
2374   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2375   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2376 
2377   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2378   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2379 
2380   {
2381     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2382     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2383     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
2384     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,
2385                                            klass2, class_loader2);








2386     if (Signature::is_array(class_name)) {
2387       constraint_name-&gt;decrement_refcount();
2388     }
2389     return result;
2390   }
2391 }
2392 
2393 // Add entry to resolution error table to record the error when the first
2394 // attempt to resolve a reference to a class has failed.
2395 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2396                                             Symbol* error, Symbol* message) {
2397   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2398   int index = resolution_errors()-&gt;hash_to_index(hash);
2399   {
2400     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2401     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2402   }
2403 }
2404 
2405 // Delete a resolution error for RedefineClasses for a constant pool is going away
</pre>
<hr />
<pre>
2487 //    itable, the method (i.e., the callee) agree with the interface
2488 //    on each type in the method&#39;s signature.
2489 //
2490 // All those methods have a boolean (check_access, checkconstraints)
2491 // which turns off the checks.  This is used from specialized contexts
2492 // such as bootstrapping, dumping, and debugging.
2493 //
2494 // No direct constraint is placed between the class and its
2495 // supertypes.  Constraints are only placed along linked relations
2496 // between callers and callees.  When a method overrides or implements
2497 // an abstract method in a supertype (superclass or interface), the
2498 // constraints are placed as if the supertype were the caller to the
2499 // overriding method.  (This works well, since callers to the
2500 // supertype have already established agreement between themselves and
2501 // the supertype.)  As a result of all this, a class can disagree with
2502 // its supertype about the meaning of a type name, as long as that
2503 // class neither calls a relevant method of the supertype, nor is
2504 // called (perhaps via an override) from the supertype.
2505 //
2506 //
<span class="line-modified">2507 // SystemDictionary::check_signature_loaders(sig, l1, l2)</span>
2508 //
2509 // Make sure all class components (including arrays) in the given
2510 // signature will be resolved to the same class in both loaders.
2511 // Returns the name of the type that failed a loader constraint check, or
2512 // NULL if no constraint failed.  No exception except OOME is thrown.
2513 // Arrays are not added to the loader constraint table, their elements are.
2514 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,

2515                                                Handle loader1, Handle loader2,
2516                                                bool is_method, TRAPS)  {
2517   // Nothing to do if loaders are the same.
2518   if (loader1() == loader2()) {
2519     return NULL;
2520   }
2521 
2522   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {
2523     if (ss.is_reference()) {
2524       Symbol* sig = ss.as_symbol();
2525       // Note: In the future, if template-like types can take
2526       // arguments, we will want to recognize them and dig out class
2527       // names hiding inside the argument lists.
<span class="line-modified">2528       if (!add_loader_constraint(sig, loader1, loader2, THREAD)) {</span>
2529         return sig;
2530       }
2531     }
2532   }
2533   return NULL;
2534 }
2535 
<span class="line-removed">2536 </span>
2537 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2538                                                        Symbol* signature,
2539                                                        TRAPS) {
2540   methodHandle empty;
2541   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2542          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2543          iid != vmIntrinsics::_invokeGeneric,
2544          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2545 
2546   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2547   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2548   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2549   methodHandle m;
2550   if (spe == NULL || spe-&gt;method() == NULL) {
2551     spe = NULL;
2552     // Must create lots of stuff here, but outside of the SystemDictionary lock.
2553     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);
2554     if (!Arguments::is_interpreter_only()) {
2555       // Generate a compiled form of the MH intrinsic.
2556       AdapterHandlerLibrary::create_native_wrapper(m);
</pre>
</td>
<td>
<hr />
<pre>
2327     BasicType t = ss.type();
2328     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
2329       klass = Universe::typeArrayKlassObj(t);
2330     } else {
2331       MutexLocker mu(THREAD, SystemDictionary_lock);
2332       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2333     }
2334     // If element class already loaded, allocate array klass
2335     if (klass != NULL) {
2336       klass = klass-&gt;array_klass_or_null(ndims);
2337     }
2338   } else {
2339     MutexLocker mu(THREAD, SystemDictionary_lock);
2340     // Non-array classes are easy: simply check the constraint table.
2341     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2342   }
2343 
2344   return klass;
2345 }
2346 
<span class="line-modified">2347 bool SystemDictionary::add_loader_constraint(Symbol* class_name,</span>
2348                                              Klass* klass_being_linked,
2349                                              Handle class_loader1,
2350                                              Handle class_loader2,
2351                                              Thread* THREAD) {
2352   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2353   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2354 
2355   Symbol* constraint_name = NULL;
2356 
2357   if (!Signature::is_array(class_name)) {
2358     constraint_name = class_name;
2359   } else {
2360     // For array classes, their Klass*s are not kept in the
2361     // constraint table. The element classes are.
2362     SignatureStream ss(class_name, false);
2363     ss.skip_array_prefix();  // skip all &#39;[&#39;s
2364     if (!ss.has_envelope()) {
2365       return true;     // primitive types always pass
2366     }
2367     constraint_name = ss.as_symbol();
2368     // Increment refcount to keep constraint_name alive after
2369     // SignatureStream is destructed. It will be decremented below
2370     // before returning.
2371     constraint_name-&gt;increment_refcount();
2372   }
2373 
2374   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2375   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2376 
2377   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2378   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2379 
2380   {
2381     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2382     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2383     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
2384     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,
2385                                            klass2, class_loader2);
<span class="line-added">2386 #if INCLUDE_CDS</span>
<span class="line-added">2387     if (Arguments::is_dumping_archive() &amp;&amp; klass_being_linked != NULL &amp;&amp;</span>
<span class="line-added">2388         !klass_being_linked-&gt;is_shared()) {</span>
<span class="line-added">2389          SystemDictionaryShared::record_linking_constraint(constraint_name,</span>
<span class="line-added">2390                                      InstanceKlass::cast(klass_being_linked),</span>
<span class="line-added">2391                                      class_loader1, class_loader2, THREAD);</span>
<span class="line-added">2392     }</span>
<span class="line-added">2393 #endif // INCLUDE_CDS</span>
2394     if (Signature::is_array(class_name)) {
2395       constraint_name-&gt;decrement_refcount();
2396     }
2397     return result;
2398   }
2399 }
2400 
2401 // Add entry to resolution error table to record the error when the first
2402 // attempt to resolve a reference to a class has failed.
2403 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2404                                             Symbol* error, Symbol* message) {
2405   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2406   int index = resolution_errors()-&gt;hash_to_index(hash);
2407   {
2408     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2409     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2410   }
2411 }
2412 
2413 // Delete a resolution error for RedefineClasses for a constant pool is going away
</pre>
<hr />
<pre>
2495 //    itable, the method (i.e., the callee) agree with the interface
2496 //    on each type in the method&#39;s signature.
2497 //
2498 // All those methods have a boolean (check_access, checkconstraints)
2499 // which turns off the checks.  This is used from specialized contexts
2500 // such as bootstrapping, dumping, and debugging.
2501 //
2502 // No direct constraint is placed between the class and its
2503 // supertypes.  Constraints are only placed along linked relations
2504 // between callers and callees.  When a method overrides or implements
2505 // an abstract method in a supertype (superclass or interface), the
2506 // constraints are placed as if the supertype were the caller to the
2507 // overriding method.  (This works well, since callers to the
2508 // supertype have already established agreement between themselves and
2509 // the supertype.)  As a result of all this, a class can disagree with
2510 // its supertype about the meaning of a type name, as long as that
2511 // class neither calls a relevant method of the supertype, nor is
2512 // called (perhaps via an override) from the supertype.
2513 //
2514 //
<span class="line-modified">2515 // SystemDictionary::check_signature_loaders(sig, klass_being_linked, l1, l2)</span>
2516 //
2517 // Make sure all class components (including arrays) in the given
2518 // signature will be resolved to the same class in both loaders.
2519 // Returns the name of the type that failed a loader constraint check, or
2520 // NULL if no constraint failed.  No exception except OOME is thrown.
2521 // Arrays are not added to the loader constraint table, their elements are.
2522 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
<span class="line-added">2523                                                Klass* klass_being_linked,</span>
2524                                                Handle loader1, Handle loader2,
2525                                                bool is_method, TRAPS)  {
2526   // Nothing to do if loaders are the same.
2527   if (loader1() == loader2()) {
2528     return NULL;
2529   }
2530 
2531   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {
2532     if (ss.is_reference()) {
2533       Symbol* sig = ss.as_symbol();
2534       // Note: In the future, if template-like types can take
2535       // arguments, we will want to recognize them and dig out class
2536       // names hiding inside the argument lists.
<span class="line-modified">2537       if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2, THREAD)) {</span>
2538         return sig;
2539       }
2540     }
2541   }
2542   return NULL;
2543 }
2544 

2545 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2546                                                        Symbol* signature,
2547                                                        TRAPS) {
2548   methodHandle empty;
2549   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2550          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2551          iid != vmIntrinsics::_invokeGeneric,
2552          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2553 
2554   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2555   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2556   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2557   methodHandle m;
2558   if (spe == NULL || spe-&gt;method() == NULL) {
2559     spe = NULL;
2560     // Must create lots of stuff here, but outside of the SystemDictionary lock.
2561     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);
2562     if (!Arguments::is_interpreter_only()) {
2563       // Generate a compiled form of the MH intrinsic.
2564       AdapterHandlerLibrary::create_native_wrapper(m);
</pre>
</td>
</tr>
</table>
<center><a href="classLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
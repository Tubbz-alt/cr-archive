<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../java.base/share/classes/java/util/Objects.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../test/hotspot/jtreg/TEST.groups.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //todo: one might eliminate uninits.andSets when monotonic
  27 
  28 package com.sun.tools.javac.comp;
  29 
  30 import java.util.HashMap;
  31 import java.util.HashSet;
  32 import java.util.Set;
<span class="line-removed">  33 import java.util.stream.Collectors;</span>
  34 
  35 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Scope.WriteableScope;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  40 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  41 import com.sun.tools.javac.tree.*;
  42 import com.sun.tools.javac.util.*;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.JCDiagnostic.Error;
  45 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  46 

  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;
  55 import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;
  56 import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;
  57 import static com.sun.tools.javac.comp.Flow.ThisExposability.DISCOURAGED;
  58 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  59 
  60 /** This pass implements dataflow analysis for Java programs though
  61  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  62  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  63  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  64  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  65  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  66  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
</pre>
<hr />
<pre>
 683                 // Warn about fall-through if lint switch fallthrough enabled.
 684                 if (alive == Liveness.ALIVE &amp;&amp;
 685                     lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &amp;&amp;
 686                     c.stats.nonEmpty() &amp;&amp; l.tail.nonEmpty())
 687                     log.warning(Lint.LintCategory.FALLTHROUGH,
 688                                 l.tail.head.pos(),
 689                                 Warnings.PossibleFallThroughIntoCase);
 690             }
 691             if (!hasDefault) {
 692                 alive = Liveness.ALIVE;
 693             }
 694             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 695         }
 696 
 697         @Override
 698         public void visitSwitchExpression(JCSwitchExpression tree) {
 699             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 700             pendingExits = new ListBuffer&lt;&gt;();
 701             scan(tree.selector);
 702             Set&lt;Object&gt; constants = null;
<span class="line-modified"> 703             if ((tree.selector.type.tsym.flags() &amp; ENUM) != 0) {</span>

 704                 constants = new HashSet&lt;&gt;();
<span class="line-modified"> 705                 for (Symbol s : tree.selector.type.tsym.members().getSymbols(s -&gt; (s.flags() &amp; ENUM) != 0)) {</span>


 706                     constants.add(s.name);
 707                 }
 708             }
 709             boolean hasDefault = false;
 710             Liveness prevAlive = alive;
 711             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 712                 alive = Liveness.ALIVE;
 713                 JCCase c = l.head;
 714                 if (c.pats.isEmpty())
 715                     hasDefault = true;
 716                 else {
 717                     for (JCExpression pat : c.pats) {
 718                         scan(pat);
 719                         if (constants != null) {
 720                             if (pat.hasTag(IDENT))
 721                                 constants.remove(((JCIdent) pat).name);
 722                             if (pat.type != null)
 723                                 constants.remove(pat.type.constValue());
 724                         }
 725                     }
</pre>
<hr />
<pre>
1252             }
1253             scan(tree.body);
1254             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1255             thrown = thrownPrev;
1256             caught = caughtPrev;
1257 
1258             List&lt;Type&gt; caughtInTry = List.nil();
1259             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1260                 JCVariableDecl param = l.head.param;
1261                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1262                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1263                         List.of(l.head.param.vartype);
1264                 List&lt;Type&gt; ctypes = List.nil();
1265                 List&lt;Type&gt; rethrownTypes = chk.diff(thrownInTry, caughtInTry);
1266                 for (JCExpression ct : subClauses) {
1267                     Type exc = ct.type;
1268                     if (exc != syms.unknownType) {
1269                         ctypes = ctypes.append(exc);
1270                         if (types.isSameType(exc, syms.objectType))
1271                             continue;
<span class="line-modified">1272                         checkCaughtType(l.head.pos(), exc, thrownInTry, caughtInTry);</span>

1273                         caughtInTry = chk.incl(exc, caughtInTry);
1274                     }
1275                 }
1276                 scan(param);
1277                 preciseRethrowTypes.put(param.sym, chk.intersect(ctypes, rethrownTypes));
1278                 scan(l.head.body);
1279                 preciseRethrowTypes.remove(param.sym);
1280             }
1281             if (tree.finalizer != null) {
1282                 List&lt;Type&gt; savedThrown = thrown;
1283                 thrown = List.nil();
1284                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1285                 pendingExits = prevPendingExits;
1286                 scan(tree.finalizer);
1287                 if (!tree.finallyCanCompleteNormally) {
1288                     // discard exits and exceptions from try and finally
1289                     thrown = chk.union(thrown, thrownPrev);
1290                 } else {
1291                     thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1292                     thrown = chk.union(thrown, savedThrown);
</pre>
</td>
<td>
<hr />
<pre>
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //todo: one might eliminate uninits.andSets when monotonic
  27 
  28 package com.sun.tools.javac.comp;
  29 
  30 import java.util.HashMap;
  31 import java.util.HashSet;
  32 import java.util.Set;

  33 
  34 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  35 import com.sun.tools.javac.code.*;
  36 import com.sun.tools.javac.code.Scope.WriteableScope;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  39 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  40 import com.sun.tools.javac.tree.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  43 import com.sun.tools.javac.util.JCDiagnostic.Error;
  44 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  45 
<span class="line-added">  46 import com.sun.tools.javac.code.Kinds.Kind;</span>
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;
  55 import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;
  56 import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;
  57 import static com.sun.tools.javac.comp.Flow.ThisExposability.DISCOURAGED;
  58 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  59 
  60 /** This pass implements dataflow analysis for Java programs though
  61  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  62  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  63  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  64  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  65  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  66  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
</pre>
<hr />
<pre>
 683                 // Warn about fall-through if lint switch fallthrough enabled.
 684                 if (alive == Liveness.ALIVE &amp;&amp;
 685                     lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &amp;&amp;
 686                     c.stats.nonEmpty() &amp;&amp; l.tail.nonEmpty())
 687                     log.warning(Lint.LintCategory.FALLTHROUGH,
 688                                 l.tail.head.pos(),
 689                                 Warnings.PossibleFallThroughIntoCase);
 690             }
 691             if (!hasDefault) {
 692                 alive = Liveness.ALIVE;
 693             }
 694             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 695         }
 696 
 697         @Override
 698         public void visitSwitchExpression(JCSwitchExpression tree) {
 699             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 700             pendingExits = new ListBuffer&lt;&gt;();
 701             scan(tree.selector);
 702             Set&lt;Object&gt; constants = null;
<span class="line-modified"> 703             TypeSymbol selectorSym = tree.selector.type.tsym;</span>
<span class="line-added"> 704             if ((selectorSym.flags() &amp; ENUM) != 0) {</span>
 705                 constants = new HashSet&lt;&gt;();
<span class="line-modified"> 706                 Filter&lt;Symbol&gt; enumConstantFilter =</span>
<span class="line-added"> 707                         s -&gt; (s.flags() &amp; ENUM) != 0 &amp;&amp; s.kind == Kind.VAR;</span>
<span class="line-added"> 708                 for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {</span>
 709                     constants.add(s.name);
 710                 }
 711             }
 712             boolean hasDefault = false;
 713             Liveness prevAlive = alive;
 714             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 715                 alive = Liveness.ALIVE;
 716                 JCCase c = l.head;
 717                 if (c.pats.isEmpty())
 718                     hasDefault = true;
 719                 else {
 720                     for (JCExpression pat : c.pats) {
 721                         scan(pat);
 722                         if (constants != null) {
 723                             if (pat.hasTag(IDENT))
 724                                 constants.remove(((JCIdent) pat).name);
 725                             if (pat.type != null)
 726                                 constants.remove(pat.type.constValue());
 727                         }
 728                     }
</pre>
<hr />
<pre>
1255             }
1256             scan(tree.body);
1257             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1258             thrown = thrownPrev;
1259             caught = caughtPrev;
1260 
1261             List&lt;Type&gt; caughtInTry = List.nil();
1262             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1263                 JCVariableDecl param = l.head.param;
1264                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1265                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1266                         List.of(l.head.param.vartype);
1267                 List&lt;Type&gt; ctypes = List.nil();
1268                 List&lt;Type&gt; rethrownTypes = chk.diff(thrownInTry, caughtInTry);
1269                 for (JCExpression ct : subClauses) {
1270                     Type exc = ct.type;
1271                     if (exc != syms.unknownType) {
1272                         ctypes = ctypes.append(exc);
1273                         if (types.isSameType(exc, syms.objectType))
1274                             continue;
<span class="line-modified">1275                         var pos = subClauses.size() &gt; 1 ? ct.pos() : l.head.pos();</span>
<span class="line-added">1276                         checkCaughtType(pos, exc, thrownInTry, caughtInTry);</span>
1277                         caughtInTry = chk.incl(exc, caughtInTry);
1278                     }
1279                 }
1280                 scan(param);
1281                 preciseRethrowTypes.put(param.sym, chk.intersect(ctypes, rethrownTypes));
1282                 scan(l.head.body);
1283                 preciseRethrowTypes.remove(param.sym);
1284             }
1285             if (tree.finalizer != null) {
1286                 List&lt;Type&gt; savedThrown = thrown;
1287                 thrown = List.nil();
1288                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1289                 pendingExits = prevPendingExits;
1290                 scan(tree.finalizer);
1291                 if (!tree.finallyCanCompleteNormally) {
1292                     // discard exits and exceptions from try and finally
1293                     thrown = chk.union(thrown, thrownPrev);
1294                 } else {
1295                     thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1296                     thrown = chk.union(thrown, savedThrown);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../java.base/share/classes/java/util/Objects.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../test/hotspot/jtreg/TEST.groups.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
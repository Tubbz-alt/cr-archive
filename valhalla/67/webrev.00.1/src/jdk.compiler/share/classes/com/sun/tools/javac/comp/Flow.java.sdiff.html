<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../java.base/share/classes/java/util/Objects.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../test/hotspot/jtreg/TEST.groups.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  35 import com.sun.tools.javac.code.*;
  36 import com.sun.tools.javac.code.Scope.WriteableScope;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  39 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  40 import com.sun.tools.javac.tree.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  43 import com.sun.tools.javac.util.JCDiagnostic.Error;
  44 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  45 
  46 import com.sun.tools.javac.code.Kinds.Kind;
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;



  55 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  56 
  57 /** This pass implements dataflow analysis for Java programs though
  58  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  59  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  60  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  61  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  62  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  63  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
  64  *  determines that local variables accessed within the scope of an inner class/lambda
  65  *  are either final or effectively-final.
  66  *
  67  *  &lt;p&gt;The JLS has a number of problems in the
  68  *  specification of these flow analysis problems. This implementation
  69  *  attempts to address those issues.
  70  *
  71  *  &lt;p&gt;First, there is no accommodation for a finally clause that cannot
  72  *  complete normally. For liveness analysis, an intervening finally
  73  *  clause can cause a break, continue, or return not to reach its
  74  *  target.  For exception analysis, an intervening finally clause can
</pre>
<hr />
<pre>
1217                 }
1218             }
1219 
1220             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1221             pendingExits = new ListBuffer&lt;&gt;();
1222             for (JCTree resource : tree.resources) {
1223                 if (resource instanceof JCVariableDecl) {
1224                     JCVariableDecl vdecl = (JCVariableDecl) resource;
1225                     visitVarDef(vdecl);
1226                 } else if (resource instanceof JCExpression) {
1227                     scan((JCExpression) resource);
1228                 } else {
1229                     throw new AssertionError(tree);  // parser error
1230                 }
1231             }
1232             for (JCTree resource : tree.resources) {
1233                 List&lt;Type&gt; closeableSupertypes = resource.type.isCompound() ?
1234                     types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
1235                     List.of(resource.type);
1236                 for (Type sup : closeableSupertypes) {
<span class="line-modified">1237                     if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {</span>
1238                         Symbol closeMethod = rs.resolveQualifiedMethod(tree,
1239                                 attrEnv,
1240                                 types.skipTypeVars(sup, false),
1241                                 names.close,
1242                                 List.nil(),
1243                                 List.nil());
1244                         Type mt = types.memberType(resource.type, closeMethod);
1245                         if (closeMethod.kind == MTH) {
1246                             for (Type t : mt.getThrownTypes()) {
1247                                 markThrown(resource, t);
1248                             }
1249                         }
1250                     }
1251                 }
1252             }
1253             scan(tree.body);
1254             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1255             thrown = thrownPrev;
1256             caught = caughtPrev;
1257 
</pre>
<hr />
<pre>
1636             inLambda = true;
1637             try {
1638                 pendingExits = new ListBuffer&lt;&gt;();
1639                 caught = List.of(syms.throwableType);
1640                 thrown = List.nil();
1641                 scan(tree.body);
1642                 inferredThrownTypes = thrown;
1643             } finally {
1644                 pendingExits = prevPending;
1645                 caught = prevCaught;
1646                 thrown = prevThrown;
1647                 inLambda = false;
1648             }
1649         }
1650         @Override
1651         public void visitClassDef(JCClassDecl tree) {
1652             //skip
1653         }
1654     }
1655 









1656     /**
1657      * This pass implements (i) definite assignment analysis, which ensures that
1658      * each variable is assigned when used and (ii) definite unassignment analysis,
1659      * which ensures that no final variable is assigned more than once. This visitor
1660      * depends on the results of the liveliness analyzer. This pass is also used to mark
1661      * effectively-final local variables/parameters.
1662      */
1663 
1664     public class AssignAnalyzer extends BaseAnalyzer {
1665 
1666         /** The set of definitely assigned variables.
1667          */
1668         final Bits inits;
1669 
1670         /** The set of definitely unassigned variables.
1671          */
1672         final Bits uninits;
1673 
1674         /** The set of variables that are definitely unassigned everywhere
1675          *  in current try block. This variable is maintained lazily; it is
</pre>
<hr />
<pre>
1724             final Bits inits;
1725             final Bits uninits;
1726             final Bits exit_inits = new Bits(true);
1727             final Bits exit_uninits = new Bits(true);
1728 
1729             public AssignPendingExit(JCTree tree, final Bits inits, final Bits uninits) {
1730                 super(tree);
1731                 this.inits = inits;
1732                 this.uninits = uninits;
1733                 this.exit_inits.assign(inits);
1734                 this.exit_uninits.assign(uninits);
1735             }
1736 
1737             @Override
1738             public void resolveJump() {
1739                 inits.andSet(exit_inits);
1740                 uninits.andSet(exit_uninits);
1741             }
1742         }
1743 



1744         public AssignAnalyzer() {
1745             this.inits = new Bits();
1746             uninits = new Bits();
1747             uninitsTry = new Bits();
1748             initsWhenTrue = new Bits(true);
1749             initsWhenFalse = new Bits(true);
1750             uninitsWhenTrue = new Bits(true);
1751             uninitsWhenFalse = new Bits(true);
1752         }
1753 
1754         private boolean isInitialConstructor = false;
1755 
1756         @Override
1757         protected void markDead() {
1758             if (!isInitialConstructor) {
1759                 inits.inclRange(returnadr, nextadr);
1760             } else {
1761                 for (int address = returnadr; address &lt; nextadr; address++) {
1762                     if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {
1763                         inits.incl(address);
</pre>
<hr />
<pre>
1849                 } else {
1850                     //log.rawWarning(pos, &quot;unreachable assignment&quot;);//DEBUG
1851                     uninits.excl(sym.adr);
1852                 }
1853             }
1854 
1855         /** If tree is either a simple name or of the form this.name or
1856          *  C.this.name, and tree represents a trackable variable,
1857          *  record an initialization of the variable.
1858          */
1859         void letInit(JCTree tree) {
1860             tree = TreeInfo.skipParens(tree);
1861             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1862                 Symbol sym = TreeInfo.symbol(tree);
1863                 if (sym.kind == VAR) {
1864                     letInit(tree.pos(), (VarSymbol)sym);
1865                 }
1866             }
1867         }
1868 
























1869         /** Check that trackable variable is initialized.
1870          */
1871         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1872             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1873         }
1874 
1875         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1876             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1877                 trackable(sym) &amp;&amp;
1878                 !inits.isMember(sym.adr)) {
1879                     log.error(pos, errkey);
1880                 inits.incl(sym.adr);
1881             }
1882         }
1883 
1884         /** Utility method to reset several Bits instances.
1885          */
1886         private void resetBits(Bits... bits) {
1887             for (Bits b : bits) {
1888                 b.reset();
</pre>
<hr />
<pre>
2044                     classDef = classDefPrev;
2045                 }
2046             } finally {
2047                 lint = lintPrev;
2048             }
2049         }
2050 
2051         public void visitMethodDef(JCMethodDecl tree) {
2052             if (tree.body == null) {
2053                 return;
2054             }
2055 
2056             /*  MemberEnter can generate synthetic methods ignore them
2057              */
2058             if ((tree.sym.flags() &amp; SYNTHETIC) != 0) {
2059                 return;
2060             }
2061 
2062             Lint lintPrev = lint;
2063             lint = lint.augment(tree.sym);

2064             try {
2065                 if (tree.body == null) {
2066                     return;
2067                 }
2068                 /*  Ignore synthetic methods, except for translated lambda methods.
2069                  */
2070                 if ((tree.sym.flags() &amp; (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {
2071                     return;
2072                 }
2073 
2074                 final Bits initsPrev = new Bits(inits);
2075                 final Bits uninitsPrev = new Bits(uninits);
2076                 int nextadrPrev = nextadr;
2077                 int firstadrPrev = firstadr;
2078                 int returnadrPrev = returnadr;
2079 
2080                 Assert.check(pendingExits.isEmpty());
2081                 boolean lastInitialConstructor = isInitialConstructor;
2082                 try {
2083                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2084 
2085                     if (!isInitialConstructor) {
2086                         firstadr = nextadr;








2087                     }
2088                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2089                         JCVariableDecl def = l.head;
2090                         scan(def);
2091                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2092                         /*  If we are executing the code from Gen, then there can be
2093                          *  synthetic or mandated variables, ignore them.
2094                          */
2095                         initParam(def);
2096                     }
2097                     // else we are in an instance initializer block;
2098                     // leave caught unchanged.
2099                     scan(tree.body);
2100 
2101                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;
2102                     if (isInitialConstructor) {
2103                         boolean isSynthesized = (tree.sym.flags() &amp;
2104                                                  GENERATEDCONSTR) != 0;
2105                         for (int i = firstadr; i &lt; nextadr; i++) {
2106                             JCVariableDecl vardecl = vardecls[i];
</pre>
<hr />
<pre>
2129                                     } else {
2130                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2131                                     }
2132                                 } else {
2133                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2134                                 }
2135                             }
2136                         }
2137                     }
2138                     clearPendingExits(true);
2139                 } finally {
2140                     inits.assign(initsPrev);
2141                     uninits.assign(uninitsPrev);
2142                     nextadr = nextadrPrev;
2143                     firstadr = firstadrPrev;
2144                     returnadr = returnadrPrev;
2145                     isInitialConstructor = lastInitialConstructor;
2146                 }
2147             } finally {
2148                 lint = lintPrev;

2149             }
2150         }
2151 
2152         private void clearPendingExits(boolean inMethod) {
2153             List&lt;PendingExit&gt; exits = pendingExits.toList();
2154             pendingExits = new ListBuffer&lt;&gt;();
2155             while (exits.nonEmpty()) {
2156                 PendingExit exit = exits.head;
2157                 exits = exits.tail;
2158                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
2159                                  log.hasErrorOn(exit.tree.pos()),
2160                              exit.tree);
2161                 if (inMethod &amp;&amp; isInitialConstructor) {
2162                     Assert.check(exit instanceof AssignPendingExit);
2163                     inits.assign(((AssignPendingExit) exit).exit_inits);
2164                     for (int i = firstadr; i &lt; nextadr; i++) {
2165                         checkInit(exit.tree.pos(), vardecls[i].sym);
2166                     }
2167                 }
2168             }
</pre>
<hr />
<pre>
2604 
2605         @Override
2606         public void visitContinue(JCContinue tree) {
2607             recordExit(new AssignPendingExit(tree, inits, uninits));
2608         }
2609 
2610         @Override
2611         public void visitReturn(JCReturn tree) {
2612             scanExpr(tree.expr);
2613             recordExit(new AssignPendingExit(tree, inits, uninits));
2614         }
2615 
2616         public void visitThrow(JCThrow tree) {
2617             scanExpr(tree.expr);
2618             markDead();
2619         }
2620 
2621         public void visitApply(JCMethodInvocation tree) {
2622             scanExpr(tree.meth);
2623             scanExprs(tree.args);





2624         }
2625 
2626         public void visitNewClass(JCNewClass tree) {
2627             scanExpr(tree.encl);
2628             scanExprs(tree.args);
2629             scan(tree.def);






2630         }
2631 
2632         @Override
2633         public void visitLambda(JCLambda tree) {
2634             final Bits prevUninits = new Bits(uninits);
2635             final Bits prevInits = new Bits(inits);
2636             int returnadrPrev = returnadr;
2637             int nextadrPrev = nextadr;
2638             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
2639             try {
2640                 returnadr = nextadr;
2641                 pendingExits = new ListBuffer&lt;&gt;();
2642                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2643                     JCVariableDecl def = l.head;
2644                     scan(def);
2645                     inits.incl(def.sym.adr);
2646                     uninits.excl(def.sym.adr);
2647                 }
2648                 if (tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2649                     scanExpr(tree.body);
</pre>
<hr />
<pre>
2672             uninitsExit.andSet(uninitsWhenTrue);
2673             if (tree.detail != null) {
2674                 inits.assign(initsWhenFalse);
2675                 uninits.assign(uninitsWhenFalse);
2676                 scanExpr(tree.detail);
2677             }
2678             inits.assign(initsExit);
2679             uninits.assign(uninitsExit);
2680         }
2681 
2682         public void visitAssign(JCAssign tree) {
2683             if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))
2684                 scanExpr(tree.lhs);
2685             scanExpr(tree.rhs);
2686             letInit(tree.lhs);
2687         }
2688 
2689         // check fields accessed through this.&lt;field&gt; are definitely
2690         // assigned before reading their value
2691         public void visitSelect(JCFieldAccess tree) {
<span class="line-modified">2692             super.visitSelect(tree);</span>







2693             if (TreeInfo.isThisQualifier(tree.selected) &amp;&amp;
2694                 tree.sym.kind == VAR) {
<span class="line-modified">2695                 checkInit(tree.pos(), (VarSymbol)tree.sym);</span>



2696             }
2697         }
2698 
2699         public void visitAssignop(JCAssignOp tree) {
2700             scanExpr(tree.lhs);
2701             scanExpr(tree.rhs);
2702             letInit(tree.lhs);
2703         }
2704 
2705         public void visitUnary(JCUnary tree) {
2706             switch (tree.getTag()) {
2707             case NOT:
2708                 scanCond(tree.arg);
2709                 final Bits t = new Bits(initsWhenFalse);
2710                 initsWhenFalse.assign(initsWhenTrue);
2711                 initsWhenTrue.assign(t);
2712                 t.assign(uninitsWhenFalse);
2713                 uninitsWhenFalse.assign(uninitsWhenTrue);
2714                 uninitsWhenTrue.assign(t);
2715                 break;
</pre>
<hr />
<pre>
2739                 scanCond(tree.lhs);
2740                 final Bits initsWhenTrueLeft = new Bits(initsWhenTrue);
2741                 final Bits uninitsWhenTrueLeft = new Bits(uninitsWhenTrue);
2742                 inits.assign(initsWhenFalse);
2743                 uninits.assign(uninitsWhenFalse);
2744                 scanCond(tree.rhs);
2745                 initsWhenTrue.andSet(initsWhenTrueLeft);
2746                 uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
2747                 break;
2748             default:
2749                 scanExpr(tree.lhs);
2750                 scanExpr(tree.rhs);
2751             }
2752         }
2753 
2754         public void visitIdent(JCIdent tree) {
2755             if (tree.sym.kind == VAR) {
2756                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2757                 referenced(tree.sym);
2758             }



2759         }
2760 
2761         void referenced(Symbol sym) {
2762             unrefdResources.remove(sym);
2763         }
2764 
2765         public void visitAnnotatedType(JCAnnotatedType tree) {
2766             // annotations don&#39;t get scanned
2767             tree.underlyingType.accept(this);
2768         }
2769 
2770         public void visitModuleDef(JCModuleDecl tree) {
2771             // Do nothing for modules
2772         }
2773 
2774     /**************************************************************************
2775      * main method
2776      *************************************************************************/
2777 
2778         /** Perform definite assignment/unassignment analysis on a tree.
</pre>
</td>
<td>
<hr />
<pre>
  35 import com.sun.tools.javac.code.*;
  36 import com.sun.tools.javac.code.Scope.WriteableScope;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  39 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  40 import com.sun.tools.javac.tree.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  43 import com.sun.tools.javac.util.JCDiagnostic.Error;
  44 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  45 
  46 import com.sun.tools.javac.code.Kinds.Kind;
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;
<span class="line-added">  55 import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;</span>
<span class="line-added">  56 import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;</span>
<span class="line-added">  57 import static com.sun.tools.javac.comp.Flow.ThisExposability.DISCOURAGED;</span>
  58 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  59 
  60 /** This pass implements dataflow analysis for Java programs though
  61  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  62  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  63  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  64  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  65  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  66  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
  67  *  determines that local variables accessed within the scope of an inner class/lambda
  68  *  are either final or effectively-final.
  69  *
  70  *  &lt;p&gt;The JLS has a number of problems in the
  71  *  specification of these flow analysis problems. This implementation
  72  *  attempts to address those issues.
  73  *
  74  *  &lt;p&gt;First, there is no accommodation for a finally clause that cannot
  75  *  complete normally. For liveness analysis, an intervening finally
  76  *  clause can cause a break, continue, or return not to reach its
  77  *  target.  For exception analysis, an intervening finally clause can
</pre>
<hr />
<pre>
1220                 }
1221             }
1222 
1223             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1224             pendingExits = new ListBuffer&lt;&gt;();
1225             for (JCTree resource : tree.resources) {
1226                 if (resource instanceof JCVariableDecl) {
1227                     JCVariableDecl vdecl = (JCVariableDecl) resource;
1228                     visitVarDef(vdecl);
1229                 } else if (resource instanceof JCExpression) {
1230                     scan((JCExpression) resource);
1231                 } else {
1232                     throw new AssertionError(tree);  // parser error
1233                 }
1234             }
1235             for (JCTree resource : tree.resources) {
1236                 List&lt;Type&gt; closeableSupertypes = resource.type.isCompound() ?
1237                     types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
1238                     List.of(resource.type);
1239                 for (Type sup : closeableSupertypes) {
<span class="line-modified">1240                     if (types.asSuper(sup, syms.autoCloseableType.tsym, true) != null) {</span>
1241                         Symbol closeMethod = rs.resolveQualifiedMethod(tree,
1242                                 attrEnv,
1243                                 types.skipTypeVars(sup, false),
1244                                 names.close,
1245                                 List.nil(),
1246                                 List.nil());
1247                         Type mt = types.memberType(resource.type, closeMethod);
1248                         if (closeMethod.kind == MTH) {
1249                             for (Type t : mt.getThrownTypes()) {
1250                                 markThrown(resource, t);
1251                             }
1252                         }
1253                     }
1254                 }
1255             }
1256             scan(tree.body);
1257             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1258             thrown = thrownPrev;
1259             caught = caughtPrev;
1260 
</pre>
<hr />
<pre>
1639             inLambda = true;
1640             try {
1641                 pendingExits = new ListBuffer&lt;&gt;();
1642                 caught = List.of(syms.throwableType);
1643                 thrown = List.nil();
1644                 scan(tree.body);
1645                 inferredThrownTypes = thrown;
1646             } finally {
1647                 pendingExits = prevPending;
1648                 caught = prevCaught;
1649                 thrown = prevThrown;
1650                 inLambda = false;
1651             }
1652         }
1653         @Override
1654         public void visitClassDef(JCClassDecl tree) {
1655             //skip
1656         }
1657     }
1658 
<span class="line-added">1659     /** Enum to model whether constructors allowed to &quot;leak&quot; this reference before</span>
<span class="line-added">1660         all instance fields are DA.</span>
<span class="line-added">1661      */</span>
<span class="line-added">1662     enum ThisExposability {</span>
<span class="line-added">1663         ALLOWED,     // Normal Object classes - NOP</span>
<span class="line-added">1664         BANNED,      // Value types           - Error</span>
<span class="line-added">1665         DISCOURAGED  // Value based types     - Warning</span>
<span class="line-added">1666     }</span>
<span class="line-added">1667 </span>
1668     /**
1669      * This pass implements (i) definite assignment analysis, which ensures that
1670      * each variable is assigned when used and (ii) definite unassignment analysis,
1671      * which ensures that no final variable is assigned more than once. This visitor
1672      * depends on the results of the liveliness analyzer. This pass is also used to mark
1673      * effectively-final local variables/parameters.
1674      */
1675 
1676     public class AssignAnalyzer extends BaseAnalyzer {
1677 
1678         /** The set of definitely assigned variables.
1679          */
1680         final Bits inits;
1681 
1682         /** The set of definitely unassigned variables.
1683          */
1684         final Bits uninits;
1685 
1686         /** The set of variables that are definitely unassigned everywhere
1687          *  in current try block. This variable is maintained lazily; it is
</pre>
<hr />
<pre>
1736             final Bits inits;
1737             final Bits uninits;
1738             final Bits exit_inits = new Bits(true);
1739             final Bits exit_uninits = new Bits(true);
1740 
1741             public AssignPendingExit(JCTree tree, final Bits inits, final Bits uninits) {
1742                 super(tree);
1743                 this.inits = inits;
1744                 this.uninits = uninits;
1745                 this.exit_inits.assign(inits);
1746                 this.exit_uninits.assign(uninits);
1747             }
1748 
1749             @Override
1750             public void resolveJump() {
1751                 inits.andSet(exit_inits);
1752                 uninits.andSet(exit_uninits);
1753             }
1754         }
1755 
<span class="line-added">1756         // Are constructors allowed to leak this reference ?</span>
<span class="line-added">1757         ThisExposability thisExposability = ALLOWED;</span>
<span class="line-added">1758 </span>
1759         public AssignAnalyzer() {
1760             this.inits = new Bits();
1761             uninits = new Bits();
1762             uninitsTry = new Bits();
1763             initsWhenTrue = new Bits(true);
1764             initsWhenFalse = new Bits(true);
1765             uninitsWhenTrue = new Bits(true);
1766             uninitsWhenFalse = new Bits(true);
1767         }
1768 
1769         private boolean isInitialConstructor = false;
1770 
1771         @Override
1772         protected void markDead() {
1773             if (!isInitialConstructor) {
1774                 inits.inclRange(returnadr, nextadr);
1775             } else {
1776                 for (int address = returnadr; address &lt; nextadr; address++) {
1777                     if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {
1778                         inits.incl(address);
</pre>
<hr />
<pre>
1864                 } else {
1865                     //log.rawWarning(pos, &quot;unreachable assignment&quot;);//DEBUG
1866                     uninits.excl(sym.adr);
1867                 }
1868             }
1869 
1870         /** If tree is either a simple name or of the form this.name or
1871          *  C.this.name, and tree represents a trackable variable,
1872          *  record an initialization of the variable.
1873          */
1874         void letInit(JCTree tree) {
1875             tree = TreeInfo.skipParens(tree);
1876             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1877                 Symbol sym = TreeInfo.symbol(tree);
1878                 if (sym.kind == VAR) {
1879                     letInit(tree.pos(), (VarSymbol)sym);
1880                 }
1881             }
1882         }
1883 
<span class="line-added">1884         void checkEmbryonicThisExposure(JCTree node) {</span>
<span class="line-added">1885             if (this.thisExposability == ALLOWED || classDef == null)</span>
<span class="line-added">1886                 return;</span>
<span class="line-added">1887 </span>
<span class="line-added">1888             // Note: for non-initial constructors, firstadr is post all instance fields.</span>
<span class="line-added">1889             for (int i = firstadr; i &lt; nextadr; i++) {</span>
<span class="line-added">1890                 VarSymbol sym = vardecls[i].sym;</span>
<span class="line-added">1891                 if (sym.owner != classDef.sym)</span>
<span class="line-added">1892                     continue;</span>
<span class="line-added">1893                 if ((sym.flags() &amp; (FINAL | HASINIT | STATIC | PARAMETER)) != FINAL)</span>
<span class="line-added">1894                     continue;</span>
<span class="line-added">1895                 if (sym.pos &lt; startPos || sym.adr &lt; firstadr)</span>
<span class="line-added">1896                     continue;</span>
<span class="line-added">1897                 if (!inits.isMember(sym.adr)) {</span>
<span class="line-added">1898                     if (this.thisExposability == BANNED) {</span>
<span class="line-added">1899                         log.error(node, Errors.ThisExposedPrematurely);</span>
<span class="line-added">1900                     } else {</span>
<span class="line-added">1901                         log.warning(node, Warnings.ThisExposedPrematurely);</span>
<span class="line-added">1902                     }</span>
<span class="line-added">1903                     return; // don&#39;t flog a dead horse.</span>
<span class="line-added">1904                 }</span>
<span class="line-added">1905             }</span>
<span class="line-added">1906         }</span>
<span class="line-added">1907 </span>
1908         /** Check that trackable variable is initialized.
1909          */
1910         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1911             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1912         }
1913 
1914         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1915             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1916                 trackable(sym) &amp;&amp;
1917                 !inits.isMember(sym.adr)) {
1918                     log.error(pos, errkey);
1919                 inits.incl(sym.adr);
1920             }
1921         }
1922 
1923         /** Utility method to reset several Bits instances.
1924          */
1925         private void resetBits(Bits... bits) {
1926             for (Bits b : bits) {
1927                 b.reset();
</pre>
<hr />
<pre>
2083                     classDef = classDefPrev;
2084                 }
2085             } finally {
2086                 lint = lintPrev;
2087             }
2088         }
2089 
2090         public void visitMethodDef(JCMethodDecl tree) {
2091             if (tree.body == null) {
2092                 return;
2093             }
2094 
2095             /*  MemberEnter can generate synthetic methods ignore them
2096              */
2097             if ((tree.sym.flags() &amp; SYNTHETIC) != 0) {
2098                 return;
2099             }
2100 
2101             Lint lintPrev = lint;
2102             lint = lint.augment(tree.sym);
<span class="line-added">2103             ThisExposability priorThisExposability = this.thisExposability;</span>
2104             try {
2105                 if (tree.body == null) {
2106                     return;
2107                 }
2108                 /*  Ignore synthetic methods, except for translated lambda methods.
2109                  */
2110                 if ((tree.sym.flags() &amp; (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {
2111                     return;
2112                 }
2113 
2114                 final Bits initsPrev = new Bits(inits);
2115                 final Bits uninitsPrev = new Bits(uninits);
2116                 int nextadrPrev = nextadr;
2117                 int firstadrPrev = firstadr;
2118                 int returnadrPrev = returnadr;
2119 
2120                 Assert.check(pendingExits.isEmpty());
2121                 boolean lastInitialConstructor = isInitialConstructor;
2122                 try {
2123                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2124 
2125                     if (!isInitialConstructor) {
2126                         firstadr = nextadr;
<span class="line-added">2127                         this.thisExposability = ALLOWED;</span>
<span class="line-added">2128                     } else {</span>
<span class="line-added">2129                         if (types.isValueBased(tree.sym.owner.type))</span>
<span class="line-added">2130                             this.thisExposability = DISCOURAGED;</span>
<span class="line-added">2131                         else if (types.isValue(tree.sym.owner.type))</span>
<span class="line-added">2132                             this.thisExposability = BANNED;</span>
<span class="line-added">2133                         else</span>
<span class="line-added">2134                             this.thisExposability = ALLOWED;</span>
2135                     }
2136                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2137                         JCVariableDecl def = l.head;
2138                         scan(def);
2139                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2140                         /*  If we are executing the code from Gen, then there can be
2141                          *  synthetic or mandated variables, ignore them.
2142                          */
2143                         initParam(def);
2144                     }
2145                     // else we are in an instance initializer block;
2146                     // leave caught unchanged.
2147                     scan(tree.body);
2148 
2149                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;
2150                     if (isInitialConstructor) {
2151                         boolean isSynthesized = (tree.sym.flags() &amp;
2152                                                  GENERATEDCONSTR) != 0;
2153                         for (int i = firstadr; i &lt; nextadr; i++) {
2154                             JCVariableDecl vardecl = vardecls[i];
</pre>
<hr />
<pre>
2177                                     } else {
2178                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2179                                     }
2180                                 } else {
2181                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2182                                 }
2183                             }
2184                         }
2185                     }
2186                     clearPendingExits(true);
2187                 } finally {
2188                     inits.assign(initsPrev);
2189                     uninits.assign(uninitsPrev);
2190                     nextadr = nextadrPrev;
2191                     firstadr = firstadrPrev;
2192                     returnadr = returnadrPrev;
2193                     isInitialConstructor = lastInitialConstructor;
2194                 }
2195             } finally {
2196                 lint = lintPrev;
<span class="line-added">2197                 this.thisExposability = priorThisExposability;</span>
2198             }
2199         }
2200 
2201         private void clearPendingExits(boolean inMethod) {
2202             List&lt;PendingExit&gt; exits = pendingExits.toList();
2203             pendingExits = new ListBuffer&lt;&gt;();
2204             while (exits.nonEmpty()) {
2205                 PendingExit exit = exits.head;
2206                 exits = exits.tail;
2207                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
2208                                  log.hasErrorOn(exit.tree.pos()),
2209                              exit.tree);
2210                 if (inMethod &amp;&amp; isInitialConstructor) {
2211                     Assert.check(exit instanceof AssignPendingExit);
2212                     inits.assign(((AssignPendingExit) exit).exit_inits);
2213                     for (int i = firstadr; i &lt; nextadr; i++) {
2214                         checkInit(exit.tree.pos(), vardecls[i].sym);
2215                     }
2216                 }
2217             }
</pre>
<hr />
<pre>
2653 
2654         @Override
2655         public void visitContinue(JCContinue tree) {
2656             recordExit(new AssignPendingExit(tree, inits, uninits));
2657         }
2658 
2659         @Override
2660         public void visitReturn(JCReturn tree) {
2661             scanExpr(tree.expr);
2662             recordExit(new AssignPendingExit(tree, inits, uninits));
2663         }
2664 
2665         public void visitThrow(JCThrow tree) {
2666             scanExpr(tree.expr);
2667             markDead();
2668         }
2669 
2670         public void visitApply(JCMethodInvocation tree) {
2671             scanExpr(tree.meth);
2672             scanExprs(tree.args);
<span class="line-added">2673             if (tree.meth.hasTag(IDENT)) {</span>
<span class="line-added">2674                 JCIdent ident = (JCIdent) tree.meth;</span>
<span class="line-added">2675                 if (ident.name != names._super &amp;&amp; !ident.sym.isStatic())</span>
<span class="line-added">2676                     checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2677             }</span>
2678         }
2679 
2680         public void visitNewClass(JCNewClass tree) {
2681             scanExpr(tree.encl);
2682             scanExprs(tree.args);
2683             scan(tree.def);
<span class="line-added">2684             if (classDef != null &amp;&amp; tree.encl == null &amp;&amp; tree.clazz.hasTag(IDENT)) {</span>
<span class="line-added">2685                 JCIdent clazz = (JCIdent) tree.clazz;</span>
<span class="line-added">2686                 if (!clazz.sym.isStatic() &amp;&amp; clazz.type.getEnclosingType().tsym == classDef.sym) {</span>
<span class="line-added">2687                     checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2688                 }</span>
<span class="line-added">2689             }</span>
2690         }
2691 
2692         @Override
2693         public void visitLambda(JCLambda tree) {
2694             final Bits prevUninits = new Bits(uninits);
2695             final Bits prevInits = new Bits(inits);
2696             int returnadrPrev = returnadr;
2697             int nextadrPrev = nextadr;
2698             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
2699             try {
2700                 returnadr = nextadr;
2701                 pendingExits = new ListBuffer&lt;&gt;();
2702                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2703                     JCVariableDecl def = l.head;
2704                     scan(def);
2705                     inits.incl(def.sym.adr);
2706                     uninits.excl(def.sym.adr);
2707                 }
2708                 if (tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2709                     scanExpr(tree.body);
</pre>
<hr />
<pre>
2732             uninitsExit.andSet(uninitsWhenTrue);
2733             if (tree.detail != null) {
2734                 inits.assign(initsWhenFalse);
2735                 uninits.assign(uninitsWhenFalse);
2736                 scanExpr(tree.detail);
2737             }
2738             inits.assign(initsExit);
2739             uninits.assign(uninitsExit);
2740         }
2741 
2742         public void visitAssign(JCAssign tree) {
2743             if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))
2744                 scanExpr(tree.lhs);
2745             scanExpr(tree.rhs);
2746             letInit(tree.lhs);
2747         }
2748 
2749         // check fields accessed through this.&lt;field&gt; are definitely
2750         // assigned before reading their value
2751         public void visitSelect(JCFieldAccess tree) {
<span class="line-modified">2752             ThisExposability priorThisExposability = this.thisExposability;</span>
<span class="line-added">2753             try {</span>
<span class="line-added">2754                 if (tree.name == names._this &amp;&amp; classDef != null &amp;&amp; tree.sym.owner == classDef.sym) {</span>
<span class="line-added">2755                     checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2756                 } else if (tree.sym.kind == VAR || tree.sym.isStatic()) {</span>
<span class="line-added">2757                     this.thisExposability = ALLOWED;</span>
<span class="line-added">2758                 }</span>
<span class="line-added">2759                 super.visitSelect(tree);</span>
2760             if (TreeInfo.isThisQualifier(tree.selected) &amp;&amp;
2761                 tree.sym.kind == VAR) {
<span class="line-modified">2762                     checkInit(tree.pos(), (VarSymbol)tree.sym);</span>
<span class="line-added">2763                 }</span>
<span class="line-added">2764             } finally {</span>
<span class="line-added">2765                  this.thisExposability = priorThisExposability;</span>
2766             }
2767         }
2768 
2769         public void visitAssignop(JCAssignOp tree) {
2770             scanExpr(tree.lhs);
2771             scanExpr(tree.rhs);
2772             letInit(tree.lhs);
2773         }
2774 
2775         public void visitUnary(JCUnary tree) {
2776             switch (tree.getTag()) {
2777             case NOT:
2778                 scanCond(tree.arg);
2779                 final Bits t = new Bits(initsWhenFalse);
2780                 initsWhenFalse.assign(initsWhenTrue);
2781                 initsWhenTrue.assign(t);
2782                 t.assign(uninitsWhenFalse);
2783                 uninitsWhenFalse.assign(uninitsWhenTrue);
2784                 uninitsWhenTrue.assign(t);
2785                 break;
</pre>
<hr />
<pre>
2809                 scanCond(tree.lhs);
2810                 final Bits initsWhenTrueLeft = new Bits(initsWhenTrue);
2811                 final Bits uninitsWhenTrueLeft = new Bits(uninitsWhenTrue);
2812                 inits.assign(initsWhenFalse);
2813                 uninits.assign(uninitsWhenFalse);
2814                 scanCond(tree.rhs);
2815                 initsWhenTrue.andSet(initsWhenTrueLeft);
2816                 uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
2817                 break;
2818             default:
2819                 scanExpr(tree.lhs);
2820                 scanExpr(tree.rhs);
2821             }
2822         }
2823 
2824         public void visitIdent(JCIdent tree) {
2825             if (tree.sym.kind == VAR) {
2826                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2827                 referenced(tree.sym);
2828             }
<span class="line-added">2829             if (tree.name == names._this) {</span>
<span class="line-added">2830                 checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2831             }</span>
2832         }
2833 
2834         void referenced(Symbol sym) {
2835             unrefdResources.remove(sym);
2836         }
2837 
2838         public void visitAnnotatedType(JCAnnotatedType tree) {
2839             // annotations don&#39;t get scanned
2840             tree.underlyingType.accept(this);
2841         }
2842 
2843         public void visitModuleDef(JCModuleDecl tree) {
2844             // Do nothing for modules
2845         }
2846 
2847     /**************************************************************************
2848      * main method
2849      *************************************************************************/
2850 
2851         /** Perform definite assignment/unassignment analysis on a tree.
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../java.base/share/classes/java/util/Objects.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../test/hotspot/jtreg/TEST.groups.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
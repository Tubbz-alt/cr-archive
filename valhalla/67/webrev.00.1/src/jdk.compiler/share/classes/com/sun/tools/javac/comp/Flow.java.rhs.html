<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //todo: one might eliminate uninits.andSets when monotonic
  27 
  28 package com.sun.tools.javac.comp;
  29 
  30 import java.util.HashMap;
  31 import java.util.HashSet;
  32 import java.util.Set;
  33 
  34 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  35 import com.sun.tools.javac.code.*;
  36 import com.sun.tools.javac.code.Scope.WriteableScope;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  39 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  40 import com.sun.tools.javac.tree.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  43 import com.sun.tools.javac.util.JCDiagnostic.Error;
  44 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  45 
  46 import com.sun.tools.javac.code.Kinds.Kind;
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;
<a name="1" id="anc1"></a><span class="line-added">  55 import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;</span>
<span class="line-added">  56 import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;</span>
<span class="line-added">  57 import static com.sun.tools.javac.comp.Flow.ThisExposability.DISCOURAGED;</span>
  58 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  59 
  60 /** This pass implements dataflow analysis for Java programs though
  61  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  62  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  63  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  64  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  65  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  66  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
  67  *  determines that local variables accessed within the scope of an inner class/lambda
  68  *  are either final or effectively-final.
  69  *
  70  *  &lt;p&gt;The JLS has a number of problems in the
  71  *  specification of these flow analysis problems. This implementation
  72  *  attempts to address those issues.
  73  *
  74  *  &lt;p&gt;First, there is no accommodation for a finally clause that cannot
  75  *  complete normally. For liveness analysis, an intervening finally
  76  *  clause can cause a break, continue, or return not to reach its
  77  *  target.  For exception analysis, an intervening finally clause can
  78  *  cause any exception to be &quot;caught&quot;.  For DA/DU analysis, the finally
  79  *  clause can prevent a transfer of control from propagating DA/DU
  80  *  state to the target.  In addition, code in the finally clause can
  81  *  affect the DA/DU status of variables.
  82  *
  83  *  &lt;p&gt;For try statements, we introduce the idea of a variable being
  84  *  definitely unassigned &quot;everywhere&quot; in a block.  A variable V is
  85  *  &quot;unassigned everywhere&quot; in a block iff it is unassigned at the
  86  *  beginning of the block and there is no reachable assignment to V
  87  *  in the block.  An assignment V=e is reachable iff V is not DA
  88  *  after e.  Then we can say that V is DU at the beginning of the
  89  *  catch block iff V is DU everywhere in the try block.  Similarly, V
  90  *  is DU at the beginning of the finally block iff V is DU everywhere
  91  *  in the try block and in every catch block.  Specifically, the
  92  *  following bullet is added to 16.2.2
  93  *  &lt;pre&gt;
  94  *      V is &lt;em&gt;unassigned everywhere&lt;/em&gt; in a block if it is
  95  *      unassigned before the block and there is no reachable
  96  *      assignment to V within the block.
  97  *  &lt;/pre&gt;
  98  *  &lt;p&gt;In 16.2.15, the third bullet (and all of its sub-bullets) for all
  99  *  try blocks is changed to
 100  *  &lt;pre&gt;
 101  *      V is definitely unassigned before a catch block iff V is
 102  *      definitely unassigned everywhere in the try block.
 103  *  &lt;/pre&gt;
 104  *  &lt;p&gt;The last bullet (and all of its sub-bullets) for try blocks that
 105  *  have a finally block is changed to
 106  *  &lt;pre&gt;
 107  *      V is definitely unassigned before the finally block iff
 108  *      V is definitely unassigned everywhere in the try block
 109  *      and everywhere in each catch block of the try statement.
 110  *  &lt;/pre&gt;
 111  *  &lt;p&gt;In addition,
 112  *  &lt;pre&gt;
 113  *      V is definitely assigned at the end of a constructor iff
 114  *      V is definitely assigned after the block that is the body
 115  *      of the constructor and V is definitely assigned at every
 116  *      return that can return from the constructor.
 117  *  &lt;/pre&gt;
 118  *  &lt;p&gt;In addition, each continue statement with the loop as its target
 119  *  is treated as a jump to the end of the loop body, and &quot;intervening&quot;
 120  *  finally clauses are treated as follows: V is DA &quot;due to the
 121  *  continue&quot; iff V is DA before the continue statement or V is DA at
 122  *  the end of any intervening finally block.  V is DU &quot;due to the
 123  *  continue&quot; iff any intervening finally cannot complete normally or V
 124  *  is DU at the end of every intervening finally block.  This &quot;due to
 125  *  the continue&quot; concept is then used in the spec for the loops.
 126  *
 127  *  &lt;p&gt;Similarly, break statements must consider intervening finally
 128  *  blocks.  For liveness analysis, a break statement for which any
 129  *  intervening finally cannot complete normally is not considered to
 130  *  cause the target statement to be able to complete normally. Then
 131  *  we say V is DA &quot;due to the break&quot; iff V is DA before the break or
 132  *  V is DA at the end of any intervening finally block.  V is DU &quot;due
 133  *  to the break&quot; iff any intervening finally cannot complete normally
 134  *  or V is DU at the break and at the end of every intervening
 135  *  finally block.  (I suspect this latter condition can be
 136  *  simplified.)  This &quot;due to the break&quot; is then used in the spec for
 137  *  all statements that can be &quot;broken&quot;.
 138  *
 139  *  &lt;p&gt;The return statement is treated similarly.  V is DA &quot;due to a
 140  *  return statement&quot; iff V is DA before the return statement or V is
 141  *  DA at the end of any intervening finally block.  Note that we
 142  *  don&#39;t have to worry about the return expression because this
 143  *  concept is only used for constructors.
 144  *
 145  *  &lt;p&gt;There is no spec in the JLS for when a variable is definitely
 146  *  assigned at the end of a constructor, which is needed for final
 147  *  fields (8.3.1.2).  We implement the rule that V is DA at the end
 148  *  of the constructor iff it is DA and the end of the body of the
 149  *  constructor and V is DA &quot;due to&quot; every return of the constructor.
 150  *
 151  *  &lt;p&gt;Intervening finally blocks similarly affect exception analysis.  An
 152  *  intervening finally that cannot complete normally allows us to ignore
 153  *  an otherwise uncaught exception.
 154  *
 155  *  &lt;p&gt;To implement the semantics of intervening finally clauses, all
 156  *  nonlocal transfers (break, continue, return, throw, method call that
 157  *  can throw a checked exception, and a constructor invocation that can
 158  *  thrown a checked exception) are recorded in a queue, and removed
 159  *  from the queue when we complete processing the target of the
 160  *  nonlocal transfer.  This allows us to modify the queue in accordance
 161  *  with the above rules when we encounter a finally clause.  The only
 162  *  exception to this [no pun intended] is that checked exceptions that
 163  *  are known to be caught or declared to be caught in the enclosing
 164  *  method are not recorded in the queue, but instead are recorded in a
 165  *  global variable &quot;{@code Set&lt;Type&gt; thrown}&quot; that records the type of all
 166  *  exceptions that can be thrown.
 167  *
 168  *  &lt;p&gt;Other minor issues the treatment of members of other classes
 169  *  (always considered DA except that within an anonymous class
 170  *  constructor, where DA status from the enclosing scope is
 171  *  preserved), treatment of the case expression (V is DA before the
 172  *  case expression iff V is DA after the switch expression),
 173  *  treatment of variables declared in a switch block (the implied
 174  *  DA/DU status after the switch expression is DU and not DA for
 175  *  variables defined in a switch block), the treatment of boolean ?:
 176  *  expressions (The JLS rules only handle b and c non-boolean; the
 177  *  new rule is that if b and c are boolean valued, then V is
 178  *  (un)assigned after a?b:c when true/false iff V is (un)assigned
 179  *  after b when true/false and V is (un)assigned after c when
 180  *  true/false).
 181  *
 182  *  &lt;p&gt;There is the remaining question of what syntactic forms constitute a
 183  *  reference to a variable.  It is conventional to allow this.x on the
 184  *  left-hand-side to initialize a final instance field named x, yet
 185  *  this.x isn&#39;t considered a &quot;use&quot; when appearing on a right-hand-side
 186  *  in most implementations.  Should parentheses affect what is
 187  *  considered a variable reference?  The simplest rule would be to
 188  *  allow unqualified forms only, parentheses optional, and phase out
 189  *  support for assigning to a final field via this.x.
 190  *
 191  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 192  *  If you write code that depends on this, you do so at your own risk.
 193  *  This code and its internal interfaces are subject to change or
 194  *  deletion without notice.&lt;/b&gt;
 195  */
 196 public class Flow {
 197     protected static final Context.Key&lt;Flow&gt; flowKey = new Context.Key&lt;&gt;();
 198 
 199     private final Names names;
 200     private final Log log;
 201     private final Symtab syms;
 202     private final Types types;
 203     private final Check chk;
 204     private       TreeMaker make;
 205     private final Resolve rs;
 206     private final JCDiagnostic.Factory diags;
 207     private Env&lt;AttrContext&gt; attrEnv;
 208     private       Lint lint;
 209     private final boolean allowEffectivelyFinalInInnerClasses;
 210 
 211     public static Flow instance(Context context) {
 212         Flow instance = context.get(flowKey);
 213         if (instance == null)
 214             instance = new Flow(context);
 215         return instance;
 216     }
 217 
 218     public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 219         new AliveAnalyzer().analyzeTree(env, make);
 220         new AssignAnalyzer().analyzeTree(env, make);
 221         new FlowAnalyzer().analyzeTree(env, make);
 222         new CaptureAnalyzer().analyzeTree(env, make);
 223     }
 224 
 225     public void analyzeLambda(Env&lt;AttrContext&gt; env, JCLambda that, TreeMaker make, boolean speculative) {
 226         Log.DiagnosticHandler diagHandler = null;
 227         //we need to disable diagnostics temporarily; the problem is that if
 228         //a lambda expression contains e.g. an unreachable statement, an error
 229         //message will be reported and will cause compilation to skip the flow analysis
 230         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 231         //related errors, which will allow for more errors to be detected
 232         if (!speculative) {
 233             diagHandler = new Log.DiscardDiagnosticHandler(log);
 234         }
 235         try {
 236             new LambdaAliveAnalyzer().analyzeTree(env, that, make);
 237         } finally {
 238             if (!speculative) {
 239                 log.popDiagnosticHandler(diagHandler);
 240             }
 241         }
 242     }
 243 
 244     public List&lt;Type&gt; analyzeLambdaThrownTypes(final Env&lt;AttrContext&gt; env,
 245             JCLambda that, TreeMaker make) {
 246         //we need to disable diagnostics temporarily; the problem is that if
 247         //a lambda expression contains e.g. an unreachable statement, an error
 248         //message will be reported and will cause compilation to skip the flow analysis
 249         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 250         //related errors, which will allow for more errors to be detected
 251         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 252         try {
 253             new LambdaAssignAnalyzer(env).analyzeTree(env, that, make);
 254             LambdaFlowAnalyzer flowAnalyzer = new LambdaFlowAnalyzer();
 255             flowAnalyzer.analyzeTree(env, that, make);
 256             return flowAnalyzer.inferredThrownTypes;
 257         } finally {
 258             log.popDiagnosticHandler(diagHandler);
 259         }
 260     }
 261 
 262     public boolean aliveAfter(Env&lt;AttrContext&gt; env, JCTree that, TreeMaker make) {
 263         //we need to disable diagnostics temporarily; the problem is that if
 264         //&quot;that&quot; contains e.g. an unreachable statement, an error
 265         //message will be reported and will cause compilation to skip the flow analysis
 266         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 267         //related errors, which will allow for more errors to be detected
 268         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 269         try {
 270             SnippetAliveAnalyzer analyzer = new SnippetAliveAnalyzer();
 271 
 272             analyzer.analyzeTree(env, that, make);
 273             return analyzer.isAlive();
 274         } finally {
 275             log.popDiagnosticHandler(diagHandler);
 276         }
 277     }
 278 
 279     public boolean breaksOutOf(Env&lt;AttrContext&gt; env, JCTree loop, JCTree body, TreeMaker make) {
 280         //we need to disable diagnostics temporarily; the problem is that if
 281         //&quot;that&quot; contains e.g. an unreachable statement, an error
 282         //message will be reported and will cause compilation to skip the flow analysis
 283         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 284         //related errors, which will allow for more errors to be detected
 285         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 286         try {
 287             SnippetBreakAnalyzer analyzer = new SnippetBreakAnalyzer();
 288 
 289             analyzer.analyzeTree(env, body, make);
 290             return analyzer.breaksOut();
 291         } finally {
 292             log.popDiagnosticHandler(diagHandler);
 293         }
 294     }
 295 
 296     /**
 297      * Definite assignment scan mode
 298      */
 299     enum FlowKind {
 300         /**
 301          * This is the normal DA/DU analysis mode
 302          */
 303         NORMAL(&quot;var.might.already.be.assigned&quot;, false),
 304         /**
 305          * This is the speculative DA/DU analysis mode used to speculatively
 306          * derive assertions within loop bodies
 307          */
 308         SPECULATIVE_LOOP(&quot;var.might.be.assigned.in.loop&quot;, true);
 309 
 310         final String errKey;
 311         final boolean isFinal;
 312 
 313         FlowKind(String errKey, boolean isFinal) {
 314             this.errKey = errKey;
 315             this.isFinal = isFinal;
 316         }
 317 
 318         boolean isFinal() {
 319             return isFinal;
 320         }
 321     }
 322 
 323     protected Flow(Context context) {
 324         context.put(flowKey, this);
 325         names = Names.instance(context);
 326         log = Log.instance(context);
 327         syms = Symtab.instance(context);
 328         types = Types.instance(context);
 329         chk = Check.instance(context);
 330         lint = Lint.instance(context);
 331         rs = Resolve.instance(context);
 332         diags = JCDiagnostic.Factory.instance(context);
 333         Source source = Source.instance(context);
 334         allowEffectivelyFinalInInnerClasses = Feature.EFFECTIVELY_FINAL_IN_INNER_CLASSES.allowedInSource(source);
 335     }
 336 
 337     /**
 338      * Base visitor class for all visitors implementing dataflow analysis logic.
 339      * This class define the shared logic for handling jumps (break/continue statements).
 340      */
 341     static abstract class BaseAnalyzer extends TreeScanner {
 342 
 343         enum JumpKind {
 344             BREAK(JCTree.Tag.BREAK) {
 345                 @Override
 346                 JCTree getTarget(JCTree tree) {
 347                     return ((JCBreak)tree).target;
 348                 }
 349             },
 350             CONTINUE(JCTree.Tag.CONTINUE) {
 351                 @Override
 352                 JCTree getTarget(JCTree tree) {
 353                     return ((JCContinue)tree).target;
 354                 }
 355             },
 356             YIELD(JCTree.Tag.YIELD) {
 357                 @Override
 358                 JCTree getTarget(JCTree tree) {
 359                     return ((JCYield)tree).target;
 360                 }
 361             };
 362 
 363             final JCTree.Tag treeTag;
 364 
 365             private JumpKind(Tag treeTag) {
 366                 this.treeTag = treeTag;
 367             }
 368 
 369             abstract JCTree getTarget(JCTree tree);
 370         }
 371 
 372         /** The currently pending exits that go from current inner blocks
 373          *  to an enclosing block, in source order.
 374          */
 375         ListBuffer&lt;PendingExit&gt; pendingExits;
 376 
 377         /** A pending exit.  These are the statements return, break, and
 378          *  continue.  In addition, exception-throwing expressions or
 379          *  statements are put here when not known to be caught.  This
 380          *  will typically result in an error unless it is within a
 381          *  try-finally whose finally block cannot complete normally.
 382          */
 383         static class PendingExit {
 384             JCTree tree;
 385 
 386             PendingExit(JCTree tree) {
 387                 this.tree = tree;
 388             }
 389 
 390             void resolveJump() {
 391                 //do nothing
 392             }
 393         }
 394 
 395         abstract void markDead();
 396 
 397         /** Record an outward transfer of control. */
 398         void recordExit(PendingExit pe) {
 399             pendingExits.append(pe);
 400             markDead();
 401         }
 402 
 403         /** Resolve all jumps of this statement. */
 404         private Liveness resolveJump(JCTree tree,
 405                          ListBuffer&lt;PendingExit&gt; oldPendingExits,
 406                          JumpKind jk) {
 407             boolean resolved = false;
 408             List&lt;PendingExit&gt; exits = pendingExits.toList();
 409             pendingExits = oldPendingExits;
 410             for (; exits.nonEmpty(); exits = exits.tail) {
 411                 PendingExit exit = exits.head;
 412                 if (exit.tree.hasTag(jk.treeTag) &amp;&amp;
 413                         jk.getTarget(exit.tree) == tree) {
 414                     exit.resolveJump();
 415                     resolved = true;
 416                 } else {
 417                     pendingExits.append(exit);
 418                 }
 419             }
 420             return Liveness.from(resolved);
 421         }
 422 
 423         /** Resolve all continues of this statement. */
 424         Liveness resolveContinues(JCTree tree) {
 425             return resolveJump(tree, new ListBuffer&lt;PendingExit&gt;(), JumpKind.CONTINUE);
 426         }
 427 
 428         /** Resolve all breaks of this statement. */
 429         Liveness resolveBreaks(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 430             return resolveJump(tree, oldPendingExits, JumpKind.BREAK);
 431         }
 432 
 433         /** Resolve all yields of this statement. */
 434         Liveness resolveYields(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 435             return resolveJump(tree, oldPendingExits, JumpKind.YIELD);
 436         }
 437 
 438         @Override
 439         public void scan(JCTree tree) {
 440             if (tree != null &amp;&amp; (
 441                     tree.type == null ||
 442                     tree.type != Type.stuckType)) {
 443                 super.scan(tree);
 444             }
 445         }
 446 
 447         public void visitPackageDef(JCPackageDecl tree) {
 448             // Do nothing for PackageDecl
 449         }
 450 
 451         protected void scanSyntheticBreak(TreeMaker make, JCTree swtch) {
 452             if (swtch.hasTag(SWITCH_EXPRESSION)) {
 453                 JCYield brk = make.at(Position.NOPOS).Yield(null);
 454                 brk.target = swtch;
 455                 scan(brk);
 456             } else {
 457                 JCBreak brk = make.at(Position.NOPOS).Break(null);
 458                 brk.target = swtch;
 459                 scan(brk);
 460             }
 461         }
 462     }
 463 
 464     /**
 465      * This pass implements the first step of the dataflow analysis, namely
 466      * the liveness analysis check. This checks that every statement is reachable.
 467      * The output of this analysis pass are used by other analyzers. This analyzer
 468      * sets the &#39;finallyCanCompleteNormally&#39; field in the JCTry class.
 469      */
 470     class AliveAnalyzer extends BaseAnalyzer {
 471 
 472         /** A flag that indicates whether the last statement could
 473          *  complete normally.
 474          */
 475         private Liveness alive;
 476 
 477         @Override
 478         void markDead() {
 479             alive = Liveness.DEAD;
 480         }
 481 
 482     /*************************************************************************
 483      * Visitor methods for statements and definitions
 484      *************************************************************************/
 485 
 486         /** Analyze a definition.
 487          */
 488         void scanDef(JCTree tree) {
 489             scanStat(tree);
 490             if (tree != null &amp;&amp; tree.hasTag(JCTree.Tag.BLOCK) &amp;&amp; alive == Liveness.DEAD) {
 491                 log.error(tree.pos(),
 492                           Errors.InitializerMustBeAbleToCompleteNormally);
 493             }
 494         }
 495 
 496         /** Analyze a statement. Check that statement is reachable.
 497          */
 498         void scanStat(JCTree tree) {
 499             if (alive == Liveness.DEAD &amp;&amp; tree != null) {
 500                 log.error(tree.pos(), Errors.UnreachableStmt);
 501                 if (!tree.hasTag(SKIP)) alive = Liveness.RECOVERY;
 502             }
 503             scan(tree);
 504         }
 505 
 506         /** Analyze list of statements.
 507          */
 508         void scanStats(List&lt;? extends JCStatement&gt; trees) {
 509             if (trees != null)
 510                 for (List&lt;? extends JCStatement&gt; l = trees; l.nonEmpty(); l = l.tail)
 511                     scanStat(l.head);
 512         }
 513 
 514         /* ------------ Visitor methods for various sorts of trees -------------*/
 515 
 516         public void visitClassDef(JCClassDecl tree) {
 517             if (tree.sym == null) return;
 518             Liveness alivePrev = alive;
 519             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 520             Lint lintPrev = lint;
 521 
 522             pendingExits = new ListBuffer&lt;&gt;();
 523             lint = lint.augment(tree.sym);
 524 
 525             try {
 526                 // process all the static initializers
 527                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 528                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 529                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
 530                         scanDef(l.head);
 531                         clearPendingExits(false);
 532                     }
 533                 }
 534 
 535                 // process all the instance initializers
 536                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 537                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 538                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
 539                         scanDef(l.head);
 540                         clearPendingExits(false);
 541                     }
 542                 }
 543 
 544                 // process all the methods
 545                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 546                     if (l.head.hasTag(METHODDEF)) {
 547                         scan(l.head);
 548                     }
 549                 }
 550             } finally {
 551                 pendingExits = pendingExitsPrev;
 552                 alive = alivePrev;
 553                 lint = lintPrev;
 554             }
 555         }
 556 
 557         public void visitMethodDef(JCMethodDecl tree) {
 558             if (tree.body == null) return;
 559             Lint lintPrev = lint;
 560 
 561             lint = lint.augment(tree.sym);
 562 
 563             Assert.check(pendingExits.isEmpty());
 564 
 565             try {
 566                 alive = Liveness.ALIVE;
 567                 scanStat(tree.body);
 568                 tree.completesNormally = alive != Liveness.DEAD;
 569 
 570                 if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
 571                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 572 
 573                 clearPendingExits(true);
 574             } finally {
 575                 lint = lintPrev;
 576             }
 577         }
 578 
 579         private void clearPendingExits(boolean inMethod) {
 580             List&lt;PendingExit&gt; exits = pendingExits.toList();
 581             pendingExits = new ListBuffer&lt;&gt;();
 582             while (exits.nonEmpty()) {
 583                 PendingExit exit = exits.head;
 584                 exits = exits.tail;
 585                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
 586                                 log.hasErrorOn(exit.tree.pos()));
 587             }
 588         }
 589 
 590         public void visitVarDef(JCVariableDecl tree) {
 591             if (tree.init != null) {
 592                 Lint lintPrev = lint;
 593                 lint = lint.augment(tree.sym);
 594                 try{
 595                     scan(tree.init);
 596                 } finally {
 597                     lint = lintPrev;
 598                 }
 599             }
 600         }
 601 
 602         public void visitBlock(JCBlock tree) {
 603             scanStats(tree.stats);
 604         }
 605 
 606         public void visitDoLoop(JCDoWhileLoop tree) {
 607             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 608             pendingExits = new ListBuffer&lt;&gt;();
 609             scanStat(tree.body);
 610             alive = alive.or(resolveContinues(tree));
 611             scan(tree.cond);
 612             alive = alive.and(!tree.cond.type.isTrue());
 613             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 614         }
 615 
 616         public void visitWhileLoop(JCWhileLoop tree) {
 617             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 618             pendingExits = new ListBuffer&lt;&gt;();
 619             scan(tree.cond);
 620             alive = Liveness.from(!tree.cond.type.isFalse());
 621             scanStat(tree.body);
 622             alive = alive.or(resolveContinues(tree));
 623             alive = resolveBreaks(tree, prevPendingExits).or(
 624                 !tree.cond.type.isTrue());
 625         }
 626 
 627         public void visitForLoop(JCForLoop tree) {
 628             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 629             scanStats(tree.init);
 630             pendingExits = new ListBuffer&lt;&gt;();
 631             if (tree.cond != null) {
 632                 scan(tree.cond);
 633                 alive = Liveness.from(!tree.cond.type.isFalse());
 634             } else {
 635                 alive = Liveness.ALIVE;
 636             }
 637             scanStat(tree.body);
 638             alive = alive.or(resolveContinues(tree));
 639             scan(tree.step);
 640             alive = resolveBreaks(tree, prevPendingExits).or(
 641                 tree.cond != null &amp;&amp; !tree.cond.type.isTrue());
 642         }
 643 
 644         public void visitForeachLoop(JCEnhancedForLoop tree) {
 645             visitVarDef(tree.var);
 646             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 647             scan(tree.expr);
 648             pendingExits = new ListBuffer&lt;&gt;();
 649             scanStat(tree.body);
 650             alive = alive.or(resolveContinues(tree));
 651             resolveBreaks(tree, prevPendingExits);
 652             alive = Liveness.ALIVE;
 653         }
 654 
 655         public void visitLabelled(JCLabeledStatement tree) {
 656             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 657             pendingExits = new ListBuffer&lt;&gt;();
 658             scanStat(tree.body);
 659             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 660         }
 661 
 662         public void visitSwitch(JCSwitch tree) {
 663             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 664             pendingExits = new ListBuffer&lt;&gt;();
 665             scan(tree.selector);
 666             boolean hasDefault = false;
 667             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 668                 alive = Liveness.ALIVE;
 669                 JCCase c = l.head;
 670                 if (c.pats.isEmpty())
 671                     hasDefault = true;
 672                 else {
 673                     for (JCExpression pat : c.pats) {
 674                         scan(pat);
 675                     }
 676                 }
 677                 scanStats(c.stats);
 678                 c.completesNormally = alive != Liveness.DEAD;
 679                 if (alive != Liveness.DEAD &amp;&amp; c.caseKind == JCCase.RULE) {
 680                     scanSyntheticBreak(make, tree);
 681                     alive = Liveness.DEAD;
 682                 }
 683                 // Warn about fall-through if lint switch fallthrough enabled.
 684                 if (alive == Liveness.ALIVE &amp;&amp;
 685                     lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &amp;&amp;
 686                     c.stats.nonEmpty() &amp;&amp; l.tail.nonEmpty())
 687                     log.warning(Lint.LintCategory.FALLTHROUGH,
 688                                 l.tail.head.pos(),
 689                                 Warnings.PossibleFallThroughIntoCase);
 690             }
 691             if (!hasDefault) {
 692                 alive = Liveness.ALIVE;
 693             }
 694             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 695         }
 696 
 697         @Override
 698         public void visitSwitchExpression(JCSwitchExpression tree) {
 699             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 700             pendingExits = new ListBuffer&lt;&gt;();
 701             scan(tree.selector);
 702             Set&lt;Object&gt; constants = null;
 703             TypeSymbol selectorSym = tree.selector.type.tsym;
 704             if ((selectorSym.flags() &amp; ENUM) != 0) {
 705                 constants = new HashSet&lt;&gt;();
 706                 Filter&lt;Symbol&gt; enumConstantFilter =
 707                         s -&gt; (s.flags() &amp; ENUM) != 0 &amp;&amp; s.kind == Kind.VAR;
 708                 for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {
 709                     constants.add(s.name);
 710                 }
 711             }
 712             boolean hasDefault = false;
 713             Liveness prevAlive = alive;
 714             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 715                 alive = Liveness.ALIVE;
 716                 JCCase c = l.head;
 717                 if (c.pats.isEmpty())
 718                     hasDefault = true;
 719                 else {
 720                     for (JCExpression pat : c.pats) {
 721                         scan(pat);
 722                         if (constants != null) {
 723                             if (pat.hasTag(IDENT))
 724                                 constants.remove(((JCIdent) pat).name);
 725                             if (pat.type != null)
 726                                 constants.remove(pat.type.constValue());
 727                         }
 728                     }
 729                 }
 730                 scanStats(c.stats);
 731                 if (alive == Liveness.ALIVE) {
 732                     if (c.caseKind == JCCase.RULE) {
 733                         log.error(TreeInfo.diagEndPos(c.body),
 734                                   Errors.RuleCompletesNormally);
 735                     } else if (l.tail.isEmpty()) {
 736                         log.error(TreeInfo.diagEndPos(tree),
 737                                   Errors.SwitchExpressionCompletesNormally);
 738                     }
 739                 }
 740                 c.completesNormally = alive != Liveness.DEAD;
 741             }
 742             if ((constants == null || !constants.isEmpty()) &amp;&amp; !hasDefault) {
 743                 log.error(tree, Errors.NotExhaustive);
 744             }
 745             alive = prevAlive;
 746             alive = alive.or(resolveYields(tree, prevPendingExits));
 747         }
 748 
 749         public void visitTry(JCTry tree) {
 750             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 751             pendingExits = new ListBuffer&lt;&gt;();
 752             for (JCTree resource : tree.resources) {
 753                 if (resource instanceof JCVariableDecl) {
 754                     JCVariableDecl vdecl = (JCVariableDecl) resource;
 755                     visitVarDef(vdecl);
 756                 } else if (resource instanceof JCExpression) {
 757                     scan((JCExpression) resource);
 758                 } else {
 759                     throw new AssertionError(tree);  // parser error
 760                 }
 761             }
 762 
 763             scanStat(tree.body);
 764             Liveness aliveEnd = alive;
 765 
 766             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
 767                 alive = Liveness.ALIVE;
 768                 JCVariableDecl param = l.head.param;
 769                 scan(param);
 770                 scanStat(l.head.body);
 771                 aliveEnd = aliveEnd.or(alive);
 772             }
 773             if (tree.finalizer != null) {
 774                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 775                 pendingExits = prevPendingExits;
 776                 alive = Liveness.ALIVE;
 777                 scanStat(tree.finalizer);
 778                 tree.finallyCanCompleteNormally = alive != Liveness.DEAD;
 779                 if (alive == Liveness.DEAD) {
 780                     if (lint.isEnabled(Lint.LintCategory.FINALLY)) {
 781                         log.warning(Lint.LintCategory.FINALLY,
 782                                 TreeInfo.diagEndPos(tree.finalizer),
 783                                 Warnings.FinallyCannotComplete);
 784                     }
 785                 } else {
 786                     while (exits.nonEmpty()) {
 787                         pendingExits.append(exits.next());
 788                     }
 789                     alive = aliveEnd;
 790                 }
 791             } else {
 792                 alive = aliveEnd;
 793                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 794                 pendingExits = prevPendingExits;
 795                 while (exits.nonEmpty()) pendingExits.append(exits.next());
 796             }
 797         }
 798 
 799         @Override
 800         public void visitIf(JCIf tree) {
 801             scan(tree.cond);
 802             scanStat(tree.thenpart);
 803             if (tree.elsepart != null) {
 804                 Liveness aliveAfterThen = alive;
 805                 alive = Liveness.ALIVE;
 806                 scanStat(tree.elsepart);
 807                 alive = alive.or(aliveAfterThen);
 808             } else {
 809                 alive = Liveness.ALIVE;
 810             }
 811         }
 812 
 813         public void visitBreak(JCBreak tree) {
 814             recordExit(new PendingExit(tree));
 815         }
 816 
 817         @Override
 818         public void visitYield(JCYield tree) {
 819             scan(tree.value);
 820             recordExit(new PendingExit(tree));
 821         }
 822 
 823         public void visitContinue(JCContinue tree) {
 824             recordExit(new PendingExit(tree));
 825         }
 826 
 827         public void visitReturn(JCReturn tree) {
 828             scan(tree.expr);
 829             recordExit(new PendingExit(tree));
 830         }
 831 
 832         public void visitThrow(JCThrow tree) {
 833             scan(tree.expr);
 834             markDead();
 835         }
 836 
 837         public void visitApply(JCMethodInvocation tree) {
 838             scan(tree.meth);
 839             scan(tree.args);
 840         }
 841 
 842         public void visitNewClass(JCNewClass tree) {
 843             scan(tree.encl);
 844             scan(tree.args);
 845             if (tree.def != null) {
 846                 scan(tree.def);
 847             }
 848         }
 849 
 850         @Override
 851         public void visitLambda(JCLambda tree) {
 852             if (tree.type != null &amp;&amp;
 853                     tree.type.isErroneous()) {
 854                 return;
 855             }
 856 
 857             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
 858             Liveness prevAlive = alive;
 859             try {
 860                 pendingExits = new ListBuffer&lt;&gt;();
 861                 alive = Liveness.ALIVE;
 862                 scanStat(tree.body);
 863                 tree.canCompleteNormally = alive != Liveness.DEAD;
 864             }
 865             finally {
 866                 pendingExits = prevPending;
 867                 alive = prevAlive;
 868             }
 869         }
 870 
 871         public void visitModuleDef(JCModuleDecl tree) {
 872             // Do nothing for modules
 873         }
 874 
 875     /**************************************************************************
 876      * main method
 877      *************************************************************************/
 878 
 879         /** Perform definite assignment/unassignment analysis on a tree.
 880          */
 881         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 882             analyzeTree(env, env.tree, make);
 883         }
 884         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
 885             try {
 886                 attrEnv = env;
 887                 Flow.this.make = make;
 888                 pendingExits = new ListBuffer&lt;&gt;();
 889                 alive = Liveness.ALIVE;
 890                 scan(tree);
 891             } finally {
 892                 pendingExits = null;
 893                 Flow.this.make = null;
 894             }
 895         }
 896     }
 897 
 898     /**
 899      * This pass implements the second step of the dataflow analysis, namely
 900      * the exception analysis. This is to ensure that every checked exception that is
 901      * thrown is declared or caught. The analyzer uses some info that has been set by
 902      * the liveliness analyzer.
 903      */
 904     class FlowAnalyzer extends BaseAnalyzer {
 905 
 906         /** A flag that indicates whether the last statement could
 907          *  complete normally.
 908          */
 909         HashMap&lt;Symbol, List&lt;Type&gt;&gt; preciseRethrowTypes;
 910 
 911         /** The current class being defined.
 912          */
 913         JCClassDecl classDef;
 914 
 915         /** The list of possibly thrown declarable exceptions.
 916          */
 917         List&lt;Type&gt; thrown;
 918 
 919         /** The list of exceptions that are either caught or declared to be
 920          *  thrown.
 921          */
 922         List&lt;Type&gt; caught;
 923 
 924         class ThrownPendingExit extends BaseAnalyzer.PendingExit {
 925 
 926             Type thrown;
 927 
 928             ThrownPendingExit(JCTree tree, Type thrown) {
 929                 super(tree);
 930                 this.thrown = thrown;
 931             }
 932         }
 933 
 934         @Override
 935         void markDead() {
 936             //do nothing
 937         }
 938 
 939         /*-------------------- Exceptions ----------------------*/
 940 
 941         /** Complain that pending exceptions are not caught.
 942          */
 943         void errorUncaught() {
 944             for (PendingExit exit = pendingExits.next();
 945                  exit != null;
 946                  exit = pendingExits.next()) {
 947                 if (exit instanceof ThrownPendingExit) {
 948                     ThrownPendingExit thrownExit = (ThrownPendingExit) exit;
 949                     if (classDef != null &amp;&amp;
 950                         classDef.pos == exit.tree.pos) {
 951                         log.error(exit.tree.pos(),
 952                                   Errors.UnreportedExceptionDefaultConstructor(thrownExit.thrown));
 953                     } else if (exit.tree.hasTag(VARDEF) &amp;&amp;
 954                             ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {
 955                         log.error(exit.tree.pos(),
 956                                   Errors.UnreportedExceptionImplicitClose(thrownExit.thrown,
 957                                                                           ((JCVariableDecl)exit.tree).sym.name));
 958                     } else {
 959                         log.error(exit.tree.pos(),
 960                                   Errors.UnreportedExceptionNeedToCatchOrThrow(thrownExit.thrown));
 961                     }
 962                 } else {
 963                     Assert.check(log.hasErrorOn(exit.tree.pos()));
 964                 }
 965             }
 966         }
 967 
 968         /** Record that exception is potentially thrown and check that it
 969          *  is caught.
 970          */
 971         void markThrown(JCTree tree, Type exc) {
 972             if (!chk.isUnchecked(tree.pos(), exc)) {
 973                 if (!chk.isHandled(exc, caught)) {
 974                     pendingExits.append(new ThrownPendingExit(tree, exc));
 975                 }
 976                 thrown = chk.incl(exc, thrown);
 977             }
 978         }
 979 
 980     /*************************************************************************
 981      * Visitor methods for statements and definitions
 982      *************************************************************************/
 983 
 984         /* ------------ Visitor methods for various sorts of trees -------------*/
 985 
 986         public void visitClassDef(JCClassDecl tree) {
 987             if (tree.sym == null) return;
 988 
 989             JCClassDecl classDefPrev = classDef;
 990             List&lt;Type&gt; thrownPrev = thrown;
 991             List&lt;Type&gt; caughtPrev = caught;
 992             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 993             Lint lintPrev = lint;
 994             boolean anonymousClass = tree.name == names.empty;
 995             pendingExits = new ListBuffer&lt;&gt;();
 996             if (!anonymousClass) {
 997                 caught = List.nil();
 998             }
 999             classDef = tree;
1000             thrown = List.nil();
1001             lint = lint.augment(tree.sym);
1002 
1003             try {
1004                 // process all the static initializers
1005                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1006                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
1007                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
1008                         scan(l.head);
1009                         errorUncaught();
1010                     }
1011                 }
1012 
1013                 // add intersection of all thrown clauses of initial constructors
1014                 // to set of caught exceptions, unless class is anonymous.
1015                 if (!anonymousClass) {
1016                     boolean firstConstructor = true;
1017                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1018                         if (TreeInfo.isInitialConstructor(l.head)) {
1019                             List&lt;Type&gt; mthrown =
1020                                 ((JCMethodDecl) l.head).sym.type.getThrownTypes();
1021                             if (firstConstructor) {
1022                                 caught = mthrown;
1023                                 firstConstructor = false;
1024                             } else {
1025                                 caught = chk.intersect(mthrown, caught);
1026                             }
1027                         }
1028                     }
1029                 }
1030 
1031                 // process all the instance initializers
1032                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1033                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
1034                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
1035                         scan(l.head);
1036                         errorUncaught();
1037                     }
1038                 }
1039 
1040                 // in an anonymous class, add the set of thrown exceptions to
1041                 // the throws clause of the synthetic constructor and propagate
1042                 // outwards.
1043                 // Changing the throws clause on the fly is okay here because
1044                 // the anonymous constructor can&#39;t be invoked anywhere else,
1045                 // and its type hasn&#39;t been cached.
1046                 if (anonymousClass) {
1047                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1048                         if (TreeInfo.isConstructor(l.head)) {
1049                             JCMethodDecl mdef = (JCMethodDecl)l.head;
1050                             scan(mdef);
1051                             mdef.thrown = make.Types(thrown);
1052                             mdef.sym.type = types.createMethodTypeWithThrown(mdef.sym.type, thrown);
1053                         }
1054                     }
1055                     thrownPrev = chk.union(thrown, thrownPrev);
1056                 }
1057 
1058                 // process all the methods
1059                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1060                     if (anonymousClass &amp;&amp; TreeInfo.isConstructor(l.head))
1061                         continue; // there can never be an uncaught exception.
1062                     if (l.head.hasTag(METHODDEF)) {
1063                         scan(l.head);
1064                         errorUncaught();
1065                     }
1066                 }
1067 
1068                 thrown = thrownPrev;
1069             } finally {
1070                 pendingExits = pendingExitsPrev;
1071                 caught = caughtPrev;
1072                 classDef = classDefPrev;
1073                 lint = lintPrev;
1074             }
1075         }
1076 
1077         public void visitMethodDef(JCMethodDecl tree) {
1078             if (tree.body == null) return;
1079 
1080             List&lt;Type&gt; caughtPrev = caught;
1081             List&lt;Type&gt; mthrown = tree.sym.type.getThrownTypes();
1082             Lint lintPrev = lint;
1083 
1084             lint = lint.augment(tree.sym);
1085 
1086             Assert.check(pendingExits.isEmpty());
1087 
1088             try {
1089                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1090                     JCVariableDecl def = l.head;
1091                     scan(def);
1092                 }
1093                 if (TreeInfo.isInitialConstructor(tree))
1094                     caught = chk.union(caught, mthrown);
1095                 else if ((tree.sym.flags() &amp; (BLOCK | STATIC)) != BLOCK)
1096                     caught = mthrown;
1097                 // else we are in an instance initializer block;
1098                 // leave caught unchanged.
1099 
1100                 scan(tree.body);
1101 
1102                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1103                 pendingExits = new ListBuffer&lt;&gt;();
1104                 while (exits.nonEmpty()) {
1105                     PendingExit exit = exits.head;
1106                     exits = exits.tail;
1107                     if (!(exit instanceof ThrownPendingExit)) {
1108                         Assert.check(exit.tree.hasTag(RETURN) ||
1109                                          log.hasErrorOn(exit.tree.pos()));
1110                     } else {
1111                         // uncaught throws will be reported later
1112                         pendingExits.append(exit);
1113                     }
1114                 }
1115             } finally {
1116                 caught = caughtPrev;
1117                 lint = lintPrev;
1118             }
1119         }
1120 
1121         public void visitVarDef(JCVariableDecl tree) {
1122             if (tree.init != null) {
1123                 Lint lintPrev = lint;
1124                 lint = lint.augment(tree.sym);
1125                 try{
1126                     scan(tree.init);
1127                 } finally {
1128                     lint = lintPrev;
1129                 }
1130             }
1131         }
1132 
1133         public void visitBlock(JCBlock tree) {
1134             scan(tree.stats);
1135         }
1136 
1137         public void visitDoLoop(JCDoWhileLoop tree) {
1138             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1139             pendingExits = new ListBuffer&lt;&gt;();
1140             scan(tree.body);
1141             resolveContinues(tree);
1142             scan(tree.cond);
1143             resolveBreaks(tree, prevPendingExits);
1144         }
1145 
1146         public void visitWhileLoop(JCWhileLoop tree) {
1147             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1148             pendingExits = new ListBuffer&lt;&gt;();
1149             scan(tree.cond);
1150             scan(tree.body);
1151             resolveContinues(tree);
1152             resolveBreaks(tree, prevPendingExits);
1153         }
1154 
1155         public void visitForLoop(JCForLoop tree) {
1156             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1157             scan(tree.init);
1158             pendingExits = new ListBuffer&lt;&gt;();
1159             if (tree.cond != null) {
1160                 scan(tree.cond);
1161             }
1162             scan(tree.body);
1163             resolveContinues(tree);
1164             scan(tree.step);
1165             resolveBreaks(tree, prevPendingExits);
1166         }
1167 
1168         public void visitForeachLoop(JCEnhancedForLoop tree) {
1169             visitVarDef(tree.var);
1170             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1171             scan(tree.expr);
1172             pendingExits = new ListBuffer&lt;&gt;();
1173             scan(tree.body);
1174             resolveContinues(tree);
1175             resolveBreaks(tree, prevPendingExits);
1176         }
1177 
1178         public void visitLabelled(JCLabeledStatement tree) {
1179             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1180             pendingExits = new ListBuffer&lt;&gt;();
1181             scan(tree.body);
1182             resolveBreaks(tree, prevPendingExits);
1183         }
1184 
1185         public void visitSwitch(JCSwitch tree) {
1186             handleSwitch(tree, tree.selector, tree.cases);
1187         }
1188 
1189         @Override
1190         public void visitSwitchExpression(JCSwitchExpression tree) {
1191             handleSwitch(tree, tree.selector, tree.cases);
1192         }
1193 
1194         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
1195             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1196             pendingExits = new ListBuffer&lt;&gt;();
1197             scan(selector);
1198             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1199                 JCCase c = l.head;
1200                 scan(c.pats);
1201                 scan(c.stats);
1202             }
1203             if (tree.hasTag(SWITCH_EXPRESSION)) {
1204                 resolveYields(tree, prevPendingExits);
1205             } else {
1206                 resolveBreaks(tree, prevPendingExits);
1207             }
1208         }
1209 
1210         public void visitTry(JCTry tree) {
1211             List&lt;Type&gt; caughtPrev = caught;
1212             List&lt;Type&gt; thrownPrev = thrown;
1213             thrown = List.nil();
1214             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1215                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1216                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1217                         List.of(l.head.param.vartype);
1218                 for (JCExpression ct : subClauses) {
1219                     caught = chk.incl(ct.type, caught);
1220                 }
1221             }
1222 
1223             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1224             pendingExits = new ListBuffer&lt;&gt;();
1225             for (JCTree resource : tree.resources) {
1226                 if (resource instanceof JCVariableDecl) {
1227                     JCVariableDecl vdecl = (JCVariableDecl) resource;
1228                     visitVarDef(vdecl);
1229                 } else if (resource instanceof JCExpression) {
1230                     scan((JCExpression) resource);
1231                 } else {
1232                     throw new AssertionError(tree);  // parser error
1233                 }
1234             }
1235             for (JCTree resource : tree.resources) {
1236                 List&lt;Type&gt; closeableSupertypes = resource.type.isCompound() ?
1237                     types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
1238                     List.of(resource.type);
1239                 for (Type sup : closeableSupertypes) {
<a name="2" id="anc2"></a><span class="line-modified">1240                     if (types.asSuper(sup, syms.autoCloseableType.tsym, true) != null) {</span>
1241                         Symbol closeMethod = rs.resolveQualifiedMethod(tree,
1242                                 attrEnv,
1243                                 types.skipTypeVars(sup, false),
1244                                 names.close,
1245                                 List.nil(),
1246                                 List.nil());
1247                         Type mt = types.memberType(resource.type, closeMethod);
1248                         if (closeMethod.kind == MTH) {
1249                             for (Type t : mt.getThrownTypes()) {
1250                                 markThrown(resource, t);
1251                             }
1252                         }
1253                     }
1254                 }
1255             }
1256             scan(tree.body);
1257             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1258             thrown = thrownPrev;
1259             caught = caughtPrev;
1260 
1261             List&lt;Type&gt; caughtInTry = List.nil();
1262             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1263                 JCVariableDecl param = l.head.param;
1264                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1265                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1266                         List.of(l.head.param.vartype);
1267                 List&lt;Type&gt; ctypes = List.nil();
1268                 List&lt;Type&gt; rethrownTypes = chk.diff(thrownInTry, caughtInTry);
1269                 for (JCExpression ct : subClauses) {
1270                     Type exc = ct.type;
1271                     if (exc != syms.unknownType) {
1272                         ctypes = ctypes.append(exc);
1273                         if (types.isSameType(exc, syms.objectType))
1274                             continue;
1275                         var pos = subClauses.size() &gt; 1 ? ct.pos() : l.head.pos();
1276                         checkCaughtType(pos, exc, thrownInTry, caughtInTry);
1277                         caughtInTry = chk.incl(exc, caughtInTry);
1278                     }
1279                 }
1280                 scan(param);
1281                 preciseRethrowTypes.put(param.sym, chk.intersect(ctypes, rethrownTypes));
1282                 scan(l.head.body);
1283                 preciseRethrowTypes.remove(param.sym);
1284             }
1285             if (tree.finalizer != null) {
1286                 List&lt;Type&gt; savedThrown = thrown;
1287                 thrown = List.nil();
1288                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1289                 pendingExits = prevPendingExits;
1290                 scan(tree.finalizer);
1291                 if (!tree.finallyCanCompleteNormally) {
1292                     // discard exits and exceptions from try and finally
1293                     thrown = chk.union(thrown, thrownPrev);
1294                 } else {
1295                     thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1296                     thrown = chk.union(thrown, savedThrown);
1297                     // FIX: this doesn&#39;t preserve source order of exits in catch
1298                     // versus finally!
1299                     while (exits.nonEmpty()) {
1300                         pendingExits.append(exits.next());
1301                     }
1302                 }
1303             } else {
1304                 thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1305                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1306                 pendingExits = prevPendingExits;
1307                 while (exits.nonEmpty()) pendingExits.append(exits.next());
1308             }
1309         }
1310 
1311         @Override
1312         public void visitIf(JCIf tree) {
1313             scan(tree.cond);
1314             scan(tree.thenpart);
1315             if (tree.elsepart != null) {
1316                 scan(tree.elsepart);
1317             }
1318         }
1319 
1320         void checkCaughtType(DiagnosticPosition pos, Type exc, List&lt;Type&gt; thrownInTry, List&lt;Type&gt; caughtInTry) {
1321             if (chk.subset(exc, caughtInTry)) {
1322                 log.error(pos, Errors.ExceptAlreadyCaught(exc));
1323             } else if (!chk.isUnchecked(pos, exc) &amp;&amp;
1324                     !isExceptionOrThrowable(exc) &amp;&amp;
1325                     !chk.intersects(exc, thrownInTry)) {
1326                 log.error(pos, Errors.ExceptNeverThrownInTry(exc));
1327             } else {
1328                 List&lt;Type&gt; catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
1329                 // &#39;catchableThrownTypes&#39; cannot possibly be empty - if &#39;exc&#39; was an
1330                 // unchecked exception, the result list would not be empty, as the augmented
1331                 // thrown set includes { RuntimeException, Error }; if &#39;exc&#39; was a checked
1332                 // exception, that would have been covered in the branch above
1333                 if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &amp;&amp;
1334                         !isExceptionOrThrowable(exc)) {
1335                     Warning key = catchableThrownTypes.length() == 1 ?
1336                             Warnings.UnreachableCatch(catchableThrownTypes) :
1337                             Warnings.UnreachableCatch1(catchableThrownTypes);
1338                     log.warning(pos, key);
1339                 }
1340             }
1341         }
1342         //where
1343             private boolean isExceptionOrThrowable(Type exc) {
1344                 return exc.tsym == syms.throwableType.tsym ||
1345                     exc.tsym == syms.exceptionType.tsym;
1346             }
1347 
1348         public void visitBreak(JCBreak tree) {
1349             recordExit(new PendingExit(tree));
1350         }
1351 
1352         public void visitYield(JCYield tree) {
1353             scan(tree.value);
1354             recordExit(new PendingExit(tree));
1355         }
1356 
1357         public void visitContinue(JCContinue tree) {
1358             recordExit(new PendingExit(tree));
1359         }
1360 
1361         public void visitReturn(JCReturn tree) {
1362             scan(tree.expr);
1363             recordExit(new PendingExit(tree));
1364         }
1365 
1366         public void visitThrow(JCThrow tree) {
1367             scan(tree.expr);
1368             Symbol sym = TreeInfo.symbol(tree.expr);
1369             if (sym != null &amp;&amp;
1370                 sym.kind == VAR &amp;&amp;
1371                 (sym.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) != 0 &amp;&amp;
1372                 preciseRethrowTypes.get(sym) != null) {
1373                 for (Type t : preciseRethrowTypes.get(sym)) {
1374                     markThrown(tree, t);
1375                 }
1376             }
1377             else {
1378                 markThrown(tree, tree.expr.type);
1379             }
1380             markDead();
1381         }
1382 
1383         public void visitApply(JCMethodInvocation tree) {
1384             scan(tree.meth);
1385             scan(tree.args);
1386             for (List&lt;Type&gt; l = tree.meth.type.getThrownTypes(); l.nonEmpty(); l = l.tail)
1387                 markThrown(tree, l.head);
1388         }
1389 
1390         public void visitNewClass(JCNewClass tree) {
1391             scan(tree.encl);
1392             scan(tree.args);
1393            // scan(tree.def);
1394             for (List&lt;Type&gt; l = tree.constructorType.getThrownTypes();
1395                  l.nonEmpty();
1396                  l = l.tail) {
1397                 markThrown(tree, l.head);
1398             }
1399             List&lt;Type&gt; caughtPrev = caught;
1400             try {
1401                 // If the new class expression defines an anonymous class,
1402                 // analysis of the anonymous constructor may encounter thrown
1403                 // types which are unsubstituted type variables.
1404                 // However, since the constructor&#39;s actual thrown types have
1405                 // already been marked as thrown, it is safe to simply include
1406                 // each of the constructor&#39;s formal thrown types in the set of
1407                 // &#39;caught/declared to be thrown&#39; types, for the duration of
1408                 // the class def analysis.
1409                 if (tree.def != null)
1410                     for (List&lt;Type&gt; l = tree.constructor.type.getThrownTypes();
1411                          l.nonEmpty();
1412                          l = l.tail) {
1413                         caught = chk.incl(l.head, caught);
1414                     }
1415                 scan(tree.def);
1416             }
1417             finally {
1418                 caught = caughtPrev;
1419             }
1420         }
1421 
1422         @Override
1423         public void visitLambda(JCLambda tree) {
1424             if (tree.type != null &amp;&amp;
1425                     tree.type.isErroneous()) {
1426                 return;
1427             }
1428             List&lt;Type&gt; prevCaught = caught;
1429             List&lt;Type&gt; prevThrown = thrown;
1430             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1431             try {
1432                 pendingExits = new ListBuffer&lt;&gt;();
1433                 caught = tree.getDescriptorType(types).getThrownTypes();
1434                 thrown = List.nil();
1435                 scan(tree.body);
1436                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1437                 pendingExits = new ListBuffer&lt;&gt;();
1438                 while (exits.nonEmpty()) {
1439                     PendingExit exit = exits.head;
1440                     exits = exits.tail;
1441                     if (!(exit instanceof ThrownPendingExit)) {
1442                         Assert.check(exit.tree.hasTag(RETURN) ||
1443                                         log.hasErrorOn(exit.tree.pos()));
1444                     } else {
1445                         // uncaught throws will be reported later
1446                         pendingExits.append(exit);
1447                     }
1448                 }
1449 
1450                 errorUncaught();
1451             } finally {
1452                 pendingExits = prevPending;
1453                 caught = prevCaught;
1454                 thrown = prevThrown;
1455             }
1456         }
1457 
1458         public void visitModuleDef(JCModuleDecl tree) {
1459             // Do nothing for modules
1460         }
1461 
1462     /**************************************************************************
1463      * main method
1464      *************************************************************************/
1465 
1466         /** Perform definite assignment/unassignment analysis on a tree.
1467          */
1468         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
1469             analyzeTree(env, env.tree, make);
1470         }
1471         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
1472             try {
1473                 attrEnv = env;
1474                 Flow.this.make = make;
1475                 pendingExits = new ListBuffer&lt;&gt;();
1476                 preciseRethrowTypes = new HashMap&lt;&gt;();
1477                 this.thrown = this.caught = null;
1478                 this.classDef = null;
1479                 scan(tree);
1480             } finally {
1481                 pendingExits = null;
1482                 Flow.this.make = null;
1483                 this.thrown = this.caught = null;
1484                 this.classDef = null;
1485             }
1486         }
1487     }
1488 
1489     /**
1490      * Specialized pass that performs reachability analysis on a lambda
1491      */
1492     class LambdaAliveAnalyzer extends AliveAnalyzer {
1493 
1494         boolean inLambda;
1495 
1496         @Override
1497         public void visitReturn(JCReturn tree) {
1498             //ignore lambda return expression (which might not even be attributed)
1499             recordExit(new PendingExit(tree));
1500         }
1501 
1502         @Override
1503         public void visitLambda(JCLambda tree) {
1504             if (inLambda || tree.getBodyKind() == BodyKind.EXPRESSION) {
1505                 return;
1506             }
1507             inLambda = true;
1508             try {
1509                 super.visitLambda(tree);
1510             } finally {
1511                 inLambda = false;
1512             }
1513         }
1514 
1515         @Override
1516         public void visitClassDef(JCClassDecl tree) {
1517             //skip
1518         }
1519     }
1520 
1521     /**
1522      * Determine if alive after the given tree.
1523      */
1524     class SnippetAliveAnalyzer extends AliveAnalyzer {
1525         @Override
1526         public void visitClassDef(JCClassDecl tree) {
1527             //skip
1528         }
1529         public boolean isAlive() {
1530             return super.alive != Liveness.DEAD;
1531         }
1532     }
1533 
1534     class SnippetBreakAnalyzer extends AliveAnalyzer {
1535         private final Set&lt;JCTree&gt; seenTrees = new HashSet&lt;&gt;();
1536         private boolean breaksOut;
1537 
1538         public SnippetBreakAnalyzer() {
1539         }
1540 
1541         @Override
1542         public void visitLabelled(JCTree.JCLabeledStatement tree) {
1543             seenTrees.add(tree);
1544             super.visitLabelled(tree);
1545         }
1546 
1547         @Override
1548         public void visitWhileLoop(JCTree.JCWhileLoop tree) {
1549             seenTrees.add(tree);
1550             super.visitWhileLoop(tree);
1551         }
1552 
1553         @Override
1554         public void visitForLoop(JCTree.JCForLoop tree) {
1555             seenTrees.add(tree);
1556             super.visitForLoop(tree);
1557         }
1558 
1559         @Override
1560         public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {
1561             seenTrees.add(tree);
1562             super.visitForeachLoop(tree);
1563         }
1564 
1565         @Override
1566         public void visitDoLoop(JCTree.JCDoWhileLoop tree) {
1567             seenTrees.add(tree);
1568             super.visitDoLoop(tree);
1569         }
1570 
1571         @Override
1572         public void visitBreak(JCBreak tree) {
1573             breaksOut |= (super.alive == Liveness.ALIVE &amp;&amp;
1574                           !seenTrees.contains(tree.target));
1575             super.visitBreak(tree);
1576         }
1577 
1578         public boolean breaksOut() {
1579             return breaksOut;
1580         }
1581     }
1582 
1583     /**
1584      * Specialized pass that performs DA/DU on a lambda
1585      */
1586     class LambdaAssignAnalyzer extends AssignAnalyzer {
1587         WriteableScope enclosedSymbols;
1588         boolean inLambda;
1589 
1590         LambdaAssignAnalyzer(Env&lt;AttrContext&gt; env) {
1591             enclosedSymbols = WriteableScope.create(env.enclClass.sym);
1592         }
1593 
1594         @Override
1595         public void visitLambda(JCLambda tree) {
1596             if (inLambda) {
1597                 return;
1598             }
1599             inLambda = true;
1600             try {
1601                 super.visitLambda(tree);
1602             } finally {
1603                 inLambda = false;
1604             }
1605         }
1606 
1607         @Override
1608         public void visitVarDef(JCVariableDecl tree) {
1609             enclosedSymbols.enter(tree.sym);
1610             super.visitVarDef(tree);
1611         }
1612         @Override
1613         protected boolean trackable(VarSymbol sym) {
1614             return enclosedSymbols.includes(sym) &amp;&amp;
1615                    sym.owner.kind == MTH;
1616         }
1617 
1618         @Override
1619         public void visitClassDef(JCClassDecl tree) {
1620             //skip
1621         }
1622     }
1623 
1624     /**
1625      * Specialized pass that performs inference of thrown types for lambdas.
1626      */
1627     class LambdaFlowAnalyzer extends FlowAnalyzer {
1628         List&lt;Type&gt; inferredThrownTypes;
1629         boolean inLambda;
1630         @Override
1631         public void visitLambda(JCLambda tree) {
1632             if ((tree.type != null &amp;&amp;
1633                     tree.type.isErroneous()) || inLambda) {
1634                 return;
1635             }
1636             List&lt;Type&gt; prevCaught = caught;
1637             List&lt;Type&gt; prevThrown = thrown;
1638             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1639             inLambda = true;
1640             try {
1641                 pendingExits = new ListBuffer&lt;&gt;();
1642                 caught = List.of(syms.throwableType);
1643                 thrown = List.nil();
1644                 scan(tree.body);
1645                 inferredThrownTypes = thrown;
1646             } finally {
1647                 pendingExits = prevPending;
1648                 caught = prevCaught;
1649                 thrown = prevThrown;
1650                 inLambda = false;
1651             }
1652         }
1653         @Override
1654         public void visitClassDef(JCClassDecl tree) {
1655             //skip
1656         }
1657     }
1658 
<a name="3" id="anc3"></a><span class="line-added">1659     /** Enum to model whether constructors allowed to &quot;leak&quot; this reference before</span>
<span class="line-added">1660         all instance fields are DA.</span>
<span class="line-added">1661      */</span>
<span class="line-added">1662     enum ThisExposability {</span>
<span class="line-added">1663         ALLOWED,     // Normal Object classes - NOP</span>
<span class="line-added">1664         BANNED,      // Value types           - Error</span>
<span class="line-added">1665         DISCOURAGED  // Value based types     - Warning</span>
<span class="line-added">1666     }</span>
<span class="line-added">1667 </span>
1668     /**
1669      * This pass implements (i) definite assignment analysis, which ensures that
1670      * each variable is assigned when used and (ii) definite unassignment analysis,
1671      * which ensures that no final variable is assigned more than once. This visitor
1672      * depends on the results of the liveliness analyzer. This pass is also used to mark
1673      * effectively-final local variables/parameters.
1674      */
1675 
1676     public class AssignAnalyzer extends BaseAnalyzer {
1677 
1678         /** The set of definitely assigned variables.
1679          */
1680         final Bits inits;
1681 
1682         /** The set of definitely unassigned variables.
1683          */
1684         final Bits uninits;
1685 
1686         /** The set of variables that are definitely unassigned everywhere
1687          *  in current try block. This variable is maintained lazily; it is
1688          *  updated only when something gets removed from uninits,
1689          *  typically by being assigned in reachable code.  To obtain the
1690          *  correct set of variables which are definitely unassigned
1691          *  anywhere in current try block, intersect uninitsTry and
1692          *  uninits.
1693          */
1694         final Bits uninitsTry;
1695 
1696         /** When analyzing a condition, inits and uninits are null.
1697          *  Instead we have:
1698          */
1699         final Bits initsWhenTrue;
1700         final Bits initsWhenFalse;
1701         final Bits uninitsWhenTrue;
1702         final Bits uninitsWhenFalse;
1703 
1704         /** A mapping from addresses to variable symbols.
1705          */
1706         protected JCVariableDecl[] vardecls;
1707 
1708         /** The current class being defined.
1709          */
1710         JCClassDecl classDef;
1711 
1712         /** The first variable sequence number in this class definition.
1713          */
1714         int firstadr;
1715 
1716         /** The next available variable sequence number.
1717          */
1718         protected int nextadr;
1719 
1720         /** The first variable sequence number in a block that can return.
1721          */
1722         protected int returnadr;
1723 
1724         /** The list of unreferenced automatic resources.
1725          */
1726         WriteableScope unrefdResources;
1727 
1728         /** Modified when processing a loop body the second time for DU analysis. */
1729         FlowKind flowKind = FlowKind.NORMAL;
1730 
1731         /** The starting position of the analyzed tree */
1732         int startPos;
1733 
1734         public class AssignPendingExit extends BaseAnalyzer.PendingExit {
1735 
1736             final Bits inits;
1737             final Bits uninits;
1738             final Bits exit_inits = new Bits(true);
1739             final Bits exit_uninits = new Bits(true);
1740 
1741             public AssignPendingExit(JCTree tree, final Bits inits, final Bits uninits) {
1742                 super(tree);
1743                 this.inits = inits;
1744                 this.uninits = uninits;
1745                 this.exit_inits.assign(inits);
1746                 this.exit_uninits.assign(uninits);
1747             }
1748 
1749             @Override
1750             public void resolveJump() {
1751                 inits.andSet(exit_inits);
1752                 uninits.andSet(exit_uninits);
1753             }
1754         }
1755 
<a name="4" id="anc4"></a><span class="line-added">1756         // Are constructors allowed to leak this reference ?</span>
<span class="line-added">1757         ThisExposability thisExposability = ALLOWED;</span>
<span class="line-added">1758 </span>
1759         public AssignAnalyzer() {
1760             this.inits = new Bits();
1761             uninits = new Bits();
1762             uninitsTry = new Bits();
1763             initsWhenTrue = new Bits(true);
1764             initsWhenFalse = new Bits(true);
1765             uninitsWhenTrue = new Bits(true);
1766             uninitsWhenFalse = new Bits(true);
1767         }
1768 
1769         private boolean isInitialConstructor = false;
1770 
1771         @Override
1772         protected void markDead() {
1773             if (!isInitialConstructor) {
1774                 inits.inclRange(returnadr, nextadr);
1775             } else {
1776                 for (int address = returnadr; address &lt; nextadr; address++) {
1777                     if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {
1778                         inits.incl(address);
1779                     }
1780                 }
1781             }
1782             uninits.inclRange(returnadr, nextadr);
1783         }
1784 
1785         /*-------------- Processing variables ----------------------*/
1786 
1787         /** Do we need to track init/uninit state of this symbol?
1788          *  I.e. is symbol either a local or a blank final variable?
1789          */
1790         protected boolean trackable(VarSymbol sym) {
1791             return
1792                 sym.pos &gt;= startPos &amp;&amp;
1793                 ((sym.owner.kind == MTH || sym.owner.kind == VAR ||
1794                 isFinalUninitializedField(sym)));
1795         }
1796 
1797         boolean isFinalUninitializedField(VarSymbol sym) {
1798             return sym.owner.kind == TYP &amp;&amp;
1799                    ((sym.flags() &amp; (FINAL | HASINIT | PARAMETER)) == FINAL &amp;&amp;
1800                    classDef.sym.isEnclosedBy((ClassSymbol)sym.owner));
1801         }
1802 
1803         boolean isFinalUninitializedStaticField(VarSymbol sym) {
1804             return isFinalUninitializedField(sym) &amp;&amp; sym.isStatic();
1805         }
1806 
1807         /** Initialize new trackable variable by setting its address field
1808          *  to the next available sequence number and entering it under that
1809          *  index into the vars array.
1810          */
1811         void newVar(JCVariableDecl varDecl) {
1812             VarSymbol sym = varDecl.sym;
1813             vardecls = ArrayUtils.ensureCapacity(vardecls, nextadr);
1814             if ((sym.flags() &amp; FINAL) == 0) {
1815                 sym.flags_field |= EFFECTIVELY_FINAL;
1816             }
1817             sym.adr = nextadr;
1818             vardecls[nextadr] = varDecl;
1819             inits.excl(nextadr);
1820             uninits.incl(nextadr);
1821             nextadr++;
1822         }
1823 
1824         /** Record an initialization of a trackable variable.
1825          */
1826         void letInit(DiagnosticPosition pos, VarSymbol sym) {
1827             if (sym.adr &gt;= firstadr &amp;&amp; trackable(sym)) {
1828                 if ((sym.flags() &amp; EFFECTIVELY_FINAL) != 0) {
1829                     if (!uninits.isMember(sym.adr)) {
1830                         //assignment targeting an effectively final variable
1831                         //makes the variable lose its status of effectively final
1832                         //if the variable is _not_ definitively unassigned
1833                         sym.flags_field &amp;= ~EFFECTIVELY_FINAL;
1834                     } else {
1835                         uninit(sym);
1836                     }
1837                 }
1838                 else if ((sym.flags() &amp; FINAL) != 0) {
1839                     if ((sym.flags() &amp; PARAMETER) != 0) {
1840                         if ((sym.flags() &amp; UNION) != 0) { //multi-catch parameter
1841                             log.error(pos, Errors.MulticatchParameterMayNotBeAssigned(sym));
1842                         }
1843                         else {
1844                             log.error(pos,
1845                                       Errors.FinalParameterMayNotBeAssigned(sym));
1846                         }
1847                     } else if (!uninits.isMember(sym.adr)) {
1848                         log.error(pos, diags.errorKey(flowKind.errKey, sym));
1849                     } else {
1850                         uninit(sym);
1851                     }
1852                 }
1853                 inits.incl(sym.adr);
1854             } else if ((sym.flags() &amp; FINAL) != 0) {
1855                 log.error(pos, Errors.VarMightAlreadyBeAssigned(sym));
1856             }
1857         }
1858         //where
1859             void uninit(VarSymbol sym) {
1860                 if (!inits.isMember(sym.adr)) {
1861                     // reachable assignment
1862                     uninits.excl(sym.adr);
1863                     uninitsTry.excl(sym.adr);
1864                 } else {
1865                     //log.rawWarning(pos, &quot;unreachable assignment&quot;);//DEBUG
1866                     uninits.excl(sym.adr);
1867                 }
1868             }
1869 
1870         /** If tree is either a simple name or of the form this.name or
1871          *  C.this.name, and tree represents a trackable variable,
1872          *  record an initialization of the variable.
1873          */
1874         void letInit(JCTree tree) {
1875             tree = TreeInfo.skipParens(tree);
1876             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1877                 Symbol sym = TreeInfo.symbol(tree);
1878                 if (sym.kind == VAR) {
1879                     letInit(tree.pos(), (VarSymbol)sym);
1880                 }
1881             }
1882         }
1883 
<a name="5" id="anc5"></a><span class="line-added">1884         void checkEmbryonicThisExposure(JCTree node) {</span>
<span class="line-added">1885             if (this.thisExposability == ALLOWED || classDef == null)</span>
<span class="line-added">1886                 return;</span>
<span class="line-added">1887 </span>
<span class="line-added">1888             // Note: for non-initial constructors, firstadr is post all instance fields.</span>
<span class="line-added">1889             for (int i = firstadr; i &lt; nextadr; i++) {</span>
<span class="line-added">1890                 VarSymbol sym = vardecls[i].sym;</span>
<span class="line-added">1891                 if (sym.owner != classDef.sym)</span>
<span class="line-added">1892                     continue;</span>
<span class="line-added">1893                 if ((sym.flags() &amp; (FINAL | HASINIT | STATIC | PARAMETER)) != FINAL)</span>
<span class="line-added">1894                     continue;</span>
<span class="line-added">1895                 if (sym.pos &lt; startPos || sym.adr &lt; firstadr)</span>
<span class="line-added">1896                     continue;</span>
<span class="line-added">1897                 if (!inits.isMember(sym.adr)) {</span>
<span class="line-added">1898                     if (this.thisExposability == BANNED) {</span>
<span class="line-added">1899                         log.error(node, Errors.ThisExposedPrematurely);</span>
<span class="line-added">1900                     } else {</span>
<span class="line-added">1901                         log.warning(node, Warnings.ThisExposedPrematurely);</span>
<span class="line-added">1902                     }</span>
<span class="line-added">1903                     return; // don&#39;t flog a dead horse.</span>
<span class="line-added">1904                 }</span>
<span class="line-added">1905             }</span>
<span class="line-added">1906         }</span>
<span class="line-added">1907 </span>
1908         /** Check that trackable variable is initialized.
1909          */
1910         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1911             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1912         }
1913 
1914         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1915             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1916                 trackable(sym) &amp;&amp;
1917                 !inits.isMember(sym.adr)) {
1918                     log.error(pos, errkey);
1919                 inits.incl(sym.adr);
1920             }
1921         }
1922 
1923         /** Utility method to reset several Bits instances.
1924          */
1925         private void resetBits(Bits... bits) {
1926             for (Bits b : bits) {
1927                 b.reset();
1928             }
1929         }
1930 
1931         /** Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
1932          */
1933         void split(boolean setToNull) {
1934             initsWhenFalse.assign(inits);
1935             uninitsWhenFalse.assign(uninits);
1936             initsWhenTrue.assign(inits);
1937             uninitsWhenTrue.assign(uninits);
1938             if (setToNull) {
1939                 resetBits(inits, uninits);
1940             }
1941         }
1942 
1943         /** Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.
1944          */
1945         protected void merge() {
1946             inits.assign(initsWhenFalse.andSet(initsWhenTrue));
1947             uninits.assign(uninitsWhenFalse.andSet(uninitsWhenTrue));
1948         }
1949 
1950     /* ************************************************************************
1951      * Visitor methods for statements and definitions
1952      *************************************************************************/
1953 
1954         /** Analyze an expression. Make sure to set (un)inits rather than
1955          *  (un)initsWhenTrue(WhenFalse) on exit.
1956          */
1957         void scanExpr(JCTree tree) {
1958             if (tree != null) {
1959                 scan(tree);
1960                 if (inits.isReset()) {
1961                     merge();
1962                 }
1963             }
1964         }
1965 
1966         /** Analyze a list of expressions.
1967          */
1968         void scanExprs(List&lt;? extends JCExpression&gt; trees) {
1969             if (trees != null)
1970                 for (List&lt;? extends JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
1971                     scanExpr(l.head);
1972         }
1973 
1974         /** Analyze a condition. Make sure to set (un)initsWhenTrue(WhenFalse)
1975          *  rather than (un)inits on exit.
1976          */
1977         void scanCond(JCTree tree) {
1978             if (tree.type.isFalse()) {
1979                 if (inits.isReset()) merge();
1980                 initsWhenTrue.assign(inits);
1981                 initsWhenTrue.inclRange(firstadr, nextadr);
1982                 uninitsWhenTrue.assign(uninits);
1983                 uninitsWhenTrue.inclRange(firstadr, nextadr);
1984                 initsWhenFalse.assign(inits);
1985                 uninitsWhenFalse.assign(uninits);
1986             } else if (tree.type.isTrue()) {
1987                 if (inits.isReset()) merge();
1988                 initsWhenFalse.assign(inits);
1989                 initsWhenFalse.inclRange(firstadr, nextadr);
1990                 uninitsWhenFalse.assign(uninits);
1991                 uninitsWhenFalse.inclRange(firstadr, nextadr);
1992                 initsWhenTrue.assign(inits);
1993                 uninitsWhenTrue.assign(uninits);
1994             } else {
1995                 scan(tree);
1996                 if (!inits.isReset())
1997                     split(tree.type != syms.unknownType);
1998             }
1999             if (tree.type != syms.unknownType) {
2000                 resetBits(inits, uninits);
2001             }
2002         }
2003 
2004         /* ------------ Visitor methods for various sorts of trees -------------*/
2005 
2006         public void visitClassDef(JCClassDecl tree) {
2007             if (tree.sym == null) {
2008                 return;
2009             }
2010 
2011             Lint lintPrev = lint;
2012             lint = lint.augment(tree.sym);
2013             try {
2014                 if (tree.sym == null) {
2015                     return;
2016                 }
2017 
2018                 JCClassDecl classDefPrev = classDef;
2019                 int firstadrPrev = firstadr;
2020                 int nextadrPrev = nextadr;
2021                 ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
2022 
2023                 pendingExits = new ListBuffer&lt;&gt;();
2024                 if (tree.name != names.empty) {
2025                     firstadr = nextadr;
2026                 }
2027                 classDef = tree;
2028                 try {
2029                     // define all the static fields
2030                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2031                         if (l.head.hasTag(VARDEF)) {
2032                             JCVariableDecl def = (JCVariableDecl)l.head;
2033                             if ((def.mods.flags &amp; STATIC) != 0) {
2034                                 VarSymbol sym = def.sym;
2035                                 if (trackable(sym)) {
2036                                     newVar(def);
2037                                 }
2038                             }
2039                         }
2040                     }
2041 
2042                     // process all the static initializers
2043                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2044                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2045                             (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
2046                             scan(l.head);
2047                             clearPendingExits(false);
2048                         }
2049                     }
2050 
2051                     // define all the instance fields
2052                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2053                         if (l.head.hasTag(VARDEF)) {
2054                             JCVariableDecl def = (JCVariableDecl)l.head;
2055                             if ((def.mods.flags &amp; STATIC) == 0) {
2056                                 VarSymbol sym = def.sym;
2057                                 if (trackable(sym)) {
2058                                     newVar(def);
2059                                 }
2060                             }
2061                         }
2062                     }
2063 
2064                     // process all the instance initializers
2065                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2066                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2067                             (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
2068                             scan(l.head);
2069                             clearPendingExits(false);
2070                         }
2071                     }
2072 
2073                     // process all the methods
2074                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2075                         if (l.head.hasTag(METHODDEF)) {
2076                             scan(l.head);
2077                         }
2078                     }
2079                 } finally {
2080                     pendingExits = pendingExitsPrev;
2081                     nextadr = nextadrPrev;
2082                     firstadr = firstadrPrev;
2083                     classDef = classDefPrev;
2084                 }
2085             } finally {
2086                 lint = lintPrev;
2087             }
2088         }
2089 
2090         public void visitMethodDef(JCMethodDecl tree) {
2091             if (tree.body == null) {
2092                 return;
2093             }
2094 
2095             /*  MemberEnter can generate synthetic methods ignore them
2096              */
2097             if ((tree.sym.flags() &amp; SYNTHETIC) != 0) {
2098                 return;
2099             }
2100 
2101             Lint lintPrev = lint;
2102             lint = lint.augment(tree.sym);
<a name="6" id="anc6"></a><span class="line-added">2103             ThisExposability priorThisExposability = this.thisExposability;</span>
2104             try {
2105                 if (tree.body == null) {
2106                     return;
2107                 }
2108                 /*  Ignore synthetic methods, except for translated lambda methods.
2109                  */
2110                 if ((tree.sym.flags() &amp; (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {
2111                     return;
2112                 }
2113 
2114                 final Bits initsPrev = new Bits(inits);
2115                 final Bits uninitsPrev = new Bits(uninits);
2116                 int nextadrPrev = nextadr;
2117                 int firstadrPrev = firstadr;
2118                 int returnadrPrev = returnadr;
2119 
2120                 Assert.check(pendingExits.isEmpty());
2121                 boolean lastInitialConstructor = isInitialConstructor;
2122                 try {
2123                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2124 
2125                     if (!isInitialConstructor) {
2126                         firstadr = nextadr;
<a name="7" id="anc7"></a><span class="line-added">2127                         this.thisExposability = ALLOWED;</span>
<span class="line-added">2128                     } else {</span>
<span class="line-added">2129                         if (types.isValueBased(tree.sym.owner.type))</span>
<span class="line-added">2130                             this.thisExposability = DISCOURAGED;</span>
<span class="line-added">2131                         else if (types.isValue(tree.sym.owner.type))</span>
<span class="line-added">2132                             this.thisExposability = BANNED;</span>
<span class="line-added">2133                         else</span>
<span class="line-added">2134                             this.thisExposability = ALLOWED;</span>
2135                     }
2136                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2137                         JCVariableDecl def = l.head;
2138                         scan(def);
2139                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2140                         /*  If we are executing the code from Gen, then there can be
2141                          *  synthetic or mandated variables, ignore them.
2142                          */
2143                         initParam(def);
2144                     }
2145                     // else we are in an instance initializer block;
2146                     // leave caught unchanged.
2147                     scan(tree.body);
2148 
2149                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;
2150                     if (isInitialConstructor) {
2151                         boolean isSynthesized = (tree.sym.flags() &amp;
2152                                                  GENERATEDCONSTR) != 0;
2153                         for (int i = firstadr; i &lt; nextadr; i++) {
2154                             JCVariableDecl vardecl = vardecls[i];
2155                             VarSymbol var = vardecl.sym;
2156                             if (var.owner == classDef.sym) {
2157                                 // choose the diagnostic position based on whether
2158                                 // the ctor is default(synthesized) or not
2159                                 if (isSynthesized &amp;&amp; !isCompactConstructor) {
2160                                     checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),
2161                                             var, Errors.VarNotInitializedInDefaultConstructor(var));
2162                                 } else if (isCompactConstructor) {
2163                                     boolean isInstanceRecordField = var.enclClass().isRecord() &amp;&amp;
2164                                             (var.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
2165                                             !var.isStatic() &amp;&amp;
2166                                             var.owner.kind == TYP;
2167                                     if (isInstanceRecordField) {
2168                                         boolean notInitialized = !inits.isMember(var.adr);
2169                                         if (notInitialized &amp;&amp; uninits.isMember(var.adr) &amp;&amp; tree.completesNormally) {
2170                                         /*  this way we indicate Lower that it should generate an initialization for this field
2171                                          *  in the compact constructor
2172                                          */
2173                                             var.flags_field |= UNINITIALIZED_FIELD;
2174                                         } else {
2175                                             checkInit(TreeInfo.diagEndPos(tree.body), var);
2176                                         }
2177                                     } else {
2178                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2179                                     }
2180                                 } else {
2181                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2182                                 }
2183                             }
2184                         }
2185                     }
2186                     clearPendingExits(true);
2187                 } finally {
2188                     inits.assign(initsPrev);
2189                     uninits.assign(uninitsPrev);
2190                     nextadr = nextadrPrev;
2191                     firstadr = firstadrPrev;
2192                     returnadr = returnadrPrev;
2193                     isInitialConstructor = lastInitialConstructor;
2194                 }
2195             } finally {
2196                 lint = lintPrev;
<a name="8" id="anc8"></a><span class="line-added">2197                 this.thisExposability = priorThisExposability;</span>
2198             }
2199         }
2200 
2201         private void clearPendingExits(boolean inMethod) {
2202             List&lt;PendingExit&gt; exits = pendingExits.toList();
2203             pendingExits = new ListBuffer&lt;&gt;();
2204             while (exits.nonEmpty()) {
2205                 PendingExit exit = exits.head;
2206                 exits = exits.tail;
2207                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
2208                                  log.hasErrorOn(exit.tree.pos()),
2209                              exit.tree);
2210                 if (inMethod &amp;&amp; isInitialConstructor) {
2211                     Assert.check(exit instanceof AssignPendingExit);
2212                     inits.assign(((AssignPendingExit) exit).exit_inits);
2213                     for (int i = firstadr; i &lt; nextadr; i++) {
2214                         checkInit(exit.tree.pos(), vardecls[i].sym);
2215                     }
2216                 }
2217             }
2218         }
2219         protected void initParam(JCVariableDecl def) {
2220             inits.incl(def.sym.adr);
2221             uninits.excl(def.sym.adr);
2222         }
2223 
2224         public void visitVarDef(JCVariableDecl tree) {
2225             Lint lintPrev = lint;
2226             lint = lint.augment(tree.sym);
2227             try{
2228                 boolean track = trackable(tree.sym);
2229                 if (track &amp;&amp; (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {
2230                     newVar(tree);
2231                 }
2232                 if (tree.init != null) {
2233                     scanExpr(tree.init);
2234                     if (track) {
2235                         letInit(tree.pos(), tree.sym);
2236                     }
2237                 }
2238             } finally {
2239                 lint = lintPrev;
2240             }
2241         }
2242 
2243         public void visitBlock(JCBlock tree) {
2244             int nextadrPrev = nextadr;
2245             scan(tree.stats);
2246             nextadr = nextadrPrev;
2247         }
2248 
2249         public void visitDoLoop(JCDoWhileLoop tree) {
2250             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2251             FlowKind prevFlowKind = flowKind;
2252             flowKind = FlowKind.NORMAL;
2253             final Bits initsSkip = new Bits(true);
2254             final Bits uninitsSkip = new Bits(true);
2255             pendingExits = new ListBuffer&lt;&gt;();
2256             int prevErrors = log.nerrors;
2257             do {
2258                 final Bits uninitsEntry = new Bits(uninits);
2259                 uninitsEntry.excludeFrom(nextadr);
2260                 scan(tree.body);
2261                 resolveContinues(tree);
2262                 scanCond(tree.cond);
2263                 if (!flowKind.isFinal()) {
2264                     initsSkip.assign(initsWhenFalse);
2265                     uninitsSkip.assign(uninitsWhenFalse);
2266                 }
2267                 if (log.nerrors !=  prevErrors ||
2268                     flowKind.isFinal() ||
2269                     new Bits(uninitsEntry).diffSet(uninitsWhenTrue).nextBit(firstadr)==-1)
2270                     break;
2271                 inits.assign(initsWhenTrue);
2272                 uninits.assign(uninitsEntry.andSet(uninitsWhenTrue));
2273                 flowKind = FlowKind.SPECULATIVE_LOOP;
2274             } while (true);
2275             flowKind = prevFlowKind;
2276             inits.assign(initsSkip);
2277             uninits.assign(uninitsSkip);
2278             resolveBreaks(tree, prevPendingExits);
2279         }
2280 
2281         public void visitWhileLoop(JCWhileLoop tree) {
2282             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2283             FlowKind prevFlowKind = flowKind;
2284             flowKind = FlowKind.NORMAL;
2285             final Bits initsSkip = new Bits(true);
2286             final Bits uninitsSkip = new Bits(true);
2287             pendingExits = new ListBuffer&lt;&gt;();
2288             int prevErrors = log.nerrors;
2289             final Bits uninitsEntry = new Bits(uninits);
2290             uninitsEntry.excludeFrom(nextadr);
2291             do {
2292                 scanCond(tree.cond);
2293                 if (!flowKind.isFinal()) {
2294                     initsSkip.assign(initsWhenFalse) ;
2295                     uninitsSkip.assign(uninitsWhenFalse);
2296                 }
2297                 inits.assign(initsWhenTrue);
2298                 uninits.assign(uninitsWhenTrue);
2299                 scan(tree.body);
2300                 resolveContinues(tree);
2301                 if (log.nerrors != prevErrors ||
2302                     flowKind.isFinal() ||
2303                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1) {
2304                     break;
2305                 }
2306                 uninits.assign(uninitsEntry.andSet(uninits));
2307                 flowKind = FlowKind.SPECULATIVE_LOOP;
2308             } while (true);
2309             flowKind = prevFlowKind;
2310             //a variable is DA/DU after the while statement, if it&#39;s DA/DU assuming the
2311             //branch is not taken AND if it&#39;s DA/DU before any break statement
2312             inits.assign(initsSkip);
2313             uninits.assign(uninitsSkip);
2314             resolveBreaks(tree, prevPendingExits);
2315         }
2316 
2317         public void visitForLoop(JCForLoop tree) {
2318             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2319             FlowKind prevFlowKind = flowKind;
2320             flowKind = FlowKind.NORMAL;
2321             int nextadrPrev = nextadr;
2322             scan(tree.init);
2323             final Bits initsSkip = new Bits(true);
2324             final Bits uninitsSkip = new Bits(true);
2325             pendingExits = new ListBuffer&lt;&gt;();
2326             int prevErrors = log.nerrors;
2327             do {
2328                 final Bits uninitsEntry = new Bits(uninits);
2329                 uninitsEntry.excludeFrom(nextadr);
2330                 if (tree.cond != null) {
2331                     scanCond(tree.cond);
2332                     if (!flowKind.isFinal()) {
2333                         initsSkip.assign(initsWhenFalse);
2334                         uninitsSkip.assign(uninitsWhenFalse);
2335                     }
2336                     inits.assign(initsWhenTrue);
2337                     uninits.assign(uninitsWhenTrue);
2338                 } else if (!flowKind.isFinal()) {
2339                     initsSkip.assign(inits);
2340                     initsSkip.inclRange(firstadr, nextadr);
2341                     uninitsSkip.assign(uninits);
2342                     uninitsSkip.inclRange(firstadr, nextadr);
2343                 }
2344                 scan(tree.body);
2345                 resolveContinues(tree);
2346                 scan(tree.step);
2347                 if (log.nerrors != prevErrors ||
2348                     flowKind.isFinal() ||
2349                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2350                     break;
2351                 uninits.assign(uninitsEntry.andSet(uninits));
2352                 flowKind = FlowKind.SPECULATIVE_LOOP;
2353             } while (true);
2354             flowKind = prevFlowKind;
2355             //a variable is DA/DU after a for loop, if it&#39;s DA/DU assuming the
2356             //branch is not taken AND if it&#39;s DA/DU before any break statement
2357             inits.assign(initsSkip);
2358             uninits.assign(uninitsSkip);
2359             resolveBreaks(tree, prevPendingExits);
2360             nextadr = nextadrPrev;
2361         }
2362 
2363         public void visitForeachLoop(JCEnhancedForLoop tree) {
2364             visitVarDef(tree.var);
2365 
2366             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2367             FlowKind prevFlowKind = flowKind;
2368             flowKind = FlowKind.NORMAL;
2369             int nextadrPrev = nextadr;
2370             scan(tree.expr);
2371             final Bits initsStart = new Bits(inits);
2372             final Bits uninitsStart = new Bits(uninits);
2373 
2374             letInit(tree.pos(), tree.var.sym);
2375             pendingExits = new ListBuffer&lt;&gt;();
2376             int prevErrors = log.nerrors;
2377             do {
2378                 final Bits uninitsEntry = new Bits(uninits);
2379                 uninitsEntry.excludeFrom(nextadr);
2380                 scan(tree.body);
2381                 resolveContinues(tree);
2382                 if (log.nerrors != prevErrors ||
2383                     flowKind.isFinal() ||
2384                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2385                     break;
2386                 uninits.assign(uninitsEntry.andSet(uninits));
2387                 flowKind = FlowKind.SPECULATIVE_LOOP;
2388             } while (true);
2389             flowKind = prevFlowKind;
2390             inits.assign(initsStart);
2391             uninits.assign(uninitsStart.andSet(uninits));
2392             resolveBreaks(tree, prevPendingExits);
2393             nextadr = nextadrPrev;
2394         }
2395 
2396         public void visitLabelled(JCLabeledStatement tree) {
2397             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2398             pendingExits = new ListBuffer&lt;&gt;();
2399             scan(tree.body);
2400             resolveBreaks(tree, prevPendingExits);
2401         }
2402 
2403         public void visitSwitch(JCSwitch tree) {
2404             handleSwitch(tree, tree.selector, tree.cases);
2405         }
2406 
2407         public void visitSwitchExpression(JCSwitchExpression tree) {
2408             handleSwitch(tree, tree.selector, tree.cases);
2409         }
2410 
2411         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
2412             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2413             pendingExits = new ListBuffer&lt;&gt;();
2414             int nextadrPrev = nextadr;
2415             scanExpr(selector);
2416             final Bits initsSwitch = new Bits(inits);
2417             final Bits uninitsSwitch = new Bits(uninits);
2418             boolean hasDefault = false;
2419             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
2420                 inits.assign(initsSwitch);
2421                 uninits.assign(uninits.andSet(uninitsSwitch));
2422                 JCCase c = l.head;
2423                 if (c.pats.isEmpty()) {
2424                     hasDefault = true;
2425                 } else {
2426                     for (JCExpression pat : c.pats) {
2427                         scanExpr(pat);
2428                     }
2429                 }
2430                 if (hasDefault) {
2431                     inits.assign(initsSwitch);
2432                     uninits.assign(uninits.andSet(uninitsSwitch));
2433                 }
2434                 scan(c.stats);
2435                 if (c.completesNormally &amp;&amp; c.caseKind == JCCase.RULE) {
2436                     scanSyntheticBreak(make, tree);
2437                 }
2438                 addVars(c.stats, initsSwitch, uninitsSwitch);
2439                 if (!hasDefault) {
2440                     inits.assign(initsSwitch);
2441                     uninits.assign(uninits.andSet(uninitsSwitch));
2442                 }
2443                 // Warn about fall-through if lint switch fallthrough enabled.
2444             }
2445             if (!hasDefault) {
2446                 if (tree.hasTag(SWITCH_EXPRESSION)) {
2447                     markDead();
2448                 } else {
2449                     inits.andSet(initsSwitch);
2450                 }
2451             }
2452             if (tree.hasTag(SWITCH_EXPRESSION)) {
2453                 resolveYields(tree, prevPendingExits);
2454             } else {
2455                 resolveBreaks(tree, prevPendingExits);
2456             }
2457             nextadr = nextadrPrev;
2458         }
2459         // where
2460             /** Add any variables defined in stats to inits and uninits. */
2461             private void addVars(List&lt;JCStatement&gt; stats, final Bits inits,
2462                                         final Bits uninits) {
2463                 for (;stats.nonEmpty(); stats = stats.tail) {
2464                     JCTree stat = stats.head;
2465                     if (stat.hasTag(VARDEF)) {
2466                         int adr = ((JCVariableDecl) stat).sym.adr;
2467                         inits.excl(adr);
2468                         uninits.incl(adr);
2469                     }
2470                 }
2471             }
2472 
2473         public void visitTry(JCTry tree) {
2474             ListBuffer&lt;JCVariableDecl&gt; resourceVarDecls = new ListBuffer&lt;&gt;();
2475             final Bits uninitsTryPrev = new Bits(uninitsTry);
2476             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2477             pendingExits = new ListBuffer&lt;&gt;();
2478             final Bits initsTry = new Bits(inits);
2479             uninitsTry.assign(uninits);
2480             for (JCTree resource : tree.resources) {
2481                 if (resource instanceof JCVariableDecl) {
2482                     JCVariableDecl vdecl = (JCVariableDecl) resource;
2483                     visitVarDef(vdecl);
2484                     unrefdResources.enter(vdecl.sym);
2485                     resourceVarDecls.append(vdecl);
2486                 } else if (resource instanceof JCExpression) {
2487                     scanExpr((JCExpression) resource);
2488                 } else {
2489                     throw new AssertionError(tree);  // parser error
2490                 }
2491             }
2492             scan(tree.body);
2493             uninitsTry.andSet(uninits);
2494             final Bits initsEnd = new Bits(inits);
2495             final Bits uninitsEnd = new Bits(uninits);
2496             int nextadrCatch = nextadr;
2497 
2498             if (!resourceVarDecls.isEmpty() &amp;&amp;
2499                     lint.isEnabled(Lint.LintCategory.TRY)) {
2500                 for (JCVariableDecl resVar : resourceVarDecls) {
2501                     if (unrefdResources.includes(resVar.sym)) {
2502                         log.warning(Lint.LintCategory.TRY, resVar.pos(),
2503                                     Warnings.TryResourceNotReferenced(resVar.sym));
2504                         unrefdResources.remove(resVar.sym);
2505                     }
2506                 }
2507             }
2508 
2509             /*  The analysis of each catch should be independent.
2510              *  Each one should have the same initial values of inits and
2511              *  uninits.
2512              */
2513             final Bits initsCatchPrev = new Bits(initsTry);
2514             final Bits uninitsCatchPrev = new Bits(uninitsTry);
2515 
2516             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
2517                 JCVariableDecl param = l.head.param;
2518                 inits.assign(initsCatchPrev);
2519                 uninits.assign(uninitsCatchPrev);
2520                 scan(param);
2521                 /* If this is a TWR and we are executing the code from Gen,
2522                  * then there can be synthetic variables, ignore them.
2523                  */
2524                 initParam(param);
2525                 scan(l.head.body);
2526                 initsEnd.andSet(inits);
2527                 uninitsEnd.andSet(uninits);
2528                 nextadr = nextadrCatch;
2529             }
2530             if (tree.finalizer != null) {
2531                 inits.assign(initsTry);
2532                 uninits.assign(uninitsTry);
2533                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2534                 pendingExits = prevPendingExits;
2535                 scan(tree.finalizer);
2536                 if (!tree.finallyCanCompleteNormally) {
2537                     // discard exits and exceptions from try and finally
2538                 } else {
2539                     uninits.andSet(uninitsEnd);
2540                     // FIX: this doesn&#39;t preserve source order of exits in catch
2541                     // versus finally!
2542                     while (exits.nonEmpty()) {
2543                         PendingExit exit = exits.next();
2544                         if (exit instanceof AssignPendingExit) {
2545                             ((AssignPendingExit) exit).exit_inits.orSet(inits);
2546                             ((AssignPendingExit) exit).exit_uninits.andSet(uninits);
2547                         }
2548                         pendingExits.append(exit);
2549                     }
2550                     inits.orSet(initsEnd);
2551                 }
2552             } else {
2553                 inits.assign(initsEnd);
2554                 uninits.assign(uninitsEnd);
2555                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2556                 pendingExits = prevPendingExits;
2557                 while (exits.nonEmpty()) pendingExits.append(exits.next());
2558             }
2559             uninitsTry.andSet(uninitsTryPrev).andSet(uninits);
2560         }
2561 
2562         public void visitConditional(JCConditional tree) {
2563             scanCond(tree.cond);
2564             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2565             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2566             inits.assign(initsWhenTrue);
2567             uninits.assign(uninitsWhenTrue);
2568             if (tree.truepart.type.hasTag(BOOLEAN) &amp;&amp;
2569                 tree.falsepart.type.hasTag(BOOLEAN)) {
2570                 // if b and c are boolean valued, then
2571                 // v is (un)assigned after a?b:c when true iff
2572                 //    v is (un)assigned after b when true and
2573                 //    v is (un)assigned after c when true
2574                 scanCond(tree.truepart);
2575                 final Bits initsAfterThenWhenTrue = new Bits(initsWhenTrue);
2576                 final Bits initsAfterThenWhenFalse = new Bits(initsWhenFalse);
2577                 final Bits uninitsAfterThenWhenTrue = new Bits(uninitsWhenTrue);
2578                 final Bits uninitsAfterThenWhenFalse = new Bits(uninitsWhenFalse);
2579                 inits.assign(initsBeforeElse);
2580                 uninits.assign(uninitsBeforeElse);
2581                 scanCond(tree.falsepart);
2582                 initsWhenTrue.andSet(initsAfterThenWhenTrue);
2583                 initsWhenFalse.andSet(initsAfterThenWhenFalse);
2584                 uninitsWhenTrue.andSet(uninitsAfterThenWhenTrue);
2585                 uninitsWhenFalse.andSet(uninitsAfterThenWhenFalse);
2586             } else {
2587                 scanExpr(tree.truepart);
2588                 final Bits initsAfterThen = new Bits(inits);
2589                 final Bits uninitsAfterThen = new Bits(uninits);
2590                 inits.assign(initsBeforeElse);
2591                 uninits.assign(uninitsBeforeElse);
2592                 scanExpr(tree.falsepart);
2593                 inits.andSet(initsAfterThen);
2594                 uninits.andSet(uninitsAfterThen);
2595             }
2596         }
2597 
2598         public void visitIf(JCIf tree) {
2599             scanCond(tree.cond);
2600             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2601             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2602             inits.assign(initsWhenTrue);
2603             uninits.assign(uninitsWhenTrue);
2604             scan(tree.thenpart);
2605             if (tree.elsepart != null) {
2606                 final Bits initsAfterThen = new Bits(inits);
2607                 final Bits uninitsAfterThen = new Bits(uninits);
2608                 inits.assign(initsBeforeElse);
2609                 uninits.assign(uninitsBeforeElse);
2610                 scan(tree.elsepart);
2611                 inits.andSet(initsAfterThen);
2612                 uninits.andSet(uninitsAfterThen);
2613             } else {
2614                 inits.andSet(initsBeforeElse);
2615                 uninits.andSet(uninitsBeforeElse);
2616             }
2617         }
2618 
2619         @Override
2620         public void visitBreak(JCBreak tree) {
2621             recordExit(new AssignPendingExit(tree, inits, uninits));
2622         }
2623 
2624         @Override
2625         public void visitYield(JCYield tree) {
2626             JCSwitchExpression expr = (JCSwitchExpression) tree.target;
2627             if (expr != null &amp;&amp; expr.type.hasTag(BOOLEAN)) {
2628                 scanCond(tree.value);
2629                 Bits initsAfterBreakWhenTrue = new Bits(initsWhenTrue);
2630                 Bits initsAfterBreakWhenFalse = new Bits(initsWhenFalse);
2631                 Bits uninitsAfterBreakWhenTrue = new Bits(uninitsWhenTrue);
2632                 Bits uninitsAfterBreakWhenFalse = new Bits(uninitsWhenFalse);
2633                 PendingExit exit = new PendingExit(tree) {
2634                     @Override
2635                     void resolveJump() {
2636                         if (!inits.isReset()) {
2637                             split(true);
2638                         }
2639                         initsWhenTrue.andSet(initsAfterBreakWhenTrue);
2640                         initsWhenFalse.andSet(initsAfterBreakWhenFalse);
2641                         uninitsWhenTrue.andSet(uninitsAfterBreakWhenTrue);
2642                         uninitsWhenFalse.andSet(uninitsAfterBreakWhenFalse);
2643                     }
2644                 };
2645                 merge();
2646                 recordExit(exit);
2647                 return ;
2648             } else {
2649                 scanExpr(tree.value);
2650                 recordExit(new AssignPendingExit(tree, inits, uninits));
2651             }
2652         }
2653 
2654         @Override
2655         public void visitContinue(JCContinue tree) {
2656             recordExit(new AssignPendingExit(tree, inits, uninits));
2657         }
2658 
2659         @Override
2660         public void visitReturn(JCReturn tree) {
2661             scanExpr(tree.expr);
2662             recordExit(new AssignPendingExit(tree, inits, uninits));
2663         }
2664 
2665         public void visitThrow(JCThrow tree) {
2666             scanExpr(tree.expr);
2667             markDead();
2668         }
2669 
2670         public void visitApply(JCMethodInvocation tree) {
2671             scanExpr(tree.meth);
2672             scanExprs(tree.args);
<a name="9" id="anc9"></a><span class="line-added">2673             if (tree.meth.hasTag(IDENT)) {</span>
<span class="line-added">2674                 JCIdent ident = (JCIdent) tree.meth;</span>
<span class="line-added">2675                 if (ident.name != names._super &amp;&amp; !ident.sym.isStatic())</span>
<span class="line-added">2676                     checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2677             }</span>
2678         }
2679 
2680         public void visitNewClass(JCNewClass tree) {
2681             scanExpr(tree.encl);
2682             scanExprs(tree.args);
2683             scan(tree.def);
<a name="10" id="anc10"></a><span class="line-added">2684             if (classDef != null &amp;&amp; tree.encl == null &amp;&amp; tree.clazz.hasTag(IDENT)) {</span>
<span class="line-added">2685                 JCIdent clazz = (JCIdent) tree.clazz;</span>
<span class="line-added">2686                 if (!clazz.sym.isStatic() &amp;&amp; clazz.type.getEnclosingType().tsym == classDef.sym) {</span>
<span class="line-added">2687                     checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2688                 }</span>
<span class="line-added">2689             }</span>
2690         }
2691 
2692         @Override
2693         public void visitLambda(JCLambda tree) {
2694             final Bits prevUninits = new Bits(uninits);
2695             final Bits prevInits = new Bits(inits);
2696             int returnadrPrev = returnadr;
2697             int nextadrPrev = nextadr;
2698             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
2699             try {
2700                 returnadr = nextadr;
2701                 pendingExits = new ListBuffer&lt;&gt;();
2702                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2703                     JCVariableDecl def = l.head;
2704                     scan(def);
2705                     inits.incl(def.sym.adr);
2706                     uninits.excl(def.sym.adr);
2707                 }
2708                 if (tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2709                     scanExpr(tree.body);
2710                 } else {
2711                     scan(tree.body);
2712                 }
2713             }
2714             finally {
2715                 returnadr = returnadrPrev;
2716                 uninits.assign(prevUninits);
2717                 inits.assign(prevInits);
2718                 pendingExits = prevPending;
2719                 nextadr = nextadrPrev;
2720             }
2721         }
2722 
2723         public void visitNewArray(JCNewArray tree) {
2724             scanExprs(tree.dims);
2725             scanExprs(tree.elems);
2726         }
2727 
2728         public void visitAssert(JCAssert tree) {
2729             final Bits initsExit = new Bits(inits);
2730             final Bits uninitsExit = new Bits(uninits);
2731             scanCond(tree.cond);
2732             uninitsExit.andSet(uninitsWhenTrue);
2733             if (tree.detail != null) {
2734                 inits.assign(initsWhenFalse);
2735                 uninits.assign(uninitsWhenFalse);
2736                 scanExpr(tree.detail);
2737             }
2738             inits.assign(initsExit);
2739             uninits.assign(uninitsExit);
2740         }
2741 
2742         public void visitAssign(JCAssign tree) {
2743             if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))
2744                 scanExpr(tree.lhs);
2745             scanExpr(tree.rhs);
2746             letInit(tree.lhs);
2747         }
2748 
2749         // check fields accessed through this.&lt;field&gt; are definitely
2750         // assigned before reading their value
2751         public void visitSelect(JCFieldAccess tree) {
<a name="11" id="anc11"></a><span class="line-modified">2752             ThisExposability priorThisExposability = this.thisExposability;</span>
<span class="line-added">2753             try {</span>
<span class="line-added">2754                 if (tree.name == names._this &amp;&amp; classDef != null &amp;&amp; tree.sym.owner == classDef.sym) {</span>
<span class="line-added">2755                     checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2756                 } else if (tree.sym.kind == VAR || tree.sym.isStatic()) {</span>
<span class="line-added">2757                     this.thisExposability = ALLOWED;</span>
<span class="line-added">2758                 }</span>
<span class="line-added">2759                 super.visitSelect(tree);</span>
2760             if (TreeInfo.isThisQualifier(tree.selected) &amp;&amp;
2761                 tree.sym.kind == VAR) {
<a name="12" id="anc12"></a><span class="line-modified">2762                     checkInit(tree.pos(), (VarSymbol)tree.sym);</span>
<span class="line-added">2763                 }</span>
<span class="line-added">2764             } finally {</span>
<span class="line-added">2765                  this.thisExposability = priorThisExposability;</span>
2766             }
2767         }
2768 
2769         public void visitAssignop(JCAssignOp tree) {
2770             scanExpr(tree.lhs);
2771             scanExpr(tree.rhs);
2772             letInit(tree.lhs);
2773         }
2774 
2775         public void visitUnary(JCUnary tree) {
2776             switch (tree.getTag()) {
2777             case NOT:
2778                 scanCond(tree.arg);
2779                 final Bits t = new Bits(initsWhenFalse);
2780                 initsWhenFalse.assign(initsWhenTrue);
2781                 initsWhenTrue.assign(t);
2782                 t.assign(uninitsWhenFalse);
2783                 uninitsWhenFalse.assign(uninitsWhenTrue);
2784                 uninitsWhenTrue.assign(t);
2785                 break;
2786             case PREINC: case POSTINC:
2787             case PREDEC: case POSTDEC:
2788                 scanExpr(tree.arg);
2789                 letInit(tree.arg);
2790                 break;
2791             default:
2792                 scanExpr(tree.arg);
2793             }
2794         }
2795 
2796         public void visitBinary(JCBinary tree) {
2797             switch (tree.getTag()) {
2798             case AND:
2799                 scanCond(tree.lhs);
2800                 final Bits initsWhenFalseLeft = new Bits(initsWhenFalse);
2801                 final Bits uninitsWhenFalseLeft = new Bits(uninitsWhenFalse);
2802                 inits.assign(initsWhenTrue);
2803                 uninits.assign(uninitsWhenTrue);
2804                 scanCond(tree.rhs);
2805                 initsWhenFalse.andSet(initsWhenFalseLeft);
2806                 uninitsWhenFalse.andSet(uninitsWhenFalseLeft);
2807                 break;
2808             case OR:
2809                 scanCond(tree.lhs);
2810                 final Bits initsWhenTrueLeft = new Bits(initsWhenTrue);
2811                 final Bits uninitsWhenTrueLeft = new Bits(uninitsWhenTrue);
2812                 inits.assign(initsWhenFalse);
2813                 uninits.assign(uninitsWhenFalse);
2814                 scanCond(tree.rhs);
2815                 initsWhenTrue.andSet(initsWhenTrueLeft);
2816                 uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
2817                 break;
2818             default:
2819                 scanExpr(tree.lhs);
2820                 scanExpr(tree.rhs);
2821             }
2822         }
2823 
2824         public void visitIdent(JCIdent tree) {
2825             if (tree.sym.kind == VAR) {
2826                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2827                 referenced(tree.sym);
2828             }
<a name="13" id="anc13"></a><span class="line-added">2829             if (tree.name == names._this) {</span>
<span class="line-added">2830                 checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2831             }</span>
2832         }
2833 
2834         void referenced(Symbol sym) {
2835             unrefdResources.remove(sym);
2836         }
2837 
2838         public void visitAnnotatedType(JCAnnotatedType tree) {
2839             // annotations don&#39;t get scanned
2840             tree.underlyingType.accept(this);
2841         }
2842 
2843         public void visitModuleDef(JCModuleDecl tree) {
2844             // Do nothing for modules
2845         }
2846 
2847     /**************************************************************************
2848      * main method
2849      *************************************************************************/
2850 
2851         /** Perform definite assignment/unassignment analysis on a tree.
2852          */
2853         public void analyzeTree(Env&lt;?&gt; env, TreeMaker make) {
2854             analyzeTree(env, env.tree, make);
2855          }
2856 
2857         public void analyzeTree(Env&lt;?&gt; env, JCTree tree, TreeMaker make) {
2858             try {
2859                 startPos = tree.pos().getStartPosition();
2860 
2861                 if (vardecls == null)
2862                     vardecls = new JCVariableDecl[32];
2863                 else
2864                     for (int i=0; i&lt;vardecls.length; i++)
2865                         vardecls[i] = null;
2866                 firstadr = 0;
2867                 nextadr = 0;
2868                 Flow.this.make = make;
2869                 pendingExits = new ListBuffer&lt;&gt;();
2870                 this.classDef = null;
2871                 unrefdResources = WriteableScope.create(env.enclClass.sym);
2872                 scan(tree);
2873             } finally {
2874                 // note that recursive invocations of this method fail hard
2875                 startPos = -1;
2876                 resetBits(inits, uninits, uninitsTry, initsWhenTrue,
2877                         initsWhenFalse, uninitsWhenTrue, uninitsWhenFalse);
2878                 if (vardecls != null) {
2879                     for (int i=0; i&lt;vardecls.length; i++)
2880                         vardecls[i] = null;
2881                 }
2882                 firstadr = 0;
2883                 nextadr = 0;
2884                 Flow.this.make = null;
2885                 pendingExits = null;
2886                 this.classDef = null;
2887                 unrefdResources = null;
2888             }
2889         }
2890     }
2891 
2892     /**
2893      * This pass implements the last step of the dataflow analysis, namely
2894      * the effectively-final analysis check. This checks that every local variable
2895      * reference from a lambda body/local inner class is either final or effectively final.
2896      * Additional this also checks that every variable that is used as an operand to
2897      * try-with-resources is final or effectively final.
2898      * As effectively final variables are marked as such during DA/DU, this pass must run after
2899      * AssignAnalyzer.
2900      */
2901     class CaptureAnalyzer extends BaseAnalyzer {
2902 
2903         JCTree currentTree; //local class or lambda
2904 
2905         @Override
2906         void markDead() {
2907             //do nothing
2908         }
2909 
2910         @SuppressWarnings(&quot;fallthrough&quot;)
2911         void checkEffectivelyFinal(DiagnosticPosition pos, VarSymbol sym) {
2912             if (currentTree != null &amp;&amp;
2913                     sym.owner.kind == MTH &amp;&amp;
2914                     sym.pos &lt; currentTree.getStartPosition()) {
2915                 switch (currentTree.getTag()) {
2916                     case CLASSDEF:
2917                         if (!allowEffectivelyFinalInInnerClasses) {
2918                             if ((sym.flags() &amp; FINAL) == 0) {
2919                                 reportInnerClsNeedsFinalError(pos, sym);
2920                             }
2921                             break;
2922                         }
2923                     case LAMBDA:
2924                         if ((sym.flags() &amp; (EFFECTIVELY_FINAL | FINAL)) == 0) {
2925                            reportEffectivelyFinalError(pos, sym);
2926                         }
2927                 }
2928             }
2929         }
2930 
2931         @SuppressWarnings(&quot;fallthrough&quot;)
2932         void letInit(JCTree tree) {
2933             tree = TreeInfo.skipParens(tree);
2934             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
2935                 Symbol sym = TreeInfo.symbol(tree);
2936                 if (currentTree != null &amp;&amp;
2937                         sym.kind == VAR &amp;&amp;
2938                         sym.owner.kind == MTH &amp;&amp;
2939                         ((VarSymbol)sym).pos &lt; currentTree.getStartPosition()) {
2940                     switch (currentTree.getTag()) {
2941                         case CLASSDEF:
2942                             if (!allowEffectivelyFinalInInnerClasses) {
2943                                 reportInnerClsNeedsFinalError(tree, sym);
2944                                 break;
2945                             }
2946                         case LAMBDA:
2947                             reportEffectivelyFinalError(tree, sym);
2948                     }
2949                 }
2950             }
2951         }
2952 
2953         void reportEffectivelyFinalError(DiagnosticPosition pos, Symbol sym) {
2954             String subKey = currentTree.hasTag(LAMBDA) ?
2955                   &quot;lambda&quot;  : &quot;inner.cls&quot;;
2956             log.error(pos, Errors.CantRefNonEffectivelyFinalVar(sym, diags.fragment(subKey)));
2957         }
2958 
2959         void reportInnerClsNeedsFinalError(DiagnosticPosition pos, Symbol sym) {
2960             log.error(pos,
2961                       Errors.LocalVarAccessedFromIclsNeedsFinal(sym));
2962         }
2963 
2964     /*************************************************************************
2965      * Visitor methods for statements and definitions
2966      *************************************************************************/
2967 
2968         /* ------------ Visitor methods for various sorts of trees -------------*/
2969 
2970         public void visitClassDef(JCClassDecl tree) {
2971             JCTree prevTree = currentTree;
2972             try {
2973                 currentTree = tree.sym.isLocal() ? tree : null;
2974                 super.visitClassDef(tree);
2975             } finally {
2976                 currentTree = prevTree;
2977             }
2978         }
2979 
2980         @Override
2981         public void visitLambda(JCLambda tree) {
2982             JCTree prevTree = currentTree;
2983             try {
2984                 currentTree = tree;
2985                 super.visitLambda(tree);
2986             } finally {
2987                 currentTree = prevTree;
2988             }
2989         }
2990 
2991         @Override
2992         public void visitIdent(JCIdent tree) {
2993             if (tree.sym.kind == VAR) {
2994                 checkEffectivelyFinal(tree, (VarSymbol)tree.sym);
2995             }
2996         }
2997 
2998         public void visitAssign(JCAssign tree) {
2999             JCTree lhs = TreeInfo.skipParens(tree.lhs);
3000             if (!(lhs instanceof JCIdent)) {
3001                 scan(lhs);
3002             }
3003             scan(tree.rhs);
3004             letInit(lhs);
3005         }
3006 
3007         public void visitAssignop(JCAssignOp tree) {
3008             scan(tree.lhs);
3009             scan(tree.rhs);
3010             letInit(tree.lhs);
3011         }
3012 
3013         public void visitUnary(JCUnary tree) {
3014             switch (tree.getTag()) {
3015                 case PREINC: case POSTINC:
3016                 case PREDEC: case POSTDEC:
3017                     scan(tree.arg);
3018                     letInit(tree.arg);
3019                     break;
3020                 default:
3021                     scan(tree.arg);
3022             }
3023         }
3024 
3025         public void visitTry(JCTry tree) {
3026             for (JCTree resource : tree.resources) {
3027                 if (!resource.hasTag(VARDEF)) {
3028                     Symbol var = TreeInfo.symbol(resource);
3029                     if (var != null &amp;&amp; (var.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) == 0) {
3030                         log.error(resource.pos(), Errors.TryWithResourcesExprEffectivelyFinalVar(var));
3031                     }
3032                 }
3033             }
3034             super.visitTry(tree);
3035         }
3036 
3037         @Override
3038         public void visitYield(JCYield tree) {
3039             scan(tree.value);
3040         }
3041 
3042         public void visitModuleDef(JCModuleDecl tree) {
3043             // Do nothing for modules
3044         }
3045 
3046     /**************************************************************************
3047      * main method
3048      *************************************************************************/
3049 
3050         /** Perform definite assignment/unassignment analysis on a tree.
3051          */
3052         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
3053             analyzeTree(env, env.tree, make);
3054         }
3055         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
3056             try {
3057                 attrEnv = env;
3058                 Flow.this.make = make;
3059                 pendingExits = new ListBuffer&lt;&gt;();
3060                 scan(tree);
3061             } finally {
3062                 pendingExits = null;
3063                 Flow.this.make = null;
3064             }
3065         }
3066     }
3067 
3068     enum Liveness {
3069         ALIVE {
3070             @Override
3071             public Liveness or(Liveness other) {
3072                 return this;
3073             }
3074             @Override
3075             public Liveness and(Liveness other) {
3076                 return other;
3077             }
3078         },
3079         DEAD {
3080             @Override
3081             public Liveness or(Liveness other) {
3082                 return other;
3083             }
3084             @Override
3085             public Liveness and(Liveness other) {
3086                 return this;
3087             }
3088         },
3089         RECOVERY {
3090             @Override
3091             public Liveness or(Liveness other) {
3092                 if (other == ALIVE) {
3093                     return ALIVE;
3094                 } else {
3095                     return this;
3096                 }
3097             }
3098             @Override
3099             public Liveness and(Liveness other) {
3100                 if (other == DEAD) {
3101                     return DEAD;
3102                 } else {
3103                     return this;
3104                 }
3105             }
3106         };
3107 
3108         public abstract Liveness or(Liveness other);
3109         public abstract Liveness and(Liveness other);
3110         public Liveness or(boolean value) {
3111             return or(from(value));
3112         }
3113         public Liveness and(boolean value) {
3114             return and(from(value));
3115         }
3116         public static Liveness from(boolean value) {
3117             return value ? ALIVE : DEAD;
3118         }
3119     }
3120 
3121 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
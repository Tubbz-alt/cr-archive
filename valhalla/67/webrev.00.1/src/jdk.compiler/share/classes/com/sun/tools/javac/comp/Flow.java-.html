<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //todo: one might eliminate uninits.andSets when monotonic
  27 
  28 package com.sun.tools.javac.comp;
  29 
  30 import java.util.HashMap;
  31 import java.util.HashSet;
  32 import java.util.Set;
  33 
  34 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  35 import com.sun.tools.javac.code.*;
  36 import com.sun.tools.javac.code.Scope.WriteableScope;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  39 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  40 import com.sun.tools.javac.tree.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  43 import com.sun.tools.javac.util.JCDiagnostic.Error;
  44 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  45 
  46 import com.sun.tools.javac.code.Kinds.Kind;
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;
  55 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  56 
  57 /** This pass implements dataflow analysis for Java programs though
  58  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  59  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  60  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  61  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  62  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  63  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
  64  *  determines that local variables accessed within the scope of an inner class/lambda
  65  *  are either final or effectively-final.
  66  *
  67  *  &lt;p&gt;The JLS has a number of problems in the
  68  *  specification of these flow analysis problems. This implementation
  69  *  attempts to address those issues.
  70  *
  71  *  &lt;p&gt;First, there is no accommodation for a finally clause that cannot
  72  *  complete normally. For liveness analysis, an intervening finally
  73  *  clause can cause a break, continue, or return not to reach its
  74  *  target.  For exception analysis, an intervening finally clause can
  75  *  cause any exception to be &quot;caught&quot;.  For DA/DU analysis, the finally
  76  *  clause can prevent a transfer of control from propagating DA/DU
  77  *  state to the target.  In addition, code in the finally clause can
  78  *  affect the DA/DU status of variables.
  79  *
  80  *  &lt;p&gt;For try statements, we introduce the idea of a variable being
  81  *  definitely unassigned &quot;everywhere&quot; in a block.  A variable V is
  82  *  &quot;unassigned everywhere&quot; in a block iff it is unassigned at the
  83  *  beginning of the block and there is no reachable assignment to V
  84  *  in the block.  An assignment V=e is reachable iff V is not DA
  85  *  after e.  Then we can say that V is DU at the beginning of the
  86  *  catch block iff V is DU everywhere in the try block.  Similarly, V
  87  *  is DU at the beginning of the finally block iff V is DU everywhere
  88  *  in the try block and in every catch block.  Specifically, the
  89  *  following bullet is added to 16.2.2
  90  *  &lt;pre&gt;
  91  *      V is &lt;em&gt;unassigned everywhere&lt;/em&gt; in a block if it is
  92  *      unassigned before the block and there is no reachable
  93  *      assignment to V within the block.
  94  *  &lt;/pre&gt;
  95  *  &lt;p&gt;In 16.2.15, the third bullet (and all of its sub-bullets) for all
  96  *  try blocks is changed to
  97  *  &lt;pre&gt;
  98  *      V is definitely unassigned before a catch block iff V is
  99  *      definitely unassigned everywhere in the try block.
 100  *  &lt;/pre&gt;
 101  *  &lt;p&gt;The last bullet (and all of its sub-bullets) for try blocks that
 102  *  have a finally block is changed to
 103  *  &lt;pre&gt;
 104  *      V is definitely unassigned before the finally block iff
 105  *      V is definitely unassigned everywhere in the try block
 106  *      and everywhere in each catch block of the try statement.
 107  *  &lt;/pre&gt;
 108  *  &lt;p&gt;In addition,
 109  *  &lt;pre&gt;
 110  *      V is definitely assigned at the end of a constructor iff
 111  *      V is definitely assigned after the block that is the body
 112  *      of the constructor and V is definitely assigned at every
 113  *      return that can return from the constructor.
 114  *  &lt;/pre&gt;
 115  *  &lt;p&gt;In addition, each continue statement with the loop as its target
 116  *  is treated as a jump to the end of the loop body, and &quot;intervening&quot;
 117  *  finally clauses are treated as follows: V is DA &quot;due to the
 118  *  continue&quot; iff V is DA before the continue statement or V is DA at
 119  *  the end of any intervening finally block.  V is DU &quot;due to the
 120  *  continue&quot; iff any intervening finally cannot complete normally or V
 121  *  is DU at the end of every intervening finally block.  This &quot;due to
 122  *  the continue&quot; concept is then used in the spec for the loops.
 123  *
 124  *  &lt;p&gt;Similarly, break statements must consider intervening finally
 125  *  blocks.  For liveness analysis, a break statement for which any
 126  *  intervening finally cannot complete normally is not considered to
 127  *  cause the target statement to be able to complete normally. Then
 128  *  we say V is DA &quot;due to the break&quot; iff V is DA before the break or
 129  *  V is DA at the end of any intervening finally block.  V is DU &quot;due
 130  *  to the break&quot; iff any intervening finally cannot complete normally
 131  *  or V is DU at the break and at the end of every intervening
 132  *  finally block.  (I suspect this latter condition can be
 133  *  simplified.)  This &quot;due to the break&quot; is then used in the spec for
 134  *  all statements that can be &quot;broken&quot;.
 135  *
 136  *  &lt;p&gt;The return statement is treated similarly.  V is DA &quot;due to a
 137  *  return statement&quot; iff V is DA before the return statement or V is
 138  *  DA at the end of any intervening finally block.  Note that we
 139  *  don&#39;t have to worry about the return expression because this
 140  *  concept is only used for constructors.
 141  *
 142  *  &lt;p&gt;There is no spec in the JLS for when a variable is definitely
 143  *  assigned at the end of a constructor, which is needed for final
 144  *  fields (8.3.1.2).  We implement the rule that V is DA at the end
 145  *  of the constructor iff it is DA and the end of the body of the
 146  *  constructor and V is DA &quot;due to&quot; every return of the constructor.
 147  *
 148  *  &lt;p&gt;Intervening finally blocks similarly affect exception analysis.  An
 149  *  intervening finally that cannot complete normally allows us to ignore
 150  *  an otherwise uncaught exception.
 151  *
 152  *  &lt;p&gt;To implement the semantics of intervening finally clauses, all
 153  *  nonlocal transfers (break, continue, return, throw, method call that
 154  *  can throw a checked exception, and a constructor invocation that can
 155  *  thrown a checked exception) are recorded in a queue, and removed
 156  *  from the queue when we complete processing the target of the
 157  *  nonlocal transfer.  This allows us to modify the queue in accordance
 158  *  with the above rules when we encounter a finally clause.  The only
 159  *  exception to this [no pun intended] is that checked exceptions that
 160  *  are known to be caught or declared to be caught in the enclosing
 161  *  method are not recorded in the queue, but instead are recorded in a
 162  *  global variable &quot;{@code Set&lt;Type&gt; thrown}&quot; that records the type of all
 163  *  exceptions that can be thrown.
 164  *
 165  *  &lt;p&gt;Other minor issues the treatment of members of other classes
 166  *  (always considered DA except that within an anonymous class
 167  *  constructor, where DA status from the enclosing scope is
 168  *  preserved), treatment of the case expression (V is DA before the
 169  *  case expression iff V is DA after the switch expression),
 170  *  treatment of variables declared in a switch block (the implied
 171  *  DA/DU status after the switch expression is DU and not DA for
 172  *  variables defined in a switch block), the treatment of boolean ?:
 173  *  expressions (The JLS rules only handle b and c non-boolean; the
 174  *  new rule is that if b and c are boolean valued, then V is
 175  *  (un)assigned after a?b:c when true/false iff V is (un)assigned
 176  *  after b when true/false and V is (un)assigned after c when
 177  *  true/false).
 178  *
 179  *  &lt;p&gt;There is the remaining question of what syntactic forms constitute a
 180  *  reference to a variable.  It is conventional to allow this.x on the
 181  *  left-hand-side to initialize a final instance field named x, yet
 182  *  this.x isn&#39;t considered a &quot;use&quot; when appearing on a right-hand-side
 183  *  in most implementations.  Should parentheses affect what is
 184  *  considered a variable reference?  The simplest rule would be to
 185  *  allow unqualified forms only, parentheses optional, and phase out
 186  *  support for assigning to a final field via this.x.
 187  *
 188  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 189  *  If you write code that depends on this, you do so at your own risk.
 190  *  This code and its internal interfaces are subject to change or
 191  *  deletion without notice.&lt;/b&gt;
 192  */
 193 public class Flow {
 194     protected static final Context.Key&lt;Flow&gt; flowKey = new Context.Key&lt;&gt;();
 195 
 196     private final Names names;
 197     private final Log log;
 198     private final Symtab syms;
 199     private final Types types;
 200     private final Check chk;
 201     private       TreeMaker make;
 202     private final Resolve rs;
 203     private final JCDiagnostic.Factory diags;
 204     private Env&lt;AttrContext&gt; attrEnv;
 205     private       Lint lint;
 206     private final boolean allowEffectivelyFinalInInnerClasses;
 207 
 208     public static Flow instance(Context context) {
 209         Flow instance = context.get(flowKey);
 210         if (instance == null)
 211             instance = new Flow(context);
 212         return instance;
 213     }
 214 
 215     public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 216         new AliveAnalyzer().analyzeTree(env, make);
 217         new AssignAnalyzer().analyzeTree(env, make);
 218         new FlowAnalyzer().analyzeTree(env, make);
 219         new CaptureAnalyzer().analyzeTree(env, make);
 220     }
 221 
 222     public void analyzeLambda(Env&lt;AttrContext&gt; env, JCLambda that, TreeMaker make, boolean speculative) {
 223         Log.DiagnosticHandler diagHandler = null;
 224         //we need to disable diagnostics temporarily; the problem is that if
 225         //a lambda expression contains e.g. an unreachable statement, an error
 226         //message will be reported and will cause compilation to skip the flow analysis
 227         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 228         //related errors, which will allow for more errors to be detected
 229         if (!speculative) {
 230             diagHandler = new Log.DiscardDiagnosticHandler(log);
 231         }
 232         try {
 233             new LambdaAliveAnalyzer().analyzeTree(env, that, make);
 234         } finally {
 235             if (!speculative) {
 236                 log.popDiagnosticHandler(diagHandler);
 237             }
 238         }
 239     }
 240 
 241     public List&lt;Type&gt; analyzeLambdaThrownTypes(final Env&lt;AttrContext&gt; env,
 242             JCLambda that, TreeMaker make) {
 243         //we need to disable diagnostics temporarily; the problem is that if
 244         //a lambda expression contains e.g. an unreachable statement, an error
 245         //message will be reported and will cause compilation to skip the flow analysis
 246         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 247         //related errors, which will allow for more errors to be detected
 248         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 249         try {
 250             new LambdaAssignAnalyzer(env).analyzeTree(env, that, make);
 251             LambdaFlowAnalyzer flowAnalyzer = new LambdaFlowAnalyzer();
 252             flowAnalyzer.analyzeTree(env, that, make);
 253             return flowAnalyzer.inferredThrownTypes;
 254         } finally {
 255             log.popDiagnosticHandler(diagHandler);
 256         }
 257     }
 258 
 259     public boolean aliveAfter(Env&lt;AttrContext&gt; env, JCTree that, TreeMaker make) {
 260         //we need to disable diagnostics temporarily; the problem is that if
 261         //&quot;that&quot; contains e.g. an unreachable statement, an error
 262         //message will be reported and will cause compilation to skip the flow analysis
 263         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 264         //related errors, which will allow for more errors to be detected
 265         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 266         try {
 267             SnippetAliveAnalyzer analyzer = new SnippetAliveAnalyzer();
 268 
 269             analyzer.analyzeTree(env, that, make);
 270             return analyzer.isAlive();
 271         } finally {
 272             log.popDiagnosticHandler(diagHandler);
 273         }
 274     }
 275 
 276     public boolean breaksOutOf(Env&lt;AttrContext&gt; env, JCTree loop, JCTree body, TreeMaker make) {
 277         //we need to disable diagnostics temporarily; the problem is that if
 278         //&quot;that&quot; contains e.g. an unreachable statement, an error
 279         //message will be reported and will cause compilation to skip the flow analysis
 280         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 281         //related errors, which will allow for more errors to be detected
 282         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 283         try {
 284             SnippetBreakAnalyzer analyzer = new SnippetBreakAnalyzer();
 285 
 286             analyzer.analyzeTree(env, body, make);
 287             return analyzer.breaksOut();
 288         } finally {
 289             log.popDiagnosticHandler(diagHandler);
 290         }
 291     }
 292 
 293     /**
 294      * Definite assignment scan mode
 295      */
 296     enum FlowKind {
 297         /**
 298          * This is the normal DA/DU analysis mode
 299          */
 300         NORMAL(&quot;var.might.already.be.assigned&quot;, false),
 301         /**
 302          * This is the speculative DA/DU analysis mode used to speculatively
 303          * derive assertions within loop bodies
 304          */
 305         SPECULATIVE_LOOP(&quot;var.might.be.assigned.in.loop&quot;, true);
 306 
 307         final String errKey;
 308         final boolean isFinal;
 309 
 310         FlowKind(String errKey, boolean isFinal) {
 311             this.errKey = errKey;
 312             this.isFinal = isFinal;
 313         }
 314 
 315         boolean isFinal() {
 316             return isFinal;
 317         }
 318     }
 319 
 320     protected Flow(Context context) {
 321         context.put(flowKey, this);
 322         names = Names.instance(context);
 323         log = Log.instance(context);
 324         syms = Symtab.instance(context);
 325         types = Types.instance(context);
 326         chk = Check.instance(context);
 327         lint = Lint.instance(context);
 328         rs = Resolve.instance(context);
 329         diags = JCDiagnostic.Factory.instance(context);
 330         Source source = Source.instance(context);
 331         allowEffectivelyFinalInInnerClasses = Feature.EFFECTIVELY_FINAL_IN_INNER_CLASSES.allowedInSource(source);
 332     }
 333 
 334     /**
 335      * Base visitor class for all visitors implementing dataflow analysis logic.
 336      * This class define the shared logic for handling jumps (break/continue statements).
 337      */
 338     static abstract class BaseAnalyzer extends TreeScanner {
 339 
 340         enum JumpKind {
 341             BREAK(JCTree.Tag.BREAK) {
 342                 @Override
 343                 JCTree getTarget(JCTree tree) {
 344                     return ((JCBreak)tree).target;
 345                 }
 346             },
 347             CONTINUE(JCTree.Tag.CONTINUE) {
 348                 @Override
 349                 JCTree getTarget(JCTree tree) {
 350                     return ((JCContinue)tree).target;
 351                 }
 352             },
 353             YIELD(JCTree.Tag.YIELD) {
 354                 @Override
 355                 JCTree getTarget(JCTree tree) {
 356                     return ((JCYield)tree).target;
 357                 }
 358             };
 359 
 360             final JCTree.Tag treeTag;
 361 
 362             private JumpKind(Tag treeTag) {
 363                 this.treeTag = treeTag;
 364             }
 365 
 366             abstract JCTree getTarget(JCTree tree);
 367         }
 368 
 369         /** The currently pending exits that go from current inner blocks
 370          *  to an enclosing block, in source order.
 371          */
 372         ListBuffer&lt;PendingExit&gt; pendingExits;
 373 
 374         /** A pending exit.  These are the statements return, break, and
 375          *  continue.  In addition, exception-throwing expressions or
 376          *  statements are put here when not known to be caught.  This
 377          *  will typically result in an error unless it is within a
 378          *  try-finally whose finally block cannot complete normally.
 379          */
 380         static class PendingExit {
 381             JCTree tree;
 382 
 383             PendingExit(JCTree tree) {
 384                 this.tree = tree;
 385             }
 386 
 387             void resolveJump() {
 388                 //do nothing
 389             }
 390         }
 391 
 392         abstract void markDead();
 393 
 394         /** Record an outward transfer of control. */
 395         void recordExit(PendingExit pe) {
 396             pendingExits.append(pe);
 397             markDead();
 398         }
 399 
 400         /** Resolve all jumps of this statement. */
 401         private Liveness resolveJump(JCTree tree,
 402                          ListBuffer&lt;PendingExit&gt; oldPendingExits,
 403                          JumpKind jk) {
 404             boolean resolved = false;
 405             List&lt;PendingExit&gt; exits = pendingExits.toList();
 406             pendingExits = oldPendingExits;
 407             for (; exits.nonEmpty(); exits = exits.tail) {
 408                 PendingExit exit = exits.head;
 409                 if (exit.tree.hasTag(jk.treeTag) &amp;&amp;
 410                         jk.getTarget(exit.tree) == tree) {
 411                     exit.resolveJump();
 412                     resolved = true;
 413                 } else {
 414                     pendingExits.append(exit);
 415                 }
 416             }
 417             return Liveness.from(resolved);
 418         }
 419 
 420         /** Resolve all continues of this statement. */
 421         Liveness resolveContinues(JCTree tree) {
 422             return resolveJump(tree, new ListBuffer&lt;PendingExit&gt;(), JumpKind.CONTINUE);
 423         }
 424 
 425         /** Resolve all breaks of this statement. */
 426         Liveness resolveBreaks(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 427             return resolveJump(tree, oldPendingExits, JumpKind.BREAK);
 428         }
 429 
 430         /** Resolve all yields of this statement. */
 431         Liveness resolveYields(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 432             return resolveJump(tree, oldPendingExits, JumpKind.YIELD);
 433         }
 434 
 435         @Override
 436         public void scan(JCTree tree) {
 437             if (tree != null &amp;&amp; (
 438                     tree.type == null ||
 439                     tree.type != Type.stuckType)) {
 440                 super.scan(tree);
 441             }
 442         }
 443 
 444         public void visitPackageDef(JCPackageDecl tree) {
 445             // Do nothing for PackageDecl
 446         }
 447 
 448         protected void scanSyntheticBreak(TreeMaker make, JCTree swtch) {
 449             if (swtch.hasTag(SWITCH_EXPRESSION)) {
 450                 JCYield brk = make.at(Position.NOPOS).Yield(null);
 451                 brk.target = swtch;
 452                 scan(brk);
 453             } else {
 454                 JCBreak brk = make.at(Position.NOPOS).Break(null);
 455                 brk.target = swtch;
 456                 scan(brk);
 457             }
 458         }
 459     }
 460 
 461     /**
 462      * This pass implements the first step of the dataflow analysis, namely
 463      * the liveness analysis check. This checks that every statement is reachable.
 464      * The output of this analysis pass are used by other analyzers. This analyzer
 465      * sets the &#39;finallyCanCompleteNormally&#39; field in the JCTry class.
 466      */
 467     class AliveAnalyzer extends BaseAnalyzer {
 468 
 469         /** A flag that indicates whether the last statement could
 470          *  complete normally.
 471          */
 472         private Liveness alive;
 473 
 474         @Override
 475         void markDead() {
 476             alive = Liveness.DEAD;
 477         }
 478 
 479     /*************************************************************************
 480      * Visitor methods for statements and definitions
 481      *************************************************************************/
 482 
 483         /** Analyze a definition.
 484          */
 485         void scanDef(JCTree tree) {
 486             scanStat(tree);
 487             if (tree != null &amp;&amp; tree.hasTag(JCTree.Tag.BLOCK) &amp;&amp; alive == Liveness.DEAD) {
 488                 log.error(tree.pos(),
 489                           Errors.InitializerMustBeAbleToCompleteNormally);
 490             }
 491         }
 492 
 493         /** Analyze a statement. Check that statement is reachable.
 494          */
 495         void scanStat(JCTree tree) {
 496             if (alive == Liveness.DEAD &amp;&amp; tree != null) {
 497                 log.error(tree.pos(), Errors.UnreachableStmt);
 498                 if (!tree.hasTag(SKIP)) alive = Liveness.RECOVERY;
 499             }
 500             scan(tree);
 501         }
 502 
 503         /** Analyze list of statements.
 504          */
 505         void scanStats(List&lt;? extends JCStatement&gt; trees) {
 506             if (trees != null)
 507                 for (List&lt;? extends JCStatement&gt; l = trees; l.nonEmpty(); l = l.tail)
 508                     scanStat(l.head);
 509         }
 510 
 511         /* ------------ Visitor methods for various sorts of trees -------------*/
 512 
 513         public void visitClassDef(JCClassDecl tree) {
 514             if (tree.sym == null) return;
 515             Liveness alivePrev = alive;
 516             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 517             Lint lintPrev = lint;
 518 
 519             pendingExits = new ListBuffer&lt;&gt;();
 520             lint = lint.augment(tree.sym);
 521 
 522             try {
 523                 // process all the static initializers
 524                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 525                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 526                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
 527                         scanDef(l.head);
 528                         clearPendingExits(false);
 529                     }
 530                 }
 531 
 532                 // process all the instance initializers
 533                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 534                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 535                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
 536                         scanDef(l.head);
 537                         clearPendingExits(false);
 538                     }
 539                 }
 540 
 541                 // process all the methods
 542                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 543                     if (l.head.hasTag(METHODDEF)) {
 544                         scan(l.head);
 545                     }
 546                 }
 547             } finally {
 548                 pendingExits = pendingExitsPrev;
 549                 alive = alivePrev;
 550                 lint = lintPrev;
 551             }
 552         }
 553 
 554         public void visitMethodDef(JCMethodDecl tree) {
 555             if (tree.body == null) return;
 556             Lint lintPrev = lint;
 557 
 558             lint = lint.augment(tree.sym);
 559 
 560             Assert.check(pendingExits.isEmpty());
 561 
 562             try {
 563                 alive = Liveness.ALIVE;
 564                 scanStat(tree.body);
 565                 tree.completesNormally = alive != Liveness.DEAD;
 566 
 567                 if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
 568                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 569 
 570                 clearPendingExits(true);
 571             } finally {
 572                 lint = lintPrev;
 573             }
 574         }
 575 
 576         private void clearPendingExits(boolean inMethod) {
 577             List&lt;PendingExit&gt; exits = pendingExits.toList();
 578             pendingExits = new ListBuffer&lt;&gt;();
 579             while (exits.nonEmpty()) {
 580                 PendingExit exit = exits.head;
 581                 exits = exits.tail;
 582                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
 583                                 log.hasErrorOn(exit.tree.pos()));
 584             }
 585         }
 586 
 587         public void visitVarDef(JCVariableDecl tree) {
 588             if (tree.init != null) {
 589                 Lint lintPrev = lint;
 590                 lint = lint.augment(tree.sym);
 591                 try{
 592                     scan(tree.init);
 593                 } finally {
 594                     lint = lintPrev;
 595                 }
 596             }
 597         }
 598 
 599         public void visitBlock(JCBlock tree) {
 600             scanStats(tree.stats);
 601         }
 602 
 603         public void visitDoLoop(JCDoWhileLoop tree) {
 604             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 605             pendingExits = new ListBuffer&lt;&gt;();
 606             scanStat(tree.body);
 607             alive = alive.or(resolveContinues(tree));
 608             scan(tree.cond);
 609             alive = alive.and(!tree.cond.type.isTrue());
 610             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 611         }
 612 
 613         public void visitWhileLoop(JCWhileLoop tree) {
 614             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 615             pendingExits = new ListBuffer&lt;&gt;();
 616             scan(tree.cond);
 617             alive = Liveness.from(!tree.cond.type.isFalse());
 618             scanStat(tree.body);
 619             alive = alive.or(resolveContinues(tree));
 620             alive = resolveBreaks(tree, prevPendingExits).or(
 621                 !tree.cond.type.isTrue());
 622         }
 623 
 624         public void visitForLoop(JCForLoop tree) {
 625             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 626             scanStats(tree.init);
 627             pendingExits = new ListBuffer&lt;&gt;();
 628             if (tree.cond != null) {
 629                 scan(tree.cond);
 630                 alive = Liveness.from(!tree.cond.type.isFalse());
 631             } else {
 632                 alive = Liveness.ALIVE;
 633             }
 634             scanStat(tree.body);
 635             alive = alive.or(resolveContinues(tree));
 636             scan(tree.step);
 637             alive = resolveBreaks(tree, prevPendingExits).or(
 638                 tree.cond != null &amp;&amp; !tree.cond.type.isTrue());
 639         }
 640 
 641         public void visitForeachLoop(JCEnhancedForLoop tree) {
 642             visitVarDef(tree.var);
 643             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 644             scan(tree.expr);
 645             pendingExits = new ListBuffer&lt;&gt;();
 646             scanStat(tree.body);
 647             alive = alive.or(resolveContinues(tree));
 648             resolveBreaks(tree, prevPendingExits);
 649             alive = Liveness.ALIVE;
 650         }
 651 
 652         public void visitLabelled(JCLabeledStatement tree) {
 653             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 654             pendingExits = new ListBuffer&lt;&gt;();
 655             scanStat(tree.body);
 656             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 657         }
 658 
 659         public void visitSwitch(JCSwitch tree) {
 660             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 661             pendingExits = new ListBuffer&lt;&gt;();
 662             scan(tree.selector);
 663             boolean hasDefault = false;
 664             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 665                 alive = Liveness.ALIVE;
 666                 JCCase c = l.head;
 667                 if (c.pats.isEmpty())
 668                     hasDefault = true;
 669                 else {
 670                     for (JCExpression pat : c.pats) {
 671                         scan(pat);
 672                     }
 673                 }
 674                 scanStats(c.stats);
 675                 c.completesNormally = alive != Liveness.DEAD;
 676                 if (alive != Liveness.DEAD &amp;&amp; c.caseKind == JCCase.RULE) {
 677                     scanSyntheticBreak(make, tree);
 678                     alive = Liveness.DEAD;
 679                 }
 680                 // Warn about fall-through if lint switch fallthrough enabled.
 681                 if (alive == Liveness.ALIVE &amp;&amp;
 682                     lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &amp;&amp;
 683                     c.stats.nonEmpty() &amp;&amp; l.tail.nonEmpty())
 684                     log.warning(Lint.LintCategory.FALLTHROUGH,
 685                                 l.tail.head.pos(),
 686                                 Warnings.PossibleFallThroughIntoCase);
 687             }
 688             if (!hasDefault) {
 689                 alive = Liveness.ALIVE;
 690             }
 691             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 692         }
 693 
 694         @Override
 695         public void visitSwitchExpression(JCSwitchExpression tree) {
 696             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 697             pendingExits = new ListBuffer&lt;&gt;();
 698             scan(tree.selector);
 699             Set&lt;Object&gt; constants = null;
 700             TypeSymbol selectorSym = tree.selector.type.tsym;
 701             if ((selectorSym.flags() &amp; ENUM) != 0) {
 702                 constants = new HashSet&lt;&gt;();
 703                 Filter&lt;Symbol&gt; enumConstantFilter =
 704                         s -&gt; (s.flags() &amp; ENUM) != 0 &amp;&amp; s.kind == Kind.VAR;
 705                 for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {
 706                     constants.add(s.name);
 707                 }
 708             }
 709             boolean hasDefault = false;
 710             Liveness prevAlive = alive;
 711             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 712                 alive = Liveness.ALIVE;
 713                 JCCase c = l.head;
 714                 if (c.pats.isEmpty())
 715                     hasDefault = true;
 716                 else {
 717                     for (JCExpression pat : c.pats) {
 718                         scan(pat);
 719                         if (constants != null) {
 720                             if (pat.hasTag(IDENT))
 721                                 constants.remove(((JCIdent) pat).name);
 722                             if (pat.type != null)
 723                                 constants.remove(pat.type.constValue());
 724                         }
 725                     }
 726                 }
 727                 scanStats(c.stats);
 728                 if (alive == Liveness.ALIVE) {
 729                     if (c.caseKind == JCCase.RULE) {
 730                         log.error(TreeInfo.diagEndPos(c.body),
 731                                   Errors.RuleCompletesNormally);
 732                     } else if (l.tail.isEmpty()) {
 733                         log.error(TreeInfo.diagEndPos(tree),
 734                                   Errors.SwitchExpressionCompletesNormally);
 735                     }
 736                 }
 737                 c.completesNormally = alive != Liveness.DEAD;
 738             }
 739             if ((constants == null || !constants.isEmpty()) &amp;&amp; !hasDefault) {
 740                 log.error(tree, Errors.NotExhaustive);
 741             }
 742             alive = prevAlive;
 743             alive = alive.or(resolveYields(tree, prevPendingExits));
 744         }
 745 
 746         public void visitTry(JCTry tree) {
 747             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 748             pendingExits = new ListBuffer&lt;&gt;();
 749             for (JCTree resource : tree.resources) {
 750                 if (resource instanceof JCVariableDecl) {
 751                     JCVariableDecl vdecl = (JCVariableDecl) resource;
 752                     visitVarDef(vdecl);
 753                 } else if (resource instanceof JCExpression) {
 754                     scan((JCExpression) resource);
 755                 } else {
 756                     throw new AssertionError(tree);  // parser error
 757                 }
 758             }
 759 
 760             scanStat(tree.body);
 761             Liveness aliveEnd = alive;
 762 
 763             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
 764                 alive = Liveness.ALIVE;
 765                 JCVariableDecl param = l.head.param;
 766                 scan(param);
 767                 scanStat(l.head.body);
 768                 aliveEnd = aliveEnd.or(alive);
 769             }
 770             if (tree.finalizer != null) {
 771                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 772                 pendingExits = prevPendingExits;
 773                 alive = Liveness.ALIVE;
 774                 scanStat(tree.finalizer);
 775                 tree.finallyCanCompleteNormally = alive != Liveness.DEAD;
 776                 if (alive == Liveness.DEAD) {
 777                     if (lint.isEnabled(Lint.LintCategory.FINALLY)) {
 778                         log.warning(Lint.LintCategory.FINALLY,
 779                                 TreeInfo.diagEndPos(tree.finalizer),
 780                                 Warnings.FinallyCannotComplete);
 781                     }
 782                 } else {
 783                     while (exits.nonEmpty()) {
 784                         pendingExits.append(exits.next());
 785                     }
 786                     alive = aliveEnd;
 787                 }
 788             } else {
 789                 alive = aliveEnd;
 790                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 791                 pendingExits = prevPendingExits;
 792                 while (exits.nonEmpty()) pendingExits.append(exits.next());
 793             }
 794         }
 795 
 796         @Override
 797         public void visitIf(JCIf tree) {
 798             scan(tree.cond);
 799             scanStat(tree.thenpart);
 800             if (tree.elsepart != null) {
 801                 Liveness aliveAfterThen = alive;
 802                 alive = Liveness.ALIVE;
 803                 scanStat(tree.elsepart);
 804                 alive = alive.or(aliveAfterThen);
 805             } else {
 806                 alive = Liveness.ALIVE;
 807             }
 808         }
 809 
 810         public void visitBreak(JCBreak tree) {
 811             recordExit(new PendingExit(tree));
 812         }
 813 
 814         @Override
 815         public void visitYield(JCYield tree) {
 816             scan(tree.value);
 817             recordExit(new PendingExit(tree));
 818         }
 819 
 820         public void visitContinue(JCContinue tree) {
 821             recordExit(new PendingExit(tree));
 822         }
 823 
 824         public void visitReturn(JCReturn tree) {
 825             scan(tree.expr);
 826             recordExit(new PendingExit(tree));
 827         }
 828 
 829         public void visitThrow(JCThrow tree) {
 830             scan(tree.expr);
 831             markDead();
 832         }
 833 
 834         public void visitApply(JCMethodInvocation tree) {
 835             scan(tree.meth);
 836             scan(tree.args);
 837         }
 838 
 839         public void visitNewClass(JCNewClass tree) {
 840             scan(tree.encl);
 841             scan(tree.args);
 842             if (tree.def != null) {
 843                 scan(tree.def);
 844             }
 845         }
 846 
 847         @Override
 848         public void visitLambda(JCLambda tree) {
 849             if (tree.type != null &amp;&amp;
 850                     tree.type.isErroneous()) {
 851                 return;
 852             }
 853 
 854             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
 855             Liveness prevAlive = alive;
 856             try {
 857                 pendingExits = new ListBuffer&lt;&gt;();
 858                 alive = Liveness.ALIVE;
 859                 scanStat(tree.body);
 860                 tree.canCompleteNormally = alive != Liveness.DEAD;
 861             }
 862             finally {
 863                 pendingExits = prevPending;
 864                 alive = prevAlive;
 865             }
 866         }
 867 
 868         public void visitModuleDef(JCModuleDecl tree) {
 869             // Do nothing for modules
 870         }
 871 
 872     /**************************************************************************
 873      * main method
 874      *************************************************************************/
 875 
 876         /** Perform definite assignment/unassignment analysis on a tree.
 877          */
 878         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 879             analyzeTree(env, env.tree, make);
 880         }
 881         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
 882             try {
 883                 attrEnv = env;
 884                 Flow.this.make = make;
 885                 pendingExits = new ListBuffer&lt;&gt;();
 886                 alive = Liveness.ALIVE;
 887                 scan(tree);
 888             } finally {
 889                 pendingExits = null;
 890                 Flow.this.make = null;
 891             }
 892         }
 893     }
 894 
 895     /**
 896      * This pass implements the second step of the dataflow analysis, namely
 897      * the exception analysis. This is to ensure that every checked exception that is
 898      * thrown is declared or caught. The analyzer uses some info that has been set by
 899      * the liveliness analyzer.
 900      */
 901     class FlowAnalyzer extends BaseAnalyzer {
 902 
 903         /** A flag that indicates whether the last statement could
 904          *  complete normally.
 905          */
 906         HashMap&lt;Symbol, List&lt;Type&gt;&gt; preciseRethrowTypes;
 907 
 908         /** The current class being defined.
 909          */
 910         JCClassDecl classDef;
 911 
 912         /** The list of possibly thrown declarable exceptions.
 913          */
 914         List&lt;Type&gt; thrown;
 915 
 916         /** The list of exceptions that are either caught or declared to be
 917          *  thrown.
 918          */
 919         List&lt;Type&gt; caught;
 920 
 921         class ThrownPendingExit extends BaseAnalyzer.PendingExit {
 922 
 923             Type thrown;
 924 
 925             ThrownPendingExit(JCTree tree, Type thrown) {
 926                 super(tree);
 927                 this.thrown = thrown;
 928             }
 929         }
 930 
 931         @Override
 932         void markDead() {
 933             //do nothing
 934         }
 935 
 936         /*-------------------- Exceptions ----------------------*/
 937 
 938         /** Complain that pending exceptions are not caught.
 939          */
 940         void errorUncaught() {
 941             for (PendingExit exit = pendingExits.next();
 942                  exit != null;
 943                  exit = pendingExits.next()) {
 944                 if (exit instanceof ThrownPendingExit) {
 945                     ThrownPendingExit thrownExit = (ThrownPendingExit) exit;
 946                     if (classDef != null &amp;&amp;
 947                         classDef.pos == exit.tree.pos) {
 948                         log.error(exit.tree.pos(),
 949                                   Errors.UnreportedExceptionDefaultConstructor(thrownExit.thrown));
 950                     } else if (exit.tree.hasTag(VARDEF) &amp;&amp;
 951                             ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {
 952                         log.error(exit.tree.pos(),
 953                                   Errors.UnreportedExceptionImplicitClose(thrownExit.thrown,
 954                                                                           ((JCVariableDecl)exit.tree).sym.name));
 955                     } else {
 956                         log.error(exit.tree.pos(),
 957                                   Errors.UnreportedExceptionNeedToCatchOrThrow(thrownExit.thrown));
 958                     }
 959                 } else {
 960                     Assert.check(log.hasErrorOn(exit.tree.pos()));
 961                 }
 962             }
 963         }
 964 
 965         /** Record that exception is potentially thrown and check that it
 966          *  is caught.
 967          */
 968         void markThrown(JCTree tree, Type exc) {
 969             if (!chk.isUnchecked(tree.pos(), exc)) {
 970                 if (!chk.isHandled(exc, caught)) {
 971                     pendingExits.append(new ThrownPendingExit(tree, exc));
 972                 }
 973                 thrown = chk.incl(exc, thrown);
 974             }
 975         }
 976 
 977     /*************************************************************************
 978      * Visitor methods for statements and definitions
 979      *************************************************************************/
 980 
 981         /* ------------ Visitor methods for various sorts of trees -------------*/
 982 
 983         public void visitClassDef(JCClassDecl tree) {
 984             if (tree.sym == null) return;
 985 
 986             JCClassDecl classDefPrev = classDef;
 987             List&lt;Type&gt; thrownPrev = thrown;
 988             List&lt;Type&gt; caughtPrev = caught;
 989             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 990             Lint lintPrev = lint;
 991             boolean anonymousClass = tree.name == names.empty;
 992             pendingExits = new ListBuffer&lt;&gt;();
 993             if (!anonymousClass) {
 994                 caught = List.nil();
 995             }
 996             classDef = tree;
 997             thrown = List.nil();
 998             lint = lint.augment(tree.sym);
 999 
1000             try {
1001                 // process all the static initializers
1002                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1003                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
1004                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
1005                         scan(l.head);
1006                         errorUncaught();
1007                     }
1008                 }
1009 
1010                 // add intersection of all thrown clauses of initial constructors
1011                 // to set of caught exceptions, unless class is anonymous.
1012                 if (!anonymousClass) {
1013                     boolean firstConstructor = true;
1014                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1015                         if (TreeInfo.isInitialConstructor(l.head)) {
1016                             List&lt;Type&gt; mthrown =
1017                                 ((JCMethodDecl) l.head).sym.type.getThrownTypes();
1018                             if (firstConstructor) {
1019                                 caught = mthrown;
1020                                 firstConstructor = false;
1021                             } else {
1022                                 caught = chk.intersect(mthrown, caught);
1023                             }
1024                         }
1025                     }
1026                 }
1027 
1028                 // process all the instance initializers
1029                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1030                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
1031                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
1032                         scan(l.head);
1033                         errorUncaught();
1034                     }
1035                 }
1036 
1037                 // in an anonymous class, add the set of thrown exceptions to
1038                 // the throws clause of the synthetic constructor and propagate
1039                 // outwards.
1040                 // Changing the throws clause on the fly is okay here because
1041                 // the anonymous constructor can&#39;t be invoked anywhere else,
1042                 // and its type hasn&#39;t been cached.
1043                 if (anonymousClass) {
1044                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1045                         if (TreeInfo.isConstructor(l.head)) {
1046                             JCMethodDecl mdef = (JCMethodDecl)l.head;
1047                             scan(mdef);
1048                             mdef.thrown = make.Types(thrown);
1049                             mdef.sym.type = types.createMethodTypeWithThrown(mdef.sym.type, thrown);
1050                         }
1051                     }
1052                     thrownPrev = chk.union(thrown, thrownPrev);
1053                 }
1054 
1055                 // process all the methods
1056                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1057                     if (anonymousClass &amp;&amp; TreeInfo.isConstructor(l.head))
1058                         continue; // there can never be an uncaught exception.
1059                     if (l.head.hasTag(METHODDEF)) {
1060                         scan(l.head);
1061                         errorUncaught();
1062                     }
1063                 }
1064 
1065                 thrown = thrownPrev;
1066             } finally {
1067                 pendingExits = pendingExitsPrev;
1068                 caught = caughtPrev;
1069                 classDef = classDefPrev;
1070                 lint = lintPrev;
1071             }
1072         }
1073 
1074         public void visitMethodDef(JCMethodDecl tree) {
1075             if (tree.body == null) return;
1076 
1077             List&lt;Type&gt; caughtPrev = caught;
1078             List&lt;Type&gt; mthrown = tree.sym.type.getThrownTypes();
1079             Lint lintPrev = lint;
1080 
1081             lint = lint.augment(tree.sym);
1082 
1083             Assert.check(pendingExits.isEmpty());
1084 
1085             try {
1086                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1087                     JCVariableDecl def = l.head;
1088                     scan(def);
1089                 }
1090                 if (TreeInfo.isInitialConstructor(tree))
1091                     caught = chk.union(caught, mthrown);
1092                 else if ((tree.sym.flags() &amp; (BLOCK | STATIC)) != BLOCK)
1093                     caught = mthrown;
1094                 // else we are in an instance initializer block;
1095                 // leave caught unchanged.
1096 
1097                 scan(tree.body);
1098 
1099                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1100                 pendingExits = new ListBuffer&lt;&gt;();
1101                 while (exits.nonEmpty()) {
1102                     PendingExit exit = exits.head;
1103                     exits = exits.tail;
1104                     if (!(exit instanceof ThrownPendingExit)) {
1105                         Assert.check(exit.tree.hasTag(RETURN) ||
1106                                          log.hasErrorOn(exit.tree.pos()));
1107                     } else {
1108                         // uncaught throws will be reported later
1109                         pendingExits.append(exit);
1110                     }
1111                 }
1112             } finally {
1113                 caught = caughtPrev;
1114                 lint = lintPrev;
1115             }
1116         }
1117 
1118         public void visitVarDef(JCVariableDecl tree) {
1119             if (tree.init != null) {
1120                 Lint lintPrev = lint;
1121                 lint = lint.augment(tree.sym);
1122                 try{
1123                     scan(tree.init);
1124                 } finally {
1125                     lint = lintPrev;
1126                 }
1127             }
1128         }
1129 
1130         public void visitBlock(JCBlock tree) {
1131             scan(tree.stats);
1132         }
1133 
1134         public void visitDoLoop(JCDoWhileLoop tree) {
1135             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1136             pendingExits = new ListBuffer&lt;&gt;();
1137             scan(tree.body);
1138             resolveContinues(tree);
1139             scan(tree.cond);
1140             resolveBreaks(tree, prevPendingExits);
1141         }
1142 
1143         public void visitWhileLoop(JCWhileLoop tree) {
1144             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1145             pendingExits = new ListBuffer&lt;&gt;();
1146             scan(tree.cond);
1147             scan(tree.body);
1148             resolveContinues(tree);
1149             resolveBreaks(tree, prevPendingExits);
1150         }
1151 
1152         public void visitForLoop(JCForLoop tree) {
1153             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1154             scan(tree.init);
1155             pendingExits = new ListBuffer&lt;&gt;();
1156             if (tree.cond != null) {
1157                 scan(tree.cond);
1158             }
1159             scan(tree.body);
1160             resolveContinues(tree);
1161             scan(tree.step);
1162             resolveBreaks(tree, prevPendingExits);
1163         }
1164 
1165         public void visitForeachLoop(JCEnhancedForLoop tree) {
1166             visitVarDef(tree.var);
1167             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1168             scan(tree.expr);
1169             pendingExits = new ListBuffer&lt;&gt;();
1170             scan(tree.body);
1171             resolveContinues(tree);
1172             resolveBreaks(tree, prevPendingExits);
1173         }
1174 
1175         public void visitLabelled(JCLabeledStatement tree) {
1176             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1177             pendingExits = new ListBuffer&lt;&gt;();
1178             scan(tree.body);
1179             resolveBreaks(tree, prevPendingExits);
1180         }
1181 
1182         public void visitSwitch(JCSwitch tree) {
1183             handleSwitch(tree, tree.selector, tree.cases);
1184         }
1185 
1186         @Override
1187         public void visitSwitchExpression(JCSwitchExpression tree) {
1188             handleSwitch(tree, tree.selector, tree.cases);
1189         }
1190 
1191         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
1192             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1193             pendingExits = new ListBuffer&lt;&gt;();
1194             scan(selector);
1195             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1196                 JCCase c = l.head;
1197                 scan(c.pats);
1198                 scan(c.stats);
1199             }
1200             if (tree.hasTag(SWITCH_EXPRESSION)) {
1201                 resolveYields(tree, prevPendingExits);
1202             } else {
1203                 resolveBreaks(tree, prevPendingExits);
1204             }
1205         }
1206 
1207         public void visitTry(JCTry tree) {
1208             List&lt;Type&gt; caughtPrev = caught;
1209             List&lt;Type&gt; thrownPrev = thrown;
1210             thrown = List.nil();
1211             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1212                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1213                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1214                         List.of(l.head.param.vartype);
1215                 for (JCExpression ct : subClauses) {
1216                     caught = chk.incl(ct.type, caught);
1217                 }
1218             }
1219 
1220             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1221             pendingExits = new ListBuffer&lt;&gt;();
1222             for (JCTree resource : tree.resources) {
1223                 if (resource instanceof JCVariableDecl) {
1224                     JCVariableDecl vdecl = (JCVariableDecl) resource;
1225                     visitVarDef(vdecl);
1226                 } else if (resource instanceof JCExpression) {
1227                     scan((JCExpression) resource);
1228                 } else {
1229                     throw new AssertionError(tree);  // parser error
1230                 }
1231             }
1232             for (JCTree resource : tree.resources) {
1233                 List&lt;Type&gt; closeableSupertypes = resource.type.isCompound() ?
1234                     types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
1235                     List.of(resource.type);
1236                 for (Type sup : closeableSupertypes) {
1237                     if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {
1238                         Symbol closeMethod = rs.resolveQualifiedMethod(tree,
1239                                 attrEnv,
1240                                 types.skipTypeVars(sup, false),
1241                                 names.close,
1242                                 List.nil(),
1243                                 List.nil());
1244                         Type mt = types.memberType(resource.type, closeMethod);
1245                         if (closeMethod.kind == MTH) {
1246                             for (Type t : mt.getThrownTypes()) {
1247                                 markThrown(resource, t);
1248                             }
1249                         }
1250                     }
1251                 }
1252             }
1253             scan(tree.body);
1254             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1255             thrown = thrownPrev;
1256             caught = caughtPrev;
1257 
1258             List&lt;Type&gt; caughtInTry = List.nil();
1259             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1260                 JCVariableDecl param = l.head.param;
1261                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1262                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1263                         List.of(l.head.param.vartype);
1264                 List&lt;Type&gt; ctypes = List.nil();
1265                 List&lt;Type&gt; rethrownTypes = chk.diff(thrownInTry, caughtInTry);
1266                 for (JCExpression ct : subClauses) {
1267                     Type exc = ct.type;
1268                     if (exc != syms.unknownType) {
1269                         ctypes = ctypes.append(exc);
1270                         if (types.isSameType(exc, syms.objectType))
1271                             continue;
1272                         var pos = subClauses.size() &gt; 1 ? ct.pos() : l.head.pos();
1273                         checkCaughtType(pos, exc, thrownInTry, caughtInTry);
1274                         caughtInTry = chk.incl(exc, caughtInTry);
1275                     }
1276                 }
1277                 scan(param);
1278                 preciseRethrowTypes.put(param.sym, chk.intersect(ctypes, rethrownTypes));
1279                 scan(l.head.body);
1280                 preciseRethrowTypes.remove(param.sym);
1281             }
1282             if (tree.finalizer != null) {
1283                 List&lt;Type&gt; savedThrown = thrown;
1284                 thrown = List.nil();
1285                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1286                 pendingExits = prevPendingExits;
1287                 scan(tree.finalizer);
1288                 if (!tree.finallyCanCompleteNormally) {
1289                     // discard exits and exceptions from try and finally
1290                     thrown = chk.union(thrown, thrownPrev);
1291                 } else {
1292                     thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1293                     thrown = chk.union(thrown, savedThrown);
1294                     // FIX: this doesn&#39;t preserve source order of exits in catch
1295                     // versus finally!
1296                     while (exits.nonEmpty()) {
1297                         pendingExits.append(exits.next());
1298                     }
1299                 }
1300             } else {
1301                 thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1302                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1303                 pendingExits = prevPendingExits;
1304                 while (exits.nonEmpty()) pendingExits.append(exits.next());
1305             }
1306         }
1307 
1308         @Override
1309         public void visitIf(JCIf tree) {
1310             scan(tree.cond);
1311             scan(tree.thenpart);
1312             if (tree.elsepart != null) {
1313                 scan(tree.elsepart);
1314             }
1315         }
1316 
1317         void checkCaughtType(DiagnosticPosition pos, Type exc, List&lt;Type&gt; thrownInTry, List&lt;Type&gt; caughtInTry) {
1318             if (chk.subset(exc, caughtInTry)) {
1319                 log.error(pos, Errors.ExceptAlreadyCaught(exc));
1320             } else if (!chk.isUnchecked(pos, exc) &amp;&amp;
1321                     !isExceptionOrThrowable(exc) &amp;&amp;
1322                     !chk.intersects(exc, thrownInTry)) {
1323                 log.error(pos, Errors.ExceptNeverThrownInTry(exc));
1324             } else {
1325                 List&lt;Type&gt; catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
1326                 // &#39;catchableThrownTypes&#39; cannot possibly be empty - if &#39;exc&#39; was an
1327                 // unchecked exception, the result list would not be empty, as the augmented
1328                 // thrown set includes { RuntimeException, Error }; if &#39;exc&#39; was a checked
1329                 // exception, that would have been covered in the branch above
1330                 if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &amp;&amp;
1331                         !isExceptionOrThrowable(exc)) {
1332                     Warning key = catchableThrownTypes.length() == 1 ?
1333                             Warnings.UnreachableCatch(catchableThrownTypes) :
1334                             Warnings.UnreachableCatch1(catchableThrownTypes);
1335                     log.warning(pos, key);
1336                 }
1337             }
1338         }
1339         //where
1340             private boolean isExceptionOrThrowable(Type exc) {
1341                 return exc.tsym == syms.throwableType.tsym ||
1342                     exc.tsym == syms.exceptionType.tsym;
1343             }
1344 
1345         public void visitBreak(JCBreak tree) {
1346             recordExit(new PendingExit(tree));
1347         }
1348 
1349         public void visitYield(JCYield tree) {
1350             scan(tree.value);
1351             recordExit(new PendingExit(tree));
1352         }
1353 
1354         public void visitContinue(JCContinue tree) {
1355             recordExit(new PendingExit(tree));
1356         }
1357 
1358         public void visitReturn(JCReturn tree) {
1359             scan(tree.expr);
1360             recordExit(new PendingExit(tree));
1361         }
1362 
1363         public void visitThrow(JCThrow tree) {
1364             scan(tree.expr);
1365             Symbol sym = TreeInfo.symbol(tree.expr);
1366             if (sym != null &amp;&amp;
1367                 sym.kind == VAR &amp;&amp;
1368                 (sym.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) != 0 &amp;&amp;
1369                 preciseRethrowTypes.get(sym) != null) {
1370                 for (Type t : preciseRethrowTypes.get(sym)) {
1371                     markThrown(tree, t);
1372                 }
1373             }
1374             else {
1375                 markThrown(tree, tree.expr.type);
1376             }
1377             markDead();
1378         }
1379 
1380         public void visitApply(JCMethodInvocation tree) {
1381             scan(tree.meth);
1382             scan(tree.args);
1383             for (List&lt;Type&gt; l = tree.meth.type.getThrownTypes(); l.nonEmpty(); l = l.tail)
1384                 markThrown(tree, l.head);
1385         }
1386 
1387         public void visitNewClass(JCNewClass tree) {
1388             scan(tree.encl);
1389             scan(tree.args);
1390            // scan(tree.def);
1391             for (List&lt;Type&gt; l = tree.constructorType.getThrownTypes();
1392                  l.nonEmpty();
1393                  l = l.tail) {
1394                 markThrown(tree, l.head);
1395             }
1396             List&lt;Type&gt; caughtPrev = caught;
1397             try {
1398                 // If the new class expression defines an anonymous class,
1399                 // analysis of the anonymous constructor may encounter thrown
1400                 // types which are unsubstituted type variables.
1401                 // However, since the constructor&#39;s actual thrown types have
1402                 // already been marked as thrown, it is safe to simply include
1403                 // each of the constructor&#39;s formal thrown types in the set of
1404                 // &#39;caught/declared to be thrown&#39; types, for the duration of
1405                 // the class def analysis.
1406                 if (tree.def != null)
1407                     for (List&lt;Type&gt; l = tree.constructor.type.getThrownTypes();
1408                          l.nonEmpty();
1409                          l = l.tail) {
1410                         caught = chk.incl(l.head, caught);
1411                     }
1412                 scan(tree.def);
1413             }
1414             finally {
1415                 caught = caughtPrev;
1416             }
1417         }
1418 
1419         @Override
1420         public void visitLambda(JCLambda tree) {
1421             if (tree.type != null &amp;&amp;
1422                     tree.type.isErroneous()) {
1423                 return;
1424             }
1425             List&lt;Type&gt; prevCaught = caught;
1426             List&lt;Type&gt; prevThrown = thrown;
1427             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1428             try {
1429                 pendingExits = new ListBuffer&lt;&gt;();
1430                 caught = tree.getDescriptorType(types).getThrownTypes();
1431                 thrown = List.nil();
1432                 scan(tree.body);
1433                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1434                 pendingExits = new ListBuffer&lt;&gt;();
1435                 while (exits.nonEmpty()) {
1436                     PendingExit exit = exits.head;
1437                     exits = exits.tail;
1438                     if (!(exit instanceof ThrownPendingExit)) {
1439                         Assert.check(exit.tree.hasTag(RETURN) ||
1440                                         log.hasErrorOn(exit.tree.pos()));
1441                     } else {
1442                         // uncaught throws will be reported later
1443                         pendingExits.append(exit);
1444                     }
1445                 }
1446 
1447                 errorUncaught();
1448             } finally {
1449                 pendingExits = prevPending;
1450                 caught = prevCaught;
1451                 thrown = prevThrown;
1452             }
1453         }
1454 
1455         public void visitModuleDef(JCModuleDecl tree) {
1456             // Do nothing for modules
1457         }
1458 
1459     /**************************************************************************
1460      * main method
1461      *************************************************************************/
1462 
1463         /** Perform definite assignment/unassignment analysis on a tree.
1464          */
1465         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
1466             analyzeTree(env, env.tree, make);
1467         }
1468         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
1469             try {
1470                 attrEnv = env;
1471                 Flow.this.make = make;
1472                 pendingExits = new ListBuffer&lt;&gt;();
1473                 preciseRethrowTypes = new HashMap&lt;&gt;();
1474                 this.thrown = this.caught = null;
1475                 this.classDef = null;
1476                 scan(tree);
1477             } finally {
1478                 pendingExits = null;
1479                 Flow.this.make = null;
1480                 this.thrown = this.caught = null;
1481                 this.classDef = null;
1482             }
1483         }
1484     }
1485 
1486     /**
1487      * Specialized pass that performs reachability analysis on a lambda
1488      */
1489     class LambdaAliveAnalyzer extends AliveAnalyzer {
1490 
1491         boolean inLambda;
1492 
1493         @Override
1494         public void visitReturn(JCReturn tree) {
1495             //ignore lambda return expression (which might not even be attributed)
1496             recordExit(new PendingExit(tree));
1497         }
1498 
1499         @Override
1500         public void visitLambda(JCLambda tree) {
1501             if (inLambda || tree.getBodyKind() == BodyKind.EXPRESSION) {
1502                 return;
1503             }
1504             inLambda = true;
1505             try {
1506                 super.visitLambda(tree);
1507             } finally {
1508                 inLambda = false;
1509             }
1510         }
1511 
1512         @Override
1513         public void visitClassDef(JCClassDecl tree) {
1514             //skip
1515         }
1516     }
1517 
1518     /**
1519      * Determine if alive after the given tree.
1520      */
1521     class SnippetAliveAnalyzer extends AliveAnalyzer {
1522         @Override
1523         public void visitClassDef(JCClassDecl tree) {
1524             //skip
1525         }
1526         public boolean isAlive() {
1527             return super.alive != Liveness.DEAD;
1528         }
1529     }
1530 
1531     class SnippetBreakAnalyzer extends AliveAnalyzer {
1532         private final Set&lt;JCTree&gt; seenTrees = new HashSet&lt;&gt;();
1533         private boolean breaksOut;
1534 
1535         public SnippetBreakAnalyzer() {
1536         }
1537 
1538         @Override
1539         public void visitLabelled(JCTree.JCLabeledStatement tree) {
1540             seenTrees.add(tree);
1541             super.visitLabelled(tree);
1542         }
1543 
1544         @Override
1545         public void visitWhileLoop(JCTree.JCWhileLoop tree) {
1546             seenTrees.add(tree);
1547             super.visitWhileLoop(tree);
1548         }
1549 
1550         @Override
1551         public void visitForLoop(JCTree.JCForLoop tree) {
1552             seenTrees.add(tree);
1553             super.visitForLoop(tree);
1554         }
1555 
1556         @Override
1557         public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {
1558             seenTrees.add(tree);
1559             super.visitForeachLoop(tree);
1560         }
1561 
1562         @Override
1563         public void visitDoLoop(JCTree.JCDoWhileLoop tree) {
1564             seenTrees.add(tree);
1565             super.visitDoLoop(tree);
1566         }
1567 
1568         @Override
1569         public void visitBreak(JCBreak tree) {
1570             breaksOut |= (super.alive == Liveness.ALIVE &amp;&amp;
1571                           !seenTrees.contains(tree.target));
1572             super.visitBreak(tree);
1573         }
1574 
1575         public boolean breaksOut() {
1576             return breaksOut;
1577         }
1578     }
1579 
1580     /**
1581      * Specialized pass that performs DA/DU on a lambda
1582      */
1583     class LambdaAssignAnalyzer extends AssignAnalyzer {
1584         WriteableScope enclosedSymbols;
1585         boolean inLambda;
1586 
1587         LambdaAssignAnalyzer(Env&lt;AttrContext&gt; env) {
1588             enclosedSymbols = WriteableScope.create(env.enclClass.sym);
1589         }
1590 
1591         @Override
1592         public void visitLambda(JCLambda tree) {
1593             if (inLambda) {
1594                 return;
1595             }
1596             inLambda = true;
1597             try {
1598                 super.visitLambda(tree);
1599             } finally {
1600                 inLambda = false;
1601             }
1602         }
1603 
1604         @Override
1605         public void visitVarDef(JCVariableDecl tree) {
1606             enclosedSymbols.enter(tree.sym);
1607             super.visitVarDef(tree);
1608         }
1609         @Override
1610         protected boolean trackable(VarSymbol sym) {
1611             return enclosedSymbols.includes(sym) &amp;&amp;
1612                    sym.owner.kind == MTH;
1613         }
1614 
1615         @Override
1616         public void visitClassDef(JCClassDecl tree) {
1617             //skip
1618         }
1619     }
1620 
1621     /**
1622      * Specialized pass that performs inference of thrown types for lambdas.
1623      */
1624     class LambdaFlowAnalyzer extends FlowAnalyzer {
1625         List&lt;Type&gt; inferredThrownTypes;
1626         boolean inLambda;
1627         @Override
1628         public void visitLambda(JCLambda tree) {
1629             if ((tree.type != null &amp;&amp;
1630                     tree.type.isErroneous()) || inLambda) {
1631                 return;
1632             }
1633             List&lt;Type&gt; prevCaught = caught;
1634             List&lt;Type&gt; prevThrown = thrown;
1635             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1636             inLambda = true;
1637             try {
1638                 pendingExits = new ListBuffer&lt;&gt;();
1639                 caught = List.of(syms.throwableType);
1640                 thrown = List.nil();
1641                 scan(tree.body);
1642                 inferredThrownTypes = thrown;
1643             } finally {
1644                 pendingExits = prevPending;
1645                 caught = prevCaught;
1646                 thrown = prevThrown;
1647                 inLambda = false;
1648             }
1649         }
1650         @Override
1651         public void visitClassDef(JCClassDecl tree) {
1652             //skip
1653         }
1654     }
1655 
1656     /**
1657      * This pass implements (i) definite assignment analysis, which ensures that
1658      * each variable is assigned when used and (ii) definite unassignment analysis,
1659      * which ensures that no final variable is assigned more than once. This visitor
1660      * depends on the results of the liveliness analyzer. This pass is also used to mark
1661      * effectively-final local variables/parameters.
1662      */
1663 
1664     public class AssignAnalyzer extends BaseAnalyzer {
1665 
1666         /** The set of definitely assigned variables.
1667          */
1668         final Bits inits;
1669 
1670         /** The set of definitely unassigned variables.
1671          */
1672         final Bits uninits;
1673 
1674         /** The set of variables that are definitely unassigned everywhere
1675          *  in current try block. This variable is maintained lazily; it is
1676          *  updated only when something gets removed from uninits,
1677          *  typically by being assigned in reachable code.  To obtain the
1678          *  correct set of variables which are definitely unassigned
1679          *  anywhere in current try block, intersect uninitsTry and
1680          *  uninits.
1681          */
1682         final Bits uninitsTry;
1683 
1684         /** When analyzing a condition, inits and uninits are null.
1685          *  Instead we have:
1686          */
1687         final Bits initsWhenTrue;
1688         final Bits initsWhenFalse;
1689         final Bits uninitsWhenTrue;
1690         final Bits uninitsWhenFalse;
1691 
1692         /** A mapping from addresses to variable symbols.
1693          */
1694         protected JCVariableDecl[] vardecls;
1695 
1696         /** The current class being defined.
1697          */
1698         JCClassDecl classDef;
1699 
1700         /** The first variable sequence number in this class definition.
1701          */
1702         int firstadr;
1703 
1704         /** The next available variable sequence number.
1705          */
1706         protected int nextadr;
1707 
1708         /** The first variable sequence number in a block that can return.
1709          */
1710         protected int returnadr;
1711 
1712         /** The list of unreferenced automatic resources.
1713          */
1714         WriteableScope unrefdResources;
1715 
1716         /** Modified when processing a loop body the second time for DU analysis. */
1717         FlowKind flowKind = FlowKind.NORMAL;
1718 
1719         /** The starting position of the analyzed tree */
1720         int startPos;
1721 
1722         public class AssignPendingExit extends BaseAnalyzer.PendingExit {
1723 
1724             final Bits inits;
1725             final Bits uninits;
1726             final Bits exit_inits = new Bits(true);
1727             final Bits exit_uninits = new Bits(true);
1728 
1729             public AssignPendingExit(JCTree tree, final Bits inits, final Bits uninits) {
1730                 super(tree);
1731                 this.inits = inits;
1732                 this.uninits = uninits;
1733                 this.exit_inits.assign(inits);
1734                 this.exit_uninits.assign(uninits);
1735             }
1736 
1737             @Override
1738             public void resolveJump() {
1739                 inits.andSet(exit_inits);
1740                 uninits.andSet(exit_uninits);
1741             }
1742         }
1743 
1744         public AssignAnalyzer() {
1745             this.inits = new Bits();
1746             uninits = new Bits();
1747             uninitsTry = new Bits();
1748             initsWhenTrue = new Bits(true);
1749             initsWhenFalse = new Bits(true);
1750             uninitsWhenTrue = new Bits(true);
1751             uninitsWhenFalse = new Bits(true);
1752         }
1753 
1754         private boolean isInitialConstructor = false;
1755 
1756         @Override
1757         protected void markDead() {
1758             if (!isInitialConstructor) {
1759                 inits.inclRange(returnadr, nextadr);
1760             } else {
1761                 for (int address = returnadr; address &lt; nextadr; address++) {
1762                     if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {
1763                         inits.incl(address);
1764                     }
1765                 }
1766             }
1767             uninits.inclRange(returnadr, nextadr);
1768         }
1769 
1770         /*-------------- Processing variables ----------------------*/
1771 
1772         /** Do we need to track init/uninit state of this symbol?
1773          *  I.e. is symbol either a local or a blank final variable?
1774          */
1775         protected boolean trackable(VarSymbol sym) {
1776             return
1777                 sym.pos &gt;= startPos &amp;&amp;
1778                 ((sym.owner.kind == MTH || sym.owner.kind == VAR ||
1779                 isFinalUninitializedField(sym)));
1780         }
1781 
1782         boolean isFinalUninitializedField(VarSymbol sym) {
1783             return sym.owner.kind == TYP &amp;&amp;
1784                    ((sym.flags() &amp; (FINAL | HASINIT | PARAMETER)) == FINAL &amp;&amp;
1785                    classDef.sym.isEnclosedBy((ClassSymbol)sym.owner));
1786         }
1787 
1788         boolean isFinalUninitializedStaticField(VarSymbol sym) {
1789             return isFinalUninitializedField(sym) &amp;&amp; sym.isStatic();
1790         }
1791 
1792         /** Initialize new trackable variable by setting its address field
1793          *  to the next available sequence number and entering it under that
1794          *  index into the vars array.
1795          */
1796         void newVar(JCVariableDecl varDecl) {
1797             VarSymbol sym = varDecl.sym;
1798             vardecls = ArrayUtils.ensureCapacity(vardecls, nextadr);
1799             if ((sym.flags() &amp; FINAL) == 0) {
1800                 sym.flags_field |= EFFECTIVELY_FINAL;
1801             }
1802             sym.adr = nextadr;
1803             vardecls[nextadr] = varDecl;
1804             inits.excl(nextadr);
1805             uninits.incl(nextadr);
1806             nextadr++;
1807         }
1808 
1809         /** Record an initialization of a trackable variable.
1810          */
1811         void letInit(DiagnosticPosition pos, VarSymbol sym) {
1812             if (sym.adr &gt;= firstadr &amp;&amp; trackable(sym)) {
1813                 if ((sym.flags() &amp; EFFECTIVELY_FINAL) != 0) {
1814                     if (!uninits.isMember(sym.adr)) {
1815                         //assignment targeting an effectively final variable
1816                         //makes the variable lose its status of effectively final
1817                         //if the variable is _not_ definitively unassigned
1818                         sym.flags_field &amp;= ~EFFECTIVELY_FINAL;
1819                     } else {
1820                         uninit(sym);
1821                     }
1822                 }
1823                 else if ((sym.flags() &amp; FINAL) != 0) {
1824                     if ((sym.flags() &amp; PARAMETER) != 0) {
1825                         if ((sym.flags() &amp; UNION) != 0) { //multi-catch parameter
1826                             log.error(pos, Errors.MulticatchParameterMayNotBeAssigned(sym));
1827                         }
1828                         else {
1829                             log.error(pos,
1830                                       Errors.FinalParameterMayNotBeAssigned(sym));
1831                         }
1832                     } else if (!uninits.isMember(sym.adr)) {
1833                         log.error(pos, diags.errorKey(flowKind.errKey, sym));
1834                     } else {
1835                         uninit(sym);
1836                     }
1837                 }
1838                 inits.incl(sym.adr);
1839             } else if ((sym.flags() &amp; FINAL) != 0) {
1840                 log.error(pos, Errors.VarMightAlreadyBeAssigned(sym));
1841             }
1842         }
1843         //where
1844             void uninit(VarSymbol sym) {
1845                 if (!inits.isMember(sym.adr)) {
1846                     // reachable assignment
1847                     uninits.excl(sym.adr);
1848                     uninitsTry.excl(sym.adr);
1849                 } else {
1850                     //log.rawWarning(pos, &quot;unreachable assignment&quot;);//DEBUG
1851                     uninits.excl(sym.adr);
1852                 }
1853             }
1854 
1855         /** If tree is either a simple name or of the form this.name or
1856          *  C.this.name, and tree represents a trackable variable,
1857          *  record an initialization of the variable.
1858          */
1859         void letInit(JCTree tree) {
1860             tree = TreeInfo.skipParens(tree);
1861             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1862                 Symbol sym = TreeInfo.symbol(tree);
1863                 if (sym.kind == VAR) {
1864                     letInit(tree.pos(), (VarSymbol)sym);
1865                 }
1866             }
1867         }
1868 
1869         /** Check that trackable variable is initialized.
1870          */
1871         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1872             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1873         }
1874 
1875         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1876             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1877                 trackable(sym) &amp;&amp;
1878                 !inits.isMember(sym.adr)) {
1879                     log.error(pos, errkey);
1880                 inits.incl(sym.adr);
1881             }
1882         }
1883 
1884         /** Utility method to reset several Bits instances.
1885          */
1886         private void resetBits(Bits... bits) {
1887             for (Bits b : bits) {
1888                 b.reset();
1889             }
1890         }
1891 
1892         /** Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
1893          */
1894         void split(boolean setToNull) {
1895             initsWhenFalse.assign(inits);
1896             uninitsWhenFalse.assign(uninits);
1897             initsWhenTrue.assign(inits);
1898             uninitsWhenTrue.assign(uninits);
1899             if (setToNull) {
1900                 resetBits(inits, uninits);
1901             }
1902         }
1903 
1904         /** Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.
1905          */
1906         protected void merge() {
1907             inits.assign(initsWhenFalse.andSet(initsWhenTrue));
1908             uninits.assign(uninitsWhenFalse.andSet(uninitsWhenTrue));
1909         }
1910 
1911     /* ************************************************************************
1912      * Visitor methods for statements and definitions
1913      *************************************************************************/
1914 
1915         /** Analyze an expression. Make sure to set (un)inits rather than
1916          *  (un)initsWhenTrue(WhenFalse) on exit.
1917          */
1918         void scanExpr(JCTree tree) {
1919             if (tree != null) {
1920                 scan(tree);
1921                 if (inits.isReset()) {
1922                     merge();
1923                 }
1924             }
1925         }
1926 
1927         /** Analyze a list of expressions.
1928          */
1929         void scanExprs(List&lt;? extends JCExpression&gt; trees) {
1930             if (trees != null)
1931                 for (List&lt;? extends JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
1932                     scanExpr(l.head);
1933         }
1934 
1935         /** Analyze a condition. Make sure to set (un)initsWhenTrue(WhenFalse)
1936          *  rather than (un)inits on exit.
1937          */
1938         void scanCond(JCTree tree) {
1939             if (tree.type.isFalse()) {
1940                 if (inits.isReset()) merge();
1941                 initsWhenTrue.assign(inits);
1942                 initsWhenTrue.inclRange(firstadr, nextadr);
1943                 uninitsWhenTrue.assign(uninits);
1944                 uninitsWhenTrue.inclRange(firstadr, nextadr);
1945                 initsWhenFalse.assign(inits);
1946                 uninitsWhenFalse.assign(uninits);
1947             } else if (tree.type.isTrue()) {
1948                 if (inits.isReset()) merge();
1949                 initsWhenFalse.assign(inits);
1950                 initsWhenFalse.inclRange(firstadr, nextadr);
1951                 uninitsWhenFalse.assign(uninits);
1952                 uninitsWhenFalse.inclRange(firstadr, nextadr);
1953                 initsWhenTrue.assign(inits);
1954                 uninitsWhenTrue.assign(uninits);
1955             } else {
1956                 scan(tree);
1957                 if (!inits.isReset())
1958                     split(tree.type != syms.unknownType);
1959             }
1960             if (tree.type != syms.unknownType) {
1961                 resetBits(inits, uninits);
1962             }
1963         }
1964 
1965         /* ------------ Visitor methods for various sorts of trees -------------*/
1966 
1967         public void visitClassDef(JCClassDecl tree) {
1968             if (tree.sym == null) {
1969                 return;
1970             }
1971 
1972             Lint lintPrev = lint;
1973             lint = lint.augment(tree.sym);
1974             try {
1975                 if (tree.sym == null) {
1976                     return;
1977                 }
1978 
1979                 JCClassDecl classDefPrev = classDef;
1980                 int firstadrPrev = firstadr;
1981                 int nextadrPrev = nextadr;
1982                 ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
1983 
1984                 pendingExits = new ListBuffer&lt;&gt;();
1985                 if (tree.name != names.empty) {
1986                     firstadr = nextadr;
1987                 }
1988                 classDef = tree;
1989                 try {
1990                     // define all the static fields
1991                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1992                         if (l.head.hasTag(VARDEF)) {
1993                             JCVariableDecl def = (JCVariableDecl)l.head;
1994                             if ((def.mods.flags &amp; STATIC) != 0) {
1995                                 VarSymbol sym = def.sym;
1996                                 if (trackable(sym)) {
1997                                     newVar(def);
1998                                 }
1999                             }
2000                         }
2001                     }
2002 
2003                     // process all the static initializers
2004                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2005                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2006                             (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
2007                             scan(l.head);
2008                             clearPendingExits(false);
2009                         }
2010                     }
2011 
2012                     // define all the instance fields
2013                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2014                         if (l.head.hasTag(VARDEF)) {
2015                             JCVariableDecl def = (JCVariableDecl)l.head;
2016                             if ((def.mods.flags &amp; STATIC) == 0) {
2017                                 VarSymbol sym = def.sym;
2018                                 if (trackable(sym)) {
2019                                     newVar(def);
2020                                 }
2021                             }
2022                         }
2023                     }
2024 
2025                     // process all the instance initializers
2026                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2027                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2028                             (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
2029                             scan(l.head);
2030                             clearPendingExits(false);
2031                         }
2032                     }
2033 
2034                     // process all the methods
2035                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2036                         if (l.head.hasTag(METHODDEF)) {
2037                             scan(l.head);
2038                         }
2039                     }
2040                 } finally {
2041                     pendingExits = pendingExitsPrev;
2042                     nextadr = nextadrPrev;
2043                     firstadr = firstadrPrev;
2044                     classDef = classDefPrev;
2045                 }
2046             } finally {
2047                 lint = lintPrev;
2048             }
2049         }
2050 
2051         public void visitMethodDef(JCMethodDecl tree) {
2052             if (tree.body == null) {
2053                 return;
2054             }
2055 
2056             /*  MemberEnter can generate synthetic methods ignore them
2057              */
2058             if ((tree.sym.flags() &amp; SYNTHETIC) != 0) {
2059                 return;
2060             }
2061 
2062             Lint lintPrev = lint;
2063             lint = lint.augment(tree.sym);
2064             try {
2065                 if (tree.body == null) {
2066                     return;
2067                 }
2068                 /*  Ignore synthetic methods, except for translated lambda methods.
2069                  */
2070                 if ((tree.sym.flags() &amp; (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {
2071                     return;
2072                 }
2073 
2074                 final Bits initsPrev = new Bits(inits);
2075                 final Bits uninitsPrev = new Bits(uninits);
2076                 int nextadrPrev = nextadr;
2077                 int firstadrPrev = firstadr;
2078                 int returnadrPrev = returnadr;
2079 
2080                 Assert.check(pendingExits.isEmpty());
2081                 boolean lastInitialConstructor = isInitialConstructor;
2082                 try {
2083                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2084 
2085                     if (!isInitialConstructor) {
2086                         firstadr = nextadr;
2087                     }
2088                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2089                         JCVariableDecl def = l.head;
2090                         scan(def);
2091                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2092                         /*  If we are executing the code from Gen, then there can be
2093                          *  synthetic or mandated variables, ignore them.
2094                          */
2095                         initParam(def);
2096                     }
2097                     // else we are in an instance initializer block;
2098                     // leave caught unchanged.
2099                     scan(tree.body);
2100 
2101                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;
2102                     if (isInitialConstructor) {
2103                         boolean isSynthesized = (tree.sym.flags() &amp;
2104                                                  GENERATEDCONSTR) != 0;
2105                         for (int i = firstadr; i &lt; nextadr; i++) {
2106                             JCVariableDecl vardecl = vardecls[i];
2107                             VarSymbol var = vardecl.sym;
2108                             if (var.owner == classDef.sym) {
2109                                 // choose the diagnostic position based on whether
2110                                 // the ctor is default(synthesized) or not
2111                                 if (isSynthesized &amp;&amp; !isCompactConstructor) {
2112                                     checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),
2113                                             var, Errors.VarNotInitializedInDefaultConstructor(var));
2114                                 } else if (isCompactConstructor) {
2115                                     boolean isInstanceRecordField = var.enclClass().isRecord() &amp;&amp;
2116                                             (var.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
2117                                             !var.isStatic() &amp;&amp;
2118                                             var.owner.kind == TYP;
2119                                     if (isInstanceRecordField) {
2120                                         boolean notInitialized = !inits.isMember(var.adr);
2121                                         if (notInitialized &amp;&amp; uninits.isMember(var.adr) &amp;&amp; tree.completesNormally) {
2122                                         /*  this way we indicate Lower that it should generate an initialization for this field
2123                                          *  in the compact constructor
2124                                          */
2125                                             var.flags_field |= UNINITIALIZED_FIELD;
2126                                         } else {
2127                                             checkInit(TreeInfo.diagEndPos(tree.body), var);
2128                                         }
2129                                     } else {
2130                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2131                                     }
2132                                 } else {
2133                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2134                                 }
2135                             }
2136                         }
2137                     }
2138                     clearPendingExits(true);
2139                 } finally {
2140                     inits.assign(initsPrev);
2141                     uninits.assign(uninitsPrev);
2142                     nextadr = nextadrPrev;
2143                     firstadr = firstadrPrev;
2144                     returnadr = returnadrPrev;
2145                     isInitialConstructor = lastInitialConstructor;
2146                 }
2147             } finally {
2148                 lint = lintPrev;
2149             }
2150         }
2151 
2152         private void clearPendingExits(boolean inMethod) {
2153             List&lt;PendingExit&gt; exits = pendingExits.toList();
2154             pendingExits = new ListBuffer&lt;&gt;();
2155             while (exits.nonEmpty()) {
2156                 PendingExit exit = exits.head;
2157                 exits = exits.tail;
2158                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
2159                                  log.hasErrorOn(exit.tree.pos()),
2160                              exit.tree);
2161                 if (inMethod &amp;&amp; isInitialConstructor) {
2162                     Assert.check(exit instanceof AssignPendingExit);
2163                     inits.assign(((AssignPendingExit) exit).exit_inits);
2164                     for (int i = firstadr; i &lt; nextadr; i++) {
2165                         checkInit(exit.tree.pos(), vardecls[i].sym);
2166                     }
2167                 }
2168             }
2169         }
2170         protected void initParam(JCVariableDecl def) {
2171             inits.incl(def.sym.adr);
2172             uninits.excl(def.sym.adr);
2173         }
2174 
2175         public void visitVarDef(JCVariableDecl tree) {
2176             Lint lintPrev = lint;
2177             lint = lint.augment(tree.sym);
2178             try{
2179                 boolean track = trackable(tree.sym);
2180                 if (track &amp;&amp; (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {
2181                     newVar(tree);
2182                 }
2183                 if (tree.init != null) {
2184                     scanExpr(tree.init);
2185                     if (track) {
2186                         letInit(tree.pos(), tree.sym);
2187                     }
2188                 }
2189             } finally {
2190                 lint = lintPrev;
2191             }
2192         }
2193 
2194         public void visitBlock(JCBlock tree) {
2195             int nextadrPrev = nextadr;
2196             scan(tree.stats);
2197             nextadr = nextadrPrev;
2198         }
2199 
2200         public void visitDoLoop(JCDoWhileLoop tree) {
2201             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2202             FlowKind prevFlowKind = flowKind;
2203             flowKind = FlowKind.NORMAL;
2204             final Bits initsSkip = new Bits(true);
2205             final Bits uninitsSkip = new Bits(true);
2206             pendingExits = new ListBuffer&lt;&gt;();
2207             int prevErrors = log.nerrors;
2208             do {
2209                 final Bits uninitsEntry = new Bits(uninits);
2210                 uninitsEntry.excludeFrom(nextadr);
2211                 scan(tree.body);
2212                 resolveContinues(tree);
2213                 scanCond(tree.cond);
2214                 if (!flowKind.isFinal()) {
2215                     initsSkip.assign(initsWhenFalse);
2216                     uninitsSkip.assign(uninitsWhenFalse);
2217                 }
2218                 if (log.nerrors !=  prevErrors ||
2219                     flowKind.isFinal() ||
2220                     new Bits(uninitsEntry).diffSet(uninitsWhenTrue).nextBit(firstadr)==-1)
2221                     break;
2222                 inits.assign(initsWhenTrue);
2223                 uninits.assign(uninitsEntry.andSet(uninitsWhenTrue));
2224                 flowKind = FlowKind.SPECULATIVE_LOOP;
2225             } while (true);
2226             flowKind = prevFlowKind;
2227             inits.assign(initsSkip);
2228             uninits.assign(uninitsSkip);
2229             resolveBreaks(tree, prevPendingExits);
2230         }
2231 
2232         public void visitWhileLoop(JCWhileLoop tree) {
2233             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2234             FlowKind prevFlowKind = flowKind;
2235             flowKind = FlowKind.NORMAL;
2236             final Bits initsSkip = new Bits(true);
2237             final Bits uninitsSkip = new Bits(true);
2238             pendingExits = new ListBuffer&lt;&gt;();
2239             int prevErrors = log.nerrors;
2240             final Bits uninitsEntry = new Bits(uninits);
2241             uninitsEntry.excludeFrom(nextadr);
2242             do {
2243                 scanCond(tree.cond);
2244                 if (!flowKind.isFinal()) {
2245                     initsSkip.assign(initsWhenFalse) ;
2246                     uninitsSkip.assign(uninitsWhenFalse);
2247                 }
2248                 inits.assign(initsWhenTrue);
2249                 uninits.assign(uninitsWhenTrue);
2250                 scan(tree.body);
2251                 resolveContinues(tree);
2252                 if (log.nerrors != prevErrors ||
2253                     flowKind.isFinal() ||
2254                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1) {
2255                     break;
2256                 }
2257                 uninits.assign(uninitsEntry.andSet(uninits));
2258                 flowKind = FlowKind.SPECULATIVE_LOOP;
2259             } while (true);
2260             flowKind = prevFlowKind;
2261             //a variable is DA/DU after the while statement, if it&#39;s DA/DU assuming the
2262             //branch is not taken AND if it&#39;s DA/DU before any break statement
2263             inits.assign(initsSkip);
2264             uninits.assign(uninitsSkip);
2265             resolveBreaks(tree, prevPendingExits);
2266         }
2267 
2268         public void visitForLoop(JCForLoop tree) {
2269             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2270             FlowKind prevFlowKind = flowKind;
2271             flowKind = FlowKind.NORMAL;
2272             int nextadrPrev = nextadr;
2273             scan(tree.init);
2274             final Bits initsSkip = new Bits(true);
2275             final Bits uninitsSkip = new Bits(true);
2276             pendingExits = new ListBuffer&lt;&gt;();
2277             int prevErrors = log.nerrors;
2278             do {
2279                 final Bits uninitsEntry = new Bits(uninits);
2280                 uninitsEntry.excludeFrom(nextadr);
2281                 if (tree.cond != null) {
2282                     scanCond(tree.cond);
2283                     if (!flowKind.isFinal()) {
2284                         initsSkip.assign(initsWhenFalse);
2285                         uninitsSkip.assign(uninitsWhenFalse);
2286                     }
2287                     inits.assign(initsWhenTrue);
2288                     uninits.assign(uninitsWhenTrue);
2289                 } else if (!flowKind.isFinal()) {
2290                     initsSkip.assign(inits);
2291                     initsSkip.inclRange(firstadr, nextadr);
2292                     uninitsSkip.assign(uninits);
2293                     uninitsSkip.inclRange(firstadr, nextadr);
2294                 }
2295                 scan(tree.body);
2296                 resolveContinues(tree);
2297                 scan(tree.step);
2298                 if (log.nerrors != prevErrors ||
2299                     flowKind.isFinal() ||
2300                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2301                     break;
2302                 uninits.assign(uninitsEntry.andSet(uninits));
2303                 flowKind = FlowKind.SPECULATIVE_LOOP;
2304             } while (true);
2305             flowKind = prevFlowKind;
2306             //a variable is DA/DU after a for loop, if it&#39;s DA/DU assuming the
2307             //branch is not taken AND if it&#39;s DA/DU before any break statement
2308             inits.assign(initsSkip);
2309             uninits.assign(uninitsSkip);
2310             resolveBreaks(tree, prevPendingExits);
2311             nextadr = nextadrPrev;
2312         }
2313 
2314         public void visitForeachLoop(JCEnhancedForLoop tree) {
2315             visitVarDef(tree.var);
2316 
2317             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2318             FlowKind prevFlowKind = flowKind;
2319             flowKind = FlowKind.NORMAL;
2320             int nextadrPrev = nextadr;
2321             scan(tree.expr);
2322             final Bits initsStart = new Bits(inits);
2323             final Bits uninitsStart = new Bits(uninits);
2324 
2325             letInit(tree.pos(), tree.var.sym);
2326             pendingExits = new ListBuffer&lt;&gt;();
2327             int prevErrors = log.nerrors;
2328             do {
2329                 final Bits uninitsEntry = new Bits(uninits);
2330                 uninitsEntry.excludeFrom(nextadr);
2331                 scan(tree.body);
2332                 resolveContinues(tree);
2333                 if (log.nerrors != prevErrors ||
2334                     flowKind.isFinal() ||
2335                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2336                     break;
2337                 uninits.assign(uninitsEntry.andSet(uninits));
2338                 flowKind = FlowKind.SPECULATIVE_LOOP;
2339             } while (true);
2340             flowKind = prevFlowKind;
2341             inits.assign(initsStart);
2342             uninits.assign(uninitsStart.andSet(uninits));
2343             resolveBreaks(tree, prevPendingExits);
2344             nextadr = nextadrPrev;
2345         }
2346 
2347         public void visitLabelled(JCLabeledStatement tree) {
2348             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2349             pendingExits = new ListBuffer&lt;&gt;();
2350             scan(tree.body);
2351             resolveBreaks(tree, prevPendingExits);
2352         }
2353 
2354         public void visitSwitch(JCSwitch tree) {
2355             handleSwitch(tree, tree.selector, tree.cases);
2356         }
2357 
2358         public void visitSwitchExpression(JCSwitchExpression tree) {
2359             handleSwitch(tree, tree.selector, tree.cases);
2360         }
2361 
2362         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
2363             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2364             pendingExits = new ListBuffer&lt;&gt;();
2365             int nextadrPrev = nextadr;
2366             scanExpr(selector);
2367             final Bits initsSwitch = new Bits(inits);
2368             final Bits uninitsSwitch = new Bits(uninits);
2369             boolean hasDefault = false;
2370             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
2371                 inits.assign(initsSwitch);
2372                 uninits.assign(uninits.andSet(uninitsSwitch));
2373                 JCCase c = l.head;
2374                 if (c.pats.isEmpty()) {
2375                     hasDefault = true;
2376                 } else {
2377                     for (JCExpression pat : c.pats) {
2378                         scanExpr(pat);
2379                     }
2380                 }
2381                 if (hasDefault) {
2382                     inits.assign(initsSwitch);
2383                     uninits.assign(uninits.andSet(uninitsSwitch));
2384                 }
2385                 scan(c.stats);
2386                 if (c.completesNormally &amp;&amp; c.caseKind == JCCase.RULE) {
2387                     scanSyntheticBreak(make, tree);
2388                 }
2389                 addVars(c.stats, initsSwitch, uninitsSwitch);
2390                 if (!hasDefault) {
2391                     inits.assign(initsSwitch);
2392                     uninits.assign(uninits.andSet(uninitsSwitch));
2393                 }
2394                 // Warn about fall-through if lint switch fallthrough enabled.
2395             }
2396             if (!hasDefault) {
2397                 if (tree.hasTag(SWITCH_EXPRESSION)) {
2398                     markDead();
2399                 } else {
2400                     inits.andSet(initsSwitch);
2401                 }
2402             }
2403             if (tree.hasTag(SWITCH_EXPRESSION)) {
2404                 resolveYields(tree, prevPendingExits);
2405             } else {
2406                 resolveBreaks(tree, prevPendingExits);
2407             }
2408             nextadr = nextadrPrev;
2409         }
2410         // where
2411             /** Add any variables defined in stats to inits and uninits. */
2412             private void addVars(List&lt;JCStatement&gt; stats, final Bits inits,
2413                                         final Bits uninits) {
2414                 for (;stats.nonEmpty(); stats = stats.tail) {
2415                     JCTree stat = stats.head;
2416                     if (stat.hasTag(VARDEF)) {
2417                         int adr = ((JCVariableDecl) stat).sym.adr;
2418                         inits.excl(adr);
2419                         uninits.incl(adr);
2420                     }
2421                 }
2422             }
2423 
2424         public void visitTry(JCTry tree) {
2425             ListBuffer&lt;JCVariableDecl&gt; resourceVarDecls = new ListBuffer&lt;&gt;();
2426             final Bits uninitsTryPrev = new Bits(uninitsTry);
2427             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2428             pendingExits = new ListBuffer&lt;&gt;();
2429             final Bits initsTry = new Bits(inits);
2430             uninitsTry.assign(uninits);
2431             for (JCTree resource : tree.resources) {
2432                 if (resource instanceof JCVariableDecl) {
2433                     JCVariableDecl vdecl = (JCVariableDecl) resource;
2434                     visitVarDef(vdecl);
2435                     unrefdResources.enter(vdecl.sym);
2436                     resourceVarDecls.append(vdecl);
2437                 } else if (resource instanceof JCExpression) {
2438                     scanExpr((JCExpression) resource);
2439                 } else {
2440                     throw new AssertionError(tree);  // parser error
2441                 }
2442             }
2443             scan(tree.body);
2444             uninitsTry.andSet(uninits);
2445             final Bits initsEnd = new Bits(inits);
2446             final Bits uninitsEnd = new Bits(uninits);
2447             int nextadrCatch = nextadr;
2448 
2449             if (!resourceVarDecls.isEmpty() &amp;&amp;
2450                     lint.isEnabled(Lint.LintCategory.TRY)) {
2451                 for (JCVariableDecl resVar : resourceVarDecls) {
2452                     if (unrefdResources.includes(resVar.sym)) {
2453                         log.warning(Lint.LintCategory.TRY, resVar.pos(),
2454                                     Warnings.TryResourceNotReferenced(resVar.sym));
2455                         unrefdResources.remove(resVar.sym);
2456                     }
2457                 }
2458             }
2459 
2460             /*  The analysis of each catch should be independent.
2461              *  Each one should have the same initial values of inits and
2462              *  uninits.
2463              */
2464             final Bits initsCatchPrev = new Bits(initsTry);
2465             final Bits uninitsCatchPrev = new Bits(uninitsTry);
2466 
2467             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
2468                 JCVariableDecl param = l.head.param;
2469                 inits.assign(initsCatchPrev);
2470                 uninits.assign(uninitsCatchPrev);
2471                 scan(param);
2472                 /* If this is a TWR and we are executing the code from Gen,
2473                  * then there can be synthetic variables, ignore them.
2474                  */
2475                 initParam(param);
2476                 scan(l.head.body);
2477                 initsEnd.andSet(inits);
2478                 uninitsEnd.andSet(uninits);
2479                 nextadr = nextadrCatch;
2480             }
2481             if (tree.finalizer != null) {
2482                 inits.assign(initsTry);
2483                 uninits.assign(uninitsTry);
2484                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2485                 pendingExits = prevPendingExits;
2486                 scan(tree.finalizer);
2487                 if (!tree.finallyCanCompleteNormally) {
2488                     // discard exits and exceptions from try and finally
2489                 } else {
2490                     uninits.andSet(uninitsEnd);
2491                     // FIX: this doesn&#39;t preserve source order of exits in catch
2492                     // versus finally!
2493                     while (exits.nonEmpty()) {
2494                         PendingExit exit = exits.next();
2495                         if (exit instanceof AssignPendingExit) {
2496                             ((AssignPendingExit) exit).exit_inits.orSet(inits);
2497                             ((AssignPendingExit) exit).exit_uninits.andSet(uninits);
2498                         }
2499                         pendingExits.append(exit);
2500                     }
2501                     inits.orSet(initsEnd);
2502                 }
2503             } else {
2504                 inits.assign(initsEnd);
2505                 uninits.assign(uninitsEnd);
2506                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2507                 pendingExits = prevPendingExits;
2508                 while (exits.nonEmpty()) pendingExits.append(exits.next());
2509             }
2510             uninitsTry.andSet(uninitsTryPrev).andSet(uninits);
2511         }
2512 
2513         public void visitConditional(JCConditional tree) {
2514             scanCond(tree.cond);
2515             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2516             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2517             inits.assign(initsWhenTrue);
2518             uninits.assign(uninitsWhenTrue);
2519             if (tree.truepart.type.hasTag(BOOLEAN) &amp;&amp;
2520                 tree.falsepart.type.hasTag(BOOLEAN)) {
2521                 // if b and c are boolean valued, then
2522                 // v is (un)assigned after a?b:c when true iff
2523                 //    v is (un)assigned after b when true and
2524                 //    v is (un)assigned after c when true
2525                 scanCond(tree.truepart);
2526                 final Bits initsAfterThenWhenTrue = new Bits(initsWhenTrue);
2527                 final Bits initsAfterThenWhenFalse = new Bits(initsWhenFalse);
2528                 final Bits uninitsAfterThenWhenTrue = new Bits(uninitsWhenTrue);
2529                 final Bits uninitsAfterThenWhenFalse = new Bits(uninitsWhenFalse);
2530                 inits.assign(initsBeforeElse);
2531                 uninits.assign(uninitsBeforeElse);
2532                 scanCond(tree.falsepart);
2533                 initsWhenTrue.andSet(initsAfterThenWhenTrue);
2534                 initsWhenFalse.andSet(initsAfterThenWhenFalse);
2535                 uninitsWhenTrue.andSet(uninitsAfterThenWhenTrue);
2536                 uninitsWhenFalse.andSet(uninitsAfterThenWhenFalse);
2537             } else {
2538                 scanExpr(tree.truepart);
2539                 final Bits initsAfterThen = new Bits(inits);
2540                 final Bits uninitsAfterThen = new Bits(uninits);
2541                 inits.assign(initsBeforeElse);
2542                 uninits.assign(uninitsBeforeElse);
2543                 scanExpr(tree.falsepart);
2544                 inits.andSet(initsAfterThen);
2545                 uninits.andSet(uninitsAfterThen);
2546             }
2547         }
2548 
2549         public void visitIf(JCIf tree) {
2550             scanCond(tree.cond);
2551             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2552             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2553             inits.assign(initsWhenTrue);
2554             uninits.assign(uninitsWhenTrue);
2555             scan(tree.thenpart);
2556             if (tree.elsepart != null) {
2557                 final Bits initsAfterThen = new Bits(inits);
2558                 final Bits uninitsAfterThen = new Bits(uninits);
2559                 inits.assign(initsBeforeElse);
2560                 uninits.assign(uninitsBeforeElse);
2561                 scan(tree.elsepart);
2562                 inits.andSet(initsAfterThen);
2563                 uninits.andSet(uninitsAfterThen);
2564             } else {
2565                 inits.andSet(initsBeforeElse);
2566                 uninits.andSet(uninitsBeforeElse);
2567             }
2568         }
2569 
2570         @Override
2571         public void visitBreak(JCBreak tree) {
2572             recordExit(new AssignPendingExit(tree, inits, uninits));
2573         }
2574 
2575         @Override
2576         public void visitYield(JCYield tree) {
2577             JCSwitchExpression expr = (JCSwitchExpression) tree.target;
2578             if (expr != null &amp;&amp; expr.type.hasTag(BOOLEAN)) {
2579                 scanCond(tree.value);
2580                 Bits initsAfterBreakWhenTrue = new Bits(initsWhenTrue);
2581                 Bits initsAfterBreakWhenFalse = new Bits(initsWhenFalse);
2582                 Bits uninitsAfterBreakWhenTrue = new Bits(uninitsWhenTrue);
2583                 Bits uninitsAfterBreakWhenFalse = new Bits(uninitsWhenFalse);
2584                 PendingExit exit = new PendingExit(tree) {
2585                     @Override
2586                     void resolveJump() {
2587                         if (!inits.isReset()) {
2588                             split(true);
2589                         }
2590                         initsWhenTrue.andSet(initsAfterBreakWhenTrue);
2591                         initsWhenFalse.andSet(initsAfterBreakWhenFalse);
2592                         uninitsWhenTrue.andSet(uninitsAfterBreakWhenTrue);
2593                         uninitsWhenFalse.andSet(uninitsAfterBreakWhenFalse);
2594                     }
2595                 };
2596                 merge();
2597                 recordExit(exit);
2598                 return ;
2599             } else {
2600                 scanExpr(tree.value);
2601                 recordExit(new AssignPendingExit(tree, inits, uninits));
2602             }
2603         }
2604 
2605         @Override
2606         public void visitContinue(JCContinue tree) {
2607             recordExit(new AssignPendingExit(tree, inits, uninits));
2608         }
2609 
2610         @Override
2611         public void visitReturn(JCReturn tree) {
2612             scanExpr(tree.expr);
2613             recordExit(new AssignPendingExit(tree, inits, uninits));
2614         }
2615 
2616         public void visitThrow(JCThrow tree) {
2617             scanExpr(tree.expr);
2618             markDead();
2619         }
2620 
2621         public void visitApply(JCMethodInvocation tree) {
2622             scanExpr(tree.meth);
2623             scanExprs(tree.args);
2624         }
2625 
2626         public void visitNewClass(JCNewClass tree) {
2627             scanExpr(tree.encl);
2628             scanExprs(tree.args);
2629             scan(tree.def);
2630         }
2631 
2632         @Override
2633         public void visitLambda(JCLambda tree) {
2634             final Bits prevUninits = new Bits(uninits);
2635             final Bits prevInits = new Bits(inits);
2636             int returnadrPrev = returnadr;
2637             int nextadrPrev = nextadr;
2638             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
2639             try {
2640                 returnadr = nextadr;
2641                 pendingExits = new ListBuffer&lt;&gt;();
2642                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2643                     JCVariableDecl def = l.head;
2644                     scan(def);
2645                     inits.incl(def.sym.adr);
2646                     uninits.excl(def.sym.adr);
2647                 }
2648                 if (tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2649                     scanExpr(tree.body);
2650                 } else {
2651                     scan(tree.body);
2652                 }
2653             }
2654             finally {
2655                 returnadr = returnadrPrev;
2656                 uninits.assign(prevUninits);
2657                 inits.assign(prevInits);
2658                 pendingExits = prevPending;
2659                 nextadr = nextadrPrev;
2660             }
2661         }
2662 
2663         public void visitNewArray(JCNewArray tree) {
2664             scanExprs(tree.dims);
2665             scanExprs(tree.elems);
2666         }
2667 
2668         public void visitAssert(JCAssert tree) {
2669             final Bits initsExit = new Bits(inits);
2670             final Bits uninitsExit = new Bits(uninits);
2671             scanCond(tree.cond);
2672             uninitsExit.andSet(uninitsWhenTrue);
2673             if (tree.detail != null) {
2674                 inits.assign(initsWhenFalse);
2675                 uninits.assign(uninitsWhenFalse);
2676                 scanExpr(tree.detail);
2677             }
2678             inits.assign(initsExit);
2679             uninits.assign(uninitsExit);
2680         }
2681 
2682         public void visitAssign(JCAssign tree) {
2683             if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))
2684                 scanExpr(tree.lhs);
2685             scanExpr(tree.rhs);
2686             letInit(tree.lhs);
2687         }
2688 
2689         // check fields accessed through this.&lt;field&gt; are definitely
2690         // assigned before reading their value
2691         public void visitSelect(JCFieldAccess tree) {
2692             super.visitSelect(tree);
2693             if (TreeInfo.isThisQualifier(tree.selected) &amp;&amp;
2694                 tree.sym.kind == VAR) {
2695                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2696             }
2697         }
2698 
2699         public void visitAssignop(JCAssignOp tree) {
2700             scanExpr(tree.lhs);
2701             scanExpr(tree.rhs);
2702             letInit(tree.lhs);
2703         }
2704 
2705         public void visitUnary(JCUnary tree) {
2706             switch (tree.getTag()) {
2707             case NOT:
2708                 scanCond(tree.arg);
2709                 final Bits t = new Bits(initsWhenFalse);
2710                 initsWhenFalse.assign(initsWhenTrue);
2711                 initsWhenTrue.assign(t);
2712                 t.assign(uninitsWhenFalse);
2713                 uninitsWhenFalse.assign(uninitsWhenTrue);
2714                 uninitsWhenTrue.assign(t);
2715                 break;
2716             case PREINC: case POSTINC:
2717             case PREDEC: case POSTDEC:
2718                 scanExpr(tree.arg);
2719                 letInit(tree.arg);
2720                 break;
2721             default:
2722                 scanExpr(tree.arg);
2723             }
2724         }
2725 
2726         public void visitBinary(JCBinary tree) {
2727             switch (tree.getTag()) {
2728             case AND:
2729                 scanCond(tree.lhs);
2730                 final Bits initsWhenFalseLeft = new Bits(initsWhenFalse);
2731                 final Bits uninitsWhenFalseLeft = new Bits(uninitsWhenFalse);
2732                 inits.assign(initsWhenTrue);
2733                 uninits.assign(uninitsWhenTrue);
2734                 scanCond(tree.rhs);
2735                 initsWhenFalse.andSet(initsWhenFalseLeft);
2736                 uninitsWhenFalse.andSet(uninitsWhenFalseLeft);
2737                 break;
2738             case OR:
2739                 scanCond(tree.lhs);
2740                 final Bits initsWhenTrueLeft = new Bits(initsWhenTrue);
2741                 final Bits uninitsWhenTrueLeft = new Bits(uninitsWhenTrue);
2742                 inits.assign(initsWhenFalse);
2743                 uninits.assign(uninitsWhenFalse);
2744                 scanCond(tree.rhs);
2745                 initsWhenTrue.andSet(initsWhenTrueLeft);
2746                 uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
2747                 break;
2748             default:
2749                 scanExpr(tree.lhs);
2750                 scanExpr(tree.rhs);
2751             }
2752         }
2753 
2754         public void visitIdent(JCIdent tree) {
2755             if (tree.sym.kind == VAR) {
2756                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2757                 referenced(tree.sym);
2758             }
2759         }
2760 
2761         void referenced(Symbol sym) {
2762             unrefdResources.remove(sym);
2763         }
2764 
2765         public void visitAnnotatedType(JCAnnotatedType tree) {
2766             // annotations don&#39;t get scanned
2767             tree.underlyingType.accept(this);
2768         }
2769 
2770         public void visitModuleDef(JCModuleDecl tree) {
2771             // Do nothing for modules
2772         }
2773 
2774     /**************************************************************************
2775      * main method
2776      *************************************************************************/
2777 
2778         /** Perform definite assignment/unassignment analysis on a tree.
2779          */
2780         public void analyzeTree(Env&lt;?&gt; env, TreeMaker make) {
2781             analyzeTree(env, env.tree, make);
2782          }
2783 
2784         public void analyzeTree(Env&lt;?&gt; env, JCTree tree, TreeMaker make) {
2785             try {
2786                 startPos = tree.pos().getStartPosition();
2787 
2788                 if (vardecls == null)
2789                     vardecls = new JCVariableDecl[32];
2790                 else
2791                     for (int i=0; i&lt;vardecls.length; i++)
2792                         vardecls[i] = null;
2793                 firstadr = 0;
2794                 nextadr = 0;
2795                 Flow.this.make = make;
2796                 pendingExits = new ListBuffer&lt;&gt;();
2797                 this.classDef = null;
2798                 unrefdResources = WriteableScope.create(env.enclClass.sym);
2799                 scan(tree);
2800             } finally {
2801                 // note that recursive invocations of this method fail hard
2802                 startPos = -1;
2803                 resetBits(inits, uninits, uninitsTry, initsWhenTrue,
2804                         initsWhenFalse, uninitsWhenTrue, uninitsWhenFalse);
2805                 if (vardecls != null) {
2806                     for (int i=0; i&lt;vardecls.length; i++)
2807                         vardecls[i] = null;
2808                 }
2809                 firstadr = 0;
2810                 nextadr = 0;
2811                 Flow.this.make = null;
2812                 pendingExits = null;
2813                 this.classDef = null;
2814                 unrefdResources = null;
2815             }
2816         }
2817     }
2818 
2819     /**
2820      * This pass implements the last step of the dataflow analysis, namely
2821      * the effectively-final analysis check. This checks that every local variable
2822      * reference from a lambda body/local inner class is either final or effectively final.
2823      * Additional this also checks that every variable that is used as an operand to
2824      * try-with-resources is final or effectively final.
2825      * As effectively final variables are marked as such during DA/DU, this pass must run after
2826      * AssignAnalyzer.
2827      */
2828     class CaptureAnalyzer extends BaseAnalyzer {
2829 
2830         JCTree currentTree; //local class or lambda
2831 
2832         @Override
2833         void markDead() {
2834             //do nothing
2835         }
2836 
2837         @SuppressWarnings(&quot;fallthrough&quot;)
2838         void checkEffectivelyFinal(DiagnosticPosition pos, VarSymbol sym) {
2839             if (currentTree != null &amp;&amp;
2840                     sym.owner.kind == MTH &amp;&amp;
2841                     sym.pos &lt; currentTree.getStartPosition()) {
2842                 switch (currentTree.getTag()) {
2843                     case CLASSDEF:
2844                         if (!allowEffectivelyFinalInInnerClasses) {
2845                             if ((sym.flags() &amp; FINAL) == 0) {
2846                                 reportInnerClsNeedsFinalError(pos, sym);
2847                             }
2848                             break;
2849                         }
2850                     case LAMBDA:
2851                         if ((sym.flags() &amp; (EFFECTIVELY_FINAL | FINAL)) == 0) {
2852                            reportEffectivelyFinalError(pos, sym);
2853                         }
2854                 }
2855             }
2856         }
2857 
2858         @SuppressWarnings(&quot;fallthrough&quot;)
2859         void letInit(JCTree tree) {
2860             tree = TreeInfo.skipParens(tree);
2861             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
2862                 Symbol sym = TreeInfo.symbol(tree);
2863                 if (currentTree != null &amp;&amp;
2864                         sym.kind == VAR &amp;&amp;
2865                         sym.owner.kind == MTH &amp;&amp;
2866                         ((VarSymbol)sym).pos &lt; currentTree.getStartPosition()) {
2867                     switch (currentTree.getTag()) {
2868                         case CLASSDEF:
2869                             if (!allowEffectivelyFinalInInnerClasses) {
2870                                 reportInnerClsNeedsFinalError(tree, sym);
2871                                 break;
2872                             }
2873                         case LAMBDA:
2874                             reportEffectivelyFinalError(tree, sym);
2875                     }
2876                 }
2877             }
2878         }
2879 
2880         void reportEffectivelyFinalError(DiagnosticPosition pos, Symbol sym) {
2881             String subKey = currentTree.hasTag(LAMBDA) ?
2882                   &quot;lambda&quot;  : &quot;inner.cls&quot;;
2883             log.error(pos, Errors.CantRefNonEffectivelyFinalVar(sym, diags.fragment(subKey)));
2884         }
2885 
2886         void reportInnerClsNeedsFinalError(DiagnosticPosition pos, Symbol sym) {
2887             log.error(pos,
2888                       Errors.LocalVarAccessedFromIclsNeedsFinal(sym));
2889         }
2890 
2891     /*************************************************************************
2892      * Visitor methods for statements and definitions
2893      *************************************************************************/
2894 
2895         /* ------------ Visitor methods for various sorts of trees -------------*/
2896 
2897         public void visitClassDef(JCClassDecl tree) {
2898             JCTree prevTree = currentTree;
2899             try {
2900                 currentTree = tree.sym.isLocal() ? tree : null;
2901                 super.visitClassDef(tree);
2902             } finally {
2903                 currentTree = prevTree;
2904             }
2905         }
2906 
2907         @Override
2908         public void visitLambda(JCLambda tree) {
2909             JCTree prevTree = currentTree;
2910             try {
2911                 currentTree = tree;
2912                 super.visitLambda(tree);
2913             } finally {
2914                 currentTree = prevTree;
2915             }
2916         }
2917 
2918         @Override
2919         public void visitIdent(JCIdent tree) {
2920             if (tree.sym.kind == VAR) {
2921                 checkEffectivelyFinal(tree, (VarSymbol)tree.sym);
2922             }
2923         }
2924 
2925         public void visitAssign(JCAssign tree) {
2926             JCTree lhs = TreeInfo.skipParens(tree.lhs);
2927             if (!(lhs instanceof JCIdent)) {
2928                 scan(lhs);
2929             }
2930             scan(tree.rhs);
2931             letInit(lhs);
2932         }
2933 
2934         public void visitAssignop(JCAssignOp tree) {
2935             scan(tree.lhs);
2936             scan(tree.rhs);
2937             letInit(tree.lhs);
2938         }
2939 
2940         public void visitUnary(JCUnary tree) {
2941             switch (tree.getTag()) {
2942                 case PREINC: case POSTINC:
2943                 case PREDEC: case POSTDEC:
2944                     scan(tree.arg);
2945                     letInit(tree.arg);
2946                     break;
2947                 default:
2948                     scan(tree.arg);
2949             }
2950         }
2951 
2952         public void visitTry(JCTry tree) {
2953             for (JCTree resource : tree.resources) {
2954                 if (!resource.hasTag(VARDEF)) {
2955                     Symbol var = TreeInfo.symbol(resource);
2956                     if (var != null &amp;&amp; (var.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) == 0) {
2957                         log.error(resource.pos(), Errors.TryWithResourcesExprEffectivelyFinalVar(var));
2958                     }
2959                 }
2960             }
2961             super.visitTry(tree);
2962         }
2963 
2964         @Override
2965         public void visitYield(JCYield tree) {
2966             scan(tree.value);
2967         }
2968 
2969         public void visitModuleDef(JCModuleDecl tree) {
2970             // Do nothing for modules
2971         }
2972 
2973     /**************************************************************************
2974      * main method
2975      *************************************************************************/
2976 
2977         /** Perform definite assignment/unassignment analysis on a tree.
2978          */
2979         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
2980             analyzeTree(env, env.tree, make);
2981         }
2982         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
2983             try {
2984                 attrEnv = env;
2985                 Flow.this.make = make;
2986                 pendingExits = new ListBuffer&lt;&gt;();
2987                 scan(tree);
2988             } finally {
2989                 pendingExits = null;
2990                 Flow.this.make = null;
2991             }
2992         }
2993     }
2994 
2995     enum Liveness {
2996         ALIVE {
2997             @Override
2998             public Liveness or(Liveness other) {
2999                 return this;
3000             }
3001             @Override
3002             public Liveness and(Liveness other) {
3003                 return other;
3004             }
3005         },
3006         DEAD {
3007             @Override
3008             public Liveness or(Liveness other) {
3009                 return other;
3010             }
3011             @Override
3012             public Liveness and(Liveness other) {
3013                 return this;
3014             }
3015         },
3016         RECOVERY {
3017             @Override
3018             public Liveness or(Liveness other) {
3019                 if (other == ALIVE) {
3020                     return ALIVE;
3021                 } else {
3022                     return this;
3023                 }
3024             }
3025             @Override
3026             public Liveness and(Liveness other) {
3027                 if (other == DEAD) {
3028                     return DEAD;
3029                 } else {
3030                     return this;
3031                 }
3032             }
3033         };
3034 
3035         public abstract Liveness or(Liveness other);
3036         public abstract Liveness and(Liveness other);
3037         public Liveness or(boolean value) {
3038             return or(from(value));
3039         }
3040         public Liveness and(boolean value) {
3041             return and(from(value));
3042         }
3043         public static Liveness from(boolean value) {
3044             return value ? ALIVE : DEAD;
3045         }
3046     }
3047 
3048 }
    </pre>
  </body>
</html>
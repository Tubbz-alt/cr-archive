<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../hotspot/share/runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  61         if (member.getDeclaringClass().isInterface() &amp;&amp;
  62             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
  63             member.isMethod() &amp;&amp; !member.isAbstract()) {
  64             // Check for corner case: invokeinterface of Object method
  65             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
  66             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
  67             if (m != null &amp;&amp; m.isPublic()) {
  68                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
  69                 member = m;
  70             }
  71         }
  72 
  73         this.member = member;
  74         this.crackable = crackable;
  75     }
  76 
  77     // Factory methods:
  78     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
  79         MethodType mtype = member.getMethodOrFieldType();
  80         if (!member.isStatic()) {
<span class="line-modified">  81             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isConstructor())</span>
  82                 throw new InternalError(member.toString());
  83             mtype = mtype.insertParameterTypes(0, refc);
  84         }
  85         if (!member.isField()) {
  86             // refKind reflects the original type of lookup via findSpecial or
  87             // findVirtual etc.
  88             switch (refKind) {
  89                 case REF_invokeSpecial: {
  90                     member = member.asSpecial();
  91                     // if caller is an interface we need to adapt to get the
  92                     // receiver check inserted
  93                     if (callerClass == null) {
  94                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
  95                     }
  96                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
  97                     return new Special(mtype, lform, member, true, callerClass);
  98                 }
  99                 case REF_invokeInterface: {
 100                     // for interfaces we always need the receiver typecheck,
 101                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 102                     // to include the REF_invokeSpecial case
 103                     LambdaForm lform = preparedLambdaForm(member, true);
 104                     return new Interface(mtype, lform, member, true, refc);
 105                 }
 106                 default: {
 107                     LambdaForm lform = preparedLambdaForm(member);
 108                     return new DirectMethodHandle(mtype, lform, member, true);
 109                 }
 110             }
 111         } else {
 112             LambdaForm lform = preparedFieldLambdaForm(member);
 113             if (member.isStatic()) {
 114                 long offset = MethodHandleNatives.staticFieldOffset(member);
 115                 Object base = MethodHandleNatives.staticFieldBase(member);
<span class="line-modified"> 116                 return new StaticAccessor(mtype, lform, member, true, base, offset);</span>

 117             } else {
 118                 long offset = MethodHandleNatives.objectFieldOffset(member);
 119                 assert(offset == (int)offset);
<span class="line-modified"> 120                 return new Accessor(mtype, lform, member, true, (int)offset);</span>

 121             }
 122         }
 123     }
 124     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
 125         byte refKind = member.getReferenceKind();
 126         if (refKind == REF_invokeSpecial)
 127             refKind =  REF_invokeVirtual;
 128         return make(refKind, refc, member, null /* no callerClass context */);
 129     }
 130     static DirectMethodHandle make(MemberName member) {
<span class="line-modified"> 131         if (member.isConstructor())</span>
 132             return makeAllocator(member);
 133         return make(member.getDeclaringClass(), member);
 134     }
 135     private static DirectMethodHandle makeAllocator(MemberName ctor) {
<span class="line-modified"> 136         assert(ctor.isConstructor() &amp;&amp; ctor.getName().equals(&quot;&lt;init&gt;&quot;));</span>

 137         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
<span class="line-modified"> 138         ctor = ctor.asConstructor();</span>
<span class="line-modified"> 139         assert(ctor.isConstructor() &amp;&amp; ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;</span>
 140         MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
 141         LambdaForm lform = preparedLambdaForm(ctor);
 142         MemberName init = ctor.asSpecial();
 143         assert(init.getMethodType().returnType() == void.class);
 144         return new Constructor(mtype, lform, ctor, true, init, instanceClass);
 145     }
 146 
 147     @Override
 148     BoundMethodHandle rebind() {
 149         return BoundMethodHandle.makeReinvoker(this);
 150     }
 151 
 152     @Override
 153     MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 154         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
 155         return new DirectMethodHandle(mt, lf, member, crackable);
 156     }
 157 
 158     @Override
 159     MethodHandle viewAsType(MethodType newType, boolean strict) {
</pre>
<hr />
<pre>
 502         @Override
 503         MethodHandle viewAsType(MethodType newType, boolean strict) {
 504             assert(viewAsTypeChecks(newType, strict));
 505             return new Constructor(newType, form, member, false, initMethod, instanceClass);
 506         }
 507     }
 508 
 509     /*non-public*/
 510     static Object constructorMethod(Object mh) {
 511         Constructor dmh = (Constructor)mh;
 512         return dmh.initMethod;
 513     }
 514 
 515     /*non-public*/
 516     static Object allocateInstance(Object mh) throws InstantiationException {
 517         Constructor dmh = (Constructor)mh;
 518         return UNSAFE.allocateInstance(dmh.instanceClass);
 519     }
 520 
 521     /** This subclass handles non-static field references. */
<span class="line-modified"> 522     static class Accessor extends DirectMethodHandle {</span>
 523         final Class&lt;?&gt; fieldType;
 524         final int      fieldOffset;
 525         private Accessor(MethodType mtype, LambdaForm form, MemberName member,
 526                          boolean crackable, int fieldOffset) {
 527             super(mtype, form, member, crackable);
 528             this.fieldType   = member.getFieldType();
 529             this.fieldOffset = fieldOffset;
 530         }










 531 
 532         @Override Object checkCast(Object obj) {
 533             return fieldType.cast(obj);
 534         }
 535         @Override
 536         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 537             return new Accessor(mt, lf, member, crackable, fieldOffset);</span>
 538         }
 539         @Override
 540         MethodHandle viewAsType(MethodType newType, boolean strict) {
 541             assert(viewAsTypeChecks(newType, strict));
<span class="line-modified"> 542             return new Accessor(newType, form, member, false, fieldOffset);</span>
















 543         }
 544     }
 545 
 546     @ForceInline
 547     /*non-public*/
 548     static long fieldOffset(Object accessorObj) {
 549         // Note: We return a long because that is what Unsafe.getObject likes.
 550         // We store a plain int because it is more compact.
 551         return ((Accessor)accessorObj).fieldOffset;
 552     }
 553 
 554     @ForceInline
 555     /*non-public*/
 556     static Object checkBase(Object obj) {
 557         // Note that the object&#39;s class has already been verified,
 558         // since the parameter type of the Accessor method handle
 559         // is either member.getDeclaringClass or a subclass.
 560         // This was verified in DirectMethodHandle.make.
 561         // Therefore, the only remaining check is for null.
 562         // Since this check is *not* guaranteed by Unsafe.getInt
 563         // and its siblings, we need to make an explicit one here.
 564         return Objects.requireNonNull(obj);
 565     }
 566 
<span class="line-modified"> 567     /** This subclass handles static field references. */</span>
<span class="line-modified"> 568     static class StaticAccessor extends DirectMethodHandle {</span>
<span class="line-modified"> 569         private final Class&lt;?&gt; fieldType;</span>
<span class="line-modified"> 570         private final Object   staticBase;</span>
<span class="line-removed"> 571         private final long     staticOffset;</span>
 572 
 573         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 574                                boolean crackable, Object staticBase, long staticOffset) {
 575             super(mtype, form, member, crackable);
 576             this.fieldType    = member.getFieldType();
 577             this.staticBase   = staticBase;
 578             this.staticOffset = staticOffset;
 579         }










 580 

 581         @Override Object checkCast(Object obj) {
 582             return fieldType.cast(obj);
 583         }
 584         @Override
 585         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 586             return new StaticAccessor(mt, lf, member, crackable, staticBase, staticOffset);</span>
 587         }
 588         @Override
 589         MethodHandle viewAsType(MethodType newType, boolean strict) {
 590             assert(viewAsTypeChecks(newType, strict));
<span class="line-modified"> 591             return new StaticAccessor(newType, form, member, false, staticBase, staticOffset);</span>


















 592         }
 593     }
 594 
 595     @ForceInline
 596     /*non-public*/
 597     static Object nullCheck(Object obj) {
 598         return Objects.requireNonNull(obj);
 599     }
 600 
 601     @ForceInline
 602     /*non-public*/
 603     static Object staticBase(Object accessorObj) {
 604         return ((StaticAccessor)accessorObj).staticBase;
 605     }
 606 
 607     @ForceInline
 608     /*non-public*/
 609     static long staticOffset(Object accessorObj) {
 610         return ((StaticAccessor)accessorObj).staticOffset;
 611     }
 612 
 613     @ForceInline
 614     /*non-public*/
 615     static Object checkCast(Object mh, Object obj) {
 616         return ((DirectMethodHandle) mh).checkCast(obj);
 617     }
 618 










 619     Object checkCast(Object obj) {
 620         return member.getReturnType().cast(obj);
 621     }
 622 
 623     // Caching machinery for field accessors:
 624     static final byte
 625             AF_GETFIELD        = 0,
 626             AF_PUTFIELD        = 1,
 627             AF_GETSTATIC       = 2,
 628             AF_PUTSTATIC       = 3,
 629             AF_GETSTATIC_INIT  = 4,
 630             AF_PUTSTATIC_INIT  = 5,
 631             AF_LIMIT           = 6;
 632     // Enumerate the different field kinds using Wrapper,
<span class="line-modified"> 633     // with an extra case added for checked references.</span>
 634     static final int
<span class="line-modified"> 635             FT_LAST_WRAPPER    = Wrapper.COUNT-1,</span>
<span class="line-modified"> 636             FT_UNCHECKED_REF   = Wrapper.OBJECT.ordinal(),</span>
<span class="line-modified"> 637             FT_CHECKED_REF     = FT_LAST_WRAPPER+1,</span>
<span class="line-modified"> 638             FT_LIMIT           = FT_LAST_WRAPPER+2;</span>
<span class="line-modified"> 639     private static int afIndex(byte formOp, boolean isVolatile, int ftypeKind) {</span>

 640         return ((formOp * FT_LIMIT * 2)
 641                 + (isVolatile ? FT_LIMIT : 0)

 642                 + ftypeKind);
 643     }
 644     @Stable
 645     private static final LambdaForm[] ACCESSOR_FORMS
<span class="line-modified"> 646             = new LambdaForm[afIndex(AF_LIMIT, false, 0)];</span>
<span class="line-modified"> 647     static int ftypeKind(Class&lt;?&gt; ftype) {</span>
 648         if (ftype.isPrimitive())
 649             return Wrapper.forPrimitiveType(ftype).ordinal();
<span class="line-modified"> 650         else if (VerifyType.isNullReferenceConversion(Object.class, ftype))</span>
 651             return FT_UNCHECKED_REF;
<span class="line-modified"> 652         else</span>
<span class="line-modified"> 653             return FT_CHECKED_REF;</span>

 654     }
 655 
 656     /**
 657      * Create a LF which can access the given field.
 658      * Cache and share this structure among all fields with
 659      * the same basicType and refKind.
 660      */
 661     private static LambdaForm preparedFieldLambdaForm(MemberName m) {
 662         Class&lt;?&gt; ftype = m.getFieldType();
<span class="line-removed"> 663         boolean isVolatile = m.isVolatile();</span>
 664         byte formOp;
 665         switch (m.getReferenceKind()) {
 666         case REF_getField:      formOp = AF_GETFIELD;    break;
 667         case REF_putField:      formOp = AF_PUTFIELD;    break;
 668         case REF_getStatic:     formOp = AF_GETSTATIC;   break;
 669         case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
 670         default:  throw new InternalError(m.toString());
 671         }
 672         if (shouldBeInitialized(m)) {
 673             // precompute the barrier-free version:
<span class="line-modified"> 674             preparedFieldLambdaForm(formOp, isVolatile, ftype);</span>
 675             assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
 676                    (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
 677             formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
 678         }
<span class="line-modified"> 679         LambdaForm lform = preparedFieldLambdaForm(formOp, isVolatile, ftype);</span>
 680         maybeCompile(lform, m);
 681         assert(lform.methodType().dropParameterTypes(0, 1)
 682                 .equals(m.getInvocationType().basicType()))
 683                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
 684         return lform;
 685     }
<span class="line-modified"> 686     private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, Class&lt;?&gt; ftype) {</span>
<span class="line-modified"> 687         int ftypeKind = ftypeKind(ftype);</span>
<span class="line-modified"> 688         int afIndex = afIndex(formOp, isVolatile, ftypeKind);</span>

 689         LambdaForm lform = ACCESSOR_FORMS[afIndex];
 690         if (lform != null)  return lform;
<span class="line-modified"> 691         lform = makePreparedFieldLambdaForm(formOp, isVolatile, ftypeKind);</span>
 692         ACCESSOR_FORMS[afIndex] = lform;  // don&#39;t bother with a CAS
 693         return lform;
 694     }
 695 
 696     private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();
 697 
<span class="line-modified"> 698     private static Kind getFieldKind(boolean isGetter, boolean isVolatile, Wrapper wrapper) {</span>
 699         if (isGetter) {
 700             if (isVolatile) {
 701                 switch (wrapper) {
 702                     case BOOLEAN: return GET_BOOLEAN_VOLATILE;
 703                     case BYTE:    return GET_BYTE_VOLATILE;
 704                     case SHORT:   return GET_SHORT_VOLATILE;
 705                     case CHAR:    return GET_CHAR_VOLATILE;
 706                     case INT:     return GET_INT_VOLATILE;
 707                     case LONG:    return GET_LONG_VOLATILE;
 708                     case FLOAT:   return GET_FLOAT_VOLATILE;
 709                     case DOUBLE:  return GET_DOUBLE_VOLATILE;
<span class="line-modified"> 710                     case OBJECT:  return GET_REFERENCE_VOLATILE;</span>
 711                 }
 712             } else {
 713                 switch (wrapper) {
 714                     case BOOLEAN: return GET_BOOLEAN;
 715                     case BYTE:    return GET_BYTE;
 716                     case SHORT:   return GET_SHORT;
 717                     case CHAR:    return GET_CHAR;
 718                     case INT:     return GET_INT;
 719                     case LONG:    return GET_LONG;
 720                     case FLOAT:   return GET_FLOAT;
 721                     case DOUBLE:  return GET_DOUBLE;
<span class="line-modified"> 722                     case OBJECT:  return GET_REFERENCE;</span>
 723                 }
 724             }
 725         } else {
 726             if (isVolatile) {
 727                 switch (wrapper) {
 728                     case BOOLEAN: return PUT_BOOLEAN_VOLATILE;
 729                     case BYTE:    return PUT_BYTE_VOLATILE;
 730                     case SHORT:   return PUT_SHORT_VOLATILE;
 731                     case CHAR:    return PUT_CHAR_VOLATILE;
 732                     case INT:     return PUT_INT_VOLATILE;
 733                     case LONG:    return PUT_LONG_VOLATILE;
 734                     case FLOAT:   return PUT_FLOAT_VOLATILE;
 735                     case DOUBLE:  return PUT_DOUBLE_VOLATILE;
<span class="line-modified"> 736                     case OBJECT:  return PUT_REFERENCE_VOLATILE;</span>
 737                 }
 738             } else {
 739                 switch (wrapper) {
 740                     case BOOLEAN: return PUT_BOOLEAN;
 741                     case BYTE:    return PUT_BYTE;
 742                     case SHORT:   return PUT_SHORT;
 743                     case CHAR:    return PUT_CHAR;
 744                     case INT:     return PUT_INT;
 745                     case LONG:    return PUT_LONG;
 746                     case FLOAT:   return PUT_FLOAT;
 747                     case DOUBLE:  return PUT_DOUBLE;
<span class="line-modified"> 748                     case OBJECT:  return PUT_REFERENCE;</span>
 749                 }
 750             }
 751         }
 752         throw new AssertionError(&quot;Invalid arguments&quot;);
 753     }
 754 
<span class="line-modified"> 755     static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftypeKind) {</span>





 756         boolean isGetter  = (formOp &amp; 1) == (AF_GETFIELD &amp; 1);
 757         boolean isStatic  = (formOp &gt;= AF_GETSTATIC);
 758         boolean needsInit = (formOp &gt;= AF_GETSTATIC_INIT);
<span class="line-modified"> 759         boolean needsCast = (ftypeKind == FT_CHECKED_REF);</span>
 760         Wrapper fw = (needsCast ? Wrapper.OBJECT : ALL_WRAPPERS[ftypeKind]);
 761         Class&lt;?&gt; ft = fw.primitiveType();
<span class="line-modified"> 762         assert(ftypeKind(needsCast ? String.class : ft) == ftypeKind);</span>
 763 
 764         // getObject, putIntVolatile, etc.
<span class="line-modified"> 765         Kind kind = getFieldKind(isGetter, isVolatile, fw);</span>
 766 
 767         MethodType linkerType;
<span class="line-modified"> 768         if (isGetter)</span>
<span class="line-modified"> 769             linkerType = MethodType.methodType(ft, Object.class, long.class);</span>
<span class="line-modified"> 770         else</span>
<span class="line-modified"> 771             linkerType = MethodType.methodType(void.class, Object.class, long.class, ft);</span>




 772         MemberName linker = new MemberName(Unsafe.class, kind.methodName, linkerType, REF_invokeVirtual);
 773         try {
 774             linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, NoSuchMethodException.class);
 775         } catch (ReflectiveOperationException ex) {
 776             throw newInternalError(ex);
 777         }
 778 
 779         // What is the external type of the lambda form?
 780         MethodType mtype;
 781         if (isGetter)
 782             mtype = MethodType.methodType(ft);
 783         else
 784             mtype = MethodType.methodType(void.class, ft);
 785         mtype = mtype.basicType();  // erase short to int, etc.
 786         if (!isStatic)
 787             mtype = mtype.insertParameterTypes(0, Object.class);
 788         final int DMH_THIS  = 0;
 789         final int ARG_BASE  = 1;
 790         final int ARG_LIMIT = ARG_BASE + mtype.parameterCount();
 791         // if this is for non-static access, the base pointer is stored at this index:
 792         final int OBJ_BASE  = isStatic ? -1 : ARG_BASE;
 793         // if this is for write access, the value to be written is stored at this index:
 794         final int SET_VALUE  = isGetter ? -1 : ARG_LIMIT - 1;
 795         int nameCursor = ARG_LIMIT;
 796         final int F_HOLDER  = (isStatic ? nameCursor++ : -1);  // static base if any
 797         final int F_OFFSET  = nameCursor++;  // Either static offset or field offset.
 798         final int OBJ_CHECK = (OBJ_BASE &gt;= 0 ? nameCursor++ : -1);
 799         final int U_HOLDER  = nameCursor++;  // UNSAFE holder
 800         final int INIT_BAR  = (needsInit ? nameCursor++ : -1);

 801         final int PRE_CAST  = (needsCast &amp;&amp; !isGetter ? nameCursor++ : -1);
 802         final int LINKER_CALL = nameCursor++;
 803         final int POST_CAST = (needsCast &amp;&amp; isGetter ? nameCursor++ : -1);
 804         final int RESULT    = nameCursor-1;  // either the call or the cast
 805         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
 806         if (needsInit)
 807             names[INIT_BAR] = new Name(getFunction(NF_ensureInitialized), names[DMH_THIS]);
 808         if (needsCast &amp;&amp; !isGetter)
 809             names[PRE_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[SET_VALUE]);
 810         Object[] outArgs = new Object[1 + linkerType.parameterCount()];
<span class="line-modified"> 811         assert(outArgs.length == (isGetter ? 3 : 4));</span>
 812         outArgs[0] = names[U_HOLDER] = new Name(getFunction(NF_UNSAFE));
 813         if (isStatic) {
 814             outArgs[1] = names[F_HOLDER]  = new Name(getFunction(NF_staticBase), names[DMH_THIS]);
 815             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_staticOffset), names[DMH_THIS]);
 816         } else {
 817             outArgs[1] = names[OBJ_CHECK] = new Name(getFunction(NF_checkBase), names[OBJ_BASE]);
 818             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_fieldOffset), names[DMH_THIS]);
 819         }





 820         if (!isGetter) {
<span class="line-modified"> 821             outArgs[3] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);</span>
 822         }
 823         for (Object a : outArgs)  assert(a != null);
 824         names[LINKER_CALL] = new Name(linker, outArgs);
 825         if (needsCast &amp;&amp; isGetter)
 826             names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[LINKER_CALL]);
 827         for (Name n : names)  assert(n != null);
 828 
 829         LambdaForm form;
 830         if (needsCast || needsInit) {
 831             // can&#39;t use the pre-generated form when casting and/or initializing
 832             form = new LambdaForm(ARG_LIMIT, names, RESULT);
 833         } else {
 834             form = new LambdaForm(ARG_LIMIT, names, RESULT, kind);
 835         }
 836 
 837         if (LambdaForm.debugNames()) {
 838             // add some detail to the lambdaForm debugname,
 839             // significant only for debugging
 840             StringBuilder nameBuilder = new StringBuilder(kind.methodName);
 841             if (isStatic) {
</pre>
<hr />
<pre>
 852             LambdaForm.associateWithDebugName(form, nameBuilder.toString());
 853         }
 854         return form;
 855     }
 856 
 857     /**
 858      * Pre-initialized NamedFunctions for bootstrapping purposes.
 859      */
 860     static final byte NF_internalMemberName = 0,
 861             NF_internalMemberNameEnsureInit = 1,
 862             NF_ensureInitialized = 2,
 863             NF_fieldOffset = 3,
 864             NF_checkBase = 4,
 865             NF_staticBase = 5,
 866             NF_staticOffset = 6,
 867             NF_checkCast = 7,
 868             NF_allocateInstance = 8,
 869             NF_constructorMethod = 9,
 870             NF_UNSAFE = 10,
 871             NF_checkReceiver = 11,
<span class="line-modified"> 872             NF_LIMIT = 12;</span>


 873 
 874     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
 875 
 876     private static NamedFunction getFunction(byte func) {
 877         NamedFunction nf = NFS[func];
 878         if (nf != null) {
 879             return nf;
 880         }
 881         // Each nf must be statically invocable or we get tied up in our bootstraps.
 882         nf = NFS[func] = createFunction(func);
 883         assert(InvokerBytecodeGenerator.isStaticallyInvocable(nf));
 884         return nf;
 885     }
 886 


 887     private static final MethodType OBJ_OBJ_TYPE = MethodType.methodType(Object.class, Object.class);
 888 
 889     private static final MethodType LONG_OBJ_TYPE = MethodType.methodType(long.class, Object.class);
 890 
 891     private static NamedFunction createFunction(byte func) {
 892         try {
 893             switch (func) {
 894                 case NF_internalMemberName:
 895                     return getNamedFunction(&quot;internalMemberName&quot;, OBJ_OBJ_TYPE);
 896                 case NF_internalMemberNameEnsureInit:
 897                     return getNamedFunction(&quot;internalMemberNameEnsureInit&quot;, OBJ_OBJ_TYPE);
 898                 case NF_ensureInitialized:
 899                     return getNamedFunction(&quot;ensureInitialized&quot;, MethodType.methodType(void.class, Object.class));
 900                 case NF_fieldOffset:
 901                     return getNamedFunction(&quot;fieldOffset&quot;, LONG_OBJ_TYPE);
 902                 case NF_checkBase:
 903                     return getNamedFunction(&quot;checkBase&quot;, OBJ_OBJ_TYPE);
 904                 case NF_staticBase:
 905                     return getNamedFunction(&quot;staticBase&quot;, OBJ_OBJ_TYPE);
 906                 case NF_staticOffset:
 907                     return getNamedFunction(&quot;staticOffset&quot;, LONG_OBJ_TYPE);
 908                 case NF_checkCast:
 909                     return getNamedFunction(&quot;checkCast&quot;, MethodType.methodType(Object.class, Object.class, Object.class));
 910                 case NF_allocateInstance:
 911                     return getNamedFunction(&quot;allocateInstance&quot;, OBJ_OBJ_TYPE);
 912                 case NF_constructorMethod:
 913                     return getNamedFunction(&quot;constructorMethod&quot;, OBJ_OBJ_TYPE);
 914                 case NF_UNSAFE:
 915                     MemberName member = new MemberName(MethodHandleStatics.class, &quot;UNSAFE&quot;, Unsafe.class, REF_getField);
 916                     return new NamedFunction(
 917                             MemberName.getFactory()
 918                                     .resolveOrFail(REF_getField, member, DirectMethodHandle.class, NoSuchMethodException.class));
 919                 case NF_checkReceiver:
 920                     member = new MemberName(DirectMethodHandle.class, &quot;checkReceiver&quot;, OBJ_OBJ_TYPE, REF_invokeVirtual);
 921                     return new NamedFunction(
 922                         MemberName.getFactory()
 923                             .resolveOrFail(REF_invokeVirtual, member, DirectMethodHandle.class, NoSuchMethodException.class));




 924                 default:
 925                     throw newInternalError(&quot;Unknown function: &quot; + func);
 926             }
 927         } catch (ReflectiveOperationException ex) {
 928             throw newInternalError(ex);
 929         }
 930     }
 931 
 932     private static NamedFunction getNamedFunction(String name, MethodType type)
 933         throws ReflectiveOperationException
 934     {
 935         MemberName member = new MemberName(DirectMethodHandle.class, name, type, REF_invokeStatic);
 936         return new NamedFunction(
 937             MemberName.getFactory()
 938                 .resolveOrFail(REF_invokeStatic, member, DirectMethodHandle.class, NoSuchMethodException.class));
 939     }
 940 
 941     static {
 942         // The Holder class will contain pre-generated DirectMethodHandles resolved
 943         // speculatively using MemberName.getFactory().resolveOrNull. However, that
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  61         if (member.getDeclaringClass().isInterface() &amp;&amp;
  62             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
  63             member.isMethod() &amp;&amp; !member.isAbstract()) {
  64             // Check for corner case: invokeinterface of Object method
  65             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
  66             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
  67             if (m != null &amp;&amp; m.isPublic()) {
  68                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
  69                 member = m;
  70             }
  71         }
  72 
  73         this.member = member;
  74         this.crackable = crackable;
  75     }
  76 
  77     // Factory methods:
  78     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
  79         MethodType mtype = member.getMethodOrFieldType();
  80         if (!member.isStatic()) {
<span class="line-modified">  81             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())</span>
  82                 throw new InternalError(member.toString());
  83             mtype = mtype.insertParameterTypes(0, refc);
  84         }
  85         if (!member.isField()) {
  86             // refKind reflects the original type of lookup via findSpecial or
  87             // findVirtual etc.
  88             switch (refKind) {
  89                 case REF_invokeSpecial: {
  90                     member = member.asSpecial();
  91                     // if caller is an interface we need to adapt to get the
  92                     // receiver check inserted
  93                     if (callerClass == null) {
  94                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
  95                     }
  96                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
  97                     return new Special(mtype, lform, member, true, callerClass);
  98                 }
  99                 case REF_invokeInterface: {
 100                     // for interfaces we always need the receiver typecheck,
 101                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 102                     // to include the REF_invokeSpecial case
 103                     LambdaForm lform = preparedLambdaForm(member, true);
 104                     return new Interface(mtype, lform, member, true, refc);
 105                 }
 106                 default: {
 107                     LambdaForm lform = preparedLambdaForm(member);
 108                     return new DirectMethodHandle(mtype, lform, member, true);
 109                 }
 110             }
 111         } else {
 112             LambdaForm lform = preparedFieldLambdaForm(member);
 113             if (member.isStatic()) {
 114                 long offset = MethodHandleNatives.staticFieldOffset(member);
 115                 Object base = MethodHandleNatives.staticFieldBase(member);
<span class="line-modified"> 116                 return member.isIndirect() ? new IndirectStaticAccessor(mtype, lform, member, base, offset)</span>
<span class="line-added"> 117                                            : new InlineStaticAccessor(mtype, lform, member, base, offset);</span>
 118             } else {
 119                 long offset = MethodHandleNatives.objectFieldOffset(member);
 120                 assert(offset == (int)offset);
<span class="line-modified"> 121                 return  member.isIndirect() ? new IndirectAccessor(mtype, lform, member, (int)offset)</span>
<span class="line-added"> 122                                             : new InlineAccessor(mtype, lform, member, (int)offset);</span>
 123             }
 124         }
 125     }
 126     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
 127         byte refKind = member.getReferenceKind();
 128         if (refKind == REF_invokeSpecial)
 129             refKind =  REF_invokeVirtual;
 130         return make(refKind, refc, member, null /* no callerClass context */);
 131     }
 132     static DirectMethodHandle make(MemberName member) {
<span class="line-modified"> 133         if (member.isObjectConstructor() &amp;&amp; member.getReturnType() == void.class)</span>
 134             return makeAllocator(member);
 135         return make(member.getDeclaringClass(), member);
 136     }
 137     private static DirectMethodHandle makeAllocator(MemberName ctor) {
<span class="line-modified"> 138         assert(ctor.isObjectConstructor() &amp;&amp; !ctor.getDeclaringClass().isInlineClass()) : ctor;</span>
<span class="line-added"> 139 </span>
 140         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
<span class="line-modified"> 141         ctor = ctor.asObjectConstructor();</span>
<span class="line-modified"> 142         assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;</span>
 143         MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
 144         LambdaForm lform = preparedLambdaForm(ctor);
 145         MemberName init = ctor.asSpecial();
 146         assert(init.getMethodType().returnType() == void.class);
 147         return new Constructor(mtype, lform, ctor, true, init, instanceClass);
 148     }
 149 
 150     @Override
 151     BoundMethodHandle rebind() {
 152         return BoundMethodHandle.makeReinvoker(this);
 153     }
 154 
 155     @Override
 156     MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 157         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
 158         return new DirectMethodHandle(mt, lf, member, crackable);
 159     }
 160 
 161     @Override
 162     MethodHandle viewAsType(MethodType newType, boolean strict) {
</pre>
<hr />
<pre>
 505         @Override
 506         MethodHandle viewAsType(MethodType newType, boolean strict) {
 507             assert(viewAsTypeChecks(newType, strict));
 508             return new Constructor(newType, form, member, false, initMethod, instanceClass);
 509         }
 510     }
 511 
 512     /*non-public*/
 513     static Object constructorMethod(Object mh) {
 514         Constructor dmh = (Constructor)mh;
 515         return dmh.initMethod;
 516     }
 517 
 518     /*non-public*/
 519     static Object allocateInstance(Object mh) throws InstantiationException {
 520         Constructor dmh = (Constructor)mh;
 521         return UNSAFE.allocateInstance(dmh.instanceClass);
 522     }
 523 
 524     /** This subclass handles non-static field references. */
<span class="line-modified"> 525     static abstract class Accessor extends DirectMethodHandle {</span>
 526         final Class&lt;?&gt; fieldType;
 527         final int      fieldOffset;
 528         private Accessor(MethodType mtype, LambdaForm form, MemberName member,
 529                          boolean crackable, int fieldOffset) {
 530             super(mtype, form, member, crackable);
 531             this.fieldType   = member.getFieldType();
 532             this.fieldOffset = fieldOffset;
 533         }
<span class="line-added"> 534         abstract Object checkCast(Object obj);</span>
<span class="line-added"> 535         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);</span>
<span class="line-added"> 536     }</span>
<span class="line-added"> 537 </span>
<span class="line-added"> 538     /** This subclass handles non-static field references of indirect type */</span>
<span class="line-added"> 539     static class IndirectAccessor extends Accessor {</span>
<span class="line-added"> 540         private IndirectAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-added"> 541                                  int fieldOffset) {</span>
<span class="line-added"> 542             super(mtype, form, member, true, fieldOffset);</span>
<span class="line-added"> 543         }</span>
 544 
 545         @Override Object checkCast(Object obj) {
 546             return fieldType.cast(obj);
 547         }
 548         @Override
 549         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 550             return new IndirectAccessor(mt, lf, member, fieldOffset);</span>
 551         }
 552         @Override
 553         MethodHandle viewAsType(MethodType newType, boolean strict) {
 554             assert(viewAsTypeChecks(newType, strict));
<span class="line-modified"> 555             return new IndirectAccessor(newType, form, member, fieldOffset);</span>
<span class="line-added"> 556         }</span>
<span class="line-added"> 557     }</span>
<span class="line-added"> 558 </span>
<span class="line-added"> 559     /** This subclass handles non-static field references of inline type */</span>
<span class="line-added"> 560     static class InlineAccessor extends Accessor {</span>
<span class="line-added"> 561         private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-added"> 562                                int fieldOffset) {</span>
<span class="line-added"> 563             super(mtype, form, member, true, fieldOffset);</span>
<span class="line-added"> 564         }</span>
<span class="line-added"> 565 </span>
<span class="line-added"> 566         @Override Object checkCast(Object obj) {</span>
<span class="line-added"> 567             return fieldType.cast(Objects.requireNonNull(obj));</span>
<span class="line-added"> 568         }</span>
<span class="line-added"> 569         @Override</span>
<span class="line-added"> 570         MethodHandle copyWith(MethodType mt, LambdaForm lf) {</span>
<span class="line-added"> 571             return new InlineAccessor(mt, lf, member, fieldOffset);</span>
 572         }
 573     }
 574 
 575     @ForceInline
 576     /*non-public*/
 577     static long fieldOffset(Object accessorObj) {
 578         // Note: We return a long because that is what Unsafe.getObject likes.
 579         // We store a plain int because it is more compact.
 580         return ((Accessor)accessorObj).fieldOffset;
 581     }
 582 
 583     @ForceInline
 584     /*non-public*/
 585     static Object checkBase(Object obj) {
 586         // Note that the object&#39;s class has already been verified,
 587         // since the parameter type of the Accessor method handle
 588         // is either member.getDeclaringClass or a subclass.
 589         // This was verified in DirectMethodHandle.make.
 590         // Therefore, the only remaining check is for null.
 591         // Since this check is *not* guaranteed by Unsafe.getInt
 592         // and its siblings, we need to make an explicit one here.
 593         return Objects.requireNonNull(obj);
 594     }
 595 
<span class="line-modified"> 596     static abstract class StaticAccessor extends DirectMethodHandle {</span>
<span class="line-modified"> 597         final Class&lt;?&gt; fieldType;</span>
<span class="line-modified"> 598         final Object staticBase;</span>
<span class="line-modified"> 599         final long staticOffset;</span>

 600 
 601         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 602                                boolean crackable, Object staticBase, long staticOffset) {
 603             super(mtype, form, member, crackable);
 604             this.fieldType    = member.getFieldType();
 605             this.staticBase   = staticBase;
 606             this.staticOffset = staticOffset;
 607         }
<span class="line-added"> 608         abstract Object checkCast(Object obj);</span>
<span class="line-added"> 609         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);</span>
<span class="line-added"> 610     }</span>
<span class="line-added"> 611 </span>
<span class="line-added"> 612     /** This subclass handles static field references of indirect type. */</span>
<span class="line-added"> 613     static class IndirectStaticAccessor extends StaticAccessor {</span>
<span class="line-added"> 614         private IndirectStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-added"> 615                                      Object staticBase, long staticOffset) {</span>
<span class="line-added"> 616             super(mtype, form, member, true, staticBase, staticOffset);</span>
<span class="line-added"> 617         }</span>
 618 
<span class="line-added"> 619         // indirect type is always nullable</span>
 620         @Override Object checkCast(Object obj) {
 621             return fieldType.cast(obj);
 622         }
 623         @Override
 624         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="line-modified"> 625             return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);</span>
 626         }
 627         @Override
 628         MethodHandle viewAsType(MethodType newType, boolean strict) {
 629             assert(viewAsTypeChecks(newType, strict));
<span class="line-modified"> 630             return new IndirectStaticAccessor(newType, form, member, staticBase, staticOffset);</span>
<span class="line-added"> 631         }</span>
<span class="line-added"> 632     }</span>
<span class="line-added"> 633 </span>
<span class="line-added"> 634     /** This subclass handles static field references of inline type . */</span>
<span class="line-added"> 635     static class InlineStaticAccessor extends StaticAccessor {</span>
<span class="line-added"> 636         private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,</span>
<span class="line-added"> 637                                      Object staticBase, long staticOffset) {</span>
<span class="line-added"> 638             super(mtype, form, member, true, staticBase, staticOffset);</span>
<span class="line-added"> 639         }</span>
<span class="line-added"> 640 </span>
<span class="line-added"> 641         // zero-default inline type is not-nullable</span>
<span class="line-added"> 642         @Override Object checkCast(Object obj) {</span>
<span class="line-added"> 643             assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;</span>
<span class="line-added"> 644             return fieldType.cast(Objects.requireNonNull(obj));</span>
<span class="line-added"> 645         }</span>
<span class="line-added"> 646         @Override</span>
<span class="line-added"> 647         MethodHandle copyWith(MethodType mt, LambdaForm lf) {</span>
<span class="line-added"> 648             return new InlineStaticAccessor(mt, lf, member, staticBase, staticOffset);</span>
 649         }
 650     }
 651 
 652     @ForceInline
 653     /*non-public*/
 654     static Object nullCheck(Object obj) {
 655         return Objects.requireNonNull(obj);
 656     }
 657 
 658     @ForceInline
 659     /*non-public*/
 660     static Object staticBase(Object accessorObj) {
 661         return ((StaticAccessor)accessorObj).staticBase;
 662     }
 663 
 664     @ForceInline
 665     /*non-public*/
 666     static long staticOffset(Object accessorObj) {
 667         return ((StaticAccessor)accessorObj).staticOffset;
 668     }
 669 
 670     @ForceInline
 671     /*non-public*/
 672     static Object checkCast(Object mh, Object obj) {
 673         return ((DirectMethodHandle) mh).checkCast(obj);
 674     }
 675 
<span class="line-added"> 676     @ForceInline</span>
<span class="line-added"> 677     /*non-public*/ static Class&lt;?&gt; fieldType(Object accessorObj) {</span>
<span class="line-added"> 678         return ((Accessor) accessorObj).fieldType;</span>
<span class="line-added"> 679     }</span>
<span class="line-added"> 680 </span>
<span class="line-added"> 681     @ForceInline</span>
<span class="line-added"> 682     /*non-public*/ static Class&lt;?&gt; staticFieldType(Object accessorObj) {</span>
<span class="line-added"> 683         return ((StaticAccessor) accessorObj).fieldType;</span>
<span class="line-added"> 684     }</span>
<span class="line-added"> 685 </span>
 686     Object checkCast(Object obj) {
 687         return member.getReturnType().cast(obj);
 688     }
 689 
 690     // Caching machinery for field accessors:
 691     static final byte
 692             AF_GETFIELD        = 0,
 693             AF_PUTFIELD        = 1,
 694             AF_GETSTATIC       = 2,
 695             AF_PUTSTATIC       = 3,
 696             AF_GETSTATIC_INIT  = 4,
 697             AF_PUTSTATIC_INIT  = 5,
 698             AF_LIMIT           = 6;
 699     // Enumerate the different field kinds using Wrapper,
<span class="line-modified"> 700     // with an extra case added for checked references and value field access</span>
 701     static final int
<span class="line-modified"> 702             FT_LAST_WRAPPER     = Wrapper.COUNT-1,</span>
<span class="line-modified"> 703             FT_UNCHECKED_REF    = Wrapper.OBJECT.ordinal(),</span>
<span class="line-modified"> 704             FT_CHECKED_REF      = FT_LAST_WRAPPER+1,</span>
<span class="line-modified"> 705             FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  // flattened and non-flattened</span>
<span class="line-modified"> 706             FT_LIMIT            = FT_LAST_WRAPPER+4;</span>
<span class="line-added"> 707     private static int afIndex(byte formOp, boolean isVolatile, boolean isFlatValue, int ftypeKind) {</span>
 708         return ((formOp * FT_LIMIT * 2)
 709                 + (isVolatile ? FT_LIMIT : 0)
<span class="line-added"> 710                 + (isFlatValue ? 1 : 0)</span>
 711                 + ftypeKind);
 712     }
 713     @Stable
 714     private static final LambdaForm[] ACCESSOR_FORMS
<span class="line-modified"> 715             = new LambdaForm[afIndex(AF_LIMIT, false, false, 0)];</span>
<span class="line-modified"> 716     static int ftypeKind(Class&lt;?&gt; ftype, boolean isValue) {</span>
 717         if (ftype.isPrimitive())
 718             return Wrapper.forPrimitiveType(ftype).ordinal();
<span class="line-modified"> 719         else if (VerifyType.isNullReferenceConversion(Object.class, ftype)) {</span>
 720             return FT_UNCHECKED_REF;
<span class="line-modified"> 721         } else</span>
<span class="line-modified"> 722             // null check for value type in addition to check cast</span>
<span class="line-added"> 723             return isValue ? FT_CHECKED_VALUE : FT_CHECKED_REF;</span>
 724     }
 725 
 726     /**
 727      * Create a LF which can access the given field.
 728      * Cache and share this structure among all fields with
 729      * the same basicType and refKind.
 730      */
 731     private static LambdaForm preparedFieldLambdaForm(MemberName m) {
 732         Class&lt;?&gt; ftype = m.getFieldType();

 733         byte formOp;
 734         switch (m.getReferenceKind()) {
 735         case REF_getField:      formOp = AF_GETFIELD;    break;
 736         case REF_putField:      formOp = AF_PUTFIELD;    break;
 737         case REF_getStatic:     formOp = AF_GETSTATIC;   break;
 738         case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
 739         default:  throw new InternalError(m.toString());
 740         }
 741         if (shouldBeInitialized(m)) {
 742             // precompute the barrier-free version:
<span class="line-modified"> 743             preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineable(), m.isFlattened(), ftype);</span>
 744             assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
 745                    (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
 746             formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
 747         }
<span class="line-modified"> 748         LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineable(), m.isFlattened(), ftype);</span>
 749         maybeCompile(lform, m);
 750         assert(lform.methodType().dropParameterTypes(0, 1)
 751                 .equals(m.getInvocationType().basicType()))
 752                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
 753         return lform;
 754     }
<span class="line-modified"> 755 </span>
<span class="line-modified"> 756     private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, Class&lt;?&gt; ftype) {</span>
<span class="line-modified"> 757         int ftypeKind = ftypeKind(ftype, isValue);</span>
<span class="line-added"> 758         int afIndex = afIndex(formOp, isVolatile, isFlatValue, ftypeKind);</span>
 759         LambdaForm lform = ACCESSOR_FORMS[afIndex];
 760         if (lform != null)  return lform;
<span class="line-modified"> 761         lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlatValue, ftypeKind);</span>
 762         ACCESSOR_FORMS[afIndex] = lform;  // don&#39;t bother with a CAS
 763         return lform;
 764     }
 765 
 766     private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();
 767 
<span class="line-modified"> 768     private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlatValue, Wrapper wrapper) {</span>
 769         if (isGetter) {
 770             if (isVolatile) {
 771                 switch (wrapper) {
 772                     case BOOLEAN: return GET_BOOLEAN_VOLATILE;
 773                     case BYTE:    return GET_BYTE_VOLATILE;
 774                     case SHORT:   return GET_SHORT_VOLATILE;
 775                     case CHAR:    return GET_CHAR_VOLATILE;
 776                     case INT:     return GET_INT_VOLATILE;
 777                     case LONG:    return GET_LONG_VOLATILE;
 778                     case FLOAT:   return GET_FLOAT_VOLATILE;
 779                     case DOUBLE:  return GET_DOUBLE_VOLATILE;
<span class="line-modified"> 780                     case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;</span>
 781                 }
 782             } else {
 783                 switch (wrapper) {
 784                     case BOOLEAN: return GET_BOOLEAN;
 785                     case BYTE:    return GET_BYTE;
 786                     case SHORT:   return GET_SHORT;
 787                     case CHAR:    return GET_CHAR;
 788                     case INT:     return GET_INT;
 789                     case LONG:    return GET_LONG;
 790                     case FLOAT:   return GET_FLOAT;
 791                     case DOUBLE:  return GET_DOUBLE;
<span class="line-modified"> 792                     case OBJECT:  return isFlatValue ? GET_VALUE : GET_REFERENCE;</span>
 793                 }
 794             }
 795         } else {
 796             if (isVolatile) {
 797                 switch (wrapper) {
 798                     case BOOLEAN: return PUT_BOOLEAN_VOLATILE;
 799                     case BYTE:    return PUT_BYTE_VOLATILE;
 800                     case SHORT:   return PUT_SHORT_VOLATILE;
 801                     case CHAR:    return PUT_CHAR_VOLATILE;
 802                     case INT:     return PUT_INT_VOLATILE;
 803                     case LONG:    return PUT_LONG_VOLATILE;
 804                     case FLOAT:   return PUT_FLOAT_VOLATILE;
 805                     case DOUBLE:  return PUT_DOUBLE_VOLATILE;
<span class="line-modified"> 806                     case OBJECT:  return isFlatValue ? PUT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;</span>
 807                 }
 808             } else {
 809                 switch (wrapper) {
 810                     case BOOLEAN: return PUT_BOOLEAN;
 811                     case BYTE:    return PUT_BYTE;
 812                     case SHORT:   return PUT_SHORT;
 813                     case CHAR:    return PUT_CHAR;
 814                     case INT:     return PUT_INT;
 815                     case LONG:    return PUT_LONG;
 816                     case FLOAT:   return PUT_FLOAT;
 817                     case DOUBLE:  return PUT_DOUBLE;
<span class="line-modified"> 818                     case OBJECT:  return isFlatValue ? PUT_VALUE : PUT_REFERENCE;</span>
 819                 }
 820             }
 821         }
 822         throw new AssertionError(&quot;Invalid arguments&quot;);
 823     }
 824 
<span class="line-modified"> 825     /** invoked by GenerateJLIClassesHelper */</span>
<span class="line-added"> 826     static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftype) {</span>
<span class="line-added"> 827         return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);</span>
<span class="line-added"> 828     }</span>
<span class="line-added"> 829 </span>
<span class="line-added"> 830     private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, int ftypeKind) {</span>
 831         boolean isGetter  = (formOp &amp; 1) == (AF_GETFIELD &amp; 1);
 832         boolean isStatic  = (formOp &gt;= AF_GETSTATIC);
 833         boolean needsInit = (formOp &gt;= AF_GETSTATIC_INIT);
<span class="line-modified"> 834         boolean needsCast = (ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_VALUE);</span>
 835         Wrapper fw = (needsCast ? Wrapper.OBJECT : ALL_WRAPPERS[ftypeKind]);
 836         Class&lt;?&gt; ft = fw.primitiveType();
<span class="line-modified"> 837         assert(needsCast ? true : ftypeKind(ft, isValue) == ftypeKind);</span>
 838 
 839         // getObject, putIntVolatile, etc.
<span class="line-modified"> 840         Kind kind = getFieldKind(isGetter, isVolatile, isFlatValue, fw);</span>
 841 
 842         MethodType linkerType;
<span class="line-modified"> 843         boolean hasValueTypeArg = isGetter ? isValue : isFlatValue;</span>
<span class="line-modified"> 844         if (isGetter) {</span>
<span class="line-modified"> 845             linkerType = isValue ? MethodType.methodType(ft, Object.class, long.class, Class.class)</span>
<span class="line-modified"> 846                                  : MethodType.methodType(ft, Object.class, long.class);</span>
<span class="line-added"> 847         } else {</span>
<span class="line-added"> 848             linkerType = isFlatValue ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)</span>
<span class="line-added"> 849                                      : MethodType.methodType(void.class, Object.class, long.class, ft);</span>
<span class="line-added"> 850         }</span>
 851         MemberName linker = new MemberName(Unsafe.class, kind.methodName, linkerType, REF_invokeVirtual);
 852         try {
 853             linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, NoSuchMethodException.class);
 854         } catch (ReflectiveOperationException ex) {
 855             throw newInternalError(ex);
 856         }
 857 
 858         // What is the external type of the lambda form?
 859         MethodType mtype;
 860         if (isGetter)
 861             mtype = MethodType.methodType(ft);
 862         else
 863             mtype = MethodType.methodType(void.class, ft);
 864         mtype = mtype.basicType();  // erase short to int, etc.
 865         if (!isStatic)
 866             mtype = mtype.insertParameterTypes(0, Object.class);
 867         final int DMH_THIS  = 0;
 868         final int ARG_BASE  = 1;
 869         final int ARG_LIMIT = ARG_BASE + mtype.parameterCount();
 870         // if this is for non-static access, the base pointer is stored at this index:
 871         final int OBJ_BASE  = isStatic ? -1 : ARG_BASE;
 872         // if this is for write access, the value to be written is stored at this index:
 873         final int SET_VALUE  = isGetter ? -1 : ARG_LIMIT - 1;
 874         int nameCursor = ARG_LIMIT;
 875         final int F_HOLDER  = (isStatic ? nameCursor++ : -1);  // static base if any
 876         final int F_OFFSET  = nameCursor++;  // Either static offset or field offset.
 877         final int OBJ_CHECK = (OBJ_BASE &gt;= 0 ? nameCursor++ : -1);
 878         final int U_HOLDER  = nameCursor++;  // UNSAFE holder
 879         final int INIT_BAR  = (needsInit ? nameCursor++ : -1);
<span class="line-added"> 880         final int VALUE_TYPE = (hasValueTypeArg ? nameCursor++ : -1);</span>
 881         final int PRE_CAST  = (needsCast &amp;&amp; !isGetter ? nameCursor++ : -1);
 882         final int LINKER_CALL = nameCursor++;
 883         final int POST_CAST = (needsCast &amp;&amp; isGetter ? nameCursor++ : -1);
 884         final int RESULT    = nameCursor-1;  // either the call or the cast
 885         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
 886         if (needsInit)
 887             names[INIT_BAR] = new Name(getFunction(NF_ensureInitialized), names[DMH_THIS]);
 888         if (needsCast &amp;&amp; !isGetter)
 889             names[PRE_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[SET_VALUE]);
 890         Object[] outArgs = new Object[1 + linkerType.parameterCount()];
<span class="line-modified"> 891         assert (outArgs.length == (isGetter ? 3 : 4) + (hasValueTypeArg ? 1 : 0));</span>
 892         outArgs[0] = names[U_HOLDER] = new Name(getFunction(NF_UNSAFE));
 893         if (isStatic) {
 894             outArgs[1] = names[F_HOLDER]  = new Name(getFunction(NF_staticBase), names[DMH_THIS]);
 895             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_staticOffset), names[DMH_THIS]);
 896         } else {
 897             outArgs[1] = names[OBJ_CHECK] = new Name(getFunction(NF_checkBase), names[OBJ_BASE]);
 898             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_fieldOffset), names[DMH_THIS]);
 899         }
<span class="line-added"> 900         int x = 3;</span>
<span class="line-added"> 901         if (hasValueTypeArg) {</span>
<span class="line-added"> 902             outArgs[x++] = names[VALUE_TYPE] = isStatic ? new Name(getFunction(NF_staticFieldType), names[DMH_THIS])</span>
<span class="line-added"> 903                                                         : new Name(getFunction(NF_fieldType), names[DMH_THIS]);</span>
<span class="line-added"> 904         }</span>
 905         if (!isGetter) {
<span class="line-modified"> 906             outArgs[x] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);</span>
 907         }
 908         for (Object a : outArgs)  assert(a != null);
 909         names[LINKER_CALL] = new Name(linker, outArgs);
 910         if (needsCast &amp;&amp; isGetter)
 911             names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[LINKER_CALL]);
 912         for (Name n : names)  assert(n != null);
 913 
 914         LambdaForm form;
 915         if (needsCast || needsInit) {
 916             // can&#39;t use the pre-generated form when casting and/or initializing
 917             form = new LambdaForm(ARG_LIMIT, names, RESULT);
 918         } else {
 919             form = new LambdaForm(ARG_LIMIT, names, RESULT, kind);
 920         }
 921 
 922         if (LambdaForm.debugNames()) {
 923             // add some detail to the lambdaForm debugname,
 924             // significant only for debugging
 925             StringBuilder nameBuilder = new StringBuilder(kind.methodName);
 926             if (isStatic) {
</pre>
<hr />
<pre>
 937             LambdaForm.associateWithDebugName(form, nameBuilder.toString());
 938         }
 939         return form;
 940     }
 941 
 942     /**
 943      * Pre-initialized NamedFunctions for bootstrapping purposes.
 944      */
 945     static final byte NF_internalMemberName = 0,
 946             NF_internalMemberNameEnsureInit = 1,
 947             NF_ensureInitialized = 2,
 948             NF_fieldOffset = 3,
 949             NF_checkBase = 4,
 950             NF_staticBase = 5,
 951             NF_staticOffset = 6,
 952             NF_checkCast = 7,
 953             NF_allocateInstance = 8,
 954             NF_constructorMethod = 9,
 955             NF_UNSAFE = 10,
 956             NF_checkReceiver = 11,
<span class="line-modified"> 957             NF_fieldType = 12,</span>
<span class="line-added"> 958             NF_staticFieldType = 13,</span>
<span class="line-added"> 959             NF_LIMIT = 14;</span>
 960 
 961     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
 962 
 963     private static NamedFunction getFunction(byte func) {
 964         NamedFunction nf = NFS[func];
 965         if (nf != null) {
 966             return nf;
 967         }
 968         // Each nf must be statically invocable or we get tied up in our bootstraps.
 969         nf = NFS[func] = createFunction(func);
 970         assert(InvokerBytecodeGenerator.isStaticallyInvocable(nf));
 971         return nf;
 972     }
 973 
<span class="line-added"> 974     private static final MethodType CLS_OBJ_TYPE = MethodType.methodType(Class.class, Object.class);</span>
<span class="line-added"> 975 </span>
 976     private static final MethodType OBJ_OBJ_TYPE = MethodType.methodType(Object.class, Object.class);
 977 
 978     private static final MethodType LONG_OBJ_TYPE = MethodType.methodType(long.class, Object.class);
 979 
 980     private static NamedFunction createFunction(byte func) {
 981         try {
 982             switch (func) {
 983                 case NF_internalMemberName:
 984                     return getNamedFunction(&quot;internalMemberName&quot;, OBJ_OBJ_TYPE);
 985                 case NF_internalMemberNameEnsureInit:
 986                     return getNamedFunction(&quot;internalMemberNameEnsureInit&quot;, OBJ_OBJ_TYPE);
 987                 case NF_ensureInitialized:
 988                     return getNamedFunction(&quot;ensureInitialized&quot;, MethodType.methodType(void.class, Object.class));
 989                 case NF_fieldOffset:
 990                     return getNamedFunction(&quot;fieldOffset&quot;, LONG_OBJ_TYPE);
 991                 case NF_checkBase:
 992                     return getNamedFunction(&quot;checkBase&quot;, OBJ_OBJ_TYPE);
 993                 case NF_staticBase:
 994                     return getNamedFunction(&quot;staticBase&quot;, OBJ_OBJ_TYPE);
 995                 case NF_staticOffset:
 996                     return getNamedFunction(&quot;staticOffset&quot;, LONG_OBJ_TYPE);
 997                 case NF_checkCast:
 998                     return getNamedFunction(&quot;checkCast&quot;, MethodType.methodType(Object.class, Object.class, Object.class));
 999                 case NF_allocateInstance:
1000                     return getNamedFunction(&quot;allocateInstance&quot;, OBJ_OBJ_TYPE);
1001                 case NF_constructorMethod:
1002                     return getNamedFunction(&quot;constructorMethod&quot;, OBJ_OBJ_TYPE);
1003                 case NF_UNSAFE:
1004                     MemberName member = new MemberName(MethodHandleStatics.class, &quot;UNSAFE&quot;, Unsafe.class, REF_getField);
1005                     return new NamedFunction(
1006                             MemberName.getFactory()
1007                                     .resolveOrFail(REF_getField, member, DirectMethodHandle.class, NoSuchMethodException.class));
1008                 case NF_checkReceiver:
1009                     member = new MemberName(DirectMethodHandle.class, &quot;checkReceiver&quot;, OBJ_OBJ_TYPE, REF_invokeVirtual);
1010                     return new NamedFunction(
1011                         MemberName.getFactory()
1012                             .resolveOrFail(REF_invokeVirtual, member, DirectMethodHandle.class, NoSuchMethodException.class));
<span class="line-added">1013                 case NF_fieldType:</span>
<span class="line-added">1014                     return getNamedFunction(&quot;fieldType&quot;, CLS_OBJ_TYPE);</span>
<span class="line-added">1015                 case NF_staticFieldType:</span>
<span class="line-added">1016                     return getNamedFunction(&quot;staticFieldType&quot;, CLS_OBJ_TYPE);</span>
1017                 default:
1018                     throw newInternalError(&quot;Unknown function: &quot; + func);
1019             }
1020         } catch (ReflectiveOperationException ex) {
1021             throw newInternalError(ex);
1022         }
1023     }
1024 
1025     private static NamedFunction getNamedFunction(String name, MethodType type)
1026         throws ReflectiveOperationException
1027     {
1028         MemberName member = new MemberName(DirectMethodHandle.class, name, type, REF_invokeStatic);
1029         return new NamedFunction(
1030             MemberName.getFactory()
1031                 .resolveOrFail(REF_invokeStatic, member, DirectMethodHandle.class, NoSuchMethodException.class));
1032     }
1033 
1034     static {
1035         // The Holder class will contain pre-generated DirectMethodHandles resolved
1036         // speculatively using MemberName.getFactory().resolveOrNull. However, that
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../hotspot/share/runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
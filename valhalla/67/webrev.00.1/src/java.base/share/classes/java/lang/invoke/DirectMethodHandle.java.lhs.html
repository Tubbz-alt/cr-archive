<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.misc.Unsafe;
 29 import jdk.internal.vm.annotation.ForceInline;
 30 import jdk.internal.vm.annotation.Stable;
 31 import sun.invoke.util.ValueConversions;
 32 import sun.invoke.util.VerifyAccess;
 33 import sun.invoke.util.VerifyType;
 34 import sun.invoke.util.Wrapper;
 35 
 36 import java.lang.ref.WeakReference;
 37 import java.util.Arrays;
 38 import java.util.Objects;
 39 
 40 import static java.lang.invoke.LambdaForm.*;
 41 import static java.lang.invoke.LambdaForm.Kind.*;
 42 import static java.lang.invoke.MethodHandleNatives.Constants.*;
 43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 44 import static java.lang.invoke.MethodHandleStatics.newInternalError;
 45 import static java.lang.invoke.MethodTypeForm.*;
 46 
 47 /**
 48  * The flavor of method handle which implements a constant reference
 49  * to a class member.
 50  * @author jrose
 51  */
 52 class DirectMethodHandle extends MethodHandle {
 53     final MemberName member;
 54     final boolean crackable;
 55 
 56     // Constructors and factory methods in this class *must* be package scoped or private.
 57     private DirectMethodHandle(MethodType mtype, LambdaForm form, MemberName member, boolean crackable) {
 58         super(mtype, form);
 59         if (!member.isResolved())  throw new InternalError();
 60 
 61         if (member.getDeclaringClass().isInterface() &amp;&amp;
 62             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
 63             member.isMethod() &amp;&amp; !member.isAbstract()) {
 64             // Check for corner case: invokeinterface of Object method
 65             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
 66             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
 67             if (m != null &amp;&amp; m.isPublic()) {
 68                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
 69                 member = m;
 70             }
 71         }
 72 
 73         this.member = member;
 74         this.crackable = crackable;
 75     }
 76 
 77     // Factory methods:
 78     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
 79         MethodType mtype = member.getMethodOrFieldType();
 80         if (!member.isStatic()) {
<a name="2" id="anc2"></a><span class="line-modified"> 81             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isConstructor())</span>
 82                 throw new InternalError(member.toString());
 83             mtype = mtype.insertParameterTypes(0, refc);
 84         }
 85         if (!member.isField()) {
 86             // refKind reflects the original type of lookup via findSpecial or
 87             // findVirtual etc.
 88             switch (refKind) {
 89                 case REF_invokeSpecial: {
 90                     member = member.asSpecial();
 91                     // if caller is an interface we need to adapt to get the
 92                     // receiver check inserted
 93                     if (callerClass == null) {
 94                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
 95                     }
 96                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
 97                     return new Special(mtype, lform, member, true, callerClass);
 98                 }
 99                 case REF_invokeInterface: {
100                     // for interfaces we always need the receiver typecheck,
101                     // so we always pass &#39;true&#39; to ensure we adapt if needed
102                     // to include the REF_invokeSpecial case
103                     LambdaForm lform = preparedLambdaForm(member, true);
104                     return new Interface(mtype, lform, member, true, refc);
105                 }
106                 default: {
107                     LambdaForm lform = preparedLambdaForm(member);
108                     return new DirectMethodHandle(mtype, lform, member, true);
109                 }
110             }
111         } else {
112             LambdaForm lform = preparedFieldLambdaForm(member);
113             if (member.isStatic()) {
114                 long offset = MethodHandleNatives.staticFieldOffset(member);
115                 Object base = MethodHandleNatives.staticFieldBase(member);
<a name="3" id="anc3"></a><span class="line-modified">116                 return new StaticAccessor(mtype, lform, member, true, base, offset);</span>

117             } else {
118                 long offset = MethodHandleNatives.objectFieldOffset(member);
119                 assert(offset == (int)offset);
<a name="4" id="anc4"></a><span class="line-modified">120                 return new Accessor(mtype, lform, member, true, (int)offset);</span>

121             }
122         }
123     }
124     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
125         byte refKind = member.getReferenceKind();
126         if (refKind == REF_invokeSpecial)
127             refKind =  REF_invokeVirtual;
128         return make(refKind, refc, member, null /* no callerClass context */);
129     }
130     static DirectMethodHandle make(MemberName member) {
<a name="5" id="anc5"></a><span class="line-modified">131         if (member.isConstructor())</span>
132             return makeAllocator(member);
133         return make(member.getDeclaringClass(), member);
134     }
135     private static DirectMethodHandle makeAllocator(MemberName ctor) {
<a name="6" id="anc6"></a><span class="line-modified">136         assert(ctor.isConstructor() &amp;&amp; ctor.getName().equals(&quot;&lt;init&gt;&quot;));</span>

137         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
<a name="7" id="anc7"></a><span class="line-modified">138         ctor = ctor.asConstructor();</span>
<span class="line-modified">139         assert(ctor.isConstructor() &amp;&amp; ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;</span>
140         MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
141         LambdaForm lform = preparedLambdaForm(ctor);
142         MemberName init = ctor.asSpecial();
143         assert(init.getMethodType().returnType() == void.class);
144         return new Constructor(mtype, lform, ctor, true, init, instanceClass);
145     }
146 
147     @Override
148     BoundMethodHandle rebind() {
149         return BoundMethodHandle.makeReinvoker(this);
150     }
151 
152     @Override
153     MethodHandle copyWith(MethodType mt, LambdaForm lf) {
154         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
155         return new DirectMethodHandle(mt, lf, member, crackable);
156     }
157 
158     @Override
159     MethodHandle viewAsType(MethodType newType, boolean strict) {
160         // No actual conversions, just a new view of the same method.
161         // However, we must not expose a DMH that is crackable into a
162         // MethodHandleInfo, so we return a cloned, uncrackable DMH
163         assert(viewAsTypeChecks(newType, strict));
164         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
165         return new DirectMethodHandle(newType, form, member, false);
166     }
167 
168     @Override
169     boolean isCrackable() {
170         return crackable;
171     }
172 
173     @Override
174     String internalProperties() {
175         return &quot;\n&amp; DMH.MN=&quot;+internalMemberName();
176     }
177 
178     //// Implementation methods.
179     @Override
180     @ForceInline
181     MemberName internalMemberName() {
182         return member;
183     }
184 
185     private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
186 
187     /**
188      * Create a LF which can invoke the given method.
189      * Cache and share this structure among all methods with
190      * the same basicType and refKind.
191      */
192     private static LambdaForm preparedLambdaForm(MemberName m, boolean adaptToSpecialIfc) {
193         assert(m.isInvocable()) : m;  // call preparedFieldLambdaForm instead
194         MethodType mtype = m.getInvocationType().basicType();
195         assert(!m.isMethodHandleInvoke()) : m;
196         int which;
197         // MemberName.getReferenceKind represents the JVM optimized form of the call
198         // as distinct from the &quot;kind&quot; passed to DMH.make which represents the original
199         // bytecode-equivalent request. Specifically private/final methods that use a direct
200         // call have getReferenceKind adapted to REF_invokeSpecial, even though the actual
201         // invocation mode may be invokevirtual or invokeinterface.
202         switch (m.getReferenceKind()) {
203         case REF_invokeVirtual:    which = LF_INVVIRTUAL;    break;
204         case REF_invokeStatic:     which = LF_INVSTATIC;     break;
205         case REF_invokeSpecial:    which = LF_INVSPECIAL;    break;
206         case REF_invokeInterface:  which = LF_INVINTERFACE;  break;
207         case REF_newInvokeSpecial: which = LF_NEWINVSPECIAL; break;
208         default:  throw new InternalError(m.toString());
209         }
210         if (which == LF_INVSTATIC &amp;&amp; shouldBeInitialized(m)) {
211             // precompute the barrier-free version:
212             preparedLambdaForm(mtype, which);
213             which = LF_INVSTATIC_INIT;
214         }
215         if (which == LF_INVSPECIAL &amp;&amp; adaptToSpecialIfc) {
216             which = LF_INVSPECIAL_IFC;
217         }
218         LambdaForm lform = preparedLambdaForm(mtype, which);
219         maybeCompile(lform, m);
220         assert(lform.methodType().dropParameterTypes(0, 1)
221                 .equals(m.getInvocationType().basicType()))
222                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
223         return lform;
224     }
225 
226     private static LambdaForm preparedLambdaForm(MemberName m) {
227         return preparedLambdaForm(m, false);
228     }
229 
230     private static LambdaForm preparedLambdaForm(MethodType mtype, int which) {
231         LambdaForm lform = mtype.form().cachedLambdaForm(which);
232         if (lform != null)  return lform;
233         lform = makePreparedLambdaForm(mtype, which);
234         return mtype.form().setCachedLambdaForm(which, lform);
235     }
236 
237     static LambdaForm makePreparedLambdaForm(MethodType mtype, int which) {
238         boolean needsInit = (which == LF_INVSTATIC_INIT);
239         boolean doesAlloc = (which == LF_NEWINVSPECIAL);
240         boolean needsReceiverCheck = (which == LF_INVINTERFACE ||
241                                       which == LF_INVSPECIAL_IFC);
242 
243         String linkerName;
244         LambdaForm.Kind kind;
245         switch (which) {
246         case LF_INVVIRTUAL:    linkerName = &quot;linkToVirtual&quot;;   kind = DIRECT_INVOKE_VIRTUAL;     break;
247         case LF_INVSTATIC:     linkerName = &quot;linkToStatic&quot;;    kind = DIRECT_INVOKE_STATIC;      break;
248         case LF_INVSTATIC_INIT:linkerName = &quot;linkToStatic&quot;;    kind = DIRECT_INVOKE_STATIC_INIT; break;
249         case LF_INVSPECIAL_IFC:linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_INVOKE_SPECIAL_IFC; break;
250         case LF_INVSPECIAL:    linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_INVOKE_SPECIAL;     break;
251         case LF_INVINTERFACE:  linkerName = &quot;linkToInterface&quot;; kind = DIRECT_INVOKE_INTERFACE;   break;
252         case LF_NEWINVSPECIAL: linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_NEW_INVOKE_SPECIAL; break;
253         default:  throw new InternalError(&quot;which=&quot;+which);
254         }
255 
256         MethodType mtypeWithArg = mtype.appendParameterTypes(MemberName.class);
257         if (doesAlloc)
258             mtypeWithArg = mtypeWithArg
259                     .insertParameterTypes(0, Object.class)  // insert newly allocated obj
260                     .changeReturnType(void.class);          // &lt;init&gt; returns void
261         MemberName linker = new MemberName(MethodHandle.class, linkerName, mtypeWithArg, REF_invokeStatic);
262         try {
263             linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, NoSuchMethodException.class);
264         } catch (ReflectiveOperationException ex) {
265             throw newInternalError(ex);
266         }
267         final int DMH_THIS    = 0;
268         final int ARG_BASE    = 1;
269         final int ARG_LIMIT   = ARG_BASE + mtype.parameterCount();
270         int nameCursor = ARG_LIMIT;
271         final int NEW_OBJ     = (doesAlloc ? nameCursor++ : -1);
272         final int GET_MEMBER  = nameCursor++;
273         final int CHECK_RECEIVER = (needsReceiverCheck ? nameCursor++ : -1);
274         final int LINKER_CALL = nameCursor++;
275         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
276         assert(names.length == nameCursor);
277         if (doesAlloc) {
278             // names = { argx,y,z,... new C, init method }
279             names[NEW_OBJ] = new Name(getFunction(NF_allocateInstance), names[DMH_THIS]);
280             names[GET_MEMBER] = new Name(getFunction(NF_constructorMethod), names[DMH_THIS]);
281         } else if (needsInit) {
282             names[GET_MEMBER] = new Name(getFunction(NF_internalMemberNameEnsureInit), names[DMH_THIS]);
283         } else {
284             names[GET_MEMBER] = new Name(getFunction(NF_internalMemberName), names[DMH_THIS]);
285         }
286         assert(findDirectMethodHandle(names[GET_MEMBER]) == names[DMH_THIS]);
287         Object[] outArgs = Arrays.copyOfRange(names, ARG_BASE, GET_MEMBER+1, Object[].class);
288         if (needsReceiverCheck) {
289             names[CHECK_RECEIVER] = new Name(getFunction(NF_checkReceiver), names[DMH_THIS], names[ARG_BASE]);
290             outArgs[0] = names[CHECK_RECEIVER];
291         }
292         assert(outArgs[outArgs.length-1] == names[GET_MEMBER]);  // look, shifted args!
293         int result = LAST_RESULT;
294         if (doesAlloc) {
295             assert(outArgs[outArgs.length-2] == names[NEW_OBJ]);  // got to move this one
296             System.arraycopy(outArgs, 0, outArgs, 1, outArgs.length-2);
297             outArgs[0] = names[NEW_OBJ];
298             result = NEW_OBJ;
299         }
300         names[LINKER_CALL] = new Name(linker, outArgs);
301         LambdaForm lform = new LambdaForm(ARG_LIMIT, names, result, kind);
302 
303         // This is a tricky bit of code.  Don&#39;t send it through the LF interpreter.
304         lform.compileToBytecode();
305         return lform;
306     }
307 
308     /* assert */ static Object findDirectMethodHandle(Name name) {
309         if (name.function.equals(getFunction(NF_internalMemberName)) ||
310             name.function.equals(getFunction(NF_internalMemberNameEnsureInit)) ||
311             name.function.equals(getFunction(NF_constructorMethod))) {
312             assert(name.arguments.length == 1);
313             return name.arguments[0];
314         }
315         return null;
316     }
317 
318     private static void maybeCompile(LambdaForm lform, MemberName m) {
319         if (lform.vmentry == null &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), MethodHandle.class))
320             // Help along bootstrapping...
321             lform.compileToBytecode();
322     }
323 
324     /** Static wrapper for DirectMethodHandle.internalMemberName. */
325     @ForceInline
326     /*non-public*/
327     static Object internalMemberName(Object mh) {
328         return ((DirectMethodHandle)mh).member;
329     }
330 
331     /** Static wrapper for DirectMethodHandle.internalMemberName.
332      * This one also forces initialization.
333      */
334     /*non-public*/
335     static Object internalMemberNameEnsureInit(Object mh) {
336         DirectMethodHandle dmh = (DirectMethodHandle)mh;
337         dmh.ensureInitialized();
338         return dmh.member;
339     }
340 
341     /*non-public*/
342     static boolean shouldBeInitialized(MemberName member) {
343         switch (member.getReferenceKind()) {
344         case REF_invokeStatic:
345         case REF_getStatic:
346         case REF_putStatic:
347         case REF_newInvokeSpecial:
348             break;
349         default:
350             // No need to initialize the class on this kind of member.
351             return false;
352         }
353         Class&lt;?&gt; cls = member.getDeclaringClass();
354         if (cls == ValueConversions.class ||
355             cls == MethodHandleImpl.class ||
356             cls == Invokers.class) {
357             // These guys have lots of &lt;clinit&gt; DMH creation but we know
358             // the MHs will not be used until the system is booted.
359             return false;
360         }
361         if (VerifyAccess.isSamePackage(MethodHandle.class, cls) ||
362             VerifyAccess.isSamePackage(ValueConversions.class, cls)) {
363             // It is a system class.  It is probably in the process of
364             // being initialized, but we will help it along just to be safe.
365             if (UNSAFE.shouldBeInitialized(cls)) {
366                 UNSAFE.ensureClassInitialized(cls);
367             }
368             return false;
369         }
370         return UNSAFE.shouldBeInitialized(cls);
371     }
372 
373     private static class EnsureInitialized extends ClassValue&lt;WeakReference&lt;Thread&gt;&gt; {
374         @Override
375         protected WeakReference&lt;Thread&gt; computeValue(Class&lt;?&gt; type) {
376             UNSAFE.ensureClassInitialized(type);
377             if (UNSAFE.shouldBeInitialized(type))
378                 // If the previous call didn&#39;t block, this can happen.
379                 // We are executing inside &lt;clinit&gt;.
380                 return new WeakReference&lt;&gt;(Thread.currentThread());
381             return null;
382         }
383         static final EnsureInitialized INSTANCE = new EnsureInitialized();
384     }
385 
386     private void ensureInitialized() {
387         if (checkInitialized(member)) {
388             // The coast is clear.  Delete the &lt;clinit&gt; barrier.
389             if (member.isField())
390                 updateForm(preparedFieldLambdaForm(member));
391             else
392                 updateForm(preparedLambdaForm(member));
393         }
394     }
395     private static boolean checkInitialized(MemberName member) {
396         Class&lt;?&gt; defc = member.getDeclaringClass();
397         WeakReference&lt;Thread&gt; ref = EnsureInitialized.INSTANCE.get(defc);
398         if (ref == null) {
399             return true;  // the final state
400         }
401         Thread clinitThread = ref.get();
402         // Somebody may still be running defc.&lt;clinit&gt;.
403         if (clinitThread == Thread.currentThread()) {
404             // If anybody is running defc.&lt;clinit&gt;, it is this thread.
405             if (UNSAFE.shouldBeInitialized(defc))
406                 // Yes, we are running it; keep the barrier for now.
407                 return false;
408         } else {
409             // We are in a random thread.  Block.
410             UNSAFE.ensureClassInitialized(defc);
411         }
412         assert(!UNSAFE.shouldBeInitialized(defc));
413         // put it into the final state
414         EnsureInitialized.INSTANCE.remove(defc);
415         return true;
416     }
417 
418     /*non-public*/
419     static void ensureInitialized(Object mh) {
420         ((DirectMethodHandle)mh).ensureInitialized();
421     }
422 
423     /** This subclass represents invokespecial instructions. */
424     static class Special extends DirectMethodHandle {
425         private final Class&lt;?&gt; caller;
426         private Special(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; caller) {
427             super(mtype, form, member, crackable);
428             this.caller = caller;
429         }
430         @Override
431         boolean isInvokeSpecial() {
432             return true;
433         }
434         @Override
435         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
436             return new Special(mt, lf, member, crackable, caller);
437         }
438         @Override
439         MethodHandle viewAsType(MethodType newType, boolean strict) {
440             assert(viewAsTypeChecks(newType, strict));
441             return new Special(newType, form, member, false, caller);
442         }
443         Object checkReceiver(Object recv) {
444             if (!caller.isInstance(recv)) {
445                 String msg = String.format(&quot;Receiver class %s is not a subclass of caller class %s&quot;,
446                                            recv.getClass().getName(), caller.getName());
447                 throw new IncompatibleClassChangeError(msg);
448             }
449             return recv;
450         }
451     }
452 
453     /** This subclass represents invokeinterface instructions. */
454     static class Interface extends DirectMethodHandle {
455         private final Class&lt;?&gt; refc;
456         private Interface(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; refc) {
457             super(mtype, form, member, crackable);
458             assert(refc.isInterface()) : refc;
459             this.refc = refc;
460         }
461         @Override
462         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
463             return new Interface(mt, lf, member, crackable, refc);
464         }
465         @Override
466         MethodHandle viewAsType(MethodType newType, boolean strict) {
467             assert(viewAsTypeChecks(newType, strict));
468             return new Interface(newType, form, member, false, refc);
469         }
470         @Override
471         Object checkReceiver(Object recv) {
472             if (!refc.isInstance(recv)) {
473                 String msg = String.format(&quot;Receiver class %s does not implement the requested interface %s&quot;,
474                                            recv.getClass().getName(), refc.getName());
475                 throw new IncompatibleClassChangeError(msg);
476             }
477             return recv;
478         }
479     }
480 
481     /** Used for interface receiver type checks, by Interface and Special modes. */
482     Object checkReceiver(Object recv) {
483         throw new InternalError(&quot;Should only be invoked on a subclass&quot;);
484     }
485 
486     /** This subclass handles constructor references. */
487     static class Constructor extends DirectMethodHandle {
488         final MemberName initMethod;
489         final Class&lt;?&gt;   instanceClass;
490 
491         private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
492                             boolean crackable, MemberName initMethod, Class&lt;?&gt; instanceClass) {
493             super(mtype, form, constructor, crackable);
494             this.initMethod = initMethod;
495             this.instanceClass = instanceClass;
496             assert(initMethod.isResolved());
497         }
498         @Override
499         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
500             return new Constructor(mt, lf, member, crackable, initMethod, instanceClass);
501         }
502         @Override
503         MethodHandle viewAsType(MethodType newType, boolean strict) {
504             assert(viewAsTypeChecks(newType, strict));
505             return new Constructor(newType, form, member, false, initMethod, instanceClass);
506         }
507     }
508 
509     /*non-public*/
510     static Object constructorMethod(Object mh) {
511         Constructor dmh = (Constructor)mh;
512         return dmh.initMethod;
513     }
514 
515     /*non-public*/
516     static Object allocateInstance(Object mh) throws InstantiationException {
517         Constructor dmh = (Constructor)mh;
518         return UNSAFE.allocateInstance(dmh.instanceClass);
519     }
520 
521     /** This subclass handles non-static field references. */
<a name="8" id="anc8"></a><span class="line-modified">522     static class Accessor extends DirectMethodHandle {</span>
523         final Class&lt;?&gt; fieldType;
524         final int      fieldOffset;
525         private Accessor(MethodType mtype, LambdaForm form, MemberName member,
526                          boolean crackable, int fieldOffset) {
527             super(mtype, form, member, crackable);
528             this.fieldType   = member.getFieldType();
529             this.fieldOffset = fieldOffset;
530         }
<a name="9" id="anc9"></a>









531 
532         @Override Object checkCast(Object obj) {
533             return fieldType.cast(obj);
534         }
535         @Override
536         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<a name="10" id="anc10"></a><span class="line-modified">537             return new Accessor(mt, lf, member, crackable, fieldOffset);</span>
538         }
539         @Override
540         MethodHandle viewAsType(MethodType newType, boolean strict) {
541             assert(viewAsTypeChecks(newType, strict));
<a name="11" id="anc11"></a><span class="line-modified">542             return new Accessor(newType, form, member, false, fieldOffset);</span>
















543         }
544     }
545 
546     @ForceInline
547     /*non-public*/
548     static long fieldOffset(Object accessorObj) {
549         // Note: We return a long because that is what Unsafe.getObject likes.
550         // We store a plain int because it is more compact.
551         return ((Accessor)accessorObj).fieldOffset;
552     }
553 
554     @ForceInline
555     /*non-public*/
556     static Object checkBase(Object obj) {
557         // Note that the object&#39;s class has already been verified,
558         // since the parameter type of the Accessor method handle
559         // is either member.getDeclaringClass or a subclass.
560         // This was verified in DirectMethodHandle.make.
561         // Therefore, the only remaining check is for null.
562         // Since this check is *not* guaranteed by Unsafe.getInt
563         // and its siblings, we need to make an explicit one here.
564         return Objects.requireNonNull(obj);
565     }
566 
<a name="12" id="anc12"></a><span class="line-modified">567     /** This subclass handles static field references. */</span>
<span class="line-modified">568     static class StaticAccessor extends DirectMethodHandle {</span>
<span class="line-modified">569         private final Class&lt;?&gt; fieldType;</span>
<span class="line-modified">570         private final Object   staticBase;</span>
<span class="line-removed">571         private final long     staticOffset;</span>
572 
573         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
574                                boolean crackable, Object staticBase, long staticOffset) {
575             super(mtype, form, member, crackable);
576             this.fieldType    = member.getFieldType();
577             this.staticBase   = staticBase;
578             this.staticOffset = staticOffset;
579         }
<a name="13" id="anc13"></a>









580 
<a name="14" id="anc14"></a>
581         @Override Object checkCast(Object obj) {
582             return fieldType.cast(obj);
583         }
584         @Override
585         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<a name="15" id="anc15"></a><span class="line-modified">586             return new StaticAccessor(mt, lf, member, crackable, staticBase, staticOffset);</span>
587         }
588         @Override
589         MethodHandle viewAsType(MethodType newType, boolean strict) {
590             assert(viewAsTypeChecks(newType, strict));
<a name="16" id="anc16"></a><span class="line-modified">591             return new StaticAccessor(newType, form, member, false, staticBase, staticOffset);</span>


















592         }
593     }
594 
595     @ForceInline
596     /*non-public*/
597     static Object nullCheck(Object obj) {
598         return Objects.requireNonNull(obj);
599     }
600 
601     @ForceInline
602     /*non-public*/
603     static Object staticBase(Object accessorObj) {
604         return ((StaticAccessor)accessorObj).staticBase;
605     }
606 
607     @ForceInline
608     /*non-public*/
609     static long staticOffset(Object accessorObj) {
610         return ((StaticAccessor)accessorObj).staticOffset;
611     }
612 
613     @ForceInline
614     /*non-public*/
615     static Object checkCast(Object mh, Object obj) {
616         return ((DirectMethodHandle) mh).checkCast(obj);
617     }
618 
<a name="17" id="anc17"></a>









619     Object checkCast(Object obj) {
620         return member.getReturnType().cast(obj);
621     }
622 
623     // Caching machinery for field accessors:
624     static final byte
625             AF_GETFIELD        = 0,
626             AF_PUTFIELD        = 1,
627             AF_GETSTATIC       = 2,
628             AF_PUTSTATIC       = 3,
629             AF_GETSTATIC_INIT  = 4,
630             AF_PUTSTATIC_INIT  = 5,
631             AF_LIMIT           = 6;
632     // Enumerate the different field kinds using Wrapper,
<a name="18" id="anc18"></a><span class="line-modified">633     // with an extra case added for checked references.</span>
634     static final int
<a name="19" id="anc19"></a><span class="line-modified">635             FT_LAST_WRAPPER    = Wrapper.COUNT-1,</span>
<span class="line-modified">636             FT_UNCHECKED_REF   = Wrapper.OBJECT.ordinal(),</span>
<span class="line-modified">637             FT_CHECKED_REF     = FT_LAST_WRAPPER+1,</span>
<span class="line-modified">638             FT_LIMIT           = FT_LAST_WRAPPER+2;</span>
<span class="line-modified">639     private static int afIndex(byte formOp, boolean isVolatile, int ftypeKind) {</span>

640         return ((formOp * FT_LIMIT * 2)
641                 + (isVolatile ? FT_LIMIT : 0)
<a name="20" id="anc20"></a>
642                 + ftypeKind);
643     }
644     @Stable
645     private static final LambdaForm[] ACCESSOR_FORMS
<a name="21" id="anc21"></a><span class="line-modified">646             = new LambdaForm[afIndex(AF_LIMIT, false, 0)];</span>
<span class="line-modified">647     static int ftypeKind(Class&lt;?&gt; ftype) {</span>
648         if (ftype.isPrimitive())
649             return Wrapper.forPrimitiveType(ftype).ordinal();
<a name="22" id="anc22"></a><span class="line-modified">650         else if (VerifyType.isNullReferenceConversion(Object.class, ftype))</span>
651             return FT_UNCHECKED_REF;
<a name="23" id="anc23"></a><span class="line-modified">652         else</span>
<span class="line-modified">653             return FT_CHECKED_REF;</span>

654     }
655 
656     /**
657      * Create a LF which can access the given field.
658      * Cache and share this structure among all fields with
659      * the same basicType and refKind.
660      */
661     private static LambdaForm preparedFieldLambdaForm(MemberName m) {
662         Class&lt;?&gt; ftype = m.getFieldType();
<a name="24" id="anc24"></a><span class="line-removed">663         boolean isVolatile = m.isVolatile();</span>
664         byte formOp;
665         switch (m.getReferenceKind()) {
666         case REF_getField:      formOp = AF_GETFIELD;    break;
667         case REF_putField:      formOp = AF_PUTFIELD;    break;
668         case REF_getStatic:     formOp = AF_GETSTATIC;   break;
669         case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
670         default:  throw new InternalError(m.toString());
671         }
672         if (shouldBeInitialized(m)) {
673             // precompute the barrier-free version:
<a name="25" id="anc25"></a><span class="line-modified">674             preparedFieldLambdaForm(formOp, isVolatile, ftype);</span>
675             assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
676                    (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
677             formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
678         }
<a name="26" id="anc26"></a><span class="line-modified">679         LambdaForm lform = preparedFieldLambdaForm(formOp, isVolatile, ftype);</span>
680         maybeCompile(lform, m);
681         assert(lform.methodType().dropParameterTypes(0, 1)
682                 .equals(m.getInvocationType().basicType()))
683                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
684         return lform;
685     }
<a name="27" id="anc27"></a><span class="line-modified">686     private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, Class&lt;?&gt; ftype) {</span>
<span class="line-modified">687         int ftypeKind = ftypeKind(ftype);</span>
<span class="line-modified">688         int afIndex = afIndex(formOp, isVolatile, ftypeKind);</span>

689         LambdaForm lform = ACCESSOR_FORMS[afIndex];
690         if (lform != null)  return lform;
<a name="28" id="anc28"></a><span class="line-modified">691         lform = makePreparedFieldLambdaForm(formOp, isVolatile, ftypeKind);</span>
692         ACCESSOR_FORMS[afIndex] = lform;  // don&#39;t bother with a CAS
693         return lform;
694     }
695 
696     private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();
697 
<a name="29" id="anc29"></a><span class="line-modified">698     private static Kind getFieldKind(boolean isGetter, boolean isVolatile, Wrapper wrapper) {</span>
699         if (isGetter) {
700             if (isVolatile) {
701                 switch (wrapper) {
702                     case BOOLEAN: return GET_BOOLEAN_VOLATILE;
703                     case BYTE:    return GET_BYTE_VOLATILE;
704                     case SHORT:   return GET_SHORT_VOLATILE;
705                     case CHAR:    return GET_CHAR_VOLATILE;
706                     case INT:     return GET_INT_VOLATILE;
707                     case LONG:    return GET_LONG_VOLATILE;
708                     case FLOAT:   return GET_FLOAT_VOLATILE;
709                     case DOUBLE:  return GET_DOUBLE_VOLATILE;
<a name="30" id="anc30"></a><span class="line-modified">710                     case OBJECT:  return GET_REFERENCE_VOLATILE;</span>
711                 }
712             } else {
713                 switch (wrapper) {
714                     case BOOLEAN: return GET_BOOLEAN;
715                     case BYTE:    return GET_BYTE;
716                     case SHORT:   return GET_SHORT;
717                     case CHAR:    return GET_CHAR;
718                     case INT:     return GET_INT;
719                     case LONG:    return GET_LONG;
720                     case FLOAT:   return GET_FLOAT;
721                     case DOUBLE:  return GET_DOUBLE;
<a name="31" id="anc31"></a><span class="line-modified">722                     case OBJECT:  return GET_REFERENCE;</span>
723                 }
724             }
725         } else {
726             if (isVolatile) {
727                 switch (wrapper) {
728                     case BOOLEAN: return PUT_BOOLEAN_VOLATILE;
729                     case BYTE:    return PUT_BYTE_VOLATILE;
730                     case SHORT:   return PUT_SHORT_VOLATILE;
731                     case CHAR:    return PUT_CHAR_VOLATILE;
732                     case INT:     return PUT_INT_VOLATILE;
733                     case LONG:    return PUT_LONG_VOLATILE;
734                     case FLOAT:   return PUT_FLOAT_VOLATILE;
735                     case DOUBLE:  return PUT_DOUBLE_VOLATILE;
<a name="32" id="anc32"></a><span class="line-modified">736                     case OBJECT:  return PUT_REFERENCE_VOLATILE;</span>
737                 }
738             } else {
739                 switch (wrapper) {
740                     case BOOLEAN: return PUT_BOOLEAN;
741                     case BYTE:    return PUT_BYTE;
742                     case SHORT:   return PUT_SHORT;
743                     case CHAR:    return PUT_CHAR;
744                     case INT:     return PUT_INT;
745                     case LONG:    return PUT_LONG;
746                     case FLOAT:   return PUT_FLOAT;
747                     case DOUBLE:  return PUT_DOUBLE;
<a name="33" id="anc33"></a><span class="line-modified">748                     case OBJECT:  return PUT_REFERENCE;</span>
749                 }
750             }
751         }
752         throw new AssertionError(&quot;Invalid arguments&quot;);
753     }
754 
<a name="34" id="anc34"></a><span class="line-modified">755     static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftypeKind) {</span>





756         boolean isGetter  = (formOp &amp; 1) == (AF_GETFIELD &amp; 1);
757         boolean isStatic  = (formOp &gt;= AF_GETSTATIC);
758         boolean needsInit = (formOp &gt;= AF_GETSTATIC_INIT);
<a name="35" id="anc35"></a><span class="line-modified">759         boolean needsCast = (ftypeKind == FT_CHECKED_REF);</span>
760         Wrapper fw = (needsCast ? Wrapper.OBJECT : ALL_WRAPPERS[ftypeKind]);
761         Class&lt;?&gt; ft = fw.primitiveType();
<a name="36" id="anc36"></a><span class="line-modified">762         assert(ftypeKind(needsCast ? String.class : ft) == ftypeKind);</span>
763 
764         // getObject, putIntVolatile, etc.
<a name="37" id="anc37"></a><span class="line-modified">765         Kind kind = getFieldKind(isGetter, isVolatile, fw);</span>
766 
767         MethodType linkerType;
<a name="38" id="anc38"></a><span class="line-modified">768         if (isGetter)</span>
<span class="line-modified">769             linkerType = MethodType.methodType(ft, Object.class, long.class);</span>
<span class="line-modified">770         else</span>
<span class="line-modified">771             linkerType = MethodType.methodType(void.class, Object.class, long.class, ft);</span>




772         MemberName linker = new MemberName(Unsafe.class, kind.methodName, linkerType, REF_invokeVirtual);
773         try {
774             linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, NoSuchMethodException.class);
775         } catch (ReflectiveOperationException ex) {
776             throw newInternalError(ex);
777         }
778 
779         // What is the external type of the lambda form?
780         MethodType mtype;
781         if (isGetter)
782             mtype = MethodType.methodType(ft);
783         else
784             mtype = MethodType.methodType(void.class, ft);
785         mtype = mtype.basicType();  // erase short to int, etc.
786         if (!isStatic)
787             mtype = mtype.insertParameterTypes(0, Object.class);
788         final int DMH_THIS  = 0;
789         final int ARG_BASE  = 1;
790         final int ARG_LIMIT = ARG_BASE + mtype.parameterCount();
791         // if this is for non-static access, the base pointer is stored at this index:
792         final int OBJ_BASE  = isStatic ? -1 : ARG_BASE;
793         // if this is for write access, the value to be written is stored at this index:
794         final int SET_VALUE  = isGetter ? -1 : ARG_LIMIT - 1;
795         int nameCursor = ARG_LIMIT;
796         final int F_HOLDER  = (isStatic ? nameCursor++ : -1);  // static base if any
797         final int F_OFFSET  = nameCursor++;  // Either static offset or field offset.
798         final int OBJ_CHECK = (OBJ_BASE &gt;= 0 ? nameCursor++ : -1);
799         final int U_HOLDER  = nameCursor++;  // UNSAFE holder
800         final int INIT_BAR  = (needsInit ? nameCursor++ : -1);
<a name="39" id="anc39"></a>
801         final int PRE_CAST  = (needsCast &amp;&amp; !isGetter ? nameCursor++ : -1);
802         final int LINKER_CALL = nameCursor++;
803         final int POST_CAST = (needsCast &amp;&amp; isGetter ? nameCursor++ : -1);
804         final int RESULT    = nameCursor-1;  // either the call or the cast
805         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
806         if (needsInit)
807             names[INIT_BAR] = new Name(getFunction(NF_ensureInitialized), names[DMH_THIS]);
808         if (needsCast &amp;&amp; !isGetter)
809             names[PRE_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[SET_VALUE]);
810         Object[] outArgs = new Object[1 + linkerType.parameterCount()];
<a name="40" id="anc40"></a><span class="line-modified">811         assert(outArgs.length == (isGetter ? 3 : 4));</span>
812         outArgs[0] = names[U_HOLDER] = new Name(getFunction(NF_UNSAFE));
813         if (isStatic) {
814             outArgs[1] = names[F_HOLDER]  = new Name(getFunction(NF_staticBase), names[DMH_THIS]);
815             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_staticOffset), names[DMH_THIS]);
816         } else {
817             outArgs[1] = names[OBJ_CHECK] = new Name(getFunction(NF_checkBase), names[OBJ_BASE]);
818             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_fieldOffset), names[DMH_THIS]);
819         }
<a name="41" id="anc41"></a>




820         if (!isGetter) {
<a name="42" id="anc42"></a><span class="line-modified">821             outArgs[3] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);</span>
822         }
823         for (Object a : outArgs)  assert(a != null);
824         names[LINKER_CALL] = new Name(linker, outArgs);
825         if (needsCast &amp;&amp; isGetter)
826             names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[LINKER_CALL]);
827         for (Name n : names)  assert(n != null);
828 
829         LambdaForm form;
830         if (needsCast || needsInit) {
831             // can&#39;t use the pre-generated form when casting and/or initializing
832             form = new LambdaForm(ARG_LIMIT, names, RESULT);
833         } else {
834             form = new LambdaForm(ARG_LIMIT, names, RESULT, kind);
835         }
836 
837         if (LambdaForm.debugNames()) {
838             // add some detail to the lambdaForm debugname,
839             // significant only for debugging
840             StringBuilder nameBuilder = new StringBuilder(kind.methodName);
841             if (isStatic) {
842                 nameBuilder.append(&quot;Static&quot;);
843             } else {
844                 nameBuilder.append(&quot;Field&quot;);
845             }
846             if (needsCast) {
847                 nameBuilder.append(&quot;Cast&quot;);
848             }
849             if (needsInit) {
850                 nameBuilder.append(&quot;Init&quot;);
851             }
852             LambdaForm.associateWithDebugName(form, nameBuilder.toString());
853         }
854         return form;
855     }
856 
857     /**
858      * Pre-initialized NamedFunctions for bootstrapping purposes.
859      */
860     static final byte NF_internalMemberName = 0,
861             NF_internalMemberNameEnsureInit = 1,
862             NF_ensureInitialized = 2,
863             NF_fieldOffset = 3,
864             NF_checkBase = 4,
865             NF_staticBase = 5,
866             NF_staticOffset = 6,
867             NF_checkCast = 7,
868             NF_allocateInstance = 8,
869             NF_constructorMethod = 9,
870             NF_UNSAFE = 10,
871             NF_checkReceiver = 11,
<a name="43" id="anc43"></a><span class="line-modified">872             NF_LIMIT = 12;</span>


873 
874     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
875 
876     private static NamedFunction getFunction(byte func) {
877         NamedFunction nf = NFS[func];
878         if (nf != null) {
879             return nf;
880         }
881         // Each nf must be statically invocable or we get tied up in our bootstraps.
882         nf = NFS[func] = createFunction(func);
883         assert(InvokerBytecodeGenerator.isStaticallyInvocable(nf));
884         return nf;
885     }
886 
<a name="44" id="anc44"></a>

887     private static final MethodType OBJ_OBJ_TYPE = MethodType.methodType(Object.class, Object.class);
888 
889     private static final MethodType LONG_OBJ_TYPE = MethodType.methodType(long.class, Object.class);
890 
891     private static NamedFunction createFunction(byte func) {
892         try {
893             switch (func) {
894                 case NF_internalMemberName:
895                     return getNamedFunction(&quot;internalMemberName&quot;, OBJ_OBJ_TYPE);
896                 case NF_internalMemberNameEnsureInit:
897                     return getNamedFunction(&quot;internalMemberNameEnsureInit&quot;, OBJ_OBJ_TYPE);
898                 case NF_ensureInitialized:
899                     return getNamedFunction(&quot;ensureInitialized&quot;, MethodType.methodType(void.class, Object.class));
900                 case NF_fieldOffset:
901                     return getNamedFunction(&quot;fieldOffset&quot;, LONG_OBJ_TYPE);
902                 case NF_checkBase:
903                     return getNamedFunction(&quot;checkBase&quot;, OBJ_OBJ_TYPE);
904                 case NF_staticBase:
905                     return getNamedFunction(&quot;staticBase&quot;, OBJ_OBJ_TYPE);
906                 case NF_staticOffset:
907                     return getNamedFunction(&quot;staticOffset&quot;, LONG_OBJ_TYPE);
908                 case NF_checkCast:
909                     return getNamedFunction(&quot;checkCast&quot;, MethodType.methodType(Object.class, Object.class, Object.class));
910                 case NF_allocateInstance:
911                     return getNamedFunction(&quot;allocateInstance&quot;, OBJ_OBJ_TYPE);
912                 case NF_constructorMethod:
913                     return getNamedFunction(&quot;constructorMethod&quot;, OBJ_OBJ_TYPE);
914                 case NF_UNSAFE:
915                     MemberName member = new MemberName(MethodHandleStatics.class, &quot;UNSAFE&quot;, Unsafe.class, REF_getField);
916                     return new NamedFunction(
917                             MemberName.getFactory()
918                                     .resolveOrFail(REF_getField, member, DirectMethodHandle.class, NoSuchMethodException.class));
919                 case NF_checkReceiver:
920                     member = new MemberName(DirectMethodHandle.class, &quot;checkReceiver&quot;, OBJ_OBJ_TYPE, REF_invokeVirtual);
921                     return new NamedFunction(
922                         MemberName.getFactory()
923                             .resolveOrFail(REF_invokeVirtual, member, DirectMethodHandle.class, NoSuchMethodException.class));
<a name="45" id="anc45"></a>



924                 default:
925                     throw newInternalError(&quot;Unknown function: &quot; + func);
926             }
927         } catch (ReflectiveOperationException ex) {
928             throw newInternalError(ex);
929         }
930     }
931 
932     private static NamedFunction getNamedFunction(String name, MethodType type)
933         throws ReflectiveOperationException
934     {
935         MemberName member = new MemberName(DirectMethodHandle.class, name, type, REF_invokeStatic);
936         return new NamedFunction(
937             MemberName.getFactory()
938                 .resolveOrFail(REF_invokeStatic, member, DirectMethodHandle.class, NoSuchMethodException.class));
939     }
940 
941     static {
942         // The Holder class will contain pre-generated DirectMethodHandles resolved
943         // speculatively using MemberName.getFactory().resolveOrNull. However, that
944         // doesn&#39;t initialize the class, which subtly breaks inlining etc. By forcing
945         // initialization of the Holder class we avoid these issues.
946         UNSAFE.ensureClassInitialized(Holder.class);
947     }
948 
949     /* Placeholder class for DirectMethodHandles generated ahead of time */
950     final class Holder {}
951 }
<a name="46" id="anc46"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="46" type="hidden" />
</body>
</html>
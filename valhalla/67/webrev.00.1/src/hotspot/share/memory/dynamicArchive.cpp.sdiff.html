<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/dynamicArchive.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../interpreter/linkResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/dynamicArchive.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 244         if (orig_ref-&gt;msotype() == MetaspaceObj::ClassType) {
 245           Klass* k = (Klass*)orig_obj;
 246           assert(k-&gt;is_instance_klass() &amp;&amp;
 247                  SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k)),
 248                  &quot;orig_obj must be excluded Class&quot;);
 249         }
 250       }
 251 #endif
 252 
 253       log_debug(cds, dynamic)(&quot;Relocating &quot; PTR_FORMAT &quot; %s&quot;, p2i(new_obj),
 254                               MetaspaceObj::type_name(orig_ref-&gt;msotype()));
 255       if (new_obj != NULL) {
 256         EmbeddedRefUpdater updater(_builder, orig_obj, new_obj);
 257         orig_ref-&gt;metaspace_pointers_do(&amp;updater);
 258       }
 259 
 260       return true; // keep recursing until every object is visited exactly once.
 261     }
 262 
 263     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
<span class="line-modified"> 264       assert(type == _method_entry_ref, &quot;only special type allowed for now&quot;);</span>

 265       address obj = ref-&gt;obj();
 266       address new_obj = _builder-&gt;get_new_loc(ref);
 267       size_t offset = pointer_delta(p, obj,  sizeof(u1));
 268       intptr_t* new_p = (intptr_t*)(new_obj + offset);
<span class="line-modified"> 269       assert(*p == *new_p, &quot;must be a copy&quot;);</span>













 270       ArchivePtrMarker::mark_pointer((address*)new_p);
 271     }
 272   };
 273 
 274   class EmbeddedRefUpdater: public MetaspaceClosure {
 275     DynamicArchiveBuilder* _builder;
 276     address _orig_obj;
 277     address _new_obj;
 278   public:
 279     EmbeddedRefUpdater(DynamicArchiveBuilder* shuffler, address orig_obj, address new_obj) :
 280       _builder(shuffler), _orig_obj(orig_obj), _new_obj(new_obj) {}
 281 
 282     // This method gets called once for each pointer field F of orig_obj.
 283     // We update new_obj-&gt;F to point to the new location of orig_obj-&gt;F.
 284     //
 285     // Example: Klass*  0x100 is copied to 0x400
 286     //          Symbol* 0x200 is copied to 0x500
 287     //
 288     // Let orig_obj == 0x100; and
 289     //     new_obj  == 0x400; and
</pre>
<hr />
<pre>
 771   }
 772   _header-&gt;populate(base_info, os::vm_allocation_granularity());
 773 }
 774 
 775 void DynamicArchiveBuilder::release_header() {
 776   // We temporarily allocated a dynamic FileMapInfo for dumping, which makes it appear we
 777   // have mapped a dynamic archive, but we actually have not. We are in a safepoint now.
 778   // Let&#39;s free it so that if class loading happens after we leave the safepoint, nothing
 779   // bad will happen.
 780   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be&quot;);
 781   FileMapInfo *mapinfo = FileMapInfo::dynamic_info();
 782   assert(mapinfo != NULL &amp;&amp; _header == mapinfo-&gt;dynamic_header(), &quot;must be&quot;);
 783   delete mapinfo;
 784   assert(!DynamicArchive::is_mapped(), &quot;must be&quot;);
 785   _header = NULL;
 786 }
 787 
 788 size_t DynamicArchiveBuilder::estimate_trampoline_size() {
 789   size_t total = 0;
 790   size_t each_method_bytes =
<span class="line-modified"> 791     align_up(SharedRuntime::trampoline_size(), BytesPerWord) +</span>
 792     align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);
 793 
 794   for (int i = 0; i &lt; _klasses-&gt;length(); i++) {
 795     InstanceKlass* ik = _klasses-&gt;at(i);
 796     Array&lt;Method*&gt;* methods = ik-&gt;methods();
 797     total += each_method_bytes * methods-&gt;length();
 798   }
 799   if (total == 0) {
 800     // We have nothing to archive, but let&#39;s avoid having an empty region.
 801     total = SharedRuntime::trampoline_size();
 802   }
 803   return total;
 804 }
 805 
 806 void DynamicArchiveBuilder::make_trampolines() {
 807   DumpRegion* mc_space = MetaspaceShared::misc_code_dump_space();
 808   char* p = mc_space-&gt;base();
 809   for (int i = 0; i &lt; _klasses-&gt;length(); i++) {
 810     InstanceKlass* ik = _klasses-&gt;at(i);
 811     Array&lt;Method*&gt;* methods = ik-&gt;methods();
 812     for (int j = 0; j &lt; methods-&gt;length(); j++) {
 813       Method* m = methods-&gt;at(j);


 814       address c2i_entry_trampoline = (address)p;
 815       p += SharedRuntime::trampoline_size();
 816       assert(p &gt;= mc_space-&gt;base() &amp;&amp; p &lt;= mc_space-&gt;top(), &quot;must be&quot;);
 817       m-&gt;set_from_compiled_entry(to_target(c2i_entry_trampoline));
 818 










 819       AdapterHandlerEntry** adapter_trampoline =(AdapterHandlerEntry**)p;
 820       p += sizeof(AdapterHandlerEntry*);
 821       assert(p &gt;= mc_space-&gt;base() &amp;&amp; p &lt;= mc_space-&gt;top(), &quot;must be&quot;);
 822       *adapter_trampoline = NULL;
 823       m-&gt;set_adapter_trampoline(to_target(adapter_trampoline));
 824     }
 825   }
 826 
 827   guarantee(p &lt;= mc_space-&gt;top(), &quot;Estimate of trampoline size is insufficient&quot;);
 828 }
 829 
 830 void DynamicArchiveBuilder::make_klasses_shareable() {
 831   int i, count = _klasses-&gt;length();
 832 
 833   InstanceKlass::disable_method_binary_search();
 834   for (i = 0; i &lt; count; i++) {
 835     InstanceKlass* ik = _klasses-&gt;at(i);
 836     sort_methods(ik);
 837   }
 838 
</pre>
</td>
<td>
<hr />
<pre>
 244         if (orig_ref-&gt;msotype() == MetaspaceObj::ClassType) {
 245           Klass* k = (Klass*)orig_obj;
 246           assert(k-&gt;is_instance_klass() &amp;&amp;
 247                  SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k)),
 248                  &quot;orig_obj must be excluded Class&quot;);
 249         }
 250       }
 251 #endif
 252 
 253       log_debug(cds, dynamic)(&quot;Relocating &quot; PTR_FORMAT &quot; %s&quot;, p2i(new_obj),
 254                               MetaspaceObj::type_name(orig_ref-&gt;msotype()));
 255       if (new_obj != NULL) {
 256         EmbeddedRefUpdater updater(_builder, orig_obj, new_obj);
 257         orig_ref-&gt;metaspace_pointers_do(&amp;updater);
 258       }
 259 
 260       return true; // keep recursing until every object is visited exactly once.
 261     }
 262 
 263     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
<span class="line-modified"> 264       // TODO:CDS - JDK-8234693 will consolidate this with an almost identical method in metaspaceShared.cpp</span>
<span class="line-added"> 265       assert_valid(type);</span>
 266       address obj = ref-&gt;obj();
 267       address new_obj = _builder-&gt;get_new_loc(ref);
 268       size_t offset = pointer_delta(p, obj,  sizeof(u1));
 269       intptr_t* new_p = (intptr_t*)(new_obj + offset);
<span class="line-modified"> 270       switch (type) {</span>
<span class="line-added"> 271       case _method_entry_ref:</span>
<span class="line-added"> 272         assert(*p == *new_p, &quot;must be a copy&quot;);</span>
<span class="line-added"> 273         break;</span>
<span class="line-added"> 274       case _internal_pointer_ref:</span>
<span class="line-added"> 275         {</span>
<span class="line-added"> 276           size_t off = pointer_delta(*((address*)p), obj, sizeof(u1));</span>
<span class="line-added"> 277           assert(0 &lt;= intx(off) &amp;&amp; intx(off) &lt; ref-&gt;size() * BytesPerWord, &quot;must point to internal address&quot;);</span>
<span class="line-added"> 278           *((address*)new_p) = new_obj + off;</span>
<span class="line-added"> 279         }</span>
<span class="line-added"> 280         break;</span>
<span class="line-added"> 281       default:</span>
<span class="line-added"> 282         ShouldNotReachHere();</span>
<span class="line-added"> 283       }</span>
 284       ArchivePtrMarker::mark_pointer((address*)new_p);
 285     }
 286   };
 287 
 288   class EmbeddedRefUpdater: public MetaspaceClosure {
 289     DynamicArchiveBuilder* _builder;
 290     address _orig_obj;
 291     address _new_obj;
 292   public:
 293     EmbeddedRefUpdater(DynamicArchiveBuilder* shuffler, address orig_obj, address new_obj) :
 294       _builder(shuffler), _orig_obj(orig_obj), _new_obj(new_obj) {}
 295 
 296     // This method gets called once for each pointer field F of orig_obj.
 297     // We update new_obj-&gt;F to point to the new location of orig_obj-&gt;F.
 298     //
 299     // Example: Klass*  0x100 is copied to 0x400
 300     //          Symbol* 0x200 is copied to 0x500
 301     //
 302     // Let orig_obj == 0x100; and
 303     //     new_obj  == 0x400; and
</pre>
<hr />
<pre>
 785   }
 786   _header-&gt;populate(base_info, os::vm_allocation_granularity());
 787 }
 788 
 789 void DynamicArchiveBuilder::release_header() {
 790   // We temporarily allocated a dynamic FileMapInfo for dumping, which makes it appear we
 791   // have mapped a dynamic archive, but we actually have not. We are in a safepoint now.
 792   // Let&#39;s free it so that if class loading happens after we leave the safepoint, nothing
 793   // bad will happen.
 794   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be&quot;);
 795   FileMapInfo *mapinfo = FileMapInfo::dynamic_info();
 796   assert(mapinfo != NULL &amp;&amp; _header == mapinfo-&gt;dynamic_header(), &quot;must be&quot;);
 797   delete mapinfo;
 798   assert(!DynamicArchive::is_mapped(), &quot;must be&quot;);
 799   _header = NULL;
 800 }
 801 
 802 size_t DynamicArchiveBuilder::estimate_trampoline_size() {
 803   size_t total = 0;
 804   size_t each_method_bytes =
<span class="line-modified"> 805     align_up(SharedRuntime::trampoline_size(), BytesPerWord) * 3 +</span>
 806     align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);
 807 
 808   for (int i = 0; i &lt; _klasses-&gt;length(); i++) {
 809     InstanceKlass* ik = _klasses-&gt;at(i);
 810     Array&lt;Method*&gt;* methods = ik-&gt;methods();
 811     total += each_method_bytes * methods-&gt;length();
 812   }
 813   if (total == 0) {
 814     // We have nothing to archive, but let&#39;s avoid having an empty region.
 815     total = SharedRuntime::trampoline_size();
 816   }
 817   return total;
 818 }
 819 
 820 void DynamicArchiveBuilder::make_trampolines() {
 821   DumpRegion* mc_space = MetaspaceShared::misc_code_dump_space();
 822   char* p = mc_space-&gt;base();
 823   for (int i = 0; i &lt; _klasses-&gt;length(); i++) {
 824     InstanceKlass* ik = _klasses-&gt;at(i);
 825     Array&lt;Method*&gt;* methods = ik-&gt;methods();
 826     for (int j = 0; j &lt; methods-&gt;length(); j++) {
 827       Method* m = methods-&gt;at(j);
<span class="line-added"> 828 </span>
<span class="line-added"> 829       // TODO:CDS - JDK-8234693 will consolidate this with Method::unlink()</span>
 830       address c2i_entry_trampoline = (address)p;
 831       p += SharedRuntime::trampoline_size();
 832       assert(p &gt;= mc_space-&gt;base() &amp;&amp; p &lt;= mc_space-&gt;top(), &quot;must be&quot;);
 833       m-&gt;set_from_compiled_entry(to_target(c2i_entry_trampoline));
 834 
<span class="line-added"> 835       address c2i_value_ro_entry_trampoline = (address)p;</span>
<span class="line-added"> 836       p += SharedRuntime::trampoline_size();</span>
<span class="line-added"> 837       assert(p &gt;= mc_space-&gt;base() &amp;&amp; p &lt;= mc_space-&gt;top(), &quot;must be&quot;);</span>
<span class="line-added"> 838       m-&gt;set_from_compiled_value_ro_entry(to_target(c2i_value_ro_entry_trampoline));</span>
<span class="line-added"> 839 </span>
<span class="line-added"> 840       address c2i_value_entry_trampoline = (address)p;</span>
<span class="line-added"> 841       p +=  SharedRuntime::trampoline_size();</span>
<span class="line-added"> 842       assert(p &gt;= mc_space-&gt;base() &amp;&amp; p &lt;= mc_space-&gt;top(), &quot;must be&quot;);</span>
<span class="line-added"> 843       m-&gt;set_from_compiled_value_entry(to_target(c2i_value_entry_trampoline));</span>
<span class="line-added"> 844 </span>
 845       AdapterHandlerEntry** adapter_trampoline =(AdapterHandlerEntry**)p;
 846       p += sizeof(AdapterHandlerEntry*);
 847       assert(p &gt;= mc_space-&gt;base() &amp;&amp; p &lt;= mc_space-&gt;top(), &quot;must be&quot;);
 848       *adapter_trampoline = NULL;
 849       m-&gt;set_adapter_trampoline(to_target(adapter_trampoline));
 850     }
 851   }
 852 
 853   guarantee(p &lt;= mc_space-&gt;top(), &quot;Estimate of trampoline size is insufficient&quot;);
 854 }
 855 
 856 void DynamicArchiveBuilder::make_klasses_shareable() {
 857   int i, count = _klasses-&gt;length();
 858 
 859   InstanceKlass::disable_method_binary_search();
 860   for (i = 0; i &lt; count; i++) {
 861     InstanceKlass* ik = _klasses-&gt;at(i);
 862     sort_methods(ik);
 863   }
 864 
</pre>
</td>
</tr>
</table>
<center><a href="../interpreter/linkResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
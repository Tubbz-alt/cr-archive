<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="dynamicArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/arrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
  44 #include &quot;memory/archiveUtils.inline.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/instanceRefKlass.hpp&quot;
  57 #include &quot;oops/methodData.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayKlass.hpp&quot;


  62 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  63 #include &quot;runtime/handles.inline.hpp&quot;
  64 #include &quot;runtime/os.hpp&quot;
  65 #include &quot;runtime/safepointVerifiers.hpp&quot;
  66 #include &quot;runtime/signature.hpp&quot;
  67 #include &quot;runtime/timerTrace.hpp&quot;
  68 #include &quot;runtime/vmThread.hpp&quot;
  69 #include &quot;runtime/vmOperations.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/bitMap.inline.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/hashtable.inline.hpp&quot;
  74 #if INCLUDE_G1GC
  75 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  76 #endif
  77 
  78 ReservedSpace MetaspaceShared::_shared_rs;
  79 VirtualSpace MetaspaceShared::_shared_vs;
  80 ReservedSpace MetaspaceShared::_symbol_rs;
  81 VirtualSpace MetaspaceShared::_symbol_vs;
</pre>
<hr />
<pre>
 655     fp.fingerprint();
 656   }
 657 }
 658 
 659 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 660 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 661 //
 662 // Addresses of the vtables and the methods may be different across JVM runs,
 663 // if libjvm.so is dynamically loaded at a different base address.
 664 //
 665 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 666 //
 667 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 668 //                  the CDS image
 669 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 670 //                  into our own tables.
 671 
 672 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 673 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 674   f(ConstantPool) \
<span class="line-modified"> 675   f(InstanceKlass) \</span>
 676   f(InstanceClassLoaderKlass) \
 677   f(InstanceMirrorKlass) \
 678   f(InstanceRefKlass) \
 679   f(Method) \
 680   f(ObjArrayKlass) \
<span class="line-modified"> 681   f(TypeArrayKlass)</span>


 682 
 683 class CppVtableInfo {
 684   intptr_t _vtable_size;
 685   intptr_t _cloned_vtable[1];
 686 public:
 687   static int num_slots(int vtable_size) {
 688     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 689   }
 690   int vtable_size()           { return int(uintx(_vtable_size)); }
 691   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 692   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 693   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 694   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 695   static size_t byte_size(int vtable_size) {
 696     CppVtableInfo i;
 697     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 698   }
 699 };
 700 
 701 template &lt;class T&gt; class CppVtableCloner : public T {
</pre>
<hr />
<pre>
 849   Arguments::assert_is_dumping_archive();
 850   int kind = -1;
 851   switch (msotype) {
 852   case MetaspaceObj::SymbolType:
 853   case MetaspaceObj::TypeArrayU1Type:
 854   case MetaspaceObj::TypeArrayU2Type:
 855   case MetaspaceObj::TypeArrayU4Type:
 856   case MetaspaceObj::TypeArrayU8Type:
 857   case MetaspaceObj::TypeArrayOtherType:
 858   case MetaspaceObj::ConstMethodType:
 859   case MetaspaceObj::ConstantPoolCacheType:
 860   case MetaspaceObj::AnnotationsType:
 861   case MetaspaceObj::MethodCountersType:
 862   case MetaspaceObj::RecordComponentType:
 863     // These have no vtables.
 864     break;
 865   case MetaspaceObj::ClassType:
 866     {
 867       Klass* k = (Klass*)obj;
 868       assert(k-&gt;is_klass(), &quot;must be&quot;);
<span class="line-modified"> 869       if (k-&gt;is_instance_klass()) {</span>


 870         InstanceKlass* ik = InstanceKlass::cast(k);
 871         if (ik-&gt;is_class_loader_instance_klass()) {
 872           kind = InstanceClassLoaderKlass_Kind;
 873         } else if (ik-&gt;is_reference_instance_klass()) {
 874           kind = InstanceRefKlass_Kind;
 875         } else if (ik-&gt;is_mirror_instance_klass()) {
 876           kind = InstanceMirrorKlass_Kind;
 877         } else {
 878           kind = InstanceKlass_Kind;
 879         }
 880       } else if (k-&gt;is_typeArray_klass()) {
 881         kind = TypeArrayKlass_Kind;
 882       } else {
 883         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);
 884         kind = ObjArrayKlass_Kind;
 885       }
 886     }
 887     break;
 888 
 889   case MetaspaceObj::MethodType:
</pre>
<hr />
<pre>
1275     ShallowCopier(bool read_only) : _read_only(read_only) {}
1276 
1277     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1278       if (read_only == _read_only) {
1279         allocate(ref, read_only);
1280       }
1281       return true; // recurse into ref.obj()
1282     }
1283   };
1284 
1285   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1286   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1287   public:
1288     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1289       address new_loc = get_new_loc(ref);
1290       RefRelocator refer;
1291       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
1292       return true; // recurse into ref.obj()
1293     }
1294     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
<span class="line-modified">1295       assert(type == _method_entry_ref, &quot;only special type allowed for now&quot;);</span>

1296       address obj = ref-&gt;obj();
1297       address new_obj = get_new_loc(ref);
1298       size_t offset = pointer_delta(p, obj,  sizeof(u1));
1299       intptr_t* new_p = (intptr_t*)(new_obj + offset);
<span class="line-modified">1300       assert(*p == *new_p, &quot;must be a copy&quot;);</span>













1301       ArchivePtrMarker::mark_pointer((address*)new_p);
1302     }
1303   };
1304 
1305   // Relocate a reference to point to its shallow copy
1306   class RefRelocator: public MetaspaceClosure {
1307   public:
1308     virtual bool do_ref(Ref* ref, bool read_only) {
1309       if (ref-&gt;not_null()) {
1310         ref-&gt;update(get_new_loc(ref));
1311         ArchivePtrMarker::mark_pointer(ref-&gt;addr());
1312       }
1313       return false; // Do not recurse.
1314     }
1315   };
1316 
1317 #ifdef ASSERT
1318   class IsRefInArchiveChecker: public MetaspaceClosure {
1319   public:
1320     virtual bool do_ref(Ref* ref, bool read_only) {
</pre>
</td>
<td>
<hr />
<pre>
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
  44 #include &quot;memory/archiveUtils.inline.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/instanceRefKlass.hpp&quot;
  57 #include &quot;oops/methodData.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayKlass.hpp&quot;
<span class="line-added">  62 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  63 #include &quot;oops/valueKlass.hpp&quot;</span>
  64 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/os.hpp&quot;
  67 #include &quot;runtime/safepointVerifiers.hpp&quot;
  68 #include &quot;runtime/signature.hpp&quot;
  69 #include &quot;runtime/timerTrace.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;runtime/vmOperations.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/bitMap.inline.hpp&quot;
  74 #include &quot;utilities/defaultStream.hpp&quot;
  75 #include &quot;utilities/hashtable.inline.hpp&quot;
  76 #if INCLUDE_G1GC
  77 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  78 #endif
  79 
  80 ReservedSpace MetaspaceShared::_shared_rs;
  81 VirtualSpace MetaspaceShared::_shared_vs;
  82 ReservedSpace MetaspaceShared::_symbol_rs;
  83 VirtualSpace MetaspaceShared::_symbol_vs;
</pre>
<hr />
<pre>
 657     fp.fingerprint();
 658   }
 659 }
 660 
 661 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 662 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 663 //
 664 // Addresses of the vtables and the methods may be different across JVM runs,
 665 // if libjvm.so is dynamically loaded at a different base address.
 666 //
 667 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 668 //
 669 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 670 //                  the CDS image
 671 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 672 //                  into our own tables.
 673 
 674 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 675 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 676   f(ConstantPool) \
<span class="line-modified"> 677   f(InstanceClassLoaderKlass) \</span>
 678   f(InstanceKlass) \
 679   f(InstanceMirrorKlass) \
 680   f(InstanceRefKlass) \
 681   f(Method) \
 682   f(ObjArrayKlass) \
<span class="line-modified"> 683   f(TypeArrayKlass) \</span>
<span class="line-added"> 684   f(ValueArrayKlass) \</span>
<span class="line-added"> 685   f(ValueKlass)</span>
 686 
 687 class CppVtableInfo {
 688   intptr_t _vtable_size;
 689   intptr_t _cloned_vtable[1];
 690 public:
 691   static int num_slots(int vtable_size) {
 692     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 693   }
 694   int vtable_size()           { return int(uintx(_vtable_size)); }
 695   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 696   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 697   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 698   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 699   static size_t byte_size(int vtable_size) {
 700     CppVtableInfo i;
 701     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 702   }
 703 };
 704 
 705 template &lt;class T&gt; class CppVtableCloner : public T {
</pre>
<hr />
<pre>
 853   Arguments::assert_is_dumping_archive();
 854   int kind = -1;
 855   switch (msotype) {
 856   case MetaspaceObj::SymbolType:
 857   case MetaspaceObj::TypeArrayU1Type:
 858   case MetaspaceObj::TypeArrayU2Type:
 859   case MetaspaceObj::TypeArrayU4Type:
 860   case MetaspaceObj::TypeArrayU8Type:
 861   case MetaspaceObj::TypeArrayOtherType:
 862   case MetaspaceObj::ConstMethodType:
 863   case MetaspaceObj::ConstantPoolCacheType:
 864   case MetaspaceObj::AnnotationsType:
 865   case MetaspaceObj::MethodCountersType:
 866   case MetaspaceObj::RecordComponentType:
 867     // These have no vtables.
 868     break;
 869   case MetaspaceObj::ClassType:
 870     {
 871       Klass* k = (Klass*)obj;
 872       assert(k-&gt;is_klass(), &quot;must be&quot;);
<span class="line-modified"> 873       if (k-&gt;is_value()) {</span>
<span class="line-added"> 874         kind = ValueKlass_Kind;</span>
<span class="line-added"> 875       } else if (k-&gt;is_instance_klass()) {</span>
 876         InstanceKlass* ik = InstanceKlass::cast(k);
 877         if (ik-&gt;is_class_loader_instance_klass()) {
 878           kind = InstanceClassLoaderKlass_Kind;
 879         } else if (ik-&gt;is_reference_instance_klass()) {
 880           kind = InstanceRefKlass_Kind;
 881         } else if (ik-&gt;is_mirror_instance_klass()) {
 882           kind = InstanceMirrorKlass_Kind;
 883         } else {
 884           kind = InstanceKlass_Kind;
 885         }
 886       } else if (k-&gt;is_typeArray_klass()) {
 887         kind = TypeArrayKlass_Kind;
 888       } else {
 889         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);
 890         kind = ObjArrayKlass_Kind;
 891       }
 892     }
 893     break;
 894 
 895   case MetaspaceObj::MethodType:
</pre>
<hr />
<pre>
1281     ShallowCopier(bool read_only) : _read_only(read_only) {}
1282 
1283     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1284       if (read_only == _read_only) {
1285         allocate(ref, read_only);
1286       }
1287       return true; // recurse into ref.obj()
1288     }
1289   };
1290 
1291   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1292   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1293   public:
1294     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1295       address new_loc = get_new_loc(ref);
1296       RefRelocator refer;
1297       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
1298       return true; // recurse into ref.obj()
1299     }
1300     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
<span class="line-modified">1301       assert_valid(type);</span>
<span class="line-added">1302 </span>
1303       address obj = ref-&gt;obj();
1304       address new_obj = get_new_loc(ref);
1305       size_t offset = pointer_delta(p, obj,  sizeof(u1));
1306       intptr_t* new_p = (intptr_t*)(new_obj + offset);
<span class="line-modified">1307       switch (type) {</span>
<span class="line-added">1308       case _method_entry_ref:</span>
<span class="line-added">1309         assert(*p == *new_p, &quot;must be a copy&quot;);</span>
<span class="line-added">1310         break;</span>
<span class="line-added">1311       case _internal_pointer_ref:</span>
<span class="line-added">1312         {</span>
<span class="line-added">1313           size_t off = pointer_delta(*((address*)p), obj, sizeof(u1));</span>
<span class="line-added">1314           assert(0 &lt;= intx(off) &amp;&amp; intx(off) &lt; ref-&gt;size() * BytesPerWord, &quot;must point to internal address&quot;);</span>
<span class="line-added">1315           *((address*)new_p) = new_obj + off;</span>
<span class="line-added">1316         }</span>
<span class="line-added">1317         break;</span>
<span class="line-added">1318       default:</span>
<span class="line-added">1319         ShouldNotReachHere();</span>
<span class="line-added">1320       }</span>
1321       ArchivePtrMarker::mark_pointer((address*)new_p);
1322     }
1323   };
1324 
1325   // Relocate a reference to point to its shallow copy
1326   class RefRelocator: public MetaspaceClosure {
1327   public:
1328     virtual bool do_ref(Ref* ref, bool read_only) {
1329       if (ref-&gt;not_null()) {
1330         ref-&gt;update(get_new_loc(ref));
1331         ArchivePtrMarker::mark_pointer(ref-&gt;addr());
1332       }
1333       return false; // Do not recurse.
1334     }
1335   };
1336 
1337 #ifdef ASSERT
1338   class IsRefInArchiveChecker: public MetaspaceClosure {
1339   public:
1340     virtual bool do_ref(Ref* ref, bool read_only) {
</pre>
</td>
</tr>
</table>
<center><a href="dynamicArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/arrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
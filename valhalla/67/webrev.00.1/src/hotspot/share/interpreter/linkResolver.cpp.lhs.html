<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/defaultMethods.hpp&quot;
  28 #include &quot;classfile/javaClasses.hpp&quot;
  29 #include &quot;classfile/resolutionErrors.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;compiler/compilationPolicy.hpp&quot;
  34 #include &quot;compiler/compileBroker.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  36 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  37 #include &quot;interpreter/bytecode.hpp&quot;
  38 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  39 #include &quot;interpreter/linkResolver.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;logging/logStream.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;oops/constantPool.hpp&quot;
  44 #include &quot;oops/cpCache.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/method.hpp&quot;
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;prims/methodHandles.hpp&quot;
  51 #include &quot;prims/nativeLookup.hpp&quot;
  52 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  53 #include &quot;runtime/frame.inline.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/reflection.hpp&quot;
  56 #include &quot;runtime/safepointVerifiers.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vmThread.hpp&quot;
  60 
  61 //------------------------------------------------------------------------------------------------------------------------
  62 // Implementation of CallInfo
  63 
  64 
  65 void CallInfo::set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS) {
  66   int vtable_index = Method::nonvirtual_vtable_index;
  67   set_common(resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);
  68 }
  69 
  70 
  71 void CallInfo::set_interface(Klass* resolved_klass,
  72                              const methodHandle&amp; resolved_method,
  73                              const methodHandle&amp; selected_method,
  74                              int itable_index, TRAPS) {
  75   // This is only called for interface methods. If the resolved_method
  76   // comes from java/lang/Object, it can be the subject of a virtual call, so
  77   // we should pick the vtable index from the resolved method.
  78   // In that case, the caller must call set_virtual instead of set_interface.
  79   assert(resolved_method-&gt;method_holder()-&gt;is_interface(), &quot;&quot;);
  80   assert(itable_index == resolved_method()-&gt;itable_index(), &quot;&quot;);
  81   set_common(resolved_klass, resolved_method, selected_method, CallInfo::itable_call, itable_index, CHECK);
  82 }
  83 
  84 void CallInfo::set_virtual(Klass* resolved_klass,
  85                            const methodHandle&amp; resolved_method,
  86                            const methodHandle&amp; selected_method,
  87                            int vtable_index, TRAPS) {
  88   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index, &quot;valid index&quot;);
  89   assert(vtable_index &lt; 0 || !resolved_method-&gt;has_vtable_index() || vtable_index == resolved_method-&gt;vtable_index(), &quot;&quot;);
  90   CallKind kind = (vtable_index &gt;= 0 &amp;&amp; !resolved_method-&gt;can_be_statically_bound() ? CallInfo::vtable_call : CallInfo::direct_call);
  91   set_common(resolved_klass, resolved_method, selected_method, kind, vtable_index, CHECK);
  92   assert(!resolved_method-&gt;is_compiled_lambda_form(), &quot;these must be handled via an invokehandle call&quot;);
  93 }
  94 
  95 void CallInfo::set_handle(const methodHandle&amp; resolved_method,
  96                           Handle resolved_appendix, TRAPS) {
  97   set_handle(SystemDictionary::MethodHandle_klass(), resolved_method, resolved_appendix, CHECK);
  98 }
  99 
 100 void CallInfo::set_handle(Klass* resolved_klass,
 101                           const methodHandle&amp; resolved_method,
 102                           Handle resolved_appendix, TRAPS) {
 103   guarantee(resolved_method.not_null(), &quot;resolved method is null&quot;);
 104   assert(resolved_method-&gt;intrinsic_id() == vmIntrinsics::_invokeBasic ||
 105          resolved_method-&gt;is_compiled_lambda_form(),
 106          &quot;linkMethod must return one of these&quot;);
 107   int vtable_index = Method::nonvirtual_vtable_index;
 108   assert(!resolved_method-&gt;has_vtable_index(), &quot;&quot;);
 109   set_common(resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);
 110   _resolved_appendix = resolved_appendix;
 111 }
 112 
 113 void CallInfo::set_common(Klass* resolved_klass,
 114                           const methodHandle&amp; resolved_method,
 115                           const methodHandle&amp; selected_method,
 116                           CallKind kind,
 117                           int index,
 118                           TRAPS) {
 119   assert(resolved_method-&gt;signature() == selected_method-&gt;signature(), &quot;signatures must correspond&quot;);
 120   _resolved_klass  = resolved_klass;
 121   _resolved_method = resolved_method;
 122   _selected_method = selected_method;
 123   _call_kind       = kind;
 124   _call_index      = index;
 125   _resolved_appendix = Handle();
 126   DEBUG_ONLY(verify());  // verify before making side effects
 127 
 128   CompilationPolicy::compile_if_required(selected_method, THREAD);
 129 }
 130 
 131 // utility query for unreflecting a method
 132 CallInfo::CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS) {
 133   Klass* resolved_method_holder = resolved_method-&gt;method_holder();
 134   if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
 135     resolved_klass = resolved_method_holder;
 136   }
 137   _resolved_klass  = resolved_klass;
 138   _resolved_method = methodHandle(THREAD, resolved_method);
 139   _selected_method = methodHandle(THREAD, resolved_method);
 140   // classify:
 141   CallKind kind = CallInfo::unknown_kind;
 142   int index = resolved_method-&gt;vtable_index();
 143   if (resolved_method-&gt;can_be_statically_bound()) {
 144     kind = CallInfo::direct_call;
 145   } else if (!resolved_method_holder-&gt;is_interface()) {
 146     // Could be an Object method inherited into an interface, but still a vtable call.
 147     kind = CallInfo::vtable_call;
 148   } else if (!resolved_klass-&gt;is_interface()) {
 149     // A default or miranda method.  Compute the vtable index.
 150     index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
 151                            _resolved_method);
 152     assert(index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
 153 
 154     kind = CallInfo::vtable_call;
 155   } else if (resolved_method-&gt;has_vtable_index()) {
 156     // Can occur if an interface redeclares a method of Object.
 157 
 158 #ifdef ASSERT
 159     // Ensure that this is really the case.
 160     Klass* object_klass = SystemDictionary::Object_klass();
 161     Method * object_resolved_method = object_klass-&gt;vtable().method_at(index);
 162     assert(object_resolved_method-&gt;name() == resolved_method-&gt;name(),
 163       &quot;Object and interface method names should match at vtable index %d, %s != %s&quot;,
 164       index, object_resolved_method-&gt;name()-&gt;as_C_string(), resolved_method-&gt;name()-&gt;as_C_string());
 165     assert(object_resolved_method-&gt;signature() == resolved_method-&gt;signature(),
 166       &quot;Object and interface method signatures should match at vtable index %d, %s != %s&quot;,
 167       index, object_resolved_method-&gt;signature()-&gt;as_C_string(), resolved_method-&gt;signature()-&gt;as_C_string());
 168 #endif // ASSERT
 169 
 170     kind = CallInfo::vtable_call;
 171   } else {
 172     // A regular interface call.
 173     kind = CallInfo::itable_call;
 174     index = resolved_method-&gt;itable_index();
 175   }
 176   assert(index == Method::nonvirtual_vtable_index || index &gt;= 0, &quot;bad index %d&quot;, index);
 177   _call_kind  = kind;
 178   _call_index = index;
 179   _resolved_appendix = Handle();
 180   // Find or create a ResolvedMethod instance for this Method*
 181   set_resolved_method_name(CHECK);
 182 
 183   DEBUG_ONLY(verify());
 184 }
 185 
 186 void CallInfo::set_resolved_method_name(TRAPS) {
 187   assert(_resolved_method() != NULL, &quot;Should already have a Method*&quot;);
 188   oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(_resolved_method, CHECK);
 189   _resolved_method_name = Handle(THREAD, rmethod_name);
 190 }
 191 
 192 #ifdef ASSERT
 193 void CallInfo::verify() {
 194   switch (call_kind()) {  // the meaning and allowed value of index depends on kind
 195   case CallInfo::direct_call:
 196     if (_call_index == Method::nonvirtual_vtable_index)  break;
 197     // else fall through to check vtable index:
 198   case CallInfo::vtable_call:
 199     assert(resolved_klass()-&gt;verify_vtable_index(_call_index), &quot;&quot;);
 200     break;
 201   case CallInfo::itable_call:
 202     assert(resolved_method()-&gt;method_holder()-&gt;verify_itable_index(_call_index), &quot;&quot;);
 203     break;
 204   case CallInfo::unknown_kind:
 205     assert(call_kind() != CallInfo::unknown_kind, &quot;CallInfo must be set&quot;);
 206     break;
 207   default:
 208     fatal(&quot;Unexpected call kind %d&quot;, call_kind());
 209   }
 210 }
 211 #endif // ASSERT
 212 
 213 #ifndef PRODUCT
 214 void CallInfo::print() {
 215   ResourceMark rm;
 216   const char* kindstr;
 217   switch (_call_kind) {
 218   case direct_call: kindstr = &quot;direct&quot;;  break;
 219   case vtable_call: kindstr = &quot;vtable&quot;;  break;
 220   case itable_call: kindstr = &quot;itable&quot;;  break;
 221   default         : kindstr = &quot;unknown&quot;; break;
 222   }
 223   tty-&gt;print_cr(&quot;Call %s@%d %s&quot;, kindstr, _call_index,
 224                 _resolved_method.is_null() ? &quot;(none)&quot; : _resolved_method-&gt;name_and_sig_as_C_string());
 225 }
 226 #endif
 227 
 228 //------------------------------------------------------------------------------------------------------------------------
 229 // Implementation of LinkInfo
 230 
 231 LinkInfo::LinkInfo(const constantPoolHandle&amp; pool, int index, const methodHandle&amp; current_method, TRAPS) {
 232    // resolve klass
 233   _resolved_klass = pool-&gt;klass_ref_at(index, CHECK);
 234 
 235   // Get name, signature, and static klass
 236   _name          = pool-&gt;name_ref_at(index);
 237   _signature     = pool-&gt;signature_ref_at(index);
 238   _tag           = pool-&gt;tag_ref_at(index);
 239   _current_klass = pool-&gt;pool_holder();
 240   _current_method = current_method;
 241 
 242   // Coming from the constant pool always checks access
 243   _check_access  = true;
 244 }
 245 
 246 LinkInfo::LinkInfo(const constantPoolHandle&amp; pool, int index, TRAPS) {
 247    // resolve klass
 248   _resolved_klass = pool-&gt;klass_ref_at(index, CHECK);
 249 
 250   // Get name, signature, and static klass
 251   _name          = pool-&gt;name_ref_at(index);
 252   _signature     = pool-&gt;signature_ref_at(index);
 253   _tag           = pool-&gt;tag_ref_at(index);
 254   _current_klass = pool-&gt;pool_holder();
 255   _current_method = methodHandle();
 256 
 257   // Coming from the constant pool always checks access
 258   _check_access  = true;
 259 }
 260 
 261 #ifndef PRODUCT
 262 void LinkInfo::print() {
 263   ResourceMark rm;
 264   tty-&gt;print_cr(&quot;Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s&quot;,
 265                 _resolved_klass-&gt;name()-&gt;as_C_string(),
 266                 _name-&gt;as_C_string(),
 267                 _signature-&gt;as_C_string(),
 268                 _current_klass == NULL ? &quot;(none)&quot; : _current_klass-&gt;name()-&gt;as_C_string(),
 269                 _check_access ? &quot;true&quot; : &quot;false&quot;);
 270 }
 271 #endif // PRODUCT
 272 //------------------------------------------------------------------------------------------------------------------------
 273 // Klass resolution
 274 
 275 void LinkResolver::check_klass_accessibility(Klass* ref_klass, Klass* sel_klass, TRAPS) {
 276   Klass* base_klass = sel_klass;
 277   if (sel_klass-&gt;is_objArray_klass()) {
 278     base_klass = ObjArrayKlass::cast(sel_klass)-&gt;bottom_klass();
 279   }
 280   // The element type could be a typeArray - we only need the access
 281   // check if it is a reference to another class.
 282   if (!base_klass-&gt;is_instance_klass()) {
 283     return;  // no relevant check to do
 284   }
 285 
 286   Reflection::VerifyClassAccessResults vca_result =
 287     Reflection::verify_class_access(ref_klass, InstanceKlass::cast(base_klass), true);
 288   if (vca_result != Reflection::ACCESS_OK) {
 289     ResourceMark rm(THREAD);
 290     char* msg = Reflection::verify_class_access_msg(ref_klass,
 291                                                     InstanceKlass::cast(base_klass),
 292                                                     vca_result);
 293     bool same_module = (base_klass-&gt;module() == ref_klass-&gt;module());
 294     if (msg == NULL) {
 295       Exceptions::fthrow(
 296         THREAD_AND_LOCATION,
 297         vmSymbols::java_lang_IllegalAccessError(),
 298         &quot;failed to access class %s from class %s (%s%s%s)&quot;,
 299         base_klass-&gt;external_name(),
 300         ref_klass-&gt;external_name(),
 301         (same_module) ? base_klass-&gt;joint_in_module_of_loader(ref_klass) : base_klass-&gt;class_in_module_of_loader(),
 302         (same_module) ? &quot;&quot; : &quot;; &quot;,
 303         (same_module) ? &quot;&quot; : ref_klass-&gt;class_in_module_of_loader());
 304     } else {
 305       // Use module specific message returned by verify_class_access_msg().
 306       Exceptions::fthrow(
 307         THREAD_AND_LOCATION,
 308         vmSymbols::java_lang_IllegalAccessError(),
 309         &quot;%s&quot;, msg);
 310     }
 311   }
 312 }
 313 
 314 //------------------------------------------------------------------------------------------------------------------------
 315 // Method resolution
 316 //
 317 // According to JVM spec. $5.4.3c &amp; $5.4.3d
 318 
 319 // Look up method in klasses, including static methods
 320 // Then look up local default methods
 321 Method* LinkResolver::lookup_method_in_klasses(const LinkInfo&amp; link_info,
 322                                                bool checkpolymorphism,
 323                                                bool in_imethod_resolve) {
 324   NoSafepointVerifier nsv;  // Method* returned may not be reclaimed
 325 
 326   Klass* klass = link_info.resolved_klass();
 327   Symbol* name = link_info.name();
 328   Symbol* signature = link_info.signature();
 329 
 330   // Ignore overpasses so statics can be found during resolution
 331   Method* result = klass-&gt;uncached_lookup_method(name, signature, Klass::skip_overpass);
 332 
 333   if (klass-&gt;is_array_klass()) {
 334     // Only consider klass and super klass for arrays
 335     return result;
 336   }
 337 
 338   InstanceKlass* ik = InstanceKlass::cast(klass);
 339 
 340   // JDK 8, JVMS 5.4.3.4: Interface method resolution should
 341   // ignore static and non-public methods of java.lang.Object,
 342   // like clone, finalize, registerNatives.
 343   if (in_imethod_resolve &amp;&amp;
 344       result != NULL &amp;&amp;
 345       ik-&gt;is_interface() &amp;&amp;
 346       (result-&gt;is_static() || !result-&gt;is_public()) &amp;&amp;
 347       result-&gt;method_holder() == SystemDictionary::Object_klass()) {
 348     result = NULL;
 349   }
 350 
 351   // Before considering default methods, check for an overpass in the
 352   // current class if a method has not been found.
 353   if (result == NULL) {
 354     result = ik-&gt;find_method(name, signature);
 355   }
 356 
 357   if (result == NULL) {
 358     Array&lt;Method*&gt;* default_methods = ik-&gt;default_methods();
 359     if (default_methods != NULL) {
 360       result = InstanceKlass::find_method(default_methods, name, signature);
 361     }
 362   }
 363 
 364   if (checkpolymorphism &amp;&amp; result != NULL) {
 365     vmIntrinsics::ID iid = result-&gt;intrinsic_id();
 366     if (MethodHandles::is_signature_polymorphic(iid)) {
 367       // Do not link directly to these.  The VM must produce a synthetic one using lookup_polymorphic_method.
 368       return NULL;
 369     }
 370   }
 371   return result;
 372 }
 373 
 374 // returns first instance method
 375 // Looks up method in classes, then looks up local default methods
 376 Method* LinkResolver::lookup_instance_method_in_klasses(Klass* klass,
 377                                                         Symbol* name,
 378                                                         Symbol* signature,
 379                                                         Klass::PrivateLookupMode private_mode, TRAPS) {
 380   Method* result = klass-&gt;uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
 381 
 382   while (result != NULL &amp;&amp; result-&gt;is_static() &amp;&amp; result-&gt;method_holder()-&gt;super() != NULL) {
 383     Klass* super_klass = result-&gt;method_holder()-&gt;super();
 384     result = super_klass-&gt;uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);
 385   }
 386 
 387   if (klass-&gt;is_array_klass()) {
 388     // Only consider klass and super klass for arrays
 389     return result;
 390   }
 391 
 392   if (result == NULL) {
 393     Array&lt;Method*&gt;* default_methods = InstanceKlass::cast(klass)-&gt;default_methods();
 394     if (default_methods != NULL) {
 395       result = InstanceKlass::find_method(default_methods, name, signature);
 396       assert(result == NULL || !result-&gt;is_static(), &quot;static defaults not allowed&quot;);
 397     }
 398   }
 399   return result;
 400 }
 401 
 402 int LinkResolver::vtable_index_of_interface_method(Klass* klass,
 403                                                    const methodHandle&amp; resolved_method) {
 404 
 405   int vtable_index = Method::invalid_vtable_index;
 406   Symbol* name = resolved_method-&gt;name();
 407   Symbol* signature = resolved_method-&gt;signature();
 408   InstanceKlass* ik = InstanceKlass::cast(klass);
 409 
 410   // First check in default method array
 411   if (!resolved_method-&gt;is_abstract() &amp;&amp; ik-&gt;default_methods() != NULL) {
 412     int index = InstanceKlass::find_method_index(ik-&gt;default_methods(),
 413                                                  name, signature, Klass::find_overpass,
 414                                                  Klass::find_static, Klass::find_private);
 415     if (index &gt;= 0 ) {
 416       vtable_index = ik-&gt;default_vtable_indices()-&gt;at(index);
 417     }
 418   }
 419   if (vtable_index == Method::invalid_vtable_index) {
 420     // get vtable_index for miranda methods
 421     klassVtable vt = ik-&gt;vtable();
 422     vtable_index = vt.index_of_miranda(name, signature);
 423   }
 424   return vtable_index;
 425 }
 426 
 427 Method* LinkResolver::lookup_method_in_interfaces(const LinkInfo&amp; cp_info) {
 428   InstanceKlass *ik = InstanceKlass::cast(cp_info.resolved_klass());
 429 
 430   // Specify &#39;true&#39; in order to skip default methods when searching the
 431   // interfaces.  Function lookup_method_in_klasses() already looked for
 432   // the method in the default methods table.
 433   return ik-&gt;lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);
 434 }
 435 
 436 Method* LinkResolver::lookup_polymorphic_method(const LinkInfo&amp; link_info,
 437                                                 Handle *appendix_result_or_null,
 438                                                 TRAPS) {
 439   ResourceMark rm(THREAD);
 440   Klass* klass = link_info.resolved_klass();
 441   Symbol* name = link_info.name();
 442   Symbol* full_signature = link_info.signature();
 443   LogTarget(Info, methodhandles) lt_mh;
 444 
 445   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
 446   log_info(methodhandles)(&quot;lookup_polymorphic_method iid=%s %s.%s%s&quot;,
 447                           vmIntrinsics::name_at(iid), klass-&gt;external_name(),
 448                           name-&gt;as_C_string(), full_signature-&gt;as_C_string());
 449   if ((klass == SystemDictionary::MethodHandle_klass() ||
 450        klass == SystemDictionary::VarHandle_klass()) &amp;&amp;
 451       iid != vmIntrinsics::_none) {
 452     if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
 453       // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
 454       // Do not erase last argument type (MemberName) if it is a static linkTo method.
 455       bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
 456       TempNewSymbol basic_signature =
 457         MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
 458       log_info(methodhandles)(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,
 459                               name-&gt;as_C_string(),
 460                               full_signature-&gt;as_C_string(),
 461                               basic_signature-&gt;as_C_string());
 462       Method* result = SystemDictionary::find_method_handle_intrinsic(iid,
 463                                                               basic_signature,
 464                                                               CHECK_NULL);
 465       if (result != NULL) {
 466         assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
 467         assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
 468         assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
 469         if (lt_mh.is_enabled()) {
 470           LogStream ls(lt_mh);
 471           ls.print(&quot;lookup_polymorphic_method =&gt; intrinsic &quot;);
 472           result-&gt;print_on(&amp;ls);
 473         }
 474       }
 475       return result;
 476     } else if (iid == vmIntrinsics::_invokeGeneric
 477                &amp;&amp; THREAD-&gt;can_call_java()
 478                &amp;&amp; appendix_result_or_null != NULL) {
 479       // This is a method with type-checking semantics.
 480       // We will ask Java code to spin an adapter method for it.
 481       if (!MethodHandles::enabled()) {
 482         // Make sure the Java part of the runtime has been booted up.
 483         Klass* natives = SystemDictionary::MethodHandleNatives_klass();
 484         if (natives == NULL || InstanceKlass::cast(natives)-&gt;is_not_initialized()) {
 485           SystemDictionary::resolve_or_fail(vmSymbols::java_lang_invoke_MethodHandleNatives(),
 486                                             Handle(),
 487                                             Handle(),
 488                                             true,
 489                                             CHECK_NULL);
 490         }
 491       }
 492 
 493       Handle appendix;
 494       Handle method_type;
 495       Method* result = SystemDictionary::find_method_handle_invoker(
 496                                                             klass,
 497                                                             name,
 498                                                             full_signature,
 499                                                             link_info.current_klass(),
 500                                                             &amp;appendix,
 501                                                             CHECK_NULL);
 502       if (lt_mh.is_enabled()) {
 503         LogStream ls(lt_mh);
 504         ls.print(&quot;lookup_polymorphic_method =&gt; (via Java) &quot;);
 505         result-&gt;print_on(&amp;ls);
 506         ls.print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);
 507         appendix.is_null() ? ls.print_cr(&quot;(none)&quot;) : appendix-&gt;print_on(&amp;ls);
 508       }
 509       if (result != NULL) {
 510 #ifdef ASSERT
 511         ResourceMark rm(THREAD);
 512 
 513         TempNewSymbol basic_signature =
 514           MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);
 515         int actual_size_of_params = result-&gt;size_of_parameters();
 516         int expected_size_of_params = ArgumentSizeComputer(basic_signature).size();
 517         // +1 for MethodHandle.this, +1 for trailing MethodType
 518         if (!MethodHandles::is_signature_polymorphic_static(iid))  expected_size_of_params += 1;
 519         if (appendix.not_null())                                   expected_size_of_params += 1;
 520         if (actual_size_of_params != expected_size_of_params) {
 521           tty-&gt;print_cr(&quot;*** basic_signature=%s&quot;, basic_signature-&gt;as_C_string());
 522           tty-&gt;print_cr(&quot;*** result for %s: &quot;, vmIntrinsics::name_at(iid));
 523           result-&gt;print();
 524         }
 525         assert(actual_size_of_params == expected_size_of_params,
 526                &quot;%d != %d&quot;, actual_size_of_params, expected_size_of_params);
 527 #endif //ASSERT
 528 
 529         assert(appendix_result_or_null != NULL, &quot;&quot;);
 530         (*appendix_result_or_null) = appendix;
 531       }
 532       return result;
 533     }
 534   }
 535   return NULL;
 536 }
 537 
 538 static void print_nest_host_error_on(stringStream* ss, Klass* ref_klass, Klass* sel_klass, TRAPS) {
 539   assert(ref_klass-&gt;is_instance_klass(), &quot;must be&quot;);
 540   assert(sel_klass-&gt;is_instance_klass(), &quot;must be&quot;);
 541   InstanceKlass* ref_ik = InstanceKlass::cast(ref_klass);
 542   InstanceKlass* sel_ik = InstanceKlass::cast(sel_klass);
 543   const char* nest_host_error_1 = ref_ik-&gt;nest_host_error(THREAD);
 544   const char* nest_host_error_2 = sel_ik-&gt;nest_host_error(THREAD);
 545   if (nest_host_error_1 != NULL || nest_host_error_2 != NULL) {
 546     ss-&gt;print(&quot;, (%s%s%s)&quot;,
 547               (nest_host_error_1 != NULL) ? nest_host_error_1 : &quot;&quot;,
 548               (nest_host_error_1 != NULL &amp;&amp; nest_host_error_2 != NULL) ? &quot;, &quot; : &quot;&quot;,
 549               (nest_host_error_2 != NULL) ? nest_host_error_2 : &quot;&quot;);
 550   }
 551 }
 552 
 553 void LinkResolver::check_method_accessability(Klass* ref_klass,
 554                                               Klass* resolved_klass,
 555                                               Klass* sel_klass,
 556                                               const methodHandle&amp; sel_method,
 557                                               TRAPS) {
 558 
 559   AccessFlags flags = sel_method-&gt;access_flags();
 560 
 561   // Special case:  arrays always override &quot;clone&quot;. JVMS 2.15.
 562   // If the resolved klass is an array class, and the declaring class
 563   // is java.lang.Object and the method is &quot;clone&quot;, set the flags
 564   // to public.
 565   //
 566   // We&#39;ll check for the method name first, as that&#39;s most likely
 567   // to be false (so we&#39;ll short-circuit out of these tests).
 568   if (sel_method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 569       sel_klass == SystemDictionary::Object_klass() &amp;&amp;
 570       resolved_klass-&gt;is_array_klass()) {
 571     // We need to change &quot;protected&quot; to &quot;public&quot;.
 572     assert(flags.is_protected(), &quot;clone not protected?&quot;);
 573     jint new_flags = flags.as_int();
 574     new_flags = new_flags &amp; (~JVM_ACC_PROTECTED);
 575     new_flags = new_flags | JVM_ACC_PUBLIC;
 576     flags.set_flags(new_flags);
 577   }
 578 //  assert(extra_arg_result_or_null != NULL, &quot;must be able to return extra argument&quot;);
 579 
 580   bool can_access = Reflection::verify_member_access(ref_klass,
 581                                                      resolved_klass,
 582                                                      sel_klass,
 583                                                      flags,
 584                                                      true, false, CHECK);
 585   // Any existing exceptions that may have been thrown
 586   // have been allowed to propagate.
 587   if (!can_access) {
 588     ResourceMark rm(THREAD);
 589     stringStream ss;
 590     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
 591     ss.print(&quot;class %s tried to access %s%s%smethod &#39;%s&#39; (%s%s%s)&quot;,
 592              ref_klass-&gt;external_name(),
 593              sel_method-&gt;is_abstract()  ? &quot;abstract &quot;  : &quot;&quot;,
 594              sel_method-&gt;is_protected() ? &quot;protected &quot; : &quot;&quot;,
 595              sel_method-&gt;is_private()   ? &quot;private &quot;   : &quot;&quot;,
 596              sel_method-&gt;external_name(),
 597              (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),
 598              (same_module) ? &quot;&quot; : &quot;; &quot;,
 599              (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()
 600              );
 601 
 602     // For private access see if there was a problem with nest host
 603     // resolution, and if so report that as part of the message.
 604     if (sel_method-&gt;is_private()) {
 605       print_nest_host_error_on(&amp;ss, ref_klass, sel_klass, THREAD);
 606     }
 607 
 608     Exceptions::fthrow(THREAD_AND_LOCATION,
 609                        vmSymbols::java_lang_IllegalAccessError(),
 610                        &quot;%s&quot;,
 611                        ss.as_string()
 612                        );
 613     return;
 614   }
 615 }
 616 
 617 Method* LinkResolver::resolve_method_statically(Bytecodes::Code code,
 618                                                 const constantPoolHandle&amp; pool, int index, TRAPS) {
 619   // This method is used only
 620   // (1) in C2 from InlineTree::ok_to_inline (via ciMethod::check_call),
 621   // and
 622   // (2) in Bytecode_invoke::static_target
 623   // It appears to fail when applied to an invokeinterface call site.
 624   // FIXME: Remove this method and ciMethod::check_call; refactor to use the other LinkResolver entry points.
 625   // resolve klass
 626   if (code == Bytecodes::_invokedynamic) {
 627     Klass* resolved_klass = SystemDictionary::MethodHandle_klass();
 628     Symbol* method_name = vmSymbols::invoke_name();
 629     Symbol* method_signature = pool-&gt;signature_ref_at(index);
 630     Klass*  current_klass = pool-&gt;pool_holder();
 631     LinkInfo link_info(resolved_klass, method_name, method_signature, current_klass);
 632     return resolve_method(link_info, code, THREAD);
 633   }
 634 
 635   LinkInfo link_info(pool, index, methodHandle(), CHECK_NULL);
 636   Klass* resolved_klass = link_info.resolved_klass();
 637 
 638   if (pool-&gt;has_preresolution()
 639       || (resolved_klass == SystemDictionary::MethodHandle_klass() &amp;&amp;
 640           MethodHandles::is_signature_polymorphic_name(resolved_klass, link_info.name()))) {
 641     Method* result = ConstantPool::method_at_if_loaded(pool, index);
 642     if (result != NULL) {
 643       return result;
 644     }
 645   }
 646 
 647   if (code == Bytecodes::_invokeinterface) {
 648     return resolve_interface_method(link_info, code, THREAD);
 649   } else if (code == Bytecodes::_invokevirtual) {
 650     return resolve_method(link_info, code, THREAD);
 651   } else if (!resolved_klass-&gt;is_interface()) {
 652     return resolve_method(link_info, code, THREAD);
 653   } else {
 654     return resolve_interface_method(link_info, code, THREAD);
 655   }
 656 }
 657 
 658 // Check and print a loader constraint violation message for method or interface method
 659 void LinkResolver::check_method_loader_constraints(const LinkInfo&amp; link_info,
 660                                                    const methodHandle&amp; resolved_method,
 661                                                    const char* method_type, TRAPS) {
 662   Handle current_loader(THREAD, link_info.current_klass()-&gt;class_loader());
 663   Handle resolved_loader(THREAD, resolved_method-&gt;method_holder()-&gt;class_loader());
 664 
 665   ResourceMark rm(THREAD);
 666   Symbol* failed_type_symbol =
 667     SystemDictionary::check_signature_loaders(link_info.signature(),
 668                                               /*klass_being_linked*/ NULL, // We are not linking class
 669                                               current_loader,
 670                                               resolved_loader, true, CHECK);
 671   if (failed_type_symbol != NULL) {
 672     Klass* current_class = link_info.current_klass();
 673     ClassLoaderData* current_loader_data = current_class-&gt;class_loader_data();
 674     assert(current_loader_data != NULL, &quot;current class has no class loader data&quot;);
 675     Klass* resolved_method_class = resolved_method-&gt;method_holder();
 676     ClassLoaderData* target_loader_data = resolved_method_class-&gt;class_loader_data();
 677     assert(target_loader_data != NULL, &quot;resolved method&#39;s class has no class loader data&quot;);
 678 
 679     stringStream ss;
 680     ss.print(&quot;loader constraint violation: when resolving %s &#39;&quot;, method_type);
 681     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());
 682     ss.print(&quot;&#39; the class loader %s of the current class, %s,&quot;
 683              &quot; and the class loader %s for the method&#39;s defining class, %s, have&quot;
 684              &quot; different Class objects for the type %s used in the signature (%s; %s)&quot;,
 685              current_loader_data-&gt;loader_name_and_id(),
 686              current_class-&gt;name()-&gt;as_C_string(),
 687              target_loader_data-&gt;loader_name_and_id(),
 688              resolved_method_class-&gt;name()-&gt;as_C_string(),
 689              failed_type_symbol-&gt;as_C_string(),
 690              current_class-&gt;class_in_module_of_loader(false, true),
 691              resolved_method_class-&gt;class_in_module_of_loader(false, true));
 692     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
 693   }
 694 }
 695 
 696 void LinkResolver::check_field_loader_constraints(Symbol* field, Symbol* sig,
 697                                                   Klass* current_klass,
 698                                                   Klass* sel_klass, TRAPS) {
 699   Handle ref_loader(THREAD, current_klass-&gt;class_loader());
 700   Handle sel_loader(THREAD, sel_klass-&gt;class_loader());
 701 
 702   ResourceMark rm(THREAD);  // needed for check_signature_loaders
 703   Symbol* failed_type_symbol =
 704     SystemDictionary::check_signature_loaders(sig,
 705                                               /*klass_being_linked*/ NULL, // We are not linking class
 706                                               ref_loader, sel_loader,
 707                                               false,
 708                                               CHECK);
 709   if (failed_type_symbol != NULL) {
 710     stringStream ss;
 711     const char* failed_type_name = failed_type_symbol-&gt;as_klass_external_name();
 712 
 713     ss.print(&quot;loader constraint violation: when resolving field \&quot;%s\&quot; of type %s, &quot;
 714              &quot;the class loader %s of the current class, %s, &quot;
 715              &quot;and the class loader %s for the field&#39;s defining %s, %s, &quot;
 716              &quot;have different Class objects for type %s (%s; %s)&quot;,
 717              field-&gt;as_C_string(),
 718              failed_type_name,
 719              current_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 720              current_klass-&gt;external_name(),
 721              sel_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
 722              sel_klass-&gt;external_kind(),
 723              sel_klass-&gt;external_name(),
 724              failed_type_name,
 725              current_klass-&gt;class_in_module_of_loader(false, true),
 726              sel_klass-&gt;class_in_module_of_loader(false, true));
 727     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
 728   }
 729 }
 730 
 731 Method* LinkResolver::resolve_method(const LinkInfo&amp; link_info,
 732                                      Bytecodes::Code code, TRAPS) {
 733 
 734   Handle nested_exception;
 735   Klass* resolved_klass = link_info.resolved_klass();
 736 
 737   // 1. For invokevirtual, cannot call an interface method
 738   if (code == Bytecodes::_invokevirtual &amp;&amp; resolved_klass-&gt;is_interface()) {
 739     ResourceMark rm(THREAD);
 740     char buf[200];
 741     jio_snprintf(buf, sizeof(buf), &quot;Found interface %s, but class was expected&quot;,
 742         resolved_klass-&gt;external_name());
 743     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 744   }
 745 
 746   // 2. check constant pool tag for called method - must be JVM_CONSTANT_Methodref
 747   if (!link_info.tag().is_invalid() &amp;&amp; !link_info.tag().is_method()) {
 748     ResourceMark rm(THREAD);
 749     stringStream ss;
 750     ss.print(&quot;Method &#39;&quot;);
 751     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());
 752     ss.print(&quot;&#39; must be Methodref constant&quot;);
 753     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
 754   }
 755 
 756   // 3. lookup method in resolved klass and its super klasses
 757   methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, true, false));
 758 
 759   // 4. lookup method in all the interfaces implemented by the resolved klass
 760   if (resolved_method.is_null() &amp;&amp; !resolved_klass-&gt;is_array_klass()) { // not found in the class hierarchy
 761     resolved_method = methodHandle(THREAD, lookup_method_in_interfaces(link_info));
 762 
 763     if (resolved_method.is_null()) {
 764       // JSR 292:  see if this is an implicitly generated method MethodHandle.linkToVirtual(*...), etc
 765       Method* method = lookup_polymorphic_method(link_info, (Handle*)NULL, THREAD);
 766       resolved_method = methodHandle(THREAD, method);
 767       if (HAS_PENDING_EXCEPTION) {
 768         nested_exception = Handle(THREAD, PENDING_EXCEPTION);
 769         CLEAR_PENDING_EXCEPTION;
 770       }
 771     }
 772   }
 773 
 774   // 5. method lookup failed
 775   if (resolved_method.is_null()) {
 776     ResourceMark rm(THREAD);
 777     stringStream ss;
 778     ss.print(&quot;&#39;&quot;);
 779     Method::print_external_name(&amp;ss, resolved_klass, link_info.name(), link_info.signature());
 780     ss.print(&quot;&#39;&quot;);
 781     THROW_MSG_CAUSE_(vmSymbols::java_lang_NoSuchMethodError(),
 782                      ss.as_string(), nested_exception, NULL);
 783   }
 784 
 785   // 6. access checks, access checking may be turned off when calling from within the VM.
 786   Klass* current_klass = link_info.current_klass();
 787   if (link_info.check_access()) {
 788     assert(current_klass != NULL , &quot;current_klass should not be null&quot;);
 789 
 790     // check if method can be accessed by the referring class
 791     check_method_accessability(current_klass,
 792                                resolved_klass,
 793                                resolved_method-&gt;method_holder(),
 794                                resolved_method,
 795                                CHECK_NULL);
 796 
 797     // check loader constraints
 798     check_method_loader_constraints(link_info, resolved_method, &quot;method&quot;, CHECK_NULL);
 799   }
 800 
 801   return resolved_method();
 802 }
 803 
 804 static void trace_method_resolution(const char* prefix,
 805                                     Klass* klass,
 806                                     Klass* resolved_klass,
 807                                     Method* method,
 808                                     bool logitables,
 809                                     int index = -1) {
 810 #ifndef PRODUCT
 811   ResourceMark rm;
 812   Log(itables) logi;
 813   LogStream lsi(logi.trace());
 814   Log(vtables) logv;
 815   LogStream lsv(logv.trace());
 816   outputStream* st;
 817   if (logitables) {
 818     st = &amp;lsi;
 819   } else {
 820     st = &amp;lsv;
 821   }
 822   st-&gt;print(&quot;%s%s, compile-time-class:%s, method:%s, method_holder:%s, access_flags: &quot;,
 823             prefix,
 824             (klass == NULL ? &quot;&lt;NULL&gt;&quot; : klass-&gt;internal_name()),
 825             (resolved_klass == NULL ? &quot;&lt;NULL&gt;&quot; : resolved_klass-&gt;internal_name()),
 826             Method::name_and_sig_as_C_string(resolved_klass,
 827                                              method-&gt;name(),
 828                                              method-&gt;signature()),
 829             method-&gt;method_holder()-&gt;internal_name());
 830   method-&gt;print_linkage_flags(st);
 831   if (index != -1) {
 832     st-&gt;print(&quot;vtable_index:%d&quot;, index);
 833   }
 834   st-&gt;cr();
 835 #endif // PRODUCT
 836 }
 837 
 838 // Do linktime resolution of a method in the interface within the context of the specied bytecode.
 839 Method* LinkResolver::resolve_interface_method(const LinkInfo&amp; link_info, Bytecodes::Code code, TRAPS) {
 840 
 841   Klass* resolved_klass = link_info.resolved_klass();
 842 
 843   // check if klass is interface
 844   if (!resolved_klass-&gt;is_interface()) {
 845     ResourceMark rm(THREAD);
 846     char buf[200];
 847     jio_snprintf(buf, sizeof(buf), &quot;Found class %s, but interface was expected&quot;, resolved_klass-&gt;external_name());
 848     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 849   }
 850 
 851   // check constant pool tag for called method - must be JVM_CONSTANT_InterfaceMethodref
 852   if (!link_info.tag().is_invalid() &amp;&amp; !link_info.tag().is_interface_method()) {
 853     ResourceMark rm(THREAD);
 854     stringStream ss;
 855     ss.print(&quot;Method &#39;&quot;);
 856     Method::print_external_name(&amp;ss, link_info.resolved_klass(), link_info.name(), link_info.signature());
 857     ss.print(&quot;&#39; must be InterfaceMethodref constant&quot;);
 858     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
 859   }
 860 
 861   // lookup method in this interface or its super, java.lang.Object
 862   // JDK8: also look for static methods
 863   methodHandle resolved_method(THREAD, lookup_method_in_klasses(link_info, false, true));
 864 
 865   if (resolved_method.is_null() &amp;&amp; !resolved_klass-&gt;is_array_klass()) {
 866     // lookup method in all the super-interfaces
 867     resolved_method = methodHandle(THREAD, lookup_method_in_interfaces(link_info));
 868   }
 869 
 870   if (resolved_method.is_null()) {
 871     // no method found
 872     ResourceMark rm(THREAD);
 873     stringStream ss;
 874     ss.print(&quot;&#39;&quot;);
 875     Method::print_external_name(&amp;ss, resolved_klass, link_info.name(), link_info.signature());
 876     ss.print(&quot;&#39;&quot;);
 877     THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());
 878   }
 879 
 880   if (link_info.check_access()) {
 881     // JDK8 adds non-public interface methods, and accessability check requirement
 882     Klass* current_klass = link_info.current_klass();
 883 
 884     assert(current_klass != NULL , &quot;current_klass should not be null&quot;);
 885 
 886     // check if method can be accessed by the referring class
 887     check_method_accessability(current_klass,
 888                                resolved_klass,
 889                                resolved_method-&gt;method_holder(),
 890                                resolved_method,
 891                                CHECK_NULL);
 892 
 893     check_method_loader_constraints(link_info, resolved_method, &quot;interface method&quot;, CHECK_NULL);
 894   }
 895 
 896   if (code != Bytecodes::_invokestatic &amp;&amp; resolved_method-&gt;is_static()) {
 897     ResourceMark rm(THREAD);
 898     stringStream ss;
 899     ss.print(&quot;Expected instance not static method &#39;&quot;);
 900     Method::print_external_name(&amp;ss, resolved_klass,
 901                                 resolved_method-&gt;name(), resolved_method-&gt;signature());
 902     ss.print(&quot;&#39;&quot;);
 903     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
 904   }
 905 
 906   if (log_develop_is_enabled(Trace, itables)) {
 907     char buf[200];
 908     jio_snprintf(buf, sizeof(buf), &quot;%s resolved interface method: caller-class:&quot;,
 909                  Bytecodes::name(code));
 910     trace_method_resolution(buf, link_info.current_klass(), resolved_klass, resolved_method(), true);
 911   }
 912 
 913   return resolved_method();
 914 }
 915 
 916 //------------------------------------------------------------------------------------------------------------------------
 917 // Field resolution
 918 
 919 void LinkResolver::check_field_accessability(Klass* ref_klass,
 920                                              Klass* resolved_klass,
 921                                              Klass* sel_klass,
 922                                              const fieldDescriptor&amp; fd,
 923                                              TRAPS) {
 924   bool can_access = Reflection::verify_member_access(ref_klass,
 925                                                      resolved_klass,
 926                                                      sel_klass,
 927                                                      fd.access_flags(),
 928                                                      true, false, CHECK);
 929   // Any existing exceptions that may have been thrown, for example LinkageErrors
 930   // from nest-host resolution, have been allowed to propagate.
 931   if (!can_access) {
 932     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
 933     ResourceMark rm(THREAD);
 934     stringStream ss;
 935     ss.print(&quot;class %s tried to access %s%sfield %s.%s (%s%s%s)&quot;,
 936              ref_klass-&gt;external_name(),
 937              fd.is_protected() ? &quot;protected &quot; : &quot;&quot;,
 938              fd.is_private()   ? &quot;private &quot;   : &quot;&quot;,
 939              sel_klass-&gt;external_name(),
 940              fd.name()-&gt;as_C_string(),
 941              (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),
 942              (same_module) ? &quot;&quot; : &quot;; &quot;,
 943              (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()
 944              );
 945     // For private access see if there was a problem with nest host
 946     // resolution, and if so report that as part of the message.
 947     if (fd.is_private()) {
 948       print_nest_host_error_on(&amp;ss, ref_klass, sel_klass, THREAD);
 949     }
 950     Exceptions::fthrow(THREAD_AND_LOCATION,
 951                        vmSymbols::java_lang_IllegalAccessError(),
 952                        &quot;%s&quot;,
 953                        ss.as_string()
 954                        );
 955     return;
 956   }
 957 }
 958 
 959 void LinkResolver::resolve_field_access(fieldDescriptor&amp; fd, const constantPoolHandle&amp; pool, int index, const methodHandle&amp; method, Bytecodes::Code byte, TRAPS) {
 960   LinkInfo link_info(pool, index, method, CHECK);
 961   resolve_field(fd, link_info, byte, true, CHECK);
 962 }
 963 
 964 void LinkResolver::resolve_field(fieldDescriptor&amp; fd,
 965                                  const LinkInfo&amp; link_info,
 966                                  Bytecodes::Code byte, bool initialize_class,
 967                                  TRAPS) {
 968   assert(byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic ||
 969          byte == Bytecodes::_getfield  || byte == Bytecodes::_putfield  ||
<a name="1" id="anc1"></a>
 970          byte == Bytecodes::_nofast_getfield  || byte == Bytecodes::_nofast_putfield  ||
 971          (byte == Bytecodes::_nop &amp;&amp; !link_info.check_access()), &quot;bad field access bytecode&quot;);
 972 
 973   bool is_static = (byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic);
<a name="2" id="anc2"></a><span class="line-modified"> 974   bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic || byte == Bytecodes::_nofast_putfield);</span>

 975   // Check if there&#39;s a resolved klass containing the field
 976   Klass* resolved_klass = link_info.resolved_klass();
 977   Symbol* field = link_info.name();
 978   Symbol* sig = link_info.signature();
 979 
 980   if (resolved_klass == NULL) {
 981     ResourceMark rm(THREAD);
 982     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 983   }
 984 
 985   // Resolve instance field
 986   Klass* sel_klass = resolved_klass-&gt;find_field(field, sig, &amp;fd);
 987   // check if field exists; i.e., if a klass containing the field def has been selected
 988   if (sel_klass == NULL) {
 989     ResourceMark rm(THREAD);
 990     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 991   }
 992 
 993   // Access checking may be turned off when calling from within the VM.
 994   Klass* current_klass = link_info.current_klass();
 995   if (link_info.check_access()) {
 996 
 997     // check access
 998     check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
 999 
1000     // check for errors
1001     if (is_static != fd.is_static()) {
1002       ResourceMark rm(THREAD);
1003       char msg[200];
1004       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
1005       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
1006     }
1007 
1008     // A final field can be modified only
1009     // (1) by methods declared in the class declaring the field and
1010     // (2) by the &lt;clinit&gt; method (in case of a static field)
1011     //     or by the &lt;init&gt; method (in case of an instance field).
<a name="3" id="anc3"></a>

1012     if (is_put &amp;&amp; fd.access_flags().is_final()) {
1013 
1014       if (sel_klass != current_klass) {
<a name="4" id="anc4"></a>








1015         ResourceMark rm(THREAD);
1016         stringStream ss;
1017         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
1018                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
<a name="5" id="anc5"></a><span class="line-modified">1019                 current_klass-&gt;external_name());</span>
1020         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1021       }
<a name="6" id="anc6"></a>
1022 
1023       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
1024         Method* m = link_info.current_method();
1025         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);
1026         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1027                                                    fd.is_static() &amp;&amp;
<a name="7" id="anc7"></a><span class="line-modified">1028                                                    !m-&gt;is_static_initializer());</span>
1029         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1030                                                      !fd.is_static() &amp;&amp;
<a name="8" id="anc8"></a><span class="line-modified">1031                                                      !m-&gt;is_object_initializer());</span>
1032 
1033         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
1034           ResourceMark rm(THREAD);
1035           stringStream ss;
1036           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1037                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1038                    m-&gt;name()-&gt;as_C_string(),
1039                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1040           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1041         }
1042       }
1043     }
1044 
1045     // initialize resolved_klass if necessary
1046     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1047     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1048     //
1049     // note 2: we don&#39;t want to force initialization if we are just checking
1050     //         if the field access is legal; e.g., during compilation
1051     if (is_static &amp;&amp; initialize_class) {
1052       sel_klass-&gt;initialize(CHECK);
1053     }
1054   }
1055 
1056   if ((sel_klass != current_klass) &amp;&amp; (current_klass != NULL)) {
1057     check_field_loader_constraints(field, sig, current_klass, sel_klass, CHECK);
1058   }
1059 
1060   // return information. note that the klass is set to the actual klass containing the
1061   // field, otherwise access of static fields in superclasses will not work.
1062 }
1063 
1064 
1065 //------------------------------------------------------------------------------------------------------------------------
1066 // Invoke resolution
1067 //
1068 // Naming conventions:
1069 //
1070 // resolved_method    the specified method (i.e., static receiver specified via constant pool index)
1071 // sel_method         the selected method  (selected via run-time lookup; e.g., based on dynamic receiver class)
1072 // resolved_klass     the specified klass  (i.e., specified via constant pool index)
1073 // recv_klass         the receiver klass
1074 
1075 
1076 void LinkResolver::resolve_static_call(CallInfo&amp; result,
1077                                        const LinkInfo&amp; link_info,
1078                                        bool initialize_class, TRAPS) {
1079   Method* resolved_method = linktime_resolve_static_method(link_info, CHECK);
1080 
1081   // The resolved class can change as a result of this resolution.
1082   Klass* resolved_klass = resolved_method-&gt;method_holder();
1083 
1084   // Initialize klass (this should only happen if everything is ok)
1085   if (initialize_class &amp;&amp; resolved_klass-&gt;should_be_initialized()) {
1086     resolved_klass-&gt;initialize(CHECK);
1087     // Use updated LinkInfo to reresolve with resolved method holder
1088     LinkInfo new_info(resolved_klass, link_info.name(), link_info.signature(),
1089                       link_info.current_klass(),
1090                       link_info.check_access() ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);
1091     resolved_method = linktime_resolve_static_method(new_info, CHECK);
1092   }
1093 
1094   // setup result
1095   result.set_static(resolved_klass, methodHandle(THREAD, resolved_method), CHECK);
1096 }
1097 
1098 // throws linktime exceptions
1099 Method* LinkResolver::linktime_resolve_static_method(const LinkInfo&amp; link_info, TRAPS) {
1100 
1101   Klass* resolved_klass = link_info.resolved_klass();
1102   Method* resolved_method;
1103   if (!resolved_klass-&gt;is_interface()) {
1104     resolved_method = resolve_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
1105   } else {
1106     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokestatic, CHECK_NULL);
1107   }
1108   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name(), &quot;should have been checked in verifier&quot;);
1109 
1110   // check if static
1111   if (!resolved_method-&gt;is_static()) {
1112     ResourceMark rm(THREAD);
1113     stringStream ss;
1114     ss.print(&quot;Expected static method &#39;&quot;);
1115     resolved_method-&gt;print_external_name(&amp;ss);
1116     ss.print(&quot;&#39;&quot;);
1117     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1118   }
1119   return resolved_method;
1120 }
1121 
1122 
1123 void LinkResolver::resolve_special_call(CallInfo&amp; result,
1124                                         Handle recv,
1125                                         const LinkInfo&amp; link_info,
1126                                         TRAPS) {
1127   Method* resolved_method = linktime_resolve_special_method(link_info, CHECK);
1128   runtime_resolve_special_method(result, link_info, methodHandle(THREAD, resolved_method), recv, CHECK);
1129 }
1130 
1131 // throws linktime exceptions
1132 Method* LinkResolver::linktime_resolve_special_method(const LinkInfo&amp; link_info, TRAPS) {
1133 
1134   // Invokespecial is called for multiple special reasons:
1135   // &lt;init&gt;
1136   // local private method invocation, for classes and interfaces
1137   // superclass.method, which can also resolve to a default method
1138   // and the selected method is recalculated relative to the direct superclass
1139   // superinterface.method, which explicitly does not check shadowing
1140   Klass* resolved_klass = link_info.resolved_klass();
1141   Method* resolved_method;
1142 
1143   if (!resolved_klass-&gt;is_interface()) {
1144     resolved_method = resolve_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1145   } else {
1146     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1147   }
1148 
1149   // check if method name is &lt;init&gt;, that it is found in same klass as static type
<a name="9" id="anc9"></a>

1150   if (resolved_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
1151       resolved_method-&gt;method_holder() != resolved_klass) {
1152     ResourceMark rm(THREAD);
1153     stringStream ss;
1154     ss.print(&quot;%s: method &#39;&quot;, resolved_klass-&gt;external_name());
1155     resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);
1156     ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());
1157     resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);
1158     ss.print(&quot;)&#39; not found&quot;);
1159     Exceptions::fthrow(
1160       THREAD_AND_LOCATION,
1161       vmSymbols::java_lang_NoSuchMethodError(),
1162       &quot;%s&quot;, ss.as_string());
1163     return NULL;
1164   }
1165 
1166   // ensure that invokespecial&#39;s interface method reference is in
1167   // a direct superinterface, not an indirect superinterface
1168   Klass* current_klass = link_info.current_klass();
1169   if (current_klass != NULL &amp;&amp; resolved_klass-&gt;is_interface()) {
1170     InstanceKlass* ck = InstanceKlass::cast(current_klass);
1171     InstanceKlass *klass_to_check = !ck-&gt;is_unsafe_anonymous() ?
1172                                     ck :
1173                                     ck-&gt;unsafe_anonymous_host();
1174     // Disable verification for the dynamically-generated reflection bytecodes.
1175     bool is_reflect = klass_to_check-&gt;is_subclass_of(
1176                         SystemDictionary::reflect_MagicAccessorImpl_klass());
1177 
1178     if (!is_reflect &amp;&amp;
1179         !klass_to_check-&gt;is_same_or_direct_interface(resolved_klass)) {
1180       ResourceMark rm(THREAD);
1181       stringStream ss;
1182       ss.print(&quot;Interface method reference: &#39;&quot;);
1183       resolved_method-&gt;print_external_name(&amp;ss);
1184       ss.print(&quot;&#39;, is in an indirect superinterface of %s&quot;,
1185                current_klass-&gt;external_name());
1186       THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1187     }
1188   }
1189 
1190   // check if not static
1191   if (resolved_method-&gt;is_static()) {
1192     ResourceMark rm(THREAD);
1193     stringStream ss;
1194     ss.print(&quot;Expecting non-static method &#39;&quot;);
1195     resolved_method-&gt;print_external_name(&amp;ss);
1196     ss.print(&quot;&#39;&quot;);
1197     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1198   }
1199 
1200   if (log_develop_is_enabled(Trace, itables)) {
1201     trace_method_resolution(&quot;invokespecial resolved method: caller-class:&quot;,
1202                             current_klass, resolved_klass, resolved_method, true);
1203   }
1204 
1205   return resolved_method;
1206 }
1207 
1208 // throws runtime exceptions
1209 void LinkResolver::runtime_resolve_special_method(CallInfo&amp; result,
1210                                                   const LinkInfo&amp; link_info,
1211                                                   const methodHandle&amp; resolved_method,
1212                                                   Handle recv, TRAPS) {
1213 
1214   Klass* resolved_klass = link_info.resolved_klass();
1215 
1216   // resolved method is selected method unless we have an old-style lookup
1217   // for a superclass method
1218   // Invokespecial for a superinterface, resolved method is selected method,
1219   // no checks for shadowing
1220   methodHandle sel_method(THREAD, resolved_method());
1221 
1222   if (link_info.check_access() &amp;&amp;
<a name="10" id="anc10"></a><span class="line-modified">1223       // check if the method is not &lt;init&gt;</span>
1224       resolved_method-&gt;name() != vmSymbols::object_initializer_name()) {
1225 
1226     Klass* current_klass = link_info.current_klass();
1227 
1228     // Check if the class of the resolved_klass is a superclass
1229     // (not supertype in order to exclude interface classes) of the current class.
1230     // This check is not performed for super.invoke for interface methods
1231     // in super interfaces.
1232     if (current_klass-&gt;is_subclass_of(resolved_klass) &amp;&amp;
1233         current_klass != resolved_klass) {
1234       // Lookup super method
1235       Klass* super_klass = current_klass-&gt;super();
1236       Method* instance_method = lookup_instance_method_in_klasses(super_klass,
1237                                                      resolved_method-&gt;name(),
1238                                                      resolved_method-&gt;signature(),
1239                                                      Klass::find_private, CHECK);
1240       sel_method = methodHandle(THREAD, instance_method);
1241 
1242       // check if found
1243       if (sel_method.is_null()) {
1244         ResourceMark rm(THREAD);
1245         stringStream ss;
1246         ss.print(&quot;&#39;&quot;);
1247         resolved_method-&gt;print_external_name(&amp;ss);
1248         ss.print(&quot;&#39;&quot;);
1249         THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1250       // check loader constraints if found a different method
1251       } else if (sel_method() != resolved_method()) {
1252         check_method_loader_constraints(link_info, sel_method, &quot;method&quot;, CHECK);
1253       }
1254     }
1255 
1256     // Check that the class of objectref (the receiver) is the current class or interface,
1257     // or a subtype of the current class or interface (the sender), otherwise invokespecial
1258     // throws IllegalAccessError.
1259     // The verifier checks that the sender is a subtype of the class in the I/MR operand.
1260     // The verifier also checks that the receiver is a subtype of the sender, if the sender is
1261     // a class.  If the sender is an interface, the check has to be performed at runtime.
1262     InstanceKlass* sender = InstanceKlass::cast(current_klass);
1263     sender = sender-&gt;is_unsafe_anonymous() ? sender-&gt;unsafe_anonymous_host() : sender;
1264     if (sender-&gt;is_interface() &amp;&amp; recv.not_null()) {
1265       Klass* receiver_klass = recv-&gt;klass();
1266       if (!receiver_klass-&gt;is_subtype_of(sender)) {
1267         ResourceMark rm(THREAD);
1268         char buf[500];
1269         jio_snprintf(buf, sizeof(buf),
1270                      &quot;Receiver class %s must be the current class or a subtype of interface %s&quot;,
1271                      receiver_klass-&gt;external_name(),
1272                      sender-&gt;external_name());
1273         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), buf);
1274       }
1275     }
1276   }
1277 
1278   // check if not static
1279   if (sel_method-&gt;is_static()) {
1280     ResourceMark rm(THREAD);
1281     stringStream ss;
1282     ss.print(&quot;Expecting non-static method &#39;&quot;);
1283     resolved_method-&gt;print_external_name(&amp;ss);
1284     ss.print(&quot;&#39;&quot;);
1285     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1286   }
1287 
1288   // check if abstract
1289   if (sel_method-&gt;is_abstract()) {
1290     ResourceMark rm(THREAD);
1291     stringStream ss;
1292     ss.print(&quot;&#39;&quot;);
1293     Method::print_external_name(&amp;ss, resolved_klass, sel_method-&gt;name(), sel_method-&gt;signature());
1294     ss.print(&quot;&#39;&quot;);
1295     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1296   }
1297 
1298   if (log_develop_is_enabled(Trace, itables)) {
1299     trace_method_resolution(&quot;invokespecial selected method: resolved-class:&quot;,
1300                             resolved_klass, resolved_klass, sel_method(), true);
1301   }
1302 
1303   // setup result
1304   result.set_static(resolved_klass, sel_method, CHECK);
1305 }
1306 
1307 void LinkResolver::resolve_virtual_call(CallInfo&amp; result, Handle recv, Klass* receiver_klass,
1308                                         const LinkInfo&amp; link_info,
1309                                         bool check_null_and_abstract, TRAPS) {
1310   Method* resolved_method = linktime_resolve_virtual_method(link_info, CHECK);
1311   runtime_resolve_virtual_method(result, methodHandle(THREAD, resolved_method),
1312                                  link_info.resolved_klass(),
1313                                  recv, receiver_klass,
1314                                  check_null_and_abstract, CHECK);
1315 }
1316 
1317 // throws linktime exceptions
1318 Method* LinkResolver::linktime_resolve_virtual_method(const LinkInfo&amp; link_info,
1319                                                            TRAPS) {
1320   // normal method resolution
1321   Method* resolved_method = resolve_method(link_info, Bytecodes::_invokevirtual, CHECK_NULL);
1322 
1323   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1324   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1325 
1326   // check if private interface method
1327   Klass* resolved_klass = link_info.resolved_klass();
1328   Klass* current_klass = link_info.current_klass();
1329 
1330   // This is impossible, if resolve_klass is an interface, we&#39;ve thrown icce in resolve_method
1331   if (resolved_klass-&gt;is_interface() &amp;&amp; resolved_method-&gt;is_private()) {
1332     ResourceMark rm(THREAD);
1333     stringStream ss;
1334     ss.print(&quot;private interface method requires invokespecial, not invokevirtual: method &#39;&quot;);
1335     resolved_method-&gt;print_external_name(&amp;ss);
1336     ss.print(&quot;&#39;, caller-class: %s&quot;,
1337              (current_klass == NULL ? &quot;&lt;null&gt;&quot; : current_klass-&gt;internal_name()));
1338     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1339   }
1340 
1341   // check if not static
1342   if (resolved_method-&gt;is_static()) {
1343     ResourceMark rm(THREAD);
1344     stringStream ss;
1345     ss.print(&quot;Expecting non-static method &#39;&quot;);
1346     resolved_method-&gt;print_external_name(&amp;ss);
1347     ss.print(&quot;&#39;&quot;);
1348     THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1349   }
1350 
1351   if (log_develop_is_enabled(Trace, vtables)) {
1352     trace_method_resolution(&quot;invokevirtual resolved method: caller-class:&quot;,
1353                             current_klass, resolved_klass, resolved_method, false);
1354   }
1355 
1356   return resolved_method;
1357 }
1358 
1359 // throws runtime exceptions
1360 void LinkResolver::runtime_resolve_virtual_method(CallInfo&amp; result,
1361                                                   const methodHandle&amp; resolved_method,
1362                                                   Klass* resolved_klass,
1363                                                   Handle recv,
1364                                                   Klass* recv_klass,
1365                                                   bool check_null_and_abstract,
1366                                                   TRAPS) {
1367 
1368   // setup default return values
1369   int vtable_index = Method::invalid_vtable_index;
1370   methodHandle selected_method;
1371 
1372   // runtime method resolution
1373   if (check_null_and_abstract &amp;&amp; recv.is_null()) { // check if receiver exists
1374     THROW(vmSymbols::java_lang_NullPointerException());
1375   }
1376 
1377   // Virtual methods cannot be resolved before its klass has been linked, for otherwise the Method*&#39;s
1378   // has not been rewritten, and the vtable initialized. Make sure to do this after the nullcheck, since
1379   // a missing receiver might result in a bogus lookup.
1380   assert(resolved_method-&gt;method_holder()-&gt;is_linked(), &quot;must be linked&quot;);
1381 
1382   // do lookup based on receiver klass using the vtable index
1383   if (resolved_method-&gt;method_holder()-&gt;is_interface()) { // default or miranda method
1384     vtable_index = vtable_index_of_interface_method(resolved_klass, resolved_method);
1385     assert(vtable_index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
1386 
1387     selected_method = methodHandle(THREAD, recv_klass-&gt;method_at_vtable(vtable_index));
1388   } else {
1389     // at this point we are sure that resolved_method is virtual and not
1390     // a default or miranda method; therefore, it must have a valid vtable index.
1391     assert(!resolved_method-&gt;has_itable_index(), &quot;&quot;);
1392     vtable_index = resolved_method-&gt;vtable_index();
1393     // We could get a negative vtable_index of nonvirtual_vtable_index for private
1394     // methods, or for final methods. Private methods never appear in the vtable
1395     // and never override other methods. As an optimization, final methods are
1396     // never put in the vtable, unless they override an existing method.
1397     // So if we do get nonvirtual_vtable_index, it means the selected method is the
1398     // resolved method, and it can never be changed by an override.
1399     if (vtable_index == Method::nonvirtual_vtable_index) {
1400       assert(resolved_method-&gt;can_be_statically_bound(), &quot;cannot override this method&quot;);
1401       selected_method = resolved_method;
1402     } else {
1403       selected_method = methodHandle(THREAD, recv_klass-&gt;method_at_vtable(vtable_index));
1404     }
1405   }
1406 
1407   // check if method exists
1408   if (selected_method.is_null()) {
1409     throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1410   }
1411 
1412   // check if abstract
1413   if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1414     // Pass arguments for generating a verbose error message.
1415     throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1416   }
1417 
1418   if (log_develop_is_enabled(Trace, vtables)) {
1419     trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
1420                             recv_klass, resolved_klass, selected_method(),
1421                             false, vtable_index);
1422   }
1423   // setup result
1424   result.set_virtual(resolved_klass, resolved_method, selected_method, vtable_index, CHECK);
1425 }
1426 
1427 void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
1428                                           const LinkInfo&amp; link_info,
1429                                           bool check_null_and_abstract, TRAPS) {
1430   // throws linktime exceptions
1431   Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);
1432   methodHandle mh(THREAD, resolved_method);
1433   runtime_resolve_interface_method(result, mh, link_info.resolved_klass(),
1434                                    recv, recv_klass, check_null_and_abstract, CHECK);
1435 }
1436 
1437 Method* LinkResolver::linktime_resolve_interface_method(const LinkInfo&amp; link_info,
1438                                                              TRAPS) {
1439   // normal interface method resolution
1440   Method* resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);
1441   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1442   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1443 
1444   return resolved_method;
1445 }
1446 
1447 // throws runtime exceptions
1448 void LinkResolver::runtime_resolve_interface_method(CallInfo&amp; result,
1449                                                     const methodHandle&amp; resolved_method,
1450                                                     Klass* resolved_klass,
1451                                                     Handle recv,
1452                                                     Klass* recv_klass,
1453                                                     bool check_null_and_abstract, TRAPS) {
1454 
1455   // check if receiver exists
1456   if (check_null_and_abstract &amp;&amp; recv.is_null()) {
1457     THROW(vmSymbols::java_lang_NullPointerException());
1458   }
1459 
1460   // check if receiver klass implements the resolved interface
1461   if (!recv_klass-&gt;is_subtype_of(resolved_klass)) {
1462     ResourceMark rm(THREAD);
1463     char buf[200];
1464     jio_snprintf(buf, sizeof(buf), &quot;Class %s does not implement the requested interface %s&quot;,
1465                  recv_klass-&gt;external_name(),
1466                  resolved_klass-&gt;external_name());
1467     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
1468   }
1469 
1470   methodHandle selected_method = resolved_method;
1471 
1472   // resolve the method in the receiver class, unless it is private
1473   if (!resolved_method()-&gt;is_private()) {
1474     // do lookup based on receiver klass
1475     // This search must match the linktime preparation search for itable initialization
1476     // to correctly enforce loader constraints for interface method inheritance.
1477     // Private methods are skipped as the resolved method was not private.
1478     Method* method = lookup_instance_method_in_klasses(recv_klass,
1479                                                        resolved_method-&gt;name(),
1480                                                        resolved_method-&gt;signature(),
1481                                                        Klass::skip_private, CHECK);
1482     selected_method = methodHandle(THREAD, method);
1483 
1484     if (selected_method.is_null() &amp;&amp; !check_null_and_abstract) {
1485       // In theory this is a harmless placeholder value, but
1486       // in practice leaving in null affects the nsk default method tests.
1487       // This needs further study.
1488       selected_method = resolved_method;
1489     }
1490     // check if method exists
1491     if (selected_method.is_null()) {
1492       // Pass arguments for generating a verbose error message.
1493       throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1494     }
1495     // check access
1496     // Throw Illegal Access Error if selected_method is not public.
1497     if (!selected_method-&gt;is_public()) {
1498       ResourceMark rm(THREAD);
1499       stringStream ss;
1500       ss.print(&quot;&#39;&quot;);
1501       Method::print_external_name(&amp;ss, recv_klass, selected_method-&gt;name(), selected_method-&gt;signature());
1502       ss.print(&quot;&#39;&quot;);
1503       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1504     }
1505     // check if abstract
1506     if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1507       throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1508     }
1509   }
1510 
1511   if (log_develop_is_enabled(Trace, itables)) {
1512     trace_method_resolution(&quot;invokeinterface selected method: receiver-class:&quot;,
1513                             recv_klass, resolved_klass, selected_method(), true);
1514   }
1515   // setup result
1516   if (resolved_method-&gt;has_vtable_index()) {
1517     int vtable_index = resolved_method-&gt;vtable_index();
1518     log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
1519     assert(vtable_index == selected_method-&gt;vtable_index(), &quot;sanity check&quot;);
1520     result.set_virtual(resolved_klass, resolved_method, selected_method, vtable_index, CHECK);
1521   } else if (resolved_method-&gt;has_itable_index()) {
1522     int itable_index = resolved_method()-&gt;itable_index();
1523     log_develop_trace(itables)(&quot;  -- itable index: %d&quot;, itable_index);
1524     result.set_interface(resolved_klass, resolved_method, selected_method, itable_index, CHECK);
1525   } else {
1526     int index = resolved_method-&gt;vtable_index();
1527     log_develop_trace(itables)(&quot;  -- non itable/vtable index: %d&quot;, index);
1528     assert(index == Method::nonvirtual_vtable_index, &quot;Oops hit another case!&quot;);
1529     assert(resolved_method()-&gt;is_private() ||
1530            (resolved_method()-&gt;is_final() &amp;&amp; resolved_method-&gt;method_holder() == SystemDictionary::Object_klass()),
1531            &quot;Should only have non-virtual invokeinterface for private or final-Object methods!&quot;);
1532     assert(resolved_method()-&gt;can_be_statically_bound(), &quot;Should only have non-virtual invokeinterface for statically bound methods!&quot;);
1533     // This sets up the nonvirtual form of &quot;virtual&quot; call (as needed for final and private methods)
1534     result.set_virtual(resolved_klass, resolved_method, resolved_method, index, CHECK);
1535   }
1536 }
1537 
1538 
1539 Method* LinkResolver::linktime_resolve_interface_method_or_null(
1540                                                  const LinkInfo&amp; link_info) {
1541   EXCEPTION_MARK;
1542   Method* method_result = linktime_resolve_interface_method(link_info, THREAD);
1543   if (HAS_PENDING_EXCEPTION) {
1544     CLEAR_PENDING_EXCEPTION;
1545     return NULL;
1546   } else {
1547     return method_result;
1548   }
1549 }
1550 
1551 Method* LinkResolver::linktime_resolve_virtual_method_or_null(
1552                                                  const LinkInfo&amp; link_info) {
1553   EXCEPTION_MARK;
1554   Method* method_result = linktime_resolve_virtual_method(link_info, THREAD);
1555   if (HAS_PENDING_EXCEPTION) {
1556     CLEAR_PENDING_EXCEPTION;
1557     return NULL;
1558   } else {
1559     return method_result;
1560   }
1561 }
1562 
1563 Method* LinkResolver::resolve_virtual_call_or_null(
1564                                                  Klass* receiver_klass,
1565                                                  const LinkInfo&amp; link_info) {
1566   EXCEPTION_MARK;
1567   CallInfo info;
1568   resolve_virtual_call(info, Handle(), receiver_klass, link_info, false, THREAD);
1569   if (HAS_PENDING_EXCEPTION) {
1570     CLEAR_PENDING_EXCEPTION;
1571     return NULL;
1572   }
1573   return info.selected_method();
1574 }
1575 
1576 Method* LinkResolver::resolve_interface_call_or_null(
1577                                                  Klass* receiver_klass,
1578                                                  const LinkInfo&amp; link_info) {
1579   EXCEPTION_MARK;
1580   CallInfo info;
1581   resolve_interface_call(info, Handle(), receiver_klass, link_info, false, THREAD);
1582   if (HAS_PENDING_EXCEPTION) {
1583     CLEAR_PENDING_EXCEPTION;
1584     return NULL;
1585   }
1586   return info.selected_method();
1587 }
1588 
1589 int LinkResolver::resolve_virtual_vtable_index(Klass* receiver_klass,
1590                                                const LinkInfo&amp; link_info) {
1591   EXCEPTION_MARK;
1592   CallInfo info;
1593   resolve_virtual_call(info, Handle(), receiver_klass, link_info,
1594                        /*check_null_or_abstract*/false, THREAD);
1595   if (HAS_PENDING_EXCEPTION) {
1596     CLEAR_PENDING_EXCEPTION;
1597     return Method::invalid_vtable_index;
1598   }
1599   return info.vtable_index();
1600 }
1601 
1602 Method* LinkResolver::resolve_static_call_or_null(const LinkInfo&amp; link_info) {
1603   EXCEPTION_MARK;
1604   CallInfo info;
1605   resolve_static_call(info, link_info, /*initialize_class*/false, THREAD);
1606   if (HAS_PENDING_EXCEPTION) {
1607     CLEAR_PENDING_EXCEPTION;
1608     return NULL;
1609   }
1610   return info.selected_method();
1611 }
1612 
1613 Method* LinkResolver::resolve_special_call_or_null(const LinkInfo&amp; link_info) {
1614   EXCEPTION_MARK;
1615   CallInfo info;
1616   resolve_special_call(info, Handle(), link_info, THREAD);
1617   if (HAS_PENDING_EXCEPTION) {
1618     CLEAR_PENDING_EXCEPTION;
1619     return NULL;
1620   }
1621   return info.selected_method();
1622 }
1623 
1624 
1625 
1626 //------------------------------------------------------------------------------------------------------------------------
1627 // ConstantPool entries
1628 
1629 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, Bytecodes::Code byte, TRAPS) {
1630   switch (byte) {
1631     case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;
1632     case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index, CHECK); break;
1633     case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;
1634     case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;
1635     case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;
1636     case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;
1637     default                         :                                                            break;
1638   }
1639   return;
1640 }
1641 
1642 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
<a name="11" id="anc11"></a><span class="line-modified">1643                              const methodHandle&amp; attached_method,</span>
<span class="line-modified">1644                              Bytecodes::Code byte, TRAPS) {</span>
1645   Klass* defc = attached_method-&gt;method_holder();
1646   Symbol* name = attached_method-&gt;name();
1647   Symbol* type = attached_method-&gt;signature();
1648   LinkInfo link_info(defc, name, type);
<a name="12" id="anc12"></a>
1649   switch(byte) {
1650     case Bytecodes::_invokevirtual:
<a name="13" id="anc13"></a><span class="line-modified">1651       resolve_virtual_call(result, recv, recv-&gt;klass(), link_info,</span>
<span class="line-modified">1652                            /*check_null_and_abstract=*/true, CHECK);</span>
1653       break;
1654     case Bytecodes::_invokeinterface:
<a name="14" id="anc14"></a><span class="line-modified">1655       resolve_interface_call(result, recv, recv-&gt;klass(), link_info,</span>
<span class="line-modified">1656                              /*check_null_and_abstract=*/true, CHECK);</span>
1657       break;
1658     case Bytecodes::_invokestatic:
1659       resolve_static_call(result, link_info, /*initialize_class=*/false, CHECK);
1660       break;
1661     case Bytecodes::_invokespecial:
1662       resolve_special_call(result, recv, link_info, CHECK);
1663       break;
1664     default:
1665       fatal(&quot;bad call: %s&quot;, Bytecodes::name(byte));
1666       break;
1667   }
1668 }
1669 
1670 void LinkResolver::resolve_invokestatic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1671   LinkInfo link_info(pool, index, CHECK);
1672   resolve_static_call(result, link_info, /*initialize_class*/true, CHECK);
1673 }
1674 
1675 
1676 void LinkResolver::resolve_invokespecial(CallInfo&amp; result, Handle recv,
1677                                          const constantPoolHandle&amp; pool, int index, TRAPS) {
1678   LinkInfo link_info(pool, index, CHECK);
1679   resolve_special_call(result, recv, link_info, CHECK);
1680 }
1681 
1682 
1683 void LinkResolver::resolve_invokevirtual(CallInfo&amp; result, Handle recv,
1684                                           const constantPoolHandle&amp; pool, int index,
1685                                           TRAPS) {
1686 
1687   LinkInfo link_info(pool, index, CHECK);
1688   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1689   resolve_virtual_call(result, recv, recvrKlass, link_info, /*check_null_or_abstract*/true, CHECK);
1690 }
1691 
1692 
1693 void LinkResolver::resolve_invokeinterface(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, TRAPS) {
1694   LinkInfo link_info(pool, index, CHECK);
1695   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1696   resolve_interface_call(result, recv, recvrKlass, link_info, true, CHECK);
1697 }
1698 
1699 
1700 void LinkResolver::resolve_invokehandle(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1701   // This guy is reached from InterpreterRuntime::resolve_invokehandle.
1702   LinkInfo link_info(pool, index, CHECK);
1703   if (log_is_enabled(Info, methodhandles)) {
1704     ResourceMark rm(THREAD);
1705     log_info(methodhandles)(&quot;resolve_invokehandle %s %s&quot;, link_info.name()-&gt;as_C_string(),
1706                             link_info.signature()-&gt;as_C_string());
1707   }
1708   resolve_handle_call(result, link_info, CHECK);
1709 }
1710 
1711 void LinkResolver::resolve_handle_call(CallInfo&amp; result,
1712                                        const LinkInfo&amp; link_info,
1713                                        TRAPS) {
1714   // JSR 292:  this must be an implicitly generated method MethodHandle.invokeExact(*...) or similar
1715   Klass* resolved_klass = link_info.resolved_klass();
1716   assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||
1717          resolved_klass == SystemDictionary::VarHandle_klass(), &quot;&quot;);
1718   assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), &quot;&quot;);
1719   Handle       resolved_appendix;
1720   Method* resolved_method = lookup_polymorphic_method(link_info, &amp;resolved_appendix, CHECK);
1721   result.set_handle(resolved_klass, methodHandle(THREAD, resolved_method), resolved_appendix, CHECK);
1722 }
1723 
1724 void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int indy_index, TRAPS) {
1725   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(indy_index);
1726   int pool_index = cpce-&gt;constant_pool_index();
1727 
1728   // Resolve the bootstrap specifier (BSM + optional arguments).
1729   BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);
1730 
1731   // Check if CallSite has been bound already or failed already, and short circuit:
1732   {
1733     bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1734     if (is_done) return;
1735   }
1736 
1737   // The initial step in Call Site Specifier Resolution is to resolve the symbolic
1738   // reference to a method handle which will be the bootstrap method for a dynamic
1739   // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap
1740   // method fails, then a MethodHandleInError is stored at the corresponding bootstrap
1741   // method&#39;s CP index for the CONSTANT_MethodHandle_info.  So, there is no need to
1742   // set the indy_rf flag since any subsequent invokedynamic instruction which shares
1743   // this bootstrap method will encounter the resolution of MethodHandleInError.
1744 
1745   resolve_dynamic_call(result, bootstrap_specifier, CHECK);
1746 
1747   LogTarget(Debug, methodhandles, indy) lt_indy;
1748   if (lt_indy.is_enabled()) {
1749     LogStream ls(lt_indy);
1750     bootstrap_specifier.print_msg_on(&amp;ls, &quot;resolve_invokedynamic&quot;);
1751   }
1752 
1753   // The returned linkage result is provisional up to the moment
1754   // the interpreter or runtime performs a serialized check of
1755   // the relevant CPCE::f1 field.  This is done by the caller
1756   // of this method, via CPCE::set_dynamic_call, which uses
1757   // an ObjectLocker to do the final serialization of updates
1758   // to CPCE state, including f1.
1759 }
1760 
1761 void LinkResolver::resolve_dynamic_call(CallInfo&amp; result,
1762                                         BootstrapInfo&amp; bootstrap_specifier,
1763                                         TRAPS) {
1764   // JSR 292:  this must resolve to an implicitly generated method
1765   // such as MH.linkToCallSite(*...) or some other call-site shape.
1766   // The appendix argument is likely to be a freshly-created CallSite.
1767   // It may also be a MethodHandle from an unwrapped ConstantCallSite,
1768   // or any other reference.  The resolved_method as well as the appendix
1769   // are both recorded together via CallInfo::set_handle.
1770   SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
1771   Exceptions::wrap_dynamic_exception(/* is_indy */ true, THREAD);
1772 
1773   if (HAS_PENDING_EXCEPTION) {
1774     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
1775       // Let any random low-level IE or SOE or OOME just bleed through.
1776       // Basically we pretend that the bootstrap method was never called,
1777       // if it fails this way:  We neither record a successful linkage,
1778       // nor do we memorize a LE for posterity.
1779       return;
1780     }
1781     // JVMS 5.4.3 says: If an attempt by the Java Virtual Machine to resolve
1782     // a symbolic reference fails because an error is thrown that is an
1783     // instance of LinkageError (or a subclass), then subsequent attempts to
1784     // resolve the reference always fail with the same error that was thrown
1785     // as a result of the initial resolution attempt.
1786      bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);
1787      if (!recorded_res_status) {
1788        // Another thread got here just before we did.  So, either use the method
1789        // that it resolved or throw the LinkageError exception that it threw.
1790        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1791        if (is_done) return;
1792      }
1793      assert(bootstrap_specifier.invokedynamic_cp_cache_entry()-&gt;indy_resolution_failed(),
1794             &quot;Resolution failure flag wasn&#39;t set&quot;);
1795   }
1796 
1797   bootstrap_specifier.resolve_newly_linked_invokedynamic(result, CHECK);
1798   // Exceptions::wrap_dynamic_exception not used because
1799   // set_handle doesn&#39;t throw linkage errors
1800 }
1801 
1802 // Selected method is abstract.
1803 void LinkResolver::throw_abstract_method_error(const methodHandle&amp; resolved_method,
1804                                                const methodHandle&amp; selected_method,
1805                                                Klass *recv_klass, TRAPS) {
1806   Klass *resolved_klass = resolved_method-&gt;method_holder();
1807   ResourceMark rm(THREAD);
1808   stringStream ss;
1809 
1810   if (recv_klass != NULL) {
1811     ss.print(&quot;Receiver class %s does not define or inherit an &quot;
1812              &quot;implementation of the&quot;,
1813              recv_klass-&gt;external_name());
1814   } else {
1815     ss.print(&quot;Missing implementation of&quot;);
1816   }
1817 
1818   assert(resolved_method.not_null(), &quot;Sanity&quot;);
1819   ss.print(&quot; resolved method &#39;%s%s&quot;,
1820            resolved_method-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
1821            resolved_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;);
1822   resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);
1823   ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());
1824   resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);
1825   ss.print(&quot;)&#39; of %s %s.&quot;,
1826            resolved_klass-&gt;external_kind(),
1827            resolved_klass-&gt;external_name());
1828 
1829   if (selected_method.not_null() &amp;&amp; !(resolved_method == selected_method)) {
1830     ss.print(&quot; Selected method is &#39;%s%s&quot;,
1831              selected_method-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
1832              selected_method-&gt;is_private()  ? &quot;private &quot;  : &quot;&quot;);
1833     selected_method-&gt;print_external_name(&amp;ss);
1834     ss.print(&quot;&#39;.&quot;);
1835   }
1836 
1837   THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1838 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
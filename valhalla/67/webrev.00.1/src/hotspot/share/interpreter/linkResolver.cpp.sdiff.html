<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../memory/dynamicArchive.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 950     Exceptions::fthrow(THREAD_AND_LOCATION,
 951                        vmSymbols::java_lang_IllegalAccessError(),
 952                        &quot;%s&quot;,
 953                        ss.as_string()
 954                        );
 955     return;
 956   }
 957 }
 958 
 959 void LinkResolver::resolve_field_access(fieldDescriptor&amp; fd, const constantPoolHandle&amp; pool, int index, const methodHandle&amp; method, Bytecodes::Code byte, TRAPS) {
 960   LinkInfo link_info(pool, index, method, CHECK);
 961   resolve_field(fd, link_info, byte, true, CHECK);
 962 }
 963 
 964 void LinkResolver::resolve_field(fieldDescriptor&amp; fd,
 965                                  const LinkInfo&amp; link_info,
 966                                  Bytecodes::Code byte, bool initialize_class,
 967                                  TRAPS) {
 968   assert(byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic ||
 969          byte == Bytecodes::_getfield  || byte == Bytecodes::_putfield  ||

 970          byte == Bytecodes::_nofast_getfield  || byte == Bytecodes::_nofast_putfield  ||
 971          (byte == Bytecodes::_nop &amp;&amp; !link_info.check_access()), &quot;bad field access bytecode&quot;);
 972 
 973   bool is_static = (byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic);
<span class="line-modified"> 974   bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic || byte == Bytecodes::_nofast_putfield);</span>

 975   // Check if there&#39;s a resolved klass containing the field
 976   Klass* resolved_klass = link_info.resolved_klass();
 977   Symbol* field = link_info.name();
 978   Symbol* sig = link_info.signature();
 979 
 980   if (resolved_klass == NULL) {
 981     ResourceMark rm(THREAD);
 982     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 983   }
 984 
 985   // Resolve instance field
 986   Klass* sel_klass = resolved_klass-&gt;find_field(field, sig, &amp;fd);
 987   // check if field exists; i.e., if a klass containing the field def has been selected
 988   if (sel_klass == NULL) {
 989     ResourceMark rm(THREAD);
 990     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 991   }
 992 
 993   // Access checking may be turned off when calling from within the VM.
 994   Klass* current_klass = link_info.current_klass();
 995   if (link_info.check_access()) {
 996 
 997     // check access
 998     check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
 999 
1000     // check for errors
1001     if (is_static != fd.is_static()) {
1002       ResourceMark rm(THREAD);
1003       char msg[200];
1004       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
1005       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
1006     }
1007 
1008     // A final field can be modified only
1009     // (1) by methods declared in the class declaring the field and
1010     // (2) by the &lt;clinit&gt; method (in case of a static field)
1011     //     or by the &lt;init&gt; method (in case of an instance field).


1012     if (is_put &amp;&amp; fd.access_flags().is_final()) {
1013 
1014       if (sel_klass != current_klass) {









1015         ResourceMark rm(THREAD);
1016         stringStream ss;
1017         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
1018                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
<span class="line-modified">1019                 current_klass-&gt;external_name());</span>
1020         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1021       }

1022 
1023       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
1024         Method* m = link_info.current_method();
1025         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);
1026         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1027                                                    fd.is_static() &amp;&amp;
<span class="line-modified">1028                                                    !m-&gt;is_static_initializer());</span>
1029         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1030                                                      !fd.is_static() &amp;&amp;
<span class="line-modified">1031                                                      !m-&gt;is_object_initializer());</span>
1032 
1033         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
1034           ResourceMark rm(THREAD);
1035           stringStream ss;
1036           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1037                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1038                    m-&gt;name()-&gt;as_C_string(),
1039                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1040           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1041         }
1042       }
1043     }
1044 
1045     // initialize resolved_klass if necessary
1046     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1047     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1048     //
1049     // note 2: we don&#39;t want to force initialization if we are just checking
1050     //         if the field access is legal; e.g., during compilation
1051     if (is_static &amp;&amp; initialize_class) {
</pre>
<hr />
<pre>
1130 
1131 // throws linktime exceptions
1132 Method* LinkResolver::linktime_resolve_special_method(const LinkInfo&amp; link_info, TRAPS) {
1133 
1134   // Invokespecial is called for multiple special reasons:
1135   // &lt;init&gt;
1136   // local private method invocation, for classes and interfaces
1137   // superclass.method, which can also resolve to a default method
1138   // and the selected method is recalculated relative to the direct superclass
1139   // superinterface.method, which explicitly does not check shadowing
1140   Klass* resolved_klass = link_info.resolved_klass();
1141   Method* resolved_method;
1142 
1143   if (!resolved_klass-&gt;is_interface()) {
1144     resolved_method = resolve_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1145   } else {
1146     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1147   }
1148 
1149   // check if method name is &lt;init&gt;, that it is found in same klass as static type


1150   if (resolved_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
1151       resolved_method-&gt;method_holder() != resolved_klass) {
1152     ResourceMark rm(THREAD);
1153     stringStream ss;
1154     ss.print(&quot;%s: method &#39;&quot;, resolved_klass-&gt;external_name());
1155     resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);
1156     ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());
1157     resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);
1158     ss.print(&quot;)&#39; not found&quot;);
1159     Exceptions::fthrow(
1160       THREAD_AND_LOCATION,
1161       vmSymbols::java_lang_NoSuchMethodError(),
1162       &quot;%s&quot;, ss.as_string());
1163     return NULL;
1164   }
1165 
1166   // ensure that invokespecial&#39;s interface method reference is in
1167   // a direct superinterface, not an indirect superinterface
1168   Klass* current_klass = link_info.current_klass();
1169   if (current_klass != NULL &amp;&amp; resolved_klass-&gt;is_interface()) {
</pre>
<hr />
<pre>
1203   }
1204 
1205   return resolved_method;
1206 }
1207 
1208 // throws runtime exceptions
1209 void LinkResolver::runtime_resolve_special_method(CallInfo&amp; result,
1210                                                   const LinkInfo&amp; link_info,
1211                                                   const methodHandle&amp; resolved_method,
1212                                                   Handle recv, TRAPS) {
1213 
1214   Klass* resolved_klass = link_info.resolved_klass();
1215 
1216   // resolved method is selected method unless we have an old-style lookup
1217   // for a superclass method
1218   // Invokespecial for a superinterface, resolved method is selected method,
1219   // no checks for shadowing
1220   methodHandle sel_method(THREAD, resolved_method());
1221 
1222   if (link_info.check_access() &amp;&amp;
<span class="line-modified">1223       // check if the method is not &lt;init&gt;</span>
1224       resolved_method-&gt;name() != vmSymbols::object_initializer_name()) {
1225 
1226     Klass* current_klass = link_info.current_klass();
1227 
1228     // Check if the class of the resolved_klass is a superclass
1229     // (not supertype in order to exclude interface classes) of the current class.
1230     // This check is not performed for super.invoke for interface methods
1231     // in super interfaces.
1232     if (current_klass-&gt;is_subclass_of(resolved_klass) &amp;&amp;
1233         current_klass != resolved_klass) {
1234       // Lookup super method
1235       Klass* super_klass = current_klass-&gt;super();
1236       Method* instance_method = lookup_instance_method_in_klasses(super_klass,
1237                                                      resolved_method-&gt;name(),
1238                                                      resolved_method-&gt;signature(),
1239                                                      Klass::find_private, CHECK);
1240       sel_method = methodHandle(THREAD, instance_method);
1241 
1242       // check if found
1243       if (sel_method.is_null()) {
</pre>
<hr />
<pre>
1623 
1624 
1625 
1626 //------------------------------------------------------------------------------------------------------------------------
1627 // ConstantPool entries
1628 
1629 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, Bytecodes::Code byte, TRAPS) {
1630   switch (byte) {
1631     case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;
1632     case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index, CHECK); break;
1633     case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;
1634     case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;
1635     case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;
1636     case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;
1637     default                         :                                                            break;
1638   }
1639   return;
1640 }
1641 
1642 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
<span class="line-modified">1643                              const methodHandle&amp; attached_method,</span>
<span class="line-modified">1644                              Bytecodes::Code byte, TRAPS) {</span>
1645   Klass* defc = attached_method-&gt;method_holder();
1646   Symbol* name = attached_method-&gt;name();
1647   Symbol* type = attached_method-&gt;signature();
1648   LinkInfo link_info(defc, name, type);

1649   switch(byte) {
1650     case Bytecodes::_invokevirtual:
<span class="line-modified">1651       resolve_virtual_call(result, recv, recv-&gt;klass(), link_info,</span>
<span class="line-modified">1652                            /*check_null_and_abstract=*/true, CHECK);</span>
1653       break;
1654     case Bytecodes::_invokeinterface:
<span class="line-modified">1655       resolve_interface_call(result, recv, recv-&gt;klass(), link_info,</span>
<span class="line-modified">1656                              /*check_null_and_abstract=*/true, CHECK);</span>
1657       break;
1658     case Bytecodes::_invokestatic:
1659       resolve_static_call(result, link_info, /*initialize_class=*/false, CHECK);
1660       break;
1661     case Bytecodes::_invokespecial:
1662       resolve_special_call(result, recv, link_info, CHECK);
1663       break;
1664     default:
1665       fatal(&quot;bad call: %s&quot;, Bytecodes::name(byte));
1666       break;
1667   }
1668 }
1669 
1670 void LinkResolver::resolve_invokestatic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1671   LinkInfo link_info(pool, index, CHECK);
1672   resolve_static_call(result, link_info, /*initialize_class*/true, CHECK);
1673 }
1674 
1675 
1676 void LinkResolver::resolve_invokespecial(CallInfo&amp; result, Handle recv,
</pre>
</td>
<td>
<hr />
<pre>
 950     Exceptions::fthrow(THREAD_AND_LOCATION,
 951                        vmSymbols::java_lang_IllegalAccessError(),
 952                        &quot;%s&quot;,
 953                        ss.as_string()
 954                        );
 955     return;
 956   }
 957 }
 958 
 959 void LinkResolver::resolve_field_access(fieldDescriptor&amp; fd, const constantPoolHandle&amp; pool, int index, const methodHandle&amp; method, Bytecodes::Code byte, TRAPS) {
 960   LinkInfo link_info(pool, index, method, CHECK);
 961   resolve_field(fd, link_info, byte, true, CHECK);
 962 }
 963 
 964 void LinkResolver::resolve_field(fieldDescriptor&amp; fd,
 965                                  const LinkInfo&amp; link_info,
 966                                  Bytecodes::Code byte, bool initialize_class,
 967                                  TRAPS) {
 968   assert(byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic ||
 969          byte == Bytecodes::_getfield  || byte == Bytecodes::_putfield  ||
<span class="line-added"> 970          byte == Bytecodes::_withfield ||</span>
 971          byte == Bytecodes::_nofast_getfield  || byte == Bytecodes::_nofast_putfield  ||
 972          (byte == Bytecodes::_nop &amp;&amp; !link_info.check_access()), &quot;bad field access bytecode&quot;);
 973 
 974   bool is_static = (byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic);
<span class="line-modified"> 975   bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic ||</span>
<span class="line-added"> 976                     byte == Bytecodes::_nofast_putfield || byte == Bytecodes::_withfield);</span>
 977   // Check if there&#39;s a resolved klass containing the field
 978   Klass* resolved_klass = link_info.resolved_klass();
 979   Symbol* field = link_info.name();
 980   Symbol* sig = link_info.signature();
 981 
 982   if (resolved_klass == NULL) {
 983     ResourceMark rm(THREAD);
 984     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 985   }
 986 
 987   // Resolve instance field
 988   Klass* sel_klass = resolved_klass-&gt;find_field(field, sig, &amp;fd);
 989   // check if field exists; i.e., if a klass containing the field def has been selected
 990   if (sel_klass == NULL) {
 991     ResourceMark rm(THREAD);
 992     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 993   }
 994 
 995   // Access checking may be turned off when calling from within the VM.
 996   Klass* current_klass = link_info.current_klass();
 997   if (link_info.check_access()) {
 998 
 999     // check access
1000     check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
1001 
1002     // check for errors
1003     if (is_static != fd.is_static()) {
1004       ResourceMark rm(THREAD);
1005       char msg[200];
1006       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
1007       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
1008     }
1009 
1010     // A final field can be modified only
1011     // (1) by methods declared in the class declaring the field and
1012     // (2) by the &lt;clinit&gt; method (in case of a static field)
1013     //     or by the &lt;init&gt; method (in case of an instance field).
<span class="line-added">1014     // (3) by withfield when field is in a value type and the</span>
<span class="line-added">1015     //     selected class and current class are nest mates.</span>
1016     if (is_put &amp;&amp; fd.access_flags().is_final()) {
1017 
1018       if (sel_klass != current_klass) {
<span class="line-added">1019       // If byte code is a withfield check if they are nestmates.</span>
<span class="line-added">1020       bool are_nestmates = false;</span>
<span class="line-added">1021       if (sel_klass-&gt;is_instance_klass() &amp;&amp;</span>
<span class="line-added">1022           InstanceKlass::cast(sel_klass)-&gt;is_value() &amp;&amp;</span>
<span class="line-added">1023           current_klass-&gt;is_instance_klass()) {</span>
<span class="line-added">1024         are_nestmates = InstanceKlass::cast(link_info.current_klass())-&gt;has_nestmate_access_to(</span>
<span class="line-added">1025                                                         InstanceKlass::cast(sel_klass), THREAD);</span>
<span class="line-added">1026       }</span>
<span class="line-added">1027       if (!are_nestmates) {</span>
1028         ResourceMark rm(THREAD);
1029         stringStream ss;
1030         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
1031                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
<span class="line-modified">1032                   current_klass-&gt;external_name());</span>
1033         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1034       }
<span class="line-added">1035       }</span>
1036 
1037       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
1038         Method* m = link_info.current_method();
1039         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);
1040         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1041                                                    fd.is_static() &amp;&amp;
<span class="line-modified">1042                                                    !m-&gt;is_class_initializer());</span>
1043         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1044                                                      !fd.is_static() &amp;&amp;
<span class="line-modified">1045                                                      !m-&gt;is_object_constructor());</span>
1046 
1047         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
1048           ResourceMark rm(THREAD);
1049           stringStream ss;
1050           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1051                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1052                    m-&gt;name()-&gt;as_C_string(),
1053                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1054           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1055         }
1056       }
1057     }
1058 
1059     // initialize resolved_klass if necessary
1060     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1061     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1062     //
1063     // note 2: we don&#39;t want to force initialization if we are just checking
1064     //         if the field access is legal; e.g., during compilation
1065     if (is_static &amp;&amp; initialize_class) {
</pre>
<hr />
<pre>
1144 
1145 // throws linktime exceptions
1146 Method* LinkResolver::linktime_resolve_special_method(const LinkInfo&amp; link_info, TRAPS) {
1147 
1148   // Invokespecial is called for multiple special reasons:
1149   // &lt;init&gt;
1150   // local private method invocation, for classes and interfaces
1151   // superclass.method, which can also resolve to a default method
1152   // and the selected method is recalculated relative to the direct superclass
1153   // superinterface.method, which explicitly does not check shadowing
1154   Klass* resolved_klass = link_info.resolved_klass();
1155   Method* resolved_method;
1156 
1157   if (!resolved_klass-&gt;is_interface()) {
1158     resolved_method = resolve_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1159   } else {
1160     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1161   }
1162 
1163   // check if method name is &lt;init&gt;, that it is found in same klass as static type
<span class="line-added">1164   // Since this method is never inherited from a super, any appearance here under</span>
<span class="line-added">1165   // the wrong class would be an error.</span>
1166   if (resolved_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
1167       resolved_method-&gt;method_holder() != resolved_klass) {
1168     ResourceMark rm(THREAD);
1169     stringStream ss;
1170     ss.print(&quot;%s: method &#39;&quot;, resolved_klass-&gt;external_name());
1171     resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);
1172     ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());
1173     resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);
1174     ss.print(&quot;)&#39; not found&quot;);
1175     Exceptions::fthrow(
1176       THREAD_AND_LOCATION,
1177       vmSymbols::java_lang_NoSuchMethodError(),
1178       &quot;%s&quot;, ss.as_string());
1179     return NULL;
1180   }
1181 
1182   // ensure that invokespecial&#39;s interface method reference is in
1183   // a direct superinterface, not an indirect superinterface
1184   Klass* current_klass = link_info.current_klass();
1185   if (current_klass != NULL &amp;&amp; resolved_klass-&gt;is_interface()) {
</pre>
<hr />
<pre>
1219   }
1220 
1221   return resolved_method;
1222 }
1223 
1224 // throws runtime exceptions
1225 void LinkResolver::runtime_resolve_special_method(CallInfo&amp; result,
1226                                                   const LinkInfo&amp; link_info,
1227                                                   const methodHandle&amp; resolved_method,
1228                                                   Handle recv, TRAPS) {
1229 
1230   Klass* resolved_klass = link_info.resolved_klass();
1231 
1232   // resolved method is selected method unless we have an old-style lookup
1233   // for a superclass method
1234   // Invokespecial for a superinterface, resolved method is selected method,
1235   // no checks for shadowing
1236   methodHandle sel_method(THREAD, resolved_method());
1237 
1238   if (link_info.check_access() &amp;&amp;
<span class="line-modified">1239       // check if the method is not &lt;init&gt;, which is never inherited</span>
1240       resolved_method-&gt;name() != vmSymbols::object_initializer_name()) {
1241 
1242     Klass* current_klass = link_info.current_klass();
1243 
1244     // Check if the class of the resolved_klass is a superclass
1245     // (not supertype in order to exclude interface classes) of the current class.
1246     // This check is not performed for super.invoke for interface methods
1247     // in super interfaces.
1248     if (current_klass-&gt;is_subclass_of(resolved_klass) &amp;&amp;
1249         current_klass != resolved_klass) {
1250       // Lookup super method
1251       Klass* super_klass = current_klass-&gt;super();
1252       Method* instance_method = lookup_instance_method_in_klasses(super_klass,
1253                                                      resolved_method-&gt;name(),
1254                                                      resolved_method-&gt;signature(),
1255                                                      Klass::find_private, CHECK);
1256       sel_method = methodHandle(THREAD, instance_method);
1257 
1258       // check if found
1259       if (sel_method.is_null()) {
</pre>
<hr />
<pre>
1639 
1640 
1641 
1642 //------------------------------------------------------------------------------------------------------------------------
1643 // ConstantPool entries
1644 
1645 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, Bytecodes::Code byte, TRAPS) {
1646   switch (byte) {
1647     case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;
1648     case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index, CHECK); break;
1649     case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;
1650     case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;
1651     case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;
1652     case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;
1653     default                         :                                                            break;
1654   }
1655   return;
1656 }
1657 
1658 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
<span class="line-modified">1659                                   const methodHandle&amp; attached_method,</span>
<span class="line-modified">1660                                   Bytecodes::Code byte, bool check_null_and_abstract, TRAPS) {</span>
1661   Klass* defc = attached_method-&gt;method_holder();
1662   Symbol* name = attached_method-&gt;name();
1663   Symbol* type = attached_method-&gt;signature();
1664   LinkInfo link_info(defc, name, type);
<span class="line-added">1665   Klass* recv_klass = recv.is_null() ? defc : recv-&gt;klass();</span>
1666   switch(byte) {
1667     case Bytecodes::_invokevirtual:
<span class="line-modified">1668       resolve_virtual_call(result, recv, recv_klass, link_info,</span>
<span class="line-modified">1669                            check_null_and_abstract, CHECK);</span>
1670       break;
1671     case Bytecodes::_invokeinterface:
<span class="line-modified">1672       resolve_interface_call(result, recv, recv_klass, link_info,</span>
<span class="line-modified">1673                              check_null_and_abstract, CHECK);</span>
1674       break;
1675     case Bytecodes::_invokestatic:
1676       resolve_static_call(result, link_info, /*initialize_class=*/false, CHECK);
1677       break;
1678     case Bytecodes::_invokespecial:
1679       resolve_special_call(result, recv, link_info, CHECK);
1680       break;
1681     default:
1682       fatal(&quot;bad call: %s&quot;, Bytecodes::name(byte));
1683       break;
1684   }
1685 }
1686 
1687 void LinkResolver::resolve_invokestatic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1688   LinkInfo link_info(pool, index, CHECK);
1689   resolve_static_call(result, link_info, /*initialize_class*/true, CHECK);
1690 }
1691 
1692 
1693 void LinkResolver::resolve_invokespecial(CallInfo&amp; result, Handle recv,
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../memory/dynamicArchive.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
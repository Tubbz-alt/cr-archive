<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/objArrayKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="objArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbol.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/objArrayKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24 
 25 #ifndef SHARE_OOPS_OBJARRAYKLASS_HPP
 26 #define SHARE_OOPS_OBJARRAYKLASS_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;oops/arrayKlass.hpp&quot;
 30 #include &quot;utilities/macros.hpp&quot;
 31 
 32 // ObjArrayKlass is the klass for objArrays
 33 
 34 class ObjArrayKlass : public ArrayKlass {
 35   friend class VMStructs;
 36   friend class JVMCIVMStructs;
 37 
 38  public:
 39   static const KlassID ID = ObjArrayKlassID;
 40 
 41  private:
 42   // If you add a new field that points to any metaspace object, you
 43   // must add this field to ObjArrayKlass::metaspace_pointers_do().
<span class="line-removed"> 44   Klass* _element_klass;            // The klass of the elements of this array type</span>
 45   Klass* _bottom_klass;             // The one-dimensional type (InstanceKlass or TypeArrayKlass)
 46 
 47   // Constructor
 48   ObjArrayKlass(int n, Klass* element_klass, Symbol* name);
 49   static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS);
 50  public:
 51   // For dummy objects
 52   ObjArrayKlass() {}
 53 
<span class="line-removed"> 54   // Instance variables</span>
<span class="line-removed"> 55   Klass* element_klass() const      { return _element_klass; }</span>
<span class="line-removed"> 56   void set_element_klass(Klass* k)  { _element_klass = k; }</span>
<span class="line-removed"> 57   Klass** element_klass_addr()      { return &amp;_element_klass; }</span>
<span class="line-removed"> 58 </span>
 59   Klass* bottom_klass() const       { return _bottom_klass; }
 60   void set_bottom_klass(Klass* k)   { _bottom_klass = k; }
 61   Klass** bottom_klass_addr()       { return &amp;_bottom_klass; }
 62 
 63   ModuleEntry* module() const;
 64   PackageEntry* package() const;
 65 
<span class="line-removed"> 66   // Compiler/Interpreter offset</span>
<span class="line-removed"> 67   static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ObjArrayKlass, _element_klass)); }</span>
<span class="line-removed"> 68 </span>
 69   // Dispatched operation
 70   bool can_be_primary_super_slow() const;
 71   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
 72                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
 73   DEBUG_ONLY(bool is_objArray_klass_slow()  const  { return true; })
 74   int oop_size(oop obj) const;
 75 
 76   // Allocation
 77   static ObjArrayKlass* allocate_objArray_klass(ClassLoaderData* loader_data,
 78                                                 int n, Klass* element_klass, TRAPS);
 79 
 80   objArrayOop allocate(int length, TRAPS);
 81   oop multi_allocate(int rank, jint* sizes, TRAPS);
 82 
 83   // Copying
 84   void  copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS);
 85 
 86   // Compute protection domain
 87   oop protection_domain() const { return bottom_klass()-&gt;protection_domain(); }
 88 
</pre>
</td>
<td>
<hr />
<pre>
 24 
 25 #ifndef SHARE_OOPS_OBJARRAYKLASS_HPP
 26 #define SHARE_OOPS_OBJARRAYKLASS_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;oops/arrayKlass.hpp&quot;
 30 #include &quot;utilities/macros.hpp&quot;
 31 
 32 // ObjArrayKlass is the klass for objArrays
 33 
 34 class ObjArrayKlass : public ArrayKlass {
 35   friend class VMStructs;
 36   friend class JVMCIVMStructs;
 37 
 38  public:
 39   static const KlassID ID = ObjArrayKlassID;
 40 
 41  private:
 42   // If you add a new field that points to any metaspace object, you
 43   // must add this field to ObjArrayKlass::metaspace_pointers_do().

 44   Klass* _bottom_klass;             // The one-dimensional type (InstanceKlass or TypeArrayKlass)
 45 
 46   // Constructor
 47   ObjArrayKlass(int n, Klass* element_klass, Symbol* name);
 48   static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS);
 49  public:
 50   // For dummy objects
 51   ObjArrayKlass() {}
 52 





 53   Klass* bottom_klass() const       { return _bottom_klass; }
 54   void set_bottom_klass(Klass* k)   { _bottom_klass = k; }
 55   Klass** bottom_klass_addr()       { return &amp;_bottom_klass; }
 56 
 57   ModuleEntry* module() const;
 58   PackageEntry* package() const;
 59 



 60   // Dispatched operation
 61   bool can_be_primary_super_slow() const;
 62   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
 63                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
 64   DEBUG_ONLY(bool is_objArray_klass_slow()  const  { return true; })
 65   int oop_size(oop obj) const;
 66 
 67   // Allocation
 68   static ObjArrayKlass* allocate_objArray_klass(ClassLoaderData* loader_data,
 69                                                 int n, Klass* element_klass, TRAPS);
 70 
 71   objArrayOop allocate(int length, TRAPS);
 72   oop multi_allocate(int rank, jint* sizes, TRAPS);
 73 
 74   // Copying
 75   void  copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS);
 76 
 77   // Compute protection domain
 78   oop protection_domain() const { return bottom_klass()-&gt;protection_domain(); }
 79 
</pre>
</td>
</tr>
</table>
<center><a href="objArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbol.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
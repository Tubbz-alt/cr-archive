<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/typeArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="symbol.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/compile.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/typeArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 79 TypeArrayKlass::TypeArrayKlass(BasicType type, Symbol* name) : ArrayKlass(name, ID) {
 80   set_layout_helper(array_layout_helper(type));
 81   assert(is_array_klass(), &quot;sanity&quot;);
 82   assert(is_typeArray_klass(), &quot;sanity&quot;);
 83 
 84   set_max_length(arrayOopDesc::max_array_length(type));
 85   assert(size() &gt;= TypeArrayKlass::header_size(), &quot;bad size&quot;);
 86 
 87   set_class_loader_data(ClassLoaderData::the_null_class_loader_data());
 88 }
 89 
 90 typeArrayOop TypeArrayKlass::allocate_common(int length, bool do_zero, TRAPS) {
 91   assert(log2_element_size() &gt;= 0, &quot;bad scale&quot;);
 92   check_array_allocation_length(length, max_length(), CHECK_NULL);
 93   size_t size = typeArrayOopDesc::object_size(layout_helper(), length);
 94   return (typeArrayOop)Universe::heap()-&gt;array_allocate(this, (int)size, length,
 95                                                         do_zero, CHECK_NULL);
 96 }
 97 
 98 oop TypeArrayKlass::multi_allocate(int rank, jint* last_size, TRAPS) {
<span class="line-removed"> 99   // For typeArrays this is only called for the last dimension</span>
100   assert(rank == 1, &quot;just checking&quot;);
101   int length = *last_size;
102   return allocate(length, THREAD);
103 }
104 
105 
106 void TypeArrayKlass::copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS) {
107   assert(s-&gt;is_typeArray(), &quot;must be type array&quot;);
108 
109   // Check destination type.
110   if (!d-&gt;is_typeArray()) {
111     ResourceMark rm(THREAD);
112     stringStream ss;
113     if (d-&gt;is_objArray()) {
114       ss.print(&quot;arraycopy: type mismatch: can not copy %s[] into object array[]&quot;,
115                type2name_tab[ArrayKlass::cast(s-&gt;klass())-&gt;element_type()]);
116     } else {
117       ss.print(&quot;arraycopy: destination type %s is not an array&quot;, d-&gt;klass()-&gt;external_name());
118     }
119     THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
</pre>
<hr />
<pre>
166 
167   // This is an attempt to make the copy_array fast.
168   int l2es = log2_element_size();
169   size_t src_offset = arrayOopDesc::base_offset_in_bytes(element_type()) + ((size_t)src_pos &lt;&lt; l2es);
170   size_t dst_offset = arrayOopDesc::base_offset_in_bytes(element_type()) + ((size_t)dst_pos &lt;&lt; l2es);
171   ArrayAccess&lt;ARRAYCOPY_ATOMIC&gt;::arraycopy&lt;void&gt;(s, src_offset, d, dst_offset, (size_t)length &lt;&lt; l2es);
172 }
173 
174 // create a klass of array holding typeArrays
175 Klass* TypeArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
176   int dim = dimension();
177   assert(dim &lt;= n, &quot;check order of chain&quot;);
178     if (dim == n)
179       return this;
180 
181   // lock-free read needs acquire semantics
182   if (higher_dimension_acquire() == NULL) {
183     if (or_null)  return NULL;
184 
185     ResourceMark rm;
<span class="line-removed">186     JavaThread *jt = (JavaThread *)THREAD;</span>
187     {
188       // Atomic create higher dimension and link into list
189       MutexLocker mu(THREAD, MultiArray_lock);
190 
191       if (higher_dimension() == NULL) {
192         Klass* oak = ObjArrayKlass::allocate_objArray_klass(
193               class_loader_data(), dim + 1, this, CHECK_NULL);
194         ObjArrayKlass* h_ak = ObjArrayKlass::cast(oak);
195         h_ak-&gt;set_lower_dimension(this);
196         // use &#39;release&#39; to pair with lock-free load
197         release_set_higher_dimension(h_ak);
198         assert(h_ak-&gt;is_objArray_klass(), &quot;incorrect initialization of ObjArrayKlass&quot;);
199       }
200     }
201   }
202 
203   ObjArrayKlass* h_ak = ObjArrayKlass::cast(higher_dimension());
204   if (or_null) {
205     return h_ak-&gt;array_klass_or_null(n);
206   }
</pre>
</td>
<td>
<hr />
<pre>
 79 TypeArrayKlass::TypeArrayKlass(BasicType type, Symbol* name) : ArrayKlass(name, ID) {
 80   set_layout_helper(array_layout_helper(type));
 81   assert(is_array_klass(), &quot;sanity&quot;);
 82   assert(is_typeArray_klass(), &quot;sanity&quot;);
 83 
 84   set_max_length(arrayOopDesc::max_array_length(type));
 85   assert(size() &gt;= TypeArrayKlass::header_size(), &quot;bad size&quot;);
 86 
 87   set_class_loader_data(ClassLoaderData::the_null_class_loader_data());
 88 }
 89 
 90 typeArrayOop TypeArrayKlass::allocate_common(int length, bool do_zero, TRAPS) {
 91   assert(log2_element_size() &gt;= 0, &quot;bad scale&quot;);
 92   check_array_allocation_length(length, max_length(), CHECK_NULL);
 93   size_t size = typeArrayOopDesc::object_size(layout_helper(), length);
 94   return (typeArrayOop)Universe::heap()-&gt;array_allocate(this, (int)size, length,
 95                                                         do_zero, CHECK_NULL);
 96 }
 97 
 98 oop TypeArrayKlass::multi_allocate(int rank, jint* last_size, TRAPS) {

 99   assert(rank == 1, &quot;just checking&quot;);
100   int length = *last_size;
101   return allocate(length, THREAD);
102 }
103 
104 
105 void TypeArrayKlass::copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS) {
106   assert(s-&gt;is_typeArray(), &quot;must be type array&quot;);
107 
108   // Check destination type.
109   if (!d-&gt;is_typeArray()) {
110     ResourceMark rm(THREAD);
111     stringStream ss;
112     if (d-&gt;is_objArray()) {
113       ss.print(&quot;arraycopy: type mismatch: can not copy %s[] into object array[]&quot;,
114                type2name_tab[ArrayKlass::cast(s-&gt;klass())-&gt;element_type()]);
115     } else {
116       ss.print(&quot;arraycopy: destination type %s is not an array&quot;, d-&gt;klass()-&gt;external_name());
117     }
118     THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
</pre>
<hr />
<pre>
165 
166   // This is an attempt to make the copy_array fast.
167   int l2es = log2_element_size();
168   size_t src_offset = arrayOopDesc::base_offset_in_bytes(element_type()) + ((size_t)src_pos &lt;&lt; l2es);
169   size_t dst_offset = arrayOopDesc::base_offset_in_bytes(element_type()) + ((size_t)dst_pos &lt;&lt; l2es);
170   ArrayAccess&lt;ARRAYCOPY_ATOMIC&gt;::arraycopy&lt;void&gt;(s, src_offset, d, dst_offset, (size_t)length &lt;&lt; l2es);
171 }
172 
173 // create a klass of array holding typeArrays
174 Klass* TypeArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
175   int dim = dimension();
176   assert(dim &lt;= n, &quot;check order of chain&quot;);
177     if (dim == n)
178       return this;
179 
180   // lock-free read needs acquire semantics
181   if (higher_dimension_acquire() == NULL) {
182     if (or_null)  return NULL;
183 
184     ResourceMark rm;

185     {
186       // Atomic create higher dimension and link into list
187       MutexLocker mu(THREAD, MultiArray_lock);
188 
189       if (higher_dimension() == NULL) {
190         Klass* oak = ObjArrayKlass::allocate_objArray_klass(
191               class_loader_data(), dim + 1, this, CHECK_NULL);
192         ObjArrayKlass* h_ak = ObjArrayKlass::cast(oak);
193         h_ak-&gt;set_lower_dimension(this);
194         // use &#39;release&#39; to pair with lock-free load
195         release_set_higher_dimension(h_ak);
196         assert(h_ak-&gt;is_objArray_klass(), &quot;incorrect initialization of ObjArrayKlass&quot;);
197       }
198     }
199   }
200 
201   ObjArrayKlass* h_ak = ObjArrayKlass::cast(higher_dimension());
202   if (or_null) {
203     return h_ak-&gt;array_klass_or_null(n);
204   }
</pre>
</td>
</tr>
</table>
<center><a href="symbol.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/compile.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/klassVtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klassVtable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1095 
1096 
1097     // Iterate through all interfaces
1098     int i;
1099     for(i = 0; i &lt; num_interfaces; i++) {
1100       itableOffsetEntry* ioe = offset_entry(i);
1101       HandleMark hm(THREAD);
1102       Klass* interf = ioe-&gt;interface_klass();
1103       assert(interf != NULL &amp;&amp; ioe-&gt;offset() != 0, &quot;bad offset entry in itable&quot;);
1104       initialize_itable_for_interface(ioe-&gt;offset(), InstanceKlass::cast(interf), checkconstraints, CHECK);
1105     }
1106 
1107   }
1108   // Check that the last entry is empty
1109   itableOffsetEntry* ioe = offset_entry(size_offset_table() - 1);
1110   guarantee(ioe-&gt;interface_klass() == NULL &amp;&amp; ioe-&gt;offset() == 0, &quot;terminator entry missing&quot;);
1111 }
1112 
1113 
1114 inline bool interface_method_needs_itable_index(Method* m) {
<span class="line-modified">1115   if (m-&gt;is_static())           return false;   // e.g., Stream.empty</span>
<span class="line-modified">1116   if (m-&gt;is_initializer())      return false;   // &lt;init&gt; or &lt;clinit&gt;</span>
<span class="line-modified">1117   if (m-&gt;is_private())          return false;   // uses direct call</span>

1118   // If an interface redeclares a method from java.lang.Object,
1119   // it should already have a vtable index, don&#39;t touch it.
1120   // e.g., CharSequence.toString (from initialize_vtable)
1121   // if (m-&gt;has_vtable_index())  return false; // NO!
1122   return true;
1123 }
1124 
1125 int klassItable::assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS) {
1126   // an interface does not have an itable, but its methods need to be numbered
1127   ResourceMark rm(THREAD);
1128   log_develop_debug(itables)(&quot;%3d: Initializing itable indices for interface %s&quot;,
1129                              ++initialize_count, klass-&gt;name()-&gt;as_C_string());
1130   Array&lt;Method*&gt;* methods = klass-&gt;methods();
1131   int nof_methods = methods-&gt;length();
1132   int ime_num = 0;
1133   for (int i = 0; i &lt; nof_methods; i++) {
1134     Method* m = methods-&gt;at(i);
1135     if (interface_method_needs_itable_index(m)) {
1136       assert(!m-&gt;is_final_method(), &quot;no final interface methods&quot;);
1137       // If m is already assigned a vtable index, do not disturb it.
</pre>
<hr />
<pre>
1327       tty-&gt;print(&quot;      (%5d)  &quot;, i);
1328       m-&gt;access_flags().print_on(tty);
1329       if (m-&gt;is_default_method()) {
1330         tty-&gt;print(&quot;default &quot;);
1331       }
1332       tty-&gt;print(&quot; --  &quot;);
1333       m-&gt;print_name(tty);
1334       tty-&gt;cr();
1335     }
1336     ime++;
1337   }
1338 }
1339 #endif // INCLUDE_JVMTI
1340 
1341 // Setup
1342 class InterfaceVisiterClosure : public StackObj {
1343  public:
1344   virtual void doit(InstanceKlass* intf, int method_count) = 0;
1345 };
1346 












1347 // Visit all interfaces with at least one itable method
1348 void visit_all_interfaces(Array&lt;InstanceKlass*&gt;* transitive_intf, InterfaceVisiterClosure *blk) {
1349   // Handle array argument
1350   for(int i = 0; i &lt; transitive_intf-&gt;length(); i++) {
1351     InstanceKlass* intf = transitive_intf-&gt;at(i);
1352     assert(intf-&gt;is_interface(), &quot;sanity check&quot;);
1353 
1354     // Find no. of itable methods
1355     int method_count = 0;
1356     // method_count = klassItable::method_count_for_interface(intf);
1357     Array&lt;Method*&gt;* methods = intf-&gt;methods();
1358     if (methods-&gt;length() &gt; 0) {
1359       for (int i = methods-&gt;length(); --i &gt;= 0; ) {
1360         if (interface_method_needs_itable_index(methods-&gt;at(i))) {
1361           method_count++;
1362         }
1363       }
1364     }
1365 
1366     // Visit all interfaces which either have any methods or can participate in receiver type check.
</pre>
<hr />
<pre>
1395     _klass_begin  = klass_begin;
1396     _offset_entry = offset_entry;
1397     _method_entry = method_entry;
1398   }
1399 
1400   itableMethodEntry* method_entry() const { return _method_entry; }
1401 
1402   void doit(InstanceKlass* intf, int method_count) {
1403     int offset = ((address)_method_entry) - _klass_begin;
1404     _offset_entry-&gt;initialize(intf, offset);
1405     _offset_entry++;
1406     _method_entry += method_count;
1407   }
1408 };
1409 
1410 int klassItable::compute_itable_size(Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
1411   // Count no of interfaces and total number of interface methods
1412   CountInterfacesClosure cic;
1413   visit_all_interfaces(transitive_interfaces, &amp;cic);
1414 
<span class="line-modified">1415   // There&#39;s alway an extra itable entry so we can null-terminate it.</span>
1416   int itable_size = calc_itable_size(cic.nof_interfaces() + 1, cic.nof_methods());
1417 
1418   // Statistics
1419   update_stats(itable_size * wordSize);
1420 
1421   return itable_size;
1422 }
1423 
1424 
1425 // Fill out offset table and interface klasses into the itable space
1426 void klassItable::setup_itable_offset_table(InstanceKlass* klass) {
1427   if (klass-&gt;itable_length() == 0) return;
1428   assert(!klass-&gt;is_interface(), &quot;Should have zero length itable&quot;);
1429 
1430   // Count no of interfaces and total number of interface methods
1431   CountInterfacesClosure cic;
1432   visit_all_interfaces(klass-&gt;transitive_interfaces(), &amp;cic);
1433   int nof_methods    = cic.nof_methods();
1434   int nof_interfaces = cic.nof_interfaces();
1435 
</pre>
</td>
<td>
<hr />
<pre>
1095 
1096 
1097     // Iterate through all interfaces
1098     int i;
1099     for(i = 0; i &lt; num_interfaces; i++) {
1100       itableOffsetEntry* ioe = offset_entry(i);
1101       HandleMark hm(THREAD);
1102       Klass* interf = ioe-&gt;interface_klass();
1103       assert(interf != NULL &amp;&amp; ioe-&gt;offset() != 0, &quot;bad offset entry in itable&quot;);
1104       initialize_itable_for_interface(ioe-&gt;offset(), InstanceKlass::cast(interf), checkconstraints, CHECK);
1105     }
1106 
1107   }
1108   // Check that the last entry is empty
1109   itableOffsetEntry* ioe = offset_entry(size_offset_table() - 1);
1110   guarantee(ioe-&gt;interface_klass() == NULL &amp;&amp; ioe-&gt;offset() == 0, &quot;terminator entry missing&quot;);
1111 }
1112 
1113 
1114 inline bool interface_method_needs_itable_index(Method* m) {
<span class="line-modified">1115   if (m-&gt;is_static())             return false;   // e.g., Stream.empty</span>
<span class="line-modified">1116   if (m-&gt;is_private())            return false;   // uses direct call</span>
<span class="line-modified">1117   if (m-&gt;is_object_constructor()) return false;   // &lt;init&gt;(...)V</span>
<span class="line-added">1118   if (m-&gt;is_class_initializer())  return false;   // &lt;clinit&gt;()V</span>
1119   // If an interface redeclares a method from java.lang.Object,
1120   // it should already have a vtable index, don&#39;t touch it.
1121   // e.g., CharSequence.toString (from initialize_vtable)
1122   // if (m-&gt;has_vtable_index())  return false; // NO!
1123   return true;
1124 }
1125 
1126 int klassItable::assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS) {
1127   // an interface does not have an itable, but its methods need to be numbered
1128   ResourceMark rm(THREAD);
1129   log_develop_debug(itables)(&quot;%3d: Initializing itable indices for interface %s&quot;,
1130                              ++initialize_count, klass-&gt;name()-&gt;as_C_string());
1131   Array&lt;Method*&gt;* methods = klass-&gt;methods();
1132   int nof_methods = methods-&gt;length();
1133   int ime_num = 0;
1134   for (int i = 0; i &lt; nof_methods; i++) {
1135     Method* m = methods-&gt;at(i);
1136     if (interface_method_needs_itable_index(m)) {
1137       assert(!m-&gt;is_final_method(), &quot;no final interface methods&quot;);
1138       // If m is already assigned a vtable index, do not disturb it.
</pre>
<hr />
<pre>
1328       tty-&gt;print(&quot;      (%5d)  &quot;, i);
1329       m-&gt;access_flags().print_on(tty);
1330       if (m-&gt;is_default_method()) {
1331         tty-&gt;print(&quot;default &quot;);
1332       }
1333       tty-&gt;print(&quot; --  &quot;);
1334       m-&gt;print_name(tty);
1335       tty-&gt;cr();
1336     }
1337     ime++;
1338   }
1339 }
1340 #endif // INCLUDE_JVMTI
1341 
1342 // Setup
1343 class InterfaceVisiterClosure : public StackObj {
1344  public:
1345   virtual void doit(InstanceKlass* intf, int method_count) = 0;
1346 };
1347 
<span class="line-added">1348 int count_interface_methods_needing_itable_index(Array&lt;Method*&gt;* methods) {</span>
<span class="line-added">1349   int method_count = 0;</span>
<span class="line-added">1350   if (methods-&gt;length() &gt; 0) {</span>
<span class="line-added">1351     for (int i = methods-&gt;length(); --i &gt;= 0; ) {</span>
<span class="line-added">1352       if (interface_method_needs_itable_index(methods-&gt;at(i))) {</span>
<span class="line-added">1353         method_count++;</span>
<span class="line-added">1354       }</span>
<span class="line-added">1355     }</span>
<span class="line-added">1356   }</span>
<span class="line-added">1357   return method_count;</span>
<span class="line-added">1358 }</span>
<span class="line-added">1359 </span>
1360 // Visit all interfaces with at least one itable method
1361 void visit_all_interfaces(Array&lt;InstanceKlass*&gt;* transitive_intf, InterfaceVisiterClosure *blk) {
1362   // Handle array argument
1363   for(int i = 0; i &lt; transitive_intf-&gt;length(); i++) {
1364     InstanceKlass* intf = transitive_intf-&gt;at(i);
1365     assert(intf-&gt;is_interface(), &quot;sanity check&quot;);
1366 
1367     // Find no. of itable methods
1368     int method_count = 0;
1369     // method_count = klassItable::method_count_for_interface(intf);
1370     Array&lt;Method*&gt;* methods = intf-&gt;methods();
1371     if (methods-&gt;length() &gt; 0) {
1372       for (int i = methods-&gt;length(); --i &gt;= 0; ) {
1373         if (interface_method_needs_itable_index(methods-&gt;at(i))) {
1374           method_count++;
1375         }
1376       }
1377     }
1378 
1379     // Visit all interfaces which either have any methods or can participate in receiver type check.
</pre>
<hr />
<pre>
1408     _klass_begin  = klass_begin;
1409     _offset_entry = offset_entry;
1410     _method_entry = method_entry;
1411   }
1412 
1413   itableMethodEntry* method_entry() const { return _method_entry; }
1414 
1415   void doit(InstanceKlass* intf, int method_count) {
1416     int offset = ((address)_method_entry) - _klass_begin;
1417     _offset_entry-&gt;initialize(intf, offset);
1418     _offset_entry++;
1419     _method_entry += method_count;
1420   }
1421 };
1422 
1423 int klassItable::compute_itable_size(Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
1424   // Count no of interfaces and total number of interface methods
1425   CountInterfacesClosure cic;
1426   visit_all_interfaces(transitive_interfaces, &amp;cic);
1427 
<span class="line-modified">1428   // There&#39;s always an extra itable entry so we can null-terminate it.</span>
1429   int itable_size = calc_itable_size(cic.nof_interfaces() + 1, cic.nof_methods());
1430 
1431   // Statistics
1432   update_stats(itable_size * wordSize);
1433 
1434   return itable_size;
1435 }
1436 
1437 
1438 // Fill out offset table and interface klasses into the itable space
1439 void klassItable::setup_itable_offset_table(InstanceKlass* klass) {
1440   if (klass-&gt;itable_length() == 0) return;
1441   assert(!klass-&gt;is_interface(), &quot;Should have zero length itable&quot;);
1442 
1443   // Count no of interfaces and total number of interface methods
1444   CountInterfacesClosure cic;
1445   visit_all_interfaces(klass-&gt;transitive_interfaces(), &amp;cic);
1446   int nof_methods    = cic.nof_methods();
1447   int nof_interfaces = cic.nof_interfaces();
1448 
</pre>
</td>
</tr>
</table>
<center><a href="klass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;code/exceptionHandlerTable.hpp&quot;
  31 #include &quot;code/nmethod.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/compileLog.hpp&quot;
  34 #include &quot;compiler/disassembler.hpp&quot;
  35 #include &quot;compiler/oopMap.hpp&quot;
  36 #include &quot;gc/shared/barrierSet.hpp&quot;
  37 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;opto/addnode.hpp&quot;
  40 #include &quot;opto/block.hpp&quot;
  41 #include &quot;opto/c2compiler.hpp&quot;
  42 #include &quot;opto/callGenerator.hpp&quot;
  43 #include &quot;opto/callnode.hpp&quot;
  44 #include &quot;opto/castnode.hpp&quot;
  45 #include &quot;opto/cfgnode.hpp&quot;
  46 #include &quot;opto/chaitin.hpp&quot;
  47 #include &quot;opto/compile.hpp&quot;
  48 #include &quot;opto/connode.hpp&quot;
  49 #include &quot;opto/convertnode.hpp&quot;
  50 #include &quot;opto/divnode.hpp&quot;
  51 #include &quot;opto/escape.hpp&quot;
  52 #include &quot;opto/idealGraphPrinter.hpp&quot;
  53 #include &quot;opto/loopnode.hpp&quot;
  54 #include &quot;opto/machnode.hpp&quot;
  55 #include &quot;opto/macro.hpp&quot;
  56 #include &quot;opto/matcher.hpp&quot;
  57 #include &quot;opto/mathexactnode.hpp&quot;
  58 #include &quot;opto/memnode.hpp&quot;
  59 #include &quot;opto/mulnode.hpp&quot;
  60 #include &quot;opto/narrowptrnode.hpp&quot;
  61 #include &quot;opto/node.hpp&quot;
  62 #include &quot;opto/opcodes.hpp&quot;
  63 #include &quot;opto/output.hpp&quot;
  64 #include &quot;opto/parse.hpp&quot;
  65 #include &quot;opto/phaseX.hpp&quot;
  66 #include &quot;opto/rootnode.hpp&quot;
  67 #include &quot;opto/runtime.hpp&quot;
  68 #include &quot;opto/stringopts.hpp&quot;
  69 #include &quot;opto/type.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  70 #include &quot;opto/valuetypenode.hpp&quot;</span>
  71 #include &quot;opto/vectornode.hpp&quot;
  72 #include &quot;runtime/arguments.hpp&quot;
  73 #include &quot;runtime/sharedRuntime.hpp&quot;
  74 #include &quot;runtime/signature.hpp&quot;
  75 #include &quot;runtime/stubRoutines.hpp&quot;
  76 #include &quot;runtime/timer.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/copy.hpp&quot;
  79 #include &quot;utilities/macros.hpp&quot;
  80 #include &quot;utilities/resourceHash.hpp&quot;
  81 
  82 
  83 // -------------------- Compile::mach_constant_base_node -----------------------
  84 // Constant table base node singleton.
  85 MachConstantBaseNode* Compile::mach_constant_base_node() {
  86   if (_mach_constant_base_node == NULL) {
  87     _mach_constant_base_node = new MachConstantBaseNode();
  88     _mach_constant_base_node-&gt;add_req(C-&gt;root());
  89   }
  90   return _mach_constant_base_node;
  91 }
  92 
  93 
  94 /// Support for intrinsics.
  95 
  96 // Return the index at which m must be inserted (or already exists).
  97 // The sort order is by the address of the ciMethod, with is_virtual as minor key.
  98 class IntrinsicDescPair {
  99  private:
 100   ciMethod* _m;
 101   bool _is_virtual;
 102  public:
 103   IntrinsicDescPair(ciMethod* m, bool is_virtual) : _m(m), _is_virtual(is_virtual) {}
 104   static int compare(IntrinsicDescPair* const&amp; key, CallGenerator* const&amp; elt) {
 105     ciMethod* m= elt-&gt;method();
 106     ciMethod* key_m = key-&gt;_m;
 107     if (key_m &lt; m)      return -1;
 108     else if (key_m &gt; m) return 1;
 109     else {
 110       bool is_virtual = elt-&gt;is_virtual();
 111       bool key_virtual = key-&gt;_is_virtual;
 112       if (key_virtual &lt; is_virtual)      return -1;
 113       else if (key_virtual &gt; is_virtual) return 1;
 114       else                               return 0;
 115     }
 116   }
 117 };
 118 int Compile::intrinsic_insertion_index(ciMethod* m, bool is_virtual, bool&amp; found) {
 119 #ifdef ASSERT
 120   for (int i = 1; i &lt; _intrinsics-&gt;length(); i++) {
 121     CallGenerator* cg1 = _intrinsics-&gt;at(i-1);
 122     CallGenerator* cg2 = _intrinsics-&gt;at(i);
 123     assert(cg1-&gt;method() != cg2-&gt;method()
 124            ? cg1-&gt;method()     &lt; cg2-&gt;method()
 125            : cg1-&gt;is_virtual() &lt; cg2-&gt;is_virtual(),
 126            &quot;compiler intrinsics list must stay sorted&quot;);
 127   }
 128 #endif
 129   IntrinsicDescPair pair(m, is_virtual);
 130   return _intrinsics-&gt;find_sorted&lt;IntrinsicDescPair*, IntrinsicDescPair::compare&gt;(&amp;pair, found);
 131 }
 132 
 133 void Compile::register_intrinsic(CallGenerator* cg) {
 134   if (_intrinsics == NULL) {
 135     _intrinsics = new (comp_arena())GrowableArray&lt;CallGenerator*&gt;(comp_arena(), 60, 0, NULL);
 136   }
 137   int len = _intrinsics-&gt;length();
 138   bool found = false;
 139   int index = intrinsic_insertion_index(cg-&gt;method(), cg-&gt;is_virtual(), found);
 140   assert(!found, &quot;registering twice&quot;);
 141   _intrinsics-&gt;insert_before(index, cg);
 142   assert(find_intrinsic(cg-&gt;method(), cg-&gt;is_virtual()) == cg, &quot;registration worked&quot;);
 143 }
 144 
 145 CallGenerator* Compile::find_intrinsic(ciMethod* m, bool is_virtual) {
 146   assert(m-&gt;is_loaded(), &quot;don&#39;t try this on unloaded methods&quot;);
 147   if (_intrinsics != NULL) {
 148     bool found = false;
 149     int index = intrinsic_insertion_index(m, is_virtual, found);
 150      if (found) {
 151       return _intrinsics-&gt;at(index);
 152     }
 153   }
 154   // Lazily create intrinsics for intrinsic IDs well-known in the runtime.
 155   if (m-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
 156       m-&gt;intrinsic_id() &lt;= vmIntrinsics::LAST_COMPILER_INLINE) {
 157     CallGenerator* cg = make_vm_intrinsic(m, is_virtual);
 158     if (cg != NULL) {
 159       // Save it for next time:
 160       register_intrinsic(cg);
 161       return cg;
 162     } else {
 163       gather_intrinsic_statistics(m-&gt;intrinsic_id(), is_virtual, _intrinsic_disabled);
 164     }
 165   }
 166   return NULL;
 167 }
 168 
 169 // Compile:: register_library_intrinsics and make_vm_intrinsic are defined
 170 // in library_call.cpp.
 171 
 172 
 173 #ifndef PRODUCT
 174 // statistics gathering...
 175 
 176 juint  Compile::_intrinsic_hist_count[vmIntrinsics::ID_LIMIT] = {0};
 177 jubyte Compile::_intrinsic_hist_flags[vmIntrinsics::ID_LIMIT] = {0};
 178 
 179 bool Compile::gather_intrinsic_statistics(vmIntrinsics::ID id, bool is_virtual, int flags) {
 180   assert(id &gt; vmIntrinsics::_none &amp;&amp; id &lt; vmIntrinsics::ID_LIMIT, &quot;oob&quot;);
 181   int oflags = _intrinsic_hist_flags[id];
 182   assert(flags != 0, &quot;what happened?&quot;);
 183   if (is_virtual) {
 184     flags |= _intrinsic_virtual;
 185   }
 186   bool changed = (flags != oflags);
 187   if ((flags &amp; _intrinsic_worked) != 0) {
 188     juint count = (_intrinsic_hist_count[id] += 1);
 189     if (count == 1) {
 190       changed = true;           // first time
 191     }
 192     // increment the overall count also:
 193     _intrinsic_hist_count[vmIntrinsics::_none] += 1;
 194   }
 195   if (changed) {
 196     if (((oflags ^ flags) &amp; _intrinsic_virtual) != 0) {
 197       // Something changed about the intrinsic&#39;s virtuality.
 198       if ((flags &amp; _intrinsic_virtual) != 0) {
 199         // This is the first use of this intrinsic as a virtual call.
 200         if (oflags != 0) {
 201           // We already saw it as a non-virtual, so note both cases.
 202           flags |= _intrinsic_both;
 203         }
 204       } else if ((oflags &amp; _intrinsic_both) == 0) {
 205         // This is the first use of this intrinsic as a non-virtual
 206         flags |= _intrinsic_both;
 207       }
 208     }
 209     _intrinsic_hist_flags[id] = (jubyte) (oflags | flags);
 210   }
 211   // update the overall flags also:
 212   _intrinsic_hist_flags[vmIntrinsics::_none] |= (jubyte) flags;
 213   return changed;
 214 }
 215 
 216 static char* format_flags(int flags, char* buf) {
 217   buf[0] = 0;
 218   if ((flags &amp; Compile::_intrinsic_worked) != 0)    strcat(buf, &quot;,worked&quot;);
 219   if ((flags &amp; Compile::_intrinsic_failed) != 0)    strcat(buf, &quot;,failed&quot;);
 220   if ((flags &amp; Compile::_intrinsic_disabled) != 0)  strcat(buf, &quot;,disabled&quot;);
 221   if ((flags &amp; Compile::_intrinsic_virtual) != 0)   strcat(buf, &quot;,virtual&quot;);
 222   if ((flags &amp; Compile::_intrinsic_both) != 0)      strcat(buf, &quot;,nonvirtual&quot;);
 223   if (buf[0] == 0)  strcat(buf, &quot;,&quot;);
 224   assert(buf[0] == &#39;,&#39;, &quot;must be&quot;);
 225   return &amp;buf[1];
 226 }
 227 
 228 void Compile::print_intrinsic_statistics() {
 229   char flagsbuf[100];
 230   ttyLocker ttyl;
 231   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;intrinsic&#39;&quot;);
 232   tty-&gt;print_cr(&quot;Compiler intrinsic usage:&quot;);
 233   juint total = _intrinsic_hist_count[vmIntrinsics::_none];
 234   if (total == 0)  total = 1;  // avoid div0 in case of no successes
 235   #define PRINT_STAT_LINE(name, c, f) \
 236     tty-&gt;print_cr(&quot;  %4d (%4.1f%%) %s (%s)&quot;, (int)(c), ((c) * 100.0) / total, name, f);
 237   for (int index = 1 + (int)vmIntrinsics::_none; index &lt; (int)vmIntrinsics::ID_LIMIT; index++) {
 238     vmIntrinsics::ID id = (vmIntrinsics::ID) index;
 239     int   flags = _intrinsic_hist_flags[id];
 240     juint count = _intrinsic_hist_count[id];
 241     if ((flags | count) != 0) {
 242       PRINT_STAT_LINE(vmIntrinsics::name_at(id), count, format_flags(flags, flagsbuf));
 243     }
 244   }
 245   PRINT_STAT_LINE(&quot;total&quot;, total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));
 246   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 247 }
 248 
 249 void Compile::print_statistics() {
 250   { ttyLocker ttyl;
 251     if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
 252     Parse::print_statistics();
 253     PhaseCCP::print_statistics();
 254     PhaseRegAlloc::print_statistics();
 255     PhaseOutput::print_statistics();
 256     PhasePeephole::print_statistics();
 257     PhaseIdealLoop::print_statistics();
 258     if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 259   }
 260   if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
 261     // put this under its own &lt;statistics&gt; element.
 262     print_intrinsic_statistics();
 263   }
 264 }
 265 #endif //PRODUCT
 266 
 267 void Compile::gvn_replace_by(Node* n, Node* nn) {
 268   for (DUIterator_Last imin, i = n-&gt;last_outs(imin); i &gt;= imin; ) {
 269     Node* use = n-&gt;last_out(i);
 270     bool is_in_table = initial_gvn()-&gt;hash_delete(use);
 271     uint uses_found = 0;
 272     for (uint j = 0; j &lt; use-&gt;len(); j++) {
 273       if (use-&gt;in(j) == n) {
 274         if (j &lt; use-&gt;req())
 275           use-&gt;set_req(j, nn);
 276         else
 277           use-&gt;set_prec(j, nn);
 278         uses_found++;
 279       }
 280     }
 281     if (is_in_table) {
 282       // reinsert into table
 283       initial_gvn()-&gt;hash_find_insert(use);
 284     }
 285     record_for_igvn(use);
 286     i -= uses_found;    // we deleted 1 or more copies of this edge
 287   }
 288 }
 289 
 290 
 291 static inline bool not_a_node(const Node* n) {
 292   if (n == NULL)                   return true;
 293   if (((intptr_t)n &amp; 1) != 0)      return true;  // uninitialized, etc.
 294   if (*(address*)n == badAddress)  return true;  // kill by Node::destruct
 295   return false;
 296 }
 297 
 298 // Identify all nodes that are reachable from below, useful.
 299 // Use breadth-first pass that records state in a Unique_Node_List,
 300 // recursive traversal is slower.
 301 void Compile::identify_useful_nodes(Unique_Node_List &amp;useful) {
 302   int estimated_worklist_size = live_nodes();
 303   useful.map( estimated_worklist_size, NULL );  // preallocate space
 304 
 305   // Initialize worklist
 306   if (root() != NULL)     { useful.push(root()); }
 307   // If &#39;top&#39; is cached, declare it useful to preserve cached node
 308   if( cached_top_node() ) { useful.push(cached_top_node()); }
 309 
 310   // Push all useful nodes onto the list, breadthfirst
 311   for( uint next = 0; next &lt; useful.size(); ++next ) {
 312     assert( next &lt; unique(), &quot;Unique useful nodes &lt; total nodes&quot;);
 313     Node *n  = useful.at(next);
 314     uint max = n-&gt;len();
 315     for( uint i = 0; i &lt; max; ++i ) {
 316       Node *m = n-&gt;in(i);
 317       if (not_a_node(m))  continue;
 318       useful.push(m);
 319     }
 320   }
 321 }
 322 
 323 // Update dead_node_list with any missing dead nodes using useful
 324 // list. Consider all non-useful nodes to be useless i.e., dead nodes.
 325 void Compile::update_dead_node_list(Unique_Node_List &amp;useful) {
 326   uint max_idx = unique();
 327   VectorSet&amp; useful_node_set = useful.member_set();
 328 
 329   for (uint node_idx = 0; node_idx &lt; max_idx; node_idx++) {
 330     // If node with index node_idx is not in useful set,
 331     // mark it as dead in dead node list.
 332     if (!useful_node_set.test(node_idx)) {
 333       record_dead_node(node_idx);
 334     }
 335   }
 336 }
 337 
 338 void Compile::remove_useless_late_inlines(GrowableArray&lt;CallGenerator*&gt;* inlines, Unique_Node_List &amp;useful) {
 339   int shift = 0;
 340   for (int i = 0; i &lt; inlines-&gt;length(); i++) {
 341     CallGenerator* cg = inlines-&gt;at(i);
 342     CallNode* call = cg-&gt;call_node();
 343     if (shift &gt; 0) {
 344       inlines-&gt;at_put(i-shift, cg);
 345     }
 346     if (!useful.member(call)) {
 347       shift++;
 348     }
 349   }
 350   inlines-&gt;trunc_to(inlines-&gt;length()-shift);
 351 }
 352 
 353 // Disconnect all useless nodes by disconnecting those at the boundary.
 354 void Compile::remove_useless_nodes(Unique_Node_List &amp;useful) {
 355   uint next = 0;
 356   while (next &lt; useful.size()) {
 357     Node *n = useful.at(next++);
 358     if (n-&gt;is_SafePoint()) {
 359       // We&#39;re done with a parsing phase. Replaced nodes are not valid
 360       // beyond that point.
 361       n-&gt;as_SafePoint()-&gt;delete_replaced_nodes();
 362     }
 363     // Use raw traversal of out edges since this code removes out edges
 364     int max = n-&gt;outcnt();
 365     for (int j = 0; j &lt; max; ++j) {
 366       Node* child = n-&gt;raw_out(j);
 367       if (! useful.member(child)) {
 368         assert(!child-&gt;is_top() || child != top(),
 369                &quot;If top is cached in Compile object it is in useful list&quot;);
 370         // Only need to remove this out-edge to the useless node
 371         n-&gt;raw_del_out(j);
 372         --j;
 373         --max;
 374       }
 375     }
 376     if (n-&gt;outcnt() == 1 &amp;&amp; n-&gt;has_special_unique_user()) {
 377       record_for_igvn(n-&gt;unique_out());
 378     }
 379   }
 380   // Remove useless macro and predicate opaq nodes
 381   for (int i = C-&gt;macro_count()-1; i &gt;= 0; i--) {
 382     Node* n = C-&gt;macro_node(i);
 383     if (!useful.member(n)) {
 384       remove_macro_node(n);
 385     }
 386   }
 387   // Remove useless CastII nodes with range check dependency
 388   for (int i = range_check_cast_count() - 1; i &gt;= 0; i--) {
 389     Node* cast = range_check_cast_node(i);
 390     if (!useful.member(cast)) {
 391       remove_range_check_cast(cast);
 392     }
 393   }
 394   // Remove useless expensive nodes
 395   for (int i = C-&gt;expensive_count()-1; i &gt;= 0; i--) {
 396     Node* n = C-&gt;expensive_node(i);
 397     if (!useful.member(n)) {
 398       remove_expensive_node(n);
 399     }
 400   }
 401   // Remove useless Opaque4 nodes
 402   for (int i = opaque4_count() - 1; i &gt;= 0; i--) {
 403     Node* opaq = opaque4_node(i);
 404     if (!useful.member(opaq)) {
 405       remove_opaque4_node(opaq);
 406     }
 407   }
<a name="2" id="anc2"></a><span class="line-added"> 408   // Remove useless value type nodes</span>
<span class="line-added"> 409   if (_value_type_nodes != NULL) {</span>
<span class="line-added"> 410     _value_type_nodes-&gt;remove_useless_nodes(useful.member_set());</span>
<span class="line-added"> 411   }</span>
 412   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 413   bs-&gt;eliminate_useless_gc_barriers(useful, this);
 414   // clean up the late inline lists
 415   remove_useless_late_inlines(&amp;_string_late_inlines, useful);
 416   remove_useless_late_inlines(&amp;_boxing_late_inlines, useful);
 417   remove_useless_late_inlines(&amp;_late_inlines, useful);
 418   debug_only(verify_graph_edges(true/*check for no_dead_code*/);)
 419 }
 420 
 421 // ============================================================================
 422 //------------------------------CompileWrapper---------------------------------
 423 class CompileWrapper : public StackObj {
 424   Compile *const _compile;
 425  public:
 426   CompileWrapper(Compile* compile);
 427 
 428   ~CompileWrapper();
 429 };
 430 
 431 CompileWrapper::CompileWrapper(Compile* compile) : _compile(compile) {
 432   // the Compile* pointer is stored in the current ciEnv:
 433   ciEnv* env = compile-&gt;env();
 434   assert(env == ciEnv::current(), &quot;must already be a ciEnv active&quot;);
 435   assert(env-&gt;compiler_data() == NULL, &quot;compile already active?&quot;);
 436   env-&gt;set_compiler_data(compile);
 437   assert(compile == Compile::current(), &quot;sanity&quot;);
 438 
 439   compile-&gt;set_type_dict(NULL);
 440   compile-&gt;set_clone_map(new Dict(cmpkey, hashkey, _compile-&gt;comp_arena()));
 441   compile-&gt;clone_map().set_clone_idx(0);
 442   compile-&gt;set_type_last_size(0);
 443   compile-&gt;set_last_tf(NULL, NULL);
 444   compile-&gt;set_indexSet_arena(NULL);
 445   compile-&gt;set_indexSet_free_block_list(NULL);
 446   compile-&gt;init_type_arena();
 447   Type::Initialize(compile);
 448   _compile-&gt;begin_method();
 449   _compile-&gt;clone_map().set_debug(_compile-&gt;has_method() &amp;&amp; _compile-&gt;directive()-&gt;CloneMapDebugOption);
 450 }
 451 CompileWrapper::~CompileWrapper() {
 452   _compile-&gt;end_method();
 453   _compile-&gt;env()-&gt;set_compiler_data(NULL);
 454 }
 455 
 456 
 457 //----------------------------print_compile_messages---------------------------
 458 void Compile::print_compile_messages() {
 459 #ifndef PRODUCT
 460   // Check if recompiling
 461   if (_subsume_loads == false &amp;&amp; PrintOpto) {
 462     // Recompiling without allowing machine instructions to subsume loads
 463     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 464     tty-&gt;print_cr(&quot;** Bailout: Recompile without subsuming loads          **&quot;);
 465     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 466   }
 467   if (_do_escape_analysis != DoEscapeAnalysis &amp;&amp; PrintOpto) {
 468     // Recompiling without escape analysis
 469     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 470     tty-&gt;print_cr(&quot;** Bailout: Recompile without escape analysis          **&quot;);
 471     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 472   }
 473   if (_eliminate_boxing != EliminateAutoBox &amp;&amp; PrintOpto) {
 474     // Recompiling without boxing elimination
 475     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 476     tty-&gt;print_cr(&quot;** Bailout: Recompile without boxing elimination       **&quot;);
 477     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 478   }
 479   if (C-&gt;directive()-&gt;BreakAtCompileOption) {
 480     // Open the debugger when compiling this method.
 481     tty-&gt;print(&quot;### Breaking when compiling: &quot;);
 482     method()-&gt;print_short_name();
 483     tty-&gt;cr();
 484     BREAKPOINT;
 485   }
 486 
 487   if( PrintOpto ) {
 488     if (is_osr_compilation()) {
 489       tty-&gt;print(&quot;[OSR]%3d&quot;, _compile_id);
 490     } else {
 491       tty-&gt;print(&quot;%3d&quot;, _compile_id);
 492     }
 493   }
 494 #endif
 495 }
 496 
 497 // ============================================================================
 498 //------------------------------Compile standard-------------------------------
 499 debug_only( int Compile::_debug_idx = 100000; )
 500 
 501 // Compile a method.  entry_bci is -1 for normal compilations and indicates
 502 // the continuation bci for on stack replacement.
 503 
 504 
 505 Compile::Compile( ciEnv* ci_env, ciMethod* target, int osr_bci,
 506                   bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
 507                 : Phase(Compiler),
 508                   _compile_id(ci_env-&gt;compile_id()),
 509                   _save_argument_registers(false),
 510                   _subsume_loads(subsume_loads),
 511                   _do_escape_analysis(do_escape_analysis),
 512                   _eliminate_boxing(eliminate_boxing),
 513                   _method(target),
 514                   _entry_bci(osr_bci),
 515                   _stub_function(NULL),
 516                   _stub_name(NULL),
 517                   _stub_entry_point(NULL),
 518                   _max_node_limit(MaxNodeLimit),
 519                   _inlining_progress(false),
 520                   _inlining_incrementally(false),
 521                   _do_cleanup(false),
 522                   _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
 523 #ifndef PRODUCT
 524                   _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 525                   _print_ideal(directive-&gt;PrintIdealOption),
 526 #endif
 527                   _has_method_handle_invokes(false),
 528                   _clinit_barrier_on_entry(false),
 529                   _comp_arena(mtCompiler),
 530                   _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 531                   _env(ci_env),
 532                   _directive(directive),
 533                   _log(ci_env-&gt;log()),
 534                   _failure_reason(NULL),
 535                   _congraph(NULL),
 536 #ifndef PRODUCT
 537                   _printer(IdealGraphPrinter::printer()),
 538 #endif
 539                   _dead_node_list(comp_arena()),
 540                   _dead_node_count(0),
 541                   _node_arena(mtCompiler),
 542                   _old_arena(mtCompiler),
 543                   _mach_constant_base_node(NULL),
 544                   _Compile_types(mtCompiler),
 545                   _initial_gvn(NULL),
 546                   _for_igvn(NULL),
 547                   _warm_calls(NULL),
 548                   _late_inlines(comp_arena(), 2, 0, NULL),
 549                   _string_late_inlines(comp_arena(), 2, 0, NULL),
 550                   _boxing_late_inlines(comp_arena(), 2, 0, NULL),
 551                   _late_inlines_pos(0),
 552                   _number_of_mh_late_inlines(0),
 553                   _print_inlining_stream(NULL),
 554                   _print_inlining_list(NULL),
 555                   _print_inlining_idx(0),
 556                   _print_inlining_output(NULL),
 557                   _replay_inline_data(NULL),
 558                   _java_calls(0),
 559                   _inner_loops(0),
 560                   _interpreter_frame_size(0)
 561 #ifndef PRODUCT
 562                   , _in_dump_cnt(0)
 563 #endif
 564 {
 565   C = this;
 566 #ifndef PRODUCT
 567   if (_printer != NULL) {
 568     _printer-&gt;set_compile(this);
 569   }
 570 #endif
 571   CompileWrapper cw(this);
 572 
 573   if (CITimeVerbose) {
 574     tty-&gt;print(&quot; &quot;);
 575     target-&gt;holder()-&gt;name()-&gt;print();
 576     tty-&gt;print(&quot;.&quot;);
 577     target-&gt;print_short_name();
 578     tty-&gt;print(&quot;  &quot;);
 579   }
 580   TraceTime t1(&quot;Total compilation time&quot;, &amp;_t_totalCompilation, CITime, CITimeVerbose);
 581   TraceTime t2(NULL, &amp;_t_methodCompilation, CITime, false);
 582 
 583 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)
 584   bool print_opto_assembly = directive-&gt;PrintOptoAssemblyOption;
 585   // We can always print a disassembly, either abstract (hex dump) or
 586   // with the help of a suitable hsdis library. Thus, we should not
 587   // couple print_assembly and print_opto_assembly controls.
 588   // But: always print opto and regular assembly on compile command &#39;print&#39;.
 589   bool print_assembly = directive-&gt;PrintAssemblyOption;
 590   set_print_assembly(print_opto_assembly || print_assembly);
 591 #else
 592   set_print_assembly(false); // must initialize.
 593 #endif
 594 
 595 #ifndef PRODUCT
 596   set_parsed_irreducible_loop(false);
 597 
 598   if (directive-&gt;ReplayInlineOption) {
 599     _replay_inline_data = ciReplay::load_inline_data(method(), entry_bci(), ci_env-&gt;comp_level());
 600   }
 601 #endif
 602   set_print_inlining(directive-&gt;PrintInliningOption || PrintOptoInlining);
 603   set_print_intrinsics(directive-&gt;PrintIntrinsicsOption);
 604   set_has_irreducible_loop(true); // conservative until build_loop_tree() reset it
 605 
 606   if (ProfileTraps RTM_OPT_ONLY( || UseRTMLocking )) {
 607     // Make sure the method being compiled gets its own MDO,
 608     // so we can at least track the decompile_count().
 609     // Need MDO to record RTM code generation state.
 610     method()-&gt;ensure_method_data();
 611   }
 612 
 613   Init(::AliasLevel);
 614 
 615 
 616   print_compile_messages();
 617 
 618   _ilt = InlineTree::build_inline_tree_root();
 619 
 620   // Even if NO memory addresses are used, MergeMem nodes must have at least 1 slice
 621   assert(num_alias_types() &gt;= AliasIdxRaw, &quot;&quot;);
 622 
 623 #define MINIMUM_NODE_HASH  1023
 624   // Node list that Iterative GVN will start with
 625   Unique_Node_List for_igvn(comp_arena());
 626   set_for_igvn(&amp;for_igvn);
 627 
 628   // GVN that will be run immediately on new nodes
 629   uint estimated_size = method()-&gt;code_size()*4+64;
 630   estimated_size = (estimated_size &lt; MINIMUM_NODE_HASH ? MINIMUM_NODE_HASH : estimated_size);
 631   PhaseGVN gvn(node_arena(), estimated_size);
 632   set_initial_gvn(&amp;gvn);
 633 
 634   print_inlining_init();
 635   { // Scope for timing the parser
 636     TracePhase tp(&quot;parse&quot;, &amp;timers[_t_parser]);
 637 
 638     // Put top into the hash table ASAP.
 639     initial_gvn()-&gt;transform_no_reclaim(top());
 640 
 641     // Set up tf(), start(), and find a CallGenerator.
 642     CallGenerator* cg = NULL;
 643     if (is_osr_compilation()) {
<a name="3" id="anc3"></a><span class="line-modified"> 644       init_tf(TypeFunc::make(method(), /* is_osr_compilation = */ true));</span>
<span class="line-modified"> 645       StartNode* s = new StartOSRNode(root(), tf()-&gt;domain_sig());</span>


 646       initial_gvn()-&gt;set_type_bottom(s);
 647       init_start(s);
 648       cg = CallGenerator::for_osr(method(), entry_bci());
 649     } else {
 650       // Normal case.
 651       init_tf(TypeFunc::make(method()));
<a name="4" id="anc4"></a><span class="line-modified"> 652       StartNode* s = new StartNode(root(), tf()-&gt;domain_cc());</span>
 653       initial_gvn()-&gt;set_type_bottom(s);
 654       init_start(s);
 655       if (method()-&gt;intrinsic_id() == vmIntrinsics::_Reference_get) {
 656         // With java.lang.ref.reference.get() we must go through the
 657         // intrinsic - even when get() is the root
 658         // method of the compile - so that, if necessary, the value in
 659         // the referent field of the reference object gets recorded by
 660         // the pre-barrier code.
 661         cg = find_intrinsic(method(), false);
 662       }
 663       if (cg == NULL) {
 664         float past_uses = method()-&gt;interpreter_invocation_count();
 665         float expected_uses = past_uses;
 666         cg = CallGenerator::for_inline(method(), expected_uses);
 667       }
 668     }
 669     if (failing())  return;
 670     if (cg == NULL) {
 671       record_method_not_compilable(&quot;cannot parse method&quot;);
 672       return;
 673     }
 674     JVMState* jvms = build_start_state(start(), tf());
 675     if ((jvms = cg-&gt;generate(jvms)) == NULL) {
 676       if (!failure_reason_is(C2Compiler::retry_class_loading_during_parsing())) {
 677         record_method_not_compilable(&quot;method parse failed&quot;);
 678       }
 679       return;
 680     }
 681     GraphKit kit(jvms);
 682 
 683     if (!kit.stopped()) {
 684       // Accept return values, and transfer control we know not where.
 685       // This is done by a special, unique ReturnNode bound to root.
 686       return_values(kit.jvms());
 687     }
 688 
 689     if (kit.has_exceptions()) {
 690       // Any exceptions that escape from this call must be rethrown
 691       // to whatever caller is dynamically above us on the stack.
 692       // This is done by a special, unique RethrowNode bound to root.
 693       rethrow_exceptions(kit.transfer_exceptions_into_jvms());
 694     }
 695 
 696     assert(IncrementalInline || (_late_inlines.length() == 0 &amp;&amp; !has_mh_late_inlines()), &quot;incremental inlining is off&quot;);
 697 
 698     if (_late_inlines.length() == 0 &amp;&amp; !has_mh_late_inlines() &amp;&amp; !failing() &amp;&amp; has_stringbuilder()) {
 699       inline_string_calls(true);
 700     }
 701 
 702     if (failing())  return;
 703 
 704     print_method(PHASE_BEFORE_REMOVEUSELESS, 3);
 705 
 706     // Remove clutter produced by parsing.
 707     if (!failing()) {
 708       ResourceMark rm;
 709       PhaseRemoveUseless pru(initial_gvn(), &amp;for_igvn);
 710     }
 711   }
 712 
 713   // Note:  Large methods are capped off in do_one_bytecode().
 714   if (failing())  return;
 715 
 716   // After parsing, node notes are no longer automagic.
 717   // They must be propagated by register_new_node_with_optimizer(),
 718   // clone(), or the like.
 719   set_default_node_notes(NULL);
 720 
 721   for (;;) {
 722     int successes = Inline_Warm();
 723     if (failing())  return;
 724     if (successes == 0)  break;
 725   }
 726 
 727   // Drain the list.
 728   Finish_Warm();
 729 #ifndef PRODUCT
 730   if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 731     _printer-&gt;print_inlining();
 732   }
 733 #endif
 734 
 735   if (failing())  return;
 736   NOT_PRODUCT( verify_graph_edges(); )
 737 
 738   // Now optimize
 739   Optimize();
 740   if (failing())  return;
 741   NOT_PRODUCT( verify_graph_edges(); )
 742 
 743 #ifndef PRODUCT
 744   if (print_ideal()) {
 745     ttyLocker ttyl;  // keep the following output all in one block
 746     // This output goes directly to the tty, not the compiler log.
 747     // To enable tools to match it up with the compilation activity,
 748     // be sure to tag this tty output with the compile ID.
 749     if (xtty != NULL) {
 750       xtty-&gt;head(&quot;ideal compile_id=&#39;%d&#39;%s&quot;, compile_id(),
 751                  is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :
 752                  &quot;&quot;);
 753     }
 754     root()-&gt;dump(9999);
 755     if (xtty != NULL) {
 756       xtty-&gt;tail(&quot;ideal&quot;);
 757     }
 758   }
 759 #endif
 760 
 761 #ifdef ASSERT
 762   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 763   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeCodeGen);
 764 #endif
 765 
 766   // Dump compilation data to replay it.
 767   if (directive-&gt;DumpReplayOption) {
 768     env()-&gt;dump_replay_data(_compile_id);
 769   }
 770   if (directive-&gt;DumpInlineOption &amp;&amp; (ilt() != NULL)) {
 771     env()-&gt;dump_inline_data(_compile_id);
 772   }
 773 
 774   // Now that we know the size of all the monitors we can add a fixed slot
 775   // for the original deopt pc.
 776   int next_slot = fixed_slots() + (sizeof(address) / VMRegImpl::stack_slot_size);
<a name="5" id="anc5"></a><span class="line-added"> 777   if (needs_stack_repair()) {</span>
<span class="line-added"> 778     // One extra slot for the special stack increment value</span>
<span class="line-added"> 779     next_slot += 2;</span>
<span class="line-added"> 780   }</span>
 781   set_fixed_slots(next_slot);
 782 
 783   // Compute when to use implicit null checks. Used by matching trap based
 784   // nodes and NullCheck optimization.
 785   set_allowed_deopt_reasons();
 786 
 787   // Now generate code
 788   Code_Gen();
 789 }
 790 
 791 //------------------------------Compile----------------------------------------
 792 // Compile a runtime stub
 793 Compile::Compile( ciEnv* ci_env,
 794                   TypeFunc_generator generator,
 795                   address stub_function,
 796                   const char *stub_name,
 797                   int is_fancy_jump,
 798                   bool pass_tls,
 799                   bool save_arg_registers,
 800                   bool return_pc,
 801                   DirectiveSet* directive)
 802   : Phase(Compiler),
 803     _compile_id(0),
 804     _save_argument_registers(save_arg_registers),
 805     _subsume_loads(true),
 806     _do_escape_analysis(false),
 807     _eliminate_boxing(false),
 808     _method(NULL),
 809     _entry_bci(InvocationEntryBci),
 810     _stub_function(stub_function),
 811     _stub_name(stub_name),
 812     _stub_entry_point(NULL),
 813     _max_node_limit(MaxNodeLimit),
 814     _inlining_progress(false),
 815     _inlining_incrementally(false),
 816     _has_reserved_stack_access(false),
 817 #ifndef PRODUCT
 818     _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 819     _print_ideal(directive-&gt;PrintIdealOption),
 820 #endif
 821     _has_method_handle_invokes(false),
 822     _clinit_barrier_on_entry(false),
 823     _comp_arena(mtCompiler),
 824     _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 825     _env(ci_env),
 826     _directive(directive),
 827     _log(ci_env-&gt;log()),
 828     _failure_reason(NULL),
 829     _congraph(NULL),
 830 #ifndef PRODUCT
 831     _printer(NULL),
 832 #endif
 833     _dead_node_list(comp_arena()),
 834     _dead_node_count(0),
 835     _node_arena(mtCompiler),
 836     _old_arena(mtCompiler),
 837     _mach_constant_base_node(NULL),
 838     _Compile_types(mtCompiler),
 839     _initial_gvn(NULL),
 840     _for_igvn(NULL),
 841     _warm_calls(NULL),
 842     _number_of_mh_late_inlines(0),
 843     _print_inlining_stream(NULL),
 844     _print_inlining_list(NULL),
 845     _print_inlining_idx(0),
 846     _print_inlining_output(NULL),
 847     _replay_inline_data(NULL),
 848     _java_calls(0),
 849     _inner_loops(0),
 850     _interpreter_frame_size(0),
 851 #ifndef PRODUCT
 852     _in_dump_cnt(0),
 853 #endif
 854     _allowed_reasons(0) {
 855   C = this;
 856 
 857   TraceTime t1(NULL, &amp;_t_totalCompilation, CITime, false);
 858   TraceTime t2(NULL, &amp;_t_stubCompilation, CITime, false);
 859 
 860 #ifndef PRODUCT
 861   set_print_assembly(PrintFrameConverterAssembly);
 862   set_parsed_irreducible_loop(false);
 863 #else
 864   set_print_assembly(false); // Must initialize.
 865 #endif
 866   set_has_irreducible_loop(false); // no loops
 867 
 868   CompileWrapper cw(this);
 869   Init(/*AliasLevel=*/ 0);
 870   init_tf((*generator)());
 871 
 872   {
 873     // The following is a dummy for the sake of GraphKit::gen_stub
 874     Unique_Node_List for_igvn(comp_arena());
 875     set_for_igvn(&amp;for_igvn);  // not used, but some GraphKit guys push on this
 876     PhaseGVN gvn(Thread::current()-&gt;resource_area(),255);
 877     set_initial_gvn(&amp;gvn);    // not significant, but GraphKit guys use it pervasively
 878     gvn.transform_no_reclaim(top());
 879 
 880     GraphKit kit;
 881     kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
 882   }
 883 
 884   NOT_PRODUCT( verify_graph_edges(); )
 885 
 886   Code_Gen();
 887 }
 888 
 889 //------------------------------Init-------------------------------------------
 890 // Prepare for a single compilation
 891 void Compile::Init(int aliaslevel) {
 892   _unique  = 0;
 893   _regalloc = NULL;
 894 
 895   _tf      = NULL;  // filled in later
 896   _top     = NULL;  // cached later
 897   _matcher = NULL;  // filled in later
 898   _cfg     = NULL;  // filled in later
 899 
 900   IA32_ONLY( set_24_bit_selection_and_mode(true, false); )
 901 
 902   _node_note_array = NULL;
 903   _default_node_notes = NULL;
 904   DEBUG_ONLY( _modified_nodes = NULL; ) // Used in Optimize()
 905 
 906   _immutable_memory = NULL; // filled in at first inquiry
 907 
 908   // Globally visible Nodes
 909   // First set TOP to NULL to give safe behavior during creation of RootNode
 910   set_cached_top_node(NULL);
 911   set_root(new RootNode());
 912   // Now that you have a Root to point to, create the real TOP
 913   set_cached_top_node( new ConNode(Type::TOP) );
 914   set_recent_alloc(NULL, NULL);
 915 
 916   // Create Debug Information Recorder to record scopes, oopmaps, etc.
 917   env()-&gt;set_oop_recorder(new OopRecorder(env()-&gt;arena()));
 918   env()-&gt;set_debug_info(new DebugInformationRecorder(env()-&gt;oop_recorder()));
 919   env()-&gt;set_dependencies(new Dependencies(env()));
 920 
 921   _fixed_slots = 0;
 922   set_has_split_ifs(false);
 923   set_has_loops(has_method() &amp;&amp; method()-&gt;has_loops()); // first approximation
 924   set_has_stringbuilder(false);
 925   set_has_boxed_value(false);
 926   _trap_can_recompile = false;  // no traps emitted yet
 927   _major_progress = true; // start out assuming good things will happen
 928   set_has_unsafe_access(false);
 929   set_max_vector_size(0);
 930   set_clear_upper_avx(false);  //false as default for clear upper bits of ymm registers
 931   Copy::zero_to_bytes(_trap_hist, sizeof(_trap_hist));
 932   set_decompile_count(0);
 933 
 934   set_do_freq_based_layout(_directive-&gt;BlockLayoutByFrequencyOption);
 935   _loop_opts_cnt = LoopOptsCount;
<a name="6" id="anc6"></a><span class="line-added"> 936   _has_flattened_accesses = false;</span>
<span class="line-added"> 937   _flattened_accesses_share_alias = true;</span>
<span class="line-added"> 938 </span>
 939   set_do_inlining(Inline);
 940   set_max_inline_size(MaxInlineSize);
 941   set_freq_inline_size(FreqInlineSize);
 942   set_do_scheduling(OptoScheduling);
 943   set_do_count_invocations(false);
 944   set_do_method_data_update(false);
 945 
 946   set_do_vector_loop(false);
 947 
 948   if (AllowVectorizeOnDemand) {
 949     if (has_method() &amp;&amp; (_directive-&gt;VectorizeOption || _directive-&gt;VectorizeDebugOption)) {
 950       set_do_vector_loop(true);
 951       NOT_PRODUCT(if (do_vector_loop() &amp;&amp; Verbose) {tty-&gt;print(&quot;Compile::Init: do vectorized loops (SIMD like) for method %s\n&quot;,  method()-&gt;name()-&gt;as_quoted_ascii());})
 952     } else if (has_method() &amp;&amp; method()-&gt;name() != 0 &amp;&amp;
 953                method()-&gt;intrinsic_id() == vmIntrinsics::_forEachRemaining) {
 954       set_do_vector_loop(true);
 955     }
 956   }
 957   set_use_cmove(UseCMoveUnconditionally /* || do_vector_loop()*/); //TODO: consider do_vector_loop() mandate use_cmove unconditionally
 958   NOT_PRODUCT(if (use_cmove() &amp;&amp; Verbose &amp;&amp; has_method()) {tty-&gt;print(&quot;Compile::Init: use CMove without profitability tests for method %s\n&quot;,  method()-&gt;name()-&gt;as_quoted_ascii());})
 959 
 960   set_age_code(has_method() &amp;&amp; method()-&gt;profile_aging());
 961   set_rtm_state(NoRTM); // No RTM lock eliding by default
 962   _max_node_limit = _directive-&gt;MaxNodeLimitOption;
 963 
 964 #if INCLUDE_RTM_OPT
 965   if (UseRTMLocking &amp;&amp; has_method() &amp;&amp; (method()-&gt;method_data_or_null() != NULL)) {
 966     int rtm_state = method()-&gt;method_data()-&gt;rtm_state();
 967     if (method_has_option(&quot;NoRTMLockEliding&quot;) || ((rtm_state &amp; NoRTM) != 0)) {
 968       // Don&#39;t generate RTM lock eliding code.
 969       set_rtm_state(NoRTM);
 970     } else if (method_has_option(&quot;UseRTMLockEliding&quot;) || ((rtm_state &amp; UseRTM) != 0) || !UseRTMDeopt) {
 971       // Generate RTM lock eliding code without abort ratio calculation code.
 972       set_rtm_state(UseRTM);
 973     } else if (UseRTMDeopt) {
 974       // Generate RTM lock eliding code and include abort ratio calculation
 975       // code if UseRTMDeopt is on.
 976       set_rtm_state(ProfileRTM);
 977     }
 978   }
 979 #endif
 980   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; has_method() &amp;&amp; !is_osr_compilation() &amp;&amp; method()-&gt;needs_clinit_barrier()) {
 981     set_clinit_barrier_on_entry(true);
 982   }
 983   if (debug_info()-&gt;recording_non_safepoints()) {
 984     set_node_note_array(new(comp_arena()) GrowableArray&lt;Node_Notes*&gt;
 985                         (comp_arena(), 8, 0, NULL));
 986     set_default_node_notes(Node_Notes::make(this));
 987   }
 988 
 989   // // -- Initialize types before each compile --
 990   // // Update cached type information
 991   // if( _method &amp;&amp; _method-&gt;constants() )
 992   //   Type::update_loaded_types(_method, _method-&gt;constants());
 993 
 994   // Init alias_type map.
 995   if (!_do_escape_analysis &amp;&amp; aliaslevel == 3)
 996     aliaslevel = 2;  // No unique types without escape analysis
 997   _AliasLevel = aliaslevel;
 998   const int grow_ats = 16;
 999   _max_alias_types = grow_ats;
1000   _alias_types   = NEW_ARENA_ARRAY(comp_arena(), AliasType*, grow_ats);
1001   AliasType* ats = NEW_ARENA_ARRAY(comp_arena(), AliasType,  grow_ats);
1002   Copy::zero_to_bytes(ats, sizeof(AliasType)*grow_ats);
1003   {
1004     for (int i = 0; i &lt; grow_ats; i++)  _alias_types[i] = &amp;ats[i];
1005   }
1006   // Initialize the first few types.
1007   _alias_types[AliasIdxTop]-&gt;Init(AliasIdxTop, NULL);
1008   _alias_types[AliasIdxBot]-&gt;Init(AliasIdxBot, TypePtr::BOTTOM);
1009   _alias_types[AliasIdxRaw]-&gt;Init(AliasIdxRaw, TypeRawPtr::BOTTOM);
1010   _num_alias_types = AliasIdxRaw+1;
1011   // Zero out the alias type cache.
1012   Copy::zero_to_bytes(_alias_cache, sizeof(_alias_cache));
1013   // A NULL adr_type hits in the cache right away.  Preload the right answer.
1014   probe_alias_cache(NULL)-&gt;_index = AliasIdxTop;
1015 
1016   _intrinsics = NULL;
1017   _macro_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1018   _predicate_opaqs = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1019   _expensive_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1020   _range_check_casts = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1021   _opaque4_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
<a name="7" id="anc7"></a><span class="line-added">1022   _value_type_nodes = new (comp_arena()) Unique_Node_List(comp_arena());</span>
1023   register_library_intrinsics();
1024 #ifdef ASSERT
1025   _type_verify_symmetry = true;
1026 #endif
1027 }
1028 
1029 //---------------------------init_start----------------------------------------
1030 // Install the StartNode on this compile object.
1031 void Compile::init_start(StartNode* s) {
1032   if (failing())
1033     return; // already failing
1034   assert(s == start(), &quot;&quot;);
1035 }
1036 
1037 /**
1038  * Return the &#39;StartNode&#39;. We must not have a pending failure, since the ideal graph
1039  * can be in an inconsistent state, i.e., we can get segmentation faults when traversing
1040  * the ideal graph.
1041  */
1042 StartNode* Compile::start() const {
1043   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());
1044   for (DUIterator_Fast imax, i = root()-&gt;fast_outs(imax); i &lt; imax; i++) {
1045     Node* start = root()-&gt;fast_out(i);
1046     if (start-&gt;is_Start()) {
1047       return start-&gt;as_Start();
1048     }
1049   }
1050   fatal(&quot;Did not find Start node!&quot;);
1051   return NULL;
1052 }
1053 
1054 //-------------------------------immutable_memory-------------------------------------
1055 // Access immutable memory
1056 Node* Compile::immutable_memory() {
1057   if (_immutable_memory != NULL) {
1058     return _immutable_memory;
1059   }
1060   StartNode* s = start();
1061   for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); true; i++) {
1062     Node *p = s-&gt;fast_out(i);
1063     if (p != s &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
1064       _immutable_memory = p;
1065       return _immutable_memory;
1066     }
1067   }
1068   ShouldNotReachHere();
1069   return NULL;
1070 }
1071 
1072 //----------------------set_cached_top_node------------------------------------
1073 // Install the cached top node, and make sure Node::is_top works correctly.
1074 void Compile::set_cached_top_node(Node* tn) {
1075   if (tn != NULL)  verify_top(tn);
1076   Node* old_top = _top;
1077   _top = tn;
1078   // Calling Node::setup_is_top allows the nodes the chance to adjust
1079   // their _out arrays.
1080   if (_top != NULL)     _top-&gt;setup_is_top();
1081   if (old_top != NULL)  old_top-&gt;setup_is_top();
1082   assert(_top == NULL || top()-&gt;is_top(), &quot;&quot;);
1083 }
1084 
1085 #ifdef ASSERT
1086 uint Compile::count_live_nodes_by_graph_walk() {
1087   Unique_Node_List useful(comp_arena());
1088   // Get useful node list by walking the graph.
1089   identify_useful_nodes(useful);
1090   return useful.size();
1091 }
1092 
1093 void Compile::print_missing_nodes() {
1094 
1095   // Return if CompileLog is NULL and PrintIdealNodeCount is false.
1096   if ((_log == NULL) &amp;&amp; (! PrintIdealNodeCount)) {
1097     return;
1098   }
1099 
1100   // This is an expensive function. It is executed only when the user
1101   // specifies VerifyIdealNodeCount option or otherwise knows the
1102   // additional work that needs to be done to identify reachable nodes
1103   // by walking the flow graph and find the missing ones using
1104   // _dead_node_list.
1105 
1106   Unique_Node_List useful(comp_arena());
1107   // Get useful node list by walking the graph.
1108   identify_useful_nodes(useful);
1109 
1110   uint l_nodes = C-&gt;live_nodes();
1111   uint l_nodes_by_walk = useful.size();
1112 
1113   if (l_nodes != l_nodes_by_walk) {
1114     if (_log != NULL) {
1115       _log-&gt;begin_head(&quot;mismatched_nodes count=&#39;%d&#39;&quot;, abs((int) (l_nodes - l_nodes_by_walk)));
1116       _log-&gt;stamp();
1117       _log-&gt;end_head();
1118     }
1119     VectorSet&amp; useful_member_set = useful.member_set();
1120     int last_idx = l_nodes_by_walk;
1121     for (int i = 0; i &lt; last_idx; i++) {
1122       if (useful_member_set.test(i)) {
1123         if (_dead_node_list.test(i)) {
1124           if (_log != NULL) {
1125             _log-&gt;elem(&quot;mismatched_node_info node_idx=&#39;%d&#39; type=&#39;both live and dead&#39;&quot;, i);
1126           }
1127           if (PrintIdealNodeCount) {
1128             // Print the log message to tty
1129               tty-&gt;print_cr(&quot;mismatched_node idx=&#39;%d&#39; both live and dead&#39;&quot;, i);
1130               useful.at(i)-&gt;dump();
1131           }
1132         }
1133       }
1134       else if (! _dead_node_list.test(i)) {
1135         if (_log != NULL) {
1136           _log-&gt;elem(&quot;mismatched_node_info node_idx=&#39;%d&#39; type=&#39;neither live nor dead&#39;&quot;, i);
1137         }
1138         if (PrintIdealNodeCount) {
1139           // Print the log message to tty
1140           tty-&gt;print_cr(&quot;mismatched_node idx=&#39;%d&#39; type=&#39;neither live nor dead&#39;&quot;, i);
1141         }
1142       }
1143     }
1144     if (_log != NULL) {
1145       _log-&gt;tail(&quot;mismatched_nodes&quot;);
1146     }
1147   }
1148 }
1149 void Compile::record_modified_node(Node* n) {
1150   if (_modified_nodes != NULL &amp;&amp; !_inlining_incrementally &amp;&amp;
1151       n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con()) {
1152     _modified_nodes-&gt;push(n);
1153   }
1154 }
1155 
1156 void Compile::remove_modified_node(Node* n) {
1157   if (_modified_nodes != NULL) {
1158     _modified_nodes-&gt;remove(n);
1159   }
1160 }
1161 #endif
1162 
1163 #ifndef PRODUCT
1164 void Compile::verify_top(Node* tn) const {
1165   if (tn != NULL) {
1166     assert(tn-&gt;is_Con(), &quot;top node must be a constant&quot;);
1167     assert(((ConNode*)tn)-&gt;type() == Type::TOP, &quot;top node must have correct type&quot;);
1168     assert(tn-&gt;in(0) != NULL, &quot;must have live top node&quot;);
1169   }
1170 }
1171 #endif
1172 
1173 
1174 ///-------------------Managing Per-Node Debug &amp; Profile Info-------------------
1175 
1176 void Compile::grow_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr, int grow_by) {
1177   guarantee(arr != NULL, &quot;&quot;);
1178   int num_blocks = arr-&gt;length();
1179   if (grow_by &lt; num_blocks)  grow_by = num_blocks;
1180   int num_notes = grow_by * _node_notes_block_size;
1181   Node_Notes* notes = NEW_ARENA_ARRAY(node_arena(), Node_Notes, num_notes);
1182   Copy::zero_to_bytes(notes, num_notes * sizeof(Node_Notes));
1183   while (num_notes &gt; 0) {
1184     arr-&gt;append(notes);
1185     notes     += _node_notes_block_size;
1186     num_notes -= _node_notes_block_size;
1187   }
1188   assert(num_notes == 0, &quot;exact multiple, please&quot;);
1189 }
1190 
1191 bool Compile::copy_node_notes_to(Node* dest, Node* source) {
1192   if (source == NULL || dest == NULL)  return false;
1193 
1194   if (dest-&gt;is_Con())
1195     return false;               // Do not push debug info onto constants.
1196 
1197 #ifdef ASSERT
1198   // Leave a bread crumb trail pointing to the original node:
1199   if (dest != NULL &amp;&amp; dest != source &amp;&amp; dest-&gt;debug_orig() == NULL) {
1200     dest-&gt;set_debug_orig(source);
1201   }
1202 #endif
1203 
1204   if (node_note_array() == NULL)
1205     return false;               // Not collecting any notes now.
1206 
1207   // This is a copy onto a pre-existing node, which may already have notes.
1208   // If both nodes have notes, do not overwrite any pre-existing notes.
1209   Node_Notes* source_notes = node_notes_at(source-&gt;_idx);
1210   if (source_notes == NULL || source_notes-&gt;is_clear())  return false;
1211   Node_Notes* dest_notes   = node_notes_at(dest-&gt;_idx);
1212   if (dest_notes == NULL || dest_notes-&gt;is_clear()) {
1213     return set_node_notes_at(dest-&gt;_idx, source_notes);
1214   }
1215 
1216   Node_Notes merged_notes = (*source_notes);
1217   // The order of operations here ensures that dest notes will win...
1218   merged_notes.update_from(dest_notes);
1219   return set_node_notes_at(dest-&gt;_idx, &amp;merged_notes);
1220 }
1221 
1222 
1223 //--------------------------allow_range_check_smearing-------------------------
1224 // Gating condition for coalescing similar range checks.
1225 // Sometimes we try &#39;speculatively&#39; replacing a series of a range checks by a
1226 // single covering check that is at least as strong as any of them.
1227 // If the optimization succeeds, the simplified (strengthened) range check
1228 // will always succeed.  If it fails, we will deopt, and then give up
1229 // on the optimization.
1230 bool Compile::allow_range_check_smearing() const {
1231   // If this method has already thrown a range-check,
1232   // assume it was because we already tried range smearing
1233   // and it failed.
1234   uint already_trapped = trap_count(Deoptimization::Reason_range_check);
1235   return !already_trapped;
1236 }
1237 
1238 
1239 //------------------------------flatten_alias_type-----------------------------
1240 const TypePtr *Compile::flatten_alias_type( const TypePtr *tj ) const {
1241   int offset = tj-&gt;offset();
1242   TypePtr::PTR ptr = tj-&gt;ptr();
1243 
1244   // Known instance (scalarizable allocation) alias only with itself.
1245   bool is_known_inst = tj-&gt;isa_oopptr() != NULL &amp;&amp;
1246                        tj-&gt;is_oopptr()-&gt;is_known_instance();
1247 
1248   // Process weird unsafe references.
1249   if (offset == Type::OffsetBot &amp;&amp; (tj-&gt;isa_instptr() /*|| tj-&gt;isa_klassptr()*/)) {
<a name="8" id="anc8"></a><span class="line-modified">1250     bool default_value_load = EnableValhalla &amp;&amp; tj-&gt;is_instptr()-&gt;klass() == ciEnv::current()-&gt;Class_klass();</span>
<span class="line-added">1251     assert(InlineUnsafeOps || default_value_load, &quot;indeterminate pointers come only from unsafe ops&quot;);</span>
1252     assert(!is_known_inst, &quot;scalarizable allocation should not have unsafe references&quot;);
1253     tj = TypeOopPtr::BOTTOM;
1254     ptr = tj-&gt;ptr();
1255     offset = tj-&gt;offset();
1256   }
1257 
1258   // Array pointers need some flattening
1259   const TypeAryPtr *ta = tj-&gt;isa_aryptr();
1260   if (ta &amp;&amp; ta-&gt;is_stable()) {
1261     // Erase stability property for alias analysis.
1262     tj = ta = ta-&gt;cast_to_stable(false);
1263   }
<a name="9" id="anc9"></a><span class="line-added">1264   if (ta &amp;&amp; ta-&gt;is_not_flat()) {</span>
<span class="line-added">1265     // Erase not flat property for alias analysis.</span>
<span class="line-added">1266     tj = ta = ta-&gt;cast_to_not_flat(false);</span>
<span class="line-added">1267   }</span>
<span class="line-added">1268   if (ta &amp;&amp; ta-&gt;is_not_null_free()) {</span>
<span class="line-added">1269     // Erase not null free property for alias analysis.</span>
<span class="line-added">1270     tj = ta = ta-&gt;cast_to_not_null_free(false);</span>
<span class="line-added">1271   }</span>
<span class="line-added">1272 </span>
1273   if( ta &amp;&amp; is_known_inst ) {
1274     if ( offset != Type::OffsetBot &amp;&amp;
1275          offset &gt; arrayOopDesc::length_offset_in_bytes() ) {
1276       offset = Type::OffsetBot; // Flatten constant access into array body only
<a name="10" id="anc10"></a><span class="line-modified">1277       tj = ta = TypeAryPtr::make(ptr, ta-&gt;ary(), ta-&gt;klass(), true, Type::Offset(offset), ta-&gt;field_offset(), ta-&gt;instance_id());</span>
1278     }
1279   } else if( ta &amp;&amp; _AliasLevel &gt;= 2 ) {
1280     // For arrays indexed by constant indices, we flatten the alias
1281     // space to include all of the array body.  Only the header, klass
1282     // and array length can be accessed un-aliased.
<a name="11" id="anc11"></a><span class="line-added">1283     // For flattened value type array, each field has its own slice so</span>
<span class="line-added">1284     // we must include the field offset.</span>
1285     if( offset != Type::OffsetBot ) {
1286       if( ta-&gt;const_oop() ) { // MethodData* or Method*
1287         offset = Type::OffsetBot;   // Flatten constant access into array body
<a name="12" id="anc12"></a><span class="line-modified">1288         tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),ta-&gt;ary(),ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());</span>
1289       } else if( offset == arrayOopDesc::length_offset_in_bytes() ) {
1290         // range is OK as-is.
1291         tj = ta = TypeAryPtr::RANGE;
1292       } else if( offset == oopDesc::klass_offset_in_bytes() ) {
1293         tj = TypeInstPtr::KLASS; // all klass loads look alike
1294         ta = TypeAryPtr::RANGE; // generic ignored junk
1295         ptr = TypePtr::BotPTR;
1296       } else if( offset == oopDesc::mark_offset_in_bytes() ) {
1297         tj = TypeInstPtr::MARK;
1298         ta = TypeAryPtr::RANGE; // generic ignored junk
1299         ptr = TypePtr::BotPTR;
1300       } else {                  // Random constant offset into array body
1301         offset = Type::OffsetBot;   // Flatten constant access into array body
<a name="13" id="anc13"></a><span class="line-modified">1302         tj = ta = TypeAryPtr::make(ptr,ta-&gt;ary(),ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());</span>
1303       }
1304     }
1305     // Arrays of fixed size alias with arrays of unknown size.
1306     if (ta-&gt;size() != TypeInt::POS) {
1307       const TypeAry *tary = TypeAry::make(ta-&gt;elem(), TypeInt::POS);
<a name="14" id="anc14"></a><span class="line-modified">1308       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());</span>
1309     }
1310     // Arrays of known objects become arrays of unknown objects.
1311     if (ta-&gt;elem()-&gt;isa_narrowoop() &amp;&amp; ta-&gt;elem() != TypeNarrowOop::BOTTOM) {
1312       const TypeAry *tary = TypeAry::make(TypeNarrowOop::BOTTOM, ta-&gt;size());
<a name="15" id="anc15"></a><span class="line-modified">1313       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,Type::Offset(offset), ta-&gt;field_offset());</span>
1314     }
1315     if (ta-&gt;elem()-&gt;isa_oopptr() &amp;&amp; ta-&gt;elem() != TypeInstPtr::BOTTOM) {
1316       const TypeAry *tary = TypeAry::make(TypeInstPtr::BOTTOM, ta-&gt;size());
<a name="16" id="anc16"></a><span class="line-modified">1317       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,Type::Offset(offset), ta-&gt;field_offset());</span>
<span class="line-added">1318     }</span>
<span class="line-added">1319     // Initially all flattened array accesses share a single slice</span>
<span class="line-added">1320     if (ta-&gt;elem()-&gt;isa_valuetype() &amp;&amp; ta-&gt;elem() != TypeValueType::BOTTOM &amp;&amp; _flattened_accesses_share_alias) {</span>
<span class="line-added">1321       const TypeAry *tary = TypeAry::make(TypeValueType::BOTTOM, ta-&gt;size());</span>
<span class="line-added">1322       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,Type::Offset(offset), Type::Offset(Type::OffsetBot));</span>
1323     }
1324     // Arrays of bytes and of booleans both use &#39;bastore&#39; and &#39;baload&#39; so
1325     // cannot be distinguished by bytecode alone.
1326     if (ta-&gt;elem() == TypeInt::BOOL) {
1327       const TypeAry *tary = TypeAry::make(TypeInt::BYTE, ta-&gt;size());
1328       ciKlass* aklass = ciTypeArrayKlass::make(T_BYTE);
<a name="17" id="anc17"></a><span class="line-modified">1329       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,aklass,false,Type::Offset(offset), ta-&gt;field_offset());</span>
1330     }
1331     // During the 2nd round of IterGVN, NotNull castings are removed.
1332     // Make sure the Bottom and NotNull variants alias the same.
1333     // Also, make sure exact and non-exact variants alias the same.
1334     if (ptr == TypePtr::NotNull || ta-&gt;klass_is_exact() || ta-&gt;speculative() != NULL) {
<a name="18" id="anc18"></a><span class="line-modified">1335       tj = ta = TypeAryPtr::make(TypePtr::BotPTR,ta-&gt;ary(),ta-&gt;klass(),false,Type::Offset(offset), ta-&gt;field_offset());</span>
1336     }
1337   }
1338 
1339   // Oop pointers need some flattening
1340   const TypeInstPtr *to = tj-&gt;isa_instptr();
1341   if( to &amp;&amp; _AliasLevel &gt;= 2 &amp;&amp; to != TypeOopPtr::BOTTOM ) {
1342     ciInstanceKlass *k = to-&gt;klass()-&gt;as_instance_klass();
1343     if( ptr == TypePtr::Constant ) {
1344       if (to-&gt;klass() != ciEnv::current()-&gt;Class_klass() ||
1345           offset &lt; k-&gt;size_helper() * wordSize) {
1346         // No constant oop pointers (such as Strings); they alias with
1347         // unknown strings.
1348         assert(!is_known_inst, &quot;not scalarizable allocation&quot;);
<a name="19" id="anc19"></a><span class="line-modified">1349         tj = to = TypeInstPtr::make(TypePtr::BotPTR,to-&gt;klass(),false,0,Type::Offset(offset), to-&gt;klass()-&gt;flatten_array());</span>
1350       }
1351     } else if( is_known_inst ) {
1352       tj = to; // Keep NotNull and klass_is_exact for instance type
1353     } else if( ptr == TypePtr::NotNull || to-&gt;klass_is_exact() ) {
1354       // During the 2nd round of IterGVN, NotNull castings are removed.
1355       // Make sure the Bottom and NotNull variants alias the same.
1356       // Also, make sure exact and non-exact variants alias the same.
<a name="20" id="anc20"></a><span class="line-modified">1357       tj = to = TypeInstPtr::make(TypePtr::BotPTR,to-&gt;klass(),false,0,Type::Offset(offset), to-&gt;klass()-&gt;flatten_array());</span>
1358     }
1359     if (to-&gt;speculative() != NULL) {
<a name="21" id="anc21"></a><span class="line-modified">1360       tj = to = TypeInstPtr::make(to-&gt;ptr(),to-&gt;klass(),to-&gt;klass_is_exact(),to-&gt;const_oop(),Type::Offset(to-&gt;offset()), to-&gt;klass()-&gt;flatten_array(), to-&gt;instance_id());</span>
1361     }
1362     // Canonicalize the holder of this field
1363     if (offset &gt;= 0 &amp;&amp; offset &lt; instanceOopDesc::base_offset_in_bytes()) {
1364       // First handle header references such as a LoadKlassNode, even if the
1365       // object&#39;s klass is unloaded at compile time (4965979).
1366       if (!is_known_inst) { // Do it only for non-instance types
<a name="22" id="anc22"></a><span class="line-modified">1367         tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()-&gt;Object_klass(), false, NULL, Type::Offset(offset), false);</span>
1368       }
1369     } else if (offset &lt; 0 || offset &gt;= k-&gt;size_helper() * wordSize) {
1370       // Static fields are in the space above the normal instance
1371       // fields in the java.lang.Class instance.
1372       if (to-&gt;klass() != ciEnv::current()-&gt;Class_klass()) {
1373         to = NULL;
1374         tj = TypeOopPtr::BOTTOM;
1375         offset = tj-&gt;offset();
1376       }
1377     } else {
1378       ciInstanceKlass *canonical_holder = k-&gt;get_canonical_holder(offset);
1379       if (!k-&gt;equals(canonical_holder) || tj-&gt;offset() != offset) {
1380         if( is_known_inst ) {
<a name="23" id="anc23"></a><span class="line-modified">1381           tj = to = TypeInstPtr::make(to-&gt;ptr(), canonical_holder, true, NULL, Type::Offset(offset), canonical_holder-&gt;flatten_array(), to-&gt;instance_id());</span>
1382         } else {
<a name="24" id="anc24"></a><span class="line-modified">1383           tj = to = TypeInstPtr::make(to-&gt;ptr(), canonical_holder, false, NULL, Type::Offset(offset), canonical_holder-&gt;flatten_array());</span>
1384         }
1385       }
1386     }
1387   }
1388 
1389   // Klass pointers to object array klasses need some flattening
1390   const TypeKlassPtr *tk = tj-&gt;isa_klassptr();
1391   if( tk ) {
1392     // If we are referencing a field within a Klass, we need
1393     // to assume the worst case of an Object.  Both exact and
1394     // inexact types must flatten to the same alias class so
1395     // use NotNull as the PTR.
1396     if ( offset == Type::OffsetBot || (offset &gt;= 0 &amp;&amp; (size_t)offset &lt; sizeof(Klass)) ) {
1397 
1398       tj = tk = TypeKlassPtr::make(TypePtr::NotNull,
1399                                    TypeKlassPtr::OBJECT-&gt;klass(),
<a name="25" id="anc25"></a><span class="line-modified">1400                                    Type::Offset(offset),</span>
<span class="line-added">1401                                    false);</span>
1402     }
1403 
1404     ciKlass* klass = tk-&gt;klass();
<a name="26" id="anc26"></a><span class="line-modified">1405     if (klass != NULL &amp;&amp; klass-&gt;is_obj_array_klass()) {</span>
1406       ciKlass* k = TypeAryPtr::OOPS-&gt;klass();
1407       if( !k || !k-&gt;is_loaded() )                  // Only fails for some -Xcomp runs
1408         k = TypeInstPtr::BOTTOM-&gt;klass();
<a name="27" id="anc27"></a><span class="line-modified">1409       tj = tk = TypeKlassPtr::make(TypePtr::NotNull, k, Type::Offset(offset), false);</span>
1410     }
1411 
1412     // Check for precise loads from the primary supertype array and force them
1413     // to the supertype cache alias index.  Check for generic array loads from
1414     // the primary supertype array and also force them to the supertype cache
1415     // alias index.  Since the same load can reach both, we need to merge
1416     // these 2 disparate memories into the same alias class.  Since the
1417     // primary supertype array is read-only, there&#39;s no chance of confusion
1418     // where we bypass an array load and an array store.
1419     int primary_supers_offset = in_bytes(Klass::primary_supers_offset());
1420     if (offset == Type::OffsetBot ||
1421         (offset &gt;= primary_supers_offset &amp;&amp;
1422          offset &lt; (int)(primary_supers_offset + Klass::primary_super_limit() * wordSize)) ||
1423         offset == (int)in_bytes(Klass::secondary_super_cache_offset())) {
1424       offset = in_bytes(Klass::secondary_super_cache_offset());
<a name="28" id="anc28"></a><span class="line-modified">1425       tj = tk = TypeKlassPtr::make(TypePtr::NotNull, tk-&gt;klass(), Type::Offset(offset), tk-&gt;flat_array());</span>
1426     }
1427   }
1428 
1429   // Flatten all Raw pointers together.
1430   if (tj-&gt;base() == Type::RawPtr)
1431     tj = TypeRawPtr::BOTTOM;
1432 
1433   if (tj-&gt;base() == Type::AnyPtr)
1434     tj = TypePtr::BOTTOM;      // An error, which the caller must check for.
1435 
1436   // Flatten all to bottom for now
1437   switch( _AliasLevel ) {
1438   case 0:
1439     tj = TypePtr::BOTTOM;
1440     break;
1441   case 1:                       // Flatten to: oop, static, field or array
1442     switch (tj-&gt;base()) {
1443     //case Type::AryPtr: tj = TypeAryPtr::RANGE;    break;
1444     case Type::RawPtr:   tj = TypeRawPtr::BOTTOM;   break;
1445     case Type::AryPtr:   // do not distinguish arrays at all
1446     case Type::InstPtr:  tj = TypeInstPtr::BOTTOM;  break;
1447     case Type::KlassPtr: tj = TypeKlassPtr::OBJECT; break;
1448     case Type::AnyPtr:   tj = TypePtr::BOTTOM;      break;  // caller checks it
1449     default: ShouldNotReachHere();
1450     }
1451     break;
1452   case 2:                       // No collapsing at level 2; keep all splits
1453   case 3:                       // No collapsing at level 3; keep all splits
1454     break;
1455   default:
1456     Unimplemented();
1457   }
1458 
1459   offset = tj-&gt;offset();
1460   assert( offset != Type::OffsetTop, &quot;Offset has fallen from constant&quot; );
1461 
1462   assert( (offset != Type::OffsetBot &amp;&amp; tj-&gt;base() != Type::AryPtr) ||
1463           (offset == Type::OffsetBot &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1464           (offset == Type::OffsetBot &amp;&amp; tj == TypeOopPtr::BOTTOM) ||
1465           (offset == Type::OffsetBot &amp;&amp; tj == TypePtr::BOTTOM) ||
1466           (offset == oopDesc::mark_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1467           (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1468           (offset == arrayOopDesc::length_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr),
1469           &quot;For oops, klasses, raw offset must be constant; for arrays the offset is never known&quot; );
1470   assert( tj-&gt;ptr() != TypePtr::TopPTR &amp;&amp;
1471           tj-&gt;ptr() != TypePtr::AnyNull &amp;&amp;
1472           tj-&gt;ptr() != TypePtr::Null, &quot;No imprecise addresses&quot; );
1473 //    assert( tj-&gt;ptr() != TypePtr::Constant ||
1474 //            tj-&gt;base() == Type::RawPtr ||
1475 //            tj-&gt;base() == Type::KlassPtr, &quot;No constant oop addresses&quot; );
1476 
1477   return tj;
1478 }
1479 
1480 void Compile::AliasType::Init(int i, const TypePtr* at) {
1481   assert(AliasIdxTop &lt;= i &amp;&amp; i &lt; Compile::current()-&gt;_max_alias_types, &quot;Invalid alias index&quot;);
1482   _index = i;
1483   _adr_type = at;
1484   _field = NULL;
1485   _element = NULL;
1486   _is_rewritable = true; // default
1487   const TypeOopPtr *atoop = (at != NULL) ? at-&gt;isa_oopptr() : NULL;
1488   if (atoop != NULL &amp;&amp; atoop-&gt;is_known_instance()) {
1489     const TypeOopPtr *gt = atoop-&gt;cast_to_instance_id(TypeOopPtr::InstanceBot);
1490     _general_index = Compile::current()-&gt;get_alias_index(gt);
1491   } else {
1492     _general_index = 0;
1493   }
1494 }
1495 
1496 BasicType Compile::AliasType::basic_type() const {
1497   if (element() != NULL) {
1498     const Type* element = adr_type()-&gt;is_aryptr()-&gt;elem();
1499     return element-&gt;isa_narrowoop() ? T_OBJECT : element-&gt;array_element_basic_type();
1500   } if (field() != NULL) {
1501     return field()-&gt;layout_type();
1502   } else {
1503     return T_ILLEGAL; // unknown
1504   }
1505 }
1506 
1507 //---------------------------------print_on------------------------------------
1508 #ifndef PRODUCT
1509 void Compile::AliasType::print_on(outputStream* st) {
1510   if (index() &lt; 10)
1511         st-&gt;print(&quot;@ &lt;%d&gt; &quot;, index());
1512   else  st-&gt;print(&quot;@ &lt;%d&gt;&quot;,  index());
1513   st-&gt;print(is_rewritable() ? &quot;   &quot; : &quot; RO&quot;);
1514   int offset = adr_type()-&gt;offset();
1515   if (offset == Type::OffsetBot)
1516         st-&gt;print(&quot; +any&quot;);
1517   else  st-&gt;print(&quot; +%-3d&quot;, offset);
1518   st-&gt;print(&quot; in &quot;);
1519   adr_type()-&gt;dump_on(st);
1520   const TypeOopPtr* tjp = adr_type()-&gt;isa_oopptr();
1521   if (field() != NULL &amp;&amp; tjp) {
1522     if (tjp-&gt;klass()  != field()-&gt;holder() ||
1523         tjp-&gt;offset() != field()-&gt;offset_in_bytes()) {
1524       st-&gt;print(&quot; != &quot;);
1525       field()-&gt;print();
1526       st-&gt;print(&quot; ***&quot;);
1527     }
1528   }
1529 }
1530 
1531 void print_alias_types() {
1532   Compile* C = Compile::current();
1533   tty-&gt;print_cr(&quot;--- Alias types, AliasIdxBot .. %d&quot;, C-&gt;num_alias_types()-1);
1534   for (int idx = Compile::AliasIdxBot; idx &lt; C-&gt;num_alias_types(); idx++) {
1535     C-&gt;alias_type(idx)-&gt;print_on(tty);
1536     tty-&gt;cr();
1537   }
1538 }
1539 #endif
1540 
1541 
1542 //----------------------------probe_alias_cache--------------------------------
1543 Compile::AliasCacheEntry* Compile::probe_alias_cache(const TypePtr* adr_type) {
1544   intptr_t key = (intptr_t) adr_type;
1545   key ^= key &gt;&gt; logAliasCacheSize;
1546   return &amp;_alias_cache[key &amp; right_n_bits(logAliasCacheSize)];
1547 }
1548 
1549 
1550 //-----------------------------grow_alias_types--------------------------------
1551 void Compile::grow_alias_types() {
1552   const int old_ats  = _max_alias_types; // how many before?
1553   const int new_ats  = old_ats;          // how many more?
1554   const int grow_ats = old_ats+new_ats;  // how many now?
1555   _max_alias_types = grow_ats;
1556   _alias_types =  REALLOC_ARENA_ARRAY(comp_arena(), AliasType*, _alias_types, old_ats, grow_ats);
1557   AliasType* ats =    NEW_ARENA_ARRAY(comp_arena(), AliasType, new_ats);
1558   Copy::zero_to_bytes(ats, sizeof(AliasType)*new_ats);
1559   for (int i = 0; i &lt; new_ats; i++)  _alias_types[old_ats+i] = &amp;ats[i];
1560 }
1561 
1562 
1563 //--------------------------------find_alias_type------------------------------
<a name="29" id="anc29"></a><span class="line-modified">1564 Compile::AliasType* Compile::find_alias_type(const TypePtr* adr_type, bool no_create, ciField* original_field, bool uncached) {</span>
1565   if (_AliasLevel == 0)
1566     return alias_type(AliasIdxBot);
1567 
<a name="30" id="anc30"></a><span class="line-modified">1568   AliasCacheEntry* ace = NULL;</span>
<span class="line-modified">1569   if (!uncached) {</span>
<span class="line-modified">1570     ace = probe_alias_cache(adr_type);</span>
<span class="line-added">1571     if (ace-&gt;_adr_type == adr_type) {</span>
<span class="line-added">1572       return alias_type(ace-&gt;_index);</span>
<span class="line-added">1573     }</span>
1574   }
1575 
1576   // Handle special cases.
1577   if (adr_type == NULL)             return alias_type(AliasIdxTop);
1578   if (adr_type == TypePtr::BOTTOM)  return alias_type(AliasIdxBot);
1579 
1580   // Do it the slow way.
1581   const TypePtr* flat = flatten_alias_type(adr_type);
1582 
1583 #ifdef ASSERT
1584   {
1585     ResourceMark rm;
1586     assert(flat == flatten_alias_type(flat), &quot;not idempotent: adr_type = %s; flat = %s =&gt; %s&quot;,
1587            Type::str(adr_type), Type::str(flat), Type::str(flatten_alias_type(flat)));
1588     assert(flat != TypePtr::BOTTOM, &quot;cannot alias-analyze an untyped ptr: adr_type = %s&quot;,
1589            Type::str(adr_type));
1590     if (flat-&gt;isa_oopptr() &amp;&amp; !flat-&gt;isa_klassptr()) {
1591       const TypeOopPtr* foop = flat-&gt;is_oopptr();
1592       // Scalarizable allocations have exact klass always.
1593       bool exact = !foop-&gt;klass_is_exact() || foop-&gt;is_known_instance();
1594       const TypePtr* xoop = foop-&gt;cast_to_exactness(exact)-&gt;is_ptr();
1595       assert(foop == flatten_alias_type(xoop), &quot;exactness must not affect alias type: foop = %s; xoop = %s&quot;,
1596              Type::str(foop), Type::str(xoop));
1597     }
1598   }
1599 #endif
1600 
1601   int idx = AliasIdxTop;
1602   for (int i = 0; i &lt; num_alias_types(); i++) {
1603     if (alias_type(i)-&gt;adr_type() == flat) {
1604       idx = i;
1605       break;
1606     }
1607   }
1608 
1609   if (idx == AliasIdxTop) {
1610     if (no_create)  return NULL;
1611     // Grow the array if necessary.
1612     if (_num_alias_types == _max_alias_types)  grow_alias_types();
1613     // Add a new alias type.
1614     idx = _num_alias_types++;
1615     _alias_types[idx]-&gt;Init(idx, flat);
1616     if (flat == TypeInstPtr::KLASS)  alias_type(idx)-&gt;set_rewritable(false);
1617     if (flat == TypeAryPtr::RANGE)   alias_type(idx)-&gt;set_rewritable(false);
1618     if (flat-&gt;isa_instptr()) {
1619       if (flat-&gt;offset() == java_lang_Class::klass_offset_in_bytes()
1620           &amp;&amp; flat-&gt;is_instptr()-&gt;klass() == env()-&gt;Class_klass())
1621         alias_type(idx)-&gt;set_rewritable(false);
1622     }
<a name="31" id="anc31"></a><span class="line-added">1623     ciField* field = NULL;</span>
1624     if (flat-&gt;isa_aryptr()) {
1625 #ifdef ASSERT
1626       const int header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1627       // (T_BYTE has the weakest alignment and size restrictions...)
1628       assert(flat-&gt;offset() &lt; header_size_min, &quot;array body reference must be OffsetBot&quot;);
1629 #endif
<a name="32" id="anc32"></a><span class="line-added">1630       const Type* elemtype = flat-&gt;is_aryptr()-&gt;elem();</span>
1631       if (flat-&gt;offset() == TypePtr::OffsetBot) {
<a name="33" id="anc33"></a><span class="line-modified">1632         alias_type(idx)-&gt;set_element(elemtype);</span>
<span class="line-added">1633       }</span>
<span class="line-added">1634       int field_offset = flat-&gt;is_aryptr()-&gt;field_offset().get();</span>
<span class="line-added">1635       if (elemtype-&gt;isa_valuetype() &amp;&amp;</span>
<span class="line-added">1636           elemtype-&gt;value_klass() != NULL &amp;&amp;</span>
<span class="line-added">1637           field_offset != Type::OffsetBot) {</span>
<span class="line-added">1638         ciValueKlass* vk = elemtype-&gt;value_klass();</span>
<span class="line-added">1639         field_offset += vk-&gt;first_field_offset();</span>
<span class="line-added">1640         field = vk-&gt;get_field_by_offset(field_offset, false);</span>
1641       }
1642     }
1643     if (flat-&gt;isa_klassptr()) {
1644       if (flat-&gt;offset() == in_bytes(Klass::super_check_offset_offset()))
1645         alias_type(idx)-&gt;set_rewritable(false);
1646       if (flat-&gt;offset() == in_bytes(Klass::modifier_flags_offset()))
1647         alias_type(idx)-&gt;set_rewritable(false);
1648       if (flat-&gt;offset() == in_bytes(Klass::access_flags_offset()))
1649         alias_type(idx)-&gt;set_rewritable(false);
1650       if (flat-&gt;offset() == in_bytes(Klass::java_mirror_offset()))
1651         alias_type(idx)-&gt;set_rewritable(false);
<a name="34" id="anc34"></a><span class="line-added">1652       if (flat-&gt;offset() == in_bytes(Klass::layout_helper_offset()))</span>
<span class="line-added">1653         alias_type(idx)-&gt;set_rewritable(false);</span>
1654       if (flat-&gt;offset() == in_bytes(Klass::secondary_super_cache_offset()))
1655         alias_type(idx)-&gt;set_rewritable(false);
1656     }
1657     // %%% (We would like to finalize JavaThread::threadObj_offset(),
1658     // but the base pointer type is not distinctive enough to identify
1659     // references into JavaThread.)
1660 
1661     // Check for final fields.
1662     const TypeInstPtr* tinst = flat-&gt;isa_instptr();
1663     if (tinst &amp;&amp; tinst-&gt;offset() &gt;= instanceOopDesc::base_offset_in_bytes()) {
<a name="35" id="anc35"></a>
1664       if (tinst-&gt;const_oop() != NULL &amp;&amp;
1665           tinst-&gt;klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
1666           tinst-&gt;offset() &gt;= (tinst-&gt;klass()-&gt;as_instance_klass()-&gt;size_helper() * wordSize)) {
1667         // static field
1668         ciInstanceKlass* k = tinst-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
1669         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), true);
<a name="36" id="anc36"></a><span class="line-added">1670       } else if (tinst-&gt;klass()-&gt;is_valuetype()) {</span>
<span class="line-added">1671         // Value type field</span>
<span class="line-added">1672         ciValueKlass* vk = tinst-&gt;value_klass();</span>
<span class="line-added">1673         field = vk-&gt;get_field_by_offset(tinst-&gt;offset(), false);</span>
1674       } else {
<a name="37" id="anc37"></a><span class="line-modified">1675         ciInstanceKlass* k = tinst-&gt;klass()-&gt;as_instance_klass();</span>
1676         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), false);
1677       }
<a name="38" id="anc38"></a><span class="line-modified">1678     }</span>
<span class="line-modified">1679     assert(field == NULL ||</span>
<span class="line-modified">1680            original_field == NULL ||</span>
<span class="line-modified">1681            (field-&gt;holder() == original_field-&gt;holder() &amp;&amp;</span>
<span class="line-modified">1682             field-&gt;offset() == original_field-&gt;offset() &amp;&amp;</span>
<span class="line-modified">1683             field-&gt;is_static() == original_field-&gt;is_static()), &quot;wrong field?&quot;);</span>
<span class="line-modified">1684     // Set field() and is_rewritable() attributes.</span>
<span class="line-added">1685     if (field != NULL) {</span>
<span class="line-added">1686       alias_type(idx)-&gt;set_field(field);</span>
<span class="line-added">1687       if (flat-&gt;isa_aryptr()) {</span>
<span class="line-added">1688         // Fields of flattened inline type arrays are rewritable although they are declared final</span>
<span class="line-added">1689         assert(flat-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype(), &quot;must be a flattened value array&quot;);</span>
<span class="line-added">1690         alias_type(idx)-&gt;set_rewritable(true);</span>
<span class="line-added">1691       }</span>
1692     }
1693   }
1694 
1695   // Fill the cache for next time.
<a name="39" id="anc39"></a><span class="line-modified">1696   if (!uncached) {</span>
<span class="line-modified">1697     ace-&gt;_adr_type = adr_type;</span>
<span class="line-modified">1698     ace-&gt;_index    = idx;</span>
<span class="line-added">1699     assert(alias_type(adr_type) == alias_type(idx),  &quot;type must be installed&quot;);</span>
1700 
<a name="40" id="anc40"></a><span class="line-modified">1701     // Might as well try to fill the cache for the flattened version, too.</span>
<span class="line-modified">1702     AliasCacheEntry* face = probe_alias_cache(flat);</span>
<span class="line-modified">1703     if (face-&gt;_adr_type == NULL) {</span>
<span class="line-modified">1704       face-&gt;_adr_type = flat;</span>
<span class="line-modified">1705       face-&gt;_index    = idx;</span>
<span class="line-modified">1706       assert(alias_type(flat) == alias_type(idx), &quot;flat type must work too&quot;);</span>
<span class="line-added">1707     }</span>
1708   }
1709 
1710   return alias_type(idx);
1711 }
1712 
1713 
1714 Compile::AliasType* Compile::alias_type(ciField* field) {
1715   const TypeOopPtr* t;
1716   if (field-&gt;is_static())
1717     t = TypeInstPtr::make(field-&gt;holder()-&gt;java_mirror());
1718   else
1719     t = TypeOopPtr::make_from_klass_raw(field-&gt;holder());
1720   AliasType* atp = alias_type(t-&gt;add_offset(field-&gt;offset_in_bytes()), field);
1721   assert((field-&gt;is_final() || field-&gt;is_stable()) == !atp-&gt;is_rewritable(), &quot;must get the rewritable bits correct&quot;);
1722   return atp;
1723 }
1724 
1725 
1726 //------------------------------have_alias_type--------------------------------
1727 bool Compile::have_alias_type(const TypePtr* adr_type) {
1728   AliasCacheEntry* ace = probe_alias_cache(adr_type);
1729   if (ace-&gt;_adr_type == adr_type) {
1730     return true;
1731   }
1732 
1733   // Handle special cases.
1734   if (adr_type == NULL)             return true;
1735   if (adr_type == TypePtr::BOTTOM)  return true;
1736 
1737   return find_alias_type(adr_type, true, NULL) != NULL;
1738 }
1739 
1740 //-----------------------------must_alias--------------------------------------
1741 // True if all values of the given address type are in the given alias category.
1742 bool Compile::must_alias(const TypePtr* adr_type, int alias_idx) {
1743   if (alias_idx == AliasIdxBot)         return true;  // the universal category
1744   if (adr_type == NULL)                 return true;  // NULL serves as TypePtr::TOP
1745   if (alias_idx == AliasIdxTop)         return false; // the empty category
1746   if (adr_type-&gt;base() == Type::AnyPtr) return false; // TypePtr::BOTTOM or its twins
1747 
1748   // the only remaining possible overlap is identity
1749   int adr_idx = get_alias_index(adr_type);
1750   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1751   assert(adr_idx == alias_idx ||
1752          (alias_type(alias_idx)-&gt;adr_type() != TypeOopPtr::BOTTOM
1753           &amp;&amp; adr_type                       != TypeOopPtr::BOTTOM),
1754          &quot;should not be testing for overlap with an unsafe pointer&quot;);
1755   return adr_idx == alias_idx;
1756 }
1757 
1758 //------------------------------can_alias--------------------------------------
1759 // True if any values of the given address type are in the given alias category.
1760 bool Compile::can_alias(const TypePtr* adr_type, int alias_idx) {
1761   if (alias_idx == AliasIdxTop)         return false; // the empty category
1762   if (adr_type == NULL)                 return false; // NULL serves as TypePtr::TOP
1763   // Known instance doesn&#39;t alias with bottom memory
1764   if (alias_idx == AliasIdxBot)         return !adr_type-&gt;is_known_instance();                   // the universal category
1765   if (adr_type-&gt;base() == Type::AnyPtr) return !C-&gt;get_adr_type(alias_idx)-&gt;is_known_instance(); // TypePtr::BOTTOM or its twins
1766 
1767   // the only remaining possible overlap is identity
1768   int adr_idx = get_alias_index(adr_type);
1769   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1770   return adr_idx == alias_idx;
1771 }
1772 
1773 
1774 
1775 //---------------------------pop_warm_call-------------------------------------
1776 WarmCallInfo* Compile::pop_warm_call() {
1777   WarmCallInfo* wci = _warm_calls;
1778   if (wci != NULL)  _warm_calls = wci-&gt;remove_from(wci);
1779   return wci;
1780 }
1781 
1782 //----------------------------Inline_Warm--------------------------------------
1783 int Compile::Inline_Warm() {
1784   // If there is room, try to inline some more warm call sites.
1785   // %%% Do a graph index compaction pass when we think we&#39;re out of space?
1786   if (!InlineWarmCalls)  return 0;
1787 
1788   int calls_made_hot = 0;
1789   int room_to_grow   = NodeCountInliningCutoff - unique();
1790   int amount_to_grow = MIN2(room_to_grow, (int)NodeCountInliningStep);
1791   int amount_grown   = 0;
1792   WarmCallInfo* call;
1793   while (amount_to_grow &gt; 0 &amp;&amp; (call = pop_warm_call()) != NULL) {
1794     int est_size = (int)call-&gt;size();
1795     if (est_size &gt; (room_to_grow - amount_grown)) {
1796       // This one won&#39;t fit anyway.  Get rid of it.
1797       call-&gt;make_cold();
1798       continue;
1799     }
1800     call-&gt;make_hot();
1801     calls_made_hot++;
1802     amount_grown   += est_size;
1803     amount_to_grow -= est_size;
1804   }
1805 
1806   if (calls_made_hot &gt; 0)  set_major_progress();
1807   return calls_made_hot;
1808 }
1809 
1810 
1811 //----------------------------Finish_Warm--------------------------------------
1812 void Compile::Finish_Warm() {
1813   if (!InlineWarmCalls)  return;
1814   if (failing())  return;
1815   if (warm_calls() == NULL)  return;
1816 
1817   // Clean up loose ends, if we are out of space for inlining.
1818   WarmCallInfo* call;
1819   while ((call = pop_warm_call()) != NULL) {
1820     call-&gt;make_cold();
1821   }
1822 }
1823 
1824 //---------------------cleanup_loop_predicates-----------------------
1825 // Remove the opaque nodes that protect the predicates so that all unused
1826 // checks and uncommon_traps will be eliminated from the ideal graph
1827 void Compile::cleanup_loop_predicates(PhaseIterGVN &amp;igvn) {
1828   if (predicate_count()==0) return;
1829   for (int i = predicate_count(); i &gt; 0; i--) {
1830     Node * n = predicate_opaque1_node(i-1);
1831     assert(n-&gt;Opcode() == Op_Opaque1, &quot;must be&quot;);
1832     igvn.replace_node(n, n-&gt;in(1));
1833   }
1834   assert(predicate_count()==0, &quot;should be clean!&quot;);
1835 }
1836 
1837 void Compile::add_range_check_cast(Node* n) {
1838   assert(n-&gt;isa_CastII()-&gt;has_range_check(), &quot;CastII should have range check dependency&quot;);
1839   assert(!_range_check_casts-&gt;contains(n), &quot;duplicate entry in range check casts&quot;);
1840   _range_check_casts-&gt;append(n);
1841 }
1842 
1843 // Remove all range check dependent CastIINodes.
1844 void Compile::remove_range_check_casts(PhaseIterGVN &amp;igvn) {
1845   for (int i = range_check_cast_count(); i &gt; 0; i--) {
1846     Node* cast = range_check_cast_node(i-1);
1847     assert(cast-&gt;isa_CastII()-&gt;has_range_check(), &quot;CastII should have range check dependency&quot;);
1848     igvn.replace_node(cast, cast-&gt;in(1));
1849   }
1850   assert(range_check_cast_count() == 0, &quot;should be empty&quot;);
1851 }
1852 
1853 void Compile::add_opaque4_node(Node* n) {
1854   assert(n-&gt;Opcode() == Op_Opaque4, &quot;Opaque4 only&quot;);
1855   assert(!_opaque4_nodes-&gt;contains(n), &quot;duplicate entry in Opaque4 list&quot;);
1856   _opaque4_nodes-&gt;append(n);
1857 }
1858 
1859 // Remove all Opaque4 nodes.
1860 void Compile::remove_opaque4_nodes(PhaseIterGVN &amp;igvn) {
1861   for (int i = opaque4_count(); i &gt; 0; i--) {
1862     Node* opaq = opaque4_node(i-1);
1863     assert(opaq-&gt;Opcode() == Op_Opaque4, &quot;Opaque4 only&quot;);
1864     igvn.replace_node(opaq, opaq-&gt;in(2));
1865   }
1866   assert(opaque4_count() == 0, &quot;should be empty&quot;);
1867 }
1868 
<a name="41" id="anc41"></a><span class="line-added">1869 void Compile::add_value_type(Node* n) {</span>
<span class="line-added">1870   assert(n-&gt;is_ValueTypeBase(), &quot;unexpected node&quot;);</span>
<span class="line-added">1871   if (_value_type_nodes != NULL) {</span>
<span class="line-added">1872     _value_type_nodes-&gt;push(n);</span>
<span class="line-added">1873   }</span>
<span class="line-added">1874 }</span>
<span class="line-added">1875 </span>
<span class="line-added">1876 void Compile::remove_value_type(Node* n) {</span>
<span class="line-added">1877   assert(n-&gt;is_ValueTypeBase(), &quot;unexpected node&quot;);</span>
<span class="line-added">1878   if (_value_type_nodes != NULL) {</span>
<span class="line-added">1879     _value_type_nodes-&gt;remove(n);</span>
<span class="line-added">1880   }</span>
<span class="line-added">1881 }</span>
<span class="line-added">1882 </span>
<span class="line-added">1883 // Does the return value keep otherwise useless value type allocations</span>
<span class="line-added">1884 // alive?</span>
<span class="line-added">1885 static bool return_val_keeps_allocations_alive(Node* ret_val) {</span>
<span class="line-added">1886   ResourceMark rm;</span>
<span class="line-added">1887   Unique_Node_List wq;</span>
<span class="line-added">1888   wq.push(ret_val);</span>
<span class="line-added">1889   bool some_allocations = false;</span>
<span class="line-added">1890   for (uint i = 0; i &lt; wq.size(); i++) {</span>
<span class="line-added">1891     Node* n = wq.at(i);</span>
<span class="line-added">1892     assert(!n-&gt;is_ValueTypeBase(), &quot;chain of value type nodes&quot;);</span>
<span class="line-added">1893     if (n-&gt;outcnt() &gt; 1) {</span>
<span class="line-added">1894       // Some other use for the allocation</span>
<span class="line-added">1895       return false;</span>
<span class="line-added">1896     } else if (n-&gt;is_Phi()) {</span>
<span class="line-added">1897       for (uint j = 1; j &lt; n-&gt;req(); j++) {</span>
<span class="line-added">1898         wq.push(n-&gt;in(j));</span>
<span class="line-added">1899       }</span>
<span class="line-added">1900     } else if (n-&gt;is_CheckCastPP() &amp;&amp;</span>
<span class="line-added">1901                n-&gt;in(1)-&gt;is_Proj() &amp;&amp;</span>
<span class="line-added">1902                n-&gt;in(1)-&gt;in(0)-&gt;is_Allocate()) {</span>
<span class="line-added">1903       some_allocations = true;</span>
<span class="line-added">1904     }</span>
<span class="line-added">1905   }</span>
<span class="line-added">1906   return some_allocations;</span>
<span class="line-added">1907 }</span>
<span class="line-added">1908 </span>
<span class="line-added">1909 void Compile::process_value_types(PhaseIterGVN &amp;igvn) {</span>
<span class="line-added">1910   // Make value types scalar in safepoints</span>
<span class="line-added">1911   while (_value_type_nodes-&gt;size() != 0) {</span>
<span class="line-added">1912     ValueTypeBaseNode* vt = _value_type_nodes-&gt;pop()-&gt;as_ValueTypeBase();</span>
<span class="line-added">1913     vt-&gt;make_scalar_in_safepoints(&amp;igvn);</span>
<span class="line-added">1914     if (vt-&gt;is_ValueTypePtr()) {</span>
<span class="line-added">1915       igvn.replace_node(vt, vt-&gt;get_oop());</span>
<span class="line-added">1916     } else if (vt-&gt;outcnt() == 0) {</span>
<span class="line-added">1917       igvn.remove_dead_node(vt);</span>
<span class="line-added">1918     }</span>
<span class="line-added">1919   }</span>
<span class="line-added">1920   _value_type_nodes = NULL;</span>
<span class="line-added">1921   if (tf()-&gt;returns_value_type_as_fields()) {</span>
<span class="line-added">1922     Node* ret = NULL;</span>
<span class="line-added">1923     for (uint i = 1; i &lt; root()-&gt;req(); i++){</span>
<span class="line-added">1924       Node* in = root()-&gt;in(i);</span>
<span class="line-added">1925       if (in-&gt;Opcode() == Op_Return) {</span>
<span class="line-added">1926         assert(ret == NULL, &quot;only one return&quot;);</span>
<span class="line-added">1927         ret = in;</span>
<span class="line-added">1928       }</span>
<span class="line-added">1929     }</span>
<span class="line-added">1930     if (ret != NULL) {</span>
<span class="line-added">1931       Node* ret_val = ret-&gt;in(TypeFunc::Parms);</span>
<span class="line-added">1932       if (igvn.type(ret_val)-&gt;isa_oopptr() &amp;&amp;</span>
<span class="line-added">1933           return_val_keeps_allocations_alive(ret_val)) {</span>
<span class="line-added">1934         igvn.replace_input_of(ret, TypeFunc::Parms, ValueTypeNode::tagged_klass(igvn.type(ret_val)-&gt;value_klass(), igvn));</span>
<span class="line-added">1935         assert(ret_val-&gt;outcnt() == 0, &quot;should be dead now&quot;);</span>
<span class="line-added">1936         igvn.remove_dead_node(ret_val);</span>
<span class="line-added">1937       }</span>
<span class="line-added">1938     }</span>
<span class="line-added">1939   }</span>
<span class="line-added">1940   igvn.optimize();</span>
<span class="line-added">1941 }</span>
<span class="line-added">1942 </span>
<span class="line-added">1943 void Compile::adjust_flattened_array_access_aliases(PhaseIterGVN&amp; igvn) {</span>
<span class="line-added">1944   if (!_has_flattened_accesses) {</span>
<span class="line-added">1945     return;</span>
<span class="line-added">1946   }</span>
<span class="line-added">1947   // Initially, all flattened array accesses share the same slice to</span>
<span class="line-added">1948   // keep dependencies with Object[] array accesses (that could be</span>
<span class="line-added">1949   // to a flattened array) correct. We&#39;re done with parsing so we</span>
<span class="line-added">1950   // now know all flattened array accesses in this compile</span>
<span class="line-added">1951   // unit. Let&#39;s move flattened array accesses to their own slice,</span>
<span class="line-added">1952   // one per element field. This should help memory access</span>
<span class="line-added">1953   // optimizations.</span>
<span class="line-added">1954   ResourceMark rm;</span>
<span class="line-added">1955   Unique_Node_List wq;</span>
<span class="line-added">1956   wq.push(root());</span>
<span class="line-added">1957 </span>
<span class="line-added">1958   Node_List mergememnodes;</span>
<span class="line-added">1959   Node_List memnodes;</span>
<span class="line-added">1960 </span>
<span class="line-added">1961   // Alias index currently shared by all flattened memory accesses</span>
<span class="line-added">1962   int index = get_alias_index(TypeAryPtr::VALUES);</span>
<span class="line-added">1963 </span>
<span class="line-added">1964   // Find MergeMem nodes and flattened array accesses</span>
<span class="line-added">1965   for (uint i = 0; i &lt; wq.size(); i++) {</span>
<span class="line-added">1966     Node* n = wq.at(i);</span>
<span class="line-added">1967     if (n-&gt;is_Mem()) {</span>
<span class="line-added">1968       const TypePtr* adr_type = NULL;</span>
<span class="line-added">1969       if (n-&gt;Opcode() == Op_StoreCM) {</span>
<span class="line-added">1970         adr_type = get_adr_type(get_alias_index(n-&gt;in(MemNode::OopStore)-&gt;adr_type()));</span>
<span class="line-added">1971       } else {</span>
<span class="line-added">1972         adr_type = get_adr_type(get_alias_index(n-&gt;adr_type()));</span>
<span class="line-added">1973       }</span>
<span class="line-added">1974       if (adr_type == TypeAryPtr::VALUES) {</span>
<span class="line-added">1975         memnodes.push(n);</span>
<span class="line-added">1976       }</span>
<span class="line-added">1977     } else if (n-&gt;is_MergeMem()) {</span>
<span class="line-added">1978       MergeMemNode* mm = n-&gt;as_MergeMem();</span>
<span class="line-added">1979       if (mm-&gt;memory_at(index) != mm-&gt;base_memory()) {</span>
<span class="line-added">1980         mergememnodes.push(n);</span>
<span class="line-added">1981       }</span>
<span class="line-added">1982     }</span>
<span class="line-added">1983     for (uint j = 0; j &lt; n-&gt;req(); j++) {</span>
<span class="line-added">1984       Node* m = n-&gt;in(j);</span>
<span class="line-added">1985       if (m != NULL) {</span>
<span class="line-added">1986         wq.push(m);</span>
<span class="line-added">1987       }</span>
<span class="line-added">1988     }</span>
<span class="line-added">1989   }</span>
<span class="line-added">1990 </span>
<span class="line-added">1991   if (memnodes.size() &gt; 0) {</span>
<span class="line-added">1992     _flattened_accesses_share_alias = false;</span>
<span class="line-added">1993 </span>
<span class="line-added">1994     // We are going to change the slice for the flattened array</span>
<span class="line-added">1995     // accesses so we need to clear the cache entries that refer to</span>
<span class="line-added">1996     // them.</span>
<span class="line-added">1997     for (uint i = 0; i &lt; AliasCacheSize; i++) {</span>
<span class="line-added">1998       AliasCacheEntry* ace = &amp;_alias_cache[i];</span>
<span class="line-added">1999       if (ace-&gt;_adr_type != NULL &amp;&amp;</span>
<span class="line-added">2000           ace-&gt;_adr_type-&gt;isa_aryptr() &amp;&amp;</span>
<span class="line-added">2001           ace-&gt;_adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {</span>
<span class="line-added">2002         ace-&gt;_adr_type = NULL;</span>
<span class="line-added">2003         ace-&gt;_index = (i != 0) ? 0 : AliasIdxTop; // Make sure the NULL adr_type resolves to AliasIdxTop</span>
<span class="line-added">2004       }</span>
<span class="line-added">2005     }</span>
<span class="line-added">2006 </span>
<span class="line-added">2007     // Find what aliases we are going to add</span>
<span class="line-added">2008     int start_alias = num_alias_types()-1;</span>
<span class="line-added">2009     int stop_alias = 0;</span>
<span class="line-added">2010 </span>
<span class="line-added">2011     for (uint i = 0; i &lt; memnodes.size(); i++) {</span>
<span class="line-added">2012       Node* m = memnodes.at(i);</span>
<span class="line-added">2013       const TypePtr* adr_type = NULL;</span>
<span class="line-added">2014       if (m-&gt;Opcode() == Op_StoreCM) {</span>
<span class="line-added">2015         adr_type = m-&gt;in(MemNode::OopStore)-&gt;adr_type();</span>
<span class="line-added">2016         Node* clone = new StoreCMNode(m-&gt;in(MemNode::Control), m-&gt;in(MemNode::Memory), m-&gt;in(MemNode::Address),</span>
<span class="line-added">2017                                       m-&gt;adr_type(), m-&gt;in(MemNode::ValueIn), m-&gt;in(MemNode::OopStore),</span>
<span class="line-added">2018                                       get_alias_index(adr_type));</span>
<span class="line-added">2019         igvn.register_new_node_with_optimizer(clone);</span>
<span class="line-added">2020         igvn.replace_node(m, clone);</span>
<span class="line-added">2021       } else {</span>
<span class="line-added">2022         adr_type = m-&gt;adr_type();</span>
<span class="line-added">2023 #ifdef ASSERT</span>
<span class="line-added">2024         m-&gt;as_Mem()-&gt;set_adr_type(adr_type);</span>
<span class="line-added">2025 #endif</span>
<span class="line-added">2026       }</span>
<span class="line-added">2027       int idx = get_alias_index(adr_type);</span>
<span class="line-added">2028       start_alias = MIN2(start_alias, idx);</span>
<span class="line-added">2029       stop_alias = MAX2(stop_alias, idx);</span>
<span class="line-added">2030     }</span>
<span class="line-added">2031 </span>
<span class="line-added">2032     assert(stop_alias &gt;= start_alias, &quot;should have expanded aliases&quot;);</span>
<span class="line-added">2033 </span>
<span class="line-added">2034     Node_Stack stack(0);</span>
<span class="line-added">2035 #ifdef ASSERT</span>
<span class="line-added">2036     VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="line-added">2037 #endif</span>
<span class="line-added">2038     // Now let&#39;s fix the memory graph so each flattened array access</span>
<span class="line-added">2039     // is moved to the right slice. Start from the MergeMem nodes.</span>
<span class="line-added">2040     uint last = unique();</span>
<span class="line-added">2041     for (uint i = 0; i &lt; mergememnodes.size(); i++) {</span>
<span class="line-added">2042       MergeMemNode* current = mergememnodes.at(i)-&gt;as_MergeMem();</span>
<span class="line-added">2043       Node* n = current-&gt;memory_at(index);</span>
<span class="line-added">2044       MergeMemNode* mm = NULL;</span>
<span class="line-added">2045       do {</span>
<span class="line-added">2046         // Follow memory edges through memory accesses, phis and</span>
<span class="line-added">2047         // narrow membars and push nodes on the stack. Once we hit</span>
<span class="line-added">2048         // bottom memory, we pop element off the stack one at a</span>
<span class="line-added">2049         // time, in reverse order, and move them to the right slice</span>
<span class="line-added">2050         // by changing their memory edges.</span>
<span class="line-added">2051         if ((n-&gt;is_Phi() &amp;&amp; n-&gt;adr_type() != TypePtr::BOTTOM) || n-&gt;is_Mem() || n-&gt;adr_type() == TypeAryPtr::VALUES) {</span>
<span class="line-added">2052           assert(!seen.test_set(n-&gt;_idx), &quot;&quot;);</span>
<span class="line-added">2053           // Uses (a load for instance) will need to be moved to the</span>
<span class="line-added">2054           // right slice as well and will get a new memory state</span>
<span class="line-added">2055           // that we don&#39;t know yet. The use could also be the</span>
<span class="line-added">2056           // backedge of a loop. We put a place holder node between</span>
<span class="line-added">2057           // the memory node and its uses. We replace that place</span>
<span class="line-added">2058           // holder with the correct memory state once we know it,</span>
<span class="line-added">2059           // i.e. when nodes are popped off the stack. Using the</span>
<span class="line-added">2060           // place holder make the logic work in the presence of</span>
<span class="line-added">2061           // loops.</span>
<span class="line-added">2062           if (n-&gt;outcnt() &gt; 1) {</span>
<span class="line-added">2063             Node* place_holder = NULL;</span>
<span class="line-added">2064             assert(!n-&gt;has_out_with(Op_Node), &quot;&quot;);</span>
<span class="line-added">2065             for (DUIterator k = n-&gt;outs(); n-&gt;has_out(k); k++) {</span>
<span class="line-added">2066               Node* u = n-&gt;out(k);</span>
<span class="line-added">2067               if (u != current &amp;&amp; u-&gt;_idx &lt; last) {</span>
<span class="line-added">2068                 bool success = false;</span>
<span class="line-added">2069                 for (uint l = 0; l &lt; u-&gt;req(); l++) {</span>
<span class="line-added">2070                   if (!stack.is_empty() &amp;&amp; u == stack.node() &amp;&amp; l == stack.index()) {</span>
<span class="line-added">2071                     continue;</span>
<span class="line-added">2072                   }</span>
<span class="line-added">2073                   Node* in = u-&gt;in(l);</span>
<span class="line-added">2074                   if (in == n) {</span>
<span class="line-added">2075                     if (place_holder == NULL) {</span>
<span class="line-added">2076                       place_holder = new Node(1);</span>
<span class="line-added">2077                       place_holder-&gt;init_req(0, n);</span>
<span class="line-added">2078                     }</span>
<span class="line-added">2079                     igvn.replace_input_of(u, l, place_holder);</span>
<span class="line-added">2080                     success = true;</span>
<span class="line-added">2081                   }</span>
<span class="line-added">2082                 }</span>
<span class="line-added">2083                 if (success) {</span>
<span class="line-added">2084                   --k;</span>
<span class="line-added">2085                 }</span>
<span class="line-added">2086               }</span>
<span class="line-added">2087             }</span>
<span class="line-added">2088           }</span>
<span class="line-added">2089           if (n-&gt;is_Phi()) {</span>
<span class="line-added">2090             stack.push(n, 1);</span>
<span class="line-added">2091             n = n-&gt;in(1);</span>
<span class="line-added">2092           } else if (n-&gt;is_Mem()) {</span>
<span class="line-added">2093             stack.push(n, n-&gt;req());</span>
<span class="line-added">2094             n = n-&gt;in(MemNode::Memory);</span>
<span class="line-added">2095           } else {</span>
<span class="line-added">2096             assert(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder, &quot;&quot;);</span>
<span class="line-added">2097             stack.push(n, n-&gt;req());</span>
<span class="line-added">2098             n = n-&gt;in(0)-&gt;in(TypeFunc::Memory);</span>
<span class="line-added">2099           }</span>
<span class="line-added">2100         } else {</span>
<span class="line-added">2101           assert(n-&gt;adr_type() == TypePtr::BOTTOM || (n-&gt;Opcode() == Op_Node &amp;&amp; n-&gt;_idx &gt;= last) || (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0)-&gt;is_Initialize()), &quot;&quot;);</span>
<span class="line-added">2102           // Build a new MergeMem node to carry the new memory state</span>
<span class="line-added">2103           // as we build it. IGVN should fold extraneous MergeMem</span>
<span class="line-added">2104           // nodes.</span>
<span class="line-added">2105           mm = MergeMemNode::make(n);</span>
<span class="line-added">2106           igvn.register_new_node_with_optimizer(mm);</span>
<span class="line-added">2107           while (stack.size() &gt; 0) {</span>
<span class="line-added">2108             Node* m = stack.node();</span>
<span class="line-added">2109             uint idx = stack.index();</span>
<span class="line-added">2110             if (m-&gt;is_Mem()) {</span>
<span class="line-added">2111               // Move memory node to its new slice</span>
<span class="line-added">2112               const TypePtr* adr_type = m-&gt;adr_type();</span>
<span class="line-added">2113               int alias = get_alias_index(adr_type);</span>
<span class="line-added">2114               Node* prev = mm-&gt;memory_at(alias);</span>
<span class="line-added">2115               igvn.replace_input_of(m, MemNode::Memory, prev);</span>
<span class="line-added">2116               mm-&gt;set_memory_at(alias, m);</span>
<span class="line-added">2117             } else if (m-&gt;is_Phi()) {</span>
<span class="line-added">2118               // We need as many new phis as there are new aliases</span>
<span class="line-added">2119               igvn.replace_input_of(m, idx, mm);</span>
<span class="line-added">2120               if (idx == m-&gt;req()-1) {</span>
<span class="line-added">2121                 Node* r = m-&gt;in(0);</span>
<span class="line-added">2122                 for (uint j = (uint)start_alias; j &lt;= (uint)stop_alias; j++) {</span>
<span class="line-added">2123                   const Type* adr_type = get_adr_type(j);</span>
<span class="line-added">2124                   if (!adr_type-&gt;isa_aryptr() || !adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {</span>
<span class="line-added">2125                     continue;</span>
<span class="line-added">2126                   }</span>
<span class="line-added">2127                   Node* phi = new PhiNode(r, Type::MEMORY, get_adr_type(j));</span>
<span class="line-added">2128                   igvn.register_new_node_with_optimizer(phi);</span>
<span class="line-added">2129                   for (uint k = 1; k &lt; m-&gt;req(); k++) {</span>
<span class="line-added">2130                     phi-&gt;init_req(k, m-&gt;in(k)-&gt;as_MergeMem()-&gt;memory_at(j));</span>
<span class="line-added">2131                   }</span>
<span class="line-added">2132                   mm-&gt;set_memory_at(j, phi);</span>
<span class="line-added">2133                 }</span>
<span class="line-added">2134                 Node* base_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);</span>
<span class="line-added">2135                 igvn.register_new_node_with_optimizer(base_phi);</span>
<span class="line-added">2136                 for (uint k = 1; k &lt; m-&gt;req(); k++) {</span>
<span class="line-added">2137                   base_phi-&gt;init_req(k, m-&gt;in(k)-&gt;as_MergeMem()-&gt;base_memory());</span>
<span class="line-added">2138                 }</span>
<span class="line-added">2139                 mm-&gt;set_base_memory(base_phi);</span>
<span class="line-added">2140               }</span>
<span class="line-added">2141             } else {</span>
<span class="line-added">2142               // This is a MemBarCPUOrder node from</span>
<span class="line-added">2143               // Parse::array_load()/Parse::array_store(), in the</span>
<span class="line-added">2144               // branch that handles flattened arrays hidden under</span>
<span class="line-added">2145               // an Object[] array. We also need one new membar per</span>
<span class="line-added">2146               // new alias to keep the unknown access that the</span>
<span class="line-added">2147               // membars protect properly ordered with accesses to</span>
<span class="line-added">2148               // known flattened array.</span>
<span class="line-added">2149               assert(m-&gt;is_Proj(), &quot;projection expected&quot;);</span>
<span class="line-added">2150               Node* ctrl = m-&gt;in(0)-&gt;in(TypeFunc::Control);</span>
<span class="line-added">2151               igvn.replace_input_of(m-&gt;in(0), TypeFunc::Control, top());</span>
<span class="line-added">2152               for (uint j = (uint)start_alias; j &lt;= (uint)stop_alias; j++) {</span>
<span class="line-added">2153                 const Type* adr_type = get_adr_type(j);</span>
<span class="line-added">2154                 if (!adr_type-&gt;isa_aryptr() || !adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {</span>
<span class="line-added">2155                   continue;</span>
<span class="line-added">2156                 }</span>
<span class="line-added">2157                 MemBarNode* mb = new MemBarCPUOrderNode(this, j, NULL);</span>
<span class="line-added">2158                 igvn.register_new_node_with_optimizer(mb);</span>
<span class="line-added">2159                 Node* mem = mm-&gt;memory_at(j);</span>
<span class="line-added">2160                 mb-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="line-added">2161                 mb-&gt;init_req(TypeFunc::Memory, mem);</span>
<span class="line-added">2162                 ctrl = new ProjNode(mb, TypeFunc::Control);</span>
<span class="line-added">2163                 igvn.register_new_node_with_optimizer(ctrl);</span>
<span class="line-added">2164                 mem = new ProjNode(mb, TypeFunc::Memory);</span>
<span class="line-added">2165                 igvn.register_new_node_with_optimizer(mem);</span>
<span class="line-added">2166                 mm-&gt;set_memory_at(j, mem);</span>
<span class="line-added">2167               }</span>
<span class="line-added">2168               igvn.replace_node(m-&gt;in(0)-&gt;as_Multi()-&gt;proj_out(TypeFunc::Control), ctrl);</span>
<span class="line-added">2169             }</span>
<span class="line-added">2170             if (idx &lt; m-&gt;req()-1) {</span>
<span class="line-added">2171               idx += 1;</span>
<span class="line-added">2172               stack.set_index(idx);</span>
<span class="line-added">2173               n = m-&gt;in(idx);</span>
<span class="line-added">2174               break;</span>
<span class="line-added">2175             }</span>
<span class="line-added">2176             // Take care of place holder nodes</span>
<span class="line-added">2177             if (m-&gt;has_out_with(Op_Node)) {</span>
<span class="line-added">2178               Node* place_holder = m-&gt;find_out_with(Op_Node);</span>
<span class="line-added">2179               if (place_holder != NULL) {</span>
<span class="line-added">2180                 Node* mm_clone = mm-&gt;clone();</span>
<span class="line-added">2181                 igvn.register_new_node_with_optimizer(mm_clone);</span>
<span class="line-added">2182                 Node* hook = new Node(1);</span>
<span class="line-added">2183                 hook-&gt;init_req(0, mm);</span>
<span class="line-added">2184                 igvn.replace_node(place_holder, mm_clone);</span>
<span class="line-added">2185                 hook-&gt;destruct();</span>
<span class="line-added">2186               }</span>
<span class="line-added">2187               assert(!m-&gt;has_out_with(Op_Node), &quot;place holder should be gone now&quot;);</span>
<span class="line-added">2188             }</span>
<span class="line-added">2189             stack.pop();</span>
<span class="line-added">2190           }</span>
<span class="line-added">2191         }</span>
<span class="line-added">2192       } while(stack.size() &gt; 0);</span>
<span class="line-added">2193       // Fix the memory state at the MergeMem we started from</span>
<span class="line-added">2194       igvn.rehash_node_delayed(current);</span>
<span class="line-added">2195       for (uint j = (uint)start_alias; j &lt;= (uint)stop_alias; j++) {</span>
<span class="line-added">2196         const Type* adr_type = get_adr_type(j);</span>
<span class="line-added">2197         if (!adr_type-&gt;isa_aryptr() || !adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_valuetype()) {</span>
<span class="line-added">2198           continue;</span>
<span class="line-added">2199         }</span>
<span class="line-added">2200         current-&gt;set_memory_at(j, mm);</span>
<span class="line-added">2201       }</span>
<span class="line-added">2202       current-&gt;set_memory_at(index, current-&gt;base_memory());</span>
<span class="line-added">2203     }</span>
<span class="line-added">2204     igvn.optimize();</span>
<span class="line-added">2205   }</span>
<span class="line-added">2206   print_method(PHASE_SPLIT_VALUES_ARRAY, 2);</span>
<span class="line-added">2207 }</span>
<span class="line-added">2208 </span>
<span class="line-added">2209 </span>
2210 // StringOpts and late inlining of string methods
2211 void Compile::inline_string_calls(bool parse_time) {
2212   {
2213     // remove useless nodes to make the usage analysis simpler
2214     ResourceMark rm;
2215     PhaseRemoveUseless pru(initial_gvn(), for_igvn());
2216   }
2217 
2218   {
2219     ResourceMark rm;
2220     print_method(PHASE_BEFORE_STRINGOPTS, 3);
2221     PhaseStringOpts pso(initial_gvn(), for_igvn());
2222     print_method(PHASE_AFTER_STRINGOPTS, 3);
2223   }
2224 
2225   // now inline anything that we skipped the first time around
2226   if (!parse_time) {
2227     _late_inlines_pos = _late_inlines.length();
2228   }
2229 
2230   while (_string_late_inlines.length() &gt; 0) {
2231     CallGenerator* cg = _string_late_inlines.pop();
2232     cg-&gt;do_late_inline();
2233     if (failing())  return;
2234   }
2235   _string_late_inlines.trunc_to(0);
2236 }
2237 
2238 // Late inlining of boxing methods
2239 void Compile::inline_boxing_calls(PhaseIterGVN&amp; igvn) {
2240   if (_boxing_late_inlines.length() &gt; 0) {
2241     assert(has_boxed_value(), &quot;inconsistent&quot;);
2242 
2243     PhaseGVN* gvn = initial_gvn();
2244     set_inlining_incrementally(true);
2245 
2246     assert( igvn._worklist.size() == 0, &quot;should be done with igvn&quot; );
2247     for_igvn()-&gt;clear();
2248     gvn-&gt;replace_with(&amp;igvn);
2249 
2250     _late_inlines_pos = _late_inlines.length();
2251 
2252     while (_boxing_late_inlines.length() &gt; 0) {
2253       CallGenerator* cg = _boxing_late_inlines.pop();
2254       cg-&gt;do_late_inline();
2255       if (failing())  return;
2256     }
2257     _boxing_late_inlines.trunc_to(0);
2258 
2259     inline_incrementally_cleanup(igvn);
2260 
2261     set_inlining_incrementally(false);
2262   }
2263 }
2264 
2265 bool Compile::inline_incrementally_one() {
2266   assert(IncrementalInline, &quot;incremental inlining should be on&quot;);
2267 
2268   TracePhase tp(&quot;incrementalInline_inline&quot;, &amp;timers[_t_incrInline_inline]);
2269   set_inlining_progress(false);
2270   set_do_cleanup(false);
2271   int i = 0;
2272   for (; i &lt;_late_inlines.length() &amp;&amp; !inlining_progress(); i++) {
2273     CallGenerator* cg = _late_inlines.at(i);
2274     _late_inlines_pos = i+1;
2275     cg-&gt;do_late_inline();
2276     if (failing())  return false;
2277   }
2278   int j = 0;
2279   for (; i &lt; _late_inlines.length(); i++, j++) {
2280     _late_inlines.at_put(j, _late_inlines.at(i));
2281   }
2282   _late_inlines.trunc_to(j);
2283   assert(inlining_progress() || _late_inlines.length() == 0, &quot;&quot;);
2284 
2285   bool needs_cleanup = do_cleanup() || over_inlining_cutoff();
2286 
2287   set_inlining_progress(false);
2288   set_do_cleanup(false);
2289   return (_late_inlines.length() &gt; 0) &amp;&amp; !needs_cleanup;
2290 }
2291 
2292 void Compile::inline_incrementally_cleanup(PhaseIterGVN&amp; igvn) {
2293   {
2294     TracePhase tp(&quot;incrementalInline_pru&quot;, &amp;timers[_t_incrInline_pru]);
2295     ResourceMark rm;
2296     PhaseRemoveUseless pru(initial_gvn(), for_igvn());
2297   }
2298   {
2299     TracePhase tp(&quot;incrementalInline_igvn&quot;, &amp;timers[_t_incrInline_igvn]);
2300     igvn = PhaseIterGVN(initial_gvn());
2301     igvn.optimize();
2302   }
2303 }
2304 
2305 // Perform incremental inlining until bound on number of live nodes is reached
2306 void Compile::inline_incrementally(PhaseIterGVN&amp; igvn) {
2307   TracePhase tp(&quot;incrementalInline&quot;, &amp;timers[_t_incrInline]);
2308 
2309   set_inlining_incrementally(true);
2310   uint low_live_nodes = 0;
2311 
2312   while (_late_inlines.length() &gt; 0) {
2313     if (live_nodes() &gt; (uint)LiveNodeCountInliningCutoff) {
2314       if (low_live_nodes &lt; (uint)LiveNodeCountInliningCutoff * 8 / 10) {
2315         TracePhase tp(&quot;incrementalInline_ideal&quot;, &amp;timers[_t_incrInline_ideal]);
2316         // PhaseIdealLoop is expensive so we only try it once we are
2317         // out of live nodes and we only try it again if the previous
2318         // helped got the number of nodes down significantly
2319         PhaseIdealLoop::optimize(igvn, LoopOptsNone);
2320         if (failing())  return;
2321         low_live_nodes = live_nodes();
2322         _major_progress = true;
2323       }
2324 
2325       if (live_nodes() &gt; (uint)LiveNodeCountInliningCutoff) {
2326         break; // finish
2327       }
2328     }
2329 
2330     for_igvn()-&gt;clear();
2331     initial_gvn()-&gt;replace_with(&amp;igvn);
2332 
2333     while (inline_incrementally_one()) {
2334       assert(!failing(), &quot;inconsistent&quot;);
2335     }
2336 
2337     if (failing())  return;
2338 
2339     inline_incrementally_cleanup(igvn);
2340 
2341     if (failing())  return;
2342   }
2343   assert( igvn._worklist.size() == 0, &quot;should be done with igvn&quot; );
2344 
2345   if (_string_late_inlines.length() &gt; 0) {
2346     assert(has_stringbuilder(), &quot;inconsistent&quot;);
2347     for_igvn()-&gt;clear();
2348     initial_gvn()-&gt;replace_with(&amp;igvn);
2349 
2350     inline_string_calls(false);
2351 
2352     if (failing())  return;
2353 
2354     inline_incrementally_cleanup(igvn);
2355   }
2356 
2357   set_inlining_incrementally(false);
2358 }
2359 
2360 
2361 bool Compile::optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode) {
2362   if(_loop_opts_cnt &gt; 0) {
2363     debug_only( int cnt = 0; );
2364     while(major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2365       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2366       assert( cnt++ &lt; 40, &quot;infinite cycle in loop optimization&quot; );
2367       PhaseIdealLoop::optimize(igvn, mode);
2368       _loop_opts_cnt--;
2369       if (failing())  return false;
2370       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP_ITERATIONS, 2);
2371     }
2372   }
2373   return true;
2374 }
2375 
2376 // Remove edges from &quot;root&quot; to each SafePoint at a backward branch.
2377 // They were inserted during parsing (see add_safepoint()) to make
2378 // infinite loops without calls or exceptions visible to root, i.e.,
2379 // useful.
2380 void Compile::remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn) {
2381   Node *r = root();
2382   if (r != NULL) {
2383     for (uint i = r-&gt;req(); i &lt; r-&gt;len(); ++i) {
2384       Node *n = r-&gt;in(i);
2385       if (n != NULL &amp;&amp; n-&gt;is_SafePoint()) {
2386         r-&gt;rm_prec(i);
2387         if (n-&gt;outcnt() == 0) {
2388           igvn.remove_dead_node(n);
2389         }
2390         --i;
2391       }
2392     }
2393     // Parsing may have added top inputs to the root node (Path
2394     // leading to the Halt node proven dead). Make sure we get a
2395     // chance to clean them up.
2396     igvn._worklist.push(r);
2397     igvn.optimize();
2398   }
2399 }
2400 
2401 //------------------------------Optimize---------------------------------------
2402 // Given a graph, optimize it.
2403 void Compile::Optimize() {
2404   TracePhase tp(&quot;optimizer&quot;, &amp;timers[_t_optimizer]);
2405 
2406 #ifndef PRODUCT
2407   if (_directive-&gt;BreakAtCompileOption) {
2408     BREAKPOINT;
2409   }
2410 
2411 #endif
2412 
2413   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2414 #ifdef ASSERT
2415   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeOptimize);
2416 #endif
2417 
2418   ResourceMark rm;
2419 
2420   print_inlining_reinit();
2421 
2422   NOT_PRODUCT( verify_graph_edges(); )
2423 
2424   print_method(PHASE_AFTER_PARSING);
2425 
2426  {
2427   // Iterative Global Value Numbering, including ideal transforms
2428   // Initialize IterGVN with types and values from parse-time GVN
2429   PhaseIterGVN igvn(initial_gvn());
2430 #ifdef ASSERT
2431   _modified_nodes = new (comp_arena()) Unique_Node_List(comp_arena());
2432 #endif
2433   {
2434     TracePhase tp(&quot;iterGVN&quot;, &amp;timers[_t_iterGVN]);
2435     igvn.optimize();
2436   }
2437 
2438   if (failing())  return;
2439 
2440   print_method(PHASE_ITER_GVN1, 2);
2441 
2442   inline_incrementally(igvn);
2443 
2444   print_method(PHASE_INCREMENTAL_INLINE, 2);
2445 
2446   if (failing())  return;
2447 
2448   if (eliminate_boxing()) {
2449     // Inline valueOf() methods now.
2450     inline_boxing_calls(igvn);
2451 
2452     if (AlwaysIncrementalInline) {
2453       inline_incrementally(igvn);
2454     }
2455 
2456     print_method(PHASE_INCREMENTAL_BOXING_INLINE, 2);
2457 
2458     if (failing())  return;
2459   }
2460 
2461   // Now that all inlining is over, cut edge from root to loop
2462   // safepoints
2463   remove_root_to_sfpts_edges(igvn);
2464 
2465   // Remove the speculative part of types and clean up the graph from
2466   // the extra CastPP nodes whose only purpose is to carry them. Do
2467   // that early so that optimizations are not disrupted by the extra
2468   // CastPP nodes.
2469   remove_speculative_types(igvn);
2470 
2471   // No more new expensive nodes will be added to the list from here
2472   // so keep only the actual candidates for optimizations.
2473   cleanup_expensive_nodes(igvn);
2474 
2475   if (!failing() &amp;&amp; RenumberLiveNodes &amp;&amp; live_nodes() + NodeLimitFudgeFactor &lt; unique()) {
2476     Compile::TracePhase tp(&quot;&quot;, &amp;timers[_t_renumberLive]);
2477     initial_gvn()-&gt;replace_with(&amp;igvn);
2478     for_igvn()-&gt;clear();
2479     Unique_Node_List new_worklist(C-&gt;comp_arena());
2480     {
2481       ResourceMark rm;
2482       PhaseRenumberLive prl = PhaseRenumberLive(initial_gvn(), for_igvn(), &amp;new_worklist);
2483     }
2484     set_for_igvn(&amp;new_worklist);
2485     igvn = PhaseIterGVN(initial_gvn());
2486     igvn.optimize();
2487   }
2488 
<a name="42" id="anc42"></a><span class="line-added">2489   if (_value_type_nodes-&gt;size() &gt; 0) {</span>
<span class="line-added">2490     // Do this once all inlining is over to avoid getting inconsistent debug info</span>
<span class="line-added">2491     process_value_types(igvn);</span>
<span class="line-added">2492   }</span>
<span class="line-added">2493 </span>
<span class="line-added">2494   adjust_flattened_array_access_aliases(igvn);</span>
<span class="line-added">2495 </span>
2496   // Perform escape analysis
2497   if (_do_escape_analysis &amp;&amp; ConnectionGraph::has_candidates(this)) {
2498     if (has_loops()) {
2499       // Cleanup graph (remove dead nodes).
2500       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2501       PhaseIdealLoop::optimize(igvn, LoopOptsMaxUnroll);
2502       if (major_progress()) print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);
2503       if (failing())  return;
2504     }
2505     ConnectionGraph::do_analysis(this, &amp;igvn);
2506 
2507     if (failing())  return;
2508 
2509     // Optimize out fields loads from scalar replaceable allocations.
2510     igvn.optimize();
2511     print_method(PHASE_ITER_GVN_AFTER_EA, 2);
2512 
2513     if (failing())  return;
2514 
2515     if (congraph() != NULL &amp;&amp; macro_count() &gt; 0) {
2516       TracePhase tp(&quot;macroEliminate&quot;, &amp;timers[_t_macroEliminate]);
2517       PhaseMacroExpand mexp(igvn);
2518       mexp.eliminate_macro_nodes();
2519       igvn.set_delay_transform(false);
2520 
2521       igvn.optimize();
2522       print_method(PHASE_ITER_GVN_AFTER_ELIMINATION, 2);
2523 
2524       if (failing())  return;
2525     }
2526   }
2527 
2528   // Loop transforms on the ideal graph.  Range Check Elimination,
2529   // peeling, unrolling, etc.
2530 
2531   // Set loop opts counter
2532   if((_loop_opts_cnt &gt; 0) &amp;&amp; (has_loops() || has_split_ifs())) {
2533     {
2534       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2535       PhaseIdealLoop::optimize(igvn, LoopOptsDefault);
2536       _loop_opts_cnt--;
2537       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP1, 2);
2538       if (failing())  return;
2539     }
2540     // Loop opts pass if partial peeling occurred in previous pass
2541     if(PartialPeelLoop &amp;&amp; major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2542       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2543       PhaseIdealLoop::optimize(igvn, LoopOptsSkipSplitIf);
2544       _loop_opts_cnt--;
2545       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP2, 2);
2546       if (failing())  return;
2547     }
2548     // Loop opts pass for loop-unrolling before CCP
2549     if(major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2550       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2551       PhaseIdealLoop::optimize(igvn, LoopOptsSkipSplitIf);
2552       _loop_opts_cnt--;
2553       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP3, 2);
2554     }
2555     if (!failing()) {
2556       // Verify that last round of loop opts produced a valid graph
2557       TracePhase tp(&quot;idealLoopVerify&quot;, &amp;timers[_t_idealLoopVerify]);
2558       PhaseIdealLoop::verify(igvn);
2559     }
2560   }
2561   if (failing())  return;
2562 
2563   // Conditional Constant Propagation;
2564   PhaseCCP ccp( &amp;igvn );
2565   assert( true, &quot;Break here to ccp.dump_nodes_and_types(_root,999,1)&quot;);
2566   {
2567     TracePhase tp(&quot;ccp&quot;, &amp;timers[_t_ccp]);
2568     ccp.do_transform();
2569   }
2570   print_method(PHASE_CPP1, 2);
2571 
2572   assert( true, &quot;Break here to ccp.dump_old2new_map()&quot;);
2573 
2574   // Iterative Global Value Numbering, including ideal transforms
2575   {
2576     TracePhase tp(&quot;iterGVN2&quot;, &amp;timers[_t_iterGVN2]);
2577     igvn = ccp;
2578     igvn.optimize();
2579   }
2580   print_method(PHASE_ITER_GVN2, 2);
2581 
2582   if (failing())  return;
2583 
2584   // Loop transforms on the ideal graph.  Range Check Elimination,
2585   // peeling, unrolling, etc.
2586   if (!optimize_loops(igvn, LoopOptsDefault)) {
2587     return;
2588   }
2589 
2590   if (failing())  return;
2591 
2592   // Ensure that major progress is now clear
2593   C-&gt;clear_major_progress();
2594 
2595   {
2596     // Verify that all previous optimizations produced a valid graph
2597     // at least to this point, even if no loop optimizations were done.
2598     TracePhase tp(&quot;idealLoopVerify&quot;, &amp;timers[_t_idealLoopVerify]);
2599     PhaseIdealLoop::verify(igvn);
2600   }
2601 
2602   if (range_check_cast_count() &gt; 0) {
2603     // No more loop optimizations. Remove all range check dependent CastIINodes.
2604     C-&gt;remove_range_check_casts(igvn);
2605     igvn.optimize();
2606   }
2607 
2608 #ifdef ASSERT
2609   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeMacroExpand);
2610 #endif
2611 
2612   {
2613     TracePhase tp(&quot;macroExpand&quot;, &amp;timers[_t_macroExpand]);
2614     PhaseMacroExpand  mex(igvn);
2615     if (mex.expand_macro_nodes()) {
2616       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2617       return;
2618     }
2619     print_method(PHASE_MACRO_EXPANSION, 2);
2620   }
2621 
2622   {
2623     TracePhase tp(&quot;barrierExpand&quot;, &amp;timers[_t_barrierExpand]);
2624     if (bs-&gt;expand_barriers(this, igvn)) {
2625       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2626       return;
2627     }
2628     print_method(PHASE_BARRIER_EXPANSION, 2);
2629   }
2630 
2631   if (opaque4_count() &gt; 0) {
2632     C-&gt;remove_opaque4_nodes(igvn);
2633     igvn.optimize();
2634   }
2635 
2636   if (C-&gt;max_vector_size() &gt; 0) {
2637     C-&gt;optimize_logic_cones(igvn);
2638     igvn.optimize();
2639   }
2640 
2641   DEBUG_ONLY( _modified_nodes = NULL; )
2642  } // (End scope of igvn; run destructor if necessary for asserts.)
2643 
2644  process_print_inlining();
2645  // A method with only infinite loops has no edges entering loops from root
2646  {
2647    TracePhase tp(&quot;graphReshape&quot;, &amp;timers[_t_graphReshaping]);
2648    if (final_graph_reshaping()) {
2649      assert(failing(), &quot;must bail out w/ explicit message&quot;);
2650      return;
2651    }
2652  }
2653 
2654  print_method(PHASE_OPTIMIZE_FINISHED, 2);
2655 }
2656 
2657 //---------------------------- Bitwise operation packing optimization ---------------------------
2658 
2659 static bool is_vector_unary_bitwise_op(Node* n) {
2660   return n-&gt;Opcode() == Op_XorV &amp;&amp;
2661          VectorNode::is_vector_bitwise_not_pattern(n);
2662 }
2663 
2664 static bool is_vector_binary_bitwise_op(Node* n) {
2665   switch (n-&gt;Opcode()) {
2666     case Op_AndV:
2667     case Op_OrV:
2668       return true;
2669 
2670     case Op_XorV:
2671       return !is_vector_unary_bitwise_op(n);
2672 
2673     default:
2674       return false;
2675   }
2676 }
2677 
2678 static bool is_vector_ternary_bitwise_op(Node* n) {
2679   return n-&gt;Opcode() == Op_MacroLogicV;
2680 }
2681 
2682 static bool is_vector_bitwise_op(Node* n) {
2683   return is_vector_unary_bitwise_op(n)  ||
2684          is_vector_binary_bitwise_op(n) ||
2685          is_vector_ternary_bitwise_op(n);
2686 }
2687 
2688 static bool is_vector_bitwise_cone_root(Node* n) {
2689   if (!is_vector_bitwise_op(n)) {
2690     return false;
2691   }
2692   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2693     if (is_vector_bitwise_op(n-&gt;fast_out(i))) {
2694       return false;
2695     }
2696   }
2697   return true;
2698 }
2699 
2700 static uint collect_unique_inputs(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {
2701   uint cnt = 0;
2702   if (is_vector_bitwise_op(n)) {
2703     if (VectorNode::is_vector_bitwise_not_pattern(n)) {
2704       for (uint i = 1; i &lt; n-&gt;req(); i++) {
2705         Node* in = n-&gt;in(i);
2706         bool skip = VectorNode::is_all_ones_vector(in);
2707         if (!skip &amp;&amp; !inputs.member(in)) {
2708           inputs.push(in);
2709           cnt++;
2710         }
2711       }
2712       assert(cnt &lt;= 1, &quot;not unary&quot;);
2713     } else {
2714       uint last_req = n-&gt;req();
2715       if (is_vector_ternary_bitwise_op(n)) {
2716         last_req = n-&gt;req() - 1; // skip last input
2717       }
2718       for (uint i = 1; i &lt; last_req; i++) {
2719         Node* def = n-&gt;in(i);
2720         if (!inputs.member(def)) {
2721           inputs.push(def);
2722           cnt++;
2723         }
2724       }
2725     }
2726     partition.push(n);
2727   } else { // not a bitwise operations
2728     if (!inputs.member(n)) {
2729       inputs.push(n);
2730       cnt++;
2731     }
2732   }
2733   return cnt;
2734 }
2735 
2736 void Compile::collect_logic_cone_roots(Unique_Node_List&amp; list) {
2737   Unique_Node_List useful_nodes;
2738   C-&gt;identify_useful_nodes(useful_nodes);
2739 
2740   for (uint i = 0; i &lt; useful_nodes.size(); i++) {
2741     Node* n = useful_nodes.at(i);
2742     if (is_vector_bitwise_cone_root(n)) {
2743       list.push(n);
2744     }
2745   }
2746 }
2747 
2748 Node* Compile::xform_to_MacroLogicV(PhaseIterGVN&amp; igvn,
2749                                     const TypeVect* vt,
2750                                     Unique_Node_List&amp; partition,
2751                                     Unique_Node_List&amp; inputs) {
2752   assert(partition.size() == 2 || partition.size() == 3, &quot;not supported&quot;);
2753   assert(inputs.size()    == 2 || inputs.size()    == 3, &quot;not supported&quot;);
2754   assert(Matcher::match_rule_supported_vector(Op_MacroLogicV, vt-&gt;length(), vt-&gt;element_basic_type()), &quot;not supported&quot;);
2755 
2756   Node* in1 = inputs.at(0);
2757   Node* in2 = inputs.at(1);
2758   Node* in3 = (inputs.size() == 3 ? inputs.at(2) : in2);
2759 
2760   uint func = compute_truth_table(partition, inputs);
2761   return igvn.transform(MacroLogicVNode::make(igvn, in3, in2, in1, func, vt));
2762 }
2763 
2764 static uint extract_bit(uint func, uint pos) {
2765   return (func &amp; (1 &lt;&lt; pos)) &gt;&gt; pos;
2766 }
2767 
2768 //
2769 //  A macro logic node represents a truth table. It has 4 inputs,
2770 //  First three inputs corresponds to 3 columns of a truth table
2771 //  and fourth input captures the logic function.
2772 //
2773 //  eg.  fn = (in1 AND in2) OR in3;
2774 //
2775 //      MacroNode(in1,in2,in3,fn)
2776 //
2777 //  -----------------
2778 //  in1 in2 in3  fn
2779 //  -----------------
2780 //  0    0   0    0
2781 //  0    0   1    1
2782 //  0    1   0    0
2783 //  0    1   1    1
2784 //  1    0   0    0
2785 //  1    0   1    1
2786 //  1    1   0    1
2787 //  1    1   1    1
2788 //
2789 
2790 uint Compile::eval_macro_logic_op(uint func, uint in1 , uint in2, uint in3) {
2791   int res = 0;
2792   for (int i = 0; i &lt; 8; i++) {
2793     int bit1 = extract_bit(in1, i);
2794     int bit2 = extract_bit(in2, i);
2795     int bit3 = extract_bit(in3, i);
2796 
2797     int func_bit_pos = (bit1 &lt;&lt; 2 | bit2 &lt;&lt; 1 | bit3);
2798     int func_bit = extract_bit(func, func_bit_pos);
2799 
2800     res |= func_bit &lt;&lt; i;
2801   }
2802   return res;
2803 }
2804 
2805 static uint eval_operand(Node* n, ResourceHashtable&lt;Node*,uint&gt;&amp; eval_map) {
2806   assert(n != NULL, &quot;&quot;);
2807   assert(eval_map.contains(n), &quot;absent&quot;);
2808   return *(eval_map.get(n));
2809 }
2810 
2811 static void eval_operands(Node* n,
2812                           uint&amp; func1, uint&amp; func2, uint&amp; func3,
2813                           ResourceHashtable&lt;Node*,uint&gt;&amp; eval_map) {
2814   assert(is_vector_bitwise_op(n), &quot;&quot;);
2815   func1 = eval_operand(n-&gt;in(1), eval_map);
2816 
2817   if (is_vector_binary_bitwise_op(n)) {
2818     func2 = eval_operand(n-&gt;in(2), eval_map);
2819   } else if (is_vector_ternary_bitwise_op(n)) {
2820     func2 = eval_operand(n-&gt;in(2), eval_map);
2821     func3 = eval_operand(n-&gt;in(3), eval_map);
2822   } else {
2823     assert(is_vector_unary_bitwise_op(n), &quot;not unary&quot;);
2824   }
2825 }
2826 
2827 uint Compile::compute_truth_table(Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {
2828   assert(inputs.size() &lt;= 3, &quot;sanity&quot;);
2829   ResourceMark rm;
2830   uint res = 0;
2831   ResourceHashtable&lt;Node*,uint&gt; eval_map;
2832 
2833   // Populate precomputed functions for inputs.
2834   // Each input corresponds to one column of 3 input truth-table.
2835   uint input_funcs[] = { 0xAA,   // (_, _, a) -&gt; a
2836                          0xCC,   // (_, b, _) -&gt; b
2837                          0xF0 }; // (c, _, _) -&gt; c
2838   for (uint i = 0; i &lt; inputs.size(); i++) {
2839     eval_map.put(inputs.at(i), input_funcs[i]);
2840   }
2841 
2842   for (uint i = 0; i &lt; partition.size(); i++) {
2843     Node* n = partition.at(i);
2844 
2845     uint func1 = 0, func2 = 0, func3 = 0;
2846     eval_operands(n, func1, func2, func3, eval_map);
2847 
2848     switch (n-&gt;Opcode()) {
2849       case Op_OrV:
2850         assert(func3 == 0, &quot;not binary&quot;);
2851         res = func1 | func2;
2852         break;
2853       case Op_AndV:
2854         assert(func3 == 0, &quot;not binary&quot;);
2855         res = func1 &amp; func2;
2856         break;
2857       case Op_XorV:
2858         if (VectorNode::is_vector_bitwise_not_pattern(n)) {
2859           assert(func2 == 0 &amp;&amp; func3 == 0, &quot;not unary&quot;);
2860           res = (~func1) &amp; 0xFF;
2861         } else {
2862           assert(func3 == 0, &quot;not binary&quot;);
2863           res = func1 ^ func2;
2864         }
2865         break;
2866       case Op_MacroLogicV:
2867         // Ordering of inputs may change during evaluation of sub-tree
2868         // containing MacroLogic node as a child node, thus a re-evaluation
2869         // makes sure that function is evaluated in context of current
2870         // inputs.
2871         res = eval_macro_logic_op(n-&gt;in(4)-&gt;get_int(), func1, func2, func3);
2872         break;
2873 
2874       default: assert(false, &quot;not supported: %s&quot;, n-&gt;Name());
2875     }
2876     assert(res &lt;= 0xFF, &quot;invalid&quot;);
2877     eval_map.put(n, res);
2878   }
2879   return res;
2880 }
2881 
2882 bool Compile::compute_logic_cone(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {
2883   assert(partition.size() == 0, &quot;not empty&quot;);
2884   assert(inputs.size() == 0, &quot;not empty&quot;);
2885   if (is_vector_ternary_bitwise_op(n)) {
2886     return false;
2887   }
2888 
2889   bool is_unary_op = is_vector_unary_bitwise_op(n);
2890   if (is_unary_op) {
2891     assert(collect_unique_inputs(n, partition, inputs) == 1, &quot;not unary&quot;);
2892     return false; // too few inputs
2893   }
2894 
2895   assert(is_vector_binary_bitwise_op(n), &quot;not binary&quot;);
2896   Node* in1 = n-&gt;in(1);
2897   Node* in2 = n-&gt;in(2);
2898 
2899   int in1_unique_inputs_cnt = collect_unique_inputs(in1, partition, inputs);
2900   int in2_unique_inputs_cnt = collect_unique_inputs(in2, partition, inputs);
2901   partition.push(n);
2902 
2903   // Too many inputs?
2904   if (inputs.size() &gt; 3) {
2905     partition.clear();
2906     inputs.clear();
2907     { // Recompute in2 inputs
2908       Unique_Node_List not_used;
2909       in2_unique_inputs_cnt = collect_unique_inputs(in2, not_used, not_used);
2910     }
2911     // Pick the node with minimum number of inputs.
2912     if (in1_unique_inputs_cnt &gt;= 3 &amp;&amp; in2_unique_inputs_cnt &gt;= 3) {
2913       return false; // still too many inputs
2914     }
2915     // Recompute partition &amp; inputs.
2916     Node* child       = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in1 : in2);
2917     collect_unique_inputs(child, partition, inputs);
2918 
2919     Node* other_input = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in2 : in1);
2920     inputs.push(other_input);
2921 
2922     partition.push(n);
2923   }
2924 
2925   return (partition.size() == 2 || partition.size() == 3) &amp;&amp;
2926          (inputs.size()    == 2 || inputs.size()    == 3);
2927 }
2928 
2929 
2930 void Compile::process_logic_cone_root(PhaseIterGVN &amp;igvn, Node *n, VectorSet &amp;visited) {
2931   assert(is_vector_bitwise_op(n), &quot;not a root&quot;);
2932 
2933   visited.set(n-&gt;_idx);
2934 
2935   // 1) Do a DFS walk over the logic cone.
2936   for (uint i = 1; i &lt; n-&gt;req(); i++) {
2937     Node* in = n-&gt;in(i);
2938     if (!visited.test(in-&gt;_idx) &amp;&amp; is_vector_bitwise_op(in)) {
2939       process_logic_cone_root(igvn, in, visited);
2940     }
2941   }
2942 
2943   // 2) Bottom up traversal: Merge node[s] with
2944   // the parent to form macro logic node.
2945   Unique_Node_List partition;
2946   Unique_Node_List inputs;
2947   if (compute_logic_cone(n, partition, inputs)) {
2948     const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();
2949     Node* macro_logic = xform_to_MacroLogicV(igvn, vt, partition, inputs);
2950     igvn.replace_node(n, macro_logic);
2951   }
2952 }
2953 
2954 void Compile::optimize_logic_cones(PhaseIterGVN &amp;igvn) {
2955   ResourceMark rm;
2956   if (Matcher::match_rule_supported(Op_MacroLogicV)) {
2957     Unique_Node_List list;
2958     collect_logic_cone_roots(list);
2959 
2960     while (list.size() &gt; 0) {
2961       Node* n = list.pop();
2962       const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();
2963       bool supported = Matcher::match_rule_supported_vector(Op_MacroLogicV, vt-&gt;length(), vt-&gt;element_basic_type());
2964       if (supported) {
2965         VectorSet visited(comp_arena());
2966         process_logic_cone_root(igvn, n, visited);
2967       }
2968     }
2969   }
2970 }
2971 
2972 //------------------------------Code_Gen---------------------------------------
2973 // Given a graph, generate code for it
2974 void Compile::Code_Gen() {
2975   if (failing()) {
2976     return;
2977   }
2978 
2979   // Perform instruction selection.  You might think we could reclaim Matcher
2980   // memory PDQ, but actually the Matcher is used in generating spill code.
2981   // Internals of the Matcher (including some VectorSets) must remain live
2982   // for awhile - thus I cannot reclaim Matcher memory lest a VectorSet usage
2983   // set a bit in reclaimed memory.
2984 
2985   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2986   // nodes.  Mapping is only valid at the root of each matched subtree.
2987   NOT_PRODUCT( verify_graph_edges(); )
2988 
2989   Matcher matcher;
2990   _matcher = &amp;matcher;
2991   {
2992     TracePhase tp(&quot;matcher&quot;, &amp;timers[_t_matcher]);
2993     matcher.match();
2994     if (failing()) {
2995       return;
2996     }
2997   }
2998 
2999   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
3000   // nodes.  Mapping is only valid at the root of each matched subtree.
3001   NOT_PRODUCT( verify_graph_edges(); )
3002 
3003   // If you have too many nodes, or if matching has failed, bail out
3004   check_node_count(0, &quot;out of nodes matching instructions&quot;);
3005   if (failing()) {
3006     return;
3007   }
3008 
3009   print_method(PHASE_MATCHING, 2);
3010 
3011   // Build a proper-looking CFG
3012   PhaseCFG cfg(node_arena(), root(), matcher);
3013   _cfg = &amp;cfg;
3014   {
3015     TracePhase tp(&quot;scheduler&quot;, &amp;timers[_t_scheduler]);
3016     bool success = cfg.do_global_code_motion();
3017     if (!success) {
3018       return;
3019     }
3020 
3021     print_method(PHASE_GLOBAL_CODE_MOTION, 2);
3022     NOT_PRODUCT( verify_graph_edges(); )
3023     debug_only( cfg.verify(); )
3024   }
3025 
3026   PhaseChaitin regalloc(unique(), cfg, matcher, false);
3027   _regalloc = &amp;regalloc;
3028   {
3029     TracePhase tp(&quot;regalloc&quot;, &amp;timers[_t_registerAllocation]);
3030     // Perform register allocation.  After Chaitin, use-def chains are
3031     // no longer accurate (at spill code) and so must be ignored.
3032     // Node-&gt;LRG-&gt;reg mappings are still accurate.
3033     _regalloc-&gt;Register_Allocate();
3034 
3035     // Bail out if the allocator builds too many nodes
3036     if (failing()) {
3037       return;
3038     }
3039   }
3040 
3041   // Prior to register allocation we kept empty basic blocks in case the
3042   // the allocator needed a place to spill.  After register allocation we
3043   // are not adding any new instructions.  If any basic block is empty, we
3044   // can now safely remove it.
3045   {
3046     TracePhase tp(&quot;blockOrdering&quot;, &amp;timers[_t_blockOrdering]);
3047     cfg.remove_empty_blocks();
3048     if (do_freq_based_layout()) {
3049       PhaseBlockLayout layout(cfg);
3050     } else {
3051       cfg.set_loop_alignment();
3052     }
3053     cfg.fixup_flow();
3054   }
3055 
3056   // Apply peephole optimizations
3057   if( OptoPeephole ) {
3058     TracePhase tp(&quot;peephole&quot;, &amp;timers[_t_peephole]);
3059     PhasePeephole peep( _regalloc, cfg);
3060     peep.do_transform();
3061   }
3062 
3063   // Do late expand if CPU requires this.
3064   if (Matcher::require_postalloc_expand) {
3065     TracePhase tp(&quot;postalloc_expand&quot;, &amp;timers[_t_postalloc_expand]);
3066     cfg.postalloc_expand(_regalloc);
3067   }
3068 
3069   // Convert Nodes to instruction bits in a buffer
3070   {
3071     TracePhase tp(&quot;output&quot;, &amp;timers[_t_output]);
3072     PhaseOutput output;
3073     output.Output();
3074     if (failing())  return;
3075     output.install();
3076   }
3077 
3078   print_method(PHASE_FINAL_CODE);
3079 
3080   // He&#39;s dead, Jim.
3081   _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
3082   _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
3083 }
3084 
3085 //------------------------------Final_Reshape_Counts---------------------------
3086 // This class defines counters to help identify when a method
3087 // may/must be executed using hardware with only 24-bit precision.
3088 struct Final_Reshape_Counts : public StackObj {
3089   int  _call_count;             // count non-inlined &#39;common&#39; calls
3090   int  _float_count;            // count float ops requiring 24-bit precision
3091   int  _double_count;           // count double ops requiring more precision
3092   int  _java_call_count;        // count non-inlined &#39;java&#39; calls
3093   int  _inner_loop_count;       // count loops which need alignment
3094   VectorSet _visited;           // Visitation flags
3095   Node_List _tests;             // Set of IfNodes &amp; PCTableNodes
3096 
3097   Final_Reshape_Counts() :
3098     _call_count(0), _float_count(0), _double_count(0),
3099     _java_call_count(0), _inner_loop_count(0),
3100     _visited( Thread::current()-&gt;resource_area() ) { }
3101 
3102   void inc_call_count  () { _call_count  ++; }
3103   void inc_float_count () { _float_count ++; }
3104   void inc_double_count() { _double_count++; }
3105   void inc_java_call_count() { _java_call_count++; }
3106   void inc_inner_loop_count() { _inner_loop_count++; }
3107 
3108   int  get_call_count  () const { return _call_count  ; }
3109   int  get_float_count () const { return _float_count ; }
3110   int  get_double_count() const { return _double_count; }
3111   int  get_java_call_count() const { return _java_call_count; }
3112   int  get_inner_loop_count() const { return _inner_loop_count; }
3113 };
3114 
3115 #ifdef ASSERT
3116 static bool oop_offset_is_sane(const TypeInstPtr* tp) {
3117   ciInstanceKlass *k = tp-&gt;klass()-&gt;as_instance_klass();
3118   // Make sure the offset goes inside the instance layout.
3119   return k-&gt;contains_field_offset(tp-&gt;offset());
3120   // Note that OffsetBot and OffsetTop are very negative.
3121 }
3122 #endif
3123 
3124 // Eliminate trivially redundant StoreCMs and accumulate their
3125 // precedence edges.
3126 void Compile::eliminate_redundant_card_marks(Node* n) {
3127   assert(n-&gt;Opcode() == Op_StoreCM, &quot;expected StoreCM&quot;);
3128   if (n-&gt;in(MemNode::Address)-&gt;outcnt() &gt; 1) {
3129     // There are multiple users of the same address so it might be
3130     // possible to eliminate some of the StoreCMs
3131     Node* mem = n-&gt;in(MemNode::Memory);
3132     Node* adr = n-&gt;in(MemNode::Address);
3133     Node* val = n-&gt;in(MemNode::ValueIn);
3134     Node* prev = n;
3135     bool done = false;
3136     // Walk the chain of StoreCMs eliminating ones that match.  As
3137     // long as it&#39;s a chain of single users then the optimization is
3138     // safe.  Eliminating partially redundant StoreCMs would require
3139     // cloning copies down the other paths.
3140     while (mem-&gt;Opcode() == Op_StoreCM &amp;&amp; mem-&gt;outcnt() == 1 &amp;&amp; !done) {
3141       if (adr == mem-&gt;in(MemNode::Address) &amp;&amp;
3142           val == mem-&gt;in(MemNode::ValueIn)) {
3143         // redundant StoreCM
3144         if (mem-&gt;req() &gt; MemNode::OopStore) {
3145           // Hasn&#39;t been processed by this code yet.
3146           n-&gt;add_prec(mem-&gt;in(MemNode::OopStore));
3147         } else {
3148           // Already converted to precedence edge
3149           for (uint i = mem-&gt;req(); i &lt; mem-&gt;len(); i++) {
3150             // Accumulate any precedence edges
3151             if (mem-&gt;in(i) != NULL) {
3152               n-&gt;add_prec(mem-&gt;in(i));
3153             }
3154           }
3155           // Everything above this point has been processed.
3156           done = true;
3157         }
3158         // Eliminate the previous StoreCM
3159         prev-&gt;set_req(MemNode::Memory, mem-&gt;in(MemNode::Memory));
3160         assert(mem-&gt;outcnt() == 0, &quot;should be dead&quot;);
3161         mem-&gt;disconnect_inputs(NULL, this);
3162       } else {
3163         prev = mem;
3164       }
3165       mem = prev-&gt;in(MemNode::Memory);
3166     }
3167   }
3168 }
3169 
<a name="43" id="anc43"></a><span class="line-added">3170 </span>
3171 //------------------------------final_graph_reshaping_impl----------------------
3172 // Implement items 1-5 from final_graph_reshaping below.
3173 void Compile::final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &amp;frc) {
3174 
3175   if ( n-&gt;outcnt() == 0 ) return; // dead node
3176   uint nop = n-&gt;Opcode();
3177 
3178   // Check for 2-input instruction with &quot;last use&quot; on right input.
3179   // Swap to left input.  Implements item (2).
3180   if( n-&gt;req() == 3 &amp;&amp;          // two-input instruction
3181       n-&gt;in(1)-&gt;outcnt() &gt; 1 &amp;&amp; // left use is NOT a last use
3182       (!n-&gt;in(1)-&gt;is_Phi() || n-&gt;in(1)-&gt;in(2) != n) &amp;&amp; // it is not data loop
3183       n-&gt;in(2)-&gt;outcnt() == 1 &amp;&amp;// right use IS a last use
3184       !n-&gt;in(2)-&gt;is_Con() ) {   // right use is not a constant
3185     // Check for commutative opcode
3186     switch( nop ) {
3187     case Op_AddI:  case Op_AddF:  case Op_AddD:  case Op_AddL:
3188     case Op_MaxI:  case Op_MinI:
3189     case Op_MulI:  case Op_MulF:  case Op_MulD:  case Op_MulL:
3190     case Op_AndL:  case Op_XorL:  case Op_OrL:
3191     case Op_AndI:  case Op_XorI:  case Op_OrI: {
3192       // Move &quot;last use&quot; input to left by swapping inputs
3193       n-&gt;swap_edges(1, 2);
3194       break;
3195     }
3196     default:
3197       break;
3198     }
3199   }
3200 
3201 #ifdef ASSERT
3202   if( n-&gt;is_Mem() ) {
3203     int alias_idx = get_alias_index(n-&gt;as_Mem()-&gt;adr_type());
3204     assert( n-&gt;in(0) != NULL || alias_idx != Compile::AliasIdxRaw ||
3205             // oop will be recorded in oop map if load crosses safepoint
3206             n-&gt;is_Load() &amp;&amp; (n-&gt;as_Load()-&gt;bottom_type()-&gt;isa_oopptr() ||
3207                              LoadNode::is_immutable_value(n-&gt;in(MemNode::Address))),
3208             &quot;raw memory operations should have control edge&quot;);
3209   }
3210   if (n-&gt;is_MemBar()) {
3211     MemBarNode* mb = n-&gt;as_MemBar();
3212     if (mb-&gt;trailing_store() || mb-&gt;trailing_load_store()) {
3213       assert(mb-&gt;leading_membar()-&gt;trailing_membar() == mb, &quot;bad membar pair&quot;);
3214       Node* mem = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;step_over_gc_barrier(mb-&gt;in(MemBarNode::Precedent));
3215       assert((mb-&gt;trailing_store() &amp;&amp; mem-&gt;is_Store() &amp;&amp; mem-&gt;as_Store()-&gt;is_release()) ||
3216              (mb-&gt;trailing_load_store() &amp;&amp; mem-&gt;is_LoadStore()), &quot;missing mem op&quot;);
3217     } else if (mb-&gt;leading()) {
3218       assert(mb-&gt;trailing_membar()-&gt;leading_membar() == mb, &quot;bad membar pair&quot;);
3219     }
3220   }
3221 #endif
3222   // Count FPU ops and common calls, implements item (3)
3223   bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;final_graph_reshaping(this, n, nop);
3224   if (!gc_handled) {
3225     final_graph_reshaping_main_switch(n, frc, nop);
3226   }
3227 
3228   // Collect CFG split points
3229   if (n-&gt;is_MultiBranch() &amp;&amp; !n-&gt;is_RangeCheck()) {
3230     frc._tests.push(n);
3231   }
3232 }
3233 
3234 void Compile::final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts&amp; frc, uint nop) {
3235   switch( nop ) {
3236   // Count all float operations that may use FPU
3237   case Op_AddF:
3238   case Op_SubF:
3239   case Op_MulF:
3240   case Op_DivF:
3241   case Op_NegF:
3242   case Op_ModF:
3243   case Op_ConvI2F:
3244   case Op_ConF:
3245   case Op_CmpF:
3246   case Op_CmpF3:
3247   // case Op_ConvL2F: // longs are split into 32-bit halves
3248     frc.inc_float_count();
3249     break;
3250 
3251   case Op_ConvF2D:
3252   case Op_ConvD2F:
3253     frc.inc_float_count();
3254     frc.inc_double_count();
3255     break;
3256 
3257   // Count all double operations that may use FPU
3258   case Op_AddD:
3259   case Op_SubD:
3260   case Op_MulD:
3261   case Op_DivD:
3262   case Op_NegD:
3263   case Op_ModD:
3264   case Op_ConvI2D:
3265   case Op_ConvD2I:
3266   // case Op_ConvL2D: // handled by leaf call
3267   // case Op_ConvD2L: // handled by leaf call
3268   case Op_ConD:
3269   case Op_CmpD:
3270   case Op_CmpD3:
3271     frc.inc_double_count();
3272     break;
3273   case Op_Opaque1:              // Remove Opaque Nodes before matching
3274   case Op_Opaque2:              // Remove Opaque Nodes before matching
3275   case Op_Opaque3:
3276     n-&gt;subsume_by(n-&gt;in(1), this);
3277     break;
3278   case Op_CallStaticJava:
3279   case Op_CallJava:
3280   case Op_CallDynamicJava:
3281     frc.inc_java_call_count(); // Count java call site;
3282   case Op_CallRuntime:
3283   case Op_CallLeaf:
3284   case Op_CallLeafNoFP: {
3285     assert (n-&gt;is_Call(), &quot;&quot;);
3286     CallNode *call = n-&gt;as_Call();
3287     // Count call sites where the FP mode bit would have to be flipped.
3288     // Do not count uncommon runtime calls:
3289     // uncommon_trap, _complete_monitor_locking, _complete_monitor_unlocking,
3290     // _new_Java, _new_typeArray, _new_objArray, _rethrow_Java, ...
3291     if (!call-&gt;is_CallStaticJava() || !call-&gt;as_CallStaticJava()-&gt;_name) {
3292       frc.inc_call_count();   // Count the call site
3293     } else {                  // See if uncommon argument is shared
3294       Node *n = call-&gt;in(TypeFunc::Parms);
3295       int nop = n-&gt;Opcode();
3296       // Clone shared simple arguments to uncommon calls, item (1).
3297       if (n-&gt;outcnt() &gt; 1 &amp;&amp;
3298           !n-&gt;is_Proj() &amp;&amp;
3299           nop != Op_CreateEx &amp;&amp;
3300           nop != Op_CheckCastPP &amp;&amp;
3301           nop != Op_DecodeN &amp;&amp;
3302           nop != Op_DecodeNKlass &amp;&amp;
3303           !n-&gt;is_Mem() &amp;&amp;
3304           !n-&gt;is_Phi()) {
3305         Node *x = n-&gt;clone();
3306         call-&gt;set_req(TypeFunc::Parms, x);
3307       }
3308     }
3309     break;
3310   }
3311 
3312   case Op_StoreD:
3313   case Op_LoadD:
3314   case Op_LoadD_unaligned:
3315     frc.inc_double_count();
3316     goto handle_mem;
3317   case Op_StoreF:
3318   case Op_LoadF:
3319     frc.inc_float_count();
3320     goto handle_mem;
3321 
3322   case Op_StoreCM:
3323     {
3324       // Convert OopStore dependence into precedence edge
3325       Node* prec = n-&gt;in(MemNode::OopStore);
3326       n-&gt;del_req(MemNode::OopStore);
3327       n-&gt;add_prec(prec);
3328       eliminate_redundant_card_marks(n);
3329     }
3330 
3331     // fall through
3332 
3333   case Op_StoreB:
3334   case Op_StoreC:
3335   case Op_StorePConditional:
3336   case Op_StoreI:
3337   case Op_StoreL:
3338   case Op_StoreIConditional:
3339   case Op_StoreLConditional:
3340   case Op_CompareAndSwapB:
3341   case Op_CompareAndSwapS:
3342   case Op_CompareAndSwapI:
3343   case Op_CompareAndSwapL:
3344   case Op_CompareAndSwapP:
3345   case Op_CompareAndSwapN:
3346   case Op_WeakCompareAndSwapB:
3347   case Op_WeakCompareAndSwapS:
3348   case Op_WeakCompareAndSwapI:
3349   case Op_WeakCompareAndSwapL:
3350   case Op_WeakCompareAndSwapP:
3351   case Op_WeakCompareAndSwapN:
3352   case Op_CompareAndExchangeB:
3353   case Op_CompareAndExchangeS:
3354   case Op_CompareAndExchangeI:
3355   case Op_CompareAndExchangeL:
3356   case Op_CompareAndExchangeP:
3357   case Op_CompareAndExchangeN:
3358   case Op_GetAndAddS:
3359   case Op_GetAndAddB:
3360   case Op_GetAndAddI:
3361   case Op_GetAndAddL:
3362   case Op_GetAndSetS:
3363   case Op_GetAndSetB:
3364   case Op_GetAndSetI:
3365   case Op_GetAndSetL:
3366   case Op_GetAndSetP:
3367   case Op_GetAndSetN:
3368   case Op_StoreP:
3369   case Op_StoreN:
3370   case Op_StoreNKlass:
3371   case Op_LoadB:
3372   case Op_LoadUB:
3373   case Op_LoadUS:
3374   case Op_LoadI:
3375   case Op_LoadKlass:
3376   case Op_LoadNKlass:
3377   case Op_LoadL:
3378   case Op_LoadL_unaligned:
3379   case Op_LoadPLocked:
3380   case Op_LoadP:
3381   case Op_LoadN:
3382   case Op_LoadRange:
3383   case Op_LoadS: {
3384   handle_mem:
3385 #ifdef ASSERT
3386     if( VerifyOptoOopOffsets ) {
3387       MemNode* mem  = n-&gt;as_Mem();
3388       // Check to see if address types have grounded out somehow.
3389       const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
3390       assert( !tp || oop_offset_is_sane(tp), &quot;&quot; );
3391     }
3392 #endif
3393     break;
3394   }
3395 
3396   case Op_AddP: {               // Assert sane base pointers
3397     Node *addp = n-&gt;in(AddPNode::Address);
3398     assert( !addp-&gt;is_AddP() ||
3399             addp-&gt;in(AddPNode::Base)-&gt;is_top() || // Top OK for allocation
3400             addp-&gt;in(AddPNode::Base) == n-&gt;in(AddPNode::Base),
3401             &quot;Base pointers must match (addp %u)&quot;, addp-&gt;_idx );
3402 #ifdef _LP64
3403     if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp;
3404         addp-&gt;Opcode() == Op_ConP &amp;&amp;
3405         addp == n-&gt;in(AddPNode::Base) &amp;&amp;
3406         n-&gt;in(AddPNode::Offset)-&gt;is_Con()) {
3407       // If the transformation of ConP to ConN+DecodeN is beneficial depends
3408       // on the platform and on the compressed oops mode.
3409       // Use addressing with narrow klass to load with offset on x86.
3410       // Some platforms can use the constant pool to load ConP.
3411       // Do this transformation here since IGVN will convert ConN back to ConP.
3412       const Type* t = addp-&gt;bottom_type();
3413       bool is_oop   = t-&gt;isa_oopptr() != NULL;
3414       bool is_klass = t-&gt;isa_klassptr() != NULL;
3415 
3416       if ((is_oop   &amp;&amp; Matcher::const_oop_prefer_decode()  ) ||
3417           (is_klass &amp;&amp; Matcher::const_klass_prefer_decode())) {
3418         Node* nn = NULL;
3419 
3420         int op = is_oop ? Op_ConN : Op_ConNKlass;
3421 
3422         // Look for existing ConN node of the same exact type.
3423         Node* r  = root();
3424         uint cnt = r-&gt;outcnt();
3425         for (uint i = 0; i &lt; cnt; i++) {
3426           Node* m = r-&gt;raw_out(i);
3427           if (m!= NULL &amp;&amp; m-&gt;Opcode() == op &amp;&amp;
3428               m-&gt;bottom_type()-&gt;make_ptr() == t) {
3429             nn = m;
3430             break;
3431           }
3432         }
3433         if (nn != NULL) {
3434           // Decode a narrow oop to match address
3435           // [R12 + narrow_oop_reg&lt;&lt;3 + offset]
3436           if (is_oop) {
3437             nn = new DecodeNNode(nn, t);
3438           } else {
3439             nn = new DecodeNKlassNode(nn, t);
3440           }
3441           // Check for succeeding AddP which uses the same Base.
3442           // Otherwise we will run into the assertion above when visiting that guy.
3443           for (uint i = 0; i &lt; n-&gt;outcnt(); ++i) {
3444             Node *out_i = n-&gt;raw_out(i);
3445             if (out_i &amp;&amp; out_i-&gt;is_AddP() &amp;&amp; out_i-&gt;in(AddPNode::Base) == addp) {
3446               out_i-&gt;set_req(AddPNode::Base, nn);
3447 #ifdef ASSERT
3448               for (uint j = 0; j &lt; out_i-&gt;outcnt(); ++j) {
3449                 Node *out_j = out_i-&gt;raw_out(j);
3450                 assert(out_j == NULL || !out_j-&gt;is_AddP() || out_j-&gt;in(AddPNode::Base) != addp,
3451                        &quot;more than 2 AddP nodes in a chain (out_j %u)&quot;, out_j-&gt;_idx);
3452               }
3453 #endif
3454             }
3455           }
3456           n-&gt;set_req(AddPNode::Base, nn);
3457           n-&gt;set_req(AddPNode::Address, nn);
3458           if (addp-&gt;outcnt() == 0) {
3459             addp-&gt;disconnect_inputs(NULL, this);
3460           }
3461         }
3462       }
3463     }
3464 #endif
3465     // platform dependent reshaping of the address expression
3466     reshape_address(n-&gt;as_AddP());
3467     break;
3468   }
3469 
3470   case Op_CastPP: {
3471     // Remove CastPP nodes to gain more freedom during scheduling but
3472     // keep the dependency they encode as control or precedence edges
3473     // (if control is set already) on memory operations. Some CastPP
3474     // nodes don&#39;t have a control (don&#39;t carry a dependency): skip
3475     // those.
3476     if (n-&gt;in(0) != NULL) {
3477       ResourceMark rm;
3478       Unique_Node_List wq;
3479       wq.push(n);
3480       for (uint next = 0; next &lt; wq.size(); ++next) {
3481         Node *m = wq.at(next);
3482         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
3483           Node* use = m-&gt;fast_out(i);
3484           if (use-&gt;is_Mem() || use-&gt;is_EncodeNarrowPtr()) {
3485             use-&gt;ensure_control_or_add_prec(n-&gt;in(0));
3486           } else {
3487             switch(use-&gt;Opcode()) {
3488             case Op_AddP:
3489             case Op_DecodeN:
3490             case Op_DecodeNKlass:
3491             case Op_CheckCastPP:
3492             case Op_CastPP:
3493               wq.push(use);
3494               break;
3495             }
3496           }
3497         }
3498       }
3499     }
3500     const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);
3501     if (is_LP64 &amp;&amp; n-&gt;in(1)-&gt;is_DecodeN() &amp;&amp; Matcher::gen_narrow_oop_implicit_null_checks()) {
3502       Node* in1 = n-&gt;in(1);
3503       const Type* t = n-&gt;bottom_type();
3504       Node* new_in1 = in1-&gt;clone();
3505       new_in1-&gt;as_DecodeN()-&gt;set_type(t);
3506 
3507       if (!Matcher::narrow_oop_use_complex_address()) {
3508         //
3509         // x86, ARM and friends can handle 2 adds in addressing mode
3510         // and Matcher can fold a DecodeN node into address by using
3511         // a narrow oop directly and do implicit NULL check in address:
3512         //
3513         // [R12 + narrow_oop_reg&lt;&lt;3 + offset]
3514         // NullCheck narrow_oop_reg
3515         //
3516         // On other platforms (Sparc) we have to keep new DecodeN node and
3517         // use it to do implicit NULL check in address:
3518         //
3519         // decode_not_null narrow_oop_reg, base_reg
3520         // [base_reg + offset]
3521         // NullCheck base_reg
3522         //
3523         // Pin the new DecodeN node to non-null path on these platform (Sparc)
3524         // to keep the information to which NULL check the new DecodeN node
3525         // corresponds to use it as value in implicit_null_check().
3526         //
3527         new_in1-&gt;set_req(0, n-&gt;in(0));
3528       }
3529 
3530       n-&gt;subsume_by(new_in1, this);
3531       if (in1-&gt;outcnt() == 0) {
3532         in1-&gt;disconnect_inputs(NULL, this);
3533       }
3534     } else {
3535       n-&gt;subsume_by(n-&gt;in(1), this);
3536       if (n-&gt;outcnt() == 0) {
3537         n-&gt;disconnect_inputs(NULL, this);
3538       }
3539     }
3540     break;
3541   }
3542 #ifdef _LP64
3543   case Op_CmpP:
3544     // Do this transformation here to preserve CmpPNode::sub() and
3545     // other TypePtr related Ideal optimizations (for example, ptr nullness).
3546     if (n-&gt;in(1)-&gt;is_DecodeNarrowPtr() || n-&gt;in(2)-&gt;is_DecodeNarrowPtr()) {
3547       Node* in1 = n-&gt;in(1);
3548       Node* in2 = n-&gt;in(2);
3549       if (!in1-&gt;is_DecodeNarrowPtr()) {
3550         in2 = in1;
3551         in1 = n-&gt;in(2);
3552       }
3553       assert(in1-&gt;is_DecodeNarrowPtr(), &quot;sanity&quot;);
3554 
3555       Node* new_in2 = NULL;
3556       if (in2-&gt;is_DecodeNarrowPtr()) {
3557         assert(in2-&gt;Opcode() == in1-&gt;Opcode(), &quot;must be same node type&quot;);
3558         new_in2 = in2-&gt;in(1);
3559       } else if (in2-&gt;Opcode() == Op_ConP) {
3560         const Type* t = in2-&gt;bottom_type();
3561         if (t == TypePtr::NULL_PTR) {
3562           assert(in1-&gt;is_DecodeN(), &quot;compare klass to null?&quot;);
3563           // Don&#39;t convert CmpP null check into CmpN if compressed
3564           // oops implicit null check is not generated.
3565           // This will allow to generate normal oop implicit null check.
3566           if (Matcher::gen_narrow_oop_implicit_null_checks())
3567             new_in2 = ConNode::make(TypeNarrowOop::NULL_PTR);
3568           //
3569           // This transformation together with CastPP transformation above
3570           // will generated code for implicit NULL checks for compressed oops.
3571           //
3572           // The original code after Optimize()
3573           //
3574           //    LoadN memory, narrow_oop_reg
3575           //    decode narrow_oop_reg, base_reg
3576           //    CmpP base_reg, NULL
3577           //    CastPP base_reg // NotNull
3578           //    Load [base_reg + offset], val_reg
3579           //
3580           // after these transformations will be
3581           //
3582           //    LoadN memory, narrow_oop_reg
3583           //    CmpN narrow_oop_reg, NULL
3584           //    decode_not_null narrow_oop_reg, base_reg
3585           //    Load [base_reg + offset], val_reg
3586           //
3587           // and the uncommon path (== NULL) will use narrow_oop_reg directly
3588           // since narrow oops can be used in debug info now (see the code in
3589           // final_graph_reshaping_walk()).
3590           //
3591           // At the end the code will be matched to
3592           // on x86:
3593           //
3594           //    Load_narrow_oop memory, narrow_oop_reg
3595           //    Load [R12 + narrow_oop_reg&lt;&lt;3 + offset], val_reg
3596           //    NullCheck narrow_oop_reg
3597           //
3598           // and on sparc:
3599           //
3600           //    Load_narrow_oop memory, narrow_oop_reg
3601           //    decode_not_null narrow_oop_reg, base_reg
3602           //    Load [base_reg + offset], val_reg
3603           //    NullCheck base_reg
3604           //
3605         } else if (t-&gt;isa_oopptr()) {
3606           new_in2 = ConNode::make(t-&gt;make_narrowoop());
3607         } else if (t-&gt;isa_klassptr()) {
3608           new_in2 = ConNode::make(t-&gt;make_narrowklass());
3609         }
3610       }
3611       if (new_in2 != NULL) {
3612         Node* cmpN = new CmpNNode(in1-&gt;in(1), new_in2);
3613         n-&gt;subsume_by(cmpN, this);
3614         if (in1-&gt;outcnt() == 0) {
3615           in1-&gt;disconnect_inputs(NULL, this);
3616         }
3617         if (in2-&gt;outcnt() == 0) {
3618           in2-&gt;disconnect_inputs(NULL, this);
3619         }
3620       }
3621     }
3622     break;
3623 
3624   case Op_DecodeN:
3625   case Op_DecodeNKlass:
3626     assert(!n-&gt;in(1)-&gt;is_EncodeNarrowPtr(), &quot;should be optimized out&quot;);
3627     // DecodeN could be pinned when it can&#39;t be fold into
3628     // an address expression, see the code for Op_CastPP above.
3629     assert(n-&gt;in(0) == NULL || (UseCompressedOops &amp;&amp; !Matcher::narrow_oop_use_complex_address()), &quot;no control&quot;);
3630     break;
3631 
3632   case Op_EncodeP:
3633   case Op_EncodePKlass: {
3634     Node* in1 = n-&gt;in(1);
3635     if (in1-&gt;is_DecodeNarrowPtr()) {
3636       n-&gt;subsume_by(in1-&gt;in(1), this);
3637     } else if (in1-&gt;Opcode() == Op_ConP) {
3638       const Type* t = in1-&gt;bottom_type();
3639       if (t == TypePtr::NULL_PTR) {
3640         assert(t-&gt;isa_oopptr(), &quot;null klass?&quot;);
3641         n-&gt;subsume_by(ConNode::make(TypeNarrowOop::NULL_PTR), this);
3642       } else if (t-&gt;isa_oopptr()) {
3643         n-&gt;subsume_by(ConNode::make(t-&gt;make_narrowoop()), this);
3644       } else if (t-&gt;isa_klassptr()) {
3645         n-&gt;subsume_by(ConNode::make(t-&gt;make_narrowklass()), this);
3646       }
3647     }
3648     if (in1-&gt;outcnt() == 0) {
3649       in1-&gt;disconnect_inputs(NULL, this);
3650     }
3651     break;
3652   }
3653 
3654   case Op_Proj: {
3655     if (OptimizeStringConcat) {
3656       ProjNode* p = n-&gt;as_Proj();
3657       if (p-&gt;_is_io_use) {
3658         // Separate projections were used for the exception path which
3659         // are normally removed by a late inline.  If it wasn&#39;t inlined
3660         // then they will hang around and should just be replaced with
3661         // the original one.
3662         Node* proj = NULL;
3663         // Replace with just one
3664         for (SimpleDUIterator i(p-&gt;in(0)); i.has_next(); i.next()) {
3665           Node *use = i.get();
3666           if (use-&gt;is_Proj() &amp;&amp; p != use &amp;&amp; use-&gt;as_Proj()-&gt;_con == p-&gt;_con) {
3667             proj = use;
3668             break;
3669           }
3670         }
3671         assert(proj != NULL || p-&gt;_con == TypeFunc::I_O, &quot;io may be dropped at an infinite loop&quot;);
3672         if (proj != NULL) {
3673           p-&gt;subsume_by(proj, this);
3674         }
3675       }
3676     }
3677     break;
3678   }
3679 
3680   case Op_Phi:
3681     if (n-&gt;as_Phi()-&gt;bottom_type()-&gt;isa_narrowoop() || n-&gt;as_Phi()-&gt;bottom_type()-&gt;isa_narrowklass()) {
3682       // The EncodeP optimization may create Phi with the same edges
3683       // for all paths. It is not handled well by Register Allocator.
3684       Node* unique_in = n-&gt;in(1);
3685       assert(unique_in != NULL, &quot;&quot;);
3686       uint cnt = n-&gt;req();
3687       for (uint i = 2; i &lt; cnt; i++) {
3688         Node* m = n-&gt;in(i);
3689         assert(m != NULL, &quot;&quot;);
3690         if (unique_in != m)
3691           unique_in = NULL;
3692       }
3693       if (unique_in != NULL) {
3694         n-&gt;subsume_by(unique_in, this);
3695       }
3696     }
3697     break;
3698 
3699 #endif
3700 
3701 #ifdef ASSERT
3702   case Op_CastII:
3703     // Verify that all range check dependent CastII nodes were removed.
3704     if (n-&gt;isa_CastII()-&gt;has_range_check()) {
3705       n-&gt;dump(3);
3706       assert(false, &quot;Range check dependent CastII node was not removed&quot;);
3707     }
3708     break;
3709 #endif
3710 
3711   case Op_ModI:
3712     if (UseDivMod) {
3713       // Check if a%b and a/b both exist
3714       Node* d = n-&gt;find_similar(Op_DivI);
3715       if (d) {
3716         // Replace them with a fused divmod if supported
3717         if (Matcher::has_match_rule(Op_DivModI)) {
3718           DivModINode* divmod = DivModINode::make(n);
3719           d-&gt;subsume_by(divmod-&gt;div_proj(), this);
3720           n-&gt;subsume_by(divmod-&gt;mod_proj(), this);
3721         } else {
3722           // replace a%b with a-((a/b)*b)
3723           Node* mult = new MulINode(d, d-&gt;in(2));
3724           Node* sub  = new SubINode(d-&gt;in(1), mult);
3725           n-&gt;subsume_by(sub, this);
3726         }
3727       }
3728     }
3729     break;
3730 
3731   case Op_ModL:
3732     if (UseDivMod) {
3733       // Check if a%b and a/b both exist
3734       Node* d = n-&gt;find_similar(Op_DivL);
3735       if (d) {
3736         // Replace them with a fused divmod if supported
3737         if (Matcher::has_match_rule(Op_DivModL)) {
3738           DivModLNode* divmod = DivModLNode::make(n);
3739           d-&gt;subsume_by(divmod-&gt;div_proj(), this);
3740           n-&gt;subsume_by(divmod-&gt;mod_proj(), this);
3741         } else {
3742           // replace a%b with a-((a/b)*b)
3743           Node* mult = new MulLNode(d, d-&gt;in(2));
3744           Node* sub  = new SubLNode(d-&gt;in(1), mult);
3745           n-&gt;subsume_by(sub, this);
3746         }
3747       }
3748     }
3749     break;
3750 
3751   case Op_LoadVector:
3752   case Op_StoreVector:
3753     break;
3754 
3755   case Op_AddReductionVI:
3756   case Op_AddReductionVL:
3757   case Op_AddReductionVF:
3758   case Op_AddReductionVD:
3759   case Op_MulReductionVI:
3760   case Op_MulReductionVL:
3761   case Op_MulReductionVF:
3762   case Op_MulReductionVD:
3763   case Op_MinReductionV:
3764   case Op_MaxReductionV:
3765   case Op_AndReductionV:
3766   case Op_OrReductionV:
3767   case Op_XorReductionV:
3768     break;
3769 
3770   case Op_PackB:
3771   case Op_PackS:
3772   case Op_PackI:
3773   case Op_PackF:
3774   case Op_PackL:
3775   case Op_PackD:
3776     if (n-&gt;req()-1 &gt; 2) {
3777       // Replace many operand PackNodes with a binary tree for matching
3778       PackNode* p = (PackNode*) n;
3779       Node* btp = p-&gt;binary_tree_pack(1, n-&gt;req());
3780       n-&gt;subsume_by(btp, this);
3781     }
3782     break;
3783   case Op_Loop:
3784   case Op_CountedLoop:
3785   case Op_OuterStripMinedLoop:
3786     if (n-&gt;as_Loop()-&gt;is_inner_loop()) {
3787       frc.inc_inner_loop_count();
3788     }
3789     n-&gt;as_Loop()-&gt;verify_strip_mined(0);
3790     break;
3791   case Op_LShiftI:
3792   case Op_RShiftI:
3793   case Op_URShiftI:
3794   case Op_LShiftL:
3795   case Op_RShiftL:
3796   case Op_URShiftL:
3797     if (Matcher::need_masked_shift_count) {
3798       // The cpu&#39;s shift instructions don&#39;t restrict the count to the
3799       // lower 5/6 bits. We need to do the masking ourselves.
3800       Node* in2 = n-&gt;in(2);
3801       juint mask = (n-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
3802       const TypeInt* t = in2-&gt;find_int_type();
3803       if (t != NULL &amp;&amp; t-&gt;is_con()) {
3804         juint shift = t-&gt;get_con();
3805         if (shift &gt; mask) { // Unsigned cmp
3806           n-&gt;set_req(2, ConNode::make(TypeInt::make(shift &amp; mask)));
3807         }
3808       } else {
3809         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
3810           Node* shift = new AndINode(in2, ConNode::make(TypeInt::make(mask)));
3811           n-&gt;set_req(2, shift);
3812         }
3813       }
3814       if (in2-&gt;outcnt() == 0) { // Remove dead node
3815         in2-&gt;disconnect_inputs(NULL, this);
3816       }
3817     }
3818     break;
3819   case Op_MemBarStoreStore:
3820   case Op_MemBarRelease:
3821     // Break the link with AllocateNode: it is no longer useful and
3822     // confuses register allocation.
3823     if (n-&gt;req() &gt; MemBarNode::Precedent) {
3824       n-&gt;set_req(MemBarNode::Precedent, top());
3825     }
3826     break;
3827   case Op_MemBarAcquire: {
3828     if (n-&gt;as_MemBar()-&gt;trailing_load() &amp;&amp; n-&gt;req() &gt; MemBarNode::Precedent) {
3829       // At parse time, the trailing MemBarAcquire for a volatile load
3830       // is created with an edge to the load. After optimizations,
3831       // that input may be a chain of Phis. If those phis have no
3832       // other use, then the MemBarAcquire keeps them alive and
3833       // register allocation can be confused.
3834       ResourceMark rm;
3835       Unique_Node_List wq;
3836       wq.push(n-&gt;in(MemBarNode::Precedent));
3837       n-&gt;set_req(MemBarNode::Precedent, top());
3838       while (wq.size() &gt; 0) {
3839         Node* m = wq.pop();
3840         if (m-&gt;outcnt() == 0) {
3841           for (uint j = 0; j &lt; m-&gt;req(); j++) {
3842             Node* in = m-&gt;in(j);
3843             if (in != NULL) {
3844               wq.push(in);
3845             }
3846           }
3847           m-&gt;disconnect_inputs(NULL, this);
3848         }
3849       }
3850     }
3851     break;
3852   }
3853   case Op_RangeCheck: {
3854     RangeCheckNode* rc = n-&gt;as_RangeCheck();
3855     Node* iff = new IfNode(rc-&gt;in(0), rc-&gt;in(1), rc-&gt;_prob, rc-&gt;_fcnt);
3856     n-&gt;subsume_by(iff, this);
3857     frc._tests.push(iff);
3858     break;
3859   }
3860   case Op_ConvI2L: {
3861     if (!Matcher::convi2l_type_required) {
3862       // Code generation on some platforms doesn&#39;t need accurate
3863       // ConvI2L types. Widening the type can help remove redundant
3864       // address computations.
3865       n-&gt;as_Type()-&gt;set_type(TypeLong::INT);
3866       ResourceMark rm;
3867       Unique_Node_List wq;
3868       wq.push(n);
3869       for (uint next = 0; next &lt; wq.size(); next++) {
3870         Node *m = wq.at(next);
3871 
3872         for(;;) {
3873           // Loop over all nodes with identical inputs edges as m
3874           Node* k = m-&gt;find_similar(m-&gt;Opcode());
3875           if (k == NULL) {
3876             break;
3877           }
3878           // Push their uses so we get a chance to remove node made
3879           // redundant
3880           for (DUIterator_Fast imax, i = k-&gt;fast_outs(imax); i &lt; imax; i++) {
3881             Node* u = k-&gt;fast_out(i);
3882             if (u-&gt;Opcode() == Op_LShiftL ||
3883                 u-&gt;Opcode() == Op_AddL ||
3884                 u-&gt;Opcode() == Op_SubL ||
3885                 u-&gt;Opcode() == Op_AddP) {
3886               wq.push(u);
3887             }
3888           }
3889           // Replace all nodes with identical edges as m with m
3890           k-&gt;subsume_by(m, this);
3891         }
3892       }
3893     }
3894     break;
3895   }
3896   case Op_CmpUL: {
3897     if (!Matcher::has_match_rule(Op_CmpUL)) {
3898       // No support for unsigned long comparisons
3899       ConINode* sign_pos = new ConINode(TypeInt::make(BitsPerLong - 1));
3900       Node* sign_bit_mask = new RShiftLNode(n-&gt;in(1), sign_pos);
3901       Node* orl = new OrLNode(n-&gt;in(1), sign_bit_mask);
3902       ConLNode* remove_sign_mask = new ConLNode(TypeLong::make(max_jlong));
3903       Node* andl = new AndLNode(orl, remove_sign_mask);
3904       Node* cmp = new CmpLNode(andl, n-&gt;in(2));
3905       n-&gt;subsume_by(cmp, this);
3906     }
3907     break;
3908   }
<a name="44" id="anc44"></a><span class="line-added">3909 #ifdef ASSERT</span>
<span class="line-added">3910   case Op_ValueTypePtr:</span>
<span class="line-added">3911   case Op_ValueType: {</span>
<span class="line-added">3912     n-&gt;dump(-1);</span>
<span class="line-added">3913     assert(false, &quot;value type node was not removed&quot;);</span>
<span class="line-added">3914     break;</span>
<span class="line-added">3915   }</span>
<span class="line-added">3916 #endif</span>
3917   default:
3918     assert(!n-&gt;is_Call(), &quot;&quot;);
3919     assert(!n-&gt;is_Mem(), &quot;&quot;);
3920     assert(nop != Op_ProfileBoolean, &quot;should be eliminated during IGVN&quot;);
3921     break;
3922   }
3923 }
3924 
3925 //------------------------------final_graph_reshaping_walk---------------------
3926 // Replacing Opaque nodes with their input in final_graph_reshaping_impl(),
3927 // requires that the walk visits a node&#39;s inputs before visiting the node.
3928 void Compile::final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc ) {
3929   ResourceArea *area = Thread::current()-&gt;resource_area();
3930   Unique_Node_List sfpt(area);
3931 
3932   frc._visited.set(root-&gt;_idx); // first, mark node as visited
3933   uint cnt = root-&gt;req();
3934   Node *n = root;
3935   uint  i = 0;
3936   while (true) {
3937     if (i &lt; cnt) {
3938       // Place all non-visited non-null inputs onto stack
3939       Node* m = n-&gt;in(i);
3940       ++i;
3941       if (m != NULL &amp;&amp; !frc._visited.test_set(m-&gt;_idx)) {
3942         if (m-&gt;is_SafePoint() &amp;&amp; m-&gt;as_SafePoint()-&gt;jvms() != NULL) {
3943           // compute worst case interpreter size in case of a deoptimization
3944           update_interpreter_frame_size(m-&gt;as_SafePoint()-&gt;jvms()-&gt;interpreter_frame_size());
3945 
3946           sfpt.push(m);
3947         }
3948         cnt = m-&gt;req();
3949         nstack.push(n, i); // put on stack parent and next input&#39;s index
3950         n = m;
3951         i = 0;
3952       }
3953     } else {
3954       // Now do post-visit work
3955       final_graph_reshaping_impl( n, frc );
3956       if (nstack.is_empty())
3957         break;             // finished
3958       n = nstack.node();   // Get node from stack
3959       cnt = n-&gt;req();
3960       i = nstack.index();
3961       nstack.pop();        // Shift to the next node on stack
3962     }
3963   }
3964 
3965   // Skip next transformation if compressed oops are not used.
3966   if ((UseCompressedOops &amp;&amp; !Matcher::gen_narrow_oop_implicit_null_checks()) ||
3967       (!UseCompressedOops &amp;&amp; !UseCompressedClassPointers))
3968     return;
3969 
3970   // Go over safepoints nodes to skip DecodeN/DecodeNKlass nodes for debug edges.
3971   // It could be done for an uncommon traps or any safepoints/calls
3972   // if the DecodeN/DecodeNKlass node is referenced only in a debug info.
3973   while (sfpt.size() &gt; 0) {
3974     n = sfpt.pop();
3975     JVMState *jvms = n-&gt;as_SafePoint()-&gt;jvms();
3976     assert(jvms != NULL, &quot;sanity&quot;);
3977     int start = jvms-&gt;debug_start();
3978     int end   = n-&gt;req();
3979     bool is_uncommon = (n-&gt;is_CallStaticJava() &amp;&amp;
3980                         n-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0);
3981     for (int j = start; j &lt; end; j++) {
3982       Node* in = n-&gt;in(j);
3983       if (in-&gt;is_DecodeNarrowPtr()) {
3984         bool safe_to_skip = true;
3985         if (!is_uncommon ) {
3986           // Is it safe to skip?
3987           for (uint i = 0; i &lt; in-&gt;outcnt(); i++) {
3988             Node* u = in-&gt;raw_out(i);
3989             if (!u-&gt;is_SafePoint() ||
3990                 (u-&gt;is_Call() &amp;&amp; u-&gt;as_Call()-&gt;has_non_debug_use(n))) {
3991               safe_to_skip = false;
3992             }
3993           }
3994         }
3995         if (safe_to_skip) {
3996           n-&gt;set_req(j, in-&gt;in(1));
3997         }
3998         if (in-&gt;outcnt() == 0) {
3999           in-&gt;disconnect_inputs(NULL, this);
4000         }
4001       }
4002     }
4003   }
4004 }
4005 
4006 //------------------------------final_graph_reshaping--------------------------
4007 // Final Graph Reshaping.
4008 //
4009 // (1) Clone simple inputs to uncommon calls, so they can be scheduled late
4010 //     and not commoned up and forced early.  Must come after regular
4011 //     optimizations to avoid GVN undoing the cloning.  Clone constant
4012 //     inputs to Loop Phis; these will be split by the allocator anyways.
4013 //     Remove Opaque nodes.
4014 // (2) Move last-uses by commutative operations to the left input to encourage
4015 //     Intel update-in-place two-address operations and better register usage
4016 //     on RISCs.  Must come after regular optimizations to avoid GVN Ideal
4017 //     calls canonicalizing them back.
4018 // (3) Count the number of double-precision FP ops, single-precision FP ops
4019 //     and call sites.  On Intel, we can get correct rounding either by
4020 //     forcing singles to memory (requires extra stores and loads after each
4021 //     FP bytecode) or we can set a rounding mode bit (requires setting and
4022 //     clearing the mode bit around call sites).  The mode bit is only used
4023 //     if the relative frequency of single FP ops to calls is low enough.
4024 //     This is a key transform for SPEC mpeg_audio.
4025 // (4) Detect infinite loops; blobs of code reachable from above but not
4026 //     below.  Several of the Code_Gen algorithms fail on such code shapes,
4027 //     so we simply bail out.  Happens a lot in ZKM.jar, but also happens
4028 //     from time to time in other codes (such as -Xcomp finalizer loops, etc).
4029 //     Detection is by looking for IfNodes where only 1 projection is
4030 //     reachable from below or CatchNodes missing some targets.
4031 // (5) Assert for insane oop offsets in debug mode.
4032 
4033 bool Compile::final_graph_reshaping() {
4034   // an infinite loop may have been eliminated by the optimizer,
4035   // in which case the graph will be empty.
4036   if (root()-&gt;req() == 1) {
4037     record_method_not_compilable(&quot;trivial infinite loop&quot;);
4038     return true;
4039   }
4040 
4041   // Expensive nodes have their control input set to prevent the GVN
4042   // from freely commoning them. There&#39;s no GVN beyond this point so
4043   // no need to keep the control input. We want the expensive nodes to
4044   // be freely moved to the least frequent code path by gcm.
4045   assert(OptimizeExpensiveOps || expensive_count() == 0, &quot;optimization off but list non empty?&quot;);
4046   for (int i = 0; i &lt; expensive_count(); i++) {
4047     _expensive_nodes-&gt;at(i)-&gt;set_req(0, NULL);
4048   }
4049 
4050   Final_Reshape_Counts frc;
4051 
4052   // Visit everybody reachable!
4053   // Allocate stack of size C-&gt;live_nodes()/2 to avoid frequent realloc
4054   Node_Stack nstack(live_nodes() &gt;&gt; 1);
4055   final_graph_reshaping_walk(nstack, root(), frc);
4056 
4057   // Check for unreachable (from below) code (i.e., infinite loops).
4058   for( uint i = 0; i &lt; frc._tests.size(); i++ ) {
4059     MultiBranchNode *n = frc._tests[i]-&gt;as_MultiBranch();
4060     // Get number of CFG targets.
4061     // Note that PCTables include exception targets after calls.
4062     uint required_outcnt = n-&gt;required_outcnt();
4063     if (n-&gt;outcnt() != required_outcnt) {
4064       // Check for a few special cases.  Rethrow Nodes never take the
4065       // &#39;fall-thru&#39; path, so expected kids is 1 less.
4066       if (n-&gt;is_PCTable() &amp;&amp; n-&gt;in(0) &amp;&amp; n-&gt;in(0)-&gt;in(0)) {
4067         if (n-&gt;in(0)-&gt;in(0)-&gt;is_Call()) {
4068           CallNode *call = n-&gt;in(0)-&gt;in(0)-&gt;as_Call();
4069           if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
4070             required_outcnt--;      // Rethrow always has 1 less kid
4071           } else if (call-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
4072                      call-&gt;is_CallDynamicJava()) {
4073             // Check for null receiver. In such case, the optimizer has
4074             // detected that the virtual call will always result in a null
4075             // pointer exception. The fall-through projection of this CatchNode
4076             // will not be populated.
4077             Node *arg0 = call-&gt;in(TypeFunc::Parms);
4078             if (arg0-&gt;is_Type() &amp;&amp;
4079                 arg0-&gt;as_Type()-&gt;type()-&gt;higher_equal(TypePtr::NULL_PTR)) {
4080               required_outcnt--;
4081             }
4082           } else if (call-&gt;entry_point() == OptoRuntime::new_array_Java() &amp;&amp;
4083                      call-&gt;req() &gt; TypeFunc::Parms+1 &amp;&amp;
4084                      call-&gt;is_CallStaticJava()) {
4085             // Check for negative array length. In such case, the optimizer has
4086             // detected that the allocation attempt will always result in an
4087             // exception. There is no fall-through projection of this CatchNode .
4088             Node *arg1 = call-&gt;in(TypeFunc::Parms+1);
4089             if (arg1-&gt;is_Type() &amp;&amp;
4090                 arg1-&gt;as_Type()-&gt;type()-&gt;join(TypeInt::POS)-&gt;empty()) {
4091               required_outcnt--;
4092             }
4093           }
4094         }
4095       }
4096       // Recheck with a better notion of &#39;required_outcnt&#39;
4097       if (n-&gt;outcnt() != required_outcnt) {
4098         record_method_not_compilable(&quot;malformed control flow&quot;);
4099         return true;            // Not all targets reachable!
4100       }
4101     }
4102     // Check that I actually visited all kids.  Unreached kids
4103     // must be infinite loops.
4104     for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++)
4105       if (!frc._visited.test(n-&gt;fast_out(j)-&gt;_idx)) {
4106         record_method_not_compilable(&quot;infinite loop&quot;);
4107         return true;            // Found unvisited kid; must be unreach
4108       }
4109 
4110     // Here so verification code in final_graph_reshaping_walk()
4111     // always see an OuterStripMinedLoopEnd
4112     if (n-&gt;is_OuterStripMinedLoopEnd()) {
4113       IfNode* init_iff = n-&gt;as_If();
4114       Node* iff = new IfNode(init_iff-&gt;in(0), init_iff-&gt;in(1), init_iff-&gt;_prob, init_iff-&gt;_fcnt);
4115       n-&gt;subsume_by(iff, this);
4116     }
4117   }
4118 
4119 #ifdef IA32
4120   // If original bytecodes contained a mixture of floats and doubles
4121   // check if the optimizer has made it homogenous, item (3).
4122   if (UseSSE == 0 &amp;&amp;
4123       frc.get_float_count() &gt; 32 &amp;&amp;
4124       frc.get_double_count() == 0 &amp;&amp;
4125       (10 * frc.get_call_count() &lt; frc.get_float_count()) ) {
4126     set_24_bit_selection_and_mode(false, true);
4127   }
4128 #endif // IA32
4129 
4130   set_java_calls(frc.get_java_call_count());
4131   set_inner_loops(frc.get_inner_loop_count());
4132 
4133   // No infinite loops, no reason to bail out.
4134   return false;
4135 }
4136 
4137 //-----------------------------too_many_traps----------------------------------
4138 // Report if there are too many traps at the current method and bci.
4139 // Return true if there was a trap, and/or PerMethodTrapLimit is exceeded.
4140 bool Compile::too_many_traps(ciMethod* method,
4141                              int bci,
4142                              Deoptimization::DeoptReason reason) {
4143   ciMethodData* md = method-&gt;method_data();
4144   if (md-&gt;is_empty()) {
4145     // Assume the trap has not occurred, or that it occurred only
4146     // because of a transient condition during start-up in the interpreter.
4147     return false;
4148   }
4149   ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this-&gt;method() : NULL;
4150   if (md-&gt;has_trap_at(bci, m, reason) != 0) {
4151     // Assume PerBytecodeTrapLimit==0, for a more conservative heuristic.
4152     // Also, if there are multiple reasons, or if there is no per-BCI record,
4153     // assume the worst.
4154     if (log())
4155       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;%d&#39;&quot;,
4156                   Deoptimization::trap_reason_name(reason),
4157                   md-&gt;trap_count(reason));
4158     return true;
4159   } else {
4160     // Ignore method/bci and see if there have been too many globally.
4161     return too_many_traps(reason, md);
4162   }
4163 }
4164 
4165 // Less-accurate variant which does not require a method and bci.
4166 bool Compile::too_many_traps(Deoptimization::DeoptReason reason,
4167                              ciMethodData* logmd) {
4168   if (trap_count(reason) &gt;= Deoptimization::per_method_trap_limit(reason)) {
4169     // Too many traps globally.
4170     // Note that we use cumulative trap_count, not just md-&gt;trap_count.
4171     if (log()) {
4172       int mcount = (logmd == NULL)? -1: (int)logmd-&gt;trap_count(reason);
4173       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;0&#39; mcount=&#39;%d&#39; ccount=&#39;%d&#39;&quot;,
4174                   Deoptimization::trap_reason_name(reason),
4175                   mcount, trap_count(reason));
4176     }
4177     return true;
4178   } else {
4179     // The coast is clear.
4180     return false;
4181   }
4182 }
4183 
4184 //--------------------------too_many_recompiles--------------------------------
4185 // Report if there are too many recompiles at the current method and bci.
4186 // Consults PerBytecodeRecompilationCutoff and PerMethodRecompilationCutoff.
4187 // Is not eager to return true, since this will cause the compiler to use
4188 // Action_none for a trap point, to avoid too many recompilations.
4189 bool Compile::too_many_recompiles(ciMethod* method,
4190                                   int bci,
4191                                   Deoptimization::DeoptReason reason) {
4192   ciMethodData* md = method-&gt;method_data();
4193   if (md-&gt;is_empty()) {
4194     // Assume the trap has not occurred, or that it occurred only
4195     // because of a transient condition during start-up in the interpreter.
4196     return false;
4197   }
4198   // Pick a cutoff point well within PerBytecodeRecompilationCutoff.
4199   uint bc_cutoff = (uint) PerBytecodeRecompilationCutoff / 8;
4200   uint m_cutoff  = (uint) PerMethodRecompilationCutoff / 2 + 1;  // not zero
4201   Deoptimization::DeoptReason per_bc_reason
4202     = Deoptimization::reason_recorded_per_bytecode_if_any(reason);
4203   ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this-&gt;method() : NULL;
4204   if ((per_bc_reason == Deoptimization::Reason_none
4205        || md-&gt;has_trap_at(bci, m, reason) != 0)
4206       // The trap frequency measure we care about is the recompile count:
4207       &amp;&amp; md-&gt;trap_recompiled_at(bci, m)
4208       &amp;&amp; md-&gt;overflow_recompile_count() &gt;= bc_cutoff) {
4209     // Do not emit a trap here if it has already caused recompilations.
4210     // Also, if there are multiple reasons, or if there is no per-BCI record,
4211     // assume the worst.
4212     if (log())
4213       log()-&gt;elem(&quot;observe trap=&#39;%s recompiled&#39; count=&#39;%d&#39; recompiles2=&#39;%d&#39;&quot;,
4214                   Deoptimization::trap_reason_name(reason),
4215                   md-&gt;trap_count(reason),
4216                   md-&gt;overflow_recompile_count());
4217     return true;
4218   } else if (trap_count(reason) != 0
4219              &amp;&amp; decompile_count() &gt;= m_cutoff) {
4220     // Too many recompiles globally, and we have seen this sort of trap.
4221     // Use cumulative decompile_count, not just md-&gt;decompile_count.
4222     if (log())
4223       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;%d&#39; mcount=&#39;%d&#39; decompiles=&#39;%d&#39; mdecompiles=&#39;%d&#39;&quot;,
4224                   Deoptimization::trap_reason_name(reason),
4225                   md-&gt;trap_count(reason), trap_count(reason),
4226                   md-&gt;decompile_count(), decompile_count());
4227     return true;
4228   } else {
4229     // The coast is clear.
4230     return false;
4231   }
4232 }
4233 
4234 // Compute when not to trap. Used by matching trap based nodes and
4235 // NullCheck optimization.
4236 void Compile::set_allowed_deopt_reasons() {
4237   _allowed_reasons = 0;
4238   if (is_method_compilation()) {
4239     for (int rs = (int)Deoptimization::Reason_none+1; rs &lt; Compile::trapHistLength; rs++) {
4240       assert(rs &lt; BitsPerInt, &quot;recode bit map&quot;);
4241       if (!too_many_traps((Deoptimization::DeoptReason) rs)) {
4242         _allowed_reasons |= nth_bit(rs);
4243       }
4244     }
4245   }
4246 }
4247 
4248 bool Compile::needs_clinit_barrier(ciMethod* method, ciMethod* accessing_method) {
4249   return method-&gt;is_static() &amp;&amp; needs_clinit_barrier(method-&gt;holder(), accessing_method);
4250 }
4251 
4252 bool Compile::needs_clinit_barrier(ciField* field, ciMethod* accessing_method) {
4253   return field-&gt;is_static() &amp;&amp; needs_clinit_barrier(field-&gt;holder(), accessing_method);
4254 }
4255 
4256 bool Compile::needs_clinit_barrier(ciInstanceKlass* holder, ciMethod* accessing_method) {
4257   if (holder-&gt;is_initialized()) {
4258     return false;
4259   }
4260   if (holder-&gt;is_being_initialized()) {
4261     if (accessing_method-&gt;holder() == holder) {
4262       // Access inside a class. The barrier can be elided when access happens in &lt;clinit&gt;,
4263       // &lt;init&gt;, or a static method. In all those cases, there was an initialization
4264       // barrier on the holder klass passed.
<a name="45" id="anc45"></a><span class="line-modified">4265       if (accessing_method-&gt;is_class_initializer() ||</span>
<span class="line-modified">4266           accessing_method-&gt;is_object_constructor() ||</span>
4267           accessing_method-&gt;is_static()) {
4268         return false;
4269       }
4270     } else if (accessing_method-&gt;holder()-&gt;is_subclass_of(holder)) {
4271       // Access from a subclass. The barrier can be elided only when access happens in &lt;clinit&gt;.
4272       // In case of &lt;init&gt; or a static method, the barrier is on the subclass is not enough:
4273       // child class can become fully initialized while its parent class is still being initialized.
<a name="46" id="anc46"></a><span class="line-modified">4274       if (accessing_method-&gt;is_class_initializer()) {</span>
4275         return false;
4276       }
4277     }
4278     ciMethod* root = method(); // the root method of compilation
4279     if (root != accessing_method) {
4280       return needs_clinit_barrier(holder, root); // check access in the context of compilation root
4281     }
4282   }
4283   return true;
4284 }
4285 
4286 #ifndef PRODUCT
4287 //------------------------------verify_graph_edges---------------------------
4288 // Walk the Graph and verify that there is a one-to-one correspondence
4289 // between Use-Def edges and Def-Use edges in the graph.
4290 void Compile::verify_graph_edges(bool no_dead_code) {
4291   if (VerifyGraphEdges) {
4292     ResourceArea *area = Thread::current()-&gt;resource_area();
4293     Unique_Node_List visited(area);
4294     // Call recursive graph walk to check edges
4295     _root-&gt;verify_edges(visited);
4296     if (no_dead_code) {
4297       // Now make sure that no visited node is used by an unvisited node.
4298       bool dead_nodes = false;
4299       Unique_Node_List checked(area);
4300       while (visited.size() &gt; 0) {
4301         Node* n = visited.pop();
4302         checked.push(n);
4303         for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {
4304           Node* use = n-&gt;raw_out(i);
4305           if (checked.member(use))  continue;  // already checked
4306           if (visited.member(use))  continue;  // already in the graph
4307           if (use-&gt;is_Con())        continue;  // a dead ConNode is OK
4308           // At this point, we have found a dead node which is DU-reachable.
4309           if (!dead_nodes) {
4310             tty-&gt;print_cr(&quot;*** Dead nodes reachable via DU edges:&quot;);
4311             dead_nodes = true;
4312           }
4313           use-&gt;dump(2);
4314           tty-&gt;print_cr(&quot;---&quot;);
4315           checked.push(use);  // No repeats; pretend it is now checked.
4316         }
4317       }
4318       assert(!dead_nodes, &quot;using nodes must be reachable from root&quot;);
4319     }
4320   }
4321 }
4322 #endif
4323 
4324 // The Compile object keeps track of failure reasons separately from the ciEnv.
4325 // This is required because there is not quite a 1-1 relation between the
4326 // ciEnv and its compilation task and the Compile object.  Note that one
4327 // ciEnv might use two Compile objects, if C2Compiler::compile_method decides
4328 // to backtrack and retry without subsuming loads.  Other than this backtracking
4329 // behavior, the Compile&#39;s failure reason is quietly copied up to the ciEnv
4330 // by the logic in C2Compiler.
4331 void Compile::record_failure(const char* reason) {
4332   if (log() != NULL) {
4333     log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;compile&#39;&quot;, reason);
4334   }
4335   if (_failure_reason == NULL) {
4336     // Record the first failure reason.
4337     _failure_reason = reason;
4338   }
4339 
4340   if (!C-&gt;failure_reason_is(C2Compiler::retry_no_subsuming_loads())) {
4341     C-&gt;print_method(PHASE_FAILURE);
4342   }
4343   _root = NULL;  // flush the graph, too
4344 }
4345 
4346 Compile::TracePhase::TracePhase(const char* name, elapsedTimer* accumulator)
4347   : TraceTime(name, accumulator, CITime, CITimeVerbose),
4348     _phase_name(name), _dolog(CITimeVerbose)
4349 {
4350   if (_dolog) {
4351     C = Compile::current();
4352     _log = C-&gt;log();
4353   } else {
4354     C = NULL;
4355     _log = NULL;
4356   }
4357   if (_log != NULL) {
4358     _log-&gt;begin_head(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
4359     _log-&gt;stamp();
4360     _log-&gt;end_head();
4361   }
4362 }
4363 
4364 Compile::TracePhase::~TracePhase() {
4365 
4366   C = Compile::current();
4367   if (_dolog) {
4368     _log = C-&gt;log();
4369   } else {
4370     _log = NULL;
4371   }
4372 
4373 #ifdef ASSERT
4374   if (PrintIdealNodeCount) {
4375     tty-&gt;print_cr(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39; live_graph_walk=&#39;%d&#39;&quot;,
4376                   _phase_name, C-&gt;unique(), C-&gt;live_nodes(), C-&gt;count_live_nodes_by_graph_walk());
4377   }
4378 
4379   if (VerifyIdealNodeCount) {
4380     Compile::current()-&gt;print_missing_nodes();
4381   }
4382 #endif
4383 
4384   if (_log != NULL) {
4385     _log-&gt;done(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
4386   }
4387 }
4388 
4389 //----------------------------static_subtype_check-----------------------------
4390 // Shortcut important common cases when superklass is exact:
4391 // (0) superklass is java.lang.Object (can occur in reflective code)
4392 // (1) subklass is already limited to a subtype of superklass =&gt; always ok
4393 // (2) subklass does not overlap with superklass =&gt; always fail
4394 // (3) superklass has NO subtypes and we can check with a simple compare.
4395 int Compile::static_subtype_check(ciKlass* superk, ciKlass* subk) {
<a name="47" id="anc47"></a><span class="line-modified">4396   if (StressReflectiveCode || superk == NULL || subk == NULL) {</span>
4397     return SSC_full_test;       // Let caller generate the general case.
4398   }
4399 
4400   if (superk == env()-&gt;Object_klass()) {
4401     return SSC_always_true;     // (0) this test cannot fail
4402   }
4403 
4404   ciType* superelem = superk;
<a name="48" id="anc48"></a><span class="line-modified">4405   if (superelem-&gt;is_array_klass()) {</span>
<span class="line-added">4406     ciArrayKlass* ak = superelem-&gt;as_array_klass();</span>
4407     superelem = superelem-&gt;as_array_klass()-&gt;base_element_type();
<a name="49" id="anc49"></a><span class="line-added">4408   }</span>
4409 
4410   if (!subk-&gt;is_interface()) {  // cannot trust static interface types yet
4411     if (subk-&gt;is_subtype_of(superk)) {
4412       return SSC_always_true;   // (1) false path dead; no dynamic test needed
4413     }
4414     if (!(superelem-&gt;is_klass() &amp;&amp; superelem-&gt;as_klass()-&gt;is_interface()) &amp;&amp;
4415         !superk-&gt;is_subtype_of(subk)) {
4416       return SSC_always_false;
4417     }
4418   }
4419 
4420   // If casting to an instance klass, it must have no subtypes
4421   if (superk-&gt;is_interface()) {
4422     // Cannot trust interfaces yet.
4423     // %%% S.B. superk-&gt;nof_implementors() == 1
4424   } else if (superelem-&gt;is_instance_klass()) {
4425     ciInstanceKlass* ik = superelem-&gt;as_instance_klass();
4426     if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
4427       if (!ik-&gt;is_final()) {
4428         // Add a dependency if there is a chance of a later subclass.
4429         dependencies()-&gt;assert_leaf_type(ik);
4430       }
4431       return SSC_easy_test;     // (3) caller can do a simple ptr comparison
4432     }
4433   } else {
4434     // A primitive array type has no subtypes.
4435     return SSC_easy_test;       // (3) caller can do a simple ptr comparison
4436   }
4437 
4438   return SSC_full_test;
4439 }
4440 
4441 Node* Compile::conv_I2X_index(PhaseGVN* phase, Node* idx, const TypeInt* sizetype, Node* ctrl) {
4442 #ifdef _LP64
4443   // The scaled index operand to AddP must be a clean 64-bit value.
4444   // Java allows a 32-bit int to be incremented to a negative
4445   // value, which appears in a 64-bit register as a large
4446   // positive number.  Using that large positive number as an
4447   // operand in pointer arithmetic has bad consequences.
4448   // On the other hand, 32-bit overflow is rare, and the possibility
4449   // can often be excluded, if we annotate the ConvI2L node with
4450   // a type assertion that its value is known to be a small positive
4451   // number.  (The prior range check has ensured this.)
4452   // This assertion is used by ConvI2LNode::Ideal.
4453   int index_max = max_jint - 1;  // array size is max_jint, index is one less
4454   if (sizetype != NULL) index_max = sizetype-&gt;_hi - 1;
4455   const TypeInt* iidxtype = TypeInt::make(0, index_max, Type::WidenMax);
4456   idx = constrained_convI2L(phase, idx, iidxtype, ctrl);
4457 #endif
4458   return idx;
4459 }
4460 
4461 // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
4462 Node* Compile::constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl) {
4463   if (ctrl != NULL) {
4464     // Express control dependency by a CastII node with a narrow type.
4465     value = new CastIINode(value, itype, false, true /* range check dependency */);
4466     // Make the CastII node dependent on the control input to prevent the narrowed ConvI2L
4467     // node from floating above the range check during loop optimizations. Otherwise, the
4468     // ConvI2L node may be eliminated independently of the range check, causing the data path
4469     // to become TOP while the control path is still there (although it&#39;s unreachable).
4470     value-&gt;set_req(0, ctrl);
4471     // Save CastII node to remove it after loop optimizations.
4472     phase-&gt;C-&gt;add_range_check_cast(value);
4473     value = phase-&gt;transform(value);
4474   }
4475   const TypeLong* ltype = TypeLong::make(itype-&gt;_lo, itype-&gt;_hi, itype-&gt;_widen);
4476   return phase-&gt;transform(new ConvI2LNode(value, ltype));
4477 }
4478 
4479 void Compile::print_inlining_stream_free() {
4480   if (_print_inlining_stream != NULL) {
4481     _print_inlining_stream-&gt;~stringStream();
4482     _print_inlining_stream = NULL;
4483   }
4484 }
4485 
4486 // The message about the current inlining is accumulated in
4487 // _print_inlining_stream and transfered into the _print_inlining_list
4488 // once we know whether inlining succeeds or not. For regular
4489 // inlining, messages are appended to the buffer pointed by
4490 // _print_inlining_idx in the _print_inlining_list. For late inlining,
4491 // a new buffer is added after _print_inlining_idx in the list. This
4492 // way we can update the inlining message for late inlining call site
4493 // when the inlining is attempted again.
4494 void Compile::print_inlining_init() {
4495   if (print_inlining() || print_intrinsics()) {
4496     // print_inlining_init is actually called several times.
4497     print_inlining_stream_free();
4498     _print_inlining_stream = new stringStream();
4499     // Watch out: The memory initialized by the constructor call PrintInliningBuffer()
4500     // will be copied into the only initial element. The default destructor of
4501     // PrintInliningBuffer will be called when leaving the scope here. If it
4502     // would destuct the  enclosed stringStream _print_inlining_list[0]-&gt;_ss
4503     // would be destructed, too!
4504     _print_inlining_list = new (comp_arena())GrowableArray&lt;PrintInliningBuffer&gt;(comp_arena(), 1, 1, PrintInliningBuffer());
4505   }
4506 }
4507 
4508 void Compile::print_inlining_reinit() {
4509   if (print_inlining() || print_intrinsics()) {
4510     print_inlining_stream_free();
4511     // Re allocate buffer when we change ResourceMark
4512     _print_inlining_stream = new stringStream();
4513   }
4514 }
4515 
4516 void Compile::print_inlining_reset() {
4517   _print_inlining_stream-&gt;reset();
4518 }
4519 
4520 void Compile::print_inlining_commit() {
4521   assert(print_inlining() || print_intrinsics(), &quot;PrintInlining off?&quot;);
4522   // Transfer the message from _print_inlining_stream to the current
4523   // _print_inlining_list buffer and clear _print_inlining_stream.
4524   _print_inlining_list-&gt;at(_print_inlining_idx).ss()-&gt;write(_print_inlining_stream-&gt;base(), _print_inlining_stream-&gt;size());
4525   print_inlining_reset();
4526 }
4527 
4528 void Compile::print_inlining_push() {
4529   // Add new buffer to the _print_inlining_list at current position
4530   _print_inlining_idx++;
4531   _print_inlining_list-&gt;insert_before(_print_inlining_idx, PrintInliningBuffer());
4532 }
4533 
4534 Compile::PrintInliningBuffer&amp; Compile::print_inlining_current() {
4535   return _print_inlining_list-&gt;at(_print_inlining_idx);
4536 }
4537 
4538 void Compile::print_inlining_update(CallGenerator* cg) {
4539   if (print_inlining() || print_intrinsics()) {
4540     if (!cg-&gt;is_late_inline()) {
4541       if (print_inlining_current().cg() != NULL) {
4542         print_inlining_push();
4543       }
4544       print_inlining_commit();
4545     } else {
4546       if (print_inlining_current().cg() != cg &amp;&amp;
4547           (print_inlining_current().cg() != NULL ||
4548            print_inlining_current().ss()-&gt;size() != 0)) {
4549         print_inlining_push();
4550       }
4551       print_inlining_commit();
4552       print_inlining_current().set_cg(cg);
4553     }
4554   }
4555 }
4556 
4557 void Compile::print_inlining_move_to(CallGenerator* cg) {
4558   // We resume inlining at a late inlining call site. Locate the
4559   // corresponding inlining buffer so that we can update it.
4560   if (print_inlining()) {
4561     for (int i = 0; i &lt; _print_inlining_list-&gt;length(); i++) {
4562       if (_print_inlining_list-&gt;adr_at(i)-&gt;cg() == cg) {
4563         _print_inlining_idx = i;
4564         return;
4565       }
4566     }
4567     ShouldNotReachHere();
4568   }
4569 }
4570 
4571 void Compile::print_inlining_update_delayed(CallGenerator* cg) {
4572   if (print_inlining()) {
4573     assert(_print_inlining_stream-&gt;size() &gt; 0, &quot;missing inlining msg&quot;);
4574     assert(print_inlining_current().cg() == cg, &quot;wrong entry&quot;);
4575     // replace message with new message
4576     _print_inlining_list-&gt;at_put(_print_inlining_idx, PrintInliningBuffer());
4577     print_inlining_commit();
4578     print_inlining_current().set_cg(cg);
4579   }
4580 }
4581 
4582 void Compile::print_inlining_assert_ready() {
4583   assert(!_print_inlining || _print_inlining_stream-&gt;size() == 0, &quot;loosing data&quot;);
4584 }
4585 
4586 void Compile::process_print_inlining() {
4587   bool do_print_inlining = print_inlining() || print_intrinsics();
4588   if (do_print_inlining || log() != NULL) {
4589     // Print inlining message for candidates that we couldn&#39;t inline
4590     // for lack of space
4591     for (int i = 0; i &lt; _late_inlines.length(); i++) {
4592       CallGenerator* cg = _late_inlines.at(i);
4593       if (!cg-&gt;is_mh_late_inline()) {
4594         const char* msg = &quot;live nodes &gt; LiveNodeCountInliningCutoff&quot;;
4595         if (do_print_inlining) {
4596           cg-&gt;print_inlining_late(msg);
4597         }
4598         log_late_inline_failure(cg, msg);
4599       }
4600     }
4601   }
4602   if (do_print_inlining) {
4603     ResourceMark rm;
4604     stringStream ss;
4605     assert(_print_inlining_list != NULL, &quot;process_print_inlining should be called only once.&quot;);
4606     for (int i = 0; i &lt; _print_inlining_list-&gt;length(); i++) {
4607       ss.print(&quot;%s&quot;, _print_inlining_list-&gt;adr_at(i)-&gt;ss()-&gt;as_string());
4608       _print_inlining_list-&gt;at(i).freeStream();
4609     }
4610     // Reset _print_inlining_list, it only contains destructed objects.
4611     // It is on the arena, so it will be freed when the arena is reset.
4612     _print_inlining_list = NULL;
4613     // _print_inlining_stream won&#39;t be used anymore, either.
4614     print_inlining_stream_free();
4615     size_t end = ss.size();
4616     _print_inlining_output = NEW_ARENA_ARRAY(comp_arena(), char, end+1);
4617     strncpy(_print_inlining_output, ss.base(), end+1);
4618     _print_inlining_output[end] = 0;
4619   }
4620 }
4621 
4622 void Compile::dump_print_inlining() {
4623   if (_print_inlining_output != NULL) {
4624     tty-&gt;print_raw(_print_inlining_output);
4625   }
4626 }
4627 
4628 void Compile::log_late_inline(CallGenerator* cg) {
4629   if (log() != NULL) {
4630     log()-&gt;head(&quot;late_inline method=&#39;%d&#39;  inline_id=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, log()-&gt;identify(cg-&gt;method()),
4631                 cg-&gt;unique_id());
4632     JVMState* p = cg-&gt;call_node()-&gt;jvms();
4633     while (p != NULL) {
4634       log()-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log()-&gt;identify(p-&gt;method()));
4635       p = p-&gt;caller();
4636     }
4637     log()-&gt;tail(&quot;late_inline&quot;);
4638   }
4639 }
4640 
4641 void Compile::log_late_inline_failure(CallGenerator* cg, const char* msg) {
4642   log_late_inline(cg);
4643   if (log() != NULL) {
4644     log()-&gt;inline_fail(msg);
4645   }
4646 }
4647 
4648 void Compile::log_inline_id(CallGenerator* cg) {
4649   if (log() != NULL) {
4650     // The LogCompilation tool needs a unique way to identify late
4651     // inline call sites. This id must be unique for this call site in
4652     // this compilation. Try to have it unique across compilations as
4653     // well because it can be convenient when grepping through the log
4654     // file.
4655     // Distinguish OSR compilations from others in case CICountOSR is
4656     // on.
4657     jlong id = ((jlong)unique()) + (((jlong)compile_id()) &lt;&lt; 33) + (CICountOSR &amp;&amp; is_osr_compilation() ? ((jlong)1) &lt;&lt; 32 : 0);
4658     cg-&gt;set_unique_id(id);
4659     log()-&gt;elem(&quot;inline_id id=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, id);
4660   }
4661 }
4662 
4663 void Compile::log_inline_failure(const char* msg) {
4664   if (C-&gt;log() != NULL) {
4665     C-&gt;log()-&gt;inline_fail(msg);
4666   }
4667 }
4668 
4669 
4670 // Dump inlining replay data to the stream.
4671 // Don&#39;t change thread state and acquire any locks.
4672 void Compile::dump_inline_data(outputStream* out) {
4673   InlineTree* inl_tree = ilt();
4674   if (inl_tree != NULL) {
4675     out-&gt;print(&quot; inline %d&quot;, inl_tree-&gt;count());
4676     inl_tree-&gt;dump_replay_data(out);
4677   }
4678 }
4679 
4680 int Compile::cmp_expensive_nodes(Node* n1, Node* n2) {
4681   if (n1-&gt;Opcode() &lt; n2-&gt;Opcode())      return -1;
4682   else if (n1-&gt;Opcode() &gt; n2-&gt;Opcode()) return 1;
4683 
4684   assert(n1-&gt;req() == n2-&gt;req(), &quot;can&#39;t compare %s nodes: n1-&gt;req() = %d, n2-&gt;req() = %d&quot;, NodeClassNames[n1-&gt;Opcode()], n1-&gt;req(), n2-&gt;req());
4685   for (uint i = 1; i &lt; n1-&gt;req(); i++) {
4686     if (n1-&gt;in(i) &lt; n2-&gt;in(i))      return -1;
4687     else if (n1-&gt;in(i) &gt; n2-&gt;in(i)) return 1;
4688   }
4689 
4690   return 0;
4691 }
4692 
4693 int Compile::cmp_expensive_nodes(Node** n1p, Node** n2p) {
4694   Node* n1 = *n1p;
4695   Node* n2 = *n2p;
4696 
4697   return cmp_expensive_nodes(n1, n2);
4698 }
4699 
4700 void Compile::sort_expensive_nodes() {
4701   if (!expensive_nodes_sorted()) {
4702     _expensive_nodes-&gt;sort(cmp_expensive_nodes);
4703   }
4704 }
4705 
4706 bool Compile::expensive_nodes_sorted() const {
4707   for (int i = 1; i &lt; _expensive_nodes-&gt;length(); i++) {
4708     if (cmp_expensive_nodes(_expensive_nodes-&gt;adr_at(i), _expensive_nodes-&gt;adr_at(i-1)) &lt; 0) {
4709       return false;
4710     }
4711   }
4712   return true;
4713 }
4714 
4715 bool Compile::should_optimize_expensive_nodes(PhaseIterGVN &amp;igvn) {
4716   if (_expensive_nodes-&gt;length() == 0) {
4717     return false;
4718   }
4719 
4720   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
4721 
4722   // Take this opportunity to remove dead nodes from the list
4723   int j = 0;
4724   for (int i = 0; i &lt; _expensive_nodes-&gt;length(); i++) {
4725     Node* n = _expensive_nodes-&gt;at(i);
4726     if (!n-&gt;is_unreachable(igvn)) {
4727       assert(n-&gt;is_expensive(), &quot;should be expensive&quot;);
4728       _expensive_nodes-&gt;at_put(j, n);
4729       j++;
4730     }
4731   }
4732   _expensive_nodes-&gt;trunc_to(j);
4733 
4734   // Then sort the list so that similar nodes are next to each other
4735   // and check for at least two nodes of identical kind with same data
4736   // inputs.
4737   sort_expensive_nodes();
4738 
4739   for (int i = 0; i &lt; _expensive_nodes-&gt;length()-1; i++) {
4740     if (cmp_expensive_nodes(_expensive_nodes-&gt;adr_at(i), _expensive_nodes-&gt;adr_at(i+1)) == 0) {
4741       return true;
4742     }
4743   }
4744 
4745   return false;
4746 }
4747 
4748 void Compile::cleanup_expensive_nodes(PhaseIterGVN &amp;igvn) {
4749   if (_expensive_nodes-&gt;length() == 0) {
4750     return;
4751   }
4752 
4753   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
4754 
4755   // Sort to bring similar nodes next to each other and clear the
4756   // control input of nodes for which there&#39;s only a single copy.
4757   sort_expensive_nodes();
4758 
4759   int j = 0;
4760   int identical = 0;
4761   int i = 0;
4762   bool modified = false;
4763   for (; i &lt; _expensive_nodes-&gt;length()-1; i++) {
4764     assert(j &lt;= i, &quot;can&#39;t write beyond current index&quot;);
4765     if (_expensive_nodes-&gt;at(i)-&gt;Opcode() == _expensive_nodes-&gt;at(i+1)-&gt;Opcode()) {
4766       identical++;
4767       _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
4768       continue;
4769     }
4770     if (identical &gt; 0) {
4771       _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
4772       identical = 0;
4773     } else {
4774       Node* n = _expensive_nodes-&gt;at(i);
4775       igvn.replace_input_of(n, 0, NULL);
4776       igvn.hash_insert(n);
4777       modified = true;
4778     }
4779   }
4780   if (identical &gt; 0) {
4781     _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
4782   } else if (_expensive_nodes-&gt;length() &gt;= 1) {
4783     Node* n = _expensive_nodes-&gt;at(i);
4784     igvn.replace_input_of(n, 0, NULL);
4785     igvn.hash_insert(n);
4786     modified = true;
4787   }
4788   _expensive_nodes-&gt;trunc_to(j);
4789   if (modified) {
4790     igvn.optimize();
4791   }
4792 }
4793 
4794 void Compile::add_expensive_node(Node * n) {
4795   assert(!_expensive_nodes-&gt;contains(n), &quot;duplicate entry in expensive list&quot;);
4796   assert(n-&gt;is_expensive(), &quot;expensive nodes with non-null control here only&quot;);
4797   assert(!n-&gt;is_CFG() &amp;&amp; !n-&gt;is_Mem(), &quot;no cfg or memory nodes here&quot;);
4798   if (OptimizeExpensiveOps) {
4799     _expensive_nodes-&gt;append(n);
4800   } else {
4801     // Clear control input and let IGVN optimize expensive nodes if
4802     // OptimizeExpensiveOps is off.
4803     n-&gt;set_req(0, NULL);
4804   }
4805 }
4806 
4807 /**
4808  * Remove the speculative part of types and clean up the graph
4809  */
4810 void Compile::remove_speculative_types(PhaseIterGVN &amp;igvn) {
4811   if (UseTypeSpeculation) {
4812     Unique_Node_List worklist;
4813     worklist.push(root());
4814     int modified = 0;
4815     // Go over all type nodes that carry a speculative type, drop the
4816     // speculative part of the type and enqueue the node for an igvn
4817     // which may optimize it out.
4818     for (uint next = 0; next &lt; worklist.size(); ++next) {
4819       Node *n  = worklist.at(next);
4820       if (n-&gt;is_Type()) {
4821         TypeNode* tn = n-&gt;as_Type();
4822         const Type* t = tn-&gt;type();
4823         const Type* t_no_spec = t-&gt;remove_speculative();
4824         if (t_no_spec != t) {
4825           bool in_hash = igvn.hash_delete(n);
4826           assert(in_hash, &quot;node should be in igvn hash table&quot;);
4827           tn-&gt;set_type(t_no_spec);
4828           igvn.hash_insert(n);
4829           igvn._worklist.push(n); // give it a chance to go away
4830           modified++;
4831         }
4832       }
4833       uint max = n-&gt;len();
4834       for( uint i = 0; i &lt; max; ++i ) {
4835         Node *m = n-&gt;in(i);
4836         if (not_a_node(m))  continue;
4837         worklist.push(m);
4838       }
4839     }
4840     // Drop the speculative part of all types in the igvn&#39;s type table
4841     igvn.remove_speculative_types();
4842     if (modified &gt; 0) {
4843       igvn.optimize();
4844     }
4845 #ifdef ASSERT
4846     // Verify that after the IGVN is over no speculative type has resurfaced
4847     worklist.clear();
4848     worklist.push(root());
4849     for (uint next = 0; next &lt; worklist.size(); ++next) {
4850       Node *n  = worklist.at(next);
4851       const Type* t = igvn.type_or_null(n);
4852       assert((t == NULL) || (t == t-&gt;remove_speculative()), &quot;no more speculative types&quot;);
4853       if (n-&gt;is_Type()) {
4854         t = n-&gt;as_Type()-&gt;type();
4855         assert(t == t-&gt;remove_speculative(), &quot;no more speculative types&quot;);
4856       }
4857       uint max = n-&gt;len();
4858       for( uint i = 0; i &lt; max; ++i ) {
4859         Node *m = n-&gt;in(i);
4860         if (not_a_node(m))  continue;
4861         worklist.push(m);
4862       }
4863     }
4864     igvn.check_no_speculative_types();
4865 #endif
4866   }
4867 }
4868 
<a name="50" id="anc50"></a><span class="line-added">4869 Node* Compile::optimize_acmp(PhaseGVN* phase, Node* a, Node* b) {</span>
<span class="line-added">4870   const TypeInstPtr* ta = phase-&gt;type(a)-&gt;isa_instptr();</span>
<span class="line-added">4871   const TypeInstPtr* tb = phase-&gt;type(b)-&gt;isa_instptr();</span>
<span class="line-added">4872   if (!EnableValhalla || ta == NULL || tb == NULL ||</span>
<span class="line-added">4873       ta-&gt;is_zero_type() || tb-&gt;is_zero_type() ||</span>
<span class="line-added">4874       !ta-&gt;can_be_value_type() || !tb-&gt;can_be_value_type()) {</span>
<span class="line-added">4875     // Use old acmp if one operand is null or not a value type</span>
<span class="line-added">4876     return new CmpPNode(a, b);</span>
<span class="line-added">4877   } else if (ta-&gt;is_valuetypeptr() || tb-&gt;is_valuetypeptr()) {</span>
<span class="line-added">4878     // We know that one operand is a value type. Therefore,</span>
<span class="line-added">4879     // new acmp will only return true if both operands are NULL.</span>
<span class="line-added">4880     // Check if both operands are null by or&#39;ing the oops.</span>
<span class="line-added">4881     a = phase-&gt;transform(new CastP2XNode(NULL, a));</span>
<span class="line-added">4882     b = phase-&gt;transform(new CastP2XNode(NULL, b));</span>
<span class="line-added">4883     a = phase-&gt;transform(new OrXNode(a, b));</span>
<span class="line-added">4884     return new CmpXNode(a, phase-&gt;MakeConX(0));</span>
<span class="line-added">4885   }</span>
<span class="line-added">4886   // Use new acmp</span>
<span class="line-added">4887   return NULL;</span>
<span class="line-added">4888 }</span>
<span class="line-added">4889 </span>
4890 // Auxiliary method to support randomized stressing/fuzzing.
4891 //
4892 // This method can be called the arbitrary number of times, with current count
4893 // as the argument. The logic allows selecting a single candidate from the
4894 // running list of candidates as follows:
4895 //    int count = 0;
4896 //    Cand* selected = null;
4897 //    while(cand = cand-&gt;next()) {
4898 //      if (randomized_select(++count)) {
4899 //        selected = cand;
4900 //      }
4901 //    }
4902 //
4903 // Including count equalizes the chances any candidate is &quot;selected&quot;.
4904 // This is useful when we don&#39;t have the complete list of candidates to choose
4905 // from uniformly. In this case, we need to adjust the randomicity of the
4906 // selection, or else we will end up biasing the selection towards the latter
4907 // candidates.
4908 //
4909 // Quick back-envelope calculation shows that for the list of n candidates
4910 // the equal probability for the candidate to persist as &quot;best&quot; can be
4911 // achieved by replacing it with &quot;next&quot; k-th candidate with the probability
4912 // of 1/k. It can be easily shown that by the end of the run, the
4913 // probability for any candidate is converged to 1/n, thus giving the
4914 // uniform distribution among all the candidates.
4915 //
4916 // We don&#39;t care about the domain size as long as (RANDOMIZED_DOMAIN / count) is large.
4917 #define RANDOMIZED_DOMAIN_POW 29
4918 #define RANDOMIZED_DOMAIN (1 &lt;&lt; RANDOMIZED_DOMAIN_POW)
4919 #define RANDOMIZED_DOMAIN_MASK ((1 &lt;&lt; (RANDOMIZED_DOMAIN_POW + 1)) - 1)
4920 bool Compile::randomized_select(int count) {
4921   assert(count &gt; 0, &quot;only positive&quot;);
4922   return (os::random() &amp; RANDOMIZED_DOMAIN_MASK) &lt; (RANDOMIZED_DOMAIN / count);
4923 }
4924 
4925 CloneMap&amp;     Compile::clone_map()                 { return _clone_map; }
4926 void          Compile::set_clone_map(Dict* d)      { _clone_map._dict = d; }
4927 
4928 void NodeCloneInfo::dump() const {
4929   tty-&gt;print(&quot; {%d:%d} &quot;, idx(), gen());
4930 }
4931 
4932 void CloneMap::clone(Node* old, Node* nnn, int gen) {
4933   uint64_t val = value(old-&gt;_idx);
4934   NodeCloneInfo cio(val);
4935   assert(val != 0, &quot;old node should be in the map&quot;);
4936   NodeCloneInfo cin(cio.idx(), gen + cio.gen());
4937   insert(nnn-&gt;_idx, cin.get());
4938 #ifndef PRODUCT
4939   if (is_debug()) {
4940     tty-&gt;print_cr(&quot;CloneMap::clone inserted node %d info {%d:%d} into CloneMap&quot;, nnn-&gt;_idx, cin.idx(), cin.gen());
4941   }
4942 #endif
4943 }
4944 
4945 void CloneMap::verify_insert_and_clone(Node* old, Node* nnn, int gen) {
4946   NodeCloneInfo cio(value(old-&gt;_idx));
4947   if (cio.get() == 0) {
4948     cio.set(old-&gt;_idx, 0);
4949     insert(old-&gt;_idx, cio.get());
4950 #ifndef PRODUCT
4951     if (is_debug()) {
4952       tty-&gt;print_cr(&quot;CloneMap::verify_insert_and_clone inserted node %d info {%d:%d} into CloneMap&quot;, old-&gt;_idx, cio.idx(), cio.gen());
4953     }
4954 #endif
4955   }
4956   clone(old, nnn, gen);
4957 }
4958 
4959 int CloneMap::max_gen() const {
4960   int g = 0;
4961   DictI di(_dict);
4962   for(; di.test(); ++di) {
4963     int t = gen(di._key);
4964     if (g &lt; t) {
4965       g = t;
4966 #ifndef PRODUCT
4967       if (is_debug()) {
4968         tty-&gt;print_cr(&quot;CloneMap::max_gen() update max=%d from %d&quot;, g, _2_node_idx_t(di._key));
4969       }
4970 #endif
4971     }
4972   }
4973   return g;
4974 }
4975 
4976 void CloneMap::dump(node_idx_t key) const {
4977   uint64_t val = value(key);
4978   if (val != 0) {
4979     NodeCloneInfo ni(val);
4980     ni.dump();
4981   }
4982 }
4983 
4984 
4985 // Move Allocate nodes to the start of the list
4986 void Compile::sort_macro_nodes() {
4987   int count = macro_count();
4988   int allocates = 0;
4989   for (int i = 0; i &lt; count; i++) {
4990     Node* n = macro_node(i);
4991     if (n-&gt;is_Allocate()) {
4992       if (i != allocates) {
4993         Node* tmp = macro_node(allocates);
4994         _macro_nodes-&gt;at_put(allocates, n);
4995         _macro_nodes-&gt;at_put(i, tmp);
4996       }
4997       allocates++;
4998     }
4999   }
5000 }
<a name="51" id="anc51"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="51" type="hidden" />
</body>
</html>
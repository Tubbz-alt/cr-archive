<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/subtypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;

  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/jvmtiThreadState.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;prims/stackwalk.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/init.hpp&quot;
  67 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  68 #include &quot;runtime/deoptimization.hpp&quot;
  69 #include &quot;runtime/handshake.hpp&quot;
  70 #include &quot;runtime/java.hpp&quot;
  71 #include &quot;runtime/javaCalls.hpp&quot;
  72 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  73 #include &quot;runtime/jniHandles.inline.hpp&quot;
  74 #include &quot;runtime/os.inline.hpp&quot;
  75 #include &quot;runtime/perfData.hpp&quot;
  76 #include &quot;runtime/reflection.hpp&quot;
  77 #include &quot;runtime/thread.inline.hpp&quot;
</pre>
<hr />
<pre>
 688   JVMWrapper(&quot;JVM_Clone&quot;);
 689   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 690   Klass* klass = obj-&gt;klass();
 691   JvmtiVMObjectAllocEventCollector oam;
 692 
 693 #ifdef ASSERT
 694   // Just checking that the cloneable flag is set correct
 695   if (obj-&gt;is_array()) {
 696     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 697   } else {
 698     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 699     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 700     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 701   }
 702 #endif
 703 
 704   // Check if class of obj supports the Cloneable interface.
 705   // All arrays are considered to be cloneable (See JLS 20.1.5).
 706   // All j.l.r.Reference classes are considered non-cloneable.
 707   if (!klass-&gt;is_cloneable() ||

 708       (klass-&gt;is_instance_klass() &amp;&amp;
 709        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 710     ResourceMark rm(THREAD);
 711     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 712   }
 713 
 714   // Make shallow object copy
 715   const int size = obj-&gt;size();
 716   oop new_obj_oop = NULL;
 717   if (obj-&gt;is_array()) {
 718     const int length = ((arrayOop)obj())-&gt;length();
 719     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 720                                                    /* do_zero */ true, CHECK_NULL);
 721   } else {
 722     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 723   }
 724 
 725   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 726 
 727   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1272   return (jstring) JNIHandles::make_local(env, result);
1273 JVM_END
1274 
1275 
1276 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1277   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1278   JvmtiVMObjectAllocEventCollector oam;
1279   oop mirror = JNIHandles::resolve_non_null(cls);
1280 
1281   // Special handling for primitive objects
1282   if (java_lang_Class::is_primitive(mirror)) {
1283     // Primitive objects does not have any interfaces
1284     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1285     return (jobjectArray) JNIHandles::make_local(env, r);
1286   }
1287 
1288   Klass* klass = java_lang_Class::as_Klass(mirror);
1289   // Figure size of result array
1290   int size;
1291   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1292     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();</span>




1293   } else {
1294     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1295     size = 2;</span>
1296   }
1297 
1298   // Allocate result array
1299   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1300   objArrayHandle result (THREAD, r);
1301   // Fill in result
1302   if (klass-&gt;is_instance_klass()) {
1303     // Regular instance klass, fill in all local interfaces

1304     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1305       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-modified">1306       result-&gt;obj_at_put(index, k-&gt;java_mirror());</span>



1307     }
1308   } else {
<span class="line-modified">1309     // All arrays implement java.lang.Cloneable and java.io.Serializable</span>
1310     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1311     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());

1312   }
1313   return (jobjectArray) JNIHandles::make_local(env, result());
1314 JVM_END
1315 
1316 
1317 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1318   JVMWrapper(&quot;JVM_IsInterface&quot;);
1319   oop mirror = JNIHandles::resolve_non_null(cls);
1320   if (java_lang_Class::is_primitive(mirror)) {
1321     return JNI_FALSE;
1322   }
1323   Klass* k = java_lang_Class::as_Klass(mirror);
1324   jboolean result = k-&gt;is_interface();
1325   assert(!result || k-&gt;is_instance_klass(),
1326          &quot;all interfaces are instance types&quot;);
1327   // The compiler intrinsic for isInterface tests the
1328   // Klass::_access_flags bits in the same way.
1329   return result;
1330 JVM_END
1331 
</pre>
<hr />
<pre>
1911         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1912       objArrayHandle components_h (THREAD, record_components);
1913 
1914       for (int x = 0; x &lt; length; x++) {
1915         RecordComponent* component = components-&gt;at(x);
1916         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1917         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1918         components_h-&gt;obj_at_put(x, component_oop);
1919       }
1920       return (jobjectArray)JNIHandles::make_local(components_h());
1921     }
1922   }
1923 
1924   // Return empty array if ofClass is not a record.
1925   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1926   return (jobjectArray)JNIHandles::make_local(env, result);
1927 }
1928 JVM_END
1929 
1930 static bool select_method(const methodHandle&amp; method, bool want_constructor) {


1931   if (want_constructor) {
<span class="line-modified">1932     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());</span>
1933   } else {
<span class="line-modified">1934     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());</span>


1935   }
1936 }
1937 
1938 static jobjectArray get_class_declared_methods_helper(
1939                                   JNIEnv *env,
1940                                   jclass ofClass, jboolean publicOnly,
1941                                   bool want_constructor,
1942                                   Klass* klass, TRAPS) {
1943 
1944   JvmtiVMObjectAllocEventCollector oam;
1945 
1946   // Exclude primitive types and array types
1947   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1948       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1949     // Return empty array
1950     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1951     return (jobjectArray) JNIHandles::make_local(env, res);
1952   }
1953 
1954   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1976     }
1977   }
1978 
1979   // Allocate result
1980   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1981   objArrayHandle result (THREAD, r);
1982 
1983   // Now just put the methods that we selected above, but go by their idnum
1984   // in case of redefinition.  The methods can be redefined at any safepoint,
1985   // so above when allocating the oop array and below when creating reflect
1986   // objects.
1987   for (int i = 0; i &lt; num_methods; i++) {
1988     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1989     if (method.is_null()) {
1990       // Method may have been deleted and seems this API can handle null
1991       // Otherwise should probably put a method that throws NSME
1992       result-&gt;obj_at_put(i, NULL);
1993     } else {
1994       oop m;
1995       if (want_constructor) {


1996         m = Reflection::new_constructor(method, CHECK_NULL);
1997       } else {
1998         m = Reflection::new_method(method, false, CHECK_NULL);
1999       }
2000       result-&gt;obj_at_put(i, m);
2001     }
2002   }
2003 
2004   return (jobjectArray) JNIHandles::make_local(env, result());
2005 }
2006 
2007 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2008 {
2009   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
2010   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2011                                            /*want_constructor*/ false,
2012                                            SystemDictionary::reflect_Method_klass(), THREAD);
2013 }
2014 JVM_END
2015 
</pre>
<hr />
<pre>
2206   constantTag tag = cp-&gt;tag_at(index);
2207   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2208     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2209   }
2210   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2211   Klass* k_o;
2212   if (force_resolution) {
2213     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2214   } else {
2215     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2216     if (k_o == NULL) return NULL;
2217   }
2218   InstanceKlass* k = InstanceKlass::cast(k_o);
2219   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2220   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2221   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2222   if (m.is_null()) {
2223     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2224   }
2225   oop method;
<span class="line-modified">2226   if (!m-&gt;is_initializer() || m-&gt;is_static()) {</span>
<span class="line-removed">2227     method = Reflection::new_method(m, true, CHECK_NULL);</span>
<span class="line-removed">2228   } else {</span>
2229     method = Reflection::new_constructor(m, CHECK_NULL);


2230   }
2231   return JNIHandles::make_local(method);
2232 }
2233 
2234 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2235 {
2236   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2237   JvmtiVMObjectAllocEventCollector oam;
2238   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2239   bounds_check(cp, index, CHECK_NULL);
2240   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2241   return res;
2242 }
2243 JVM_END
2244 
2245 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2246 {
2247   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2248   JvmtiVMObjectAllocEventCollector oam;
2249   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2497   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2498   if (!k-&gt;is_instance_klass()) return false;
2499 
2500   ResourceMark rm(THREAD);
2501   const char* name = k-&gt;name()-&gt;as_C_string();
2502   bool system_class = k-&gt;class_loader() == NULL;
2503   return JavaAssertions::enabled(name, system_class);
2504 
2505 JVM_END
2506 
2507 
2508 // Return a new AssertionStatusDirectives object with the fields filled in with
2509 // command-line assertion arguments (i.e., -ea, -da).
2510 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2511   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2512   JvmtiVMObjectAllocEventCollector oam;
2513   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2514   return JNIHandles::make_local(env, asd);
2515 JVM_END
2516 







































2517 // Verification ////////////////////////////////////////////////////////////////////////////////
2518 
2519 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2520 
2521 // RedefineClasses support: bug 6214132 caused verification to fail.
2522 // All functions from this section should call the jvmtiThreadSate function:
2523 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2524 // The function returns a Klass* of the _scratch_class if the verifier
2525 // was invoked in the middle of the class redefinition.
2526 // Otherwise it returns its argument value which is the _the_class Klass*.
2527 // Please, refer to the description in the jvmtiThreadSate.hpp.
2528 
2529 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2530   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2531   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2532   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2533   return k-&gt;name()-&gt;as_utf8();
2534 JVM_END
2535 
2536 
</pre>
<hr />
<pre>
2676   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2677   return method-&gt;size_of_parameters();
2678 JVM_END
2679 
2680 
2681 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2682   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2683   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2684   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2685   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2686   return method-&gt;verifier_max_stack();
2687 JVM_END
2688 
2689 
2690 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2691   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2692   ResourceMark rm(THREAD);
2693   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2694   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2695   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2696   return method-&gt;name() == vmSymbols::object_initializer_name();</span>
2697 JVM_END
2698 
2699 
2700 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2701   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2702   ResourceMark rm(THREAD);
2703   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2704   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2705   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2706   return method-&gt;is_overpass();
2707 JVM_END
2708 
2709 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2710   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2711   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2712   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2713   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2714   return method-&gt;name()-&gt;as_utf8();
2715 JVM_END
2716 
</pre>
<hr />
<pre>
3671   //   protection_domain. The protection_domain is passed as NULL by the java code
3672   //   if there is no security manager in 3-arg Class.forName().
3673   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3674 
3675   // Check if we should initialize the class
3676   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3677     klass-&gt;initialize(CHECK_NULL);
3678   }
3679   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3680 }
3681 
3682 
3683 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3684 
3685 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3686   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3687   Handle method_handle;
3688   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3689     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3690     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3691     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3692     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3693     jobject res = JNIHandles::make_local(env, result);
3694     if (JvmtiExport::should_post_vm_object_alloc()) {
3695       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3696       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3697       if (java_lang_Class::is_primitive(ret_type)) {
3698         // Only for primitive type vm allocates memory for java object.
3699         // See box() method.
3700         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3701       }
3702     }
3703     return res;
3704   } else {
3705     THROW_0(vmSymbols::java_lang_StackOverflowError());
3706   }
3707 JVM_END
3708 
3709 
3710 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3711   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);

3712   oop constructor_mirror = JNIHandles::resolve(c);
<span class="line-removed">3713   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3714   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3715   jobject res = JNIHandles::make_local(env, result);
3716   if (JvmtiExport::should_post_vm_object_alloc()) {
3717     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3718   }
3719   return res;
3720 JVM_END
3721 
3722 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3723 
3724 JVM_LEAF(jboolean, JVM_SupportsCX8())
3725   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3726   return VM_Version::supports_cx8();
3727 JVM_END
3728 
3729 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3730   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3731   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3732   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3733   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  58 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
  59 #include &quot;prims/jvm_misc.hpp&quot;
  60 #include &quot;prims/jvmtiExport.hpp&quot;
  61 #include &quot;prims/jvmtiThreadState.hpp&quot;
  62 #include &quot;prims/nativeLookup.hpp&quot;
  63 #include &quot;prims/stackwalk.hpp&quot;
  64 #include &quot;runtime/arguments.hpp&quot;
  65 #include &quot;runtime/atomic.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/init.hpp&quot;
  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  69 #include &quot;runtime/deoptimization.hpp&quot;
  70 #include &quot;runtime/handshake.hpp&quot;
  71 #include &quot;runtime/java.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/os.inline.hpp&quot;
  76 #include &quot;runtime/perfData.hpp&quot;
  77 #include &quot;runtime/reflection.hpp&quot;
  78 #include &quot;runtime/thread.inline.hpp&quot;
</pre>
<hr />
<pre>
 689   JVMWrapper(&quot;JVM_Clone&quot;);
 690   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 691   Klass* klass = obj-&gt;klass();
 692   JvmtiVMObjectAllocEventCollector oam;
 693 
 694 #ifdef ASSERT
 695   // Just checking that the cloneable flag is set correct
 696   if (obj-&gt;is_array()) {
 697     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 698   } else {
 699     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 700     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 701     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 702   }
 703 #endif
 704 
 705   // Check if class of obj supports the Cloneable interface.
 706   // All arrays are considered to be cloneable (See JLS 20.1.5).
 707   // All j.l.r.Reference classes are considered non-cloneable.
 708   if (!klass-&gt;is_cloneable() ||
<span class="line-added"> 709        klass-&gt;is_value() ||</span>
 710       (klass-&gt;is_instance_klass() &amp;&amp;
 711        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 712     ResourceMark rm(THREAD);
 713     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 714   }
 715 
 716   // Make shallow object copy
 717   const int size = obj-&gt;size();
 718   oop new_obj_oop = NULL;
 719   if (obj-&gt;is_array()) {
 720     const int length = ((arrayOop)obj())-&gt;length();
 721     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 722                                                    /* do_zero */ true, CHECK_NULL);
 723   } else {
 724     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 725   }
 726 
 727   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 728 
 729   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1274   return (jstring) JNIHandles::make_local(env, result);
1275 JVM_END
1276 
1277 
1278 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1279   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1280   JvmtiVMObjectAllocEventCollector oam;
1281   oop mirror = JNIHandles::resolve_non_null(cls);
1282 
1283   // Special handling for primitive objects
1284   if (java_lang_Class::is_primitive(mirror)) {
1285     // Primitive objects does not have any interfaces
1286     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1287     return (jobjectArray) JNIHandles::make_local(env, r);
1288   }
1289 
1290   Klass* klass = java_lang_Class::as_Klass(mirror);
1291   // Figure size of result array
1292   int size;
1293   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1294     InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-added">1295     size = ik-&gt;local_interfaces()-&gt;length();</span>
<span class="line-added">1296     if (ik-&gt;has_injected_identityObject()) {</span>
<span class="line-added">1297       size--;</span>
<span class="line-added">1298     }</span>
1299   } else {
1300     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1301     size = 3;</span>
1302   }
1303 
1304   // Allocate result array
1305   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1306   objArrayHandle result (THREAD, r);
1307   // Fill in result
1308   if (klass-&gt;is_instance_klass()) {
1309     // Regular instance klass, fill in all local interfaces
<span class="line-added">1310     int cursor = 0;</span>
1311     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1312       InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-modified">1313       Klass* k = ik-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-added">1314       if (!ik-&gt;has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">1315         result-&gt;obj_at_put(cursor++, k-&gt;java_mirror());</span>
<span class="line-added">1316       }</span>
1317     }
1318   } else {
<span class="line-modified">1319     // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject</span>
1320     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1321     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
<span class="line-added">1322     result-&gt;obj_at_put(2, SystemDictionary::IdentityObject_klass()-&gt;java_mirror());</span>
1323   }
1324   return (jobjectArray) JNIHandles::make_local(env, result());
1325 JVM_END
1326 
1327 
1328 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1329   JVMWrapper(&quot;JVM_IsInterface&quot;);
1330   oop mirror = JNIHandles::resolve_non_null(cls);
1331   if (java_lang_Class::is_primitive(mirror)) {
1332     return JNI_FALSE;
1333   }
1334   Klass* k = java_lang_Class::as_Klass(mirror);
1335   jboolean result = k-&gt;is_interface();
1336   assert(!result || k-&gt;is_instance_klass(),
1337          &quot;all interfaces are instance types&quot;);
1338   // The compiler intrinsic for isInterface tests the
1339   // Klass::_access_flags bits in the same way.
1340   return result;
1341 JVM_END
1342 
</pre>
<hr />
<pre>
1922         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1923       objArrayHandle components_h (THREAD, record_components);
1924 
1925       for (int x = 0; x &lt; length; x++) {
1926         RecordComponent* component = components-&gt;at(x);
1927         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1928         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1929         components_h-&gt;obj_at_put(x, component_oop);
1930       }
1931       return (jobjectArray)JNIHandles::make_local(components_h());
1932     }
1933   }
1934 
1935   // Return empty array if ofClass is not a record.
1936   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1937   return (jobjectArray)JNIHandles::make_local(env, result);
1938 }
1939 JVM_END
1940 
1941 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
<span class="line-added">1942   bool is_ctor = (method-&gt;is_object_constructor() ||</span>
<span class="line-added">1943                   method-&gt;is_static_init_factory());</span>
1944   if (want_constructor) {
<span class="line-modified">1945     return is_ctor;</span>
1946   } else {
<span class="line-modified">1947     return (!is_ctor &amp;&amp;</span>
<span class="line-added">1948             !method-&gt;is_class_initializer() &amp;&amp;</span>
<span class="line-added">1949             !method-&gt;is_overpass());</span>
1950   }
1951 }
1952 
1953 static jobjectArray get_class_declared_methods_helper(
1954                                   JNIEnv *env,
1955                                   jclass ofClass, jboolean publicOnly,
1956                                   bool want_constructor,
1957                                   Klass* klass, TRAPS) {
1958 
1959   JvmtiVMObjectAllocEventCollector oam;
1960 
1961   // Exclude primitive types and array types
1962   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1963       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1964     // Return empty array
1965     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1966     return (jobjectArray) JNIHandles::make_local(env, res);
1967   }
1968 
1969   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1991     }
1992   }
1993 
1994   // Allocate result
1995   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1996   objArrayHandle result (THREAD, r);
1997 
1998   // Now just put the methods that we selected above, but go by their idnum
1999   // in case of redefinition.  The methods can be redefined at any safepoint,
2000   // so above when allocating the oop array and below when creating reflect
2001   // objects.
2002   for (int i = 0; i &lt; num_methods; i++) {
2003     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
2004     if (method.is_null()) {
2005       // Method may have been deleted and seems this API can handle null
2006       // Otherwise should probably put a method that throws NSME
2007       result-&gt;obj_at_put(i, NULL);
2008     } else {
2009       oop m;
2010       if (want_constructor) {
<span class="line-added">2011         assert(method-&gt;is_object_constructor() ||</span>
<span class="line-added">2012                method-&gt;is_static_init_factory(), &quot;must be&quot;);</span>
2013         m = Reflection::new_constructor(method, CHECK_NULL);
2014       } else {
2015         m = Reflection::new_method(method, false, CHECK_NULL);
2016       }
2017       result-&gt;obj_at_put(i, m);
2018     }
2019   }
2020 
2021   return (jobjectArray) JNIHandles::make_local(env, result());
2022 }
2023 
2024 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2025 {
2026   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
2027   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2028                                            /*want_constructor*/ false,
2029                                            SystemDictionary::reflect_Method_klass(), THREAD);
2030 }
2031 JVM_END
2032 
</pre>
<hr />
<pre>
2223   constantTag tag = cp-&gt;tag_at(index);
2224   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2225     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2226   }
2227   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2228   Klass* k_o;
2229   if (force_resolution) {
2230     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2231   } else {
2232     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2233     if (k_o == NULL) return NULL;
2234   }
2235   InstanceKlass* k = InstanceKlass::cast(k_o);
2236   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2237   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2238   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2239   if (m.is_null()) {
2240     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2241   }
2242   oop method;
<span class="line-modified">2243   if (m-&gt;is_object_constructor()) {</span>


2244     method = Reflection::new_constructor(m, CHECK_NULL);
<span class="line-added">2245   } else {</span>
<span class="line-added">2246     method = Reflection::new_method(m, true, CHECK_NULL);</span>
2247   }
2248   return JNIHandles::make_local(method);
2249 }
2250 
2251 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2252 {
2253   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2254   JvmtiVMObjectAllocEventCollector oam;
2255   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2256   bounds_check(cp, index, CHECK_NULL);
2257   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2258   return res;
2259 }
2260 JVM_END
2261 
2262 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2263 {
2264   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2265   JvmtiVMObjectAllocEventCollector oam;
2266   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2514   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2515   if (!k-&gt;is_instance_klass()) return false;
2516 
2517   ResourceMark rm(THREAD);
2518   const char* name = k-&gt;name()-&gt;as_C_string();
2519   bool system_class = k-&gt;class_loader() == NULL;
2520   return JavaAssertions::enabled(name, system_class);
2521 
2522 JVM_END
2523 
2524 
2525 // Return a new AssertionStatusDirectives object with the fields filled in with
2526 // command-line assertion arguments (i.e., -ea, -da).
2527 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2528   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2529   JvmtiVMObjectAllocEventCollector oam;
2530   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2531   return JNIHandles::make_local(env, asd);
2532 JVM_END
2533 
<span class="line-added">2534 // Arrays support /////////////////////////////////////////////////////////////</span>
<span class="line-added">2535 </span>
<span class="line-added">2536 JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2537   JVMWrapper(&quot;JVM_ArrayIsAccessAtomic&quot;);</span>
<span class="line-added">2538   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2539   Klass* k = o-&gt;klass();</span>
<span class="line-added">2540   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2541     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2542   }</span>
<span class="line-added">2543   return ArrayKlass::cast(k)-&gt;element_access_is_atomic();</span>
<span class="line-added">2544 JVM_END</span>
<span class="line-added">2545 </span>
<span class="line-added">2546 JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2547   JVMWrapper(&quot;JVM_ArrayEnsureAccessAtomic&quot;);</span>
<span class="line-added">2548   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2549   Klass* k = o-&gt;klass();</span>
<span class="line-added">2550   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2551     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2552   }</span>
<span class="line-added">2553   if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added">2554     ValueArrayKlass* vk = ValueArrayKlass::cast(k);</span>
<span class="line-added">2555     if (!vk-&gt;element_access_is_atomic()) {</span>
<span class="line-added">2556       /**</span>
<span class="line-added">2557        * Need to decide how to implement:</span>
<span class="line-added">2558        *</span>
<span class="line-added">2559        * 1) Change to objArrayOop layout, therefore oop-&gt;klass() differs so</span>
<span class="line-added">2560        * then &quot;&lt;atomic&gt;[Qfoo;&quot; klass needs to subclass &quot;[Qfoo;&quot; to pass through</span>
<span class="line-added">2561        * &quot;checkcast&quot; &amp; &quot;instanceof&quot;</span>
<span class="line-added">2562        *</span>
<span class="line-added">2563        * 2) Use extra header in the valueArrayOop to flag atomicity required and</span>
<span class="line-added">2564        * possibly per instance lock structure. Said info, could be placed in</span>
<span class="line-added">2565        * &quot;trailer&quot; rather than disturb the current arrayOop</span>
<span class="line-added">2566        */</span>
<span class="line-added">2567       Unimplemented();</span>
<span class="line-added">2568     }</span>
<span class="line-added">2569   }</span>
<span class="line-added">2570   return array;</span>
<span class="line-added">2571 JVM_END</span>
<span class="line-added">2572 </span>
2573 // Verification ////////////////////////////////////////////////////////////////////////////////
2574 
2575 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2576 
2577 // RedefineClasses support: bug 6214132 caused verification to fail.
2578 // All functions from this section should call the jvmtiThreadSate function:
2579 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2580 // The function returns a Klass* of the _scratch_class if the verifier
2581 // was invoked in the middle of the class redefinition.
2582 // Otherwise it returns its argument value which is the _the_class Klass*.
2583 // Please, refer to the description in the jvmtiThreadSate.hpp.
2584 
2585 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2586   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2587   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2588   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2589   return k-&gt;name()-&gt;as_utf8();
2590 JVM_END
2591 
2592 
</pre>
<hr />
<pre>
2732   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2733   return method-&gt;size_of_parameters();
2734 JVM_END
2735 
2736 
2737 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2738   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2739   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2740   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2741   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2742   return method-&gt;verifier_max_stack();
2743 JVM_END
2744 
2745 
2746 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2747   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2748   ResourceMark rm(THREAD);
2749   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2750   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2751   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2752   return method-&gt;is_object_constructor();</span>
2753 JVM_END
2754 
2755 
2756 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2757   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2758   ResourceMark rm(THREAD);
2759   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2760   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2761   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2762   return method-&gt;is_overpass();
2763 JVM_END
2764 
2765 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2766   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2767   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2768   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2769   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2770   return method-&gt;name()-&gt;as_utf8();
2771 JVM_END
2772 
</pre>
<hr />
<pre>
3727   //   protection_domain. The protection_domain is passed as NULL by the java code
3728   //   if there is no security manager in 3-arg Class.forName().
3729   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3730 
3731   // Check if we should initialize the class
3732   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3733     klass-&gt;initialize(CHECK_NULL);
3734   }
3735   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3736 }
3737 
3738 
3739 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3740 
3741 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3742   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3743   Handle method_handle;
3744   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3745     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3746     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3747     objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3748     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3749     jobject res = JNIHandles::make_local(env, result);
3750     if (JvmtiExport::should_post_vm_object_alloc()) {
3751       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3752       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3753       if (java_lang_Class::is_primitive(ret_type)) {
3754         // Only for primitive type vm allocates memory for java object.
3755         // See box() method.
3756         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3757       }
3758     }
3759     return res;
3760   } else {
3761     THROW_0(vmSymbols::java_lang_StackOverflowError());
3762   }
3763 JVM_END
3764 
3765 
3766 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3767   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
<span class="line-added">3768   objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3769   oop constructor_mirror = JNIHandles::resolve(c);

3770   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3771   jobject res = JNIHandles::make_local(env, result);
3772   if (JvmtiExport::should_post_vm_object_alloc()) {
3773     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3774   }
3775   return res;
3776 JVM_END
3777 
3778 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3779 
3780 JVM_LEAF(jboolean, JVM_SupportsCX8())
3781   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3782   return VM_Version::supports_cx8();
3783 JVM_END
3784 
3785 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3786   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3787   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3788   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3789   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
</tr>
</table>
<center><a href="../opto/subtypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
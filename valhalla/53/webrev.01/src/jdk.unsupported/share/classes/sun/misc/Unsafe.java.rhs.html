<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.unsupported/share/classes/sun/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.misc;
  27 
  28 import jdk.internal.vm.annotation.ForceInline;
  29 import jdk.internal.misc.VM;
  30 import jdk.internal.reflect.CallerSensitive;
  31 import jdk.internal.reflect.Reflection;
  32 
  33 import java.lang.reflect.Field;
  34 import java.util.Set;
  35 
  36 
  37 /**
  38  * A collection of methods for performing low-level, unsafe operations.
  39  * Although the class and all methods are public, use of this class is
  40  * limited because only trusted code can obtain instances of it.
  41  *
  42  * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make sure
  43  * arguments are checked before methods of this class are
  44  * called. While some rudimentary checks are performed on the input,
  45  * the checks are best effort and when performance is an overriding
  46  * priority, as when methods of this class are optimized by the
  47  * runtime compiler, some or all checks (if any) may be elided. Hence,
  48  * the caller must not rely on the checks and corresponding
  49  * exceptions!
  50  *
  51  * @author John R. Rose
  52  * @see #getUnsafe
  53  */
  54 
  55 public final class Unsafe {
  56 
  57     static {
  58         Reflection.registerMethodsToFilter(Unsafe.class, Set.of(&quot;getUnsafe&quot;));
  59     }
  60 
  61     private Unsafe() {}
  62 
  63     private static final Unsafe theUnsafe = new Unsafe();
  64     private static final jdk.internal.misc.Unsafe theInternalUnsafe = jdk.internal.misc.Unsafe.getUnsafe();
  65 
  66     /**
  67      * Provides the caller with the capability of performing unsafe
  68      * operations.
  69      *
  70      * &lt;p&gt;The returned {@code Unsafe} object should be carefully guarded
  71      * by the caller, since it can be used to read and write data at arbitrary
  72      * memory addresses.  It must never be passed to untrusted code.
  73      *
  74      * &lt;p&gt;Most methods in this class are very low-level, and correspond to a
  75      * small number of hardware instructions (on typical machines).  Compilers
  76      * are encouraged to optimize these methods accordingly.
  77      *
  78      * &lt;p&gt;Here is a suggested idiom for using unsafe operations:
  79      *
  80      * &lt;pre&gt; {@code
  81      * class MyTrustedClass {
  82      *   private static final Unsafe unsafe = Unsafe.getUnsafe();
  83      *   ...
  84      *   private long myCountAddress = ...;
  85      *   public int getCount() { return unsafe.getByte(myCountAddress); }
  86      * }}&lt;/pre&gt;
  87      *
  88      * (It may assist compilers to make the local variable {@code final}.)
  89      *
  90      * @throws  SecurityException if the class loader of the caller
  91      *          class is not in the system domain in which all permissions
  92      *          are granted.
  93      */
  94     @CallerSensitive
  95     public static Unsafe getUnsafe() {
  96         Class&lt;?&gt; caller = Reflection.getCallerClass();
  97         if (!VM.isSystemDomainLoader(caller.getClassLoader()))
  98             throw new SecurityException(&quot;Unsafe&quot;);
  99         return theUnsafe;
 100     }
 101 
 102     /// peek and poke operations
 103     /// (compilers should optimize these to memory ops)
 104 
 105     // These work on object fields in the Java heap.
 106     // They will not work on elements of packed arrays.
 107 
 108     /**
 109      * Fetches a value from a given Java variable.
 110      * More specifically, fetches a field or array element within the given
 111      * object {@code o} at the given offset, or (if {@code o} is null)
 112      * from the memory address whose numerical value is the given offset.
 113      * &lt;p&gt;
 114      * The results are undefined unless one of the following cases is true:
 115      * &lt;ul&gt;
 116      * &lt;li&gt;The offset was obtained from {@link #objectFieldOffset} on
 117      * the {@link java.lang.reflect.Field} of some Java field and the object
 118      * referred to by {@code o} is of a class compatible with that
 119      * field&#39;s class.
 120      *
 121      * &lt;li&gt;The offset and object reference {@code o} (either null or
 122      * non-null) were both obtained via {@link #staticFieldOffset}
 123      * and {@link #staticFieldBase} (respectively) from the
 124      * reflective {@link Field} representation of some Java field.
 125      *
 126      * &lt;li&gt;The object referred to by {@code o} is an array, and the offset
 127      * is an integer of the form {@code B+N*S}, where {@code N} is
 128      * a valid index into the array, and {@code B} and {@code S} are
 129      * the values obtained by {@link #arrayBaseOffset} and {@link
 130      * #arrayIndexScale} (respectively) from the array&#39;s class.  The value
 131      * referred to is the {@code N}&lt;em&gt;th&lt;/em&gt; element of the array.
 132      *
 133      * &lt;/ul&gt;
 134      * &lt;p&gt;
 135      * If one of the above cases is true, the call references a specific Java
 136      * variable (field or array element).  However, the results are undefined
 137      * if that variable is not in fact of the type returned by this method.
 138      * &lt;p&gt;
 139      * This method refers to a variable by means of two parameters, and so
 140      * it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode
 141      * for Java variables.  When the object reference is null, this method
 142      * uses its offset as an absolute address.  This is similar in operation
 143      * to methods such as {@link #getInt(long)}, which provide (in effect) a
 144      * &lt;em&gt;single-register&lt;/em&gt; addressing mode for non-Java variables.
 145      * However, because Java variables may have a different layout in memory
 146      * from non-Java variables, programmers should not assume that these
 147      * two addressing modes are ever equivalent.  Also, programmers should
 148      * remember that offsets from the double-register addressing mode cannot
 149      * be portably confused with longs used in the single-register addressing
 150      * mode.
 151      *
 152      * @param o Java heap object in which the variable resides, if any, else
 153      *        null
 154      * @param offset indication of where the variable resides in a Java heap
 155      *        object, if any, else a memory address locating the variable
 156      *        statically
 157      * @return the value fetched from the indicated Java variable
 158      * @throws RuntimeException No defined exceptions are thrown, not even
 159      *         {@link NullPointerException}
 160      */
 161     @ForceInline
 162     public int getInt(Object o, long offset) {
 163         return theInternalUnsafe.getInt(o, offset);
 164     }
 165 
 166     /**
 167      * Stores a value into a given Java variable.
 168      * &lt;p&gt;
 169      * The first two parameters are interpreted exactly as with
 170      * {@link #getInt(Object, long)} to refer to a specific
 171      * Java variable (field or array element).  The given value
 172      * is stored into that variable.
 173      * &lt;p&gt;
 174      * The variable must be of the same type as the method
 175      * parameter {@code x}.
 176      *
 177      * @param o Java heap object in which the variable resides, if any, else
 178      *        null
 179      * @param offset indication of where the variable resides in a Java heap
 180      *        object, if any, else a memory address locating the variable
 181      *        statically
 182      * @param x the value to store into the indicated Java variable
 183      * @throws RuntimeException No defined exceptions are thrown, not even
 184      *         {@link NullPointerException}
 185      */
 186     @ForceInline
 187     public void putInt(Object o, long offset, int x) {
 188         theInternalUnsafe.putInt(o, offset, x);
 189     }
 190 
 191     /**
 192      * Fetches a reference value from a given Java variable.
 193      * @see #getInt(Object, long)
 194      */
 195     @ForceInline
 196     public Object getObject(Object o, long offset) {
 197         return theInternalUnsafe.getReference(o, offset);
 198     }
 199 
 200     /**
 201      * Stores a reference value into a given Java variable.
 202      * &lt;p&gt;
 203      * Unless the reference {@code x} being stored is either null
 204      * or matches the field type, the results are undefined.
 205      * If the reference {@code o} is non-null, card marks or
 206      * other store barriers for that object (if the VM requires them)
 207      * are updated.
 208      * @see #putInt(Object, long, int)
 209      */
 210     @ForceInline
 211     public void putObject(Object o, long offset, Object x) {
 212         theInternalUnsafe.putReference(o, offset, x);
 213     }
 214 
 215     /** @see #getInt(Object, long) */
 216     @ForceInline
 217     public boolean getBoolean(Object o, long offset) {
 218         return theInternalUnsafe.getBoolean(o, offset);
 219     }
 220 
 221     /** @see #putInt(Object, long, int) */
 222     @ForceInline
 223     public void putBoolean(Object o, long offset, boolean x) {
 224         theInternalUnsafe.putBoolean(o, offset, x);
 225     }
 226 
 227     /** @see #getInt(Object, long) */
 228     @ForceInline
 229     public byte getByte(Object o, long offset) {
 230         return theInternalUnsafe.getByte(o, offset);
 231     }
 232 
 233     /** @see #putInt(Object, long, int) */
 234     @ForceInline
 235     public void putByte(Object o, long offset, byte x) {
 236         theInternalUnsafe.putByte(o, offset, x);
 237     }
 238 
 239     /** @see #getInt(Object, long) */
 240     @ForceInline
 241     public short getShort(Object o, long offset) {
 242         return theInternalUnsafe.getShort(o, offset);
 243     }
 244 
 245     /** @see #putInt(Object, long, int) */
 246     @ForceInline
 247     public void putShort(Object o, long offset, short x) {
 248         theInternalUnsafe.putShort(o, offset, x);
 249     }
 250 
 251     /** @see #getInt(Object, long) */
 252     @ForceInline
 253     public char getChar(Object o, long offset) {
 254         return theInternalUnsafe.getChar(o, offset);
 255     }
 256 
 257     /** @see #putInt(Object, long, int) */
 258     @ForceInline
 259     public void putChar(Object o, long offset, char x) {
 260         theInternalUnsafe.putChar(o, offset, x);
 261     }
 262 
 263     /** @see #getInt(Object, long) */
 264     @ForceInline
 265     public long getLong(Object o, long offset) {
 266         return theInternalUnsafe.getLong(o, offset);
 267     }
 268 
 269     /** @see #putInt(Object, long, int) */
 270     @ForceInline
 271     public void putLong(Object o, long offset, long x) {
 272         theInternalUnsafe.putLong(o, offset, x);
 273     }
 274 
 275     /** @see #getInt(Object, long) */
 276     @ForceInline
 277     public float getFloat(Object o, long offset) {
 278         return theInternalUnsafe.getFloat(o, offset);
 279     }
 280 
 281     /** @see #putInt(Object, long, int) */
 282     @ForceInline
 283     public void putFloat(Object o, long offset, float x) {
 284         theInternalUnsafe.putFloat(o, offset, x);
 285     }
 286 
 287     /** @see #getInt(Object, long) */
 288     @ForceInline
 289     public double getDouble(Object o, long offset) {
 290         return theInternalUnsafe.getDouble(o, offset);
 291     }
 292 
 293     /** @see #putInt(Object, long, int) */
 294     @ForceInline
 295     public void putDouble(Object o, long offset, double x) {
 296         theInternalUnsafe.putDouble(o, offset, x);
 297     }
 298 
 299     // These work on values in the C heap.
 300 
 301     /**
 302      * Fetches a value from a given memory address.  If the address is zero, or
 303      * does not point into a block obtained from {@link #allocateMemory}, the
 304      * results are undefined.
 305      *
 306      * @see #allocateMemory
 307      */
 308     @ForceInline
 309     public byte getByte(long address) {
 310         return theInternalUnsafe.getByte(address);
 311     }
 312 
 313     /**
 314      * Stores a value into a given memory address.  If the address is zero, or
 315      * does not point into a block obtained from {@link #allocateMemory}, the
 316      * results are undefined.
 317      *
 318      * @see #getByte(long)
 319      */
 320     @ForceInline
 321     public void putByte(long address, byte x) {
 322         theInternalUnsafe.putByte(address, x);
 323     }
 324 
 325     /** @see #getByte(long) */
 326     @ForceInline
 327     public short getShort(long address) {
 328         return theInternalUnsafe.getShort(address);
 329     }
 330 
 331     /** @see #putByte(long, byte) */
 332     @ForceInline
 333     public void putShort(long address, short x) {
 334         theInternalUnsafe.putShort(address, x);
 335     }
 336 
 337     /** @see #getByte(long) */
 338     @ForceInline
 339     public char getChar(long address) {
 340         return theInternalUnsafe.getChar(address);
 341     }
 342 
 343     /** @see #putByte(long, byte) */
 344     @ForceInline
 345     public void putChar(long address, char x) {
 346         theInternalUnsafe.putChar(address, x);
 347     }
 348 
 349     /** @see #getByte(long) */
 350     @ForceInline
 351     public int getInt(long address) {
 352         return theInternalUnsafe.getInt(address);
 353     }
 354 
 355     /** @see #putByte(long, byte) */
 356     @ForceInline
 357     public void putInt(long address, int x) {
 358         theInternalUnsafe.putInt(address, x);
 359     }
 360 
 361     /** @see #getByte(long) */
 362     @ForceInline
 363     public long getLong(long address) {
 364         return theInternalUnsafe.getLong(address);
 365     }
 366 
 367     /** @see #putByte(long, byte) */
 368     @ForceInline
 369     public void putLong(long address, long x) {
 370         theInternalUnsafe.putLong(address, x);
 371     }
 372 
 373     /** @see #getByte(long) */
 374     @ForceInline
 375     public float getFloat(long address) {
 376         return theInternalUnsafe.getFloat(address);
 377     }
 378 
 379     /** @see #putByte(long, byte) */
 380     @ForceInline
 381     public void putFloat(long address, float x) {
 382         theInternalUnsafe.putFloat(address, x);
 383     }
 384 
 385     /** @see #getByte(long) */
 386     @ForceInline
 387     public double getDouble(long address) {
 388         return theInternalUnsafe.getDouble(address);
 389     }
 390 
 391     /** @see #putByte(long, byte) */
 392     @ForceInline
 393     public void putDouble(long address, double x) {
 394         theInternalUnsafe.putDouble(address, x);
 395     }
 396 
 397 
 398     /**
 399      * Fetches a native pointer from a given memory address.  If the address is
 400      * zero, or does not point into a block obtained from {@link
 401      * #allocateMemory}, the results are undefined.
 402      *
 403      * &lt;p&gt;If the native pointer is less than 64 bits wide, it is extended as
 404      * an unsigned number to a Java long.  The pointer may be indexed by any
 405      * given byte offset, simply by adding that offset (as a simple integer) to
 406      * the long representing the pointer.  The number of bytes actually read
 407      * from the target address may be determined by consulting {@link
 408      * #addressSize}.
 409      *
 410      * @see #allocateMemory
 411      */
 412     @ForceInline
 413     public long getAddress(long address) {
 414         return theInternalUnsafe.getAddress(address);
 415     }
 416 
 417     /**
 418      * Stores a native pointer into a given memory address.  If the address is
 419      * zero, or does not point into a block obtained from {@link
 420      * #allocateMemory}, the results are undefined.
 421      *
 422      * &lt;p&gt;The number of bytes actually written at the target address may be
 423      * determined by consulting {@link #addressSize}.
 424      *
 425      * @see #getAddress(long)
 426      */
 427     @ForceInline
 428     public void putAddress(long address, long x) {
 429         theInternalUnsafe.putAddress(address, x);
 430     }
 431 
 432 
 433     /// wrappers for malloc, realloc, free:
 434 
 435     /**
 436      * Allocates a new block of native memory, of the given size in bytes.  The
 437      * contents of the memory are uninitialized; they will generally be
 438      * garbage.  The resulting native pointer will never be zero, and will be
 439      * aligned for all value types.  Dispose of this memory by calling {@link
 440      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 441      *
 442      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 443      * sure arguments are checked before the methods are called. While
 444      * some rudimentary checks are performed on the input, the checks
 445      * are best effort and when performance is an overriding priority,
 446      * as when methods of this class are optimized by the runtime
 447      * compiler, some or all checks (if any) may be elided. Hence, the
 448      * caller must not rely on the checks and corresponding
 449      * exceptions!
 450      *
 451      * @throws RuntimeException if the size is negative or too large
 452      *         for the native size_t type
 453      *
 454      * @throws OutOfMemoryError if the allocation is refused by the system
 455      *
 456      * @see #getByte(long)
 457      * @see #putByte(long, byte)
 458      */
 459     @ForceInline
 460     public long allocateMemory(long bytes) {
 461         return theInternalUnsafe.allocateMemory(bytes);
 462     }
 463 
 464     /**
 465      * Resizes a new block of native memory, to the given size in bytes.  The
 466      * contents of the new block past the size of the old block are
 467      * uninitialized; they will generally be garbage.  The resulting native
 468      * pointer will be zero if and only if the requested size is zero.  The
 469      * resulting native pointer will be aligned for all value types.  Dispose
 470      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 471      * #reallocateMemory}.  The address passed to this method may be null, in
 472      * which case an allocation will be performed.
 473      *
 474      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 475      * sure arguments are checked before the methods are called. While
 476      * some rudimentary checks are performed on the input, the checks
 477      * are best effort and when performance is an overriding priority,
 478      * as when methods of this class are optimized by the runtime
 479      * compiler, some or all checks (if any) may be elided. Hence, the
 480      * caller must not rely on the checks and corresponding
 481      * exceptions!
 482      *
 483      * @throws RuntimeException if the size is negative or too large
 484      *         for the native size_t type
 485      *
 486      * @throws OutOfMemoryError if the allocation is refused by the system
 487      *
 488      * @see #allocateMemory
 489      */
 490     @ForceInline
 491     public long reallocateMemory(long address, long bytes) {
 492         return theInternalUnsafe.reallocateMemory(address, bytes);
 493     }
 494 
 495     /**
 496      * Sets all bytes in a given block of memory to a fixed value
 497      * (usually zero).
 498      *
 499      * &lt;p&gt;This method determines a block&#39;s base address by means of two parameters,
 500      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 501      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 502      * the offset supplies an absolute base address.
 503      *
 504      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 505      * by the address and length parameters.  If the effective address and
 506      * length are all even modulo 8, the stores take place in &#39;long&#39; units.
 507      * If the effective address and length are (resp.) even modulo 4 or 2,
 508      * the stores take place in units of &#39;int&#39; or &#39;short&#39;.
 509      *
 510      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 511      * sure arguments are checked before the methods are called. While
 512      * some rudimentary checks are performed on the input, the checks
 513      * are best effort and when performance is an overriding priority,
 514      * as when methods of this class are optimized by the runtime
 515      * compiler, some or all checks (if any) may be elided. Hence, the
 516      * caller must not rely on the checks and corresponding
 517      * exceptions!
 518      *
 519      * @throws RuntimeException if any of the arguments is invalid
 520      *
 521      * @since 1.7
 522      */
 523     @ForceInline
 524     public void setMemory(Object o, long offset, long bytes, byte value) {
 525         theInternalUnsafe.setMemory(o, offset, bytes, value);
 526     }
 527 
 528     /**
 529      * Sets all bytes in a given block of memory to a fixed value
 530      * (usually zero).  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 531      * as discussed in {@link #getInt(Object,long)}.
 532      *
 533      * &lt;p&gt;Equivalent to {@code setMemory(null, address, bytes, value)}.
 534      */
 535     @ForceInline
 536     public void setMemory(long address, long bytes, byte value) {
 537         theInternalUnsafe.setMemory(address, bytes, value);
 538     }
 539 
 540     /**
 541      * Sets all bytes in a given block of memory to a copy of another
 542      * block.
 543      *
 544      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 545      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 546      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 547      * the offset supplies an absolute base address.
 548      *
 549      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 550      * by the address and length parameters.  If the effective addresses and
 551      * length are all even modulo 8, the transfer takes place in &#39;long&#39; units.
 552      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 553      * the transfer takes place in units of &#39;int&#39; or &#39;short&#39;.
 554      *
 555      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 556      * sure arguments are checked before the methods are called. While
 557      * some rudimentary checks are performed on the input, the checks
 558      * are best effort and when performance is an overriding priority,
 559      * as when methods of this class are optimized by the runtime
 560      * compiler, some or all checks (if any) may be elided. Hence, the
 561      * caller must not rely on the checks and corresponding
 562      * exceptions!
 563      *
 564      * @throws RuntimeException if any of the arguments is invalid
 565      *
 566      * @since 1.7
 567      */
 568     @ForceInline
 569     public void copyMemory(Object srcBase, long srcOffset,
 570                            Object destBase, long destOffset,
 571                            long bytes) {
 572         theInternalUnsafe.copyMemory(srcBase, srcOffset, destBase, destOffset, bytes);
 573     }
 574 
 575     /**
 576      * Sets all bytes in a given block of memory to a copy of another
 577      * block.  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 578      * as discussed in {@link #getInt(Object,long)}.
 579      *
 580      * Equivalent to {@code copyMemory(null, srcAddress, null, destAddress, bytes)}.
 581      */
 582     @ForceInline
 583     public void copyMemory(long srcAddress, long destAddress, long bytes) {
 584         theInternalUnsafe.copyMemory(srcAddress, destAddress, bytes);
 585     }
 586 
 587     /**
 588      * Disposes of a block of native memory, as obtained from {@link
 589      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 590      * this method may be null, in which case no action is taken.
 591      *
 592      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 593      * sure arguments are checked before the methods are called. While
 594      * some rudimentary checks are performed on the input, the checks
 595      * are best effort and when performance is an overriding priority,
 596      * as when methods of this class are optimized by the runtime
 597      * compiler, some or all checks (if any) may be elided. Hence, the
 598      * caller must not rely on the checks and corresponding
 599      * exceptions!
 600      *
 601      * @throws RuntimeException if any of the arguments is invalid
 602      *
 603      * @see #allocateMemory
 604      */
 605     @ForceInline
 606     public void freeMemory(long address) {
 607         theInternalUnsafe.freeMemory(address);
 608     }
 609 
 610     /// random queries
 611 
 612     /**
 613      * This constant differs from all results that will ever be returned from
 614      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
 615      * or {@link #arrayBaseOffset}.
 616      */
 617     public static final int INVALID_FIELD_OFFSET = jdk.internal.misc.Unsafe.INVALID_FIELD_OFFSET;
 618 
 619     /**
 620      * Reports the location of a given field in the storage allocation of its
 621      * class.  Do not expect to perform any sort of arithmetic on this offset;
 622      * it is just a cookie which is passed to the unsafe heap memory accessors.
 623      *
 624      * &lt;p&gt;Any given field will always have the same offset and base, and no
 625      * two distinct fields of the same class will ever have the same offset
 626      * and base.
 627      *
 628      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 629      * although the Sun JVM does not use the most significant 32 bits.
 630      * However, JVM implementations which store static fields at absolute
 631      * addresses can use long offsets and null base pointers to express
 632      * the field locations in a form usable by {@link #getInt(Object,long)}.
 633      * Therefore, code which will be ported to such JVMs on 64-bit platforms
 634      * must preserve all bits of static field offsets.
 635      * @see #getInt(Object, long)
 636      */
 637     @ForceInline
 638     public long objectFieldOffset(Field f) {
<a name="1" id="anc1"></a><span class="line-added"> 639         if (f == null) {</span>
<span class="line-added"> 640             throw new NullPointerException();</span>
<span class="line-added"> 641         }</span>
<span class="line-added"> 642         if (f.getDeclaringClass().isInlineClass()) {</span>
<span class="line-added"> 643             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on an inline class: &quot; + f);</span>
<span class="line-added"> 644         }</span>
 645         return theInternalUnsafe.objectFieldOffset(f);
 646     }
 647 
 648     /**
 649      * Reports the location of a given static field, in conjunction with {@link
 650      * #staticFieldBase}.
 651      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
 652      * it is just a cookie which is passed to the unsafe heap memory accessors.
 653      *
 654      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
 655      * fields of the same class will ever have the same offset.
 656      *
 657      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 658      * although the Sun JVM does not use the most significant 32 bits.
 659      * It is hard to imagine a JVM technology which needs more than
 660      * a few bits to encode an offset within a non-array object,
 661      * However, for consistency with other methods in this class,
 662      * this method reports its result as a long value.
 663      * @see #getInt(Object, long)
 664      */
 665     @ForceInline
 666     public long staticFieldOffset(Field f) {
<a name="2" id="anc2"></a><span class="line-added"> 667         if (f == null) {</span>
<span class="line-added"> 668             throw new NullPointerException();</span>
<span class="line-added"> 669         }</span>
<span class="line-added"> 670         if (f.getDeclaringClass().isInlineClass()) {</span>
<span class="line-added"> 671             throw new UnsupportedOperationException(&quot;can&#39;t get static field offset on an inline class: &quot; + f);</span>
<span class="line-added"> 672         }</span>
 673         return theInternalUnsafe.staticFieldOffset(f);
 674     }
 675 
 676     /**
 677      * Reports the location of a given static field, in conjunction with {@link
 678      * #staticFieldOffset}.
 679      * &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
 680      * given class can be accessed via methods like {@link #getInt(Object,
 681      * long)}.  This value may be null.  This value may refer to an object
 682      * which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
 683      * not be used in any way except as argument to the get and put routines in
 684      * this class.
 685      */
 686     @ForceInline
 687     public Object staticFieldBase(Field f) {
<a name="3" id="anc3"></a><span class="line-added"> 688         if (f == null) {</span>
<span class="line-added"> 689             throw new NullPointerException();</span>
<span class="line-added"> 690         }</span>
<span class="line-added"> 691         if (f.getDeclaringClass().isInlineClass()) {</span>
<span class="line-added"> 692             throw new UnsupportedOperationException(&quot;can&#39;t get base address on an inline class: &quot; + f);</span>
<span class="line-added"> 693         }</span>
 694         return theInternalUnsafe.staticFieldBase(f);
 695     }
 696 
 697     /**
 698      * Detects if the given class may need to be initialized. This is often
 699      * needed in conjunction with obtaining the static field base of a
 700      * class.
 701      * @return false only if a call to {@code ensureClassInitialized} would have no effect
 702      */
 703     @ForceInline
 704     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
 705         return theInternalUnsafe.shouldBeInitialized(c);
 706     }
 707 
 708     /**
 709      * Ensures the given class has been initialized. This is often
 710      * needed in conjunction with obtaining the static field base of a
 711      * class.
 712      */
 713     @ForceInline
 714     public void ensureClassInitialized(Class&lt;?&gt; c) {
 715         theInternalUnsafe.ensureClassInitialized(c);
 716     }
 717 
 718     /**
 719      * Reports the offset of the first element in the storage allocation of a
 720      * given array class.  If {@link #arrayIndexScale} returns a non-zero value
 721      * for the same class, you may use that scale factor, together with this
 722      * base offset, to form new offsets to access elements of arrays of the
 723      * given class.
 724      *
 725      * @see #getInt(Object, long)
 726      * @see #putInt(Object, long, int)
 727      */
 728     @ForceInline
 729     public int arrayBaseOffset(Class&lt;?&gt; arrayClass) {
 730         return theInternalUnsafe.arrayBaseOffset(arrayClass);
 731     }
 732 
 733     /** The value of {@code arrayBaseOffset(boolean[].class)} */
 734     public static final int ARRAY_BOOLEAN_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;
 735 
 736     /** The value of {@code arrayBaseOffset(byte[].class)} */
 737     public static final int ARRAY_BYTE_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;
 738 
 739     /** The value of {@code arrayBaseOffset(short[].class)} */
 740     public static final int ARRAY_SHORT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_SHORT_BASE_OFFSET;
 741 
 742     /** The value of {@code arrayBaseOffset(char[].class)} */
 743     public static final int ARRAY_CHAR_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_CHAR_BASE_OFFSET;
 744 
 745     /** The value of {@code arrayBaseOffset(int[].class)} */
 746     public static final int ARRAY_INT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_INT_BASE_OFFSET;
 747 
 748     /** The value of {@code arrayBaseOffset(long[].class)} */
 749     public static final int ARRAY_LONG_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_LONG_BASE_OFFSET;
 750 
 751     /** The value of {@code arrayBaseOffset(float[].class)} */
 752     public static final int ARRAY_FLOAT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_FLOAT_BASE_OFFSET;
 753 
 754     /** The value of {@code arrayBaseOffset(double[].class)} */
 755     public static final int ARRAY_DOUBLE_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_DOUBLE_BASE_OFFSET;
 756 
 757     /** The value of {@code arrayBaseOffset(Object[].class)} */
 758     public static final int ARRAY_OBJECT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_OBJECT_BASE_OFFSET;
 759 
 760     /**
 761      * Reports the scale factor for addressing elements in the storage
 762      * allocation of a given array class.  However, arrays of &quot;narrow&quot; types
 763      * will generally not work properly with accessors like {@link
 764      * #getByte(Object, long)}, so the scale factor for such classes is reported
 765      * as zero.
 766      *
 767      * @see #arrayBaseOffset
 768      * @see #getInt(Object, long)
 769      * @see #putInt(Object, long, int)
 770      */
 771     @ForceInline
 772     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
 773         return theInternalUnsafe.arrayIndexScale(arrayClass);
 774     }
 775 
 776     /** The value of {@code arrayIndexScale(boolean[].class)} */
 777     public static final int ARRAY_BOOLEAN_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_BOOLEAN_INDEX_SCALE;
 778 
 779     /** The value of {@code arrayIndexScale(byte[].class)} */
 780     public static final int ARRAY_BYTE_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_BYTE_INDEX_SCALE;
 781 
 782     /** The value of {@code arrayIndexScale(short[].class)} */
 783     public static final int ARRAY_SHORT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_SHORT_INDEX_SCALE;
 784 
 785     /** The value of {@code arrayIndexScale(char[].class)} */
 786     public static final int ARRAY_CHAR_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_CHAR_INDEX_SCALE;
 787 
 788     /** The value of {@code arrayIndexScale(int[].class)} */
 789     public static final int ARRAY_INT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_INT_INDEX_SCALE;
 790 
 791     /** The value of {@code arrayIndexScale(long[].class)} */
 792     public static final int ARRAY_LONG_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_LONG_INDEX_SCALE;
 793 
 794     /** The value of {@code arrayIndexScale(float[].class)} */
 795     public static final int ARRAY_FLOAT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_FLOAT_INDEX_SCALE;
 796 
 797     /** The value of {@code arrayIndexScale(double[].class)} */
 798     public static final int ARRAY_DOUBLE_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_DOUBLE_INDEX_SCALE;
 799 
 800     /** The value of {@code arrayIndexScale(Object[].class)} */
 801     public static final int ARRAY_OBJECT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_OBJECT_INDEX_SCALE;
 802 
 803     /**
 804      * Reports the size in bytes of a native pointer, as stored via {@link
 805      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
 806      * other primitive types (as stored in native memory blocks) is determined
 807      * fully by their information content.
 808      */
 809     @ForceInline
 810     public int addressSize() {
 811         return theInternalUnsafe.addressSize();
 812     }
 813 
 814     /** The value of {@code addressSize()} */
 815     public static final int ADDRESS_SIZE = theInternalUnsafe.addressSize();
 816 
 817     /**
 818      * Reports the size in bytes of a native memory page (whatever that is).
 819      * This value will always be a power of two.
 820      */
 821     @ForceInline
 822     public int pageSize() {
 823         return theInternalUnsafe.pageSize();
 824     }
 825 
 826 
 827     /// random trusted operations from JNI:
 828 
 829     /**
 830      * Defines a class but does not make it known to the class loader or system dictionary.
 831      * &lt;p&gt;
 832      * For each CP entry, the corresponding CP patch must either be null or have
 833      * the a format that matches its tag:
 834      * &lt;ul&gt;
 835      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
 836      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
 837      * &lt;li&gt;Class: any java.lang.Class object
 838      * &lt;li&gt;String: any object (not just a java.lang.String)
 839      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site&#39;s arguments
 840      * &lt;/ul&gt;
 841      * @param hostClass context for linkage, access control, protection domain, and class loader
 842      * @param data      bytes of a class file
 843      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
 844      */
 845     @ForceInline
 846     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
 847         return theInternalUnsafe.defineAnonymousClass(hostClass, data, cpPatches);
 848     }
 849 
 850     /**
 851      * Allocates an instance but does not run any constructor.
 852      * Initializes the class if it has not yet been.
 853      */
 854     @ForceInline
 855     public Object allocateInstance(Class&lt;?&gt; cls)
 856         throws InstantiationException {
 857         return theInternalUnsafe.allocateInstance(cls);
 858     }
 859 
 860     /** Throws the exception without telling the verifier. */
 861     @ForceInline
 862     public void throwException(Throwable ee) {
 863         theInternalUnsafe.throwException(ee);
 864     }
 865 
 866     /**
 867      * Atomically updates Java variable to {@code x} if it is currently
 868      * holding {@code expected}.
 869      *
 870      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 871      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 872      *
 873      * @return {@code true} if successful
 874      */
 875     @ForceInline
 876     public final boolean compareAndSwapObject(Object o, long offset,
 877                                               Object expected,
 878                                               Object x) {
 879         return theInternalUnsafe.compareAndSetReference(o, offset, expected, x);
 880     }
 881 
 882     /**
 883      * Atomically updates Java variable to {@code x} if it is currently
 884      * holding {@code expected}.
 885      *
 886      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 887      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 888      *
 889      * @return {@code true} if successful
 890      */
 891     @ForceInline
 892     public final boolean compareAndSwapInt(Object o, long offset,
 893                                            int expected,
 894                                            int x) {
 895         return theInternalUnsafe.compareAndSetInt(o, offset, expected, x);
 896     }
 897 
 898     /**
 899      * Atomically updates Java variable to {@code x} if it is currently
 900      * holding {@code expected}.
 901      *
 902      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 903      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 904      *
 905      * @return {@code true} if successful
 906      */
 907     @ForceInline
 908     public final boolean compareAndSwapLong(Object o, long offset,
 909                                             long expected,
 910                                             long x) {
 911         return theInternalUnsafe.compareAndSetLong(o, offset, expected, x);
 912     }
 913 
 914     /**
 915      * Fetches a reference value from a given Java variable, with volatile
 916      * load semantics. Otherwise identical to {@link #getObject(Object, long)}
 917      */
 918     @ForceInline
 919     public Object getObjectVolatile(Object o, long offset) {
 920         return theInternalUnsafe.getReferenceVolatile(o, offset);
 921     }
 922 
 923     /**
 924      * Stores a reference value into a given Java variable, with
 925      * volatile store semantics. Otherwise identical to {@link #putObject(Object, long, Object)}
 926      */
 927     @ForceInline
 928     public void putObjectVolatile(Object o, long offset, Object x) {
 929         theInternalUnsafe.putReferenceVolatile(o, offset, x);
 930     }
 931 
 932     /** Volatile version of {@link #getInt(Object, long)}  */
 933     @ForceInline
 934     public int getIntVolatile(Object o, long offset) {
 935         return theInternalUnsafe.getIntVolatile(o, offset);
 936     }
 937 
 938     /** Volatile version of {@link #putInt(Object, long, int)}  */
 939     @ForceInline
 940     public void putIntVolatile(Object o, long offset, int x) {
 941         theInternalUnsafe.putIntVolatile(o, offset, x);
 942     }
 943 
 944     /** Volatile version of {@link #getBoolean(Object, long)}  */
 945     @ForceInline
 946     public boolean getBooleanVolatile(Object o, long offset) {
 947         return theInternalUnsafe.getBooleanVolatile(o, offset);
 948     }
 949 
 950     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
 951     @ForceInline
 952     public void putBooleanVolatile(Object o, long offset, boolean x) {
 953         theInternalUnsafe.putBooleanVolatile(o, offset, x);
 954     }
 955 
 956     /** Volatile version of {@link #getByte(Object, long)}  */
 957     @ForceInline
 958     public byte getByteVolatile(Object o, long offset) {
 959         return theInternalUnsafe.getByteVolatile(o, offset);
 960     }
 961 
 962     /** Volatile version of {@link #putByte(Object, long, byte)}  */
 963     @ForceInline
 964     public void putByteVolatile(Object o, long offset, byte x) {
 965         theInternalUnsafe.putByteVolatile(o, offset, x);
 966     }
 967 
 968     /** Volatile version of {@link #getShort(Object, long)}  */
 969     @ForceInline
 970     public short getShortVolatile(Object o, long offset) {
 971         return theInternalUnsafe.getShortVolatile(o, offset);
 972     }
 973 
 974     /** Volatile version of {@link #putShort(Object, long, short)}  */
 975     @ForceInline
 976     public void putShortVolatile(Object o, long offset, short x) {
 977         theInternalUnsafe.putShortVolatile(o, offset, x);
 978     }
 979 
 980     /** Volatile version of {@link #getChar(Object, long)}  */
 981     @ForceInline
 982     public char getCharVolatile(Object o, long offset) {
 983         return theInternalUnsafe.getCharVolatile(o, offset);
 984     }
 985 
 986     /** Volatile version of {@link #putChar(Object, long, char)}  */
 987     @ForceInline
 988     public void putCharVolatile(Object o, long offset, char x) {
 989         theInternalUnsafe.putCharVolatile(o, offset, x);
 990     }
 991 
 992     /** Volatile version of {@link #getLong(Object, long)}  */
 993     @ForceInline
 994     public long getLongVolatile(Object o, long offset) {
 995         return theInternalUnsafe.getLongVolatile(o, offset);
 996     }
 997 
 998     /** Volatile version of {@link #putLong(Object, long, long)}  */
 999     @ForceInline
1000     public void putLongVolatile(Object o, long offset, long x) {
1001         theInternalUnsafe.putLongVolatile(o, offset, x);
1002     }
1003 
1004     /** Volatile version of {@link #getFloat(Object, long)}  */
1005     @ForceInline
1006     public float getFloatVolatile(Object o, long offset) {
1007         return theInternalUnsafe.getFloatVolatile(o, offset);
1008     }
1009 
1010     /** Volatile version of {@link #putFloat(Object, long, float)}  */
1011     @ForceInline
1012     public void putFloatVolatile(Object o, long offset, float x) {
1013         theInternalUnsafe.putFloatVolatile(o, offset, x);
1014     }
1015 
1016     /** Volatile version of {@link #getDouble(Object, long)}  */
1017     @ForceInline
1018     public double getDoubleVolatile(Object o, long offset) {
1019         return theInternalUnsafe.getDoubleVolatile(o, offset);
1020     }
1021 
1022     /** Volatile version of {@link #putDouble(Object, long, double)}  */
1023     @ForceInline
1024     public void putDoubleVolatile(Object o, long offset, double x) {
1025         theInternalUnsafe.putDoubleVolatile(o, offset, x);
1026     }
1027 
1028     /**
1029      * Version of {@link #putObjectVolatile(Object, long, Object)}
1030      * that does not guarantee immediate visibility of the store to
1031      * other threads. This method is generally only useful if the
1032      * underlying field is a Java volatile (or if an array cell, one
1033      * that is otherwise only accessed using volatile accesses).
1034      *
1035      * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
1036      */
1037     @ForceInline
1038     public void putOrderedObject(Object o, long offset, Object x) {
1039         theInternalUnsafe.putReferenceRelease(o, offset, x);
1040     }
1041 
1042     /** Ordered/Lazy version of {@link #putIntVolatile(Object, long, int)}  */
1043     @ForceInline
1044     public void putOrderedInt(Object o, long offset, int x) {
1045         theInternalUnsafe.putIntRelease(o, offset, x);
1046     }
1047 
1048     /** Ordered/Lazy version of {@link #putLongVolatile(Object, long, long)} */
1049     @ForceInline
1050     public void putOrderedLong(Object o, long offset, long x) {
1051         theInternalUnsafe.putLongRelease(o, offset, x);
1052     }
1053 
1054     /**
1055      * Unblocks the given thread blocked on {@code park}, or, if it is
1056      * not blocked, causes the subsequent call to {@code park} not to
1057      * block.  Note: this operation is &quot;unsafe&quot; solely because the
1058      * caller must somehow ensure that the thread has not been
1059      * destroyed. Nothing special is usually required to ensure this
1060      * when called from Java (in which there will ordinarily be a live
1061      * reference to the thread) but this is not nearly-automatically
1062      * so when calling from native code.
1063      *
1064      * @param thread the thread to unpark.
1065      */
1066     @ForceInline
1067     public void unpark(Object thread) {
1068         theInternalUnsafe.unpark(thread);
1069     }
1070 
1071     /**
1072      * Blocks current thread, returning when a balancing
1073      * {@code unpark} occurs, or a balancing {@code unpark} has
1074      * already occurred, or the thread is interrupted, or, if not
1075      * absolute and time is not zero, the given time nanoseconds have
1076      * elapsed, or if absolute, the given deadline in milliseconds
1077      * since Epoch has passed, or spuriously (i.e., returning for no
1078      * &quot;reason&quot;). Note: This operation is in the Unsafe class only
1079      * because {@code unpark} is, so it would be strange to place it
1080      * elsewhere.
1081      */
1082     @ForceInline
1083     public void park(boolean isAbsolute, long time) {
1084         theInternalUnsafe.park(isAbsolute, time);
1085     }
1086 
1087     /**
1088      * Gets the load average in the system run queue assigned
1089      * to the available processors averaged over various periods of time.
1090      * This method retrieves the given {@code nelem} samples and
1091      * assigns to the elements of the given {@code loadavg} array.
1092      * The system imposes a maximum of 3 samples, representing
1093      * averages over the last 1,  5,  and  15 minutes, respectively.
1094      *
1095      * @param loadavg an array of double of size nelems
1096      * @param nelems the number of samples to be retrieved and
1097      *        must be 1 to 3.
1098      *
1099      * @return the number of samples actually retrieved; or -1
1100      *         if the load average is unobtainable.
1101      */
1102     @ForceInline
1103     public int getLoadAverage(double[] loadavg, int nelems) {
1104         return theInternalUnsafe.getLoadAverage(loadavg, nelems);
1105     }
1106 
1107     // The following contain CAS-based Java implementations used on
1108     // platforms not supporting native instructions
1109 
1110     /**
1111      * Atomically adds the given value to the current value of a field
1112      * or array element within the given object {@code o}
1113      * at the given {@code offset}.
1114      *
1115      * @param o object/array to update the field/element in
1116      * @param offset field/element offset
1117      * @param delta the value to add
1118      * @return the previous value
1119      * @since 1.8
1120      */
1121     @ForceInline
1122     public final int getAndAddInt(Object o, long offset, int delta) {
1123         return theInternalUnsafe.getAndAddInt(o, offset, delta);
1124     }
1125 
1126     /**
1127      * Atomically adds the given value to the current value of a field
1128      * or array element within the given object {@code o}
1129      * at the given {@code offset}.
1130      *
1131      * @param o object/array to update the field/element in
1132      * @param offset field/element offset
1133      * @param delta the value to add
1134      * @return the previous value
1135      * @since 1.8
1136      */
1137     @ForceInline
1138     public final long getAndAddLong(Object o, long offset, long delta) {
1139         return theInternalUnsafe.getAndAddLong(o, offset, delta);
1140     }
1141 
1142     /**
1143      * Atomically exchanges the given value with the current value of
1144      * a field or array element within the given object {@code o}
1145      * at the given {@code offset}.
1146      *
1147      * @param o object/array to update the field/element in
1148      * @param offset field/element offset
1149      * @param newValue new value
1150      * @return the previous value
1151      * @since 1.8
1152      */
1153     @ForceInline
1154     public final int getAndSetInt(Object o, long offset, int newValue) {
1155         return theInternalUnsafe.getAndSetInt(o, offset, newValue);
1156     }
1157 
1158     /**
1159      * Atomically exchanges the given value with the current value of
1160      * a field or array element within the given object {@code o}
1161      * at the given {@code offset}.
1162      *
1163      * @param o object/array to update the field/element in
1164      * @param offset field/element offset
1165      * @param newValue new value
1166      * @return the previous value
1167      * @since 1.8
1168      */
1169     @ForceInline
1170     public final long getAndSetLong(Object o, long offset, long newValue) {
1171         return theInternalUnsafe.getAndSetLong(o, offset, newValue);
1172     }
1173 
1174     /**
1175      * Atomically exchanges the given reference value with the current
1176      * reference value of a field or array element within the given
1177      * object {@code o} at the given {@code offset}.
1178      *
1179      * @param o object/array to update the field/element in
1180      * @param offset field/element offset
1181      * @param newValue new value
1182      * @return the previous value
1183      * @since 1.8
1184      */
1185     @ForceInline
1186     public final Object getAndSetObject(Object o, long offset, Object newValue) {
1187         return theInternalUnsafe.getAndSetReference(o, offset, newValue);
1188     }
1189 
1190 
1191     /**
1192      * Ensures that loads before the fence will not be reordered with loads and
1193      * stores after the fence; a &quot;LoadLoad plus LoadStore barrier&quot;.
1194      *
1195      * Corresponds to C11 atomic_thread_fence(memory_order_acquire)
1196      * (an &quot;acquire fence&quot;).
1197      *
1198      * A pure LoadLoad fence is not provided, since the addition of LoadStore
1199      * is almost always desired, and most current hardware instructions that
1200      * provide a LoadLoad barrier also provide a LoadStore barrier for free.
1201      * @since 1.8
1202      */
1203     @ForceInline
1204     public void loadFence() {
1205         theInternalUnsafe.loadFence();
1206     }
1207 
1208     /**
1209      * Ensures that loads and stores before the fence will not be reordered with
1210      * stores after the fence; a &quot;StoreStore plus LoadStore barrier&quot;.
1211      *
1212      * Corresponds to C11 atomic_thread_fence(memory_order_release)
1213      * (a &quot;release fence&quot;).
1214      *
1215      * A pure StoreStore fence is not provided, since the addition of LoadStore
1216      * is almost always desired, and most current hardware instructions that
1217      * provide a StoreStore barrier also provide a LoadStore barrier for free.
1218      * @since 1.8
1219      */
1220     @ForceInline
1221     public void storeFence() {
1222         theInternalUnsafe.storeFence();
1223     }
1224 
1225     /**
1226      * Ensures that loads and stores before the fence will not be reordered
1227      * with loads and stores after the fence.  Implies the effects of both
1228      * loadFence() and storeFence(), and in addition, the effect of a StoreLoad
1229      * barrier.
1230      *
1231      * Corresponds to C11 atomic_thread_fence(memory_order_seq_cst).
1232      * @since 1.8
1233      */
1234     @ForceInline
1235     public void fullFence() {
1236         theInternalUnsafe.fullFence();
1237     }
1238 
1239     /**
1240      * Invokes the given direct byte buffer&#39;s cleaner, if any.
1241      *
1242      * @param directBuffer a direct byte buffer
1243      * @throws NullPointerException if {@code directBuffer} is null
1244      * @throws IllegalArgumentException if {@code directBuffer} is non-direct,
1245      * or is a {@link java.nio.Buffer#slice slice}, or is a
1246      * {@link java.nio.Buffer#duplicate duplicate}
1247      * @since 9
1248      */
1249     public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
1250         if (!directBuffer.isDirect())
1251             throw new IllegalArgumentException(&quot;buffer is non-direct&quot;);
1252 
1253         theInternalUnsafe.invokeCleaner(directBuffer);
1254     }
1255 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/runtime/signature.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="invoke/DirectMethodHandle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
<span class="line-modified"> 166     private static final int VALUE_TYPE = 0x00000100;</span>
 167 
 168     private static native void registerNatives();
 169     static {
 170         registerNatives();
 171     }
 172 
 173     /*
 174      * Private constructor. Only the Java Virtual Machine creates Class objects.
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
 195      * @return a string representation of this {@code Class} object.
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
<span class="line-modified"> 200                + getName() + (isInlineClass() &amp;&amp; isIndirectType() ? &quot;?&quot; : &quot;&quot;);</span>
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * {@code @interface}, or {@code record} as appropriate), followed
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
</pre>
<hr />
<pre>
 502                 // if caller is null, Class.forName is the last java frame on the stack.
 503                 // java.base has all permissions
 504                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 505             }
 506             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 507             cl = AccessController.doPrivileged(pa);
 508         } else {
 509             cl = module.getClassLoader();
 510         }
 511 
 512         if (cl != null) {
 513             return cl.loadClass(module, name);
 514         } else {
 515             return BootLoader.loadClass(module, name);
 516         }
 517     }
 518 
 519     /**
 520      * Returns {@code true} if this class is an inline class.
 521      *
<span class="line-modified"> 522      * @return {@code true} if this class is an inline class.</span>

 523      */
 524     public boolean isInlineClass() {
<span class="line-modified"> 525         return (this.getModifiers() &amp; VALUE_TYPE) != 0;</span>
 526     }
 527 
 528     /**
<span class="line-modified"> 529      * Returns a {@code Class} object representing the primary type of</span>
<span class="line-modified"> 530      * this class.</span>
<span class="line-modified"> 531      *</span>
<span class="line-modified"> 532      * &lt;p&gt; For class {@code C}, {@code C.class} is the primary type of {@code C}.</span>
<span class="line-modified"> 533      * For a primitive type, the {@code Class} instance representing</span>
<span class="line-modified"> 534      * that primitive type is its primary type, for example {@code int.class}.</span>
<span class="line-modified"> 535      *</span>
<span class="line-modified"> 536      * @return the {@code Class} object representing the primary type of</span>
<span class="line-modified"> 537      *         this class</span>
 538      */
<span class="line-modified"> 539     public Class&lt;T&gt; asPrimaryType() {</span>
<span class="line-modified"> 540         return isInlineClass() ? inlineType : this;</span>
 541     }
 542 
 543     /**
<span class="line-modified"> 544      * Returns a {@code Class} object representing the &lt;em&gt;indirect projection&lt;/em&gt;</span>
<span class="line-modified"> 545      * type if this class is an {@linkplain #isInlineClass() inline class};</span>
<span class="line-modified"> 546      * otherwise, returns this class.</span>
<span class="line-modified"> 547      *</span>
<span class="line-modified"> 548      * &lt;p&gt; An inline class, {@code V}, has two {@code Class} representations,</span>
<span class="line-modified"> 549      * {@code V.class} and its {@linkplain #asIndirectType() indirect projection</span>
<span class="line-modified"> 550      * type}.  The indirect projection type is always</span>
<span class="line-modified"> 551      * {@linkplain #isNullableType() nullable}.</span>
<span class="line-modified"> 552      * The indirect projection type of a zero-default inline class</span>
<span class="line-modified"> 553      * is also its nullable projection type.</span>
<span class="line-modified"> 554      *</span>
<span class="line-removed"> 555      * @return the {@code Class} object representing the indirect projection type of</span>
<span class="line-removed"> 556      *         this class if this class is an inline class; otherwise, this class.</span>
 557      */
<span class="line-modified"> 558     public Class&lt;T&gt; asIndirectType() {</span>
<span class="line-modified"> 559         return isInlineClass() ? indirectType : this;</span>
<span class="line-removed"> 560     }</span>
<span class="line-removed"> 561 </span>
<span class="line-removed"> 562     /**</span>
<span class="line-removed"> 563      * Returns a {@code Class} object representing the &lt;em&gt;nullable projection&lt;/em&gt;</span>
<span class="line-removed"> 564      * type if this class is an {@linkplain #isInlineClass() inline class};</span>
<span class="line-removed"> 565      * otherwise, returns this class.</span>
<span class="line-removed"> 566      *</span>
<span class="line-removed"> 567      * &lt;p&gt; An inline class, {@code V}, has two {@code Class} representations,</span>
<span class="line-removed"> 568      * {@code V.class} and its {@linkplain #asIndirectType() indirect projection</span>
<span class="line-removed"> 569      * type}.  The indirect projection type is always</span>
<span class="line-removed"> 570      * {@linkplain #isNullableType() nullable}.</span>
<span class="line-removed"> 571      * The indirect projection type of a zero-default inline class</span>
<span class="line-removed"> 572      * is also its nullable projection type.</span>
<span class="line-removed"> 573      *</span>
<span class="line-removed"> 574      * @return the {@code Class} object representing the nullable projection type of</span>
<span class="line-removed"> 575      *         this class if this class is an inline class; otherwise, this class.</span>
<span class="line-removed"> 576      */</span>
<span class="line-removed"> 577     public Class&lt;T&gt; asNullableType() {</span>
<span class="line-removed"> 578         return asIndirectType();</span>
<span class="line-removed"> 579     }</span>
<span class="line-removed"> 580 </span>
<span class="line-removed"> 581     /**</span>
<span class="line-removed"> 582      * Returns {@code true} if this class is an indirect type.</span>
<span class="line-removed"> 583      * An indirect type is always {@linkplain #isNullableType() nullable}.</span>
<span class="line-removed"> 584      *</span>
<span class="line-removed"> 585      * @return {@code true} if this class is an indirect type.</span>
<span class="line-removed"> 586      */</span>
<span class="line-removed"> 587     public boolean isIndirectType() {</span>
<span class="line-removed"> 588         return indirectType == null || this == indirectType;</span>
<span class="line-removed"> 589     }</span>
<span class="line-removed"> 590 </span>
<span class="line-removed"> 591     /**</span>
<span class="line-removed"> 592      * Returns {@code true} if this class is a nullable type.</span>
<span class="line-removed"> 593      *</span>
<span class="line-removed"> 594      * @return {@code true} if this class is a nullable type.</span>
<span class="line-removed"> 595      */</span>
<span class="line-removed"> 596     public boolean isNullableType() {</span>
<span class="line-removed"> 597         return isIndirectType();</span>
 598     }
 599 
 600     // set by VM if this class is an inline type
 601     // otherwise, these two fields are null
<span class="line-modified"> 602     private transient Class&lt;T&gt; inlineType;</span>
<span class="line-modified"> 603     private transient Class&lt;T&gt; indirectType;</span>
 604 
 605     /**
 606      * Creates a new instance of the class represented by this {@code Class}
 607      * object.  The class is instantiated as if by a {@code new}
 608      * expression with an empty argument list.  The class is initialized if it
 609      * has not already been initialized.
 610      *
 611      * @deprecated This method propagates any exception thrown by the
 612      * nullary constructor, including a checked exception.  Use of
 613      * this method effectively bypasses the compile-time exception
 614      * checking that would otherwise be performed by the compiler.
 615      * The {@link
 616      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 617      * Constructor.newInstance} method avoids this problem by wrapping
 618      * any exception thrown by the constructor in a (checked) {@link
 619      * java.lang.reflect.InvocationTargetException}.
 620      *
 621      * &lt;p&gt;The call
 622      *
 623      * &lt;pre&gt;{@code
</pre>
<hr />
<pre>
 859      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the
 860      * name returned is a {@code String} equal to the Java language
 861      * keyword corresponding to the primitive type or void.
 862      *
 863      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal
 864      * form of the name consists of the name of the element type preceded by
 865      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 866      * nesting.  The encoding of element type names is as follows:
 867      *
 868      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 869      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 870      * &lt;thead&gt;
 871      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 872      * &lt;/thead&gt;
 873      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 874      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 875      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 876      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 877      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 878      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
<span class="line-modified"> 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; non-nullable {@linkplain #isInlineClass() inline class}</span>
 880      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;
 881      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 882      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 883      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 885      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 886      * &lt;/tbody&gt;
 887      * &lt;/table&gt;&lt;/blockquote&gt;
 888      *
 889      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 890      * the class specified above.
 891      *
 892      * &lt;p&gt; Examples:
 893      * &lt;blockquote&gt;&lt;pre&gt;
 894      * String.class.getName()
 895      *     returns &quot;java.lang.String&quot;
 896      * byte.class.getName()
 897      *     returns &quot;byte&quot;
 898      * Point.class.getName()
 899      *     returns &quot;Point&quot;
 900      * (new Object[3]).getClass().getName()
 901      *     returns &quot;[Ljava.lang.Object;&quot;
 902      * (new Point[3]).getClass().getName()
 903      *     returns &quot;[QPoint;&quot;
<span class="line-modified"> 904      * (new Point?[3][4]).getClass().getName()</span>
<span class="line-modified"> 905      *     returns &quot;[[LPoint;&quot;</span>
 906      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 907      *     returns &quot;[[[[[[[I&quot;
 908      * &lt;/pre&gt;&lt;/blockquote&gt;
 909      *
 910      * @return  the name of the class or interface
 911      *          represented by this {@code Class} object.
 912      */
 913     public String getName() {
 914         String name = this.name;
 915         return name != null ? name : initClassName();
 916     }
 917 
 918     // Cache the name to reduce the number of calls into the VM.
 919     // This field would be set by VM itself during initClassName call.
 920     private transient String name;
 921     private native String initClassName();
 922 
 923     /**
 924      * Returns the class loader for the class.  Some implementations may use
 925      * null to represent the bootstrap class loader. This method will return
</pre>
<hr />
<pre>
1304      * by this specification.
1305      *
1306      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1307      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1308      *
1309      * @return the {@code int} representing the modifiers for this class
1310      * @see     java.lang.reflect.Modifier
1311      * @since 1.1
1312      */
1313     @HotSpotIntrinsicCandidate
1314     public native int getModifiers();
1315 
1316     /**
1317      * Gets the signers of this class.
1318      *
1319      * @return  the signers of this class, or null if there are no signers.  In
1320      *          particular, this method returns null if this {@code Class} object represents
1321      *          a primitive type or void.
1322      * @since   1.1
1323      */
<span class="line-modified">1324     public Object[] getSigners() {</span>
<span class="line-removed">1325         return asPrimaryType().getSigners0();</span>
<span class="line-removed">1326     }</span>
<span class="line-removed">1327 </span>
<span class="line-removed">1328     private native Object[] getSigners0();</span>
1329 
1330     /**
1331      * Set the signers of this class.
1332      */
<span class="line-modified">1333     void setSigners(Object[] signers) {</span>
<span class="line-removed">1334         asPrimaryType().setSigners0(signers);</span>
<span class="line-removed">1335     }</span>
<span class="line-removed">1336 </span>
<span class="line-removed">1337     native void setSigners0(Object[] signers);</span>
1338 
1339 
1340     /**
1341      * If this {@code Class} object represents a local or anonymous
1342      * class within a method, returns a {@link
1343      * java.lang.reflect.Method Method} object representing the
1344      * immediately enclosing method of the underlying class. Returns
1345      * {@code null} otherwise.
1346      *
1347      * In particular, this method returns {@code null} if the underlying
1348      * class is a local or anonymous class immediately enclosed by a type
1349      * declaration, instance initializer or static initializer.
1350      *
1351      * @return the immediately enclosing method of the underlying class, if
1352      *     that class is a local or anonymous class; otherwise {@code null}.
1353      *
1354      * @throws SecurityException
1355      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1356      *         following conditions is met:
1357      *
</pre>
<hr />
<pre>
1676      * @since 1.5
1677      */
1678     public String getSimpleName() {
1679         ReflectionData&lt;T&gt; rd = reflectionData();
1680         String simpleName = rd.simpleName;
1681         if (simpleName == null) {
1682             rd.simpleName = simpleName = getSimpleName0();
1683         }
1684         return simpleName;
1685     }
1686 
1687     private String getSimpleName0() {
1688         if (isArray()) {
1689             return getComponentType().getSimpleName() + &quot;[]&quot;;
1690         }
1691         String simpleName = getSimpleBinaryName();
1692         if (simpleName == null) { // top level class
1693             simpleName = getName();
1694             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1695         }
<span class="line-modified">1696         return isInlineClass() &amp;&amp; isIndirectType() ? simpleName + &quot;?&quot; : simpleName;</span>
1697     }
1698 
1699     /**
1700      * Return an informative string for the name of this type.
1701      *
1702      * @return an informative string for the name of this type
1703      * @since 1.8
1704      */
1705     public String getTypeName() {
1706         if (isArray()) {
1707             try {
1708                 Class&lt;?&gt; cl = this;
1709                 int dimensions = 0;
1710                 do {
1711                     dimensions++;
1712                     cl = cl.getComponentType();
1713                 } while (cl.isArray());
1714                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1715             } catch (Throwable e) { /*FALLTHRU*/ }
1716         }
<span class="line-modified">1717         return toTypeName();</span>
1718     }
1719 
1720     /**
1721      * Returns the canonical name of the underlying class as defined
1722      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section
1723      * {@jls 6.7}.  Returns null if the underlying class does not have
1724      * a canonical name (i.e., if it is a local or anonymous class or
1725      * an array whose component type does not have a canonical name).
1726      * @return the canonical name of the underlying class if it exists, and
1727      * {@code null} otherwise.
1728      * @since 1.5
1729      */
1730     public String getCanonicalName() {
1731         ReflectionData&lt;T&gt; rd = reflectionData();
1732         String canonicalName = rd.canonicalName;
1733         if (canonicalName == null) {
1734             rd.canonicalName = canonicalName = getCanonicalName0();
1735         }
1736         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1737     }
</pre>
<hr />
<pre>
3591         }
3592         return out;
3593     }
3594 
3595     private native Field[]       getDeclaredFields0(boolean publicOnly);
3596     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3597     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3598     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3599     @SuppressWarnings(&quot;preview&quot;)
3600     private native RecordComponent[] getRecordComponents0();
3601     private native boolean      isRecord0();
3602 
3603     /**
3604      * Helper method to get the method name from arguments.
3605      */
3606     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3607         return getName() + &#39;.&#39; + name +
3608                 ((argTypes == null || argTypes.length == 0) ?
3609                 &quot;()&quot; :
3610                 Arrays.stream(argTypes)
<span class="line-modified">3611                         .map(c -&gt; c == null ? &quot;null&quot; : c.toTypeName())</span>
3612                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3613     }
3614 
<span class="line-removed">3615     /*</span>
<span class="line-removed">3616      * Returns the class name appended with &quot;?&quot; if it is the nullable projection</span>
<span class="line-removed">3617      * of an inline class.</span>
<span class="line-removed">3618      */</span>
<span class="line-removed">3619     private String toTypeName() {</span>
<span class="line-removed">3620         return isInlineClass() &amp;&amp; isIndirectType() ? getName() + &quot;?&quot; : getName();</span>
<span class="line-removed">3621     }</span>
<span class="line-removed">3622 </span>
3623     /** use serialVersionUID from JDK 1.1 for interoperability */
3624     @java.io.Serial
3625     private static final long serialVersionUID = 3206093459760846163L;
3626 
3627 
3628     /**
3629      * Class Class is special cased within the Serialization Stream Protocol.
3630      *
3631      * A Class instance is written initially into an ObjectOutputStream in the
3632      * following format:
3633      * &lt;pre&gt;
3634      *      {@code TC_CLASS} ClassDescriptor
3635      *      A ClassDescriptor is a special cased serialization of
3636      *      a {@code java.io.ObjectStreamClass} instance.
3637      * &lt;/pre&gt;
3638      * A new handle is generated for the initial time the class descriptor
3639      * is written into the stream. Future references to the class descriptor
3640      * are written as references to the initial class descriptor instance.
3641      *
3642      * @see java.io.ObjectStreamClass
</pre>
<hr />
<pre>
3828                     getName() + &quot; is not an enum type&quot;);
3829             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3830             for (T constant : universe) {
3831                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3832             }
3833             enumConstantDirectory = directory;
3834         }
3835         return directory;
3836     }
3837     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3838 
3839     /**
3840      * Casts an object to the class or interface represented
3841      * by this {@code Class} object.
3842      *
3843      * @param obj the object to be cast
3844      * @return the object after casting, or null if obj is null
3845      *
3846      * @throws ClassCastException if the object is not
3847      * {@code null} and is not assignable to the type T.
<span class="line-modified">3848      * @throws NullPointerException if this is not a {@linkplain #isNullableType()</span>
<span class="line-modified">3849      * nullable type} and the object is {@code null}</span>
3850      *
3851      * @since 1.5
3852      */
3853     @SuppressWarnings(&quot;unchecked&quot;)
3854     @HotSpotIntrinsicCandidate
3855     public T cast(Object obj) {
<span class="line-modified">3856         if (!isNullableType() &amp;&amp; obj == null)</span>
3857             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3858 
3859         if (obj != null &amp;&amp; !isInstance(obj))
3860             throw new ClassCastException(cannotCastMsg(obj));
3861         return (T) obj;
3862     }
3863 
3864     private String cannotCastMsg(Object obj) {
3865         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3866     }
3867 
3868     /**
3869      * Casts this {@code Class} object to represent a subclass of the class
3870      * represented by the specified class object.  Checks that the cast
3871      * is valid, and throws a {@code ClassCastException} if it is not.  If
3872      * this method succeeds, it always returns a reference to this {@code Class} object.
3873      *
3874      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3875      * a {@code Class} object to pass it to an API that restricts the
3876      * {@code Class} objects that it is willing to accept.  A cast would
</pre>
<hr />
<pre>
4314 
4315     /**
4316      * Returns the type descriptor string for this class.
4317      * &lt;p&gt;
4318      * Note that this is not a strict inverse of {@link #forName};
4319      * distinct classes which share a common name but have different class loaders
4320      * will have identical descriptor strings.
4321      *
4322      * @return the type descriptor representation
4323      * @jvms 4.3.2 Field Descriptors
4324      * @since 12
4325      */
4326     @Override
4327     public String descriptorString() {
4328         if (isPrimitive())
4329             return Wrapper.forPrimitiveType(this).basicTypeString();
4330         else if (isArray()) {
4331             return &quot;[&quot; + componentType.descriptorString();
4332         }
4333         else {
<span class="line-modified">4334             return &quot;L&quot; + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>

4335         }
4336     }
4337 
4338     /**
4339      * Returns the component type of this {@code Class}, if it describes
4340      * an array type, or {@code null} otherwise.
4341      *
4342      * @implSpec
4343      * Equivalent to {@link Class#getComponentType()}.
4344      *
4345      * @return a {@code Class} describing the component type, or {@code null}
4346      * if this {@code Class} does not describe an array type
4347      * @since 12
4348      */
4349     @Override
4350     public Class&lt;?&gt; componentType() {
4351         return isArray() ? componentType : null;
4352     }
4353 
4354     /**
</pre>
</td>
<td>
<hr />
<pre>
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
<span class="line-modified"> 166     private static final int INLINE     = 0x00000100;</span>
 167 
 168     private static native void registerNatives();
 169     static {
 170         registerNatives();
 171     }
 172 
 173     /*
 174      * Private constructor. Only the Java Virtual Machine creates Class objects.
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
 195      * @return a string representation of this {@code Class} object.
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
<span class="line-modified"> 200                + getName();</span>
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * {@code @interface}, or {@code record} as appropriate), followed
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
</pre>
<hr />
<pre>
 502                 // if caller is null, Class.forName is the last java frame on the stack.
 503                 // java.base has all permissions
 504                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 505             }
 506             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 507             cl = AccessController.doPrivileged(pa);
 508         } else {
 509             cl = module.getClassLoader();
 510         }
 511 
 512         if (cl != null) {
 513             return cl.loadClass(module, name);
 514         } else {
 515             return BootLoader.loadClass(module, name);
 516         }
 517     }
 518 
 519     /**
 520      * Returns {@code true} if this class is an inline class.
 521      *
<span class="line-modified"> 522      * @return {@code true} if this class is an inline class</span>
<span class="line-added"> 523      * @since Valhalla</span>
 524      */
 525     public boolean isInlineClass() {
<span class="line-modified"> 526         return (this.getModifiers() &amp; INLINE) != 0;</span>
 527     }
 528 
 529     /**
<span class="line-modified"> 530      * Returns a {@code Class} object representing the &lt;em&gt;value projection&lt;/em&gt;</span>
<span class="line-modified"> 531      * type of this class if this {@code Class} is the reference projection type</span>
<span class="line-modified"> 532      * of an {@linkplain #isInlineClass() inline class}.  Otherwise an empty</span>
<span class="line-modified"> 533      * {@link Optional} is returned.</span>
<span class="line-modified"> 534      *</span>
<span class="line-modified"> 535      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-modified"> 536      *         this class if this class is the reference projection type of an</span>
<span class="line-modified"> 537      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-modified"> 538      * @since Valhalla</span>
 539      */
<span class="line-modified"> 540     public Optional&lt;Class&lt;T&gt;&gt; valueType() {</span>
<span class="line-modified"> 541         return Optional.ofNullable(valType);</span>
 542     }
 543 
 544     /**
<span class="line-modified"> 545      * Returns a {@code Class} object representing the &lt;em&gt;reference projection&lt;/em&gt;</span>
<span class="line-modified"> 546      * type of this class if this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-modified"> 547      * with a reference projection.</span>
<span class="line-modified"> 548      * If this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-modified"> 549      * without a reference projection or this class is not an inline class,</span>
<span class="line-modified"> 550      * then this method returns an empty {@link Optional}.</span>
<span class="line-modified"> 551      *</span>
<span class="line-modified"> 552      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-modified"> 553      *         this class if this class is the reference projection type of an</span>
<span class="line-modified"> 554      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-modified"> 555      * @since Valhalla</span>


 556      */
<span class="line-modified"> 557     public Optional&lt;Class&lt;T&gt;&gt; referenceType() {</span>
<span class="line-modified"> 558         return valType != null ? Optional.ofNullable(refType) : Optional.of(this);</span>






































 559     }
 560 
 561     // set by VM if this class is an inline type
 562     // otherwise, these two fields are null
<span class="line-modified"> 563     private transient Class&lt;T&gt; valType;</span>
<span class="line-modified"> 564     private transient Class&lt;T&gt; refType;</span>
 565 
 566     /**
 567      * Creates a new instance of the class represented by this {@code Class}
 568      * object.  The class is instantiated as if by a {@code new}
 569      * expression with an empty argument list.  The class is initialized if it
 570      * has not already been initialized.
 571      *
 572      * @deprecated This method propagates any exception thrown by the
 573      * nullary constructor, including a checked exception.  Use of
 574      * this method effectively bypasses the compile-time exception
 575      * checking that would otherwise be performed by the compiler.
 576      * The {@link
 577      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 578      * Constructor.newInstance} method avoids this problem by wrapping
 579      * any exception thrown by the constructor in a (checked) {@link
 580      * java.lang.reflect.InvocationTargetException}.
 581      *
 582      * &lt;p&gt;The call
 583      *
 584      * &lt;pre&gt;{@code
</pre>
<hr />
<pre>
 820      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the
 821      * name returned is a {@code String} equal to the Java language
 822      * keyword corresponding to the primitive type or void.
 823      *
 824      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal
 825      * form of the name consists of the name of the element type preceded by
 826      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 827      * nesting.  The encoding of element type names is as follows:
 828      *
 829      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 830      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 831      * &lt;thead&gt;
 832      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 833      * &lt;/thead&gt;
 834      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 835      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 836      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 837      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 838      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 839      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
<span class="line-modified"> 840      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class}</span>
 841      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;
 842      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 843      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 844      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 845      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 846      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 847      * &lt;/tbody&gt;
 848      * &lt;/table&gt;&lt;/blockquote&gt;
 849      *
 850      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 851      * the class specified above.
 852      *
 853      * &lt;p&gt; Examples:
 854      * &lt;blockquote&gt;&lt;pre&gt;
 855      * String.class.getName()
 856      *     returns &quot;java.lang.String&quot;
 857      * byte.class.getName()
 858      *     returns &quot;byte&quot;
 859      * Point.class.getName()
 860      *     returns &quot;Point&quot;
 861      * (new Object[3]).getClass().getName()
 862      *     returns &quot;[Ljava.lang.Object;&quot;
 863      * (new Point[3]).getClass().getName()
 864      *     returns &quot;[QPoint;&quot;
<span class="line-modified"> 865      * (new Point.ref[3][4]).getClass().getName()</span>
<span class="line-modified"> 866      *     returns &quot;[[LPoint$ref;&quot;</span>
 867      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 868      *     returns &quot;[[[[[[[I&quot;
 869      * &lt;/pre&gt;&lt;/blockquote&gt;
 870      *
 871      * @return  the name of the class or interface
 872      *          represented by this {@code Class} object.
 873      */
 874     public String getName() {
 875         String name = this.name;
 876         return name != null ? name : initClassName();
 877     }
 878 
 879     // Cache the name to reduce the number of calls into the VM.
 880     // This field would be set by VM itself during initClassName call.
 881     private transient String name;
 882     private native String initClassName();
 883 
 884     /**
 885      * Returns the class loader for the class.  Some implementations may use
 886      * null to represent the bootstrap class loader. This method will return
</pre>
<hr />
<pre>
1265      * by this specification.
1266      *
1267      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1268      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1269      *
1270      * @return the {@code int} representing the modifiers for this class
1271      * @see     java.lang.reflect.Modifier
1272      * @since 1.1
1273      */
1274     @HotSpotIntrinsicCandidate
1275     public native int getModifiers();
1276 
1277     /**
1278      * Gets the signers of this class.
1279      *
1280      * @return  the signers of this class, or null if there are no signers.  In
1281      *          particular, this method returns null if this {@code Class} object represents
1282      *          a primitive type or void.
1283      * @since   1.1
1284      */
<span class="line-modified">1285     public native Object[] getSigners();</span>




1286 
1287     /**
1288      * Set the signers of this class.
1289      */
<span class="line-modified">1290     native void setSigners(Object[] signers);</span>




1291 
1292 
1293     /**
1294      * If this {@code Class} object represents a local or anonymous
1295      * class within a method, returns a {@link
1296      * java.lang.reflect.Method Method} object representing the
1297      * immediately enclosing method of the underlying class. Returns
1298      * {@code null} otherwise.
1299      *
1300      * In particular, this method returns {@code null} if the underlying
1301      * class is a local or anonymous class immediately enclosed by a type
1302      * declaration, instance initializer or static initializer.
1303      *
1304      * @return the immediately enclosing method of the underlying class, if
1305      *     that class is a local or anonymous class; otherwise {@code null}.
1306      *
1307      * @throws SecurityException
1308      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1309      *         following conditions is met:
1310      *
</pre>
<hr />
<pre>
1629      * @since 1.5
1630      */
1631     public String getSimpleName() {
1632         ReflectionData&lt;T&gt; rd = reflectionData();
1633         String simpleName = rd.simpleName;
1634         if (simpleName == null) {
1635             rd.simpleName = simpleName = getSimpleName0();
1636         }
1637         return simpleName;
1638     }
1639 
1640     private String getSimpleName0() {
1641         if (isArray()) {
1642             return getComponentType().getSimpleName() + &quot;[]&quot;;
1643         }
1644         String simpleName = getSimpleBinaryName();
1645         if (simpleName == null) { // top level class
1646             simpleName = getName();
1647             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1648         }
<span class="line-modified">1649         return simpleName;</span>
1650     }
1651 
1652     /**
1653      * Return an informative string for the name of this type.
1654      *
1655      * @return an informative string for the name of this type
1656      * @since 1.8
1657      */
1658     public String getTypeName() {
1659         if (isArray()) {
1660             try {
1661                 Class&lt;?&gt; cl = this;
1662                 int dimensions = 0;
1663                 do {
1664                     dimensions++;
1665                     cl = cl.getComponentType();
1666                 } while (cl.isArray());
1667                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1668             } catch (Throwable e) { /*FALLTHRU*/ }
1669         }
<span class="line-modified">1670         return getName();</span>
1671     }
1672 
1673     /**
1674      * Returns the canonical name of the underlying class as defined
1675      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section
1676      * {@jls 6.7}.  Returns null if the underlying class does not have
1677      * a canonical name (i.e., if it is a local or anonymous class or
1678      * an array whose component type does not have a canonical name).
1679      * @return the canonical name of the underlying class if it exists, and
1680      * {@code null} otherwise.
1681      * @since 1.5
1682      */
1683     public String getCanonicalName() {
1684         ReflectionData&lt;T&gt; rd = reflectionData();
1685         String canonicalName = rd.canonicalName;
1686         if (canonicalName == null) {
1687             rd.canonicalName = canonicalName = getCanonicalName0();
1688         }
1689         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1690     }
</pre>
<hr />
<pre>
3544         }
3545         return out;
3546     }
3547 
3548     private native Field[]       getDeclaredFields0(boolean publicOnly);
3549     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3550     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3551     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3552     @SuppressWarnings(&quot;preview&quot;)
3553     private native RecordComponent[] getRecordComponents0();
3554     private native boolean      isRecord0();
3555 
3556     /**
3557      * Helper method to get the method name from arguments.
3558      */
3559     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3560         return getName() + &#39;.&#39; + name +
3561                 ((argTypes == null || argTypes.length == 0) ?
3562                 &quot;()&quot; :
3563                 Arrays.stream(argTypes)
<span class="line-modified">3564                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())</span>
3565                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3566     }
3567 








3568     /** use serialVersionUID from JDK 1.1 for interoperability */
3569     @java.io.Serial
3570     private static final long serialVersionUID = 3206093459760846163L;
3571 
3572 
3573     /**
3574      * Class Class is special cased within the Serialization Stream Protocol.
3575      *
3576      * A Class instance is written initially into an ObjectOutputStream in the
3577      * following format:
3578      * &lt;pre&gt;
3579      *      {@code TC_CLASS} ClassDescriptor
3580      *      A ClassDescriptor is a special cased serialization of
3581      *      a {@code java.io.ObjectStreamClass} instance.
3582      * &lt;/pre&gt;
3583      * A new handle is generated for the initial time the class descriptor
3584      * is written into the stream. Future references to the class descriptor
3585      * are written as references to the initial class descriptor instance.
3586      *
3587      * @see java.io.ObjectStreamClass
</pre>
<hr />
<pre>
3773                     getName() + &quot; is not an enum type&quot;);
3774             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3775             for (T constant : universe) {
3776                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3777             }
3778             enumConstantDirectory = directory;
3779         }
3780         return directory;
3781     }
3782     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3783 
3784     /**
3785      * Casts an object to the class or interface represented
3786      * by this {@code Class} object.
3787      *
3788      * @param obj the object to be cast
3789      * @return the object after casting, or null if obj is null
3790      *
3791      * @throws ClassCastException if the object is not
3792      * {@code null} and is not assignable to the type T.
<span class="line-modified">3793      * @throws NullPointerException if this is an {@linkplain #isInlineClass()</span>
<span class="line-modified">3794      * inline type} and the object is {@code null}</span>
3795      *
3796      * @since 1.5
3797      */
3798     @SuppressWarnings(&quot;unchecked&quot;)
3799     @HotSpotIntrinsicCandidate
3800     public T cast(Object obj) {
<span class="line-modified">3801         if (isInlineClass() &amp;&amp; obj == null)</span>
3802             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3803 
3804         if (obj != null &amp;&amp; !isInstance(obj))
3805             throw new ClassCastException(cannotCastMsg(obj));
3806         return (T) obj;
3807     }
3808 
3809     private String cannotCastMsg(Object obj) {
3810         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3811     }
3812 
3813     /**
3814      * Casts this {@code Class} object to represent a subclass of the class
3815      * represented by the specified class object.  Checks that the cast
3816      * is valid, and throws a {@code ClassCastException} if it is not.  If
3817      * this method succeeds, it always returns a reference to this {@code Class} object.
3818      *
3819      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3820      * a {@code Class} object to pass it to an API that restricts the
3821      * {@code Class} objects that it is willing to accept.  A cast would
</pre>
<hr />
<pre>
4259 
4260     /**
4261      * Returns the type descriptor string for this class.
4262      * &lt;p&gt;
4263      * Note that this is not a strict inverse of {@link #forName};
4264      * distinct classes which share a common name but have different class loaders
4265      * will have identical descriptor strings.
4266      *
4267      * @return the type descriptor representation
4268      * @jvms 4.3.2 Field Descriptors
4269      * @since 12
4270      */
4271     @Override
4272     public String descriptorString() {
4273         if (isPrimitive())
4274             return Wrapper.forPrimitiveType(this).basicTypeString();
4275         else if (isArray()) {
4276             return &quot;[&quot; + componentType.descriptorString();
4277         }
4278         else {
<span class="line-modified">4279             return (isInlineClass() ? &quot;Q&quot; : &quot;L&quot;)</span>
<span class="line-added">4280                     + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
4281         }
4282     }
4283 
4284     /**
4285      * Returns the component type of this {@code Class}, if it describes
4286      * an array type, or {@code null} otherwise.
4287      *
4288      * @implSpec
4289      * Equivalent to {@link Class#getComponentType()}.
4290      *
4291      * @return a {@code Class} describing the component type, or {@code null}
4292      * if this {@code Class} does not describe an array type
4293      * @since 12
4294      */
4295     @Override
4296     public Class&lt;?&gt; componentType() {
4297         return isArray() ? componentType : null;
4298     }
4299 
4300     /**
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../hotspot/share/runtime/signature.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="invoke/DirectMethodHandle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../Class.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="InfoFromMemberName.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  61             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
  62             member.isMethod() &amp;&amp; !member.isAbstract()) {
  63             // Check for corner case: invokeinterface of Object method
  64             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
  65             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
  66             if (m != null &amp;&amp; m.isPublic()) {
  67                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
  68                 member = m;
  69             }
  70         }
  71 
  72         this.member = member;
  73     }
  74 
  75     // Factory methods:
  76     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
  77         MethodType mtype = member.getMethodOrFieldType();
  78         if (!member.isStatic()) {
  79             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())
  80                 throw new InternalError(member.toString());
<span class="line-modified">  81             mtype = mtype.insertParameterTypes(0, refc.asPrimaryType());</span>
  82         }
  83         if (!member.isField()) {
  84             // refKind reflects the original type of lookup via findSpecial or
  85             // findVirtual etc.
  86             switch (refKind) {
  87                 case REF_invokeSpecial: {
  88                     member = member.asSpecial();
  89                     // if caller is an interface we need to adapt to get the
  90                     // receiver check inserted
  91                     if (callerClass == null) {
  92                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
  93                     }
  94                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
  95                     return new Special(mtype, lform, member, callerClass);
  96                 }
  97                 case REF_invokeInterface: {
  98                     // for interfaces we always need the receiver typecheck,
  99                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 100                     // to include the REF_invokeSpecial case
 101                     LambdaForm lform = preparedLambdaForm(member, true);
</pre>
<hr />
<pre>
 583 
 584         // indirect type is always nullable
 585         @Override Object checkCast(Object obj) {
 586             return fieldType.cast(obj);
 587         }
 588         @Override
 589         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 590             return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);
 591         }
 592     }
 593 
 594     /** This subclass handles static field references of inline type . */
 595     static class InlineStaticAccessor extends StaticAccessor {
 596         private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 597                                      Object staticBase, long staticOffset) {
 598             super(mtype, form, member, staticBase, staticOffset);
 599         }
 600 
 601         // zero-default inline type is not-nullable
 602         @Override Object checkCast(Object obj) {
<span class="line-modified"> 603             assert !fieldType.isNullableType() : &quot;null-default inline type not yet supported&quot;;</span>
 604             return fieldType.cast(Objects.requireNonNull(obj));
 605         }
 606         @Override
 607         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 608             return new InlineStaticAccessor(mt, lf, member, staticBase, staticOffset);
 609         }
 610     }
 611 
 612     @ForceInline
 613     /*non-public*/
 614     static Object nullCheck(Object obj) {
 615         return Objects.requireNonNull(obj);
 616     }
 617 
 618     @ForceInline
 619     /*non-public*/
 620     static Object staticBase(Object accessorObj) {
 621         return ((StaticAccessor)accessorObj).staticBase;
 622     }
 623 
</pre>
</td>
<td>
<hr />
<pre>
  61             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
  62             member.isMethod() &amp;&amp; !member.isAbstract()) {
  63             // Check for corner case: invokeinterface of Object method
  64             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
  65             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
  66             if (m != null &amp;&amp; m.isPublic()) {
  67                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
  68                 member = m;
  69             }
  70         }
  71 
  72         this.member = member;
  73     }
  74 
  75     // Factory methods:
  76     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
  77         MethodType mtype = member.getMethodOrFieldType();
  78         if (!member.isStatic()) {
  79             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())
  80                 throw new InternalError(member.toString());
<span class="line-modified">  81             mtype = mtype.insertParameterTypes(0, refc);</span>
  82         }
  83         if (!member.isField()) {
  84             // refKind reflects the original type of lookup via findSpecial or
  85             // findVirtual etc.
  86             switch (refKind) {
  87                 case REF_invokeSpecial: {
  88                     member = member.asSpecial();
  89                     // if caller is an interface we need to adapt to get the
  90                     // receiver check inserted
  91                     if (callerClass == null) {
  92                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
  93                     }
  94                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
  95                     return new Special(mtype, lform, member, callerClass);
  96                 }
  97                 case REF_invokeInterface: {
  98                     // for interfaces we always need the receiver typecheck,
  99                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 100                     // to include the REF_invokeSpecial case
 101                     LambdaForm lform = preparedLambdaForm(member, true);
</pre>
<hr />
<pre>
 583 
 584         // indirect type is always nullable
 585         @Override Object checkCast(Object obj) {
 586             return fieldType.cast(obj);
 587         }
 588         @Override
 589         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 590             return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);
 591         }
 592     }
 593 
 594     /** This subclass handles static field references of inline type . */
 595     static class InlineStaticAccessor extends StaticAccessor {
 596         private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 597                                      Object staticBase, long staticOffset) {
 598             super(mtype, form, member, staticBase, staticOffset);
 599         }
 600 
 601         // zero-default inline type is not-nullable
 602         @Override Object checkCast(Object obj) {
<span class="line-modified"> 603             assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;</span>
 604             return fieldType.cast(Objects.requireNonNull(obj));
 605         }
 606         @Override
 607         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 608             return new InlineStaticAccessor(mt, lf, member, staticBase, staticOffset);
 609         }
 610     }
 611 
 612     @ForceInline
 613     /*non-public*/
 614     static Object nullCheck(Object obj) {
 615         return Objects.requireNonNull(obj);
 616     }
 617 
 618     @ForceInline
 619     /*non-public*/
 620     static Object staticBase(Object accessorObj) {
 621         return ((StaticAccessor)accessorObj).staticBase;
 622     }
 623 
</pre>
</td>
</tr>
</table>
<center><a href="../Class.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="InfoFromMemberName.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.misc.Unsafe;
  29 import jdk.internal.vm.annotation.ForceInline;
  30 import jdk.internal.vm.annotation.Stable;
  31 import sun.invoke.util.ValueConversions;
  32 import sun.invoke.util.VerifyAccess;
  33 import sun.invoke.util.VerifyType;
  34 import sun.invoke.util.Wrapper;
  35 
  36 import java.lang.ref.WeakReference;
  37 import java.util.Arrays;
  38 import java.util.Objects;
  39 
  40 import static java.lang.invoke.LambdaForm.*;
  41 import static java.lang.invoke.LambdaForm.Kind.*;
  42 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  44 import static java.lang.invoke.MethodHandleStatics.newInternalError;
  45 import static java.lang.invoke.MethodTypeForm.*;
  46 
  47 /**
  48  * The flavor of method handle which implements a constant reference
  49  * to a class member.
  50  * @author jrose
  51  */
  52 class DirectMethodHandle extends MethodHandle {
  53     final MemberName member;
  54 
  55     // Constructors and factory methods in this class *must* be package scoped or private.
  56     private DirectMethodHandle(MethodType mtype, LambdaForm form, MemberName member) {
  57         super(mtype, form);
  58         if (!member.isResolved())  throw new InternalError();
  59 
  60         if (member.getDeclaringClass().isInterface() &amp;&amp;
  61             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
  62             member.isMethod() &amp;&amp; !member.isAbstract()) {
  63             // Check for corner case: invokeinterface of Object method
  64             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
  65             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
  66             if (m != null &amp;&amp; m.isPublic()) {
  67                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
  68                 member = m;
  69             }
  70         }
  71 
  72         this.member = member;
  73     }
  74 
  75     // Factory methods:
  76     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
  77         MethodType mtype = member.getMethodOrFieldType();
  78         if (!member.isStatic()) {
  79             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())
  80                 throw new InternalError(member.toString());
  81             mtype = mtype.insertParameterTypes(0, refc.asPrimaryType());
  82         }
  83         if (!member.isField()) {
  84             // refKind reflects the original type of lookup via findSpecial or
  85             // findVirtual etc.
  86             switch (refKind) {
  87                 case REF_invokeSpecial: {
  88                     member = member.asSpecial();
  89                     // if caller is an interface we need to adapt to get the
  90                     // receiver check inserted
  91                     if (callerClass == null) {
  92                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
  93                     }
  94                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
  95                     return new Special(mtype, lform, member, callerClass);
  96                 }
  97                 case REF_invokeInterface: {
  98                     // for interfaces we always need the receiver typecheck,
  99                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 100                     // to include the REF_invokeSpecial case
 101                     LambdaForm lform = preparedLambdaForm(member, true);
 102                     return new Interface(mtype, lform, member, refc);
 103                 }
 104                 default: {
 105                     LambdaForm lform = preparedLambdaForm(member);
 106                     return new DirectMethodHandle(mtype, lform, member);
 107                 }
 108             }
 109         } else {
 110             LambdaForm lform = preparedFieldLambdaForm(member);
 111             if (member.isStatic()) {
 112                 long offset = MethodHandleNatives.staticFieldOffset(member);
 113                 Object base = MethodHandleNatives.staticFieldBase(member);
 114                 return member.isIndirect() ? new IndirectStaticAccessor(mtype, lform, member, base, offset)
 115                                            : new InlineStaticAccessor(mtype, lform, member, base, offset);
 116             } else {
 117                 long offset = MethodHandleNatives.objectFieldOffset(member);
 118                 assert(offset == (int)offset);
 119                 return  member.isIndirect() ? new IndirectAccessor(mtype, lform, member, (int)offset)
 120                                             : new InlineAccessor(mtype, lform, member, (int)offset);
 121             }
 122         }
 123     }
 124     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
 125         byte refKind = member.getReferenceKind();
 126         if (refKind == REF_invokeSpecial)
 127             refKind =  REF_invokeVirtual;
 128         return make(refKind, refc, member, null /* no callerClass context */);
 129     }
 130     static DirectMethodHandle make(MemberName member) {
 131         if (member.isObjectConstructor() &amp;&amp; member.getReturnType() == void.class)
 132             return makeAllocator(member);
 133         return make(member.getDeclaringClass(), member);
 134     }
 135     private static DirectMethodHandle makeAllocator(MemberName ctor) {
 136         assert(ctor.isObjectConstructor() &amp;&amp; !ctor.getDeclaringClass().isInlineClass()) : ctor;
 137 
 138         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
 139         ctor = ctor.asObjectConstructor();
 140         assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;
 141         MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
 142         LambdaForm lform = preparedLambdaForm(ctor);
 143         MemberName init = ctor.asSpecial();
 144         assert(init.getMethodType().returnType() == void.class);
 145         return new Constructor(mtype, lform, ctor, init, instanceClass);
 146     }
 147 
 148     @Override
 149     BoundMethodHandle rebind() {
 150         return BoundMethodHandle.makeReinvoker(this);
 151     }
 152 
 153     @Override
 154     MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 155         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
 156         return new DirectMethodHandle(mt, lf, member);
 157     }
 158 
 159     @Override
 160     String internalProperties() {
 161         return &quot;\n&amp; DMH.MN=&quot;+internalMemberName();
 162     }
 163 
 164     //// Implementation methods.
 165     @Override
 166     @ForceInline
 167     MemberName internalMemberName() {
 168         return member;
 169     }
 170 
 171     private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
 172 
 173     /**
 174      * Create a LF which can invoke the given method.
 175      * Cache and share this structure among all methods with
 176      * the same basicType and refKind.
 177      */
 178     private static LambdaForm preparedLambdaForm(MemberName m, boolean adaptToSpecialIfc) {
 179         assert(m.isInvocable()) : m;  // call preparedFieldLambdaForm instead
 180         MethodType mtype = m.getInvocationType().basicType();
 181         assert(!m.isMethodHandleInvoke()) : m;
 182         int which;
 183         // MemberName.getReferenceKind represents the JVM optimized form of the call
 184         // as distinct from the &quot;kind&quot; passed to DMH.make which represents the original
 185         // bytecode-equivalent request. Specifically private/final methods that use a direct
 186         // call have getReferenceKind adapted to REF_invokeSpecial, even though the actual
 187         // invocation mode may be invokevirtual or invokeinterface.
 188         switch (m.getReferenceKind()) {
 189         case REF_invokeVirtual:    which = LF_INVVIRTUAL;    break;
 190         case REF_invokeStatic:     which = LF_INVSTATIC;     break;
 191         case REF_invokeSpecial:    which = LF_INVSPECIAL;    break;
 192         case REF_invokeInterface:  which = LF_INVINTERFACE;  break;
 193         case REF_newInvokeSpecial: which = LF_NEWINVSPECIAL; break;
 194         default:  throw new InternalError(m.toString());
 195         }
 196         if (which == LF_INVSTATIC &amp;&amp; shouldBeInitialized(m)) {
 197             // precompute the barrier-free version:
 198             preparedLambdaForm(mtype, which);
 199             which = LF_INVSTATIC_INIT;
 200         }
 201         if (which == LF_INVSPECIAL &amp;&amp; adaptToSpecialIfc) {
 202             which = LF_INVSPECIAL_IFC;
 203         }
 204         LambdaForm lform = preparedLambdaForm(mtype, which);
 205         maybeCompile(lform, m);
 206         assert(lform.methodType().dropParameterTypes(0, 1)
 207                 .equals(m.getInvocationType().basicType()))
 208                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
 209         return lform;
 210     }
 211 
 212     private static LambdaForm preparedLambdaForm(MemberName m) {
 213         return preparedLambdaForm(m, false);
 214     }
 215 
 216     private static LambdaForm preparedLambdaForm(MethodType mtype, int which) {
 217         LambdaForm lform = mtype.form().cachedLambdaForm(which);
 218         if (lform != null)  return lform;
 219         lform = makePreparedLambdaForm(mtype, which);
 220         return mtype.form().setCachedLambdaForm(which, lform);
 221     }
 222 
 223     static LambdaForm makePreparedLambdaForm(MethodType mtype, int which) {
 224         boolean needsInit = (which == LF_INVSTATIC_INIT);
 225         boolean doesAlloc = (which == LF_NEWINVSPECIAL);
 226         boolean needsReceiverCheck = (which == LF_INVINTERFACE ||
 227                                       which == LF_INVSPECIAL_IFC);
 228 
 229         String linkerName;
 230         LambdaForm.Kind kind;
 231         switch (which) {
 232         case LF_INVVIRTUAL:    linkerName = &quot;linkToVirtual&quot;;   kind = DIRECT_INVOKE_VIRTUAL;     break;
 233         case LF_INVSTATIC:     linkerName = &quot;linkToStatic&quot;;    kind = DIRECT_INVOKE_STATIC;      break;
 234         case LF_INVSTATIC_INIT:linkerName = &quot;linkToStatic&quot;;    kind = DIRECT_INVOKE_STATIC_INIT; break;
 235         case LF_INVSPECIAL_IFC:linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_INVOKE_SPECIAL_IFC; break;
 236         case LF_INVSPECIAL:    linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_INVOKE_SPECIAL;     break;
 237         case LF_INVINTERFACE:  linkerName = &quot;linkToInterface&quot;; kind = DIRECT_INVOKE_INTERFACE;   break;
 238         case LF_NEWINVSPECIAL: linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_NEW_INVOKE_SPECIAL; break;
 239         default:  throw new InternalError(&quot;which=&quot;+which);
 240         }
 241 
 242         MethodType mtypeWithArg = mtype.appendParameterTypes(MemberName.class);
 243         if (doesAlloc)
 244             mtypeWithArg = mtypeWithArg
 245                     .insertParameterTypes(0, Object.class)  // insert newly allocated obj
 246                     .changeReturnType(void.class);          // &lt;init&gt; returns void
 247         MemberName linker = new MemberName(MethodHandle.class, linkerName, mtypeWithArg, REF_invokeStatic);
 248         try {
 249             linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, NoSuchMethodException.class);
 250         } catch (ReflectiveOperationException ex) {
 251             throw newInternalError(ex);
 252         }
 253         final int DMH_THIS    = 0;
 254         final int ARG_BASE    = 1;
 255         final int ARG_LIMIT   = ARG_BASE + mtype.parameterCount();
 256         int nameCursor = ARG_LIMIT;
 257         final int NEW_OBJ     = (doesAlloc ? nameCursor++ : -1);
 258         final int GET_MEMBER  = nameCursor++;
 259         final int CHECK_RECEIVER = (needsReceiverCheck ? nameCursor++ : -1);
 260         final int LINKER_CALL = nameCursor++;
 261         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
 262         assert(names.length == nameCursor);
 263         if (doesAlloc) {
 264             // names = { argx,y,z,... new C, init method }
 265             names[NEW_OBJ] = new Name(getFunction(NF_allocateInstance), names[DMH_THIS]);
 266             names[GET_MEMBER] = new Name(getFunction(NF_constructorMethod), names[DMH_THIS]);
 267         } else if (needsInit) {
 268             names[GET_MEMBER] = new Name(getFunction(NF_internalMemberNameEnsureInit), names[DMH_THIS]);
 269         } else {
 270             names[GET_MEMBER] = new Name(getFunction(NF_internalMemberName), names[DMH_THIS]);
 271         }
 272         assert(findDirectMethodHandle(names[GET_MEMBER]) == names[DMH_THIS]);
 273         Object[] outArgs = Arrays.copyOfRange(names, ARG_BASE, GET_MEMBER+1, Object[].class);
 274         if (needsReceiverCheck) {
 275             names[CHECK_RECEIVER] = new Name(getFunction(NF_checkReceiver), names[DMH_THIS], names[ARG_BASE]);
 276             outArgs[0] = names[CHECK_RECEIVER];
 277         }
 278         assert(outArgs[outArgs.length-1] == names[GET_MEMBER]);  // look, shifted args!
 279         int result = LAST_RESULT;
 280         if (doesAlloc) {
 281             assert(outArgs[outArgs.length-2] == names[NEW_OBJ]);  // got to move this one
 282             System.arraycopy(outArgs, 0, outArgs, 1, outArgs.length-2);
 283             outArgs[0] = names[NEW_OBJ];
 284             result = NEW_OBJ;
 285         }
 286         names[LINKER_CALL] = new Name(linker, outArgs);
 287         LambdaForm lform = new LambdaForm(ARG_LIMIT, names, result, kind);
 288 
 289         // This is a tricky bit of code.  Don&#39;t send it through the LF interpreter.
 290         lform.compileToBytecode();
 291         return lform;
 292     }
 293 
 294     /* assert */ static Object findDirectMethodHandle(Name name) {
 295         if (name.function.equals(getFunction(NF_internalMemberName)) ||
 296             name.function.equals(getFunction(NF_internalMemberNameEnsureInit)) ||
 297             name.function.equals(getFunction(NF_constructorMethod))) {
 298             assert(name.arguments.length == 1);
 299             return name.arguments[0];
 300         }
 301         return null;
 302     }
 303 
 304     private static void maybeCompile(LambdaForm lform, MemberName m) {
 305         if (lform.vmentry == null &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), MethodHandle.class))
 306             // Help along bootstrapping...
 307             lform.compileToBytecode();
 308     }
 309 
 310     /** Static wrapper for DirectMethodHandle.internalMemberName. */
 311     @ForceInline
 312     /*non-public*/
 313     static Object internalMemberName(Object mh) {
 314         return ((DirectMethodHandle)mh).member;
 315     }
 316 
 317     /** Static wrapper for DirectMethodHandle.internalMemberName.
 318      * This one also forces initialization.
 319      */
 320     /*non-public*/
 321     static Object internalMemberNameEnsureInit(Object mh) {
 322         DirectMethodHandle dmh = (DirectMethodHandle)mh;
 323         dmh.ensureInitialized();
 324         return dmh.member;
 325     }
 326 
 327     /*non-public*/
 328     static boolean shouldBeInitialized(MemberName member) {
 329         switch (member.getReferenceKind()) {
 330         case REF_invokeStatic:
 331         case REF_getStatic:
 332         case REF_putStatic:
 333         case REF_newInvokeSpecial:
 334             break;
 335         default:
 336             // No need to initialize the class on this kind of member.
 337             return false;
 338         }
 339         Class&lt;?&gt; cls = member.getDeclaringClass();
 340         if (cls == ValueConversions.class ||
 341             cls == MethodHandleImpl.class ||
 342             cls == Invokers.class) {
 343             // These guys have lots of &lt;clinit&gt; DMH creation but we know
 344             // the MHs will not be used until the system is booted.
 345             return false;
 346         }
 347         if (VerifyAccess.isSamePackage(MethodHandle.class, cls) ||
 348             VerifyAccess.isSamePackage(ValueConversions.class, cls)) {
 349             // It is a system class.  It is probably in the process of
 350             // being initialized, but we will help it along just to be safe.
 351             if (UNSAFE.shouldBeInitialized(cls)) {
 352                 UNSAFE.ensureClassInitialized(cls);
 353             }
 354             return false;
 355         }
 356         return UNSAFE.shouldBeInitialized(cls);
 357     }
 358 
 359     private static class EnsureInitialized extends ClassValue&lt;WeakReference&lt;Thread&gt;&gt; {
 360         @Override
 361         protected WeakReference&lt;Thread&gt; computeValue(Class&lt;?&gt; type) {
 362             UNSAFE.ensureClassInitialized(type);
 363             if (UNSAFE.shouldBeInitialized(type))
 364                 // If the previous call didn&#39;t block, this can happen.
 365                 // We are executing inside &lt;clinit&gt;.
 366                 return new WeakReference&lt;&gt;(Thread.currentThread());
 367             return null;
 368         }
 369         static final EnsureInitialized INSTANCE = new EnsureInitialized();
 370     }
 371 
 372     private void ensureInitialized() {
 373         if (checkInitialized(member)) {
 374             // The coast is clear.  Delete the &lt;clinit&gt; barrier.
 375             if (member.isField())
 376                 updateForm(preparedFieldLambdaForm(member));
 377             else
 378                 updateForm(preparedLambdaForm(member));
 379         }
 380     }
 381     private static boolean checkInitialized(MemberName member) {
 382         Class&lt;?&gt; defc = member.getDeclaringClass();
 383         WeakReference&lt;Thread&gt; ref = EnsureInitialized.INSTANCE.get(defc);
 384         if (ref == null) {
 385             return true;  // the final state
 386         }
 387         Thread clinitThread = ref.get();
 388         // Somebody may still be running defc.&lt;clinit&gt;.
 389         if (clinitThread == Thread.currentThread()) {
 390             // If anybody is running defc.&lt;clinit&gt;, it is this thread.
 391             if (UNSAFE.shouldBeInitialized(defc))
 392                 // Yes, we are running it; keep the barrier for now.
 393                 return false;
 394         } else {
 395             // We are in a random thread.  Block.
 396             UNSAFE.ensureClassInitialized(defc);
 397         }
 398         assert(!UNSAFE.shouldBeInitialized(defc));
 399         // put it into the final state
 400         EnsureInitialized.INSTANCE.remove(defc);
 401         return true;
 402     }
 403 
 404     /*non-public*/
 405     static void ensureInitialized(Object mh) {
 406         ((DirectMethodHandle)mh).ensureInitialized();
 407     }
 408 
 409     /** This subclass represents invokespecial instructions. */
 410     static class Special extends DirectMethodHandle {
 411         private final Class&lt;?&gt; caller;
 412         private Special(MethodType mtype, LambdaForm form, MemberName member, Class&lt;?&gt; caller) {
 413             super(mtype, form, member);
 414             this.caller = caller;
 415         }
 416         @Override
 417         boolean isInvokeSpecial() {
 418             return true;
 419         }
 420         @Override
 421         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 422             return new Special(mt, lf, member, caller);
 423         }
 424         Object checkReceiver(Object recv) {
 425             if (!caller.isInstance(recv)) {
 426                 String msg = String.format(&quot;Receiver class %s is not a subclass of caller class %s&quot;,
 427                                            recv.getClass().getName(), caller.getName());
 428                 throw new IncompatibleClassChangeError(msg);
 429             }
 430             return recv;
 431         }
 432     }
 433 
 434     /** This subclass represents invokeinterface instructions. */
 435     static class Interface extends DirectMethodHandle {
 436         private final Class&lt;?&gt; refc;
 437         private Interface(MethodType mtype, LambdaForm form, MemberName member, Class&lt;?&gt; refc) {
 438             super(mtype, form, member);
 439             assert refc.isInterface() : refc;
 440             this.refc = refc;
 441         }
 442         @Override
 443         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 444             return new Interface(mt, lf, member, refc);
 445         }
 446         @Override
 447         Object checkReceiver(Object recv) {
 448             if (!refc.isInstance(recv)) {
 449                 String msg = String.format(&quot;Receiver class %s does not implement the requested interface %s&quot;,
 450                                            recv.getClass().getName(), refc.getName());
 451                 throw new IncompatibleClassChangeError(msg);
 452             }
 453             return recv;
 454         }
 455     }
 456 
 457     /** Used for interface receiver type checks, by Interface and Special modes. */
 458     Object checkReceiver(Object recv) {
 459         throw new InternalError(&quot;Should only be invoked on a subclass&quot;);
 460     }
 461 
 462 
 463     /** This subclass handles constructor references. */
 464     static class Constructor extends DirectMethodHandle {
 465         final MemberName initMethod;
 466         final Class&lt;?&gt;   instanceClass;
 467 
 468         private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
 469                             MemberName initMethod, Class&lt;?&gt; instanceClass) {
 470             super(mtype, form, constructor);
 471             this.initMethod = initMethod;
 472             this.instanceClass = instanceClass;
 473             assert(initMethod.isResolved());
 474         }
 475         @Override
 476         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 477             return new Constructor(mt, lf, member, initMethod, instanceClass);
 478         }
 479     }
 480 
 481     /*non-public*/
 482     static Object constructorMethod(Object mh) {
 483         Constructor dmh = (Constructor)mh;
 484         return dmh.initMethod;
 485     }
 486 
 487     /*non-public*/
 488     static Object allocateInstance(Object mh) throws InstantiationException {
 489         Constructor dmh = (Constructor)mh;
 490         return UNSAFE.allocateInstance(dmh.instanceClass);
 491     }
 492 
 493     /** This subclass handles non-static field references. */
 494     static abstract class Accessor extends DirectMethodHandle {
 495         final Class&lt;?&gt; fieldType;
 496         final int fieldOffset;
 497 
 498         protected Accessor(MethodType mtype, LambdaForm form, MemberName member,
 499                            int fieldOffset) {
 500             super(mtype, form, member);
 501             this.fieldType = member.getFieldType();
 502             this.fieldOffset = fieldOffset;
 503         }
 504         abstract Object checkCast(Object obj);
 505         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
 506     }
 507 
 508     /** This subclass handles non-static field references of indirect type */
 509     static class IndirectAccessor extends Accessor {
 510         private IndirectAccessor(MethodType mtype, LambdaForm form, MemberName member,
 511                                  int fieldOffset) {
 512             super(mtype, form, member, fieldOffset);
 513         }
 514 
 515         @Override Object checkCast(Object obj) {
 516             return fieldType.cast(obj);
 517         }
 518         @Override
 519         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 520             return new IndirectAccessor(mt, lf, member, fieldOffset);
 521         }
 522     }
 523 
 524     /** This subclass handles non-static field references of inline type */
 525     static class InlineAccessor extends Accessor {
 526         private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
 527                                int fieldOffset) {
 528             super(mtype, form, member, fieldOffset);
 529         }
 530 
 531         @Override Object checkCast(Object obj) {
 532             return fieldType.cast(Objects.requireNonNull(obj));
 533         }
 534         @Override
 535         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 536             return new InlineAccessor(mt, lf, member, fieldOffset);
 537         }
 538     }
 539 
 540     @ForceInline
 541     /*non-public*/
 542     static long fieldOffset(Object accessorObj) {
 543         // Note: We return a long because that is what Unsafe.getObject likes.
 544         // We store a plain int because it is more compact.
 545         return ((Accessor)accessorObj).fieldOffset;
 546     }
 547 
 548     @ForceInline
 549     /*non-public*/
 550     static Object checkBase(Object obj) {
 551         // Note that the object&#39;s class has already been verified,
 552         // since the parameter type of the Accessor method handle
 553         // is either member.getDeclaringClass or a subclass.
 554         // This was verified in DirectMethodHandle.make.
 555         // Therefore, the only remaining check is for null.
 556         // Since this check is *not* guaranteed by Unsafe.getInt
 557         // and its siblings, we need to make an explicit one here.
 558         return Objects.requireNonNull(obj);
 559     }
 560 
 561     static abstract class StaticAccessor extends DirectMethodHandle {
 562         final Class&lt;?&gt; fieldType;
 563         final Object staticBase;
 564         final long staticOffset;
 565 
 566         protected StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 567                                  Object staticBase, long staticOffset) {
 568             super(mtype, form, member);
 569             this.fieldType = member.getFieldType();
 570             this.staticBase = staticBase;
 571             this.staticOffset = staticOffset;
 572         }
 573         abstract Object checkCast(Object obj);
 574         abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
 575     }
 576 
 577     /** This subclass handles static field references of indirect type. */
 578     static class IndirectStaticAccessor extends StaticAccessor {
 579         private IndirectStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 580                                      Object staticBase, long staticOffset) {
 581             super(mtype, form, member, staticBase, staticOffset);
 582         }
 583 
 584         // indirect type is always nullable
 585         @Override Object checkCast(Object obj) {
 586             return fieldType.cast(obj);
 587         }
 588         @Override
 589         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 590             return new IndirectStaticAccessor(mt, lf, member, staticBase, staticOffset);
 591         }
 592     }
 593 
 594     /** This subclass handles static field references of inline type . */
 595     static class InlineStaticAccessor extends StaticAccessor {
 596         private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 597                                      Object staticBase, long staticOffset) {
 598             super(mtype, form, member, staticBase, staticOffset);
 599         }
 600 
 601         // zero-default inline type is not-nullable
 602         @Override Object checkCast(Object obj) {
 603             assert !fieldType.isNullableType() : &quot;null-default inline type not yet supported&quot;;
 604             return fieldType.cast(Objects.requireNonNull(obj));
 605         }
 606         @Override
 607         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 608             return new InlineStaticAccessor(mt, lf, member, staticBase, staticOffset);
 609         }
 610     }
 611 
 612     @ForceInline
 613     /*non-public*/
 614     static Object nullCheck(Object obj) {
 615         return Objects.requireNonNull(obj);
 616     }
 617 
 618     @ForceInline
 619     /*non-public*/
 620     static Object staticBase(Object accessorObj) {
 621         return ((StaticAccessor)accessorObj).staticBase;
 622     }
 623 
 624     @ForceInline
 625     /*non-public*/
 626     static long staticOffset(Object accessorObj) {
 627         return ((StaticAccessor)accessorObj).staticOffset;
 628     }
 629 
 630     @ForceInline
 631     /*non-public*/
 632     static Object checkCast(Object mh, Object obj) {
 633         return ((DirectMethodHandle) mh).checkCast(obj);
 634     }
 635 
 636     @ForceInline
 637     /*non-public*/ static Class&lt;?&gt; fieldType(Object accessorObj) {
 638         return ((Accessor) accessorObj).fieldType;
 639     }
 640 
 641     @ForceInline
 642     /*non-public*/ static Class&lt;?&gt; staticFieldType(Object accessorObj) {
 643         return ((StaticAccessor) accessorObj).fieldType;
 644     }
 645 
 646     Object checkCast(Object obj) {
 647         return member.getReturnType().cast(obj);
 648     }
 649 
 650     // Caching machinery for field accessors:
 651     static final byte
 652             AF_GETFIELD        = 0,
 653             AF_PUTFIELD        = 1,
 654             AF_GETSTATIC       = 2,
 655             AF_PUTSTATIC       = 3,
 656             AF_GETSTATIC_INIT  = 4,
 657             AF_PUTSTATIC_INIT  = 5,
 658             AF_LIMIT           = 6;
 659     // Enumerate the different field kinds using Wrapper,
 660     // with an extra case added for checked references and value field access
 661     static final int
 662             FT_LAST_WRAPPER     = Wrapper.COUNT-1,
 663             FT_UNCHECKED_REF    = Wrapper.OBJECT.ordinal(),
 664             FT_CHECKED_REF      = FT_LAST_WRAPPER+1,
 665             FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  // flattened and non-flattened
 666             FT_LIMIT            = FT_LAST_WRAPPER+4;
 667     private static int afIndex(byte formOp, boolean isVolatile, boolean isFlatValue, int ftypeKind) {
 668         return ((formOp * FT_LIMIT * 2)
 669                 + (isVolatile ? FT_LIMIT : 0)
 670                 + (isFlatValue ? 1 : 0)
 671                 + ftypeKind);
 672     }
 673     @Stable
 674     private static final LambdaForm[] ACCESSOR_FORMS
 675             = new LambdaForm[afIndex(AF_LIMIT, false, false, 0)];
 676     static int ftypeKind(Class&lt;?&gt; ftype, boolean isValue) {
 677         if (ftype.isPrimitive())
 678             return Wrapper.forPrimitiveType(ftype).ordinal();
 679         else if (VerifyType.isNullReferenceConversion(Object.class, ftype)) {
 680             return FT_UNCHECKED_REF;
 681         } else
 682             // null check for value type in addition to check cast
 683             return isValue ? FT_CHECKED_VALUE : FT_CHECKED_REF;
 684     }
 685 
 686     /**
 687      * Create a LF which can access the given field.
 688      * Cache and share this structure among all fields with
 689      * the same basicType and refKind.
 690      */
 691     private static LambdaForm preparedFieldLambdaForm(MemberName m) {
 692         Class&lt;?&gt; ftype = m.getFieldType();
 693         byte formOp;
 694         switch (m.getReferenceKind()) {
 695         case REF_getField:      formOp = AF_GETFIELD;    break;
 696         case REF_putField:      formOp = AF_PUTFIELD;    break;
 697         case REF_getStatic:     formOp = AF_GETSTATIC;   break;
 698         case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
 699         default:  throw new InternalError(m.toString());
 700         }
 701         if (shouldBeInitialized(m)) {
 702             // precompute the barrier-free version:
 703             preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineable(), m.isFlattened(), ftype);
 704             assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
 705                    (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
 706             formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
 707         }
 708         LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineable(), m.isFlattened(), ftype);
 709         maybeCompile(lform, m);
 710         assert(lform.methodType().dropParameterTypes(0, 1)
 711                 .equals(m.getInvocationType().basicType()))
 712                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
 713         return lform;
 714     }
 715 
 716     private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, Class&lt;?&gt; ftype) {
 717         int ftypeKind = ftypeKind(ftype, isValue);
 718         int afIndex = afIndex(formOp, isVolatile, isFlatValue, ftypeKind);
 719         LambdaForm lform = ACCESSOR_FORMS[afIndex];
 720         if (lform != null)  return lform;
 721         lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlatValue, ftypeKind);
 722         ACCESSOR_FORMS[afIndex] = lform;  // don&#39;t bother with a CAS
 723         return lform;
 724     }
 725 
 726     private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();
 727 
 728     private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlatValue, Wrapper wrapper) {
 729         if (isGetter) {
 730             if (isVolatile) {
 731                 switch (wrapper) {
 732                     case BOOLEAN: return GET_BOOLEAN_VOLATILE;
 733                     case BYTE:    return GET_BYTE_VOLATILE;
 734                     case SHORT:   return GET_SHORT_VOLATILE;
 735                     case CHAR:    return GET_CHAR_VOLATILE;
 736                     case INT:     return GET_INT_VOLATILE;
 737                     case LONG:    return GET_LONG_VOLATILE;
 738                     case FLOAT:   return GET_FLOAT_VOLATILE;
 739                     case DOUBLE:  return GET_DOUBLE_VOLATILE;
 740                     case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;
 741                 }
 742             } else {
 743                 switch (wrapper) {
 744                     case BOOLEAN: return GET_BOOLEAN;
 745                     case BYTE:    return GET_BYTE;
 746                     case SHORT:   return GET_SHORT;
 747                     case CHAR:    return GET_CHAR;
 748                     case INT:     return GET_INT;
 749                     case LONG:    return GET_LONG;
 750                     case FLOAT:   return GET_FLOAT;
 751                     case DOUBLE:  return GET_DOUBLE;
 752                     case OBJECT:  return isFlatValue ? GET_VALUE : GET_REFERENCE;
 753                 }
 754             }
 755         } else {
 756             if (isVolatile) {
 757                 switch (wrapper) {
 758                     case BOOLEAN: return PUT_BOOLEAN_VOLATILE;
 759                     case BYTE:    return PUT_BYTE_VOLATILE;
 760                     case SHORT:   return PUT_SHORT_VOLATILE;
 761                     case CHAR:    return PUT_CHAR_VOLATILE;
 762                     case INT:     return PUT_INT_VOLATILE;
 763                     case LONG:    return PUT_LONG_VOLATILE;
 764                     case FLOAT:   return PUT_FLOAT_VOLATILE;
 765                     case DOUBLE:  return PUT_DOUBLE_VOLATILE;
 766                     case OBJECT:  return isFlatValue ? PUT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;
 767                 }
 768             } else {
 769                 switch (wrapper) {
 770                     case BOOLEAN: return PUT_BOOLEAN;
 771                     case BYTE:    return PUT_BYTE;
 772                     case SHORT:   return PUT_SHORT;
 773                     case CHAR:    return PUT_CHAR;
 774                     case INT:     return PUT_INT;
 775                     case LONG:    return PUT_LONG;
 776                     case FLOAT:   return PUT_FLOAT;
 777                     case DOUBLE:  return PUT_DOUBLE;
 778                     case OBJECT:  return isFlatValue ? PUT_VALUE : PUT_REFERENCE;
 779                 }
 780             }
 781         }
 782         throw new AssertionError(&quot;Invalid arguments&quot;);
 783     }
 784 
 785     /** invoked by GenerateJLIClassesHelper */
 786     static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftype) {
 787         return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);
 788     }
 789 
 790     private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, int ftypeKind) {
 791         boolean isGetter  = (formOp &amp; 1) == (AF_GETFIELD &amp; 1);
 792         boolean isStatic  = (formOp &gt;= AF_GETSTATIC);
 793         boolean needsInit = (formOp &gt;= AF_GETSTATIC_INIT);
 794         boolean needsCast = (ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_VALUE);
 795         Wrapper fw = (needsCast ? Wrapper.OBJECT : ALL_WRAPPERS[ftypeKind]);
 796         Class&lt;?&gt; ft = fw.primitiveType();
 797         assert(needsCast ? true : ftypeKind(ft, isValue) == ftypeKind);
 798 
 799         // getObject, putIntVolatile, etc.
 800         Kind kind = getFieldKind(isGetter, isVolatile, isFlatValue, fw);
 801 
 802         MethodType linkerType;
 803         boolean hasValueTypeArg = isGetter ? isValue : isFlatValue;
 804         if (isGetter) {
 805             linkerType = isValue ? MethodType.methodType(ft, Object.class, long.class, Class.class)
 806                                  : MethodType.methodType(ft, Object.class, long.class);
 807         } else {
 808             linkerType = isFlatValue ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)
 809                                      : MethodType.methodType(void.class, Object.class, long.class, ft);
 810         }
 811         MemberName linker = new MemberName(Unsafe.class, kind.methodName, linkerType, REF_invokeVirtual);
 812         try {
 813             linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, NoSuchMethodException.class);
 814         } catch (ReflectiveOperationException ex) {
 815             throw newInternalError(ex);
 816         }
 817 
 818         // What is the external type of the lambda form?
 819         MethodType mtype;
 820         if (isGetter)
 821             mtype = MethodType.methodType(ft);
 822         else
 823             mtype = MethodType.methodType(void.class, ft);
 824         mtype = mtype.basicType();  // erase short to int, etc.
 825         if (!isStatic)
 826             mtype = mtype.insertParameterTypes(0, Object.class);
 827         final int DMH_THIS  = 0;
 828         final int ARG_BASE  = 1;
 829         final int ARG_LIMIT = ARG_BASE + mtype.parameterCount();
 830         // if this is for non-static access, the base pointer is stored at this index:
 831         final int OBJ_BASE  = isStatic ? -1 : ARG_BASE;
 832         // if this is for write access, the value to be written is stored at this index:
 833         final int SET_VALUE  = isGetter ? -1 : ARG_LIMIT - 1;
 834         int nameCursor = ARG_LIMIT;
 835         final int F_HOLDER  = (isStatic ? nameCursor++ : -1);  // static base if any
 836         final int F_OFFSET  = nameCursor++;  // Either static offset or field offset.
 837         final int OBJ_CHECK = (OBJ_BASE &gt;= 0 ? nameCursor++ : -1);
 838         final int U_HOLDER  = nameCursor++;  // UNSAFE holder
 839         final int INIT_BAR  = (needsInit ? nameCursor++ : -1);
 840         final int VALUE_TYPE = (hasValueTypeArg ? nameCursor++ : -1);
 841         final int PRE_CAST  = (needsCast &amp;&amp; !isGetter ? nameCursor++ : -1);
 842         final int LINKER_CALL = nameCursor++;
 843         final int POST_CAST = (needsCast &amp;&amp; isGetter ? nameCursor++ : -1);
 844         final int RESULT    = nameCursor-1;  // either the call or the cast
 845         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
 846         if (needsInit)
 847             names[INIT_BAR] = new Name(getFunction(NF_ensureInitialized), names[DMH_THIS]);
 848         if (needsCast &amp;&amp; !isGetter)
 849             names[PRE_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[SET_VALUE]);
 850         Object[] outArgs = new Object[1 + linkerType.parameterCount()];
 851         assert (outArgs.length == (isGetter ? 3 : 4) + (hasValueTypeArg ? 1 : 0));
 852         outArgs[0] = names[U_HOLDER] = new Name(getFunction(NF_UNSAFE));
 853         if (isStatic) {
 854             outArgs[1] = names[F_HOLDER]  = new Name(getFunction(NF_staticBase), names[DMH_THIS]);
 855             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_staticOffset), names[DMH_THIS]);
 856         } else {
 857             outArgs[1] = names[OBJ_CHECK] = new Name(getFunction(NF_checkBase), names[OBJ_BASE]);
 858             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_fieldOffset), names[DMH_THIS]);
 859         }
 860         int x = 3;
 861         if (hasValueTypeArg) {
 862             outArgs[x++] = names[VALUE_TYPE] = isStatic ? new Name(getFunction(NF_staticFieldType), names[DMH_THIS])
 863                                                         : new Name(getFunction(NF_fieldType), names[DMH_THIS]);
 864         }
 865         if (!isGetter) {
 866             outArgs[x] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);
 867         }
 868         for (Object a : outArgs)  assert(a != null);
 869         names[LINKER_CALL] = new Name(linker, outArgs);
 870         if (needsCast &amp;&amp; isGetter)
 871             names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[LINKER_CALL]);
 872         for (Name n : names)  assert(n != null);
 873 
 874         LambdaForm form;
 875         if (needsCast || needsInit) {
 876             // can&#39;t use the pre-generated form when casting and/or initializing
 877             form = new LambdaForm(ARG_LIMIT, names, RESULT);
 878         } else {
 879             form = new LambdaForm(ARG_LIMIT, names, RESULT, kind);
 880         }
 881 
 882         if (LambdaForm.debugNames()) {
 883             // add some detail to the lambdaForm debugname,
 884             // significant only for debugging
 885             StringBuilder nameBuilder = new StringBuilder(kind.methodName);
 886             if (isStatic) {
 887                 nameBuilder.append(&quot;Static&quot;);
 888             } else {
 889                 nameBuilder.append(&quot;Field&quot;);
 890             }
 891             if (needsCast) {
 892                 nameBuilder.append(&quot;Cast&quot;);
 893             }
 894             if (needsInit) {
 895                 nameBuilder.append(&quot;Init&quot;);
 896             }
 897             LambdaForm.associateWithDebugName(form, nameBuilder.toString());
 898         }
 899         return form;
 900     }
 901 
 902     /**
 903      * Pre-initialized NamedFunctions for bootstrapping purposes.
 904      */
 905     static final byte NF_internalMemberName = 0,
 906             NF_internalMemberNameEnsureInit = 1,
 907             NF_ensureInitialized = 2,
 908             NF_fieldOffset = 3,
 909             NF_checkBase = 4,
 910             NF_staticBase = 5,
 911             NF_staticOffset = 6,
 912             NF_checkCast = 7,
 913             NF_allocateInstance = 8,
 914             NF_constructorMethod = 9,
 915             NF_UNSAFE = 10,
 916             NF_checkReceiver = 11,
 917             NF_fieldType = 12,
 918             NF_staticFieldType = 13,
 919             NF_LIMIT = 14;
 920 
 921     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
 922 
 923     private static NamedFunction getFunction(byte func) {
 924         NamedFunction nf = NFS[func];
 925         if (nf != null) {
 926             return nf;
 927         }
 928         // Each nf must be statically invocable or we get tied up in our bootstraps.
 929         nf = NFS[func] = createFunction(func);
 930         assert(InvokerBytecodeGenerator.isStaticallyInvocable(nf));
 931         return nf;
 932     }
 933 
 934     private static final MethodType CLS_OBJ_TYPE = MethodType.methodType(Class.class, Object.class);
 935 
 936     private static final MethodType OBJ_OBJ_TYPE = MethodType.methodType(Object.class, Object.class);
 937 
 938     private static final MethodType LONG_OBJ_TYPE = MethodType.methodType(long.class, Object.class);
 939 
 940     private static NamedFunction createFunction(byte func) {
 941         try {
 942             switch (func) {
 943                 case NF_internalMemberName:
 944                     return getNamedFunction(&quot;internalMemberName&quot;, OBJ_OBJ_TYPE);
 945                 case NF_internalMemberNameEnsureInit:
 946                     return getNamedFunction(&quot;internalMemberNameEnsureInit&quot;, OBJ_OBJ_TYPE);
 947                 case NF_ensureInitialized:
 948                     return getNamedFunction(&quot;ensureInitialized&quot;, MethodType.methodType(void.class, Object.class));
 949                 case NF_fieldOffset:
 950                     return getNamedFunction(&quot;fieldOffset&quot;, LONG_OBJ_TYPE);
 951                 case NF_checkBase:
 952                     return getNamedFunction(&quot;checkBase&quot;, OBJ_OBJ_TYPE);
 953                 case NF_staticBase:
 954                     return getNamedFunction(&quot;staticBase&quot;, OBJ_OBJ_TYPE);
 955                 case NF_staticOffset:
 956                     return getNamedFunction(&quot;staticOffset&quot;, LONG_OBJ_TYPE);
 957                 case NF_checkCast:
 958                     return getNamedFunction(&quot;checkCast&quot;, MethodType.methodType(Object.class, Object.class, Object.class));
 959                 case NF_allocateInstance:
 960                     return getNamedFunction(&quot;allocateInstance&quot;, OBJ_OBJ_TYPE);
 961                 case NF_constructorMethod:
 962                     return getNamedFunction(&quot;constructorMethod&quot;, OBJ_OBJ_TYPE);
 963                 case NF_UNSAFE:
 964                     MemberName member = new MemberName(MethodHandleStatics.class, &quot;UNSAFE&quot;, Unsafe.class, REF_getField);
 965                     return new NamedFunction(
 966                             MemberName.getFactory()
 967                                     .resolveOrFail(REF_getField, member, DirectMethodHandle.class, NoSuchMethodException.class));
 968                 case NF_checkReceiver:
 969                     member = new MemberName(DirectMethodHandle.class, &quot;checkReceiver&quot;, OBJ_OBJ_TYPE, REF_invokeVirtual);
 970                     return new NamedFunction(
 971                         MemberName.getFactory()
 972                             .resolveOrFail(REF_invokeVirtual, member, DirectMethodHandle.class, NoSuchMethodException.class));
 973                 case NF_fieldType:
 974                     return getNamedFunction(&quot;fieldType&quot;, CLS_OBJ_TYPE);
 975                 case NF_staticFieldType:
 976                     return getNamedFunction(&quot;staticFieldType&quot;, CLS_OBJ_TYPE);
 977                 default:
 978                     throw newInternalError(&quot;Unknown function: &quot; + func);
 979             }
 980         } catch (ReflectiveOperationException ex) {
 981             throw newInternalError(ex);
 982         }
 983     }
 984 
 985     private static NamedFunction getNamedFunction(String name, MethodType type)
 986         throws ReflectiveOperationException
 987     {
 988         MemberName member = new MemberName(DirectMethodHandle.class, name, type, REF_invokeStatic);
 989         return new NamedFunction(
 990             MemberName.getFactory()
 991                 .resolveOrFail(REF_invokeStatic, member, DirectMethodHandle.class, NoSuchMethodException.class));
 992     }
 993 
 994     static {
 995         // The Holder class will contain pre-generated DirectMethodHandles resolved
 996         // speculatively using MemberName.getFactory().resolveOrNull. However, that
 997         // doesn&#39;t initialize the class, which subtly breaks inlining etc. By forcing
 998         // initialization of the Holder class we avoid these issues.
 999         UNSAFE.ensureClassInitialized(Holder.class);
1000     }
1001 
1002     /* Placeholder class for DirectMethodHandles generated ahead of time */
1003     final class Holder {}
1004 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
  31 import java.lang.module.ModuleReader;
  32 import java.lang.ref.SoftReference;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.ObjectStreamField;
  36 import java.lang.reflect.AnnotatedElement;
  37 import java.lang.reflect.AnnotatedType;
  38 import java.lang.reflect.Array;
  39 import java.lang.reflect.Constructor;
  40 import java.lang.reflect.Executable;
  41 import java.lang.reflect.Field;
  42 import java.lang.reflect.GenericArrayType;
  43 import java.lang.reflect.GenericDeclaration;
  44 import java.lang.reflect.InvocationTargetException;
  45 import java.lang.reflect.Member;
  46 import java.lang.reflect.Method;
  47 import java.lang.reflect.Modifier;
  48 import java.lang.reflect.Proxy;
  49 import java.lang.reflect.RecordComponent;
  50 import java.lang.reflect.Type;
  51 import java.lang.reflect.TypeVariable;
  52 import java.lang.constant.Constable;
  53 import java.net.URL;
  54 import java.security.AccessController;
  55 import java.security.PrivilegedAction;
  56 import java.util.ArrayList;
  57 import java.util.Arrays;
  58 import java.util.Collection;
  59 import java.util.HashMap;
  60 import java.util.LinkedHashMap;
  61 import java.util.LinkedHashSet;
  62 import java.util.List;
  63 import java.util.Map;
  64 import java.util.Objects;
  65 import java.util.Optional;
  66 import java.util.stream.Collectors;
  67 
  68 import jdk.internal.HotSpotIntrinsicCandidate;
  69 import jdk.internal.loader.BootLoader;
  70 import jdk.internal.loader.BuiltinClassLoader;
  71 import jdk.internal.misc.Unsafe;
  72 import jdk.internal.module.Resources;
  73 import jdk.internal.reflect.CallerSensitive;
  74 import jdk.internal.reflect.ConstantPool;
  75 import jdk.internal.reflect.Reflection;
  76 import jdk.internal.reflect.ReflectionFactory;
  77 import jdk.internal.vm.annotation.ForceInline;
  78 import sun.invoke.util.Wrapper;
  79 import sun.reflect.generics.factory.CoreReflectionFactory;
  80 import sun.reflect.generics.factory.GenericsFactory;
  81 import sun.reflect.generics.repository.ClassRepository;
  82 import sun.reflect.generics.repository.MethodRepository;
  83 import sun.reflect.generics.repository.ConstructorRepository;
  84 import sun.reflect.generics.scope.ClassScope;
  85 import sun.security.util.SecurityConstants;
  86 import sun.reflect.annotation.*;
  87 import sun.reflect.misc.ReflectUtil;
  88 
  89 /**
  90  * Instances of the class {@code Class} represent classes and
  91  * interfaces in a running Java application. An enum type and a record
  92  * type are kinds of class; an annotation type is a kind of
  93  * interface. Every array also belongs to a class that is reflected as
  94  * a {@code Class} object that is shared by all arrays with the same
  95  * element type and number of dimensions.  The primitive Java types
  96  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  97  * int}, {@code long}, {@code float}, and {@code double}), and the
  98  * keyword {@code void} are also represented as {@code Class} objects.
  99  *
 100  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
 101  * object is constructed automatically by the Java Virtual Machine
 102  * when a class loader invokes one of the
 103  * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
 104  * and passes the bytes of a {@code class} file.
 105  *
 106  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 107  * class or interface. Most characteristics are derived from the {@code class}
 108  * file that the class loader passed to the Java Virtual Machine. A few
 109  * characteristics are determined by the class loading environment at run time,
 110  * such as the module returned by {@link #getModule() getModule()}.
 111  *
 112  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 113  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 114  * another declaration. Other methods describe how a class or interface
 115  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 116  * classes and interfaces, in the same run-time package, that
 117  * allow mutual access to their {@code private} members.
 118  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 119  * One nestmate acts as the
 120  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 121  * belong to the nest; each of them in turn records it as the nest host.
 122  * The classes and interfaces which belong to a nest, including its host, are
 123  * determined when
 124  * {@code class} files are generated, for example, a Java compiler
 125  * will typically record a top-level class as the host of a nest where the
 126  * other members are the classes and interfaces whose declarations are
 127  * enclosed within the top-level class declaration.
 128  *
 129  * &lt;p&gt; The following example uses a {@code Class} object to print the
 130  * class name of an object:
 131  *
 132  * &lt;blockquote&gt;&lt;pre&gt;
 133  *     void printClassName(Object obj) {
 134  *         System.out.println(&quot;The class of &quot; + obj +
 135  *                            &quot; is &quot; + obj.getClass().getName());
 136  *     }
 137  * &lt;/pre&gt;&lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
 140  * type (or for void) using a class literal.  See Section {@jls
 141  * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 142  * For example:
 143  *
 144  * &lt;blockquote&gt;
 145  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
 166     private static final int INLINE     = 0x00000100;
 167 
 168     private static native void registerNatives();
 169     static {
 170         registerNatives();
 171     }
 172 
 173     /*
 174      * Private constructor. Only the Java Virtual Machine creates Class objects.
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
 195      * @return a string representation of this {@code Class} object.
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 200                + getName();
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * {@code @interface}, or {@code record} as appropriate), followed
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
 221      * followed by an angle-bracketed comma-separated list of the
 222      * type&#39;s type parameters, if any, followed by a sequence of
 223      * {@code []} characters, one set of brackets per dimension of
 224      * the array.
 225      *
 226      * &lt;p&gt;Note that since information about the runtime representation
 227      * of a type is being generated, modifiers not present on the
 228      * originating source code or illegal on the originating source
 229      * code may be present.
 230      *
 231      * @return a string describing this {@code Class}, including
 232      * information about modifiers and type parameters
 233      *
 234      * @since 1.8
 235      */
 236     @SuppressWarnings(&quot;preview&quot;)
 237     public String toGenericString() {
 238         if (isPrimitive()) {
 239             return toString();
 240         } else {
 241             StringBuilder sb = new StringBuilder();
 242             Class&lt;?&gt; component = this;
 243             int arrayDepth = 0;
 244 
 245             if (isArray()) {
 246                 do {
 247                     arrayDepth++;
 248                     component = component.getComponentType();
 249                 } while (component.isArray());
 250                 sb.append(component.getName());
 251             } else {
 252                 // Class modifiers are a superset of interface modifiers
 253                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 254                 if (modifiers != 0) {
 255                     sb.append(Modifier.toString(modifiers));
 256                     sb.append(&#39; &#39;);
 257                 }
 258 
 259                 if (isAnnotation()) {
 260                     sb.append(&#39;@&#39;);
 261                 }
 262                 if (isInlineClass()) {
 263                     sb.append(&quot;inline&quot;);
 264                     sb.append(&#39; &#39;);
 265                 }
 266                 if (isInterface()) { // Note: all annotation types are interfaces
 267                     sb.append(&quot;interface&quot;);
 268                 } else {
 269                     if (isEnum())
 270                         sb.append(&quot;enum&quot;);
 271                     else if (isRecord())
 272                         sb.append(&quot;record&quot;);
 273                     else
 274                         sb.append(&quot;class&quot;);
 275                 }
 276                 sb.append(&#39; &#39;);
 277                 sb.append(getName());
 278             }
 279 
 280             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 281             if (typeparms.length &gt; 0) {
 282                 sb.append(Arrays.stream(typeparms)
 283                           .map(Class::typeVarBounds)
 284                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 285             }
 286 
 287             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));
 288 
 289             return sb.toString();
 290         }
 291     }
 292 
 293     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 294         Type[] bounds = typeVar.getBounds();
 295         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 296             return typeVar.getName();
 297         } else {
 298             return typeVar.getName() + &quot; extends &quot; +
 299                 Arrays.stream(bounds)
 300                 .map(Type::getTypeName)
 301                 .collect(Collectors.joining(&quot; &amp; &quot;));
 302         }
 303     }
 304 
 305     /**
 306      * Returns the {@code Class} object associated with the class or
 307      * interface with the given string name.  Invoking this method is
 308      * equivalent to:
 309      *
 310      * &lt;blockquote&gt;
 311      *  {@code Class.forName(className, true, currentLoader)}
 312      * &lt;/blockquote&gt;
 313      *
 314      * where {@code currentLoader} denotes the defining class loader of
 315      * the current class.
 316      *
 317      * &lt;p&gt; For example, the following code fragment returns the
 318      * runtime {@code Class} descriptor for the class named
 319      * {@code java.lang.Thread}:
 320      *
 321      * &lt;blockquote&gt;
 322      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 323      * &lt;/blockquote&gt;
 324      * &lt;p&gt;
 325      * A call to {@code forName(&quot;X&quot;)} causes the class named
 326      * {@code X} to be initialized.
 327      *
 328      * @param      className   the fully qualified name of the desired class.
 329      * @return     the {@code Class} object for the class with the
 330      *             specified name.
 331      * @throws    LinkageError if the linkage fails
 332      * @throws    ExceptionInInitializerError if the initialization provoked
 333      *            by this method fails
 334      * @throws    ClassNotFoundException if the class cannot be located
 335      *
 336      * @jls 12.2 Loading of Classes and Interfaces
 337      * @jls 12.3 Linking of Classes and Interfaces
 338      * @jls 12.4 Initialization of Classes and Interfaces
 339      */
 340     @CallerSensitive
 341     public static Class&lt;?&gt; forName(String className)
 342                 throws ClassNotFoundException {
 343         Class&lt;?&gt; caller = Reflection.getCallerClass();
 344         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 345     }
 346 
 347 
 348     /**
 349      * Returns the {@code Class} object associated with the class or
 350      * interface with the given string name, using the given class loader.
 351      * Given the fully qualified name for a class or interface (in the same
 352      * format returned by {@code getName}) this method attempts to
 353      * locate and load the class or interface.  The specified class
 354      * loader is used to load the class or interface.  If the parameter
 355      * {@code loader} is null, the class is loaded through the bootstrap
 356      * class loader.  The class is initialized only if the
 357      * {@code initialize} parameter is {@code true} and if it has
 358      * not been initialized earlier.
 359      *
 360      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 361      * will be made to locate a user-defined class in the unnamed package whose
 362      * name is {@code name}. Therefore, this method cannot be used to
 363      * obtain any of the {@code Class} objects representing primitive
 364      * types or void.
 365      *
 366      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 367      * the array class is loaded but not initialized.
 368      *
 369      * &lt;p&gt; For example, in an instance method the expression:
 370      *
 371      * &lt;blockquote&gt;
 372      *  {@code Class.forName(&quot;Foo&quot;)}
 373      * &lt;/blockquote&gt;
 374      *
 375      * is equivalent to:
 376      *
 377      * &lt;blockquote&gt;
 378      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 379      * &lt;/blockquote&gt;
 380      *
 381      * Note that this method throws errors related to loading, linking
 382      * or initializing as specified in Sections {@jls 12.2}, {@jls
 383      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language
 384      * Specification&lt;/cite&gt;.
 385      * Note that this method does not check whether the requested class
 386      * is accessible to its caller.
 387      *
 388      * @param name       fully qualified name of the desired class
 389 
 390      * @param initialize if {@code true} the class will be initialized
 391      *                   (which implies linking). See Section {@jls
 392      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language
 393      *                   Specification&lt;/cite&gt;.
 394      * @param loader     class loader from which the class must be loaded
 395      * @return           class object representing the desired class
 396      *
 397      * @throws    LinkageError if the linkage fails
 398      * @throws    ExceptionInInitializerError if the initialization provoked
 399      *            by this method fails
 400      * @throws    ClassNotFoundException if the class cannot be located by
 401      *            the specified class loader
 402      * @throws    SecurityException
 403      *            if a security manager is present, and the {@code loader} is
 404      *            {@code null}, and the caller&#39;s class loader is not
 405      *            {@code null}, and the caller does not have the
 406      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 407      *
 408      * @see       java.lang.Class#forName(String)
 409      * @see       java.lang.ClassLoader
 410      *
 411      * @jls 12.2 Loading of Classes and Interfaces
 412      * @jls 12.3 Linking of Classes and Interfaces
 413      * @jls 12.4 Initialization of Classes and Interfaces
 414      * @since     1.2
 415      */
 416     @CallerSensitive
 417     public static Class&lt;?&gt; forName(String name, boolean initialize,
 418                                    ClassLoader loader)
 419         throws ClassNotFoundException
 420     {
 421         Class&lt;?&gt; caller = null;
 422         SecurityManager sm = System.getSecurityManager();
 423         if (sm != null) {
 424             // Reflective call to get caller class is only needed if a security manager
 425             // is present.  Avoid the overhead of making this call otherwise.
 426             caller = Reflection.getCallerClass();
 427             if (loader == null) {
 428                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 429                 if (ccl != null) {
 430                     sm.checkPermission(
 431                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 432                 }
 433             }
 434         }
 435         return forName0(name, initialize, loader, caller);
 436     }
 437 
 438     /** Called after security check for system loader access checks have been made. */
 439     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 440                                     ClassLoader loader,
 441                                     Class&lt;?&gt; caller)
 442         throws ClassNotFoundException;
 443 
 444 
 445     /**
 446      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 447      * binary name&lt;/a&gt; in the given module.
 448      *
 449      * &lt;p&gt; This method attempts to locate and load the class or interface.
 450      * It does not link the class, and does not run the class initializer.
 451      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 452      *
 453      * &lt;p&gt; If the class loader of the given module defines other modules and
 454      * the given name is a class defined in a different module, this method
 455      * returns {@code null} after the class is loaded. &lt;/p&gt;
 456      *
 457      * &lt;p&gt; This method does not check whether the requested class is
 458      * accessible to its caller. &lt;/p&gt;
 459      *
 460      * @apiNote
 461      * This method returns {@code null} on failure rather than
 462      * throwing a {@link ClassNotFoundException}, as is done by
 463      * the {@link #forName(String, boolean, ClassLoader)} method.
 464      * The security check is a stack-based permission check if the caller
 465      * loads a class in another module.
 466      *
 467      * @param  module   A module
 468      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 469      *                  of the class
 470      * @return {@code Class} object of the given name defined in the given module;
 471      *         {@code null} if not found.
 472      *
 473      * @throws NullPointerException if the given module or name is {@code null}
 474      *
 475      * @throws LinkageError if the linkage fails
 476      *
 477      * @throws SecurityException
 478      *         &lt;ul&gt;
 479      *         &lt;li&gt; if the caller is not the specified module and
 480      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 481      *         &lt;li&gt; access to the module content is denied. For example,
 482      *         permission check will be performed when a class loader calls
 483      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 484      *         in a module.&lt;/li&gt;
 485      *         &lt;/ul&gt;
 486      *
 487      * @jls 12.2 Loading of Classes and Interfaces
 488      * @jls 12.3 Linking of Classes and Interfaces
 489      * @since 9
 490      * @spec JPMS
 491      */
 492     @CallerSensitive
 493     public static Class&lt;?&gt; forName(Module module, String name) {
 494         Objects.requireNonNull(module);
 495         Objects.requireNonNull(name);
 496 
 497         ClassLoader cl;
 498         SecurityManager sm = System.getSecurityManager();
 499         if (sm != null) {
 500             Class&lt;?&gt; caller = Reflection.getCallerClass();
 501             if (caller != null &amp;&amp; caller.getModule() != module) {
 502                 // if caller is null, Class.forName is the last java frame on the stack.
 503                 // java.base has all permissions
 504                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 505             }
 506             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 507             cl = AccessController.doPrivileged(pa);
 508         } else {
 509             cl = module.getClassLoader();
 510         }
 511 
 512         if (cl != null) {
 513             return cl.loadClass(module, name);
 514         } else {
 515             return BootLoader.loadClass(module, name);
 516         }
 517     }
 518 
 519     /**
 520      * Returns {@code true} if this class is an inline class.
 521      *
 522      * @return {@code true} if this class is an inline class
 523      * @since Valhalla
 524      */
 525     public boolean isInlineClass() {
 526         return (this.getModifiers() &amp; INLINE) != 0;
 527     }
 528 
 529     /**
 530      * Returns a {@code Class} object representing the &lt;em&gt;value projection&lt;/em&gt;
 531      * type of this class if this {@code Class} is the reference projection type
 532      * of an {@linkplain #isInlineClass() inline class}.  Otherwise an empty
 533      * {@link Optional} is returned.
 534      *
 535      * @return the {@code Class} object representing the value projection type of
 536      *         this class if this class is the reference projection type of an
 537      *         inline class; an empty {@link Optional} otherwise
 538      * @since Valhalla
 539      */
 540     public Optional&lt;Class&lt;T&gt;&gt; valueType() {
 541         return Optional.ofNullable(valType);
 542     }
 543 
 544     /**
 545      * Returns a {@code Class} object representing the &lt;em&gt;reference projection&lt;/em&gt;
 546      * type of this class if this class is an {@linkplain #isInlineClass() inline class}
 547      * with a reference projection.
 548      * If this class is an {@linkplain #isInlineClass() inline class}
 549      * without a reference projection or this class is not an inline class,
 550      * then this method returns an empty {@link Optional}.
 551      *
 552      * @return the {@code Class} object representing the value projection type of
 553      *         this class if this class is the reference projection type of an
 554      *         inline class; an empty {@link Optional} otherwise
 555      * @since Valhalla
 556      */
 557     public Optional&lt;Class&lt;T&gt;&gt; referenceType() {
 558         return valType != null ? Optional.ofNullable(refType) : Optional.of(this);
 559     }
 560 
 561     // set by VM if this class is an inline type
 562     // otherwise, these two fields are null
 563     private transient Class&lt;T&gt; valType;
 564     private transient Class&lt;T&gt; refType;
 565 
 566     /**
 567      * Creates a new instance of the class represented by this {@code Class}
 568      * object.  The class is instantiated as if by a {@code new}
 569      * expression with an empty argument list.  The class is initialized if it
 570      * has not already been initialized.
 571      *
 572      * @deprecated This method propagates any exception thrown by the
 573      * nullary constructor, including a checked exception.  Use of
 574      * this method effectively bypasses the compile-time exception
 575      * checking that would otherwise be performed by the compiler.
 576      * The {@link
 577      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 578      * Constructor.newInstance} method avoids this problem by wrapping
 579      * any exception thrown by the constructor in a (checked) {@link
 580      * java.lang.reflect.InvocationTargetException}.
 581      *
 582      * &lt;p&gt;The call
 583      *
 584      * &lt;pre&gt;{@code
 585      * clazz.newInstance()
 586      * }&lt;/pre&gt;
 587      *
 588      * can be replaced by
 589      *
 590      * &lt;pre&gt;{@code
 591      * clazz.getDeclaredConstructor().newInstance()
 592      * }&lt;/pre&gt;
 593      *
 594      * The latter sequence of calls is inferred to be able to throw
 595      * the additional exception types {@link
 596      * InvocationTargetException} and {@link
 597      * NoSuchMethodException}. Both of these exception types are
 598      * subclasses of {@link ReflectiveOperationException}.
 599      *
 600      * @return  a newly allocated instance of the class represented by this
 601      *          object.
 602      * @throws  IllegalAccessException  if the class or its nullary
 603      *          constructor is not accessible.
 604      * @throws  InstantiationException
 605      *          if this {@code Class} represents an abstract class,
 606      *          an interface, an array class, a primitive type, or void;
 607      *          or if the class has no nullary constructor;
 608      *          or if the instantiation fails for some other reason.
 609      * @throws  ExceptionInInitializerError if the initialization
 610      *          provoked by this method fails.
 611      * @throws  SecurityException
 612      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
 613      *          the caller&#39;s class loader is not the same as or an
 614      *          ancestor of the class loader for the current class and
 615      *          invocation of {@link SecurityManager#checkPackageAccess
 616      *          s.checkPackageAccess()} denies access to the package
 617      *          of this class.
 618      */
 619     @CallerSensitive
 620     @Deprecated(since=&quot;9&quot;)
 621     public T newInstance()
 622         throws InstantiationException, IllegalAccessException
 623     {
 624         SecurityManager sm = System.getSecurityManager();
 625         if (sm != null) {
 626             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
 627         }
 628 
 629         // Constructor lookup
 630         Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
 631         if (tmpConstructor == null) {
 632             if (this == Class.class) {
 633                 throw new IllegalAccessException(
 634                     &quot;Can not call newInstance() on the Class for java.lang.Class&quot;
 635                 );
 636             }
 637             try {
 638                 Class&lt;?&gt;[] empty = {};
 639                 final Constructor&lt;T&gt; c = getReflectionFactory().copyConstructor(
 640                     getConstructor0(empty, Member.DECLARED));
 641                 // Disable accessibility checks on the constructor
 642                 // access check is done with the true caller
 643                 java.security.AccessController.doPrivileged(
 644                     new java.security.PrivilegedAction&lt;&gt;() {
 645                         public Void run() {
 646                                 c.setAccessible(true);
 647                                 return null;
 648                             }
 649                         });
 650                 cachedConstructor = tmpConstructor = c;
 651             } catch (NoSuchMethodException e) {
 652                 throw (InstantiationException)
 653                     new InstantiationException(getName()).initCause(e);
 654             }
 655         }
 656 
 657         try {
 658             Class&lt;?&gt; caller = Reflection.getCallerClass();
 659             return getReflectionFactory().newInstance(tmpConstructor, null, caller);
 660         } catch (InvocationTargetException e) {
 661             Unsafe.getUnsafe().throwException(e.getTargetException());
 662             // Not reached
 663             return null;
 664         }
 665     }
 666 
 667     private transient volatile Constructor&lt;T&gt; cachedConstructor;
 668 
 669     /**
 670      * Determines if the specified {@code Object} is assignment-compatible
 671      * with the object represented by this {@code Class}.  This method is
 672      * the dynamic equivalent of the Java language {@code instanceof}
 673      * operator. The method returns {@code true} if the specified
 674      * {@code Object} argument is non-null and can be cast to the
 675      * reference type represented by this {@code Class} object without
 676      * raising a {@code ClassCastException.} It returns {@code false}
 677      * otherwise.
 678      *
 679      * &lt;p&gt; Specifically, if this {@code Class} object represents a
 680      * declared class, this method returns {@code true} if the specified
 681      * {@code Object} argument is an instance of the represented class (or
 682      * of any of its subclasses); it returns {@code false} otherwise. If
 683      * this {@code Class} object represents an array class, this method
 684      * returns {@code true} if the specified {@code Object} argument
 685      * can be converted to an object of the array class by an identity
 686      * conversion or by a widening reference conversion; it returns
 687      * {@code false} otherwise. If this {@code Class} object
 688      * represents an interface, this method returns {@code true} if the
 689      * class or any superclass of the specified {@code Object} argument
 690      * implements this interface; it returns {@code false} otherwise. If
 691      * this {@code Class} object represents a primitive type, this method
 692      * returns {@code false}.
 693      *
 694      * @param   obj the object to check
 695      * @return  true if {@code obj} is an instance of this class
 696      *
 697      * @since 1.1
 698      */
 699     @HotSpotIntrinsicCandidate
 700     public native boolean isInstance(Object obj);
 701 
 702 
 703     /**
 704      * Determines if the class or interface represented by this
 705      * {@code Class} object is either the same as, or is a superclass or
 706      * superinterface of, the class or interface represented by the specified
 707      * {@code Class} parameter. It returns {@code true} if so;
 708      * otherwise it returns {@code false}. If this {@code Class}
 709      * object represents a primitive type, this method returns
 710      * {@code true} if the specified {@code Class} parameter is
 711      * exactly this {@code Class} object; otherwise it returns
 712      * {@code false}.
 713      *
 714      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 715      * specified {@code Class} parameter can be converted to the type
 716      * represented by this {@code Class} object via an identity conversion
 717      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language
 718      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},
 719      * for details.
 720      *
 721      * @param     cls the {@code Class} object to be checked
 722      * @return    the {@code boolean} value indicating whether objects of the
 723      *            type {@code cls} can be assigned to objects of this class
 724      * @throws    NullPointerException if the specified Class parameter is
 725      *            null.
 726      * @since     1.1
 727      */
 728     @HotSpotIntrinsicCandidate
 729     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 730 
 731 
 732     /**
 733      * Determines if this {@code Class} object represents an
 734      * interface type.
 735      *
 736      * @return  {@code true} if this {@code Class} object represents an interface;
 737      *          {@code false} otherwise.
 738      */
 739     @HotSpotIntrinsicCandidate
 740     public native boolean isInterface();
 741 
 742 
 743     /**
 744      * Determines if this {@code Class} object represents an array class.
 745      *
 746      * @return  {@code true} if this {@code Class} object represents an array class;
 747      *          {@code false} otherwise.
 748      * @since   1.1
 749      */
 750     @HotSpotIntrinsicCandidate
 751     public native boolean isArray();
 752 
 753 
 754     /**
 755      * Determines if the specified {@code Class} object represents a
 756      * primitive type.
 757      *
 758      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 759      * the eight primitive types and void.  These are created by the Java
 760      * Virtual Machine, and have the same names as the primitive types that
 761      * they represent, namely {@code boolean}, {@code byte},
 762      * {@code char}, {@code short}, {@code int},
 763      * {@code long}, {@code float}, and {@code double}.
 764      *
 765      * &lt;p&gt; These objects may only be accessed via the following public static
 766      * final variables, and are the only {@code Class} objects for which
 767      * this method returns {@code true}.
 768      *
 769      * @return true if and only if this class represents a primitive type
 770      *
 771      * @see     java.lang.Boolean#TYPE
 772      * @see     java.lang.Character#TYPE
 773      * @see     java.lang.Byte#TYPE
 774      * @see     java.lang.Short#TYPE
 775      * @see     java.lang.Integer#TYPE
 776      * @see     java.lang.Long#TYPE
 777      * @see     java.lang.Float#TYPE
 778      * @see     java.lang.Double#TYPE
 779      * @see     java.lang.Void#TYPE
 780      * @since 1.1
 781      */
 782     @HotSpotIntrinsicCandidate
 783     public native boolean isPrimitive();
 784 
 785     /**
 786      * Returns true if this {@code Class} object represents an annotation
 787      * type.  Note that if this method returns true, {@link #isInterface()}
 788      * would also return true, as all annotation types are also interfaces.
 789      *
 790      * @return {@code true} if this {@code Class} object represents an annotation
 791      *      type; {@code false} otherwise
 792      * @since 1.5
 793      */
 794     public boolean isAnnotation() {
 795         return (getModifiers() &amp; ANNOTATION) != 0;
 796     }
 797 
 798     /**
 799      * Returns {@code true} if this class is a synthetic class;
 800      * returns {@code false} otherwise.
 801      * @return {@code true} if and only if this class is a synthetic class as
 802      *         defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 803      * @jls 13.1 The Form of a Binary
 804      * @since 1.5
 805      */
 806     public boolean isSynthetic() {
 807         return (getModifiers() &amp; SYNTHETIC) != 0;
 808     }
 809 
 810     /**
 811      * Returns the  name of the entity (class, interface, array class,
 812      * primitive type, or void) represented by this {@code Class} object,
 813      * as a {@code String}.
 814      *
 815      * &lt;p&gt; If this {@code Class} object represents a reference type that is
 816      * not an array type then the binary name of the class is
 817      * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language
 818      * Specification&lt;/cite&gt;.
 819      *
 820      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the
 821      * name returned is a {@code String} equal to the Java language
 822      * keyword corresponding to the primitive type or void.
 823      *
 824      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal
 825      * form of the name consists of the name of the element type preceded by
 826      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 827      * nesting.  The encoding of element type names is as follows:
 828      *
 829      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 830      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 831      * &lt;thead&gt;
 832      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 833      * &lt;/thead&gt;
 834      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 835      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 836      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 837      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 838      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 839      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
 840      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class}
 841      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;
 842      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 843      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 844      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 845      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 846      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 847      * &lt;/tbody&gt;
 848      * &lt;/table&gt;&lt;/blockquote&gt;
 849      *
 850      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 851      * the class specified above.
 852      *
 853      * &lt;p&gt; Examples:
 854      * &lt;blockquote&gt;&lt;pre&gt;
 855      * String.class.getName()
 856      *     returns &quot;java.lang.String&quot;
 857      * byte.class.getName()
 858      *     returns &quot;byte&quot;
 859      * Point.class.getName()
 860      *     returns &quot;Point&quot;
 861      * (new Object[3]).getClass().getName()
 862      *     returns &quot;[Ljava.lang.Object;&quot;
 863      * (new Point[3]).getClass().getName()
 864      *     returns &quot;[QPoint;&quot;
 865      * (new Point.ref[3][4]).getClass().getName()
 866      *     returns &quot;[[LPoint$ref;&quot;
 867      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 868      *     returns &quot;[[[[[[[I&quot;
 869      * &lt;/pre&gt;&lt;/blockquote&gt;
 870      *
 871      * @return  the name of the class or interface
 872      *          represented by this {@code Class} object.
 873      */
 874     public String getName() {
 875         String name = this.name;
 876         return name != null ? name : initClassName();
 877     }
 878 
 879     // Cache the name to reduce the number of calls into the VM.
 880     // This field would be set by VM itself during initClassName call.
 881     private transient String name;
 882     private native String initClassName();
 883 
 884     /**
 885      * Returns the class loader for the class.  Some implementations may use
 886      * null to represent the bootstrap class loader. This method will return
 887      * null in such implementations if this class was loaded by the bootstrap
 888      * class loader.
 889      *
 890      * &lt;p&gt;If this {@code Class} object
 891      * represents a primitive type or void, null is returned.
 892      *
 893      * @return  the class loader that loaded the class or interface
 894      *          represented by this {@code Class} object.
 895      * @throws  SecurityException
 896      *          if a security manager is present, and the caller&#39;s class loader
 897      *          is not {@code null} and is not the same as or an ancestor of the
 898      *          class loader for the class whose class loader is requested,
 899      *          and the caller does not have the
 900      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 901      * @see java.lang.ClassLoader
 902      * @see SecurityManager#checkPermission
 903      * @see java.lang.RuntimePermission
 904      */
 905     @CallerSensitive
 906     @ForceInline // to ensure Reflection.getCallerClass optimization
 907     public ClassLoader getClassLoader() {
 908         ClassLoader cl = getClassLoader0();
 909         if (cl == null)
 910             return null;
 911         SecurityManager sm = System.getSecurityManager();
 912         if (sm != null) {
 913             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 914         }
 915         return cl;
 916     }
 917 
 918     // Package-private to allow ClassLoader access
 919     ClassLoader getClassLoader0() { return classLoader; }
 920 
 921     /**
 922      * Returns the module that this class or interface is a member of.
 923      *
 924      * If this class represents an array type then this method returns the
 925      * {@code Module} for the element type. If this class represents a
 926      * primitive type or void, then the {@code Module} object for the
 927      * {@code java.base} module is returned.
 928      *
 929      * If this class is in an unnamed module then the {@linkplain
 930      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
 931      * loader for this class is returned.
 932      *
 933      * @return the module that this class or interface is a member of
 934      *
 935      * @since 9
 936      * @spec JPMS
 937      */
 938     public Module getModule() {
 939         return module;
 940     }
 941 
 942     // set by VM
 943     private transient Module module;
 944 
 945     // Initialized in JVM not by private constructor
 946     // This field is filtered from reflection access, i.e. getDeclaredField
 947     // will throw NoSuchFieldException
 948     private final ClassLoader classLoader;
 949 
 950     /**
 951      * Returns an array of {@code TypeVariable} objects that represent the
 952      * type variables declared by the generic declaration represented by this
 953      * {@code GenericDeclaration} object, in declaration order.  Returns an
 954      * array of length 0 if the underlying generic declaration declares no type
 955      * variables.
 956      *
 957      * @return an array of {@code TypeVariable} objects that represent
 958      *     the type variables declared by this generic declaration
 959      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 960      *     signature of this generic declaration does not conform to
 961      *     the format specified in section {@jvms 4.7.9} of
 962      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;,
 963      * @since 1.5
 964      */
 965     @SuppressWarnings(&quot;unchecked&quot;)
 966     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
 967         ClassRepository info = getGenericInfo();
 968         if (info != null)
 969             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
 970         else
 971             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
 972     }
 973 
 974 
 975     /**
 976      * Returns the {@code Class} representing the direct superclass of the
 977      * entity (class, interface, primitive type or void) represented by
 978      * this {@code Class}.  If this {@code Class} represents either the
 979      * {@code Object} class, an interface, a primitive type, or void, then
 980      * null is returned.  If this {@code Class} object represents an array class
 981      * then the {@code Class} object representing the {@code Object} class is
 982      * returned.
 983      *
 984      * @return the direct superclass of the class represented by this {@code Class} object
 985      */
 986     @HotSpotIntrinsicCandidate
 987     public native Class&lt;? super T&gt; getSuperclass();
 988 
 989 
 990     /**
 991      * Returns the {@code Type} representing the direct superclass of
 992      * the entity (class, interface, primitive type or void) represented by
 993      * this {@code Class} object.
 994      *
 995      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
 996      * object returned must accurately reflect the actual type
 997      * arguments used in the source code. The parameterized type
 998      * representing the superclass is created if it had not been
 999      * created before. See the declaration of {@link
1000      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1001      * semantics of the creation process for parameterized types.  If
1002      * this {@code Class} object represents either the {@code Object}
1003      * class, an interface, a primitive type, or void, then null is
1004      * returned.  If this {@code Class} object represents an array class
1005      * then the {@code Class} object representing the {@code Object} class is
1006      * returned.
1007      *
1008      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1009      *     class signature does not conform to the format specified in
1010      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
1011      *     Machine Specification&lt;/cite&gt;
1012      * @throws TypeNotPresentException if the generic superclass
1013      *     refers to a non-existent type declaration
1014      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1015      *     generic superclass refers to a parameterized type that cannot be
1016      *     instantiated  for any reason
1017      * @return the direct superclass of the class represented by this {@code Class} object
1018      * @since 1.5
1019      */
1020     public Type getGenericSuperclass() {
1021         ClassRepository info = getGenericInfo();
1022         if (info == null) {
1023             return getSuperclass();
1024         }
1025 
1026         // Historical irregularity:
1027         // Generic signature marks interfaces with superclass = Object
1028         // but this API returns null for interfaces
1029         if (isInterface()) {
1030             return null;
1031         }
1032 
1033         return info.getSuperclass();
1034     }
1035 
1036     /**
1037      * Gets the package of this class.
1038      *
1039      * &lt;p&gt;If this class represents an array type, a primitive type or void,
1040      * this method returns {@code null}.
1041      *
1042      * @return the package of this class.
1043      * @revised 9
1044      * @spec JPMS
1045      */
1046     public Package getPackage() {
1047         if (isPrimitive() || isArray()) {
1048             return null;
1049         }
1050         ClassLoader cl = getClassLoader0();
1051         return cl != null ? cl.definePackage(this)
1052                           : BootLoader.definePackage(this);
1053     }
1054 
1055     /**
1056      * Returns the fully qualified package name.
1057      *
1058      * &lt;p&gt; If this class is a top level class, then this method returns the fully
1059      * qualified name of the package that the class is a member of, or the
1060      * empty string if the class is in an unnamed package.
1061      *
1062      * &lt;p&gt; If this class is a member class, then this method is equivalent to
1063      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
1064      * enclosing class}.
1065      *
1066      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1067      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1068      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1069      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1070      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1071      *
1072      * &lt;p&gt; If this class represents an array type then this method returns the
1073      * package name of the element type. If this class represents a primitive
1074      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1075      *
1076      * @return the fully qualified package name
1077      *
1078      * @since 9
1079      * @spec JPMS
1080      * @jls 6.7 Fully Qualified Names
1081      */
1082     public String getPackageName() {
1083         String pn = this.packageName;
1084         if (pn == null) {
1085             Class&lt;?&gt; c = this;
1086             while (c.isArray()) {
1087                 c = c.getComponentType();
1088             }
1089             if (c.isPrimitive()) {
1090                 pn = &quot;java.lang&quot;;
1091             } else {
1092                 String cn = c.getName();
1093                 int dot = cn.lastIndexOf(&#39;.&#39;);
1094                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1095             }
1096             this.packageName = pn;
1097         }
1098         return pn;
1099     }
1100 
1101     // cached package name
1102     private transient String packageName;
1103 
1104     /**
1105      * Returns the interfaces directly implemented by the class or interface
1106      * represented by this {@code Class} object.
1107      *
1108      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1109      * containing objects representing all interfaces directly implemented by
1110      * the class.  The order of the interface objects in the array corresponds
1111      * to the order of the interface names in the {@code implements} clause of
1112      * the declaration of the class represented by this {@code Class} object.  For example,
1113      * given the declaration:
1114      * &lt;blockquote&gt;
1115      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1116      * &lt;/blockquote&gt;
1117      * suppose the value of {@code s} is an instance of
1118      * {@code Shimmer}; the value of the expression:
1119      * &lt;blockquote&gt;
1120      * {@code s.getClass().getInterfaces()[0]}
1121      * &lt;/blockquote&gt;
1122      * is the {@code Class} object that represents interface
1123      * {@code FloorWax}; and the value of:
1124      * &lt;blockquote&gt;
1125      * {@code s.getClass().getInterfaces()[1]}
1126      * &lt;/blockquote&gt;
1127      * is the {@code Class} object that represents interface
1128      * {@code DessertTopping}.
1129      *
1130      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1131      * representing all interfaces directly extended by the interface.  The
1132      * order of the interface objects in the array corresponds to the order of
1133      * the interface names in the {@code extends} clause of the declaration of
1134      * the interface represented by this {@code Class} object.
1135      *
1136      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1137      * interfaces, the method returns an array of length 0.
1138      *
1139      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1140      * returns an array of length 0.
1141      *
1142      * &lt;p&gt;If this {@code Class} object represents an array type, the
1143      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1144      * returned in that order.
1145      *
1146      * @return an array of interfaces directly implemented by this class
1147      */
1148     public Class&lt;?&gt;[] getInterfaces() {
1149         // defensively copy before handing over to user code
1150         return getInterfaces(true);
1151     }
1152 
1153     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1154         ReflectionData&lt;T&gt; rd = reflectionData();
1155         if (rd == null) {
1156             // no cloning required
1157             return getInterfaces0();
1158         } else {
1159             Class&lt;?&gt;[] interfaces = rd.interfaces;
1160             if (interfaces == null) {
1161                 interfaces = getInterfaces0();
1162                 rd.interfaces = interfaces;
1163             }
1164             // defensively copy if requested
1165             return cloneArray ? interfaces.clone() : interfaces;
1166         }
1167     }
1168 
1169     private native Class&lt;?&gt;[] getInterfaces0();
1170 
1171     /**
1172      * Returns the {@code Type}s representing the interfaces
1173      * directly implemented by the class or interface represented by
1174      * this {@code Class} object.
1175      *
1176      * &lt;p&gt;If a superinterface is a parameterized type, the
1177      * {@code Type} object returned for it must accurately reflect
1178      * the actual type arguments used in the source code. The
1179      * parameterized type representing each superinterface is created
1180      * if it had not been created before. See the declaration of
1181      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1182      * for the semantics of the creation process for parameterized
1183      * types.
1184      *
1185      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1186      * containing objects representing all interfaces directly implemented by
1187      * the class.  The order of the interface objects in the array corresponds
1188      * to the order of the interface names in the {@code implements} clause of
1189      * the declaration of the class represented by this {@code Class} object.
1190      *
1191      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1192      * representing all interfaces directly extended by the interface.  The
1193      * order of the interface objects in the array corresponds to the order of
1194      * the interface names in the {@code extends} clause of the declaration of
1195      * the interface represented by this {@code Class} object.
1196      *
1197      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1198      * interfaces, the method returns an array of length 0.
1199      *
1200      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1201      * returns an array of length 0.
1202      *
1203      * &lt;p&gt;If this {@code Class} object represents an array type, the
1204      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1205      * returned in that order.
1206      *
1207      * @throws java.lang.reflect.GenericSignatureFormatError
1208      *     if the generic class signature does not conform to the
1209      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The
1210      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1211      * @throws TypeNotPresentException if any of the generic
1212      *     superinterfaces refers to a non-existent type declaration
1213      * @throws java.lang.reflect.MalformedParameterizedTypeException
1214      *     if any of the generic superinterfaces refer to a parameterized
1215      *     type that cannot be instantiated for any reason
1216      * @return an array of interfaces directly implemented by this class
1217      * @since 1.5
1218      */
1219     public Type[] getGenericInterfaces() {
1220         ClassRepository info = getGenericInfo();
1221         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1222     }
1223 
1224 
1225     /**
1226      * Returns the {@code Class} representing the component type of an
1227      * array.  If this class does not represent an array class this method
1228      * returns null.
1229      *
1230      * @return the {@code Class} representing the component type of this
1231      * class if this class is an array
1232      * @see     java.lang.reflect.Array
1233      * @since 1.1
1234      */
1235     public Class&lt;?&gt; getComponentType() {
1236         // Only return for array types. Storage may be reused for Class for instance types.
1237         if (isArray()) {
1238             return componentType;
1239         } else {
1240             return null;
1241         }
1242     }
1243 
1244     private final Class&lt;?&gt; componentType;
1245 
1246 
1247     /**
1248      * Returns the Java language modifiers for this class or interface, encoded
1249      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1250      * constants for {@code public}, {@code protected},
1251      * {@code private}, {@code final}, {@code static},
1252      * {@code abstract} and {@code interface}; they should be decoded
1253      * using the methods of class {@code Modifier}.
1254      *
1255      * &lt;p&gt; If the underlying class is an array class, then its
1256      * {@code public}, {@code private} and {@code protected}
1257      * modifiers are the same as those of its component type.  If this
1258      * {@code Class} object represents a primitive type or void, its
1259      * {@code public} modifier is always {@code true}, and its
1260      * {@code protected} and {@code private} modifiers are always
1261      * {@code false}. If this {@code Class} object represents an array class, a
1262      * primitive type or void, then its {@code final} modifier is always
1263      * {@code true} and its interface modifier is always
1264      * {@code false}. The values of its other modifiers are not determined
1265      * by this specification.
1266      *
1267      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1268      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1269      *
1270      * @return the {@code int} representing the modifiers for this class
1271      * @see     java.lang.reflect.Modifier
1272      * @since 1.1
1273      */
1274     @HotSpotIntrinsicCandidate
1275     public native int getModifiers();
1276 
1277     /**
1278      * Gets the signers of this class.
1279      *
1280      * @return  the signers of this class, or null if there are no signers.  In
1281      *          particular, this method returns null if this {@code Class} object represents
1282      *          a primitive type or void.
1283      * @since   1.1
1284      */
1285     public native Object[] getSigners();
1286 
1287     /**
1288      * Set the signers of this class.
1289      */
1290     native void setSigners(Object[] signers);
1291 
1292 
1293     /**
1294      * If this {@code Class} object represents a local or anonymous
1295      * class within a method, returns a {@link
1296      * java.lang.reflect.Method Method} object representing the
1297      * immediately enclosing method of the underlying class. Returns
1298      * {@code null} otherwise.
1299      *
1300      * In particular, this method returns {@code null} if the underlying
1301      * class is a local or anonymous class immediately enclosed by a type
1302      * declaration, instance initializer or static initializer.
1303      *
1304      * @return the immediately enclosing method of the underlying class, if
1305      *     that class is a local or anonymous class; otherwise {@code null}.
1306      *
1307      * @throws SecurityException
1308      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1309      *         following conditions is met:
1310      *
1311      *         &lt;ul&gt;
1312      *
1313      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1314      *         class loader of the enclosing class and invocation of
1315      *         {@link SecurityManager#checkPermission
1316      *         s.checkPermission} method with
1317      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1318      *         denies access to the methods within the enclosing class
1319      *
1320      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1321      *         ancestor of the class loader for the enclosing class and
1322      *         invocation of {@link SecurityManager#checkPackageAccess
1323      *         s.checkPackageAccess()} denies access to the package
1324      *         of the enclosing class
1325      *
1326      *         &lt;/ul&gt;
1327      * @since 1.5
1328      */
1329     @CallerSensitive
1330     public Method getEnclosingMethod() throws SecurityException {
1331         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1332 
1333         if (enclosingInfo == null)
1334             return null;
1335         else {
1336             if (!enclosingInfo.isMethod())
1337                 return null;
1338 
1339             MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
1340                                                               getFactory());
1341             Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
1342             Type []    parameterTypes   = typeInfo.getParameterTypes();
1343             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1344 
1345             // Convert Types to Classes; returned types *should*
1346             // be class objects since the methodDescriptor&#39;s used
1347             // don&#39;t have generics information
1348             for(int i = 0; i &lt; parameterClasses.length; i++)
1349                 parameterClasses[i] = toClass(parameterTypes[i]);
1350 
1351             // Perform access check
1352             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1353             SecurityManager sm = System.getSecurityManager();
1354             if (sm != null) {
1355                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1356                                                      Reflection.getCallerClass(), true);
1357             }
1358             Method[] candidates = enclosingCandidate.privateGetDeclaredMethods(false);
1359 
1360             /*
1361              * Loop over all declared methods; match method name,
1362              * number of and type of parameters, *and* return
1363              * type.  Matching return type is also necessary
1364              * because of covariant returns, etc.
1365              */
1366             ReflectionFactory fact = getReflectionFactory();
1367             for (Method m : candidates) {
1368                 if (m.getName().equals(enclosingInfo.getName()) &amp;&amp;
1369                     arrayContentsEq(parameterClasses,
1370                                     fact.getExecutableSharedParameterTypes(m))) {
1371                     // finally, check return type
1372                     if (m.getReturnType().equals(returnType)) {
1373                         return fact.copyMethod(m);
1374                     }
1375                 }
1376             }
1377 
1378             throw new InternalError(&quot;Enclosing method not found&quot;);
1379         }
1380     }
1381 
1382     private native Object[] getEnclosingMethod0();
1383 
1384     private EnclosingMethodInfo getEnclosingMethodInfo() {
1385         Object[] enclosingInfo = getEnclosingMethod0();
1386         if (enclosingInfo == null)
1387             return null;
1388         else {
1389             return new EnclosingMethodInfo(enclosingInfo);
1390         }
1391     }
1392 
1393     private static final class EnclosingMethodInfo {
1394         private final Class&lt;?&gt; enclosingClass;
1395         private final String name;
1396         private final String descriptor;
1397 
1398         static void validate(Object[] enclosingInfo) {
1399             if (enclosingInfo.length != 3)
1400                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1401             try {
1402                 // The array is expected to have three elements:
1403 
1404                 // the immediately enclosing class
1405                 Class&lt;?&gt; enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1406                 assert(enclosingClass != null);
1407 
1408                 // the immediately enclosing method or constructor&#39;s
1409                 // name (can be null).
1410                 String name = (String)enclosingInfo[1];
1411 
1412                 // the immediately enclosing method or constructor&#39;s
1413                 // descriptor (null iff name is).
1414                 String descriptor = (String)enclosingInfo[2];
1415                 assert((name != null &amp;&amp; descriptor != null) || name == descriptor);
1416             } catch (ClassCastException cce) {
1417                 throw new InternalError(&quot;Invalid type in enclosing method information&quot;, cce);
1418             }
1419         }
1420 
1421         EnclosingMethodInfo(Object[] enclosingInfo) {
1422             validate(enclosingInfo);
1423             this.enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1424             this.name = (String)enclosingInfo[1];
1425             this.descriptor = (String)enclosingInfo[2];
1426         }
1427 
1428         boolean isPartial() {
1429             return enclosingClass == null || name == null || descriptor == null;
1430         }
1431 
1432         boolean isConstructor() { return !isPartial() &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name); }
1433 
1434         boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name); }
1435 
1436         Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }
1437 
1438         String getName() { return name; }
1439 
1440         String getDescriptor() { return descriptor; }
1441 
1442     }
1443 
1444     private static Class&lt;?&gt; toClass(Type o) {
1445         if (o instanceof GenericArrayType)
1446             return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
1447                                      0)
1448                 .getClass();
1449         return (Class&lt;?&gt;)o;
1450      }
1451 
1452     /**
1453      * If this {@code Class} object represents a local or anonymous
1454      * class within a constructor, returns a {@link
1455      * java.lang.reflect.Constructor Constructor} object representing
1456      * the immediately enclosing constructor of the underlying
1457      * class. Returns {@code null} otherwise.  In particular, this
1458      * method returns {@code null} if the underlying class is a local
1459      * or anonymous class immediately enclosed by a type declaration,
1460      * instance initializer or static initializer.
1461      *
1462      * @return the immediately enclosing constructor of the underlying class, if
1463      *     that class is a local or anonymous class; otherwise {@code null}.
1464      * @throws SecurityException
1465      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1466      *         following conditions is met:
1467      *
1468      *         &lt;ul&gt;
1469      *
1470      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1471      *         class loader of the enclosing class and invocation of
1472      *         {@link SecurityManager#checkPermission
1473      *         s.checkPermission} method with
1474      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1475      *         denies access to the constructors within the enclosing class
1476      *
1477      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1478      *         ancestor of the class loader for the enclosing class and
1479      *         invocation of {@link SecurityManager#checkPackageAccess
1480      *         s.checkPackageAccess()} denies access to the package
1481      *         of the enclosing class
1482      *
1483      *         &lt;/ul&gt;
1484      * @since 1.5
1485      */
1486     @CallerSensitive
1487     public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {
1488         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1489 
1490         if (enclosingInfo == null)
1491             return null;
1492         else {
1493             if (!enclosingInfo.isConstructor())
1494                 return null;
1495 
1496             ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
1497                                                                         getFactory());
1498             Type []    parameterTypes   = typeInfo.getParameterTypes();
1499             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1500 
1501             // Convert Types to Classes; returned types *should*
1502             // be class objects since the methodDescriptor&#39;s used
1503             // don&#39;t have generics information
1504             for(int i = 0; i &lt; parameterClasses.length; i++)
1505                 parameterClasses[i] = toClass(parameterTypes[i]);
1506 
1507             // Perform access check
1508             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1509             SecurityManager sm = System.getSecurityManager();
1510             if (sm != null) {
1511                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1512                                                      Reflection.getCallerClass(), true);
1513             }
1514 
1515             Constructor&lt;?&gt;[] candidates = enclosingCandidate
1516                     .privateGetDeclaredConstructors(false);
1517             /*
1518              * Loop over all declared constructors; match number
1519              * of and type of parameters.
1520              */
1521             ReflectionFactory fact = getReflectionFactory();
1522             for (Constructor&lt;?&gt; c : candidates) {
1523                 if (arrayContentsEq(parameterClasses,
1524                                     fact.getExecutableSharedParameterTypes(c))) {
1525                     return fact.copyConstructor(c);
1526                 }
1527             }
1528 
1529             throw new InternalError(&quot;Enclosing constructor not found&quot;);
1530         }
1531     }
1532 
1533 
1534     /**
1535      * If the class or interface represented by this {@code Class} object
1536      * is a member of another class, returns the {@code Class} object
1537      * representing the class in which it was declared.  This method returns
1538      * null if this class or interface is not a member of any other class.  If
1539      * this {@code Class} object represents an array class, a primitive
1540      * type, or void,then this method returns null.
1541      *
1542      * @return the declaring class for this class
1543      * @throws SecurityException
1544      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1545      *         class loader is not the same as or an ancestor of the class
1546      *         loader for the declaring class and invocation of {@link
1547      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
1548      *         denies access to the package of the declaring class
1549      * @since 1.1
1550      */
1551     @CallerSensitive
1552     public Class&lt;?&gt; getDeclaringClass() throws SecurityException {
1553         final Class&lt;?&gt; candidate = getDeclaringClass0();
1554 
1555         if (candidate != null) {
1556             SecurityManager sm = System.getSecurityManager();
1557             if (sm != null) {
1558                 candidate.checkPackageAccess(sm,
1559                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1560             }
1561         }
1562         return candidate;
1563     }
1564 
1565     private native Class&lt;?&gt; getDeclaringClass0();
1566 
1567 
1568     /**
1569      * Returns the immediately enclosing class of the underlying
1570      * class.  If the underlying class is a top level class this
1571      * method returns {@code null}.
1572      * @return the immediately enclosing class of the underlying class
1573      * @throws     SecurityException
1574      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1575      *             class loader is not the same as or an ancestor of the class
1576      *             loader for the enclosing class and invocation of {@link
1577      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1578      *             denies access to the package of the enclosing class
1579      * @since 1.5
1580      */
1581     @CallerSensitive
1582     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1583         // There are five kinds of classes (or interfaces):
1584         // a) Top level classes
1585         // b) Nested classes (static member classes)
1586         // c) Inner classes (non-static member classes)
1587         // d) Local classes (named classes declared within a method)
1588         // e) Anonymous classes
1589 
1590 
1591         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1592         // attribute if and only if it is a local class or an
1593         // anonymous class.
1594         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1595         Class&lt;?&gt; enclosingCandidate;
1596 
1597         if (enclosingInfo == null) {
1598             // This is a top level or a nested class or an inner class (a, b, or c)
1599             enclosingCandidate = getDeclaringClass0();
1600         } else {
1601             Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
1602             // This is a local class or an anonymous class (d or e)
1603             if (enclosingClass == this || enclosingClass == null)
1604                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1605             else
1606                 enclosingCandidate = enclosingClass;
1607         }
1608 
1609         if (enclosingCandidate != null) {
1610             SecurityManager sm = System.getSecurityManager();
1611             if (sm != null) {
1612                 enclosingCandidate.checkPackageAccess(sm,
1613                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1614             }
1615         }
1616         return enclosingCandidate;
1617     }
1618 
1619     /**
1620      * Returns the simple name of the underlying class as given in the
1621      * source code. Returns an empty string if the underlying class is
1622      * anonymous.
1623      *
1624      * &lt;p&gt;The simple name of an array is the simple name of the
1625      * component type with &quot;[]&quot; appended.  In particular the simple
1626      * name of an array whose component type is anonymous is &quot;[]&quot;.
1627      *
1628      * @return the simple name of the underlying class
1629      * @since 1.5
1630      */
1631     public String getSimpleName() {
1632         ReflectionData&lt;T&gt; rd = reflectionData();
1633         String simpleName = rd.simpleName;
1634         if (simpleName == null) {
1635             rd.simpleName = simpleName = getSimpleName0();
1636         }
1637         return simpleName;
1638     }
1639 
1640     private String getSimpleName0() {
1641         if (isArray()) {
1642             return getComponentType().getSimpleName() + &quot;[]&quot;;
1643         }
1644         String simpleName = getSimpleBinaryName();
1645         if (simpleName == null) { // top level class
1646             simpleName = getName();
1647             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1648         }
1649         return simpleName;
1650     }
1651 
1652     /**
1653      * Return an informative string for the name of this type.
1654      *
1655      * @return an informative string for the name of this type
1656      * @since 1.8
1657      */
1658     public String getTypeName() {
1659         if (isArray()) {
1660             try {
1661                 Class&lt;?&gt; cl = this;
1662                 int dimensions = 0;
1663                 do {
1664                     dimensions++;
1665                     cl = cl.getComponentType();
1666                 } while (cl.isArray());
1667                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1668             } catch (Throwable e) { /*FALLTHRU*/ }
1669         }
1670         return getName();
1671     }
1672 
1673     /**
1674      * Returns the canonical name of the underlying class as defined
1675      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section
1676      * {@jls 6.7}.  Returns null if the underlying class does not have
1677      * a canonical name (i.e., if it is a local or anonymous class or
1678      * an array whose component type does not have a canonical name).
1679      * @return the canonical name of the underlying class if it exists, and
1680      * {@code null} otherwise.
1681      * @since 1.5
1682      */
1683     public String getCanonicalName() {
1684         ReflectionData&lt;T&gt; rd = reflectionData();
1685         String canonicalName = rd.canonicalName;
1686         if (canonicalName == null) {
1687             rd.canonicalName = canonicalName = getCanonicalName0();
1688         }
1689         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1690     }
1691 
1692     private String getCanonicalName0() {
1693         if (isArray()) {
1694             String canonicalName = getComponentType().getCanonicalName();
1695             if (canonicalName != null)
1696                 return canonicalName + &quot;[]&quot;;
1697             else
1698                 return ReflectionData.NULL_SENTINEL;
1699         }
1700         if (isLocalOrAnonymousClass())
1701             return ReflectionData.NULL_SENTINEL;
1702         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1703         if (enclosingClass == null) { // top level class
1704             return getName();
1705         } else {
1706             String enclosingName = enclosingClass.getCanonicalName();
1707             if (enclosingName == null)
1708                 return ReflectionData.NULL_SENTINEL;
1709             return enclosingName + &quot;.&quot; + getSimpleName();
1710         }
1711     }
1712 
1713     /**
1714      * Returns {@code true} if and only if the underlying class
1715      * is an anonymous class.
1716      *
1717      * @return {@code true} if and only if this class is an anonymous class.
1718      * @since 1.5
1719      */
1720     public boolean isAnonymousClass() {
1721         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1722                 getSimpleBinaryName0() == null;
1723     }
1724 
1725     /**
1726      * Returns {@code true} if and only if the underlying class
1727      * is a local class.
1728      *
1729      * @return {@code true} if and only if this class is a local class.
1730      * @since 1.5
1731      */
1732     public boolean isLocalClass() {
1733         return isLocalOrAnonymousClass() &amp;&amp;
1734                 (isArray() || getSimpleBinaryName0() != null);
1735     }
1736 
1737     /**
1738      * Returns {@code true} if and only if the underlying class
1739      * is a member class.
1740      *
1741      * @return {@code true} if and only if this class is a member class.
1742      * @since 1.5
1743      */
1744     public boolean isMemberClass() {
1745         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() != null;
1746     }
1747 
1748     /**
1749      * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
1750      * the binary name without the leading enclosing class name.
1751      * Returns {@code null} if the underlying class is a top level
1752      * class.
1753      */
1754     private String getSimpleBinaryName() {
1755         if (isTopLevelClass())
1756             return null;
1757         String name = getSimpleBinaryName0();
1758         if (name == null) // anonymous class
1759             return &quot;&quot;;
1760         return name;
1761     }
1762 
1763     private native String getSimpleBinaryName0();
1764 
1765     /**
1766      * Returns {@code true} if this is a top level class.  Returns {@code false}
1767      * otherwise.
1768      */
1769     private boolean isTopLevelClass() {
1770         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() == null;
1771     }
1772 
1773     /**
1774      * Returns {@code true} if this is a local class or an anonymous
1775      * class.  Returns {@code false} otherwise.
1776      */
1777     private boolean isLocalOrAnonymousClass() {
1778         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1779         // attribute if and only if it is a local class or an
1780         // anonymous class.
1781         return hasEnclosingMethodInfo();
1782     }
1783 
1784     private boolean hasEnclosingMethodInfo() {
1785         Object[] enclosingInfo = getEnclosingMethod0();
1786         if (enclosingInfo != null) {
1787             EnclosingMethodInfo.validate(enclosingInfo);
1788             return true;
1789         }
1790         return false;
1791     }
1792 
1793     /**
1794      * Returns an array containing {@code Class} objects representing all
1795      * the public classes and interfaces that are members of the class
1796      * represented by this {@code Class} object.  This includes public
1797      * class and interface members inherited from superclasses and public class
1798      * and interface members declared by the class.  This method returns an
1799      * array of length 0 if this {@code Class} object has no public member
1800      * classes or interfaces.  This method also returns an array of length 0 if
1801      * this {@code Class} object represents a primitive type, an array
1802      * class, or void.
1803      *
1804      * @return the array of {@code Class} objects representing the public
1805      *         members of this class
1806      * @throws SecurityException
1807      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1808      *         the caller&#39;s class loader is not the same as or an
1809      *         ancestor of the class loader for the current class and
1810      *         invocation of {@link SecurityManager#checkPackageAccess
1811      *         s.checkPackageAccess()} denies access to the package
1812      *         of this class.
1813      *
1814      * @since 1.1
1815      */
1816     @CallerSensitive
1817     public Class&lt;?&gt;[] getClasses() {
1818         SecurityManager sm = System.getSecurityManager();
1819         if (sm != null) {
1820             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
1821         }
1822 
1823         // Privileged so this implementation can look at DECLARED classes,
1824         // something the caller might not have privilege to do.  The code here
1825         // is allowed to look at DECLARED classes because (1) it does not hand
1826         // out anything other than public members and (2) public member access
1827         // has already been ok&#39;d by the SecurityManager.
1828 
1829         return java.security.AccessController.doPrivileged(
1830             new java.security.PrivilegedAction&lt;&gt;() {
1831                 public Class&lt;?&gt;[] run() {
1832                     List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();
1833                     Class&lt;?&gt; currentClass = Class.this;
1834                     while (currentClass != null) {
1835                         for (Class&lt;?&gt; m : currentClass.getDeclaredClasses()) {
1836                             if (Modifier.isPublic(m.getModifiers())) {
1837                                 list.add(m);
1838                             }
1839                         }
1840                         currentClass = currentClass.getSuperclass();
1841                     }
1842                     return list.toArray(new Class&lt;?&gt;[0]);
1843                 }
1844             });
1845     }
1846 
1847 
1848     /**
1849      * Returns an array containing {@code Field} objects reflecting all
1850      * the accessible public fields of the class or interface represented by
1851      * this {@code Class} object.
1852      *
1853      * &lt;p&gt; If this {@code Class} object represents a class or interface with
1854      * no accessible public fields, then this method returns an array of length
1855      * 0.
1856      *
1857      * &lt;p&gt; If this {@code Class} object represents a class, then this method
1858      * returns the public fields of the class and of all its superclasses and
1859      * superinterfaces.
1860      *
1861      * &lt;p&gt; If this {@code Class} object represents an interface, then this
1862      * method returns the fields of the interface and of all its
1863      * superinterfaces.
1864      *
1865      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
1866      * type, or void, then this method returns an array of length 0.
1867      *
1868      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1869      * particular order.
1870      *
1871      * @return the array of {@code Field} objects representing the
1872      *         public fields
1873      * @throws SecurityException
1874      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1875      *         the caller&#39;s class loader is not the same as or an
1876      *         ancestor of the class loader for the current class and
1877      *         invocation of {@link SecurityManager#checkPackageAccess
1878      *         s.checkPackageAccess()} denies access to the package
1879      *         of this class.
1880      *
1881      * @since 1.1
1882      * @jls 8.2 Class Members
1883      * @jls 8.3 Field Declarations
1884      */
1885     @CallerSensitive
1886     public Field[] getFields() throws SecurityException {
1887         SecurityManager sm = System.getSecurityManager();
1888         if (sm != null) {
1889             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1890         }
1891         return copyFields(privateGetPublicFields());
1892     }
1893 
1894 
1895     /**
1896      * Returns an array containing {@code Method} objects reflecting all the
1897      * public methods of the class or interface represented by this {@code
1898      * Class} object, including those declared by the class or interface and
1899      * those inherited from superclasses and superinterfaces.
1900      *
1901      * &lt;p&gt; If this {@code Class} object represents an array type, then the
1902      * returned array has a {@code Method} object for each of the public
1903      * methods inherited by the array type from {@code Object}. It does not
1904      * contain a {@code Method} object for {@code clone()}.
1905      *
1906      * &lt;p&gt; If this {@code Class} object represents an interface then the
1907      * returned array does not contain any implicitly declared methods from
1908      * {@code Object}. Therefore, if no methods are explicitly declared in
1909      * this interface or any of its superinterfaces then the returned array
1910      * has length 0. (Note that a {@code Class} object which represents a class
1911      * always has public methods, inherited from {@code Object}.)
1912      *
1913      * &lt;p&gt; The returned array never contains methods with names &quot;{@code &lt;init&gt;}&quot;
1914      * or &quot;{@code &lt;clinit&gt;}&quot;.
1915      *
1916      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1917      * particular order.
1918      *
1919      * &lt;p&gt; Generally, the result is computed as with the following 4 step algorithm.
1920      * Let C be the class or interface represented by this {@code Class} object:
1921      * &lt;ol&gt;
1922      * &lt;li&gt; A union of methods is composed of:
1923      *   &lt;ol type=&quot;a&quot;&gt;
1924      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
1925      *        {@link #getDeclaredMethods()} and filtered to include only public
1926      *        methods.&lt;/li&gt;
1927      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
1928      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
1929      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
1930      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
1931      *   &lt;/ol&gt;&lt;/li&gt;
1932      * &lt;li&gt; Union from step 1 is partitioned into subsets of methods with same
1933      *      signature (name, parameter types) and return type.&lt;/li&gt;
1934      * &lt;li&gt; Within each such subset only the most specific methods are selected.
1935      *      Let method M be a method from a set of methods with same signature
1936      *      and return type. M is most specific if there is no such method
1937      *      N != M from the same set, such that N is more specific than M.
1938      *      N is more specific than M if:
1939      *   &lt;ol type=&quot;a&quot;&gt;
1940      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
1941      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
1942      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
1943      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
1944      *        M and N are the same method).&lt;/li&gt;
1945      *   &lt;/ol&gt;&lt;/li&gt;
1946      * &lt;li&gt; The result of this algorithm is the union of all selected methods from
1947      *      step 3.&lt;/li&gt;
1948      * &lt;/ol&gt;
1949      *
1950      * @apiNote There may be more than one method with a particular name
1951      * and parameter types in a class because while the Java language forbids a
1952      * class to declare multiple methods with the same signature but different
1953      * return types, the Java virtual machine does not.  This
1954      * increased flexibility in the virtual machine can be used to
1955      * implement various language features.  For example, covariant
1956      * returns can be implemented with {@linkplain
1957      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
1958      * method and the overriding method would have the same
1959      * signature but different return types.
1960      *
1961      * @return the array of {@code Method} objects representing the
1962      *         public methods of this class
1963      * @throws SecurityException
1964      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1965      *         the caller&#39;s class loader is not the same as or an
1966      *         ancestor of the class loader for the current class and
1967      *         invocation of {@link SecurityManager#checkPackageAccess
1968      *         s.checkPackageAccess()} denies access to the package
1969      *         of this class.
1970      *
1971      * @jls 8.2 Class Members
1972      * @jls 8.4 Method Declarations
1973      * @since 1.1
1974      */
1975     @CallerSensitive
1976     public Method[] getMethods() throws SecurityException {
1977         SecurityManager sm = System.getSecurityManager();
1978         if (sm != null) {
1979             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1980         }
1981         return copyMethods(privateGetPublicMethods());
1982     }
1983 
1984 
1985     /**
1986      * Returns an array containing {@code Constructor} objects reflecting
1987      * all the public constructors of the class represented by this
1988      * {@code Class} object.  An array of length 0 is returned if the
1989      * class has no public constructors, or if the class is an array class, or
1990      * if the class reflects a primitive type or void.
1991      *
1992      * @apiNote
1993      * While this method returns an array of {@code
1994      * Constructor&lt;T&gt;} objects (that is an array of constructors from
1995      * this class), the return type of this method is {@code
1996      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
1997      * might be expected.  This less informative return type is
1998      * necessary since after being returned from this method, the
1999      * array could be modified to hold {@code Constructor} objects for
2000      * different classes, which would violate the type guarantees of
2001      * {@code Constructor&lt;T&gt;[]}.
2002      *
2003      * @return the array of {@code Constructor} objects representing the
2004      *         public constructors of this class
2005      * @throws SecurityException
2006      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2007      *         the caller&#39;s class loader is not the same as or an
2008      *         ancestor of the class loader for the current class and
2009      *         invocation of {@link SecurityManager#checkPackageAccess
2010      *         s.checkPackageAccess()} denies access to the package
2011      *         of this class.
2012      *
2013      * @since 1.1
2014      */
2015     @CallerSensitive
2016     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2017         SecurityManager sm = System.getSecurityManager();
2018         if (sm != null) {
2019             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2020         }
2021         return copyConstructors(privateGetDeclaredConstructors(true));
2022     }
2023 
2024 
2025     /**
2026      * Returns a {@code Field} object that reflects the specified public member
2027      * field of the class or interface represented by this {@code Class}
2028      * object. The {@code name} parameter is a {@code String} specifying the
2029      * simple name of the desired field.
2030      *
2031      * &lt;p&gt; The field to be reflected is determined by the algorithm that
2032      * follows.  Let C be the class or interface represented by this {@code Class} object:
2033      *
2034      * &lt;OL&gt;
2035      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2036      *      field to be reflected.&lt;/LI&gt;
2037      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2038      *      recursively to each direct superinterface of C. The direct
2039      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2040      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2041      *      superclass S, then this algorithm is invoked recursively upon S.
2042      *      If C has no superclass, then a {@code NoSuchFieldException}
2043      *      is thrown.&lt;/LI&gt;
2044      * &lt;/OL&gt;
2045      *
2046      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2047      * method does not find the {@code length} field of the array type.
2048      *
2049      * @param name the field name
2050      * @return the {@code Field} object of this class specified by
2051      *         {@code name}
2052      * @throws NoSuchFieldException if a field with the specified name is
2053      *         not found.
2054      * @throws NullPointerException if {@code name} is {@code null}
2055      * @throws SecurityException
2056      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2057      *         the caller&#39;s class loader is not the same as or an
2058      *         ancestor of the class loader for the current class and
2059      *         invocation of {@link SecurityManager#checkPackageAccess
2060      *         s.checkPackageAccess()} denies access to the package
2061      *         of this class.
2062      *
2063      * @since 1.1
2064      * @jls 8.2 Class Members
2065      * @jls 8.3 Field Declarations
2066      */
2067     @CallerSensitive
2068     public Field getField(String name)
2069         throws NoSuchFieldException, SecurityException {
2070         Objects.requireNonNull(name);
2071         SecurityManager sm = System.getSecurityManager();
2072         if (sm != null) {
2073             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2074         }
2075         Field field = getField0(name);
2076         if (field == null) {
2077             throw new NoSuchFieldException(name);
2078         }
2079         return getReflectionFactory().copyField(field);
2080     }
2081 
2082 
2083     /**
2084      * Returns a {@code Method} object that reflects the specified public
2085      * member method of the class or interface represented by this
2086      * {@code Class} object. The {@code name} parameter is a
2087      * {@code String} specifying the simple name of the desired method. The
2088      * {@code parameterTypes} parameter is an array of {@code Class}
2089      * objects that identify the method&#39;s formal parameter types, in declared
2090      * order. If {@code parameterTypes} is {@code null}, it is
2091      * treated as if it were an empty array.
2092      *
2093      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2094      * method finds any public method inherited by the array type from
2095      * {@code Object} except method {@code clone()}.
2096      *
2097      * &lt;p&gt; If this {@code Class} object represents an interface then this
2098      * method does not find any implicitly declared method from
2099      * {@code Object}. Therefore, if no methods are explicitly declared in
2100      * this interface or any of its superinterfaces, then this method does not
2101      * find any method.
2102      *
2103      * &lt;p&gt; This method does not find any method with name &quot;{@code &lt;init&gt;}&quot; or
2104      * &quot;{@code &lt;clinit&gt;}&quot;.
2105      *
2106      * &lt;p&gt; Generally, the method to be reflected is determined by the 4 step
2107      * algorithm that follows.
2108      * Let C be the class or interface represented by this {@code Class} object:
2109      * &lt;ol&gt;
2110      * &lt;li&gt; A union of methods is composed of:
2111      *   &lt;ol type=&quot;a&quot;&gt;
2112      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2113      *        {@link #getDeclaredMethods()} and filtered to include only public
2114      *        methods that match given {@code name} and {@code parameterTypes}&lt;/li&gt;
2115      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2116      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2117      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2118      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2119      *   &lt;/ol&gt;&lt;/li&gt;
2120      * &lt;li&gt; This union is partitioned into subsets of methods with same
2121      *      return type (the selection of methods from step 1 also guarantees that
2122      *      they have the same method name and parameter types).&lt;/li&gt;
2123      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2124      *      Let method M be a method from a set of methods with same VM
2125      *      signature (return type, name, parameter types).
2126      *      M is most specific if there is no such method N != M from the same
2127      *      set, such that N is more specific than M. N is more specific than M
2128      *      if:
2129      *   &lt;ol type=&quot;a&quot;&gt;
2130      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2131      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2132      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2133      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2134      *        M and N are the same method).&lt;/li&gt;
2135      *   &lt;/ol&gt;&lt;/li&gt;
2136      * &lt;li&gt; The result of this algorithm is chosen arbitrarily from the methods
2137      *      with most specific return type among all selected methods from step 3.
2138      *      Let R be a return type of a method M from the set of all selected methods
2139      *      from step 3. M is a method with most specific return type if there is
2140      *      no such method N != M from the same set, having return type S != R,
2141      *      such that S is a subtype of R as determined by
2142      *      R.class.{@link #isAssignableFrom}(S.class).
2143      * &lt;/ol&gt;
2144      *
2145      * @apiNote There may be more than one method with matching name and
2146      * parameter types in a class because while the Java language forbids a
2147      * class to declare multiple methods with the same signature but different
2148      * return types, the Java virtual machine does not.  This
2149      * increased flexibility in the virtual machine can be used to
2150      * implement various language features.  For example, covariant
2151      * returns can be implemented with {@linkplain
2152      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2153      * method and the overriding method would have the same
2154      * signature but different return types. This method would return the
2155      * overriding method as it would have a more specific return type.
2156      *
2157      * @param name the name of the method
2158      * @param parameterTypes the list of parameters
2159      * @return the {@code Method} object that matches the specified
2160      *         {@code name} and {@code parameterTypes}
2161      * @throws NoSuchMethodException if a matching method is not found
2162      *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
2163      * @throws NullPointerException if {@code name} is {@code null}
2164      * @throws SecurityException
2165      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2166      *         the caller&#39;s class loader is not the same as or an
2167      *         ancestor of the class loader for the current class and
2168      *         invocation of {@link SecurityManager#checkPackageAccess
2169      *         s.checkPackageAccess()} denies access to the package
2170      *         of this class.
2171      *
2172      * @jls 8.2 Class Members
2173      * @jls 8.4 Method Declarations
2174      * @since 1.1
2175      */
2176     @CallerSensitive
2177     public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
2178         throws NoSuchMethodException, SecurityException {
2179         Objects.requireNonNull(name);
2180         SecurityManager sm = System.getSecurityManager();
2181         if (sm != null) {
2182             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2183         }
2184         Method method = getMethod0(name, parameterTypes);
2185         if (method == null) {
2186             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2187         }
2188         return getReflectionFactory().copyMethod(method);
2189     }
2190 
2191     /**
2192      * Returns a {@code Constructor} object that reflects the specified
2193      * public constructor of the class represented by this {@code Class}
2194      * object. The {@code parameterTypes} parameter is an array of
2195      * {@code Class} objects that identify the constructor&#39;s formal
2196      * parameter types, in declared order.
2197      *
2198      * If this {@code Class} object represents an inner class
2199      * declared in a non-static context, the formal parameter types
2200      * include the explicit enclosing instance as the first parameter.
2201      *
2202      * &lt;p&gt; The constructor to reflect is the public constructor of the class
2203      * represented by this {@code Class} object whose formal parameter
2204      * types match those specified by {@code parameterTypes}.
2205      *
2206      * @param parameterTypes the parameter array
2207      * @return the {@code Constructor} object of the public constructor that
2208      *         matches the specified {@code parameterTypes}
2209      * @throws NoSuchMethodException if a matching method is not found.
2210      * @throws SecurityException
2211      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2212      *         the caller&#39;s class loader is not the same as or an
2213      *         ancestor of the class loader for the current class and
2214      *         invocation of {@link SecurityManager#checkPackageAccess
2215      *         s.checkPackageAccess()} denies access to the package
2216      *         of this class.
2217      *
2218      * @since 1.1
2219      */
2220     @CallerSensitive
2221     public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
2222         throws NoSuchMethodException, SecurityException
2223     {
2224         SecurityManager sm = System.getSecurityManager();
2225         if (sm != null) {
2226             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2227         }
2228         return getReflectionFactory().copyConstructor(
2229             getConstructor0(parameterTypes, Member.PUBLIC));
2230     }
2231 
2232 
2233     /**
2234      * Returns an array of {@code Class} objects reflecting all the
2235      * classes and interfaces declared as members of the class represented by
2236      * this {@code Class} object. This includes public, protected, default
2237      * (package) access, and private classes and interfaces declared by the
2238      * class, but excludes inherited classes and interfaces.  This method
2239      * returns an array of length 0 if the class declares no classes or
2240      * interfaces as members, or if this {@code Class} object represents a
2241      * primitive type, an array class, or void.
2242      *
2243      * @return the array of {@code Class} objects representing all the
2244      *         declared members of this class
2245      * @throws SecurityException
2246      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2247      *         following conditions is met:
2248      *
2249      *         &lt;ul&gt;
2250      *
2251      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
2252      *         class loader of this class and invocation of
2253      *         {@link SecurityManager#checkPermission
2254      *         s.checkPermission} method with
2255      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2256      *         denies access to the declared classes within this class
2257      *
2258      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
2259      *         ancestor of the class loader for the current class and
2260      *         invocation of {@link SecurityManager#checkPackageAccess
2261      *         s.checkPackageAccess()} denies access to the package
2262      *         of this class
2263      *
2264      *         &lt;/ul&gt;
2265      *
2266      * @since 1.1
2267      */
2268     @CallerSensitive
2269     public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
2270         SecurityManager sm = System.getSecurityManager();
2271         if (sm != null) {
2272             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);
2273         }
2274         return getDeclaredClasses0();
2275     }
2276 
2277 
2278     /**
2279      * Returns an array of {@code Field} objects reflecting all the fields
2280      * declared by the class or interface represented by this
2281      * {@code Class} object. This includes public, protected, default
2282      * (package) access, and private fields, but excludes inherited fields.
2283      *
2284      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2285      * declared fields, then this method returns an array of length 0.
2286      *
2287      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2288      * type, or void, then this method returns an array of length 0.
2289      *
2290      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2291      * particular order.
2292      *
2293      * @return  the array of {@code Field} objects representing all the
2294      *          declared fields of this class
2295      * @throws  SecurityException
2296      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2297      *          following conditions is met:
2298      *
2299      *          &lt;ul&gt;
2300      *
2301      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2302      *          class loader of this class and invocation of
2303      *          {@link SecurityManager#checkPermission
2304      *          s.checkPermission} method with
2305      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2306      *          denies access to the declared fields within this class
2307      *
2308      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2309      *          ancestor of the class loader for the current class and
2310      *          invocation of {@link SecurityManager#checkPackageAccess
2311      *          s.checkPackageAccess()} denies access to the package
2312      *          of this class
2313      *
2314      *          &lt;/ul&gt;
2315      *
2316      * @since 1.1
2317      * @jls 8.2 Class Members
2318      * @jls 8.3 Field Declarations
2319      */
2320     @CallerSensitive
2321     public Field[] getDeclaredFields() throws SecurityException {
2322         SecurityManager sm = System.getSecurityManager();
2323         if (sm != null) {
2324             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2325         }
2326         return copyFields(privateGetDeclaredFields(false));
2327     }
2328 
2329     /**
2330      * {@preview Associated with records, a preview feature of the Java language.
2331      *
2332      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
2333      *           feature of the Java language. Preview features
2334      *           may be removed in a future release, or upgraded to permanent
2335      *           features of the Java language.}
2336      *
2337      * Returns an array of {@code RecordComponent} objects representing all the
2338      * record components of this record class, or {@code null} if this class is
2339      * not a record class.
2340      *
2341      * &lt;p&gt; The components are returned in the same order that they are declared
2342      * in the record header. The array is empty if this record class has no
2343      * components. If the class is not a record class, that is {@link
2344      * #isRecord()} returns {@code false}, then this method returns {@code null}.
2345      * Conversely, if {@link #isRecord()} returns {@code true}, then this method
2346      * returns a non-null value.
2347      *
2348      * @return  An array of {@code RecordComponent} objects representing all the
2349      *          record components of this record class, or {@code null} if this
2350      *          class is not a record class
2351      * @throws  SecurityException
2352      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2353      *          following conditions is met:
2354      *
2355      *          &lt;ul&gt;
2356      *
2357      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2358      *          class loader of this class and invocation of
2359      *          {@link SecurityManager#checkPermission
2360      *          s.checkPermission} method with
2361      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2362      *          denies access to the declared methods within this class
2363      *
2364      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2365      *          ancestor of the class loader for the current class and
2366      *          invocation of {@link SecurityManager#checkPackageAccess
2367      *          s.checkPackageAccess()} denies access to the package
2368      *          of this class
2369      *
2370      *          &lt;/ul&gt;
2371      *
2372      * @jls 8.10 Record Types
2373      * @since 14
2374      */
2375     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
2376                                  essentialAPI=false)
2377     @SuppressWarnings(&quot;preview&quot;)
2378     @CallerSensitive
2379     public RecordComponent[] getRecordComponents() {
2380         SecurityManager sm = System.getSecurityManager();
2381         if (sm != null) {
2382             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2383         }
2384         if (!isRecord()) {
2385             return null;
2386         }
2387         RecordComponent[] recordComponents = getRecordComponents0();
2388         if (recordComponents == null) {
2389             return new RecordComponent[0];
2390         }
2391         return recordComponents;
2392     }
2393 
2394     /**
2395      * Returns an array containing {@code Method} objects reflecting all the
2396      * declared methods of the class or interface represented by this {@code
2397      * Class} object, including public, protected, default (package)
2398      * access, and private methods, but excluding inherited methods.
2399      *
2400      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2401      * declared methods with the same name and parameter types, but different
2402      * return types, then the returned array has a {@code Method} object for
2403      * each such method.
2404      *
2405      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2406      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2407      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2408      *
2409      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2410      * declared methods, then the returned array has length 0.
2411      *
2412      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2413      * type, or void, then the returned array has length 0.
2414      *
2415      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2416      * particular order.
2417      *
2418      * @return  the array of {@code Method} objects representing all the
2419      *          declared methods of this class
2420      * @throws  SecurityException
2421      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2422      *          following conditions is met:
2423      *
2424      *          &lt;ul&gt;
2425      *
2426      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2427      *          class loader of this class and invocation of
2428      *          {@link SecurityManager#checkPermission
2429      *          s.checkPermission} method with
2430      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2431      *          denies access to the declared methods within this class
2432      *
2433      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2434      *          ancestor of the class loader for the current class and
2435      *          invocation of {@link SecurityManager#checkPackageAccess
2436      *          s.checkPackageAccess()} denies access to the package
2437      *          of this class
2438      *
2439      *          &lt;/ul&gt;
2440      *
2441      * @jls 8.2 Class Members
2442      * @jls 8.4 Method Declarations
2443      * @since 1.1
2444      */
2445     @CallerSensitive
2446     public Method[] getDeclaredMethods() throws SecurityException {
2447         SecurityManager sm = System.getSecurityManager();
2448         if (sm != null) {
2449             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2450         }
2451         return copyMethods(privateGetDeclaredMethods(false));
2452     }
2453 
2454 
2455     /**
2456      * Returns an array of {@code Constructor} objects reflecting all the
2457      * constructors declared by the class represented by this
2458      * {@code Class} object. These are public, protected, default
2459      * (package) access, and private constructors.  The elements in the array
2460      * returned are not sorted and are not in any particular order.  If the
2461      * class has a default constructor, it is included in the returned array.
2462      * This method returns an array of length 0 if this {@code Class}
2463      * object represents an interface, a primitive type, an array class, or
2464      * void.
2465      *
2466      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
2467      * section {@jls 8.2}.
2468      *
2469      * @return  the array of {@code Constructor} objects representing all the
2470      *          declared constructors of this class
2471      * @throws  SecurityException
2472      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2473      *          following conditions is met:
2474      *
2475      *          &lt;ul&gt;
2476      *
2477      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2478      *          class loader of this class and invocation of
2479      *          {@link SecurityManager#checkPermission
2480      *          s.checkPermission} method with
2481      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2482      *          denies access to the declared constructors within this class
2483      *
2484      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2485      *          ancestor of the class loader for the current class and
2486      *          invocation of {@link SecurityManager#checkPackageAccess
2487      *          s.checkPackageAccess()} denies access to the package
2488      *          of this class
2489      *
2490      *          &lt;/ul&gt;
2491      *
2492      * @since 1.1
2493      */
2494     @CallerSensitive
2495     public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
2496         SecurityManager sm = System.getSecurityManager();
2497         if (sm != null) {
2498             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2499         }
2500         return copyConstructors(privateGetDeclaredConstructors(false));
2501     }
2502 
2503 
2504     /**
2505      * Returns a {@code Field} object that reflects the specified declared
2506      * field of the class or interface represented by this {@code Class}
2507      * object. The {@code name} parameter is a {@code String} that specifies
2508      * the simple name of the desired field.
2509      *
2510      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2511      * method does not find the {@code length} field of the array type.
2512      *
2513      * @param name the name of the field
2514      * @return  the {@code Field} object for the specified field in this
2515      *          class
2516      * @throws  NoSuchFieldException if a field with the specified name is
2517      *          not found.
2518      * @throws  NullPointerException if {@code name} is {@code null}
2519      * @throws  SecurityException
2520      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2521      *          following conditions is met:
2522      *
2523      *          &lt;ul&gt;
2524      *
2525      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2526      *          class loader of this class and invocation of
2527      *          {@link SecurityManager#checkPermission
2528      *          s.checkPermission} method with
2529      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2530      *          denies access to the declared field
2531      *
2532      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2533      *          ancestor of the class loader for the current class and
2534      *          invocation of {@link SecurityManager#checkPackageAccess
2535      *          s.checkPackageAccess()} denies access to the package
2536      *          of this class
2537      *
2538      *          &lt;/ul&gt;
2539      *
2540      * @since 1.1
2541      * @jls 8.2 Class Members
2542      * @jls 8.3 Field Declarations
2543      */
2544     @CallerSensitive
2545     public Field getDeclaredField(String name)
2546         throws NoSuchFieldException, SecurityException {
2547         Objects.requireNonNull(name);
2548         SecurityManager sm = System.getSecurityManager();
2549         if (sm != null) {
2550             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2551         }
2552         Field field = searchFields(privateGetDeclaredFields(false), name);
2553         if (field == null) {
2554             throw new NoSuchFieldException(name);
2555         }
2556         return getReflectionFactory().copyField(field);
2557     }
2558 
2559 
2560     /**
2561      * Returns a {@code Method} object that reflects the specified
2562      * declared method of the class or interface represented by this
2563      * {@code Class} object. The {@code name} parameter is a
2564      * {@code String} that specifies the simple name of the desired
2565      * method, and the {@code parameterTypes} parameter is an array of
2566      * {@code Class} objects that identify the method&#39;s formal parameter
2567      * types, in declared order.  If more than one method with the same
2568      * parameter types is declared in a class, and one of these methods has a
2569      * return type that is more specific than any of the others, that method is
2570      * returned; otherwise one of the methods is chosen arbitrarily.  If the
2571      * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}
2572      * is raised.
2573      *
2574      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2575      * method does not find the {@code clone()} method.
2576      *
2577      * @param name the name of the method
2578      * @param parameterTypes the parameter array
2579      * @return  the {@code Method} object for the method of this class
2580      *          matching the specified name and parameters
2581      * @throws  NoSuchMethodException if a matching method is not found.
2582      * @throws  NullPointerException if {@code name} is {@code null}
2583      * @throws  SecurityException
2584      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2585      *          following conditions is met:
2586      *
2587      *          &lt;ul&gt;
2588      *
2589      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2590      *          class loader of this class and invocation of
2591      *          {@link SecurityManager#checkPermission
2592      *          s.checkPermission} method with
2593      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2594      *          denies access to the declared method
2595      *
2596      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2597      *          ancestor of the class loader for the current class and
2598      *          invocation of {@link SecurityManager#checkPackageAccess
2599      *          s.checkPackageAccess()} denies access to the package
2600      *          of this class
2601      *
2602      *          &lt;/ul&gt;
2603      *
2604      * @jls 8.2 Class Members
2605      * @jls 8.4 Method Declarations
2606      * @since 1.1
2607      */
2608     @CallerSensitive
2609     public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
2610         throws NoSuchMethodException, SecurityException {
2611         Objects.requireNonNull(name);
2612         SecurityManager sm = System.getSecurityManager();
2613         if (sm != null) {
2614             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2615         }
2616         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
2617         if (method == null) {
2618             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2619         }
2620         return getReflectionFactory().copyMethod(method);
2621     }
2622 
2623     /**
2624      * Returns the list of {@code Method} objects for the declared public
2625      * methods of this class or interface that have the specified method name
2626      * and parameter types.
2627      *
2628      * @param name the name of the method
2629      * @param parameterTypes the parameter array
2630      * @return the list of {@code Method} objects for the public methods of
2631      *         this class matching the specified name and parameters
2632      */
2633     List&lt;Method&gt; getDeclaredPublicMethods(String name, Class&lt;?&gt;... parameterTypes) {
2634         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
2635         ReflectionFactory factory = getReflectionFactory();
2636         List&lt;Method&gt; result = new ArrayList&lt;&gt;();
2637         for (Method method : methods) {
2638             if (method.getName().equals(name)
2639                 &amp;&amp; Arrays.equals(
2640                     factory.getExecutableSharedParameterTypes(method),
2641                     parameterTypes)) {
2642                 result.add(factory.copyMethod(method));
2643             }
2644         }
2645         return result;
2646     }
2647 
2648     /**
2649      * Returns a {@code Constructor} object that reflects the specified
2650      * constructor of the class or interface represented by this
2651      * {@code Class} object.  The {@code parameterTypes} parameter is
2652      * an array of {@code Class} objects that identify the constructor&#39;s
2653      * formal parameter types, in declared order.
2654      *
2655      * If this {@code Class} object represents an inner class
2656      * declared in a non-static context, the formal parameter types
2657      * include the explicit enclosing instance as the first parameter.
2658      *
2659      * @param parameterTypes the parameter array
2660      * @return  The {@code Constructor} object for the constructor with the
2661      *          specified parameter list
2662      * @throws  NoSuchMethodException if a matching method is not found.
2663      * @throws  SecurityException
2664      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2665      *          following conditions is met:
2666      *
2667      *          &lt;ul&gt;
2668      *
2669      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2670      *          class loader of this class and invocation of
2671      *          {@link SecurityManager#checkPermission
2672      *          s.checkPermission} method with
2673      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2674      *          denies access to the declared constructor
2675      *
2676      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2677      *          ancestor of the class loader for the current class and
2678      *          invocation of {@link SecurityManager#checkPackageAccess
2679      *          s.checkPackageAccess()} denies access to the package
2680      *          of this class
2681      *
2682      *          &lt;/ul&gt;
2683      *
2684      * @since 1.1
2685      */
2686     @CallerSensitive
2687     public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
2688         throws NoSuchMethodException, SecurityException
2689     {
2690         SecurityManager sm = System.getSecurityManager();
2691         if (sm != null) {
2692             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2693         }
2694 
2695         return getReflectionFactory().copyConstructor(
2696             getConstructor0(parameterTypes, Member.DECLARED));
2697     }
2698 
2699     /**
2700      * Finds a resource with a given name.
2701      *
2702      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2703      * will attempt to find the resource in the module. This is done by
2704      * delegating to the module&#39;s class loader {@link
2705      * ClassLoader#findResource(String,String) findResource(String,String)}
2706      * method, invoking it with the module name and the absolute name of the
2707      * resource. Resources in named modules are subject to the rules for
2708      * encapsulation specified in the {@code Module} {@link
2709      * Module#getResourceAsStream getResourceAsStream} method and so this
2710      * method returns {@code null} when the resource is a
2711      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2712      * caller&#39;s module.
2713      *
2714      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2715      * searching resources associated with a given class are implemented by the
2716      * defining {@linkplain ClassLoader class loader} of the class.  This method
2717      * delegates to this {@code Class} object&#39;s class loader.
2718      * If this {@code Class} object was loaded by the bootstrap class loader,
2719      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.
2720      *
2721      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2722      * given resource name using this algorithm:
2723      *
2724      * &lt;ul&gt;
2725      *
2726      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2727      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2728      * portion of the {@code name} following the {@code &#39;/&#39;}.
2729      *
2730      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2731      *
2732      * &lt;blockquote&gt;
2733      *   {@code modified_package_name/name}
2734      * &lt;/blockquote&gt;
2735      *
2736      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2737      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2738      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2739      *
2740      * &lt;/ul&gt;
2741      *
2742      * @param  name name of the desired resource
2743      * @return  A {@link java.io.InputStream} object; {@code null} if no
2744      *          resource with this name is found, the resource is in a package
2745      *          that is not {@linkplain Module#isOpen(String, Module) open} to at
2746      *          least the caller module, or access to the resource is denied
2747      *          by the security manager.
2748      * @throws  NullPointerException If {@code name} is {@code null}
2749      *
2750      * @see Module#getResourceAsStream(String)
2751      * @since  1.1
2752      * @revised 9
2753      * @spec JPMS
2754      */
2755     @CallerSensitive
2756     public InputStream getResourceAsStream(String name) {
2757         name = resolveName(name);
2758 
2759         Module thisModule = getModule();
2760         if (thisModule.isNamed()) {
2761             // check if resource can be located by caller
2762             if (Resources.canEncapsulate(name)
2763                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2764                 return null;
2765             }
2766 
2767             // resource not encapsulated or in package open to caller
2768             String mn = thisModule.getName();
2769             ClassLoader cl = getClassLoader0();
2770             try {
2771 
2772                 // special-case built-in class loaders to avoid the
2773                 // need for a URL connection
2774                 if (cl == null) {
2775                     return BootLoader.findResourceAsStream(mn, name);
2776                 } else if (cl instanceof BuiltinClassLoader) {
2777                     return ((BuiltinClassLoader) cl).findResourceAsStream(mn, name);
2778                 } else {
2779                     URL url = cl.findResource(mn, name);
2780                     return (url != null) ? url.openStream() : null;
2781                 }
2782 
2783             } catch (IOException | SecurityException e) {
2784                 return null;
2785             }
2786         }
2787 
2788         // unnamed module
2789         ClassLoader cl = getClassLoader0();
2790         if (cl == null) {
2791             return ClassLoader.getSystemResourceAsStream(name);
2792         } else {
2793             return cl.getResourceAsStream(name);
2794         }
2795     }
2796 
2797     /**
2798      * Finds a resource with a given name.
2799      *
2800      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2801      * will attempt to find the resource in the module. This is done by
2802      * delegating to the module&#39;s class loader {@link
2803      * ClassLoader#findResource(String,String) findResource(String,String)}
2804      * method, invoking it with the module name and the absolute name of the
2805      * resource. Resources in named modules are subject to the rules for
2806      * encapsulation specified in the {@code Module} {@link
2807      * Module#getResourceAsStream getResourceAsStream} method and so this
2808      * method returns {@code null} when the resource is a
2809      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2810      * caller&#39;s module.
2811      *
2812      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2813      * searching resources associated with a given class are implemented by the
2814      * defining {@linkplain ClassLoader class loader} of the class.  This method
2815      * delegates to this {@code Class} object&#39;s class loader.
2816      * If this {@code Class} object was loaded by the bootstrap class loader,
2817      * the method delegates to {@link ClassLoader#getSystemResource}.
2818      *
2819      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2820      * given resource name using this algorithm:
2821      *
2822      * &lt;ul&gt;
2823      *
2824      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2825      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2826      * portion of the {@code name} following the {@code &#39;/&#39;}.
2827      *
2828      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2829      *
2830      * &lt;blockquote&gt;
2831      *   {@code modified_package_name/name}
2832      * &lt;/blockquote&gt;
2833      *
2834      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2835      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2836      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2837      *
2838      * &lt;/ul&gt;
2839      *
2840      * @param  name name of the desired resource
2841      * @return A {@link java.net.URL} object; {@code null} if no resource with
2842      *         this name is found, the resource cannot be located by a URL, the
2843      *         resource is in a package that is not
2844      *         {@linkplain Module#isOpen(String, Module) open} to at least the caller
2845      *         module, or access to the resource is denied by the security
2846      *         manager.
2847      * @throws NullPointerException If {@code name} is {@code null}
2848      * @since  1.1
2849      * @revised 9
2850      * @spec JPMS
2851      */
2852     @CallerSensitive
2853     public URL getResource(String name) {
2854         name = resolveName(name);
2855 
2856         Module thisModule = getModule();
2857         if (thisModule.isNamed()) {
2858             // check if resource can be located by caller
2859             if (Resources.canEncapsulate(name)
2860                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2861                 return null;
2862             }
2863 
2864             // resource not encapsulated or in package open to caller
2865             String mn = thisModule.getName();
2866             ClassLoader cl = getClassLoader0();
2867             try {
2868                 if (cl == null) {
2869                     return BootLoader.findResource(mn, name);
2870                 } else {
2871                     return cl.findResource(mn, name);
2872                 }
2873             } catch (IOException ioe) {
2874                 return null;
2875             }
2876         }
2877 
2878         // unnamed module
2879         ClassLoader cl = getClassLoader0();
2880         if (cl == null) {
2881             return ClassLoader.getSystemResource(name);
2882         } else {
2883             return cl.getResource(name);
2884         }
2885     }
2886 
2887     /**
2888      * Returns true if a resource with the given name can be located by the
2889      * given caller. All resources in a module can be located by code in
2890      * the module. For other callers, then the package needs to be open to
2891      * the caller.
2892      */
2893     private boolean isOpenToCaller(String name, Class&lt;?&gt; caller) {
2894         // assert getModule().isNamed();
2895         Module thisModule = getModule();
2896         Module callerModule = (caller != null) ? caller.getModule() : null;
2897         if (callerModule != thisModule) {
2898             String pn = Resources.toPackageName(name);
2899             if (thisModule.getDescriptor().packages().contains(pn)) {
2900                 if (callerModule == null &amp;&amp; !thisModule.isOpen(pn)) {
2901                     // no caller, package not open
2902                     return false;
2903                 }
2904                 if (!thisModule.isOpen(pn, callerModule)) {
2905                     // package not open to caller
2906                     return false;
2907                 }
2908             }
2909         }
2910         return true;
2911     }
2912 
2913 
2914     /** protection domain returned when the internal domain is null */
2915     private static java.security.ProtectionDomain allPermDomain;
2916 
2917     /**
2918      * Returns the {@code ProtectionDomain} of this class.  If there is a
2919      * security manager installed, this method first calls the security
2920      * manager&#39;s {@code checkPermission} method with a
2921      * {@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
2922      * ensure it&#39;s ok to get the
2923      * {@code ProtectionDomain}.
2924      *
2925      * @return the ProtectionDomain of this class
2926      *
2927      * @throws SecurityException
2928      *        if a security manager exists and its
2929      *        {@code checkPermission} method doesn&#39;t allow
2930      *        getting the ProtectionDomain.
2931      *
2932      * @see java.security.ProtectionDomain
2933      * @see SecurityManager#checkPermission
2934      * @see java.lang.RuntimePermission
2935      * @since 1.2
2936      */
2937     public java.security.ProtectionDomain getProtectionDomain() {
2938         SecurityManager sm = System.getSecurityManager();
2939         if (sm != null) {
2940             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
2941         }
2942         java.security.ProtectionDomain pd = getProtectionDomain0();
2943         if (pd == null) {
2944             if (allPermDomain == null) {
2945                 java.security.Permissions perms =
2946                     new java.security.Permissions();
2947                 perms.add(SecurityConstants.ALL_PERMISSION);
2948                 allPermDomain =
2949                     new java.security.ProtectionDomain(null, perms);
2950             }
2951             pd = allPermDomain;
2952         }
2953         return pd;
2954     }
2955 
2956 
2957     /**
2958      * Returns the ProtectionDomain of this class.
2959      */
2960     private native java.security.ProtectionDomain getProtectionDomain0();
2961 
2962     /*
2963      * Return the Virtual Machine&#39;s Class object for the named
2964      * primitive type.
2965      */
2966     static native Class&lt;?&gt; getPrimitiveClass(String name);
2967 
2968     /*
2969      * Check if client is allowed to access members.  If access is denied,
2970      * throw a SecurityException.
2971      *
2972      * This method also enforces package access.
2973      *
2974      * &lt;p&gt; Default policy: allow all clients access with normal Java access
2975      * control.
2976      *
2977      * &lt;p&gt; NOTE: should only be called if a SecurityManager is installed
2978      */
2979     private void checkMemberAccess(SecurityManager sm, int which,
2980                                    Class&lt;?&gt; caller, boolean checkProxyInterfaces) {
2981         /* Default policy allows access to all {@link Member#PUBLIC} members,
2982          * as well as access to classes that have the same class loader as the caller.
2983          * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
2984          * permission.
2985          */
2986         final ClassLoader ccl = ClassLoader.getClassLoader(caller);
2987         if (which != Member.PUBLIC) {
2988             final ClassLoader cl = getClassLoader0();
2989             if (ccl != cl) {
2990                 sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
2991             }
2992         }
2993         this.checkPackageAccess(sm, ccl, checkProxyInterfaces);
2994     }
2995 
2996     /*
2997      * Checks if a client loaded in ClassLoader ccl is allowed to access this
2998      * class under the current package access policy. If access is denied,
2999      * throw a SecurityException.
3000      *
3001      * NOTE: this method should only be called if a SecurityManager is active
3002      */
3003     private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,
3004                                     boolean checkProxyInterfaces) {
3005         final ClassLoader cl = getClassLoader0();
3006 
3007         if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
3008             String pkg = this.getPackageName();
3009             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3010                 // skip the package access check on a proxy class in default proxy package
3011                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3012                     sm.checkPackageAccess(pkg);
3013                 }
3014             }
3015         }
3016         // check package access on the proxy interfaces
3017         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3018             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3019         }
3020     }
3021 
3022     /**
3023      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3024      * if name is absolute
3025      */
3026     private String resolveName(String name) {
3027         if (!name.startsWith(&quot;/&quot;)) {
3028             Class&lt;?&gt; c = this;
3029             while (c.isArray()) {
3030                 c = c.getComponentType();
3031             }
3032             String baseName = c.getPackageName();
3033             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3034                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3035             }
3036         } else {
3037             name = name.substring(1);
3038         }
3039         return name;
3040     }
3041 
3042     /**
3043      * Atomic operations support.
3044      */
3045     private static class Atomic {
3046         // initialize Unsafe machinery here, since we need to call Class.class instance method
3047         // and have to avoid calling it in the static initializer of the Class class...
3048         private static final Unsafe unsafe = Unsafe.getUnsafe();
3049         // offset of Class.reflectionData instance field
3050         private static final long reflectionDataOffset
3051                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
3052         // offset of Class.annotationType instance field
3053         private static final long annotationTypeOffset
3054                 = unsafe.objectFieldOffset(Class.class, &quot;annotationType&quot;);
3055         // offset of Class.annotationData instance field
3056         private static final long annotationDataOffset
3057                 = unsafe.objectFieldOffset(Class.class, &quot;annotationData&quot;);
3058 
3059         static &lt;T&gt; boolean casReflectionData(Class&lt;?&gt; clazz,
3060                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
3061                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) {
3062             return unsafe.compareAndSetReference(clazz, reflectionDataOffset, oldData, newData);
3063         }
3064 
3065         static &lt;T&gt; boolean casAnnotationType(Class&lt;?&gt; clazz,
3066                                              AnnotationType oldType,
3067                                              AnnotationType newType) {
3068             return unsafe.compareAndSetReference(clazz, annotationTypeOffset, oldType, newType);
3069         }
3070 
3071         static &lt;T&gt; boolean casAnnotationData(Class&lt;?&gt; clazz,
3072                                              AnnotationData oldData,
3073                                              AnnotationData newData) {
3074             return unsafe.compareAndSetReference(clazz, annotationDataOffset, oldData, newData);
3075         }
3076     }
3077 
3078     /**
3079      * Reflection support.
3080      */
3081 
3082     // Reflection data caches various derived names and reflective members. Cached
3083     // values may be invalidated when JVM TI RedefineClasses() is called
3084     private static class ReflectionData&lt;T&gt; {
3085         volatile Field[] declaredFields;
3086         volatile Field[] publicFields;
3087         volatile Method[] declaredMethods;
3088         volatile Method[] publicMethods;
3089         volatile Constructor&lt;T&gt;[] declaredConstructors;
3090         volatile Constructor&lt;T&gt;[] publicConstructors;
3091         // Intermediate results for getFields and getMethods
3092         volatile Field[] declaredPublicFields;
3093         volatile Method[] declaredPublicMethods;
3094         volatile Class&lt;?&gt;[] interfaces;
3095 
3096         // Cached names
3097         String simpleName;
3098         String canonicalName;
3099         static final String NULL_SENTINEL = new String();
3100 
3101         // Value of classRedefinedCount when we created this ReflectionData instance
3102         final int redefinedCount;
3103 
3104         ReflectionData(int redefinedCount) {
3105             this.redefinedCount = redefinedCount;
3106         }
3107     }
3108 
3109     private transient volatile SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;
3110 
3111     // Incremented by the VM on each call to JVM TI RedefineClasses()
3112     // that redefines this class or a superclass.
3113     private transient volatile int classRedefinedCount;
3114 
3115     // Lazily create and cache ReflectionData
3116     private ReflectionData&lt;T&gt; reflectionData() {
3117         SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;
3118         int classRedefinedCount = this.classRedefinedCount;
3119         ReflectionData&lt;T&gt; rd;
3120         if (reflectionData != null &amp;&amp;
3121             (rd = reflectionData.get()) != null &amp;&amp;
3122             rd.redefinedCount == classRedefinedCount) {
3123             return rd;
3124         }
3125         // else no SoftReference or cleared SoftReference or stale ReflectionData
3126         // -&gt; create and replace new instance
3127         return newReflectionData(reflectionData, classRedefinedCount);
3128     }
3129 
3130     private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
3131                                                 int classRedefinedCount) {
3132         while (true) {
3133             ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);
3134             // try to CAS it...
3135             if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {
3136                 return rd;
3137             }
3138             // else retry
3139             oldReflectionData = this.reflectionData;
3140             classRedefinedCount = this.classRedefinedCount;
3141             if (oldReflectionData != null &amp;&amp;
3142                 (rd = oldReflectionData.get()) != null &amp;&amp;
3143                 rd.redefinedCount == classRedefinedCount) {
3144                 return rd;
3145             }
3146         }
3147     }
3148 
3149     // Generic signature handling
3150     private native String getGenericSignature0();
3151 
3152     // Generic info repository; lazily initialized
3153     private transient volatile ClassRepository genericInfo;
3154 
3155     // accessor for factory
3156     private GenericsFactory getFactory() {
3157         // create scope and factory
3158         return CoreReflectionFactory.make(this, ClassScope.make(this));
3159     }
3160 
3161     // accessor for generic info repository;
3162     // generic info is lazily initialized
3163     private ClassRepository getGenericInfo() {
3164         ClassRepository genericInfo = this.genericInfo;
3165         if (genericInfo == null) {
3166             String signature = getGenericSignature0();
3167             if (signature == null) {
3168                 genericInfo = ClassRepository.NONE;
3169             } else {
3170                 genericInfo = ClassRepository.make(signature, getFactory());
3171             }
3172             this.genericInfo = genericInfo;
3173         }
3174         return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
3175     }
3176 
3177     // Annotations handling
3178     native byte[] getRawAnnotations();
3179     // Since 1.8
3180     native byte[] getRawTypeAnnotations();
3181     static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
3182         return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
3183     }
3184 
3185     native ConstantPool getConstantPool();
3186 
3187     //
3188     //
3189     // java.lang.reflect.Field handling
3190     //
3191     //
3192 
3193     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3194     // be propagated to the outside world, but must instead be copied
3195     // via ReflectionFactory.copyField.
3196     private Field[] privateGetDeclaredFields(boolean publicOnly) {
3197         Field[] res;
3198         ReflectionData&lt;T&gt; rd = reflectionData();
3199         if (rd != null) {
3200             res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
3201             if (res != null) return res;
3202         }
3203         // No cached value available; request value from VM
3204         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
3205         if (rd != null) {
3206             if (publicOnly) {
3207                 rd.declaredPublicFields = res;
3208             } else {
3209                 rd.declaredFields = res;
3210             }
3211         }
3212         return res;
3213     }
3214 
3215     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3216     // be propagated to the outside world, but must instead be copied
3217     // via ReflectionFactory.copyField.
3218     private Field[] privateGetPublicFields() {
3219         Field[] res;
3220         ReflectionData&lt;T&gt; rd = reflectionData();
3221         if (rd != null) {
3222             res = rd.publicFields;
3223             if (res != null) return res;
3224         }
3225 
3226         // Use a linked hash set to ensure order is preserved and
3227         // fields from common super interfaces are not duplicated
3228         LinkedHashSet&lt;Field&gt; fields = new LinkedHashSet&lt;&gt;();
3229 
3230         // Local fields
3231         addAll(fields, privateGetDeclaredFields(true));
3232 
3233         // Direct superinterfaces, recursively
3234         for (Class&lt;?&gt; si : getInterfaces()) {
3235             addAll(fields, si.privateGetPublicFields());
3236         }
3237 
3238         // Direct superclass, recursively
3239         Class&lt;?&gt; sc = getSuperclass();
3240         if (sc != null) {
3241             addAll(fields, sc.privateGetPublicFields());
3242         }
3243 
3244         res = fields.toArray(new Field[0]);
3245         if (rd != null) {
3246             rd.publicFields = res;
3247         }
3248         return res;
3249     }
3250 
3251     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
3252         for (Field f : o) {
3253             c.add(f);
3254         }
3255     }
3256 
3257 
3258     //
3259     //
3260     // java.lang.reflect.Constructor handling
3261     //
3262     //
3263 
3264     // Returns an array of &quot;root&quot; constructors. These Constructor
3265     // objects must NOT be propagated to the outside world, but must
3266     // instead be copied via ReflectionFactory.copyConstructor.
3267     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
3268         Constructor&lt;T&gt;[] res;
3269         ReflectionData&lt;T&gt; rd = reflectionData();
3270         if (rd != null) {
3271             res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
3272             if (res != null) return res;
3273         }
3274         // No cached value available; request value from VM
3275         if (isInterface()) {
3276             @SuppressWarnings(&quot;unchecked&quot;)
3277             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
3278             res = temporaryRes;
3279         } else {
3280             res = getDeclaredConstructors0(publicOnly);
3281         }
3282         if (rd != null) {
3283             if (publicOnly) {
3284                 rd.publicConstructors = res;
3285             } else {
3286                 rd.declaredConstructors = res;
3287             }
3288         }
3289         return res;
3290     }
3291 
3292     //
3293     //
3294     // java.lang.reflect.Method handling
3295     //
3296     //
3297 
3298     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3299     // be propagated to the outside world, but must instead be copied
3300     // via ReflectionFactory.copyMethod.
3301     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
3302         Method[] res;
3303         ReflectionData&lt;T&gt; rd = reflectionData();
3304         if (rd != null) {
3305             res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
3306             if (res != null) return res;
3307         }
3308         // No cached value available; request value from VM
3309         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
3310         if (rd != null) {
3311             if (publicOnly) {
3312                 rd.declaredPublicMethods = res;
3313             } else {
3314                 rd.declaredMethods = res;
3315             }
3316         }
3317         return res;
3318     }
3319 
3320     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3321     // be propagated to the outside world, but must instead be copied
3322     // via ReflectionFactory.copyMethod.
3323     private Method[] privateGetPublicMethods() {
3324         Method[] res;
3325         ReflectionData&lt;T&gt; rd = reflectionData();
3326         if (rd != null) {
3327             res = rd.publicMethods;
3328             if (res != null) return res;
3329         }
3330 
3331         // No cached value available; compute value recursively.
3332         // Start by fetching public declared methods...
3333         PublicMethods pms = new PublicMethods();
3334         for (Method m : privateGetDeclaredMethods(/* publicOnly */ true)) {
3335             pms.merge(m);
3336         }
3337         // ...then recur over superclass methods...
3338         Class&lt;?&gt; sc = getSuperclass();
3339         if (sc != null) {
3340             for (Method m : sc.privateGetPublicMethods()) {
3341                 pms.merge(m);
3342             }
3343         }
3344         // ...and finally over direct superinterfaces.
3345         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3346             for (Method m : intf.privateGetPublicMethods()) {
3347                 // static interface methods are not inherited
3348                 if (!Modifier.isStatic(m.getModifiers())) {
3349                     pms.merge(m);
3350                 }
3351             }
3352         }
3353 
3354         res = pms.toArray();
3355         if (rd != null) {
3356             rd.publicMethods = res;
3357         }
3358         return res;
3359     }
3360 
3361 
3362     //
3363     // Helpers for fetchers of one field, method, or constructor
3364     //
3365 
3366     // This method does not copy the returned Field object!
3367     private static Field searchFields(Field[] fields, String name) {
3368         for (Field field : fields) {
3369             if (field.getName().equals(name)) {
3370                 return field;
3371             }
3372         }
3373         return null;
3374     }
3375 
3376     // Returns a &quot;root&quot; Field object. This Field object must NOT
3377     // be propagated to the outside world, but must instead be copied
3378     // via ReflectionFactory.copyField.
3379     private Field getField0(String name) {
3380         // Note: the intent is that the search algorithm this routine
3381         // uses be equivalent to the ordering imposed by
3382         // privateGetPublicFields(). It fetches only the declared
3383         // public fields for each class, however, to reduce the number
3384         // of Field objects which have to be created for the common
3385         // case where the field being requested is declared in the
3386         // class which is being queried.
3387         Field res;
3388         // Search declared public fields
3389         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
3390             return res;
3391         }
3392         // Direct superinterfaces, recursively
3393         Class&lt;?&gt;[] interfaces = getInterfaces(/* cloneArray */ false);
3394         for (Class&lt;?&gt; c : interfaces) {
3395             if ((res = c.getField0(name)) != null) {
3396                 return res;
3397             }
3398         }
3399         // Direct superclass, recursively
3400         if (!isInterface()) {
3401             Class&lt;?&gt; c = getSuperclass();
3402             if (c != null) {
3403                 if ((res = c.getField0(name)) != null) {
3404                     return res;
3405                 }
3406             }
3407         }
3408         return null;
3409     }
3410 
3411     // This method does not copy the returned Method object!
3412     private static Method searchMethods(Method[] methods,
3413                                         String name,
3414                                         Class&lt;?&gt;[] parameterTypes)
3415     {
3416         ReflectionFactory fact = getReflectionFactory();
3417         Method res = null;
3418         for (Method m : methods) {
3419             if (m.getName().equals(name)
3420                 &amp;&amp; arrayContentsEq(parameterTypes,
3421                                    fact.getExecutableSharedParameterTypes(m))
3422                 &amp;&amp; (res == null
3423                     || (res.getReturnType() != m.getReturnType()
3424                         &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))
3425                 res = m;
3426         }
3427         return res;
3428     }
3429 
3430     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];
3431 
3432     // Returns a &quot;root&quot; Method object. This Method object must NOT
3433     // be propagated to the outside world, but must instead be copied
3434     // via ReflectionFactory.copyMethod.
3435     private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes) {
3436         PublicMethods.MethodList res = getMethodsRecursive(
3437             name,
3438             parameterTypes == null ? EMPTY_CLASS_ARRAY : parameterTypes,
3439             /* includeStatic */ true);
3440         return res == null ? null : res.getMostSpecific();
3441     }
3442 
3443     // Returns a list of &quot;root&quot; Method objects. These Method objects must NOT
3444     // be propagated to the outside world, but must instead be copied
3445     // via ReflectionFactory.copyMethod.
3446     private PublicMethods.MethodList getMethodsRecursive(String name,
3447                                                          Class&lt;?&gt;[] parameterTypes,
3448                                                          boolean includeStatic) {
3449         // 1st check declared public methods
3450         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
3451         PublicMethods.MethodList res = PublicMethods.MethodList
3452             .filter(methods, name, parameterTypes, includeStatic);
3453         // if there is at least one match among declared methods, we need not
3454         // search any further as such match surely overrides matching methods
3455         // declared in superclass(es) or interface(s).
3456         if (res != null) {
3457             return res;
3458         }
3459 
3460         // if there was no match among declared methods,
3461         // we must consult the superclass (if any) recursively...
3462         Class&lt;?&gt; sc = getSuperclass();
3463         if (sc != null) {
3464             res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);
3465         }
3466 
3467         // ...and coalesce the superclass methods with methods obtained
3468         // from directly implemented interfaces excluding static methods...
3469         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3470             res = PublicMethods.MethodList.merge(
3471                 res, intf.getMethodsRecursive(name, parameterTypes,
3472                                               /* includeStatic */ false));
3473         }
3474 
3475         return res;
3476     }
3477 
3478     // Returns a &quot;root&quot; Constructor object. This Constructor object must NOT
3479     // be propagated to the outside world, but must instead be copied
3480     // via ReflectionFactory.copyConstructor.
3481     private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
3482                                         int which) throws NoSuchMethodException
3483     {
3484         ReflectionFactory fact = getReflectionFactory();
3485         Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
3486         for (Constructor&lt;T&gt; constructor : constructors) {
3487             if (arrayContentsEq(parameterTypes,
3488                                 fact.getExecutableSharedParameterTypes(constructor))) {
3489                 return constructor;
3490             }
3491         }
3492         throw new NoSuchMethodException(methodToString(&quot;&lt;init&gt;&quot;, parameterTypes));
3493     }
3494 
3495     //
3496     // Other helpers and base implementation
3497     //
3498 
3499     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
3500         if (a1 == null) {
3501             return a2 == null || a2.length == 0;
3502         }
3503 
3504         if (a2 == null) {
3505             return a1.length == 0;
3506         }
3507 
3508         if (a1.length != a2.length) {
3509             return false;
3510         }
3511 
3512         for (int i = 0; i &lt; a1.length; i++) {
3513             if (a1[i] != a2[i]) {
3514                 return false;
3515             }
3516         }
3517 
3518         return true;
3519     }
3520 
3521     private static Field[] copyFields(Field[] arg) {
3522         Field[] out = new Field[arg.length];
3523         ReflectionFactory fact = getReflectionFactory();
3524         for (int i = 0; i &lt; arg.length; i++) {
3525             out[i] = fact.copyField(arg[i]);
3526         }
3527         return out;
3528     }
3529 
3530     private static Method[] copyMethods(Method[] arg) {
3531         Method[] out = new Method[arg.length];
3532         ReflectionFactory fact = getReflectionFactory();
3533         for (int i = 0; i &lt; arg.length; i++) {
3534             out[i] = fact.copyMethod(arg[i]);
3535         }
3536         return out;
3537     }
3538 
3539     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3540         Constructor&lt;U&gt;[] out = arg.clone();
3541         ReflectionFactory fact = getReflectionFactory();
3542         for (int i = 0; i &lt; out.length; i++) {
3543             out[i] = fact.copyConstructor(out[i]);
3544         }
3545         return out;
3546     }
3547 
3548     private native Field[]       getDeclaredFields0(boolean publicOnly);
3549     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3550     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3551     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3552     @SuppressWarnings(&quot;preview&quot;)
3553     private native RecordComponent[] getRecordComponents0();
3554     private native boolean      isRecord0();
3555 
3556     /**
3557      * Helper method to get the method name from arguments.
3558      */
3559     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3560         return getName() + &#39;.&#39; + name +
3561                 ((argTypes == null || argTypes.length == 0) ?
3562                 &quot;()&quot; :
3563                 Arrays.stream(argTypes)
3564                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())
3565                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3566     }
3567 
3568     /** use serialVersionUID from JDK 1.1 for interoperability */
3569     @java.io.Serial
3570     private static final long serialVersionUID = 3206093459760846163L;
3571 
3572 
3573     /**
3574      * Class Class is special cased within the Serialization Stream Protocol.
3575      *
3576      * A Class instance is written initially into an ObjectOutputStream in the
3577      * following format:
3578      * &lt;pre&gt;
3579      *      {@code TC_CLASS} ClassDescriptor
3580      *      A ClassDescriptor is a special cased serialization of
3581      *      a {@code java.io.ObjectStreamClass} instance.
3582      * &lt;/pre&gt;
3583      * A new handle is generated for the initial time the class descriptor
3584      * is written into the stream. Future references to the class descriptor
3585      * are written as references to the initial class descriptor instance.
3586      *
3587      * @see java.io.ObjectStreamClass
3588      */
3589     @java.io.Serial
3590     private static final ObjectStreamField[] serialPersistentFields =
3591         new ObjectStreamField[0];
3592 
3593 
3594     /**
3595      * Returns the assertion status that would be assigned to this
3596      * class if it were to be initialized at the time this method is invoked.
3597      * If this class has had its assertion status set, the most recent
3598      * setting will be returned; otherwise, if any package default assertion
3599      * status pertains to this class, the most recent setting for the most
3600      * specific pertinent package default assertion status is returned;
3601      * otherwise, if this class is not a system class (i.e., it has a
3602      * class loader) its class loader&#39;s default assertion status is returned;
3603      * otherwise, the system class default assertion status is returned.
3604      *
3605      * @apiNote
3606      * Few programmers will have any need for this method; it is provided
3607      * for the benefit of the JDK itself.  (It allows a class to determine at
3608      * the time that it is initialized whether assertions should be enabled.)
3609      * Note that this method is not guaranteed to return the actual
3610      * assertion status that was (or will be) associated with the specified
3611      * class when it was (or will be) initialized.
3612      *
3613      * @return the desired assertion status of the specified class.
3614      * @see    java.lang.ClassLoader#setClassAssertionStatus
3615      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3616      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3617      * @since  1.4
3618      */
3619     public boolean desiredAssertionStatus() {
3620         ClassLoader loader = getClassLoader0();
3621         // If the loader is null this is a system class, so ask the VM
3622         if (loader == null)
3623             return desiredAssertionStatus0(this);
3624 
3625         // If the classloader has been initialized with the assertion
3626         // directives, ask it. Otherwise, ask the VM.
3627         synchronized(loader.assertionLock) {
3628             if (loader.classAssertionStatus != null) {
3629                 return loader.desiredAssertionStatus(getName());
3630             }
3631         }
3632         return desiredAssertionStatus0(this);
3633     }
3634 
3635     // Retrieves the desired assertion status of this class from the VM
3636     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3637 
3638     /**
3639      * Returns true if and only if this class was declared as an enum in the
3640      * source code.
3641      *
3642      * Note that {@link java.lang.Enum} is not itself an enum type.
3643      *
3644      * Also note that if an enum constant is declared with a class body,
3645      * the class of that enum constant object is an anonymous class
3646      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The
3647      * {@link Enum#getDeclaringClass} method of an enum constant can
3648      * be used to get the class of the enum type declaring the
3649      * constant.
3650      *
3651      * @return true if and only if this class was declared as an enum in the
3652      *     source code
3653      * @since 1.5
3654      * @jls 8.9.1 Enum Constants
3655      */
3656     public boolean isEnum() {
3657         // An enum must both directly extend java.lang.Enum and have
3658         // the ENUM bit set; classes for specialized enum constants
3659         // don&#39;t do the former.
3660         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3661         this.getSuperclass() == java.lang.Enum.class;
3662     }
3663 
3664     /** java.lang.Record.class */
3665     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();
3666     private static Class&lt;?&gt; javaLangRecordClass() {
3667         try {
3668             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);
3669         } catch (ClassNotFoundException e) {
3670             throw new InternalError(&quot;should not reach here&quot;, e);
3671         }
3672     }
3673 
3674     /**
3675      * {@preview Associated with records, a preview feature of the Java language.
3676      *
3677      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
3678      *           feature of the Java language. Preview features
3679      *           may be removed in a future release, or upgraded to permanent
3680      *           features of the Java language.}
3681      *
3682      * Returns {@code true} if and only if this class is a record class.
3683      *
3684      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record
3685      * class is {@code java.lang.Record}. A record class has (possibly zero)
3686      * record components, that is, {@link #getRecordComponents()} returns a
3687      * non-null value.
3688      *
3689      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking
3690      * this method on class {@code Record} returns {@code false}.
3691      *
3692      * @return true if and only if this class is a record class, otherwise false
3693      * @jls 8.10 Record Types
3694      * @since 14
3695      */
3696     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
3697                                  essentialAPI=false)
3698     public boolean isRecord() {
3699         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3700     }
3701 
3702     // Fetches the factory for reflective objects
3703     private static ReflectionFactory getReflectionFactory() {
3704         if (reflectionFactory == null) {
3705             reflectionFactory =
3706                 java.security.AccessController.doPrivileged
3707                     (new ReflectionFactory.GetReflectionFactoryAction());
3708         }
3709         return reflectionFactory;
3710     }
3711     private static ReflectionFactory reflectionFactory;
3712 
3713     /**
3714      * Returns the elements of this enum class or null if this
3715      * Class object does not represent an enum type.
3716      *
3717      * @return an array containing the values comprising the enum class
3718      *     represented by this {@code Class} object in the order they&#39;re
3719      *     declared, or null if this {@code Class} object does not
3720      *     represent an enum type
3721      * @since 1.5
3722      */
3723     public T[] getEnumConstants() {
3724         T[] values = getEnumConstantsShared();
3725         return (values != null) ? values.clone() : null;
3726     }
3727 
3728     /**
3729      * Returns the elements of this enum class or null if this
3730      * Class object does not represent an enum type;
3731      * identical to getEnumConstants except that the result is
3732      * uncloned, cached, and shared by all callers.
3733      */
3734     T[] getEnumConstantsShared() {
3735         T[] constants = enumConstants;
3736         if (constants == null) {
3737             if (!isEnum()) return null;
3738             try {
3739                 final Method values = getMethod(&quot;values&quot;);
3740                 java.security.AccessController.doPrivileged(
3741                     new java.security.PrivilegedAction&lt;&gt;() {
3742                         public Void run() {
3743                                 values.setAccessible(true);
3744                                 return null;
3745                             }
3746                         });
3747                 @SuppressWarnings(&quot;unchecked&quot;)
3748                 T[] temporaryConstants = (T[])values.invoke(null);
3749                 enumConstants = constants = temporaryConstants;
3750             }
3751             // These can happen when users concoct enum-like classes
3752             // that don&#39;t comply with the enum spec.
3753             catch (InvocationTargetException | NoSuchMethodException |
3754                    IllegalAccessException ex) { return null; }
3755         }
3756         return constants;
3757     }
3758     private transient volatile T[] enumConstants;
3759 
3760     /**
3761      * Returns a map from simple name to enum constant.  This package-private
3762      * method is used internally by Enum to implement
3763      * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
3764      * efficiently.  Note that the map is returned by this method is
3765      * created lazily on first use.  Typically it won&#39;t ever get created.
3766      */
3767     Map&lt;String, T&gt; enumConstantDirectory() {
3768         Map&lt;String, T&gt; directory = enumConstantDirectory;
3769         if (directory == null) {
3770             T[] universe = getEnumConstantsShared();
3771             if (universe == null)
3772                 throw new IllegalArgumentException(
3773                     getName() + &quot; is not an enum type&quot;);
3774             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3775             for (T constant : universe) {
3776                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3777             }
3778             enumConstantDirectory = directory;
3779         }
3780         return directory;
3781     }
3782     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3783 
3784     /**
3785      * Casts an object to the class or interface represented
3786      * by this {@code Class} object.
3787      *
3788      * @param obj the object to be cast
3789      * @return the object after casting, or null if obj is null
3790      *
3791      * @throws ClassCastException if the object is not
3792      * {@code null} and is not assignable to the type T.
3793      * @throws NullPointerException if this is an {@linkplain #isInlineClass()
3794      * inline type} and the object is {@code null}
3795      *
3796      * @since 1.5
3797      */
3798     @SuppressWarnings(&quot;unchecked&quot;)
3799     @HotSpotIntrinsicCandidate
3800     public T cast(Object obj) {
3801         if (isInlineClass() &amp;&amp; obj == null)
3802             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3803 
3804         if (obj != null &amp;&amp; !isInstance(obj))
3805             throw new ClassCastException(cannotCastMsg(obj));
3806         return (T) obj;
3807     }
3808 
3809     private String cannotCastMsg(Object obj) {
3810         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3811     }
3812 
3813     /**
3814      * Casts this {@code Class} object to represent a subclass of the class
3815      * represented by the specified class object.  Checks that the cast
3816      * is valid, and throws a {@code ClassCastException} if it is not.  If
3817      * this method succeeds, it always returns a reference to this {@code Class} object.
3818      *
3819      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3820      * a {@code Class} object to pass it to an API that restricts the
3821      * {@code Class} objects that it is willing to accept.  A cast would
3822      * generate a compile-time warning, as the correctness of the cast
3823      * could not be checked at runtime (because generic types are implemented
3824      * by erasure).
3825      *
3826      * @param &lt;U&gt; the type to cast this {@code Class} object to
3827      * @param clazz the class of the type to cast this {@code Class} object to
3828      * @return this {@code Class} object, cast to represent a subclass of
3829      *    the specified class object.
3830      * @throws ClassCastException if this {@code Class} object does not
3831      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3832      *    the class itself).
3833      * @since 1.5
3834      */
3835     @SuppressWarnings(&quot;unchecked&quot;)
3836     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3837         if (clazz.isAssignableFrom(this))
3838             return (Class&lt;? extends U&gt;) this;
3839         else
3840             throw new ClassCastException(this.toString());
3841     }
3842 
3843     /**
3844      * {@inheritDoc}
3845      * &lt;p&gt;Note that any annotation returned by this method is a
3846      * declaration annotation.
3847      *
3848      * @throws NullPointerException {@inheritDoc}
3849      * @since 1.5
3850      */
3851     @Override
3852     @SuppressWarnings(&quot;unchecked&quot;)
3853     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3854         Objects.requireNonNull(annotationClass);
3855 
3856         return (A) annotationData().annotations.get(annotationClass);
3857     }
3858 
3859     /**
3860      * {@inheritDoc}
3861      * @throws NullPointerException {@inheritDoc}
3862      * @since 1.5
3863      */
3864     @Override
3865     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
3866         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
3867     }
3868 
3869     /**
3870      * {@inheritDoc}
3871      * &lt;p&gt;Note that any annotations returned by this method are
3872      * declaration annotations.
3873      *
3874      * @throws NullPointerException {@inheritDoc}
3875      * @since 1.8
3876      */
3877     @Override
3878     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
3879         Objects.requireNonNull(annotationClass);
3880 
3881         AnnotationData annotationData = annotationData();
3882         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
3883                                                           this,
3884                                                           annotationClass);
3885     }
3886 
3887     /**
3888      * {@inheritDoc}
3889      * &lt;p&gt;Note that any annotations returned by this method are
3890      * declaration annotations.
3891      *
3892      * @since 1.5
3893      */
3894     @Override
3895     public Annotation[] getAnnotations() {
3896         return AnnotationParser.toArray(annotationData().annotations);
3897     }
3898 
3899     /**
3900      * {@inheritDoc}
3901      * &lt;p&gt;Note that any annotation returned by this method is a
3902      * declaration annotation.
3903      *
3904      * @throws NullPointerException {@inheritDoc}
3905      * @since 1.8
3906      */
3907     @Override
3908     @SuppressWarnings(&quot;unchecked&quot;)
3909     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
3910         Objects.requireNonNull(annotationClass);
3911 
3912         return (A) annotationData().declaredAnnotations.get(annotationClass);
3913     }
3914 
3915     /**
3916      * {@inheritDoc}
3917      * &lt;p&gt;Note that any annotations returned by this method are
3918      * declaration annotations.
3919      *
3920      * @throws NullPointerException {@inheritDoc}
3921      * @since 1.8
3922      */
3923     @Override
3924     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
3925         Objects.requireNonNull(annotationClass);
3926 
3927         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
3928                                                                  annotationClass);
3929     }
3930 
3931     /**
3932      * {@inheritDoc}
3933      * &lt;p&gt;Note that any annotations returned by this method are
3934      * declaration annotations.
3935      *
3936      * @since 1.5
3937      */
3938     @Override
3939     public Annotation[] getDeclaredAnnotations()  {
3940         return AnnotationParser.toArray(annotationData().declaredAnnotations);
3941     }
3942 
3943     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
3944     private static class AnnotationData {
3945         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
3946         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
3947 
3948         // Value of classRedefinedCount when we created this AnnotationData instance
3949         final int redefinedCount;
3950 
3951         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
3952                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
3953                        int redefinedCount) {
3954             this.annotations = annotations;
3955             this.declaredAnnotations = declaredAnnotations;
3956             this.redefinedCount = redefinedCount;
3957         }
3958     }
3959 
3960     // Annotations cache
3961     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
3962     private transient volatile AnnotationData annotationData;
3963 
3964     private AnnotationData annotationData() {
3965         while (true) { // retry loop
3966             AnnotationData annotationData = this.annotationData;
3967             int classRedefinedCount = this.classRedefinedCount;
3968             if (annotationData != null &amp;&amp;
3969                 annotationData.redefinedCount == classRedefinedCount) {
3970                 return annotationData;
3971             }
3972             // null or stale annotationData -&gt; optimistically create new instance
3973             AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
3974             // try to install it
3975             if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {
3976                 // successfully installed new AnnotationData
3977                 return newAnnotationData;
3978             }
3979         }
3980     }
3981 
3982     private AnnotationData createAnnotationData(int classRedefinedCount) {
3983         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =
3984             AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);
3985         Class&lt;?&gt; superClass = getSuperclass();
3986         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;
3987         if (superClass != null) {
3988             Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =
3989                 superClass.annotationData().annotations;
3990             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {
3991                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
3992                 if (AnnotationType.getInstance(annotationClass).isInherited()) {
3993                     if (annotations == null) { // lazy construction
3994                         annotations = new LinkedHashMap&lt;&gt;((Math.max(
3995                                 declaredAnnotations.size(),
3996                                 Math.min(12, declaredAnnotations.size() + superAnnotations.size())
3997                             ) * 4 + 2) / 3
3998                         );
3999                     }
4000                     annotations.put(annotationClass, e.getValue());
4001                 }
4002             }
4003         }
4004         if (annotations == null) {
4005             // no inherited annotations -&gt; share the Map with declaredAnnotations
4006             annotations = declaredAnnotations;
4007         } else {
4008             // at least one inherited annotation -&gt; declared may override inherited
4009             annotations.putAll(declaredAnnotations);
4010         }
4011         return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
4012     }
4013 
4014     // Annotation types cache their internal (AnnotationType) form
4015 
4016     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4017     private transient volatile AnnotationType annotationType;
4018 
4019     boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
4020         return Atomic.casAnnotationType(this, oldType, newType);
4021     }
4022 
4023     AnnotationType getAnnotationType() {
4024         return annotationType;
4025     }
4026 
4027     Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
4028         return annotationData().declaredAnnotations;
4029     }
4030 
4031     /* Backing store of user-defined values pertaining to this class.
4032      * Maintained by the ClassValue class.
4033      */
4034     transient ClassValue.ClassValueMap classValueMap;
4035 
4036     /**
4037      * Returns an {@code AnnotatedType} object that represents the use of a
4038      * type to specify the superclass of the entity represented by this {@code
4039      * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
4040      * in &#39;...  extends Foo&#39; is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
4041      * Foo.)
4042      *
4043      * &lt;p&gt; If this {@code Class} object represents a type whose declaration
4044      * does not explicitly indicate an annotated superclass, then the return
4045      * value is an {@code AnnotatedType} object representing an element with no
4046      * annotations.
4047      *
4048      * &lt;p&gt; If this {@code Class} represents either the {@code Object} class, an
4049      * interface type, an array type, a primitive type, or void, the return
4050      * value is {@code null}.
4051      *
4052      * @return an object representing the superclass
4053      * @since 1.8
4054      */
4055     public AnnotatedType getAnnotatedSuperclass() {
4056         if (this == Object.class ||
4057                 isInterface() ||
4058                 isArray() ||
4059                 isPrimitive() ||
4060                 this == Void.TYPE) {
4061             return null;
4062         }
4063 
4064         return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);
4065     }
4066 
4067     /**
4068      * Returns an array of {@code AnnotatedType} objects that represent the use
4069      * of types to specify superinterfaces of the entity represented by this
4070      * {@code Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
4071      * superinterface in &#39;... implements Foo&#39; is distinct from the
4072      * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
4073      *
4074      * &lt;p&gt; If this {@code Class} object represents a class, the return value is
4075      * an array containing objects representing the uses of interface types to
4076      * specify interfaces implemented by the class. The order of the objects in
4077      * the array corresponds to the order of the interface types used in the
4078      * &#39;implements&#39; clause of the declaration of this {@code Class} object.
4079      *
4080      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4081      * value is an array containing objects representing the uses of interface
4082      * types to specify interfaces directly extended by the interface. The
4083      * order of the objects in the array corresponds to the order of the
4084      * interface types used in the &#39;extends&#39; clause of the declaration of this
4085      * {@code Class} object.
4086      *
4087      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4088      * declaration does not explicitly indicate any annotated superinterfaces,
4089      * the return value is an array of length 0.
4090      *
4091      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4092      * class, an array type, a primitive type, or void, the return value is an
4093      * array of length 0.
4094      *
4095      * @return an array representing the superinterfaces
4096      * @since 1.8
4097      */
4098     public AnnotatedType[] getAnnotatedInterfaces() {
4099         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
4100     }
4101 
4102     private native Class&lt;?&gt; getNestHost0();
4103 
4104     /**
4105      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4106      * or interface represented by this {@code Class} object belongs.
4107      * Every class and interface is a member of exactly one nest.
4108      * A class or interface that is not recorded as belonging to a nest
4109      * belongs to the nest consisting only of itself, and is the nest
4110      * host.
4111      *
4112      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4113      * primitive types, and {@code void} returns {@code this} to indicate
4114      * that the represented entity belongs to the nest consisting only of
4115      * itself, and is the nest host.
4116      *
4117      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing
4118      * the nest host, or if this class or interface is not enumerated as
4119      * a member of the nest by the nest host, then it is considered to belong
4120      * to its own nest and {@code this} is returned as the host.
4121      *
4122      * @apiNote A {@code class} file of version 55.0 or greater may record the
4123      * host of the nest to which it belongs by using the {@code NestHost}
4124      * attribute (JVMS {@jvms 4.7.28}). Alternatively, a {@code class} file of
4125      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
4126      * other members with the
4127      * {@code NestMembers} attribute (JVMS {@jvms 4.7.29}).
4128      * A {@code class} file of version 54.0 or lower does not use these
4129      * attributes.
4130      *
4131      * @return the nest host of this class or interface
4132      *
4133      * @throws SecurityException
4134      *         If the returned class is not the current class, and
4135      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4136      *         class loader is not the same as or an ancestor of the class
4137      *         loader for the returned class and invocation of {@link
4138      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4139      *         denies access to the package of the returned class
4140      * @since 11
4141      * @jvms 4.7.28 The {@code NestHost} Attribute
4142      * @jvms 4.7.29 The {@code NestMembers} Attribute
4143      * @jvms 5.4.4 Access Control
4144      */
4145     @CallerSensitive
4146     public Class&lt;?&gt; getNestHost() {
4147         if (isPrimitive() || isArray()) {
4148             return this;
4149         }
4150         Class&lt;?&gt; host;
4151         try {
4152             host = getNestHost0();
4153         } catch (LinkageError e) {
4154             // if we couldn&#39;t load our nest-host then we
4155             // act as-if we have no nest-host attribute
4156             return this;
4157         }
4158         // if null then nest membership validation failed, so we
4159         // act as-if we have no nest-host attribute
4160         if (host == null || host == this) {
4161             return this;
4162         }
4163         // returning a different class requires a security check
4164         SecurityManager sm = System.getSecurityManager();
4165         if (sm != null) {
4166             checkPackageAccess(sm,
4167                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4168         }
4169         return host;
4170     }
4171 
4172     /**
4173      * Determines if the given {@code Class} is a nestmate of the
4174      * class or interface represented by this {@code Class} object.
4175      * Two classes or interfaces are nestmates
4176      * if they have the same {@linkplain #getNestHost() nest host}.
4177      *
4178      * @param c the class to check
4179      * @return {@code true} if this class and {@code c} are members of
4180      * the same nest; and {@code false} otherwise.
4181      *
4182      * @since 11
4183      */
4184     public boolean isNestmateOf(Class&lt;?&gt; c) {
4185         if (this == c) {
4186             return true;
4187         }
4188         if (isPrimitive() || isArray() ||
4189             c.isPrimitive() || c.isArray()) {
4190             return false;
4191         }
4192         try {
4193             return getNestHost0() == c.getNestHost0();
4194         } catch (LinkageError e) {
4195             return false;
4196         }
4197     }
4198 
4199     private native Class&lt;?&gt;[] getNestMembers0();
4200 
4201     /**
4202      * Returns an array containing {@code Class} objects representing all the
4203      * classes and interfaces that are members of the nest to which the class
4204      * or interface represented by this {@code Class} object belongs.
4205      * The {@linkplain #getNestHost() nest host} of that nest is the zeroth
4206      * element of the array. Subsequent elements represent any classes or
4207      * interfaces that are recorded by the nest host as being members of
4208      * the nest; the order of such elements is unspecified. Duplicates are
4209      * permitted.
4210      * If the nest host of that nest does not enumerate any members, then the
4211      * array has a single element containing {@code this}.
4212      *
4213      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4214      * primitive types, and {@code void} returns an array containing only
4215      * {@code this}.
4216      *
4217      * &lt;p&gt;This method validates that, for each class or interface which is
4218      * recorded as a member of the nest by the nest host, that class or
4219      * interface records itself as a member of that same nest. Any exceptions
4220      * that occur during this validation are rethrown by this method.
4221      *
4222      * @return an array of all classes and interfaces in the same nest as
4223      * this class
4224      *
4225      * @throws LinkageError
4226      *         If there is any problem loading or validating a nest member or
4227      *         its nest host
4228      * @throws SecurityException
4229      *         If any returned class is not the current class, and
4230      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4231      *         class loader is not the same as or an ancestor of the class
4232      *         loader for that returned class and invocation of {@link
4233      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4234      *         denies access to the package of that returned class
4235      *
4236      * @since 11
4237      * @see #getNestHost()
4238      */
4239     @CallerSensitive
4240     public Class&lt;?&gt;[] getNestMembers() {
4241         if (isPrimitive() || isArray()) {
4242             return new Class&lt;?&gt;[] { this };
4243         }
4244         Class&lt;?&gt;[] members = getNestMembers0();
4245         // Can&#39;t actually enable this due to bootstrapping issues
4246         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4247 
4248         if (members.length &gt; 1) {
4249             // If we return anything other than the current class we need
4250             // a security check
4251             SecurityManager sm = System.getSecurityManager();
4252             if (sm != null) {
4253                 checkPackageAccess(sm,
4254                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4255             }
4256         }
4257         return members;
4258     }
4259 
4260     /**
4261      * Returns the type descriptor string for this class.
4262      * &lt;p&gt;
4263      * Note that this is not a strict inverse of {@link #forName};
4264      * distinct classes which share a common name but have different class loaders
4265      * will have identical descriptor strings.
4266      *
4267      * @return the type descriptor representation
4268      * @jvms 4.3.2 Field Descriptors
4269      * @since 12
4270      */
4271     @Override
4272     public String descriptorString() {
4273         if (isPrimitive())
4274             return Wrapper.forPrimitiveType(this).basicTypeString();
4275         else if (isArray()) {
4276             return &quot;[&quot; + componentType.descriptorString();
4277         }
4278         else {
4279             return (isInlineClass() ? &quot;Q&quot; : &quot;L&quot;)
4280                     + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;
4281         }
4282     }
4283 
4284     /**
4285      * Returns the component type of this {@code Class}, if it describes
4286      * an array type, or {@code null} otherwise.
4287      *
4288      * @implSpec
4289      * Equivalent to {@link Class#getComponentType()}.
4290      *
4291      * @return a {@code Class} describing the component type, or {@code null}
4292      * if this {@code Class} does not describe an array type
4293      * @since 12
4294      */
4295     @Override
4296     public Class&lt;?&gt; componentType() {
4297         return isArray() ? componentType : null;
4298     }
4299 
4300     /**
4301      * Returns a {@code Class} for an array type whose component type
4302      * is described by this {@linkplain Class}.
4303      *
4304      * @return a {@code Class} describing the array type
4305      * @since 12
4306      */
4307     @Override
4308     public Class&lt;?&gt; arrayType() {
4309         return Array.newInstance(this, 0).getClass();
4310     }
4311 
4312     /**
4313      * Returns a nominal descriptor for this instance, if one can be
4314      * constructed, or an empty {@link Optional} if one cannot be.
4315      *
4316      * @return An {@link Optional} containing the resulting nominal descriptor,
4317      * or an empty {@link Optional} if one cannot be constructed.
4318      * @since 12
4319      */
4320     @Override
4321     public Optional&lt;ClassDesc&gt; describeConstable() {
4322         return Optional.of(ClassDesc.ofDescriptor(descriptorString()));
4323     }
4324 }
    </pre>
  </body>
</html>
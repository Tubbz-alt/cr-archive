<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
  31 import java.lang.module.ModuleReader;
  32 import java.lang.ref.SoftReference;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.ObjectStreamField;
  36 import java.lang.reflect.AnnotatedElement;
  37 import java.lang.reflect.AnnotatedType;
  38 import java.lang.reflect.Array;
  39 import java.lang.reflect.Constructor;
  40 import java.lang.reflect.Executable;
  41 import java.lang.reflect.Field;
  42 import java.lang.reflect.GenericArrayType;
  43 import java.lang.reflect.GenericDeclaration;
  44 import java.lang.reflect.InvocationTargetException;
  45 import java.lang.reflect.Member;
  46 import java.lang.reflect.Method;
  47 import java.lang.reflect.Modifier;
  48 import java.lang.reflect.Proxy;
  49 import java.lang.reflect.RecordComponent;
  50 import java.lang.reflect.Type;
  51 import java.lang.reflect.TypeVariable;
  52 import java.lang.constant.Constable;
  53 import java.net.URL;
  54 import java.security.AccessController;
  55 import java.security.PrivilegedAction;
  56 import java.util.ArrayList;
  57 import java.util.Arrays;
  58 import java.util.Collection;
  59 import java.util.HashMap;
  60 import java.util.LinkedHashMap;
  61 import java.util.LinkedHashSet;
  62 import java.util.List;
  63 import java.util.Map;
  64 import java.util.Objects;
  65 import java.util.Optional;
  66 import java.util.stream.Collectors;
  67 
  68 import jdk.internal.HotSpotIntrinsicCandidate;
  69 import jdk.internal.loader.BootLoader;
  70 import jdk.internal.loader.BuiltinClassLoader;
  71 import jdk.internal.misc.Unsafe;
  72 import jdk.internal.module.Resources;
  73 import jdk.internal.reflect.CallerSensitive;
  74 import jdk.internal.reflect.ConstantPool;
  75 import jdk.internal.reflect.Reflection;
  76 import jdk.internal.reflect.ReflectionFactory;
  77 import jdk.internal.vm.annotation.ForceInline;
  78 import sun.invoke.util.Wrapper;
  79 import sun.reflect.generics.factory.CoreReflectionFactory;
  80 import sun.reflect.generics.factory.GenericsFactory;
  81 import sun.reflect.generics.repository.ClassRepository;
  82 import sun.reflect.generics.repository.MethodRepository;
  83 import sun.reflect.generics.repository.ConstructorRepository;
  84 import sun.reflect.generics.scope.ClassScope;
  85 import sun.security.util.SecurityConstants;
  86 import sun.reflect.annotation.*;
  87 import sun.reflect.misc.ReflectUtil;
  88 
  89 /**
  90  * Instances of the class {@code Class} represent classes and
  91  * interfaces in a running Java application. An enum type and a record
  92  * type are kinds of class; an annotation type is a kind of
  93  * interface. Every array also belongs to a class that is reflected as
  94  * a {@code Class} object that is shared by all arrays with the same
  95  * element type and number of dimensions.  The primitive Java types
  96  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  97  * int}, {@code long}, {@code float}, and {@code double}), and the
  98  * keyword {@code void} are also represented as {@code Class} objects.
  99  *
 100  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
 101  * object is constructed automatically by the Java Virtual Machine
 102  * when a class loader invokes one of the
 103  * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
 104  * and passes the bytes of a {@code class} file.
 105  *
 106  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 107  * class or interface. Most characteristics are derived from the {@code class}
 108  * file that the class loader passed to the Java Virtual Machine. A few
 109  * characteristics are determined by the class loading environment at run time,
 110  * such as the module returned by {@link #getModule() getModule()}.
 111  *
 112  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 113  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 114  * another declaration. Other methods describe how a class or interface
 115  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 116  * classes and interfaces, in the same run-time package, that
 117  * allow mutual access to their {@code private} members.
 118  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 119  * One nestmate acts as the
 120  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 121  * belong to the nest; each of them in turn records it as the nest host.
 122  * The classes and interfaces which belong to a nest, including its host, are
 123  * determined when
 124  * {@code class} files are generated, for example, a Java compiler
 125  * will typically record a top-level class as the host of a nest where the
 126  * other members are the classes and interfaces whose declarations are
 127  * enclosed within the top-level class declaration.
 128  *
 129  * &lt;p&gt; The following example uses a {@code Class} object to print the
 130  * class name of an object:
 131  *
 132  * &lt;blockquote&gt;&lt;pre&gt;
 133  *     void printClassName(Object obj) {
 134  *         System.out.println(&quot;The class of &quot; + obj +
 135  *                            &quot; is &quot; + obj.getClass().getName());
 136  *     }
 137  * &lt;/pre&gt;&lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
 140  * type (or for void) using a class literal.  See Section {@jls
 141  * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 142  * For example:
 143  *
 144  * &lt;blockquote&gt;
 145  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
<a name="1" id="anc1"></a><span class="line-modified"> 166     private static final int VALUE_TYPE = 0x00000100;</span>
 167 
 168     private static native void registerNatives();
 169     static {
 170         registerNatives();
 171     }
 172 
 173     /*
 174      * Private constructor. Only the Java Virtual Machine creates Class objects.
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
 195      * @return a string representation of this {@code Class} object.
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
<a name="2" id="anc2"></a><span class="line-modified"> 200                + getName() + (isInlineClass() &amp;&amp; isIndirectType() ? &quot;?&quot; : &quot;&quot;);</span>
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * {@code @interface}, or {@code record} as appropriate), followed
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
 221      * followed by an angle-bracketed comma-separated list of the
 222      * type&#39;s type parameters, if any, followed by a sequence of
 223      * {@code []} characters, one set of brackets per dimension of
 224      * the array.
 225      *
 226      * &lt;p&gt;Note that since information about the runtime representation
 227      * of a type is being generated, modifiers not present on the
 228      * originating source code or illegal on the originating source
 229      * code may be present.
 230      *
 231      * @return a string describing this {@code Class}, including
 232      * information about modifiers and type parameters
 233      *
 234      * @since 1.8
 235      */
 236     @SuppressWarnings(&quot;preview&quot;)
 237     public String toGenericString() {
 238         if (isPrimitive()) {
 239             return toString();
 240         } else {
 241             StringBuilder sb = new StringBuilder();
 242             Class&lt;?&gt; component = this;
 243             int arrayDepth = 0;
 244 
 245             if (isArray()) {
 246                 do {
 247                     arrayDepth++;
 248                     component = component.getComponentType();
 249                 } while (component.isArray());
 250                 sb.append(component.getName());
 251             } else {
 252                 // Class modifiers are a superset of interface modifiers
 253                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 254                 if (modifiers != 0) {
 255                     sb.append(Modifier.toString(modifiers));
 256                     sb.append(&#39; &#39;);
 257                 }
 258 
 259                 if (isAnnotation()) {
 260                     sb.append(&#39;@&#39;);
 261                 }
 262                 if (isInlineClass()) {
 263                     sb.append(&quot;inline&quot;);
 264                     sb.append(&#39; &#39;);
 265                 }
 266                 if (isInterface()) { // Note: all annotation types are interfaces
 267                     sb.append(&quot;interface&quot;);
 268                 } else {
 269                     if (isEnum())
 270                         sb.append(&quot;enum&quot;);
 271                     else if (isRecord())
 272                         sb.append(&quot;record&quot;);
 273                     else
 274                         sb.append(&quot;class&quot;);
 275                 }
 276                 sb.append(&#39; &#39;);
 277                 sb.append(getName());
 278             }
 279 
 280             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 281             if (typeparms.length &gt; 0) {
 282                 sb.append(Arrays.stream(typeparms)
 283                           .map(Class::typeVarBounds)
 284                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 285             }
 286 
 287             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));
 288 
 289             return sb.toString();
 290         }
 291     }
 292 
 293     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 294         Type[] bounds = typeVar.getBounds();
 295         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 296             return typeVar.getName();
 297         } else {
 298             return typeVar.getName() + &quot; extends &quot; +
 299                 Arrays.stream(bounds)
 300                 .map(Type::getTypeName)
 301                 .collect(Collectors.joining(&quot; &amp; &quot;));
 302         }
 303     }
 304 
 305     /**
 306      * Returns the {@code Class} object associated with the class or
 307      * interface with the given string name.  Invoking this method is
 308      * equivalent to:
 309      *
 310      * &lt;blockquote&gt;
 311      *  {@code Class.forName(className, true, currentLoader)}
 312      * &lt;/blockquote&gt;
 313      *
 314      * where {@code currentLoader} denotes the defining class loader of
 315      * the current class.
 316      *
 317      * &lt;p&gt; For example, the following code fragment returns the
 318      * runtime {@code Class} descriptor for the class named
 319      * {@code java.lang.Thread}:
 320      *
 321      * &lt;blockquote&gt;
 322      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 323      * &lt;/blockquote&gt;
 324      * &lt;p&gt;
 325      * A call to {@code forName(&quot;X&quot;)} causes the class named
 326      * {@code X} to be initialized.
 327      *
 328      * @param      className   the fully qualified name of the desired class.
 329      * @return     the {@code Class} object for the class with the
 330      *             specified name.
 331      * @throws    LinkageError if the linkage fails
 332      * @throws    ExceptionInInitializerError if the initialization provoked
 333      *            by this method fails
 334      * @throws    ClassNotFoundException if the class cannot be located
 335      *
 336      * @jls 12.2 Loading of Classes and Interfaces
 337      * @jls 12.3 Linking of Classes and Interfaces
 338      * @jls 12.4 Initialization of Classes and Interfaces
 339      */
 340     @CallerSensitive
 341     public static Class&lt;?&gt; forName(String className)
 342                 throws ClassNotFoundException {
 343         Class&lt;?&gt; caller = Reflection.getCallerClass();
 344         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 345     }
 346 
 347 
 348     /**
 349      * Returns the {@code Class} object associated with the class or
 350      * interface with the given string name, using the given class loader.
 351      * Given the fully qualified name for a class or interface (in the same
 352      * format returned by {@code getName}) this method attempts to
 353      * locate and load the class or interface.  The specified class
 354      * loader is used to load the class or interface.  If the parameter
 355      * {@code loader} is null, the class is loaded through the bootstrap
 356      * class loader.  The class is initialized only if the
 357      * {@code initialize} parameter is {@code true} and if it has
 358      * not been initialized earlier.
 359      *
 360      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 361      * will be made to locate a user-defined class in the unnamed package whose
 362      * name is {@code name}. Therefore, this method cannot be used to
 363      * obtain any of the {@code Class} objects representing primitive
 364      * types or void.
 365      *
 366      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 367      * the array class is loaded but not initialized.
 368      *
 369      * &lt;p&gt; For example, in an instance method the expression:
 370      *
 371      * &lt;blockquote&gt;
 372      *  {@code Class.forName(&quot;Foo&quot;)}
 373      * &lt;/blockquote&gt;
 374      *
 375      * is equivalent to:
 376      *
 377      * &lt;blockquote&gt;
 378      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 379      * &lt;/blockquote&gt;
 380      *
 381      * Note that this method throws errors related to loading, linking
 382      * or initializing as specified in Sections {@jls 12.2}, {@jls
 383      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language
 384      * Specification&lt;/cite&gt;.
 385      * Note that this method does not check whether the requested class
 386      * is accessible to its caller.
 387      *
 388      * @param name       fully qualified name of the desired class
 389 
 390      * @param initialize if {@code true} the class will be initialized
 391      *                   (which implies linking). See Section {@jls
 392      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language
 393      *                   Specification&lt;/cite&gt;.
 394      * @param loader     class loader from which the class must be loaded
 395      * @return           class object representing the desired class
 396      *
 397      * @throws    LinkageError if the linkage fails
 398      * @throws    ExceptionInInitializerError if the initialization provoked
 399      *            by this method fails
 400      * @throws    ClassNotFoundException if the class cannot be located by
 401      *            the specified class loader
 402      * @throws    SecurityException
 403      *            if a security manager is present, and the {@code loader} is
 404      *            {@code null}, and the caller&#39;s class loader is not
 405      *            {@code null}, and the caller does not have the
 406      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 407      *
 408      * @see       java.lang.Class#forName(String)
 409      * @see       java.lang.ClassLoader
 410      *
 411      * @jls 12.2 Loading of Classes and Interfaces
 412      * @jls 12.3 Linking of Classes and Interfaces
 413      * @jls 12.4 Initialization of Classes and Interfaces
 414      * @since     1.2
 415      */
 416     @CallerSensitive
 417     public static Class&lt;?&gt; forName(String name, boolean initialize,
 418                                    ClassLoader loader)
 419         throws ClassNotFoundException
 420     {
 421         Class&lt;?&gt; caller = null;
 422         SecurityManager sm = System.getSecurityManager();
 423         if (sm != null) {
 424             // Reflective call to get caller class is only needed if a security manager
 425             // is present.  Avoid the overhead of making this call otherwise.
 426             caller = Reflection.getCallerClass();
 427             if (loader == null) {
 428                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 429                 if (ccl != null) {
 430                     sm.checkPermission(
 431                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 432                 }
 433             }
 434         }
 435         return forName0(name, initialize, loader, caller);
 436     }
 437 
 438     /** Called after security check for system loader access checks have been made. */
 439     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 440                                     ClassLoader loader,
 441                                     Class&lt;?&gt; caller)
 442         throws ClassNotFoundException;
 443 
 444 
 445     /**
 446      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 447      * binary name&lt;/a&gt; in the given module.
 448      *
 449      * &lt;p&gt; This method attempts to locate and load the class or interface.
 450      * It does not link the class, and does not run the class initializer.
 451      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 452      *
 453      * &lt;p&gt; If the class loader of the given module defines other modules and
 454      * the given name is a class defined in a different module, this method
 455      * returns {@code null} after the class is loaded. &lt;/p&gt;
 456      *
 457      * &lt;p&gt; This method does not check whether the requested class is
 458      * accessible to its caller. &lt;/p&gt;
 459      *
 460      * @apiNote
 461      * This method returns {@code null} on failure rather than
 462      * throwing a {@link ClassNotFoundException}, as is done by
 463      * the {@link #forName(String, boolean, ClassLoader)} method.
 464      * The security check is a stack-based permission check if the caller
 465      * loads a class in another module.
 466      *
 467      * @param  module   A module
 468      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 469      *                  of the class
 470      * @return {@code Class} object of the given name defined in the given module;
 471      *         {@code null} if not found.
 472      *
 473      * @throws NullPointerException if the given module or name is {@code null}
 474      *
 475      * @throws LinkageError if the linkage fails
 476      *
 477      * @throws SecurityException
 478      *         &lt;ul&gt;
 479      *         &lt;li&gt; if the caller is not the specified module and
 480      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 481      *         &lt;li&gt; access to the module content is denied. For example,
 482      *         permission check will be performed when a class loader calls
 483      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 484      *         in a module.&lt;/li&gt;
 485      *         &lt;/ul&gt;
 486      *
 487      * @jls 12.2 Loading of Classes and Interfaces
 488      * @jls 12.3 Linking of Classes and Interfaces
 489      * @since 9
 490      * @spec JPMS
 491      */
 492     @CallerSensitive
 493     public static Class&lt;?&gt; forName(Module module, String name) {
 494         Objects.requireNonNull(module);
 495         Objects.requireNonNull(name);
 496 
 497         ClassLoader cl;
 498         SecurityManager sm = System.getSecurityManager();
 499         if (sm != null) {
 500             Class&lt;?&gt; caller = Reflection.getCallerClass();
 501             if (caller != null &amp;&amp; caller.getModule() != module) {
 502                 // if caller is null, Class.forName is the last java frame on the stack.
 503                 // java.base has all permissions
 504                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 505             }
 506             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 507             cl = AccessController.doPrivileged(pa);
 508         } else {
 509             cl = module.getClassLoader();
 510         }
 511 
 512         if (cl != null) {
 513             return cl.loadClass(module, name);
 514         } else {
 515             return BootLoader.loadClass(module, name);
 516         }
 517     }
 518 
 519     /**
 520      * Returns {@code true} if this class is an inline class.
 521      *
<a name="3" id="anc3"></a><span class="line-modified"> 522      * @return {@code true} if this class is an inline class.</span>

 523      */
 524     public boolean isInlineClass() {
<a name="4" id="anc4"></a><span class="line-modified"> 525         return (this.getModifiers() &amp; VALUE_TYPE) != 0;</span>
 526     }
 527 
 528     /**
<a name="5" id="anc5"></a><span class="line-modified"> 529      * Returns a {@code Class} object representing the primary type of</span>
<span class="line-modified"> 530      * this class.</span>
<span class="line-modified"> 531      *</span>
<span class="line-modified"> 532      * &lt;p&gt; For class {@code C}, {@code C.class} is the primary type of {@code C}.</span>
<span class="line-modified"> 533      * For a primitive type, the {@code Class} instance representing</span>
<span class="line-modified"> 534      * that primitive type is its primary type, for example {@code int.class}.</span>
<span class="line-modified"> 535      *</span>
<span class="line-modified"> 536      * @return the {@code Class} object representing the primary type of</span>
<span class="line-modified"> 537      *         this class</span>
 538      */
<a name="6" id="anc6"></a><span class="line-modified"> 539     public Class&lt;T&gt; asPrimaryType() {</span>
<span class="line-modified"> 540         return isInlineClass() ? inlineType : this;</span>
 541     }
 542 
 543     /**
<a name="7" id="anc7"></a><span class="line-modified"> 544      * Returns a {@code Class} object representing the &lt;em&gt;indirect projection&lt;/em&gt;</span>
<span class="line-modified"> 545      * type if this class is an {@linkplain #isInlineClass() inline class};</span>
<span class="line-modified"> 546      * otherwise, returns this class.</span>
<span class="line-modified"> 547      *</span>
<span class="line-modified"> 548      * &lt;p&gt; An inline class, {@code V}, has two {@code Class} representations,</span>
<span class="line-modified"> 549      * {@code V.class} and its {@linkplain #asIndirectType() indirect projection</span>
<span class="line-modified"> 550      * type}.  The indirect projection type is always</span>
<span class="line-modified"> 551      * {@linkplain #isNullableType() nullable}.</span>
<span class="line-modified"> 552      * The indirect projection type of a zero-default inline class</span>
<span class="line-modified"> 553      * is also its nullable projection type.</span>
<span class="line-modified"> 554      *</span>
<span class="line-removed"> 555      * @return the {@code Class} object representing the indirect projection type of</span>
<span class="line-removed"> 556      *         this class if this class is an inline class; otherwise, this class.</span>
 557      */
<a name="8" id="anc8"></a><span class="line-modified"> 558     public Class&lt;T&gt; asIndirectType() {</span>
<span class="line-modified"> 559         return isInlineClass() ? indirectType : this;</span>
<span class="line-removed"> 560     }</span>
<span class="line-removed"> 561 </span>
<span class="line-removed"> 562     /**</span>
<span class="line-removed"> 563      * Returns a {@code Class} object representing the &lt;em&gt;nullable projection&lt;/em&gt;</span>
<span class="line-removed"> 564      * type if this class is an {@linkplain #isInlineClass() inline class};</span>
<span class="line-removed"> 565      * otherwise, returns this class.</span>
<span class="line-removed"> 566      *</span>
<span class="line-removed"> 567      * &lt;p&gt; An inline class, {@code V}, has two {@code Class} representations,</span>
<span class="line-removed"> 568      * {@code V.class} and its {@linkplain #asIndirectType() indirect projection</span>
<span class="line-removed"> 569      * type}.  The indirect projection type is always</span>
<span class="line-removed"> 570      * {@linkplain #isNullableType() nullable}.</span>
<span class="line-removed"> 571      * The indirect projection type of a zero-default inline class</span>
<span class="line-removed"> 572      * is also its nullable projection type.</span>
<span class="line-removed"> 573      *</span>
<span class="line-removed"> 574      * @return the {@code Class} object representing the nullable projection type of</span>
<span class="line-removed"> 575      *         this class if this class is an inline class; otherwise, this class.</span>
<span class="line-removed"> 576      */</span>
<span class="line-removed"> 577     public Class&lt;T&gt; asNullableType() {</span>
<span class="line-removed"> 578         return asIndirectType();</span>
<span class="line-removed"> 579     }</span>
<span class="line-removed"> 580 </span>
<span class="line-removed"> 581     /**</span>
<span class="line-removed"> 582      * Returns {@code true} if this class is an indirect type.</span>
<span class="line-removed"> 583      * An indirect type is always {@linkplain #isNullableType() nullable}.</span>
<span class="line-removed"> 584      *</span>
<span class="line-removed"> 585      * @return {@code true} if this class is an indirect type.</span>
<span class="line-removed"> 586      */</span>
<span class="line-removed"> 587     public boolean isIndirectType() {</span>
<span class="line-removed"> 588         return indirectType == null || this == indirectType;</span>
<span class="line-removed"> 589     }</span>
<span class="line-removed"> 590 </span>
<span class="line-removed"> 591     /**</span>
<span class="line-removed"> 592      * Returns {@code true} if this class is a nullable type.</span>
<span class="line-removed"> 593      *</span>
<span class="line-removed"> 594      * @return {@code true} if this class is a nullable type.</span>
<span class="line-removed"> 595      */</span>
<span class="line-removed"> 596     public boolean isNullableType() {</span>
<span class="line-removed"> 597         return isIndirectType();</span>
 598     }
 599 
 600     // set by VM if this class is an inline type
 601     // otherwise, these two fields are null
<a name="9" id="anc9"></a><span class="line-modified"> 602     private transient Class&lt;T&gt; inlineType;</span>
<span class="line-modified"> 603     private transient Class&lt;T&gt; indirectType;</span>
 604 
 605     /**
 606      * Creates a new instance of the class represented by this {@code Class}
 607      * object.  The class is instantiated as if by a {@code new}
 608      * expression with an empty argument list.  The class is initialized if it
 609      * has not already been initialized.
 610      *
 611      * @deprecated This method propagates any exception thrown by the
 612      * nullary constructor, including a checked exception.  Use of
 613      * this method effectively bypasses the compile-time exception
 614      * checking that would otherwise be performed by the compiler.
 615      * The {@link
 616      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 617      * Constructor.newInstance} method avoids this problem by wrapping
 618      * any exception thrown by the constructor in a (checked) {@link
 619      * java.lang.reflect.InvocationTargetException}.
 620      *
 621      * &lt;p&gt;The call
 622      *
 623      * &lt;pre&gt;{@code
 624      * clazz.newInstance()
 625      * }&lt;/pre&gt;
 626      *
 627      * can be replaced by
 628      *
 629      * &lt;pre&gt;{@code
 630      * clazz.getDeclaredConstructor().newInstance()
 631      * }&lt;/pre&gt;
 632      *
 633      * The latter sequence of calls is inferred to be able to throw
 634      * the additional exception types {@link
 635      * InvocationTargetException} and {@link
 636      * NoSuchMethodException}. Both of these exception types are
 637      * subclasses of {@link ReflectiveOperationException}.
 638      *
 639      * @return  a newly allocated instance of the class represented by this
 640      *          object.
 641      * @throws  IllegalAccessException  if the class or its nullary
 642      *          constructor is not accessible.
 643      * @throws  InstantiationException
 644      *          if this {@code Class} represents an abstract class,
 645      *          an interface, an array class, a primitive type, or void;
 646      *          or if the class has no nullary constructor;
 647      *          or if the instantiation fails for some other reason.
 648      * @throws  ExceptionInInitializerError if the initialization
 649      *          provoked by this method fails.
 650      * @throws  SecurityException
 651      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
 652      *          the caller&#39;s class loader is not the same as or an
 653      *          ancestor of the class loader for the current class and
 654      *          invocation of {@link SecurityManager#checkPackageAccess
 655      *          s.checkPackageAccess()} denies access to the package
 656      *          of this class.
 657      */
 658     @CallerSensitive
 659     @Deprecated(since=&quot;9&quot;)
 660     public T newInstance()
 661         throws InstantiationException, IllegalAccessException
 662     {
 663         SecurityManager sm = System.getSecurityManager();
 664         if (sm != null) {
 665             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
 666         }
 667 
 668         // Constructor lookup
 669         Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
 670         if (tmpConstructor == null) {
 671             if (this == Class.class) {
 672                 throw new IllegalAccessException(
 673                     &quot;Can not call newInstance() on the Class for java.lang.Class&quot;
 674                 );
 675             }
 676             try {
 677                 Class&lt;?&gt;[] empty = {};
 678                 final Constructor&lt;T&gt; c = getReflectionFactory().copyConstructor(
 679                     getConstructor0(empty, Member.DECLARED));
 680                 // Disable accessibility checks on the constructor
 681                 // access check is done with the true caller
 682                 java.security.AccessController.doPrivileged(
 683                     new java.security.PrivilegedAction&lt;&gt;() {
 684                         public Void run() {
 685                                 c.setAccessible(true);
 686                                 return null;
 687                             }
 688                         });
 689                 cachedConstructor = tmpConstructor = c;
 690             } catch (NoSuchMethodException e) {
 691                 throw (InstantiationException)
 692                     new InstantiationException(getName()).initCause(e);
 693             }
 694         }
 695 
 696         try {
 697             Class&lt;?&gt; caller = Reflection.getCallerClass();
 698             return getReflectionFactory().newInstance(tmpConstructor, null, caller);
 699         } catch (InvocationTargetException e) {
 700             Unsafe.getUnsafe().throwException(e.getTargetException());
 701             // Not reached
 702             return null;
 703         }
 704     }
 705 
 706     private transient volatile Constructor&lt;T&gt; cachedConstructor;
 707 
 708     /**
 709      * Determines if the specified {@code Object} is assignment-compatible
 710      * with the object represented by this {@code Class}.  This method is
 711      * the dynamic equivalent of the Java language {@code instanceof}
 712      * operator. The method returns {@code true} if the specified
 713      * {@code Object} argument is non-null and can be cast to the
 714      * reference type represented by this {@code Class} object without
 715      * raising a {@code ClassCastException.} It returns {@code false}
 716      * otherwise.
 717      *
 718      * &lt;p&gt; Specifically, if this {@code Class} object represents a
 719      * declared class, this method returns {@code true} if the specified
 720      * {@code Object} argument is an instance of the represented class (or
 721      * of any of its subclasses); it returns {@code false} otherwise. If
 722      * this {@code Class} object represents an array class, this method
 723      * returns {@code true} if the specified {@code Object} argument
 724      * can be converted to an object of the array class by an identity
 725      * conversion or by a widening reference conversion; it returns
 726      * {@code false} otherwise. If this {@code Class} object
 727      * represents an interface, this method returns {@code true} if the
 728      * class or any superclass of the specified {@code Object} argument
 729      * implements this interface; it returns {@code false} otherwise. If
 730      * this {@code Class} object represents a primitive type, this method
 731      * returns {@code false}.
 732      *
 733      * @param   obj the object to check
 734      * @return  true if {@code obj} is an instance of this class
 735      *
 736      * @since 1.1
 737      */
 738     @HotSpotIntrinsicCandidate
 739     public native boolean isInstance(Object obj);
 740 
 741 
 742     /**
 743      * Determines if the class or interface represented by this
 744      * {@code Class} object is either the same as, or is a superclass or
 745      * superinterface of, the class or interface represented by the specified
 746      * {@code Class} parameter. It returns {@code true} if so;
 747      * otherwise it returns {@code false}. If this {@code Class}
 748      * object represents a primitive type, this method returns
 749      * {@code true} if the specified {@code Class} parameter is
 750      * exactly this {@code Class} object; otherwise it returns
 751      * {@code false}.
 752      *
 753      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 754      * specified {@code Class} parameter can be converted to the type
 755      * represented by this {@code Class} object via an identity conversion
 756      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language
 757      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},
 758      * for details.
 759      *
 760      * @param     cls the {@code Class} object to be checked
 761      * @return    the {@code boolean} value indicating whether objects of the
 762      *            type {@code cls} can be assigned to objects of this class
 763      * @throws    NullPointerException if the specified Class parameter is
 764      *            null.
 765      * @since     1.1
 766      */
 767     @HotSpotIntrinsicCandidate
 768     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 769 
 770 
 771     /**
 772      * Determines if this {@code Class} object represents an
 773      * interface type.
 774      *
 775      * @return  {@code true} if this {@code Class} object represents an interface;
 776      *          {@code false} otherwise.
 777      */
 778     @HotSpotIntrinsicCandidate
 779     public native boolean isInterface();
 780 
 781 
 782     /**
 783      * Determines if this {@code Class} object represents an array class.
 784      *
 785      * @return  {@code true} if this {@code Class} object represents an array class;
 786      *          {@code false} otherwise.
 787      * @since   1.1
 788      */
 789     @HotSpotIntrinsicCandidate
 790     public native boolean isArray();
 791 
 792 
 793     /**
 794      * Determines if the specified {@code Class} object represents a
 795      * primitive type.
 796      *
 797      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 798      * the eight primitive types and void.  These are created by the Java
 799      * Virtual Machine, and have the same names as the primitive types that
 800      * they represent, namely {@code boolean}, {@code byte},
 801      * {@code char}, {@code short}, {@code int},
 802      * {@code long}, {@code float}, and {@code double}.
 803      *
 804      * &lt;p&gt; These objects may only be accessed via the following public static
 805      * final variables, and are the only {@code Class} objects for which
 806      * this method returns {@code true}.
 807      *
 808      * @return true if and only if this class represents a primitive type
 809      *
 810      * @see     java.lang.Boolean#TYPE
 811      * @see     java.lang.Character#TYPE
 812      * @see     java.lang.Byte#TYPE
 813      * @see     java.lang.Short#TYPE
 814      * @see     java.lang.Integer#TYPE
 815      * @see     java.lang.Long#TYPE
 816      * @see     java.lang.Float#TYPE
 817      * @see     java.lang.Double#TYPE
 818      * @see     java.lang.Void#TYPE
 819      * @since 1.1
 820      */
 821     @HotSpotIntrinsicCandidate
 822     public native boolean isPrimitive();
 823 
 824     /**
 825      * Returns true if this {@code Class} object represents an annotation
 826      * type.  Note that if this method returns true, {@link #isInterface()}
 827      * would also return true, as all annotation types are also interfaces.
 828      *
 829      * @return {@code true} if this {@code Class} object represents an annotation
 830      *      type; {@code false} otherwise
 831      * @since 1.5
 832      */
 833     public boolean isAnnotation() {
 834         return (getModifiers() &amp; ANNOTATION) != 0;
 835     }
 836 
 837     /**
 838      * Returns {@code true} if this class is a synthetic class;
 839      * returns {@code false} otherwise.
 840      * @return {@code true} if and only if this class is a synthetic class as
 841      *         defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 842      * @jls 13.1 The Form of a Binary
 843      * @since 1.5
 844      */
 845     public boolean isSynthetic() {
 846         return (getModifiers() &amp; SYNTHETIC) != 0;
 847     }
 848 
 849     /**
 850      * Returns the  name of the entity (class, interface, array class,
 851      * primitive type, or void) represented by this {@code Class} object,
 852      * as a {@code String}.
 853      *
 854      * &lt;p&gt; If this {@code Class} object represents a reference type that is
 855      * not an array type then the binary name of the class is
 856      * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language
 857      * Specification&lt;/cite&gt;.
 858      *
 859      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the
 860      * name returned is a {@code String} equal to the Java language
 861      * keyword corresponding to the primitive type or void.
 862      *
 863      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal
 864      * form of the name consists of the name of the element type preceded by
 865      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 866      * nesting.  The encoding of element type names is as follows:
 867      *
 868      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 869      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 870      * &lt;thead&gt;
 871      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 872      * &lt;/thead&gt;
 873      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 874      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 875      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 876      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 877      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 878      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
<a name="10" id="anc10"></a><span class="line-modified"> 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; non-nullable {@linkplain #isInlineClass() inline class}</span>
 880      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;
 881      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 882      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 883      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 885      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 886      * &lt;/tbody&gt;
 887      * &lt;/table&gt;&lt;/blockquote&gt;
 888      *
 889      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 890      * the class specified above.
 891      *
 892      * &lt;p&gt; Examples:
 893      * &lt;blockquote&gt;&lt;pre&gt;
 894      * String.class.getName()
 895      *     returns &quot;java.lang.String&quot;
 896      * byte.class.getName()
 897      *     returns &quot;byte&quot;
 898      * Point.class.getName()
 899      *     returns &quot;Point&quot;
 900      * (new Object[3]).getClass().getName()
 901      *     returns &quot;[Ljava.lang.Object;&quot;
 902      * (new Point[3]).getClass().getName()
 903      *     returns &quot;[QPoint;&quot;
<a name="11" id="anc11"></a><span class="line-modified"> 904      * (new Point?[3][4]).getClass().getName()</span>
<span class="line-modified"> 905      *     returns &quot;[[LPoint;&quot;</span>
 906      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 907      *     returns &quot;[[[[[[[I&quot;
 908      * &lt;/pre&gt;&lt;/blockquote&gt;
 909      *
 910      * @return  the name of the class or interface
 911      *          represented by this {@code Class} object.
 912      */
 913     public String getName() {
 914         String name = this.name;
 915         return name != null ? name : initClassName();
 916     }
 917 
 918     // Cache the name to reduce the number of calls into the VM.
 919     // This field would be set by VM itself during initClassName call.
 920     private transient String name;
 921     private native String initClassName();
 922 
 923     /**
 924      * Returns the class loader for the class.  Some implementations may use
 925      * null to represent the bootstrap class loader. This method will return
 926      * null in such implementations if this class was loaded by the bootstrap
 927      * class loader.
 928      *
 929      * &lt;p&gt;If this {@code Class} object
 930      * represents a primitive type or void, null is returned.
 931      *
 932      * @return  the class loader that loaded the class or interface
 933      *          represented by this {@code Class} object.
 934      * @throws  SecurityException
 935      *          if a security manager is present, and the caller&#39;s class loader
 936      *          is not {@code null} and is not the same as or an ancestor of the
 937      *          class loader for the class whose class loader is requested,
 938      *          and the caller does not have the
 939      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 940      * @see java.lang.ClassLoader
 941      * @see SecurityManager#checkPermission
 942      * @see java.lang.RuntimePermission
 943      */
 944     @CallerSensitive
 945     @ForceInline // to ensure Reflection.getCallerClass optimization
 946     public ClassLoader getClassLoader() {
 947         ClassLoader cl = getClassLoader0();
 948         if (cl == null)
 949             return null;
 950         SecurityManager sm = System.getSecurityManager();
 951         if (sm != null) {
 952             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 953         }
 954         return cl;
 955     }
 956 
 957     // Package-private to allow ClassLoader access
 958     ClassLoader getClassLoader0() { return classLoader; }
 959 
 960     /**
 961      * Returns the module that this class or interface is a member of.
 962      *
 963      * If this class represents an array type then this method returns the
 964      * {@code Module} for the element type. If this class represents a
 965      * primitive type or void, then the {@code Module} object for the
 966      * {@code java.base} module is returned.
 967      *
 968      * If this class is in an unnamed module then the {@linkplain
 969      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
 970      * loader for this class is returned.
 971      *
 972      * @return the module that this class or interface is a member of
 973      *
 974      * @since 9
 975      * @spec JPMS
 976      */
 977     public Module getModule() {
 978         return module;
 979     }
 980 
 981     // set by VM
 982     private transient Module module;
 983 
 984     // Initialized in JVM not by private constructor
 985     // This field is filtered from reflection access, i.e. getDeclaredField
 986     // will throw NoSuchFieldException
 987     private final ClassLoader classLoader;
 988 
 989     /**
 990      * Returns an array of {@code TypeVariable} objects that represent the
 991      * type variables declared by the generic declaration represented by this
 992      * {@code GenericDeclaration} object, in declaration order.  Returns an
 993      * array of length 0 if the underlying generic declaration declares no type
 994      * variables.
 995      *
 996      * @return an array of {@code TypeVariable} objects that represent
 997      *     the type variables declared by this generic declaration
 998      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 999      *     signature of this generic declaration does not conform to
1000      *     the format specified in section {@jvms 4.7.9} of
1001      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;,
1002      * @since 1.5
1003      */
1004     @SuppressWarnings(&quot;unchecked&quot;)
1005     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1006         ClassRepository info = getGenericInfo();
1007         if (info != null)
1008             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1009         else
1010             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1011     }
1012 
1013 
1014     /**
1015      * Returns the {@code Class} representing the direct superclass of the
1016      * entity (class, interface, primitive type or void) represented by
1017      * this {@code Class}.  If this {@code Class} represents either the
1018      * {@code Object} class, an interface, a primitive type, or void, then
1019      * null is returned.  If this {@code Class} object represents an array class
1020      * then the {@code Class} object representing the {@code Object} class is
1021      * returned.
1022      *
1023      * @return the direct superclass of the class represented by this {@code Class} object
1024      */
1025     @HotSpotIntrinsicCandidate
1026     public native Class&lt;? super T&gt; getSuperclass();
1027 
1028 
1029     /**
1030      * Returns the {@code Type} representing the direct superclass of
1031      * the entity (class, interface, primitive type or void) represented by
1032      * this {@code Class} object.
1033      *
1034      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1035      * object returned must accurately reflect the actual type
1036      * arguments used in the source code. The parameterized type
1037      * representing the superclass is created if it had not been
1038      * created before. See the declaration of {@link
1039      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1040      * semantics of the creation process for parameterized types.  If
1041      * this {@code Class} object represents either the {@code Object}
1042      * class, an interface, a primitive type, or void, then null is
1043      * returned.  If this {@code Class} object represents an array class
1044      * then the {@code Class} object representing the {@code Object} class is
1045      * returned.
1046      *
1047      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1048      *     class signature does not conform to the format specified in
1049      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
1050      *     Machine Specification&lt;/cite&gt;
1051      * @throws TypeNotPresentException if the generic superclass
1052      *     refers to a non-existent type declaration
1053      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1054      *     generic superclass refers to a parameterized type that cannot be
1055      *     instantiated  for any reason
1056      * @return the direct superclass of the class represented by this {@code Class} object
1057      * @since 1.5
1058      */
1059     public Type getGenericSuperclass() {
1060         ClassRepository info = getGenericInfo();
1061         if (info == null) {
1062             return getSuperclass();
1063         }
1064 
1065         // Historical irregularity:
1066         // Generic signature marks interfaces with superclass = Object
1067         // but this API returns null for interfaces
1068         if (isInterface()) {
1069             return null;
1070         }
1071 
1072         return info.getSuperclass();
1073     }
1074 
1075     /**
1076      * Gets the package of this class.
1077      *
1078      * &lt;p&gt;If this class represents an array type, a primitive type or void,
1079      * this method returns {@code null}.
1080      *
1081      * @return the package of this class.
1082      * @revised 9
1083      * @spec JPMS
1084      */
1085     public Package getPackage() {
1086         if (isPrimitive() || isArray()) {
1087             return null;
1088         }
1089         ClassLoader cl = getClassLoader0();
1090         return cl != null ? cl.definePackage(this)
1091                           : BootLoader.definePackage(this);
1092     }
1093 
1094     /**
1095      * Returns the fully qualified package name.
1096      *
1097      * &lt;p&gt; If this class is a top level class, then this method returns the fully
1098      * qualified name of the package that the class is a member of, or the
1099      * empty string if the class is in an unnamed package.
1100      *
1101      * &lt;p&gt; If this class is a member class, then this method is equivalent to
1102      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
1103      * enclosing class}.
1104      *
1105      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1106      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1107      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1108      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1109      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1110      *
1111      * &lt;p&gt; If this class represents an array type then this method returns the
1112      * package name of the element type. If this class represents a primitive
1113      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1114      *
1115      * @return the fully qualified package name
1116      *
1117      * @since 9
1118      * @spec JPMS
1119      * @jls 6.7 Fully Qualified Names
1120      */
1121     public String getPackageName() {
1122         String pn = this.packageName;
1123         if (pn == null) {
1124             Class&lt;?&gt; c = this;
1125             while (c.isArray()) {
1126                 c = c.getComponentType();
1127             }
1128             if (c.isPrimitive()) {
1129                 pn = &quot;java.lang&quot;;
1130             } else {
1131                 String cn = c.getName();
1132                 int dot = cn.lastIndexOf(&#39;.&#39;);
1133                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1134             }
1135             this.packageName = pn;
1136         }
1137         return pn;
1138     }
1139 
1140     // cached package name
1141     private transient String packageName;
1142 
1143     /**
1144      * Returns the interfaces directly implemented by the class or interface
1145      * represented by this {@code Class} object.
1146      *
1147      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1148      * containing objects representing all interfaces directly implemented by
1149      * the class.  The order of the interface objects in the array corresponds
1150      * to the order of the interface names in the {@code implements} clause of
1151      * the declaration of the class represented by this {@code Class} object.  For example,
1152      * given the declaration:
1153      * &lt;blockquote&gt;
1154      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1155      * &lt;/blockquote&gt;
1156      * suppose the value of {@code s} is an instance of
1157      * {@code Shimmer}; the value of the expression:
1158      * &lt;blockquote&gt;
1159      * {@code s.getClass().getInterfaces()[0]}
1160      * &lt;/blockquote&gt;
1161      * is the {@code Class} object that represents interface
1162      * {@code FloorWax}; and the value of:
1163      * &lt;blockquote&gt;
1164      * {@code s.getClass().getInterfaces()[1]}
1165      * &lt;/blockquote&gt;
1166      * is the {@code Class} object that represents interface
1167      * {@code DessertTopping}.
1168      *
1169      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1170      * representing all interfaces directly extended by the interface.  The
1171      * order of the interface objects in the array corresponds to the order of
1172      * the interface names in the {@code extends} clause of the declaration of
1173      * the interface represented by this {@code Class} object.
1174      *
1175      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1176      * interfaces, the method returns an array of length 0.
1177      *
1178      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1179      * returns an array of length 0.
1180      *
1181      * &lt;p&gt;If this {@code Class} object represents an array type, the
1182      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1183      * returned in that order.
1184      *
1185      * @return an array of interfaces directly implemented by this class
1186      */
1187     public Class&lt;?&gt;[] getInterfaces() {
1188         // defensively copy before handing over to user code
1189         return getInterfaces(true);
1190     }
1191 
1192     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1193         ReflectionData&lt;T&gt; rd = reflectionData();
1194         if (rd == null) {
1195             // no cloning required
1196             return getInterfaces0();
1197         } else {
1198             Class&lt;?&gt;[] interfaces = rd.interfaces;
1199             if (interfaces == null) {
1200                 interfaces = getInterfaces0();
1201                 rd.interfaces = interfaces;
1202             }
1203             // defensively copy if requested
1204             return cloneArray ? interfaces.clone() : interfaces;
1205         }
1206     }
1207 
1208     private native Class&lt;?&gt;[] getInterfaces0();
1209 
1210     /**
1211      * Returns the {@code Type}s representing the interfaces
1212      * directly implemented by the class or interface represented by
1213      * this {@code Class} object.
1214      *
1215      * &lt;p&gt;If a superinterface is a parameterized type, the
1216      * {@code Type} object returned for it must accurately reflect
1217      * the actual type arguments used in the source code. The
1218      * parameterized type representing each superinterface is created
1219      * if it had not been created before. See the declaration of
1220      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1221      * for the semantics of the creation process for parameterized
1222      * types.
1223      *
1224      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1225      * containing objects representing all interfaces directly implemented by
1226      * the class.  The order of the interface objects in the array corresponds
1227      * to the order of the interface names in the {@code implements} clause of
1228      * the declaration of the class represented by this {@code Class} object.
1229      *
1230      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1231      * representing all interfaces directly extended by the interface.  The
1232      * order of the interface objects in the array corresponds to the order of
1233      * the interface names in the {@code extends} clause of the declaration of
1234      * the interface represented by this {@code Class} object.
1235      *
1236      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1237      * interfaces, the method returns an array of length 0.
1238      *
1239      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1240      * returns an array of length 0.
1241      *
1242      * &lt;p&gt;If this {@code Class} object represents an array type, the
1243      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1244      * returned in that order.
1245      *
1246      * @throws java.lang.reflect.GenericSignatureFormatError
1247      *     if the generic class signature does not conform to the
1248      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The
1249      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1250      * @throws TypeNotPresentException if any of the generic
1251      *     superinterfaces refers to a non-existent type declaration
1252      * @throws java.lang.reflect.MalformedParameterizedTypeException
1253      *     if any of the generic superinterfaces refer to a parameterized
1254      *     type that cannot be instantiated for any reason
1255      * @return an array of interfaces directly implemented by this class
1256      * @since 1.5
1257      */
1258     public Type[] getGenericInterfaces() {
1259         ClassRepository info = getGenericInfo();
1260         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1261     }
1262 
1263 
1264     /**
1265      * Returns the {@code Class} representing the component type of an
1266      * array.  If this class does not represent an array class this method
1267      * returns null.
1268      *
1269      * @return the {@code Class} representing the component type of this
1270      * class if this class is an array
1271      * @see     java.lang.reflect.Array
1272      * @since 1.1
1273      */
1274     public Class&lt;?&gt; getComponentType() {
1275         // Only return for array types. Storage may be reused for Class for instance types.
1276         if (isArray()) {
1277             return componentType;
1278         } else {
1279             return null;
1280         }
1281     }
1282 
1283     private final Class&lt;?&gt; componentType;
1284 
1285 
1286     /**
1287      * Returns the Java language modifiers for this class or interface, encoded
1288      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1289      * constants for {@code public}, {@code protected},
1290      * {@code private}, {@code final}, {@code static},
1291      * {@code abstract} and {@code interface}; they should be decoded
1292      * using the methods of class {@code Modifier}.
1293      *
1294      * &lt;p&gt; If the underlying class is an array class, then its
1295      * {@code public}, {@code private} and {@code protected}
1296      * modifiers are the same as those of its component type.  If this
1297      * {@code Class} object represents a primitive type or void, its
1298      * {@code public} modifier is always {@code true}, and its
1299      * {@code protected} and {@code private} modifiers are always
1300      * {@code false}. If this {@code Class} object represents an array class, a
1301      * primitive type or void, then its {@code final} modifier is always
1302      * {@code true} and its interface modifier is always
1303      * {@code false}. The values of its other modifiers are not determined
1304      * by this specification.
1305      *
1306      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1307      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1308      *
1309      * @return the {@code int} representing the modifiers for this class
1310      * @see     java.lang.reflect.Modifier
1311      * @since 1.1
1312      */
1313     @HotSpotIntrinsicCandidate
1314     public native int getModifiers();
1315 
1316     /**
1317      * Gets the signers of this class.
1318      *
1319      * @return  the signers of this class, or null if there are no signers.  In
1320      *          particular, this method returns null if this {@code Class} object represents
1321      *          a primitive type or void.
1322      * @since   1.1
1323      */
<a name="12" id="anc12"></a><span class="line-modified">1324     public Object[] getSigners() {</span>
<span class="line-removed">1325         return asPrimaryType().getSigners0();</span>
<span class="line-removed">1326     }</span>
<span class="line-removed">1327 </span>
<span class="line-removed">1328     private native Object[] getSigners0();</span>
1329 
1330     /**
1331      * Set the signers of this class.
1332      */
<a name="13" id="anc13"></a><span class="line-modified">1333     void setSigners(Object[] signers) {</span>
<span class="line-removed">1334         asPrimaryType().setSigners0(signers);</span>
<span class="line-removed">1335     }</span>
<span class="line-removed">1336 </span>
<span class="line-removed">1337     native void setSigners0(Object[] signers);</span>
1338 
1339 
1340     /**
1341      * If this {@code Class} object represents a local or anonymous
1342      * class within a method, returns a {@link
1343      * java.lang.reflect.Method Method} object representing the
1344      * immediately enclosing method of the underlying class. Returns
1345      * {@code null} otherwise.
1346      *
1347      * In particular, this method returns {@code null} if the underlying
1348      * class is a local or anonymous class immediately enclosed by a type
1349      * declaration, instance initializer or static initializer.
1350      *
1351      * @return the immediately enclosing method of the underlying class, if
1352      *     that class is a local or anonymous class; otherwise {@code null}.
1353      *
1354      * @throws SecurityException
1355      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1356      *         following conditions is met:
1357      *
1358      *         &lt;ul&gt;
1359      *
1360      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1361      *         class loader of the enclosing class and invocation of
1362      *         {@link SecurityManager#checkPermission
1363      *         s.checkPermission} method with
1364      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1365      *         denies access to the methods within the enclosing class
1366      *
1367      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1368      *         ancestor of the class loader for the enclosing class and
1369      *         invocation of {@link SecurityManager#checkPackageAccess
1370      *         s.checkPackageAccess()} denies access to the package
1371      *         of the enclosing class
1372      *
1373      *         &lt;/ul&gt;
1374      * @since 1.5
1375      */
1376     @CallerSensitive
1377     public Method getEnclosingMethod() throws SecurityException {
1378         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1379 
1380         if (enclosingInfo == null)
1381             return null;
1382         else {
1383             if (!enclosingInfo.isMethod())
1384                 return null;
1385 
1386             MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
1387                                                               getFactory());
1388             Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
1389             Type []    parameterTypes   = typeInfo.getParameterTypes();
1390             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1391 
1392             // Convert Types to Classes; returned types *should*
1393             // be class objects since the methodDescriptor&#39;s used
1394             // don&#39;t have generics information
1395             for(int i = 0; i &lt; parameterClasses.length; i++)
1396                 parameterClasses[i] = toClass(parameterTypes[i]);
1397 
1398             // Perform access check
1399             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1400             SecurityManager sm = System.getSecurityManager();
1401             if (sm != null) {
1402                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1403                                                      Reflection.getCallerClass(), true);
1404             }
1405             Method[] candidates = enclosingCandidate.privateGetDeclaredMethods(false);
1406 
1407             /*
1408              * Loop over all declared methods; match method name,
1409              * number of and type of parameters, *and* return
1410              * type.  Matching return type is also necessary
1411              * because of covariant returns, etc.
1412              */
1413             ReflectionFactory fact = getReflectionFactory();
1414             for (Method m : candidates) {
1415                 if (m.getName().equals(enclosingInfo.getName()) &amp;&amp;
1416                     arrayContentsEq(parameterClasses,
1417                                     fact.getExecutableSharedParameterTypes(m))) {
1418                     // finally, check return type
1419                     if (m.getReturnType().equals(returnType)) {
1420                         return fact.copyMethod(m);
1421                     }
1422                 }
1423             }
1424 
1425             throw new InternalError(&quot;Enclosing method not found&quot;);
1426         }
1427     }
1428 
1429     private native Object[] getEnclosingMethod0();
1430 
1431     private EnclosingMethodInfo getEnclosingMethodInfo() {
1432         Object[] enclosingInfo = getEnclosingMethod0();
1433         if (enclosingInfo == null)
1434             return null;
1435         else {
1436             return new EnclosingMethodInfo(enclosingInfo);
1437         }
1438     }
1439 
1440     private static final class EnclosingMethodInfo {
1441         private final Class&lt;?&gt; enclosingClass;
1442         private final String name;
1443         private final String descriptor;
1444 
1445         static void validate(Object[] enclosingInfo) {
1446             if (enclosingInfo.length != 3)
1447                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1448             try {
1449                 // The array is expected to have three elements:
1450 
1451                 // the immediately enclosing class
1452                 Class&lt;?&gt; enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1453                 assert(enclosingClass != null);
1454 
1455                 // the immediately enclosing method or constructor&#39;s
1456                 // name (can be null).
1457                 String name = (String)enclosingInfo[1];
1458 
1459                 // the immediately enclosing method or constructor&#39;s
1460                 // descriptor (null iff name is).
1461                 String descriptor = (String)enclosingInfo[2];
1462                 assert((name != null &amp;&amp; descriptor != null) || name == descriptor);
1463             } catch (ClassCastException cce) {
1464                 throw new InternalError(&quot;Invalid type in enclosing method information&quot;, cce);
1465             }
1466         }
1467 
1468         EnclosingMethodInfo(Object[] enclosingInfo) {
1469             validate(enclosingInfo);
1470             this.enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1471             this.name = (String)enclosingInfo[1];
1472             this.descriptor = (String)enclosingInfo[2];
1473         }
1474 
1475         boolean isPartial() {
1476             return enclosingClass == null || name == null || descriptor == null;
1477         }
1478 
1479         boolean isConstructor() { return !isPartial() &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name); }
1480 
1481         boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name); }
1482 
1483         Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }
1484 
1485         String getName() { return name; }
1486 
1487         String getDescriptor() { return descriptor; }
1488 
1489     }
1490 
1491     private static Class&lt;?&gt; toClass(Type o) {
1492         if (o instanceof GenericArrayType)
1493             return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
1494                                      0)
1495                 .getClass();
1496         return (Class&lt;?&gt;)o;
1497      }
1498 
1499     /**
1500      * If this {@code Class} object represents a local or anonymous
1501      * class within a constructor, returns a {@link
1502      * java.lang.reflect.Constructor Constructor} object representing
1503      * the immediately enclosing constructor of the underlying
1504      * class. Returns {@code null} otherwise.  In particular, this
1505      * method returns {@code null} if the underlying class is a local
1506      * or anonymous class immediately enclosed by a type declaration,
1507      * instance initializer or static initializer.
1508      *
1509      * @return the immediately enclosing constructor of the underlying class, if
1510      *     that class is a local or anonymous class; otherwise {@code null}.
1511      * @throws SecurityException
1512      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1513      *         following conditions is met:
1514      *
1515      *         &lt;ul&gt;
1516      *
1517      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1518      *         class loader of the enclosing class and invocation of
1519      *         {@link SecurityManager#checkPermission
1520      *         s.checkPermission} method with
1521      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1522      *         denies access to the constructors within the enclosing class
1523      *
1524      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1525      *         ancestor of the class loader for the enclosing class and
1526      *         invocation of {@link SecurityManager#checkPackageAccess
1527      *         s.checkPackageAccess()} denies access to the package
1528      *         of the enclosing class
1529      *
1530      *         &lt;/ul&gt;
1531      * @since 1.5
1532      */
1533     @CallerSensitive
1534     public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {
1535         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1536 
1537         if (enclosingInfo == null)
1538             return null;
1539         else {
1540             if (!enclosingInfo.isConstructor())
1541                 return null;
1542 
1543             ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
1544                                                                         getFactory());
1545             Type []    parameterTypes   = typeInfo.getParameterTypes();
1546             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1547 
1548             // Convert Types to Classes; returned types *should*
1549             // be class objects since the methodDescriptor&#39;s used
1550             // don&#39;t have generics information
1551             for(int i = 0; i &lt; parameterClasses.length; i++)
1552                 parameterClasses[i] = toClass(parameterTypes[i]);
1553 
1554             // Perform access check
1555             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1556             SecurityManager sm = System.getSecurityManager();
1557             if (sm != null) {
1558                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1559                                                      Reflection.getCallerClass(), true);
1560             }
1561 
1562             Constructor&lt;?&gt;[] candidates = enclosingCandidate
1563                     .privateGetDeclaredConstructors(false);
1564             /*
1565              * Loop over all declared constructors; match number
1566              * of and type of parameters.
1567              */
1568             ReflectionFactory fact = getReflectionFactory();
1569             for (Constructor&lt;?&gt; c : candidates) {
1570                 if (arrayContentsEq(parameterClasses,
1571                                     fact.getExecutableSharedParameterTypes(c))) {
1572                     return fact.copyConstructor(c);
1573                 }
1574             }
1575 
1576             throw new InternalError(&quot;Enclosing constructor not found&quot;);
1577         }
1578     }
1579 
1580 
1581     /**
1582      * If the class or interface represented by this {@code Class} object
1583      * is a member of another class, returns the {@code Class} object
1584      * representing the class in which it was declared.  This method returns
1585      * null if this class or interface is not a member of any other class.  If
1586      * this {@code Class} object represents an array class, a primitive
1587      * type, or void,then this method returns null.
1588      *
1589      * @return the declaring class for this class
1590      * @throws SecurityException
1591      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1592      *         class loader is not the same as or an ancestor of the class
1593      *         loader for the declaring class and invocation of {@link
1594      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
1595      *         denies access to the package of the declaring class
1596      * @since 1.1
1597      */
1598     @CallerSensitive
1599     public Class&lt;?&gt; getDeclaringClass() throws SecurityException {
1600         final Class&lt;?&gt; candidate = getDeclaringClass0();
1601 
1602         if (candidate != null) {
1603             SecurityManager sm = System.getSecurityManager();
1604             if (sm != null) {
1605                 candidate.checkPackageAccess(sm,
1606                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1607             }
1608         }
1609         return candidate;
1610     }
1611 
1612     private native Class&lt;?&gt; getDeclaringClass0();
1613 
1614 
1615     /**
1616      * Returns the immediately enclosing class of the underlying
1617      * class.  If the underlying class is a top level class this
1618      * method returns {@code null}.
1619      * @return the immediately enclosing class of the underlying class
1620      * @throws     SecurityException
1621      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1622      *             class loader is not the same as or an ancestor of the class
1623      *             loader for the enclosing class and invocation of {@link
1624      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1625      *             denies access to the package of the enclosing class
1626      * @since 1.5
1627      */
1628     @CallerSensitive
1629     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1630         // There are five kinds of classes (or interfaces):
1631         // a) Top level classes
1632         // b) Nested classes (static member classes)
1633         // c) Inner classes (non-static member classes)
1634         // d) Local classes (named classes declared within a method)
1635         // e) Anonymous classes
1636 
1637 
1638         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1639         // attribute if and only if it is a local class or an
1640         // anonymous class.
1641         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1642         Class&lt;?&gt; enclosingCandidate;
1643 
1644         if (enclosingInfo == null) {
1645             // This is a top level or a nested class or an inner class (a, b, or c)
1646             enclosingCandidate = getDeclaringClass0();
1647         } else {
1648             Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
1649             // This is a local class or an anonymous class (d or e)
1650             if (enclosingClass == this || enclosingClass == null)
1651                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1652             else
1653                 enclosingCandidate = enclosingClass;
1654         }
1655 
1656         if (enclosingCandidate != null) {
1657             SecurityManager sm = System.getSecurityManager();
1658             if (sm != null) {
1659                 enclosingCandidate.checkPackageAccess(sm,
1660                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1661             }
1662         }
1663         return enclosingCandidate;
1664     }
1665 
1666     /**
1667      * Returns the simple name of the underlying class as given in the
1668      * source code. Returns an empty string if the underlying class is
1669      * anonymous.
1670      *
1671      * &lt;p&gt;The simple name of an array is the simple name of the
1672      * component type with &quot;[]&quot; appended.  In particular the simple
1673      * name of an array whose component type is anonymous is &quot;[]&quot;.
1674      *
1675      * @return the simple name of the underlying class
1676      * @since 1.5
1677      */
1678     public String getSimpleName() {
1679         ReflectionData&lt;T&gt; rd = reflectionData();
1680         String simpleName = rd.simpleName;
1681         if (simpleName == null) {
1682             rd.simpleName = simpleName = getSimpleName0();
1683         }
1684         return simpleName;
1685     }
1686 
1687     private String getSimpleName0() {
1688         if (isArray()) {
1689             return getComponentType().getSimpleName() + &quot;[]&quot;;
1690         }
1691         String simpleName = getSimpleBinaryName();
1692         if (simpleName == null) { // top level class
1693             simpleName = getName();
1694             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1695         }
<a name="14" id="anc14"></a><span class="line-modified">1696         return isInlineClass() &amp;&amp; isIndirectType() ? simpleName + &quot;?&quot; : simpleName;</span>
1697     }
1698 
1699     /**
1700      * Return an informative string for the name of this type.
1701      *
1702      * @return an informative string for the name of this type
1703      * @since 1.8
1704      */
1705     public String getTypeName() {
1706         if (isArray()) {
1707             try {
1708                 Class&lt;?&gt; cl = this;
1709                 int dimensions = 0;
1710                 do {
1711                     dimensions++;
1712                     cl = cl.getComponentType();
1713                 } while (cl.isArray());
1714                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1715             } catch (Throwable e) { /*FALLTHRU*/ }
1716         }
<a name="15" id="anc15"></a><span class="line-modified">1717         return toTypeName();</span>
1718     }
1719 
1720     /**
1721      * Returns the canonical name of the underlying class as defined
1722      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section
1723      * {@jls 6.7}.  Returns null if the underlying class does not have
1724      * a canonical name (i.e., if it is a local or anonymous class or
1725      * an array whose component type does not have a canonical name).
1726      * @return the canonical name of the underlying class if it exists, and
1727      * {@code null} otherwise.
1728      * @since 1.5
1729      */
1730     public String getCanonicalName() {
1731         ReflectionData&lt;T&gt; rd = reflectionData();
1732         String canonicalName = rd.canonicalName;
1733         if (canonicalName == null) {
1734             rd.canonicalName = canonicalName = getCanonicalName0();
1735         }
1736         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1737     }
1738 
1739     private String getCanonicalName0() {
1740         if (isArray()) {
1741             String canonicalName = getComponentType().getCanonicalName();
1742             if (canonicalName != null)
1743                 return canonicalName + &quot;[]&quot;;
1744             else
1745                 return ReflectionData.NULL_SENTINEL;
1746         }
1747         if (isLocalOrAnonymousClass())
1748             return ReflectionData.NULL_SENTINEL;
1749         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1750         if (enclosingClass == null) { // top level class
1751             return getName();
1752         } else {
1753             String enclosingName = enclosingClass.getCanonicalName();
1754             if (enclosingName == null)
1755                 return ReflectionData.NULL_SENTINEL;
1756             return enclosingName + &quot;.&quot; + getSimpleName();
1757         }
1758     }
1759 
1760     /**
1761      * Returns {@code true} if and only if the underlying class
1762      * is an anonymous class.
1763      *
1764      * @return {@code true} if and only if this class is an anonymous class.
1765      * @since 1.5
1766      */
1767     public boolean isAnonymousClass() {
1768         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1769                 getSimpleBinaryName0() == null;
1770     }
1771 
1772     /**
1773      * Returns {@code true} if and only if the underlying class
1774      * is a local class.
1775      *
1776      * @return {@code true} if and only if this class is a local class.
1777      * @since 1.5
1778      */
1779     public boolean isLocalClass() {
1780         return isLocalOrAnonymousClass() &amp;&amp;
1781                 (isArray() || getSimpleBinaryName0() != null);
1782     }
1783 
1784     /**
1785      * Returns {@code true} if and only if the underlying class
1786      * is a member class.
1787      *
1788      * @return {@code true} if and only if this class is a member class.
1789      * @since 1.5
1790      */
1791     public boolean isMemberClass() {
1792         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() != null;
1793     }
1794 
1795     /**
1796      * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
1797      * the binary name without the leading enclosing class name.
1798      * Returns {@code null} if the underlying class is a top level
1799      * class.
1800      */
1801     private String getSimpleBinaryName() {
1802         if (isTopLevelClass())
1803             return null;
1804         String name = getSimpleBinaryName0();
1805         if (name == null) // anonymous class
1806             return &quot;&quot;;
1807         return name;
1808     }
1809 
1810     private native String getSimpleBinaryName0();
1811 
1812     /**
1813      * Returns {@code true} if this is a top level class.  Returns {@code false}
1814      * otherwise.
1815      */
1816     private boolean isTopLevelClass() {
1817         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() == null;
1818     }
1819 
1820     /**
1821      * Returns {@code true} if this is a local class or an anonymous
1822      * class.  Returns {@code false} otherwise.
1823      */
1824     private boolean isLocalOrAnonymousClass() {
1825         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1826         // attribute if and only if it is a local class or an
1827         // anonymous class.
1828         return hasEnclosingMethodInfo();
1829     }
1830 
1831     private boolean hasEnclosingMethodInfo() {
1832         Object[] enclosingInfo = getEnclosingMethod0();
1833         if (enclosingInfo != null) {
1834             EnclosingMethodInfo.validate(enclosingInfo);
1835             return true;
1836         }
1837         return false;
1838     }
1839 
1840     /**
1841      * Returns an array containing {@code Class} objects representing all
1842      * the public classes and interfaces that are members of the class
1843      * represented by this {@code Class} object.  This includes public
1844      * class and interface members inherited from superclasses and public class
1845      * and interface members declared by the class.  This method returns an
1846      * array of length 0 if this {@code Class} object has no public member
1847      * classes or interfaces.  This method also returns an array of length 0 if
1848      * this {@code Class} object represents a primitive type, an array
1849      * class, or void.
1850      *
1851      * @return the array of {@code Class} objects representing the public
1852      *         members of this class
1853      * @throws SecurityException
1854      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1855      *         the caller&#39;s class loader is not the same as or an
1856      *         ancestor of the class loader for the current class and
1857      *         invocation of {@link SecurityManager#checkPackageAccess
1858      *         s.checkPackageAccess()} denies access to the package
1859      *         of this class.
1860      *
1861      * @since 1.1
1862      */
1863     @CallerSensitive
1864     public Class&lt;?&gt;[] getClasses() {
1865         SecurityManager sm = System.getSecurityManager();
1866         if (sm != null) {
1867             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
1868         }
1869 
1870         // Privileged so this implementation can look at DECLARED classes,
1871         // something the caller might not have privilege to do.  The code here
1872         // is allowed to look at DECLARED classes because (1) it does not hand
1873         // out anything other than public members and (2) public member access
1874         // has already been ok&#39;d by the SecurityManager.
1875 
1876         return java.security.AccessController.doPrivileged(
1877             new java.security.PrivilegedAction&lt;&gt;() {
1878                 public Class&lt;?&gt;[] run() {
1879                     List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();
1880                     Class&lt;?&gt; currentClass = Class.this;
1881                     while (currentClass != null) {
1882                         for (Class&lt;?&gt; m : currentClass.getDeclaredClasses()) {
1883                             if (Modifier.isPublic(m.getModifiers())) {
1884                                 list.add(m);
1885                             }
1886                         }
1887                         currentClass = currentClass.getSuperclass();
1888                     }
1889                     return list.toArray(new Class&lt;?&gt;[0]);
1890                 }
1891             });
1892     }
1893 
1894 
1895     /**
1896      * Returns an array containing {@code Field} objects reflecting all
1897      * the accessible public fields of the class or interface represented by
1898      * this {@code Class} object.
1899      *
1900      * &lt;p&gt; If this {@code Class} object represents a class or interface with
1901      * no accessible public fields, then this method returns an array of length
1902      * 0.
1903      *
1904      * &lt;p&gt; If this {@code Class} object represents a class, then this method
1905      * returns the public fields of the class and of all its superclasses and
1906      * superinterfaces.
1907      *
1908      * &lt;p&gt; If this {@code Class} object represents an interface, then this
1909      * method returns the fields of the interface and of all its
1910      * superinterfaces.
1911      *
1912      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
1913      * type, or void, then this method returns an array of length 0.
1914      *
1915      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1916      * particular order.
1917      *
1918      * @return the array of {@code Field} objects representing the
1919      *         public fields
1920      * @throws SecurityException
1921      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1922      *         the caller&#39;s class loader is not the same as or an
1923      *         ancestor of the class loader for the current class and
1924      *         invocation of {@link SecurityManager#checkPackageAccess
1925      *         s.checkPackageAccess()} denies access to the package
1926      *         of this class.
1927      *
1928      * @since 1.1
1929      * @jls 8.2 Class Members
1930      * @jls 8.3 Field Declarations
1931      */
1932     @CallerSensitive
1933     public Field[] getFields() throws SecurityException {
1934         SecurityManager sm = System.getSecurityManager();
1935         if (sm != null) {
1936             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1937         }
1938         return copyFields(privateGetPublicFields());
1939     }
1940 
1941 
1942     /**
1943      * Returns an array containing {@code Method} objects reflecting all the
1944      * public methods of the class or interface represented by this {@code
1945      * Class} object, including those declared by the class or interface and
1946      * those inherited from superclasses and superinterfaces.
1947      *
1948      * &lt;p&gt; If this {@code Class} object represents an array type, then the
1949      * returned array has a {@code Method} object for each of the public
1950      * methods inherited by the array type from {@code Object}. It does not
1951      * contain a {@code Method} object for {@code clone()}.
1952      *
1953      * &lt;p&gt; If this {@code Class} object represents an interface then the
1954      * returned array does not contain any implicitly declared methods from
1955      * {@code Object}. Therefore, if no methods are explicitly declared in
1956      * this interface or any of its superinterfaces then the returned array
1957      * has length 0. (Note that a {@code Class} object which represents a class
1958      * always has public methods, inherited from {@code Object}.)
1959      *
1960      * &lt;p&gt; The returned array never contains methods with names &quot;{@code &lt;init&gt;}&quot;
1961      * or &quot;{@code &lt;clinit&gt;}&quot;.
1962      *
1963      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1964      * particular order.
1965      *
1966      * &lt;p&gt; Generally, the result is computed as with the following 4 step algorithm.
1967      * Let C be the class or interface represented by this {@code Class} object:
1968      * &lt;ol&gt;
1969      * &lt;li&gt; A union of methods is composed of:
1970      *   &lt;ol type=&quot;a&quot;&gt;
1971      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
1972      *        {@link #getDeclaredMethods()} and filtered to include only public
1973      *        methods.&lt;/li&gt;
1974      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
1975      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
1976      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
1977      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
1978      *   &lt;/ol&gt;&lt;/li&gt;
1979      * &lt;li&gt; Union from step 1 is partitioned into subsets of methods with same
1980      *      signature (name, parameter types) and return type.&lt;/li&gt;
1981      * &lt;li&gt; Within each such subset only the most specific methods are selected.
1982      *      Let method M be a method from a set of methods with same signature
1983      *      and return type. M is most specific if there is no such method
1984      *      N != M from the same set, such that N is more specific than M.
1985      *      N is more specific than M if:
1986      *   &lt;ol type=&quot;a&quot;&gt;
1987      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
1988      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
1989      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
1990      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
1991      *        M and N are the same method).&lt;/li&gt;
1992      *   &lt;/ol&gt;&lt;/li&gt;
1993      * &lt;li&gt; The result of this algorithm is the union of all selected methods from
1994      *      step 3.&lt;/li&gt;
1995      * &lt;/ol&gt;
1996      *
1997      * @apiNote There may be more than one method with a particular name
1998      * and parameter types in a class because while the Java language forbids a
1999      * class to declare multiple methods with the same signature but different
2000      * return types, the Java virtual machine does not.  This
2001      * increased flexibility in the virtual machine can be used to
2002      * implement various language features.  For example, covariant
2003      * returns can be implemented with {@linkplain
2004      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2005      * method and the overriding method would have the same
2006      * signature but different return types.
2007      *
2008      * @return the array of {@code Method} objects representing the
2009      *         public methods of this class
2010      * @throws SecurityException
2011      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2012      *         the caller&#39;s class loader is not the same as or an
2013      *         ancestor of the class loader for the current class and
2014      *         invocation of {@link SecurityManager#checkPackageAccess
2015      *         s.checkPackageAccess()} denies access to the package
2016      *         of this class.
2017      *
2018      * @jls 8.2 Class Members
2019      * @jls 8.4 Method Declarations
2020      * @since 1.1
2021      */
2022     @CallerSensitive
2023     public Method[] getMethods() throws SecurityException {
2024         SecurityManager sm = System.getSecurityManager();
2025         if (sm != null) {
2026             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2027         }
2028         return copyMethods(privateGetPublicMethods());
2029     }
2030 
2031 
2032     /**
2033      * Returns an array containing {@code Constructor} objects reflecting
2034      * all the public constructors of the class represented by this
2035      * {@code Class} object.  An array of length 0 is returned if the
2036      * class has no public constructors, or if the class is an array class, or
2037      * if the class reflects a primitive type or void.
2038      *
2039      * @apiNote
2040      * While this method returns an array of {@code
2041      * Constructor&lt;T&gt;} objects (that is an array of constructors from
2042      * this class), the return type of this method is {@code
2043      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
2044      * might be expected.  This less informative return type is
2045      * necessary since after being returned from this method, the
2046      * array could be modified to hold {@code Constructor} objects for
2047      * different classes, which would violate the type guarantees of
2048      * {@code Constructor&lt;T&gt;[]}.
2049      *
2050      * @return the array of {@code Constructor} objects representing the
2051      *         public constructors of this class
2052      * @throws SecurityException
2053      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2054      *         the caller&#39;s class loader is not the same as or an
2055      *         ancestor of the class loader for the current class and
2056      *         invocation of {@link SecurityManager#checkPackageAccess
2057      *         s.checkPackageAccess()} denies access to the package
2058      *         of this class.
2059      *
2060      * @since 1.1
2061      */
2062     @CallerSensitive
2063     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2064         SecurityManager sm = System.getSecurityManager();
2065         if (sm != null) {
2066             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2067         }
2068         return copyConstructors(privateGetDeclaredConstructors(true));
2069     }
2070 
2071 
2072     /**
2073      * Returns a {@code Field} object that reflects the specified public member
2074      * field of the class or interface represented by this {@code Class}
2075      * object. The {@code name} parameter is a {@code String} specifying the
2076      * simple name of the desired field.
2077      *
2078      * &lt;p&gt; The field to be reflected is determined by the algorithm that
2079      * follows.  Let C be the class or interface represented by this {@code Class} object:
2080      *
2081      * &lt;OL&gt;
2082      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2083      *      field to be reflected.&lt;/LI&gt;
2084      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2085      *      recursively to each direct superinterface of C. The direct
2086      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2087      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2088      *      superclass S, then this algorithm is invoked recursively upon S.
2089      *      If C has no superclass, then a {@code NoSuchFieldException}
2090      *      is thrown.&lt;/LI&gt;
2091      * &lt;/OL&gt;
2092      *
2093      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2094      * method does not find the {@code length} field of the array type.
2095      *
2096      * @param name the field name
2097      * @return the {@code Field} object of this class specified by
2098      *         {@code name}
2099      * @throws NoSuchFieldException if a field with the specified name is
2100      *         not found.
2101      * @throws NullPointerException if {@code name} is {@code null}
2102      * @throws SecurityException
2103      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2104      *         the caller&#39;s class loader is not the same as or an
2105      *         ancestor of the class loader for the current class and
2106      *         invocation of {@link SecurityManager#checkPackageAccess
2107      *         s.checkPackageAccess()} denies access to the package
2108      *         of this class.
2109      *
2110      * @since 1.1
2111      * @jls 8.2 Class Members
2112      * @jls 8.3 Field Declarations
2113      */
2114     @CallerSensitive
2115     public Field getField(String name)
2116         throws NoSuchFieldException, SecurityException {
2117         Objects.requireNonNull(name);
2118         SecurityManager sm = System.getSecurityManager();
2119         if (sm != null) {
2120             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2121         }
2122         Field field = getField0(name);
2123         if (field == null) {
2124             throw new NoSuchFieldException(name);
2125         }
2126         return getReflectionFactory().copyField(field);
2127     }
2128 
2129 
2130     /**
2131      * Returns a {@code Method} object that reflects the specified public
2132      * member method of the class or interface represented by this
2133      * {@code Class} object. The {@code name} parameter is a
2134      * {@code String} specifying the simple name of the desired method. The
2135      * {@code parameterTypes} parameter is an array of {@code Class}
2136      * objects that identify the method&#39;s formal parameter types, in declared
2137      * order. If {@code parameterTypes} is {@code null}, it is
2138      * treated as if it were an empty array.
2139      *
2140      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2141      * method finds any public method inherited by the array type from
2142      * {@code Object} except method {@code clone()}.
2143      *
2144      * &lt;p&gt; If this {@code Class} object represents an interface then this
2145      * method does not find any implicitly declared method from
2146      * {@code Object}. Therefore, if no methods are explicitly declared in
2147      * this interface or any of its superinterfaces, then this method does not
2148      * find any method.
2149      *
2150      * &lt;p&gt; This method does not find any method with name &quot;{@code &lt;init&gt;}&quot; or
2151      * &quot;{@code &lt;clinit&gt;}&quot;.
2152      *
2153      * &lt;p&gt; Generally, the method to be reflected is determined by the 4 step
2154      * algorithm that follows.
2155      * Let C be the class or interface represented by this {@code Class} object:
2156      * &lt;ol&gt;
2157      * &lt;li&gt; A union of methods is composed of:
2158      *   &lt;ol type=&quot;a&quot;&gt;
2159      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2160      *        {@link #getDeclaredMethods()} and filtered to include only public
2161      *        methods that match given {@code name} and {@code parameterTypes}&lt;/li&gt;
2162      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2163      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2164      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2165      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2166      *   &lt;/ol&gt;&lt;/li&gt;
2167      * &lt;li&gt; This union is partitioned into subsets of methods with same
2168      *      return type (the selection of methods from step 1 also guarantees that
2169      *      they have the same method name and parameter types).&lt;/li&gt;
2170      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2171      *      Let method M be a method from a set of methods with same VM
2172      *      signature (return type, name, parameter types).
2173      *      M is most specific if there is no such method N != M from the same
2174      *      set, such that N is more specific than M. N is more specific than M
2175      *      if:
2176      *   &lt;ol type=&quot;a&quot;&gt;
2177      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2178      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2179      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2180      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2181      *        M and N are the same method).&lt;/li&gt;
2182      *   &lt;/ol&gt;&lt;/li&gt;
2183      * &lt;li&gt; The result of this algorithm is chosen arbitrarily from the methods
2184      *      with most specific return type among all selected methods from step 3.
2185      *      Let R be a return type of a method M from the set of all selected methods
2186      *      from step 3. M is a method with most specific return type if there is
2187      *      no such method N != M from the same set, having return type S != R,
2188      *      such that S is a subtype of R as determined by
2189      *      R.class.{@link #isAssignableFrom}(S.class).
2190      * &lt;/ol&gt;
2191      *
2192      * @apiNote There may be more than one method with matching name and
2193      * parameter types in a class because while the Java language forbids a
2194      * class to declare multiple methods with the same signature but different
2195      * return types, the Java virtual machine does not.  This
2196      * increased flexibility in the virtual machine can be used to
2197      * implement various language features.  For example, covariant
2198      * returns can be implemented with {@linkplain
2199      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2200      * method and the overriding method would have the same
2201      * signature but different return types. This method would return the
2202      * overriding method as it would have a more specific return type.
2203      *
2204      * @param name the name of the method
2205      * @param parameterTypes the list of parameters
2206      * @return the {@code Method} object that matches the specified
2207      *         {@code name} and {@code parameterTypes}
2208      * @throws NoSuchMethodException if a matching method is not found
2209      *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
2210      * @throws NullPointerException if {@code name} is {@code null}
2211      * @throws SecurityException
2212      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2213      *         the caller&#39;s class loader is not the same as or an
2214      *         ancestor of the class loader for the current class and
2215      *         invocation of {@link SecurityManager#checkPackageAccess
2216      *         s.checkPackageAccess()} denies access to the package
2217      *         of this class.
2218      *
2219      * @jls 8.2 Class Members
2220      * @jls 8.4 Method Declarations
2221      * @since 1.1
2222      */
2223     @CallerSensitive
2224     public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
2225         throws NoSuchMethodException, SecurityException {
2226         Objects.requireNonNull(name);
2227         SecurityManager sm = System.getSecurityManager();
2228         if (sm != null) {
2229             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2230         }
2231         Method method = getMethod0(name, parameterTypes);
2232         if (method == null) {
2233             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2234         }
2235         return getReflectionFactory().copyMethod(method);
2236     }
2237 
2238     /**
2239      * Returns a {@code Constructor} object that reflects the specified
2240      * public constructor of the class represented by this {@code Class}
2241      * object. The {@code parameterTypes} parameter is an array of
2242      * {@code Class} objects that identify the constructor&#39;s formal
2243      * parameter types, in declared order.
2244      *
2245      * If this {@code Class} object represents an inner class
2246      * declared in a non-static context, the formal parameter types
2247      * include the explicit enclosing instance as the first parameter.
2248      *
2249      * &lt;p&gt; The constructor to reflect is the public constructor of the class
2250      * represented by this {@code Class} object whose formal parameter
2251      * types match those specified by {@code parameterTypes}.
2252      *
2253      * @param parameterTypes the parameter array
2254      * @return the {@code Constructor} object of the public constructor that
2255      *         matches the specified {@code parameterTypes}
2256      * @throws NoSuchMethodException if a matching method is not found.
2257      * @throws SecurityException
2258      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2259      *         the caller&#39;s class loader is not the same as or an
2260      *         ancestor of the class loader for the current class and
2261      *         invocation of {@link SecurityManager#checkPackageAccess
2262      *         s.checkPackageAccess()} denies access to the package
2263      *         of this class.
2264      *
2265      * @since 1.1
2266      */
2267     @CallerSensitive
2268     public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
2269         throws NoSuchMethodException, SecurityException
2270     {
2271         SecurityManager sm = System.getSecurityManager();
2272         if (sm != null) {
2273             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2274         }
2275         return getReflectionFactory().copyConstructor(
2276             getConstructor0(parameterTypes, Member.PUBLIC));
2277     }
2278 
2279 
2280     /**
2281      * Returns an array of {@code Class} objects reflecting all the
2282      * classes and interfaces declared as members of the class represented by
2283      * this {@code Class} object. This includes public, protected, default
2284      * (package) access, and private classes and interfaces declared by the
2285      * class, but excludes inherited classes and interfaces.  This method
2286      * returns an array of length 0 if the class declares no classes or
2287      * interfaces as members, or if this {@code Class} object represents a
2288      * primitive type, an array class, or void.
2289      *
2290      * @return the array of {@code Class} objects representing all the
2291      *         declared members of this class
2292      * @throws SecurityException
2293      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2294      *         following conditions is met:
2295      *
2296      *         &lt;ul&gt;
2297      *
2298      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
2299      *         class loader of this class and invocation of
2300      *         {@link SecurityManager#checkPermission
2301      *         s.checkPermission} method with
2302      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2303      *         denies access to the declared classes within this class
2304      *
2305      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
2306      *         ancestor of the class loader for the current class and
2307      *         invocation of {@link SecurityManager#checkPackageAccess
2308      *         s.checkPackageAccess()} denies access to the package
2309      *         of this class
2310      *
2311      *         &lt;/ul&gt;
2312      *
2313      * @since 1.1
2314      */
2315     @CallerSensitive
2316     public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
2317         SecurityManager sm = System.getSecurityManager();
2318         if (sm != null) {
2319             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);
2320         }
2321         return getDeclaredClasses0();
2322     }
2323 
2324 
2325     /**
2326      * Returns an array of {@code Field} objects reflecting all the fields
2327      * declared by the class or interface represented by this
2328      * {@code Class} object. This includes public, protected, default
2329      * (package) access, and private fields, but excludes inherited fields.
2330      *
2331      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2332      * declared fields, then this method returns an array of length 0.
2333      *
2334      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2335      * type, or void, then this method returns an array of length 0.
2336      *
2337      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2338      * particular order.
2339      *
2340      * @return  the array of {@code Field} objects representing all the
2341      *          declared fields of this class
2342      * @throws  SecurityException
2343      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2344      *          following conditions is met:
2345      *
2346      *          &lt;ul&gt;
2347      *
2348      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2349      *          class loader of this class and invocation of
2350      *          {@link SecurityManager#checkPermission
2351      *          s.checkPermission} method with
2352      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2353      *          denies access to the declared fields within this class
2354      *
2355      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2356      *          ancestor of the class loader for the current class and
2357      *          invocation of {@link SecurityManager#checkPackageAccess
2358      *          s.checkPackageAccess()} denies access to the package
2359      *          of this class
2360      *
2361      *          &lt;/ul&gt;
2362      *
2363      * @since 1.1
2364      * @jls 8.2 Class Members
2365      * @jls 8.3 Field Declarations
2366      */
2367     @CallerSensitive
2368     public Field[] getDeclaredFields() throws SecurityException {
2369         SecurityManager sm = System.getSecurityManager();
2370         if (sm != null) {
2371             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2372         }
2373         return copyFields(privateGetDeclaredFields(false));
2374     }
2375 
2376     /**
2377      * {@preview Associated with records, a preview feature of the Java language.
2378      *
2379      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
2380      *           feature of the Java language. Preview features
2381      *           may be removed in a future release, or upgraded to permanent
2382      *           features of the Java language.}
2383      *
2384      * Returns an array of {@code RecordComponent} objects representing all the
2385      * record components of this record class, or {@code null} if this class is
2386      * not a record class.
2387      *
2388      * &lt;p&gt; The components are returned in the same order that they are declared
2389      * in the record header. The array is empty if this record class has no
2390      * components. If the class is not a record class, that is {@link
2391      * #isRecord()} returns {@code false}, then this method returns {@code null}.
2392      * Conversely, if {@link #isRecord()} returns {@code true}, then this method
2393      * returns a non-null value.
2394      *
2395      * @return  An array of {@code RecordComponent} objects representing all the
2396      *          record components of this record class, or {@code null} if this
2397      *          class is not a record class
2398      * @throws  SecurityException
2399      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2400      *          following conditions is met:
2401      *
2402      *          &lt;ul&gt;
2403      *
2404      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2405      *          class loader of this class and invocation of
2406      *          {@link SecurityManager#checkPermission
2407      *          s.checkPermission} method with
2408      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2409      *          denies access to the declared methods within this class
2410      *
2411      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2412      *          ancestor of the class loader for the current class and
2413      *          invocation of {@link SecurityManager#checkPackageAccess
2414      *          s.checkPackageAccess()} denies access to the package
2415      *          of this class
2416      *
2417      *          &lt;/ul&gt;
2418      *
2419      * @jls 8.10 Record Types
2420      * @since 14
2421      */
2422     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
2423                                  essentialAPI=false)
2424     @SuppressWarnings(&quot;preview&quot;)
2425     @CallerSensitive
2426     public RecordComponent[] getRecordComponents() {
2427         SecurityManager sm = System.getSecurityManager();
2428         if (sm != null) {
2429             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2430         }
2431         if (!isRecord()) {
2432             return null;
2433         }
2434         RecordComponent[] recordComponents = getRecordComponents0();
2435         if (recordComponents == null) {
2436             return new RecordComponent[0];
2437         }
2438         return recordComponents;
2439     }
2440 
2441     /**
2442      * Returns an array containing {@code Method} objects reflecting all the
2443      * declared methods of the class or interface represented by this {@code
2444      * Class} object, including public, protected, default (package)
2445      * access, and private methods, but excluding inherited methods.
2446      *
2447      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2448      * declared methods with the same name and parameter types, but different
2449      * return types, then the returned array has a {@code Method} object for
2450      * each such method.
2451      *
2452      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2453      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2454      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2455      *
2456      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2457      * declared methods, then the returned array has length 0.
2458      *
2459      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2460      * type, or void, then the returned array has length 0.
2461      *
2462      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2463      * particular order.
2464      *
2465      * @return  the array of {@code Method} objects representing all the
2466      *          declared methods of this class
2467      * @throws  SecurityException
2468      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2469      *          following conditions is met:
2470      *
2471      *          &lt;ul&gt;
2472      *
2473      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2474      *          class loader of this class and invocation of
2475      *          {@link SecurityManager#checkPermission
2476      *          s.checkPermission} method with
2477      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2478      *          denies access to the declared methods within this class
2479      *
2480      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2481      *          ancestor of the class loader for the current class and
2482      *          invocation of {@link SecurityManager#checkPackageAccess
2483      *          s.checkPackageAccess()} denies access to the package
2484      *          of this class
2485      *
2486      *          &lt;/ul&gt;
2487      *
2488      * @jls 8.2 Class Members
2489      * @jls 8.4 Method Declarations
2490      * @since 1.1
2491      */
2492     @CallerSensitive
2493     public Method[] getDeclaredMethods() throws SecurityException {
2494         SecurityManager sm = System.getSecurityManager();
2495         if (sm != null) {
2496             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2497         }
2498         return copyMethods(privateGetDeclaredMethods(false));
2499     }
2500 
2501 
2502     /**
2503      * Returns an array of {@code Constructor} objects reflecting all the
2504      * constructors declared by the class represented by this
2505      * {@code Class} object. These are public, protected, default
2506      * (package) access, and private constructors.  The elements in the array
2507      * returned are not sorted and are not in any particular order.  If the
2508      * class has a default constructor, it is included in the returned array.
2509      * This method returns an array of length 0 if this {@code Class}
2510      * object represents an interface, a primitive type, an array class, or
2511      * void.
2512      *
2513      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
2514      * section {@jls 8.2}.
2515      *
2516      * @return  the array of {@code Constructor} objects representing all the
2517      *          declared constructors of this class
2518      * @throws  SecurityException
2519      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2520      *          following conditions is met:
2521      *
2522      *          &lt;ul&gt;
2523      *
2524      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2525      *          class loader of this class and invocation of
2526      *          {@link SecurityManager#checkPermission
2527      *          s.checkPermission} method with
2528      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2529      *          denies access to the declared constructors within this class
2530      *
2531      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2532      *          ancestor of the class loader for the current class and
2533      *          invocation of {@link SecurityManager#checkPackageAccess
2534      *          s.checkPackageAccess()} denies access to the package
2535      *          of this class
2536      *
2537      *          &lt;/ul&gt;
2538      *
2539      * @since 1.1
2540      */
2541     @CallerSensitive
2542     public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
2543         SecurityManager sm = System.getSecurityManager();
2544         if (sm != null) {
2545             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2546         }
2547         return copyConstructors(privateGetDeclaredConstructors(false));
2548     }
2549 
2550 
2551     /**
2552      * Returns a {@code Field} object that reflects the specified declared
2553      * field of the class or interface represented by this {@code Class}
2554      * object. The {@code name} parameter is a {@code String} that specifies
2555      * the simple name of the desired field.
2556      *
2557      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2558      * method does not find the {@code length} field of the array type.
2559      *
2560      * @param name the name of the field
2561      * @return  the {@code Field} object for the specified field in this
2562      *          class
2563      * @throws  NoSuchFieldException if a field with the specified name is
2564      *          not found.
2565      * @throws  NullPointerException if {@code name} is {@code null}
2566      * @throws  SecurityException
2567      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2568      *          following conditions is met:
2569      *
2570      *          &lt;ul&gt;
2571      *
2572      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2573      *          class loader of this class and invocation of
2574      *          {@link SecurityManager#checkPermission
2575      *          s.checkPermission} method with
2576      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2577      *          denies access to the declared field
2578      *
2579      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2580      *          ancestor of the class loader for the current class and
2581      *          invocation of {@link SecurityManager#checkPackageAccess
2582      *          s.checkPackageAccess()} denies access to the package
2583      *          of this class
2584      *
2585      *          &lt;/ul&gt;
2586      *
2587      * @since 1.1
2588      * @jls 8.2 Class Members
2589      * @jls 8.3 Field Declarations
2590      */
2591     @CallerSensitive
2592     public Field getDeclaredField(String name)
2593         throws NoSuchFieldException, SecurityException {
2594         Objects.requireNonNull(name);
2595         SecurityManager sm = System.getSecurityManager();
2596         if (sm != null) {
2597             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2598         }
2599         Field field = searchFields(privateGetDeclaredFields(false), name);
2600         if (field == null) {
2601             throw new NoSuchFieldException(name);
2602         }
2603         return getReflectionFactory().copyField(field);
2604     }
2605 
2606 
2607     /**
2608      * Returns a {@code Method} object that reflects the specified
2609      * declared method of the class or interface represented by this
2610      * {@code Class} object. The {@code name} parameter is a
2611      * {@code String} that specifies the simple name of the desired
2612      * method, and the {@code parameterTypes} parameter is an array of
2613      * {@code Class} objects that identify the method&#39;s formal parameter
2614      * types, in declared order.  If more than one method with the same
2615      * parameter types is declared in a class, and one of these methods has a
2616      * return type that is more specific than any of the others, that method is
2617      * returned; otherwise one of the methods is chosen arbitrarily.  If the
2618      * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}
2619      * is raised.
2620      *
2621      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2622      * method does not find the {@code clone()} method.
2623      *
2624      * @param name the name of the method
2625      * @param parameterTypes the parameter array
2626      * @return  the {@code Method} object for the method of this class
2627      *          matching the specified name and parameters
2628      * @throws  NoSuchMethodException if a matching method is not found.
2629      * @throws  NullPointerException if {@code name} is {@code null}
2630      * @throws  SecurityException
2631      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2632      *          following conditions is met:
2633      *
2634      *          &lt;ul&gt;
2635      *
2636      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2637      *          class loader of this class and invocation of
2638      *          {@link SecurityManager#checkPermission
2639      *          s.checkPermission} method with
2640      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2641      *          denies access to the declared method
2642      *
2643      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2644      *          ancestor of the class loader for the current class and
2645      *          invocation of {@link SecurityManager#checkPackageAccess
2646      *          s.checkPackageAccess()} denies access to the package
2647      *          of this class
2648      *
2649      *          &lt;/ul&gt;
2650      *
2651      * @jls 8.2 Class Members
2652      * @jls 8.4 Method Declarations
2653      * @since 1.1
2654      */
2655     @CallerSensitive
2656     public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
2657         throws NoSuchMethodException, SecurityException {
2658         Objects.requireNonNull(name);
2659         SecurityManager sm = System.getSecurityManager();
2660         if (sm != null) {
2661             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2662         }
2663         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
2664         if (method == null) {
2665             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2666         }
2667         return getReflectionFactory().copyMethod(method);
2668     }
2669 
2670     /**
2671      * Returns the list of {@code Method} objects for the declared public
2672      * methods of this class or interface that have the specified method name
2673      * and parameter types.
2674      *
2675      * @param name the name of the method
2676      * @param parameterTypes the parameter array
2677      * @return the list of {@code Method} objects for the public methods of
2678      *         this class matching the specified name and parameters
2679      */
2680     List&lt;Method&gt; getDeclaredPublicMethods(String name, Class&lt;?&gt;... parameterTypes) {
2681         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
2682         ReflectionFactory factory = getReflectionFactory();
2683         List&lt;Method&gt; result = new ArrayList&lt;&gt;();
2684         for (Method method : methods) {
2685             if (method.getName().equals(name)
2686                 &amp;&amp; Arrays.equals(
2687                     factory.getExecutableSharedParameterTypes(method),
2688                     parameterTypes)) {
2689                 result.add(factory.copyMethod(method));
2690             }
2691         }
2692         return result;
2693     }
2694 
2695     /**
2696      * Returns a {@code Constructor} object that reflects the specified
2697      * constructor of the class or interface represented by this
2698      * {@code Class} object.  The {@code parameterTypes} parameter is
2699      * an array of {@code Class} objects that identify the constructor&#39;s
2700      * formal parameter types, in declared order.
2701      *
2702      * If this {@code Class} object represents an inner class
2703      * declared in a non-static context, the formal parameter types
2704      * include the explicit enclosing instance as the first parameter.
2705      *
2706      * @param parameterTypes the parameter array
2707      * @return  The {@code Constructor} object for the constructor with the
2708      *          specified parameter list
2709      * @throws  NoSuchMethodException if a matching method is not found.
2710      * @throws  SecurityException
2711      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2712      *          following conditions is met:
2713      *
2714      *          &lt;ul&gt;
2715      *
2716      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2717      *          class loader of this class and invocation of
2718      *          {@link SecurityManager#checkPermission
2719      *          s.checkPermission} method with
2720      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2721      *          denies access to the declared constructor
2722      *
2723      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2724      *          ancestor of the class loader for the current class and
2725      *          invocation of {@link SecurityManager#checkPackageAccess
2726      *          s.checkPackageAccess()} denies access to the package
2727      *          of this class
2728      *
2729      *          &lt;/ul&gt;
2730      *
2731      * @since 1.1
2732      */
2733     @CallerSensitive
2734     public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
2735         throws NoSuchMethodException, SecurityException
2736     {
2737         SecurityManager sm = System.getSecurityManager();
2738         if (sm != null) {
2739             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2740         }
2741 
2742         return getReflectionFactory().copyConstructor(
2743             getConstructor0(parameterTypes, Member.DECLARED));
2744     }
2745 
2746     /**
2747      * Finds a resource with a given name.
2748      *
2749      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2750      * will attempt to find the resource in the module. This is done by
2751      * delegating to the module&#39;s class loader {@link
2752      * ClassLoader#findResource(String,String) findResource(String,String)}
2753      * method, invoking it with the module name and the absolute name of the
2754      * resource. Resources in named modules are subject to the rules for
2755      * encapsulation specified in the {@code Module} {@link
2756      * Module#getResourceAsStream getResourceAsStream} method and so this
2757      * method returns {@code null} when the resource is a
2758      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2759      * caller&#39;s module.
2760      *
2761      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2762      * searching resources associated with a given class are implemented by the
2763      * defining {@linkplain ClassLoader class loader} of the class.  This method
2764      * delegates to this {@code Class} object&#39;s class loader.
2765      * If this {@code Class} object was loaded by the bootstrap class loader,
2766      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.
2767      *
2768      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2769      * given resource name using this algorithm:
2770      *
2771      * &lt;ul&gt;
2772      *
2773      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2774      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2775      * portion of the {@code name} following the {@code &#39;/&#39;}.
2776      *
2777      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2778      *
2779      * &lt;blockquote&gt;
2780      *   {@code modified_package_name/name}
2781      * &lt;/blockquote&gt;
2782      *
2783      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2784      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2785      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2786      *
2787      * &lt;/ul&gt;
2788      *
2789      * @param  name name of the desired resource
2790      * @return  A {@link java.io.InputStream} object; {@code null} if no
2791      *          resource with this name is found, the resource is in a package
2792      *          that is not {@linkplain Module#isOpen(String, Module) open} to at
2793      *          least the caller module, or access to the resource is denied
2794      *          by the security manager.
2795      * @throws  NullPointerException If {@code name} is {@code null}
2796      *
2797      * @see Module#getResourceAsStream(String)
2798      * @since  1.1
2799      * @revised 9
2800      * @spec JPMS
2801      */
2802     @CallerSensitive
2803     public InputStream getResourceAsStream(String name) {
2804         name = resolveName(name);
2805 
2806         Module thisModule = getModule();
2807         if (thisModule.isNamed()) {
2808             // check if resource can be located by caller
2809             if (Resources.canEncapsulate(name)
2810                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2811                 return null;
2812             }
2813 
2814             // resource not encapsulated or in package open to caller
2815             String mn = thisModule.getName();
2816             ClassLoader cl = getClassLoader0();
2817             try {
2818 
2819                 // special-case built-in class loaders to avoid the
2820                 // need for a URL connection
2821                 if (cl == null) {
2822                     return BootLoader.findResourceAsStream(mn, name);
2823                 } else if (cl instanceof BuiltinClassLoader) {
2824                     return ((BuiltinClassLoader) cl).findResourceAsStream(mn, name);
2825                 } else {
2826                     URL url = cl.findResource(mn, name);
2827                     return (url != null) ? url.openStream() : null;
2828                 }
2829 
2830             } catch (IOException | SecurityException e) {
2831                 return null;
2832             }
2833         }
2834 
2835         // unnamed module
2836         ClassLoader cl = getClassLoader0();
2837         if (cl == null) {
2838             return ClassLoader.getSystemResourceAsStream(name);
2839         } else {
2840             return cl.getResourceAsStream(name);
2841         }
2842     }
2843 
2844     /**
2845      * Finds a resource with a given name.
2846      *
2847      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2848      * will attempt to find the resource in the module. This is done by
2849      * delegating to the module&#39;s class loader {@link
2850      * ClassLoader#findResource(String,String) findResource(String,String)}
2851      * method, invoking it with the module name and the absolute name of the
2852      * resource. Resources in named modules are subject to the rules for
2853      * encapsulation specified in the {@code Module} {@link
2854      * Module#getResourceAsStream getResourceAsStream} method and so this
2855      * method returns {@code null} when the resource is a
2856      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2857      * caller&#39;s module.
2858      *
2859      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2860      * searching resources associated with a given class are implemented by the
2861      * defining {@linkplain ClassLoader class loader} of the class.  This method
2862      * delegates to this {@code Class} object&#39;s class loader.
2863      * If this {@code Class} object was loaded by the bootstrap class loader,
2864      * the method delegates to {@link ClassLoader#getSystemResource}.
2865      *
2866      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2867      * given resource name using this algorithm:
2868      *
2869      * &lt;ul&gt;
2870      *
2871      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2872      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2873      * portion of the {@code name} following the {@code &#39;/&#39;}.
2874      *
2875      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2876      *
2877      * &lt;blockquote&gt;
2878      *   {@code modified_package_name/name}
2879      * &lt;/blockquote&gt;
2880      *
2881      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2882      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2883      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2884      *
2885      * &lt;/ul&gt;
2886      *
2887      * @param  name name of the desired resource
2888      * @return A {@link java.net.URL} object; {@code null} if no resource with
2889      *         this name is found, the resource cannot be located by a URL, the
2890      *         resource is in a package that is not
2891      *         {@linkplain Module#isOpen(String, Module) open} to at least the caller
2892      *         module, or access to the resource is denied by the security
2893      *         manager.
2894      * @throws NullPointerException If {@code name} is {@code null}
2895      * @since  1.1
2896      * @revised 9
2897      * @spec JPMS
2898      */
2899     @CallerSensitive
2900     public URL getResource(String name) {
2901         name = resolveName(name);
2902 
2903         Module thisModule = getModule();
2904         if (thisModule.isNamed()) {
2905             // check if resource can be located by caller
2906             if (Resources.canEncapsulate(name)
2907                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2908                 return null;
2909             }
2910 
2911             // resource not encapsulated or in package open to caller
2912             String mn = thisModule.getName();
2913             ClassLoader cl = getClassLoader0();
2914             try {
2915                 if (cl == null) {
2916                     return BootLoader.findResource(mn, name);
2917                 } else {
2918                     return cl.findResource(mn, name);
2919                 }
2920             } catch (IOException ioe) {
2921                 return null;
2922             }
2923         }
2924 
2925         // unnamed module
2926         ClassLoader cl = getClassLoader0();
2927         if (cl == null) {
2928             return ClassLoader.getSystemResource(name);
2929         } else {
2930             return cl.getResource(name);
2931         }
2932     }
2933 
2934     /**
2935      * Returns true if a resource with the given name can be located by the
2936      * given caller. All resources in a module can be located by code in
2937      * the module. For other callers, then the package needs to be open to
2938      * the caller.
2939      */
2940     private boolean isOpenToCaller(String name, Class&lt;?&gt; caller) {
2941         // assert getModule().isNamed();
2942         Module thisModule = getModule();
2943         Module callerModule = (caller != null) ? caller.getModule() : null;
2944         if (callerModule != thisModule) {
2945             String pn = Resources.toPackageName(name);
2946             if (thisModule.getDescriptor().packages().contains(pn)) {
2947                 if (callerModule == null &amp;&amp; !thisModule.isOpen(pn)) {
2948                     // no caller, package not open
2949                     return false;
2950                 }
2951                 if (!thisModule.isOpen(pn, callerModule)) {
2952                     // package not open to caller
2953                     return false;
2954                 }
2955             }
2956         }
2957         return true;
2958     }
2959 
2960 
2961     /** protection domain returned when the internal domain is null */
2962     private static java.security.ProtectionDomain allPermDomain;
2963 
2964     /**
2965      * Returns the {@code ProtectionDomain} of this class.  If there is a
2966      * security manager installed, this method first calls the security
2967      * manager&#39;s {@code checkPermission} method with a
2968      * {@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
2969      * ensure it&#39;s ok to get the
2970      * {@code ProtectionDomain}.
2971      *
2972      * @return the ProtectionDomain of this class
2973      *
2974      * @throws SecurityException
2975      *        if a security manager exists and its
2976      *        {@code checkPermission} method doesn&#39;t allow
2977      *        getting the ProtectionDomain.
2978      *
2979      * @see java.security.ProtectionDomain
2980      * @see SecurityManager#checkPermission
2981      * @see java.lang.RuntimePermission
2982      * @since 1.2
2983      */
2984     public java.security.ProtectionDomain getProtectionDomain() {
2985         SecurityManager sm = System.getSecurityManager();
2986         if (sm != null) {
2987             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
2988         }
2989         java.security.ProtectionDomain pd = getProtectionDomain0();
2990         if (pd == null) {
2991             if (allPermDomain == null) {
2992                 java.security.Permissions perms =
2993                     new java.security.Permissions();
2994                 perms.add(SecurityConstants.ALL_PERMISSION);
2995                 allPermDomain =
2996                     new java.security.ProtectionDomain(null, perms);
2997             }
2998             pd = allPermDomain;
2999         }
3000         return pd;
3001     }
3002 
3003 
3004     /**
3005      * Returns the ProtectionDomain of this class.
3006      */
3007     private native java.security.ProtectionDomain getProtectionDomain0();
3008 
3009     /*
3010      * Return the Virtual Machine&#39;s Class object for the named
3011      * primitive type.
3012      */
3013     static native Class&lt;?&gt; getPrimitiveClass(String name);
3014 
3015     /*
3016      * Check if client is allowed to access members.  If access is denied,
3017      * throw a SecurityException.
3018      *
3019      * This method also enforces package access.
3020      *
3021      * &lt;p&gt; Default policy: allow all clients access with normal Java access
3022      * control.
3023      *
3024      * &lt;p&gt; NOTE: should only be called if a SecurityManager is installed
3025      */
3026     private void checkMemberAccess(SecurityManager sm, int which,
3027                                    Class&lt;?&gt; caller, boolean checkProxyInterfaces) {
3028         /* Default policy allows access to all {@link Member#PUBLIC} members,
3029          * as well as access to classes that have the same class loader as the caller.
3030          * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
3031          * permission.
3032          */
3033         final ClassLoader ccl = ClassLoader.getClassLoader(caller);
3034         if (which != Member.PUBLIC) {
3035             final ClassLoader cl = getClassLoader0();
3036             if (ccl != cl) {
3037                 sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3038             }
3039         }
3040         this.checkPackageAccess(sm, ccl, checkProxyInterfaces);
3041     }
3042 
3043     /*
3044      * Checks if a client loaded in ClassLoader ccl is allowed to access this
3045      * class under the current package access policy. If access is denied,
3046      * throw a SecurityException.
3047      *
3048      * NOTE: this method should only be called if a SecurityManager is active
3049      */
3050     private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,
3051                                     boolean checkProxyInterfaces) {
3052         final ClassLoader cl = getClassLoader0();
3053 
3054         if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
3055             String pkg = this.getPackageName();
3056             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3057                 // skip the package access check on a proxy class in default proxy package
3058                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3059                     sm.checkPackageAccess(pkg);
3060                 }
3061             }
3062         }
3063         // check package access on the proxy interfaces
3064         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3065             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3066         }
3067     }
3068 
3069     /**
3070      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3071      * if name is absolute
3072      */
3073     private String resolveName(String name) {
3074         if (!name.startsWith(&quot;/&quot;)) {
3075             Class&lt;?&gt; c = this;
3076             while (c.isArray()) {
3077                 c = c.getComponentType();
3078             }
3079             String baseName = c.getPackageName();
3080             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3081                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3082             }
3083         } else {
3084             name = name.substring(1);
3085         }
3086         return name;
3087     }
3088 
3089     /**
3090      * Atomic operations support.
3091      */
3092     private static class Atomic {
3093         // initialize Unsafe machinery here, since we need to call Class.class instance method
3094         // and have to avoid calling it in the static initializer of the Class class...
3095         private static final Unsafe unsafe = Unsafe.getUnsafe();
3096         // offset of Class.reflectionData instance field
3097         private static final long reflectionDataOffset
3098                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
3099         // offset of Class.annotationType instance field
3100         private static final long annotationTypeOffset
3101                 = unsafe.objectFieldOffset(Class.class, &quot;annotationType&quot;);
3102         // offset of Class.annotationData instance field
3103         private static final long annotationDataOffset
3104                 = unsafe.objectFieldOffset(Class.class, &quot;annotationData&quot;);
3105 
3106         static &lt;T&gt; boolean casReflectionData(Class&lt;?&gt; clazz,
3107                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
3108                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) {
3109             return unsafe.compareAndSetReference(clazz, reflectionDataOffset, oldData, newData);
3110         }
3111 
3112         static &lt;T&gt; boolean casAnnotationType(Class&lt;?&gt; clazz,
3113                                              AnnotationType oldType,
3114                                              AnnotationType newType) {
3115             return unsafe.compareAndSetReference(clazz, annotationTypeOffset, oldType, newType);
3116         }
3117 
3118         static &lt;T&gt; boolean casAnnotationData(Class&lt;?&gt; clazz,
3119                                              AnnotationData oldData,
3120                                              AnnotationData newData) {
3121             return unsafe.compareAndSetReference(clazz, annotationDataOffset, oldData, newData);
3122         }
3123     }
3124 
3125     /**
3126      * Reflection support.
3127      */
3128 
3129     // Reflection data caches various derived names and reflective members. Cached
3130     // values may be invalidated when JVM TI RedefineClasses() is called
3131     private static class ReflectionData&lt;T&gt; {
3132         volatile Field[] declaredFields;
3133         volatile Field[] publicFields;
3134         volatile Method[] declaredMethods;
3135         volatile Method[] publicMethods;
3136         volatile Constructor&lt;T&gt;[] declaredConstructors;
3137         volatile Constructor&lt;T&gt;[] publicConstructors;
3138         // Intermediate results for getFields and getMethods
3139         volatile Field[] declaredPublicFields;
3140         volatile Method[] declaredPublicMethods;
3141         volatile Class&lt;?&gt;[] interfaces;
3142 
3143         // Cached names
3144         String simpleName;
3145         String canonicalName;
3146         static final String NULL_SENTINEL = new String();
3147 
3148         // Value of classRedefinedCount when we created this ReflectionData instance
3149         final int redefinedCount;
3150 
3151         ReflectionData(int redefinedCount) {
3152             this.redefinedCount = redefinedCount;
3153         }
3154     }
3155 
3156     private transient volatile SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;
3157 
3158     // Incremented by the VM on each call to JVM TI RedefineClasses()
3159     // that redefines this class or a superclass.
3160     private transient volatile int classRedefinedCount;
3161 
3162     // Lazily create and cache ReflectionData
3163     private ReflectionData&lt;T&gt; reflectionData() {
3164         SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;
3165         int classRedefinedCount = this.classRedefinedCount;
3166         ReflectionData&lt;T&gt; rd;
3167         if (reflectionData != null &amp;&amp;
3168             (rd = reflectionData.get()) != null &amp;&amp;
3169             rd.redefinedCount == classRedefinedCount) {
3170             return rd;
3171         }
3172         // else no SoftReference or cleared SoftReference or stale ReflectionData
3173         // -&gt; create and replace new instance
3174         return newReflectionData(reflectionData, classRedefinedCount);
3175     }
3176 
3177     private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
3178                                                 int classRedefinedCount) {
3179         while (true) {
3180             ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);
3181             // try to CAS it...
3182             if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {
3183                 return rd;
3184             }
3185             // else retry
3186             oldReflectionData = this.reflectionData;
3187             classRedefinedCount = this.classRedefinedCount;
3188             if (oldReflectionData != null &amp;&amp;
3189                 (rd = oldReflectionData.get()) != null &amp;&amp;
3190                 rd.redefinedCount == classRedefinedCount) {
3191                 return rd;
3192             }
3193         }
3194     }
3195 
3196     // Generic signature handling
3197     private native String getGenericSignature0();
3198 
3199     // Generic info repository; lazily initialized
3200     private transient volatile ClassRepository genericInfo;
3201 
3202     // accessor for factory
3203     private GenericsFactory getFactory() {
3204         // create scope and factory
3205         return CoreReflectionFactory.make(this, ClassScope.make(this));
3206     }
3207 
3208     // accessor for generic info repository;
3209     // generic info is lazily initialized
3210     private ClassRepository getGenericInfo() {
3211         ClassRepository genericInfo = this.genericInfo;
3212         if (genericInfo == null) {
3213             String signature = getGenericSignature0();
3214             if (signature == null) {
3215                 genericInfo = ClassRepository.NONE;
3216             } else {
3217                 genericInfo = ClassRepository.make(signature, getFactory());
3218             }
3219             this.genericInfo = genericInfo;
3220         }
3221         return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
3222     }
3223 
3224     // Annotations handling
3225     native byte[] getRawAnnotations();
3226     // Since 1.8
3227     native byte[] getRawTypeAnnotations();
3228     static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
3229         return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
3230     }
3231 
3232     native ConstantPool getConstantPool();
3233 
3234     //
3235     //
3236     // java.lang.reflect.Field handling
3237     //
3238     //
3239 
3240     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3241     // be propagated to the outside world, but must instead be copied
3242     // via ReflectionFactory.copyField.
3243     private Field[] privateGetDeclaredFields(boolean publicOnly) {
3244         Field[] res;
3245         ReflectionData&lt;T&gt; rd = reflectionData();
3246         if (rd != null) {
3247             res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
3248             if (res != null) return res;
3249         }
3250         // No cached value available; request value from VM
3251         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
3252         if (rd != null) {
3253             if (publicOnly) {
3254                 rd.declaredPublicFields = res;
3255             } else {
3256                 rd.declaredFields = res;
3257             }
3258         }
3259         return res;
3260     }
3261 
3262     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3263     // be propagated to the outside world, but must instead be copied
3264     // via ReflectionFactory.copyField.
3265     private Field[] privateGetPublicFields() {
3266         Field[] res;
3267         ReflectionData&lt;T&gt; rd = reflectionData();
3268         if (rd != null) {
3269             res = rd.publicFields;
3270             if (res != null) return res;
3271         }
3272 
3273         // Use a linked hash set to ensure order is preserved and
3274         // fields from common super interfaces are not duplicated
3275         LinkedHashSet&lt;Field&gt; fields = new LinkedHashSet&lt;&gt;();
3276 
3277         // Local fields
3278         addAll(fields, privateGetDeclaredFields(true));
3279 
3280         // Direct superinterfaces, recursively
3281         for (Class&lt;?&gt; si : getInterfaces()) {
3282             addAll(fields, si.privateGetPublicFields());
3283         }
3284 
3285         // Direct superclass, recursively
3286         Class&lt;?&gt; sc = getSuperclass();
3287         if (sc != null) {
3288             addAll(fields, sc.privateGetPublicFields());
3289         }
3290 
3291         res = fields.toArray(new Field[0]);
3292         if (rd != null) {
3293             rd.publicFields = res;
3294         }
3295         return res;
3296     }
3297 
3298     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
3299         for (Field f : o) {
3300             c.add(f);
3301         }
3302     }
3303 
3304 
3305     //
3306     //
3307     // java.lang.reflect.Constructor handling
3308     //
3309     //
3310 
3311     // Returns an array of &quot;root&quot; constructors. These Constructor
3312     // objects must NOT be propagated to the outside world, but must
3313     // instead be copied via ReflectionFactory.copyConstructor.
3314     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
3315         Constructor&lt;T&gt;[] res;
3316         ReflectionData&lt;T&gt; rd = reflectionData();
3317         if (rd != null) {
3318             res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
3319             if (res != null) return res;
3320         }
3321         // No cached value available; request value from VM
3322         if (isInterface()) {
3323             @SuppressWarnings(&quot;unchecked&quot;)
3324             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
3325             res = temporaryRes;
3326         } else {
3327             res = getDeclaredConstructors0(publicOnly);
3328         }
3329         if (rd != null) {
3330             if (publicOnly) {
3331                 rd.publicConstructors = res;
3332             } else {
3333                 rd.declaredConstructors = res;
3334             }
3335         }
3336         return res;
3337     }
3338 
3339     //
3340     //
3341     // java.lang.reflect.Method handling
3342     //
3343     //
3344 
3345     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3346     // be propagated to the outside world, but must instead be copied
3347     // via ReflectionFactory.copyMethod.
3348     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
3349         Method[] res;
3350         ReflectionData&lt;T&gt; rd = reflectionData();
3351         if (rd != null) {
3352             res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
3353             if (res != null) return res;
3354         }
3355         // No cached value available; request value from VM
3356         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
3357         if (rd != null) {
3358             if (publicOnly) {
3359                 rd.declaredPublicMethods = res;
3360             } else {
3361                 rd.declaredMethods = res;
3362             }
3363         }
3364         return res;
3365     }
3366 
3367     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3368     // be propagated to the outside world, but must instead be copied
3369     // via ReflectionFactory.copyMethod.
3370     private Method[] privateGetPublicMethods() {
3371         Method[] res;
3372         ReflectionData&lt;T&gt; rd = reflectionData();
3373         if (rd != null) {
3374             res = rd.publicMethods;
3375             if (res != null) return res;
3376         }
3377 
3378         // No cached value available; compute value recursively.
3379         // Start by fetching public declared methods...
3380         PublicMethods pms = new PublicMethods();
3381         for (Method m : privateGetDeclaredMethods(/* publicOnly */ true)) {
3382             pms.merge(m);
3383         }
3384         // ...then recur over superclass methods...
3385         Class&lt;?&gt; sc = getSuperclass();
3386         if (sc != null) {
3387             for (Method m : sc.privateGetPublicMethods()) {
3388                 pms.merge(m);
3389             }
3390         }
3391         // ...and finally over direct superinterfaces.
3392         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3393             for (Method m : intf.privateGetPublicMethods()) {
3394                 // static interface methods are not inherited
3395                 if (!Modifier.isStatic(m.getModifiers())) {
3396                     pms.merge(m);
3397                 }
3398             }
3399         }
3400 
3401         res = pms.toArray();
3402         if (rd != null) {
3403             rd.publicMethods = res;
3404         }
3405         return res;
3406     }
3407 
3408 
3409     //
3410     // Helpers for fetchers of one field, method, or constructor
3411     //
3412 
3413     // This method does not copy the returned Field object!
3414     private static Field searchFields(Field[] fields, String name) {
3415         for (Field field : fields) {
3416             if (field.getName().equals(name)) {
3417                 return field;
3418             }
3419         }
3420         return null;
3421     }
3422 
3423     // Returns a &quot;root&quot; Field object. This Field object must NOT
3424     // be propagated to the outside world, but must instead be copied
3425     // via ReflectionFactory.copyField.
3426     private Field getField0(String name) {
3427         // Note: the intent is that the search algorithm this routine
3428         // uses be equivalent to the ordering imposed by
3429         // privateGetPublicFields(). It fetches only the declared
3430         // public fields for each class, however, to reduce the number
3431         // of Field objects which have to be created for the common
3432         // case where the field being requested is declared in the
3433         // class which is being queried.
3434         Field res;
3435         // Search declared public fields
3436         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
3437             return res;
3438         }
3439         // Direct superinterfaces, recursively
3440         Class&lt;?&gt;[] interfaces = getInterfaces(/* cloneArray */ false);
3441         for (Class&lt;?&gt; c : interfaces) {
3442             if ((res = c.getField0(name)) != null) {
3443                 return res;
3444             }
3445         }
3446         // Direct superclass, recursively
3447         if (!isInterface()) {
3448             Class&lt;?&gt; c = getSuperclass();
3449             if (c != null) {
3450                 if ((res = c.getField0(name)) != null) {
3451                     return res;
3452                 }
3453             }
3454         }
3455         return null;
3456     }
3457 
3458     // This method does not copy the returned Method object!
3459     private static Method searchMethods(Method[] methods,
3460                                         String name,
3461                                         Class&lt;?&gt;[] parameterTypes)
3462     {
3463         ReflectionFactory fact = getReflectionFactory();
3464         Method res = null;
3465         for (Method m : methods) {
3466             if (m.getName().equals(name)
3467                 &amp;&amp; arrayContentsEq(parameterTypes,
3468                                    fact.getExecutableSharedParameterTypes(m))
3469                 &amp;&amp; (res == null
3470                     || (res.getReturnType() != m.getReturnType()
3471                         &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))
3472                 res = m;
3473         }
3474         return res;
3475     }
3476 
3477     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];
3478 
3479     // Returns a &quot;root&quot; Method object. This Method object must NOT
3480     // be propagated to the outside world, but must instead be copied
3481     // via ReflectionFactory.copyMethod.
3482     private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes) {
3483         PublicMethods.MethodList res = getMethodsRecursive(
3484             name,
3485             parameterTypes == null ? EMPTY_CLASS_ARRAY : parameterTypes,
3486             /* includeStatic */ true);
3487         return res == null ? null : res.getMostSpecific();
3488     }
3489 
3490     // Returns a list of &quot;root&quot; Method objects. These Method objects must NOT
3491     // be propagated to the outside world, but must instead be copied
3492     // via ReflectionFactory.copyMethod.
3493     private PublicMethods.MethodList getMethodsRecursive(String name,
3494                                                          Class&lt;?&gt;[] parameterTypes,
3495                                                          boolean includeStatic) {
3496         // 1st check declared public methods
3497         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
3498         PublicMethods.MethodList res = PublicMethods.MethodList
3499             .filter(methods, name, parameterTypes, includeStatic);
3500         // if there is at least one match among declared methods, we need not
3501         // search any further as such match surely overrides matching methods
3502         // declared in superclass(es) or interface(s).
3503         if (res != null) {
3504             return res;
3505         }
3506 
3507         // if there was no match among declared methods,
3508         // we must consult the superclass (if any) recursively...
3509         Class&lt;?&gt; sc = getSuperclass();
3510         if (sc != null) {
3511             res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);
3512         }
3513 
3514         // ...and coalesce the superclass methods with methods obtained
3515         // from directly implemented interfaces excluding static methods...
3516         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3517             res = PublicMethods.MethodList.merge(
3518                 res, intf.getMethodsRecursive(name, parameterTypes,
3519                                               /* includeStatic */ false));
3520         }
3521 
3522         return res;
3523     }
3524 
3525     // Returns a &quot;root&quot; Constructor object. This Constructor object must NOT
3526     // be propagated to the outside world, but must instead be copied
3527     // via ReflectionFactory.copyConstructor.
3528     private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
3529                                         int which) throws NoSuchMethodException
3530     {
3531         ReflectionFactory fact = getReflectionFactory();
3532         Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
3533         for (Constructor&lt;T&gt; constructor : constructors) {
3534             if (arrayContentsEq(parameterTypes,
3535                                 fact.getExecutableSharedParameterTypes(constructor))) {
3536                 return constructor;
3537             }
3538         }
3539         throw new NoSuchMethodException(methodToString(&quot;&lt;init&gt;&quot;, parameterTypes));
3540     }
3541 
3542     //
3543     // Other helpers and base implementation
3544     //
3545 
3546     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
3547         if (a1 == null) {
3548             return a2 == null || a2.length == 0;
3549         }
3550 
3551         if (a2 == null) {
3552             return a1.length == 0;
3553         }
3554 
3555         if (a1.length != a2.length) {
3556             return false;
3557         }
3558 
3559         for (int i = 0; i &lt; a1.length; i++) {
3560             if (a1[i] != a2[i]) {
3561                 return false;
3562             }
3563         }
3564 
3565         return true;
3566     }
3567 
3568     private static Field[] copyFields(Field[] arg) {
3569         Field[] out = new Field[arg.length];
3570         ReflectionFactory fact = getReflectionFactory();
3571         for (int i = 0; i &lt; arg.length; i++) {
3572             out[i] = fact.copyField(arg[i]);
3573         }
3574         return out;
3575     }
3576 
3577     private static Method[] copyMethods(Method[] arg) {
3578         Method[] out = new Method[arg.length];
3579         ReflectionFactory fact = getReflectionFactory();
3580         for (int i = 0; i &lt; arg.length; i++) {
3581             out[i] = fact.copyMethod(arg[i]);
3582         }
3583         return out;
3584     }
3585 
3586     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3587         Constructor&lt;U&gt;[] out = arg.clone();
3588         ReflectionFactory fact = getReflectionFactory();
3589         for (int i = 0; i &lt; out.length; i++) {
3590             out[i] = fact.copyConstructor(out[i]);
3591         }
3592         return out;
3593     }
3594 
3595     private native Field[]       getDeclaredFields0(boolean publicOnly);
3596     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3597     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3598     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3599     @SuppressWarnings(&quot;preview&quot;)
3600     private native RecordComponent[] getRecordComponents0();
3601     private native boolean      isRecord0();
3602 
3603     /**
3604      * Helper method to get the method name from arguments.
3605      */
3606     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3607         return getName() + &#39;.&#39; + name +
3608                 ((argTypes == null || argTypes.length == 0) ?
3609                 &quot;()&quot; :
3610                 Arrays.stream(argTypes)
<a name="16" id="anc16"></a><span class="line-modified">3611                         .map(c -&gt; c == null ? &quot;null&quot; : c.toTypeName())</span>
3612                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3613     }
3614 
<a name="17" id="anc17"></a><span class="line-removed">3615     /*</span>
<span class="line-removed">3616      * Returns the class name appended with &quot;?&quot; if it is the nullable projection</span>
<span class="line-removed">3617      * of an inline class.</span>
<span class="line-removed">3618      */</span>
<span class="line-removed">3619     private String toTypeName() {</span>
<span class="line-removed">3620         return isInlineClass() &amp;&amp; isIndirectType() ? getName() + &quot;?&quot; : getName();</span>
<span class="line-removed">3621     }</span>
<span class="line-removed">3622 </span>
3623     /** use serialVersionUID from JDK 1.1 for interoperability */
3624     @java.io.Serial
3625     private static final long serialVersionUID = 3206093459760846163L;
3626 
3627 
3628     /**
3629      * Class Class is special cased within the Serialization Stream Protocol.
3630      *
3631      * A Class instance is written initially into an ObjectOutputStream in the
3632      * following format:
3633      * &lt;pre&gt;
3634      *      {@code TC_CLASS} ClassDescriptor
3635      *      A ClassDescriptor is a special cased serialization of
3636      *      a {@code java.io.ObjectStreamClass} instance.
3637      * &lt;/pre&gt;
3638      * A new handle is generated for the initial time the class descriptor
3639      * is written into the stream. Future references to the class descriptor
3640      * are written as references to the initial class descriptor instance.
3641      *
3642      * @see java.io.ObjectStreamClass
3643      */
3644     @java.io.Serial
3645     private static final ObjectStreamField[] serialPersistentFields =
3646         new ObjectStreamField[0];
3647 
3648 
3649     /**
3650      * Returns the assertion status that would be assigned to this
3651      * class if it were to be initialized at the time this method is invoked.
3652      * If this class has had its assertion status set, the most recent
3653      * setting will be returned; otherwise, if any package default assertion
3654      * status pertains to this class, the most recent setting for the most
3655      * specific pertinent package default assertion status is returned;
3656      * otherwise, if this class is not a system class (i.e., it has a
3657      * class loader) its class loader&#39;s default assertion status is returned;
3658      * otherwise, the system class default assertion status is returned.
3659      *
3660      * @apiNote
3661      * Few programmers will have any need for this method; it is provided
3662      * for the benefit of the JDK itself.  (It allows a class to determine at
3663      * the time that it is initialized whether assertions should be enabled.)
3664      * Note that this method is not guaranteed to return the actual
3665      * assertion status that was (or will be) associated with the specified
3666      * class when it was (or will be) initialized.
3667      *
3668      * @return the desired assertion status of the specified class.
3669      * @see    java.lang.ClassLoader#setClassAssertionStatus
3670      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3671      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3672      * @since  1.4
3673      */
3674     public boolean desiredAssertionStatus() {
3675         ClassLoader loader = getClassLoader0();
3676         // If the loader is null this is a system class, so ask the VM
3677         if (loader == null)
3678             return desiredAssertionStatus0(this);
3679 
3680         // If the classloader has been initialized with the assertion
3681         // directives, ask it. Otherwise, ask the VM.
3682         synchronized(loader.assertionLock) {
3683             if (loader.classAssertionStatus != null) {
3684                 return loader.desiredAssertionStatus(getName());
3685             }
3686         }
3687         return desiredAssertionStatus0(this);
3688     }
3689 
3690     // Retrieves the desired assertion status of this class from the VM
3691     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3692 
3693     /**
3694      * Returns true if and only if this class was declared as an enum in the
3695      * source code.
3696      *
3697      * Note that {@link java.lang.Enum} is not itself an enum type.
3698      *
3699      * Also note that if an enum constant is declared with a class body,
3700      * the class of that enum constant object is an anonymous class
3701      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The
3702      * {@link Enum#getDeclaringClass} method of an enum constant can
3703      * be used to get the class of the enum type declaring the
3704      * constant.
3705      *
3706      * @return true if and only if this class was declared as an enum in the
3707      *     source code
3708      * @since 1.5
3709      * @jls 8.9.1 Enum Constants
3710      */
3711     public boolean isEnum() {
3712         // An enum must both directly extend java.lang.Enum and have
3713         // the ENUM bit set; classes for specialized enum constants
3714         // don&#39;t do the former.
3715         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3716         this.getSuperclass() == java.lang.Enum.class;
3717     }
3718 
3719     /** java.lang.Record.class */
3720     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();
3721     private static Class&lt;?&gt; javaLangRecordClass() {
3722         try {
3723             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);
3724         } catch (ClassNotFoundException e) {
3725             throw new InternalError(&quot;should not reach here&quot;, e);
3726         }
3727     }
3728 
3729     /**
3730      * {@preview Associated with records, a preview feature of the Java language.
3731      *
3732      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
3733      *           feature of the Java language. Preview features
3734      *           may be removed in a future release, or upgraded to permanent
3735      *           features of the Java language.}
3736      *
3737      * Returns {@code true} if and only if this class is a record class.
3738      *
3739      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record
3740      * class is {@code java.lang.Record}. A record class has (possibly zero)
3741      * record components, that is, {@link #getRecordComponents()} returns a
3742      * non-null value.
3743      *
3744      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking
3745      * this method on class {@code Record} returns {@code false}.
3746      *
3747      * @return true if and only if this class is a record class, otherwise false
3748      * @jls 8.10 Record Types
3749      * @since 14
3750      */
3751     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
3752                                  essentialAPI=false)
3753     public boolean isRecord() {
3754         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3755     }
3756 
3757     // Fetches the factory for reflective objects
3758     private static ReflectionFactory getReflectionFactory() {
3759         if (reflectionFactory == null) {
3760             reflectionFactory =
3761                 java.security.AccessController.doPrivileged
3762                     (new ReflectionFactory.GetReflectionFactoryAction());
3763         }
3764         return reflectionFactory;
3765     }
3766     private static ReflectionFactory reflectionFactory;
3767 
3768     /**
3769      * Returns the elements of this enum class or null if this
3770      * Class object does not represent an enum type.
3771      *
3772      * @return an array containing the values comprising the enum class
3773      *     represented by this {@code Class} object in the order they&#39;re
3774      *     declared, or null if this {@code Class} object does not
3775      *     represent an enum type
3776      * @since 1.5
3777      */
3778     public T[] getEnumConstants() {
3779         T[] values = getEnumConstantsShared();
3780         return (values != null) ? values.clone() : null;
3781     }
3782 
3783     /**
3784      * Returns the elements of this enum class or null if this
3785      * Class object does not represent an enum type;
3786      * identical to getEnumConstants except that the result is
3787      * uncloned, cached, and shared by all callers.
3788      */
3789     T[] getEnumConstantsShared() {
3790         T[] constants = enumConstants;
3791         if (constants == null) {
3792             if (!isEnum()) return null;
3793             try {
3794                 final Method values = getMethod(&quot;values&quot;);
3795                 java.security.AccessController.doPrivileged(
3796                     new java.security.PrivilegedAction&lt;&gt;() {
3797                         public Void run() {
3798                                 values.setAccessible(true);
3799                                 return null;
3800                             }
3801                         });
3802                 @SuppressWarnings(&quot;unchecked&quot;)
3803                 T[] temporaryConstants = (T[])values.invoke(null);
3804                 enumConstants = constants = temporaryConstants;
3805             }
3806             // These can happen when users concoct enum-like classes
3807             // that don&#39;t comply with the enum spec.
3808             catch (InvocationTargetException | NoSuchMethodException |
3809                    IllegalAccessException ex) { return null; }
3810         }
3811         return constants;
3812     }
3813     private transient volatile T[] enumConstants;
3814 
3815     /**
3816      * Returns a map from simple name to enum constant.  This package-private
3817      * method is used internally by Enum to implement
3818      * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
3819      * efficiently.  Note that the map is returned by this method is
3820      * created lazily on first use.  Typically it won&#39;t ever get created.
3821      */
3822     Map&lt;String, T&gt; enumConstantDirectory() {
3823         Map&lt;String, T&gt; directory = enumConstantDirectory;
3824         if (directory == null) {
3825             T[] universe = getEnumConstantsShared();
3826             if (universe == null)
3827                 throw new IllegalArgumentException(
3828                     getName() + &quot; is not an enum type&quot;);
3829             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3830             for (T constant : universe) {
3831                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3832             }
3833             enumConstantDirectory = directory;
3834         }
3835         return directory;
3836     }
3837     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3838 
3839     /**
3840      * Casts an object to the class or interface represented
3841      * by this {@code Class} object.
3842      *
3843      * @param obj the object to be cast
3844      * @return the object after casting, or null if obj is null
3845      *
3846      * @throws ClassCastException if the object is not
3847      * {@code null} and is not assignable to the type T.
<a name="18" id="anc18"></a><span class="line-modified">3848      * @throws NullPointerException if this is not a {@linkplain #isNullableType()</span>
<span class="line-modified">3849      * nullable type} and the object is {@code null}</span>
3850      *
3851      * @since 1.5
3852      */
3853     @SuppressWarnings(&quot;unchecked&quot;)
3854     @HotSpotIntrinsicCandidate
3855     public T cast(Object obj) {
<a name="19" id="anc19"></a><span class="line-modified">3856         if (!isNullableType() &amp;&amp; obj == null)</span>
3857             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3858 
3859         if (obj != null &amp;&amp; !isInstance(obj))
3860             throw new ClassCastException(cannotCastMsg(obj));
3861         return (T) obj;
3862     }
3863 
3864     private String cannotCastMsg(Object obj) {
3865         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3866     }
3867 
3868     /**
3869      * Casts this {@code Class} object to represent a subclass of the class
3870      * represented by the specified class object.  Checks that the cast
3871      * is valid, and throws a {@code ClassCastException} if it is not.  If
3872      * this method succeeds, it always returns a reference to this {@code Class} object.
3873      *
3874      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3875      * a {@code Class} object to pass it to an API that restricts the
3876      * {@code Class} objects that it is willing to accept.  A cast would
3877      * generate a compile-time warning, as the correctness of the cast
3878      * could not be checked at runtime (because generic types are implemented
3879      * by erasure).
3880      *
3881      * @param &lt;U&gt; the type to cast this {@code Class} object to
3882      * @param clazz the class of the type to cast this {@code Class} object to
3883      * @return this {@code Class} object, cast to represent a subclass of
3884      *    the specified class object.
3885      * @throws ClassCastException if this {@code Class} object does not
3886      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3887      *    the class itself).
3888      * @since 1.5
3889      */
3890     @SuppressWarnings(&quot;unchecked&quot;)
3891     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3892         if (clazz.isAssignableFrom(this))
3893             return (Class&lt;? extends U&gt;) this;
3894         else
3895             throw new ClassCastException(this.toString());
3896     }
3897 
3898     /**
3899      * {@inheritDoc}
3900      * &lt;p&gt;Note that any annotation returned by this method is a
3901      * declaration annotation.
3902      *
3903      * @throws NullPointerException {@inheritDoc}
3904      * @since 1.5
3905      */
3906     @Override
3907     @SuppressWarnings(&quot;unchecked&quot;)
3908     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3909         Objects.requireNonNull(annotationClass);
3910 
3911         return (A) annotationData().annotations.get(annotationClass);
3912     }
3913 
3914     /**
3915      * {@inheritDoc}
3916      * @throws NullPointerException {@inheritDoc}
3917      * @since 1.5
3918      */
3919     @Override
3920     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
3921         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
3922     }
3923 
3924     /**
3925      * {@inheritDoc}
3926      * &lt;p&gt;Note that any annotations returned by this method are
3927      * declaration annotations.
3928      *
3929      * @throws NullPointerException {@inheritDoc}
3930      * @since 1.8
3931      */
3932     @Override
3933     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
3934         Objects.requireNonNull(annotationClass);
3935 
3936         AnnotationData annotationData = annotationData();
3937         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
3938                                                           this,
3939                                                           annotationClass);
3940     }
3941 
3942     /**
3943      * {@inheritDoc}
3944      * &lt;p&gt;Note that any annotations returned by this method are
3945      * declaration annotations.
3946      *
3947      * @since 1.5
3948      */
3949     @Override
3950     public Annotation[] getAnnotations() {
3951         return AnnotationParser.toArray(annotationData().annotations);
3952     }
3953 
3954     /**
3955      * {@inheritDoc}
3956      * &lt;p&gt;Note that any annotation returned by this method is a
3957      * declaration annotation.
3958      *
3959      * @throws NullPointerException {@inheritDoc}
3960      * @since 1.8
3961      */
3962     @Override
3963     @SuppressWarnings(&quot;unchecked&quot;)
3964     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
3965         Objects.requireNonNull(annotationClass);
3966 
3967         return (A) annotationData().declaredAnnotations.get(annotationClass);
3968     }
3969 
3970     /**
3971      * {@inheritDoc}
3972      * &lt;p&gt;Note that any annotations returned by this method are
3973      * declaration annotations.
3974      *
3975      * @throws NullPointerException {@inheritDoc}
3976      * @since 1.8
3977      */
3978     @Override
3979     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
3980         Objects.requireNonNull(annotationClass);
3981 
3982         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
3983                                                                  annotationClass);
3984     }
3985 
3986     /**
3987      * {@inheritDoc}
3988      * &lt;p&gt;Note that any annotations returned by this method are
3989      * declaration annotations.
3990      *
3991      * @since 1.5
3992      */
3993     @Override
3994     public Annotation[] getDeclaredAnnotations()  {
3995         return AnnotationParser.toArray(annotationData().declaredAnnotations);
3996     }
3997 
3998     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
3999     private static class AnnotationData {
4000         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
4001         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
4002 
4003         // Value of classRedefinedCount when we created this AnnotationData instance
4004         final int redefinedCount;
4005 
4006         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
4007                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
4008                        int redefinedCount) {
4009             this.annotations = annotations;
4010             this.declaredAnnotations = declaredAnnotations;
4011             this.redefinedCount = redefinedCount;
4012         }
4013     }
4014 
4015     // Annotations cache
4016     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4017     private transient volatile AnnotationData annotationData;
4018 
4019     private AnnotationData annotationData() {
4020         while (true) { // retry loop
4021             AnnotationData annotationData = this.annotationData;
4022             int classRedefinedCount = this.classRedefinedCount;
4023             if (annotationData != null &amp;&amp;
4024                 annotationData.redefinedCount == classRedefinedCount) {
4025                 return annotationData;
4026             }
4027             // null or stale annotationData -&gt; optimistically create new instance
4028             AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
4029             // try to install it
4030             if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {
4031                 // successfully installed new AnnotationData
4032                 return newAnnotationData;
4033             }
4034         }
4035     }
4036 
4037     private AnnotationData createAnnotationData(int classRedefinedCount) {
4038         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =
4039             AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);
4040         Class&lt;?&gt; superClass = getSuperclass();
4041         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;
4042         if (superClass != null) {
4043             Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =
4044                 superClass.annotationData().annotations;
4045             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {
4046                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
4047                 if (AnnotationType.getInstance(annotationClass).isInherited()) {
4048                     if (annotations == null) { // lazy construction
4049                         annotations = new LinkedHashMap&lt;&gt;((Math.max(
4050                                 declaredAnnotations.size(),
4051                                 Math.min(12, declaredAnnotations.size() + superAnnotations.size())
4052                             ) * 4 + 2) / 3
4053                         );
4054                     }
4055                     annotations.put(annotationClass, e.getValue());
4056                 }
4057             }
4058         }
4059         if (annotations == null) {
4060             // no inherited annotations -&gt; share the Map with declaredAnnotations
4061             annotations = declaredAnnotations;
4062         } else {
4063             // at least one inherited annotation -&gt; declared may override inherited
4064             annotations.putAll(declaredAnnotations);
4065         }
4066         return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
4067     }
4068 
4069     // Annotation types cache their internal (AnnotationType) form
4070 
4071     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4072     private transient volatile AnnotationType annotationType;
4073 
4074     boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
4075         return Atomic.casAnnotationType(this, oldType, newType);
4076     }
4077 
4078     AnnotationType getAnnotationType() {
4079         return annotationType;
4080     }
4081 
4082     Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
4083         return annotationData().declaredAnnotations;
4084     }
4085 
4086     /* Backing store of user-defined values pertaining to this class.
4087      * Maintained by the ClassValue class.
4088      */
4089     transient ClassValue.ClassValueMap classValueMap;
4090 
4091     /**
4092      * Returns an {@code AnnotatedType} object that represents the use of a
4093      * type to specify the superclass of the entity represented by this {@code
4094      * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
4095      * in &#39;...  extends Foo&#39; is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
4096      * Foo.)
4097      *
4098      * &lt;p&gt; If this {@code Class} object represents a type whose declaration
4099      * does not explicitly indicate an annotated superclass, then the return
4100      * value is an {@code AnnotatedType} object representing an element with no
4101      * annotations.
4102      *
4103      * &lt;p&gt; If this {@code Class} represents either the {@code Object} class, an
4104      * interface type, an array type, a primitive type, or void, the return
4105      * value is {@code null}.
4106      *
4107      * @return an object representing the superclass
4108      * @since 1.8
4109      */
4110     public AnnotatedType getAnnotatedSuperclass() {
4111         if (this == Object.class ||
4112                 isInterface() ||
4113                 isArray() ||
4114                 isPrimitive() ||
4115                 this == Void.TYPE) {
4116             return null;
4117         }
4118 
4119         return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);
4120     }
4121 
4122     /**
4123      * Returns an array of {@code AnnotatedType} objects that represent the use
4124      * of types to specify superinterfaces of the entity represented by this
4125      * {@code Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
4126      * superinterface in &#39;... implements Foo&#39; is distinct from the
4127      * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
4128      *
4129      * &lt;p&gt; If this {@code Class} object represents a class, the return value is
4130      * an array containing objects representing the uses of interface types to
4131      * specify interfaces implemented by the class. The order of the objects in
4132      * the array corresponds to the order of the interface types used in the
4133      * &#39;implements&#39; clause of the declaration of this {@code Class} object.
4134      *
4135      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4136      * value is an array containing objects representing the uses of interface
4137      * types to specify interfaces directly extended by the interface. The
4138      * order of the objects in the array corresponds to the order of the
4139      * interface types used in the &#39;extends&#39; clause of the declaration of this
4140      * {@code Class} object.
4141      *
4142      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4143      * declaration does not explicitly indicate any annotated superinterfaces,
4144      * the return value is an array of length 0.
4145      *
4146      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4147      * class, an array type, a primitive type, or void, the return value is an
4148      * array of length 0.
4149      *
4150      * @return an array representing the superinterfaces
4151      * @since 1.8
4152      */
4153     public AnnotatedType[] getAnnotatedInterfaces() {
4154         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
4155     }
4156 
4157     private native Class&lt;?&gt; getNestHost0();
4158 
4159     /**
4160      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4161      * or interface represented by this {@code Class} object belongs.
4162      * Every class and interface is a member of exactly one nest.
4163      * A class or interface that is not recorded as belonging to a nest
4164      * belongs to the nest consisting only of itself, and is the nest
4165      * host.
4166      *
4167      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4168      * primitive types, and {@code void} returns {@code this} to indicate
4169      * that the represented entity belongs to the nest consisting only of
4170      * itself, and is the nest host.
4171      *
4172      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing
4173      * the nest host, or if this class or interface is not enumerated as
4174      * a member of the nest by the nest host, then it is considered to belong
4175      * to its own nest and {@code this} is returned as the host.
4176      *
4177      * @apiNote A {@code class} file of version 55.0 or greater may record the
4178      * host of the nest to which it belongs by using the {@code NestHost}
4179      * attribute (JVMS {@jvms 4.7.28}). Alternatively, a {@code class} file of
4180      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
4181      * other members with the
4182      * {@code NestMembers} attribute (JVMS {@jvms 4.7.29}).
4183      * A {@code class} file of version 54.0 or lower does not use these
4184      * attributes.
4185      *
4186      * @return the nest host of this class or interface
4187      *
4188      * @throws SecurityException
4189      *         If the returned class is not the current class, and
4190      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4191      *         class loader is not the same as or an ancestor of the class
4192      *         loader for the returned class and invocation of {@link
4193      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4194      *         denies access to the package of the returned class
4195      * @since 11
4196      * @jvms 4.7.28 The {@code NestHost} Attribute
4197      * @jvms 4.7.29 The {@code NestMembers} Attribute
4198      * @jvms 5.4.4 Access Control
4199      */
4200     @CallerSensitive
4201     public Class&lt;?&gt; getNestHost() {
4202         if (isPrimitive() || isArray()) {
4203             return this;
4204         }
4205         Class&lt;?&gt; host;
4206         try {
4207             host = getNestHost0();
4208         } catch (LinkageError e) {
4209             // if we couldn&#39;t load our nest-host then we
4210             // act as-if we have no nest-host attribute
4211             return this;
4212         }
4213         // if null then nest membership validation failed, so we
4214         // act as-if we have no nest-host attribute
4215         if (host == null || host == this) {
4216             return this;
4217         }
4218         // returning a different class requires a security check
4219         SecurityManager sm = System.getSecurityManager();
4220         if (sm != null) {
4221             checkPackageAccess(sm,
4222                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4223         }
4224         return host;
4225     }
4226 
4227     /**
4228      * Determines if the given {@code Class} is a nestmate of the
4229      * class or interface represented by this {@code Class} object.
4230      * Two classes or interfaces are nestmates
4231      * if they have the same {@linkplain #getNestHost() nest host}.
4232      *
4233      * @param c the class to check
4234      * @return {@code true} if this class and {@code c} are members of
4235      * the same nest; and {@code false} otherwise.
4236      *
4237      * @since 11
4238      */
4239     public boolean isNestmateOf(Class&lt;?&gt; c) {
4240         if (this == c) {
4241             return true;
4242         }
4243         if (isPrimitive() || isArray() ||
4244             c.isPrimitive() || c.isArray()) {
4245             return false;
4246         }
4247         try {
4248             return getNestHost0() == c.getNestHost0();
4249         } catch (LinkageError e) {
4250             return false;
4251         }
4252     }
4253 
4254     private native Class&lt;?&gt;[] getNestMembers0();
4255 
4256     /**
4257      * Returns an array containing {@code Class} objects representing all the
4258      * classes and interfaces that are members of the nest to which the class
4259      * or interface represented by this {@code Class} object belongs.
4260      * The {@linkplain #getNestHost() nest host} of that nest is the zeroth
4261      * element of the array. Subsequent elements represent any classes or
4262      * interfaces that are recorded by the nest host as being members of
4263      * the nest; the order of such elements is unspecified. Duplicates are
4264      * permitted.
4265      * If the nest host of that nest does not enumerate any members, then the
4266      * array has a single element containing {@code this}.
4267      *
4268      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4269      * primitive types, and {@code void} returns an array containing only
4270      * {@code this}.
4271      *
4272      * &lt;p&gt;This method validates that, for each class or interface which is
4273      * recorded as a member of the nest by the nest host, that class or
4274      * interface records itself as a member of that same nest. Any exceptions
4275      * that occur during this validation are rethrown by this method.
4276      *
4277      * @return an array of all classes and interfaces in the same nest as
4278      * this class
4279      *
4280      * @throws LinkageError
4281      *         If there is any problem loading or validating a nest member or
4282      *         its nest host
4283      * @throws SecurityException
4284      *         If any returned class is not the current class, and
4285      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4286      *         class loader is not the same as or an ancestor of the class
4287      *         loader for that returned class and invocation of {@link
4288      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4289      *         denies access to the package of that returned class
4290      *
4291      * @since 11
4292      * @see #getNestHost()
4293      */
4294     @CallerSensitive
4295     public Class&lt;?&gt;[] getNestMembers() {
4296         if (isPrimitive() || isArray()) {
4297             return new Class&lt;?&gt;[] { this };
4298         }
4299         Class&lt;?&gt;[] members = getNestMembers0();
4300         // Can&#39;t actually enable this due to bootstrapping issues
4301         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4302 
4303         if (members.length &gt; 1) {
4304             // If we return anything other than the current class we need
4305             // a security check
4306             SecurityManager sm = System.getSecurityManager();
4307             if (sm != null) {
4308                 checkPackageAccess(sm,
4309                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4310             }
4311         }
4312         return members;
4313     }
4314 
4315     /**
4316      * Returns the type descriptor string for this class.
4317      * &lt;p&gt;
4318      * Note that this is not a strict inverse of {@link #forName};
4319      * distinct classes which share a common name but have different class loaders
4320      * will have identical descriptor strings.
4321      *
4322      * @return the type descriptor representation
4323      * @jvms 4.3.2 Field Descriptors
4324      * @since 12
4325      */
4326     @Override
4327     public String descriptorString() {
4328         if (isPrimitive())
4329             return Wrapper.forPrimitiveType(this).basicTypeString();
4330         else if (isArray()) {
4331             return &quot;[&quot; + componentType.descriptorString();
4332         }
4333         else {
<a name="20" id="anc20"></a><span class="line-modified">4334             return &quot;L&quot; + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>

4335         }
4336     }
4337 
4338     /**
4339      * Returns the component type of this {@code Class}, if it describes
4340      * an array type, or {@code null} otherwise.
4341      *
4342      * @implSpec
4343      * Equivalent to {@link Class#getComponentType()}.
4344      *
4345      * @return a {@code Class} describing the component type, or {@code null}
4346      * if this {@code Class} does not describe an array type
4347      * @since 12
4348      */
4349     @Override
4350     public Class&lt;?&gt; componentType() {
4351         return isArray() ? componentType : null;
4352     }
4353 
4354     /**
4355      * Returns a {@code Class} for an array type whose component type
4356      * is described by this {@linkplain Class}.
4357      *
4358      * @return a {@code Class} describing the array type
4359      * @since 12
4360      */
4361     @Override
4362     public Class&lt;?&gt; arrayType() {
4363         return Array.newInstance(this, 0).getClass();
4364     }
4365 
4366     /**
4367      * Returns a nominal descriptor for this instance, if one can be
4368      * constructed, or an empty {@link Optional} if one cannot be.
4369      *
4370      * @return An {@link Optional} containing the resulting nominal descriptor,
4371      * or an empty {@link Optional} if one cannot be constructed.
4372      * @since 12
4373      */
4374     @Override
4375     public Optional&lt;ClassDesc&gt; describeConstable() {
4376         return Optional.of(ClassDesc.ofDescriptor(descriptorString()));
4377     }
4378 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
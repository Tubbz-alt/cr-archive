<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.reflect;
 27 
 28 import java.lang.reflect.Field;
 29 import java.lang.reflect.Modifier;
 30 import jdk.internal.misc.Unsafe;
 31 
 32 /** Base class for jdk.internal.misc.Unsafe-based FieldAccessors. The
 33     observation is that there are only nine types of fields from the
 34     standpoint of reflection code: the eight primitive types and
 35     Object. Using class Unsafe instead of generated bytecodes saves
 36     memory and loading time for the dynamically-generated
 37     FieldAccessors. */
 38 
 39 abstract class UnsafeFieldAccessorImpl extends FieldAccessorImpl {
 40     static final Unsafe unsafe = Unsafe.getUnsafe();
 41 
 42     protected final Field   field;
 43     protected final long    fieldOffset;
 44     protected final boolean isFinal;
 45 
 46     UnsafeFieldAccessorImpl(Field field) {
 47         this.field = field;
 48         if (Modifier.isStatic(field.getModifiers()))
 49             this.fieldOffset = unsafe.staticFieldOffset(field);
 50         else
 51             this.fieldOffset = unsafe.objectFieldOffset(field);
 52         this.isFinal = Modifier.isFinal(field.getModifiers());
 53     }
 54 
 55     protected void ensureObj(Object o) {
 56         // NOTE: will throw NullPointerException, as specified, if o is null
 57         if (!field.getDeclaringClass().isAssignableFrom(o.getClass())) {
 58             throwSetIllegalArgumentException(o);
 59         }
 60     }
 61 
 62     protected boolean isFlattened() {
 63         return unsafe.isFlattened(field);
 64     }
 65 
 66     protected boolean canBeNull() {
 67         return !field.getType().isInlineClass();
 68     }
 69 
 70     protected Object checkValue(Object value) {
 71         if (!canBeNull() &amp;&amp; value == null)
 72             throw new NullPointerException(field + &quot; cannot be set to null&quot;);
 73 
 74         if (value != null) {
 75             if (!field.getType().isAssignableFrom(value.getClass())) {
 76                 throwSetIllegalArgumentException(value);
 77             }
 78         }
 79         return value;
 80     }
 81 
 82     private String getQualifiedFieldName() {
 83       return field.getDeclaringClass().getName() + &quot;.&quot; +field.getName();
 84     }
 85 
 86     protected IllegalArgumentException newGetIllegalArgumentException(String type) {
 87         return new IllegalArgumentException(
 88           &quot;Attempt to get &quot;+field.getType().getName()+&quot; field \&quot;&quot; +
 89           getQualifiedFieldName() + &quot;\&quot; with illegal data type conversion to &quot;+type
 90         );
 91     }
 92 
 93     protected void throwFinalFieldIllegalAccessException(String attemptedType,
 94                                                          String attemptedValue)
 95                                                          throws IllegalAccessException {
 96         throw new IllegalAccessException(getSetMessage(attemptedType, attemptedValue));
 97 
 98     }
 99     protected void throwFinalFieldIllegalAccessException(Object o) throws IllegalAccessException {
100         throwFinalFieldIllegalAccessException(o != null ? o.getClass().getName() : &quot;&quot;, &quot;&quot;);
101     }
102 
103     protected void throwFinalFieldIllegalAccessException(boolean z) throws IllegalAccessException {
104         throwFinalFieldIllegalAccessException(&quot;boolean&quot;, Boolean.toString(z));
105     }
106 
107     protected void throwFinalFieldIllegalAccessException(char b) throws IllegalAccessException {
108         throwFinalFieldIllegalAccessException(&quot;char&quot;, Character.toString(b));
109     }
110 
111     protected void throwFinalFieldIllegalAccessException(byte b) throws IllegalAccessException {
112         throwFinalFieldIllegalAccessException(&quot;byte&quot;, Byte.toString(b));
113     }
114 
115     protected void throwFinalFieldIllegalAccessException(short b) throws IllegalAccessException {
116         throwFinalFieldIllegalAccessException(&quot;short&quot;, Short.toString(b));
117     }
118 
119     protected void throwFinalFieldIllegalAccessException(int i) throws IllegalAccessException {
120         throwFinalFieldIllegalAccessException(&quot;int&quot;, Integer.toString(i));
121     }
122 
123     protected void throwFinalFieldIllegalAccessException(long i) throws IllegalAccessException {
124         throwFinalFieldIllegalAccessException(&quot;long&quot;, Long.toString(i));
125     }
126 
127     protected void throwFinalFieldIllegalAccessException(float f) throws IllegalAccessException {
128         throwFinalFieldIllegalAccessException(&quot;float&quot;, Float.toString(f));
129     }
130 
131     protected void throwFinalFieldIllegalAccessException(double f) throws IllegalAccessException {
132         throwFinalFieldIllegalAccessException(&quot;double&quot;, Double.toString(f));
133     }
134 
135     protected IllegalArgumentException newGetBooleanIllegalArgumentException() {
136         return newGetIllegalArgumentException(&quot;boolean&quot;);
137     }
138 
139     protected IllegalArgumentException newGetByteIllegalArgumentException() {
140         return newGetIllegalArgumentException(&quot;byte&quot;);
141     }
142 
143     protected IllegalArgumentException newGetCharIllegalArgumentException() {
144         return newGetIllegalArgumentException(&quot;char&quot;);
145     }
146 
147     protected IllegalArgumentException newGetShortIllegalArgumentException() {
148         return newGetIllegalArgumentException(&quot;short&quot;);
149     }
150 
151     protected IllegalArgumentException newGetIntIllegalArgumentException() {
152         return newGetIllegalArgumentException(&quot;int&quot;);
153     }
154 
155     protected IllegalArgumentException newGetLongIllegalArgumentException() {
156         return newGetIllegalArgumentException(&quot;long&quot;);
157     }
158 
159     protected IllegalArgumentException newGetFloatIllegalArgumentException() {
160         return newGetIllegalArgumentException(&quot;float&quot;);
161     }
162 
163     protected IllegalArgumentException newGetDoubleIllegalArgumentException() {
164         return newGetIllegalArgumentException(&quot;double&quot;);
165     }
166 
167     protected String getSetMessage(String attemptedType, String attemptedValue) {
168         String err = &quot;Can not set&quot;;
169         if (Modifier.isStatic(field.getModifiers()))
170             err += &quot; static&quot;;
171         if (isFinal)
172             err += &quot; final&quot;;
173         err += &quot; &quot; + field.getType().getName() + &quot; field &quot; + getQualifiedFieldName() + &quot; to &quot;;
174         if (!attemptedValue.isEmpty()) {
175             err += &quot;(&quot; + attemptedType + &quot;)&quot; + attemptedValue;
176         } else {
177             if (!attemptedType.isEmpty())
178                 err += attemptedType;
179             else
180                 err += &quot;null value&quot;;
181         }
182         return err;
183     }
184 
185     protected void throwSetIllegalArgumentException(String attemptedType,
186                                                     String attemptedValue) {
187         throw new IllegalArgumentException(getSetMessage(attemptedType,attemptedValue));
188     }
189 
190     protected void throwSetIllegalArgumentException(Object o) {
191         throwSetIllegalArgumentException(o != null ? o.getClass().getName() : &quot;&quot;, &quot;&quot;);
192     }
193 
194     protected void throwSetIllegalArgumentException(boolean b) {
195         throwSetIllegalArgumentException(&quot;boolean&quot;, Boolean.toString(b));
196     }
197 
198     protected void throwSetIllegalArgumentException(byte b) {
199         throwSetIllegalArgumentException(&quot;byte&quot;, Byte.toString(b));
200     }
201 
202     protected void throwSetIllegalArgumentException(char c) {
203         throwSetIllegalArgumentException(&quot;char&quot;, Character.toString(c));
204     }
205 
206     protected void throwSetIllegalArgumentException(short s) {
207         throwSetIllegalArgumentException(&quot;short&quot;, Short.toString(s));
208     }
209 
210     protected void throwSetIllegalArgumentException(int i) {
211         throwSetIllegalArgumentException(&quot;int&quot;, Integer.toString(i));
212     }
213 
214     protected void throwSetIllegalArgumentException(long l) {
215         throwSetIllegalArgumentException(&quot;long&quot;, Long.toString(l));
216     }
217 
218     protected void throwSetIllegalArgumentException(float f) {
219         throwSetIllegalArgumentException(&quot;float&quot;, Float.toString(f));
220     }
221 
222     protected void throwSetIllegalArgumentException(double d) {
223         throwSetIllegalArgumentException(&quot;double&quot;, Double.toString(d));
224     }
225 
226 }
    </pre>
  </body>
</html>
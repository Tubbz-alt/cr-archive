<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/MemberName.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import sun.invoke.util.BytecodeDescriptor;
  29 import sun.invoke.util.VerifyAccess;
  30 
  31 import java.lang.reflect.Constructor;
  32 import java.lang.reflect.Field;
  33 import java.lang.reflect.Member;
  34 import java.lang.reflect.Method;
  35 import java.lang.reflect.Modifier;
  36 import java.util.ArrayList;
  37 import java.util.Collections;
  38 import java.util.Iterator;
  39 import java.util.List;
  40 import java.util.Objects;
  41 
  42 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  43 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
  44 import static java.lang.invoke.MethodHandleStatics.newInternalError;
  45 
  46 /**
  47  * A {@code MemberName} is a compact symbolic datum which fully characterizes
  48  * a method or field reference.
  49  * A member name refers to a field, method, constructor, or member type.
  50  * Every member name has a simple name (a string) and a type (either a Class or MethodType).
  51  * A member name may also have a non-null declaring class, or it may be simply
  52  * a naked name/type pair.
  53  * A member name may also have non-zero modifier flags.
  54  * Finally, a member name may be either resolved or unresolved.
  55  * If it is resolved, the existence of the named member has been determined by the JVM.
  56  * &lt;p&gt;
  57  * Whether resolved or not, a member name provides no access rights or
  58  * invocation capability to its possessor.  It is merely a compact
  59  * representation of all symbolic information necessary to link to
  60  * and properly use the named member.
  61  * &lt;p&gt;
  62  * When resolved, a member name&#39;s internal implementation may include references to JVM metadata.
  63  * This representation is stateless and only descriptive.
  64  * It provides no private information and no capability to use the member.
  65  * &lt;p&gt;
  66  * By contrast, a {@linkplain java.lang.reflect.Method} contains fuller information
  67  * about the internals of a method (except its bytecodes) and also
  68  * allows invocation.  A MemberName is much lighter than a Method,
  69  * since it contains about 7 fields to the 16 of Method (plus its sub-arrays),
  70  * and those seven fields omit much of the information in Method.
  71  * @author jrose
  72  */
  73 /*non-public*/
  74 final class ResolvedMethodName {
  75     //@Injected JVM_Method* vmtarget;
  76     //@Injected Class&lt;?&gt;    vmholder;
  77 };
  78 
  79 /*non-public*/
  80 final class MemberName implements Member, Cloneable {
  81     private Class&lt;?&gt; clazz;       // class in which the member is defined
  82     private String   name;        // may be null if not yet materialized
  83     private Object   type;        // may be null if not yet materialized
  84     private int      flags;       // modifier bits; see reflect.Modifier
  85     private ResolvedMethodName method;    // cached resolved method information
  86     //@Injected intptr_t       vmindex;   // vtable index or offset of resolved member
  87     Object   resolution;  // if null, this guy is resolved
  88 
  89     /** Return the declaring class of this member.
  90      *  In the case of a bare name and type, the declaring class will be null.
  91      */
  92     public Class&lt;?&gt; getDeclaringClass() {
  93         return clazz;
  94     }
  95 
  96     /** Utility method producing the class loader of the declaring class. */
  97     public ClassLoader getClassLoader() {
  98         return clazz.getClassLoader();
  99     }
 100 
 101     /** Return the simple name of this member.
 102      *  For a type, it is the same as {@link Class#getSimpleName}.
 103      *  For a method or field, it is the simple name of the member.
 104      *  For a constructor, it is always {@code &quot;&lt;init&gt;&quot;}.
 105      */
 106     public String getName() {
 107         if (name == null) {
 108             expandFromVM();
 109             if (name == null) {
 110                 return null;
 111             }
 112         }
 113         return name;
 114     }
 115 
 116     public MethodType getMethodOrFieldType() {
 117         if (isInvocable())
 118             return getMethodType();
 119         if (isGetter())
 120             return MethodType.methodType(getFieldType());
 121         if (isSetter())
 122             return MethodType.methodType(void.class, getFieldType());
 123         throw new InternalError(&quot;not a method or field: &quot;+this);
 124     }
 125 
 126     /** Return the declared type of this member, which
 127      *  must be a method or constructor.
 128      */
 129     public MethodType getMethodType() {
 130         if (type == null) {
 131             expandFromVM();
 132             if (type == null) {
 133                 return null;
 134             }
 135         }
 136         if (!isInvocable()) {
 137             throw newIllegalArgumentException(&quot;not invocable, no method type&quot;);
 138         }
 139 
 140         {
 141             // Get a snapshot of type which doesn&#39;t get changed by racing threads.
 142             final Object type = this.type;
 143             if (type instanceof MethodType) {
 144                 return (MethodType) type;
 145             }
 146         }
 147 
 148         // type is not a MethodType yet.  Convert it thread-safely.
 149         synchronized (this) {
 150             if (type instanceof String) {
 151                 String sig = (String) type;
 152                 MethodType res = MethodType.fromDescriptor(sig, getClassLoader());
 153                 type = res;
 154             } else if (type instanceof Object[]) {
 155                 Object[] typeInfo = (Object[]) type;
 156                 Class&lt;?&gt;[] ptypes = (Class&lt;?&gt;[]) typeInfo[1];
 157                 Class&lt;?&gt; rtype = (Class&lt;?&gt;) typeInfo[0];
 158                 MethodType res = MethodType.makeImpl(rtype, ptypes, true);
 159                 type = res;
 160             }
 161             // Make sure type is a MethodType for racing threads.
 162             assert type instanceof MethodType : &quot;bad method type &quot; + type;
 163         }
 164         return (MethodType) type;
 165     }
 166 
 167     /** Return the descriptor of this member, which
 168      *  must be a method or constructor.
 169      */
 170     String getMethodDescriptor() {
 171         if (type == null) {
 172             expandFromVM();
 173             if (type == null) {
 174                 return null;
 175             }
 176         }
 177         if (!isInvocable()) {
 178             throw newIllegalArgumentException(&quot;not invocable, no method type&quot;);
 179         }
 180 
 181         // Get a snapshot of type which doesn&#39;t get changed by racing threads.
 182         final Object type = this.type;
 183         if (type instanceof String) {
 184             return (String) type;
 185         } else {
 186             return getMethodType().toMethodDescriptorString();
 187         }
 188     }
 189 
 190     /** Return the actual type under which this method or constructor must be invoked.
 191      *  For non-static methods or constructors, this is the type with a leading parameter,
 192      *  a reference to declaring class.  For static methods, it is the same as the declared type.
 193      */
 194     public MethodType getInvocationType() {
 195         MethodType itype = getMethodOrFieldType();
<a name="1" id="anc1"></a><span class="line-removed"> 196         Class&lt;?&gt; c = clazz.asPrimaryType();</span>
 197         if (isObjectConstructor() &amp;&amp; getReferenceKind() == REF_newInvokeSpecial)
<a name="2" id="anc2"></a><span class="line-modified"> 198             return itype.changeReturnType(c);</span>
 199         if (!isStatic())
<a name="3" id="anc3"></a><span class="line-modified"> 200             return itype.insertParameterTypes(0, c);</span>
 201         return itype;
 202     }
 203 
 204     /** Utility method producing the parameter types of the method type. */
 205     public Class&lt;?&gt;[] getParameterTypes() {
 206         return getMethodType().parameterArray();
 207     }
 208 
 209     /** Utility method producing the return type of the method type. */
 210     public Class&lt;?&gt; getReturnType() {
 211         return getMethodType().returnType();
 212     }
 213 
 214     /** Return the declared type of this member, which
 215      *  must be a field or type.
 216      *  If it is a type member, that type itself is returned.
 217      */
 218     public Class&lt;?&gt; getFieldType() {
 219         if (type == null) {
 220             expandFromVM();
 221             if (type == null) {
 222                 return null;
 223             }
 224         }
 225         if (isInvocable()) {
 226             throw newIllegalArgumentException(&quot;not a field or nested class, no simple type&quot;);
 227         }
 228 
 229         {
 230             // Get a snapshot of type which doesn&#39;t get changed by racing threads.
 231             final Object type = this.type;
 232             if (type instanceof Class&lt;?&gt;) {
 233                 return (Class&lt;?&gt;) type;
 234             }
 235         }
 236 
 237         // type is not a Class yet.  Convert it thread-safely.
 238         synchronized (this) {
 239             if (type instanceof String) {
 240                 String sig = (String) type;
 241                 MethodType mtype = MethodType.fromDescriptor(&quot;()&quot;+sig, getClassLoader());
 242                 Class&lt;?&gt; res = mtype.returnType();
 243                 type = res;
 244             }
 245             // Make sure type is a Class for racing threads.
 246             assert type instanceof Class&lt;?&gt; : &quot;bad field type &quot; + type;
 247         }
 248         return (Class&lt;?&gt;) type;
 249     }
 250 
 251     /** Utility method to produce either the method type or field type of this member. */
 252     public Object getType() {
 253         return (isInvocable() ? getMethodType() : getFieldType());
 254     }
 255 
 256     /** Utility method to produce the signature of this member,
 257      *  used within the class file format to describe its type.
 258      */
 259     public String getSignature() {
 260         if (type == null) {
 261             expandFromVM();
 262             if (type == null) {
 263                 return null;
 264             }
 265         }
 266         if (isInvocable())
 267             return BytecodeDescriptor.unparse(getMethodType());
 268         else
 269             return BytecodeDescriptor.unparse(getFieldType());
 270     }
 271 
 272     /** Return the modifier flags of this member.
 273      *  @see java.lang.reflect.Modifier
 274      */
 275     public int getModifiers() {
 276         return (flags &amp; RECOGNIZED_MODIFIERS);
 277     }
 278 
 279     /** Return the reference kind of this member, or zero if none.
 280      */
 281     public byte getReferenceKind() {
 282         return (byte) ((flags &gt;&gt;&gt; MN_REFERENCE_KIND_SHIFT) &amp; MN_REFERENCE_KIND_MASK);
 283     }
 284     private boolean referenceKindIsConsistent() {
 285         byte refKind = getReferenceKind();
 286         if (refKind == REF_NONE)  return isType();
 287         if (isField()) {
 288             assert(staticIsConsistent());
 289             assert(MethodHandleNatives.refKindIsField(refKind));
 290         } else if (isObjectConstructor()) {
 291             assert(refKind == REF_newInvokeSpecial || refKind == REF_invokeSpecial);
 292         } else if (isMethod()) {
 293             assert(staticIsConsistent());
 294             assert(MethodHandleNatives.refKindIsMethod(refKind));
 295             if (clazz.isInterface())
 296                 assert(refKind == REF_invokeInterface ||
 297                        refKind == REF_invokeStatic    ||
 298                        refKind == REF_invokeSpecial   ||
 299                        refKind == REF_invokeVirtual &amp;&amp; isObjectPublicMethod());
 300         } else {
 301             assert(false);
 302         }
 303         return true;
 304     }
 305     private boolean isObjectPublicMethod() {
 306         if (clazz == Object.class)  return true;
 307         MethodType mtype = getMethodType();
 308         if (name.equals(&quot;toString&quot;) &amp;&amp; mtype.returnType() == String.class &amp;&amp; mtype.parameterCount() == 0)
 309             return true;
 310         if (name.equals(&quot;hashCode&quot;) &amp;&amp; mtype.returnType() == int.class &amp;&amp; mtype.parameterCount() == 0)
 311             return true;
 312         if (name.equals(&quot;equals&quot;) &amp;&amp; mtype.returnType() == boolean.class &amp;&amp; mtype.parameterCount() == 1 &amp;&amp; mtype.parameterType(0) == Object.class)
 313             return true;
 314         return false;
 315     }
 316 
 317     /*non-public*/
 318     boolean referenceKindIsConsistentWith(int originalRefKind) {
 319         int refKind = getReferenceKind();
 320         if (refKind == originalRefKind)  return true;
 321         switch (originalRefKind) {
 322         case REF_invokeInterface:
 323             // Looking up an interface method, can get (e.g.) Object.hashCode
 324             assert(refKind == REF_invokeVirtual ||
 325                    refKind == REF_invokeSpecial) : this;
 326             return true;
 327         case REF_invokeVirtual:
 328         case REF_newInvokeSpecial:
 329             // Looked up a virtual, can get (e.g.) final String.hashCode.
 330             assert(refKind == REF_invokeSpecial) : this;
 331             return true;
 332         }
 333         assert(false) : this+&quot; != &quot;+MethodHandleNatives.refKindName((byte)originalRefKind);
 334         return true;
 335     }
 336     private boolean staticIsConsistent() {
 337         byte refKind = getReferenceKind();
 338         return MethodHandleNatives.refKindIsStatic(refKind) == isStatic() || getModifiers() == 0;
 339     }
 340     private boolean vminfoIsConsistent() {
 341         byte refKind = getReferenceKind();
 342         assert(isResolved());  // else don&#39;t call
 343         Object vminfo = MethodHandleNatives.getMemberVMInfo(this);
 344         assert(vminfo instanceof Object[]);
 345         long vmindex = (Long) ((Object[])vminfo)[0];
 346         Object vmtarget = ((Object[])vminfo)[1];
 347         if (MethodHandleNatives.refKindIsField(refKind)) {
 348             assert(vmindex &gt;= 0) : vmindex + &quot;:&quot; + this;
 349             assert(vmtarget instanceof Class);
 350         } else {
 351             if (MethodHandleNatives.refKindDoesDispatch(refKind))
 352                 assert(vmindex &gt;= 0) : vmindex + &quot;:&quot; + this;
 353             else
 354                 assert(vmindex &lt; 0) : vmindex;
 355             assert(vmtarget instanceof MemberName) : vmtarget + &quot; in &quot; + this;
 356         }
 357         return true;
 358     }
 359 
 360     private MemberName changeReferenceKind(byte refKind, byte oldKind) {
 361         assert(getReferenceKind() == oldKind);
 362         assert(MethodHandleNatives.refKindIsValid(refKind));
 363         flags += (((int)refKind - oldKind) &lt;&lt; MN_REFERENCE_KIND_SHIFT);
 364         return this;
 365     }
 366 
 367     private boolean testFlags(int mask, int value) {
 368         return (flags &amp; mask) == value;
 369     }
 370     private boolean testAllFlags(int mask) {
 371         return testFlags(mask, mask);
 372     }
 373     private boolean testAnyFlags(int mask) {
 374         return !testFlags(mask, 0);
 375     }
 376 
 377     /** Utility method to query if this member is a method handle invocation (invoke or invokeExact).
 378      */
 379     public boolean isMethodHandleInvoke() {
 380         final int bits = MH_INVOKE_MODS &amp;~ Modifier.PUBLIC;
 381         final int negs = Modifier.STATIC;
 382         if (testFlags(bits | negs, bits) &amp;&amp;
 383             clazz == MethodHandle.class) {
 384             return isMethodHandleInvokeName(name);
 385         }
 386         return false;
 387     }
 388     public static boolean isMethodHandleInvokeName(String name) {
 389         switch (name) {
 390         case &quot;invoke&quot;:
 391         case &quot;invokeExact&quot;:
 392             return true;
 393         default:
 394             return false;
 395         }
 396     }
 397     public boolean isVarHandleMethodInvoke() {
 398         final int bits = MH_INVOKE_MODS &amp;~ Modifier.PUBLIC;
 399         final int negs = Modifier.STATIC;
 400         if (testFlags(bits | negs, bits) &amp;&amp;
 401             clazz == VarHandle.class) {
 402             return isVarHandleMethodInvokeName(name);
 403         }
 404         return false;
 405     }
 406     public static boolean isVarHandleMethodInvokeName(String name) {
 407         try {
 408             VarHandle.AccessMode.valueFromMethodName(name);
 409             return true;
 410         } catch (IllegalArgumentException e) {
 411             return false;
 412         }
 413     }
 414     private static final int MH_INVOKE_MODS = Modifier.NATIVE | Modifier.FINAL | Modifier.PUBLIC;
 415 
 416     /** Utility method to query the modifier flags of this member. */
 417     public boolean isStatic() {
 418         return Modifier.isStatic(flags);
 419     }
 420     /** Utility method to query the modifier flags of this member. */
 421     public boolean isPublic() {
 422         return Modifier.isPublic(flags);
 423     }
 424     /** Utility method to query the modifier flags of this member. */
 425     public boolean isPrivate() {
 426         return Modifier.isPrivate(flags);
 427     }
 428     /** Utility method to query the modifier flags of this member. */
 429     public boolean isProtected() {
 430         return Modifier.isProtected(flags);
 431     }
 432     /** Utility method to query the modifier flags of this member. */
 433     public boolean isFinal() {
 434         // all fields declared in a value type are effectively final
 435         assert(!clazz.isInlineClass() || !isField() || Modifier.isFinal(flags));
 436         return Modifier.isFinal(flags);
 437     }
 438     /** Utility method to query whether this member or its defining class is final. */
 439     public boolean canBeStaticallyBound() {
 440         return Modifier.isFinal(flags | clazz.getModifiers());
 441     }
 442     /** Utility method to query the modifier flags of this member. */
 443     public boolean isVolatile() {
 444         return Modifier.isVolatile(flags);
 445     }
 446     /** Utility method to query the modifier flags of this member. */
 447     public boolean isAbstract() {
 448         return Modifier.isAbstract(flags);
 449     }
 450     /** Utility method to query the modifier flags of this member. */
 451     public boolean isNative() {
 452         return Modifier.isNative(flags);
 453     }
 454     // let the rest (native, volatile, transient, etc.) be tested via Modifier.isFoo
 455 
 456     // unofficial modifier flags, used by HotSpot:
 457     static final int BRIDGE      = 0x00000040;
 458     static final int VARARGS     = 0x00000080;
 459     static final int SYNTHETIC   = 0x00001000;
 460     static final int ANNOTATION  = 0x00002000;
 461     static final int ENUM        = 0x00004000;
 462     static final int FLATTENED   = 0x00008000;
 463 
 464     /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
 465     public boolean isBridge() {
 466         return testAllFlags(IS_METHOD | BRIDGE);
 467     }
 468     /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
 469     public boolean isVarargs() {
 470         return testAllFlags(VARARGS) &amp;&amp; isInvocable();
 471     }
 472     /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
 473     public boolean isSynthetic() {
 474         return testAllFlags(SYNTHETIC);
 475     }
 476 
 477     /** Query whether this member is a flattened field */
 478     public boolean isFlattened() { return (flags &amp; FLATTENED) == FLATTENED; }
 479 
 480     /** Query whether this member is a field of an inline class. */
 481     public boolean isInlineable()  {
 482         if (isField()) {
 483             Class&lt;?&gt; type = getFieldType();
<a name="4" id="anc4"></a><span class="line-modified"> 484             return type.isInlineClass() &amp;&amp; type == type.asPrimaryType();</span>
 485         }
 486         return false;
 487     }
 488 
 489     public boolean isIndirect()  {
 490         if (isField()) {
<a name="5" id="anc5"></a><span class="line-modified"> 491             return getFieldType().isIndirectType();</span>
 492         }
 493         return false;
 494     }
 495 
 496     static final String CONSTRUCTOR_NAME = &quot;&lt;init&gt;&quot;;  // the ever-popular
 497 
 498     // modifiers exported by the JVM:
 499     static final int RECOGNIZED_MODIFIERS = 0xFFFF;
 500 
 501     // private flags, not part of RECOGNIZED_MODIFIERS:
 502     static final int
 503             IS_METHOD             = MN_IS_METHOD,              // method (not object constructor)
 504             IS_OBJECT_CONSTRUCTOR = MN_IS_OBJECT_CONSTRUCTOR,  // object constructor
 505             IS_FIELD              = MN_IS_FIELD,               // field
 506             IS_TYPE               = MN_IS_TYPE,                // nested type
 507             CALLER_SENSITIVE      = MN_CALLER_SENSITIVE;       // @CallerSensitive annotation detected
 508 
 509     static final int ALL_ACCESS = Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED;
 510     static final int ALL_KINDS = IS_METHOD | IS_OBJECT_CONSTRUCTOR | IS_FIELD | IS_TYPE;
 511     static final int IS_INVOCABLE = IS_METHOD | IS_OBJECT_CONSTRUCTOR;
 512     static final int IS_FIELD_OR_METHOD = IS_METHOD | IS_FIELD;
 513     static final int SEARCH_ALL_SUPERS = MN_SEARCH_SUPERCLASSES | MN_SEARCH_INTERFACES;
 514 
 515     /** Utility method to query whether this member is a method or constructor. */
 516     public boolean isInvocable() {
 517         return testAnyFlags(IS_INVOCABLE);
 518     }
 519     /** Utility method to query whether this member is a method, constructor, or field. */
 520     public boolean isFieldOrMethod() {
 521         return testAnyFlags(IS_FIELD_OR_METHOD);
 522     }
 523     /** Query whether this member is a method. */
 524     public boolean isMethod() {
 525         return testAllFlags(IS_METHOD);
 526     }
 527     /** Query whether this member is a constructor. */
 528     public boolean isObjectConstructor() {
 529         return testAllFlags(IS_OBJECT_CONSTRUCTOR);
 530     }
 531     /** Query whether this member is an object constructor or static &lt;init&gt; factory */
 532     public boolean isObjectConstructorOrStaticInitMethod() {
 533         return isObjectConstructor() || (getName().equals(CONSTRUCTOR_NAME) &amp;&amp; testAllFlags(IS_METHOD));
 534     }
 535     /** Query whether this member is a field. */
 536     public boolean isField() {
 537         return testAllFlags(IS_FIELD);
 538     }
 539     /** Query whether this member is a type. */
 540     public boolean isType() {
 541         return testAllFlags(IS_TYPE);
 542     }
 543     /** Utility method to query whether this member is neither public, private, nor protected. */
 544     public boolean isPackage() {
 545         return !testAnyFlags(ALL_ACCESS);
 546     }
 547     /** Query whether this member has a CallerSensitive annotation. */
 548     public boolean isCallerSensitive() {
 549         return testAllFlags(CALLER_SENSITIVE);
 550     }
 551 
 552     /** Utility method to query whether this member is accessible from a given lookup class. */
 553     public boolean isAccessibleFrom(Class&lt;?&gt; lookupClass) {
 554         int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);
 555         return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,
 556                                                lookupClass, null, mode);
 557     }
 558 
 559     /**
 560      * Check if MemberName is a call to a method named {@code name} in class {@code declaredClass}.
 561      */
 562     public boolean refersTo(Class&lt;?&gt; declc, String n) {
 563         return clazz == declc &amp;&amp; getName().equals(n);
 564     }
 565 
 566     /** Initialize a query.   It is not resolved. */
 567     private void init(Class&lt;?&gt; defClass, String name, Object type, int flags) {
 568         // defining class is allowed to be null (for a naked name/type pair)
 569         //name.toString();  // null check
 570         //type.equals(type);  // null check
 571         // fill in fields:
 572         this.clazz = defClass;
 573         this.name = name;
 574         this.type = type;
 575         this.flags = flags;
 576         assert(testAnyFlags(ALL_KINDS));
 577         assert(this.resolution == null);  // nobody should have touched this yet
 578         //assert(referenceKindIsConsistent());  // do this after resolution
 579     }
 580 
 581     /**
 582      * Calls down to the VM to fill in the fields.  This method is
 583      * synchronized to avoid racing calls.
 584      */
 585     private void expandFromVM() {
 586         if (type != null) {
 587             return;
 588         }
 589         if (!isResolved()) {
 590             return;
 591         }
 592         MethodHandleNatives.expand(this);
 593     }
 594 
 595     // Capturing information from the Core Reflection API:
 596     private static int flagsMods(int flags, int mods, byte refKind) {
 597         assert((flags &amp; RECOGNIZED_MODIFIERS) == 0);
 598         assert((mods &amp; ~RECOGNIZED_MODIFIERS) == 0);
 599         assert((refKind &amp; ~MN_REFERENCE_KIND_MASK) == 0);
 600         return flags | mods | (refKind &lt;&lt; MN_REFERENCE_KIND_SHIFT);
 601     }
 602     /** Create a name for the given reflected method.  The resulting name will be in a resolved state. */
 603     public MemberName(Method m) {
 604         this(m, false);
 605     }
 606     @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)
 607     public MemberName(Method m, boolean wantSpecial) {
 608         Objects.requireNonNull(m);
 609         // fill in vmtarget, vmindex while we have m in hand:
 610         MethodHandleNatives.init(this, m);
 611         if (clazz == null) {  // MHN.init failed
 612             if (m.getDeclaringClass() == MethodHandle.class &amp;&amp;
 613                 isMethodHandleInvokeName(m.getName())) {
 614                 // The JVM did not reify this signature-polymorphic instance.
 615                 // Need a special case here.
 616                 // See comments on MethodHandleNatives.linkMethod.
 617                 MethodType type = MethodType.methodType(m.getReturnType(), m.getParameterTypes());
 618                 int flags = flagsMods(IS_METHOD, m.getModifiers(), REF_invokeVirtual);
 619                 init(MethodHandle.class, m.getName(), type, flags);
 620                 if (isMethodHandleInvoke())
 621                     return;
 622             }
 623             if (m.getDeclaringClass() == VarHandle.class &amp;&amp;
 624                 isVarHandleMethodInvokeName(m.getName())) {
 625                 // The JVM did not reify this signature-polymorphic instance.
 626                 // Need a special case here.
 627                 // See comments on MethodHandleNatives.linkMethod.
 628                 MethodType type = MethodType.methodType(m.getReturnType(), m.getParameterTypes());
 629                 int flags = flagsMods(IS_METHOD, m.getModifiers(), REF_invokeVirtual);
 630                 init(VarHandle.class, m.getName(), type, flags);
 631                 if (isVarHandleMethodInvoke())
 632                     return;
 633             }
 634             throw new LinkageError(m.toString());
 635         }
 636         assert(isResolved() &amp;&amp; this.clazz != null);
 637         this.name = m.getName();
 638         if (this.type == null)
 639             this.type = new Object[] { m.getReturnType(), m.getParameterTypes() };
 640         if (wantSpecial) {
 641             if (isAbstract())
 642                 throw new AbstractMethodError(this.toString());
 643             if (getReferenceKind() == REF_invokeVirtual)
 644                 changeReferenceKind(REF_invokeSpecial, REF_invokeVirtual);
 645             else if (getReferenceKind() == REF_invokeInterface)
 646                 // invokeSpecial on a default method
 647                 changeReferenceKind(REF_invokeSpecial, REF_invokeInterface);
 648         }
 649     }
 650     public MemberName asSpecial() {
 651         switch (getReferenceKind()) {
 652         case REF_invokeSpecial:     return this;
 653         case REF_invokeVirtual:     return clone().changeReferenceKind(REF_invokeSpecial, REF_invokeVirtual);
 654         case REF_invokeInterface:   return clone().changeReferenceKind(REF_invokeSpecial, REF_invokeInterface);
 655         case REF_newInvokeSpecial:  return clone().changeReferenceKind(REF_invokeSpecial, REF_newInvokeSpecial);
 656         }
 657         throw new IllegalArgumentException(this.toString());
 658     }
 659     /** If this MN is not REF_newInvokeSpecial, return a clone with that ref. kind.
 660      *  In that case it must already be REF_invokeSpecial.
 661      */
 662     public MemberName asObjectConstructor() {
 663         switch (getReferenceKind()) {
 664         case REF_invokeSpecial:     return clone().changeReferenceKind(REF_newInvokeSpecial, REF_invokeSpecial);
 665         case REF_newInvokeSpecial:  return this;
 666         }
 667         throw new IllegalArgumentException(this.toString());
 668     }
 669     /** If this MN is a REF_invokeSpecial, return a clone with the &quot;normal&quot; kind
 670      *  REF_invokeVirtual; also switch either to REF_invokeInterface if clazz.isInterface.
 671      *  The end result is to get a fully virtualized version of the MN.
 672      *  (Note that resolving in the JVM will sometimes devirtualize, changing
 673      *  REF_invokeVirtual of a final to REF_invokeSpecial, and REF_invokeInterface
 674      *  in some corner cases to either of the previous two; this transform
 675      *  undoes that change under the assumption that it occurred.)
 676      */
 677     public MemberName asNormalOriginal() {
 678         byte normalVirtual = clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;
 679         byte refKind = getReferenceKind();
 680         byte newRefKind = refKind;
 681         MemberName result = this;
 682         switch (refKind) {
 683         case REF_invokeInterface:
 684         case REF_invokeVirtual:
 685         case REF_invokeSpecial:
 686             newRefKind = normalVirtual;
 687             break;
 688         }
 689         if (newRefKind == refKind)
 690             return this;
 691         result = clone().changeReferenceKind(newRefKind, refKind);
 692         assert(this.referenceKindIsConsistentWith(result.getReferenceKind()));
 693         return result;
 694     }
 695     /** Create a name for the given reflected constructor.  The resulting name will be in a resolved state. */
 696     @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)
 697     public MemberName(Constructor&lt;?&gt; ctor) {
 698         Objects.requireNonNull(ctor);
 699         // fill in vmtarget, vmindex while we have ctor in hand:
 700         MethodHandleNatives.init(this, ctor);
 701         assert(isResolved() &amp;&amp; this.clazz != null);
 702         this.name = CONSTRUCTOR_NAME;
 703         if (this.type == null) {
 704             Class&lt;?&gt; rtype = void.class;
 705             if (isStatic()) {  // a static init factory, not a true constructor
 706                 rtype = getDeclaringClass();
 707                 // FIXME: If it&#39;s a hidden class, this sig won&#39;t work.
 708             }
 709             this.type = new Object[] { rtype, ctor.getParameterTypes() };
 710         }
 711     }
 712     /** Create a name for the given reflected field.  The resulting name will be in a resolved state.
 713      */
 714     public MemberName(Field fld) {
 715         this(fld, false);
 716     }
 717     @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)
 718     public MemberName(Field fld, boolean makeSetter) {
 719         Objects.requireNonNull(fld);
 720         // fill in vmtarget, vmindex while we have fld in hand:
 721         MethodHandleNatives.init(this, fld);
 722         assert(isResolved() &amp;&amp; this.clazz != null);
 723         this.name = fld.getName();
 724         this.type = fld.getType();
 725         assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));
 726         byte refKind = this.getReferenceKind();
 727         assert(refKind == (isStatic() ? REF_getStatic : REF_getField));
 728         if (makeSetter) {
 729             changeReferenceKind((byte)(refKind + (REF_putStatic - REF_getStatic)), refKind);
 730         }
 731     }
 732     public boolean isGetter() {
 733         return MethodHandleNatives.refKindIsGetter(getReferenceKind());
 734     }
 735     public boolean isSetter() {
 736         return MethodHandleNatives.refKindIsSetter(getReferenceKind());
 737     }
 738     public MemberName asSetter() {
 739         byte refKind = getReferenceKind();
 740         assert(MethodHandleNatives.refKindIsGetter(refKind));
 741         assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));
 742         byte setterRefKind = (byte)(refKind + (REF_putField - REF_getField));
 743         return clone().changeReferenceKind(setterRefKind, refKind);
 744     }
 745     /** Create a name for the given class.  The resulting name will be in a resolved state. */
 746     public MemberName(Class&lt;?&gt; type) {
 747         init(type.getDeclaringClass(), type.getSimpleName(), type,
 748                 flagsMods(IS_TYPE, type.getModifiers(), REF_NONE));
 749         initResolved(true);
 750     }
 751 
 752     /**
 753      * Create a name for a signature-polymorphic invoker.
 754      * This is a placeholder for a signature-polymorphic instance
 755      * (of MH.invokeExact, etc.) that the JVM does not reify.
 756      * See comments on {@link MethodHandleNatives#linkMethod}.
 757      */
 758     static MemberName makeMethodHandleInvoke(String name, MethodType type) {
 759         return makeMethodHandleInvoke(name, type, MH_INVOKE_MODS | SYNTHETIC);
 760     }
 761     static MemberName makeMethodHandleInvoke(String name, MethodType type, int mods) {
 762         MemberName mem = new MemberName(MethodHandle.class, name, type, REF_invokeVirtual);
 763         mem.flags |= mods;  // it&#39;s not resolved, but add these modifiers anyway
 764         assert(mem.isMethodHandleInvoke()) : mem;
 765         return mem;
 766     }
 767 
 768     static MemberName makeVarHandleMethodInvoke(String name, MethodType type) {
 769         return makeVarHandleMethodInvoke(name, type, MH_INVOKE_MODS | SYNTHETIC);
 770     }
 771     static MemberName makeVarHandleMethodInvoke(String name, MethodType type, int mods) {
 772         MemberName mem = new MemberName(VarHandle.class, name, type, REF_invokeVirtual);
 773         mem.flags |= mods;  // it&#39;s not resolved, but add these modifiers anyway
 774         assert(mem.isVarHandleMethodInvoke()) : mem;
 775         return mem;
 776     }
 777 
 778     // bare-bones constructor; the JVM will fill it in
 779     MemberName() { }
 780 
 781     // locally useful cloner
 782     @Override protected MemberName clone() {
 783         try {
 784             return (MemberName) super.clone();
 785         } catch (CloneNotSupportedException ex) {
 786             throw newInternalError(ex);
 787         }
 788      }
 789 
 790     /** Get the definition of this member name.
 791      *  This may be in a super-class of the declaring class of this member.
 792      */
 793     public MemberName getDefinition() {
 794         if (!isResolved())  throw new IllegalStateException(&quot;must be resolved: &quot;+this);
 795         if (isType())  return this;
 796         MemberName res = this.clone();
 797         res.clazz = null;
 798         res.type = null;
 799         res.name = null;
 800         res.resolution = res;
 801         res.expandFromVM();
 802         assert(res.getName().equals(this.getName()));
 803         return res;
 804     }
 805 
 806     @Override
 807     @SuppressWarnings(&quot;deprecation&quot;)
 808     public int hashCode() {
 809         // Avoid autoboxing getReferenceKind(), since this is used early and will force
 810         // early initialization of Byte$ByteCache
 811         return Objects.hash(clazz, new Byte(getReferenceKind()), name, getType());
 812     }
 813 
 814     @Override
 815     public boolean equals(Object that) {
 816         return (that instanceof MemberName &amp;&amp; this.equals((MemberName)that));
 817     }
 818 
 819     /** Decide if two member names have exactly the same symbolic content.
 820      *  Does not take into account any actual class members, so even if
 821      *  two member names resolve to the same actual member, they may
 822      *  be distinct references.
 823      */
 824     public boolean equals(MemberName that) {
 825         if (this == that)  return true;
 826         if (that == null)  return false;
 827         return this.clazz == that.clazz
 828                 &amp;&amp; this.getReferenceKind() == that.getReferenceKind()
 829                 &amp;&amp; Objects.equals(this.name, that.name)
 830                 &amp;&amp; Objects.equals(this.getType(), that.getType());
 831     }
 832 
 833     // Construction from symbolic parts, for queries:
 834     /** Create a field or type name from the given components:
 835      *  Declaring class, name, type, reference kind.
 836      *  The declaring class may be supplied as null if this is to be a bare name and type.
 837      *  The resulting name will in an unresolved state.
 838      */
 839     public MemberName(Class&lt;?&gt; defClass, String name, Class&lt;?&gt; type, byte refKind) {
 840         init(defClass, name, type, flagsMods(IS_FIELD, 0, refKind));
 841         initResolved(false);
 842     }
 843     /** Create a method or constructor name from the given components:
 844      *  Declaring class, name, type, reference kind.
 845      *  It will be a constructor if and only if the name is {@code &quot;&lt;init&gt;&quot;}.
 846      *  The declaring class may be supplied as null if this is to be a bare name and type.
 847      *  The last argument is optional, a boolean which requests REF_invokeSpecial.
 848      *  The resulting name will in an unresolved state.
 849      */
 850     public MemberName(Class&lt;?&gt; defClass, String name, MethodType type, byte refKind) {
 851         int initFlags = (name != null &amp;&amp; name.equals(CONSTRUCTOR_NAME) &amp;&amp; type.returnType() == void.class ? IS_OBJECT_CONSTRUCTOR : IS_METHOD);
 852         init(defClass, name, type, flagsMods(initFlags, 0, refKind));
 853         initResolved(false);
 854     }
 855     /** Create a method, constructor, or field name from the given components:
 856      *  Reference kind, declaring class, name, type.
 857      */
 858     public MemberName(byte refKind, Class&lt;?&gt; defClass, String name, Object type) {
 859         int kindFlags;
 860         if (MethodHandleNatives.refKindIsField(refKind)) {
 861             kindFlags = IS_FIELD;
 862             if (!(type instanceof Class))
 863                 throw newIllegalArgumentException(&quot;not a field type&quot;);
 864         } else if (MethodHandleNatives.refKindIsMethod(refKind)) {
 865             kindFlags = IS_METHOD;
 866             if (!(type instanceof MethodType))
 867                 throw newIllegalArgumentException(&quot;not a method type&quot;);
 868         } else if (refKind == REF_newInvokeSpecial) {
 869             kindFlags = IS_OBJECT_CONSTRUCTOR;
 870             if (!(type instanceof MethodType) ||
 871                 !CONSTRUCTOR_NAME.equals(name))
 872                 throw newIllegalArgumentException(&quot;not a constructor type or name&quot;);
 873         } else {
 874             throw newIllegalArgumentException(&quot;bad reference kind &quot;+refKind);
 875         }
 876         init(defClass, name, type, flagsMods(kindFlags, 0, refKind));
 877         initResolved(false);
 878     }
 879     /** Query whether this member name is resolved to a non-static, non-final method.
 880      */
 881     public boolean hasReceiverTypeDispatch() {
 882         return MethodHandleNatives.refKindDoesDispatch(getReferenceKind());
 883     }
 884 
 885     /** Query whether this member name is resolved.
 886      *  A resolved member name is one for which the JVM has found
 887      *  a method, constructor, field, or type binding corresponding exactly to the name.
 888      *  (Document?)
 889      */
 890     public boolean isResolved() {
 891         return resolution == null;
 892     }
 893 
 894     void initResolved(boolean isResolved) {
 895         assert(this.resolution == null);  // not initialized yet!
 896         if (!isResolved)
 897             this.resolution = this;
 898         assert(isResolved() == isResolved);
 899     }
 900 
 901     void checkForTypeAlias(Class&lt;?&gt; refc) {
 902         if (isInvocable()) {
 903             MethodType type;
 904             if (this.type instanceof MethodType)
 905                 type = (MethodType) this.type;
 906             else
 907                 this.type = type = getMethodType();
 908             if (type.erase() == type)  return;
 909             if (VerifyAccess.isTypeVisible(type, refc))  return;
 910             throw new LinkageError(&quot;bad method type alias: &quot;+type+&quot; not visible from &quot;+refc);
 911         } else {
 912             Class&lt;?&gt; type;
 913             if (this.type instanceof Class&lt;?&gt;)
 914                 type = (Class&lt;?&gt;) this.type;
 915             else
 916                 this.type = type = getFieldType();
 917             if (VerifyAccess.isTypeVisible(type, refc))  return;
 918             throw new LinkageError(&quot;bad field type alias: &quot;+type+&quot; not visible from &quot;+refc);
 919         }
 920     }
 921 
 922 
 923     /** Produce a string form of this member name.
 924      *  For types, it is simply the type&#39;s own string (as reported by {@code toString}).
 925      *  For fields, it is {@code &quot;DeclaringClass.name/type&quot;}.
 926      *  For methods and constructors, it is {@code &quot;DeclaringClass.name(ptype...)rtype&quot;}.
 927      *  If the declaring class is null, the prefix {@code &quot;DeclaringClass.&quot;} is omitted.
 928      *  If the member is unresolved, a prefix {@code &quot;*.&quot;} is prepended.
 929      */
 930     @SuppressWarnings(&quot;LocalVariableHidesMemberVariable&quot;)
 931     @Override
 932     public String toString() {
 933         if (isType())
 934             return type.toString();  // class java.lang.String
 935         // else it is a field, method, or constructor
 936         StringBuilder buf = new StringBuilder();
 937         if (getDeclaringClass() != null) {
 938             buf.append(getName(clazz));
 939             buf.append(&#39;.&#39;);
 940         }
 941         String name = this.name; // avoid expanding from VM
 942         buf.append(name == null ? &quot;*&quot; : name);
 943         Object type = this.type; // avoid expanding from VM
 944         if (!isInvocable()) {
 945             buf.append(&#39;/&#39;);
 946             buf.append(type == null ? &quot;*&quot; : getName(type));
 947         } else {
 948             buf.append(type == null ? &quot;(*)*&quot; : getName(type));
 949         }
 950         byte refKind = getReferenceKind();
 951         if (refKind != REF_NONE) {
 952             buf.append(&#39;/&#39;);
 953             buf.append(MethodHandleNatives.refKindName(refKind));
 954         }
 955         //buf.append(&quot;#&quot;).append(System.identityHashCode(this));
 956         return buf.toString();
 957     }
 958     private static String getName(Object obj) {
 959         if (obj instanceof Class&lt;?&gt;)
<a name="6" id="anc6"></a><span class="line-modified"> 960             return toTypeName((Class&lt;?&gt;)obj);</span>
 961         return String.valueOf(obj);
 962     }
 963 
<a name="7" id="anc7"></a><span class="line-removed"> 964     /*</span>
<span class="line-removed"> 965      * Returns the class name appended with &quot;?&quot; if it is the nullable projection</span>
<span class="line-removed"> 966      * of an inline class.</span>
<span class="line-removed"> 967      */</span>
<span class="line-removed"> 968     private static String toTypeName(Class&lt;?&gt; type) {</span>
<span class="line-removed"> 969         return type.isInlineClass() &amp;&amp; type.isIndirectType() ? type.getName() + &quot;?&quot; : type.getName();</span>
<span class="line-removed"> 970     }</span>
<span class="line-removed"> 971 </span>
<span class="line-removed"> 972 </span>
 973     public IllegalAccessException makeAccessException(String message, Object from) {
 974         message = message + &quot;: &quot;+ toString();
 975         if (from != null)  {
 976             if (from == MethodHandles.publicLookup()) {
 977                 message += &quot;, from public Lookup&quot;;
 978             } else {
 979                 Module m;
 980                 Class&lt;?&gt; plc;
 981                 if (from instanceof MethodHandles.Lookup) {
 982                     MethodHandles.Lookup lookup = (MethodHandles.Lookup)from;
 983                     from = lookup.lookupClass();
 984                     m = lookup.lookupClass().getModule();
 985                     plc = lookup.previousLookupClass();
 986                 } else {
 987                     m = ((Class&lt;?&gt;)from).getModule();
 988                     plc = null;
 989                 }
 990                 message += &quot;, from &quot; + from + &quot; (&quot; + m + &quot;)&quot;;
 991                 if (plc != null) {
 992                     message += &quot;, previous lookup &quot; +
 993                         plc.getName() + &quot; (&quot; + plc.getModule() + &quot;)&quot;;
 994                 }
 995             }
 996         }
 997         return new IllegalAccessException(message);
 998     }
 999     private String message() {
1000         if (isResolved())
1001             return &quot;no access&quot;;
1002         else if (isObjectConstructor())
1003             return &quot;no such constructor&quot;;
1004         else if (isMethod())
1005             return &quot;no such method&quot;;
1006         else
1007             return &quot;no such field&quot;;
1008     }
1009     public ReflectiveOperationException makeAccessException() {
1010         String message = message() + &quot;: &quot;+ toString();
1011         ReflectiveOperationException ex;
1012         if (isResolved() || !(resolution instanceof NoSuchMethodError ||
1013                               resolution instanceof NoSuchFieldError))
1014             ex = new IllegalAccessException(message);
1015         else if (isObjectConstructor())
1016             ex = new NoSuchMethodException(message);
1017         else if (isMethod())
1018             ex = new NoSuchMethodException(message);
1019         else
1020             ex = new NoSuchFieldException(message);
1021         if (resolution instanceof Throwable)
1022             ex.initCause((Throwable) resolution);
1023         return ex;
1024     }
1025 
1026     /** Actually making a query requires an access check. */
1027     /*non-public*/
1028     static Factory getFactory() {
1029         return Factory.INSTANCE;
1030     }
1031     /** A factory type for resolving member names with the help of the VM.
1032      *  TBD: Define access-safe public constructors for this factory.
1033      */
1034     /*non-public*/
1035     static class Factory {
1036         private Factory() { } // singleton pattern
1037         static Factory INSTANCE = new Factory();
1038 
1039         private static int ALLOWED_FLAGS = ALL_KINDS;
1040 
1041         /// Queries
1042         List&lt;MemberName&gt; getMembers(Class&lt;?&gt; defc,
1043                 String matchName, Object matchType,
1044                 int matchFlags, Class&lt;?&gt; lookupClass) {
1045             matchFlags &amp;= ALLOWED_FLAGS;
1046             String matchSig = null;
1047             if (matchType != null) {
1048                 matchSig = BytecodeDescriptor.unparse(matchType);
1049                 if (matchSig.startsWith(&quot;(&quot;))
1050                     matchFlags &amp;= ~(ALL_KINDS &amp; ~IS_INVOCABLE);
1051                 else
1052                     matchFlags &amp;= ~(ALL_KINDS &amp; ~IS_FIELD);
1053             }
1054             final int BUF_MAX = 0x2000;
1055             int len1 = matchName == null ? 10 : matchType == null ? 4 : 1;
1056             MemberName[] buf = newMemberBuffer(len1);
1057             int totalCount = 0;
1058             ArrayList&lt;MemberName[]&gt; bufs = null;
1059             int bufCount = 0;
1060             for (;;) {
1061                 bufCount = MethodHandleNatives.getMembers(defc,
1062                         matchName, matchSig, matchFlags,
1063                         lookupClass,
1064                         totalCount, buf);
1065                 if (bufCount &lt;= buf.length) {
1066                     if (bufCount &lt; 0)  bufCount = 0;
1067                     totalCount += bufCount;
1068                     break;
1069                 }
1070                 // JVM returned to us with an intentional overflow!
1071                 totalCount += buf.length;
1072                 int excess = bufCount - buf.length;
1073                 if (bufs == null)  bufs = new ArrayList&lt;&gt;(1);
1074                 bufs.add(buf);
1075                 int len2 = buf.length;
1076                 len2 = Math.max(len2, excess);
1077                 len2 = Math.max(len2, totalCount / 4);
1078                 buf = newMemberBuffer(Math.min(BUF_MAX, len2));
1079             }
1080             ArrayList&lt;MemberName&gt; result = new ArrayList&lt;&gt;(totalCount);
1081             if (bufs != null) {
1082                 for (MemberName[] buf0 : bufs) {
1083                     Collections.addAll(result, buf0);
1084                 }
1085             }
1086             for (int i = 0; i &lt; bufCount; i++) {
1087                 result.add(buf[i]);
1088             }
1089             // Signature matching is not the same as type matching, since
1090             // one signature might correspond to several types.
1091             // So if matchType is a Class or MethodType, refilter the results.
1092             if (matchType != null &amp;&amp; matchType != matchSig) {
1093                 for (Iterator&lt;MemberName&gt; it = result.iterator(); it.hasNext();) {
1094                     MemberName m = it.next();
1095                     if (!matchType.equals(m.getType()))
1096                         it.remove();
1097                 }
1098             }
1099             return result;
1100         }
1101         /** Produce a resolved version of the given member.
1102          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1103          *  Access checking is performed on behalf of the given {@code lookupClass}.
1104          *  If lookup fails or access is not permitted, null is returned.
1105          *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
1106          */
1107         private MemberName resolve(byte refKind, MemberName ref, Class&lt;?&gt; lookupClass,
1108                                    boolean speculativeResolve) {
1109             MemberName m = ref.clone();  // JVM will side-effect the ref
1110             assert(refKind == m.getReferenceKind());
1111             try {
1112                 // There are 4 entities in play here:
1113                 //   * LC: lookupClass
1114                 //   * REFC: symbolic reference class (MN.clazz before resolution);
1115                 //   * DEFC: resolved method holder (MN.clazz after resolution);
1116                 //   * PTYPES: parameter types (MN.type)
1117                 //
1118                 // What we care about when resolving a MemberName is consistency between DEFC and PTYPES.
1119                 // We do type alias (TA) checks on DEFC to ensure that. DEFC is not known until the JVM
1120                 // finishes the resolution, so do TA checks right after MHN.resolve() is over.
1121                 //
1122                 // All parameters passed by a caller are checked against MH type (PTYPES) on every invocation,
1123                 // so it is safe to call a MH from any context.
1124                 //
1125                 // REFC view on PTYPES doesn&#39;t matter, since it is used only as a starting point for resolution and doesn&#39;t
1126                 // participate in method selection.
1127                 m = MethodHandleNatives.resolve(m, lookupClass, speculativeResolve);
1128                 if (m == null &amp;&amp; speculativeResolve) {
1129                     return null;
1130                 }
1131                 m.checkForTypeAlias(m.getDeclaringClass());
1132                 m.resolution = null;
1133             } catch (ClassNotFoundException | LinkageError ex) {
1134                 // JVM reports that the &quot;bytecode behavior&quot; would get an error
1135                 assert(!m.isResolved());
1136                 m.resolution = ex;
1137                 return m;
1138             }
1139             assert(m.referenceKindIsConsistent());
1140             m.initResolved(true);
1141             assert(m.vminfoIsConsistent());
1142             return m;
1143         }
1144         /** Produce a resolved version of the given member.
1145          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1146          *  Access checking is performed on behalf of the given {@code lookupClass}.
1147          *  If lookup fails or access is not permitted, a {@linkplain ReflectiveOperationException} is thrown.
1148          *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
1149          */
1150         public &lt;NoSuchMemberException extends ReflectiveOperationException&gt;
1151                 MemberName resolveOrFail(byte refKind, MemberName m, Class&lt;?&gt; lookupClass,
1152                                  Class&lt;NoSuchMemberException&gt; nsmClass)
1153                 throws IllegalAccessException, NoSuchMemberException {
1154             MemberName result = resolve(refKind, m, lookupClass, false);
1155             if (result.isResolved())
1156                 return result;
1157             ReflectiveOperationException ex = result.makeAccessException();
1158             if (ex instanceof IllegalAccessException)  throw (IllegalAccessException) ex;
1159             throw nsmClass.cast(ex);
1160         }
1161         /** Produce a resolved version of the given member.
1162          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1163          *  Access checking is performed on behalf of the given {@code lookupClass}.
1164          *  If lookup fails or access is not permitted, return null.
1165          *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
1166          */
1167         public MemberName resolveOrNull(byte refKind, MemberName m, Class&lt;?&gt; lookupClass) {
1168             MemberName result = resolve(refKind, m, lookupClass, true);
1169             if (result != null &amp;&amp; result.isResolved())
1170                 return result;
1171             return null;
1172         }
1173         /** Return a list of all methods defined by the given class.
1174          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1175          *  Access checking is performed on behalf of the given {@code lookupClass}.
1176          *  Inaccessible members are not added to the last.
1177          */
1178         public List&lt;MemberName&gt; getMethods(Class&lt;?&gt; defc, boolean searchSupers,
1179                 Class&lt;?&gt; lookupClass) {
1180             return getMethods(defc, searchSupers, null, null, lookupClass);
1181         }
1182         /** Return a list of matching methods defined by the given class.
1183          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1184          *  Returned methods will match the name (if not null) and the type (if not null).
1185          *  Access checking is performed on behalf of the given {@code lookupClass}.
1186          *  Inaccessible members are not added to the last.
1187          */
1188         public List&lt;MemberName&gt; getMethods(Class&lt;?&gt; defc, boolean searchSupers,
1189                 String name, MethodType type, Class&lt;?&gt; lookupClass) {
1190             int matchFlags = IS_METHOD | (searchSupers ? SEARCH_ALL_SUPERS : 0);
1191             return getMembers(defc, name, type, matchFlags, lookupClass);
1192         }
1193         /** Return a list of all object constructors defined by the given class.
1194          *  Access checking is performed on behalf of the given {@code lookupClass}.
1195          *  Inaccessible members are not added to the last.
1196          */
1197         public List&lt;MemberName&gt; getObjectConstructors(Class&lt;?&gt; defc, Class&lt;?&gt; lookupClass) {
1198             return getMembers(defc, null, null, IS_OBJECT_CONSTRUCTOR, lookupClass);
1199         }
1200         /** Return a list of all fields defined by the given class.
1201          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1202          *  Access checking is performed on behalf of the given {@code lookupClass}.
1203          *  Inaccessible members are not added to the last.
1204          */
1205         public List&lt;MemberName&gt; getFields(Class&lt;?&gt; defc, boolean searchSupers,
1206                 Class&lt;?&gt; lookupClass) {
1207             return getFields(defc, searchSupers, null, null, lookupClass);
1208         }
1209         /** Return a list of all fields defined by the given class.
1210          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1211          *  Returned fields will match the name (if not null) and the type (if not null).
1212          *  Access checking is performed on behalf of the given {@code lookupClass}.
1213          *  Inaccessible members are not added to the last.
1214          */
1215         public List&lt;MemberName&gt; getFields(Class&lt;?&gt; defc, boolean searchSupers,
1216                 String name, Class&lt;?&gt; type, Class&lt;?&gt; lookupClass) {
1217             int matchFlags = IS_FIELD | (searchSupers ? SEARCH_ALL_SUPERS : 0);
1218             return getMembers(defc, name, type, matchFlags, lookupClass);
1219         }
1220         /** Return a list of all nested types defined by the given class.
1221          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1222          *  Access checking is performed on behalf of the given {@code lookupClass}.
1223          *  Inaccessible members are not added to the last.
1224          */
1225         public List&lt;MemberName&gt; getNestedTypes(Class&lt;?&gt; defc, boolean searchSupers,
1226                 Class&lt;?&gt; lookupClass) {
1227             int matchFlags = IS_TYPE | (searchSupers ? SEARCH_ALL_SUPERS : 0);
1228             return getMembers(defc, null, null, matchFlags, lookupClass);
1229         }
1230         private static MemberName[] newMemberBuffer(int length) {
1231             MemberName[] buf = new MemberName[length];
1232             // fill the buffer with dummy structs for the JVM to fill in
1233             for (int i = 0; i &lt; length; i++)
1234                 buf[i] = new MemberName();
1235             return buf;
1236         }
1237     }
1238 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
  31 import java.lang.module.ModuleReader;
  32 import java.lang.ref.SoftReference;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.ObjectStreamField;
  36 import java.lang.reflect.AnnotatedElement;
  37 import java.lang.reflect.AnnotatedType;
  38 import java.lang.reflect.Array;
  39 import java.lang.reflect.Constructor;
  40 import java.lang.reflect.Executable;
  41 import java.lang.reflect.Field;
  42 import java.lang.reflect.GenericArrayType;
  43 import java.lang.reflect.GenericDeclaration;
  44 import java.lang.reflect.InvocationTargetException;
  45 import java.lang.reflect.Member;
  46 import java.lang.reflect.Method;
  47 import java.lang.reflect.Modifier;
  48 import java.lang.reflect.Proxy;
  49 import java.lang.reflect.RecordComponent;
  50 import java.lang.reflect.Type;
  51 import java.lang.reflect.TypeVariable;
  52 import java.lang.constant.Constable;
  53 import java.net.URL;
  54 import java.security.AccessController;
  55 import java.security.PrivilegedAction;
  56 import java.util.ArrayList;
  57 import java.util.Arrays;
  58 import java.util.Collection;
  59 import java.util.HashMap;
  60 import java.util.LinkedHashMap;
  61 import java.util.LinkedHashSet;
  62 import java.util.List;
  63 import java.util.Map;
  64 import java.util.Objects;
  65 import java.util.Optional;
  66 import java.util.stream.Collectors;
  67 
  68 import jdk.internal.HotSpotIntrinsicCandidate;
  69 import jdk.internal.loader.BootLoader;
  70 import jdk.internal.loader.BuiltinClassLoader;
  71 import jdk.internal.misc.Unsafe;
  72 import jdk.internal.module.Resources;
  73 import jdk.internal.reflect.CallerSensitive;
  74 import jdk.internal.reflect.ConstantPool;
  75 import jdk.internal.reflect.Reflection;
  76 import jdk.internal.reflect.ReflectionFactory;
  77 import jdk.internal.vm.annotation.ForceInline;
  78 import sun.invoke.util.Wrapper;
  79 import sun.reflect.generics.factory.CoreReflectionFactory;
  80 import sun.reflect.generics.factory.GenericsFactory;
  81 import sun.reflect.generics.repository.ClassRepository;
  82 import sun.reflect.generics.repository.MethodRepository;
  83 import sun.reflect.generics.repository.ConstructorRepository;
  84 import sun.reflect.generics.scope.ClassScope;
  85 import sun.security.util.SecurityConstants;
  86 import sun.reflect.annotation.*;
  87 import sun.reflect.misc.ReflectUtil;
  88 
  89 /**
  90  * Instances of the class {@code Class} represent classes and
  91  * interfaces in a running Java application. An enum type and a record
  92  * type are kinds of class; an annotation type is a kind of
  93  * interface. Every array also belongs to a class that is reflected as
  94  * a {@code Class} object that is shared by all arrays with the same
  95  * element type and number of dimensions.  The primitive Java types
  96  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  97  * int}, {@code long}, {@code float}, and {@code double}), and the
  98  * keyword {@code void} are also represented as {@code Class} objects.
  99  *
 100  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
 101  * object is constructed automatically by the Java Virtual Machine
 102  * when a class loader invokes one of the
 103  * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
 104  * and passes the bytes of a {@code class} file.
 105  *
 106  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 107  * class or interface. Most characteristics are derived from the {@code class}
 108  * file that the class loader passed to the Java Virtual Machine. A few
 109  * characteristics are determined by the class loading environment at run time,
 110  * such as the module returned by {@link #getModule() getModule()}.
 111  *
 112  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 113  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 114  * another declaration. Other methods describe how a class or interface
 115  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 116  * classes and interfaces, in the same run-time package, that
 117  * allow mutual access to their {@code private} members.
 118  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 119  * One nestmate acts as the
 120  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 121  * belong to the nest; each of them in turn records it as the nest host.
 122  * The classes and interfaces which belong to a nest, including its host, are
 123  * determined when
 124  * {@code class} files are generated, for example, a Java compiler
 125  * will typically record a top-level class as the host of a nest where the
 126  * other members are the classes and interfaces whose declarations are
 127  * enclosed within the top-level class declaration.
 128  *
 129  * &lt;p&gt; The following example uses a {@code Class} object to print the
 130  * class name of an object:
 131  *
 132  * &lt;blockquote&gt;&lt;pre&gt;
 133  *     void printClassName(Object obj) {
 134  *         System.out.println(&quot;The class of &quot; + obj +
 135  *                            &quot; is &quot; + obj.getClass().getName());
 136  *     }
 137  * &lt;/pre&gt;&lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
 140  * type (or for void) using a class literal.  See Section {@jls
 141  * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 142  * For example:
 143  *
 144  * &lt;blockquote&gt;
 145  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
<a name="1" id="anc1"></a><span class="line-modified"> 166     private static final int INLINE     = 0x00000100;</span>
 167 
 168     private static native void registerNatives();
 169     static {
 170         registerNatives();
 171     }
 172 
 173     /*
 174      * Private constructor. Only the Java Virtual Machine creates Class objects.
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
 195      * @return a string representation of this {@code Class} object.
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
<a name="2" id="anc2"></a><span class="line-modified"> 200                + getName();</span>
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * {@code @interface}, or {@code record} as appropriate), followed
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
 221      * followed by an angle-bracketed comma-separated list of the
 222      * type&#39;s type parameters, if any, followed by a sequence of
 223      * {@code []} characters, one set of brackets per dimension of
 224      * the array.
 225      *
 226      * &lt;p&gt;Note that since information about the runtime representation
 227      * of a type is being generated, modifiers not present on the
 228      * originating source code or illegal on the originating source
 229      * code may be present.
 230      *
 231      * @return a string describing this {@code Class}, including
 232      * information about modifiers and type parameters
 233      *
 234      * @since 1.8
 235      */
 236     @SuppressWarnings(&quot;preview&quot;)
 237     public String toGenericString() {
 238         if (isPrimitive()) {
 239             return toString();
 240         } else {
 241             StringBuilder sb = new StringBuilder();
 242             Class&lt;?&gt; component = this;
 243             int arrayDepth = 0;
 244 
 245             if (isArray()) {
 246                 do {
 247                     arrayDepth++;
 248                     component = component.getComponentType();
 249                 } while (component.isArray());
 250                 sb.append(component.getName());
 251             } else {
 252                 // Class modifiers are a superset of interface modifiers
 253                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 254                 if (modifiers != 0) {
 255                     sb.append(Modifier.toString(modifiers));
 256                     sb.append(&#39; &#39;);
 257                 }
 258 
 259                 if (isAnnotation()) {
 260                     sb.append(&#39;@&#39;);
 261                 }
 262                 if (isInlineClass()) {
 263                     sb.append(&quot;inline&quot;);
 264                     sb.append(&#39; &#39;);
 265                 }
 266                 if (isInterface()) { // Note: all annotation types are interfaces
 267                     sb.append(&quot;interface&quot;);
 268                 } else {
 269                     if (isEnum())
 270                         sb.append(&quot;enum&quot;);
 271                     else if (isRecord())
 272                         sb.append(&quot;record&quot;);
 273                     else
 274                         sb.append(&quot;class&quot;);
 275                 }
 276                 sb.append(&#39; &#39;);
 277                 sb.append(getName());
 278             }
 279 
 280             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 281             if (typeparms.length &gt; 0) {
 282                 sb.append(Arrays.stream(typeparms)
 283                           .map(Class::typeVarBounds)
 284                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 285             }
 286 
 287             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));
 288 
 289             return sb.toString();
 290         }
 291     }
 292 
 293     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 294         Type[] bounds = typeVar.getBounds();
 295         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 296             return typeVar.getName();
 297         } else {
 298             return typeVar.getName() + &quot; extends &quot; +
 299                 Arrays.stream(bounds)
 300                 .map(Type::getTypeName)
 301                 .collect(Collectors.joining(&quot; &amp; &quot;));
 302         }
 303     }
 304 
 305     /**
 306      * Returns the {@code Class} object associated with the class or
 307      * interface with the given string name.  Invoking this method is
 308      * equivalent to:
 309      *
 310      * &lt;blockquote&gt;
 311      *  {@code Class.forName(className, true, currentLoader)}
 312      * &lt;/blockquote&gt;
 313      *
 314      * where {@code currentLoader} denotes the defining class loader of
 315      * the current class.
 316      *
 317      * &lt;p&gt; For example, the following code fragment returns the
 318      * runtime {@code Class} descriptor for the class named
 319      * {@code java.lang.Thread}:
 320      *
 321      * &lt;blockquote&gt;
 322      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 323      * &lt;/blockquote&gt;
 324      * &lt;p&gt;
 325      * A call to {@code forName(&quot;X&quot;)} causes the class named
 326      * {@code X} to be initialized.
 327      *
 328      * @param      className   the fully qualified name of the desired class.
 329      * @return     the {@code Class} object for the class with the
 330      *             specified name.
 331      * @throws    LinkageError if the linkage fails
 332      * @throws    ExceptionInInitializerError if the initialization provoked
 333      *            by this method fails
 334      * @throws    ClassNotFoundException if the class cannot be located
 335      *
 336      * @jls 12.2 Loading of Classes and Interfaces
 337      * @jls 12.3 Linking of Classes and Interfaces
 338      * @jls 12.4 Initialization of Classes and Interfaces
 339      */
 340     @CallerSensitive
 341     public static Class&lt;?&gt; forName(String className)
 342                 throws ClassNotFoundException {
 343         Class&lt;?&gt; caller = Reflection.getCallerClass();
 344         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 345     }
 346 
 347 
 348     /**
 349      * Returns the {@code Class} object associated with the class or
 350      * interface with the given string name, using the given class loader.
 351      * Given the fully qualified name for a class or interface (in the same
 352      * format returned by {@code getName}) this method attempts to
 353      * locate and load the class or interface.  The specified class
 354      * loader is used to load the class or interface.  If the parameter
 355      * {@code loader} is null, the class is loaded through the bootstrap
 356      * class loader.  The class is initialized only if the
 357      * {@code initialize} parameter is {@code true} and if it has
 358      * not been initialized earlier.
 359      *
 360      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 361      * will be made to locate a user-defined class in the unnamed package whose
 362      * name is {@code name}. Therefore, this method cannot be used to
 363      * obtain any of the {@code Class} objects representing primitive
 364      * types or void.
 365      *
 366      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 367      * the array class is loaded but not initialized.
 368      *
 369      * &lt;p&gt; For example, in an instance method the expression:
 370      *
 371      * &lt;blockquote&gt;
 372      *  {@code Class.forName(&quot;Foo&quot;)}
 373      * &lt;/blockquote&gt;
 374      *
 375      * is equivalent to:
 376      *
 377      * &lt;blockquote&gt;
 378      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 379      * &lt;/blockquote&gt;
 380      *
 381      * Note that this method throws errors related to loading, linking
 382      * or initializing as specified in Sections {@jls 12.2}, {@jls
 383      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language
 384      * Specification&lt;/cite&gt;.
 385      * Note that this method does not check whether the requested class
 386      * is accessible to its caller.
 387      *
 388      * @param name       fully qualified name of the desired class
 389 
 390      * @param initialize if {@code true} the class will be initialized
 391      *                   (which implies linking). See Section {@jls
 392      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language
 393      *                   Specification&lt;/cite&gt;.
 394      * @param loader     class loader from which the class must be loaded
 395      * @return           class object representing the desired class
 396      *
 397      * @throws    LinkageError if the linkage fails
 398      * @throws    ExceptionInInitializerError if the initialization provoked
 399      *            by this method fails
 400      * @throws    ClassNotFoundException if the class cannot be located by
 401      *            the specified class loader
 402      * @throws    SecurityException
 403      *            if a security manager is present, and the {@code loader} is
 404      *            {@code null}, and the caller&#39;s class loader is not
 405      *            {@code null}, and the caller does not have the
 406      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 407      *
 408      * @see       java.lang.Class#forName(String)
 409      * @see       java.lang.ClassLoader
 410      *
 411      * @jls 12.2 Loading of Classes and Interfaces
 412      * @jls 12.3 Linking of Classes and Interfaces
 413      * @jls 12.4 Initialization of Classes and Interfaces
 414      * @since     1.2
 415      */
 416     @CallerSensitive
 417     public static Class&lt;?&gt; forName(String name, boolean initialize,
 418                                    ClassLoader loader)
 419         throws ClassNotFoundException
 420     {
 421         Class&lt;?&gt; caller = null;
 422         SecurityManager sm = System.getSecurityManager();
 423         if (sm != null) {
 424             // Reflective call to get caller class is only needed if a security manager
 425             // is present.  Avoid the overhead of making this call otherwise.
 426             caller = Reflection.getCallerClass();
 427             if (loader == null) {
 428                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 429                 if (ccl != null) {
 430                     sm.checkPermission(
 431                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 432                 }
 433             }
 434         }
 435         return forName0(name, initialize, loader, caller);
 436     }
 437 
 438     /** Called after security check for system loader access checks have been made. */
 439     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 440                                     ClassLoader loader,
 441                                     Class&lt;?&gt; caller)
 442         throws ClassNotFoundException;
 443 
 444 
 445     /**
 446      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 447      * binary name&lt;/a&gt; in the given module.
 448      *
 449      * &lt;p&gt; This method attempts to locate and load the class or interface.
 450      * It does not link the class, and does not run the class initializer.
 451      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 452      *
 453      * &lt;p&gt; If the class loader of the given module defines other modules and
 454      * the given name is a class defined in a different module, this method
 455      * returns {@code null} after the class is loaded. &lt;/p&gt;
 456      *
 457      * &lt;p&gt; This method does not check whether the requested class is
 458      * accessible to its caller. &lt;/p&gt;
 459      *
 460      * @apiNote
 461      * This method returns {@code null} on failure rather than
 462      * throwing a {@link ClassNotFoundException}, as is done by
 463      * the {@link #forName(String, boolean, ClassLoader)} method.
 464      * The security check is a stack-based permission check if the caller
 465      * loads a class in another module.
 466      *
 467      * @param  module   A module
 468      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 469      *                  of the class
 470      * @return {@code Class} object of the given name defined in the given module;
 471      *         {@code null} if not found.
 472      *
 473      * @throws NullPointerException if the given module or name is {@code null}
 474      *
 475      * @throws LinkageError if the linkage fails
 476      *
 477      * @throws SecurityException
 478      *         &lt;ul&gt;
 479      *         &lt;li&gt; if the caller is not the specified module and
 480      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 481      *         &lt;li&gt; access to the module content is denied. For example,
 482      *         permission check will be performed when a class loader calls
 483      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 484      *         in a module.&lt;/li&gt;
 485      *         &lt;/ul&gt;
 486      *
 487      * @jls 12.2 Loading of Classes and Interfaces
 488      * @jls 12.3 Linking of Classes and Interfaces
 489      * @since 9
 490      * @spec JPMS
 491      */
 492     @CallerSensitive
 493     public static Class&lt;?&gt; forName(Module module, String name) {
 494         Objects.requireNonNull(module);
 495         Objects.requireNonNull(name);
 496 
 497         ClassLoader cl;
 498         SecurityManager sm = System.getSecurityManager();
 499         if (sm != null) {
 500             Class&lt;?&gt; caller = Reflection.getCallerClass();
 501             if (caller != null &amp;&amp; caller.getModule() != module) {
 502                 // if caller is null, Class.forName is the last java frame on the stack.
 503                 // java.base has all permissions
 504                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 505             }
 506             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 507             cl = AccessController.doPrivileged(pa);
 508         } else {
 509             cl = module.getClassLoader();
 510         }
 511 
 512         if (cl != null) {
 513             return cl.loadClass(module, name);
 514         } else {
 515             return BootLoader.loadClass(module, name);
 516         }
 517     }
 518 
 519     /**
 520      * Returns {@code true} if this class is an inline class.
 521      *
<a name="3" id="anc3"></a><span class="line-modified"> 522      * @return {@code true} if this class is an inline class</span>
<span class="line-added"> 523      * @since Valhalla</span>
 524      */
 525     public boolean isInlineClass() {
<a name="4" id="anc4"></a><span class="line-modified"> 526         return (this.getModifiers() &amp; INLINE) != 0;</span>
 527     }
 528 
 529     /**
<a name="5" id="anc5"></a><span class="line-modified"> 530      * Returns a {@code Class} object representing the &lt;em&gt;value projection&lt;/em&gt;</span>
<span class="line-modified"> 531      * type of this class if this {@code Class} is the reference projection type</span>
<span class="line-modified"> 532      * of an {@linkplain #isInlineClass() inline class}.  Otherwise an empty</span>
<span class="line-modified"> 533      * {@link Optional} is returned.</span>
<span class="line-modified"> 534      *</span>
<span class="line-modified"> 535      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-modified"> 536      *         this class if this class is the reference projection type of an</span>
<span class="line-modified"> 537      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-modified"> 538      * @since Valhalla</span>
 539      */
<a name="6" id="anc6"></a><span class="line-modified"> 540     public Optional&lt;Class&lt;T&gt;&gt; valueType() {</span>
<span class="line-modified"> 541         return Optional.ofNullable(valType);</span>

 542     }
 543 
 544     /**
<a name="7" id="anc7"></a><span class="line-modified"> 545      * Returns a {@code Class} object representing the &lt;em&gt;reference projection&lt;/em&gt;</span>
<span class="line-modified"> 546      * type of this class if this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-modified"> 547      * with a reference projection.</span>
<span class="line-modified"> 548      * If this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-modified"> 549      * without a reference projection or this class is not an inline class,</span>
<span class="line-modified"> 550      * then this method returns an empty {@link Optional}.</span>
<span class="line-modified"> 551      *</span>
<span class="line-modified"> 552      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-modified"> 553      *         this class if this class is the reference projection type of an</span>
<span class="line-modified"> 554      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-modified"> 555      * @since Valhalla</span>


 556      */
<a name="8" id="anc8"></a><span class="line-modified"> 557     public Optional&lt;Class&lt;T&gt;&gt; referenceType() {</span>
<span class="line-modified"> 558         return valType != null ? Optional.ofNullable(refType) : Optional.of(this);</span>

 559     }
 560 
<a name="9" id="anc9"></a><span class="line-modified"> 561     // TO BE REMOVED together with the C2 intrinsic implementation</span>
<span class="line-modified"> 562     @HotSpotIntrinsicCandidate</span>
<span class="line-modified"> 563     private Class&lt;T&gt; asPrimaryType() {</span>
<span class="line-modified"> 564         return valType == null ? this : valType;</span>























 565     }
<a name="10" id="anc10"></a><span class="line-modified"> 566     // TO BE REMOVED together with the C2 intrinsic implementation</span>
<span class="line-modified"> 567     @HotSpotIntrinsicCandidate</span>
<span class="line-modified"> 568     private Class&lt;T&gt; asIndirectType() {</span>
<span class="line-modified"> 569         return valType != null ? refType : this;</span>




 570     }
 571 
 572     // set by VM if this class is an inline type
 573     // otherwise, these two fields are null
<a name="11" id="anc11"></a><span class="line-modified"> 574     private transient Class&lt;T&gt; valType;</span>
<span class="line-modified"> 575     private transient Class&lt;T&gt; refType;</span>
 576 
 577     /**
 578      * Creates a new instance of the class represented by this {@code Class}
 579      * object.  The class is instantiated as if by a {@code new}
 580      * expression with an empty argument list.  The class is initialized if it
 581      * has not already been initialized.
 582      *
 583      * @deprecated This method propagates any exception thrown by the
 584      * nullary constructor, including a checked exception.  Use of
 585      * this method effectively bypasses the compile-time exception
 586      * checking that would otherwise be performed by the compiler.
 587      * The {@link
 588      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 589      * Constructor.newInstance} method avoids this problem by wrapping
 590      * any exception thrown by the constructor in a (checked) {@link
 591      * java.lang.reflect.InvocationTargetException}.
 592      *
 593      * &lt;p&gt;The call
 594      *
 595      * &lt;pre&gt;{@code
 596      * clazz.newInstance()
 597      * }&lt;/pre&gt;
 598      *
 599      * can be replaced by
 600      *
 601      * &lt;pre&gt;{@code
 602      * clazz.getDeclaredConstructor().newInstance()
 603      * }&lt;/pre&gt;
 604      *
 605      * The latter sequence of calls is inferred to be able to throw
 606      * the additional exception types {@link
 607      * InvocationTargetException} and {@link
 608      * NoSuchMethodException}. Both of these exception types are
 609      * subclasses of {@link ReflectiveOperationException}.
 610      *
 611      * @return  a newly allocated instance of the class represented by this
 612      *          object.
 613      * @throws  IllegalAccessException  if the class or its nullary
 614      *          constructor is not accessible.
 615      * @throws  InstantiationException
 616      *          if this {@code Class} represents an abstract class,
 617      *          an interface, an array class, a primitive type, or void;
 618      *          or if the class has no nullary constructor;
 619      *          or if the instantiation fails for some other reason.
 620      * @throws  ExceptionInInitializerError if the initialization
 621      *          provoked by this method fails.
 622      * @throws  SecurityException
 623      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
 624      *          the caller&#39;s class loader is not the same as or an
 625      *          ancestor of the class loader for the current class and
 626      *          invocation of {@link SecurityManager#checkPackageAccess
 627      *          s.checkPackageAccess()} denies access to the package
 628      *          of this class.
 629      */
 630     @CallerSensitive
 631     @Deprecated(since=&quot;9&quot;)
 632     public T newInstance()
 633         throws InstantiationException, IllegalAccessException
 634     {
 635         SecurityManager sm = System.getSecurityManager();
 636         if (sm != null) {
 637             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
 638         }
 639 
 640         // Constructor lookup
 641         Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
 642         if (tmpConstructor == null) {
 643             if (this == Class.class) {
 644                 throw new IllegalAccessException(
 645                     &quot;Can not call newInstance() on the Class for java.lang.Class&quot;
 646                 );
 647             }
 648             try {
 649                 Class&lt;?&gt;[] empty = {};
 650                 final Constructor&lt;T&gt; c = getReflectionFactory().copyConstructor(
 651                     getConstructor0(empty, Member.DECLARED));
 652                 // Disable accessibility checks on the constructor
 653                 // access check is done with the true caller
 654                 java.security.AccessController.doPrivileged(
 655                     new java.security.PrivilegedAction&lt;&gt;() {
 656                         public Void run() {
 657                                 c.setAccessible(true);
 658                                 return null;
 659                             }
 660                         });
 661                 cachedConstructor = tmpConstructor = c;
 662             } catch (NoSuchMethodException e) {
 663                 throw (InstantiationException)
 664                     new InstantiationException(getName()).initCause(e);
 665             }
 666         }
 667 
 668         try {
 669             Class&lt;?&gt; caller = Reflection.getCallerClass();
 670             return getReflectionFactory().newInstance(tmpConstructor, null, caller);
 671         } catch (InvocationTargetException e) {
 672             Unsafe.getUnsafe().throwException(e.getTargetException());
 673             // Not reached
 674             return null;
 675         }
 676     }
 677 
 678     private transient volatile Constructor&lt;T&gt; cachedConstructor;
 679 
 680     /**
 681      * Determines if the specified {@code Object} is assignment-compatible
 682      * with the object represented by this {@code Class}.  This method is
 683      * the dynamic equivalent of the Java language {@code instanceof}
 684      * operator. The method returns {@code true} if the specified
 685      * {@code Object} argument is non-null and can be cast to the
 686      * reference type represented by this {@code Class} object without
 687      * raising a {@code ClassCastException.} It returns {@code false}
 688      * otherwise.
 689      *
 690      * &lt;p&gt; Specifically, if this {@code Class} object represents a
 691      * declared class, this method returns {@code true} if the specified
 692      * {@code Object} argument is an instance of the represented class (or
 693      * of any of its subclasses); it returns {@code false} otherwise. If
 694      * this {@code Class} object represents an array class, this method
 695      * returns {@code true} if the specified {@code Object} argument
 696      * can be converted to an object of the array class by an identity
 697      * conversion or by a widening reference conversion; it returns
 698      * {@code false} otherwise. If this {@code Class} object
 699      * represents an interface, this method returns {@code true} if the
 700      * class or any superclass of the specified {@code Object} argument
 701      * implements this interface; it returns {@code false} otherwise. If
 702      * this {@code Class} object represents a primitive type, this method
 703      * returns {@code false}.
 704      *
 705      * @param   obj the object to check
 706      * @return  true if {@code obj} is an instance of this class
 707      *
 708      * @since 1.1
 709      */
 710     @HotSpotIntrinsicCandidate
 711     public native boolean isInstance(Object obj);
 712 
 713 
 714     /**
 715      * Determines if the class or interface represented by this
 716      * {@code Class} object is either the same as, or is a superclass or
 717      * superinterface of, the class or interface represented by the specified
 718      * {@code Class} parameter. It returns {@code true} if so;
 719      * otherwise it returns {@code false}. If this {@code Class}
 720      * object represents a primitive type, this method returns
 721      * {@code true} if the specified {@code Class} parameter is
 722      * exactly this {@code Class} object; otherwise it returns
 723      * {@code false}.
 724      *
 725      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 726      * specified {@code Class} parameter can be converted to the type
 727      * represented by this {@code Class} object via an identity conversion
 728      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language
 729      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},
 730      * for details.
 731      *
 732      * @param     cls the {@code Class} object to be checked
 733      * @return    the {@code boolean} value indicating whether objects of the
 734      *            type {@code cls} can be assigned to objects of this class
 735      * @throws    NullPointerException if the specified Class parameter is
 736      *            null.
 737      * @since     1.1
 738      */
 739     @HotSpotIntrinsicCandidate
 740     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 741 
 742 
 743     /**
 744      * Determines if this {@code Class} object represents an
 745      * interface type.
 746      *
 747      * @return  {@code true} if this {@code Class} object represents an interface;
 748      *          {@code false} otherwise.
 749      */
 750     @HotSpotIntrinsicCandidate
 751     public native boolean isInterface();
 752 
 753 
 754     /**
 755      * Determines if this {@code Class} object represents an array class.
 756      *
 757      * @return  {@code true} if this {@code Class} object represents an array class;
 758      *          {@code false} otherwise.
 759      * @since   1.1
 760      */
 761     @HotSpotIntrinsicCandidate
 762     public native boolean isArray();
 763 
 764 
 765     /**
 766      * Determines if the specified {@code Class} object represents a
 767      * primitive type.
 768      *
 769      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 770      * the eight primitive types and void.  These are created by the Java
 771      * Virtual Machine, and have the same names as the primitive types that
 772      * they represent, namely {@code boolean}, {@code byte},
 773      * {@code char}, {@code short}, {@code int},
 774      * {@code long}, {@code float}, and {@code double}.
 775      *
 776      * &lt;p&gt; These objects may only be accessed via the following public static
 777      * final variables, and are the only {@code Class} objects for which
 778      * this method returns {@code true}.
 779      *
 780      * @return true if and only if this class represents a primitive type
 781      *
 782      * @see     java.lang.Boolean#TYPE
 783      * @see     java.lang.Character#TYPE
 784      * @see     java.lang.Byte#TYPE
 785      * @see     java.lang.Short#TYPE
 786      * @see     java.lang.Integer#TYPE
 787      * @see     java.lang.Long#TYPE
 788      * @see     java.lang.Float#TYPE
 789      * @see     java.lang.Double#TYPE
 790      * @see     java.lang.Void#TYPE
 791      * @since 1.1
 792      */
 793     @HotSpotIntrinsicCandidate
 794     public native boolean isPrimitive();
 795 
 796     /**
 797      * Returns true if this {@code Class} object represents an annotation
 798      * type.  Note that if this method returns true, {@link #isInterface()}
 799      * would also return true, as all annotation types are also interfaces.
 800      *
 801      * @return {@code true} if this {@code Class} object represents an annotation
 802      *      type; {@code false} otherwise
 803      * @since 1.5
 804      */
 805     public boolean isAnnotation() {
 806         return (getModifiers() &amp; ANNOTATION) != 0;
 807     }
 808 
 809     /**
 810      * Returns {@code true} if this class is a synthetic class;
 811      * returns {@code false} otherwise.
 812      * @return {@code true} if and only if this class is a synthetic class as
 813      *         defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 814      * @jls 13.1 The Form of a Binary
 815      * @since 1.5
 816      */
 817     public boolean isSynthetic() {
 818         return (getModifiers() &amp; SYNTHETIC) != 0;
 819     }
 820 
 821     /**
 822      * Returns the  name of the entity (class, interface, array class,
 823      * primitive type, or void) represented by this {@code Class} object,
 824      * as a {@code String}.
 825      *
 826      * &lt;p&gt; If this {@code Class} object represents a reference type that is
 827      * not an array type then the binary name of the class is
 828      * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language
 829      * Specification&lt;/cite&gt;.
 830      *
 831      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the
 832      * name returned is a {@code String} equal to the Java language
 833      * keyword corresponding to the primitive type or void.
 834      *
 835      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal
 836      * form of the name consists of the name of the element type preceded by
 837      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 838      * nesting.  The encoding of element type names is as follows:
 839      *
 840      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 841      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 842      * &lt;thead&gt;
 843      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 844      * &lt;/thead&gt;
 845      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 846      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 847      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 848      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 849      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 850      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
<a name="12" id="anc12"></a><span class="line-modified"> 851      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class}</span>
 852      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;
 853      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 854      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 855      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 856      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 857      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 858      * &lt;/tbody&gt;
 859      * &lt;/table&gt;&lt;/blockquote&gt;
 860      *
 861      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 862      * the class specified above.
 863      *
 864      * &lt;p&gt; Examples:
 865      * &lt;blockquote&gt;&lt;pre&gt;
 866      * String.class.getName()
 867      *     returns &quot;java.lang.String&quot;
 868      * byte.class.getName()
 869      *     returns &quot;byte&quot;
 870      * Point.class.getName()
 871      *     returns &quot;Point&quot;
 872      * (new Object[3]).getClass().getName()
 873      *     returns &quot;[Ljava.lang.Object;&quot;
 874      * (new Point[3]).getClass().getName()
 875      *     returns &quot;[QPoint;&quot;
<a name="13" id="anc13"></a><span class="line-modified"> 876      * (new Point.ref[3][4]).getClass().getName()</span>
<span class="line-modified"> 877      *     returns &quot;[[LPoint$ref;&quot;</span>
 878      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 879      *     returns &quot;[[[[[[[I&quot;
 880      * &lt;/pre&gt;&lt;/blockquote&gt;
 881      *
 882      * @return  the name of the class or interface
 883      *          represented by this {@code Class} object.
 884      */
 885     public String getName() {
 886         String name = this.name;
 887         return name != null ? name : initClassName();
 888     }
 889 
 890     // Cache the name to reduce the number of calls into the VM.
 891     // This field would be set by VM itself during initClassName call.
 892     private transient String name;
 893     private native String initClassName();
 894 
 895     /**
 896      * Returns the class loader for the class.  Some implementations may use
 897      * null to represent the bootstrap class loader. This method will return
 898      * null in such implementations if this class was loaded by the bootstrap
 899      * class loader.
 900      *
 901      * &lt;p&gt;If this {@code Class} object
 902      * represents a primitive type or void, null is returned.
 903      *
 904      * @return  the class loader that loaded the class or interface
 905      *          represented by this {@code Class} object.
 906      * @throws  SecurityException
 907      *          if a security manager is present, and the caller&#39;s class loader
 908      *          is not {@code null} and is not the same as or an ancestor of the
 909      *          class loader for the class whose class loader is requested,
 910      *          and the caller does not have the
 911      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 912      * @see java.lang.ClassLoader
 913      * @see SecurityManager#checkPermission
 914      * @see java.lang.RuntimePermission
 915      */
 916     @CallerSensitive
 917     @ForceInline // to ensure Reflection.getCallerClass optimization
 918     public ClassLoader getClassLoader() {
 919         ClassLoader cl = getClassLoader0();
 920         if (cl == null)
 921             return null;
 922         SecurityManager sm = System.getSecurityManager();
 923         if (sm != null) {
 924             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 925         }
 926         return cl;
 927     }
 928 
 929     // Package-private to allow ClassLoader access
 930     ClassLoader getClassLoader0() { return classLoader; }
 931 
 932     /**
 933      * Returns the module that this class or interface is a member of.
 934      *
 935      * If this class represents an array type then this method returns the
 936      * {@code Module} for the element type. If this class represents a
 937      * primitive type or void, then the {@code Module} object for the
 938      * {@code java.base} module is returned.
 939      *
 940      * If this class is in an unnamed module then the {@linkplain
 941      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
 942      * loader for this class is returned.
 943      *
 944      * @return the module that this class or interface is a member of
 945      *
 946      * @since 9
 947      * @spec JPMS
 948      */
 949     public Module getModule() {
 950         return module;
 951     }
 952 
 953     // set by VM
 954     private transient Module module;
 955 
 956     // Initialized in JVM not by private constructor
 957     // This field is filtered from reflection access, i.e. getDeclaredField
 958     // will throw NoSuchFieldException
 959     private final ClassLoader classLoader;
 960 
 961     /**
 962      * Returns an array of {@code TypeVariable} objects that represent the
 963      * type variables declared by the generic declaration represented by this
 964      * {@code GenericDeclaration} object, in declaration order.  Returns an
 965      * array of length 0 if the underlying generic declaration declares no type
 966      * variables.
 967      *
 968      * @return an array of {@code TypeVariable} objects that represent
 969      *     the type variables declared by this generic declaration
 970      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 971      *     signature of this generic declaration does not conform to
 972      *     the format specified in section {@jvms 4.7.9} of
 973      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;,
 974      * @since 1.5
 975      */
 976     @SuppressWarnings(&quot;unchecked&quot;)
 977     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
 978         ClassRepository info = getGenericInfo();
 979         if (info != null)
 980             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
 981         else
 982             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
 983     }
 984 
 985 
 986     /**
 987      * Returns the {@code Class} representing the direct superclass of the
 988      * entity (class, interface, primitive type or void) represented by
 989      * this {@code Class}.  If this {@code Class} represents either the
 990      * {@code Object} class, an interface, a primitive type, or void, then
 991      * null is returned.  If this {@code Class} object represents an array class
 992      * then the {@code Class} object representing the {@code Object} class is
 993      * returned.
 994      *
 995      * @return the direct superclass of the class represented by this {@code Class} object
 996      */
 997     @HotSpotIntrinsicCandidate
 998     public native Class&lt;? super T&gt; getSuperclass();
 999 
1000 
1001     /**
1002      * Returns the {@code Type} representing the direct superclass of
1003      * the entity (class, interface, primitive type or void) represented by
1004      * this {@code Class} object.
1005      *
1006      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1007      * object returned must accurately reflect the actual type
1008      * arguments used in the source code. The parameterized type
1009      * representing the superclass is created if it had not been
1010      * created before. See the declaration of {@link
1011      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1012      * semantics of the creation process for parameterized types.  If
1013      * this {@code Class} object represents either the {@code Object}
1014      * class, an interface, a primitive type, or void, then null is
1015      * returned.  If this {@code Class} object represents an array class
1016      * then the {@code Class} object representing the {@code Object} class is
1017      * returned.
1018      *
1019      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1020      *     class signature does not conform to the format specified in
1021      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
1022      *     Machine Specification&lt;/cite&gt;
1023      * @throws TypeNotPresentException if the generic superclass
1024      *     refers to a non-existent type declaration
1025      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1026      *     generic superclass refers to a parameterized type that cannot be
1027      *     instantiated  for any reason
1028      * @return the direct superclass of the class represented by this {@code Class} object
1029      * @since 1.5
1030      */
1031     public Type getGenericSuperclass() {
1032         ClassRepository info = getGenericInfo();
1033         if (info == null) {
1034             return getSuperclass();
1035         }
1036 
1037         // Historical irregularity:
1038         // Generic signature marks interfaces with superclass = Object
1039         // but this API returns null for interfaces
1040         if (isInterface()) {
1041             return null;
1042         }
1043 
1044         return info.getSuperclass();
1045     }
1046 
1047     /**
1048      * Gets the package of this class.
1049      *
1050      * &lt;p&gt;If this class represents an array type, a primitive type or void,
1051      * this method returns {@code null}.
1052      *
1053      * @return the package of this class.
1054      * @revised 9
1055      * @spec JPMS
1056      */
1057     public Package getPackage() {
1058         if (isPrimitive() || isArray()) {
1059             return null;
1060         }
1061         ClassLoader cl = getClassLoader0();
1062         return cl != null ? cl.definePackage(this)
1063                           : BootLoader.definePackage(this);
1064     }
1065 
1066     /**
1067      * Returns the fully qualified package name.
1068      *
1069      * &lt;p&gt; If this class is a top level class, then this method returns the fully
1070      * qualified name of the package that the class is a member of, or the
1071      * empty string if the class is in an unnamed package.
1072      *
1073      * &lt;p&gt; If this class is a member class, then this method is equivalent to
1074      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
1075      * enclosing class}.
1076      *
1077      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1078      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1079      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1080      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1081      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1082      *
1083      * &lt;p&gt; If this class represents an array type then this method returns the
1084      * package name of the element type. If this class represents a primitive
1085      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1086      *
1087      * @return the fully qualified package name
1088      *
1089      * @since 9
1090      * @spec JPMS
1091      * @jls 6.7 Fully Qualified Names
1092      */
1093     public String getPackageName() {
1094         String pn = this.packageName;
1095         if (pn == null) {
1096             Class&lt;?&gt; c = this;
1097             while (c.isArray()) {
1098                 c = c.getComponentType();
1099             }
1100             if (c.isPrimitive()) {
1101                 pn = &quot;java.lang&quot;;
1102             } else {
1103                 String cn = c.getName();
1104                 int dot = cn.lastIndexOf(&#39;.&#39;);
1105                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1106             }
1107             this.packageName = pn;
1108         }
1109         return pn;
1110     }
1111 
1112     // cached package name
1113     private transient String packageName;
1114 
1115     /**
1116      * Returns the interfaces directly implemented by the class or interface
1117      * represented by this {@code Class} object.
1118      *
1119      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1120      * containing objects representing all interfaces directly implemented by
1121      * the class.  The order of the interface objects in the array corresponds
1122      * to the order of the interface names in the {@code implements} clause of
1123      * the declaration of the class represented by this {@code Class} object.  For example,
1124      * given the declaration:
1125      * &lt;blockquote&gt;
1126      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1127      * &lt;/blockquote&gt;
1128      * suppose the value of {@code s} is an instance of
1129      * {@code Shimmer}; the value of the expression:
1130      * &lt;blockquote&gt;
1131      * {@code s.getClass().getInterfaces()[0]}
1132      * &lt;/blockquote&gt;
1133      * is the {@code Class} object that represents interface
1134      * {@code FloorWax}; and the value of:
1135      * &lt;blockquote&gt;
1136      * {@code s.getClass().getInterfaces()[1]}
1137      * &lt;/blockquote&gt;
1138      * is the {@code Class} object that represents interface
1139      * {@code DessertTopping}.
1140      *
1141      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1142      * representing all interfaces directly extended by the interface.  The
1143      * order of the interface objects in the array corresponds to the order of
1144      * the interface names in the {@code extends} clause of the declaration of
1145      * the interface represented by this {@code Class} object.
1146      *
1147      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1148      * interfaces, the method returns an array of length 0.
1149      *
1150      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1151      * returns an array of length 0.
1152      *
1153      * &lt;p&gt;If this {@code Class} object represents an array type, the
1154      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1155      * returned in that order.
1156      *
1157      * @return an array of interfaces directly implemented by this class
1158      */
1159     public Class&lt;?&gt;[] getInterfaces() {
1160         // defensively copy before handing over to user code
1161         return getInterfaces(true);
1162     }
1163 
1164     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1165         ReflectionData&lt;T&gt; rd = reflectionData();
1166         if (rd == null) {
1167             // no cloning required
1168             return getInterfaces0();
1169         } else {
1170             Class&lt;?&gt;[] interfaces = rd.interfaces;
1171             if (interfaces == null) {
1172                 interfaces = getInterfaces0();
1173                 rd.interfaces = interfaces;
1174             }
1175             // defensively copy if requested
1176             return cloneArray ? interfaces.clone() : interfaces;
1177         }
1178     }
1179 
1180     private native Class&lt;?&gt;[] getInterfaces0();
1181 
1182     /**
1183      * Returns the {@code Type}s representing the interfaces
1184      * directly implemented by the class or interface represented by
1185      * this {@code Class} object.
1186      *
1187      * &lt;p&gt;If a superinterface is a parameterized type, the
1188      * {@code Type} object returned for it must accurately reflect
1189      * the actual type arguments used in the source code. The
1190      * parameterized type representing each superinterface is created
1191      * if it had not been created before. See the declaration of
1192      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1193      * for the semantics of the creation process for parameterized
1194      * types.
1195      *
1196      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1197      * containing objects representing all interfaces directly implemented by
1198      * the class.  The order of the interface objects in the array corresponds
1199      * to the order of the interface names in the {@code implements} clause of
1200      * the declaration of the class represented by this {@code Class} object.
1201      *
1202      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1203      * representing all interfaces directly extended by the interface.  The
1204      * order of the interface objects in the array corresponds to the order of
1205      * the interface names in the {@code extends} clause of the declaration of
1206      * the interface represented by this {@code Class} object.
1207      *
1208      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1209      * interfaces, the method returns an array of length 0.
1210      *
1211      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1212      * returns an array of length 0.
1213      *
1214      * &lt;p&gt;If this {@code Class} object represents an array type, the
1215      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1216      * returned in that order.
1217      *
1218      * @throws java.lang.reflect.GenericSignatureFormatError
1219      *     if the generic class signature does not conform to the
1220      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The
1221      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1222      * @throws TypeNotPresentException if any of the generic
1223      *     superinterfaces refers to a non-existent type declaration
1224      * @throws java.lang.reflect.MalformedParameterizedTypeException
1225      *     if any of the generic superinterfaces refer to a parameterized
1226      *     type that cannot be instantiated for any reason
1227      * @return an array of interfaces directly implemented by this class
1228      * @since 1.5
1229      */
1230     public Type[] getGenericInterfaces() {
1231         ClassRepository info = getGenericInfo();
1232         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1233     }
1234 
1235 
1236     /**
1237      * Returns the {@code Class} representing the component type of an
1238      * array.  If this class does not represent an array class this method
1239      * returns null.
1240      *
1241      * @return the {@code Class} representing the component type of this
1242      * class if this class is an array
1243      * @see     java.lang.reflect.Array
1244      * @since 1.1
1245      */
1246     public Class&lt;?&gt; getComponentType() {
1247         // Only return for array types. Storage may be reused for Class for instance types.
1248         if (isArray()) {
1249             return componentType;
1250         } else {
1251             return null;
1252         }
1253     }
1254 
1255     private final Class&lt;?&gt; componentType;
1256 
1257 
1258     /**
1259      * Returns the Java language modifiers for this class or interface, encoded
1260      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1261      * constants for {@code public}, {@code protected},
1262      * {@code private}, {@code final}, {@code static},
1263      * {@code abstract} and {@code interface}; they should be decoded
1264      * using the methods of class {@code Modifier}.
1265      *
1266      * &lt;p&gt; If the underlying class is an array class, then its
1267      * {@code public}, {@code private} and {@code protected}
1268      * modifiers are the same as those of its component type.  If this
1269      * {@code Class} object represents a primitive type or void, its
1270      * {@code public} modifier is always {@code true}, and its
1271      * {@code protected} and {@code private} modifiers are always
1272      * {@code false}. If this {@code Class} object represents an array class, a
1273      * primitive type or void, then its {@code final} modifier is always
1274      * {@code true} and its interface modifier is always
1275      * {@code false}. The values of its other modifiers are not determined
1276      * by this specification.
1277      *
1278      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1279      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1280      *
1281      * @return the {@code int} representing the modifiers for this class
1282      * @see     java.lang.reflect.Modifier
1283      * @since 1.1
1284      */
1285     @HotSpotIntrinsicCandidate
1286     public native int getModifiers();
1287 
1288     /**
1289      * Gets the signers of this class.
1290      *
1291      * @return  the signers of this class, or null if there are no signers.  In
1292      *          particular, this method returns null if this {@code Class} object represents
1293      *          a primitive type or void.
1294      * @since   1.1
1295      */
<a name="14" id="anc14"></a><span class="line-modified">1296     public native Object[] getSigners();</span>




1297 
1298     /**
1299      * Set the signers of this class.
1300      */
<a name="15" id="anc15"></a><span class="line-modified">1301     native void setSigners(Object[] signers);</span>




1302 
1303 
1304     /**
1305      * If this {@code Class} object represents a local or anonymous
1306      * class within a method, returns a {@link
1307      * java.lang.reflect.Method Method} object representing the
1308      * immediately enclosing method of the underlying class. Returns
1309      * {@code null} otherwise.
1310      *
1311      * In particular, this method returns {@code null} if the underlying
1312      * class is a local or anonymous class immediately enclosed by a type
1313      * declaration, instance initializer or static initializer.
1314      *
1315      * @return the immediately enclosing method of the underlying class, if
1316      *     that class is a local or anonymous class; otherwise {@code null}.
1317      *
1318      * @throws SecurityException
1319      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1320      *         following conditions is met:
1321      *
1322      *         &lt;ul&gt;
1323      *
1324      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1325      *         class loader of the enclosing class and invocation of
1326      *         {@link SecurityManager#checkPermission
1327      *         s.checkPermission} method with
1328      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1329      *         denies access to the methods within the enclosing class
1330      *
1331      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1332      *         ancestor of the class loader for the enclosing class and
1333      *         invocation of {@link SecurityManager#checkPackageAccess
1334      *         s.checkPackageAccess()} denies access to the package
1335      *         of the enclosing class
1336      *
1337      *         &lt;/ul&gt;
1338      * @since 1.5
1339      */
1340     @CallerSensitive
1341     public Method getEnclosingMethod() throws SecurityException {
1342         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1343 
1344         if (enclosingInfo == null)
1345             return null;
1346         else {
1347             if (!enclosingInfo.isMethod())
1348                 return null;
1349 
1350             MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
1351                                                               getFactory());
1352             Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
1353             Type []    parameterTypes   = typeInfo.getParameterTypes();
1354             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1355 
1356             // Convert Types to Classes; returned types *should*
1357             // be class objects since the methodDescriptor&#39;s used
1358             // don&#39;t have generics information
1359             for(int i = 0; i &lt; parameterClasses.length; i++)
1360                 parameterClasses[i] = toClass(parameterTypes[i]);
1361 
1362             // Perform access check
1363             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1364             SecurityManager sm = System.getSecurityManager();
1365             if (sm != null) {
1366                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1367                                                      Reflection.getCallerClass(), true);
1368             }
1369             Method[] candidates = enclosingCandidate.privateGetDeclaredMethods(false);
1370 
1371             /*
1372              * Loop over all declared methods; match method name,
1373              * number of and type of parameters, *and* return
1374              * type.  Matching return type is also necessary
1375              * because of covariant returns, etc.
1376              */
1377             ReflectionFactory fact = getReflectionFactory();
1378             for (Method m : candidates) {
1379                 if (m.getName().equals(enclosingInfo.getName()) &amp;&amp;
1380                     arrayContentsEq(parameterClasses,
1381                                     fact.getExecutableSharedParameterTypes(m))) {
1382                     // finally, check return type
1383                     if (m.getReturnType().equals(returnType)) {
1384                         return fact.copyMethod(m);
1385                     }
1386                 }
1387             }
1388 
1389             throw new InternalError(&quot;Enclosing method not found&quot;);
1390         }
1391     }
1392 
1393     private native Object[] getEnclosingMethod0();
1394 
1395     private EnclosingMethodInfo getEnclosingMethodInfo() {
1396         Object[] enclosingInfo = getEnclosingMethod0();
1397         if (enclosingInfo == null)
1398             return null;
1399         else {
1400             return new EnclosingMethodInfo(enclosingInfo);
1401         }
1402     }
1403 
1404     private static final class EnclosingMethodInfo {
1405         private final Class&lt;?&gt; enclosingClass;
1406         private final String name;
1407         private final String descriptor;
1408 
1409         static void validate(Object[] enclosingInfo) {
1410             if (enclosingInfo.length != 3)
1411                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1412             try {
1413                 // The array is expected to have three elements:
1414 
1415                 // the immediately enclosing class
1416                 Class&lt;?&gt; enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1417                 assert(enclosingClass != null);
1418 
1419                 // the immediately enclosing method or constructor&#39;s
1420                 // name (can be null).
1421                 String name = (String)enclosingInfo[1];
1422 
1423                 // the immediately enclosing method or constructor&#39;s
1424                 // descriptor (null iff name is).
1425                 String descriptor = (String)enclosingInfo[2];
1426                 assert((name != null &amp;&amp; descriptor != null) || name == descriptor);
1427             } catch (ClassCastException cce) {
1428                 throw new InternalError(&quot;Invalid type in enclosing method information&quot;, cce);
1429             }
1430         }
1431 
1432         EnclosingMethodInfo(Object[] enclosingInfo) {
1433             validate(enclosingInfo);
1434             this.enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1435             this.name = (String)enclosingInfo[1];
1436             this.descriptor = (String)enclosingInfo[2];
1437         }
1438 
1439         boolean isPartial() {
1440             return enclosingClass == null || name == null || descriptor == null;
1441         }
1442 
1443         boolean isConstructor() { return !isPartial() &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name); }
1444 
1445         boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name); }
1446 
1447         Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }
1448 
1449         String getName() { return name; }
1450 
1451         String getDescriptor() { return descriptor; }
1452 
1453     }
1454 
1455     private static Class&lt;?&gt; toClass(Type o) {
1456         if (o instanceof GenericArrayType)
1457             return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
1458                                      0)
1459                 .getClass();
1460         return (Class&lt;?&gt;)o;
1461      }
1462 
1463     /**
1464      * If this {@code Class} object represents a local or anonymous
1465      * class within a constructor, returns a {@link
1466      * java.lang.reflect.Constructor Constructor} object representing
1467      * the immediately enclosing constructor of the underlying
1468      * class. Returns {@code null} otherwise.  In particular, this
1469      * method returns {@code null} if the underlying class is a local
1470      * or anonymous class immediately enclosed by a type declaration,
1471      * instance initializer or static initializer.
1472      *
1473      * @return the immediately enclosing constructor of the underlying class, if
1474      *     that class is a local or anonymous class; otherwise {@code null}.
1475      * @throws SecurityException
1476      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1477      *         following conditions is met:
1478      *
1479      *         &lt;ul&gt;
1480      *
1481      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1482      *         class loader of the enclosing class and invocation of
1483      *         {@link SecurityManager#checkPermission
1484      *         s.checkPermission} method with
1485      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1486      *         denies access to the constructors within the enclosing class
1487      *
1488      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1489      *         ancestor of the class loader for the enclosing class and
1490      *         invocation of {@link SecurityManager#checkPackageAccess
1491      *         s.checkPackageAccess()} denies access to the package
1492      *         of the enclosing class
1493      *
1494      *         &lt;/ul&gt;
1495      * @since 1.5
1496      */
1497     @CallerSensitive
1498     public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {
1499         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1500 
1501         if (enclosingInfo == null)
1502             return null;
1503         else {
1504             if (!enclosingInfo.isConstructor())
1505                 return null;
1506 
1507             ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
1508                                                                         getFactory());
1509             Type []    parameterTypes   = typeInfo.getParameterTypes();
1510             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1511 
1512             // Convert Types to Classes; returned types *should*
1513             // be class objects since the methodDescriptor&#39;s used
1514             // don&#39;t have generics information
1515             for(int i = 0; i &lt; parameterClasses.length; i++)
1516                 parameterClasses[i] = toClass(parameterTypes[i]);
1517 
1518             // Perform access check
1519             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1520             SecurityManager sm = System.getSecurityManager();
1521             if (sm != null) {
1522                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1523                                                      Reflection.getCallerClass(), true);
1524             }
1525 
1526             Constructor&lt;?&gt;[] candidates = enclosingCandidate
1527                     .privateGetDeclaredConstructors(false);
1528             /*
1529              * Loop over all declared constructors; match number
1530              * of and type of parameters.
1531              */
1532             ReflectionFactory fact = getReflectionFactory();
1533             for (Constructor&lt;?&gt; c : candidates) {
1534                 if (arrayContentsEq(parameterClasses,
1535                                     fact.getExecutableSharedParameterTypes(c))) {
1536                     return fact.copyConstructor(c);
1537                 }
1538             }
1539 
1540             throw new InternalError(&quot;Enclosing constructor not found&quot;);
1541         }
1542     }
1543 
1544 
1545     /**
1546      * If the class or interface represented by this {@code Class} object
1547      * is a member of another class, returns the {@code Class} object
1548      * representing the class in which it was declared.  This method returns
1549      * null if this class or interface is not a member of any other class.  If
1550      * this {@code Class} object represents an array class, a primitive
1551      * type, or void,then this method returns null.
1552      *
1553      * @return the declaring class for this class
1554      * @throws SecurityException
1555      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1556      *         class loader is not the same as or an ancestor of the class
1557      *         loader for the declaring class and invocation of {@link
1558      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
1559      *         denies access to the package of the declaring class
1560      * @since 1.1
1561      */
1562     @CallerSensitive
1563     public Class&lt;?&gt; getDeclaringClass() throws SecurityException {
1564         final Class&lt;?&gt; candidate = getDeclaringClass0();
1565 
1566         if (candidate != null) {
1567             SecurityManager sm = System.getSecurityManager();
1568             if (sm != null) {
1569                 candidate.checkPackageAccess(sm,
1570                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1571             }
1572         }
1573         return candidate;
1574     }
1575 
1576     private native Class&lt;?&gt; getDeclaringClass0();
1577 
1578 
1579     /**
1580      * Returns the immediately enclosing class of the underlying
1581      * class.  If the underlying class is a top level class this
1582      * method returns {@code null}.
1583      * @return the immediately enclosing class of the underlying class
1584      * @throws     SecurityException
1585      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1586      *             class loader is not the same as or an ancestor of the class
1587      *             loader for the enclosing class and invocation of {@link
1588      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1589      *             denies access to the package of the enclosing class
1590      * @since 1.5
1591      */
1592     @CallerSensitive
1593     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1594         // There are five kinds of classes (or interfaces):
1595         // a) Top level classes
1596         // b) Nested classes (static member classes)
1597         // c) Inner classes (non-static member classes)
1598         // d) Local classes (named classes declared within a method)
1599         // e) Anonymous classes
1600 
1601 
1602         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1603         // attribute if and only if it is a local class or an
1604         // anonymous class.
1605         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1606         Class&lt;?&gt; enclosingCandidate;
1607 
1608         if (enclosingInfo == null) {
1609             // This is a top level or a nested class or an inner class (a, b, or c)
1610             enclosingCandidate = getDeclaringClass0();
1611         } else {
1612             Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
1613             // This is a local class or an anonymous class (d or e)
1614             if (enclosingClass == this || enclosingClass == null)
1615                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1616             else
1617                 enclosingCandidate = enclosingClass;
1618         }
1619 
1620         if (enclosingCandidate != null) {
1621             SecurityManager sm = System.getSecurityManager();
1622             if (sm != null) {
1623                 enclosingCandidate.checkPackageAccess(sm,
1624                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1625             }
1626         }
1627         return enclosingCandidate;
1628     }
1629 
1630     /**
1631      * Returns the simple name of the underlying class as given in the
1632      * source code. Returns an empty string if the underlying class is
1633      * anonymous.
1634      *
1635      * &lt;p&gt;The simple name of an array is the simple name of the
1636      * component type with &quot;[]&quot; appended.  In particular the simple
1637      * name of an array whose component type is anonymous is &quot;[]&quot;.
1638      *
1639      * @return the simple name of the underlying class
1640      * @since 1.5
1641      */
1642     public String getSimpleName() {
1643         ReflectionData&lt;T&gt; rd = reflectionData();
1644         String simpleName = rd.simpleName;
1645         if (simpleName == null) {
1646             rd.simpleName = simpleName = getSimpleName0();
1647         }
1648         return simpleName;
1649     }
1650 
1651     private String getSimpleName0() {
1652         if (isArray()) {
1653             return getComponentType().getSimpleName() + &quot;[]&quot;;
1654         }
1655         String simpleName = getSimpleBinaryName();
1656         if (simpleName == null) { // top level class
1657             simpleName = getName();
1658             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1659         }
<a name="16" id="anc16"></a><span class="line-modified">1660         return simpleName;</span>
1661     }
1662 
1663     /**
1664      * Return an informative string for the name of this type.
1665      *
1666      * @return an informative string for the name of this type
1667      * @since 1.8
1668      */
1669     public String getTypeName() {
1670         if (isArray()) {
1671             try {
1672                 Class&lt;?&gt; cl = this;
1673                 int dimensions = 0;
1674                 do {
1675                     dimensions++;
1676                     cl = cl.getComponentType();
1677                 } while (cl.isArray());
1678                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1679             } catch (Throwable e) { /*FALLTHRU*/ }
1680         }
<a name="17" id="anc17"></a><span class="line-modified">1681         return getName();</span>
1682     }
1683 
1684     /**
1685      * Returns the canonical name of the underlying class as defined
1686      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section
1687      * {@jls 6.7}.  Returns null if the underlying class does not have
1688      * a canonical name (i.e., if it is a local or anonymous class or
1689      * an array whose component type does not have a canonical name).
1690      * @return the canonical name of the underlying class if it exists, and
1691      * {@code null} otherwise.
1692      * @since 1.5
1693      */
1694     public String getCanonicalName() {
1695         ReflectionData&lt;T&gt; rd = reflectionData();
1696         String canonicalName = rd.canonicalName;
1697         if (canonicalName == null) {
1698             rd.canonicalName = canonicalName = getCanonicalName0();
1699         }
1700         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1701     }
1702 
1703     private String getCanonicalName0() {
1704         if (isArray()) {
1705             String canonicalName = getComponentType().getCanonicalName();
1706             if (canonicalName != null)
1707                 return canonicalName + &quot;[]&quot;;
1708             else
1709                 return ReflectionData.NULL_SENTINEL;
1710         }
1711         if (isLocalOrAnonymousClass())
1712             return ReflectionData.NULL_SENTINEL;
1713         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1714         if (enclosingClass == null) { // top level class
1715             return getName();
1716         } else {
1717             String enclosingName = enclosingClass.getCanonicalName();
1718             if (enclosingName == null)
1719                 return ReflectionData.NULL_SENTINEL;
1720             return enclosingName + &quot;.&quot; + getSimpleName();
1721         }
1722     }
1723 
1724     /**
1725      * Returns {@code true} if and only if the underlying class
1726      * is an anonymous class.
1727      *
1728      * @return {@code true} if and only if this class is an anonymous class.
1729      * @since 1.5
1730      */
1731     public boolean isAnonymousClass() {
1732         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1733                 getSimpleBinaryName0() == null;
1734     }
1735 
1736     /**
1737      * Returns {@code true} if and only if the underlying class
1738      * is a local class.
1739      *
1740      * @return {@code true} if and only if this class is a local class.
1741      * @since 1.5
1742      */
1743     public boolean isLocalClass() {
1744         return isLocalOrAnonymousClass() &amp;&amp;
1745                 (isArray() || getSimpleBinaryName0() != null);
1746     }
1747 
1748     /**
1749      * Returns {@code true} if and only if the underlying class
1750      * is a member class.
1751      *
1752      * @return {@code true} if and only if this class is a member class.
1753      * @since 1.5
1754      */
1755     public boolean isMemberClass() {
1756         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() != null;
1757     }
1758 
1759     /**
1760      * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
1761      * the binary name without the leading enclosing class name.
1762      * Returns {@code null} if the underlying class is a top level
1763      * class.
1764      */
1765     private String getSimpleBinaryName() {
1766         if (isTopLevelClass())
1767             return null;
1768         String name = getSimpleBinaryName0();
1769         if (name == null) // anonymous class
1770             return &quot;&quot;;
1771         return name;
1772     }
1773 
1774     private native String getSimpleBinaryName0();
1775 
1776     /**
1777      * Returns {@code true} if this is a top level class.  Returns {@code false}
1778      * otherwise.
1779      */
1780     private boolean isTopLevelClass() {
1781         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() == null;
1782     }
1783 
1784     /**
1785      * Returns {@code true} if this is a local class or an anonymous
1786      * class.  Returns {@code false} otherwise.
1787      */
1788     private boolean isLocalOrAnonymousClass() {
1789         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1790         // attribute if and only if it is a local class or an
1791         // anonymous class.
1792         return hasEnclosingMethodInfo();
1793     }
1794 
1795     private boolean hasEnclosingMethodInfo() {
1796         Object[] enclosingInfo = getEnclosingMethod0();
1797         if (enclosingInfo != null) {
1798             EnclosingMethodInfo.validate(enclosingInfo);
1799             return true;
1800         }
1801         return false;
1802     }
1803 
1804     /**
1805      * Returns an array containing {@code Class} objects representing all
1806      * the public classes and interfaces that are members of the class
1807      * represented by this {@code Class} object.  This includes public
1808      * class and interface members inherited from superclasses and public class
1809      * and interface members declared by the class.  This method returns an
1810      * array of length 0 if this {@code Class} object has no public member
1811      * classes or interfaces.  This method also returns an array of length 0 if
1812      * this {@code Class} object represents a primitive type, an array
1813      * class, or void.
1814      *
1815      * @return the array of {@code Class} objects representing the public
1816      *         members of this class
1817      * @throws SecurityException
1818      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1819      *         the caller&#39;s class loader is not the same as or an
1820      *         ancestor of the class loader for the current class and
1821      *         invocation of {@link SecurityManager#checkPackageAccess
1822      *         s.checkPackageAccess()} denies access to the package
1823      *         of this class.
1824      *
1825      * @since 1.1
1826      */
1827     @CallerSensitive
1828     public Class&lt;?&gt;[] getClasses() {
1829         SecurityManager sm = System.getSecurityManager();
1830         if (sm != null) {
1831             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
1832         }
1833 
1834         // Privileged so this implementation can look at DECLARED classes,
1835         // something the caller might not have privilege to do.  The code here
1836         // is allowed to look at DECLARED classes because (1) it does not hand
1837         // out anything other than public members and (2) public member access
1838         // has already been ok&#39;d by the SecurityManager.
1839 
1840         return java.security.AccessController.doPrivileged(
1841             new java.security.PrivilegedAction&lt;&gt;() {
1842                 public Class&lt;?&gt;[] run() {
1843                     List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();
1844                     Class&lt;?&gt; currentClass = Class.this;
1845                     while (currentClass != null) {
1846                         for (Class&lt;?&gt; m : currentClass.getDeclaredClasses()) {
1847                             if (Modifier.isPublic(m.getModifiers())) {
1848                                 list.add(m);
1849                             }
1850                         }
1851                         currentClass = currentClass.getSuperclass();
1852                     }
1853                     return list.toArray(new Class&lt;?&gt;[0]);
1854                 }
1855             });
1856     }
1857 
1858 
1859     /**
1860      * Returns an array containing {@code Field} objects reflecting all
1861      * the accessible public fields of the class or interface represented by
1862      * this {@code Class} object.
1863      *
1864      * &lt;p&gt; If this {@code Class} object represents a class or interface with
1865      * no accessible public fields, then this method returns an array of length
1866      * 0.
1867      *
1868      * &lt;p&gt; If this {@code Class} object represents a class, then this method
1869      * returns the public fields of the class and of all its superclasses and
1870      * superinterfaces.
1871      *
1872      * &lt;p&gt; If this {@code Class} object represents an interface, then this
1873      * method returns the fields of the interface and of all its
1874      * superinterfaces.
1875      *
1876      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
1877      * type, or void, then this method returns an array of length 0.
1878      *
1879      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1880      * particular order.
1881      *
1882      * @return the array of {@code Field} objects representing the
1883      *         public fields
1884      * @throws SecurityException
1885      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1886      *         the caller&#39;s class loader is not the same as or an
1887      *         ancestor of the class loader for the current class and
1888      *         invocation of {@link SecurityManager#checkPackageAccess
1889      *         s.checkPackageAccess()} denies access to the package
1890      *         of this class.
1891      *
1892      * @since 1.1
1893      * @jls 8.2 Class Members
1894      * @jls 8.3 Field Declarations
1895      */
1896     @CallerSensitive
1897     public Field[] getFields() throws SecurityException {
1898         SecurityManager sm = System.getSecurityManager();
1899         if (sm != null) {
1900             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1901         }
1902         return copyFields(privateGetPublicFields());
1903     }
1904 
1905 
1906     /**
1907      * Returns an array containing {@code Method} objects reflecting all the
1908      * public methods of the class or interface represented by this {@code
1909      * Class} object, including those declared by the class or interface and
1910      * those inherited from superclasses and superinterfaces.
1911      *
1912      * &lt;p&gt; If this {@code Class} object represents an array type, then the
1913      * returned array has a {@code Method} object for each of the public
1914      * methods inherited by the array type from {@code Object}. It does not
1915      * contain a {@code Method} object for {@code clone()}.
1916      *
1917      * &lt;p&gt; If this {@code Class} object represents an interface then the
1918      * returned array does not contain any implicitly declared methods from
1919      * {@code Object}. Therefore, if no methods are explicitly declared in
1920      * this interface or any of its superinterfaces then the returned array
1921      * has length 0. (Note that a {@code Class} object which represents a class
1922      * always has public methods, inherited from {@code Object}.)
1923      *
1924      * &lt;p&gt; The returned array never contains methods with names &quot;{@code &lt;init&gt;}&quot;
1925      * or &quot;{@code &lt;clinit&gt;}&quot;.
1926      *
1927      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1928      * particular order.
1929      *
1930      * &lt;p&gt; Generally, the result is computed as with the following 4 step algorithm.
1931      * Let C be the class or interface represented by this {@code Class} object:
1932      * &lt;ol&gt;
1933      * &lt;li&gt; A union of methods is composed of:
1934      *   &lt;ol type=&quot;a&quot;&gt;
1935      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
1936      *        {@link #getDeclaredMethods()} and filtered to include only public
1937      *        methods.&lt;/li&gt;
1938      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
1939      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
1940      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
1941      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
1942      *   &lt;/ol&gt;&lt;/li&gt;
1943      * &lt;li&gt; Union from step 1 is partitioned into subsets of methods with same
1944      *      signature (name, parameter types) and return type.&lt;/li&gt;
1945      * &lt;li&gt; Within each such subset only the most specific methods are selected.
1946      *      Let method M be a method from a set of methods with same signature
1947      *      and return type. M is most specific if there is no such method
1948      *      N != M from the same set, such that N is more specific than M.
1949      *      N is more specific than M if:
1950      *   &lt;ol type=&quot;a&quot;&gt;
1951      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
1952      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
1953      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
1954      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
1955      *        M and N are the same method).&lt;/li&gt;
1956      *   &lt;/ol&gt;&lt;/li&gt;
1957      * &lt;li&gt; The result of this algorithm is the union of all selected methods from
1958      *      step 3.&lt;/li&gt;
1959      * &lt;/ol&gt;
1960      *
1961      * @apiNote There may be more than one method with a particular name
1962      * and parameter types in a class because while the Java language forbids a
1963      * class to declare multiple methods with the same signature but different
1964      * return types, the Java virtual machine does not.  This
1965      * increased flexibility in the virtual machine can be used to
1966      * implement various language features.  For example, covariant
1967      * returns can be implemented with {@linkplain
1968      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
1969      * method and the overriding method would have the same
1970      * signature but different return types.
1971      *
1972      * @return the array of {@code Method} objects representing the
1973      *         public methods of this class
1974      * @throws SecurityException
1975      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1976      *         the caller&#39;s class loader is not the same as or an
1977      *         ancestor of the class loader for the current class and
1978      *         invocation of {@link SecurityManager#checkPackageAccess
1979      *         s.checkPackageAccess()} denies access to the package
1980      *         of this class.
1981      *
1982      * @jls 8.2 Class Members
1983      * @jls 8.4 Method Declarations
1984      * @since 1.1
1985      */
1986     @CallerSensitive
1987     public Method[] getMethods() throws SecurityException {
1988         SecurityManager sm = System.getSecurityManager();
1989         if (sm != null) {
1990             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1991         }
1992         return copyMethods(privateGetPublicMethods());
1993     }
1994 
1995 
1996     /**
1997      * Returns an array containing {@code Constructor} objects reflecting
1998      * all the public constructors of the class represented by this
1999      * {@code Class} object.  An array of length 0 is returned if the
2000      * class has no public constructors, or if the class is an array class, or
2001      * if the class reflects a primitive type or void.
2002      *
2003      * @apiNote
2004      * While this method returns an array of {@code
2005      * Constructor&lt;T&gt;} objects (that is an array of constructors from
2006      * this class), the return type of this method is {@code
2007      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
2008      * might be expected.  This less informative return type is
2009      * necessary since after being returned from this method, the
2010      * array could be modified to hold {@code Constructor} objects for
2011      * different classes, which would violate the type guarantees of
2012      * {@code Constructor&lt;T&gt;[]}.
2013      *
2014      * @return the array of {@code Constructor} objects representing the
2015      *         public constructors of this class
2016      * @throws SecurityException
2017      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2018      *         the caller&#39;s class loader is not the same as or an
2019      *         ancestor of the class loader for the current class and
2020      *         invocation of {@link SecurityManager#checkPackageAccess
2021      *         s.checkPackageAccess()} denies access to the package
2022      *         of this class.
2023      *
2024      * @since 1.1
2025      */
2026     @CallerSensitive
2027     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2028         SecurityManager sm = System.getSecurityManager();
2029         if (sm != null) {
2030             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2031         }
2032         return copyConstructors(privateGetDeclaredConstructors(true));
2033     }
2034 
2035 
2036     /**
2037      * Returns a {@code Field} object that reflects the specified public member
2038      * field of the class or interface represented by this {@code Class}
2039      * object. The {@code name} parameter is a {@code String} specifying the
2040      * simple name of the desired field.
2041      *
2042      * &lt;p&gt; The field to be reflected is determined by the algorithm that
2043      * follows.  Let C be the class or interface represented by this {@code Class} object:
2044      *
2045      * &lt;OL&gt;
2046      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2047      *      field to be reflected.&lt;/LI&gt;
2048      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2049      *      recursively to each direct superinterface of C. The direct
2050      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2051      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2052      *      superclass S, then this algorithm is invoked recursively upon S.
2053      *      If C has no superclass, then a {@code NoSuchFieldException}
2054      *      is thrown.&lt;/LI&gt;
2055      * &lt;/OL&gt;
2056      *
2057      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2058      * method does not find the {@code length} field of the array type.
2059      *
2060      * @param name the field name
2061      * @return the {@code Field} object of this class specified by
2062      *         {@code name}
2063      * @throws NoSuchFieldException if a field with the specified name is
2064      *         not found.
2065      * @throws NullPointerException if {@code name} is {@code null}
2066      * @throws SecurityException
2067      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2068      *         the caller&#39;s class loader is not the same as or an
2069      *         ancestor of the class loader for the current class and
2070      *         invocation of {@link SecurityManager#checkPackageAccess
2071      *         s.checkPackageAccess()} denies access to the package
2072      *         of this class.
2073      *
2074      * @since 1.1
2075      * @jls 8.2 Class Members
2076      * @jls 8.3 Field Declarations
2077      */
2078     @CallerSensitive
2079     public Field getField(String name)
2080         throws NoSuchFieldException, SecurityException {
2081         Objects.requireNonNull(name);
2082         SecurityManager sm = System.getSecurityManager();
2083         if (sm != null) {
2084             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2085         }
2086         Field field = getField0(name);
2087         if (field == null) {
2088             throw new NoSuchFieldException(name);
2089         }
2090         return getReflectionFactory().copyField(field);
2091     }
2092 
2093 
2094     /**
2095      * Returns a {@code Method} object that reflects the specified public
2096      * member method of the class or interface represented by this
2097      * {@code Class} object. The {@code name} parameter is a
2098      * {@code String} specifying the simple name of the desired method. The
2099      * {@code parameterTypes} parameter is an array of {@code Class}
2100      * objects that identify the method&#39;s formal parameter types, in declared
2101      * order. If {@code parameterTypes} is {@code null}, it is
2102      * treated as if it were an empty array.
2103      *
2104      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2105      * method finds any public method inherited by the array type from
2106      * {@code Object} except method {@code clone()}.
2107      *
2108      * &lt;p&gt; If this {@code Class} object represents an interface then this
2109      * method does not find any implicitly declared method from
2110      * {@code Object}. Therefore, if no methods are explicitly declared in
2111      * this interface or any of its superinterfaces, then this method does not
2112      * find any method.
2113      *
2114      * &lt;p&gt; This method does not find any method with name &quot;{@code &lt;init&gt;}&quot; or
2115      * &quot;{@code &lt;clinit&gt;}&quot;.
2116      *
2117      * &lt;p&gt; Generally, the method to be reflected is determined by the 4 step
2118      * algorithm that follows.
2119      * Let C be the class or interface represented by this {@code Class} object:
2120      * &lt;ol&gt;
2121      * &lt;li&gt; A union of methods is composed of:
2122      *   &lt;ol type=&quot;a&quot;&gt;
2123      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2124      *        {@link #getDeclaredMethods()} and filtered to include only public
2125      *        methods that match given {@code name} and {@code parameterTypes}&lt;/li&gt;
2126      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2127      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2128      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2129      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2130      *   &lt;/ol&gt;&lt;/li&gt;
2131      * &lt;li&gt; This union is partitioned into subsets of methods with same
2132      *      return type (the selection of methods from step 1 also guarantees that
2133      *      they have the same method name and parameter types).&lt;/li&gt;
2134      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2135      *      Let method M be a method from a set of methods with same VM
2136      *      signature (return type, name, parameter types).
2137      *      M is most specific if there is no such method N != M from the same
2138      *      set, such that N is more specific than M. N is more specific than M
2139      *      if:
2140      *   &lt;ol type=&quot;a&quot;&gt;
2141      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2142      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2143      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2144      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2145      *        M and N are the same method).&lt;/li&gt;
2146      *   &lt;/ol&gt;&lt;/li&gt;
2147      * &lt;li&gt; The result of this algorithm is chosen arbitrarily from the methods
2148      *      with most specific return type among all selected methods from step 3.
2149      *      Let R be a return type of a method M from the set of all selected methods
2150      *      from step 3. M is a method with most specific return type if there is
2151      *      no such method N != M from the same set, having return type S != R,
2152      *      such that S is a subtype of R as determined by
2153      *      R.class.{@link #isAssignableFrom}(S.class).
2154      * &lt;/ol&gt;
2155      *
2156      * @apiNote There may be more than one method with matching name and
2157      * parameter types in a class because while the Java language forbids a
2158      * class to declare multiple methods with the same signature but different
2159      * return types, the Java virtual machine does not.  This
2160      * increased flexibility in the virtual machine can be used to
2161      * implement various language features.  For example, covariant
2162      * returns can be implemented with {@linkplain
2163      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2164      * method and the overriding method would have the same
2165      * signature but different return types. This method would return the
2166      * overriding method as it would have a more specific return type.
2167      *
2168      * @param name the name of the method
2169      * @param parameterTypes the list of parameters
2170      * @return the {@code Method} object that matches the specified
2171      *         {@code name} and {@code parameterTypes}
2172      * @throws NoSuchMethodException if a matching method is not found
2173      *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
2174      * @throws NullPointerException if {@code name} is {@code null}
2175      * @throws SecurityException
2176      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2177      *         the caller&#39;s class loader is not the same as or an
2178      *         ancestor of the class loader for the current class and
2179      *         invocation of {@link SecurityManager#checkPackageAccess
2180      *         s.checkPackageAccess()} denies access to the package
2181      *         of this class.
2182      *
2183      * @jls 8.2 Class Members
2184      * @jls 8.4 Method Declarations
2185      * @since 1.1
2186      */
2187     @CallerSensitive
2188     public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
2189         throws NoSuchMethodException, SecurityException {
2190         Objects.requireNonNull(name);
2191         SecurityManager sm = System.getSecurityManager();
2192         if (sm != null) {
2193             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2194         }
2195         Method method = getMethod0(name, parameterTypes);
2196         if (method == null) {
2197             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2198         }
2199         return getReflectionFactory().copyMethod(method);
2200     }
2201 
2202     /**
2203      * Returns a {@code Constructor} object that reflects the specified
2204      * public constructor of the class represented by this {@code Class}
2205      * object. The {@code parameterTypes} parameter is an array of
2206      * {@code Class} objects that identify the constructor&#39;s formal
2207      * parameter types, in declared order.
2208      *
2209      * If this {@code Class} object represents an inner class
2210      * declared in a non-static context, the formal parameter types
2211      * include the explicit enclosing instance as the first parameter.
2212      *
2213      * &lt;p&gt; The constructor to reflect is the public constructor of the class
2214      * represented by this {@code Class} object whose formal parameter
2215      * types match those specified by {@code parameterTypes}.
2216      *
2217      * @param parameterTypes the parameter array
2218      * @return the {@code Constructor} object of the public constructor that
2219      *         matches the specified {@code parameterTypes}
2220      * @throws NoSuchMethodException if a matching method is not found.
2221      * @throws SecurityException
2222      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2223      *         the caller&#39;s class loader is not the same as or an
2224      *         ancestor of the class loader for the current class and
2225      *         invocation of {@link SecurityManager#checkPackageAccess
2226      *         s.checkPackageAccess()} denies access to the package
2227      *         of this class.
2228      *
2229      * @since 1.1
2230      */
2231     @CallerSensitive
2232     public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
2233         throws NoSuchMethodException, SecurityException
2234     {
2235         SecurityManager sm = System.getSecurityManager();
2236         if (sm != null) {
2237             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2238         }
2239         return getReflectionFactory().copyConstructor(
2240             getConstructor0(parameterTypes, Member.PUBLIC));
2241     }
2242 
2243 
2244     /**
2245      * Returns an array of {@code Class} objects reflecting all the
2246      * classes and interfaces declared as members of the class represented by
2247      * this {@code Class} object. This includes public, protected, default
2248      * (package) access, and private classes and interfaces declared by the
2249      * class, but excludes inherited classes and interfaces.  This method
2250      * returns an array of length 0 if the class declares no classes or
2251      * interfaces as members, or if this {@code Class} object represents a
2252      * primitive type, an array class, or void.
2253      *
2254      * @return the array of {@code Class} objects representing all the
2255      *         declared members of this class
2256      * @throws SecurityException
2257      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2258      *         following conditions is met:
2259      *
2260      *         &lt;ul&gt;
2261      *
2262      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
2263      *         class loader of this class and invocation of
2264      *         {@link SecurityManager#checkPermission
2265      *         s.checkPermission} method with
2266      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2267      *         denies access to the declared classes within this class
2268      *
2269      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
2270      *         ancestor of the class loader for the current class and
2271      *         invocation of {@link SecurityManager#checkPackageAccess
2272      *         s.checkPackageAccess()} denies access to the package
2273      *         of this class
2274      *
2275      *         &lt;/ul&gt;
2276      *
2277      * @since 1.1
2278      */
2279     @CallerSensitive
2280     public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
2281         SecurityManager sm = System.getSecurityManager();
2282         if (sm != null) {
2283             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);
2284         }
2285         return getDeclaredClasses0();
2286     }
2287 
2288 
2289     /**
2290      * Returns an array of {@code Field} objects reflecting all the fields
2291      * declared by the class or interface represented by this
2292      * {@code Class} object. This includes public, protected, default
2293      * (package) access, and private fields, but excludes inherited fields.
2294      *
2295      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2296      * declared fields, then this method returns an array of length 0.
2297      *
2298      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2299      * type, or void, then this method returns an array of length 0.
2300      *
2301      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2302      * particular order.
2303      *
2304      * @return  the array of {@code Field} objects representing all the
2305      *          declared fields of this class
2306      * @throws  SecurityException
2307      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2308      *          following conditions is met:
2309      *
2310      *          &lt;ul&gt;
2311      *
2312      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2313      *          class loader of this class and invocation of
2314      *          {@link SecurityManager#checkPermission
2315      *          s.checkPermission} method with
2316      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2317      *          denies access to the declared fields within this class
2318      *
2319      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2320      *          ancestor of the class loader for the current class and
2321      *          invocation of {@link SecurityManager#checkPackageAccess
2322      *          s.checkPackageAccess()} denies access to the package
2323      *          of this class
2324      *
2325      *          &lt;/ul&gt;
2326      *
2327      * @since 1.1
2328      * @jls 8.2 Class Members
2329      * @jls 8.3 Field Declarations
2330      */
2331     @CallerSensitive
2332     public Field[] getDeclaredFields() throws SecurityException {
2333         SecurityManager sm = System.getSecurityManager();
2334         if (sm != null) {
2335             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2336         }
2337         return copyFields(privateGetDeclaredFields(false));
2338     }
2339 
2340     /**
2341      * {@preview Associated with records, a preview feature of the Java language.
2342      *
2343      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
2344      *           feature of the Java language. Preview features
2345      *           may be removed in a future release, or upgraded to permanent
2346      *           features of the Java language.}
2347      *
2348      * Returns an array of {@code RecordComponent} objects representing all the
2349      * record components of this record class, or {@code null} if this class is
2350      * not a record class.
2351      *
2352      * &lt;p&gt; The components are returned in the same order that they are declared
2353      * in the record header. The array is empty if this record class has no
2354      * components. If the class is not a record class, that is {@link
2355      * #isRecord()} returns {@code false}, then this method returns {@code null}.
2356      * Conversely, if {@link #isRecord()} returns {@code true}, then this method
2357      * returns a non-null value.
2358      *
2359      * @return  An array of {@code RecordComponent} objects representing all the
2360      *          record components of this record class, or {@code null} if this
2361      *          class is not a record class
2362      * @throws  SecurityException
2363      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2364      *          following conditions is met:
2365      *
2366      *          &lt;ul&gt;
2367      *
2368      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2369      *          class loader of this class and invocation of
2370      *          {@link SecurityManager#checkPermission
2371      *          s.checkPermission} method with
2372      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2373      *          denies access to the declared methods within this class
2374      *
2375      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2376      *          ancestor of the class loader for the current class and
2377      *          invocation of {@link SecurityManager#checkPackageAccess
2378      *          s.checkPackageAccess()} denies access to the package
2379      *          of this class
2380      *
2381      *          &lt;/ul&gt;
2382      *
2383      * @jls 8.10 Record Types
2384      * @since 14
2385      */
2386     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
2387                                  essentialAPI=false)
2388     @SuppressWarnings(&quot;preview&quot;)
2389     @CallerSensitive
2390     public RecordComponent[] getRecordComponents() {
2391         SecurityManager sm = System.getSecurityManager();
2392         if (sm != null) {
2393             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2394         }
2395         if (!isRecord()) {
2396             return null;
2397         }
2398         RecordComponent[] recordComponents = getRecordComponents0();
2399         if (recordComponents == null) {
2400             return new RecordComponent[0];
2401         }
2402         return recordComponents;
2403     }
2404 
2405     /**
2406      * Returns an array containing {@code Method} objects reflecting all the
2407      * declared methods of the class or interface represented by this {@code
2408      * Class} object, including public, protected, default (package)
2409      * access, and private methods, but excluding inherited methods.
2410      *
2411      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2412      * declared methods with the same name and parameter types, but different
2413      * return types, then the returned array has a {@code Method} object for
2414      * each such method.
2415      *
2416      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2417      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2418      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2419      *
2420      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2421      * declared methods, then the returned array has length 0.
2422      *
2423      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2424      * type, or void, then the returned array has length 0.
2425      *
2426      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2427      * particular order.
2428      *
2429      * @return  the array of {@code Method} objects representing all the
2430      *          declared methods of this class
2431      * @throws  SecurityException
2432      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2433      *          following conditions is met:
2434      *
2435      *          &lt;ul&gt;
2436      *
2437      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2438      *          class loader of this class and invocation of
2439      *          {@link SecurityManager#checkPermission
2440      *          s.checkPermission} method with
2441      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2442      *          denies access to the declared methods within this class
2443      *
2444      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2445      *          ancestor of the class loader for the current class and
2446      *          invocation of {@link SecurityManager#checkPackageAccess
2447      *          s.checkPackageAccess()} denies access to the package
2448      *          of this class
2449      *
2450      *          &lt;/ul&gt;
2451      *
2452      * @jls 8.2 Class Members
2453      * @jls 8.4 Method Declarations
2454      * @since 1.1
2455      */
2456     @CallerSensitive
2457     public Method[] getDeclaredMethods() throws SecurityException {
2458         SecurityManager sm = System.getSecurityManager();
2459         if (sm != null) {
2460             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2461         }
2462         return copyMethods(privateGetDeclaredMethods(false));
2463     }
2464 
2465 
2466     /**
2467      * Returns an array of {@code Constructor} objects reflecting all the
2468      * constructors declared by the class represented by this
2469      * {@code Class} object. These are public, protected, default
2470      * (package) access, and private constructors.  The elements in the array
2471      * returned are not sorted and are not in any particular order.  If the
2472      * class has a default constructor, it is included in the returned array.
2473      * This method returns an array of length 0 if this {@code Class}
2474      * object represents an interface, a primitive type, an array class, or
2475      * void.
2476      *
2477      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
2478      * section {@jls 8.2}.
2479      *
2480      * @return  the array of {@code Constructor} objects representing all the
2481      *          declared constructors of this class
2482      * @throws  SecurityException
2483      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2484      *          following conditions is met:
2485      *
2486      *          &lt;ul&gt;
2487      *
2488      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2489      *          class loader of this class and invocation of
2490      *          {@link SecurityManager#checkPermission
2491      *          s.checkPermission} method with
2492      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2493      *          denies access to the declared constructors within this class
2494      *
2495      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2496      *          ancestor of the class loader for the current class and
2497      *          invocation of {@link SecurityManager#checkPackageAccess
2498      *          s.checkPackageAccess()} denies access to the package
2499      *          of this class
2500      *
2501      *          &lt;/ul&gt;
2502      *
2503      * @since 1.1
2504      */
2505     @CallerSensitive
2506     public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
2507         SecurityManager sm = System.getSecurityManager();
2508         if (sm != null) {
2509             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2510         }
2511         return copyConstructors(privateGetDeclaredConstructors(false));
2512     }
2513 
2514 
2515     /**
2516      * Returns a {@code Field} object that reflects the specified declared
2517      * field of the class or interface represented by this {@code Class}
2518      * object. The {@code name} parameter is a {@code String} that specifies
2519      * the simple name of the desired field.
2520      *
2521      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2522      * method does not find the {@code length} field of the array type.
2523      *
2524      * @param name the name of the field
2525      * @return  the {@code Field} object for the specified field in this
2526      *          class
2527      * @throws  NoSuchFieldException if a field with the specified name is
2528      *          not found.
2529      * @throws  NullPointerException if {@code name} is {@code null}
2530      * @throws  SecurityException
2531      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2532      *          following conditions is met:
2533      *
2534      *          &lt;ul&gt;
2535      *
2536      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2537      *          class loader of this class and invocation of
2538      *          {@link SecurityManager#checkPermission
2539      *          s.checkPermission} method with
2540      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2541      *          denies access to the declared field
2542      *
2543      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2544      *          ancestor of the class loader for the current class and
2545      *          invocation of {@link SecurityManager#checkPackageAccess
2546      *          s.checkPackageAccess()} denies access to the package
2547      *          of this class
2548      *
2549      *          &lt;/ul&gt;
2550      *
2551      * @since 1.1
2552      * @jls 8.2 Class Members
2553      * @jls 8.3 Field Declarations
2554      */
2555     @CallerSensitive
2556     public Field getDeclaredField(String name)
2557         throws NoSuchFieldException, SecurityException {
2558         Objects.requireNonNull(name);
2559         SecurityManager sm = System.getSecurityManager();
2560         if (sm != null) {
2561             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2562         }
2563         Field field = searchFields(privateGetDeclaredFields(false), name);
2564         if (field == null) {
2565             throw new NoSuchFieldException(name);
2566         }
2567         return getReflectionFactory().copyField(field);
2568     }
2569 
2570 
2571     /**
2572      * Returns a {@code Method} object that reflects the specified
2573      * declared method of the class or interface represented by this
2574      * {@code Class} object. The {@code name} parameter is a
2575      * {@code String} that specifies the simple name of the desired
2576      * method, and the {@code parameterTypes} parameter is an array of
2577      * {@code Class} objects that identify the method&#39;s formal parameter
2578      * types, in declared order.  If more than one method with the same
2579      * parameter types is declared in a class, and one of these methods has a
2580      * return type that is more specific than any of the others, that method is
2581      * returned; otherwise one of the methods is chosen arbitrarily.  If the
2582      * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}
2583      * is raised.
2584      *
2585      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2586      * method does not find the {@code clone()} method.
2587      *
2588      * @param name the name of the method
2589      * @param parameterTypes the parameter array
2590      * @return  the {@code Method} object for the method of this class
2591      *          matching the specified name and parameters
2592      * @throws  NoSuchMethodException if a matching method is not found.
2593      * @throws  NullPointerException if {@code name} is {@code null}
2594      * @throws  SecurityException
2595      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2596      *          following conditions is met:
2597      *
2598      *          &lt;ul&gt;
2599      *
2600      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2601      *          class loader of this class and invocation of
2602      *          {@link SecurityManager#checkPermission
2603      *          s.checkPermission} method with
2604      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2605      *          denies access to the declared method
2606      *
2607      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2608      *          ancestor of the class loader for the current class and
2609      *          invocation of {@link SecurityManager#checkPackageAccess
2610      *          s.checkPackageAccess()} denies access to the package
2611      *          of this class
2612      *
2613      *          &lt;/ul&gt;
2614      *
2615      * @jls 8.2 Class Members
2616      * @jls 8.4 Method Declarations
2617      * @since 1.1
2618      */
2619     @CallerSensitive
2620     public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
2621         throws NoSuchMethodException, SecurityException {
2622         Objects.requireNonNull(name);
2623         SecurityManager sm = System.getSecurityManager();
2624         if (sm != null) {
2625             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2626         }
2627         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
2628         if (method == null) {
2629             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2630         }
2631         return getReflectionFactory().copyMethod(method);
2632     }
2633 
2634     /**
2635      * Returns the list of {@code Method} objects for the declared public
2636      * methods of this class or interface that have the specified method name
2637      * and parameter types.
2638      *
2639      * @param name the name of the method
2640      * @param parameterTypes the parameter array
2641      * @return the list of {@code Method} objects for the public methods of
2642      *         this class matching the specified name and parameters
2643      */
2644     List&lt;Method&gt; getDeclaredPublicMethods(String name, Class&lt;?&gt;... parameterTypes) {
2645         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
2646         ReflectionFactory factory = getReflectionFactory();
2647         List&lt;Method&gt; result = new ArrayList&lt;&gt;();
2648         for (Method method : methods) {
2649             if (method.getName().equals(name)
2650                 &amp;&amp; Arrays.equals(
2651                     factory.getExecutableSharedParameterTypes(method),
2652                     parameterTypes)) {
2653                 result.add(factory.copyMethod(method));
2654             }
2655         }
2656         return result;
2657     }
2658 
2659     /**
2660      * Returns a {@code Constructor} object that reflects the specified
2661      * constructor of the class or interface represented by this
2662      * {@code Class} object.  The {@code parameterTypes} parameter is
2663      * an array of {@code Class} objects that identify the constructor&#39;s
2664      * formal parameter types, in declared order.
2665      *
2666      * If this {@code Class} object represents an inner class
2667      * declared in a non-static context, the formal parameter types
2668      * include the explicit enclosing instance as the first parameter.
2669      *
2670      * @param parameterTypes the parameter array
2671      * @return  The {@code Constructor} object for the constructor with the
2672      *          specified parameter list
2673      * @throws  NoSuchMethodException if a matching method is not found.
2674      * @throws  SecurityException
2675      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2676      *          following conditions is met:
2677      *
2678      *          &lt;ul&gt;
2679      *
2680      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2681      *          class loader of this class and invocation of
2682      *          {@link SecurityManager#checkPermission
2683      *          s.checkPermission} method with
2684      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2685      *          denies access to the declared constructor
2686      *
2687      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2688      *          ancestor of the class loader for the current class and
2689      *          invocation of {@link SecurityManager#checkPackageAccess
2690      *          s.checkPackageAccess()} denies access to the package
2691      *          of this class
2692      *
2693      *          &lt;/ul&gt;
2694      *
2695      * @since 1.1
2696      */
2697     @CallerSensitive
2698     public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
2699         throws NoSuchMethodException, SecurityException
2700     {
2701         SecurityManager sm = System.getSecurityManager();
2702         if (sm != null) {
2703             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2704         }
2705 
2706         return getReflectionFactory().copyConstructor(
2707             getConstructor0(parameterTypes, Member.DECLARED));
2708     }
2709 
2710     /**
2711      * Finds a resource with a given name.
2712      *
2713      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2714      * will attempt to find the resource in the module. This is done by
2715      * delegating to the module&#39;s class loader {@link
2716      * ClassLoader#findResource(String,String) findResource(String,String)}
2717      * method, invoking it with the module name and the absolute name of the
2718      * resource. Resources in named modules are subject to the rules for
2719      * encapsulation specified in the {@code Module} {@link
2720      * Module#getResourceAsStream getResourceAsStream} method and so this
2721      * method returns {@code null} when the resource is a
2722      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2723      * caller&#39;s module.
2724      *
2725      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2726      * searching resources associated with a given class are implemented by the
2727      * defining {@linkplain ClassLoader class loader} of the class.  This method
2728      * delegates to this {@code Class} object&#39;s class loader.
2729      * If this {@code Class} object was loaded by the bootstrap class loader,
2730      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.
2731      *
2732      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2733      * given resource name using this algorithm:
2734      *
2735      * &lt;ul&gt;
2736      *
2737      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2738      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2739      * portion of the {@code name} following the {@code &#39;/&#39;}.
2740      *
2741      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2742      *
2743      * &lt;blockquote&gt;
2744      *   {@code modified_package_name/name}
2745      * &lt;/blockquote&gt;
2746      *
2747      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2748      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2749      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2750      *
2751      * &lt;/ul&gt;
2752      *
2753      * @param  name name of the desired resource
2754      * @return  A {@link java.io.InputStream} object; {@code null} if no
2755      *          resource with this name is found, the resource is in a package
2756      *          that is not {@linkplain Module#isOpen(String, Module) open} to at
2757      *          least the caller module, or access to the resource is denied
2758      *          by the security manager.
2759      * @throws  NullPointerException If {@code name} is {@code null}
2760      *
2761      * @see Module#getResourceAsStream(String)
2762      * @since  1.1
2763      * @revised 9
2764      * @spec JPMS
2765      */
2766     @CallerSensitive
2767     public InputStream getResourceAsStream(String name) {
2768         name = resolveName(name);
2769 
2770         Module thisModule = getModule();
2771         if (thisModule.isNamed()) {
2772             // check if resource can be located by caller
2773             if (Resources.canEncapsulate(name)
2774                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2775                 return null;
2776             }
2777 
2778             // resource not encapsulated or in package open to caller
2779             String mn = thisModule.getName();
2780             ClassLoader cl = getClassLoader0();
2781             try {
2782 
2783                 // special-case built-in class loaders to avoid the
2784                 // need for a URL connection
2785                 if (cl == null) {
2786                     return BootLoader.findResourceAsStream(mn, name);
2787                 } else if (cl instanceof BuiltinClassLoader) {
2788                     return ((BuiltinClassLoader) cl).findResourceAsStream(mn, name);
2789                 } else {
2790                     URL url = cl.findResource(mn, name);
2791                     return (url != null) ? url.openStream() : null;
2792                 }
2793 
2794             } catch (IOException | SecurityException e) {
2795                 return null;
2796             }
2797         }
2798 
2799         // unnamed module
2800         ClassLoader cl = getClassLoader0();
2801         if (cl == null) {
2802             return ClassLoader.getSystemResourceAsStream(name);
2803         } else {
2804             return cl.getResourceAsStream(name);
2805         }
2806     }
2807 
2808     /**
2809      * Finds a resource with a given name.
2810      *
2811      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2812      * will attempt to find the resource in the module. This is done by
2813      * delegating to the module&#39;s class loader {@link
2814      * ClassLoader#findResource(String,String) findResource(String,String)}
2815      * method, invoking it with the module name and the absolute name of the
2816      * resource. Resources in named modules are subject to the rules for
2817      * encapsulation specified in the {@code Module} {@link
2818      * Module#getResourceAsStream getResourceAsStream} method and so this
2819      * method returns {@code null} when the resource is a
2820      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2821      * caller&#39;s module.
2822      *
2823      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2824      * searching resources associated with a given class are implemented by the
2825      * defining {@linkplain ClassLoader class loader} of the class.  This method
2826      * delegates to this {@code Class} object&#39;s class loader.
2827      * If this {@code Class} object was loaded by the bootstrap class loader,
2828      * the method delegates to {@link ClassLoader#getSystemResource}.
2829      *
2830      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2831      * given resource name using this algorithm:
2832      *
2833      * &lt;ul&gt;
2834      *
2835      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2836      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2837      * portion of the {@code name} following the {@code &#39;/&#39;}.
2838      *
2839      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2840      *
2841      * &lt;blockquote&gt;
2842      *   {@code modified_package_name/name}
2843      * &lt;/blockquote&gt;
2844      *
2845      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2846      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2847      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2848      *
2849      * &lt;/ul&gt;
2850      *
2851      * @param  name name of the desired resource
2852      * @return A {@link java.net.URL} object; {@code null} if no resource with
2853      *         this name is found, the resource cannot be located by a URL, the
2854      *         resource is in a package that is not
2855      *         {@linkplain Module#isOpen(String, Module) open} to at least the caller
2856      *         module, or access to the resource is denied by the security
2857      *         manager.
2858      * @throws NullPointerException If {@code name} is {@code null}
2859      * @since  1.1
2860      * @revised 9
2861      * @spec JPMS
2862      */
2863     @CallerSensitive
2864     public URL getResource(String name) {
2865         name = resolveName(name);
2866 
2867         Module thisModule = getModule();
2868         if (thisModule.isNamed()) {
2869             // check if resource can be located by caller
2870             if (Resources.canEncapsulate(name)
2871                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2872                 return null;
2873             }
2874 
2875             // resource not encapsulated or in package open to caller
2876             String mn = thisModule.getName();
2877             ClassLoader cl = getClassLoader0();
2878             try {
2879                 if (cl == null) {
2880                     return BootLoader.findResource(mn, name);
2881                 } else {
2882                     return cl.findResource(mn, name);
2883                 }
2884             } catch (IOException ioe) {
2885                 return null;
2886             }
2887         }
2888 
2889         // unnamed module
2890         ClassLoader cl = getClassLoader0();
2891         if (cl == null) {
2892             return ClassLoader.getSystemResource(name);
2893         } else {
2894             return cl.getResource(name);
2895         }
2896     }
2897 
2898     /**
2899      * Returns true if a resource with the given name can be located by the
2900      * given caller. All resources in a module can be located by code in
2901      * the module. For other callers, then the package needs to be open to
2902      * the caller.
2903      */
2904     private boolean isOpenToCaller(String name, Class&lt;?&gt; caller) {
2905         // assert getModule().isNamed();
2906         Module thisModule = getModule();
2907         Module callerModule = (caller != null) ? caller.getModule() : null;
2908         if (callerModule != thisModule) {
2909             String pn = Resources.toPackageName(name);
2910             if (thisModule.getDescriptor().packages().contains(pn)) {
2911                 if (callerModule == null &amp;&amp; !thisModule.isOpen(pn)) {
2912                     // no caller, package not open
2913                     return false;
2914                 }
2915                 if (!thisModule.isOpen(pn, callerModule)) {
2916                     // package not open to caller
2917                     return false;
2918                 }
2919             }
2920         }
2921         return true;
2922     }
2923 
2924 
2925     /** protection domain returned when the internal domain is null */
2926     private static java.security.ProtectionDomain allPermDomain;
2927 
2928     /**
2929      * Returns the {@code ProtectionDomain} of this class.  If there is a
2930      * security manager installed, this method first calls the security
2931      * manager&#39;s {@code checkPermission} method with a
2932      * {@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
2933      * ensure it&#39;s ok to get the
2934      * {@code ProtectionDomain}.
2935      *
2936      * @return the ProtectionDomain of this class
2937      *
2938      * @throws SecurityException
2939      *        if a security manager exists and its
2940      *        {@code checkPermission} method doesn&#39;t allow
2941      *        getting the ProtectionDomain.
2942      *
2943      * @see java.security.ProtectionDomain
2944      * @see SecurityManager#checkPermission
2945      * @see java.lang.RuntimePermission
2946      * @since 1.2
2947      */
2948     public java.security.ProtectionDomain getProtectionDomain() {
2949         SecurityManager sm = System.getSecurityManager();
2950         if (sm != null) {
2951             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
2952         }
2953         java.security.ProtectionDomain pd = getProtectionDomain0();
2954         if (pd == null) {
2955             if (allPermDomain == null) {
2956                 java.security.Permissions perms =
2957                     new java.security.Permissions();
2958                 perms.add(SecurityConstants.ALL_PERMISSION);
2959                 allPermDomain =
2960                     new java.security.ProtectionDomain(null, perms);
2961             }
2962             pd = allPermDomain;
2963         }
2964         return pd;
2965     }
2966 
2967 
2968     /**
2969      * Returns the ProtectionDomain of this class.
2970      */
2971     private native java.security.ProtectionDomain getProtectionDomain0();
2972 
2973     /*
2974      * Return the Virtual Machine&#39;s Class object for the named
2975      * primitive type.
2976      */
2977     static native Class&lt;?&gt; getPrimitiveClass(String name);
2978 
2979     /*
2980      * Check if client is allowed to access members.  If access is denied,
2981      * throw a SecurityException.
2982      *
2983      * This method also enforces package access.
2984      *
2985      * &lt;p&gt; Default policy: allow all clients access with normal Java access
2986      * control.
2987      *
2988      * &lt;p&gt; NOTE: should only be called if a SecurityManager is installed
2989      */
2990     private void checkMemberAccess(SecurityManager sm, int which,
2991                                    Class&lt;?&gt; caller, boolean checkProxyInterfaces) {
2992         /* Default policy allows access to all {@link Member#PUBLIC} members,
2993          * as well as access to classes that have the same class loader as the caller.
2994          * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
2995          * permission.
2996          */
2997         final ClassLoader ccl = ClassLoader.getClassLoader(caller);
2998         if (which != Member.PUBLIC) {
2999             final ClassLoader cl = getClassLoader0();
3000             if (ccl != cl) {
3001                 sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3002             }
3003         }
3004         this.checkPackageAccess(sm, ccl, checkProxyInterfaces);
3005     }
3006 
3007     /*
3008      * Checks if a client loaded in ClassLoader ccl is allowed to access this
3009      * class under the current package access policy. If access is denied,
3010      * throw a SecurityException.
3011      *
3012      * NOTE: this method should only be called if a SecurityManager is active
3013      */
3014     private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,
3015                                     boolean checkProxyInterfaces) {
3016         final ClassLoader cl = getClassLoader0();
3017 
3018         if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
3019             String pkg = this.getPackageName();
3020             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3021                 // skip the package access check on a proxy class in default proxy package
3022                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3023                     sm.checkPackageAccess(pkg);
3024                 }
3025             }
3026         }
3027         // check package access on the proxy interfaces
3028         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3029             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3030         }
3031     }
3032 
3033     /**
3034      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3035      * if name is absolute
3036      */
3037     private String resolveName(String name) {
3038         if (!name.startsWith(&quot;/&quot;)) {
3039             Class&lt;?&gt; c = this;
3040             while (c.isArray()) {
3041                 c = c.getComponentType();
3042             }
3043             String baseName = c.getPackageName();
3044             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3045                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3046             }
3047         } else {
3048             name = name.substring(1);
3049         }
3050         return name;
3051     }
3052 
3053     /**
3054      * Atomic operations support.
3055      */
3056     private static class Atomic {
3057         // initialize Unsafe machinery here, since we need to call Class.class instance method
3058         // and have to avoid calling it in the static initializer of the Class class...
3059         private static final Unsafe unsafe = Unsafe.getUnsafe();
3060         // offset of Class.reflectionData instance field
3061         private static final long reflectionDataOffset
3062                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
3063         // offset of Class.annotationType instance field
3064         private static final long annotationTypeOffset
3065                 = unsafe.objectFieldOffset(Class.class, &quot;annotationType&quot;);
3066         // offset of Class.annotationData instance field
3067         private static final long annotationDataOffset
3068                 = unsafe.objectFieldOffset(Class.class, &quot;annotationData&quot;);
3069 
3070         static &lt;T&gt; boolean casReflectionData(Class&lt;?&gt; clazz,
3071                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
3072                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) {
3073             return unsafe.compareAndSetReference(clazz, reflectionDataOffset, oldData, newData);
3074         }
3075 
3076         static &lt;T&gt; boolean casAnnotationType(Class&lt;?&gt; clazz,
3077                                              AnnotationType oldType,
3078                                              AnnotationType newType) {
3079             return unsafe.compareAndSetReference(clazz, annotationTypeOffset, oldType, newType);
3080         }
3081 
3082         static &lt;T&gt; boolean casAnnotationData(Class&lt;?&gt; clazz,
3083                                              AnnotationData oldData,
3084                                              AnnotationData newData) {
3085             return unsafe.compareAndSetReference(clazz, annotationDataOffset, oldData, newData);
3086         }
3087     }
3088 
3089     /**
3090      * Reflection support.
3091      */
3092 
3093     // Reflection data caches various derived names and reflective members. Cached
3094     // values may be invalidated when JVM TI RedefineClasses() is called
3095     private static class ReflectionData&lt;T&gt; {
3096         volatile Field[] declaredFields;
3097         volatile Field[] publicFields;
3098         volatile Method[] declaredMethods;
3099         volatile Method[] publicMethods;
3100         volatile Constructor&lt;T&gt;[] declaredConstructors;
3101         volatile Constructor&lt;T&gt;[] publicConstructors;
3102         // Intermediate results for getFields and getMethods
3103         volatile Field[] declaredPublicFields;
3104         volatile Method[] declaredPublicMethods;
3105         volatile Class&lt;?&gt;[] interfaces;
3106 
3107         // Cached names
3108         String simpleName;
3109         String canonicalName;
3110         static final String NULL_SENTINEL = new String();
3111 
3112         // Value of classRedefinedCount when we created this ReflectionData instance
3113         final int redefinedCount;
3114 
3115         ReflectionData(int redefinedCount) {
3116             this.redefinedCount = redefinedCount;
3117         }
3118     }
3119 
3120     private transient volatile SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;
3121 
3122     // Incremented by the VM on each call to JVM TI RedefineClasses()
3123     // that redefines this class or a superclass.
3124     private transient volatile int classRedefinedCount;
3125 
3126     // Lazily create and cache ReflectionData
3127     private ReflectionData&lt;T&gt; reflectionData() {
3128         SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;
3129         int classRedefinedCount = this.classRedefinedCount;
3130         ReflectionData&lt;T&gt; rd;
3131         if (reflectionData != null &amp;&amp;
3132             (rd = reflectionData.get()) != null &amp;&amp;
3133             rd.redefinedCount == classRedefinedCount) {
3134             return rd;
3135         }
3136         // else no SoftReference or cleared SoftReference or stale ReflectionData
3137         // -&gt; create and replace new instance
3138         return newReflectionData(reflectionData, classRedefinedCount);
3139     }
3140 
3141     private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
3142                                                 int classRedefinedCount) {
3143         while (true) {
3144             ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);
3145             // try to CAS it...
3146             if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {
3147                 return rd;
3148             }
3149             // else retry
3150             oldReflectionData = this.reflectionData;
3151             classRedefinedCount = this.classRedefinedCount;
3152             if (oldReflectionData != null &amp;&amp;
3153                 (rd = oldReflectionData.get()) != null &amp;&amp;
3154                 rd.redefinedCount == classRedefinedCount) {
3155                 return rd;
3156             }
3157         }
3158     }
3159 
3160     // Generic signature handling
3161     private native String getGenericSignature0();
3162 
3163     // Generic info repository; lazily initialized
3164     private transient volatile ClassRepository genericInfo;
3165 
3166     // accessor for factory
3167     private GenericsFactory getFactory() {
3168         // create scope and factory
3169         return CoreReflectionFactory.make(this, ClassScope.make(this));
3170     }
3171 
3172     // accessor for generic info repository;
3173     // generic info is lazily initialized
3174     private ClassRepository getGenericInfo() {
3175         ClassRepository genericInfo = this.genericInfo;
3176         if (genericInfo == null) {
3177             String signature = getGenericSignature0();
3178             if (signature == null) {
3179                 genericInfo = ClassRepository.NONE;
3180             } else {
3181                 genericInfo = ClassRepository.make(signature, getFactory());
3182             }
3183             this.genericInfo = genericInfo;
3184         }
3185         return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
3186     }
3187 
3188     // Annotations handling
3189     native byte[] getRawAnnotations();
3190     // Since 1.8
3191     native byte[] getRawTypeAnnotations();
3192     static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
3193         return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
3194     }
3195 
3196     native ConstantPool getConstantPool();
3197 
3198     //
3199     //
3200     // java.lang.reflect.Field handling
3201     //
3202     //
3203 
3204     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3205     // be propagated to the outside world, but must instead be copied
3206     // via ReflectionFactory.copyField.
3207     private Field[] privateGetDeclaredFields(boolean publicOnly) {
3208         Field[] res;
3209         ReflectionData&lt;T&gt; rd = reflectionData();
3210         if (rd != null) {
3211             res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
3212             if (res != null) return res;
3213         }
3214         // No cached value available; request value from VM
3215         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
3216         if (rd != null) {
3217             if (publicOnly) {
3218                 rd.declaredPublicFields = res;
3219             } else {
3220                 rd.declaredFields = res;
3221             }
3222         }
3223         return res;
3224     }
3225 
3226     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3227     // be propagated to the outside world, but must instead be copied
3228     // via ReflectionFactory.copyField.
3229     private Field[] privateGetPublicFields() {
3230         Field[] res;
3231         ReflectionData&lt;T&gt; rd = reflectionData();
3232         if (rd != null) {
3233             res = rd.publicFields;
3234             if (res != null) return res;
3235         }
3236 
3237         // Use a linked hash set to ensure order is preserved and
3238         // fields from common super interfaces are not duplicated
3239         LinkedHashSet&lt;Field&gt; fields = new LinkedHashSet&lt;&gt;();
3240 
3241         // Local fields
3242         addAll(fields, privateGetDeclaredFields(true));
3243 
3244         // Direct superinterfaces, recursively
3245         for (Class&lt;?&gt; si : getInterfaces()) {
3246             addAll(fields, si.privateGetPublicFields());
3247         }
3248 
3249         // Direct superclass, recursively
3250         Class&lt;?&gt; sc = getSuperclass();
3251         if (sc != null) {
3252             addAll(fields, sc.privateGetPublicFields());
3253         }
3254 
3255         res = fields.toArray(new Field[0]);
3256         if (rd != null) {
3257             rd.publicFields = res;
3258         }
3259         return res;
3260     }
3261 
3262     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
3263         for (Field f : o) {
3264             c.add(f);
3265         }
3266     }
3267 
3268 
3269     //
3270     //
3271     // java.lang.reflect.Constructor handling
3272     //
3273     //
3274 
3275     // Returns an array of &quot;root&quot; constructors. These Constructor
3276     // objects must NOT be propagated to the outside world, but must
3277     // instead be copied via ReflectionFactory.copyConstructor.
3278     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
3279         Constructor&lt;T&gt;[] res;
3280         ReflectionData&lt;T&gt; rd = reflectionData();
3281         if (rd != null) {
3282             res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
3283             if (res != null) return res;
3284         }
3285         // No cached value available; request value from VM
3286         if (isInterface()) {
3287             @SuppressWarnings(&quot;unchecked&quot;)
3288             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
3289             res = temporaryRes;
3290         } else {
3291             res = getDeclaredConstructors0(publicOnly);
3292         }
3293         if (rd != null) {
3294             if (publicOnly) {
3295                 rd.publicConstructors = res;
3296             } else {
3297                 rd.declaredConstructors = res;
3298             }
3299         }
3300         return res;
3301     }
3302 
3303     //
3304     //
3305     // java.lang.reflect.Method handling
3306     //
3307     //
3308 
3309     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3310     // be propagated to the outside world, but must instead be copied
3311     // via ReflectionFactory.copyMethod.
3312     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
3313         Method[] res;
3314         ReflectionData&lt;T&gt; rd = reflectionData();
3315         if (rd != null) {
3316             res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
3317             if (res != null) return res;
3318         }
3319         // No cached value available; request value from VM
3320         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
3321         if (rd != null) {
3322             if (publicOnly) {
3323                 rd.declaredPublicMethods = res;
3324             } else {
3325                 rd.declaredMethods = res;
3326             }
3327         }
3328         return res;
3329     }
3330 
3331     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3332     // be propagated to the outside world, but must instead be copied
3333     // via ReflectionFactory.copyMethod.
3334     private Method[] privateGetPublicMethods() {
3335         Method[] res;
3336         ReflectionData&lt;T&gt; rd = reflectionData();
3337         if (rd != null) {
3338             res = rd.publicMethods;
3339             if (res != null) return res;
3340         }
3341 
3342         // No cached value available; compute value recursively.
3343         // Start by fetching public declared methods...
3344         PublicMethods pms = new PublicMethods();
3345         for (Method m : privateGetDeclaredMethods(/* publicOnly */ true)) {
3346             pms.merge(m);
3347         }
3348         // ...then recur over superclass methods...
3349         Class&lt;?&gt; sc = getSuperclass();
3350         if (sc != null) {
3351             for (Method m : sc.privateGetPublicMethods()) {
3352                 pms.merge(m);
3353             }
3354         }
3355         // ...and finally over direct superinterfaces.
3356         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3357             for (Method m : intf.privateGetPublicMethods()) {
3358                 // static interface methods are not inherited
3359                 if (!Modifier.isStatic(m.getModifiers())) {
3360                     pms.merge(m);
3361                 }
3362             }
3363         }
3364 
3365         res = pms.toArray();
3366         if (rd != null) {
3367             rd.publicMethods = res;
3368         }
3369         return res;
3370     }
3371 
3372 
3373     //
3374     // Helpers for fetchers of one field, method, or constructor
3375     //
3376 
3377     // This method does not copy the returned Field object!
3378     private static Field searchFields(Field[] fields, String name) {
3379         for (Field field : fields) {
3380             if (field.getName().equals(name)) {
3381                 return field;
3382             }
3383         }
3384         return null;
3385     }
3386 
3387     // Returns a &quot;root&quot; Field object. This Field object must NOT
3388     // be propagated to the outside world, but must instead be copied
3389     // via ReflectionFactory.copyField.
3390     private Field getField0(String name) {
3391         // Note: the intent is that the search algorithm this routine
3392         // uses be equivalent to the ordering imposed by
3393         // privateGetPublicFields(). It fetches only the declared
3394         // public fields for each class, however, to reduce the number
3395         // of Field objects which have to be created for the common
3396         // case where the field being requested is declared in the
3397         // class which is being queried.
3398         Field res;
3399         // Search declared public fields
3400         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
3401             return res;
3402         }
3403         // Direct superinterfaces, recursively
3404         Class&lt;?&gt;[] interfaces = getInterfaces(/* cloneArray */ false);
3405         for (Class&lt;?&gt; c : interfaces) {
3406             if ((res = c.getField0(name)) != null) {
3407                 return res;
3408             }
3409         }
3410         // Direct superclass, recursively
3411         if (!isInterface()) {
3412             Class&lt;?&gt; c = getSuperclass();
3413             if (c != null) {
3414                 if ((res = c.getField0(name)) != null) {
3415                     return res;
3416                 }
3417             }
3418         }
3419         return null;
3420     }
3421 
3422     // This method does not copy the returned Method object!
3423     private static Method searchMethods(Method[] methods,
3424                                         String name,
3425                                         Class&lt;?&gt;[] parameterTypes)
3426     {
3427         ReflectionFactory fact = getReflectionFactory();
3428         Method res = null;
3429         for (Method m : methods) {
3430             if (m.getName().equals(name)
3431                 &amp;&amp; arrayContentsEq(parameterTypes,
3432                                    fact.getExecutableSharedParameterTypes(m))
3433                 &amp;&amp; (res == null
3434                     || (res.getReturnType() != m.getReturnType()
3435                         &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))
3436                 res = m;
3437         }
3438         return res;
3439     }
3440 
3441     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];
3442 
3443     // Returns a &quot;root&quot; Method object. This Method object must NOT
3444     // be propagated to the outside world, but must instead be copied
3445     // via ReflectionFactory.copyMethod.
3446     private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes) {
3447         PublicMethods.MethodList res = getMethodsRecursive(
3448             name,
3449             parameterTypes == null ? EMPTY_CLASS_ARRAY : parameterTypes,
3450             /* includeStatic */ true);
3451         return res == null ? null : res.getMostSpecific();
3452     }
3453 
3454     // Returns a list of &quot;root&quot; Method objects. These Method objects must NOT
3455     // be propagated to the outside world, but must instead be copied
3456     // via ReflectionFactory.copyMethod.
3457     private PublicMethods.MethodList getMethodsRecursive(String name,
3458                                                          Class&lt;?&gt;[] parameterTypes,
3459                                                          boolean includeStatic) {
3460         // 1st check declared public methods
3461         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
3462         PublicMethods.MethodList res = PublicMethods.MethodList
3463             .filter(methods, name, parameterTypes, includeStatic);
3464         // if there is at least one match among declared methods, we need not
3465         // search any further as such match surely overrides matching methods
3466         // declared in superclass(es) or interface(s).
3467         if (res != null) {
3468             return res;
3469         }
3470 
3471         // if there was no match among declared methods,
3472         // we must consult the superclass (if any) recursively...
3473         Class&lt;?&gt; sc = getSuperclass();
3474         if (sc != null) {
3475             res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);
3476         }
3477 
3478         // ...and coalesce the superclass methods with methods obtained
3479         // from directly implemented interfaces excluding static methods...
3480         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3481             res = PublicMethods.MethodList.merge(
3482                 res, intf.getMethodsRecursive(name, parameterTypes,
3483                                               /* includeStatic */ false));
3484         }
3485 
3486         return res;
3487     }
3488 
3489     // Returns a &quot;root&quot; Constructor object. This Constructor object must NOT
3490     // be propagated to the outside world, but must instead be copied
3491     // via ReflectionFactory.copyConstructor.
3492     private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
3493                                         int which) throws NoSuchMethodException
3494     {
3495         ReflectionFactory fact = getReflectionFactory();
3496         Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
3497         for (Constructor&lt;T&gt; constructor : constructors) {
3498             if (arrayContentsEq(parameterTypes,
3499                                 fact.getExecutableSharedParameterTypes(constructor))) {
3500                 return constructor;
3501             }
3502         }
3503         throw new NoSuchMethodException(methodToString(&quot;&lt;init&gt;&quot;, parameterTypes));
3504     }
3505 
3506     //
3507     // Other helpers and base implementation
3508     //
3509 
3510     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
3511         if (a1 == null) {
3512             return a2 == null || a2.length == 0;
3513         }
3514 
3515         if (a2 == null) {
3516             return a1.length == 0;
3517         }
3518 
3519         if (a1.length != a2.length) {
3520             return false;
3521         }
3522 
3523         for (int i = 0; i &lt; a1.length; i++) {
3524             if (a1[i] != a2[i]) {
3525                 return false;
3526             }
3527         }
3528 
3529         return true;
3530     }
3531 
3532     private static Field[] copyFields(Field[] arg) {
3533         Field[] out = new Field[arg.length];
3534         ReflectionFactory fact = getReflectionFactory();
3535         for (int i = 0; i &lt; arg.length; i++) {
3536             out[i] = fact.copyField(arg[i]);
3537         }
3538         return out;
3539     }
3540 
3541     private static Method[] copyMethods(Method[] arg) {
3542         Method[] out = new Method[arg.length];
3543         ReflectionFactory fact = getReflectionFactory();
3544         for (int i = 0; i &lt; arg.length; i++) {
3545             out[i] = fact.copyMethod(arg[i]);
3546         }
3547         return out;
3548     }
3549 
3550     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3551         Constructor&lt;U&gt;[] out = arg.clone();
3552         ReflectionFactory fact = getReflectionFactory();
3553         for (int i = 0; i &lt; out.length; i++) {
3554             out[i] = fact.copyConstructor(out[i]);
3555         }
3556         return out;
3557     }
3558 
3559     private native Field[]       getDeclaredFields0(boolean publicOnly);
3560     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3561     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3562     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3563     @SuppressWarnings(&quot;preview&quot;)
3564     private native RecordComponent[] getRecordComponents0();
3565     private native boolean      isRecord0();
3566 
3567     /**
3568      * Helper method to get the method name from arguments.
3569      */
3570     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3571         return getName() + &#39;.&#39; + name +
3572                 ((argTypes == null || argTypes.length == 0) ?
3573                 &quot;()&quot; :
3574                 Arrays.stream(argTypes)
<a name="18" id="anc18"></a><span class="line-modified">3575                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())</span>
3576                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3577     }
3578 
<a name="19" id="anc19"></a>







3579     /** use serialVersionUID from JDK 1.1 for interoperability */
3580     @java.io.Serial
3581     private static final long serialVersionUID = 3206093459760846163L;
3582 
3583 
3584     /**
3585      * Class Class is special cased within the Serialization Stream Protocol.
3586      *
3587      * A Class instance is written initially into an ObjectOutputStream in the
3588      * following format:
3589      * &lt;pre&gt;
3590      *      {@code TC_CLASS} ClassDescriptor
3591      *      A ClassDescriptor is a special cased serialization of
3592      *      a {@code java.io.ObjectStreamClass} instance.
3593      * &lt;/pre&gt;
3594      * A new handle is generated for the initial time the class descriptor
3595      * is written into the stream. Future references to the class descriptor
3596      * are written as references to the initial class descriptor instance.
3597      *
3598      * @see java.io.ObjectStreamClass
3599      */
3600     @java.io.Serial
3601     private static final ObjectStreamField[] serialPersistentFields =
3602         new ObjectStreamField[0];
3603 
3604 
3605     /**
3606      * Returns the assertion status that would be assigned to this
3607      * class if it were to be initialized at the time this method is invoked.
3608      * If this class has had its assertion status set, the most recent
3609      * setting will be returned; otherwise, if any package default assertion
3610      * status pertains to this class, the most recent setting for the most
3611      * specific pertinent package default assertion status is returned;
3612      * otherwise, if this class is not a system class (i.e., it has a
3613      * class loader) its class loader&#39;s default assertion status is returned;
3614      * otherwise, the system class default assertion status is returned.
3615      *
3616      * @apiNote
3617      * Few programmers will have any need for this method; it is provided
3618      * for the benefit of the JDK itself.  (It allows a class to determine at
3619      * the time that it is initialized whether assertions should be enabled.)
3620      * Note that this method is not guaranteed to return the actual
3621      * assertion status that was (or will be) associated with the specified
3622      * class when it was (or will be) initialized.
3623      *
3624      * @return the desired assertion status of the specified class.
3625      * @see    java.lang.ClassLoader#setClassAssertionStatus
3626      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3627      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3628      * @since  1.4
3629      */
3630     public boolean desiredAssertionStatus() {
3631         ClassLoader loader = getClassLoader0();
3632         // If the loader is null this is a system class, so ask the VM
3633         if (loader == null)
3634             return desiredAssertionStatus0(this);
3635 
3636         // If the classloader has been initialized with the assertion
3637         // directives, ask it. Otherwise, ask the VM.
3638         synchronized(loader.assertionLock) {
3639             if (loader.classAssertionStatus != null) {
3640                 return loader.desiredAssertionStatus(getName());
3641             }
3642         }
3643         return desiredAssertionStatus0(this);
3644     }
3645 
3646     // Retrieves the desired assertion status of this class from the VM
3647     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3648 
3649     /**
3650      * Returns true if and only if this class was declared as an enum in the
3651      * source code.
3652      *
3653      * Note that {@link java.lang.Enum} is not itself an enum type.
3654      *
3655      * Also note that if an enum constant is declared with a class body,
3656      * the class of that enum constant object is an anonymous class
3657      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The
3658      * {@link Enum#getDeclaringClass} method of an enum constant can
3659      * be used to get the class of the enum type declaring the
3660      * constant.
3661      *
3662      * @return true if and only if this class was declared as an enum in the
3663      *     source code
3664      * @since 1.5
3665      * @jls 8.9.1 Enum Constants
3666      */
3667     public boolean isEnum() {
3668         // An enum must both directly extend java.lang.Enum and have
3669         // the ENUM bit set; classes for specialized enum constants
3670         // don&#39;t do the former.
3671         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3672         this.getSuperclass() == java.lang.Enum.class;
3673     }
3674 
3675     /** java.lang.Record.class */
3676     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();
3677     private static Class&lt;?&gt; javaLangRecordClass() {
3678         try {
3679             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);
3680         } catch (ClassNotFoundException e) {
3681             throw new InternalError(&quot;should not reach here&quot;, e);
3682         }
3683     }
3684 
3685     /**
3686      * {@preview Associated with records, a preview feature of the Java language.
3687      *
3688      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
3689      *           feature of the Java language. Preview features
3690      *           may be removed in a future release, or upgraded to permanent
3691      *           features of the Java language.}
3692      *
3693      * Returns {@code true} if and only if this class is a record class.
3694      *
3695      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record
3696      * class is {@code java.lang.Record}. A record class has (possibly zero)
3697      * record components, that is, {@link #getRecordComponents()} returns a
3698      * non-null value.
3699      *
3700      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking
3701      * this method on class {@code Record} returns {@code false}.
3702      *
3703      * @return true if and only if this class is a record class, otherwise false
3704      * @jls 8.10 Record Types
3705      * @since 14
3706      */
3707     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
3708                                  essentialAPI=false)
3709     public boolean isRecord() {
3710         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3711     }
3712 
3713     // Fetches the factory for reflective objects
3714     private static ReflectionFactory getReflectionFactory() {
3715         if (reflectionFactory == null) {
3716             reflectionFactory =
3717                 java.security.AccessController.doPrivileged
3718                     (new ReflectionFactory.GetReflectionFactoryAction());
3719         }
3720         return reflectionFactory;
3721     }
3722     private static ReflectionFactory reflectionFactory;
3723 
3724     /**
3725      * Returns the elements of this enum class or null if this
3726      * Class object does not represent an enum type.
3727      *
3728      * @return an array containing the values comprising the enum class
3729      *     represented by this {@code Class} object in the order they&#39;re
3730      *     declared, or null if this {@code Class} object does not
3731      *     represent an enum type
3732      * @since 1.5
3733      */
3734     public T[] getEnumConstants() {
3735         T[] values = getEnumConstantsShared();
3736         return (values != null) ? values.clone() : null;
3737     }
3738 
3739     /**
3740      * Returns the elements of this enum class or null if this
3741      * Class object does not represent an enum type;
3742      * identical to getEnumConstants except that the result is
3743      * uncloned, cached, and shared by all callers.
3744      */
3745     T[] getEnumConstantsShared() {
3746         T[] constants = enumConstants;
3747         if (constants == null) {
3748             if (!isEnum()) return null;
3749             try {
3750                 final Method values = getMethod(&quot;values&quot;);
3751                 java.security.AccessController.doPrivileged(
3752                     new java.security.PrivilegedAction&lt;&gt;() {
3753                         public Void run() {
3754                                 values.setAccessible(true);
3755                                 return null;
3756                             }
3757                         });
3758                 @SuppressWarnings(&quot;unchecked&quot;)
3759                 T[] temporaryConstants = (T[])values.invoke(null);
3760                 enumConstants = constants = temporaryConstants;
3761             }
3762             // These can happen when users concoct enum-like classes
3763             // that don&#39;t comply with the enum spec.
3764             catch (InvocationTargetException | NoSuchMethodException |
3765                    IllegalAccessException ex) { return null; }
3766         }
3767         return constants;
3768     }
3769     private transient volatile T[] enumConstants;
3770 
3771     /**
3772      * Returns a map from simple name to enum constant.  This package-private
3773      * method is used internally by Enum to implement
3774      * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
3775      * efficiently.  Note that the map is returned by this method is
3776      * created lazily on first use.  Typically it won&#39;t ever get created.
3777      */
3778     Map&lt;String, T&gt; enumConstantDirectory() {
3779         Map&lt;String, T&gt; directory = enumConstantDirectory;
3780         if (directory == null) {
3781             T[] universe = getEnumConstantsShared();
3782             if (universe == null)
3783                 throw new IllegalArgumentException(
3784                     getName() + &quot; is not an enum type&quot;);
3785             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3786             for (T constant : universe) {
3787                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3788             }
3789             enumConstantDirectory = directory;
3790         }
3791         return directory;
3792     }
3793     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3794 
3795     /**
3796      * Casts an object to the class or interface represented
3797      * by this {@code Class} object.
3798      *
3799      * @param obj the object to be cast
3800      * @return the object after casting, or null if obj is null
3801      *
3802      * @throws ClassCastException if the object is not
3803      * {@code null} and is not assignable to the type T.
<a name="20" id="anc20"></a><span class="line-modified">3804      * @throws NullPointerException if this is an {@linkplain #isInlineClass()</span>
<span class="line-modified">3805      * inline type} and the object is {@code null}</span>
3806      *
3807      * @since 1.5
3808      */
3809     @SuppressWarnings(&quot;unchecked&quot;)
3810     @HotSpotIntrinsicCandidate
3811     public T cast(Object obj) {
<a name="21" id="anc21"></a><span class="line-modified">3812         if (isInlineClass() &amp;&amp; obj == null)</span>
3813             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3814 
3815         if (obj != null &amp;&amp; !isInstance(obj))
3816             throw new ClassCastException(cannotCastMsg(obj));
3817         return (T) obj;
3818     }
3819 
3820     private String cannotCastMsg(Object obj) {
3821         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3822     }
3823 
3824     /**
3825      * Casts this {@code Class} object to represent a subclass of the class
3826      * represented by the specified class object.  Checks that the cast
3827      * is valid, and throws a {@code ClassCastException} if it is not.  If
3828      * this method succeeds, it always returns a reference to this {@code Class} object.
3829      *
3830      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3831      * a {@code Class} object to pass it to an API that restricts the
3832      * {@code Class} objects that it is willing to accept.  A cast would
3833      * generate a compile-time warning, as the correctness of the cast
3834      * could not be checked at runtime (because generic types are implemented
3835      * by erasure).
3836      *
3837      * @param &lt;U&gt; the type to cast this {@code Class} object to
3838      * @param clazz the class of the type to cast this {@code Class} object to
3839      * @return this {@code Class} object, cast to represent a subclass of
3840      *    the specified class object.
3841      * @throws ClassCastException if this {@code Class} object does not
3842      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3843      *    the class itself).
3844      * @since 1.5
3845      */
3846     @SuppressWarnings(&quot;unchecked&quot;)
3847     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3848         if (clazz.isAssignableFrom(this))
3849             return (Class&lt;? extends U&gt;) this;
3850         else
3851             throw new ClassCastException(this.toString());
3852     }
3853 
3854     /**
3855      * {@inheritDoc}
3856      * &lt;p&gt;Note that any annotation returned by this method is a
3857      * declaration annotation.
3858      *
3859      * @throws NullPointerException {@inheritDoc}
3860      * @since 1.5
3861      */
3862     @Override
3863     @SuppressWarnings(&quot;unchecked&quot;)
3864     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3865         Objects.requireNonNull(annotationClass);
3866 
3867         return (A) annotationData().annotations.get(annotationClass);
3868     }
3869 
3870     /**
3871      * {@inheritDoc}
3872      * @throws NullPointerException {@inheritDoc}
3873      * @since 1.5
3874      */
3875     @Override
3876     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
3877         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
3878     }
3879 
3880     /**
3881      * {@inheritDoc}
3882      * &lt;p&gt;Note that any annotations returned by this method are
3883      * declaration annotations.
3884      *
3885      * @throws NullPointerException {@inheritDoc}
3886      * @since 1.8
3887      */
3888     @Override
3889     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
3890         Objects.requireNonNull(annotationClass);
3891 
3892         AnnotationData annotationData = annotationData();
3893         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
3894                                                           this,
3895                                                           annotationClass);
3896     }
3897 
3898     /**
3899      * {@inheritDoc}
3900      * &lt;p&gt;Note that any annotations returned by this method are
3901      * declaration annotations.
3902      *
3903      * @since 1.5
3904      */
3905     @Override
3906     public Annotation[] getAnnotations() {
3907         return AnnotationParser.toArray(annotationData().annotations);
3908     }
3909 
3910     /**
3911      * {@inheritDoc}
3912      * &lt;p&gt;Note that any annotation returned by this method is a
3913      * declaration annotation.
3914      *
3915      * @throws NullPointerException {@inheritDoc}
3916      * @since 1.8
3917      */
3918     @Override
3919     @SuppressWarnings(&quot;unchecked&quot;)
3920     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
3921         Objects.requireNonNull(annotationClass);
3922 
3923         return (A) annotationData().declaredAnnotations.get(annotationClass);
3924     }
3925 
3926     /**
3927      * {@inheritDoc}
3928      * &lt;p&gt;Note that any annotations returned by this method are
3929      * declaration annotations.
3930      *
3931      * @throws NullPointerException {@inheritDoc}
3932      * @since 1.8
3933      */
3934     @Override
3935     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
3936         Objects.requireNonNull(annotationClass);
3937 
3938         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
3939                                                                  annotationClass);
3940     }
3941 
3942     /**
3943      * {@inheritDoc}
3944      * &lt;p&gt;Note that any annotations returned by this method are
3945      * declaration annotations.
3946      *
3947      * @since 1.5
3948      */
3949     @Override
3950     public Annotation[] getDeclaredAnnotations()  {
3951         return AnnotationParser.toArray(annotationData().declaredAnnotations);
3952     }
3953 
3954     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
3955     private static class AnnotationData {
3956         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
3957         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
3958 
3959         // Value of classRedefinedCount when we created this AnnotationData instance
3960         final int redefinedCount;
3961 
3962         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
3963                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
3964                        int redefinedCount) {
3965             this.annotations = annotations;
3966             this.declaredAnnotations = declaredAnnotations;
3967             this.redefinedCount = redefinedCount;
3968         }
3969     }
3970 
3971     // Annotations cache
3972     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
3973     private transient volatile AnnotationData annotationData;
3974 
3975     private AnnotationData annotationData() {
3976         while (true) { // retry loop
3977             AnnotationData annotationData = this.annotationData;
3978             int classRedefinedCount = this.classRedefinedCount;
3979             if (annotationData != null &amp;&amp;
3980                 annotationData.redefinedCount == classRedefinedCount) {
3981                 return annotationData;
3982             }
3983             // null or stale annotationData -&gt; optimistically create new instance
3984             AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
3985             // try to install it
3986             if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {
3987                 // successfully installed new AnnotationData
3988                 return newAnnotationData;
3989             }
3990         }
3991     }
3992 
3993     private AnnotationData createAnnotationData(int classRedefinedCount) {
3994         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =
3995             AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);
3996         Class&lt;?&gt; superClass = getSuperclass();
3997         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;
3998         if (superClass != null) {
3999             Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =
4000                 superClass.annotationData().annotations;
4001             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {
4002                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
4003                 if (AnnotationType.getInstance(annotationClass).isInherited()) {
4004                     if (annotations == null) { // lazy construction
4005                         annotations = new LinkedHashMap&lt;&gt;((Math.max(
4006                                 declaredAnnotations.size(),
4007                                 Math.min(12, declaredAnnotations.size() + superAnnotations.size())
4008                             ) * 4 + 2) / 3
4009                         );
4010                     }
4011                     annotations.put(annotationClass, e.getValue());
4012                 }
4013             }
4014         }
4015         if (annotations == null) {
4016             // no inherited annotations -&gt; share the Map with declaredAnnotations
4017             annotations = declaredAnnotations;
4018         } else {
4019             // at least one inherited annotation -&gt; declared may override inherited
4020             annotations.putAll(declaredAnnotations);
4021         }
4022         return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
4023     }
4024 
4025     // Annotation types cache their internal (AnnotationType) form
4026 
4027     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4028     private transient volatile AnnotationType annotationType;
4029 
4030     boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
4031         return Atomic.casAnnotationType(this, oldType, newType);
4032     }
4033 
4034     AnnotationType getAnnotationType() {
4035         return annotationType;
4036     }
4037 
4038     Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
4039         return annotationData().declaredAnnotations;
4040     }
4041 
4042     /* Backing store of user-defined values pertaining to this class.
4043      * Maintained by the ClassValue class.
4044      */
4045     transient ClassValue.ClassValueMap classValueMap;
4046 
4047     /**
4048      * Returns an {@code AnnotatedType} object that represents the use of a
4049      * type to specify the superclass of the entity represented by this {@code
4050      * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
4051      * in &#39;...  extends Foo&#39; is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
4052      * Foo.)
4053      *
4054      * &lt;p&gt; If this {@code Class} object represents a type whose declaration
4055      * does not explicitly indicate an annotated superclass, then the return
4056      * value is an {@code AnnotatedType} object representing an element with no
4057      * annotations.
4058      *
4059      * &lt;p&gt; If this {@code Class} represents either the {@code Object} class, an
4060      * interface type, an array type, a primitive type, or void, the return
4061      * value is {@code null}.
4062      *
4063      * @return an object representing the superclass
4064      * @since 1.8
4065      */
4066     public AnnotatedType getAnnotatedSuperclass() {
4067         if (this == Object.class ||
4068                 isInterface() ||
4069                 isArray() ||
4070                 isPrimitive() ||
4071                 this == Void.TYPE) {
4072             return null;
4073         }
4074 
4075         return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);
4076     }
4077 
4078     /**
4079      * Returns an array of {@code AnnotatedType} objects that represent the use
4080      * of types to specify superinterfaces of the entity represented by this
4081      * {@code Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
4082      * superinterface in &#39;... implements Foo&#39; is distinct from the
4083      * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
4084      *
4085      * &lt;p&gt; If this {@code Class} object represents a class, the return value is
4086      * an array containing objects representing the uses of interface types to
4087      * specify interfaces implemented by the class. The order of the objects in
4088      * the array corresponds to the order of the interface types used in the
4089      * &#39;implements&#39; clause of the declaration of this {@code Class} object.
4090      *
4091      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4092      * value is an array containing objects representing the uses of interface
4093      * types to specify interfaces directly extended by the interface. The
4094      * order of the objects in the array corresponds to the order of the
4095      * interface types used in the &#39;extends&#39; clause of the declaration of this
4096      * {@code Class} object.
4097      *
4098      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4099      * declaration does not explicitly indicate any annotated superinterfaces,
4100      * the return value is an array of length 0.
4101      *
4102      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4103      * class, an array type, a primitive type, or void, the return value is an
4104      * array of length 0.
4105      *
4106      * @return an array representing the superinterfaces
4107      * @since 1.8
4108      */
4109     public AnnotatedType[] getAnnotatedInterfaces() {
4110         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
4111     }
4112 
4113     private native Class&lt;?&gt; getNestHost0();
4114 
4115     /**
4116      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4117      * or interface represented by this {@code Class} object belongs.
4118      * Every class and interface is a member of exactly one nest.
4119      * A class or interface that is not recorded as belonging to a nest
4120      * belongs to the nest consisting only of itself, and is the nest
4121      * host.
4122      *
4123      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4124      * primitive types, and {@code void} returns {@code this} to indicate
4125      * that the represented entity belongs to the nest consisting only of
4126      * itself, and is the nest host.
4127      *
4128      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing
4129      * the nest host, or if this class or interface is not enumerated as
4130      * a member of the nest by the nest host, then it is considered to belong
4131      * to its own nest and {@code this} is returned as the host.
4132      *
4133      * @apiNote A {@code class} file of version 55.0 or greater may record the
4134      * host of the nest to which it belongs by using the {@code NestHost}
4135      * attribute (JVMS {@jvms 4.7.28}). Alternatively, a {@code class} file of
4136      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
4137      * other members with the
4138      * {@code NestMembers} attribute (JVMS {@jvms 4.7.29}).
4139      * A {@code class} file of version 54.0 or lower does not use these
4140      * attributes.
4141      *
4142      * @return the nest host of this class or interface
4143      *
4144      * @throws SecurityException
4145      *         If the returned class is not the current class, and
4146      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4147      *         class loader is not the same as or an ancestor of the class
4148      *         loader for the returned class and invocation of {@link
4149      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4150      *         denies access to the package of the returned class
4151      * @since 11
4152      * @jvms 4.7.28 The {@code NestHost} Attribute
4153      * @jvms 4.7.29 The {@code NestMembers} Attribute
4154      * @jvms 5.4.4 Access Control
4155      */
4156     @CallerSensitive
4157     public Class&lt;?&gt; getNestHost() {
4158         if (isPrimitive() || isArray()) {
4159             return this;
4160         }
4161         Class&lt;?&gt; host;
4162         try {
4163             host = getNestHost0();
4164         } catch (LinkageError e) {
4165             // if we couldn&#39;t load our nest-host then we
4166             // act as-if we have no nest-host attribute
4167             return this;
4168         }
4169         // if null then nest membership validation failed, so we
4170         // act as-if we have no nest-host attribute
4171         if (host == null || host == this) {
4172             return this;
4173         }
4174         // returning a different class requires a security check
4175         SecurityManager sm = System.getSecurityManager();
4176         if (sm != null) {
4177             checkPackageAccess(sm,
4178                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4179         }
4180         return host;
4181     }
4182 
4183     /**
4184      * Determines if the given {@code Class} is a nestmate of the
4185      * class or interface represented by this {@code Class} object.
4186      * Two classes or interfaces are nestmates
4187      * if they have the same {@linkplain #getNestHost() nest host}.
4188      *
4189      * @param c the class to check
4190      * @return {@code true} if this class and {@code c} are members of
4191      * the same nest; and {@code false} otherwise.
4192      *
4193      * @since 11
4194      */
4195     public boolean isNestmateOf(Class&lt;?&gt; c) {
4196         if (this == c) {
4197             return true;
4198         }
4199         if (isPrimitive() || isArray() ||
4200             c.isPrimitive() || c.isArray()) {
4201             return false;
4202         }
4203         try {
4204             return getNestHost0() == c.getNestHost0();
4205         } catch (LinkageError e) {
4206             return false;
4207         }
4208     }
4209 
4210     private native Class&lt;?&gt;[] getNestMembers0();
4211 
4212     /**
4213      * Returns an array containing {@code Class} objects representing all the
4214      * classes and interfaces that are members of the nest to which the class
4215      * or interface represented by this {@code Class} object belongs.
4216      * The {@linkplain #getNestHost() nest host} of that nest is the zeroth
4217      * element of the array. Subsequent elements represent any classes or
4218      * interfaces that are recorded by the nest host as being members of
4219      * the nest; the order of such elements is unspecified. Duplicates are
4220      * permitted.
4221      * If the nest host of that nest does not enumerate any members, then the
4222      * array has a single element containing {@code this}.
4223      *
4224      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4225      * primitive types, and {@code void} returns an array containing only
4226      * {@code this}.
4227      *
4228      * &lt;p&gt;This method validates that, for each class or interface which is
4229      * recorded as a member of the nest by the nest host, that class or
4230      * interface records itself as a member of that same nest. Any exceptions
4231      * that occur during this validation are rethrown by this method.
4232      *
4233      * @return an array of all classes and interfaces in the same nest as
4234      * this class
4235      *
4236      * @throws LinkageError
4237      *         If there is any problem loading or validating a nest member or
4238      *         its nest host
4239      * @throws SecurityException
4240      *         If any returned class is not the current class, and
4241      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4242      *         class loader is not the same as or an ancestor of the class
4243      *         loader for that returned class and invocation of {@link
4244      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4245      *         denies access to the package of that returned class
4246      *
4247      * @since 11
4248      * @see #getNestHost()
4249      */
4250     @CallerSensitive
4251     public Class&lt;?&gt;[] getNestMembers() {
4252         if (isPrimitive() || isArray()) {
4253             return new Class&lt;?&gt;[] { this };
4254         }
4255         Class&lt;?&gt;[] members = getNestMembers0();
4256         // Can&#39;t actually enable this due to bootstrapping issues
4257         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4258 
4259         if (members.length &gt; 1) {
4260             // If we return anything other than the current class we need
4261             // a security check
4262             SecurityManager sm = System.getSecurityManager();
4263             if (sm != null) {
4264                 checkPackageAccess(sm,
4265                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4266             }
4267         }
4268         return members;
4269     }
4270 
4271     /**
4272      * Returns the type descriptor string for this class.
4273      * &lt;p&gt;
4274      * Note that this is not a strict inverse of {@link #forName};
4275      * distinct classes which share a common name but have different class loaders
4276      * will have identical descriptor strings.
4277      *
4278      * @return the type descriptor representation
4279      * @jvms 4.3.2 Field Descriptors
4280      * @since 12
4281      */
4282     @Override
4283     public String descriptorString() {
4284         if (isPrimitive())
4285             return Wrapper.forPrimitiveType(this).basicTypeString();
4286         else if (isArray()) {
4287             return &quot;[&quot; + componentType.descriptorString();
4288         }
4289         else {
<a name="22" id="anc22"></a><span class="line-modified">4290             return (isInlineClass() ? &quot;Q&quot; : &quot;L&quot;)</span>
<span class="line-added">4291                     + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
4292         }
4293     }
4294 
4295     /**
4296      * Returns the component type of this {@code Class}, if it describes
4297      * an array type, or {@code null} otherwise.
4298      *
4299      * @implSpec
4300      * Equivalent to {@link Class#getComponentType()}.
4301      *
4302      * @return a {@code Class} describing the component type, or {@code null}
4303      * if this {@code Class} does not describe an array type
4304      * @since 12
4305      */
4306     @Override
4307     public Class&lt;?&gt; componentType() {
4308         return isArray() ? componentType : null;
4309     }
4310 
4311     /**
4312      * Returns a {@code Class} for an array type whose component type
4313      * is described by this {@linkplain Class}.
4314      *
4315      * @return a {@code Class} describing the array type
4316      * @since 12
4317      */
4318     @Override
4319     public Class&lt;?&gt; arrayType() {
4320         return Array.newInstance(this, 0).getClass();
4321     }
4322 
4323     /**
4324      * Returns a nominal descriptor for this instance, if one can be
4325      * constructed, or an empty {@link Optional} if one cannot be.
4326      *
4327      * @return An {@link Optional} containing the resulting nominal descriptor,
4328      * or an empty {@link Optional} if one cannot be constructed.
4329      * @since 12
4330      */
4331     @Override
4332     public Optional&lt;ClassDesc&gt; describeConstable() {
4333         return Optional.of(ClassDesc.ofDescriptor(descriptorString()));
4334     }
4335 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
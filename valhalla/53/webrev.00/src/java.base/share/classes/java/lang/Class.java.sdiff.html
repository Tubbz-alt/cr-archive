<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/runtime/signature.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="invoke/DirectMethodHandle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
<span class="line-modified"> 166     private static final int VALUE_TYPE = 0x00000100;</span>
 167 
 168     private static native void registerNatives();
 169     static {
 170         registerNatives();
 171     }
 172 
 173     /*
 174      * Private constructor. Only the Java Virtual Machine creates Class objects.
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
 195      * @return a string representation of this {@code Class} object.
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
<span class="line-modified"> 200                + getName() + (isInlineClass() &amp;&amp; isIndirectType() ? &quot;?&quot; : &quot;&quot;);</span>
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * {@code @interface}, or {@code record} as appropriate), followed
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
</pre>
<hr />
<pre>
 502                 // if caller is null, Class.forName is the last java frame on the stack.
 503                 // java.base has all permissions
 504                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 505             }
 506             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 507             cl = AccessController.doPrivileged(pa);
 508         } else {
 509             cl = module.getClassLoader();
 510         }
 511 
 512         if (cl != null) {
 513             return cl.loadClass(module, name);
 514         } else {
 515             return BootLoader.loadClass(module, name);
 516         }
 517     }
 518 
 519     /**
 520      * Returns {@code true} if this class is an inline class.
 521      *
<span class="line-modified"> 522      * @return {@code true} if this class is an inline class.</span>

 523      */
 524     public boolean isInlineClass() {
<span class="line-modified"> 525         return (this.getModifiers() &amp; VALUE_TYPE) != 0;</span>
 526     }
 527 
 528     /**
<span class="line-modified"> 529      * Returns a {@code Class} object representing the primary type of</span>
<span class="line-modified"> 530      * this class.</span>
<span class="line-modified"> 531      *</span>
<span class="line-modified"> 532      * &lt;p&gt; For class {@code C}, {@code C.class} is the primary type of {@code C}.</span>
<span class="line-modified"> 533      * For a primitive type, the {@code Class} instance representing</span>
<span class="line-modified"> 534      * that primitive type is its primary type, for example {@code int.class}.</span>
<span class="line-modified"> 535      *</span>
<span class="line-modified"> 536      * @return the {@code Class} object representing the primary type of</span>
<span class="line-modified"> 537      *         this class</span>
 538      */
<span class="line-modified"> 539     @HotSpotIntrinsicCandidate</span>
<span class="line-modified"> 540     public Class&lt;T&gt; asPrimaryType() {</span>
<span class="line-removed"> 541         return isInlineClass() ? inlineType : this;</span>
 542     }
 543 
 544     /**
<span class="line-modified"> 545      * Returns a {@code Class} object representing the &lt;em&gt;indirect projection&lt;/em&gt;</span>
<span class="line-modified"> 546      * type if this class is an {@linkplain #isInlineClass() inline class};</span>
<span class="line-modified"> 547      * otherwise, returns this class.</span>
<span class="line-modified"> 548      *</span>
<span class="line-modified"> 549      * &lt;p&gt; An inline class, {@code V}, has two {@code Class} representations,</span>
<span class="line-modified"> 550      * {@code V.class} and its {@linkplain #asIndirectType() indirect projection</span>
<span class="line-modified"> 551      * type}.  The indirect projection type is always</span>
<span class="line-modified"> 552      * {@linkplain #isNullableType() nullable}.</span>
<span class="line-modified"> 553      * The indirect projection type of a zero-default inline class</span>
<span class="line-modified"> 554      * is also its nullable projection type.</span>
<span class="line-modified"> 555      *</span>
<span class="line-removed"> 556      * @return the {@code Class} object representing the indirect projection type of</span>
<span class="line-removed"> 557      *         this class if this class is an inline class; otherwise, this class.</span>
 558      */
<span class="line-modified"> 559     @HotSpotIntrinsicCandidate</span>
<span class="line-modified"> 560     public Class&lt;T&gt; asIndirectType() {</span>
<span class="line-removed"> 561         return isInlineClass() ? indirectType : this;</span>
 562     }
 563 
<span class="line-modified"> 564     /**</span>
<span class="line-modified"> 565      * Returns a {@code Class} object representing the &lt;em&gt;nullable projection&lt;/em&gt;</span>
<span class="line-modified"> 566      * type if this class is an {@linkplain #isInlineClass() inline class};</span>
<span class="line-modified"> 567      * otherwise, returns this class.</span>
<span class="line-removed"> 568      *</span>
<span class="line-removed"> 569      * &lt;p&gt; An inline class, {@code V}, has two {@code Class} representations,</span>
<span class="line-removed"> 570      * {@code V.class} and its {@linkplain #asIndirectType() indirect projection</span>
<span class="line-removed"> 571      * type}.  The indirect projection type is always</span>
<span class="line-removed"> 572      * {@linkplain #isNullableType() nullable}.</span>
<span class="line-removed"> 573      * The indirect projection type of a zero-default inline class</span>
<span class="line-removed"> 574      * is also its nullable projection type.</span>
<span class="line-removed"> 575      *</span>
<span class="line-removed"> 576      * @return the {@code Class} object representing the nullable projection type of</span>
<span class="line-removed"> 577      *         this class if this class is an inline class; otherwise, this class.</span>
<span class="line-removed"> 578      */</span>
<span class="line-removed"> 579     public Class&lt;T&gt; asNullableType() {</span>
<span class="line-removed"> 580         return asIndirectType();</span>
<span class="line-removed"> 581     }</span>
<span class="line-removed"> 582 </span>
<span class="line-removed"> 583     /**</span>
<span class="line-removed"> 584      * Returns {@code true} if this class is an indirect type.</span>
<span class="line-removed"> 585      * An indirect type is always {@linkplain #isNullableType() nullable}.</span>
<span class="line-removed"> 586      *</span>
<span class="line-removed"> 587      * @return {@code true} if this class is an indirect type.</span>
<span class="line-removed"> 588      */</span>
<span class="line-removed"> 589     public boolean isIndirectType() {</span>
<span class="line-removed"> 590         return indirectType == null || this == indirectType;</span>
 591     }
<span class="line-modified"> 592 </span>
<span class="line-modified"> 593     /**</span>
<span class="line-modified"> 594      * Returns {@code true} if this class is a nullable type.</span>
<span class="line-modified"> 595      *</span>
<span class="line-removed"> 596      * @return {@code true} if this class is a nullable type.</span>
<span class="line-removed"> 597      */</span>
<span class="line-removed"> 598     public boolean isNullableType() {</span>
<span class="line-removed"> 599         return isIndirectType();</span>
 600     }
 601 
 602     // set by VM if this class is an inline type
 603     // otherwise, these two fields are null
<span class="line-modified"> 604     private transient Class&lt;T&gt; inlineType;</span>
<span class="line-modified"> 605     private transient Class&lt;T&gt; indirectType;</span>
 606 
 607     /**
 608      * Creates a new instance of the class represented by this {@code Class}
 609      * object.  The class is instantiated as if by a {@code new}
 610      * expression with an empty argument list.  The class is initialized if it
 611      * has not already been initialized.
 612      *
 613      * @deprecated This method propagates any exception thrown by the
 614      * nullary constructor, including a checked exception.  Use of
 615      * this method effectively bypasses the compile-time exception
 616      * checking that would otherwise be performed by the compiler.
 617      * The {@link
 618      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 619      * Constructor.newInstance} method avoids this problem by wrapping
 620      * any exception thrown by the constructor in a (checked) {@link
 621      * java.lang.reflect.InvocationTargetException}.
 622      *
 623      * &lt;p&gt;The call
 624      *
 625      * &lt;pre&gt;{@code
</pre>
<hr />
<pre>
 861      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the
 862      * name returned is a {@code String} equal to the Java language
 863      * keyword corresponding to the primitive type or void.
 864      *
 865      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal
 866      * form of the name consists of the name of the element type preceded by
 867      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 868      * nesting.  The encoding of element type names is as follows:
 869      *
 870      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 871      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 872      * &lt;thead&gt;
 873      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 874      * &lt;/thead&gt;
 875      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 876      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 877      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 878      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 880      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
<span class="line-modified"> 881      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; non-nullable {@linkplain #isInlineClass() inline class}</span>
 882      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;
 883      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 885      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 886      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 887      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 888      * &lt;/tbody&gt;
 889      * &lt;/table&gt;&lt;/blockquote&gt;
 890      *
 891      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 892      * the class specified above.
 893      *
 894      * &lt;p&gt; Examples:
 895      * &lt;blockquote&gt;&lt;pre&gt;
 896      * String.class.getName()
 897      *     returns &quot;java.lang.String&quot;
 898      * byte.class.getName()
 899      *     returns &quot;byte&quot;
 900      * Point.class.getName()
 901      *     returns &quot;Point&quot;
 902      * (new Object[3]).getClass().getName()
 903      *     returns &quot;[Ljava.lang.Object;&quot;
 904      * (new Point[3]).getClass().getName()
 905      *     returns &quot;[QPoint;&quot;
<span class="line-modified"> 906      * (new Point?[3][4]).getClass().getName()</span>
<span class="line-modified"> 907      *     returns &quot;[[LPoint;&quot;</span>
 908      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 909      *     returns &quot;[[[[[[[I&quot;
 910      * &lt;/pre&gt;&lt;/blockquote&gt;
 911      *
 912      * @return  the name of the class or interface
 913      *          represented by this {@code Class} object.
 914      */
 915     public String getName() {
 916         String name = this.name;
 917         return name != null ? name : initClassName();
 918     }
 919 
 920     // Cache the name to reduce the number of calls into the VM.
 921     // This field would be set by VM itself during initClassName call.
 922     private transient String name;
 923     private native String initClassName();
 924 
 925     /**
 926      * Returns the class loader for the class.  Some implementations may use
 927      * null to represent the bootstrap class loader. This method will return
</pre>
<hr />
<pre>
1306      * by this specification.
1307      *
1308      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1309      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1310      *
1311      * @return the {@code int} representing the modifiers for this class
1312      * @see     java.lang.reflect.Modifier
1313      * @since 1.1
1314      */
1315     @HotSpotIntrinsicCandidate
1316     public native int getModifiers();
1317 
1318     /**
1319      * Gets the signers of this class.
1320      *
1321      * @return  the signers of this class, or null if there are no signers.  In
1322      *          particular, this method returns null if this {@code Class} object represents
1323      *          a primitive type or void.
1324      * @since   1.1
1325      */
<span class="line-modified">1326     public Object[] getSigners() {</span>
<span class="line-removed">1327         return asPrimaryType().getSigners0();</span>
<span class="line-removed">1328     }</span>
<span class="line-removed">1329 </span>
<span class="line-removed">1330     private native Object[] getSigners0();</span>
1331 
1332     /**
1333      * Set the signers of this class.
1334      */
<span class="line-modified">1335     void setSigners(Object[] signers) {</span>
<span class="line-removed">1336         asPrimaryType().setSigners0(signers);</span>
<span class="line-removed">1337     }</span>
<span class="line-removed">1338 </span>
<span class="line-removed">1339     native void setSigners0(Object[] signers);</span>
1340 
1341 
1342     /**
1343      * If this {@code Class} object represents a local or anonymous
1344      * class within a method, returns a {@link
1345      * java.lang.reflect.Method Method} object representing the
1346      * immediately enclosing method of the underlying class. Returns
1347      * {@code null} otherwise.
1348      *
1349      * In particular, this method returns {@code null} if the underlying
1350      * class is a local or anonymous class immediately enclosed by a type
1351      * declaration, instance initializer or static initializer.
1352      *
1353      * @return the immediately enclosing method of the underlying class, if
1354      *     that class is a local or anonymous class; otherwise {@code null}.
1355      *
1356      * @throws SecurityException
1357      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1358      *         following conditions is met:
1359      *
</pre>
<hr />
<pre>
1678      * @since 1.5
1679      */
1680     public String getSimpleName() {
1681         ReflectionData&lt;T&gt; rd = reflectionData();
1682         String simpleName = rd.simpleName;
1683         if (simpleName == null) {
1684             rd.simpleName = simpleName = getSimpleName0();
1685         }
1686         return simpleName;
1687     }
1688 
1689     private String getSimpleName0() {
1690         if (isArray()) {
1691             return getComponentType().getSimpleName() + &quot;[]&quot;;
1692         }
1693         String simpleName = getSimpleBinaryName();
1694         if (simpleName == null) { // top level class
1695             simpleName = getName();
1696             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1697         }
<span class="line-modified">1698         return isInlineClass() &amp;&amp; isIndirectType() ? simpleName + &quot;?&quot; : simpleName;</span>
1699     }
1700 
1701     /**
1702      * Return an informative string for the name of this type.
1703      *
1704      * @return an informative string for the name of this type
1705      * @since 1.8
1706      */
1707     public String getTypeName() {
1708         if (isArray()) {
1709             try {
1710                 Class&lt;?&gt; cl = this;
1711                 int dimensions = 0;
1712                 do {
1713                     dimensions++;
1714                     cl = cl.getComponentType();
1715                 } while (cl.isArray());
1716                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1717             } catch (Throwable e) { /*FALLTHRU*/ }
1718         }
<span class="line-modified">1719         return toTypeName();</span>
1720     }
1721 
1722     /**
1723      * Returns the canonical name of the underlying class as defined
1724      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section
1725      * {@jls 6.7}.  Returns null if the underlying class does not have
1726      * a canonical name (i.e., if it is a local or anonymous class or
1727      * an array whose component type does not have a canonical name).
1728      * @return the canonical name of the underlying class if it exists, and
1729      * {@code null} otherwise.
1730      * @since 1.5
1731      */
1732     public String getCanonicalName() {
1733         ReflectionData&lt;T&gt; rd = reflectionData();
1734         String canonicalName = rd.canonicalName;
1735         if (canonicalName == null) {
1736             rd.canonicalName = canonicalName = getCanonicalName0();
1737         }
1738         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1739     }
</pre>
<hr />
<pre>
3593         }
3594         return out;
3595     }
3596 
3597     private native Field[]       getDeclaredFields0(boolean publicOnly);
3598     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3599     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3600     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3601     @SuppressWarnings(&quot;preview&quot;)
3602     private native RecordComponent[] getRecordComponents0();
3603     private native boolean      isRecord0();
3604 
3605     /**
3606      * Helper method to get the method name from arguments.
3607      */
3608     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3609         return getName() + &#39;.&#39; + name +
3610                 ((argTypes == null || argTypes.length == 0) ?
3611                 &quot;()&quot; :
3612                 Arrays.stream(argTypes)
<span class="line-modified">3613                         .map(c -&gt; c == null ? &quot;null&quot; : c.toTypeName())</span>
3614                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3615     }
3616 
<span class="line-removed">3617     /*</span>
<span class="line-removed">3618      * Returns the class name appended with &quot;?&quot; if it is the nullable projection</span>
<span class="line-removed">3619      * of an inline class.</span>
<span class="line-removed">3620      */</span>
<span class="line-removed">3621     private String toTypeName() {</span>
<span class="line-removed">3622         return isInlineClass() &amp;&amp; isIndirectType() ? getName() + &quot;?&quot; : getName();</span>
<span class="line-removed">3623     }</span>
<span class="line-removed">3624 </span>
3625     /** use serialVersionUID from JDK 1.1 for interoperability */
3626     @java.io.Serial
3627     private static final long serialVersionUID = 3206093459760846163L;
3628 
3629 
3630     /**
3631      * Class Class is special cased within the Serialization Stream Protocol.
3632      *
3633      * A Class instance is written initially into an ObjectOutputStream in the
3634      * following format:
3635      * &lt;pre&gt;
3636      *      {@code TC_CLASS} ClassDescriptor
3637      *      A ClassDescriptor is a special cased serialization of
3638      *      a {@code java.io.ObjectStreamClass} instance.
3639      * &lt;/pre&gt;
3640      * A new handle is generated for the initial time the class descriptor
3641      * is written into the stream. Future references to the class descriptor
3642      * are written as references to the initial class descriptor instance.
3643      *
3644      * @see java.io.ObjectStreamClass
</pre>
<hr />
<pre>
3830                     getName() + &quot; is not an enum type&quot;);
3831             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3832             for (T constant : universe) {
3833                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3834             }
3835             enumConstantDirectory = directory;
3836         }
3837         return directory;
3838     }
3839     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3840 
3841     /**
3842      * Casts an object to the class or interface represented
3843      * by this {@code Class} object.
3844      *
3845      * @param obj the object to be cast
3846      * @return the object after casting, or null if obj is null
3847      *
3848      * @throws ClassCastException if the object is not
3849      * {@code null} and is not assignable to the type T.
<span class="line-modified">3850      * @throws NullPointerException if this is not a {@linkplain #isNullableType()</span>
<span class="line-modified">3851      * nullable type} and the object is {@code null}</span>
3852      *
3853      * @since 1.5
3854      */
3855     @SuppressWarnings(&quot;unchecked&quot;)
3856     @HotSpotIntrinsicCandidate
3857     public T cast(Object obj) {
<span class="line-modified">3858         if (!isNullableType() &amp;&amp; obj == null)</span>
3859             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3860 
3861         if (obj != null &amp;&amp; !isInstance(obj))
3862             throw new ClassCastException(cannotCastMsg(obj));
3863         return (T) obj;
3864     }
3865 
3866     private String cannotCastMsg(Object obj) {
3867         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3868     }
3869 
3870     /**
3871      * Casts this {@code Class} object to represent a subclass of the class
3872      * represented by the specified class object.  Checks that the cast
3873      * is valid, and throws a {@code ClassCastException} if it is not.  If
3874      * this method succeeds, it always returns a reference to this {@code Class} object.
3875      *
3876      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3877      * a {@code Class} object to pass it to an API that restricts the
3878      * {@code Class} objects that it is willing to accept.  A cast would
</pre>
<hr />
<pre>
4316 
4317     /**
4318      * Returns the type descriptor string for this class.
4319      * &lt;p&gt;
4320      * Note that this is not a strict inverse of {@link #forName};
4321      * distinct classes which share a common name but have different class loaders
4322      * will have identical descriptor strings.
4323      *
4324      * @return the type descriptor representation
4325      * @jvms 4.3.2 Field Descriptors
4326      * @since 12
4327      */
4328     @Override
4329     public String descriptorString() {
4330         if (isPrimitive())
4331             return Wrapper.forPrimitiveType(this).basicTypeString();
4332         else if (isArray()) {
4333             return &quot;[&quot; + componentType.descriptorString();
4334         }
4335         else {
<span class="line-modified">4336             return &quot;L&quot; + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>

4337         }
4338     }
4339 
4340     /**
4341      * Returns the component type of this {@code Class}, if it describes
4342      * an array type, or {@code null} otherwise.
4343      *
4344      * @implSpec
4345      * Equivalent to {@link Class#getComponentType()}.
4346      *
4347      * @return a {@code Class} describing the component type, or {@code null}
4348      * if this {@code Class} does not describe an array type
4349      * @since 12
4350      */
4351     @Override
4352     public Class&lt;?&gt; componentType() {
4353         return isArray() ? componentType : null;
4354     }
4355 
4356     /**
</pre>
</td>
<td>
<hr />
<pre>
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
<span class="line-modified"> 166     private static final int INLINE     = 0x00000100;</span>
 167 
 168     private static native void registerNatives();
 169     static {
 170         registerNatives();
 171     }
 172 
 173     /*
 174      * Private constructor. Only the Java Virtual Machine creates Class objects.
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
 195      * @return a string representation of this {@code Class} object.
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
<span class="line-modified"> 200                + getName();</span>
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * {@code @interface}, or {@code record} as appropriate), followed
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
</pre>
<hr />
<pre>
 502                 // if caller is null, Class.forName is the last java frame on the stack.
 503                 // java.base has all permissions
 504                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 505             }
 506             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 507             cl = AccessController.doPrivileged(pa);
 508         } else {
 509             cl = module.getClassLoader();
 510         }
 511 
 512         if (cl != null) {
 513             return cl.loadClass(module, name);
 514         } else {
 515             return BootLoader.loadClass(module, name);
 516         }
 517     }
 518 
 519     /**
 520      * Returns {@code true} if this class is an inline class.
 521      *
<span class="line-modified"> 522      * @return {@code true} if this class is an inline class</span>
<span class="line-added"> 523      * @since Valhalla</span>
 524      */
 525     public boolean isInlineClass() {
<span class="line-modified"> 526         return (this.getModifiers() &amp; INLINE) != 0;</span>
 527     }
 528 
 529     /**
<span class="line-modified"> 530      * Returns a {@code Class} object representing the &lt;em&gt;value projection&lt;/em&gt;</span>
<span class="line-modified"> 531      * type of this class if this {@code Class} is the reference projection type</span>
<span class="line-modified"> 532      * of an {@linkplain #isInlineClass() inline class}.  Otherwise an empty</span>
<span class="line-modified"> 533      * {@link Optional} is returned.</span>
<span class="line-modified"> 534      *</span>
<span class="line-modified"> 535      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-modified"> 536      *         this class if this class is the reference projection type of an</span>
<span class="line-modified"> 537      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-modified"> 538      * @since Valhalla</span>
 539      */
<span class="line-modified"> 540     public Optional&lt;Class&lt;T&gt;&gt; valueType() {</span>
<span class="line-modified"> 541         return Optional.ofNullable(valType);</span>

 542     }
 543 
 544     /**
<span class="line-modified"> 545      * Returns a {@code Class} object representing the &lt;em&gt;reference projection&lt;/em&gt;</span>
<span class="line-modified"> 546      * type of this class if this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-modified"> 547      * with a reference projection.</span>
<span class="line-modified"> 548      * If this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-modified"> 549      * without a reference projection or this class is not an inline class,</span>
<span class="line-modified"> 550      * then this method returns an empty {@link Optional}.</span>
<span class="line-modified"> 551      *</span>
<span class="line-modified"> 552      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-modified"> 553      *         this class if this class is the reference projection type of an</span>
<span class="line-modified"> 554      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-modified"> 555      * @since Valhalla</span>


 556      */
<span class="line-modified"> 557     public Optional&lt;Class&lt;T&gt;&gt; referenceType() {</span>
<span class="line-modified"> 558         return valType != null ? Optional.ofNullable(refType) : Optional.of(this);</span>

 559     }
 560 
<span class="line-modified"> 561     // TO BE REMOVED together with the C2 intrinsic implementation</span>
<span class="line-modified"> 562     @HotSpotIntrinsicCandidate</span>
<span class="line-modified"> 563     private Class&lt;T&gt; asPrimaryType() {</span>
<span class="line-modified"> 564         return valType == null ? this : valType;</span>























 565     }
<span class="line-modified"> 566     // TO BE REMOVED together with the C2 intrinsic implementation</span>
<span class="line-modified"> 567     @HotSpotIntrinsicCandidate</span>
<span class="line-modified"> 568     private Class&lt;T&gt; asIndirectType() {</span>
<span class="line-modified"> 569         return valType != null ? refType : this;</span>




 570     }
 571 
 572     // set by VM if this class is an inline type
 573     // otherwise, these two fields are null
<span class="line-modified"> 574     private transient Class&lt;T&gt; valType;</span>
<span class="line-modified"> 575     private transient Class&lt;T&gt; refType;</span>
 576 
 577     /**
 578      * Creates a new instance of the class represented by this {@code Class}
 579      * object.  The class is instantiated as if by a {@code new}
 580      * expression with an empty argument list.  The class is initialized if it
 581      * has not already been initialized.
 582      *
 583      * @deprecated This method propagates any exception thrown by the
 584      * nullary constructor, including a checked exception.  Use of
 585      * this method effectively bypasses the compile-time exception
 586      * checking that would otherwise be performed by the compiler.
 587      * The {@link
 588      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 589      * Constructor.newInstance} method avoids this problem by wrapping
 590      * any exception thrown by the constructor in a (checked) {@link
 591      * java.lang.reflect.InvocationTargetException}.
 592      *
 593      * &lt;p&gt;The call
 594      *
 595      * &lt;pre&gt;{@code
</pre>
<hr />
<pre>
 831      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the
 832      * name returned is a {@code String} equal to the Java language
 833      * keyword corresponding to the primitive type or void.
 834      *
 835      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal
 836      * form of the name consists of the name of the element type preceded by
 837      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 838      * nesting.  The encoding of element type names is as follows:
 839      *
 840      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 841      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 842      * &lt;thead&gt;
 843      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 844      * &lt;/thead&gt;
 845      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 846      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 847      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 848      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 849      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 850      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
<span class="line-modified"> 851      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class}</span>
 852      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;
 853      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 854      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 855      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 856      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 857      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 858      * &lt;/tbody&gt;
 859      * &lt;/table&gt;&lt;/blockquote&gt;
 860      *
 861      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 862      * the class specified above.
 863      *
 864      * &lt;p&gt; Examples:
 865      * &lt;blockquote&gt;&lt;pre&gt;
 866      * String.class.getName()
 867      *     returns &quot;java.lang.String&quot;
 868      * byte.class.getName()
 869      *     returns &quot;byte&quot;
 870      * Point.class.getName()
 871      *     returns &quot;Point&quot;
 872      * (new Object[3]).getClass().getName()
 873      *     returns &quot;[Ljava.lang.Object;&quot;
 874      * (new Point[3]).getClass().getName()
 875      *     returns &quot;[QPoint;&quot;
<span class="line-modified"> 876      * (new Point.ref[3][4]).getClass().getName()</span>
<span class="line-modified"> 877      *     returns &quot;[[LPoint$ref;&quot;</span>
 878      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 879      *     returns &quot;[[[[[[[I&quot;
 880      * &lt;/pre&gt;&lt;/blockquote&gt;
 881      *
 882      * @return  the name of the class or interface
 883      *          represented by this {@code Class} object.
 884      */
 885     public String getName() {
 886         String name = this.name;
 887         return name != null ? name : initClassName();
 888     }
 889 
 890     // Cache the name to reduce the number of calls into the VM.
 891     // This field would be set by VM itself during initClassName call.
 892     private transient String name;
 893     private native String initClassName();
 894 
 895     /**
 896      * Returns the class loader for the class.  Some implementations may use
 897      * null to represent the bootstrap class loader. This method will return
</pre>
<hr />
<pre>
1276      * by this specification.
1277      *
1278      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1279      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1280      *
1281      * @return the {@code int} representing the modifiers for this class
1282      * @see     java.lang.reflect.Modifier
1283      * @since 1.1
1284      */
1285     @HotSpotIntrinsicCandidate
1286     public native int getModifiers();
1287 
1288     /**
1289      * Gets the signers of this class.
1290      *
1291      * @return  the signers of this class, or null if there are no signers.  In
1292      *          particular, this method returns null if this {@code Class} object represents
1293      *          a primitive type or void.
1294      * @since   1.1
1295      */
<span class="line-modified">1296     public native Object[] getSigners();</span>




1297 
1298     /**
1299      * Set the signers of this class.
1300      */
<span class="line-modified">1301     native void setSigners(Object[] signers);</span>




1302 
1303 
1304     /**
1305      * If this {@code Class} object represents a local or anonymous
1306      * class within a method, returns a {@link
1307      * java.lang.reflect.Method Method} object representing the
1308      * immediately enclosing method of the underlying class. Returns
1309      * {@code null} otherwise.
1310      *
1311      * In particular, this method returns {@code null} if the underlying
1312      * class is a local or anonymous class immediately enclosed by a type
1313      * declaration, instance initializer or static initializer.
1314      *
1315      * @return the immediately enclosing method of the underlying class, if
1316      *     that class is a local or anonymous class; otherwise {@code null}.
1317      *
1318      * @throws SecurityException
1319      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1320      *         following conditions is met:
1321      *
</pre>
<hr />
<pre>
1640      * @since 1.5
1641      */
1642     public String getSimpleName() {
1643         ReflectionData&lt;T&gt; rd = reflectionData();
1644         String simpleName = rd.simpleName;
1645         if (simpleName == null) {
1646             rd.simpleName = simpleName = getSimpleName0();
1647         }
1648         return simpleName;
1649     }
1650 
1651     private String getSimpleName0() {
1652         if (isArray()) {
1653             return getComponentType().getSimpleName() + &quot;[]&quot;;
1654         }
1655         String simpleName = getSimpleBinaryName();
1656         if (simpleName == null) { // top level class
1657             simpleName = getName();
1658             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1659         }
<span class="line-modified">1660         return simpleName;</span>
1661     }
1662 
1663     /**
1664      * Return an informative string for the name of this type.
1665      *
1666      * @return an informative string for the name of this type
1667      * @since 1.8
1668      */
1669     public String getTypeName() {
1670         if (isArray()) {
1671             try {
1672                 Class&lt;?&gt; cl = this;
1673                 int dimensions = 0;
1674                 do {
1675                     dimensions++;
1676                     cl = cl.getComponentType();
1677                 } while (cl.isArray());
1678                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1679             } catch (Throwable e) { /*FALLTHRU*/ }
1680         }
<span class="line-modified">1681         return getName();</span>
1682     }
1683 
1684     /**
1685      * Returns the canonical name of the underlying class as defined
1686      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section
1687      * {@jls 6.7}.  Returns null if the underlying class does not have
1688      * a canonical name (i.e., if it is a local or anonymous class or
1689      * an array whose component type does not have a canonical name).
1690      * @return the canonical name of the underlying class if it exists, and
1691      * {@code null} otherwise.
1692      * @since 1.5
1693      */
1694     public String getCanonicalName() {
1695         ReflectionData&lt;T&gt; rd = reflectionData();
1696         String canonicalName = rd.canonicalName;
1697         if (canonicalName == null) {
1698             rd.canonicalName = canonicalName = getCanonicalName0();
1699         }
1700         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1701     }
</pre>
<hr />
<pre>
3555         }
3556         return out;
3557     }
3558 
3559     private native Field[]       getDeclaredFields0(boolean publicOnly);
3560     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3561     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3562     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3563     @SuppressWarnings(&quot;preview&quot;)
3564     private native RecordComponent[] getRecordComponents0();
3565     private native boolean      isRecord0();
3566 
3567     /**
3568      * Helper method to get the method name from arguments.
3569      */
3570     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3571         return getName() + &#39;.&#39; + name +
3572                 ((argTypes == null || argTypes.length == 0) ?
3573                 &quot;()&quot; :
3574                 Arrays.stream(argTypes)
<span class="line-modified">3575                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())</span>
3576                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3577     }
3578 








3579     /** use serialVersionUID from JDK 1.1 for interoperability */
3580     @java.io.Serial
3581     private static final long serialVersionUID = 3206093459760846163L;
3582 
3583 
3584     /**
3585      * Class Class is special cased within the Serialization Stream Protocol.
3586      *
3587      * A Class instance is written initially into an ObjectOutputStream in the
3588      * following format:
3589      * &lt;pre&gt;
3590      *      {@code TC_CLASS} ClassDescriptor
3591      *      A ClassDescriptor is a special cased serialization of
3592      *      a {@code java.io.ObjectStreamClass} instance.
3593      * &lt;/pre&gt;
3594      * A new handle is generated for the initial time the class descriptor
3595      * is written into the stream. Future references to the class descriptor
3596      * are written as references to the initial class descriptor instance.
3597      *
3598      * @see java.io.ObjectStreamClass
</pre>
<hr />
<pre>
3784                     getName() + &quot; is not an enum type&quot;);
3785             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3786             for (T constant : universe) {
3787                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3788             }
3789             enumConstantDirectory = directory;
3790         }
3791         return directory;
3792     }
3793     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3794 
3795     /**
3796      * Casts an object to the class or interface represented
3797      * by this {@code Class} object.
3798      *
3799      * @param obj the object to be cast
3800      * @return the object after casting, or null if obj is null
3801      *
3802      * @throws ClassCastException if the object is not
3803      * {@code null} and is not assignable to the type T.
<span class="line-modified">3804      * @throws NullPointerException if this is an {@linkplain #isInlineClass()</span>
<span class="line-modified">3805      * inline type} and the object is {@code null}</span>
3806      *
3807      * @since 1.5
3808      */
3809     @SuppressWarnings(&quot;unchecked&quot;)
3810     @HotSpotIntrinsicCandidate
3811     public T cast(Object obj) {
<span class="line-modified">3812         if (isInlineClass() &amp;&amp; obj == null)</span>
3813             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3814 
3815         if (obj != null &amp;&amp; !isInstance(obj))
3816             throw new ClassCastException(cannotCastMsg(obj));
3817         return (T) obj;
3818     }
3819 
3820     private String cannotCastMsg(Object obj) {
3821         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3822     }
3823 
3824     /**
3825      * Casts this {@code Class} object to represent a subclass of the class
3826      * represented by the specified class object.  Checks that the cast
3827      * is valid, and throws a {@code ClassCastException} if it is not.  If
3828      * this method succeeds, it always returns a reference to this {@code Class} object.
3829      *
3830      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3831      * a {@code Class} object to pass it to an API that restricts the
3832      * {@code Class} objects that it is willing to accept.  A cast would
</pre>
<hr />
<pre>
4270 
4271     /**
4272      * Returns the type descriptor string for this class.
4273      * &lt;p&gt;
4274      * Note that this is not a strict inverse of {@link #forName};
4275      * distinct classes which share a common name but have different class loaders
4276      * will have identical descriptor strings.
4277      *
4278      * @return the type descriptor representation
4279      * @jvms 4.3.2 Field Descriptors
4280      * @since 12
4281      */
4282     @Override
4283     public String descriptorString() {
4284         if (isPrimitive())
4285             return Wrapper.forPrimitiveType(this).basicTypeString();
4286         else if (isArray()) {
4287             return &quot;[&quot; + componentType.descriptorString();
4288         }
4289         else {
<span class="line-modified">4290             return (isInlineClass() ? &quot;Q&quot; : &quot;L&quot;)</span>
<span class="line-added">4291                     + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
4292         }
4293     }
4294 
4295     /**
4296      * Returns the component type of this {@code Class}, if it describes
4297      * an array type, or {@code null} otherwise.
4298      *
4299      * @implSpec
4300      * Equivalent to {@link Class#getComponentType()}.
4301      *
4302      * @return a {@code Class} describing the component type, or {@code null}
4303      * if this {@code Class} does not describe an array type
4304      * @since 12
4305      */
4306     @Override
4307     public Class&lt;?&gt; componentType() {
4308         return isArray() ? componentType : null;
4309     }
4310 
4311     /**
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../hotspot/share/runtime/signature.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="invoke/DirectMethodHandle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/X-VarHandle.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.lang.invoke;
  26 
  27 import jdk.internal.util.Preconditions;
  28 import jdk.internal.vm.annotation.ForceInline;
  29 
  30 import java.lang.invoke.VarHandle.VarHandleDesc;
  31 import java.util.Objects;
  32 import java.util.Optional;
  33 
  34 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  35 
  36 #warn
  37 
  38 final class VarHandle$Type$s {
  39 
  40     static class FieldInstanceReadOnly extends VarHandle {
  41         final long fieldOffset;
  42         final Class&lt;?&gt; receiverType;
  43 #if[Object]
  44         final Class&lt;?&gt; fieldType;
  45 #end[Object]
  46 
  47         FieldInstanceReadOnly(Class&lt;?&gt; receiverType, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
  48             this(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadOnly.FORM);
  49         }
  50 
  51         protected FieldInstanceReadOnly(Class&lt;?&gt; receiverType, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType},
  52                                         VarForm form) {
  53             super(form);
  54             this.fieldOffset = fieldOffset;
  55             this.receiverType = receiverType;
  56 #if[Object]
  57             this.fieldType = fieldType;
  58 #end[Object]
  59         }
  60 
  61         @Override
  62         final MethodType accessModeTypeUncached(AccessMode accessMode) {
  63             return accessMode.at.accessModeType(receiverType, {#if[Object]?fieldType:$type$.class});
  64         }
  65 
  66         @Override
  67         public Optional&lt;VarHandleDesc&gt; describeConstable() {
  68             var receiverTypeRef = receiverType.describeConstable();
  69             var fieldTypeRef = {#if[Object]?fieldType:$type$.class}.describeConstable();
  70             if (!receiverTypeRef.isPresent() || !fieldTypeRef.isPresent())
  71                 return Optional.empty();
  72 
  73             // Reflect on this VarHandle to extract the field name
  74             String name = VarHandles.getFieldFromReceiverAndOffset(
  75                 receiverType, fieldOffset, {#if[Object]?fieldType:$type$.class}).getName();
  76             return Optional.of(VarHandleDesc.ofField(receiverTypeRef.get(), name, fieldTypeRef.get()));
  77         }
  78 
  79         @ForceInline
  80         static $type$ get(FieldInstanceReadOnly handle, Object holder) {
  81             return UNSAFE.get$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
  82                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  83         }
  84 
  85         @ForceInline
  86         static $type$ getVolatile(FieldInstanceReadOnly handle, Object holder) {
  87             return UNSAFE.get$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),
  88                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  89         }
  90 
  91         @ForceInline
  92         static $type$ getOpaque(FieldInstanceReadOnly handle, Object holder) {
  93             return UNSAFE.get$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),
  94                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  95         }
  96 
  97         @ForceInline
  98         static $type$ getAcquire(FieldInstanceReadOnly handle, Object holder) {
  99             return UNSAFE.get$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 100                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 101         }
 102 
 103         static final VarForm FORM = new VarForm(FieldInstanceReadOnly.class, Object.class, $type$.class);
 104     }
 105 
 106     static final class FieldInstanceReadWrite extends FieldInstanceReadOnly {
 107         FieldInstanceReadWrite(Class&lt;?&gt; receiverType, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 108             super(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadWrite.FORM);
 109         }
 110 
 111 #if[Object]
 112         @ForceInline
 113         static Object checkCast(FieldInstanceReadWrite handle, $type$ value) {
 114             if (!handle.fieldType.isNullableType())
 115                 Objects.requireNonNull(value);
 116             return handle.fieldType.cast(value);
 117         }
 118 #end[Object]
 119 
 120         @ForceInline
 121         static void set(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 122             UNSAFE.put$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 123                              handle.fieldOffset{#if[Value]?, handle.fieldType},
 124                              {#if[Object]?checkCast(handle, value):value});
 125         }
 126 
 127         @ForceInline
 128         static void setVolatile(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 129             UNSAFE.put$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),
 130                                      handle.fieldOffset{#if[Value]?, handle.fieldType},
 131                                      {#if[Object]?checkCast(handle, value):value});
 132         }
 133 
 134         @ForceInline
 135         static void setOpaque(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 136             UNSAFE.put$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),
 137                                    handle.fieldOffset{#if[Value]?, handle.fieldType},
 138                                    {#if[Object]?checkCast(handle, value):value});
 139         }
 140 
 141         @ForceInline
 142         static void setRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 143             UNSAFE.put$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 144                                     handle.fieldOffset{#if[Value]?, handle.fieldType},
 145                                     {#if[Object]?checkCast(handle, value):value});
 146         }
 147 #if[CAS]
 148 
 149         @ForceInline
 150         static boolean compareAndSet(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {
 151             return UNSAFE.compareAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 152                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 153                                                {#if[Object]?checkCast(handle, expected):expected},
 154                                                {#if[Object]?checkCast(handle, value):value});
 155         }
 156 
 157         @ForceInline
 158         static $type$ compareAndExchange(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {
 159             return UNSAFE.compareAndExchange$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 160                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 161                                                {#if[Object]?checkCast(handle, expected):expected},
 162                                                {#if[Object]?checkCast(handle, value):value});
 163         }
 164 
 165         @ForceInline
 166         static $type$ compareAndExchangeAcquire(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {
 167             return UNSAFE.compareAndExchange$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 168                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 169                                                {#if[Object]?checkCast(handle, expected):expected},
 170                                                {#if[Object]?checkCast(handle, value):value});
 171         }
 172 
 173         @ForceInline
 174         static $type$ compareAndExchangeRelease(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {
 175             return UNSAFE.compareAndExchange$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 176                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 177                                                {#if[Object]?checkCast(handle, expected):expected},
 178                                                {#if[Object]?checkCast(handle, value):value});
 179         }
 180 
 181         @ForceInline
 182         static boolean weakCompareAndSetPlain(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {
 183             return UNSAFE.weakCompareAndSet$Type$Plain(Objects.requireNonNull(handle.receiverType.cast(holder)),
 184                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 185                                                {#if[Object]?checkCast(handle, expected):expected},
 186                                                {#if[Object]?checkCast(handle, value):value});
 187         }
 188 
 189         @ForceInline
 190         static boolean weakCompareAndSet(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {
 191             return UNSAFE.weakCompareAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 192                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 193                                                {#if[Object]?checkCast(handle, expected):expected},
 194                                                {#if[Object]?checkCast(handle, value):value});
 195         }
 196 
 197         @ForceInline
 198         static boolean weakCompareAndSetAcquire(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {
 199             return UNSAFE.weakCompareAndSet$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 200                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 201                                                {#if[Object]?checkCast(handle, expected):expected},
 202                                                {#if[Object]?checkCast(handle, value):value});
 203         }
 204 
 205         @ForceInline
 206         static boolean weakCompareAndSetRelease(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {
 207             return UNSAFE.weakCompareAndSet$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 208                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 209                                                {#if[Object]?checkCast(handle, expected):expected},
 210                                                {#if[Object]?checkCast(handle, value):value});
 211         }
 212 
 213         @ForceInline
 214         static $type$ getAndSet(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 215             return UNSAFE.getAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 216                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 217                                           {#if[Object]?checkCast(handle, value):value});
 218         }
 219 
 220         @ForceInline
 221         static $type$ getAndSetAcquire(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 222             return UNSAFE.getAndSet$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 223                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 224                                           {#if[Object]?checkCast(handle, value):value});
 225         }
 226 
 227         @ForceInline
 228         static $type$ getAndSetRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 229             return UNSAFE.getAndSet$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 230                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 231                                           {#if[Object]?checkCast(handle, value):value});
 232         }
 233 #end[CAS]
 234 #if[AtomicAdd]
 235 
 236         @ForceInline
 237         static $type$ getAndAdd(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 238             return UNSAFE.getAndAdd$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 239                                        handle.fieldOffset,
 240                                        value);
 241         }
 242 
 243         @ForceInline
 244         static $type$ getAndAddAcquire(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 245             return UNSAFE.getAndAdd$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 246                                        handle.fieldOffset,
 247                                        value);
 248         }
 249 
 250         @ForceInline
 251         static $type$ getAndAddRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 252             return UNSAFE.getAndAdd$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 253                                        handle.fieldOffset,
 254                                        value);
 255         }
 256 
 257 #end[AtomicAdd]
 258 #if[Bitwise]
 259 
 260         @ForceInline
 261         static $type$ getAndBitwiseOr(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 262             return UNSAFE.getAndBitwiseOr$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 263                                        handle.fieldOffset,
 264                                        value);
 265         }
 266 
 267         @ForceInline
 268         static $type$ getAndBitwiseOrRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 269             return UNSAFE.getAndBitwiseOr$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 270                                        handle.fieldOffset,
 271                                        value);
 272         }
 273 
 274         @ForceInline
 275         static $type$ getAndBitwiseOrAcquire(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 276             return UNSAFE.getAndBitwiseOr$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 277                                        handle.fieldOffset,
 278                                        value);
 279         }
 280 
 281         @ForceInline
 282         static $type$ getAndBitwiseAnd(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 283             return UNSAFE.getAndBitwiseAnd$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 284                                        handle.fieldOffset,
 285                                        value);
 286         }
 287 
 288         @ForceInline
 289         static $type$ getAndBitwiseAndRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 290             return UNSAFE.getAndBitwiseAnd$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 291                                        handle.fieldOffset,
 292                                        value);
 293         }
 294 
 295         @ForceInline
 296         static $type$ getAndBitwiseAndAcquire(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 297             return UNSAFE.getAndBitwiseAnd$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 298                                        handle.fieldOffset,
 299                                        value);
 300         }
 301 
 302         @ForceInline
 303         static $type$ getAndBitwiseXor(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 304             return UNSAFE.getAndBitwiseXor$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 305                                        handle.fieldOffset,
 306                                        value);
 307         }
 308 
 309         @ForceInline
 310         static $type$ getAndBitwiseXorRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 311             return UNSAFE.getAndBitwiseXor$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 312                                        handle.fieldOffset,
 313                                        value);
 314         }
 315 
 316         @ForceInline
 317         static $type$ getAndBitwiseXorAcquire(FieldInstanceReadWrite handle, Object holder, $type$ value) {
 318             return UNSAFE.getAndBitwiseXor$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 319                                        handle.fieldOffset,
 320                                        value);
 321         }
 322 #end[Bitwise]
 323 
 324         static final VarForm FORM = new VarForm(FieldInstanceReadWrite.class, Object.class, $type$.class);
 325     }
 326 
 327 
 328     static class FieldStaticReadOnly extends VarHandle {
 329         final Object base;
 330         final long fieldOffset;
 331 #if[Object]
 332         final Class&lt;?&gt; fieldType;
 333 #end[Object]
 334 
 335         FieldStaticReadOnly(Object base, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 336             this(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM);
 337         }
 338 
 339         protected FieldStaticReadOnly(Object base, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType},
 340                                       VarForm form) {
 341             super(form);
 342             this.base = base;
 343             this.fieldOffset = fieldOffset;
 344 #if[Object]
 345             this.fieldType = fieldType;
 346 #end[Object]
 347         }
 348 
 349         @Override
 350         public Optional&lt;VarHandleDesc&gt; describeConstable() {
 351             var fieldTypeRef = {#if[Object]?fieldType:$type$.class}.describeConstable();
 352             if (!fieldTypeRef.isPresent())
 353                 return Optional.empty();
 354 
 355             // Reflect on this VarHandle to extract the field name
 356             var staticField = VarHandles.getStaticFieldFromBaseAndOffset(
 357                 base, fieldOffset, {#if[Object]?fieldType:$type$.class});
 358             var receiverTypeRef = staticField.getDeclaringClass().describeConstable();
 359             if (!receiverTypeRef.isPresent())
 360                 return Optional.empty();
 361             return Optional.of(VarHandleDesc.ofStaticField(receiverTypeRef.get(), staticField.getName(), fieldTypeRef.get()));
 362         }
 363 
 364         @Override
 365         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 366             return accessMode.at.accessModeType(null, {#if[Object]?fieldType:$type$.class});
 367         }
 368 
 369         @ForceInline
 370         static $type$ get(FieldStaticReadOnly handle) {
 371             return UNSAFE.get$Type$(handle.base,
 372                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 373         }
 374 
 375         @ForceInline
 376         static $type$ getVolatile(FieldStaticReadOnly handle) {
 377             return UNSAFE.get$Type$Volatile(handle.base,
 378                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 379         }
 380 
 381         @ForceInline
 382         static $type$ getOpaque(FieldStaticReadOnly handle) {
 383             return UNSAFE.get$Type$Opaque(handle.base,
 384                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 385         }
 386 
 387         @ForceInline
 388         static $type$ getAcquire(FieldStaticReadOnly handle) {
 389             return UNSAFE.get$Type$Acquire(handle.base,
 390                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 391         }
 392 
 393         static final VarForm FORM = new VarForm(FieldStaticReadOnly.class, null, $type$.class);
 394     }
 395 
 396     static final class FieldStaticReadWrite extends FieldStaticReadOnly {
 397         FieldStaticReadWrite(Object base, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 398             super(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM);
 399         }
 400 
 401 #if[Object]
 402         static Object checkCast(FieldStaticReadWrite handle, $type$ value) {
 403             if (!handle.fieldType.isNullableType())
 404                 Objects.requireNonNull(value);
 405             return handle.fieldType.cast(value);
 406         }
 407 #end[Object]
 408 
 409         @ForceInline
 410         static void set(FieldStaticReadWrite handle, $type$ value) {
 411             UNSAFE.put$Type$(handle.base,
 412                              handle.fieldOffset{#if[Value]?, handle.fieldType},
 413                              {#if[Object]?checkCast(handle, value):value});
 414         }
 415 
 416         @ForceInline
 417         static void setVolatile(FieldStaticReadWrite handle, $type$ value) {
 418             UNSAFE.put$Type$Volatile(handle.base,
 419                                      handle.fieldOffset{#if[Value]?, handle.fieldType},
 420                                      {#if[Object]?checkCast(handle, value):value});
 421         }
 422 
 423         @ForceInline
 424         static void setOpaque(FieldStaticReadWrite handle, $type$ value) {
 425             UNSAFE.put$Type$Opaque(handle.base,
 426                                    handle.fieldOffset{#if[Value]?, handle.fieldType},
 427                                    {#if[Object]?checkCast(handle, value):value});
 428         }
 429 
 430         @ForceInline
 431         static void setRelease(FieldStaticReadWrite handle, $type$ value) {
 432             UNSAFE.put$Type$Release(handle.base,
 433                                     handle.fieldOffset{#if[Value]?, handle.fieldType},
 434                                     {#if[Object]?checkCast(handle, value):value});
 435         }
 436 #if[CAS]
 437 
 438         @ForceInline
 439         static boolean compareAndSet(FieldStaticReadWrite handle, $type$ expected, $type$ value) {
 440             return UNSAFE.compareAndSet$Type$(handle.base,
 441                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 442                                                {#if[Object]?checkCast(handle, expected):expected},
 443                                                {#if[Object]?checkCast(handle, value):value});
 444         }
 445 
 446 
 447         @ForceInline
 448         static $type$ compareAndExchange(FieldStaticReadWrite handle, $type$ expected, $type$ value) {
 449             return UNSAFE.compareAndExchange$Type$(handle.base,
 450                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 451                                                {#if[Object]?checkCast(handle, expected):expected},
 452                                                {#if[Object]?checkCast(handle, value):value});
 453         }
 454 
 455         @ForceInline
 456         static $type$ compareAndExchangeAcquire(FieldStaticReadWrite handle, $type$ expected, $type$ value) {
 457             return UNSAFE.compareAndExchange$Type$Acquire(handle.base,
 458                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 459                                                {#if[Object]?checkCast(handle, expected):expected},
 460                                                {#if[Object]?checkCast(handle, value):value});
 461         }
 462 
 463         @ForceInline
 464         static $type$ compareAndExchangeRelease(FieldStaticReadWrite handle, $type$ expected, $type$ value) {
 465             return UNSAFE.compareAndExchange$Type$Release(handle.base,
 466                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 467                                                {#if[Object]?checkCast(handle, expected):expected},
 468                                                {#if[Object]?checkCast(handle, value):value});
 469         }
 470 
 471         @ForceInline
 472         static boolean weakCompareAndSetPlain(FieldStaticReadWrite handle, $type$ expected, $type$ value) {
 473             return UNSAFE.weakCompareAndSet$Type$Plain(handle.base,
 474                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 475                                                {#if[Object]?checkCast(handle, expected):expected},
 476                                                {#if[Object]?checkCast(handle, value):value});
 477         }
 478 
 479         @ForceInline
 480         static boolean weakCompareAndSet(FieldStaticReadWrite handle, $type$ expected, $type$ value) {
 481             return UNSAFE.weakCompareAndSet$Type$(handle.base,
 482                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 483                                                {#if[Object]?checkCast(handle, expected):expected},
 484                                                {#if[Object]?checkCast(handle, value):value});
 485         }
 486 
 487         @ForceInline
 488         static boolean weakCompareAndSetAcquire(FieldStaticReadWrite handle, $type$ expected, $type$ value) {
 489             return UNSAFE.weakCompareAndSet$Type$Acquire(handle.base,
 490                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 491                                                {#if[Object]?checkCast(handle, expected):expected},
 492                                                {#if[Object]?checkCast(handle, value):value});
 493         }
 494 
 495         @ForceInline
 496         static boolean weakCompareAndSetRelease(FieldStaticReadWrite handle, $type$ expected, $type$ value) {
 497             return UNSAFE.weakCompareAndSet$Type$Release(handle.base,
 498                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 499                                                {#if[Object]?checkCast(handle, expected):expected},
 500                                                {#if[Object]?checkCast(handle, value):value});
 501         }
 502 
 503         @ForceInline
 504         static $type$ getAndSet(FieldStaticReadWrite handle, $type$ value) {
 505             return UNSAFE.getAndSet$Type$(handle.base,
 506                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 507                                           {#if[Object]?checkCast(handle, value):value});
 508         }
 509 
 510         @ForceInline
 511         static $type$ getAndSetAcquire(FieldStaticReadWrite handle, $type$ value) {
 512             return UNSAFE.getAndSet$Type$Acquire(handle.base,
 513                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 514                                           {#if[Object]?checkCast(handle, value):value});
 515         }
 516 
 517         @ForceInline
 518         static $type$ getAndSetRelease(FieldStaticReadWrite handle, $type$ value) {
 519             return UNSAFE.getAndSet$Type$Release(handle.base,
 520                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 521                                           {#if[Object]?checkCast(handle, value):value});
 522         }
 523 #end[CAS]
 524 #if[AtomicAdd]
 525 
 526         @ForceInline
 527         static $type$ getAndAdd(FieldStaticReadWrite handle, $type$ value) {
 528             return UNSAFE.getAndAdd$Type$(handle.base,
 529                                        handle.fieldOffset,
 530                                        value);
 531         }
 532 
 533         @ForceInline
 534         static $type$ getAndAddAcquire(FieldStaticReadWrite handle, $type$ value) {
 535             return UNSAFE.getAndAdd$Type$Acquire(handle.base,
 536                                        handle.fieldOffset,
 537                                        value);
 538         }
 539 
 540         @ForceInline
 541         static $type$ getAndAddRelease(FieldStaticReadWrite handle, $type$ value) {
 542             return UNSAFE.getAndAdd$Type$Release(handle.base,
 543                                        handle.fieldOffset,
 544                                        value);
 545         }
 546 #end[AtomicAdd]
 547 #if[Bitwise]
 548 
 549         @ForceInline
 550         static $type$ getAndBitwiseOr(FieldStaticReadWrite handle, $type$ value) {
 551             return UNSAFE.getAndBitwiseOr$Type$(handle.base,
 552                                        handle.fieldOffset,
 553                                        value);
 554         }
 555 
 556         @ForceInline
 557         static $type$ getAndBitwiseOrRelease(FieldStaticReadWrite handle, $type$ value) {
 558             return UNSAFE.getAndBitwiseOr$Type$Release(handle.base,
 559                                        handle.fieldOffset,
 560                                        value);
 561         }
 562 
 563         @ForceInline
 564         static $type$ getAndBitwiseOrAcquire(FieldStaticReadWrite handle, $type$ value) {
 565             return UNSAFE.getAndBitwiseOr$Type$Acquire(handle.base,
 566                                        handle.fieldOffset,
 567                                        value);
 568         }
 569 
 570         @ForceInline
 571         static $type$ getAndBitwiseAnd(FieldStaticReadWrite handle, $type$ value) {
 572             return UNSAFE.getAndBitwiseAnd$Type$(handle.base,
 573                                        handle.fieldOffset,
 574                                        value);
 575         }
 576 
 577         @ForceInline
 578         static $type$ getAndBitwiseAndRelease(FieldStaticReadWrite handle, $type$ value) {
 579             return UNSAFE.getAndBitwiseAnd$Type$Release(handle.base,
 580                                        handle.fieldOffset,
 581                                        value);
 582         }
 583 
 584         @ForceInline
 585         static $type$ getAndBitwiseAndAcquire(FieldStaticReadWrite handle, $type$ value) {
 586             return UNSAFE.getAndBitwiseAnd$Type$Acquire(handle.base,
 587                                        handle.fieldOffset,
 588                                        value);
 589         }
 590 
 591         @ForceInline
 592         static $type$ getAndBitwiseXor(FieldStaticReadWrite handle, $type$ value) {
 593             return UNSAFE.getAndBitwiseXor$Type$(handle.base,
 594                                        handle.fieldOffset,
 595                                        value);
 596         }
 597 
 598         @ForceInline
 599         static $type$ getAndBitwiseXorRelease(FieldStaticReadWrite handle, $type$ value) {
 600             return UNSAFE.getAndBitwiseXor$Type$Release(handle.base,
 601                                        handle.fieldOffset,
 602                                        value);
 603         }
 604 
 605         @ForceInline
 606         static $type$ getAndBitwiseXorAcquire(FieldStaticReadWrite handle, $type$ value) {
 607             return UNSAFE.getAndBitwiseXor$Type$Acquire(handle.base,
 608                                        handle.fieldOffset,
 609                                        value);
 610         }
 611 #end[Bitwise]
 612 
 613         static final VarForm FORM = new VarForm(FieldStaticReadWrite.class, null, $type$.class);
 614     }
 615 
 616 #if[Reference]
 617     static VarHandle makeVarHandleValuesArray(Class&lt;?&gt; arrayClass) {
 618         Class&lt;?&gt; componentType = arrayClass.getComponentType();
 619         assert componentType.isInlineClass() &amp;&amp; UNSAFE.isFlattenedArray(arrayClass);
 620         // should cache these VarHandle for performance
 621         return VarHandles.makeArrayElementHandle(arrayClass);
 622     }
 623 #end[Reference]
 624 
 625     static final class Array extends VarHandle {
 626         final int abase;
 627         final int ashift;
 628 #if[Object]
 629         final Class&lt;{#if[Object]??:$type$[]}&gt; arrayType;
 630         final Class&lt;?&gt; componentType;
 631 #end[Object]
 632 
 633         Array(int abase, int ashift{#if[Object]?, Class&lt;?&gt; arrayType}) {
 634             super(Array.FORM);
 635             this.abase = abase;
 636             this.ashift = ashift;
 637 #if[Object]
 638             this.arrayType = {#if[Object]?arrayType:$type$[].class};
 639             this.componentType = arrayType.getComponentType();
 640 #end[Object]
 641         }
 642 
 643         @Override
 644         public Optional&lt;VarHandleDesc&gt; describeConstable() {
 645             var arrayTypeRef = {#if[Object]?arrayType:$type$[].class}.describeConstable();
 646             if (!arrayTypeRef.isPresent())
 647                 return Optional.empty();
 648 
 649             return Optional.of(VarHandleDesc.ofArray(arrayTypeRef.get()));
 650         }
 651 
 652         @Override
 653         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 654             return accessMode.at.accessModeType({#if[Object]?arrayType:$type$[].class}, {#if[Object]?arrayType.getComponentType():$type$.class}, int.class);
 655         }
 656 
 657 #if[Object]
 658         @ForceInline
 659         static Object runtimeTypeCheck(Array handle, Object[] oarray, Object value) {
 660             if (!handle.componentType.isNullableType())
 661                  Objects.requireNonNull(value);
 662 
 663             if (handle.arrayType == oarray.getClass()) {
 664                 // Fast path: static array type same as argument array type
 665                 return handle.componentType.cast(value);
 666             } else {
 667                 // Slow path: check value against argument array component type
 668                 return reflectiveTypeCheck(oarray, value);
 669             }
 670         }
 671 
 672         @ForceInline
 673         static Object reflectiveTypeCheck(Object[] oarray, Object value) {
 674             try {
 675                 return oarray.getClass().getComponentType().cast(value);
 676             } catch (ClassCastException e) {
 677                 throw new ArrayStoreException();
 678             }
 679         }
 680 #end[Object]
 681 
 682         @ForceInline
 683         static $type$ get(Array handle, Object oarray, int index) {
 684 #if[Object]
 685             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 686 #else[Object]
 687             $type$[] array = ($type$[]) oarray;
 688 #end[Object]
 689             return array[index];
 690         }
 691 
 692         @ForceInline
 693         static void set(Array handle, Object oarray, int index, $type$ value) {
 694 #if[Object]
 695             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 696 #else[Object]
 697             $type$[] array = ($type$[]) oarray;
 698 #end[Object]
 699 #if[Reference]
 700             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 701                 // for flattened array, delegate to VarHandle of the inline type array
 702                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 703                 vh.set(oarray, index, reflectiveTypeCheck(array, value));
 704                 return;
 705             }
 706 #end[Reference]
 707             array[index] = {#if[Object]?runtimeTypeCheck(handle, array, value):value};
 708         }
 709 
 710         @ForceInline
 711         static $type$ getVolatile(Array handle, Object oarray, int index) {
 712 #if[Object]
 713             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 714 #else[Object]
 715             $type$[] array = ($type$[]) oarray;
 716 #end[Object]
 717 #if[Reference]
 718             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 719                 // for flattened array, delegate to VarHandle of the inline type array
 720                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 721                 return vh.getVolatile(oarray, index);
 722             }
 723 #end[Reference]
 724             return UNSAFE.get$Type$Volatile(array,
 725                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 726         }
 727 
 728         @ForceInline
 729         static void setVolatile(Array handle, Object oarray, int index, $type$ value) {
 730 #if[Object]
 731             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 732 #else[Object]
 733             $type$[] array = ($type$[]) oarray;
 734 #end[Object]
 735 #if[Reference]
 736             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 737                 // for flattened array, delegate to VarHandle of the inline type array
 738                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 739                 vh.setVolatile(oarray, index, reflectiveTypeCheck(array, value));
 740                 return;
 741             }
 742 #end[Reference]
 743             UNSAFE.put$Type$Volatile(array,
 744                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 745                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 746         }
 747 
 748         @ForceInline
 749         static $type$ getOpaque(Array handle, Object oarray, int index) {
 750 #if[Object]
 751             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 752 #else[Object]
 753             $type$[] array = ($type$[]) oarray;
 754 #end[Object]
 755 #if[Reference]
 756             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 757                 // for flattened array, delegate to VarHandle of the inline type array
 758                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 759                 return vh.getOpaque(oarray, index);
 760             }
 761 #end[Reference]
 762             return UNSAFE.get$Type$Opaque(array,
 763                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 764         }
 765 
 766         @ForceInline
 767         static void setOpaque(Array handle, Object oarray, int index, $type$ value) {
 768 #if[Object]
 769             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 770 #else[Object]
 771             $type$[] array = ($type$[]) oarray;
 772 #end[Object]
 773 #if[Reference]
 774             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 775                 // for flattened array, delegate to VarHandle of the inline type array
 776                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 777                 vh.setOpaque(oarray, index, reflectiveTypeCheck(array, value));
 778                 return;
 779             }
 780 #end[Reference]
 781             UNSAFE.put$Type$Opaque(array,
 782                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 783                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 784         }
 785 
 786         @ForceInline
 787         static $type$ getAcquire(Array handle, Object oarray, int index) {
 788 #if[Object]
 789             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 790 #else[Object]
 791             $type$[] array = ($type$[]) oarray;
 792 #end[Object]
 793 #if[Reference]
 794             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 795                 // for flattened array, delegate to VarHandle of the inline type array
 796                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 797                 return vh.getAcquire(oarray, index);
 798             }
 799 #end[Reference]
 800             return UNSAFE.get$Type$Acquire(array,
 801                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 802         }
 803 
 804         @ForceInline
 805         static void setRelease(Array handle, Object oarray, int index, $type$ value) {
 806 #if[Object]
 807             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 808 #else[Object]
 809             $type$[] array = ($type$[]) oarray;
 810 #end[Object]
 811 #if[Reference]
 812             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 813                 // for flattened array, delegate to VarHandle of the inline type array
 814                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 815                 vh.setRelease(oarray, index, reflectiveTypeCheck(array, value));
 816                 return;
 817             }
 818 #end[Reference]
 819             UNSAFE.put$Type$Release(array,
 820                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 821                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 822         }
 823 #if[CAS]
 824 
 825         @ForceInline
 826         static boolean compareAndSet(Array handle, Object oarray, int index, $type$ expected, $type$ value) {
 827 #if[Object]
 828             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 829 #else[Object]
 830             $type$[] array = ($type$[]) oarray;
 831 #end[Object]
 832 #if[Reference]
 833             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 834                 // for flattened array, delegate to VarHandle of the inline type array
 835                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 836                 return vh.compareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));
 837             }
 838 #end[Reference]
 839             return UNSAFE.compareAndSet$Type$(array,
 840                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 841                     {#if[Object]?handle.componentType.cast(expected):expected},
 842                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 843         }
 844 
 845         @ForceInline
 846         static $type$ compareAndExchange(Array handle, Object oarray, int index, $type$ expected, $type$ value) {
 847 #if[Object]
 848             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 849 #else[Object]
 850             $type$[] array = ($type$[]) oarray;
 851 #end[Object]
 852 #if[Reference]
 853             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 854                 // for flattened array, delegate to VarHandle of the inline type array
 855                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 856                 return vh.compareAndExchange(oarray, index, expected, reflectiveTypeCheck(array, value));
 857             }
 858 #end[Reference]
 859             return UNSAFE.compareAndExchange$Type$(array,
 860                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 861                     {#if[Object]?handle.componentType.cast(expected):expected},
 862                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 863         }
 864 
 865         @ForceInline
 866         static $type$ compareAndExchangeAcquire(Array handle, Object oarray, int index, $type$ expected, $type$ value) {
 867 #if[Object]
 868             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 869 #else[Object]
 870             $type$[] array = ($type$[]) oarray;
 871 #end[Object]
 872 #if[Reference]
 873             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 874                 // for flattened array, delegate to VarHandle of the inline type array
 875                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 876                 return vh.compareAndExchangeAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));
 877             }
 878 #end[Reference]
 879             return UNSAFE.compareAndExchange$Type$Acquire(array,
 880                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 881                     {#if[Object]?handle.componentType.cast(expected):expected},
 882                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 883         }
 884 
 885         @ForceInline
 886         static $type$ compareAndExchangeRelease(Array handle, Object oarray, int index, $type$ expected, $type$ value) {
 887 #if[Object]
 888             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 889 #else[Object]
 890             $type$[] array = ($type$[]) oarray;
 891 #end[Object]
 892 #if[Reference]
 893             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 894                 // for flattened array, delegate to VarHandle of the inline type array
 895                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 896                 return vh.compareAndExchangeRelease(oarray, index, expected, reflectiveTypeCheck(array, value));
 897             }
 898 #end[Reference]
 899             return UNSAFE.compareAndExchange$Type$Release(array,
 900                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 901                     {#if[Object]?handle.componentType.cast(expected):expected},
 902                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 903         }
 904 
 905         @ForceInline
 906         static boolean weakCompareAndSetPlain(Array handle, Object oarray, int index, $type$ expected, $type$ value) {
 907 #if[Object]
 908             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 909 #else[Object]
 910             $type$[] array = ($type$[]) oarray;
 911 #end[Object]
 912 #if[Reference]
 913             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 914                 // for flattened array, delegate to VarHandle of the inline type array
 915                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 916                 return vh.weakCompareAndSetPlain(oarray, index, expected, reflectiveTypeCheck(array, value));
 917             }
 918 #end[Reference]
 919             return UNSAFE.weakCompareAndSet$Type$Plain(array,
 920                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 921                     {#if[Object]?handle.componentType.cast(expected):expected},
 922                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 923         }
 924 
 925         @ForceInline
 926         static boolean weakCompareAndSet(Array handle, Object oarray, int index, $type$ expected, $type$ value) {
 927 #if[Object]
 928             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 929 #else[Object]
 930             $type$[] array = ($type$[]) oarray;
 931 #end[Object]
 932 #if[Reference]
 933             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 934                 // for flattened array, delegate to VarHandle of the inline type array
 935                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 936                 return vh.weakCompareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));
 937             }
 938 #end[Reference]
 939             return UNSAFE.weakCompareAndSet$Type$(array,
 940                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 941                     {#if[Object]?handle.componentType.cast(expected):expected},
 942                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 943         }
 944 
 945         @ForceInline
 946         static boolean weakCompareAndSetAcquire(Array handle, Object oarray, int index, $type$ expected, $type$ value) {
 947 #if[Object]
 948             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 949 #else[Object]
 950             $type$[] array = ($type$[]) oarray;
 951 #end[Object]
 952 #if[Reference]
 953             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 954                 // for flattened array, delegate to VarHandle of the inline type array
 955                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 956                 return vh.weakCompareAndSetAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));
 957             }
 958 #end[Reference]
 959             return UNSAFE.weakCompareAndSet$Type$Acquire(array,
 960                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 961                     {#if[Object]?handle.componentType.cast(expected):expected},
 962                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 963         }
 964 
 965         @ForceInline
 966         static boolean weakCompareAndSetRelease(Array handle, Object oarray, int index, $type$ expected, $type$ value) {
 967 #if[Object]
 968             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 969 #else[Object]
 970             $type$[] array = ($type$[]) oarray;
 971 #end[Object]
 972 #if[Reference]
 973             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 974                 // for flattened array, delegate to VarHandle of the inline type array
 975                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 976                 return vh.weakCompareAndSetRelease(oarray, index, expected, reflectiveTypeCheck(array, value));
 977             }
 978 #end[Reference]
 979             return UNSAFE.weakCompareAndSet$Type$Release(array,
 980                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 981                     {#if[Object]?handle.componentType.cast(expected):expected},
 982                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 983         }
 984 
 985         @ForceInline
 986         static $type$ getAndSet(Array handle, Object oarray, int index, $type$ value) {
 987 #if[Object]
 988             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 989 #else[Object]
 990             $type$[] array = ($type$[]) oarray;
 991 #end[Object]
 992 #if[Reference]
 993             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 994                 // for flattened array, delegate to VarHandle of the inline type array
 995                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 996                 return vh.getAndSet(oarray, index, reflectiveTypeCheck(array, value));
 997             }
 998 #end[Reference]
 999             return UNSAFE.getAndSet$Type$(array,
1000                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1001                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1002         }
1003 
1004         @ForceInline
1005         static $type$ getAndSetAcquire(Array handle, Object oarray, int index, $type$ value) {
1006 #if[Object]
1007             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1008 #else[Object]
1009             $type$[] array = ($type$[]) oarray;
1010 #end[Object]
1011 #if[Reference]
1012             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1013                 // for flattened array, delegate to VarHandle of the inline type array
1014                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1015                 return vh.getAndSetAcquire(oarray, index, reflectiveTypeCheck(array, value));
1016             }
1017 #end[Reference]
1018             return UNSAFE.getAndSet$Type$Acquire(array,
1019                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1020                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1021         }
1022 
1023         @ForceInline
1024         static $type$ getAndSetRelease(Array handle, Object oarray, int index, $type$ value) {
1025 #if[Object]
1026             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1027 #else[Object]
1028             $type$[] array = ($type$[]) oarray;
1029 #end[Object]
1030 #if[Reference]
1031             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1032                 // for flattened array, delegate to VarHandle of the inline type array
1033                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1034                 return vh.getAndSetRelease(oarray, index, reflectiveTypeCheck(array, value));
1035             }
1036 #end[Reference]
1037             return UNSAFE.getAndSet$Type$Release(array,
1038                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1039                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1040         }
1041 #end[CAS]
1042 #if[AtomicAdd]
1043 
1044         @ForceInline
1045         static $type$ getAndAdd(Array handle, Object oarray, int index, $type$ value) {
1046             $type$[] array = ($type$[]) oarray;
1047             return UNSAFE.getAndAdd$Type$(array,
1048                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1049                     value);
1050         }
1051 
1052         @ForceInline
1053         static $type$ getAndAddAcquire(Array handle, Object oarray, int index, $type$ value) {
1054             $type$[] array = ($type$[]) oarray;
1055             return UNSAFE.getAndAdd$Type$Acquire(array,
1056                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1057                     value);
1058         }
1059 
1060         @ForceInline
1061         static $type$ getAndAddRelease(Array handle, Object oarray, int index, $type$ value) {
1062             $type$[] array = ($type$[]) oarray;
1063             return UNSAFE.getAndAdd$Type$Release(array,
1064                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1065                     value);
1066         }
1067 #end[AtomicAdd]
1068 #if[Bitwise]
1069 
1070         @ForceInline
1071         static $type$ getAndBitwiseOr(Array handle, Object oarray, int index, $type$ value) {
1072             $type$[] array = ($type$[]) oarray;
1073             return UNSAFE.getAndBitwiseOr$Type$(array,
1074                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1075                                        value);
1076         }
1077 
1078         @ForceInline
1079         static $type$ getAndBitwiseOrRelease(Array handle, Object oarray, int index, $type$ value) {
1080             $type$[] array = ($type$[]) oarray;
1081             return UNSAFE.getAndBitwiseOr$Type$Release(array,
1082                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1083                                        value);
1084         }
1085 
1086         @ForceInline
1087         static $type$ getAndBitwiseOrAcquire(Array handle, Object oarray, int index, $type$ value) {
1088             $type$[] array = ($type$[]) oarray;
1089             return UNSAFE.getAndBitwiseOr$Type$Acquire(array,
1090                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1091                                        value);
1092         }
1093 
1094         @ForceInline
1095         static $type$ getAndBitwiseAnd(Array handle, Object oarray, int index, $type$ value) {
1096             $type$[] array = ($type$[]) oarray;
1097             return UNSAFE.getAndBitwiseAnd$Type$(array,
1098                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1099                                        value);
1100         }
1101 
1102         @ForceInline
1103         static $type$ getAndBitwiseAndRelease(Array handle, Object oarray, int index, $type$ value) {
1104             $type$[] array = ($type$[]) oarray;
1105             return UNSAFE.getAndBitwiseAnd$Type$Release(array,
1106                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1107                                        value);
1108         }
1109 
1110         @ForceInline
1111         static $type$ getAndBitwiseAndAcquire(Array handle, Object oarray, int index, $type$ value) {
1112             $type$[] array = ($type$[]) oarray;
1113             return UNSAFE.getAndBitwiseAnd$Type$Acquire(array,
1114                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1115                                        value);
1116         }
1117 
1118         @ForceInline
1119         static $type$ getAndBitwiseXor(Array handle, Object oarray, int index, $type$ value) {
1120             $type$[] array = ($type$[]) oarray;
1121             return UNSAFE.getAndBitwiseXor$Type$(array,
1122                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1123                                        value);
1124         }
1125 
1126         @ForceInline
1127         static $type$ getAndBitwiseXorRelease(Array handle, Object oarray, int index, $type$ value) {
1128             $type$[] array = ($type$[]) oarray;
1129             return UNSAFE.getAndBitwiseXor$Type$Release(array,
1130                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1131                                        value);
1132         }
1133 
1134         @ForceInline
1135         static $type$ getAndBitwiseXorAcquire(Array handle, Object oarray, int index, $type$ value) {
1136             $type$[] array = ($type$[]) oarray;
1137             return UNSAFE.getAndBitwiseXor$Type$Acquire(array,
1138                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1139                                        value);
1140         }
1141 #end[Bitwise]
1142 
1143         static final VarForm FORM = new VarForm(Array.class, {#if[Object]?Object[].class:$type$[].class}, {#if[Object]?Object.class:$type$.class}, int.class);
1144     }
1145 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/reflect/Field.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../invoke/X-VarHandle.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Proxy.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/Field.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 761      * @param value the new value for the field of {@code obj}
 762      * being modified
 763      *
 764      * @throws    IllegalAccessException    if this {@code Field} object
 765      *              is enforcing Java language access control and the underlying
 766      *              field is either inaccessible or final.
 767      * @throws    IllegalArgumentException  if the specified object is not an
 768      *              instance of the class or interface declaring the underlying
 769      *              field (or a subclass or implementor thereof),
 770      *              or if an unwrapping conversion fails.
 771      * @throws    NullPointerException      if the specified object is null
 772      *              and the field is an instance field.
 773      * @throws    ExceptionInInitializerError if the initialization provoked
 774      *              by this method fails.
 775      */
 776     @CallerSensitive
 777     @ForceInline // to ensure Reflection.getCallerClass optimization
 778     public void set(Object obj, Object value)
 779         throws IllegalArgumentException, IllegalAccessException
 780     {
<span class="line-removed"> 781         ensureNotValueClass();</span>
<span class="line-removed"> 782 </span>
 783         if (!override) {
 784             Class&lt;?&gt; caller = Reflection.getCallerClass();
 785             checkAccess(caller, obj);
 786         }
 787         getFieldAccessor(obj).set(obj, value);
 788     }
 789 
 790     /**
 791      * Sets the value of a field as a {@code boolean} on the specified object.
 792      * This method is equivalent to
 793      * {@code set(obj, zObj)},
 794      * where {@code zObj} is a {@code Boolean} object and
 795      * {@code zObj.booleanValue() == z}.
 796      *
 797      * @param obj the object whose field should be modified
 798      * @param z   the new value for the field of {@code obj}
 799      * being modified
 800      *
 801      * @throws    IllegalAccessException    if this {@code Field} object
 802      *              is enforcing Java language access control and the underlying
 803      *              field is either inaccessible or final.
 804      * @throws    IllegalArgumentException  if the specified object is not an
 805      *              instance of the class or interface declaring the underlying
 806      *              field (or a subclass or implementor thereof),
 807      *              or if an unwrapping conversion fails.
 808      * @throws    NullPointerException      if the specified object is null
 809      *              and the field is an instance field.
 810      * @throws    ExceptionInInitializerError if the initialization provoked
 811      *              by this method fails.
 812      * @see       Field#set
 813      */
 814     @CallerSensitive
 815     @ForceInline // to ensure Reflection.getCallerClass optimization
 816     public void setBoolean(Object obj, boolean z)
 817         throws IllegalArgumentException, IllegalAccessException
 818     {
<span class="line-removed"> 819         ensureNotValueClass();</span>
<span class="line-removed"> 820 </span>
 821         if (!override) {
 822             Class&lt;?&gt; caller = Reflection.getCallerClass();
 823             checkAccess(caller, obj);
 824         }
 825         getFieldAccessor(obj).setBoolean(obj, z);
 826     }
 827 
 828     /**
 829      * Sets the value of a field as a {@code byte} on the specified object.
 830      * This method is equivalent to
 831      * {@code set(obj, bObj)},
 832      * where {@code bObj} is a {@code Byte} object and
 833      * {@code bObj.byteValue() == b}.
 834      *
 835      * @param obj the object whose field should be modified
 836      * @param b   the new value for the field of {@code obj}
 837      * being modified
 838      *
 839      * @throws    IllegalAccessException    if this {@code Field} object
 840      *              is enforcing Java language access control and the underlying
 841      *              field is either inaccessible or final.
 842      * @throws    IllegalArgumentException  if the specified object is not an
 843      *              instance of the class or interface declaring the underlying
 844      *              field (or a subclass or implementor thereof),
 845      *              or if an unwrapping conversion fails.
 846      * @throws    NullPointerException      if the specified object is null
 847      *              and the field is an instance field.
 848      * @throws    ExceptionInInitializerError if the initialization provoked
 849      *              by this method fails.
 850      * @see       Field#set
 851      */
 852     @CallerSensitive
 853     @ForceInline // to ensure Reflection.getCallerClass optimization
 854     public void setByte(Object obj, byte b)
 855         throws IllegalArgumentException, IllegalAccessException
 856     {
<span class="line-removed"> 857         ensureNotValueClass();</span>
<span class="line-removed"> 858 </span>
 859         if (!override) {
 860             Class&lt;?&gt; caller = Reflection.getCallerClass();
 861             checkAccess(caller, obj);
 862         }
 863         getFieldAccessor(obj).setByte(obj, b);
 864     }
 865 
 866     /**
 867      * Sets the value of a field as a {@code char} on the specified object.
 868      * This method is equivalent to
 869      * {@code set(obj, cObj)},
 870      * where {@code cObj} is a {@code Character} object and
 871      * {@code cObj.charValue() == c}.
 872      *
 873      * @param obj the object whose field should be modified
 874      * @param c   the new value for the field of {@code obj}
 875      * being modified
 876      *
 877      * @throws    IllegalAccessException    if this {@code Field} object
 878      *              is enforcing Java language access control and the underlying
 879      *              field is either inaccessible or final.
 880      * @throws    IllegalArgumentException  if the specified object is not an
 881      *              instance of the class or interface declaring the underlying
 882      *              field (or a subclass or implementor thereof),
 883      *              or if an unwrapping conversion fails.
 884      * @throws    NullPointerException      if the specified object is null
 885      *              and the field is an instance field.
 886      * @throws    ExceptionInInitializerError if the initialization provoked
 887      *              by this method fails.
 888      * @see       Field#set
 889      */
 890     @CallerSensitive
 891     @ForceInline // to ensure Reflection.getCallerClass optimization
 892     public void setChar(Object obj, char c)
 893         throws IllegalArgumentException, IllegalAccessException
 894     {
<span class="line-removed"> 895         ensureNotValueClass();</span>
<span class="line-removed"> 896 </span>
 897         if (!override) {
 898             Class&lt;?&gt; caller = Reflection.getCallerClass();
 899             checkAccess(caller, obj);
 900         }
 901         getFieldAccessor(obj).setChar(obj, c);
 902     }
 903 
 904     /**
 905      * Sets the value of a field as a {@code short} on the specified object.
 906      * This method is equivalent to
 907      * {@code set(obj, sObj)},
 908      * where {@code sObj} is a {@code Short} object and
 909      * {@code sObj.shortValue() == s}.
 910      *
 911      * @param obj the object whose field should be modified
 912      * @param s   the new value for the field of {@code obj}
 913      * being modified
 914      *
 915      * @throws    IllegalAccessException    if this {@code Field} object
 916      *              is enforcing Java language access control and the underlying
 917      *              field is either inaccessible or final.
 918      * @throws    IllegalArgumentException  if the specified object is not an
 919      *              instance of the class or interface declaring the underlying
 920      *              field (or a subclass or implementor thereof),
 921      *              or if an unwrapping conversion fails.
 922      * @throws    NullPointerException      if the specified object is null
 923      *              and the field is an instance field.
 924      * @throws    ExceptionInInitializerError if the initialization provoked
 925      *              by this method fails.
 926      * @see       Field#set
 927      */
 928     @CallerSensitive
 929     @ForceInline // to ensure Reflection.getCallerClass optimization
 930     public void setShort(Object obj, short s)
 931         throws IllegalArgumentException, IllegalAccessException
 932     {
<span class="line-removed"> 933         ensureNotValueClass();</span>
<span class="line-removed"> 934 </span>
 935         if (!override) {
 936             Class&lt;?&gt; caller = Reflection.getCallerClass();
 937             checkAccess(caller, obj);
 938         }
 939         getFieldAccessor(obj).setShort(obj, s);
 940     }
 941 
 942     /**
 943      * Sets the value of a field as an {@code int} on the specified object.
 944      * This method is equivalent to
 945      * {@code set(obj, iObj)},
 946      * where {@code iObj} is an {@code Integer} object and
 947      * {@code iObj.intValue() == i}.
 948      *
 949      * @param obj the object whose field should be modified
 950      * @param i   the new value for the field of {@code obj}
 951      * being modified
 952      *
 953      * @throws    IllegalAccessException    if this {@code Field} object
 954      *              is enforcing Java language access control and the underlying
 955      *              field is either inaccessible or final.
 956      * @throws    IllegalArgumentException  if the specified object is not an
 957      *              instance of the class or interface declaring the underlying
 958      *              field (or a subclass or implementor thereof),
 959      *              or if an unwrapping conversion fails.
 960      * @throws    NullPointerException      if the specified object is null
 961      *              and the field is an instance field.
 962      * @throws    ExceptionInInitializerError if the initialization provoked
 963      *              by this method fails.
 964      * @see       Field#set
 965      */
 966     @CallerSensitive
 967     @ForceInline // to ensure Reflection.getCallerClass optimization
 968     public void setInt(Object obj, int i)
 969         throws IllegalArgumentException, IllegalAccessException
 970     {
<span class="line-removed"> 971         ensureNotValueClass();</span>
<span class="line-removed"> 972 </span>
 973         if (!override) {
 974             Class&lt;?&gt; caller = Reflection.getCallerClass();
 975             checkAccess(caller, obj);
 976         }
 977         getFieldAccessor(obj).setInt(obj, i);
 978     }
 979 
 980     /**
 981      * Sets the value of a field as a {@code long} on the specified object.
 982      * This method is equivalent to
 983      * {@code set(obj, lObj)},
 984      * where {@code lObj} is a {@code Long} object and
 985      * {@code lObj.longValue() == l}.
 986      *
 987      * @param obj the object whose field should be modified
 988      * @param l   the new value for the field of {@code obj}
 989      * being modified
 990      *
 991      * @throws    IllegalAccessException    if this {@code Field} object
 992      *              is enforcing Java language access control and the underlying
 993      *              field is either inaccessible or final.
 994      * @throws    IllegalArgumentException  if the specified object is not an
 995      *              instance of the class or interface declaring the underlying
 996      *              field (or a subclass or implementor thereof),
 997      *              or if an unwrapping conversion fails.
 998      * @throws    NullPointerException      if the specified object is null
 999      *              and the field is an instance field.
1000      * @throws    ExceptionInInitializerError if the initialization provoked
1001      *              by this method fails.
1002      * @see       Field#set
1003      */
1004     @CallerSensitive
1005     @ForceInline // to ensure Reflection.getCallerClass optimization
1006     public void setLong(Object obj, long l)
1007         throws IllegalArgumentException, IllegalAccessException
1008     {
<span class="line-removed">1009         ensureNotValueClass();</span>
<span class="line-removed">1010 </span>
1011         if (!override) {
1012             Class&lt;?&gt; caller = Reflection.getCallerClass();
1013             checkAccess(caller, obj);
1014         }
1015         getFieldAccessor(obj).setLong(obj, l);
1016     }
1017 
1018     /**
1019      * Sets the value of a field as a {@code float} on the specified object.
1020      * This method is equivalent to
1021      * {@code set(obj, fObj)},
1022      * where {@code fObj} is a {@code Float} object and
1023      * {@code fObj.floatValue() == f}.
1024      *
1025      * @param obj the object whose field should be modified
1026      * @param f   the new value for the field of {@code obj}
1027      * being modified
1028      *
1029      * @throws    IllegalAccessException    if this {@code Field} object
1030      *              is enforcing Java language access control and the underlying
1031      *              field is either inaccessible or final.
1032      * @throws    IllegalArgumentException  if the specified object is not an
1033      *              instance of the class or interface declaring the underlying
1034      *              field (or a subclass or implementor thereof),
1035      *              or if an unwrapping conversion fails.
1036      * @throws    NullPointerException      if the specified object is null
1037      *              and the field is an instance field.
1038      * @throws    ExceptionInInitializerError if the initialization provoked
1039      *              by this method fails.
1040      * @see       Field#set
1041      */
1042     @CallerSensitive
1043     @ForceInline // to ensure Reflection.getCallerClass optimization
1044     public void setFloat(Object obj, float f)
1045         throws IllegalArgumentException, IllegalAccessException
1046     {
<span class="line-removed">1047         ensureNotValueClass();</span>
<span class="line-removed">1048 </span>
1049         if (!override) {
1050             Class&lt;?&gt; caller = Reflection.getCallerClass();
1051             checkAccess(caller, obj);
1052         }
1053         getFieldAccessor(obj).setFloat(obj, f);
1054     }
1055 
1056     /**
1057      * Sets the value of a field as a {@code double} on the specified object.
1058      * This method is equivalent to
1059      * {@code set(obj, dObj)},
1060      * where {@code dObj} is a {@code Double} object and
1061      * {@code dObj.doubleValue() == d}.
1062      *
1063      * @param obj the object whose field should be modified
1064      * @param d   the new value for the field of {@code obj}
1065      * being modified
1066      *
1067      * @throws    IllegalAccessException    if this {@code Field} object
1068      *              is enforcing Java language access control and the underlying
1069      *              field is either inaccessible or final.
1070      * @throws    IllegalArgumentException  if the specified object is not an
1071      *              instance of the class or interface declaring the underlying
1072      *              field (or a subclass or implementor thereof),
1073      *              or if an unwrapping conversion fails.
1074      * @throws    NullPointerException      if the specified object is null
1075      *              and the field is an instance field.
1076      * @throws    ExceptionInInitializerError if the initialization provoked
1077      *              by this method fails.
1078      * @see       Field#set
1079      */
1080     @CallerSensitive
1081     @ForceInline // to ensure Reflection.getCallerClass optimization
1082     public void setDouble(Object obj, double d)
1083         throws IllegalArgumentException, IllegalAccessException
1084     {
<span class="line-removed">1085         ensureNotValueClass();</span>
<span class="line-removed">1086 </span>
1087         if (!override) {
1088             Class&lt;?&gt; caller = Reflection.getCallerClass();
1089             checkAccess(caller, obj);
1090         }
1091         getFieldAccessor(obj).setDouble(obj, d);
1092     }
1093 
1094     // check access to field
1095     private void checkAccess(Class&lt;?&gt; caller, Object obj)
1096         throws IllegalAccessException
1097     {
1098         checkAccess(caller, clazz,
1099                     Modifier.isStatic(modifiers) ? null : obj.getClass(),
1100                     modifiers);
1101     }
1102 
<span class="line-removed">1103     /*</span>
<span class="line-removed">1104      * Ensure the declaring class is not an inline class.</span>
<span class="line-removed">1105      */</span>
<span class="line-removed">1106     private void ensureNotValueClass() throws IllegalAccessException {</span>
<span class="line-removed">1107         if (clazz.isInlineClass()) {</span>
<span class="line-removed">1108             throw new IllegalAccessException(&quot;cannot set field \&quot;&quot; + this + &quot;\&quot; of inline class &quot;</span>
<span class="line-removed">1109                 + clazz.getName());</span>
<span class="line-removed">1110         }</span>
<span class="line-removed">1111     }</span>
<span class="line-removed">1112 </span>
1113     // security check is done before calling this method
1114     private FieldAccessor getFieldAccessor(Object obj)
1115         throws IllegalAccessException
1116     {
1117         boolean ov = override;
1118         FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;
1119         return (a != null) ? a : acquireFieldAccessor(ov);
1120     }
1121 
1122     // NOTE that there is no synchronization used here. It is correct
1123     // (though not efficient) to generate more than one FieldAccessor
1124     // for a given Field. However, avoiding synchronization will
1125     // probably make the implementation more scalable.
1126     private FieldAccessor acquireFieldAccessor(boolean overrideFinalCheck) {
1127         // First check to see if one has been created yet, and take it
1128         // if so
1129         FieldAccessor tmp = null;
1130         if (root != null) tmp = root.getFieldAccessor(overrideFinalCheck);
1131         if (tmp != null) {
1132             if (overrideFinalCheck)
</pre>
</td>
<td>
<hr />
<pre>
 761      * @param value the new value for the field of {@code obj}
 762      * being modified
 763      *
 764      * @throws    IllegalAccessException    if this {@code Field} object
 765      *              is enforcing Java language access control and the underlying
 766      *              field is either inaccessible or final.
 767      * @throws    IllegalArgumentException  if the specified object is not an
 768      *              instance of the class or interface declaring the underlying
 769      *              field (or a subclass or implementor thereof),
 770      *              or if an unwrapping conversion fails.
 771      * @throws    NullPointerException      if the specified object is null
 772      *              and the field is an instance field.
 773      * @throws    ExceptionInInitializerError if the initialization provoked
 774      *              by this method fails.
 775      */
 776     @CallerSensitive
 777     @ForceInline // to ensure Reflection.getCallerClass optimization
 778     public void set(Object obj, Object value)
 779         throws IllegalArgumentException, IllegalAccessException
 780     {


 781         if (!override) {
 782             Class&lt;?&gt; caller = Reflection.getCallerClass();
 783             checkAccess(caller, obj);
 784         }
 785         getFieldAccessor(obj).set(obj, value);
 786     }
 787 
 788     /**
 789      * Sets the value of a field as a {@code boolean} on the specified object.
 790      * This method is equivalent to
 791      * {@code set(obj, zObj)},
 792      * where {@code zObj} is a {@code Boolean} object and
 793      * {@code zObj.booleanValue() == z}.
 794      *
 795      * @param obj the object whose field should be modified
 796      * @param z   the new value for the field of {@code obj}
 797      * being modified
 798      *
 799      * @throws    IllegalAccessException    if this {@code Field} object
 800      *              is enforcing Java language access control and the underlying
 801      *              field is either inaccessible or final.
 802      * @throws    IllegalArgumentException  if the specified object is not an
 803      *              instance of the class or interface declaring the underlying
 804      *              field (or a subclass or implementor thereof),
 805      *              or if an unwrapping conversion fails.
 806      * @throws    NullPointerException      if the specified object is null
 807      *              and the field is an instance field.
 808      * @throws    ExceptionInInitializerError if the initialization provoked
 809      *              by this method fails.
 810      * @see       Field#set
 811      */
 812     @CallerSensitive
 813     @ForceInline // to ensure Reflection.getCallerClass optimization
 814     public void setBoolean(Object obj, boolean z)
 815         throws IllegalArgumentException, IllegalAccessException
 816     {


 817         if (!override) {
 818             Class&lt;?&gt; caller = Reflection.getCallerClass();
 819             checkAccess(caller, obj);
 820         }
 821         getFieldAccessor(obj).setBoolean(obj, z);
 822     }
 823 
 824     /**
 825      * Sets the value of a field as a {@code byte} on the specified object.
 826      * This method is equivalent to
 827      * {@code set(obj, bObj)},
 828      * where {@code bObj} is a {@code Byte} object and
 829      * {@code bObj.byteValue() == b}.
 830      *
 831      * @param obj the object whose field should be modified
 832      * @param b   the new value for the field of {@code obj}
 833      * being modified
 834      *
 835      * @throws    IllegalAccessException    if this {@code Field} object
 836      *              is enforcing Java language access control and the underlying
 837      *              field is either inaccessible or final.
 838      * @throws    IllegalArgumentException  if the specified object is not an
 839      *              instance of the class or interface declaring the underlying
 840      *              field (or a subclass or implementor thereof),
 841      *              or if an unwrapping conversion fails.
 842      * @throws    NullPointerException      if the specified object is null
 843      *              and the field is an instance field.
 844      * @throws    ExceptionInInitializerError if the initialization provoked
 845      *              by this method fails.
 846      * @see       Field#set
 847      */
 848     @CallerSensitive
 849     @ForceInline // to ensure Reflection.getCallerClass optimization
 850     public void setByte(Object obj, byte b)
 851         throws IllegalArgumentException, IllegalAccessException
 852     {


 853         if (!override) {
 854             Class&lt;?&gt; caller = Reflection.getCallerClass();
 855             checkAccess(caller, obj);
 856         }
 857         getFieldAccessor(obj).setByte(obj, b);
 858     }
 859 
 860     /**
 861      * Sets the value of a field as a {@code char} on the specified object.
 862      * This method is equivalent to
 863      * {@code set(obj, cObj)},
 864      * where {@code cObj} is a {@code Character} object and
 865      * {@code cObj.charValue() == c}.
 866      *
 867      * @param obj the object whose field should be modified
 868      * @param c   the new value for the field of {@code obj}
 869      * being modified
 870      *
 871      * @throws    IllegalAccessException    if this {@code Field} object
 872      *              is enforcing Java language access control and the underlying
 873      *              field is either inaccessible or final.
 874      * @throws    IllegalArgumentException  if the specified object is not an
 875      *              instance of the class or interface declaring the underlying
 876      *              field (or a subclass or implementor thereof),
 877      *              or if an unwrapping conversion fails.
 878      * @throws    NullPointerException      if the specified object is null
 879      *              and the field is an instance field.
 880      * @throws    ExceptionInInitializerError if the initialization provoked
 881      *              by this method fails.
 882      * @see       Field#set
 883      */
 884     @CallerSensitive
 885     @ForceInline // to ensure Reflection.getCallerClass optimization
 886     public void setChar(Object obj, char c)
 887         throws IllegalArgumentException, IllegalAccessException
 888     {


 889         if (!override) {
 890             Class&lt;?&gt; caller = Reflection.getCallerClass();
 891             checkAccess(caller, obj);
 892         }
 893         getFieldAccessor(obj).setChar(obj, c);
 894     }
 895 
 896     /**
 897      * Sets the value of a field as a {@code short} on the specified object.
 898      * This method is equivalent to
 899      * {@code set(obj, sObj)},
 900      * where {@code sObj} is a {@code Short} object and
 901      * {@code sObj.shortValue() == s}.
 902      *
 903      * @param obj the object whose field should be modified
 904      * @param s   the new value for the field of {@code obj}
 905      * being modified
 906      *
 907      * @throws    IllegalAccessException    if this {@code Field} object
 908      *              is enforcing Java language access control and the underlying
 909      *              field is either inaccessible or final.
 910      * @throws    IllegalArgumentException  if the specified object is not an
 911      *              instance of the class or interface declaring the underlying
 912      *              field (or a subclass or implementor thereof),
 913      *              or if an unwrapping conversion fails.
 914      * @throws    NullPointerException      if the specified object is null
 915      *              and the field is an instance field.
 916      * @throws    ExceptionInInitializerError if the initialization provoked
 917      *              by this method fails.
 918      * @see       Field#set
 919      */
 920     @CallerSensitive
 921     @ForceInline // to ensure Reflection.getCallerClass optimization
 922     public void setShort(Object obj, short s)
 923         throws IllegalArgumentException, IllegalAccessException
 924     {


 925         if (!override) {
 926             Class&lt;?&gt; caller = Reflection.getCallerClass();
 927             checkAccess(caller, obj);
 928         }
 929         getFieldAccessor(obj).setShort(obj, s);
 930     }
 931 
 932     /**
 933      * Sets the value of a field as an {@code int} on the specified object.
 934      * This method is equivalent to
 935      * {@code set(obj, iObj)},
 936      * where {@code iObj} is an {@code Integer} object and
 937      * {@code iObj.intValue() == i}.
 938      *
 939      * @param obj the object whose field should be modified
 940      * @param i   the new value for the field of {@code obj}
 941      * being modified
 942      *
 943      * @throws    IllegalAccessException    if this {@code Field} object
 944      *              is enforcing Java language access control and the underlying
 945      *              field is either inaccessible or final.
 946      * @throws    IllegalArgumentException  if the specified object is not an
 947      *              instance of the class or interface declaring the underlying
 948      *              field (or a subclass or implementor thereof),
 949      *              or if an unwrapping conversion fails.
 950      * @throws    NullPointerException      if the specified object is null
 951      *              and the field is an instance field.
 952      * @throws    ExceptionInInitializerError if the initialization provoked
 953      *              by this method fails.
 954      * @see       Field#set
 955      */
 956     @CallerSensitive
 957     @ForceInline // to ensure Reflection.getCallerClass optimization
 958     public void setInt(Object obj, int i)
 959         throws IllegalArgumentException, IllegalAccessException
 960     {


 961         if (!override) {
 962             Class&lt;?&gt; caller = Reflection.getCallerClass();
 963             checkAccess(caller, obj);
 964         }
 965         getFieldAccessor(obj).setInt(obj, i);
 966     }
 967 
 968     /**
 969      * Sets the value of a field as a {@code long} on the specified object.
 970      * This method is equivalent to
 971      * {@code set(obj, lObj)},
 972      * where {@code lObj} is a {@code Long} object and
 973      * {@code lObj.longValue() == l}.
 974      *
 975      * @param obj the object whose field should be modified
 976      * @param l   the new value for the field of {@code obj}
 977      * being modified
 978      *
 979      * @throws    IllegalAccessException    if this {@code Field} object
 980      *              is enforcing Java language access control and the underlying
 981      *              field is either inaccessible or final.
 982      * @throws    IllegalArgumentException  if the specified object is not an
 983      *              instance of the class or interface declaring the underlying
 984      *              field (or a subclass or implementor thereof),
 985      *              or if an unwrapping conversion fails.
 986      * @throws    NullPointerException      if the specified object is null
 987      *              and the field is an instance field.
 988      * @throws    ExceptionInInitializerError if the initialization provoked
 989      *              by this method fails.
 990      * @see       Field#set
 991      */
 992     @CallerSensitive
 993     @ForceInline // to ensure Reflection.getCallerClass optimization
 994     public void setLong(Object obj, long l)
 995         throws IllegalArgumentException, IllegalAccessException
 996     {


 997         if (!override) {
 998             Class&lt;?&gt; caller = Reflection.getCallerClass();
 999             checkAccess(caller, obj);
1000         }
1001         getFieldAccessor(obj).setLong(obj, l);
1002     }
1003 
1004     /**
1005      * Sets the value of a field as a {@code float} on the specified object.
1006      * This method is equivalent to
1007      * {@code set(obj, fObj)},
1008      * where {@code fObj} is a {@code Float} object and
1009      * {@code fObj.floatValue() == f}.
1010      *
1011      * @param obj the object whose field should be modified
1012      * @param f   the new value for the field of {@code obj}
1013      * being modified
1014      *
1015      * @throws    IllegalAccessException    if this {@code Field} object
1016      *              is enforcing Java language access control and the underlying
1017      *              field is either inaccessible or final.
1018      * @throws    IllegalArgumentException  if the specified object is not an
1019      *              instance of the class or interface declaring the underlying
1020      *              field (or a subclass or implementor thereof),
1021      *              or if an unwrapping conversion fails.
1022      * @throws    NullPointerException      if the specified object is null
1023      *              and the field is an instance field.
1024      * @throws    ExceptionInInitializerError if the initialization provoked
1025      *              by this method fails.
1026      * @see       Field#set
1027      */
1028     @CallerSensitive
1029     @ForceInline // to ensure Reflection.getCallerClass optimization
1030     public void setFloat(Object obj, float f)
1031         throws IllegalArgumentException, IllegalAccessException
1032     {


1033         if (!override) {
1034             Class&lt;?&gt; caller = Reflection.getCallerClass();
1035             checkAccess(caller, obj);
1036         }
1037         getFieldAccessor(obj).setFloat(obj, f);
1038     }
1039 
1040     /**
1041      * Sets the value of a field as a {@code double} on the specified object.
1042      * This method is equivalent to
1043      * {@code set(obj, dObj)},
1044      * where {@code dObj} is a {@code Double} object and
1045      * {@code dObj.doubleValue() == d}.
1046      *
1047      * @param obj the object whose field should be modified
1048      * @param d   the new value for the field of {@code obj}
1049      * being modified
1050      *
1051      * @throws    IllegalAccessException    if this {@code Field} object
1052      *              is enforcing Java language access control and the underlying
1053      *              field is either inaccessible or final.
1054      * @throws    IllegalArgumentException  if the specified object is not an
1055      *              instance of the class or interface declaring the underlying
1056      *              field (or a subclass or implementor thereof),
1057      *              or if an unwrapping conversion fails.
1058      * @throws    NullPointerException      if the specified object is null
1059      *              and the field is an instance field.
1060      * @throws    ExceptionInInitializerError if the initialization provoked
1061      *              by this method fails.
1062      * @see       Field#set
1063      */
1064     @CallerSensitive
1065     @ForceInline // to ensure Reflection.getCallerClass optimization
1066     public void setDouble(Object obj, double d)
1067         throws IllegalArgumentException, IllegalAccessException
1068     {


1069         if (!override) {
1070             Class&lt;?&gt; caller = Reflection.getCallerClass();
1071             checkAccess(caller, obj);
1072         }
1073         getFieldAccessor(obj).setDouble(obj, d);
1074     }
1075 
1076     // check access to field
1077     private void checkAccess(Class&lt;?&gt; caller, Object obj)
1078         throws IllegalAccessException
1079     {
1080         checkAccess(caller, clazz,
1081                     Modifier.isStatic(modifiers) ? null : obj.getClass(),
1082                     modifiers);
1083     }
1084 










1085     // security check is done before calling this method
1086     private FieldAccessor getFieldAccessor(Object obj)
1087         throws IllegalAccessException
1088     {
1089         boolean ov = override;
1090         FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;
1091         return (a != null) ? a : acquireFieldAccessor(ov);
1092     }
1093 
1094     // NOTE that there is no synchronization used here. It is correct
1095     // (though not efficient) to generate more than one FieldAccessor
1096     // for a given Field. However, avoiding synchronization will
1097     // probably make the implementation more scalable.
1098     private FieldAccessor acquireFieldAccessor(boolean overrideFinalCheck) {
1099         // First check to see if one has been created yet, and take it
1100         // if so
1101         FieldAccessor tmp = null;
1102         if (root != null) tmp = root.getFieldAccessor(overrideFinalCheck);
1103         if (tmp != null) {
1104             if (overrideFinalCheck)
</pre>
</td>
</tr>
</table>
<center><a href="../invoke/X-VarHandle.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Proxy.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
  32 
  33 class RecordComponent;
  34 
  35 // Interface for manipulating the basic Java classes.
  36 //
  37 // All dependencies on layout of actual Java classes should be kept here.
  38 // If the layout of any of the classes above changes the offsets must be adjusted.
  39 //
  40 // For most classes we hardwire the offsets for performance reasons. In certain
  41 // cases (e.g. java.security.AccessControlContext) we compute the offsets at
  42 // startup since the layout here differs between JDK1.2 and JDK1.3.
  43 //
  44 // Note that fields (static and non-static) are arranged with oops before non-oops
  45 // on a per class basis. The offsets below have to reflect this ordering.
  46 //
  47 // When editing the layouts please update the check_offset verification code
  48 // correspondingly. The names in the enums must be identical to the actual field
  49 // names in order for the verification code to work.
  50 
  51 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  52   f(java_lang_Class) \
  53   f(java_lang_String) \
  54   //end
  55 
  56 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  57   f(java_lang_System) \
  58   f(java_lang_ClassLoader) \
  59   f(java_lang_Throwable) \
  60   f(java_lang_Thread) \
  61   f(java_lang_ThreadGroup) \
  62   f(java_lang_AssertionStatusDirectives) \
  63   f(java_lang_ref_SoftReference) \
  64   f(java_lang_invoke_MethodHandle) \
  65   f(java_lang_invoke_DirectMethodHandle) \
  66   f(java_lang_invoke_MemberName) \
  67   f(java_lang_invoke_ResolvedMethodName) \
  68   f(java_lang_invoke_LambdaForm) \
  69   f(java_lang_invoke_MethodType) \
  70   f(java_lang_invoke_CallSite) \
  71   f(java_lang_invoke_ConstantCallSite) \
  72   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  73   f(java_security_AccessControlContext) \
  74   f(java_lang_reflect_AccessibleObject) \
  75   f(java_lang_reflect_Method) \
  76   f(java_lang_reflect_Constructor) \
  77   f(java_lang_reflect_Field) \
  78   f(java_lang_reflect_RecordComponent) \
  79   f(java_nio_Buffer) \
  80   f(reflect_ConstantPool) \
  81   f(reflect_UnsafeStaticFieldAccessorImpl) \
  82   f(java_lang_reflect_Parameter) \
  83   f(java_lang_Module) \
  84   f(java_lang_StackTraceElement) \
  85   f(java_lang_StackFrameInfo) \
  86   f(java_lang_LiveStackFrameInfo) \
  87   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  88   f(jdk_internal_misc_UnsafeConstants) \
  89   f(jdk_internal_vm_jni_SubElementSelector) \
  90   //end
  91 
  92 #define BASIC_JAVA_CLASSES_DO(f) \
  93         BASIC_JAVA_CLASSES_DO_PART1(f) \
  94         BASIC_JAVA_CLASSES_DO_PART2(f)
  95 
  96 // Interface to java.lang.Object objects
  97 
  98 class java_lang_Object : AllStatic {
  99  public:
 100   static void register_natives(TRAPS);
 101 };
 102 
 103 // Interface to java.lang.String objects
 104 
 105 class java_lang_String : AllStatic {
 106  private:
 107   static int value_offset;
 108   static int hash_offset;
 109   static int hashIsZero_offset;
 110   static int coder_offset;
 111 
 112   static bool initialized;
 113 
 114   static Handle basic_create(int length, bool byte_arr, TRAPS);
 115 
 116   static inline void set_coder(oop string, jbyte coder);
 117 
 118  public:
 119 
 120   // Coders
 121   enum Coder {
 122     CODER_LATIN1 =  0,
 123     CODER_UTF16  =  1
 124   };
 125 
 126   static void compute_offsets();
 127   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 128 
 129   // Instance creation
 130   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 131   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 132   static Handle create_from_str(const char* utf8_str, TRAPS);
 133   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 134   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 135   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 136   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 137 
 138   static void set_compact_strings(bool value);
 139 
 140   static int value_offset_in_bytes()  {
 141     assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 142     return value_offset;
 143   }
 144   static int hash_offset_in_bytes()   {
 145     assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);
 146     return hash_offset;
 147   }
 148   static int hashIsZero_offset_in_bytes()   {
 149     assert(initialized &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 150     return hashIsZero_offset;
 151   }
 152   static int coder_offset_in_bytes()   {
 153     assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 154     return coder_offset;
 155   }
 156 
 157   static inline void set_value_raw(oop string, typeArrayOop buffer);
 158   static inline void set_value(oop string, typeArrayOop buffer);
 159 
 160   // Accessors
 161   static inline typeArrayOop value(oop java_string);
 162   static inline typeArrayOop value_no_keepalive(oop java_string);
 163   static inline bool hash_is_set(oop string);
 164   static inline bool is_latin1(oop java_string);
 165   static inline int length(oop java_string);
 166   static inline int length(oop java_string, typeArrayOop string_value);
 167   static int utf8_length(oop java_string);
 168   static int utf8_length(oop java_string, typeArrayOop string_value);
 169 
 170   // String converters
 171   static char*  as_utf8_string(oop java_string);
 172   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 173   static char*  as_utf8_string(oop java_string, int start, int len);
 174   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
 175   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
 176   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
 177   static jchar* as_unicode_string(oop java_string, int&amp; length, TRAPS);
 178   // produce an ascii string with all other values quoted using \u####
 179   static char*  as_quoted_ascii(oop java_string);
 180 
 181   // Compute the hash value for a java.lang.String object which would
 182   // contain the characters passed in.
 183   //
 184   // As the hash value used by the String object itself, in
 185   // String.hashCode().  This value is normally calculated in Java code
 186   // in the String.hashCode method(), but is precomputed for String
 187   // objects in the shared archive file.
 188   // hash P(31) from Kernighan &amp; Ritchie
 189   //
 190   // For this reason, THIS ALGORITHM MUST MATCH String.hashCode().
 191   static unsigned int hash_code(const jchar* s, int len) {
 192     unsigned int h = 0;
 193     while (len-- &gt; 0) {
 194       h = 31*h + (unsigned int) *s;
 195       s++;
 196     }
 197     return h;
 198   }
 199 
 200   static unsigned int hash_code(const jbyte* s, int len) {
 201     unsigned int h = 0;
 202     while (len-- &gt; 0) {
 203       h = 31*h + (((unsigned int) *s) &amp; 0xFF);
 204       s++;
 205     }
 206     return h;
 207   }
 208 
 209   static unsigned int hash_code(oop java_string);
 210 
 211   static bool equals(oop java_string, const jchar* chars, int len);
 212   static bool equals(oop str1, oop str2);
 213   static inline bool value_equals(typeArrayOop str_value1, typeArrayOop str_value2);
 214 
 215   // Conversion between &#39;.&#39; and &#39;/&#39; formats
 216   static Handle externalize_classname(Handle java_string, TRAPS) {
 217     return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);
 218   }
 219 
 220   // Conversion
 221   static Symbol* as_symbol(oop java_string);
 222   static Symbol* as_symbol_or_null(oop java_string);
 223 
 224   // Testers
 225   static bool is_instance(oop obj);
 226   static inline bool is_instance_inlined(oop obj);
 227 
 228   // Debugging
 229   static void print(oop java_string, outputStream* st);
 230   friend class JavaClasses;
 231   friend class StringTable;
 232 };
 233 
 234 
 235 // Interface to java.lang.Class objects
 236 
 237 #define CLASS_INJECTED_FIELDS(macro)                                       \
 238   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 239   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 240   macro(java_lang_Class, oop_size,               int_signature,     false) \
 241   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
 242   macro(java_lang_Class, protection_domain,      object_signature,  false) \
 243   macro(java_lang_Class, signers,                object_signature,  false) \
 244   macro(java_lang_Class, source_file,            object_signature,  false) \
 245 
 246 class java_lang_Class : AllStatic {
 247   friend class VMStructs;
 248   friend class JVMCIVMStructs;
 249 
 250  private:
 251   // The fake offsets are added by the class loader when java.lang.Class is loaded
 252 
 253   static int _klass_offset;
 254   static int _array_klass_offset;
 255 
 256   static int _oop_size_offset;
 257   static int _static_oop_field_count_offset;
 258 
 259   static int _protection_domain_offset;
 260   static int _init_lock_offset;
 261   static int _signers_offset;
 262   static int _class_loader_offset;
 263   static int _module_offset;
 264   static int _component_mirror_offset;
 265   static int _name_offset;
 266   static int _source_file_offset;
 267   static int _val_type_mirror_offset;
 268   static int _ref_type_mirror_offset;
 269 
 270   static bool offsets_computed;
 271   static int classRedefinedCount_offset;
 272 
 273   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 274   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 275 
 276   static void set_init_lock(oop java_class, oop init_lock);
 277   static void set_protection_domain(oop java_class, oop protection_domain);
 278   static void set_class_loader(oop java_class, oop class_loader);
 279   static void set_component_mirror(oop java_class, oop comp_mirror);
 280   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain, TRAPS);
 281   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 282  public:
 283   static void allocate_fixup_lists();
 284   static void compute_offsets();
 285 
 286   // Instance creation
 287   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 288                             Handle protection_domain, TRAPS);
 289   static void fixup_mirror(Klass* k, TRAPS);
 290   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
 291   static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 292   static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 293 
 294   // Archiving
 295   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 296   static void archive_basic_type_mirrors(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 297   static oop  archive_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 298   static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror, Thread *THREAD)
 299                                       NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 300   static bool restore_archived_mirror(Klass *k, Handle class_loader, Handle module,
 301                                       Handle protection_domain,
 302                                       TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);
 303 
 304   static void fixup_module_field(Klass* k, Handle module);
 305 
 306   // Conversion
 307   static Klass* as_Klass(oop java_class);
 308   static Klass* as_Klass_raw(oop java_class);
 309   static void set_klass(oop java_class, Klass* klass);
 310   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 311   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 312   static void print_signature(oop java_class, outputStream *st);
 313   static const char* as_external_name(oop java_class);
 314   // Testing
 315   static bool is_instance(oop obj);
 316 
 317   static bool is_primitive(oop java_class);
 318   static BasicType primitive_type(oop java_class);
 319   static oop primitive_mirror(BasicType t);
 320   // JVM_NewArray support
 321   static Klass* array_klass_acquire(oop java_class);
 322   static void release_set_array_klass(oop java_class, Klass* klass);
 323   // compiler support for class operations
 324   static int klass_offset_in_bytes()                { return _klass_offset; }
 325   static int array_klass_offset_in_bytes()          { return _array_klass_offset; }
 326   static int val_type_mirror_offset_in_bytes()      { return _val_type_mirror_offset; }
 327   static int component_mirror_offset_in_bytes()     { return _component_mirror_offset; }
 328   // Support for classRedefinedCount field
 329   static int classRedefinedCount(oop the_class_mirror);
 330   static void set_classRedefinedCount(oop the_class_mirror, int value);
 331 
 332   // Support for embedded per-class oops
 333   static oop  protection_domain(oop java_class);
 334   static oop  init_lock(oop java_class);
 335   static oop  component_mirror(oop java_class);
 336   static objArrayOop  signers(oop java_class);
 337   static void set_signers(oop java_class, objArrayOop signers);
 338 
 339   static oop class_loader(oop java_class);
 340   static void set_module(oop java_class, oop module);
 341   static oop module(oop java_class);
 342 
 343   static void set_ref_type_mirror(oop java_class, oop mirror);
 344   static oop ref_type_mirror(oop java_class);
 345 
 346   static void set_val_type_mirror(oop java_class, oop mirror);
 347   static oop val_type_mirror(oop java_class);
 348 
 349   static oop name(Handle java_class, TRAPS);
 350 
 351   static oop source_file(oop java_class);
 352   static void set_source_file(oop java_class, oop source_file);
 353 
 354   static int oop_size(oop java_class);
 355   static int oop_size_raw(oop java_class);
 356   static void set_oop_size(HeapWord* java_class, int size);
 357   static int static_oop_field_count(oop java_class);
 358   static int static_oop_field_count_raw(oop java_class);
 359   static void set_static_oop_field_count(oop java_class, int size);
 360 
 361   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 362     return _fixup_mirror_list;
 363   }
 364   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 365     _fixup_mirror_list = v;
 366   }
 367 
 368   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
 369     return _fixup_module_field_list;
 370   }
 371   static void set_fixup_module_field_list(GrowableArray&lt;Klass*&gt;* v) {
 372     _fixup_module_field_list = v;
 373   }
 374 
 375   // Debugging
 376   friend class JavaClasses;
 377   friend class InstanceKlass;   // verification code accesses offsets
 378   friend class ClassFileParser; // access to number_of_fake_fields
 379 };
 380 
 381 // Interface to java.lang.Thread objects
 382 
 383 class java_lang_Thread : AllStatic {
 384  private:
 385   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 386   // so we compute the offsets at startup rather than hard-wiring them.
 387   static int _name_offset;
 388   static int _group_offset;
 389   static int _contextClassLoader_offset;
 390   static int _inheritedAccessControlContext_offset;
 391   static int _priority_offset;
 392   static int _eetop_offset;
 393   static int _interrupted_offset;
 394   static int _daemon_offset;
 395   static int _stillborn_offset;
 396   static int _stackSize_offset;
 397   static int _tid_offset;
 398   static int _thread_status_offset;
 399   static int _park_blocker_offset;
 400 
 401   static void compute_offsets();
 402 
 403  public:
 404   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 405 
 406   // Instance creation
 407   static oop create();
 408   // Returns the JavaThread associated with the thread obj
 409   static JavaThread* thread(oop java_thread);
 410   // Set JavaThread for instance
 411   static void set_thread(oop java_thread, JavaThread* thread);
 412   // Interrupted status
 413   static bool interrupted(oop java_thread);
 414   static void set_interrupted(oop java_thread, bool val);
 415   // Name
 416   static oop name(oop java_thread);
 417   static void set_name(oop java_thread, oop name);
 418   // Priority
 419   static ThreadPriority priority(oop java_thread);
 420   static void set_priority(oop java_thread, ThreadPriority priority);
 421   // Thread group
 422   static oop  threadGroup(oop java_thread);
 423   // Stillborn
 424   static bool is_stillborn(oop java_thread);
 425   static void set_stillborn(oop java_thread);
 426   // Alive (NOTE: this is not really a field, but provides the correct
 427   // definition without doing a Java call)
 428   static bool is_alive(oop java_thread);
 429   // Daemon
 430   static bool is_daemon(oop java_thread);
 431   static void set_daemon(oop java_thread);
 432   // Context ClassLoader
 433   static oop context_class_loader(oop java_thread);
 434   // Control context
 435   static oop inherited_access_control_context(oop java_thread);
 436   // Stack size hint
 437   static jlong stackSize(oop java_thread);
 438   // Thread ID
 439   static jlong thread_id(oop java_thread);
 440 
 441   // Blocker object responsible for thread parking
 442   static oop park_blocker(oop java_thread);
 443 
 444   // Java Thread Status for JVMTI and M&amp;M use.
 445   // This thread status info is saved in threadStatus field of
 446   // java.lang.Thread java class.
 447   enum ThreadStatus {
 448     NEW                      = 0,
 449     RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
 450                                JVMTI_THREAD_STATE_RUNNABLE,
 451     SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
 452                                JVMTI_THREAD_STATE_WAITING +
 453                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 454                                JVMTI_THREAD_STATE_SLEEPING,
 455     IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
 456                                JVMTI_THREAD_STATE_WAITING +
 457                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 458                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 459     IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
 460                                JVMTI_THREAD_STATE_WAITING +
 461                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 462                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 463     PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
 464                                JVMTI_THREAD_STATE_WAITING +
 465                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 466                                JVMTI_THREAD_STATE_PARKED,
 467     PARKED_TIMED             = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park(long)
 468                                JVMTI_THREAD_STATE_WAITING +
 469                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 470                                JVMTI_THREAD_STATE_PARKED,
 471     BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE +          // (re-)entering a synchronization block
 472                                JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
 473     TERMINATED               = JVMTI_THREAD_STATE_TERMINATED
 474   };
 475   // Write thread status info to threadStatus field of java.lang.Thread.
 476   static void set_thread_status(oop java_thread_oop, ThreadStatus status);
 477   // Read thread status info from threadStatus field of java.lang.Thread.
 478   static ThreadStatus get_thread_status(oop java_thread_oop);
 479 
 480   static const char*  thread_status_name(oop java_thread_oop);
 481 
 482   // Debugging
 483   friend class JavaClasses;
 484 };
 485 
 486 // Interface to java.lang.ThreadGroup objects
 487 
 488 class java_lang_ThreadGroup : AllStatic {
 489  private:
 490   static int _parent_offset;
 491   static int _name_offset;
 492   static int _threads_offset;
 493   static int _groups_offset;
 494   static int _maxPriority_offset;
 495   static int _destroyed_offset;
 496   static int _daemon_offset;
 497   static int _nthreads_offset;
 498   static int _ngroups_offset;
 499 
 500   static void compute_offsets();
 501 
 502  public:
 503   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 504 
 505   // parent ThreadGroup
 506   static oop  parent(oop java_thread_group);
 507   // name
 508   static const char* name(oop java_thread_group);
 509   // (&quot;name as oop&quot; accessor is not necessary)
 510   // Number of threads in group
 511   static int nthreads(oop java_thread_group);
 512   // threads
 513   static objArrayOop threads(oop java_thread_group);
 514   // Number of threads in group
 515   static int ngroups(oop java_thread_group);
 516   // groups
 517   static objArrayOop groups(oop java_thread_group);
 518   // maxPriority in group
 519   static ThreadPriority maxPriority(oop java_thread_group);
 520   // Destroyed
 521   static bool is_destroyed(oop java_thread_group);
 522   // Daemon
 523   static bool is_daemon(oop java_thread_group);
 524   // Debugging
 525   friend class JavaClasses;
 526 };
 527 
 528 
 529 
 530 // Interface to java.lang.Throwable objects
 531 
 532 class java_lang_Throwable: AllStatic {
 533   friend class BacktraceBuilder;
 534   friend class BacktraceIterator;
 535 
 536  private:
 537   // Offsets
 538   enum {
 539     hc_backtrace_offset     =  0,
 540     hc_detailMessage_offset =  1,
 541     hc_cause_offset         =  2,  // New since 1.4
 542     hc_stackTrace_offset    =  3   // New since 1.4
 543   };
 544   // Trace constants
 545   enum {
 546     trace_methods_offset = 0,
 547     trace_bcis_offset    = 1,
 548     trace_mirrors_offset = 2,
 549     trace_names_offset   = 3,
 550     trace_next_offset    = 4,
 551     trace_hidden_offset  = 5,
 552     trace_size           = 6,
 553     trace_chunk_size     = 32
 554   };
 555 
 556   static int backtrace_offset;
 557   static int detailMessage_offset;
 558   static int stackTrace_offset;
 559   static int depth_offset;
 560   static int static_unassigned_stacktrace_offset;
 561 
 562   // StackTrace (programmatic access, new since 1.4)
 563   static void clear_stacktrace(oop throwable);
 564   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 565   static void set_stacktrace(oop throwable, oop st_element_array);
 566   static oop unassigned_stacktrace();
 567 
 568  public:
 569   // Backtrace
 570   static oop backtrace(oop throwable);
 571   static void set_backtrace(oop throwable, oop value);
 572   static int depth(oop throwable);
 573   static void set_depth(oop throwable, int value);
 574   // Needed by JVMTI to filter out this internal field.
 575   static int get_backtrace_offset() { return backtrace_offset;}
 576   static int get_detailMessage_offset() { return detailMessage_offset;}
 577   // Message
 578   static oop message(oop throwable);
 579   static void set_message(oop throwable, oop value);
 580   static Symbol* detail_message(oop throwable);
 581   static void print_stack_element(outputStream *st, Method* method, int bci);
 582   static void print_stack_usage(Handle stream);
 583 
 584   static void compute_offsets();
 585   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 586 
 587   // Allocate space for backtrace (created but stack trace not filled in)
 588   static void allocate_backtrace(Handle throwable, TRAPS);
 589   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 590   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 591   // Fill in current stack trace, can cause GC
 592   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 593   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 594   // Programmatic access to stack trace
 595   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 596   // Printing
 597   static void print(oop throwable, outputStream* st);
 598   static void print_stack_trace(Handle throwable, outputStream* st);
 599   static void java_printStackTrace(Handle throwable, TRAPS);
 600   // Debugging
 601   friend class JavaClasses;
 602   // Gets the method and bci of the top frame (TOS). Returns false if this failed.
 603   static bool get_top_method_and_bci(oop throwable, Method** method, int* bci);
 604 };
 605 
 606 
 607 // Interface to java.lang.reflect.AccessibleObject objects
 608 
 609 class java_lang_reflect_AccessibleObject: AllStatic {
 610  private:
 611   // Note that to reduce dependencies on the JDK we compute these
 612   // offsets at run-time.
 613   static int override_offset;
 614 
 615   static void compute_offsets();
 616 
 617  public:
 618   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 619 
 620   // Accessors
 621   static jboolean override(oop reflect);
 622   static void set_override(oop reflect, jboolean value);
 623 
 624   // Debugging
 625   friend class JavaClasses;
 626 };
 627 
 628 
 629 // Interface to java.lang.reflect.Method objects
 630 
 631 class java_lang_reflect_Method : public java_lang_reflect_AccessibleObject {
 632  private:
 633   // Note that to reduce dependencies on the JDK we compute these
 634   // offsets at run-time.
 635   static int clazz_offset;
 636   static int name_offset;
 637   static int returnType_offset;
 638   static int parameterTypes_offset;
 639   static int exceptionTypes_offset;
 640   static int slot_offset;
 641   static int modifiers_offset;
 642   static int signature_offset;
 643   static int annotations_offset;
 644   static int parameter_annotations_offset;
 645   static int annotation_default_offset;
 646 
 647   static void compute_offsets();
 648  public:
 649   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 650 
 651   // Allocation
 652   static Handle create(TRAPS);
 653 
 654   // Accessors
 655   static oop clazz(oop reflect);
 656   static void set_clazz(oop reflect, oop value);
 657 
 658   static void set_name(oop method, oop value);
 659 
 660   static oop return_type(oop method);
 661   static void set_return_type(oop method, oop value);
 662 
 663   static oop parameter_types(oop method);
 664   static void set_parameter_types(oop method, oop value);
 665 
 666   static int slot(oop reflect);
 667   static void set_slot(oop reflect, int value);
 668 
 669   static void set_exception_types(oop method, oop value);
 670   static void set_modifiers(oop method, int value);
 671   static void set_signature(oop method, oop value);
 672   static void set_annotations(oop method, oop value);
 673   static void set_parameter_annotations(oop method, oop value);
 674   static void set_annotation_default(oop method, oop value);
 675 
 676   // Debugging
 677   friend class JavaClasses;
 678 };
 679 
 680 
 681 // Interface to java.lang.reflect.Constructor objects
 682 
 683 class java_lang_reflect_Constructor : public java_lang_reflect_AccessibleObject {
 684  private:
 685   // Note that to reduce dependencies on the JDK we compute these
 686   // offsets at run-time.
 687   static int clazz_offset;
 688   static int parameterTypes_offset;
 689   static int exceptionTypes_offset;
 690   static int slot_offset;
 691   static int modifiers_offset;
 692   static int signature_offset;
 693   static int annotations_offset;
 694   static int parameter_annotations_offset;
 695 
 696   static void compute_offsets();
 697  public:
 698   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 699 
 700   // Allocation
 701   static Handle create(TRAPS);
 702 
 703   // Accessors
 704   static oop clazz(oop reflect);
 705   static void set_clazz(oop reflect, oop value);
 706 
 707   static oop parameter_types(oop constructor);
 708   static void set_parameter_types(oop constructor, oop value);
 709 
 710   static int slot(oop reflect);
 711   static void set_slot(oop reflect, int value);
 712 
 713   static void set_exception_types(oop constructor, oop value);
 714   static void set_modifiers(oop constructor, int value);
 715   static void set_signature(oop constructor, oop value);
 716   static void set_annotations(oop constructor, oop value);
 717   static void set_parameter_annotations(oop method, oop value);
 718 
 719   // Debugging
 720   friend class JavaClasses;
 721 };
 722 
 723 
 724 // Interface to java.lang.reflect.Field objects
 725 
 726 class java_lang_reflect_Field : public java_lang_reflect_AccessibleObject {
 727  private:
 728   // Note that to reduce dependencies on the JDK we compute these
 729   // offsets at run-time.
 730   static int clazz_offset;
 731   static int name_offset;
 732   static int type_offset;
 733   static int slot_offset;
 734   static int modifiers_offset;
 735   static int signature_offset;
 736   static int annotations_offset;
 737 
 738   static void compute_offsets();
 739 
 740  public:
 741   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 742 
 743   // Allocation
 744   static Handle create(TRAPS);
 745 
 746   // Accessors
 747   static oop clazz(oop reflect);
 748   static void set_clazz(oop reflect, oop value);
 749 
 750   static oop name(oop field);
 751   static void set_name(oop field, oop value);
 752 
 753   static oop type(oop field);
 754   static void set_type(oop field, oop value);
 755 
 756   static int slot(oop reflect);
 757   static void set_slot(oop reflect, int value);
 758 
 759   static int modifiers(oop field);
 760   static void set_modifiers(oop field, int value);
 761 
 762   static void set_signature(oop constructor, oop value);
 763   static void set_annotations(oop constructor, oop value);
 764   static void set_parameter_annotations(oop method, oop value);
 765   static void set_annotation_default(oop method, oop value);
 766 
 767   // Debugging
 768   friend class JavaClasses;
 769 };
 770 
 771 class java_lang_reflect_Parameter {
 772  private:
 773   // Note that to reduce dependencies on the JDK we compute these
 774   // offsets at run-time.
 775   static int name_offset;
 776   static int modifiers_offset;
 777   static int index_offset;
 778   static int executable_offset;
 779 
 780   static void compute_offsets();
 781 
 782  public:
 783   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 784 
 785   // Allocation
 786   static Handle create(TRAPS);
 787 
 788   // Accessors
 789   static oop name(oop field);
 790   static void set_name(oop field, oop value);
 791 
 792   static int index(oop reflect);
 793   static void set_index(oop reflect, int value);
 794 
 795   static int modifiers(oop reflect);
 796   static void set_modifiers(oop reflect, int value);
 797 
 798   static oop executable(oop constructor);
 799   static void set_executable(oop constructor, oop value);
 800 
 801   friend class JavaClasses;
 802 };
 803 
 804 #define MODULE_INJECTED_FIELDS(macro)                            \
 805   macro(java_lang_Module, module_entry, intptr_signature, false)
 806 
 807 class java_lang_Module {
 808   private:
 809     static int loader_offset;
 810     static int name_offset;
 811     static int _module_entry_offset;
 812     static void compute_offsets();
 813 
 814   public:
 815     static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 816 
 817     // Allocation
 818     static Handle create(Handle loader, Handle module_name, TRAPS);
 819 
 820     // Testers
 821     static bool is_instance(oop obj);
 822 
 823     // Accessors
 824     static oop loader(oop module);
 825     static void set_loader(oop module, oop value);
 826 
 827     static oop name(oop module);
 828     static void set_name(oop module, oop value);
 829 
 830     static ModuleEntry* module_entry(oop module);
 831     static void set_module_entry(oop module, ModuleEntry* module_entry);
 832 
 833   friend class JavaClasses;
 834 };
 835 
 836 // Interface to jdk.internal.reflect.ConstantPool objects
 837 class reflect_ConstantPool {
 838  private:
 839   // Note that to reduce dependencies on the JDK we compute these
 840   // offsets at run-time.
 841   static int _oop_offset;
 842 
 843   static void compute_offsets();
 844 
 845  public:
 846   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 847 
 848   // Allocation
 849   static Handle create(TRAPS);
 850 
 851   // Accessors
 852   static void set_cp(oop reflect, ConstantPool* value);
 853   static int oop_offset() {
 854     return _oop_offset;
 855   }
 856 
 857   static ConstantPool* get_cp(oop reflect);
 858 
 859   // Debugging
 860   friend class JavaClasses;
 861 };
 862 
 863 // Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects
 864 class reflect_UnsafeStaticFieldAccessorImpl {
 865  private:
 866   static int _base_offset;
 867   static void compute_offsets();
 868 
 869  public:
 870   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 871 
 872   static int base_offset() {
 873     return _base_offset;
 874   }
 875 
 876   // Debugging
 877   friend class JavaClasses;
 878 };
 879 
 880 // Interface to java.lang primitive type boxing objects:
 881 //  - java.lang.Boolean
 882 //  - java.lang.Character
 883 //  - java.lang.Float
 884 //  - java.lang.Double
 885 //  - java.lang.Byte
 886 //  - java.lang.Short
 887 //  - java.lang.Integer
 888 //  - java.lang.Long
 889 
 890 // This could be separated out into 8 individual classes.
 891 
 892 class java_lang_boxing_object: AllStatic {
 893  private:
 894   enum {
 895    hc_value_offset = 0
 896   };
 897   static int value_offset;
 898   static int long_value_offset;
 899 
 900   static oop initialize_and_allocate(BasicType type, TRAPS);
 901  public:
 902   // Allocation. Returns a boxed value, or NULL for invalid type.
 903   static oop create(BasicType type, jvalue* value, TRAPS);
 904   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 905   static BasicType get_value(oop box, jvalue* value);
 906   static BasicType set_value(oop box, jvalue* value);
 907   static BasicType basic_type(oop box);
 908   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 909   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 910   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 911   static void print(BasicType type, jvalue* value, outputStream* st);
 912 
 913   static int value_offset_in_bytes(BasicType type) {
 914     return ( type == T_LONG || type == T_DOUBLE ) ? long_value_offset :
 915                                                     value_offset;
 916   }
 917 
 918   // Debugging
 919   friend class JavaClasses;
 920 };
 921 
 922 
 923 
 924 // Interface to java.lang.ref.Reference objects
 925 
 926 class java_lang_ref_Reference: AllStatic {
 927  public:
 928   enum {
 929    hc_referent_offset   = 0,
 930    hc_queue_offset      = 1,
 931    hc_next_offset       = 2,
 932    hc_discovered_offset = 3  // Is not last, see SoftRefs.
 933   };
 934 
 935   static int referent_offset;
 936   static int queue_offset;
 937   static int next_offset;
 938   static int discovered_offset;
 939 
 940   // Accessors
 941   static inline oop referent(oop ref);
 942   static inline void set_referent(oop ref, oop value);
 943   static inline void set_referent_raw(oop ref, oop value);
 944   static inline HeapWord* referent_addr_raw(oop ref);
 945   static inline oop next(oop ref);
 946   static inline void set_next(oop ref, oop value);
 947   static inline void set_next_raw(oop ref, oop value);
 948   static inline HeapWord* next_addr_raw(oop ref);
 949   static inline oop discovered(oop ref);
 950   static inline void set_discovered(oop ref, oop value);
 951   static inline void set_discovered_raw(oop ref, oop value);
 952   static inline HeapWord* discovered_addr_raw(oop ref);
 953   static inline oop queue(oop ref);
 954   static inline void set_queue(oop ref, oop value);
 955   static bool is_referent_field(oop obj, ptrdiff_t offset);
 956   static inline bool is_final(oop ref);
 957   static inline bool is_phantom(oop ref);
 958 };
 959 
 960 
 961 // Interface to java.lang.ref.SoftReference objects
 962 
 963 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
 964  public:
 965   static int timestamp_offset;
 966   static int static_clock_offset;
 967 
 968   // Accessors
 969   static jlong timestamp(oop ref);
 970 
 971   // Accessors for statics
 972   static jlong clock();
 973   static void set_clock(jlong value);
 974 
 975   static void compute_offsets();
 976   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 977 };
 978 
 979 // Interface to java.lang.invoke.MethodHandle objects
 980 
 981 class MethodHandleEntry;
 982 
 983 class java_lang_invoke_MethodHandle: AllStatic {
 984   friend class JavaClasses;
 985 
 986  private:
 987   static int _type_offset;               // the MethodType of this MH
 988   static int _form_offset;               // the LambdaForm of this MH
 989 
 990   static void compute_offsets();
 991 
 992  public:
 993   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 994 
 995   // Accessors
 996   static oop            type(oop mh);
 997   static void       set_type(oop mh, oop mtype);
 998 
 999   static oop            form(oop mh);
1000   static void       set_form(oop mh, oop lform);
1001 
1002   // Testers
1003   static bool is_subclass(Klass* klass) {
1004     return klass-&gt;is_subclass_of(SystemDictionary::MethodHandle_klass());
1005   }
1006   static bool is_instance(oop obj);
1007 
1008   // Accessors for code generation:
1009   static int type_offset_in_bytes()             { return _type_offset; }
1010   static int form_offset_in_bytes()             { return _form_offset; }
1011 };
1012 
1013 // Interface to java.lang.invoke.DirectMethodHandle objects
1014 
1015 class java_lang_invoke_DirectMethodHandle: AllStatic {
1016   friend class JavaClasses;
1017 
1018  private:
1019   static int _member_offset;               // the MemberName of this DMH
1020 
1021   static void compute_offsets();
1022 
1023  public:
1024   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1025 
1026   // Accessors
1027   static oop  member(oop mh);
1028 
1029   // Testers
1030   static bool is_subclass(Klass* klass) {
1031     return klass-&gt;is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
1032   }
1033   static bool is_instance(oop obj);
1034 
1035   // Accessors for code generation:
1036   static int member_offset_in_bytes()           { return _member_offset; }
1037 };
1038 
1039 // Interface to java.lang.invoke.LambdaForm objects
1040 // (These are a private interface for managing adapter code generation.)
1041 
1042 class java_lang_invoke_LambdaForm: AllStatic {
1043   friend class JavaClasses;
1044 
1045  private:
1046   static int _vmentry_offset;  // type is MemberName
1047 
1048   static void compute_offsets();
1049 
1050  public:
1051   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1052 
1053   // Accessors
1054   static oop            vmentry(oop lform);
1055   static void       set_vmentry(oop lform, oop invoker);
1056 
1057   // Testers
1058   static bool is_subclass(Klass* klass) {
1059     return SystemDictionary::LambdaForm_klass() != NULL &amp;&amp;
1060       klass-&gt;is_subclass_of(SystemDictionary::LambdaForm_klass());
1061   }
1062   static bool is_instance(oop obj);
1063 
1064   // Accessors for code generation:
1065   static int vmentry_offset_in_bytes()          { return _vmentry_offset; }
1066 };
1067 
1068 
1069 // Interface to java.lang.invoke.MemberName objects
1070 // (These are a private interface for Java code to query the class hierarchy.)
1071 
1072 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1073   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1074   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1075 
1076 class java_lang_invoke_ResolvedMethodName : AllStatic {
1077   friend class JavaClasses;
1078 
1079   static int _vmtarget_offset;
1080   static int _vmholder_offset;
1081 
1082   static void compute_offsets();
1083  public:
1084   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1085 
1086   static int vmtarget_offset_in_bytes() { return _vmtarget_offset; }
1087 
1088   static Method* vmtarget(oop resolved_method);
1089   static void set_vmtarget(oop resolved_method, Method* method);
1090 
1091   static void set_vmholder(oop resolved_method, oop holder);
1092 
1093   // find or create resolved member name
1094   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1095 
1096   static bool is_instance(oop resolved_method);
1097 };
1098 
1099 
1100 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1101   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1102 
1103 
1104 class java_lang_invoke_MemberName: AllStatic {
1105   friend class JavaClasses;
1106 
1107  private:
1108   // From java.lang.invoke.MemberName:
1109   //    private Class&lt;?&gt;   clazz;       // class in which the method is defined
1110   //    private String     name;        // may be null if not yet materialized
1111   //    private Object     type;        // may be null if not yet materialized
1112   //    private int        flags;       // modifier bits; see reflect.Modifier
1113   //    private ResolvedMethodName method;    // holds VM-specific target value
1114   //    private intptr_t   vmindex;     // member index within class or interface
1115   static int _clazz_offset;
1116   static int _name_offset;
1117   static int _type_offset;
1118   static int _flags_offset;
1119   static int _method_offset;
1120   static int _vmindex_offset;
1121 
1122   static void compute_offsets();
1123 
1124  public:
1125   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1126   // Accessors
1127   static oop            clazz(oop mname);
1128   static void       set_clazz(oop mname, oop clazz);
1129 
1130   static oop            type(oop mname);
1131   static void       set_type(oop mname, oop type);
1132 
1133   static oop            name(oop mname);
1134   static void       set_name(oop mname, oop name);
1135 
1136   static int            flags(oop mname);
1137   static void       set_flags(oop mname, int flags);
1138 
1139   // Link through ResolvedMethodName field to get Method*
1140   static Method*        vmtarget(oop mname);
1141   static void       set_method(oop mname, oop method);
1142 
1143   static intptr_t       vmindex(oop mname);
1144   static void       set_vmindex(oop mname, intptr_t index);
1145 
1146   // Testers
1147   static bool is_subclass(Klass* klass) {
1148     return klass-&gt;is_subclass_of(SystemDictionary::MemberName_klass());
1149   }
1150   static bool is_instance(oop obj);
1151 
1152   static bool is_method(oop obj);
1153 
1154   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1155   enum {
1156     MN_IS_METHOD             = 0x00010000, // method (not object constructor)
1157     MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, // object constructor
1158     MN_IS_FIELD              = 0x00040000, // field
1159     MN_IS_TYPE               = 0x00080000, // nested type
1160     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
1161     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
1162     MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1163     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1164     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
1165     MN_SEARCH_INTERFACES     = 0x00200000  // walk implemented interfaces
1166   };
1167 
1168   // Accessors for code generation:
1169   static int clazz_offset_in_bytes()            { return _clazz_offset; }
1170   static int type_offset_in_bytes()             { return _type_offset; }
1171   static int name_offset_in_bytes()             { return _name_offset; }
1172   static int flags_offset_in_bytes()            { return _flags_offset; }
1173   static int method_offset_in_bytes()           { return _method_offset; }
1174   static int vmindex_offset_in_bytes()          { return _vmindex_offset; }
1175 };
1176 
1177 
1178 // Interface to java.lang.invoke.MethodType objects
1179 
1180 class java_lang_invoke_MethodType: AllStatic {
1181   friend class JavaClasses;
1182 
1183  private:
1184   static int _rtype_offset;
1185   static int _ptypes_offset;
1186 
1187   static void compute_offsets();
1188 
1189  public:
1190   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1191   // Accessors
1192   static oop            rtype(oop mt);
1193   static objArrayOop    ptypes(oop mt);
1194 
1195   static oop            ptype(oop mt, int index);
1196   static int            ptype_count(oop mt);
1197 
1198   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1199   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1200 
1201   static Symbol*        as_signature(oop mt, bool intern_if_not_found);
1202   static void           print_signature(oop mt, outputStream* st);
1203 
1204   static bool is_instance(oop obj);
1205 
1206   static bool equals(oop mt1, oop mt2);
1207 
1208   // Accessors for code generation:
1209   static int rtype_offset_in_bytes()            { return _rtype_offset; }
1210   static int ptypes_offset_in_bytes()           { return _ptypes_offset; }
1211 };
1212 
1213 
1214 // Interface to java.lang.invoke.CallSite objects
1215 
1216 class java_lang_invoke_CallSite: AllStatic {
1217   friend class JavaClasses;
1218 
1219 private:
1220   static int _target_offset;
1221   static int _context_offset;
1222 
1223   static void compute_offsets();
1224 
1225 public:
1226   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1227   // Accessors
1228   static oop              target(          oop site);
1229   static void         set_target(          oop site, oop target);
1230   static void         set_target_volatile( oop site, oop target);
1231 
1232   static oop context_no_keepalive(oop site);
1233 
1234   // Testers
1235   static bool is_subclass(Klass* klass) {
1236     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1237   }
1238   static bool is_instance(oop obj);
1239 
1240   // Accessors for code generation:
1241   static int target_offset_in_bytes()           { return _target_offset; }
1242 };
1243 
1244 // Interface to java.lang.invoke.ConstantCallSite objects
1245 
1246 class java_lang_invoke_ConstantCallSite: AllStatic {
1247   friend class JavaClasses;
1248 
1249 private:
1250   static int _is_frozen_offset;
1251 
1252   static void compute_offsets();
1253 
1254 public:
1255   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1256   // Accessors
1257   static jboolean is_frozen(oop site);
1258 
1259   // Testers
1260   static bool is_subclass(Klass* klass) {
1261     return klass-&gt;is_subclass_of(SystemDictionary::ConstantCallSite_klass());
1262   }
1263   static bool is_instance(oop obj);
1264 };
1265 
1266 // Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects
1267 
1268 #define CALLSITECONTEXT_INJECTED_FIELDS(macro) \
1269   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \
1270   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)
1271 
1272 class DependencyContext;
1273 
1274 class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {
1275   friend class JavaClasses;
1276 
1277 private:
1278   static int _vmdependencies_offset;
1279   static int _last_cleanup_offset;
1280 
1281   static void compute_offsets();
1282 
1283 public:
1284   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1285   // Accessors
1286   static DependencyContext vmdependencies(oop context);
1287 
1288   // Testers
1289   static bool is_subclass(Klass* klass) {
1290     return klass-&gt;is_subclass_of(SystemDictionary::Context_klass());
1291   }
1292   static bool is_instance(oop obj);
1293 };
1294 
1295 // Interface to java.security.AccessControlContext objects
1296 
1297 class java_security_AccessControlContext: AllStatic {
1298  private:
1299   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
1300   // so we compute the offsets at startup rather than hard-wiring them.
1301   static int _context_offset;
1302   static int _privilegedContext_offset;
1303   static int _isPrivileged_offset;
1304   static int _isAuthorized_offset;
1305 
1306   static void compute_offsets();
1307  public:
1308   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1309   static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);
1310 
1311   // Debugging/initialization
1312   friend class JavaClasses;
1313 };
1314 
1315 
1316 // Interface to java.lang.ClassLoader objects
1317 
1318 #define CLASSLOADER_INJECTED_FIELDS(macro)                            \
1319   macro(java_lang_ClassLoader, loader_data,  intptr_signature, false)
1320 
1321 class java_lang_ClassLoader : AllStatic {
1322  private:
1323   static int _loader_data_offset;
1324   static bool offsets_computed;
1325   static int parent_offset;
1326   static int parallelCapable_offset;
1327   static int name_offset;
1328   static int nameAndId_offset;
1329   static int unnamedModule_offset;
1330 
1331  public:
1332   static void compute_offsets();
1333   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1334 
1335   static ClassLoaderData* loader_data_acquire(oop loader);
1336   static ClassLoaderData* loader_data_raw(oop loader);
1337   static void release_set_loader_data(oop loader, ClassLoaderData* new_data);
1338 
1339   static oop parent(oop loader);
1340   static oop name(oop loader);
1341   static oop nameAndId(oop loader);
1342   static bool isAncestor(oop loader, oop cl);
1343 
1344   // Support for parallelCapable field
1345   static bool parallelCapable(oop the_class_mirror);
1346 
1347   static bool is_trusted_loader(oop loader);
1348 
1349   // Return true if this is one of the class loaders associated with
1350   // the generated bytecodes for reflection.
1351   static bool is_reflection_class_loader(oop loader);
1352 
1353   // Fix for 4474172
1354   static oop  non_reflection_class_loader(oop loader);
1355 
1356   // Testers
1357   static bool is_subclass(Klass* klass) {
1358     return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass());
1359   }
1360   static bool is_instance(oop obj);
1361 
1362   static oop unnamedModule(oop loader);
1363 
1364   // Debugging
1365   friend class JavaClasses;
1366   friend class ClassFileParser; // access to number_of_fake_fields
1367 };
1368 
1369 
1370 // Interface to java.lang.System objects
1371 
1372 class java_lang_System : AllStatic {
1373  private:
1374   static int  static_in_offset;
1375   static int static_out_offset;
1376   static int static_err_offset;
1377   static int static_security_offset;
1378 
1379  public:
1380   static int  in_offset_in_bytes();
1381   static int out_offset_in_bytes();
1382   static int err_offset_in_bytes();
1383 
1384   static void compute_offsets();
1385   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1386 
1387   // Debugging
1388   friend class JavaClasses;
1389 };
1390 
1391 
1392 // Interface to java.lang.StackTraceElement objects
1393 
1394 class java_lang_StackTraceElement: AllStatic {
1395  private:
1396   static int declaringClassObject_offset;
1397   static int classLoaderName_offset;
1398   static int moduleName_offset;
1399   static int moduleVersion_offset;
1400   static int declaringClass_offset;
1401   static int methodName_offset;
1402   static int fileName_offset;
1403   static int lineNumber_offset;
1404 
1405   // Setters
1406   static void set_classLoaderName(oop element, oop value);
1407   static void set_moduleName(oop element, oop value);
1408   static void set_moduleVersion(oop element, oop value);
1409   static void set_declaringClass(oop element, oop value);
1410   static void set_methodName(oop element, oop value);
1411   static void set_fileName(oop element, oop value);
1412   static void set_lineNumber(oop element, int value);
1413   static void set_declaringClassObject(oop element, oop value);
1414 
1415   static void decode_file_and_line(Handle java_mirror, InstanceKlass* holder, int version,
1416                                    const methodHandle&amp; method, int bci,
1417                                    Symbol*&amp; source, oop&amp; source_file, int&amp; line_number, TRAPS);
1418 
1419  public:
1420   // Create an instance of StackTraceElement
1421   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1422 
1423   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
1424                       int version, int bci, Symbol* name, TRAPS);
1425 
1426   static void compute_offsets();
1427   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1428 
1429 #if INCLUDE_JVMCI
1430   static void decode(const methodHandle&amp; method, int bci, Symbol*&amp; fileName, int&amp; lineNumber, TRAPS);
1431 #endif
1432 
1433   // Debugging
1434   friend class JavaClasses;
1435 };
1436 
1437 
1438 class Backtrace: AllStatic {
1439  public:
1440   // Helper backtrace functions to store bci|version together.
1441   static int merge_bci_and_version(int bci, int version);
1442   static int merge_mid_and_cpref(int mid, int cpref);
1443   static int bci_at(unsigned int merged);
1444   static int version_at(unsigned int merged);
1445   static int mid_at(unsigned int merged);
1446   static int cpref_at(unsigned int merged);
1447   static int get_line_number(Method* method, int bci);
1448   static Symbol* get_source_file_name(InstanceKlass* holder, int version);
1449 
1450   // Debugging
1451   friend class JavaClasses;
1452 };
1453 
1454 // Interface to java.lang.StackFrameInfo objects
1455 
1456 #define STACKFRAMEINFO_INJECTED_FIELDS(macro)                      \
1457   macro(java_lang_StackFrameInfo, version, short_signature, false)
1458 
1459 class java_lang_StackFrameInfo: AllStatic {
1460 private:
1461   static int _memberName_offset;
1462   static int _bci_offset;
1463   static int _version_offset;
1464 
1465   static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);
1466 
1467 public:
1468   // Setters
1469   static void set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS);
1470   static void set_bci(oop info, int value);
1471 
1472   static void set_version(oop info, short value);
1473 
1474   static void compute_offsets();
1475   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1476 
1477   static void to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS);
1478 
1479   // Debugging
1480   friend class JavaClasses;
1481 };
1482 
1483 class java_lang_LiveStackFrameInfo: AllStatic {
1484  private:
1485   static int _monitors_offset;
1486   static int _locals_offset;
1487   static int _operands_offset;
1488   static int _mode_offset;
1489 
1490  public:
1491   static void set_monitors(oop info, oop value);
1492   static void set_locals(oop info, oop value);
1493   static void set_operands(oop info, oop value);
1494   static void set_mode(oop info, int value);
1495 
1496   static void compute_offsets();
1497   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1498 
1499   // Debugging
1500   friend class JavaClasses;
1501 };
1502 
1503 // Interface to java.lang.reflect.RecordComponent objects
1504 
1505 class java_lang_reflect_RecordComponent: AllStatic {
1506  private:
1507   static int clazz_offset;
1508   static int name_offset;
1509   static int type_offset;
1510   static int accessor_offset;
1511   static int signature_offset;
1512   static int annotations_offset;
1513   static int typeAnnotations_offset;
1514 
1515   // Setters
1516   static void set_clazz(oop element, oop value);
1517   static void set_name(oop element, oop value);
1518   static void set_type(oop element, oop value);
1519   static void set_accessor(oop element, oop value);
1520   static void set_signature(oop element, oop value);
1521   static void set_annotations(oop element, oop value);
1522   static void set_typeAnnotations(oop element, oop value);
1523 
1524  public:
1525   // Create an instance of RecordComponent
1526   static oop create(InstanceKlass* holder, RecordComponent* component, TRAPS);
1527 
1528   static void compute_offsets();
1529   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1530 
1531   // Debugging
1532   friend class JavaClasses;
1533 };
1534 
1535 
1536 // Interface to java.lang.AssertionStatusDirectives objects
1537 
1538 class java_lang_AssertionStatusDirectives: AllStatic {
1539  private:
1540   static int classes_offset;
1541   static int classEnabled_offset;
1542   static int packages_offset;
1543   static int packageEnabled_offset;
1544   static int deflt_offset;
1545 
1546  public:
1547   // Setters
1548   static void set_classes(oop obj, oop val);
1549   static void set_classEnabled(oop obj, oop val);
1550   static void set_packages(oop obj, oop val);
1551   static void set_packageEnabled(oop obj, oop val);
1552   static void set_deflt(oop obj, bool val);
1553 
1554   static void compute_offsets();
1555   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1556 
1557   // Debugging
1558   friend class JavaClasses;
1559 };
1560 
1561 
1562 class java_nio_Buffer: AllStatic {
1563  private:
1564   static int _limit_offset;
1565 
1566  public:
1567   static int  limit_offset();
1568   static void compute_offsets();
1569   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1570 };
1571 
1572 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1573  private:
1574   static int  _owner_offset;
1575  public:
1576   static void compute_offsets();
1577   static oop  get_owner_threadObj(oop obj);
1578   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1579 };
1580 
1581  // Interface to jdk.internal.misc.UnsafeConsants
1582 
1583 class jdk_internal_misc_UnsafeConstants : AllStatic {
1584  public:
1585   static void set_unsafe_constants();
1586   static void compute_offsets() { }
1587   static void serialize_offsets(SerializeClosure* f) { }
1588 };
1589 
1590 class java_lang_Integer : AllStatic {
1591 public:
1592   static jint value(oop obj);
1593 };
1594 
1595 class java_lang_Long : AllStatic {
1596 public:
1597   static jlong value(oop obj);
1598 };
1599 
1600 class java_lang_Character : AllStatic {
1601 public:
1602   static jchar value(oop obj);
1603 };
1604 
1605 class java_lang_Short : AllStatic {
1606 public:
1607   static jshort value(oop obj);
1608 };
1609 
1610 class java_lang_Byte : AllStatic {
1611 public:
1612   static jbyte value(oop obj);
1613 };
1614 
1615 class java_lang_Boolean : AllStatic {
1616  private:
1617   static int _static_TRUE_offset;
1618   static int _static_FALSE_offset;
1619  public:
1620   static Symbol* symbol();
1621   static void compute_offsets(InstanceKlass* k);
1622   static oop  get_TRUE(InstanceKlass *k);
1623   static oop  get_FALSE(InstanceKlass *k);
1624   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1625   static jboolean value(oop obj);
1626 };
1627 
1628 class java_lang_Integer_IntegerCache : AllStatic {
1629  private:
1630   static int _static_cache_offset;
1631  public:
1632   static Symbol* symbol();
1633   static void compute_offsets(InstanceKlass* k);
1634   static objArrayOop  cache(InstanceKlass *k);
1635   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1636 };
1637 
1638 class java_lang_Long_LongCache : AllStatic {
1639  private:
1640   static int _static_cache_offset;
1641  public:
1642   static Symbol* symbol();
1643   static void compute_offsets(InstanceKlass* k);
1644   static objArrayOop  cache(InstanceKlass *k);
1645   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1646 };
1647 
1648 class java_lang_Character_CharacterCache : AllStatic {
1649  private:
1650   static int _static_cache_offset;
1651  public:
1652   static Symbol* symbol();
1653   static void compute_offsets(InstanceKlass* k);
1654   static objArrayOop  cache(InstanceKlass *k);
1655   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1656 };
1657 
1658 class java_lang_Short_ShortCache : AllStatic {
1659  private:
1660   static int _static_cache_offset;
1661  public:
1662   static Symbol* symbol();
1663   static void compute_offsets(InstanceKlass* k);
1664   static objArrayOop  cache(InstanceKlass *k);
1665   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1666 };
1667 
1668 class java_lang_Byte_ByteCache : AllStatic {
1669  private:
1670   static int _static_cache_offset;
1671  public:
1672   static Symbol* symbol();
1673   static void compute_offsets(InstanceKlass* k);
1674   static objArrayOop  cache(InstanceKlass *k);
1675   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1676 };
1677 
1678 class jdk_internal_vm_jni_SubElementSelector : AllStatic {
1679  private:
1680   static int _arrayElementType_offset;
1681   static int _subElementType_offset;
1682   static int _offset_offset;
1683   static int _isFlattened_offset;
1684   static int _isFlattenable_offset;
1685  public:
1686   static Symbol* symbol();
1687   static void compute_offsets();
1688   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1689 
1690   static oop getArrayElementType(oop obj);
1691   static void setArrayElementType(oop obj, oop type);
1692   static oop getSubElementType(oop obj);
1693   static void setSubElementType(oop obj, oop type);
1694   static int getOffset(oop obj);
1695   static void setOffset(oop obj, int offset);
1696   static bool getIsFlattened(oop obj);
1697   static void setIsFlattened(oop obj, bool b);
1698   static bool getIsFlattenable(oop obj);
1699   static void setIsFlattenable(oop obj, bool b);
1700 };
1701 
1702 // Use to declare fields that need to be injected into Java classes
1703 // for the JVM to use.  The name_index and signature_index are
1704 // declared in vmSymbols.  The may_be_java flag is used to declare
1705 // fields that might already exist in Java but should be injected if
1706 // they don&#39;t.  Otherwise the field is unconditionally injected and
1707 // the JVM uses the injected one.  This is to ensure that name
1708 // collisions don&#39;t occur.  In general may_be_java should be false
1709 // unless there&#39;s a good reason.
1710 
1711 class InjectedField {
1712  public:
1713   const SystemDictionary::WKID klass_id;
1714   const vmSymbols::SID name_index;
1715   const vmSymbols::SID signature_index;
1716   const bool           may_be_java;
1717 
1718 
1719   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1720   Symbol* name() const      { return lookup_symbol(name_index); }
1721   Symbol* signature() const { return lookup_symbol(signature_index); }
1722 
1723   int compute_offset();
1724 
1725   // Find the Symbol for this index
1726   static Symbol* lookup_symbol(int symbol_index) {
1727     return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);
1728   }
1729 };
1730 
1731 #define DECLARE_INJECTED_FIELD_ENUM(klass, name, signature, may_be_java) \
1732   klass##_##name##_enum,
1733 
1734 #define ALL_INJECTED_FIELDS(macro)          \
1735   CLASS_INJECTED_FIELDS(macro)              \
1736   CLASSLOADER_INJECTED_FIELDS(macro)        \
1737   RESOLVEDMETHOD_INJECTED_FIELDS(macro)     \
1738   MEMBERNAME_INJECTED_FIELDS(macro)         \
1739   CALLSITECONTEXT_INJECTED_FIELDS(macro)    \
1740   STACKFRAMEINFO_INJECTED_FIELDS(macro)     \
1741   MODULE_INJECTED_FIELDS(macro)
1742 
1743 // Interface to hard-coded offset checking
1744 
1745 class JavaClasses : AllStatic {
1746  private:
1747 
1748   static InjectedField _injected_fields[];
1749 
1750   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1751  public:
1752   enum InjectedFieldID {
1753     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1754     MAX_enum
1755   };
1756 
1757   static int compute_injected_offset(InjectedFieldID id);
1758 
1759   static void compute_hard_coded_offsets();
1760   static void compute_offsets();
1761   static void check_offsets() PRODUCT_RETURN;
1762   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1763   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1764   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1765 };
1766 
1767 #undef DECLARE_INJECTED_FIELD_ENUM
1768 
1769 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
    </pre>
  </body>
</html>
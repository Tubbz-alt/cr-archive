diff a/src/hotspot/share/ci/ciInstance.cpp b/src/hotspot/share/ci/ciInstance.cpp
--- a/src/hotspot/share/ci/ciInstance.cpp
+++ b/src/hotspot/share/ci/ciInstance.cpp
@@ -51,11 +51,11 @@
     return ciType::make(java_lang_Class::primitive_type(m));
   } else {
     Klass* k = java_lang_Class::as_Klass(m);
     assert(k != NULL, "");
     if (is_indirect_type != NULL) {
-      *is_indirect_type = java_lang_Class::is_indirect_type(m);
+      *is_indirect_type = !k->is_value();
     }
     return CURRENT_THREAD_ENV->get_klass(k);
   }
 }
 
diff a/src/hotspot/share/ci/ciMethodType.cpp b/src/hotspot/share/ci/ciMethodType.cpp
--- a/src/hotspot/share/ci/ciMethodType.cpp
+++ b/src/hotspot/share/ci/ciMethodType.cpp
@@ -39,11 +39,11 @@
 }
 
 ciType* ciMethodType::rtype(bool& never_null) const {
   GUARDED_VM_ENTRY(
     oop rtype = java_lang_invoke_MethodType::rtype(get_oop());
-    never_null = (java_lang_Class::inline_type_mirror(rtype) == rtype);
+    never_null = (java_lang_Class::as_Klass(rtype)->is_value());
     return class_to_citype(rtype);
   )
 }
 
 int ciMethodType::ptype_count() const {
@@ -55,9 +55,9 @@
 }
 
 ciType* ciMethodType::ptype_at(int index, bool& never_null) const {
   GUARDED_VM_ENTRY(
     oop ptype = java_lang_invoke_MethodType::ptype(get_oop(), index);
-    never_null = (java_lang_Class::inline_type_mirror(ptype) == ptype);
+    never_null = (java_lang_Class::as_Klass(ptype)->is_value());
     return class_to_citype(ptype);
   )
 }
diff a/src/hotspot/share/ci/ciValueKlass.cpp b/src/hotspot/share/ci/ciValueKlass.cpp
--- a/src/hotspot/share/ci/ciValueKlass.cpp
+++ b/src/hotspot/share/ci/ciValueKlass.cpp
@@ -109,18 +109,18 @@
   )
 }
 
 ciInstance* ciValueKlass::inline_mirror_instance() const {
   GUARDED_VM_ENTRY(
-    oop value_mirror = to_ValueKlass()->value_mirror();
-    return CURRENT_ENV->get_instance(value_mirror);
+    oop mirror = to_ValueKlass()->java_mirror();
+    return CURRENT_ENV->get_instance(mirror);
   )
 }
 
 ciInstance* ciValueKlass::indirect_mirror_instance() const {
   GUARDED_VM_ENTRY(
-    oop mirror = to_ValueKlass()->indirect_mirror();
+    oop mirror = to_ValueKlass()->ref_mirror();
     return CURRENT_ENV->get_instance(mirror);
   )
 }
 
 bool ciValueKlass::contains_oops() const {
diff a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -955,27 +955,19 @@
     if (k->is_array_klass()) {
       if (k->is_valueArray_klass()) {
         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)->element_klass();
         assert(element_klass->is_value(), "Must be value type component");
         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));
-        comp_mirror = Handle(THREAD, vk->value_mirror());
+        comp_mirror = Handle(THREAD, vk->java_mirror());
       } else if (k->is_typeArray_klass()) {
         BasicType type = TypeArrayKlass::cast(k)->element_type();
         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
       } else {
         assert(k->is_objArray_klass(), "Must be");
         Klass* element_klass = ObjArrayKlass::cast(k)->element_klass();
         assert(element_klass != NULL, "Must have an element klass");
-        if (element_klass->is_value()) {
-          ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));
-          assert(vk->java_mirror() == vk->value_mirror(), "primary mirror is the value mirror");
-          assert(vk->indirect_mirror() != NULL, "must have an indirect class mirror");
-          comp_mirror = k->name()->is_Q_array_signature() ? Handle(THREAD, vk->value_mirror())
-                                                          : Handle(THREAD, vk->indirect_mirror());
-        } else {
-          comp_mirror = Handle(THREAD, element_klass->java_mirror());
-        }
+        comp_mirror = Handle(THREAD, element_klass->java_mirror());
       }
       assert(comp_mirror() != NULL, "must have a mirror");
 
       // Two-way link between the array klass and its component mirror:
       // (array_klass) k -> mirror -> component_mirror -> array_klass -> k
@@ -1013,43 +1005,31 @@
       // concurrently doesn't expect a k to have a null java_mirror.
       release_set_array_klass(comp_mirror(), k);
     }
 
     if (k->is_value()) {
-      // create the secondary mirror for an inline class
-      oop indirect_mirror_oop = create_indirect_type_mirror(k, mirror, CHECK);
-      set_inline_type_mirror(mirror(), mirror());
-      set_indirect_type_mirror(mirror(), indirect_mirror_oop);
+      InstanceKlass* super = k->java_super();
+      set_val_type_mirror(mirror(), mirror());
+
+      // if the supertype is a restricted abstract class
+      if (super != SystemDictionary::Object_klass()) {
+        assert(super->access_flags().is_abstract(), "must be an abstract class");
+        oop ref_type_oop = super->java_mirror();
+        // set the reference projection type
+        set_ref_type_mirror(mirror(), ref_type_oop);
+
+        // set the value and reference projection types
+        set_val_type_mirror(ref_type_oop, mirror());
+        set_ref_type_mirror(ref_type_oop, ref_type_oop);
+      }
     }
   } else {
     assert(fixup_mirror_list() != NULL, "fixup_mirror_list not initialized");
     fixup_mirror_list()->push(k);
   }
 }
 
-// Create the secondary mirror for inline class. Sets all the fields of this java.lang.Class
-// instance with the same value as the primary mirror
-oop java_lang_Class::create_indirect_type_mirror(Klass* k, Handle mirror, TRAPS) {
-  assert(k->is_value(), "inline class");
-  // Allocate mirror (java.lang.Class instance)
-  oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())->allocate_instance(k, CHECK_0);
-  Handle indirect_mirror(THREAD, mirror_oop);
-
-  java_lang_Class::set_klass(indirect_mirror(), k);
-  java_lang_Class::set_static_oop_field_count(indirect_mirror(), static_oop_field_count(mirror()));
-  // ## do we need to set init lock?
-  java_lang_Class::set_init_lock(indirect_mirror(), init_lock(mirror()));
-
-  set_protection_domain(indirect_mirror(), protection_domain(mirror()));
-  set_class_loader(indirect_mirror(), class_loader(mirror()));
-  // ## handle if java.base is not yet defined
-  set_module(indirect_mirror(), module(mirror()));
-  set_inline_type_mirror(indirect_mirror(), mirror());
-  set_indirect_type_mirror(indirect_mirror(), indirect_mirror());
-  return indirect_mirror();
-}
-
 #if INCLUDE_CDS_JAVA_HEAP
 // Clears mirror fields. Static final fields with initial values are reloaded
 // from constant pool. The object identity hash is in the object header and is
 // not affected.
 class ResetMirrorField: public FieldClosure {
@@ -1197,11 +1177,11 @@
       return NULL;
     }
   }
 
   if (k->is_value()) {
-    // Values have a mirror and an indirect mirror. Don't handle this for now. TODO:CDS
+    // Values have a val type mirror and a ref type mirror. Don't handle this for now. TODO:CDS
     k->set_java_mirror_handle(NULL);
     return NULL;
   }
 
   // Now start archiving the mirror object
@@ -1486,28 +1466,28 @@
 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
   assert(_source_file_offset != 0, "must be set");
   java_class->obj_field_put(_source_file_offset, source_file);
 }
 
-oop java_lang_Class::inline_type_mirror(oop java_class) {
-  assert(_inline_mirror_offset != 0, "must be set");
-  return java_class->obj_field(_inline_mirror_offset);
+oop java_lang_Class::val_type_mirror(oop java_class) {
+  assert(_val_type_mirror_offset != 0, "must be set");
+  return java_class->obj_field(_val_type_mirror_offset);
 }
 
-void java_lang_Class::set_inline_type_mirror(oop java_class, oop mirror) {
-  assert(_inline_mirror_offset != 0, "must be set");
-  java_class->obj_field_put(_inline_mirror_offset, mirror);
+void java_lang_Class::set_val_type_mirror(oop java_class, oop mirror) {
+  assert(_val_type_mirror_offset != 0, "must be set");
+  java_class->obj_field_put(_val_type_mirror_offset, mirror);
 }
 
-oop java_lang_Class::indirect_type_mirror(oop java_class) {
-  assert(_indirect_mirror_offset != 0, "must be set");
-  return java_class->obj_field(_indirect_mirror_offset);
+oop java_lang_Class::ref_type_mirror(oop java_class) {
+  assert(_ref_type_mirror_offset != 0, "must be set");
+  return java_class->obj_field(_ref_type_mirror_offset);
 }
 
-void java_lang_Class::set_indirect_type_mirror(oop java_class, oop mirror) {
-  assert(_indirect_mirror_offset != 0, "must be set");
-  java_class->obj_field_put(_indirect_mirror_offset, mirror);
+void java_lang_Class::set_ref_type_mirror(oop java_class, oop mirror) {
+  assert(_ref_type_mirror_offset != 0, "must be set");
+  java_class->obj_field_put(_ref_type_mirror_offset, mirror);
 }
 
 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
   // This should be improved by adding a field at the Java level or by
   // introducing a new VM klass (see comment in ClassFileParser)
@@ -1564,11 +1544,11 @@
   if (name == NULL) {
     st->print("<null>");
     return;
   }
   if (is_instance)  {
-    if (is_value && (java_class == inline_type_mirror(java_class))) {
+    if (is_value) {
       st->print("Q");
     } else {
       st->print("L");
     }
   }
@@ -1590,18 +1570,11 @@
     if (!k->is_instance_klass()) {
       name = k->name();
       name->increment_refcount();
     } else {
       ResourceMark rm;
-      const char* sigstr;
-      if (k->is_value()) {
-        char c = (java_class == inline_type_mirror(java_class)) ?
-          JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;
-        sigstr = InstanceKlass::cast(k)->signature_name_of(c);
-      } else {
-        sigstr = k->signature_name();
-      }
+      const char* sigstr = k->signature_name();
       int siglen = (int) strlen(sigstr);
       if (!intern_if_not_found) {
         name = SymbolTable::probe(sigstr, siglen);
       } else {
         name = SymbolTable::new_symbol(sigstr, siglen);
@@ -1683,12 +1656,12 @@
   macro(classRedefinedCount_offset, k, "classRedefinedCount", int_signature,         false); \
   macro(_class_loader_offset,       k, "classLoader",         classloader_signature, false); \
   macro(_component_mirror_offset,   k, "componentType",       class_signature,       false); \
   macro(_module_offset,             k, "module",              module_signature,      false); \
   macro(_name_offset,               k, "name",                string_signature,      false); \
-  macro(_inline_mirror_offset,      k, "inlineType",          class_signature,       false); \
-  macro(_indirect_mirror_offset,    k, "indirectType",        class_signature,       false); \
+  macro(_val_type_mirror_offset,    k, "valType",             class_signature,       false); \
+  macro(_ref_type_mirror_offset,    k, "refType",             class_signature,       false); \
 
 void java_lang_Class::compute_offsets() {
   if (offsets_computed) {
     return;
   }
@@ -4349,12 +4322,12 @@
 int java_lang_Class::_static_oop_field_count_offset;
 int java_lang_Class::_class_loader_offset;
 int java_lang_Class::_module_offset;
 int java_lang_Class::_protection_domain_offset;
 int java_lang_Class::_component_mirror_offset;
-int java_lang_Class::_inline_mirror_offset;
-int java_lang_Class::_indirect_mirror_offset;
+int java_lang_Class::_val_type_mirror_offset;
+int java_lang_Class::_ref_type_mirror_offset;
 int java_lang_Class::_init_lock_offset;
 int java_lang_Class::_signers_offset;
 int java_lang_Class::_name_offset;
 int java_lang_Class::_source_file_offset;
 GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = NULL;
diff a/src/hotspot/share/classfile/javaClasses.hpp b/src/hotspot/share/classfile/javaClasses.hpp
--- a/src/hotspot/share/classfile/javaClasses.hpp
+++ b/src/hotspot/share/classfile/javaClasses.hpp
@@ -262,12 +262,12 @@
   static int _class_loader_offset;
   static int _module_offset;
   static int _component_mirror_offset;
   static int _name_offset;
   static int _source_file_offset;
-  static int _inline_mirror_offset;
-  static int _indirect_mirror_offset;
+  static int _val_type_mirror_offset;
+  static int _ref_type_mirror_offset;
 
   static bool offsets_computed;
   static int classRedefinedCount_offset;
 
   static GrowableArray<Klass*>* _fixup_mirror_list;
@@ -286,11 +286,10 @@
   // Instance creation
   static void create_mirror(Klass* k, Handle class_loader, Handle module,
                             Handle protection_domain, TRAPS);
   static void fixup_mirror(Klass* k, TRAPS);
   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
-  static oop  create_indirect_type_mirror(Klass* k, Handle mirror, TRAPS);
   static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
   static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 
   // Archiving
   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
@@ -322,11 +321,11 @@
   static Klass* array_klass_acquire(oop java_class);
   static void release_set_array_klass(oop java_class, Klass* klass);
   // compiler support for class operations
   static int klass_offset_in_bytes()                { return _klass_offset; }
   static int array_klass_offset_in_bytes()          { return _array_klass_offset; }
-  static int inline_mirror_offset_in_bytes()        { return _inline_mirror_offset; }
+  static int val_type_mirror_offset_in_bytes()      { return _val_type_mirror_offset; }
   static int component_mirror_offset_in_bytes()     { return _component_mirror_offset; }
   // Support for classRedefinedCount field
   static int classRedefinedCount(oop the_class_mirror);
   static void set_classRedefinedCount(oop the_class_mirror, int value);
 
@@ -339,18 +338,15 @@
 
   static oop class_loader(oop java_class);
   static void set_module(oop java_class, oop module);
   static oop module(oop java_class);
 
-  static void set_indirect_type_mirror(oop java_class, oop mirror);
-  static oop indirect_type_mirror(oop java_class);
-  static bool is_indirect_type(oop java_class) { // Must match "Class.isIndirectType()"
-    return indirect_type_mirror(java_class) == NULL || indirect_type_mirror(java_class) == java_class;
-  }
+  static void set_ref_type_mirror(oop java_class, oop mirror);
+  static oop ref_type_mirror(oop java_class);
 
-  static void set_inline_type_mirror(oop java_class, oop mirror);
-  static oop inline_type_mirror(oop java_class);
+  static void set_val_type_mirror(oop java_class, oop mirror);
+  static oop val_type_mirror(oop java_class);
 
   static oop name(Handle java_class, TRAPS);
 
   static oop source_file(oop java_class);
   static void set_source_file(oop java_class, oop source_file);
diff a/src/hotspot/share/oops/instanceKlass.cpp b/src/hotspot/share/oops/instanceKlass.cpp
--- a/src/hotspot/share/oops/instanceKlass.cpp
+++ b/src/hotspot/share/oops/instanceKlass.cpp
@@ -2752,14 +2752,10 @@
     _source_debug_extension = sde;
   }
 }
 
 const char* InstanceKlass::signature_name() const {
-  return signature_name_of(is_value() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS);
-}
-
-const char* InstanceKlass::signature_name_of(char c) const {
   int hash_len = 0;
   char hash_buf[40];
 
   // If this is an unsafe anonymous class, append a hash to make the name unique
   if (is_unsafe_anonymous()) {
@@ -2774,11 +2770,11 @@
 
   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
 
   // Add L or Q as type indicator
   int dest_index = 0;
-  dest[dest_index++] = c;
+  dest[dest_index++] = is_value() ? 'Q' : 'L';
 
   // Add the actual class name
   for (int src_index = 0; src_index < src_length; ) {
     dest[dest_index++] = src[src_index++];
   }
diff a/src/hotspot/share/oops/instanceKlass.hpp b/src/hotspot/share/oops/instanceKlass.hpp
--- a/src/hotspot/share/oops/instanceKlass.hpp
+++ b/src/hotspot/share/oops/instanceKlass.hpp
@@ -1373,11 +1373,10 @@
   static void unload_class(InstanceKlass* ik);
   static void release_C_heap_structures(InstanceKlass* ik);
 
   // Naming
   const char* signature_name() const;
-  const char* signature_name_of(char c) const;
 
   // Oop fields (and metadata) iterators
   //
   // The InstanceKlass iterators also visits the Object's klass.
 
diff a/src/hotspot/share/oops/valueKlass.hpp b/src/hotspot/share/oops/valueKlass.hpp
--- a/src/hotspot/share/oops/valueKlass.hpp
+++ b/src/hotspot/share/oops/valueKlass.hpp
@@ -181,13 +181,12 @@
 
  public:
   // Type testing
   bool is_value_slow() const        { return true; }
 
-  // value_mirror is the primary mirror
-  oop value_mirror() const    { return java_lang_Class::inline_type_mirror(java_mirror()); }
-  oop indirect_mirror() const { return java_lang_Class::indirect_type_mirror(java_mirror()); }
+  // ## Remove this function when its dependencies are removed
+  oop ref_mirror() const { return java_lang_Class::ref_type_mirror(java_mirror()); }
 
   // Casting from Klass*
   static ValueKlass* cast(Klass* k);
 
   // Use this to return the size of an instance in heap words
@@ -299,11 +298,10 @@
     return offset;
   }
 
   void set_default_value(oop val) {
     java_mirror()->obj_field_put(default_value_offset(), val);
-    indirect_mirror()->obj_field_put(default_value_offset(), val);
   }
 
   oop default_value();
   void deallocate_contents(ClassLoaderData* loader_data);
   static void cleanup(ValueKlass* ik) ;
diff a/src/hotspot/share/opto/graphKit.cpp b/src/hotspot/share/opto/graphKit.cpp
--- a/src/hotspot/share/opto/graphKit.cpp
+++ b/src/hotspot/share/opto/graphKit.cpp
@@ -3542,13 +3542,13 @@
   Node* cmp = _gvn.transform(new CmpXNode(andx, mask));
   return _gvn.transform(new BoolNode(cmp, BoolTest::eq));
 }
 
 Node* GraphKit::is_value_mirror(Node* mirror) {
-  Node* p = basic_plus_adr(mirror, java_lang_Class::inline_mirror_offset_in_bytes());
-  Node* inline_mirror = access_load_at(mirror, p, _gvn.type(p)->is_ptr(), TypeInstPtr::MIRROR->cast_to_ptr_type(TypePtr::BotPTR), T_OBJECT, IN_HEAP);
-  Node* cmp = _gvn.transform(new CmpPNode(mirror, inline_mirror));
+  Node* p = basic_plus_adr(mirror, java_lang_Class::val_type_mirror_offset_in_bytes());
+  Node* val_type_mirror = access_load_at(mirror, p, _gvn.type(p)->is_ptr(), TypeInstPtr::MIRROR->cast_to_ptr_type(TypePtr::BotPTR), T_OBJECT, IN_HEAP);
+  Node* cmp = _gvn.transform(new CmpPNode(mirror, val_type_mirror));
   return _gvn.transform(new BoolNode(cmp, BoolTest::eq));
 }
 
 // Check if 'ary' is a null-free value type array
 Node* GraphKit::gen_null_free_array_check(Node* ary) {
diff a/src/hotspot/share/opto/memnode.cpp b/src/hotspot/share/opto/memnode.cpp
--- a/src/hotspot/share/opto/memnode.cpp
+++ b/src/hotspot/share/opto/memnode.cpp
@@ -1887,11 +1887,11 @@
     BasicType bt = memory_type();
 
     // Fold component and value mirror loads
     ciInstanceKlass* ik = tinst->klass()->as_instance_klass();
     if (ik == phase->C->env()->Class_klass() && (off == java_lang_Class::component_mirror_offset_in_bytes() ||
-                                                 off == java_lang_Class::inline_mirror_offset_in_bytes())) {
+                                                 off == java_lang_Class::val_type_mirror_offset_in_bytes())) {
       ciType* mirror_type = tinst->java_mirror_type();
       if (mirror_type != NULL) {
         const Type* const_oop = TypePtr::NULL_PTR;
         if (mirror_type->is_array_klass()) {
           const_oop = TypeInstPtr::make(mirror_type->as_array_klass()->component_mirror_instance());
diff a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -581,19 +581,10 @@
   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
   assert(sub_klass != NULL && super_klass != NULL, "invalid arguments to jni_IsAssignableFrom");
   jboolean ret = sub_klass->is_subtype_of(super_klass) ?
                    JNI_TRUE : JNI_FALSE;
-  if (sub_klass == super_klass && sub_klass->is_value()) {
-    // for inline class, V <: V?
-    ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(sub_klass));
-    if (sub_mirror == super_mirror || (sub_mirror == vk->value_mirror() && super_mirror == vk->indirect_mirror())) {
-      ret = JNI_TRUE;
-    } else {
-      ret = JNI_FALSE;
-    }
-  }
   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
   return ret;
 JNI_END
 
 
diff a/src/hotspot/share/runtime/reflection.cpp b/src/hotspot/share/runtime/reflection.cpp
--- a/src/hotspot/share/runtime/reflection.cpp
+++ b/src/hotspot/share/runtime/reflection.cpp
@@ -346,14 +346,14 @@
   } else {
     Klass* k = java_lang_Class::as_Klass(element_mirror);
     if (k->is_array_klass() && ArrayKlass::cast(k)->dimension() >= MAX_DIM) {
       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
     }
-    if (java_lang_Class::is_indirect_type(element_mirror)) {
-      return oopFactory::new_objArray(k, length, THREAD);
-    } else {
+    if (k->is_value()) {
       return oopFactory::new_valueArray(k, length, THREAD);
+    } else {
+      return oopFactory::new_objArray(k, length, THREAD);
     }
   }
 }
 
 
@@ -1184,11 +1184,11 @@
 
   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
   BasicType rtype;
   if (java_lang_Class::is_primitive(return_type_mirror)) {
     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
-  } else if (java_lang_Class::inline_type_mirror(return_type_mirror) == return_type_mirror) {
+  } else if (java_lang_Class::as_Klass(return_type_mirror)->is_value()) {
     rtype = T_VALUETYPE;
   } else {
     rtype = T_OBJECT;
   }
 
diff a/src/hotspot/share/runtime/signature.cpp b/src/hotspot/share/runtime/signature.cpp
--- a/src/hotspot/share/runtime/signature.cpp
+++ b/src/hotspot/share/runtime/signature.cpp
@@ -420,17 +420,11 @@
   }
   Klass* klass = as_klass(class_loader, protection_domain, failure_mode, CHECK_NULL);
   if (klass == NULL) {
     return NULL;
   }
-  if (klass->is_value()) {
-    ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(klass));
-    return _type == T_VALUETYPE ? vk->value_mirror() : vk->indirect_mirror();
-  } else {
-    assert(_type != T_VALUETYPE, "must not be value type");
-    return klass->java_mirror();
-  }
+  return klass->java_mirror();
 }
 
 void SignatureStream::skip_to_return_type() {
   while (!at_return_type()) {
     next();
diff a/src/java.base/share/classes/java/lang/Class.java b/src/java.base/share/classes/java/lang/Class.java
--- a/src/java.base/share/classes/java/lang/Class.java
+++ b/src/java.base/share/classes/java/lang/Class.java
@@ -161,11 +161,11 @@
                               TypeDescriptor.OfField<Class<?>>,
                               Constable {
     private static final int ANNOTATION = 0x00002000;
     private static final int ENUM       = 0x00004000;
     private static final int SYNTHETIC  = 0x00001000;
-    private static final int VALUE_TYPE = 0x00000100;
+    private static final int INLINE     = 0x00000100;
 
     private static native void registerNatives();
     static {
         registerNatives();
     }
@@ -195,11 +195,11 @@
      * @return a string representation of this {@code Class} object.
      */
     public String toString() {
         return (isInlineClass() ? "inline " : "")
                + (isInterface() ? "interface " : (isPrimitive() ? "" : "class "))
-               + getName() + (isInlineClass() && isIndirectType() ? "?" : "");
+               + getName();
     }
 
     /**
      * Returns a string describing this {@code Class}, including
      * information about modifiers and type parameters.
@@ -517,94 +517,64 @@
     }
 
     /**
      * Returns {@code true} if this class is an inline class.
      *
-     * @return {@code true} if this class is an inline class.
+     * @return {@code true} if this class is an inline class
+     * @since Valhalla
      */
     public boolean isInlineClass() {
-        return (this.getModifiers() & VALUE_TYPE) != 0;
+        return (this.getModifiers() & INLINE) != 0;
     }
 
     /**
-     * Returns a {@code Class} object representing the primary type of
-     * this class.
-     *
-     * <p> For class {@code C}, {@code C.class} is the primary type of {@code C}.
-     * For a primitive type, the {@code Class} instance representing
-     * that primitive type is its primary type, for example {@code int.class}.
-     *
-     * @return the {@code Class} object representing the primary type of
-     *         this class
+     * Returns a {@code Class} object representing the <em>value projection</em>
+     * type of this class if this {@code Class} is the reference projection type
+     * of an {@linkplain #isInlineClass() inline class}.  Otherwise an empty
+     * {@link Optional} is returned.
+     *
+     * @return the {@code Class} object representing the value projection type of
+     *         this class if this class is the reference projection type of an
+     *         inline class; an empty {@link Optional} otherwise
+     * @since Valhalla
      */
-    @HotSpotIntrinsicCandidate
-    public Class<T> asPrimaryType() {
-        return isInlineClass() ? inlineType : this;
+    public Optional<Class<T>> valueType() {
+        return Optional.ofNullable(valType);
     }
 
     /**
-     * Returns a {@code Class} object representing the <em>indirect projection</em>
-     * type if this class is an {@linkplain #isInlineClass() inline class};
-     * otherwise, returns this class.
-     *
-     * <p> An inline class, {@code V}, has two {@code Class} representations,
-     * {@code V.class} and its {@linkplain #asIndirectType() indirect projection
-     * type}.  The indirect projection type is always
-     * {@linkplain #isNullableType() nullable}.
-     * The indirect projection type of a zero-default inline class
-     * is also its nullable projection type.
-     *
-     * @return the {@code Class} object representing the indirect projection type of
-     *         this class if this class is an inline class; otherwise, this class.
+     * Returns a {@code Class} object representing the <em>reference projection</em>
+     * type of this class if this class is an {@linkplain #isInlineClass() inline class}
+     * with a reference projection.
+     * If this class is an {@linkplain #isInlineClass() inline class}
+     * without a reference projection or this class is not an inline class,
+     * then this method returns an empty {@link Optional}.
+     *
+     * @return the {@code Class} object representing the value projection type of
+     *         this class if this class is the reference projection type of an
+     *         inline class; an empty {@link Optional} otherwise
+     * @since Valhalla
      */
-    @HotSpotIntrinsicCandidate
-    public Class<T> asIndirectType() {
-        return isInlineClass() ? indirectType : this;
+    public Optional<Class<T>> referenceType() {
+        return valType != null ? Optional.ofNullable(refType) : Optional.of(this);
     }
 
-    /**
-     * Returns a {@code Class} object representing the <em>nullable projection</em>
-     * type if this class is an {@linkplain #isInlineClass() inline class};
-     * otherwise, returns this class.
-     *
-     * <p> An inline class, {@code V}, has two {@code Class} representations,
-     * {@code V.class} and its {@linkplain #asIndirectType() indirect projection
-     * type}.  The indirect projection type is always
-     * {@linkplain #isNullableType() nullable}.
-     * The indirect projection type of a zero-default inline class
-     * is also its nullable projection type.
-     *
-     * @return the {@code Class} object representing the nullable projection type of
-     *         this class if this class is an inline class; otherwise, this class.
-     */
-    public Class<T> asNullableType() {
-        return asIndirectType();
-    }
-
-    /**
-     * Returns {@code true} if this class is an indirect type.
-     * An indirect type is always {@linkplain #isNullableType() nullable}.
-     *
-     * @return {@code true} if this class is an indirect type.
-     */
-    public boolean isIndirectType() {
-        return indirectType == null || this == indirectType;
+    // TO BE REMOVED together with the C2 intrinsic implementation
+    @HotSpotIntrinsicCandidate
+    private Class<T> asPrimaryType() {
+        return valType == null ? this : valType;
     }
-
-    /**
-     * Returns {@code true} if this class is a nullable type.
-     *
-     * @return {@code true} if this class is a nullable type.
-     */
-    public boolean isNullableType() {
-        return isIndirectType();
+    // TO BE REMOVED together with the C2 intrinsic implementation
+    @HotSpotIntrinsicCandidate
+    private Class<T> asIndirectType() {
+        return valType != null ? refType : this;
     }
 
     // set by VM if this class is an inline type
     // otherwise, these two fields are null
-    private transient Class<T> inlineType;
-    private transient Class<T> indirectType;
+    private transient Class<T> valType;
+    private transient Class<T> refType;
 
     /**
      * Creates a new instance of the class represented by this {@code Class}
      * object.  The class is instantiated as if by a {@code new}
      * expression with an empty argument list.  The class is initialized if it
@@ -876,11 +846,11 @@
      * <tr><th scope="row"> boolean      <td style="text-align:center"> Z
      * <tr><th scope="row"> byte         <td style="text-align:center"> B
      * <tr><th scope="row"> char         <td style="text-align:center"> C
      * <tr><th scope="row"> class or interface
      *                                   <td style="text-align:center"> L<i>classname</i>;
-     * <tr><th scope="row"> non-nullable {@linkplain #isInlineClass() inline class}
+     * <tr><th scope="row"> {@linkplain #isInlineClass() inline class}
      *                                   <td style="text-align:center"> Q<i>classname</i>;
      * <tr><th scope="row"> double       <td style="text-align:center"> D
      * <tr><th scope="row"> float        <td style="text-align:center"> F
      * <tr><th scope="row"> int          <td style="text-align:center"> I
      * <tr><th scope="row"> long         <td style="text-align:center"> J
@@ -901,12 +871,12 @@
      *     returns "Point"
      * (new Object[3]).getClass().getName()
      *     returns "[Ljava.lang.Object;"
      * (new Point[3]).getClass().getName()
      *     returns "[QPoint;"
-     * (new Point?[3][4]).getClass().getName()
-     *     returns "[[LPoint;"
+     * (new Point.ref[3][4]).getClass().getName()
+     *     returns "[[LPoint$ref;"
      * (new int[3][4][5][6][7][8][9]).getClass().getName()
      *     returns "[[[[[[[I"
      * </pre></blockquote>
      *
      * @return  the name of the class or interface
@@ -1321,24 +1291,16 @@
      * @return  the signers of this class, or null if there are no signers.  In
      *          particular, this method returns null if this {@code Class} object represents
      *          a primitive type or void.
      * @since   1.1
      */
-    public Object[] getSigners() {
-        return asPrimaryType().getSigners0();
-    }
-
-    private native Object[] getSigners0();
+    public native Object[] getSigners();
 
     /**
      * Set the signers of this class.
      */
-    void setSigners(Object[] signers) {
-        asPrimaryType().setSigners0(signers);
-    }
-
-    native void setSigners0(Object[] signers);
+    native void setSigners(Object[] signers);
 
 
     /**
      * If this {@code Class} object represents a local or anonymous
      * class within a method, returns a {@link
@@ -1693,11 +1655,11 @@
         String simpleName = getSimpleBinaryName();
         if (simpleName == null) { // top level class
             simpleName = getName();
             simpleName = simpleName.substring(simpleName.lastIndexOf('.') + 1); // strip the package name
         }
-        return isInlineClass() && isIndirectType() ? simpleName + "?" : simpleName;
+        return simpleName;
     }
 
     /**
      * Return an informative string for the name of this type.
      *
@@ -1714,11 +1676,11 @@
                     cl = cl.getComponentType();
                 } while (cl.isArray());
                 return cl.getTypeName() + "[]".repeat(dimensions);
             } catch (Throwable e) { /*FALLTHRU*/ }
         }
-        return toTypeName();
+        return getName();
     }
 
     /**
      * Returns the canonical name of the underlying class as defined
      * by <cite>The Java&trade; Language Specification</cite>, section
@@ -3608,22 +3570,14 @@
     private String methodToString(String name, Class<?>[] argTypes) {
         return getName() + '.' + name +
                 ((argTypes == null || argTypes.length == 0) ?
                 "()" :
                 Arrays.stream(argTypes)
-                        .map(c -> c == null ? "null" : c.toTypeName())
+                        .map(c -> c == null ? "null" : c.getName())
                         .collect(Collectors.joining(",", "(", ")")));
     }
 
-    /*
-     * Returns the class name appended with "?" if it is the nullable projection
-     * of an inline class.
-     */
-    private String toTypeName() {
-        return isInlineClass() && isIndirectType() ? getName() + "?" : getName();
-    }
-
     /** use serialVersionUID from JDK 1.1 for interoperability */
     @java.io.Serial
     private static final long serialVersionUID = 3206093459760846163L;
 
 
@@ -3845,19 +3799,19 @@
      * @param obj the object to be cast
      * @return the object after casting, or null if obj is null
      *
      * @throws ClassCastException if the object is not
      * {@code null} and is not assignable to the type T.
-     * @throws NullPointerException if this is not a {@linkplain #isNullableType()
-     * nullable type} and the object is {@code null}
+     * @throws NullPointerException if this is an {@linkplain #isInlineClass()
+     * inline type} and the object is {@code null}
      *
      * @since 1.5
      */
     @SuppressWarnings("unchecked")
     @HotSpotIntrinsicCandidate
     public T cast(Object obj) {
-        if (!isNullableType() && obj == null)
+        if (isInlineClass() && obj == null)
             throw new NullPointerException(getName() + " is an inline class");
 
         if (obj != null && !isInstance(obj))
             throw new ClassCastException(cannotCastMsg(obj));
         return (T) obj;
@@ -4331,11 +4285,12 @@
             return Wrapper.forPrimitiveType(this).basicTypeString();
         else if (isArray()) {
             return "[" + componentType.descriptorString();
         }
         else {
-            return "L" + getName().replace('.', '/') + ";";
+            return (isInlineClass() ? "Q" : "L")
+                    + getName().replace('.', '/') + ";";
         }
     }
 
     /**
      * Returns the component type of this {@code Class}, if it describes
diff a/src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java b/src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java
--- a/src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java
+++ b/src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java
@@ -76,11 +76,11 @@
     static DirectMethodHandle make(byte refKind, Class<?> refc, MemberName member, Class<?> callerClass) {
         MethodType mtype = member.getMethodOrFieldType();
         if (!member.isStatic()) {
             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())
                 throw new InternalError(member.toString());
-            mtype = mtype.insertParameterTypes(0, refc.asPrimaryType());
+            mtype = mtype.insertParameterTypes(0, refc);
         }
         if (!member.isField()) {
             // refKind reflects the original type of lookup via findSpecial or
             // findVirtual etc.
             switch (refKind) {
@@ -598,11 +598,11 @@
             super(mtype, form, member, staticBase, staticOffset);
         }
 
         // zero-default inline type is not-nullable
         @Override Object checkCast(Object obj) {
-            assert !fieldType.isNullableType() : "null-default inline type not yet supported";
+            assert fieldType.isInlineClass() : "null-default inline type not yet supported";
             return fieldType.cast(Objects.requireNonNull(obj));
         }
         @Override
         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
             return new InlineStaticAccessor(mt, lf, member, staticBase, staticOffset);
diff a/src/java.base/share/classes/java/lang/invoke/InfoFromMemberName.java b/src/java.base/share/classes/java/lang/invoke/InfoFromMemberName.java
--- a/src/java.base/share/classes/java/lang/invoke/InfoFromMemberName.java
+++ b/src/java.base/share/classes/java/lang/invoke/InfoFromMemberName.java
@@ -113,11 +113,11 @@
             if (MethodHandleNatives.refKindIsObjectConstructor(refKind) &&
                 methodType.returnType() != void.class) {
                 // object constructor
                 throw new IllegalArgumentException("object constructor must be of void return type");
             } else if (MethodHandleNatives.refKindIsMethod(refKind) &&
-                       methodType.returnType() != defc.asPrimaryType()) {
+                       methodType.returnType() != defc) {
                 // static init factory
                 throw new IllegalArgumentException("static constructor must be of " + getDeclaringClass().getName());
             }
 
             return isPublic ? defc.getConstructor(methodType.parameterArray())
diff a/src/java.base/share/classes/java/lang/invoke/MemberName.java b/src/java.base/share/classes/java/lang/invoke/MemberName.java
--- a/src/java.base/share/classes/java/lang/invoke/MemberName.java
+++ b/src/java.base/share/classes/java/lang/invoke/MemberName.java
@@ -191,15 +191,14 @@
      *  For non-static methods or constructors, this is the type with a leading parameter,
      *  a reference to declaring class.  For static methods, it is the same as the declared type.
      */
     public MethodType getInvocationType() {
         MethodType itype = getMethodOrFieldType();
-        Class<?> c = clazz.asPrimaryType();
         if (isObjectConstructor() && getReferenceKind() == REF_newInvokeSpecial)
-            return itype.changeReturnType(c);
+            return itype.changeReturnType(clazz);
         if (!isStatic())
-            return itype.insertParameterTypes(0, c);
+            return itype.insertParameterTypes(0, clazz);
         return itype;
     }
 
     /** Utility method producing the parameter types of the method type. */
     public Class<?>[] getParameterTypes() {
@@ -479,18 +478,18 @@
 
     /** Query whether this member is a field of an inline class. */
     public boolean isInlineable()  {
         if (isField()) {
             Class<?> type = getFieldType();
-            return type.isInlineClass() && type == type.asPrimaryType();
+            return type.isInlineClass();
         }
         return false;
     }
 
     public boolean isIndirect()  {
         if (isField()) {
-            return getFieldType().isIndirectType();
+            return !getFieldType().isInlineClass();
         }
         return false;
     }
 
     static final String CONSTRUCTOR_NAME = "<init>";  // the ever-popular
@@ -955,23 +954,14 @@
         //buf.append("#").append(System.identityHashCode(this));
         return buf.toString();
     }
     private static String getName(Object obj) {
         if (obj instanceof Class<?>)
-            return toTypeName((Class<?>)obj);
+            return ((Class<?>)obj).getName();
         return String.valueOf(obj);
     }
 
-    /*
-     * Returns the class name appended with "?" if it is the nullable projection
-     * of an inline class.
-     */
-    private static String toTypeName(Class<?> type) {
-        return type.isInlineClass() && type.isIndirectType() ? type.getName() + "?" : type.getName();
-    }
-
-
     public IllegalAccessException makeAccessException(String message, Object from) {
         message = message + ": "+ toString();
         if (from != null)  {
             if (from == MethodHandles.publicLookup()) {
                 message += ", from public Lookup";
diff a/src/java.base/share/classes/java/lang/invoke/ValueBootstrapMethods.java b/src/java.base/share/classes/java/lang/invoke/ValueBootstrapMethods.java
--- a/src/java.base/share/classes/java/lang/invoke/ValueBootstrapMethods.java
+++ b/src/java.base/share/classes/java/lang/invoke/ValueBootstrapMethods.java
@@ -169,11 +169,11 @@
         /*
          * Produces a MethodHandle that returns boolean if two value instances
          * of the given inline class are substitutable.
          */
         static MethodHandle inlineTypeEquals(Class<?> type) {
-            assert type.isInlineClass() && !type.isIndirectType();
+            assert type.isInlineClass();
             MethodType mt = methodType(boolean.class, type, type);
             MethodHandles.Lookup lookup = new MethodHandles.Lookup(type);
             MethodHandle[] getters = getters(lookup, TYPE_SORTER);
             MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);
             MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class).asType(mt);
@@ -598,11 +598,11 @@
     }
 
     // store the method handle for value types in ClassValue
     private static ClassValue<MethodHandle> SUBST_TEST_METHOD_HANDLES = new ClassValue<>() {
         @Override protected MethodHandle computeValue(Class<?> type) {
-            return MethodHandleBuilder.inlineTypeEquals(type.asPrimaryType());
+            return MethodHandleBuilder.inlineTypeEquals(type);
         }
     };
 
     private static final Comparator<MethodHandle> TYPE_SORTER = (mh1, mh2) -> {
         // sort the getters with the return type
diff a/src/java.base/share/classes/java/lang/invoke/VarHandle.java b/src/java.base/share/classes/java/lang/invoke/VarHandle.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandle.java
+++ b/src/java.base/share/classes/java/lang/invoke/VarHandle.java
@@ -1549,15 +1549,10 @@
 
         MethodType accessModeType(Class<?> receiver, Class<?> value,
                                   Class<?>... intermediate) {
             Class<?>[] ps;
             int i;
-            // the field type (value) is mapped to the return type of MethodType
-            // the receiver type is mapped to a parameter type of MethodType
-            // So use the value type as receiver may be a box type.
-            if (receiver != null && receiver.isInlineClass())
-                receiver = receiver.asPrimaryType();
             switch (this) {
                 case GET:
                     ps = allocateParameters(0, receiver, intermediate);
                     fillParameters(ps, receiver, intermediate);
                     return MethodType.methodType(value, ps);
diff a/src/java.base/share/classes/java/lang/invoke/X-VarHandle.java.template b/src/java.base/share/classes/java/lang/invoke/X-VarHandle.java.template
--- a/src/java.base/share/classes/java/lang/invoke/X-VarHandle.java.template
+++ b/src/java.base/share/classes/java/lang/invoke/X-VarHandle.java.template
@@ -109,11 +109,11 @@
         }
 
 #if[Object]
         @ForceInline
         static Object checkCast(FieldInstanceReadWrite handle, $type$ value) {
-            if (!handle.fieldType.isNullableType())
+            if (handle.fieldType.isInlineClass())
                 Objects.requireNonNull(value);
             return handle.fieldType.cast(value);
         }
 #end[Object]
 
@@ -398,11 +398,11 @@
             super(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM);
         }
 
 #if[Object]
         static Object checkCast(FieldStaticReadWrite handle, $type$ value) {
-            if (!handle.fieldType.isNullableType())
+            if (handle.fieldType.isInlineClass())
                 Objects.requireNonNull(value);
             return handle.fieldType.cast(value);
         }
 #end[Object]
 
@@ -655,11 +655,11 @@
         }
 
 #if[Object]
         @ForceInline
         static Object runtimeTypeCheck(Array handle, Object[] oarray, Object value) {
-            if (!handle.componentType.isNullableType())
+            if (handle.componentType.isInlineClass())
                  Objects.requireNonNull(value);
 
             if (handle.arrayType == oarray.getClass()) {
                 // Fast path: static array type same as argument array type
                 return handle.componentType.cast(value);
diff a/src/java.base/share/classes/java/lang/reflect/Field.java b/src/java.base/share/classes/java/lang/reflect/Field.java
--- a/src/java.base/share/classes/java/lang/reflect/Field.java
+++ b/src/java.base/share/classes/java/lang/reflect/Field.java
@@ -776,12 +776,10 @@
     @CallerSensitive
     @ForceInline // to ensure Reflection.getCallerClass optimization
     public void set(Object obj, Object value)
         throws IllegalArgumentException, IllegalAccessException
     {
-        ensureNotValueClass();
-
         if (!override) {
             Class<?> caller = Reflection.getCallerClass();
             checkAccess(caller, obj);
         }
         getFieldAccessor(obj).set(obj, value);
@@ -814,12 +812,10 @@
     @CallerSensitive
     @ForceInline // to ensure Reflection.getCallerClass optimization
     public void setBoolean(Object obj, boolean z)
         throws IllegalArgumentException, IllegalAccessException
     {
-        ensureNotValueClass();
-
         if (!override) {
             Class<?> caller = Reflection.getCallerClass();
             checkAccess(caller, obj);
         }
         getFieldAccessor(obj).setBoolean(obj, z);
@@ -852,12 +848,10 @@
     @CallerSensitive
     @ForceInline // to ensure Reflection.getCallerClass optimization
     public void setByte(Object obj, byte b)
         throws IllegalArgumentException, IllegalAccessException
     {
-        ensureNotValueClass();
-
         if (!override) {
             Class<?> caller = Reflection.getCallerClass();
             checkAccess(caller, obj);
         }
         getFieldAccessor(obj).setByte(obj, b);
@@ -890,12 +884,10 @@
     @CallerSensitive
     @ForceInline // to ensure Reflection.getCallerClass optimization
     public void setChar(Object obj, char c)
         throws IllegalArgumentException, IllegalAccessException
     {
-        ensureNotValueClass();
-
         if (!override) {
             Class<?> caller = Reflection.getCallerClass();
             checkAccess(caller, obj);
         }
         getFieldAccessor(obj).setChar(obj, c);
@@ -928,12 +920,10 @@
     @CallerSensitive
     @ForceInline // to ensure Reflection.getCallerClass optimization
     public void setShort(Object obj, short s)
         throws IllegalArgumentException, IllegalAccessException
     {
-        ensureNotValueClass();
-
         if (!override) {
             Class<?> caller = Reflection.getCallerClass();
             checkAccess(caller, obj);
         }
         getFieldAccessor(obj).setShort(obj, s);
@@ -966,12 +956,10 @@
     @CallerSensitive
     @ForceInline // to ensure Reflection.getCallerClass optimization
     public void setInt(Object obj, int i)
         throws IllegalArgumentException, IllegalAccessException
     {
-        ensureNotValueClass();
-
         if (!override) {
             Class<?> caller = Reflection.getCallerClass();
             checkAccess(caller, obj);
         }
         getFieldAccessor(obj).setInt(obj, i);
@@ -1004,12 +992,10 @@
     @CallerSensitive
     @ForceInline // to ensure Reflection.getCallerClass optimization
     public void setLong(Object obj, long l)
         throws IllegalArgumentException, IllegalAccessException
     {
-        ensureNotValueClass();
-
         if (!override) {
             Class<?> caller = Reflection.getCallerClass();
             checkAccess(caller, obj);
         }
         getFieldAccessor(obj).setLong(obj, l);
@@ -1042,12 +1028,10 @@
     @CallerSensitive
     @ForceInline // to ensure Reflection.getCallerClass optimization
     public void setFloat(Object obj, float f)
         throws IllegalArgumentException, IllegalAccessException
     {
-        ensureNotValueClass();
-
         if (!override) {
             Class<?> caller = Reflection.getCallerClass();
             checkAccess(caller, obj);
         }
         getFieldAccessor(obj).setFloat(obj, f);
@@ -1080,12 +1064,10 @@
     @CallerSensitive
     @ForceInline // to ensure Reflection.getCallerClass optimization
     public void setDouble(Object obj, double d)
         throws IllegalArgumentException, IllegalAccessException
     {
-        ensureNotValueClass();
-
         if (!override) {
             Class<?> caller = Reflection.getCallerClass();
             checkAccess(caller, obj);
         }
         getFieldAccessor(obj).setDouble(obj, d);
@@ -1098,20 +1080,10 @@
         checkAccess(caller, clazz,
                     Modifier.isStatic(modifiers) ? null : obj.getClass(),
                     modifiers);
     }
 
-    /*
-     * Ensure the declaring class is not an inline class.
-     */
-    private void ensureNotValueClass() throws IllegalAccessException {
-        if (clazz.isInlineClass()) {
-            throw new IllegalAccessException("cannot set field \"" + this + "\" of inline class "
-                + clazz.getName());
-        }
-    }
-
     // security check is done before calling this method
     private FieldAccessor getFieldAccessor(Object obj)
         throws IllegalAccessException
     {
         boolean ov = override;
diff a/src/java.base/share/classes/java/lang/reflect/Proxy.java b/src/java.base/share/classes/java/lang/reflect/Proxy.java
--- a/src/java.base/share/classes/java/lang/reflect/Proxy.java
+++ b/src/java.base/share/classes/java/lang/reflect/Proxy.java
@@ -849,12 +849,10 @@
          * Ensure the given class is visible to the class loader.
          */
         private static void ensureVisible(ClassLoader ld, Class<?> c) {
             Class<?> type = null;
             try {
-                if (c.isInlineClass() && c.isIndirectType())
-                    c = c.asPrimaryType();
                 type = Class.forName(c.getName(), false, ld);
             } catch (ClassNotFoundException e) {
             }
             if (type != c) {
                 throw new IllegalArgumentException(c.getName() +
diff a/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java b/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
--- a/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
+++ b/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java
@@ -812,11 +812,11 @@
                 } else {
                     throw new AssertionError();
                 }
             } else {
                 String internalName = dotToSlash(type.getName());
-                if (type.isInlineClass() && !type.isIndirectType()) {
+                if (type.isInlineClass()) {
                     internalName = 'Q' + internalName + ";";
                 }
                 mv.visitTypeInsn(CHECKCAST, internalName);
                 mv.visitInsn(ARETURN);
             }
@@ -877,15 +877,10 @@
         private void codeClassForName(MethodVisitor mv, Class<?> cl) {
             mv.visitLdcInsn(cl.getName());
             mv.visitMethodInsn(INVOKESTATIC,
                     JL_CLASS,
                     "forName", "(Ljava/lang/String;)Ljava/lang/Class;", false);
-            if (cl.isInlineClass() && cl == cl.asPrimaryType()) {
-                mv.visitMethodInsn(INVOKEVIRTUAL,
-                    JL_CLASS,
-                    "asPrimaryType", "()Ljava/lang/Class;", false);
-            }
         }
 
         /**
          * Visit a bytecode for a constant.
          *
diff a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
--- a/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
+++ b/src/java.base/share/classes/jdk/internal/misc/Unsafe.java
@@ -263,21 +263,21 @@
      *
      * @param vc inline class
      */
     public Object getReference(Object o, long offset, Class<?> vc) {
         Object ref = getReference(o, offset);
-        if (ref == null && vc.isInlineClass() && !vc.isIndirectType()) {
+        if (ref == null && vc.isInlineClass()) {
             // If the type of the returned reference is a regular inline type
             // return an uninitialized default value if null
             ref = uninitializedDefaultValue(vc);
         }
         return ref;
     }
 
     public Object getReferenceVolatile(Object o, long offset, Class<?> vc) {
         Object ref = getReferenceVolatile(o, offset);
-        if (ref == null && vc.isInlineClass() && !vc.isIndirectType()) {
+        if (ref == null && vc.isInlineClass()) {
             // If the type of the returned reference is a regular inline type
             // return an uninitialized default value if null
             ref = uninitializedDefaultValue(vc);
         }
         return ref;
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Type.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Type.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Type.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Type.java
@@ -666,51 +666,27 @@
                 throw new AssertionError();
             }
             stringBuilder.append(descriptor);
         } else {
             String name = currentClass.getName();
-            if (Helper.isIndirectType(currentClass)) {
-                stringBuilder.append('L');
-            } else {
+            if (isInlineClass(currentClass)) {
                 stringBuilder.append('Q');
-
+            } else {
+                stringBuilder.append('L');
             }
             int nameLength = name.length();
             for (int i = 0; i < nameLength; ++i) {
                 char car = name.charAt(i);
                 stringBuilder.append(car == '.' ? '/' : car);
             }
             stringBuilder.append(';');
         }
     }
 
-    // Workarounds nasgen build that depends on ASM but compiled with
-    // the bootstrap JDK.  Can't reference Class::isIndirectType
-    static class Helper {
-        static final Method isIndirectTypeMethod = isIndirectTypeMethod();
-        static Method isIndirectTypeMethod() {
-            try {
-                return Class.class.getMethod("isIndirectType");
-            } catch (NoSuchMethodException e) {
-                return null;
-            }
-        }
-
-        static boolean isIndirectType(Class<?> clazz) {
-            int mods = clazz.getModifiers();
-            if ((mods & 0x00000100) != 0) {            // inline class
-                assert isIndirectTypeMethod != null;
-                try {
-                    return (boolean) isIndirectTypeMethod.invoke(clazz);
-                } catch (InvocationTargetException e) {
-                    throw new InternalError(e.getCause());
-                } catch (IllegalAccessException e) {
-                    throw new InternalError(e);
-                }
-            }
-            return true;
-        }
+    static boolean isInlineClass(Class<?> clazz) {
+        int mods = clazz.getModifiers();
+        return (mods & 0x00000100) != 0;
     }
 
     // -----------------------------------------------------------------------------------------------
     // Methods to get the sort, dimension, size, and opcodes corresponding to a Type or descriptor.
     // -----------------------------------------------------------------------------------------------
diff a/src/java.base/share/classes/jdk/internal/reflect/AccessorGenerator.java b/src/java.base/share/classes/jdk/internal/reflect/AccessorGenerator.java
--- a/src/java.base/share/classes/jdk/internal/reflect/AccessorGenerator.java
+++ b/src/java.base/share/classes/jdk/internal/reflect/AccessorGenerator.java
@@ -418,11 +418,11 @@
             throw new InternalError("Should have found primitive type");
         } else if (c.isArray()) {
             return "[" + getClassName(c.getComponentType(), true);
         } else {
             if (addPrefixAndSuffixForNonPrimitiveTypes) {
-                final String desc = (c.isIndirectType() ? 'L' : 'Q') + c.getName() + ";";
+                final String desc = (c.isInlineClass() ? 'Q' : 'L') + c.getName() + ";";
                 return internalize(desc);
             } else {
                 return internalize(c.getName());
             }
         }
diff a/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorFactory.java b/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorFactory.java
--- a/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorFactory.java
+++ b/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorFactory.java
@@ -33,11 +33,11 @@
         Class<?> type = field.getType();
         boolean isStatic = Modifier.isStatic(field.getModifiers());
         boolean isFinal = Modifier.isFinal(field.getModifiers());
         boolean isVolatile = Modifier.isVolatile(field.getModifiers());
         boolean isQualified = isFinal || isVolatile;
-        boolean isReadOnly = isFinal && (isStatic || !override);
+        boolean isReadOnly = isFinal && (isStatic || !override || field.getDeclaringClass().isInlineClass());
         if (isStatic) {
             // This code path does not guarantee that the field's
             // declaring class has been initialized, but it must be
             // before performing reflective operations.
             UnsafeFieldAccessorImpl.unsafe.ensureClassInitialized(field.getDeclaringClass());
diff a/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorImpl.java b/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorImpl.java
--- a/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorImpl.java
+++ b/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorImpl.java
@@ -62,11 +62,11 @@
     protected boolean isFlattened() {
         return unsafe.isFlattened(field);
     }
 
     protected boolean canBeNull() {
-        return field.getType().isNullableType();
+        return !field.getType().isInlineClass();
     }
 
     protected Object checkValue(Object value) {
         if (!canBeNull() && value == null)
             throw new NullPointerException(field + " cannot be set to null");
diff a/src/java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java b/src/java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java
--- a/src/java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java
+++ b/src/java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java
@@ -88,12 +88,11 @@
             int begc = i[0], endc = str.indexOf(';', begc);
             if (endc < 0)  return null;
             i[0] = endc+1;
             String name = str.substring(begc, endc).replace('/', '.');
             try {
-                Class<?> clz = Class.forName(name, false, loader);
-                return c == 'Q' ? clz.asPrimaryType() : clz.asIndirectType();
+                return Class.forName(name, false, loader);
             } catch (ClassNotFoundException ex) {
                 throw new TypeNotPresentException(name, ex);
             }
         } else if (c == '[') {
             Class<?> t = parseSig(str, i, end, loader);
@@ -154,13 +153,11 @@
             sb.append(c);
         } else if (t == Object.class) {
             sb.append("Ljava/lang/Object;");
         } else {
             boolean lsemi = (!t.isArray());
-            if (!t.isIndirectType())
-                c = 'Q';
-            if (lsemi)  sb.append(c);
+            if (lsemi)  sb.append(t.isInlineClass() ? 'Q' : 'L');
             sb.append(t.getName().replace('.', '/'));
             if (lsemi)  sb.append(';');
         }
     }
 
diff a/src/java.base/share/classes/sun/invoke/util/VerifyAccess.java b/src/java.base/share/classes/sun/invoke/util/VerifyAccess.java
--- a/src/java.base/share/classes/sun/invoke/util/VerifyAccess.java
+++ b/src/java.base/share/classes/sun/invoke/util/VerifyAccess.java
@@ -271,11 +271,11 @@
      * reference of a given reference class, is really visible to that class.
      * @param type the supposed type of a member or symbolic reference of refc
      * @param refc the class attempting to make the reference
      */
     public static boolean isTypeVisible(Class<?> type, Class<?> refc) {
-        if (type.asPrimaryType() == refc.asPrimaryType()) {
+        if (type == refc) {
             return true;  // easy check
         }
         while (type.isArray())  type = type.getComponentType();
         if (type.isPrimitive() || type == Object.class) {
             return true;
@@ -331,11 +331,11 @@
                         } catch (ClassNotFoundException | LinkageError e) {
                             return null; // Assume the class is not found
                         }
                     }
             });
-        return (type.asPrimaryType() == res);
+        return (type == res);
     }
 
     /**
      * Decide if the given method type, attributed to a member or symbolic
      * reference of a given reference class, is really visible to that class.
diff a/src/java.base/share/native/libjava/Class.c b/src/java.base/share/native/libjava/Class.c
--- a/src/java.base/share/native/libjava/Class.c
+++ b/src/java.base/share/native/libjava/Class.c
@@ -56,12 +56,12 @@
 static JNINativeMethod methods[] = {
     {"initClassName",    "()" STR,          (void *)&JVM_InitClassName},
     {"getSuperclass",    "()" CLS,          NULL},
     {"getInterfaces0",   "()[" CLS,         (void *)&JVM_GetClassInterfaces},
     {"isInterface",      "()Z",             (void *)&JVM_IsInterface},
-    {"getSigners0",      "()[" OBJ,         (void *)&JVM_GetClassSigners},
-    {"setSigners0",      "([" OBJ ")V",     (void *)&JVM_SetClassSigners},
+    {"getSigners",       "()[" OBJ,         (void *)&JVM_GetClassSigners},
+    {"setSigners",       "([" OBJ ")V",     (void *)&JVM_SetClassSigners},
     {"isArray",          "()Z",             (void *)&JVM_IsArrayClass},
     {"isPrimitive",      "()Z",             (void *)&JVM_IsPrimitiveClass},
     {"getModifiers",     "()I",             (void *)&JVM_GetClassModifiers},
     {"getDeclaredFields0","(Z)[" FLD,       (void *)&JVM_GetClassDeclaredFields},
     {"getDeclaredMethods0","(Z)[" MHD,      (void *)&JVM_GetClassDeclaredMethods},
diff a/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java b/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java
--- a/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java
+++ b/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java
@@ -634,10 +634,16 @@
      * must preserve all bits of static field offsets.
      * @see #getInt(Object, long)
      */
     @ForceInline
     public long objectFieldOffset(Field f) {
+        if (f == null) {
+            throw new NullPointerException();
+        }
+        if (f.getDeclaringClass().isInlineClass()) {
+            throw new UnsupportedOperationException("can't get field offset on an inline class: " + f);
+        }
         return theInternalUnsafe.objectFieldOffset(f);
     }
 
     /**
      * Reports the location of a given static field, in conjunction with {@link
@@ -656,10 +662,16 @@
      * this method reports its result as a long value.
      * @see #getInt(Object, long)
      */
     @ForceInline
     public long staticFieldOffset(Field f) {
+        if (f == null) {
+            throw new NullPointerException();
+        }
+        if (f.getDeclaringClass().isInlineClass()) {
+            throw new UnsupportedOperationException("can't get static field offset on an inline class: " + f);
+        }
         return theInternalUnsafe.staticFieldOffset(f);
     }
 
     /**
      * Reports the location of a given static field, in conjunction with {@link
@@ -671,10 +683,16 @@
      * not be used in any way except as argument to the get and put routines in
      * this class.
      */
     @ForceInline
     public Object staticFieldBase(Field f) {
+        if (f == null) {
+            throw new NullPointerException();
+        }
+        if (f.getDeclaringClass().isInlineClass()) {
+            throw new UnsupportedOperationException("can't get base address on an inline class: " + f);
+        }
         return theInternalUnsafe.staticFieldBase(f);
     }
 
     /**
      * Detects if the given class may need to be initialized. This is often
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
@@ -66,33 +66,33 @@
         return supercls.isAssignableFrom(subcls);
     }
 
     public void test1_verifier(boolean warmup) {
         Asserts.assertTrue(test1(java.util.AbstractList.class, java.util.ArrayList.class), "test1_1 failed");
-        Asserts.assertTrue(test1(MyValue1.class.asIndirectType(), MyValue1.class.asIndirectType()), "test1_2 failed");
+        Asserts.assertTrue(test1(MyValue1.class.referenceType().get(), MyValue1.class.referenceType().get()), "test1_2 failed");
         Asserts.assertTrue(test1(MyValue1.class, MyValue1.class), "test1_3 failed");
-        Asserts.assertTrue(test1(MyValue1.class.asIndirectType(), MyValue1.class), "test1_4 failed");
-        Asserts.assertFalse(test1(MyValue1.class, MyValue1.class.asIndirectType()), "test1_5 failed");
+        Asserts.assertTrue(test1(MyValue1.class.referenceType().get(), MyValue1.class), "test1_4 failed");
+        Asserts.assertFalse(test1(MyValue1.class, MyValue1.class.referenceType().get()), "test1_5 failed");
         Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), "test1_6 failed");
-        Asserts.assertTrue(test1(Object.class, MyValue1.class.asIndirectType()), "test1_7 failed");
+        Asserts.assertTrue(test1(Object.class, MyValue1.class.referenceType().get()), "test1_7 failed");
         Asserts.assertTrue(test1(Object.class, MyValue1.class), "test1_8 failed");
-        Asserts.assertTrue(!test1(MyValue1.class.asIndirectType(), Object.class), "test1_9 failed");
+        Asserts.assertTrue(!test1(MyValue1.class.referenceType().get(), Object.class), "test1_9 failed");
         Asserts.assertTrue(!test1(MyValue1.class, Object.class), "test1_10 failed");
     }
 
     // Verify that Class::isAssignableFrom checks with statically known classes are folded
     @Test(failOn = LOADK)
     public boolean test2() {
         boolean check1 = java.util.AbstractList.class.isAssignableFrom(java.util.ArrayList.class);
-        boolean check2 = MyValue1.class.asIndirectType().isAssignableFrom(MyValue1.class.asIndirectType());
+        boolean check2 = MyValue1.class.referenceType().get().isAssignableFrom(MyValue1.class.referenceType().get());
         boolean check3 = MyValue1.class.isAssignableFrom(MyValue1.class);
-        boolean check4 = MyValue1.class.asIndirectType().isAssignableFrom(MyValue1.class);
-        boolean check5 = !MyValue1.class.isAssignableFrom(MyValue1.class.asIndirectType());
+        boolean check4 = MyValue1.class.referenceType().get().isAssignableFrom(MyValue1.class);
+        boolean check5 = !MyValue1.class.isAssignableFrom(MyValue1.class.referenceType().get());
         boolean check6 = Object.class.isAssignableFrom(java.util.ArrayList.class);
-        boolean check7 = Object.class.isAssignableFrom(MyValue1.class.asIndirectType());
+        boolean check7 = Object.class.isAssignableFrom(MyValue1.class.referenceType().get());
         boolean check8 = Object.class.isAssignableFrom(MyValue1.class);
-        boolean check9 = !MyValue1.class.asIndirectType().isAssignableFrom(Object.class);
+        boolean check9 = !MyValue1.class.referenceType().get().isAssignableFrom(Object.class);
         boolean check10 = !MyValue1.class.isAssignableFrom(Object.class);
         return check1 && check2 && check3 && check4 && check5 && check6 && check7 && check8 && check9 && check10;
     }
 
     public void test2_verifier(boolean warmup) {
@@ -105,23 +105,23 @@
         return cls.getSuperclass();
     }
 
     public void test3_verifier(boolean warmup) {
         Asserts.assertTrue(test3(Object.class) == null, "test3_1 failed");
-        Asserts.assertTrue(test3(MyValue1.class.asIndirectType()) == MyValue1.ref.class, "test3_2 failed");
-        Asserts.assertTrue(test3(MyValue1.class.asPrimaryType()) == MyValue1.ref.class, "test3_3 failed");
+        Asserts.assertTrue(test3(MyValue1.class.referenceType().get()) == MyValue1.ref.class, "test3_2 failed");
+        Asserts.assertTrue(test3(MyValue1.class.valueType().get()) == MyValue1.ref.class, "test3_3 failed");
         Asserts.assertTrue(test3(Class.class) == Object.class, "test3_4 failed");
     }
 
     // Verify that Class::getSuperclass checks with statically known classes are folded
     @Test(failOn = LOADK)
     public boolean test4() {
         boolean check1 = Object.class.getSuperclass() == null;
         // TODO Remove cast as workaround once javac is fixed
-        boolean check2 = (Class<?>)MyValue1.class.asIndirectType().getSuperclass() == MyValue1.ref.class;
+        boolean check2 = (Class<?>)MyValue1.class.referenceType().get().getSuperclass() == MyValue1.ref.class;
         // TODO Remove cast as workaround once javac is fixed
-        boolean check3 = (Class<?>)MyValue1.class.asPrimaryType().getSuperclass() == MyValue1.ref.class;
+        boolean check3 = (Class<?>)MyValue1.class.valueType().get().getSuperclass() == MyValue1.ref.class;
         boolean check4 = Class.class.getSuperclass() == Object.class;
         return check1 && check2 && check3 && check4;
     }
 
     public void test4_verifier(boolean warmup) {
@@ -179,11 +179,11 @@
     @DontCompile
     public void test8_verifier(boolean warmup) {
         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
         boolean result = test8(MyValue1.class, vt);
         Asserts.assertTrue(result);
-        result = test8(MyValue1.class.asIndirectType(), vt);
+        result = test8(MyValue1.class.referenceType().get(), vt);
         Asserts.assertTrue(result);
     }
 
     @Test()
     public boolean test9(Class c, MyValue1 vt) {
@@ -193,11 +193,11 @@
     @DontCompile
     public void test9_verifier(boolean warmup) {
         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
         boolean result = test9(MyValue2.class, vt);
         Asserts.assertFalse(result);
-        result = test9(MyValue2.class.asIndirectType(), vt);
+        result = test9(MyValue2.class.referenceType().get(), vt);
         Asserts.assertFalse(result);
     }
 
     // Class.cast
     @Test()
@@ -255,11 +255,11 @@
     }
 
     // value type array creation via reflection
     @Test()
     public void test14(int len, long hash) {
-        Object[] va = (Object[])Array.newInstance(MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), len);
+        Object[] va = (Object[])Array.newInstance(MyValue1.class.valueType().get().referenceType().get().valueType().get(), len);
         for (int i = 0; i < len; ++i) {
             Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);
         }
     }
 
@@ -451,11 +451,11 @@
     @Test
     public Object test26() {
         Class<?>[] ca = new Class<?>[1];
         for (int i = 0; i < 1; ++i) {
           // Folds during loop opts
-          ca[i] = MyValue1.class.asPrimaryType();
+          ca[i] = MyValue1.class.valueType().get();
         }
         return Array.newInstance(ca[0], 1);
     }
 
     @DontCompile
@@ -536,11 +536,11 @@
 
     // getValue to retrieve flattened field from value
     @Test(failOn=CALL_Unsafe)
     public MyValue2 test30(MyValue1 v) {
         if (V1_FLATTENED) {
-            return U.getValue(v, V1_OFFSET, MyValue2.class.asPrimaryType().asIndirectType().asPrimaryType());
+            return U.getValue(v, V1_OFFSET, MyValue2.class.valueType().get().referenceType().get().valueType().get());
         }
         return (MyValue2)U.getReference(v, V1_OFFSET);
     }
 
     @DontCompile
@@ -565,11 +565,11 @@
 
     // getValue to retrieve flattened field from object
     @Test(failOn=CALL_Unsafe)
     public MyValue1 test31() {
         if (TEST31_VT_FLATTENED) {
-            return U.getValue(this, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());
+            return U.getValue(this, TEST31_VT_OFFSET, MyValue1.class.valueType().get().referenceType().get().valueType().get());
         }
         return (MyValue1)U.getReference(this, TEST31_VT_OFFSET);
     }
 
     @DontCompile
@@ -581,11 +581,11 @@
 
     // putValue to set flattened field in object
     @Test(failOn=CALL_Unsafe)
     public void test32(MyValue1 vt) {
         if (TEST31_VT_FLATTENED) {
-            U.putValue(this, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), vt);
+            U.putValue(this, TEST31_VT_OFFSET, MyValue1.class.valueType().get().referenceType().get().valueType().get(), vt);
         } else {
             U.putReference(this, TEST31_VT_OFFSET, vt);
         }
     }
 
@@ -611,11 +611,11 @@
     }
     // getValue to retrieve flattened field from array
     @Test(failOn=CALL_Unsafe)
     public MyValue1 test33(MyValue1[] arr) {
         if (TEST33_FLATTENED_ARRAY) {
-            return U.getValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());
+            return U.getValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.valueType().get().referenceType().get().valueType().get());
         }
         return (MyValue1)U.getReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);
     }
 
     @DontCompile
@@ -629,11 +629,11 @@
 
     // putValue to set flattened field in array
     @Test(failOn=CALL_Unsafe)
     public void test34(MyValue1[] arr, MyValue1 vt) {
         if (TEST33_FLATTENED_ARRAY) {
-            U.putValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), vt);
+            U.putValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.valueType().get().referenceType().get().valueType().get(), vt);
         } else {
             U.putReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);
         }
     }
 
@@ -648,11 +648,11 @@
     // getValue to retrieve flattened field from object with unknown
     // container type
     @Test(failOn=CALL_Unsafe)
     public MyValue1 test35(Object o) {
         if (TEST31_VT_FLATTENED) {
-            return U.getValue(o, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());
+            return U.getValue(o, TEST31_VT_OFFSET, MyValue1.class.valueType().get().referenceType().get().valueType().get());
         }
         return (MyValue1)U.getReference(o, TEST31_VT_OFFSET);
     }
 
     @DontCompile
@@ -665,11 +665,11 @@
     // getValue to retrieve flattened field from object at unknown
     // offset
     @Test(failOn=CALL_Unsafe)
     public MyValue1 test36(long offset) {
         if (TEST31_VT_FLATTENED) {
-            return U.getValue(this, offset, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());
+            return U.getValue(this, offset, MyValue1.class.valueType().get().referenceType().get().valueType().get());
         }
         return (MyValue1)U.getReference(this, offset);
     }
 
     @DontCompile
@@ -682,11 +682,11 @@
     // putValue to set flattened field in object with unknown
     // container
     @Test(failOn=CALL_Unsafe)
     public void test37(Object o, MyValue1 vt) {
         if (TEST31_VT_FLATTENED) {
-            U.putValue(o, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), vt);
+            U.putValue(o, TEST31_VT_OFFSET, MyValue1.class.valueType().get().referenceType().get().valueType().get(), vt);
         } else {
             U.putReference(o, TEST31_VT_OFFSET, vt);
         }
     }
 
@@ -701,11 +701,11 @@
     // putValue to set flattened field in object, non value argument
     // to store
     @Test(match = { CALL_Unsafe }, matchCount = { 1 })
     public void test38(Object o) {
         if (TEST31_VT_FLATTENED) {
-            U.putValue(this, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), o);
+            U.putValue(this, TEST31_VT_OFFSET, MyValue1.class.valueType().get().referenceType().get().valueType().get(), o);
         } else {
             U.putReference(this, TEST31_VT_OFFSET, o);
         }
     }
 
@@ -740,11 +740,11 @@
     }
 
     @DontCompile
     public void test40_verifier(boolean warmup) {
         int len = Math.abs(rI) % 42;
-        Object[] va = test40(MyValue1.class.asIndirectType(), len);
+        Object[] va = test40(MyValue1.class.referenceType().get(), len);
         for (int i = 0; i < len; ++i) {
             Asserts.assertEQ(va[i], null);
         }
     }
 
@@ -755,11 +755,11 @@
     }
 
     @DontCompile
     public void test41_verifier(boolean warmup) {
         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
-        boolean result = test41(MyValue1.class.asIndirectType(), vt);
+        boolean result = test41(MyValue1.class.referenceType().get(), vt);
         Asserts.assertTrue(result);
         result = test41(MyValue1.class, vt);
         Asserts.assertTrue(result);
     }
 
@@ -769,11 +769,11 @@
     }
 
     @DontCompile
     public void test42_verifier(boolean warmup) {
         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
-        boolean result = test42(MyValue2.class.asIndirectType(), vt);
+        boolean result = test42(MyValue2.class.referenceType().get(), vt);
         Asserts.assertFalse(result);
         result = test42(MyValue2.class, vt);
         Asserts.assertFalse(result);
     }
 
@@ -784,13 +784,13 @@
     }
 
     @DontCompile
     public void test43_verifier(boolean warmup) {
         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
-        Object result = test43(MyValue1.class.asIndirectType(), vt);
+        Object result = test43(MyValue1.class.referenceType().get(), vt);
         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
-        result = test43(MyValue1.class.asIndirectType(), null);
+        result = test43(MyValue1.class.referenceType().get(), null);
         Asserts.assertEQ(result, null);
     }
 
     @Test()
     public Object test44(Class c, MyValue1.ref vt) {
@@ -799,19 +799,19 @@
 
     @DontCompile
     public void test44_verifier(boolean warmup) {
         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
         try {
-            test44(MyValue2.class.asIndirectType(), vt);
+            test44(MyValue2.class.referenceType().get(), vt);
             throw new RuntimeException("should have thrown");
         } catch (ClassCastException cce) {
         }
     }
 
     @Test()
     public Object test45(MyValue1.ref vt) {
-        return MyValue1.class.asIndirectType().cast(vt);
+        return MyValue1.class.referenceType().get().cast(vt);
     }
 
     @DontCompile
     public void test45_verifier(boolean warmup) {
         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
@@ -821,11 +821,11 @@
         Asserts.assertEQ(result, null);
     }
 
     @Test()
     public Object test46(MyValue1.ref vt) {
-        return MyValue2.class.asIndirectType().cast(vt);
+        return MyValue2.class.referenceType().get().cast(vt);
     }
 
     @DontCompile
     public void test46_verifier(boolean warmup) {
         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
@@ -837,11 +837,11 @@
         }
     }
 
     @Test()
     public Object test47(MyValue1.ref vt) {
-        return MyValue1.class.asPrimaryType().cast(vt);
+        return MyValue1.class.valueType().get().cast(vt);
     }
 
     @DontCompile
     public void test47_verifier(boolean warmup) {
         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
@@ -871,11 +871,11 @@
         }
     }
 
     @Test()
     public Object test49(MyValue1 vt) {
-        return MyValue1.class.asIndirectType().cast(vt);
+        return MyValue1.class.referenceType().get().cast(vt);
     }
 
     @DontCompile
     public void test49_verifier(boolean warmup) {
         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
@@ -893,11 +893,11 @@
         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
         MyValue1[] va  = new MyValue1[42];
         MyValue1.ref[] vba = new MyValue1.ref[42];
         Object result = test50(MyValue1.class, vt);
         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
-        result = test50(MyValue1.class.asIndirectType(), vt);
+        result = test50(MyValue1.class.referenceType().get(), vt);
         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
         result = test50(MyValue1[].class, va);
         Asserts.assertEQ(result, va);
         result = test50(MyValue1.ref[].class, vba);
         Asserts.assertEQ(result, vba);
@@ -916,11 +916,11 @@
     }
 
     // value type array creation via reflection
     @Test()
     public void test51(int len) {
-        Object[] va = (Object[])Array.newInstance(MyValue1.class.asIndirectType().asPrimaryType().asIndirectType(), len);
+        Object[] va = (Object[])Array.newInstance(MyValue1.class.referenceType().get().valueType().get().referenceType().get(), len);
         for (int i = 0; i < len; ++i) {
             Asserts.assertEQ(va[i], null);
         }
     }
 
@@ -1003,32 +1003,32 @@
         test53(MyValue1[].class, MyValue1.ref[].class, len, 2);
         test53(MyValue1[].class, MyValue1.ref[].class, len, 3);
         test53(MyValue1[].class, MyValue1.ref[].class, len, 4);
     }
 
-    // Test asIndirectType intrinsic with non-value mirror
+    // Test referenceType().get() intrinsic with non-value mirror
     @Test()
     public Class<?> test54(Class<?> c) {
-        if (c.asIndirectType() != Integer.class) {
+        if (c.referenceType().get() != Integer.class) {
             throw new RuntimeException("Unexpected class");
         }
-        return Integer.class.asIndirectType();
+        return Integer.class.referenceType().get();
     }
 
     @DontCompile
     public void test54_verifier(boolean warmup) {
         Class<?> result = test54(Integer.class);
         Asserts.assertEQ(result, Integer.class);
     }
 
-    // Test asPrimaryType intrinsic with non-value mirror
+    // Test valueType().get intrinsic with non-value mirror
     @Test()
     public Class<?> test55(Class<?> c) {
-        if (c.asPrimaryType() != Integer.class) {
+        if (c.valueType().get() != Integer.class) {
             throw new RuntimeException("Unexpected class");
         }
-        return Integer.class.asPrimaryType();
+        return Integer.class.valueType().get();
     }
 
     @DontCompile
     public void test55_verifier(boolean warmup) {
         Class<?> result = test55(Integer.class);
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
@@ -1376,11 +1376,11 @@
     }
 
     // Tests writing an array element with a (statically known) incompatible type
     private static final MethodHandle setArrayElementIncompatible = MethodHandleBuilder.loadCode(MethodHandles.lookup(),
         "setArrayElementIncompatible",
-        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class.asPrimaryType()),
+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class),
         CODE -> {
             CODE.
             aload_1().
             iload_2().
             aload_3().
diff a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
--- a/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
+++ b/test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java
@@ -217,12 +217,11 @@
         assertEquals(array3.length, 1, "Incorrect length");
         assertEquals(array3[0].length, 2, "Incorrect length");
         assertTrue(array3[0][0] == null, "Expected NULL");
 
         // Now create ObjArrays of ValueArray...
-        cls = (Class<?>) Point.class.asIndirectType();
-        Point.ref[][] barray = (Point.ref[][]) Array.newInstance(cls, 1, 2);
+        Point.ref[][] barray = (Point.ref[][]) Array.newInstance(Point.ref.class, 1, 2);
         assertEquals(barray.length, 1, "Incorrect length");
         assertEquals(barray[0].length, 2, "Incorrect length");
         barray[0][1] = Point.createPoint(1, 2);
         Point.ref pb = barray[0][1];
         int x = pb.getX();
diff a/test/jdk/valhalla/valuetypes/ArrayElementVarHandleTest.java b/test/jdk/valhalla/valuetypes/ArrayElementVarHandleTest.java
--- a/test/jdk/valhalla/valuetypes/ArrayElementVarHandleTest.java
+++ b/test/jdk/valhalla/valuetypes/ArrayElementVarHandleTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -154,11 +154,11 @@
             Point.makePoint(1, 2),
             Point.makePoint(10, 20),
             Point.makePoint(100, 200)
     };
 
-    private static final Point.ref[] NULLABLE_POINTS = new Point.ref[]{
+    private static final Point.ref[] NULL_POINTS = new Point.ref[]{
         Point.makePoint(11, 22),
                 Point.makePoint(110, 220),
                 null
     };
 
@@ -167,10 +167,12 @@
             Line.makeLine(10, 20, 30, 40),
             Line.makeLine(15, 25, 35, 45),
             Line.makeLine(20, 30, 40, 50)
     };
 
+    private static final Line.ref[] NULL_LINES = new Line.ref[] { null, null };
+
     private static final NonFlattenValue[] NFV_ARRAY = new NonFlattenValue[]{
             NonFlattenValue.make(1, 2),
             NonFlattenValue.make(10, 20),
             NonFlattenValue.make(100, 200)
     };
@@ -182,38 +184,37 @@
     public static void testObjectArrayVarHandle() throws Throwable {
         ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Object[].class);
         // Point[] <: Point.ref[] <: Object
         Object[] array1 = test.newArray(POINTS.length);
         test.setElements(array1, POINTS);
-        test.setElements(array1, NULLABLE_POINTS);
+        test.setElements(array1, NULL_POINTS);
         test.setElements(array1, new Object[] { "abc", Point.makePoint(1, 2) });
 
-        Point.ref []array2 = new Point.ref [NULLABLE_POINTS.length];
+        Point.ref []array2 = new Point.ref [NULL_POINTS.length];
         test.setElements(array2, POINTS);
-        test.setElements(array2, NULLABLE_POINTS);
+        test.setElements(array2, NULL_POINTS);
 
         Point[] array3 = new Point[POINTS.length];
         test.setElements(array3, POINTS);
     }
 
     /*
      * VarHandle of Point.ref[].class
      */
     @Test
-    public static void testIndirectPointVarHandle() throws Throwable {
-        Object o = new Point.ref[0];
-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(o.getClass());
-        assertTrue(test.componentType.isIndirectType());
+    public static void testPointRefVarHandle() throws Throwable {
+        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Point.ref[].class);
+        assertTrue(test.componentType == Point.ref.class);
 
         // Point[] <: Point.ref[] <: Object
         Point.ref[] array1 = (Point.ref[])test.newArray(POINTS.length);
         test.setElements(array1, POINTS);
-        test.setElements(array1, NULLABLE_POINTS);
+        test.setElements(array1, NULL_POINTS);
 
-        Point.ref[] array2 = new Point.ref[NULLABLE_POINTS.length];
+        Point.ref[] array2 = new Point.ref[NULL_POINTS.length];
         test.setElements(array2, POINTS);
-        test.setElements(array2, NULLABLE_POINTS);
+        test.setElements(array2, NULL_POINTS);
 
         Point[] array3 = new Point[POINTS.length];
         test.setElements(array3, POINTS);
     }
 
@@ -221,11 +222,11 @@
      * VarHandle of Point[].class
      */
     @Test
     public static void testPointArrayVarHandle()  throws Throwable {
         ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Point[].class);
-        assertFalse(test.componentType.isIndirectType());
+        assertTrue(test.componentType == Point.class);
 
         // Point[] <: Point.ref[] <: Object
         Point[] array1 = (Point[]) test.newArray(POINTS.length);
         test.setElements(array1, POINTS);
 
@@ -235,23 +236,22 @@
 
     /*
      * VarHandle of Line.ref[].class
      */
     @Test
-    public static void testIndirectLineVarHandle() throws Throwable {
-        Line.ref[] nullableLines = new Line.ref[] { null, null };
-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(nullableLines.getClass());
-        assertTrue(test.componentType.isIndirectType());
+    public static void testLineRefVarHandle() throws Throwable {
+        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Line.ref[].class);
+        assertTrue(test.componentType == Line.ref.class);
 
         // Line[] <: Line.ref[]
         Line.ref[] array1 = (Line.ref[])test.newArray(LINES.length);
         test.setElements(array1, LINES);
-        test.setElements(array1, nullableLines);
+        test.setElements(array1, NULL_LINES);
 
         Line.ref[] array2 = new Line.ref[LINES.length];
         test.setElements(array2, LINES);
-        test.setElements(array2, nullableLines);
+        test.setElements(array2, NULL_LINES);
 
         Line[] array3 = new Line[LINES.length];
         test.setElements(array3, LINES);
     }
 
@@ -259,11 +259,11 @@
      * VarHandle of Line[].class
      */
     @Test
     public static void testLineVarHandle() throws Throwable {
         ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Line[].class);
-        assertFalse(test.componentType.isIndirectType());
+        assertTrue(test.componentType == Line.class);
 
         Line[] array1 = (Line[]) test.newArray(LINES.length);
         test.setElements(array1, LINES);
 
         Line[] array3 = new Line[LINES.length];
@@ -274,11 +274,11 @@
      * VarHandle of NonFlattenValue[].class
      */
     @Test
     public static void testNonFlattenedValueVarHandle() throws Throwable {
         ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(NonFlattenValue[].class);
-        assertFalse(test.componentType.isIndirectType());
+        assertTrue(test.componentType == NonFlattenValue.class);
 
         NonFlattenValue[] array1 = (NonFlattenValue[]) test.newArray(NFV_ARRAY.length);
         test.setElements(array1, NFV_ARRAY);
 
         NonFlattenValue[] array3 = new NonFlattenValue[POINTS.length];
diff a/test/jdk/valhalla/valuetypes/MethodHandleTest.java b/test/jdk/valhalla/valuetypes/MethodHandleTest.java
--- a/test/jdk/valhalla/valuetypes/MethodHandleTest.java
+++ b/test/jdk/valhalla/valuetypes/MethodHandleTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -31,11 +31,10 @@
 import java.lang.invoke.*;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.util.List;
 
-import org.testng.annotations.BeforeTest;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 import static org.testng.Assert.*;
 
 public class MethodHandleTest {
@@ -118,11 +117,11 @@
             assertEquals(v, o);
         }
 
         Class<?> elementType = c.getComponentType();
         if (elementType.isInlineClass()) {
-            assertTrue(elementType == elementType.asPrimaryType());
+            assertTrue(elementType == elementType.valueType().get());
         }
         // set an array element to null
         try {
             Object v = (Object)setter.invoke(array, 0, null);
             assertFalse(elementType.isInlineClass(), "should fail to set an inline class array element to null");
@@ -193,12 +192,11 @@
      * The field must be flattenable but may or may not be flattened.
      */
     void setValueField(String name, Object obj, Object value) throws Throwable {
         Field f = c.getDeclaredField(name);
         boolean isStatic = Modifier.isStatic(f.getModifiers());
-        assertTrue(f.getType().isInlineClass() ||
-                   f.getType().getCanonicalName().endsWith("$ref"));
+        assertTrue(f.getType().isInlineClass() || f.getType().valueType().isPresent());
         assertTrue((isStatic && obj == null) || (!isStatic && obj != null));
         Object v = f.get(obj);
 
         // Field::set
         try {
@@ -289,11 +287,11 @@
      * Test setting the given field to null via reflection, method handle
      * and var handle.
      */
     void ensureNullable(Field f) throws Throwable {
         assertFalse(Modifier.isStatic(f.getModifiers()));
-        boolean canBeNull = f.getType().isNullableType();
+        boolean canBeNull = !f.getType().isInlineClass();
         // test reflection
         try {
             f.set(o, null);
             assertTrue(canBeNull, f + " cannot be set to null");
         } catch (NullPointerException e) {
diff a/test/jdk/valhalla/valuetypes/QTypeDescriptorTest.java b/test/jdk/valhalla/valuetypes/QTypeDescriptorTest.java
--- a/test/jdk/valhalla/valuetypes/QTypeDescriptorTest.java
+++ b/test/jdk/valhalla/valuetypes/QTypeDescriptorTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -123,22 +123,18 @@
         assertEquals(l.p2, NFV.pointValue());
     }
 
     @DataProvider
     static Object[][] descriptors() {
-        Class<?> pointLType = Point.ref.class;
-        Class<?> pointQType = Point.class;
-        Class<?> nonFlattenValueLType = NonFlattenValue.ref.class;
-        Class<?> nonFlattenValueQType = NonFlattenValue.class;
         return new Object[][]{
-            { QTypeDescriptorTest.class, "toLine", new Class<?>[] {pointQType, nonFlattenValueQType}, true},
-            { QTypeDescriptorTest.class, "toLine", new Class<?>[] {pointLType, nonFlattenValueQType}, false},
-            { QTypeDescriptorTest.class, "toLine", new Class<?>[] { Point[].class },                  true},
-            { NonFlattenValue.class, "point",      null,                                              true},
-            { NonFlattenValue.class, "pointValue", null,                                              true},
-            { NonFlattenValue.class, "has",        new Class<?>[] {pointQType, pointLType},           true},
-            { NonFlattenValue.class, "has",        new Class<?>[] {pointQType, pointQType},           false},
+            { QTypeDescriptorTest.class, "toLine", new Class<?>[] { Point.class, NonFlattenValue.class},     true},
+            { QTypeDescriptorTest.class, "toLine", new Class<?>[] { Point.ref.class, NonFlattenValue.class}, false},
+            { QTypeDescriptorTest.class, "toLine", new Class<?>[] { Point[].class },                         true},
+            { NonFlattenValue.class, "point",      null,                                                     true},
+            { NonFlattenValue.class, "pointValue", null,                                                     true},
+            { NonFlattenValue.class, "has",        new Class<?>[] { Point.class, Point.ref.class},           true},
+            { NonFlattenValue.class, "has",        new Class<?>[] { Point.class, Point.class},               false},
         };
     }
 
     @Test(dataProvider = "descriptors")
     public static void testDescriptors(Class<?> defc, String name, Class<?>[] params, boolean found) throws Exception {
@@ -150,25 +146,23 @@
         }
     }
 
     @DataProvider
     static Object[][] methodTypes() {
-        Class<?> pointLType = Point.ref.class;
-        Class<?> pointQType = Point.class;
         ClassLoader loader = QTypeDescriptorTest.class.getClassLoader();
         return new Object[][]{
-            { "point",      MethodType.methodType(pointLType),                            true },
-            { "pointValue", MethodType.methodType(pointQType),                            true },
-            { "has",        MethodType.methodType(boolean.class, pointQType, pointLType), true },
-            { "point",      MethodType.methodType(pointQType),                            false },
-            { "pointValue", MethodType.methodType(pointLType),                            false },
-            { "has",        MethodType.methodType(boolean.class, pointLType, pointQType), false },
-            { "point",      MethodType.fromMethodDescriptorString("()LPoint$ref;", loader),         true },
-            { "point",      MethodType.fromMethodDescriptorString("()QPoint;", loader),         false },
-            { "pointValue", MethodType.fromMethodDescriptorString("()QPoint;", loader),         true },
-            { "pointValue", MethodType.fromMethodDescriptorString("()LPoint;", loader),         false },
-            { "has",        MethodType.fromMethodDescriptorString("(QPoint;LPoint$ref;)Z", loader), true },
+            { "point",      MethodType.methodType(Point.ref.class),                                     true },
+            { "pointValue", MethodType.methodType(Point.class),                                         true },
+            { "has",        MethodType.methodType(boolean.class, Point.class, Point.ref.class),         true },
+            { "point",      MethodType.methodType(Point.class),                                         false },
+            { "pointValue", MethodType.methodType(Point.ref.class),                                     false },
+            { "has",        MethodType.methodType(boolean.class, Point.ref.class, Point.class),         false },
+            { "point",      MethodType.fromMethodDescriptorString("()LPoint$ref;", loader),             true },
+            { "point",      MethodType.fromMethodDescriptorString("()QPoint;", loader),                 false },
+            { "pointValue", MethodType.fromMethodDescriptorString("()QPoint;", loader),                 true },
+            { "pointValue", MethodType.fromMethodDescriptorString("()LPoint$ref;", loader),             false },
+            { "has",        MethodType.fromMethodDescriptorString("(QPoint;LPoint$ref;)Z", loader),     true },
             { "has",        MethodType.fromMethodDescriptorString("(LPoint$ref;LPoint$ref;)Z", loader), false },
         };
     }
 
     @Test(dataProvider = "methodTypes")
diff a/test/jdk/valhalla/valuetypes/Reflection.java b/test/jdk/valhalla/valuetypes/Reflection.java
--- a/test/jdk/valhalla/valuetypes/Reflection.java
+++ b/test/jdk/valhalla/valuetypes/Reflection.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,99 +23,90 @@
 
 
 /*
  * @test
  * @summary test reflection on inline types
- * @run main/othervm Reflection
+ * @run testng/othervm Reflection
  */
 
 import java.lang.reflect.Array;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.InaccessibleObjectException;
 import java.lang.reflect.Method;
 
-public class Reflection {
-    public static void main(String... args) throws Exception {
-        testPointClass();
-        testLineClass();
-        testNonFlattenValue();
-        testMirrors();
-        testClassName();
-    }
+import org.testng.annotations.Test;
+import static org.testng.Assert.*;
 
-    static void testPointClass() throws Exception  {
+public class Reflection {
+    @Test
+    public static void testPointClass() throws Exception  {
         Point o = Point.makePoint(10, 20);
         Reflection test = new Reflection(Point.class, "Point", o);
         test.newInstance();
         test.constructor();
         test.accessFieldX(o.x);
         test.staticField();
     }
 
-    static void testLineClass() throws Exception {
+    @Test
+    public static void testLineClass() throws Exception {
         Line l = Line.makeLine(10, 20, 30, 40);
         Reflection test = new Reflection(Line.class, "Line", l);
         test.checkField("public final Point Line.p1", "p1", Point.class);
         test.checkField("public final Point Line.p2", "p2", Point.class);
         test.checkMethod("public Point Line.p1()",           "p1", Point.class);
         test.checkMethod("public Point Line.p2()",           "p2", Point.class);
     }
 
-    static void testNonFlattenValue() throws Exception {
+    @Test
+    public static void testNonFlattenValue() throws Exception {
         NonFlattenValue nfv = NonFlattenValue.make(10, 20);
         Reflection test = new Reflection(NonFlattenValue.class, "NonFlattenValue", nfv);
         test.checkField("final Point$ref NonFlattenValue.nfp", "nfp", Point.ref.class);
         test.checkMethod("public Point NonFlattenValue.pointValue()", "pointValue", Point.class);
         test.checkMethod("public Point$ref NonFlattenValue.point()", "point", Point.ref.class);
         test.checkMethod("public boolean NonFlattenValue.has(Point,Point$ref)", "has", boolean.class, Point.class, Point.ref.class);
     }
 
     /*
-     * Tests reflection APIs with the primary type and indirect/nullable projection type
+     * Tests reflection APIs with the value and reference projection type
      */
-    static void testMirrors() throws Exception {
-        Class<?> primary = Point.class;
-        Class<?> indirect = Point.ref.class;
-
-        assertEquals(primary, Point.class);
-        assertEquals(indirect, Point.ref.class);
-        assertTrue(primary.isInlineClass());
-        assertFalse(primary.isIndirectType());
-        assertFalse(primary.isNullableType());
+    @Test
+    public static void testMirrors() throws Exception {
+        Class<?> inlineClass = Point.class;
+        assertTrue(inlineClass.isInlineClass());
+        assertFalse(Point.ref.class.isInlineClass());
+        assertEquals(inlineClass.valueType().get(), Point.class);
+        assertEquals(inlineClass.referenceType().get(), Point.ref.class);
 
-        assertTrue(!indirect.isInlineClass());
-        assertTrue(indirect.isIndirectType());
-        assertTrue(indirect.isNullableType());
 
         Point o = Point.makePoint(10, 20);
-        assertTrue(primary.isInstance(o));
-        assertTrue(indirect.isInstance(o));
+        assertTrue(Point.class.isInstance(o));
+        assertTrue(Point.ref.class.isInstance(o));
 
+    }
+
+    @Test
+    public static void testAssignableFrom() {
         // V <: V? and V <: Object
-        assertTrue(indirect.isAssignableFrom(primary));
-        assertTrue(Object.class.isAssignableFrom(primary));
-        assertFalse(primary.isAssignableFrom(indirect));
-        assertTrue(Object.class.isAssignableFrom(indirect));
+        assertTrue(Point.ref.class.isAssignableFrom(Point.class));
+        assertTrue(Object.class.isAssignableFrom(Point.class));
+        assertFalse(Point.class.isAssignableFrom(Point.ref.class));
+        assertTrue(Object.class.isAssignableFrom(Point.ref.class));
 
-        assertEquals(primary, primary.asSubclass(indirect));
+        assertEquals(Point.class, Point.class.asSubclass(Point.ref.class));
         try {
-            Class<?> c = indirect.asSubclass(primary);
+            Class<?> c = Point.ref.class.asSubclass(Point.class);
             assertTrue(false);
         } catch (ClassCastException e) { }
-
-        // indirect class
-        assertEquals(Reflection.class.asPrimaryType(), Reflection.class);
-        assertEquals(Reflection.class.asIndirectType(), Reflection.class);
-        assertEquals(Reflection.class.asNullableType(), Reflection.class);
-        assertTrue(Reflection.class.isIndirectType());
-        assertTrue(Reflection.class.isNullableType());
     }
 
-    static void testClassName() {
+    @Test
+    public static void testClassName() {
         assertEquals(Point.class.getName(), "Point");
-        assertEquals(Point.class.asNullableType().getName(), "Point");
+        assertEquals(Point.ref.class.getName(), "Point$ref");
         assertEquals(Line.class.getName(), "Line");
         assertEquals((new Point[0]).getClass().getName(), "[QPoint;");
         assertEquals((new Point.ref[0][0]).getClass().getName(), "[[LPoint$ref;");
     }
 
@@ -128,49 +119,49 @@
             throw new RuntimeException(cn + " is not an inline class");
         }
 
         // V.class, Class.forName, and the type of the object return the primary mirror
         assertEquals(type, o.getClass());
-        assertEquals(type, c.asPrimaryType());
-        assertEquals(c, c.asPrimaryType());
+        assertEquals(type, c.valueType().get());
+        assertEquals(c, c.valueType().get());
 
         this.ctor = c.getDeclaredConstructor();
         this.o = o;
 
 
         // test the primary mirror and secondary mirror
         testMirrors(this.c);
         // test array of Q-type and L-type
-        testArray(c.asPrimaryType());
-        testArray(c.asNullableType());
+        testArray(c.valueType().get());
+        testArray(c.referenceType().get());
     }
 
     private static void testMirrors(Class<?> c) {
-        Class<?> inlineType = c.asPrimaryType();
-        Class<?> nullableType = c.asNullableType();
+        Class<?> valType = c.valueType().get();
+        Class<?> refType = c.referenceType().get();
 
-        assertTrue(inlineType != null);
-        assertEquals(nullableType.getTypeName(), c.getTypeName() + "?");
-        assertEquals(nullableType.getSimpleName(), c.getSimpleName() + "?");
+        assertTrue(valType != null);
+        assertEquals(refType.getTypeName(), c.getTypeName() + "$ref");
+        assertEquals(refType.getSimpleName(), c.getSimpleName() + "$ref");
 
-        assertEquals(nullableType.getName(), inlineType.getName());
-        assertEquals(nullableType.getTypeName(), inlineType.getTypeName() + "?");
-        assertEquals(nullableType.getSimpleName(), inlineType.getSimpleName() + "?");
+        assertEquals(refType.getName(), valType.getName() + "$ref");
+        assertEquals(refType.getTypeName(), valType.getTypeName() + "$ref");
+        assertEquals(refType.getSimpleName(), valType.getSimpleName() + "$ref");
 
-        assertEquals(inlineType.asNullableType(), nullableType);
-        assertEquals(nullableType.asPrimaryType(), inlineType);
+        assertEquals(valType.referenceType().get(), refType);
+        assertEquals(refType.valueType().get(), valType);
     }
 
     void testArray(Class<?> elementType) {
         Object[] array = (Object[])Array.newInstance(elementType, 1);
         Class<?> arrayType = array.getClass();
         assertTrue(arrayType.isArray());
         Class<?> componentType = arrayType.getComponentType();
-        assertTrue(componentType.isInlineClass());
+        assertTrue(componentType.isInlineClass() || componentType.valueType().isPresent());
         assertEquals(componentType, elementType);
         // Array is a reference type
-        assertEquals(arrayType.asNullableType(), arrayType);
+        assertEquals(arrayType.referenceType().get(), arrayType);
         if (array[0] == null) {
             System.out.println("array[0] = null");
         } else {
             System.out.println("array[0] = " + array[0]);
         }
@@ -218,23 +209,6 @@
 
     void checkMethod(String source, String name, Class<?> returnType, Class<?>... params) throws Exception {
         Method m = c.getDeclaredMethod(name, params);
         assertEquals(m.toString(), source);
     }
-
-    static void assertEquals(Object o1, Object o2) {
-        if (o1 == o2 || o1.equals(o2))
-            return;
-
-        throw new AssertionError(o1 + " != " + o2);
-    }
-
-    static void assertTrue(boolean value) {
-        if (!value)
-            throw new AssertionError("expected true");
-    }
-
-    static void assertFalse(boolean value) {
-        if (value)
-            throw new AssertionError("expected false");
-    }
 }
diff a/test/jdk/valhalla/valuetypes/ValueArray.java b/test/jdk/valhalla/valuetypes/ValueArray.java
--- a/test/jdk/valhalla/valuetypes/ValueArray.java
+++ b/test/jdk/valhalla/valuetypes/ValueArray.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,11 +29,10 @@
  */
 
 import java.lang.reflect.Array;
 import java.util.Arrays;
 
-import org.testng.annotations.BeforeTest;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 import static org.testng.Assert.*;
 
 public class ValueArray {
@@ -56,12 +55,12 @@
     void run() {
         testClassName();
         testArrayElements();
 
         if (componentType.isInlineClass()) {
-            Object[] qArray = (Object[]) Array.newInstance(componentType.asPrimaryType(), 0);
-            Object[] lArray = (Object[]) Array.newInstance(componentType.asIndirectType(), 0);
+            Object[] qArray = (Object[]) Array.newInstance(componentType, 0);
+            Object[] lArray = (Object[]) Array.newInstance(componentType.referenceType().get(), 0);
             testInlineArrayCovariance(componentType, qArray, lArray);
         }
     }
 
     void testClassName() {
@@ -71,13 +70,12 @@
         Class<?> c = arrayClass;
         while (c.isArray()) {
             sb.append("[");
             c = c.getComponentType();
         }
-        sb.append(c.isIndirectType() ? "L" : "Q").append(c.getName()).append(";");
+        sb.append(c.isInlineClass() ? "Q" : "L").append(c.getName()).append(";");
         assertEquals(sb.toString(), arrayClassName);
-        assertEquals(c.getTypeName(), c.getName() + (c.isInlineClass() && c.isIndirectType() ? "?" : ""));
     }
 
     void testArrayElements() {
         Object[] array = (Object[]) Array.newInstance(componentType, this.array.length);
         assertTrue(array.getClass() == arrayClass);
@@ -92,11 +90,11 @@
             assertEquals(o, this.array[i]);
         }
         Arrays.setAll(array, i -> this.array[i]);
 
         // test nullable
-        if (componentType.isNullableType()) {
+        if (!componentType.isInlineClass()) {
             for (int i=0; i < array.length; i++) {
                 Array.set(array, i, null);
             }
         } else {
             for (int i=0; i < array.length; i++) {

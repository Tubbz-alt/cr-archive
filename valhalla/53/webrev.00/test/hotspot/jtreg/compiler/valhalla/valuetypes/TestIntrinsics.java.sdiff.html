<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../src/jdk.unsupported/share/classes/sun/misc/Unsafe.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestLWorld.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  51         switch (scenario) {
  52         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:ValueArrayElemMaxFlatSize=-1&quot;};
  53         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;};
  54         }
  55         return null;
  56     }
  57 
  58     public static void main(String[] args) throws Throwable {
  59         TestIntrinsics test = new TestIntrinsics();
  60         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  61     }
  62 
  63     // Test correctness of the Class::isAssignableFrom intrinsic
  64     @Test()
  65     public boolean test1(Class&lt;?&gt; supercls, Class&lt;?&gt; subcls) {
  66         return supercls.isAssignableFrom(subcls);
  67     }
  68 
  69     public void test1_verifier(boolean warmup) {
  70         Asserts.assertTrue(test1(java.util.AbstractList.class, java.util.ArrayList.class), &quot;test1_1 failed&quot;);
<span class="line-modified">  71         Asserts.assertTrue(test1(MyValue1.class.asIndirectType(), MyValue1.class.asIndirectType()), &quot;test1_2 failed&quot;);</span>
  72         Asserts.assertTrue(test1(MyValue1.class, MyValue1.class), &quot;test1_3 failed&quot;);
<span class="line-modified">  73         Asserts.assertTrue(test1(MyValue1.class.asIndirectType(), MyValue1.class), &quot;test1_4 failed&quot;);</span>
<span class="line-modified">  74         Asserts.assertFalse(test1(MyValue1.class, MyValue1.class.asIndirectType()), &quot;test1_5 failed&quot;);</span>
  75         Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), &quot;test1_6 failed&quot;);
<span class="line-modified">  76         Asserts.assertTrue(test1(Object.class, MyValue1.class.asIndirectType()), &quot;test1_7 failed&quot;);</span>
  77         Asserts.assertTrue(test1(Object.class, MyValue1.class), &quot;test1_8 failed&quot;);
<span class="line-modified">  78         Asserts.assertTrue(!test1(MyValue1.class.asIndirectType(), Object.class), &quot;test1_9 failed&quot;);</span>
  79         Asserts.assertTrue(!test1(MyValue1.class, Object.class), &quot;test1_10 failed&quot;);
  80     }
  81 
  82     // Verify that Class::isAssignableFrom checks with statically known classes are folded
  83     @Test(failOn = LOADK)
  84     public boolean test2() {
  85         boolean check1 = java.util.AbstractList.class.isAssignableFrom(java.util.ArrayList.class);
<span class="line-modified">  86         boolean check2 = MyValue1.class.asIndirectType().isAssignableFrom(MyValue1.class.asIndirectType());</span>
  87         boolean check3 = MyValue1.class.isAssignableFrom(MyValue1.class);
<span class="line-modified">  88         boolean check4 = MyValue1.class.asIndirectType().isAssignableFrom(MyValue1.class);</span>
<span class="line-modified">  89         boolean check5 = !MyValue1.class.isAssignableFrom(MyValue1.class.asIndirectType());</span>
  90         boolean check6 = Object.class.isAssignableFrom(java.util.ArrayList.class);
<span class="line-modified">  91         boolean check7 = Object.class.isAssignableFrom(MyValue1.class.asIndirectType());</span>
  92         boolean check8 = Object.class.isAssignableFrom(MyValue1.class);
<span class="line-modified">  93         boolean check9 = !MyValue1.class.asIndirectType().isAssignableFrom(Object.class);</span>
  94         boolean check10 = !MyValue1.class.isAssignableFrom(Object.class);
  95         return check1 &amp;&amp; check2 &amp;&amp; check3 &amp;&amp; check4 &amp;&amp; check5 &amp;&amp; check6 &amp;&amp; check7 &amp;&amp; check8 &amp;&amp; check9 &amp;&amp; check10;
  96     }
  97 
  98     public void test2_verifier(boolean warmup) {
  99         Asserts.assertTrue(test2(), &quot;test2 failed&quot;);
 100     }
 101 
 102     // Test correctness of the Class::getSuperclass intrinsic
 103     @Test()
 104     public Class&lt;?&gt; test3(Class&lt;?&gt; cls) {
 105         return cls.getSuperclass();
 106     }
 107 
 108     public void test3_verifier(boolean warmup) {
 109         Asserts.assertTrue(test3(Object.class) == null, &quot;test3_1 failed&quot;);
<span class="line-modified"> 110         Asserts.assertTrue(test3(MyValue1.class.asIndirectType()) == MyValue1.ref.class, &quot;test3_2 failed&quot;);</span>
<span class="line-modified"> 111         Asserts.assertTrue(test3(MyValue1.class.asPrimaryType()) == MyValue1.ref.class, &quot;test3_3 failed&quot;);</span>
 112         Asserts.assertTrue(test3(Class.class) == Object.class, &quot;test3_4 failed&quot;);
 113     }
 114 
 115     // Verify that Class::getSuperclass checks with statically known classes are folded
 116     @Test(failOn = LOADK)
 117     public boolean test4() {
 118         boolean check1 = Object.class.getSuperclass() == null;
 119         // TODO Remove cast as workaround once javac is fixed
<span class="line-modified"> 120         boolean check2 = (Class&lt;?&gt;)MyValue1.class.asIndirectType().getSuperclass() == MyValue1.ref.class;</span>
 121         // TODO Remove cast as workaround once javac is fixed
<span class="line-modified"> 122         boolean check3 = (Class&lt;?&gt;)MyValue1.class.asPrimaryType().getSuperclass() == MyValue1.ref.class;</span>
 123         boolean check4 = Class.class.getSuperclass() == Object.class;
 124         return check1 &amp;&amp; check2 &amp;&amp; check3 &amp;&amp; check4;
 125     }
 126 
 127     public void test4_verifier(boolean warmup) {
 128         Asserts.assertTrue(test4(), &quot;test4 failed&quot;);
 129     }
 130 
 131     // Test toString() method
 132     @Test()
 133     public String test5(MyValue1 v) {
 134         return v.toString();
 135     }
 136 
 137     @DontCompile
 138     public void test5_verifier(boolean warmup) {
 139         MyValue1 v = MyValue1.createDefaultInline();
 140         test5(v);
 141     }
 142 
</pre>
<hr />
<pre>
 164     public void test7_verifier(boolean warmup) {
 165         int len = Math.abs(rI) % 42;
 166         long hash = MyValue1.createDefaultDontInline().hashPrimitive();
 167         Object[] va = test7(MyValue1.class, len);
 168         for (int i = 0; i &lt; len; ++i) {
 169             Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);
 170         }
 171     }
 172 
 173     // Class.isInstance
 174     @Test()
 175     public boolean test8(Class c, MyValue1 vt) {
 176         return c.isInstance(vt);
 177     }
 178 
 179     @DontCompile
 180     public void test8_verifier(boolean warmup) {
 181         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 182         boolean result = test8(MyValue1.class, vt);
 183         Asserts.assertTrue(result);
<span class="line-modified"> 184         result = test8(MyValue1.class.asIndirectType(), vt);</span>
 185         Asserts.assertTrue(result);
 186     }
 187 
 188     @Test()
 189     public boolean test9(Class c, MyValue1 vt) {
 190         return c.isInstance(vt);
 191     }
 192 
 193     @DontCompile
 194     public void test9_verifier(boolean warmup) {
 195         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 196         boolean result = test9(MyValue2.class, vt);
 197         Asserts.assertFalse(result);
<span class="line-modified"> 198         result = test9(MyValue2.class.asIndirectType(), vt);</span>
 199         Asserts.assertFalse(result);
 200     }
 201 
 202     // Class.cast
 203     @Test()
 204     public Object test10(Class c, MyValue1 vt) {
 205         return c.cast(vt);
 206     }
 207 
 208     @DontCompile
 209     public void test10_verifier(boolean warmup) {
 210         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 211         Object result = test10(MyValue1.class, vt);
 212         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 213     }
 214 
 215     @Test()
 216     public Object test11(Class c, MyValue1 vt) {
 217         return c.cast(vt);
 218     }
</pre>
<hr />
<pre>
 240     }
 241 
 242     @Test()
 243     public Object test13(MyValue1 vt) {
 244         return MyValue2.class.cast(vt);
 245     }
 246 
 247     @DontCompile
 248     public void test13_verifier(boolean warmup) {
 249         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 250         try {
 251             test13(vt);
 252             throw new RuntimeException(&quot;should have thrown&quot;);
 253         } catch (ClassCastException cce) {
 254         }
 255     }
 256 
 257     // value type array creation via reflection
 258     @Test()
 259     public void test14(int len, long hash) {
<span class="line-modified"> 260         Object[] va = (Object[])Array.newInstance(MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), len);</span>
 261         for (int i = 0; i &lt; len; ++i) {
 262             Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);
 263         }
 264     }
 265 
 266     @DontCompile
 267     public void test14_verifier(boolean warmup) {
 268         int len = Math.abs(rI) % 42;
 269         long hash = MyValue1.createDefaultDontInline().hashPrimitive();
 270         test14(len, hash);
 271     }
 272 
 273     // Test hashCode() method
 274     @Test()
 275     public int test15(Object v) {
 276         return v.hashCode();
 277     }
 278 
 279     @DontCompile
 280     public void test15_verifier(boolean warmup) {
</pre>
<hr />
<pre>
 436 
 437     @Test
 438     public Test25Value[] test25(Test25Value element) {
 439         // TODO Remove cast as workaround once javac is fixed
 440         Test25Value[] newArray = (Test25Value[])Arrays.copyOf(test25Array, test25Array.length + 1);
 441         newArray[test25Array.length] = element;
 442         return newArray;
 443     }
 444 
 445     @DontCompile
 446     public void test25_verifier(boolean warmup) {
 447         Test25Value vt = new Test25Value();
 448         test25(vt);
 449     }
 450 
 451     @Test
 452     public Object test26() {
 453         Class&lt;?&gt;[] ca = new Class&lt;?&gt;[1];
 454         for (int i = 0; i &lt; 1; ++i) {
 455           // Folds during loop opts
<span class="line-modified"> 456           ca[i] = MyValue1.class.asPrimaryType();</span>
 457         }
 458         return Array.newInstance(ca[0], 1);
 459     }
 460 
 461     @DontCompile
 462     public void test26_verifier(boolean warmup) {
 463         Object[] res = (Object[])test26();
 464         Asserts.assertEQ(((MyValue1)res[0]).hashPrimitive(), MyValue1.createDefaultInline().hashPrimitive());
 465     }
 466 
 467     // Load non-flattenable value type field with unsafe
 468     MyValue1.ref test27_vt = MyValue1.createWithFieldsInline(rI, rL);
 469     private static final long TEST27_OFFSET;
 470     static {
 471         try {
 472             Field field = TestIntrinsics.class.getDeclaredField(&quot;test27_vt&quot;);
 473             TEST27_OFFSET = U.objectFieldOffset(field);
 474         } catch (Exception e) {
 475             throw new RuntimeException(e);
 476         }
</pre>
<hr />
<pre>
 521         long res = test29(v);
 522         if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {
 523             if (X_OFFSET &lt; Y_OFFSET) {
 524                 Asserts.assertEQ(((int)res) &lt;&lt; 8, (v.x &gt;&gt; 8) &lt;&lt; 8);
 525             } else {
 526                 Asserts.assertEQ(res &lt;&lt; 8, (v.y &gt;&gt; 8) &lt;&lt; 8);
 527             }
 528         } else {
 529             if (X_OFFSET &lt; Y_OFFSET) {
 530                 Asserts.assertEQ(((int)res), v.x &gt;&gt;&gt; 8);
 531             } else {
 532                 Asserts.assertEQ(res, v.y &gt;&gt;&gt; 8);
 533             }
 534         }
 535     }
 536 
 537     // getValue to retrieve flattened field from value
 538     @Test(failOn=CALL_Unsafe)
 539     public MyValue2 test30(MyValue1 v) {
 540         if (V1_FLATTENED) {
<span class="line-modified"> 541             return U.getValue(v, V1_OFFSET, MyValue2.class.asPrimaryType().asIndirectType().asPrimaryType());</span>
 542         }
 543         return (MyValue2)U.getReference(v, V1_OFFSET);
 544     }
 545 
 546     @DontCompile
 547     public void test30_verifier(boolean warmup) {
 548         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 549         MyValue2 res = test30(v);
 550         Asserts.assertEQ(res.hash(), v.v1.hash());
 551     }
 552 
 553     MyValue1 test31_vt;
 554     private static final long TEST31_VT_OFFSET;
 555     private static final boolean TEST31_VT_FLATTENED;
 556     static {
 557         try {
 558             Field test31_vt_Field = TestIntrinsics.class.getDeclaredField(&quot;test31_vt&quot;);
 559             TEST31_VT_OFFSET = U.objectFieldOffset(test31_vt_Field);
 560             TEST31_VT_FLATTENED = U.isFlattened(test31_vt_Field);
 561         } catch (Exception e) {
 562             throw new RuntimeException(e);
 563         }
 564     }
 565 
 566     // getValue to retrieve flattened field from object
 567     @Test(failOn=CALL_Unsafe)
 568     public MyValue1 test31() {
 569         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 570             return U.getValue(this, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());</span>
 571         }
 572         return (MyValue1)U.getReference(this, TEST31_VT_OFFSET);
 573     }
 574 
 575     @DontCompile
 576     public void test31_verifier(boolean warmup) {
 577         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 578         MyValue1 res = test31();
 579         Asserts.assertEQ(res.hash(), test31_vt.hash());
 580     }
 581 
 582     // putValue to set flattened field in object
 583     @Test(failOn=CALL_Unsafe)
 584     public void test32(MyValue1 vt) {
 585         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 586             U.putValue(this, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), vt);</span>
 587         } else {
 588             U.putReference(this, TEST31_VT_OFFSET, vt);
 589         }
 590     }
 591 
 592     @DontCompile
 593     public void test32_verifier(boolean warmup) {
 594         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 595         test31_vt = MyValue1.createDefaultInline();
 596         test32(vt);
 597         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 598     }
 599 
 600     private static final int TEST33_BASE_OFFSET;
 601     private static final int TEST33_INDEX_SCALE;
 602     private static final boolean TEST33_FLATTENED_ARRAY;
 603     static {
 604         try {
 605             TEST33_BASE_OFFSET = U.arrayBaseOffset(MyValue1[].class);
 606             TEST33_INDEX_SCALE = U.arrayIndexScale(MyValue1[].class);
 607             TEST33_FLATTENED_ARRAY = U.isFlattenedArray(MyValue1[].class);
 608         } catch (Exception e) {
 609             throw new RuntimeException(e);
 610         }
 611     }
 612     // getValue to retrieve flattened field from array
 613     @Test(failOn=CALL_Unsafe)
 614     public MyValue1 test33(MyValue1[] arr) {
 615         if (TEST33_FLATTENED_ARRAY) {
<span class="line-modified"> 616             return U.getValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());</span>
 617         }
 618         return (MyValue1)U.getReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);
 619     }
 620 
 621     @DontCompile
 622     public void test33_verifier(boolean warmup) {
 623         MyValue1[] arr = new MyValue1[2];
 624         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 625         arr[1] = vt;
 626         MyValue1 res = test33(arr);
 627         Asserts.assertEQ(res.hash(), vt.hash());
 628     }
 629 
 630     // putValue to set flattened field in array
 631     @Test(failOn=CALL_Unsafe)
 632     public void test34(MyValue1[] arr, MyValue1 vt) {
 633         if (TEST33_FLATTENED_ARRAY) {
<span class="line-modified"> 634             U.putValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), vt);</span>
 635         } else {
 636             U.putReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);
 637         }
 638     }
 639 
 640     @DontCompile
 641     public void test34_verifier(boolean warmup) {
 642         MyValue1[] arr = new MyValue1[2];
 643         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 644         test34(arr, vt);
 645         Asserts.assertEQ(arr[1].hash(), vt.hash());
 646     }
 647 
 648     // getValue to retrieve flattened field from object with unknown
 649     // container type
 650     @Test(failOn=CALL_Unsafe)
 651     public MyValue1 test35(Object o) {
 652         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 653             return U.getValue(o, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());</span>
 654         }
 655         return (MyValue1)U.getReference(o, TEST31_VT_OFFSET);
 656     }
 657 
 658     @DontCompile
 659     public void test35_verifier(boolean warmup) {
 660         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 661         MyValue1 res = test35(this);
 662         Asserts.assertEQ(res.hash(), test31_vt.hash());
 663     }
 664 
 665     // getValue to retrieve flattened field from object at unknown
 666     // offset
 667     @Test(failOn=CALL_Unsafe)
 668     public MyValue1 test36(long offset) {
 669         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 670             return U.getValue(this, offset, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType());</span>
 671         }
 672         return (MyValue1)U.getReference(this, offset);
 673     }
 674 
 675     @DontCompile
 676     public void test36_verifier(boolean warmup) {
 677         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 678         MyValue1 res = test36(TEST31_VT_OFFSET);
 679         Asserts.assertEQ(res.hash(), test31_vt.hash());
 680     }
 681 
 682     // putValue to set flattened field in object with unknown
 683     // container
 684     @Test(failOn=CALL_Unsafe)
 685     public void test37(Object o, MyValue1 vt) {
 686         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 687             U.putValue(o, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), vt);</span>
 688         } else {
 689             U.putReference(o, TEST31_VT_OFFSET, vt);
 690         }
 691     }
 692 
 693     @DontCompile
 694     public void test37_verifier(boolean warmup) {
 695         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 696         test31_vt = MyValue1.createDefaultInline();
 697         test37(this, vt);
 698         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 699     }
 700 
 701     // putValue to set flattened field in object, non value argument
 702     // to store
 703     @Test(match = { CALL_Unsafe }, matchCount = { 1 })
 704     public void test38(Object o) {
 705         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 706             U.putValue(this, TEST31_VT_OFFSET, MyValue1.class.asPrimaryType().asIndirectType().asPrimaryType(), o);</span>
 707         } else {
 708             U.putReference(this, TEST31_VT_OFFSET, o);
 709         }
 710     }
 711 
 712     @DontCompile
 713     public void test38_verifier(boolean warmup) {
 714         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 715         test31_vt = MyValue1.createDefaultInline();
 716         test38(vt);
 717         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 718     }
 719 
 720     @Test(failOn=CALL_Unsafe)
 721     public MyValue1 test39(MyValue1 v) {
 722         v = U.makePrivateBuffer(v);
 723         U.putInt(v, X_OFFSET, rI);
 724         v = U.finishPrivateBuffer(v);
 725         return v;
 726     }
 727 
 728     @DontCompile
 729     public void test39_verifier(boolean warmup) {
 730         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 731         MyValue1 res = test39(v.setX(v, 0));
 732         Asserts.assertEQ(res.hash(), v.hash());
 733     }
 734 
 735     // Test default value type array creation via reflection
 736     @Test()
 737     public Object[] test40(Class&lt;?&gt; componentType, int len) {
 738         Object[] va = (Object[])Array.newInstance(componentType, len);
 739         return va;
 740     }
 741 
 742     @DontCompile
 743     public void test40_verifier(boolean warmup) {
 744         int len = Math.abs(rI) % 42;
<span class="line-modified"> 745         Object[] va = test40(MyValue1.class.asIndirectType(), len);</span>
 746         for (int i = 0; i &lt; len; ++i) {
 747             Asserts.assertEQ(va[i], null);
 748         }
 749     }
 750 
 751     // Class.isInstance
 752     @Test()
 753     public boolean test41(Class c, MyValue1.ref vt) {
 754         return c.isInstance(vt);
 755     }
 756 
 757     @DontCompile
 758     public void test41_verifier(boolean warmup) {
 759         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
<span class="line-modified"> 760         boolean result = test41(MyValue1.class.asIndirectType(), vt);</span>
 761         Asserts.assertTrue(result);
 762         result = test41(MyValue1.class, vt);
 763         Asserts.assertTrue(result);
 764     }
 765 
 766     @Test()
 767     public boolean test42(Class c, MyValue1.ref vt) {
 768         return c.isInstance(vt);
 769     }
 770 
 771     @DontCompile
 772     public void test42_verifier(boolean warmup) {
 773         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
<span class="line-modified"> 774         boolean result = test42(MyValue2.class.asIndirectType(), vt);</span>
 775         Asserts.assertFalse(result);
 776         result = test42(MyValue2.class, vt);
 777         Asserts.assertFalse(result);
 778     }
 779 
 780     // Class.cast
 781     @Test()
 782     public Object test43(Class c, MyValue1.ref vt) {
 783         return c.cast(vt);
 784     }
 785 
 786     @DontCompile
 787     public void test43_verifier(boolean warmup) {
 788         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
<span class="line-modified"> 789         Object result = test43(MyValue1.class.asIndirectType(), vt);</span>
 790         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
<span class="line-modified"> 791         result = test43(MyValue1.class.asIndirectType(), null);</span>
 792         Asserts.assertEQ(result, null);
 793     }
 794 
 795     @Test()
 796     public Object test44(Class c, MyValue1.ref vt) {
 797         return c.cast(vt);
 798     }
 799 
 800     @DontCompile
 801     public void test44_verifier(boolean warmup) {
 802         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 803         try {
<span class="line-modified"> 804             test44(MyValue2.class.asIndirectType(), vt);</span>
 805             throw new RuntimeException(&quot;should have thrown&quot;);
 806         } catch (ClassCastException cce) {
 807         }
 808     }
 809 
 810     @Test()
 811     public Object test45(MyValue1.ref vt) {
<span class="line-modified"> 812         return MyValue1.class.asIndirectType().cast(vt);</span>
 813     }
 814 
 815     @DontCompile
 816     public void test45_verifier(boolean warmup) {
 817         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 818         Object result = test45(vt);
 819         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 820         result = test45(null);
 821         Asserts.assertEQ(result, null);
 822     }
 823 
 824     @Test()
 825     public Object test46(MyValue1.ref vt) {
<span class="line-modified"> 826         return MyValue2.class.asIndirectType().cast(vt);</span>
 827     }
 828 
 829     @DontCompile
 830     public void test46_verifier(boolean warmup) {
 831         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 832         test46(null);
 833         try {
 834             test46(vt);
 835             throw new RuntimeException(&quot;should have thrown&quot;);
 836         } catch (ClassCastException cce) {
 837         }
 838     }
 839 
 840     @Test()
 841     public Object test47(MyValue1.ref vt) {
<span class="line-modified"> 842         return MyValue1.class.asPrimaryType().cast(vt);</span>
 843     }
 844 
 845     @DontCompile
 846     public void test47_verifier(boolean warmup) {
 847         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 848         Object result = test47(vt);
 849         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 850         try {
 851             test47(null);
 852             throw new RuntimeException(&quot;should have thrown&quot;);
 853         } catch (NullPointerException npe) {
 854         }
 855     }
 856 
 857     @Test()
 858     public Object test48(Class c, MyValue1.ref vt) {
 859         return c.cast(vt);
 860     }
 861 
 862     @DontCompile
 863     public void test48_verifier(boolean warmup) {
 864         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 865         Object result = test48(MyValue1.class, vt);
 866         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 867         try {
 868             test48(MyValue1.class, null);
 869             throw new RuntimeException(&quot;should have thrown&quot;);
 870         } catch (NullPointerException npe) {
 871         }
 872     }
 873 
 874     @Test()
 875     public Object test49(MyValue1 vt) {
<span class="line-modified"> 876         return MyValue1.class.asIndirectType().cast(vt);</span>
 877     }
 878 
 879     @DontCompile
 880     public void test49_verifier(boolean warmup) {
 881         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 882         Object result = test49(vt);
 883         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 884     }
 885 
 886     @Test()
 887     public Object test50(Class c, Object obj) {
 888         return c.cast(obj);
 889     }
 890 
 891     @DontCompile
 892     public void test50_verifier(boolean warmup) {
 893         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 894         MyValue1[] va  = new MyValue1[42];
 895         MyValue1.ref[] vba = new MyValue1.ref[42];
 896         Object result = test50(MyValue1.class, vt);
 897         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
<span class="line-modified"> 898         result = test50(MyValue1.class.asIndirectType(), vt);</span>
 899         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 900         result = test50(MyValue1[].class, va);
 901         Asserts.assertEQ(result, va);
 902         result = test50(MyValue1.ref[].class, vba);
 903         Asserts.assertEQ(result, vba);
 904         result = test50(MyValue1.ref[].class, va);
 905         Asserts.assertEQ(result, va);
 906         try {
 907             test50(MyValue1.class, null);
 908             throw new RuntimeException(&quot;should have thrown&quot;);
 909         } catch (NullPointerException npe) {
 910         }
 911         try {
 912             test50(MyValue1[].class, vba);
 913             throw new RuntimeException(&quot;should have thrown&quot;);
 914         } catch (ClassCastException cce) {
 915         }
 916     }
 917 
 918     // value type array creation via reflection
 919     @Test()
 920     public void test51(int len) {
<span class="line-modified"> 921         Object[] va = (Object[])Array.newInstance(MyValue1.class.asIndirectType().asPrimaryType().asIndirectType(), len);</span>
 922         for (int i = 0; i &lt; len; ++i) {
 923             Asserts.assertEQ(va[i], null);
 924         }
 925     }
 926 
 927     @DontCompile
 928     public void test51_verifier(boolean warmup) {
 929         int len = Math.abs(rI) % 42;
 930         test51(len);
 931     }
 932 
 933     // multidimensional value type array creation via reflection
 934     @Test()
 935     public Object[][] test52(int len, int val) {
 936         MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);
 937         MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);
 938         Object[][] result;
 939         if (val == 1) {
 940             va1[0] = new MyValue1[1];
 941             result = va1;
</pre>
<hr />
<pre>
 988             result = va4;
 989         }
 990         if ((val == 1 || val == 3) &amp;&amp; len &gt; 0) {
 991             Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());
 992         } else if (len &gt; 0) {
 993             Asserts.assertEQ(result[0][0], null);
 994             result[0][0] = null;
 995         }
 996         return result;
 997     }
 998 
 999     @DontCompile
1000     public void test53_verifier(boolean warmup) {
1001         int len = Math.abs(rI) % 42;
1002         test53(MyValue1[].class, MyValue1.ref[].class, len, 1);
1003         test53(MyValue1[].class, MyValue1.ref[].class, len, 2);
1004         test53(MyValue1[].class, MyValue1.ref[].class, len, 3);
1005         test53(MyValue1[].class, MyValue1.ref[].class, len, 4);
1006     }
1007 
<span class="line-modified">1008     // Test asIndirectType intrinsic with non-value mirror</span>
1009     @Test()
1010     public Class&lt;?&gt; test54(Class&lt;?&gt; c) {
<span class="line-modified">1011         if (c.asIndirectType() != Integer.class) {</span>
1012             throw new RuntimeException(&quot;Unexpected class&quot;);
1013         }
<span class="line-modified">1014         return Integer.class.asIndirectType();</span>
1015     }
1016 
1017     @DontCompile
1018     public void test54_verifier(boolean warmup) {
1019         Class&lt;?&gt; result = test54(Integer.class);
1020         Asserts.assertEQ(result, Integer.class);
1021     }
1022 
<span class="line-modified">1023     // Test asPrimaryType intrinsic with non-value mirror</span>
1024     @Test()
1025     public Class&lt;?&gt; test55(Class&lt;?&gt; c) {
<span class="line-modified">1026         if (c.asPrimaryType() != Integer.class) {</span>
1027             throw new RuntimeException(&quot;Unexpected class&quot;);
1028         }
<span class="line-modified">1029         return Integer.class.asPrimaryType();</span>
1030     }
1031 
1032     @DontCompile
1033     public void test55_verifier(boolean warmup) {
1034         Class&lt;?&gt; result = test55(Integer.class);
1035         Asserts.assertEQ(result, Integer.class);
1036     }
1037 
1038     // Same as test39 but Unsafe.putInt to buffer is not intrinsified/compiled
1039     @DontCompile
1040     public void test56_callee(MyValue1.ref v) { // Use .ref here to make sure the argument is not scalarized (otherwise larval information is lost)
1041         U.putInt(v, X_OFFSET, rI);
1042     }
1043 
1044     @Test()
1045     @Warmup(10000) // Fill up the TLAB to trigger slow path allocation
1046     public MyValue1 test56(MyValue1 v) {
1047         v = U.makePrivateBuffer(v);
1048         test56_callee(v);
1049         v = U.finishPrivateBuffer(v);
</pre>
</td>
<td>
<hr />
<pre>
  51         switch (scenario) {
  52         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:ValueArrayElemMaxFlatSize=-1&quot;};
  53         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;};
  54         }
  55         return null;
  56     }
  57 
  58     public static void main(String[] args) throws Throwable {
  59         TestIntrinsics test = new TestIntrinsics();
  60         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  61     }
  62 
  63     // Test correctness of the Class::isAssignableFrom intrinsic
  64     @Test()
  65     public boolean test1(Class&lt;?&gt; supercls, Class&lt;?&gt; subcls) {
  66         return supercls.isAssignableFrom(subcls);
  67     }
  68 
  69     public void test1_verifier(boolean warmup) {
  70         Asserts.assertTrue(test1(java.util.AbstractList.class, java.util.ArrayList.class), &quot;test1_1 failed&quot;);
<span class="line-modified">  71         Asserts.assertTrue(test1(MyValue1.class.referenceType().get(), MyValue1.class.referenceType().get()), &quot;test1_2 failed&quot;);</span>
  72         Asserts.assertTrue(test1(MyValue1.class, MyValue1.class), &quot;test1_3 failed&quot;);
<span class="line-modified">  73         Asserts.assertTrue(test1(MyValue1.class.referenceType().get(), MyValue1.class), &quot;test1_4 failed&quot;);</span>
<span class="line-modified">  74         Asserts.assertFalse(test1(MyValue1.class, MyValue1.class.referenceType().get()), &quot;test1_5 failed&quot;);</span>
  75         Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), &quot;test1_6 failed&quot;);
<span class="line-modified">  76         Asserts.assertTrue(test1(Object.class, MyValue1.class.referenceType().get()), &quot;test1_7 failed&quot;);</span>
  77         Asserts.assertTrue(test1(Object.class, MyValue1.class), &quot;test1_8 failed&quot;);
<span class="line-modified">  78         Asserts.assertTrue(!test1(MyValue1.class.referenceType().get(), Object.class), &quot;test1_9 failed&quot;);</span>
  79         Asserts.assertTrue(!test1(MyValue1.class, Object.class), &quot;test1_10 failed&quot;);
  80     }
  81 
  82     // Verify that Class::isAssignableFrom checks with statically known classes are folded
  83     @Test(failOn = LOADK)
  84     public boolean test2() {
  85         boolean check1 = java.util.AbstractList.class.isAssignableFrom(java.util.ArrayList.class);
<span class="line-modified">  86         boolean check2 = MyValue1.class.referenceType().get().isAssignableFrom(MyValue1.class.referenceType().get());</span>
  87         boolean check3 = MyValue1.class.isAssignableFrom(MyValue1.class);
<span class="line-modified">  88         boolean check4 = MyValue1.class.referenceType().get().isAssignableFrom(MyValue1.class);</span>
<span class="line-modified">  89         boolean check5 = !MyValue1.class.isAssignableFrom(MyValue1.class.referenceType().get());</span>
  90         boolean check6 = Object.class.isAssignableFrom(java.util.ArrayList.class);
<span class="line-modified">  91         boolean check7 = Object.class.isAssignableFrom(MyValue1.class.referenceType().get());</span>
  92         boolean check8 = Object.class.isAssignableFrom(MyValue1.class);
<span class="line-modified">  93         boolean check9 = !MyValue1.class.referenceType().get().isAssignableFrom(Object.class);</span>
  94         boolean check10 = !MyValue1.class.isAssignableFrom(Object.class);
  95         return check1 &amp;&amp; check2 &amp;&amp; check3 &amp;&amp; check4 &amp;&amp; check5 &amp;&amp; check6 &amp;&amp; check7 &amp;&amp; check8 &amp;&amp; check9 &amp;&amp; check10;
  96     }
  97 
  98     public void test2_verifier(boolean warmup) {
  99         Asserts.assertTrue(test2(), &quot;test2 failed&quot;);
 100     }
 101 
 102     // Test correctness of the Class::getSuperclass intrinsic
 103     @Test()
 104     public Class&lt;?&gt; test3(Class&lt;?&gt; cls) {
 105         return cls.getSuperclass();
 106     }
 107 
 108     public void test3_verifier(boolean warmup) {
 109         Asserts.assertTrue(test3(Object.class) == null, &quot;test3_1 failed&quot;);
<span class="line-modified"> 110         Asserts.assertTrue(test3(MyValue1.class.referenceType().get()) == MyValue1.ref.class, &quot;test3_2 failed&quot;);</span>
<span class="line-modified"> 111         Asserts.assertTrue(test3(MyValue1.class.valueType().get()) == MyValue1.ref.class, &quot;test3_3 failed&quot;);</span>
 112         Asserts.assertTrue(test3(Class.class) == Object.class, &quot;test3_4 failed&quot;);
 113     }
 114 
 115     // Verify that Class::getSuperclass checks with statically known classes are folded
 116     @Test(failOn = LOADK)
 117     public boolean test4() {
 118         boolean check1 = Object.class.getSuperclass() == null;
 119         // TODO Remove cast as workaround once javac is fixed
<span class="line-modified"> 120         boolean check2 = (Class&lt;?&gt;)MyValue1.class.referenceType().get().getSuperclass() == MyValue1.ref.class;</span>
 121         // TODO Remove cast as workaround once javac is fixed
<span class="line-modified"> 122         boolean check3 = (Class&lt;?&gt;)MyValue1.class.valueType().get().getSuperclass() == MyValue1.ref.class;</span>
 123         boolean check4 = Class.class.getSuperclass() == Object.class;
 124         return check1 &amp;&amp; check2 &amp;&amp; check3 &amp;&amp; check4;
 125     }
 126 
 127     public void test4_verifier(boolean warmup) {
 128         Asserts.assertTrue(test4(), &quot;test4 failed&quot;);
 129     }
 130 
 131     // Test toString() method
 132     @Test()
 133     public String test5(MyValue1 v) {
 134         return v.toString();
 135     }
 136 
 137     @DontCompile
 138     public void test5_verifier(boolean warmup) {
 139         MyValue1 v = MyValue1.createDefaultInline();
 140         test5(v);
 141     }
 142 
</pre>
<hr />
<pre>
 164     public void test7_verifier(boolean warmup) {
 165         int len = Math.abs(rI) % 42;
 166         long hash = MyValue1.createDefaultDontInline().hashPrimitive();
 167         Object[] va = test7(MyValue1.class, len);
 168         for (int i = 0; i &lt; len; ++i) {
 169             Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);
 170         }
 171     }
 172 
 173     // Class.isInstance
 174     @Test()
 175     public boolean test8(Class c, MyValue1 vt) {
 176         return c.isInstance(vt);
 177     }
 178 
 179     @DontCompile
 180     public void test8_verifier(boolean warmup) {
 181         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 182         boolean result = test8(MyValue1.class, vt);
 183         Asserts.assertTrue(result);
<span class="line-modified"> 184         result = test8(MyValue1.class.referenceType().get(), vt);</span>
 185         Asserts.assertTrue(result);
 186     }
 187 
 188     @Test()
 189     public boolean test9(Class c, MyValue1 vt) {
 190         return c.isInstance(vt);
 191     }
 192 
 193     @DontCompile
 194     public void test9_verifier(boolean warmup) {
 195         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 196         boolean result = test9(MyValue2.class, vt);
 197         Asserts.assertFalse(result);
<span class="line-modified"> 198         result = test9(MyValue2.class.referenceType().get(), vt);</span>
 199         Asserts.assertFalse(result);
 200     }
 201 
 202     // Class.cast
 203     @Test()
 204     public Object test10(Class c, MyValue1 vt) {
 205         return c.cast(vt);
 206     }
 207 
 208     @DontCompile
 209     public void test10_verifier(boolean warmup) {
 210         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 211         Object result = test10(MyValue1.class, vt);
 212         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 213     }
 214 
 215     @Test()
 216     public Object test11(Class c, MyValue1 vt) {
 217         return c.cast(vt);
 218     }
</pre>
<hr />
<pre>
 240     }
 241 
 242     @Test()
 243     public Object test13(MyValue1 vt) {
 244         return MyValue2.class.cast(vt);
 245     }
 246 
 247     @DontCompile
 248     public void test13_verifier(boolean warmup) {
 249         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 250         try {
 251             test13(vt);
 252             throw new RuntimeException(&quot;should have thrown&quot;);
 253         } catch (ClassCastException cce) {
 254         }
 255     }
 256 
 257     // value type array creation via reflection
 258     @Test()
 259     public void test14(int len, long hash) {
<span class="line-modified"> 260         Object[] va = (Object[])Array.newInstance(MyValue1.class.valueType().get().referenceType().get().valueType().get(), len);</span>
 261         for (int i = 0; i &lt; len; ++i) {
 262             Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);
 263         }
 264     }
 265 
 266     @DontCompile
 267     public void test14_verifier(boolean warmup) {
 268         int len = Math.abs(rI) % 42;
 269         long hash = MyValue1.createDefaultDontInline().hashPrimitive();
 270         test14(len, hash);
 271     }
 272 
 273     // Test hashCode() method
 274     @Test()
 275     public int test15(Object v) {
 276         return v.hashCode();
 277     }
 278 
 279     @DontCompile
 280     public void test15_verifier(boolean warmup) {
</pre>
<hr />
<pre>
 436 
 437     @Test
 438     public Test25Value[] test25(Test25Value element) {
 439         // TODO Remove cast as workaround once javac is fixed
 440         Test25Value[] newArray = (Test25Value[])Arrays.copyOf(test25Array, test25Array.length + 1);
 441         newArray[test25Array.length] = element;
 442         return newArray;
 443     }
 444 
 445     @DontCompile
 446     public void test25_verifier(boolean warmup) {
 447         Test25Value vt = new Test25Value();
 448         test25(vt);
 449     }
 450 
 451     @Test
 452     public Object test26() {
 453         Class&lt;?&gt;[] ca = new Class&lt;?&gt;[1];
 454         for (int i = 0; i &lt; 1; ++i) {
 455           // Folds during loop opts
<span class="line-modified"> 456           ca[i] = MyValue1.class.valueType().get();</span>
 457         }
 458         return Array.newInstance(ca[0], 1);
 459     }
 460 
 461     @DontCompile
 462     public void test26_verifier(boolean warmup) {
 463         Object[] res = (Object[])test26();
 464         Asserts.assertEQ(((MyValue1)res[0]).hashPrimitive(), MyValue1.createDefaultInline().hashPrimitive());
 465     }
 466 
 467     // Load non-flattenable value type field with unsafe
 468     MyValue1.ref test27_vt = MyValue1.createWithFieldsInline(rI, rL);
 469     private static final long TEST27_OFFSET;
 470     static {
 471         try {
 472             Field field = TestIntrinsics.class.getDeclaredField(&quot;test27_vt&quot;);
 473             TEST27_OFFSET = U.objectFieldOffset(field);
 474         } catch (Exception e) {
 475             throw new RuntimeException(e);
 476         }
</pre>
<hr />
<pre>
 521         long res = test29(v);
 522         if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {
 523             if (X_OFFSET &lt; Y_OFFSET) {
 524                 Asserts.assertEQ(((int)res) &lt;&lt; 8, (v.x &gt;&gt; 8) &lt;&lt; 8);
 525             } else {
 526                 Asserts.assertEQ(res &lt;&lt; 8, (v.y &gt;&gt; 8) &lt;&lt; 8);
 527             }
 528         } else {
 529             if (X_OFFSET &lt; Y_OFFSET) {
 530                 Asserts.assertEQ(((int)res), v.x &gt;&gt;&gt; 8);
 531             } else {
 532                 Asserts.assertEQ(res, v.y &gt;&gt;&gt; 8);
 533             }
 534         }
 535     }
 536 
 537     // getValue to retrieve flattened field from value
 538     @Test(failOn=CALL_Unsafe)
 539     public MyValue2 test30(MyValue1 v) {
 540         if (V1_FLATTENED) {
<span class="line-modified"> 541             return U.getValue(v, V1_OFFSET, MyValue2.class.valueType().get().referenceType().get().valueType().get());</span>
 542         }
 543         return (MyValue2)U.getReference(v, V1_OFFSET);
 544     }
 545 
 546     @DontCompile
 547     public void test30_verifier(boolean warmup) {
 548         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 549         MyValue2 res = test30(v);
 550         Asserts.assertEQ(res.hash(), v.v1.hash());
 551     }
 552 
 553     MyValue1 test31_vt;
 554     private static final long TEST31_VT_OFFSET;
 555     private static final boolean TEST31_VT_FLATTENED;
 556     static {
 557         try {
 558             Field test31_vt_Field = TestIntrinsics.class.getDeclaredField(&quot;test31_vt&quot;);
 559             TEST31_VT_OFFSET = U.objectFieldOffset(test31_vt_Field);
 560             TEST31_VT_FLATTENED = U.isFlattened(test31_vt_Field);
 561         } catch (Exception e) {
 562             throw new RuntimeException(e);
 563         }
 564     }
 565 
 566     // getValue to retrieve flattened field from object
 567     @Test(failOn=CALL_Unsafe)
 568     public MyValue1 test31() {
 569         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 570             return U.getValue(this, TEST31_VT_OFFSET, MyValue1.class.valueType().get().referenceType().get().valueType().get());</span>
 571         }
 572         return (MyValue1)U.getReference(this, TEST31_VT_OFFSET);
 573     }
 574 
 575     @DontCompile
 576     public void test31_verifier(boolean warmup) {
 577         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 578         MyValue1 res = test31();
 579         Asserts.assertEQ(res.hash(), test31_vt.hash());
 580     }
 581 
 582     // putValue to set flattened field in object
 583     @Test(failOn=CALL_Unsafe)
 584     public void test32(MyValue1 vt) {
 585         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 586             U.putValue(this, TEST31_VT_OFFSET, MyValue1.class.valueType().get().referenceType().get().valueType().get(), vt);</span>
 587         } else {
 588             U.putReference(this, TEST31_VT_OFFSET, vt);
 589         }
 590     }
 591 
 592     @DontCompile
 593     public void test32_verifier(boolean warmup) {
 594         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 595         test31_vt = MyValue1.createDefaultInline();
 596         test32(vt);
 597         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 598     }
 599 
 600     private static final int TEST33_BASE_OFFSET;
 601     private static final int TEST33_INDEX_SCALE;
 602     private static final boolean TEST33_FLATTENED_ARRAY;
 603     static {
 604         try {
 605             TEST33_BASE_OFFSET = U.arrayBaseOffset(MyValue1[].class);
 606             TEST33_INDEX_SCALE = U.arrayIndexScale(MyValue1[].class);
 607             TEST33_FLATTENED_ARRAY = U.isFlattenedArray(MyValue1[].class);
 608         } catch (Exception e) {
 609             throw new RuntimeException(e);
 610         }
 611     }
 612     // getValue to retrieve flattened field from array
 613     @Test(failOn=CALL_Unsafe)
 614     public MyValue1 test33(MyValue1[] arr) {
 615         if (TEST33_FLATTENED_ARRAY) {
<span class="line-modified"> 616             return U.getValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.valueType().get().referenceType().get().valueType().get());</span>
 617         }
 618         return (MyValue1)U.getReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);
 619     }
 620 
 621     @DontCompile
 622     public void test33_verifier(boolean warmup) {
 623         MyValue1[] arr = new MyValue1[2];
 624         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 625         arr[1] = vt;
 626         MyValue1 res = test33(arr);
 627         Asserts.assertEQ(res.hash(), vt.hash());
 628     }
 629 
 630     // putValue to set flattened field in array
 631     @Test(failOn=CALL_Unsafe)
 632     public void test34(MyValue1[] arr, MyValue1 vt) {
 633         if (TEST33_FLATTENED_ARRAY) {
<span class="line-modified"> 634             U.putValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.class.valueType().get().referenceType().get().valueType().get(), vt);</span>
 635         } else {
 636             U.putReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);
 637         }
 638     }
 639 
 640     @DontCompile
 641     public void test34_verifier(boolean warmup) {
 642         MyValue1[] arr = new MyValue1[2];
 643         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 644         test34(arr, vt);
 645         Asserts.assertEQ(arr[1].hash(), vt.hash());
 646     }
 647 
 648     // getValue to retrieve flattened field from object with unknown
 649     // container type
 650     @Test(failOn=CALL_Unsafe)
 651     public MyValue1 test35(Object o) {
 652         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 653             return U.getValue(o, TEST31_VT_OFFSET, MyValue1.class.valueType().get().referenceType().get().valueType().get());</span>
 654         }
 655         return (MyValue1)U.getReference(o, TEST31_VT_OFFSET);
 656     }
 657 
 658     @DontCompile
 659     public void test35_verifier(boolean warmup) {
 660         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 661         MyValue1 res = test35(this);
 662         Asserts.assertEQ(res.hash(), test31_vt.hash());
 663     }
 664 
 665     // getValue to retrieve flattened field from object at unknown
 666     // offset
 667     @Test(failOn=CALL_Unsafe)
 668     public MyValue1 test36(long offset) {
 669         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 670             return U.getValue(this, offset, MyValue1.class.valueType().get().referenceType().get().valueType().get());</span>
 671         }
 672         return (MyValue1)U.getReference(this, offset);
 673     }
 674 
 675     @DontCompile
 676     public void test36_verifier(boolean warmup) {
 677         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 678         MyValue1 res = test36(TEST31_VT_OFFSET);
 679         Asserts.assertEQ(res.hash(), test31_vt.hash());
 680     }
 681 
 682     // putValue to set flattened field in object with unknown
 683     // container
 684     @Test(failOn=CALL_Unsafe)
 685     public void test37(Object o, MyValue1 vt) {
 686         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 687             U.putValue(o, TEST31_VT_OFFSET, MyValue1.class.valueType().get().referenceType().get().valueType().get(), vt);</span>
 688         } else {
 689             U.putReference(o, TEST31_VT_OFFSET, vt);
 690         }
 691     }
 692 
 693     @DontCompile
 694     public void test37_verifier(boolean warmup) {
 695         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 696         test31_vt = MyValue1.createDefaultInline();
 697         test37(this, vt);
 698         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 699     }
 700 
 701     // putValue to set flattened field in object, non value argument
 702     // to store
 703     @Test(match = { CALL_Unsafe }, matchCount = { 1 })
 704     public void test38(Object o) {
 705         if (TEST31_VT_FLATTENED) {
<span class="line-modified"> 706             U.putValue(this, TEST31_VT_OFFSET, MyValue1.class.valueType().get().referenceType().get().valueType().get(), o);</span>
 707         } else {
 708             U.putReference(this, TEST31_VT_OFFSET, o);
 709         }
 710     }
 711 
 712     @DontCompile
 713     public void test38_verifier(boolean warmup) {
 714         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 715         test31_vt = MyValue1.createDefaultInline();
 716         test38(vt);
 717         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 718     }
 719 
 720     @Test(failOn=CALL_Unsafe)
 721     public MyValue1 test39(MyValue1 v) {
 722         v = U.makePrivateBuffer(v);
 723         U.putInt(v, X_OFFSET, rI);
 724         v = U.finishPrivateBuffer(v);
 725         return v;
 726     }
 727 
 728     @DontCompile
 729     public void test39_verifier(boolean warmup) {
 730         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 731         MyValue1 res = test39(v.setX(v, 0));
 732         Asserts.assertEQ(res.hash(), v.hash());
 733     }
 734 
 735     // Test default value type array creation via reflection
 736     @Test()
 737     public Object[] test40(Class&lt;?&gt; componentType, int len) {
 738         Object[] va = (Object[])Array.newInstance(componentType, len);
 739         return va;
 740     }
 741 
 742     @DontCompile
 743     public void test40_verifier(boolean warmup) {
 744         int len = Math.abs(rI) % 42;
<span class="line-modified"> 745         Object[] va = test40(MyValue1.class.referenceType().get(), len);</span>
 746         for (int i = 0; i &lt; len; ++i) {
 747             Asserts.assertEQ(va[i], null);
 748         }
 749     }
 750 
 751     // Class.isInstance
 752     @Test()
 753     public boolean test41(Class c, MyValue1.ref vt) {
 754         return c.isInstance(vt);
 755     }
 756 
 757     @DontCompile
 758     public void test41_verifier(boolean warmup) {
 759         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
<span class="line-modified"> 760         boolean result = test41(MyValue1.class.referenceType().get(), vt);</span>
 761         Asserts.assertTrue(result);
 762         result = test41(MyValue1.class, vt);
 763         Asserts.assertTrue(result);
 764     }
 765 
 766     @Test()
 767     public boolean test42(Class c, MyValue1.ref vt) {
 768         return c.isInstance(vt);
 769     }
 770 
 771     @DontCompile
 772     public void test42_verifier(boolean warmup) {
 773         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
<span class="line-modified"> 774         boolean result = test42(MyValue2.class.referenceType().get(), vt);</span>
 775         Asserts.assertFalse(result);
 776         result = test42(MyValue2.class, vt);
 777         Asserts.assertFalse(result);
 778     }
 779 
 780     // Class.cast
 781     @Test()
 782     public Object test43(Class c, MyValue1.ref vt) {
 783         return c.cast(vt);
 784     }
 785 
 786     @DontCompile
 787     public void test43_verifier(boolean warmup) {
 788         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
<span class="line-modified"> 789         Object result = test43(MyValue1.class.referenceType().get(), vt);</span>
 790         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
<span class="line-modified"> 791         result = test43(MyValue1.class.referenceType().get(), null);</span>
 792         Asserts.assertEQ(result, null);
 793     }
 794 
 795     @Test()
 796     public Object test44(Class c, MyValue1.ref vt) {
 797         return c.cast(vt);
 798     }
 799 
 800     @DontCompile
 801     public void test44_verifier(boolean warmup) {
 802         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 803         try {
<span class="line-modified"> 804             test44(MyValue2.class.referenceType().get(), vt);</span>
 805             throw new RuntimeException(&quot;should have thrown&quot;);
 806         } catch (ClassCastException cce) {
 807         }
 808     }
 809 
 810     @Test()
 811     public Object test45(MyValue1.ref vt) {
<span class="line-modified"> 812         return MyValue1.class.referenceType().get().cast(vt);</span>
 813     }
 814 
 815     @DontCompile
 816     public void test45_verifier(boolean warmup) {
 817         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 818         Object result = test45(vt);
 819         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 820         result = test45(null);
 821         Asserts.assertEQ(result, null);
 822     }
 823 
 824     @Test()
 825     public Object test46(MyValue1.ref vt) {
<span class="line-modified"> 826         return MyValue2.class.referenceType().get().cast(vt);</span>
 827     }
 828 
 829     @DontCompile
 830     public void test46_verifier(boolean warmup) {
 831         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 832         test46(null);
 833         try {
 834             test46(vt);
 835             throw new RuntimeException(&quot;should have thrown&quot;);
 836         } catch (ClassCastException cce) {
 837         }
 838     }
 839 
 840     @Test()
 841     public Object test47(MyValue1.ref vt) {
<span class="line-modified"> 842         return MyValue1.class.valueType().get().cast(vt);</span>
 843     }
 844 
 845     @DontCompile
 846     public void test47_verifier(boolean warmup) {
 847         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 848         Object result = test47(vt);
 849         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 850         try {
 851             test47(null);
 852             throw new RuntimeException(&quot;should have thrown&quot;);
 853         } catch (NullPointerException npe) {
 854         }
 855     }
 856 
 857     @Test()
 858     public Object test48(Class c, MyValue1.ref vt) {
 859         return c.cast(vt);
 860     }
 861 
 862     @DontCompile
 863     public void test48_verifier(boolean warmup) {
 864         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 865         Object result = test48(MyValue1.class, vt);
 866         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 867         try {
 868             test48(MyValue1.class, null);
 869             throw new RuntimeException(&quot;should have thrown&quot;);
 870         } catch (NullPointerException npe) {
 871         }
 872     }
 873 
 874     @Test()
 875     public Object test49(MyValue1 vt) {
<span class="line-modified"> 876         return MyValue1.class.referenceType().get().cast(vt);</span>
 877     }
 878 
 879     @DontCompile
 880     public void test49_verifier(boolean warmup) {
 881         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 882         Object result = test49(vt);
 883         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 884     }
 885 
 886     @Test()
 887     public Object test50(Class c, Object obj) {
 888         return c.cast(obj);
 889     }
 890 
 891     @DontCompile
 892     public void test50_verifier(boolean warmup) {
 893         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 894         MyValue1[] va  = new MyValue1[42];
 895         MyValue1.ref[] vba = new MyValue1.ref[42];
 896         Object result = test50(MyValue1.class, vt);
 897         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
<span class="line-modified"> 898         result = test50(MyValue1.class.referenceType().get(), vt);</span>
 899         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 900         result = test50(MyValue1[].class, va);
 901         Asserts.assertEQ(result, va);
 902         result = test50(MyValue1.ref[].class, vba);
 903         Asserts.assertEQ(result, vba);
 904         result = test50(MyValue1.ref[].class, va);
 905         Asserts.assertEQ(result, va);
 906         try {
 907             test50(MyValue1.class, null);
 908             throw new RuntimeException(&quot;should have thrown&quot;);
 909         } catch (NullPointerException npe) {
 910         }
 911         try {
 912             test50(MyValue1[].class, vba);
 913             throw new RuntimeException(&quot;should have thrown&quot;);
 914         } catch (ClassCastException cce) {
 915         }
 916     }
 917 
 918     // value type array creation via reflection
 919     @Test()
 920     public void test51(int len) {
<span class="line-modified"> 921         Object[] va = (Object[])Array.newInstance(MyValue1.class.referenceType().get().valueType().get().referenceType().get(), len);</span>
 922         for (int i = 0; i &lt; len; ++i) {
 923             Asserts.assertEQ(va[i], null);
 924         }
 925     }
 926 
 927     @DontCompile
 928     public void test51_verifier(boolean warmup) {
 929         int len = Math.abs(rI) % 42;
 930         test51(len);
 931     }
 932 
 933     // multidimensional value type array creation via reflection
 934     @Test()
 935     public Object[][] test52(int len, int val) {
 936         MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);
 937         MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);
 938         Object[][] result;
 939         if (val == 1) {
 940             va1[0] = new MyValue1[1];
 941             result = va1;
</pre>
<hr />
<pre>
 988             result = va4;
 989         }
 990         if ((val == 1 || val == 3) &amp;&amp; len &gt; 0) {
 991             Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());
 992         } else if (len &gt; 0) {
 993             Asserts.assertEQ(result[0][0], null);
 994             result[0][0] = null;
 995         }
 996         return result;
 997     }
 998 
 999     @DontCompile
1000     public void test53_verifier(boolean warmup) {
1001         int len = Math.abs(rI) % 42;
1002         test53(MyValue1[].class, MyValue1.ref[].class, len, 1);
1003         test53(MyValue1[].class, MyValue1.ref[].class, len, 2);
1004         test53(MyValue1[].class, MyValue1.ref[].class, len, 3);
1005         test53(MyValue1[].class, MyValue1.ref[].class, len, 4);
1006     }
1007 
<span class="line-modified">1008     // Test referenceType().get() intrinsic with non-value mirror</span>
1009     @Test()
1010     public Class&lt;?&gt; test54(Class&lt;?&gt; c) {
<span class="line-modified">1011         if (c.referenceType().get() != Integer.class) {</span>
1012             throw new RuntimeException(&quot;Unexpected class&quot;);
1013         }
<span class="line-modified">1014         return Integer.class.referenceType().get();</span>
1015     }
1016 
1017     @DontCompile
1018     public void test54_verifier(boolean warmup) {
1019         Class&lt;?&gt; result = test54(Integer.class);
1020         Asserts.assertEQ(result, Integer.class);
1021     }
1022 
<span class="line-modified">1023     // Test valueType().get intrinsic with non-value mirror</span>
1024     @Test()
1025     public Class&lt;?&gt; test55(Class&lt;?&gt; c) {
<span class="line-modified">1026         if (c.valueType().get() != Integer.class) {</span>
1027             throw new RuntimeException(&quot;Unexpected class&quot;);
1028         }
<span class="line-modified">1029         return Integer.class.valueType().get();</span>
1030     }
1031 
1032     @DontCompile
1033     public void test55_verifier(boolean warmup) {
1034         Class&lt;?&gt; result = test55(Integer.class);
1035         Asserts.assertEQ(result, Integer.class);
1036     }
1037 
1038     // Same as test39 but Unsafe.putInt to buffer is not intrinsified/compiled
1039     @DontCompile
1040     public void test56_callee(MyValue1.ref v) { // Use .ref here to make sure the argument is not scalarized (otherwise larval information is lost)
1041         U.putInt(v, X_OFFSET, rI);
1042     }
1043 
1044     @Test()
1045     @Warmup(10000) // Fill up the TLAB to trigger slow path allocation
1046     public MyValue1 test56(MyValue1 v) {
1047         v = U.makePrivateBuffer(v);
1048         test56_callee(v);
1049         v = U.finishPrivateBuffer(v);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../src/jdk.unsupported/share/classes/sun/misc/Unsafe.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestLWorld.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
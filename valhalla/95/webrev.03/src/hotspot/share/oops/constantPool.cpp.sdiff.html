<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/heapInspection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constantPool.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 385   // at runtime.
 386   set_resolved_reference_length(
 387     resolved_references() != NULL ? resolved_references()-&gt;length() : 0);
 388 
 389   // If archiving heap objects is not allowed, clear the resolved references.
 390   // Otherwise, it is cleared after the resolved references array is cached
 391   // (see archive_resolved_references()).
 392   // If DynamicDumpSharedSpaces is enabled, clear the resolved references also
 393   // as java objects are not archived in the top layer.
 394   if (!HeapShared::is_heap_object_archiving_allowed() || DynamicDumpSharedSpaces) {
 395     set_resolved_references(OopHandle());
 396   }
 397 
 398   // Shared ConstantPools are in the RO region, so the _flags cannot be modified.
 399   // The _on_stack flag is used to prevent ConstantPools from deallocation during
 400   // class redefinition. Since shared ConstantPools cannot be deallocated anyway,
 401   // we always set _on_stack to true to avoid having to change _flags during runtime.
 402   _flags |= (_on_stack | _is_shared);
 403   int num_klasses = 0;
 404   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused

 405     if (!DynamicDumpSharedSpaces) {
 406       assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during static dump time&quot;);
 407     } else {
 408       if (tag_at(index).is_unresolved_klass_in_error() ||
 409           tag_at(index).is_method_handle_in_error()    ||
 410           tag_at(index).is_method_type_in_error()      ||
 411           tag_at(index).is_dynamic_constant_in_error()) {
<span class="line-modified"> 412         tag_at_put(index, JVM_CONSTANT_UnresolvedClass);</span>
 413       }
 414     }
 415     if (tag_at(index).is_klass()) {
 416       // This class was resolved as a side effect of executing Java code
 417       // during dump time. We need to restore it back to an UnresolvedClass,
 418       // so that the proper class loading and initialization can happen
 419       // at runtime.
 420       bool clear_it = true;
 421       if (pool_holder()-&gt;is_hidden() &amp;&amp; index == pool_holder()-&gt;this_class_index()) {
 422         // All references to a hidden class&#39;s own field/methods are through this
 423         // index. We cannot clear it. See comments in ClassFileParser::fill_instance_klass.
 424         clear_it = false;
 425       }
 426       if (clear_it) {
 427         CPKlassSlot kslot = klass_slot_at(index);
 428         int resolved_klass_index = kslot.resolved_klass_index();
 429         int name_index = kslot.name_index();
 430         assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 431         resolved_klasses()-&gt;at_put(resolved_klass_index, NULL);
<span class="line-modified"> 432         tag_at_put(index, JVM_CONSTANT_UnresolvedClass);</span>
 433         assert(klass_name_at(index) == symbol_at(name_index), &quot;sanity&quot;);
 434       }
 435     }
 436   }
 437   if (cache() != NULL) {
 438     cache()-&gt;remove_unshareable_info();
 439   }
 440 }
 441 
 442 int ConstantPool::cp_to_object_index(int cp_index) {
 443   // this is harder don&#39;t do this so much.
 444   int i = reference_map()-&gt;find(cp_index);
 445   // We might not find the index for jsr292 call.
 446   return (i &lt; 0) ? _no_index_sentinel : i;
 447 }
 448 
 449 void ConstantPool::string_at_put(int which, int obj_index, oop str) {
 450   resolved_references()-&gt;obj_at_put(obj_index, str);
 451 }
 452 
</pre>
<hr />
<pre>
 547   if (!HAS_PENDING_EXCEPTION &amp;&amp; inline_type_signature) {
 548     check_is_inline_type(k, THREAD);
 549   }
 550 
 551   if (!HAS_PENDING_EXCEPTION) {
 552     Klass* bottom_klass = NULL;
 553     if (k-&gt;is_objArray_klass()) {
 554       bottom_klass = ObjArrayKlass::cast(k)-&gt;bottom_klass();
 555       assert(bottom_klass != NULL, &quot;Should be set&quot;);
 556       assert(bottom_klass-&gt;is_instance_klass() || bottom_klass-&gt;is_typeArray_klass(), &quot;Sanity check&quot;);
 557     } else if (k-&gt;is_valueArray_klass()) {
 558       bottom_klass = ValueArrayKlass::cast(k)-&gt;element_klass();
 559       assert(bottom_klass != NULL, &quot;Should be set&quot;);
 560     }
 561   }
 562 
 563   // Failed to resolve class. We must record the errors so that subsequent attempts
 564   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 565   if (HAS_PENDING_EXCEPTION) {
 566     if (save_resolution_error) {
<span class="line-modified"> 567       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);</span>




 568       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 569       // some other thread has beaten us and has resolved the class.
 570       // To preserve old behavior, we return the resolved class.
 571       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 572       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 573       return klass;
 574     } else {
 575       return NULL;  // return the pending exception
 576     }
 577   }
 578 
 579   // logging for class+resolve.
 580   if (log_is_enabled(Debug, class, resolve)){
 581     trace_class_resolution(this_cp, k);
 582   }
 583   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 584   Atomic::release_store(adr, k);
 585   // The interpreter assumes when the tag is stored, the klass is resolved
 586   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 587   // hardware store ordering here.
</pre>
</td>
<td>
<hr />
<pre>
 385   // at runtime.
 386   set_resolved_reference_length(
 387     resolved_references() != NULL ? resolved_references()-&gt;length() : 0);
 388 
 389   // If archiving heap objects is not allowed, clear the resolved references.
 390   // Otherwise, it is cleared after the resolved references array is cached
 391   // (see archive_resolved_references()).
 392   // If DynamicDumpSharedSpaces is enabled, clear the resolved references also
 393   // as java objects are not archived in the top layer.
 394   if (!HeapShared::is_heap_object_archiving_allowed() || DynamicDumpSharedSpaces) {
 395     set_resolved_references(OopHandle());
 396   }
 397 
 398   // Shared ConstantPools are in the RO region, so the _flags cannot be modified.
 399   // The _on_stack flag is used to prevent ConstantPools from deallocation during
 400   // class redefinition. Since shared ConstantPools cannot be deallocated anyway,
 401   // we always set _on_stack to true to avoid having to change _flags during runtime.
 402   _flags |= (_on_stack | _is_shared);
 403   int num_klasses = 0;
 404   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
<span class="line-added"> 405     jbyte qdesc_bit = tag_at(index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;</span>
 406     if (!DynamicDumpSharedSpaces) {
 407       assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during static dump time&quot;);
 408     } else {
 409       if (tag_at(index).is_unresolved_klass_in_error() ||
 410           tag_at(index).is_method_handle_in_error()    ||
 411           tag_at(index).is_method_type_in_error()      ||
 412           tag_at(index).is_dynamic_constant_in_error()) {
<span class="line-modified"> 413         tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);</span>
 414       }
 415     }
 416     if (tag_at(index).is_klass()) {
 417       // This class was resolved as a side effect of executing Java code
 418       // during dump time. We need to restore it back to an UnresolvedClass,
 419       // so that the proper class loading and initialization can happen
 420       // at runtime.
 421       bool clear_it = true;
 422       if (pool_holder()-&gt;is_hidden() &amp;&amp; index == pool_holder()-&gt;this_class_index()) {
 423         // All references to a hidden class&#39;s own field/methods are through this
 424         // index. We cannot clear it. See comments in ClassFileParser::fill_instance_klass.
 425         clear_it = false;
 426       }
 427       if (clear_it) {
 428         CPKlassSlot kslot = klass_slot_at(index);
 429         int resolved_klass_index = kslot.resolved_klass_index();
 430         int name_index = kslot.name_index();
 431         assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 432         resolved_klasses()-&gt;at_put(resolved_klass_index, NULL);
<span class="line-modified"> 433         tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);</span>
 434         assert(klass_name_at(index) == symbol_at(name_index), &quot;sanity&quot;);
 435       }
 436     }
 437   }
 438   if (cache() != NULL) {
 439     cache()-&gt;remove_unshareable_info();
 440   }
 441 }
 442 
 443 int ConstantPool::cp_to_object_index(int cp_index) {
 444   // this is harder don&#39;t do this so much.
 445   int i = reference_map()-&gt;find(cp_index);
 446   // We might not find the index for jsr292 call.
 447   return (i &lt; 0) ? _no_index_sentinel : i;
 448 }
 449 
 450 void ConstantPool::string_at_put(int which, int obj_index, oop str) {
 451   resolved_references()-&gt;obj_at_put(obj_index, str);
 452 }
 453 
</pre>
<hr />
<pre>
 548   if (!HAS_PENDING_EXCEPTION &amp;&amp; inline_type_signature) {
 549     check_is_inline_type(k, THREAD);
 550   }
 551 
 552   if (!HAS_PENDING_EXCEPTION) {
 553     Klass* bottom_klass = NULL;
 554     if (k-&gt;is_objArray_klass()) {
 555       bottom_klass = ObjArrayKlass::cast(k)-&gt;bottom_klass();
 556       assert(bottom_klass != NULL, &quot;Should be set&quot;);
 557       assert(bottom_klass-&gt;is_instance_klass() || bottom_klass-&gt;is_typeArray_klass(), &quot;Sanity check&quot;);
 558     } else if (k-&gt;is_valueArray_klass()) {
 559       bottom_klass = ValueArrayKlass::cast(k)-&gt;element_klass();
 560       assert(bottom_klass != NULL, &quot;Should be set&quot;);
 561     }
 562   }
 563 
 564   // Failed to resolve class. We must record the errors so that subsequent attempts
 565   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 566   if (HAS_PENDING_EXCEPTION) {
 567     if (save_resolution_error) {
<span class="line-modified"> 568       jbyte tag = JVM_CONSTANT_UnresolvedClass;</span>
<span class="line-added"> 569       if (this_cp-&gt;tag_at(which).is_Qdescriptor_klass()) {</span>
<span class="line-added"> 570         tag |= JVM_CONSTANT_QDescBit;</span>
<span class="line-added"> 571       }</span>
<span class="line-added"> 572       save_and_throw_exception(this_cp, which, constantTag(tag), CHECK_NULL);</span>
 573       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 574       // some other thread has beaten us and has resolved the class.
 575       // To preserve old behavior, we return the resolved class.
 576       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 577       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 578       return klass;
 579     } else {
 580       return NULL;  // return the pending exception
 581     }
 582   }
 583 
 584   // logging for class+resolve.
 585   if (log_is_enabled(Debug, class, resolve)){
 586     trace_class_resolution(this_cp, k);
 587   }
 588   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 589   Atomic::release_store(adr, k);
 590   // The interpreter assumes when the tag is stored, the klass is resolved
 591   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 592   // hardware store ordering here.
</pre>
</td>
</tr>
</table>
<center><a href="../memory/heapInspection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
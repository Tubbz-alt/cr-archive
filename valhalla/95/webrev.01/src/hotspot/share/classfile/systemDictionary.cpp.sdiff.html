<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1463 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1464                                                    Handle class_loader,
1465                                                    Handle protection_domain,
1466                                                    const ClassFileStream *cfs,
1467                                                    PackageEntry* pkg_entry,
1468                                                    TRAPS) {
1469   assert(ik != NULL, &quot;sanity&quot;);
1470   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1471   Symbol* class_name = ik-&gt;name();
1472 
1473   bool visible = is_shared_class_visible(
1474                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1475   if (!visible) {
1476     return NULL;
1477   }
1478 
1479   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1480     return NULL;
1481   }
1482 


















1483   InstanceKlass* new_ik = NULL;
1484   // CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).
1485   // It will be skipped for shared VM hidden lambda proxy classes.
1486   if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {
1487     new_ik = KlassFactory::check_shared_class_file_load_hook(
1488       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1489   }
1490   if (new_ik != NULL) {
1491     // The class is changed by CFLH. Return the new class. The shared class is
1492     // not used.
1493     return new_ik;
1494   }
1495 
1496   // Adjust methods to recover missing data.  They need addresses for
1497   // interpreter entry points and their default native method address
1498   // must be reset.
1499 
1500   // Updating methods must be done under a lock so multiple
1501   // threads don&#39;t update these in parallel
1502   //
1503   // Shared classes are all currently loaded by either the bootstrap or
1504   // internal parallel class loaders, so this will never cause a deadlock
1505   // on a custom class loader lock.
1506 
1507   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1508   {
1509     HandleMark hm(THREAD);
1510     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1511     check_loader_lock_contention(lockObject, THREAD);
1512     ObjectLocker ol(lockObject, THREAD, true);
1513     // prohibited package check assumes all classes loaded from archive call
1514     // restore_unshareable_info which calls ik-&gt;set_package()
1515     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1516   }
1517 
1518   load_shared_class_misc(ik, loader_data, CHECK_NULL);







1519   return ik;
1520 }
1521 
1522 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1523   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1524 
1525   // For boot loader, ensure that GetSystemPackage knows that a class in this
1526   // package was loaded.
1527   if (loader_data-&gt;is_the_null_class_loader_data()) {
1528     int path_index = ik-&gt;shared_classpath_index();
1529     ik-&gt;set_classpath_index(path_index, THREAD);
1530   }
1531 
1532   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1533     // Only dump the classes that can be stored into CDS archive
1534     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1535       ResourceMark rm(THREAD);
1536       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1537       classlist_file-&gt;flush();
1538     }
</pre>
<hr />
<pre>
1562   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1563   if (klass-&gt;class_loader_data() != NULL) {
1564     return;
1565   }
1566 
1567   // add super and interfaces first
1568   Klass* super = klass-&gt;super();
1569   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1570     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1571     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1572   }
1573 
1574   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1575   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1576     InstanceKlass* ik = ifs-&gt;at(i);
1577     if (ik-&gt;class_loader_data()  == NULL) {
1578       quick_resolve(ik, loader_data, domain, CHECK);
1579     }
1580   }
1581 















1582   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1583   load_shared_class_misc(klass, loader_data, CHECK);
1584   Dictionary* dictionary = loader_data-&gt;dictionary();
1585   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1586   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1587   add_to_hierarchy(klass, CHECK);
1588   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1589 }
1590 #endif // INCLUDE_CDS
1591 
1592 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1593 
1594   if (class_loader.is_null()) {
1595     ResourceMark rm(THREAD);
1596     PackageEntry* pkg_entry = NULL;
1597     bool search_only_bootloader_append = false;
1598     ClassLoaderData *loader_data = class_loader_data(class_loader);
1599 
1600     // Find the package in the boot loader&#39;s package entry table.
1601     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
</pre>
</td>
<td>
<hr />
<pre>
1463 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1464                                                    Handle class_loader,
1465                                                    Handle protection_domain,
1466                                                    const ClassFileStream *cfs,
1467                                                    PackageEntry* pkg_entry,
1468                                                    TRAPS) {
1469   assert(ik != NULL, &quot;sanity&quot;);
1470   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1471   Symbol* class_name = ik-&gt;name();
1472 
1473   bool visible = is_shared_class_visible(
1474                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1475   if (!visible) {
1476     return NULL;
1477   }
1478 
1479   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1480     return NULL;
1481   }
1482 
<span class="line-added">1483 </span>
<span class="line-added">1484   if (ik-&gt;has_inline_type_fields()) {</span>
<span class="line-added">1485     for (AllFieldStream fs(ik-&gt;fields(), ik-&gt;constants()); !fs.done(); fs.next()) {</span>
<span class="line-added">1486       if (Signature::basic_type(fs.signature()) == T_VALUETYPE) {</span>
<span class="line-added">1487         if (!fs.access_flags().is_static()) {</span>
<span class="line-added">1488           // Pre-load inline class</span>
<span class="line-added">1489           Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="line-added">1490             class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="line-added">1491           Klass* k = ik-&gt;get_inline_type_field_klass_or_null(fs.index());</span>
<span class="line-added">1492           if (real_k != k) {</span>
<span class="line-added">1493             // oops, the app has substituted a different version of k!</span>
<span class="line-added">1494             return NULL;</span>
<span class="line-added">1495           }</span>
<span class="line-added">1496         }</span>
<span class="line-added">1497       }</span>
<span class="line-added">1498     }</span>
<span class="line-added">1499   }</span>
<span class="line-added">1500 </span>
1501   InstanceKlass* new_ik = NULL;
1502   // CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).
1503   // It will be skipped for shared VM hidden lambda proxy classes.
1504   if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {
1505     new_ik = KlassFactory::check_shared_class_file_load_hook(
1506       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1507   }
1508   if (new_ik != NULL) {
1509     // The class is changed by CFLH. Return the new class. The shared class is
1510     // not used.
1511     return new_ik;
1512   }
1513 
1514   // Adjust methods to recover missing data.  They need addresses for
1515   // interpreter entry points and their default native method address
1516   // must be reset.
1517 
1518   // Updating methods must be done under a lock so multiple
1519   // threads don&#39;t update these in parallel
1520   //
1521   // Shared classes are all currently loaded by either the bootstrap or
1522   // internal parallel class loaders, so this will never cause a deadlock
1523   // on a custom class loader lock.
1524 
1525   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1526   {
1527     HandleMark hm(THREAD);
1528     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1529     check_loader_lock_contention(lockObject, THREAD);
1530     ObjectLocker ol(lockObject, THREAD, true);
1531     // prohibited package check assumes all classes loaded from archive call
1532     // restore_unshareable_info which calls ik-&gt;set_package()
1533     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1534   }
1535 
1536   load_shared_class_misc(ik, loader_data, CHECK_NULL);
<span class="line-added">1537 </span>
<span class="line-added">1538   if (ik-&gt;is_inline_klass()) {</span>
<span class="line-added">1539     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">1540     oop val = ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">1541     vk-&gt;set_default_value(val);</span>
<span class="line-added">1542   }</span>
<span class="line-added">1543 </span>
1544   return ik;
1545 }
1546 
1547 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1548   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1549 
1550   // For boot loader, ensure that GetSystemPackage knows that a class in this
1551   // package was loaded.
1552   if (loader_data-&gt;is_the_null_class_loader_data()) {
1553     int path_index = ik-&gt;shared_classpath_index();
1554     ik-&gt;set_classpath_index(path_index, THREAD);
1555   }
1556 
1557   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1558     // Only dump the classes that can be stored into CDS archive
1559     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1560       ResourceMark rm(THREAD);
1561       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1562       classlist_file-&gt;flush();
1563     }
</pre>
<hr />
<pre>
1587   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1588   if (klass-&gt;class_loader_data() != NULL) {
1589     return;
1590   }
1591 
1592   // add super and interfaces first
1593   Klass* super = klass-&gt;super();
1594   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1595     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1596     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1597   }
1598 
1599   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1600   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1601     InstanceKlass* ik = ifs-&gt;at(i);
1602     if (ik-&gt;class_loader_data()  == NULL) {
1603       quick_resolve(ik, loader_data, domain, CHECK);
1604     }
1605   }
1606 
<span class="line-added">1607   if (klass-&gt;has_inline_type_fields()) {</span>
<span class="line-added">1608     for (AllFieldStream fs(klass-&gt;fields(), klass-&gt;constants()); !fs.done(); fs.next()) {</span>
<span class="line-added">1609       if (Signature::basic_type(fs.signature()) == T_VALUETYPE) {</span>
<span class="line-added">1610         if (!fs.access_flags().is_static()) {</span>
<span class="line-added">1611           Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="line-added">1612             Handle(THREAD, loader_data-&gt;class_loader()), domain, true, CHECK);</span>
<span class="line-added">1613           Klass* k = klass-&gt;get_inline_type_field_klass_or_null(fs.index());</span>
<span class="line-added">1614           assert(real_k == k, &quot;oops, the app has substituted a different version of k!&quot;);</span>
<span class="line-added">1615         } else {</span>
<span class="line-added">1616           klass-&gt;reset_inline_type_field_klass(fs.index());</span>
<span class="line-added">1617         }</span>
<span class="line-added">1618       }</span>
<span class="line-added">1619     }</span>
<span class="line-added">1620   }</span>
<span class="line-added">1621 </span>
1622   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1623   load_shared_class_misc(klass, loader_data, CHECK);
1624   Dictionary* dictionary = loader_data-&gt;dictionary();
1625   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1626   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1627   add_to_hierarchy(klass, CHECK);
1628   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1629 }
1630 #endif // INCLUDE_CDS
1631 
1632 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1633 
1634   if (class_loader.is_null()) {
1635     ResourceMark rm(THREAD);
1636     PackageEntry* pkg_entry = NULL;
1637     bool search_only_bootloader_append = false;
1638     ClassLoaderData *loader_data = class_loader_data(class_loader);
1639 
1640     // Find the package in the boot loader&#39;s package entry table.
1641     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
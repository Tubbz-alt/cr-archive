<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  53 #include &quot;oops/valueArrayKlass.hpp&quot;
  54 #include &quot;runtime/atomic.hpp&quot;
  55 #include &quot;runtime/handles.inline.hpp&quot;
  56 #include &quot;runtime/init.hpp&quot;
  57 #include &quot;runtime/javaCalls.hpp&quot;
  58 #include &quot;runtime/signature.hpp&quot;
  59 #include &quot;runtime/thread.inline.hpp&quot;
  60 #include &quot;runtime/vframe.inline.hpp&quot;
  61 #include &quot;utilities/copy.hpp&quot;
  62 
  63 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  64   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  65   int size = ConstantPool::size(length);
  66   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  67 }
  68 
  69 void ConstantPool::copy_fields(const ConstantPool* orig) {
  70   // Preserve dynamic constant information from the original pool
  71   if (orig-&gt;has_dynamic_constant()) {
  72     set_has_dynamic_constant();
  73   }
  74 
  75   // Copy class version
  76   set_major_version(orig-&gt;major_version());
  77   set_minor_version(orig-&gt;minor_version());
  78 
  79   set_source_file_name_index(orig-&gt;source_file_name_index());
  80   set_generic_signature_index(orig-&gt;generic_signature_index());
  81 }
  82 
  83 #ifdef ASSERT
  84 
  85 // MetaspaceObj allocation invariant is calloc equivalent memory
  86 // simple verification of this here (JVM_CONSTANT_Invalid == 0 )
  87 static bool tag_array_is_zero_initialized(Array&lt;u1&gt;* tags) {
  88   assert(tags != NULL, &quot;invariant&quot;);
  89   const int length = tags-&gt;length();
  90   for (int index = 0; index &lt; length; ++index) {
  91     if (JVM_CONSTANT_Invalid != tags-&gt;at(index)) {
  92       return false;
  93     }
  94   }
  95   return true;
  96 }
  97 
  98 #endif
  99 
 100 ConstantPool::ConstantPool(Array&lt;u1&gt;* tags) :
 101   _tags(tags),
 102   _length(tags-&gt;length()) {
 103 
 104     assert(_tags != NULL, &quot;invariant&quot;);
 105     assert(tags-&gt;length() == _length, &quot;invariant&quot;);
 106     assert(tag_array_is_zero_initialized(tags), &quot;invariant&quot;);
 107     assert(0 == flags(), &quot;invariant&quot;);
 108     assert(0 == version(), &quot;invariant&quot;);
 109     assert(NULL == _pool_holder, &quot;invariant&quot;);
 110 }
 111 
 112 void ConstantPool::deallocate_contents(ClassLoaderData* loader_data) {
 113   if (cache() != NULL) {
 114     MetadataFactory::free_metadata(loader_data, cache());
 115     set_cache(NULL);
 116   }
 117 
 118   MetadataFactory::free_array&lt;Klass*&gt;(loader_data, resolved_klasses());
 119   set_resolved_klasses(NULL);
 120 
 121   MetadataFactory::free_array&lt;jushort&gt;(loader_data, operands());
 122   set_operands(NULL);
 123 
 124   release_C_heap_structures();
 125 
 126   // free tag array
 127   MetadataFactory::free_array&lt;u1&gt;(loader_data, tags());
 128   set_tags(NULL);
 129 }
 130 
 131 void ConstantPool::release_C_heap_structures() {
 132   // walk constant pool and decrement symbol reference counts
 133   unreference_symbols();
 134 }
 135 
 136 void ConstantPool::metaspace_pointers_do(MetaspaceClosure* it) {
 137   log_trace(cds)(&quot;Iter(ConstantPool): %p&quot;, this);
 138 
 139   it-&gt;push(&amp;_tags, MetaspaceClosure::_writable);
 140   it-&gt;push(&amp;_cache);
 141   it-&gt;push(&amp;_pool_holder);
 142   it-&gt;push(&amp;_operands);
 143   it-&gt;push(&amp;_resolved_klasses, MetaspaceClosure::_writable);
 144 
 145   for (int i = 0; i &lt; length(); i++) {
 146     // The only MSO&#39;s embedded in the CP entries are Symbols:
 147     //   JVM_CONSTANT_String (normal and pseudo)
 148     //   JVM_CONSTANT_Utf8
 149     constantTag ctag = tag_at(i);
 150     if (ctag.is_string() || ctag.is_utf8()) {
 151       it-&gt;push(symbol_at_addr(i));
 152     }
 153   }
 154 }
 155 
 156 objArrayOop ConstantPool::resolved_references() const {
 157   return (objArrayOop)_cache-&gt;resolved_references();
 158 }
 159 
 160 // Called from outside constant pool resolution where a resolved_reference array
 161 // may not be present.
 162 objArrayOop ConstantPool::resolved_references_or_null() const {
 163   if (_cache == NULL) {
 164     return NULL;
 165   } else {
 166     return (objArrayOop)_cache-&gt;resolved_references();
 167   }
 168 }
 169 
 170 // Create resolved_references array and mapping array for original cp indexes
 171 // The ldc bytecode was rewritten to have the resolved reference array index so need a way
 172 // to map it back for resolving and some unlikely miscellaneous uses.
 173 // The objects created by invokedynamic are appended to this list.
 174 void ConstantPool::initialize_resolved_references(ClassLoaderData* loader_data,
 175                                                   const intStack&amp; reference_map,
 176                                                   int constant_pool_map_length,
 177                                                   TRAPS) {
 178   // Initialized the resolved object cache.
 179   int map_length = reference_map.length();
 180   if (map_length &gt; 0) {
 181     // Only need mapping back to constant pool entries.  The map isn&#39;t used for
 182     // invokedynamic resolved_reference entries.  For invokedynamic entries,
 183     // the constant pool cache index has the mapping back to both the constant
 184     // pool and to the resolved reference index.
 185     if (constant_pool_map_length &gt; 0) {
 186       Array&lt;u2&gt;* om = MetadataFactory::new_array&lt;u2&gt;(loader_data, constant_pool_map_length, CHECK);
 187 
 188       for (int i = 0; i &lt; constant_pool_map_length; i++) {
 189         int x = reference_map.at(i);
 190         assert(x == (int)(jushort) x, &quot;klass index is too big&quot;);
 191         om-&gt;at_put(i, (jushort)x);
 192       }
 193       set_reference_map(om);
 194     }
 195 
 196     // Create Java array for holding resolved strings, methodHandles,
 197     // methodTypes, invokedynamic and invokehandle appendix objects, etc.
 198     objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 199     Handle refs_handle (THREAD, (oop)stom);  // must handleize.
 200     set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 201   }
 202 }
 203 
 204 void ConstantPool::allocate_resolved_klasses(ClassLoaderData* loader_data, int num_klasses, TRAPS) {
 205   // A ConstantPool can&#39;t possibly have 0xffff valid class entries,
 206   // because entry #0 must be CONSTANT_Invalid, and each class entry must refer to a UTF8
 207   // entry for the class&#39;s name. So at most we will have 0xfffe class entries.
 208   // This allows us to use 0xffff (ConstantPool::_temp_resolved_klass_index) to indicate
 209   // UnresolvedKlass entries that are temporarily created during class redefinition.
 210   assert(num_klasses &lt; CPKlassSlot::_temp_resolved_klass_index, &quot;sanity&quot;);
 211   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 212   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 213   set_resolved_klasses(rk);
 214 }
 215 
 216 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 217   int len = length();
 218   int num_klasses = 0;
 219   for (int i = 1; i &lt;len; i++) {
 220     switch (tag_at(i).value()) {
 221     case JVM_CONSTANT_ClassIndex:
 222       {
 223         const int class_index = klass_index_at(i);
 224         unresolved_klass_at_put(i, class_index, num_klasses++);
 225       }
 226       break;
 227 #ifndef PRODUCT
 228     case JVM_CONSTANT_Class:
 229     case JVM_CONSTANT_UnresolvedClass:
 230     case JVM_CONSTANT_UnresolvedClassInError:
 231       // All of these should have been reverted back to Unresolved before calling
 232       // this function.
 233       ShouldNotReachHere();
 234 #endif
 235     }
 236   }
 237   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 238 }
 239 
 240 // Unsafe anonymous class support:
 241 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 242   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 243   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 244   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 245   *int_at_addr(class_index) =
 246     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 247 
 248   symbol_at_put(name_index, name);
 249   name-&gt;increment_refcount();
 250   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 251   Atomic::release_store(adr, k);
 252 
 253   // The interpreter assumes when the tag is stored, the klass is resolved
 254   // and the Klass* non-NULL, so we need hardware store ordering here.
 255   jbyte qdesc_bit = (name-&gt;is_Q_signature()) ? (jbyte) JVM_CONSTANT_QDescBit : 0;
 256   if (k != NULL) {
 257     release_tag_at_put(class_index, JVM_CONSTANT_Class | qdesc_bit);
 258   } else {
 259     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);
 260   }
 261 }
 262 
 263 // Unsafe anonymous class support:
 264 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 265   assert(k != NULL, &quot;must be valid klass&quot;);
 266   CPKlassSlot kslot = klass_slot_at(class_index);
 267   int resolved_klass_index = kslot.resolved_klass_index();
 268   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 269   Atomic::release_store(adr, k);
 270 
 271   // The interpreter assumes when the tag is stored, the klass is resolved
 272   // and the Klass* non-NULL, so we need hardware store ordering here.
 273   assert(!k-&gt;name()-&gt;is_Q_signature(), &quot;Q-type without JVM_CONSTANT_QDescBit&quot;);
 274   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 275 }
 276 
 277 #if INCLUDE_CDS_JAVA_HEAP
 278 // Archive the resolved references
 279 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 280   if (_cache == NULL) {
 281     return; // nothing to do
 282   }
 283 
 284   InstanceKlass *ik = pool_holder();
 285   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 286         ik-&gt;is_shared_app_class())) {
 287     // Archiving resolved references for classes from non-builtin loaders
 288     // is not yet supported.
 289     set_resolved_references(OopHandle());
 290     return;
 291   }
 292 
 293   objArrayOop rr = resolved_references();
 294   Array&lt;u2&gt;* ref_map = reference_map();
 295   if (rr != NULL) {
 296     int ref_map_len = ref_map == NULL ? 0 : ref_map-&gt;length();
 297     int rr_len = rr-&gt;length();
 298     for (int i = 0; i &lt; rr_len; i++) {
 299       oop p = rr-&gt;obj_at(i);
 300       rr-&gt;obj_at_put(i, NULL);
 301       if (p != NULL &amp;&amp; i &lt; ref_map_len) {
 302         int index = object_to_cp_index(i);
 303         if (tag_at(index).is_string()) {
 304           oop op = StringTable::create_archived_string(p, THREAD);
 305           // If the String object is not archived (possibly too large),
 306           // NULL is returned. Also set it in the array, so we won&#39;t
 307           // have a &#39;bad&#39; reference in the archived resolved_reference
 308           // array.
 309           rr-&gt;obj_at_put(i, op);
 310         }
 311       }
 312     }
 313 
 314     oop archived = HeapShared::archive_heap_object(rr, THREAD);
 315     // If the resolved references array is not archived (too large),
 316     // the &#39;archived&#39; object is NULL. No need to explicitly check
 317     // the return value of archive_heap_object here. At runtime, the
 318     // resolved references will be created using the normal process
 319     // when there is no archived value.
 320     _cache-&gt;set_archived_references(archived);
 321     set_resolved_references(OopHandle());
 322   }
 323 }
 324 
 325 void ConstantPool::resolve_class_constants(TRAPS) {
 326   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
 327   // The _cache may be NULL if the _pool_holder klass fails verification
 328   // at dump time due to missing dependencies.
 329   if (cache() == NULL || reference_map() == NULL) {
 330     return; // nothing to do
 331   }
 332 
 333   constantPoolHandle cp(THREAD, this);
 334   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
 335     if (tag_at(index).is_string() &amp;&amp; !cp-&gt;is_pseudo_string_at(index)) {
 336       int cache_index = cp-&gt;cp_to_object_index(index);
 337       string_at_impl(cp, index, cache_index, CHECK);
 338     }
 339   }
 340 }
 341 #endif
 342 
 343 // CDS support. Create a new resolved_references array.
 344 void ConstantPool::restore_unshareable_info(TRAPS) {
 345   assert(is_constantPool(), &quot;ensure C++ vtable is restored&quot;);
 346   assert(on_stack(), &quot;should always be set for shared constant pools&quot;);
 347   assert(is_shared(), &quot;should always be set for shared constant pools&quot;);
 348   assert(_cache != NULL, &quot;constant pool _cache should not be NULL&quot;);
 349 
 350   // Only create the new resolved references array if it hasn&#39;t been attempted before
 351   if (resolved_references() != NULL) return;
 352 
 353   // restore the C++ vtable from the shared archive
 354   restore_vtable();
 355 
 356   if (SystemDictionary::Object_klass_loaded()) {
 357     ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
 358 #if INCLUDE_CDS_JAVA_HEAP
 359     if (HeapShared::open_archive_heap_region_mapped() &amp;&amp;
 360         _cache-&gt;archived_references() != NULL) {
 361       oop archived = _cache-&gt;archived_references();
 362       // Create handle for the archived resolved reference array object
 363       Handle refs_handle(THREAD, archived);
 364       set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 365     } else
 366 #endif
 367     {
 368       // No mapped archived resolved reference array
 369       // Recreate the object array and add to ClassLoaderData.
 370       int map_length = resolved_reference_length();
 371       if (map_length &gt; 0) {
 372         objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 373         Handle refs_handle(THREAD, (oop)stom);  // must handleize.
 374         set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 375       }
 376     }
 377   }
 378 }
 379 
 380 void ConstantPool::remove_unshareable_info() {
 381   // Resolved references are not in the shared archive.
 382   // Save the length for restoration.  It is not necessarily the same length
 383   // as reference_map.length() if invokedynamic is saved. It is needed when
 384   // re-creating the resolved reference array if archived heap data cannot be map
 385   // at runtime.
 386   set_resolved_reference_length(
 387     resolved_references() != NULL ? resolved_references()-&gt;length() : 0);
 388 
 389   // If archiving heap objects is not allowed, clear the resolved references.
 390   // Otherwise, it is cleared after the resolved references array is cached
 391   // (see archive_resolved_references()).
 392   // If DynamicDumpSharedSpaces is enabled, clear the resolved references also
 393   // as java objects are not archived in the top layer.
 394   if (!HeapShared::is_heap_object_archiving_allowed() || DynamicDumpSharedSpaces) {
 395     set_resolved_references(OopHandle());
 396   }
 397 
 398   // Shared ConstantPools are in the RO region, so the _flags cannot be modified.
 399   // The _on_stack flag is used to prevent ConstantPools from deallocation during
 400   // class redefinition. Since shared ConstantPools cannot be deallocated anyway,
 401   // we always set _on_stack to true to avoid having to change _flags during runtime.
 402   _flags |= (_on_stack | _is_shared);
 403   int num_klasses = 0;
 404   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
 405     jbyte qdesc_bit = tag_at(index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;
 406     if (!DynamicDumpSharedSpaces) {
 407       assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during static dump time&quot;);
 408     } else {
 409       if (tag_at(index).is_unresolved_klass_in_error() ||
 410           tag_at(index).is_method_handle_in_error()    ||
 411           tag_at(index).is_method_type_in_error()      ||
 412           tag_at(index).is_dynamic_constant_in_error()) {
 413         tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);
 414       }
 415     }
 416     if (tag_at(index).is_klass()) {
 417       // This class was resolved as a side effect of executing Java code
 418       // during dump time. We need to restore it back to an UnresolvedClass,
 419       // so that the proper class loading and initialization can happen
 420       // at runtime.
 421       bool clear_it = true;
 422       if (pool_holder()-&gt;is_hidden() &amp;&amp; index == pool_holder()-&gt;this_class_index()) {
 423         // All references to a hidden class&#39;s own field/methods are through this
 424         // index. We cannot clear it. See comments in ClassFileParser::fill_instance_klass.
 425         clear_it = false;
 426       }
 427       if (clear_it) {
 428         CPKlassSlot kslot = klass_slot_at(index);
 429         int resolved_klass_index = kslot.resolved_klass_index();
 430         int name_index = kslot.name_index();
 431         assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 432         resolved_klasses()-&gt;at_put(resolved_klass_index, NULL);
 433         tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);
 434         assert(klass_name_at(index) == symbol_at(name_index), &quot;sanity&quot;);
 435       }
 436     }
 437   }
 438   if (cache() != NULL) {
 439     cache()-&gt;remove_unshareable_info();
 440   }
 441 }
 442 
 443 int ConstantPool::cp_to_object_index(int cp_index) {
 444   // this is harder don&#39;t do this so much.
 445   int i = reference_map()-&gt;find(cp_index);
 446   // We might not find the index for jsr292 call.
 447   return (i &lt; 0) ? _no_index_sentinel : i;
 448 }
 449 
 450 void ConstantPool::string_at_put(int which, int obj_index, oop str) {
 451   resolved_references()-&gt;obj_at_put(obj_index, str);
 452 }
 453 
 454 void ConstantPool::trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k) {
 455   ResourceMark rm;
 456   int line_number = -1;
 457   const char * source_file = NULL;
 458   if (JavaThread::current()-&gt;has_last_Java_frame()) {
 459     // try to identify the method which called this function.
 460     vframeStream vfst(JavaThread::current());
 461     if (!vfst.at_end()) {
 462       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 463       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 464       if (s != NULL) {
 465         source_file = s-&gt;as_C_string();
 466       }
 467     }
 468   }
 469   if (k != this_cp-&gt;pool_holder()) {
 470     // only print something if the classes are different
 471     if (source_file != NULL) {
 472       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 473                  this_cp-&gt;pool_holder()-&gt;external_name(),
 474                  k-&gt;external_name(), source_file, line_number);
 475     } else {
 476       log_debug(class, resolve)(&quot;%s %s&quot;,
 477                  this_cp-&gt;pool_holder()-&gt;external_name(),
 478                  k-&gt;external_name());
 479     }
 480   }
 481 }
 482 
 483 void check_is_inline_type(Klass* k, TRAPS) {
 484   if (!k-&gt;is_inline_klass()) {
 485     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 486   }
 487 }
 488 
 489 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 490                                    bool save_resolution_error, TRAPS) {
 491   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 492   JavaThread* javaThread = (JavaThread*)THREAD;
 493 
 494   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 495   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 496   // the entry and tag is not updated atomicly.
 497   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 498   int resolved_klass_index = kslot.resolved_klass_index();
 499   int name_index = kslot.name_index();
 500   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 501 
 502   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 503   if (klass != NULL) {
 504     return klass;
 505   }
 506 
 507   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 508   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 509     // The original attempt to resolve this constant pool entry failed so find the
 510     // class of the original error and throw another error of the same class
 511     // (JVMS 5.4.3).
 512     // If there is a detail message, pass that detail message to the error.
 513     // The JVMS does not strictly require us to duplicate the same detail message,
 514     // or any internal exception fields such as cause or stacktrace.  But since the
 515     // detail message is often a class name or other literal string, we will repeat it
 516     // if we can find it in the symbol table.
 517     throw_resolution_error(this_cp, which, CHECK_NULL);
 518     ShouldNotReachHere();
 519   }
 520 
 521   Handle mirror_handle;
 522   Symbol* name = this_cp-&gt;symbol_at(name_index);
 523   bool inline_type_signature = false;
 524   if (name-&gt;is_Q_signature()) {
 525     name = name-&gt;fundamental_name(THREAD);
 526     inline_type_signature = true;
 527   }
 528   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 529   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 530 
 531   Klass* k;
 532   {
 533     // Turn off the single stepping while doing class resolution
 534     JvmtiHideSingleStepping jhss(javaThread);
 535     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 536   } //  JvmtiHideSingleStepping jhss(javaThread);
 537   if (inline_type_signature) {
 538     name-&gt;decrement_refcount();
 539   }
 540 
 541   if (!HAS_PENDING_EXCEPTION) {
 542     // preserve the resolved klass from unloading
 543     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 544     // Do access check for klasses
 545     verify_constant_pool_resolve(this_cp, k, THREAD);
 546   }
 547 
 548   if (!HAS_PENDING_EXCEPTION &amp;&amp; inline_type_signature) {
 549     check_is_inline_type(k, THREAD);
 550   }
 551 
 552   if (!HAS_PENDING_EXCEPTION) {
 553     Klass* bottom_klass = NULL;
 554     if (k-&gt;is_objArray_klass()) {
 555       bottom_klass = ObjArrayKlass::cast(k)-&gt;bottom_klass();
 556       assert(bottom_klass != NULL, &quot;Should be set&quot;);
 557       assert(bottom_klass-&gt;is_instance_klass() || bottom_klass-&gt;is_typeArray_klass(), &quot;Sanity check&quot;);
 558     } else if (k-&gt;is_valueArray_klass()) {
 559       bottom_klass = ValueArrayKlass::cast(k)-&gt;element_klass();
 560       assert(bottom_klass != NULL, &quot;Should be set&quot;);
 561     }
 562   }
 563 
 564   // Failed to resolve class. We must record the errors so that subsequent attempts
 565   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 566   if (HAS_PENDING_EXCEPTION) {
 567     if (save_resolution_error) {
 568       jbyte tag = JVM_CONSTANT_UnresolvedClass;
 569       if (this_cp-&gt;tag_at(which).is_Qdescriptor_klass()) {
 570         tag |= JVM_CONSTANT_QDescBit;
 571       }
 572       save_and_throw_exception(this_cp, which, constantTag(tag), CHECK_NULL);
 573       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 574       // some other thread has beaten us and has resolved the class.
 575       // To preserve old behavior, we return the resolved class.
 576       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 577       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 578       return klass;
 579     } else {
 580       return NULL;  // return the pending exception
 581     }
 582   }
 583 
 584   // logging for class+resolve.
 585   if (log_is_enabled(Debug, class, resolve)){
 586     trace_class_resolution(this_cp, k);
 587   }
 588   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 589   Atomic::release_store(adr, k);
 590   // The interpreter assumes when the tag is stored, the klass is resolved
 591   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 592   // hardware store ordering here.
 593   jbyte tag = JVM_CONSTANT_Class;
 594   if (this_cp-&gt;tag_at(which).is_Qdescriptor_klass()) {
 595     tag |= JVM_CONSTANT_QDescBit;
 596   }
 597   this_cp-&gt;release_tag_at_put(which, tag);
 598   return k;
 599 }
 600 
 601 
 602 // Does not update ConstantPool* - to avoid any exception throwing. Used
 603 // by compiler and exception handling.  Also used to avoid classloads for
 604 // instanceof operations. Returns NULL if the class has not been loaded or
 605 // if the verification of constant pool failed
 606 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 607   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 608   int resolved_klass_index = kslot.resolved_klass_index();
 609   int name_index = kslot.name_index();
 610   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 611 
 612   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 613   if (k != NULL) {
 614     return k;
 615   } else {
 616     Thread *thread = Thread::current();
 617     Symbol* name = this_cp-&gt;symbol_at(name_index);
 618     oop loader = this_cp-&gt;pool_holder()-&gt;class_loader();
 619     oop protection_domain = this_cp-&gt;pool_holder()-&gt;protection_domain();
 620     Handle h_prot (thread, protection_domain);
 621     Handle h_loader (thread, loader);
 622     Klass* k = SystemDictionary::find(name, h_loader, h_prot, thread);
 623 
 624     // Avoid constant pool verification at a safepoint, which takes the Module_lock.
 625     if (k != NULL &amp;&amp; !SafepointSynchronize::is_at_safepoint()) {
 626       // Make sure that resolving is legal
 627       EXCEPTION_MARK;
 628       // return NULL if verification fails
 629       verify_constant_pool_resolve(this_cp, k, THREAD);
 630       if (HAS_PENDING_EXCEPTION) {
 631         CLEAR_PENDING_EXCEPTION;
 632         return NULL;
 633       }
 634       return k;
 635     } else {
 636       return k;
 637     }
 638   }
 639 }
 640 
 641 Method* ConstantPool::method_at_if_loaded(const constantPoolHandle&amp; cpool,
 642                                                    int which) {
 643   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 644   int cache_index = decode_cpcache_index(which, true);
 645   if (!(cache_index &gt;= 0 &amp;&amp; cache_index &lt; cpool-&gt;cache()-&gt;length())) {
 646     // FIXME: should be an assert
 647     log_debug(class, resolve)(&quot;bad operand %d in:&quot;, which); cpool-&gt;print();
 648     return NULL;
 649   }
 650   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 651   return e-&gt;method_if_resolved(cpool);
 652 }
 653 
 654 
 655 bool ConstantPool::has_appendix_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 656   if (cpool-&gt;cache() == NULL)  return false;  // nothing to load yet
 657   int cache_index = decode_cpcache_index(which, true);
 658   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 659   return e-&gt;has_appendix();
 660 }
 661 
 662 oop ConstantPool::appendix_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 663   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 664   int cache_index = decode_cpcache_index(which, true);
 665   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 666   return e-&gt;appendix_if_resolved(cpool);
 667 }
 668 
 669 
 670 bool ConstantPool::has_local_signature_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 671   if (cpool-&gt;cache() == NULL)  return false;  // nothing to load yet
 672   int cache_index = decode_cpcache_index(which, true);
 673   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 674   return e-&gt;has_local_signature();
 675 }
 676 
 677 Symbol* ConstantPool::impl_name_ref_at(int which, bool uncached) {
 678   int name_index = name_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));
 679   return symbol_at(name_index);
 680 }
 681 
 682 
 683 Symbol* ConstantPool::impl_signature_ref_at(int which, bool uncached) {
 684   int signature_index = signature_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));
 685   return symbol_at(signature_index);
 686 }
 687 
 688 int ConstantPool::impl_name_and_type_ref_index_at(int which, bool uncached) {
 689   int i = which;
 690   if (!uncached &amp;&amp; cache() != NULL) {
 691     if (ConstantPool::is_invokedynamic_index(which)) {
 692       // Invokedynamic index is index into the constant pool cache
 693       int pool_index = invokedynamic_bootstrap_ref_index_at(which);
 694       pool_index = bootstrap_name_and_type_ref_index_at(pool_index);
 695       assert(tag_at(pool_index).is_name_and_type(), &quot;&quot;);
 696       return pool_index;
 697     }
 698     // change byte-ordering and go via cache
 699     i = remap_instruction_operand_from_cache(which);
 700   } else {
 701     if (tag_at(which).has_bootstrap()) {
 702       int pool_index = bootstrap_name_and_type_ref_index_at(which);
 703       assert(tag_at(pool_index).is_name_and_type(), &quot;&quot;);
 704       return pool_index;
 705     }
 706   }
 707   assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
 708   assert(!tag_at(i).has_bootstrap(), &quot;Must be handled above&quot;);
 709   jint ref_index = *int_at_addr(i);
 710   return extract_high_short_from_int(ref_index);
 711 }
 712 
 713 constantTag ConstantPool::impl_tag_ref_at(int which, bool uncached) {
 714   int pool_index = which;
 715   if (!uncached &amp;&amp; cache() != NULL) {
 716     if (ConstantPool::is_invokedynamic_index(which)) {
 717       // Invokedynamic index is index into resolved_references
 718       pool_index = invokedynamic_bootstrap_ref_index_at(which);
 719     } else {
 720       // change byte-ordering and go via cache
 721       pool_index = remap_instruction_operand_from_cache(which);
 722     }
 723   }
 724   return tag_at(pool_index);
 725 }
 726 
 727 int ConstantPool::impl_klass_ref_index_at(int which, bool uncached) {
 728   guarantee(!ConstantPool::is_invokedynamic_index(which),
 729             &quot;an invokedynamic instruction does not have a klass&quot;);
 730   int i = which;
 731   if (!uncached &amp;&amp; cache() != NULL) {
 732     // change byte-ordering and go via cache
 733     i = remap_instruction_operand_from_cache(which);
 734   }
 735   assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
 736   jint ref_index = *int_at_addr(i);
 737   return extract_low_short_from_int(ref_index);
 738 }
 739 
 740 
 741 
 742 int ConstantPool::remap_instruction_operand_from_cache(int operand) {
 743   int cpc_index = operand;
 744   DEBUG_ONLY(cpc_index -= CPCACHE_INDEX_TAG);
 745   assert((int)(u2)cpc_index == cpc_index, &quot;clean u2&quot;);
 746   int member_index = cache()-&gt;entry_at(cpc_index)-&gt;constant_pool_index();
 747   return member_index;
 748 }
 749 
 750 
 751 void ConstantPool::verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* k, TRAPS) {
 752   if (!(k-&gt;is_instance_klass() || k-&gt;is_objArray_klass())) {
 753     return;  // short cut, typeArray klass is always accessible
 754   }
 755   Klass* holder = this_cp-&gt;pool_holder();
 756   LinkResolver::check_klass_accessibility(holder, k, CHECK);
 757 }
 758 
 759 
 760 int ConstantPool::name_ref_index_at(int which_nt) {
 761   jint ref_index = name_and_type_at(which_nt);
 762   return extract_low_short_from_int(ref_index);
 763 }
 764 
 765 
 766 int ConstantPool::signature_ref_index_at(int which_nt) {
 767   jint ref_index = name_and_type_at(which_nt);
 768   return extract_high_short_from_int(ref_index);
 769 }
 770 
 771 
 772 Klass* ConstantPool::klass_ref_at(int which, TRAPS) {
 773   return klass_at(klass_ref_index_at(which), THREAD);
 774 }
 775 
 776 Symbol* ConstantPool::klass_name_at(int which) const {
 777   return symbol_at(klass_slot_at(which).name_index());
 778 }
 779 
 780 Symbol* ConstantPool::klass_ref_at_noresolve(int which) {
 781   jint ref_index = klass_ref_index_at(which);
 782   return klass_at_noresolve(ref_index);
 783 }
 784 
 785 Symbol* ConstantPool::uncached_klass_ref_at_noresolve(int which) {
 786   jint ref_index = uncached_klass_ref_index_at(which);
 787   return klass_at_noresolve(ref_index);
 788 }
 789 
 790 char* ConstantPool::string_at_noresolve(int which) {
 791   return unresolved_string_at(which)-&gt;as_C_string();
 792 }
 793 
 794 BasicType ConstantPool::basic_type_for_signature_at(int which) const {
 795   return Signature::basic_type(symbol_at(which));
 796 }
 797 
 798 
 799 void ConstantPool::resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS) {
 800   for (int index = 1; index &lt; this_cp-&gt;length(); index++) { // Index 0 is unused
 801     if (this_cp-&gt;tag_at(index).is_string()) {
 802       this_cp-&gt;string_at(index, CHECK);
 803     }
 804   }
 805 }
 806 
 807 Symbol* ConstantPool::exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception) {
 808   // Dig out the detailed message to reuse if possible
 809   Symbol* message = java_lang_Throwable::detail_message(pending_exception);
 810   if (message != NULL) {
 811     return message;
 812   }
 813 
 814   // Return specific message for the tag
 815   switch (tag.value()) {
 816   case JVM_CONSTANT_UnresolvedClass:
 817     // return the class name in the error message
 818     message = this_cp-&gt;klass_name_at(which);
 819     break;
 820   case JVM_CONSTANT_MethodHandle:
 821     // return the method handle name in the error message
 822     message = this_cp-&gt;method_handle_name_ref_at(which);
 823     break;
 824   case JVM_CONSTANT_MethodType:
 825     // return the method type signature in the error message
 826     message = this_cp-&gt;method_type_signature_at(which);
 827     break;
 828   case JVM_CONSTANT_Dynamic:
 829     // return the name of the condy in the error message
 830     message = this_cp-&gt;uncached_name_ref_at(which);
 831     break;
 832   default:
 833     ShouldNotReachHere();
 834   }
 835 
 836   return message;
 837 }
 838 
 839 void ConstantPool::throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS) {
 840   Symbol* message = NULL;
 841   Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &amp;message);
 842   assert(error != NULL, &quot;checking&quot;);
 843   CLEAR_PENDING_EXCEPTION;
 844   if (message != NULL) {
 845     ResourceMark rm;
 846     THROW_MSG(error, message-&gt;as_C_string());
 847   } else {
 848     THROW(error);
 849   }
 850 }
 851 
 852 // If resolution for Class, Dynamic constant, MethodHandle or MethodType fails, save the
 853 // exception in the resolution error table, so that the same exception is thrown again.
 854 void ConstantPool::save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which,
 855                                             constantTag tag, TRAPS) {
 856   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 857 
 858   int error_tag = tag.error_value();
 859 
 860   if (!PENDING_EXCEPTION-&gt;
 861     is_a(SystemDictionary::LinkageError_klass())) {
 862     // Just throw the exception and don&#39;t prevent these classes from
 863     // being loaded due to virtual machine errors like StackOverflow
 864     // and OutOfMemoryError, etc, or if the thread was hit by stop()
 865     // Needs clarification to section 5.4.3 of the VM spec (see 6308271)
 866   } else if (this_cp-&gt;tag_at(which).value() != error_tag) {
 867     Symbol* message = exception_message(this_cp, which, tag, PENDING_EXCEPTION);
 868     SystemDictionary::add_resolution_error(this_cp, which, error, message);
 869     // CAS in the tag.  If a thread beat us to registering this error that&#39;s fine.
 870     // If another thread resolved the reference, this is a race condition. This
 871     // thread may have had a security manager or something temporary.
 872     // This doesn&#39;t deterministically get an error.   So why do we save this?
 873     // We save this because jvmti can add classes to the bootclass path after
 874     // this error, so it needs to get the same error if the error is first.
 875     jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp-&gt;tag_addr_at(which),
 876                                     (jbyte)tag.value(),
 877                                     (jbyte)error_tag);
 878     if (old_tag != error_tag &amp;&amp; old_tag != tag.value()) {
 879       // MethodHandles and MethodType doesn&#39;t change to resolved version.
 880       assert(this_cp-&gt;tag_at(which).is_klass(), &quot;Wrong tag value&quot;);
 881       // Forget the exception and use the resolved class.
 882       CLEAR_PENDING_EXCEPTION;
 883     }
 884   } else {
 885     // some other thread put this in error state
 886     throw_resolution_error(this_cp, which, CHECK);
 887   }
 888 }
 889 
 890 constantTag ConstantPool::constant_tag_at(int which) {
 891   constantTag tag = tag_at(which);
 892   if (tag.is_dynamic_constant() ||
 893       tag.is_dynamic_constant_in_error()) {
 894     BasicType bt = basic_type_for_constant_at(which);
 895     // dynamic constant could return an array, treat as object
 896     return constantTag::ofBasicType(is_reference_type(bt) ? T_OBJECT : bt);
 897   }
 898   return tag;
 899 }
 900 
 901 BasicType ConstantPool::basic_type_for_constant_at(int which) {
 902   constantTag tag = tag_at(which);
 903   if (tag.is_dynamic_constant() ||
 904       tag.is_dynamic_constant_in_error()) {
 905     // have to look at the signature for this one
 906     Symbol* constant_type = uncached_signature_ref_at(which);
 907     return Signature::basic_type(constant_type);
 908   }
 909   return tag.basic_type();
 910 }
 911 
 912 // Called to resolve constants in the constant pool and return an oop.
 913 // Some constant pool entries cache their resolved oop. This is also
 914 // called to create oops from constants to use in arguments for invokedynamic
 915 oop ConstantPool::resolve_constant_at_impl(const constantPoolHandle&amp; this_cp,
 916                                            int index, int cache_index,
 917                                            bool* status_return, TRAPS) {
 918   oop result_oop = NULL;
 919   Handle throw_exception;
 920 
 921   if (cache_index == _possible_index_sentinel) {
 922     // It is possible that this constant is one which is cached in the objects.
 923     // We&#39;ll do a linear search.  This should be OK because this usage is rare.
 924     // FIXME: If bootstrap specifiers stress this code, consider putting in
 925     // a reverse index.  Binary search over a short array should do it.
 926     assert(index &gt; 0, &quot;valid index&quot;);
 927     cache_index = this_cp-&gt;cp_to_object_index(index);
 928   }
 929   assert(cache_index == _no_index_sentinel || cache_index &gt;= 0, &quot;&quot;);
 930   assert(index == _no_index_sentinel || index &gt;= 0, &quot;&quot;);
 931 
 932   if (cache_index &gt;= 0) {
 933     result_oop = this_cp-&gt;resolved_references()-&gt;obj_at(cache_index);
 934     if (result_oop != NULL) {
 935       if (result_oop == Universe::the_null_sentinel()) {
 936         DEBUG_ONLY(int temp_index = (index &gt;= 0 ? index : this_cp-&gt;object_to_cp_index(cache_index)));
 937         assert(this_cp-&gt;tag_at(temp_index).is_dynamic_constant(), &quot;only condy uses the null sentinel&quot;);
 938         result_oop = NULL;
 939       }
 940       if (status_return != NULL)  (*status_return) = true;
 941       return result_oop;
 942       // That was easy...
 943     }
 944     index = this_cp-&gt;object_to_cp_index(cache_index);
 945   }
 946 
 947   jvalue prim_value;  // temp used only in a few cases below
 948 
 949   constantTag tag = this_cp-&gt;tag_at(index);
 950 
 951   if (status_return != NULL) {
 952     // don&#39;t trigger resolution if the constant might need it
 953     switch (tag.value()) {
 954     case JVM_CONSTANT_Class:
 955     {
 956       CPKlassSlot kslot = this_cp-&gt;klass_slot_at(index);
 957       int resolved_klass_index = kslot.resolved_klass_index();
 958       if (this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index) == NULL) {
 959         (*status_return) = false;
 960         return NULL;
 961       }
 962       // the klass is waiting in the CP; go get it
 963       break;
 964     }
 965     case JVM_CONSTANT_String:
 966     case JVM_CONSTANT_Integer:
 967     case JVM_CONSTANT_Float:
 968     case JVM_CONSTANT_Long:
 969     case JVM_CONSTANT_Double:
 970       // these guys trigger OOM at worst
 971       break;
 972     default:
 973       (*status_return) = false;
 974       return NULL;
 975     }
 976     // from now on there is either success or an OOME
 977     (*status_return) = true;
 978   }
 979 
 980   switch (tag.value()) {
 981 
 982   case JVM_CONSTANT_UnresolvedClass:
 983   case JVM_CONSTANT_UnresolvedClassInError:
 984   case JVM_CONSTANT_Class:
 985     {
 986       assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
 987       Klass* resolved = klass_at_impl(this_cp, index, true, CHECK_NULL);
 988       // ldc wants the java mirror.
 989       result_oop = resolved-&gt;java_mirror();
 990       break;
 991     }
 992 
 993   case JVM_CONSTANT_Dynamic:
 994     {
 995       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.
 996       BootstrapInfo bootstrap_specifier(this_cp, index);
 997 
 998       // The initial step in resolving an unresolved symbolic reference to a
 999       // dynamically-computed constant is to resolve the symbolic reference to a
1000       // method handle which will be the bootstrap method for the dynamically-computed
1001       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
1002       // method fails, then a MethodHandleInError is stored at the corresponding
1003       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
1004       // set a DynamicConstantInError here since any subsequent use of this
1005       // bootstrap method will encounter the resolution of MethodHandleInError.
1006       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,
1007       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()
1008       // for the bootstrap_specifier created above.
1009       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
1010       Exceptions::wrap_dynamic_exception(/* is_indy */ false, THREAD);
1011       if (HAS_PENDING_EXCEPTION) {
1012         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
1013         // will check for a LinkageError and store a DynamicConstantInError.
1014         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1015       }
1016       result_oop = bootstrap_specifier.resolved_value()();
1017       BasicType type = Signature::basic_type(bootstrap_specifier.signature());
1018       if (!is_reference_type(type)) {
1019         // Make sure the primitive value is properly boxed.
1020         // This is a JDK responsibility.
1021         const char* fail = NULL;
1022         if (result_oop == NULL) {
1023           fail = &quot;null result instead of box&quot;;
1024         } else if (!is_java_primitive(type)) {
1025           // FIXME: support value types via unboxing
1026           fail = &quot;can only handle references and primitives&quot;;
1027         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
1028           fail = &quot;primitive is not properly boxed&quot;;
1029         }
1030         if (fail != NULL) {
1031           // Since this exception is not a LinkageError, throw exception
1032           // but do not save a DynamicInError resolution result.
1033           // See section 5.4.3 of the VM spec.
1034           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
1035         }
1036       }
1037 
1038       LogTarget(Debug, methodhandles, condy) lt_condy;
1039       if (lt_condy.is_enabled()) {
1040         LogStream ls(lt_condy);
1041         bootstrap_specifier.print_msg_on(&amp;ls, &quot;resolve_constant_at_impl&quot;);
1042       }
1043       break;
1044     }
1045 
1046   case JVM_CONSTANT_String:
1047     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
1048     if (this_cp-&gt;is_pseudo_string_at(index)) {
1049       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
1050       break;
1051     }
1052     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
1053     break;
1054 
1055   case JVM_CONSTANT_DynamicInError:
1056   case JVM_CONSTANT_MethodHandleInError:
1057   case JVM_CONSTANT_MethodTypeInError:
1058     {
1059       throw_resolution_error(this_cp, index, CHECK_NULL);
1060       break;
1061     }
1062 
1063   case JVM_CONSTANT_MethodHandle:
1064     {
1065       int ref_kind                 = this_cp-&gt;method_handle_ref_kind_at(index);
1066       int callee_index             = this_cp-&gt;method_handle_klass_index_at(index);
1067       Symbol*  name =      this_cp-&gt;method_handle_name_ref_at(index);
1068       Symbol*  signature = this_cp-&gt;method_handle_signature_ref_at(index);
1069       constantTag m_tag  = this_cp-&gt;tag_at(this_cp-&gt;method_handle_index_at(index));
1070       { ResourceMark rm(THREAD);
1071         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodHandle:%d [%d/%d/%d] %s.%s&quot;,
1072                               ref_kind, index, this_cp-&gt;method_handle_index_at(index),
1073                               callee_index, name-&gt;as_C_string(), signature-&gt;as_C_string());
1074       }
1075 
1076       Klass* callee = klass_at_impl(this_cp, callee_index, true, CHECK_NULL);
1077 
1078       // Check constant pool method consistency
1079       if ((callee-&gt;is_interface() &amp;&amp; m_tag.is_method()) ||
1080           ((!callee-&gt;is_interface() &amp;&amp; m_tag.is_interface_method()))) {
1081         ResourceMark rm(THREAD);
1082         stringStream ss;
1083         ss.print(&quot;Inconsistent constant pool data in classfile for class %s. &quot;
1084                  &quot;Method &#39;&quot;, callee-&gt;name()-&gt;as_C_string());
1085         signature-&gt;print_as_signature_external_return_type(&amp;ss);
1086         ss.print(&quot; %s(&quot;, name-&gt;as_C_string());
1087         signature-&gt;print_as_signature_external_parameters(&amp;ss);
1088         ss.print(&quot;)&#39; at index %d is %s and should be %s&quot;,
1089                  index,
1090                  callee-&gt;is_interface() ? &quot;CONSTANT_MethodRef&quot; : &quot;CONSTANT_InterfaceMethodRef&quot;,
1091                  callee-&gt;is_interface() ? &quot;CONSTANT_InterfaceMethodRef&quot; : &quot;CONSTANT_MethodRef&quot;);
1092         THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1093       }
1094 
1095       Klass* klass = this_cp-&gt;pool_holder();
1096       Handle value = SystemDictionary::link_method_handle_constant(klass, ref_kind,
1097                                                                    callee, name, signature,
1098                                                                    THREAD);
1099       result_oop = value();
1100       if (HAS_PENDING_EXCEPTION) {
1101         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1102       }
1103       break;
1104     }
1105 
1106   case JVM_CONSTANT_MethodType:
1107     {
1108       Symbol*  signature = this_cp-&gt;method_type_signature_at(index);
1109       { ResourceMark rm(THREAD);
1110         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodType [%d/%d] %s&quot;,
1111                               index, this_cp-&gt;method_type_index_at(index),
1112                               signature-&gt;as_C_string());
1113       }
1114       Klass* klass = this_cp-&gt;pool_holder();
1115       Handle value = SystemDictionary::find_method_handle_type(signature, klass, THREAD);
1116       result_oop = value();
1117       if (HAS_PENDING_EXCEPTION) {
1118         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1119       }
1120       break;
1121     }
1122 
1123   case JVM_CONSTANT_Integer:
1124     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1125     prim_value.i = this_cp-&gt;int_at(index);
1126     result_oop = java_lang_boxing_object::create(T_INT, &amp;prim_value, CHECK_NULL);
1127     break;
1128 
1129   case JVM_CONSTANT_Float:
1130     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1131     prim_value.f = this_cp-&gt;float_at(index);
1132     result_oop = java_lang_boxing_object::create(T_FLOAT, &amp;prim_value, CHECK_NULL);
1133     break;
1134 
1135   case JVM_CONSTANT_Long:
1136     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1137     prim_value.j = this_cp-&gt;long_at(index);
1138     result_oop = java_lang_boxing_object::create(T_LONG, &amp;prim_value, CHECK_NULL);
1139     break;
1140 
1141   case JVM_CONSTANT_Double:
1142     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1143     prim_value.d = this_cp-&gt;double_at(index);
1144     result_oop = java_lang_boxing_object::create(T_DOUBLE, &amp;prim_value, CHECK_NULL);
1145     break;
1146 
1147   default:
1148     DEBUG_ONLY( tty-&gt;print_cr(&quot;*** %p: tag at CP[%d/%d] = %d&quot;,
1149                               this_cp(), index, cache_index, tag.value()));
1150     assert(false, &quot;unexpected constant tag&quot;);
1151     break;
1152   }
1153 
1154   if (cache_index &gt;= 0) {
1155     // Benign race condition:  resolved_references may already be filled in.
1156     // The important thing here is that all threads pick up the same result.
1157     // It doesn&#39;t matter which racing thread wins, as long as only one
1158     // result is used by all threads, and all future queries.
1159     oop new_result = (result_oop == NULL ? Universe::the_null_sentinel() : result_oop);
1160     oop old_result = this_cp-&gt;resolved_references()
1161       -&gt;atomic_compare_exchange_oop(cache_index, new_result, NULL);
1162     if (old_result == NULL) {
1163       return result_oop;  // was installed
1164     } else {
1165       // Return the winning thread&#39;s result.  This can be different than
1166       // the result here for MethodHandles.
1167       if (old_result == Universe::the_null_sentinel())
1168         old_result = NULL;
1169       return old_result;
1170     }
1171   } else {
1172     assert(result_oop != Universe::the_null_sentinel(), &quot;&quot;);
1173     return result_oop;
1174   }
1175 }
1176 
1177 oop ConstantPool::uncached_string_at(int which, TRAPS) {
1178   Symbol* sym = unresolved_string_at(which);
1179   oop str = StringTable::intern(sym, CHECK_(NULL));
1180   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1181   return str;
1182 }
1183 
1184 void ConstantPool::copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
1185                                                     int start_arg, int end_arg,
1186                                                     objArrayHandle info, int pos,
1187                                                     bool must_resolve, Handle if_not_available,
1188                                                     TRAPS) {
1189   int argc;
1190   int limit = pos + end_arg - start_arg;
1191   // checks: index in range [0..this_cp-&gt;length),
1192   // tag at index, start..end in range [0..argc],
1193   // info array non-null, pos..limit in [0..info.length]
1194   if ((0 &gt;= index    || index &gt;= this_cp-&gt;length())  ||
1195       !(this_cp-&gt;tag_at(index).is_invoke_dynamic()    ||
1196         this_cp-&gt;tag_at(index).is_dynamic_constant()) ||
1197       (0 &gt; start_arg || start_arg &gt; end_arg) ||
1198       (end_arg &gt; (argc = this_cp-&gt;bootstrap_argument_count_at(index))) ||
1199       (0 &gt; pos       || pos &gt; limit)         ||
1200       (info.is_null() || limit &gt; info-&gt;length())) {
1201     // An index or something else went wrong; throw an error.
1202     // Since this is an internal API, we don&#39;t expect this,
1203     // so we don&#39;t bother to craft a nice message.
1204     THROW_MSG(vmSymbols::java_lang_LinkageError(), &quot;bad BSM argument access&quot;);
1205   }
1206   // now we can loop safely
1207   int info_i = pos;
1208   for (int i = start_arg; i &lt; end_arg; i++) {
1209     int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);
1210     oop arg_oop;
1211     if (must_resolve) {
1212       arg_oop = this_cp-&gt;resolve_possibly_cached_constant_at(arg_index, CHECK);
1213     } else {
1214       bool found_it = false;
1215       arg_oop = this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK);
1216       if (!found_it)  arg_oop = if_not_available();
1217     }
1218     info-&gt;obj_at_put(info_i++, arg_oop);
1219   }
1220 }
1221 
1222 oop ConstantPool::string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS) {
1223   // If the string has already been interned, this entry will be non-null
1224   oop str = this_cp-&gt;resolved_references()-&gt;obj_at(obj_index);
1225   assert(str != Universe::the_null_sentinel(), &quot;&quot;);
1226   if (str != NULL) return str;
1227   Symbol* sym = this_cp-&gt;unresolved_string_at(which);
1228   str = StringTable::intern(sym, CHECK_(NULL));
1229   this_cp-&gt;string_at_put(which, obj_index, str);
1230   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1231   return str;
1232 }
1233 
1234 
1235 bool ConstantPool::klass_name_at_matches(const InstanceKlass* k, int which) {
1236   // Names are interned, so we can compare Symbol*s directly
1237   Symbol* cp_name = klass_name_at(which);
1238   return (cp_name == k-&gt;name());
1239 }
1240 
1241 
1242 // Iterate over symbols and decrement ones which are Symbol*s
1243 // This is done during GC.
1244 // Only decrement the UTF8 symbols. Strings point to
1245 // these symbols but didn&#39;t increment the reference count.
1246 void ConstantPool::unreference_symbols() {
1247   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
1248     constantTag tag = tag_at(index);
1249     if (tag.is_symbol()) {
1250       symbol_at(index)-&gt;decrement_refcount();
1251     }
1252   }
1253 }
1254 
1255 
1256 // Compare this constant pool&#39;s entry at index1 to the constant pool
1257 // cp2&#39;s entry at index2.
1258 bool ConstantPool::compare_entry_to(int index1, const constantPoolHandle&amp; cp2,
1259        int index2, TRAPS) {
1260 
1261   // The error tags are equivalent to non-error tags when comparing
1262   jbyte t1 = tag_at(index1).non_error_value();
1263   jbyte t2 = cp2-&gt;tag_at(index2).non_error_value();
1264 
1265   if (t1 != t2) {
1266     // Not the same entry type so there is nothing else to check. Note
1267     // that this style of checking will consider resolved/unresolved
1268     // class pairs as different.
1269     // From the ConstantPool* API point of view, this is correct
1270     // behavior. See VM_RedefineClasses::merge_constant_pools() to see how this
1271     // plays out in the context of ConstantPool* merging.
1272     return false;
1273   }
1274 
1275   switch (t1) {
1276   case JVM_CONSTANT_Class:
1277   {
1278     Klass* k1 = klass_at(index1, CHECK_false);
1279     Klass* k2 = cp2-&gt;klass_at(index2, CHECK_false);
1280     if (k1 == k2) {
1281       return true;
1282     }
1283   } break;
1284 
1285   case JVM_CONSTANT_ClassIndex:
1286   {
1287     int recur1 = klass_index_at(index1);
1288     int recur2 = cp2-&gt;klass_index_at(index2);
1289     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1290     if (match) {
1291       return true;
1292     }
1293   } break;
1294 
1295   case JVM_CONSTANT_Double:
1296   {
1297     jdouble d1 = double_at(index1);
1298     jdouble d2 = cp2-&gt;double_at(index2);
1299     if (d1 == d2) {
1300       return true;
1301     }
1302   } break;
1303 
1304   case JVM_CONSTANT_Fieldref:
1305   case JVM_CONSTANT_InterfaceMethodref:
1306   case JVM_CONSTANT_Methodref:
1307   {
1308     int recur1 = uncached_klass_ref_index_at(index1);
1309     int recur2 = cp2-&gt;uncached_klass_ref_index_at(index2);
1310     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1311     if (match) {
1312       recur1 = uncached_name_and_type_ref_index_at(index1);
1313       recur2 = cp2-&gt;uncached_name_and_type_ref_index_at(index2);
1314       match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1315       if (match) {
1316         return true;
1317       }
1318     }
1319   } break;
1320 
1321   case JVM_CONSTANT_Float:
1322   {
1323     jfloat f1 = float_at(index1);
1324     jfloat f2 = cp2-&gt;float_at(index2);
1325     if (f1 == f2) {
1326       return true;
1327     }
1328   } break;
1329 
1330   case JVM_CONSTANT_Integer:
1331   {
1332     jint i1 = int_at(index1);
1333     jint i2 = cp2-&gt;int_at(index2);
1334     if (i1 == i2) {
1335       return true;
1336     }
1337   } break;
1338 
1339   case JVM_CONSTANT_Long:
1340   {
1341     jlong l1 = long_at(index1);
1342     jlong l2 = cp2-&gt;long_at(index2);
1343     if (l1 == l2) {
1344       return true;
1345     }
1346   } break;
1347 
1348   case JVM_CONSTANT_NameAndType:
1349   {
1350     int recur1 = name_ref_index_at(index1);
1351     int recur2 = cp2-&gt;name_ref_index_at(index2);
1352     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1353     if (match) {
1354       recur1 = signature_ref_index_at(index1);
1355       recur2 = cp2-&gt;signature_ref_index_at(index2);
1356       match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1357       if (match) {
1358         return true;
1359       }
1360     }
1361   } break;
1362 
1363   case JVM_CONSTANT_StringIndex:
1364   {
1365     int recur1 = string_index_at(index1);
1366     int recur2 = cp2-&gt;string_index_at(index2);
1367     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1368     if (match) {
1369       return true;
1370     }
1371   } break;
1372 
1373   case JVM_CONSTANT_UnresolvedClass:
1374   {
1375     Symbol* k1 = klass_name_at(index1);
1376     Symbol* k2 = cp2-&gt;klass_name_at(index2);
1377     if (k1 == k2) {
1378       return true;
1379     }
1380   } break;
1381 
1382   case JVM_CONSTANT_MethodType:
1383   {
1384     int k1 = method_type_index_at(index1);
1385     int k2 = cp2-&gt;method_type_index_at(index2);
1386     bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
1387     if (match) {
1388       return true;
1389     }
1390   } break;
1391 
1392   case JVM_CONSTANT_MethodHandle:
1393   {
1394     int k1 = method_handle_ref_kind_at(index1);
1395     int k2 = cp2-&gt;method_handle_ref_kind_at(index2);
1396     if (k1 == k2) {
1397       int i1 = method_handle_index_at(index1);
1398       int i2 = cp2-&gt;method_handle_index_at(index2);
1399       bool match = compare_entry_to(i1, cp2, i2, CHECK_false);
1400       if (match) {
1401         return true;
1402       }
1403     }
1404   } break;
1405 
1406   case JVM_CONSTANT_Dynamic:
1407   {
1408     int k1 = bootstrap_name_and_type_ref_index_at(index1);
1409     int k2 = cp2-&gt;bootstrap_name_and_type_ref_index_at(index2);
1410     int i1 = bootstrap_methods_attribute_index(index1);
1411     int i2 = cp2-&gt;bootstrap_methods_attribute_index(index2);
1412     // separate statements and variables because CHECK_false is used
1413     bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);
1414     bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);
1415     return (match_entry &amp;&amp; match_operand);
1416   } break;
1417 
1418   case JVM_CONSTANT_InvokeDynamic:
1419   {
1420     int k1 = bootstrap_name_and_type_ref_index_at(index1);
1421     int k2 = cp2-&gt;bootstrap_name_and_type_ref_index_at(index2);
1422     int i1 = bootstrap_methods_attribute_index(index1);
1423     int i2 = cp2-&gt;bootstrap_methods_attribute_index(index2);
1424     // separate statements and variables because CHECK_false is used
1425     bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);
1426     bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);
1427     return (match_entry &amp;&amp; match_operand);
1428   } break;
1429 
1430   case JVM_CONSTANT_String:
1431   {
1432     Symbol* s1 = unresolved_string_at(index1);
1433     Symbol* s2 = cp2-&gt;unresolved_string_at(index2);
1434     if (s1 == s2) {
1435       return true;
1436     }
1437   } break;
1438 
1439   case JVM_CONSTANT_Utf8:
1440   {
1441     Symbol* s1 = symbol_at(index1);
1442     Symbol* s2 = cp2-&gt;symbol_at(index2);
1443     if (s1 == s2) {
1444       return true;
1445     }
1446   } break;
1447 
1448   // Invalid is used as the tag for the second constant pool entry
1449   // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
1450   // not be seen by itself.
1451   case JVM_CONSTANT_Invalid: // fall through
1452 
1453   default:
1454     ShouldNotReachHere();
1455     break;
1456   }
1457 
1458   return false;
1459 } // end compare_entry_to()
1460 
1461 
1462 // Resize the operands array with delta_len and delta_size.
1463 // Used in RedefineClasses for CP merge.
1464 void ConstantPool::resize_operands(int delta_len, int delta_size, TRAPS) {
1465   int old_len  = operand_array_length(operands());
1466   int new_len  = old_len + delta_len;
1467   int min_len  = (delta_len &gt; 0) ? old_len : new_len;
1468 
1469   int old_size = operands()-&gt;length();
1470   int new_size = old_size + delta_size;
1471   int min_size = (delta_size &gt; 0) ? old_size : new_size;
1472 
1473   ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
1474   Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, new_size, CHECK);
1475 
1476   // Set index in the resized array for existing elements only
1477   for (int idx = 0; idx &lt; min_len; idx++) {
1478     int offset = operand_offset_at(idx);                       // offset in original array
1479     operand_offset_at_put(new_ops, idx, offset + 2*delta_len); // offset in resized array
1480   }
1481   // Copy the bootstrap specifiers only
1482   Copy::conjoint_memory_atomic(operands()-&gt;adr_at(2*old_len),
1483                                new_ops-&gt;adr_at(2*new_len),
1484                                (min_size - 2*min_len) * sizeof(u2));
1485   // Explicitly deallocate old operands array.
1486   // Note, it is not needed for 7u backport.
1487   if ( operands() != NULL) { // the safety check
1488     MetadataFactory::free_array&lt;u2&gt;(loader_data, operands());
1489   }
1490   set_operands(new_ops);
1491 } // end resize_operands()
1492 
1493 
1494 // Extend the operands array with the length and size of the ext_cp operands.
1495 // Used in RedefineClasses for CP merge.
1496 void ConstantPool::extend_operands(const constantPoolHandle&amp; ext_cp, TRAPS) {
1497   int delta_len = operand_array_length(ext_cp-&gt;operands());
1498   if (delta_len == 0) {
1499     return; // nothing to do
1500   }
1501   int delta_size = ext_cp-&gt;operands()-&gt;length();
1502 
1503   assert(delta_len  &gt; 0 &amp;&amp; delta_size &gt; 0, &quot;extended operands array must be bigger&quot;);
1504 
1505   if (operand_array_length(operands()) == 0) {
1506     ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
1507     Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, delta_size, CHECK);
1508     // The first element index defines the offset of second part
1509     operand_offset_at_put(new_ops, 0, 2*delta_len); // offset in new array
1510     set_operands(new_ops);
1511   } else {
1512     resize_operands(delta_len, delta_size, CHECK);
1513   }
1514 
1515 } // end extend_operands()
1516 
1517 
1518 // Shrink the operands array to a smaller array with new_len length.
1519 // Used in RedefineClasses for CP merge.
1520 void ConstantPool::shrink_operands(int new_len, TRAPS) {
1521   int old_len = operand_array_length(operands());
1522   if (new_len == old_len) {
1523     return; // nothing to do
1524   }
1525   assert(new_len &lt; old_len, &quot;shrunken operands array must be smaller&quot;);
1526 
1527   int free_base  = operand_next_offset_at(new_len - 1);
1528   int delta_len  = new_len - old_len;
1529   int delta_size = 2*delta_len + free_base - operands()-&gt;length();
1530 
1531   resize_operands(delta_len, delta_size, CHECK);
1532 
1533 } // end shrink_operands()
1534 
1535 
1536 void ConstantPool::copy_operands(const constantPoolHandle&amp; from_cp,
1537                                  const constantPoolHandle&amp; to_cp,
1538                                  TRAPS) {
1539 
1540   int from_oplen = operand_array_length(from_cp-&gt;operands());
1541   int old_oplen  = operand_array_length(to_cp-&gt;operands());
1542   if (from_oplen != 0) {
1543     ClassLoaderData* loader_data = to_cp-&gt;pool_holder()-&gt;class_loader_data();
1544     // append my operands to the target&#39;s operands array
1545     if (old_oplen == 0) {
1546       // Can&#39;t just reuse from_cp&#39;s operand list because of deallocation issues
1547       int len = from_cp-&gt;operands()-&gt;length();
1548       Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, len, CHECK);
1549       Copy::conjoint_memory_atomic(
1550           from_cp-&gt;operands()-&gt;adr_at(0), new_ops-&gt;adr_at(0), len * sizeof(u2));
1551       to_cp-&gt;set_operands(new_ops);
1552     } else {
1553       int old_len  = to_cp-&gt;operands()-&gt;length();
1554       int from_len = from_cp-&gt;operands()-&gt;length();
1555       int old_off  = old_oplen * sizeof(u2);
1556       int from_off = from_oplen * sizeof(u2);
1557       // Use the metaspace for the destination constant pool
1558       Array&lt;u2&gt;* new_operands = MetadataFactory::new_array&lt;u2&gt;(loader_data, old_len + from_len, CHECK);
1559       int fillp = 0, len = 0;
1560       // first part of dest
1561       Copy::conjoint_memory_atomic(to_cp-&gt;operands()-&gt;adr_at(0),
1562                                    new_operands-&gt;adr_at(fillp),
1563                                    (len = old_off) * sizeof(u2));
1564       fillp += len;
1565       // first part of src
1566       Copy::conjoint_memory_atomic(from_cp-&gt;operands()-&gt;adr_at(0),
1567                                    new_operands-&gt;adr_at(fillp),
1568                                    (len = from_off) * sizeof(u2));
1569       fillp += len;
1570       // second part of dest
1571       Copy::conjoint_memory_atomic(to_cp-&gt;operands()-&gt;adr_at(old_off),
1572                                    new_operands-&gt;adr_at(fillp),
1573                                    (len = old_len - old_off) * sizeof(u2));
1574       fillp += len;
1575       // second part of src
1576       Copy::conjoint_memory_atomic(from_cp-&gt;operands()-&gt;adr_at(from_off),
1577                                    new_operands-&gt;adr_at(fillp),
1578                                    (len = from_len - from_off) * sizeof(u2));
1579       fillp += len;
1580       assert(fillp == new_operands-&gt;length(), &quot;&quot;);
1581 
1582       // Adjust indexes in the first part of the copied operands array.
1583       for (int j = 0; j &lt; from_oplen; j++) {
1584         int offset = operand_offset_at(new_operands, old_oplen + j);
1585         assert(offset == operand_offset_at(from_cp-&gt;operands(), j), &quot;correct copy&quot;);
1586         offset += old_len;  // every new tuple is preceded by old_len extra u2&#39;s
1587         operand_offset_at_put(new_operands, old_oplen + j, offset);
1588       }
1589 
1590       // replace target operands array with combined array
1591       to_cp-&gt;set_operands(new_operands);
1592     }
1593   }
1594 } // end copy_operands()
1595 
1596 
1597 // Copy this constant pool&#39;s entries at start_i to end_i (inclusive)
1598 // to the constant pool to_cp&#39;s entries starting at to_i. A total of
1599 // (end_i - start_i) + 1 entries are copied.
1600 void ConstantPool::copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i,
1601        const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
1602 
1603 
1604   int dest_i = to_i;  // leave original alone for debug purposes
1605 
1606   for (int src_i = start_i; src_i &lt;= end_i; /* see loop bottom */ ) {
1607     copy_entry_to(from_cp, src_i, to_cp, dest_i, CHECK);
1608 
1609     switch (from_cp-&gt;tag_at(src_i).value()) {
1610     case JVM_CONSTANT_Double:
1611     case JVM_CONSTANT_Long:
1612       // double and long take two constant pool entries
1613       src_i += 2;
1614       dest_i += 2;
1615       break;
1616 
1617     default:
1618       // all others take one constant pool entry
1619       src_i++;
1620       dest_i++;
1621       break;
1622     }
1623   }
1624   copy_operands(from_cp, to_cp, CHECK);
1625 
1626 } // end copy_cp_to_impl()
1627 
1628 
1629 // Copy this constant pool&#39;s entry at from_i to the constant pool
1630 // to_cp&#39;s entry at to_i.
1631 void ConstantPool::copy_entry_to(const constantPoolHandle&amp; from_cp, int from_i,
1632                                         const constantPoolHandle&amp; to_cp, int to_i,
1633                                         TRAPS) {
1634 
1635   int tag = from_cp-&gt;tag_at(from_i).value();
1636   switch (tag) {
1637   case JVM_CONSTANT_ClassIndex:
1638   {
1639     jint ki = from_cp-&gt;klass_index_at(from_i);
1640     to_cp-&gt;klass_index_at_put(to_i, ki);
1641   } break;
1642 
1643   case JVM_CONSTANT_Double:
1644   {
1645     jdouble d = from_cp-&gt;double_at(from_i);
1646     to_cp-&gt;double_at_put(to_i, d);
1647     // double takes two constant pool entries so init second entry&#39;s tag
1648     to_cp-&gt;tag_at_put(to_i + 1, JVM_CONSTANT_Invalid);
1649   } break;
1650 
1651   case JVM_CONSTANT_Fieldref:
1652   {
1653     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1654     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1655     to_cp-&gt;field_at_put(to_i, class_index, name_and_type_index);
1656   } break;
1657 
1658   case JVM_CONSTANT_Float:
1659   {
1660     jfloat f = from_cp-&gt;float_at(from_i);
1661     to_cp-&gt;float_at_put(to_i, f);
1662   } break;
1663 
1664   case JVM_CONSTANT_Integer:
1665   {
1666     jint i = from_cp-&gt;int_at(from_i);
1667     to_cp-&gt;int_at_put(to_i, i);
1668   } break;
1669 
1670   case JVM_CONSTANT_InterfaceMethodref:
1671   {
1672     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1673     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1674     to_cp-&gt;interface_method_at_put(to_i, class_index, name_and_type_index);
1675   } break;
1676 
1677   case JVM_CONSTANT_Long:
1678   {
1679     jlong l = from_cp-&gt;long_at(from_i);
1680     to_cp-&gt;long_at_put(to_i, l);
1681     // long takes two constant pool entries so init second entry&#39;s tag
1682     to_cp-&gt;tag_at_put(to_i + 1, JVM_CONSTANT_Invalid);
1683   } break;
1684 
1685   case JVM_CONSTANT_Methodref:
1686   {
1687     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1688     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1689     to_cp-&gt;method_at_put(to_i, class_index, name_and_type_index);
1690   } break;
1691 
1692   case JVM_CONSTANT_NameAndType:
1693   {
1694     int name_ref_index = from_cp-&gt;name_ref_index_at(from_i);
1695     int signature_ref_index = from_cp-&gt;signature_ref_index_at(from_i);
1696     to_cp-&gt;name_and_type_at_put(to_i, name_ref_index, signature_ref_index);
1697   } break;
1698 
1699   case JVM_CONSTANT_StringIndex:
1700   {
1701     jint si = from_cp-&gt;string_index_at(from_i);
1702     to_cp-&gt;string_index_at_put(to_i, si);
1703   } break;
1704 
1705   case JVM_CONSTANT_Class:
1706   case JVM_CONSTANT_UnresolvedClass:
1707   case JVM_CONSTANT_UnresolvedClassInError:
1708   {
1709     // Revert to JVM_CONSTANT_ClassIndex
1710     int name_index = from_cp-&gt;klass_slot_at(from_i).name_index();
1711     assert(from_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
1712     to_cp-&gt;klass_index_at_put(to_i, name_index);
1713   } break;
1714 
1715   case JVM_CONSTANT_String:
1716   {
1717     Symbol* s = from_cp-&gt;unresolved_string_at(from_i);
1718     to_cp-&gt;unresolved_string_at_put(to_i, s);
1719   } break;
1720 
1721   case JVM_CONSTANT_Utf8:
1722   {
1723     Symbol* s = from_cp-&gt;symbol_at(from_i);
1724     // Need to increase refcount, the old one will be thrown away and deferenced
1725     s-&gt;increment_refcount();
1726     to_cp-&gt;symbol_at_put(to_i, s);
1727   } break;
1728 
1729   case JVM_CONSTANT_MethodType:
1730   case JVM_CONSTANT_MethodTypeInError:
1731   {
1732     jint k = from_cp-&gt;method_type_index_at(from_i);
1733     to_cp-&gt;method_type_index_at_put(to_i, k);
1734   } break;
1735 
1736   case JVM_CONSTANT_MethodHandle:
1737   case JVM_CONSTANT_MethodHandleInError:
1738   {
1739     int k1 = from_cp-&gt;method_handle_ref_kind_at(from_i);
1740     int k2 = from_cp-&gt;method_handle_index_at(from_i);
1741     to_cp-&gt;method_handle_index_at_put(to_i, k1, k2);
1742   } break;
1743 
1744   case JVM_CONSTANT_Dynamic:
1745   case JVM_CONSTANT_DynamicInError:
1746   {
1747     int k1 = from_cp-&gt;bootstrap_methods_attribute_index(from_i);
1748     int k2 = from_cp-&gt;bootstrap_name_and_type_ref_index_at(from_i);
1749     k1 += operand_array_length(to_cp-&gt;operands());  // to_cp might already have operands
1750     to_cp-&gt;dynamic_constant_at_put(to_i, k1, k2);
1751   } break;
1752 
1753   case JVM_CONSTANT_InvokeDynamic:
1754   {
1755     int k1 = from_cp-&gt;bootstrap_methods_attribute_index(from_i);
1756     int k2 = from_cp-&gt;bootstrap_name_and_type_ref_index_at(from_i);
1757     k1 += operand_array_length(to_cp-&gt;operands());  // to_cp might already have operands
1758     to_cp-&gt;invoke_dynamic_at_put(to_i, k1, k2);
1759   } break;
1760 
1761   // Invalid is used as the tag for the second constant pool entry
1762   // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
1763   // not be seen by itself.
1764   case JVM_CONSTANT_Invalid: // fall through
1765 
1766   default:
1767   {
1768     ShouldNotReachHere();
1769   } break;
1770   }
1771 } // end copy_entry_to()
1772 
1773 // Search constant pool search_cp for an entry that matches this
1774 // constant pool&#39;s entry at pattern_i. Returns the index of a
1775 // matching entry or zero (0) if there is no matching entry.
1776 int ConstantPool::find_matching_entry(int pattern_i,
1777       const constantPoolHandle&amp; search_cp, TRAPS) {
1778 
1779   // index zero (0) is not used
1780   for (int i = 1; i &lt; search_cp-&gt;length(); i++) {
1781     bool found = compare_entry_to(pattern_i, search_cp, i, CHECK_0);
1782     if (found) {
1783       return i;
1784     }
1785   }
1786 
1787   return 0;  // entry not found; return unused index zero (0)
1788 } // end find_matching_entry()
1789 
1790 
1791 // Compare this constant pool&#39;s bootstrap specifier at idx1 to the constant pool
1792 // cp2&#39;s bootstrap specifier at idx2.
1793 bool ConstantPool::compare_operand_to(int idx1, const constantPoolHandle&amp; cp2, int idx2, TRAPS) {
1794   int k1 = operand_bootstrap_method_ref_index_at(idx1);
1795   int k2 = cp2-&gt;operand_bootstrap_method_ref_index_at(idx2);
1796   bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
1797 
1798   if (!match) {
1799     return false;
1800   }
1801   int argc = operand_argument_count_at(idx1);
1802   if (argc == cp2-&gt;operand_argument_count_at(idx2)) {
1803     for (int j = 0; j &lt; argc; j++) {
1804       k1 = operand_argument_index_at(idx1, j);
1805       k2 = cp2-&gt;operand_argument_index_at(idx2, j);
1806       match = compare_entry_to(k1, cp2, k2, CHECK_false);
1807       if (!match) {
1808         return false;
1809       }
1810     }
1811     return true;           // got through loop; all elements equal
1812   }
1813   return false;
1814 } // end compare_operand_to()
1815 
1816 // Search constant pool search_cp for a bootstrap specifier that matches
1817 // this constant pool&#39;s bootstrap specifier data at pattern_i index.
1818 // Return the index of a matching bootstrap attribute record or (-1) if there is no match.
1819 int ConstantPool::find_matching_operand(int pattern_i,
1820                     const constantPoolHandle&amp; search_cp, int search_len, TRAPS) {
1821   for (int i = 0; i &lt; search_len; i++) {
1822     bool found = compare_operand_to(pattern_i, search_cp, i, CHECK_(-1));
1823     if (found) {
1824       return i;
1825     }
1826   }
1827   return -1;  // bootstrap specifier data not found; return unused index (-1)
1828 } // end find_matching_operand()
1829 
1830 
1831 #ifndef PRODUCT
1832 
1833 const char* ConstantPool::printable_name_at(int which) {
1834 
1835   constantTag tag = tag_at(which);
1836 
1837   if (tag.is_string()) {
1838     return string_at_noresolve(which);
1839   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
1840     return klass_name_at(which)-&gt;as_C_string();
1841   } else if (tag.is_symbol()) {
1842     return symbol_at(which)-&gt;as_C_string();
1843   }
1844   return &quot;&quot;;
1845 }
1846 
1847 #endif // PRODUCT
1848 
1849 
1850 // JVMTI GetConstantPool support
1851 
1852 // For debugging of constant pool
1853 const bool debug_cpool = false;
1854 
1855 #define DBG(code) do { if (debug_cpool) { (code); } } while(0)
1856 
1857 static void print_cpool_bytes(jint cnt, u1 *bytes) {
1858   const char* WARN_MSG = &quot;Must not be such entry!&quot;;
1859   jint size = 0;
1860   u2   idx1, idx2;
1861 
1862   for (jint idx = 1; idx &lt; cnt; idx++) {
1863     jint ent_size = 0;
1864     u1   tag  = *bytes++;
1865     size++;                       // count tag
1866 
1867     printf(&quot;const #%03d, tag: %02d &quot;, idx, tag);
1868     switch(tag) {
1869       case JVM_CONSTANT_Invalid: {
1870         printf(&quot;Invalid&quot;);
1871         break;
1872       }
1873       case JVM_CONSTANT_Unicode: {
1874         printf(&quot;Unicode      %s&quot;, WARN_MSG);
1875         break;
1876       }
1877       case JVM_CONSTANT_Utf8: {
1878         u2 len = Bytes::get_Java_u2(bytes);
1879         char str[128];
1880         if (len &gt; 127) {
1881            len = 127;
1882         }
1883         strncpy(str, (char *) (bytes+2), len);
1884         str[len] = &#39;\0&#39;;
1885         printf(&quot;Utf8          \&quot;%s\&quot;&quot;, str);
1886         ent_size = 2 + len;
1887         break;
1888       }
1889       case JVM_CONSTANT_Integer: {
1890         u4 val = Bytes::get_Java_u4(bytes);
1891         printf(&quot;int          %d&quot;, *(int *) &amp;val);
1892         ent_size = 4;
1893         break;
1894       }
1895       case JVM_CONSTANT_Float: {
1896         u4 val = Bytes::get_Java_u4(bytes);
1897         printf(&quot;float        %5.3ff&quot;, *(float *) &amp;val);
1898         ent_size = 4;
1899         break;
1900       }
1901       case JVM_CONSTANT_Long: {
1902         u8 val = Bytes::get_Java_u8(bytes);
1903         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1904         ent_size = 8;
1905         idx++; // Long takes two cpool slots
1906         break;
1907       }
1908       case JVM_CONSTANT_Double: {
1909         u8 val = Bytes::get_Java_u8(bytes);
1910         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1911         ent_size = 8;
1912         idx++; // Double takes two cpool slots
1913         break;
1914       }
1915       case JVM_CONSTANT_Class: {
1916         idx1 = Bytes::get_Java_u2(bytes);
1917         printf(&quot;class        #%03d&quot;, idx1);
1918         ent_size = 2;
1919         break;
1920       }
1921       case (JVM_CONSTANT_Class | JVM_CONSTANT_QDescBit): {
1922         idx1 = Bytes::get_Java_u2(bytes);
1923         printf(&quot;qclass        #%03d&quot;, idx1);
1924         ent_size = 2;
1925         break;
1926       }
1927       case JVM_CONSTANT_String: {
1928         idx1 = Bytes::get_Java_u2(bytes);
1929         printf(&quot;String       #%03d&quot;, idx1);
1930         ent_size = 2;
1931         break;
1932       }
1933       case JVM_CONSTANT_Fieldref: {
1934         idx1 = Bytes::get_Java_u2(bytes);
1935         idx2 = Bytes::get_Java_u2(bytes+2);
1936         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1937         ent_size = 4;
1938         break;
1939       }
1940       case JVM_CONSTANT_Methodref: {
1941         idx1 = Bytes::get_Java_u2(bytes);
1942         idx2 = Bytes::get_Java_u2(bytes+2);
1943         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1944         ent_size = 4;
1945         break;
1946       }
1947       case JVM_CONSTANT_InterfaceMethodref: {
1948         idx1 = Bytes::get_Java_u2(bytes);
1949         idx2 = Bytes::get_Java_u2(bytes+2);
1950         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1951         ent_size = 4;
1952         break;
1953       }
1954       case JVM_CONSTANT_NameAndType: {
1955         idx1 = Bytes::get_Java_u2(bytes);
1956         idx2 = Bytes::get_Java_u2(bytes+2);
1957         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1958         ent_size = 4;
1959         break;
1960       }
1961       case JVM_CONSTANT_ClassIndex: {
1962         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1963         break;
1964       }
1965       case JVM_CONSTANT_UnresolvedClass: {
1966         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1967         break;
1968       }
1969       case (JVM_CONSTANT_UnresolvedClass | JVM_CONSTANT_QDescBit): {
1970         printf(&quot;UnresolvedQClass: %s&quot;, WARN_MSG);
1971         break;
1972       }
1973       case JVM_CONSTANT_UnresolvedClassInError: {
1974         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1975         break;
1976       }
1977       case JVM_CONSTANT_StringIndex: {
1978         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1979         break;
1980       }
1981     }
1982     printf(&quot;;\n&quot;);
1983     bytes += ent_size;
1984     size  += ent_size;
1985   }
1986   printf(&quot;Cpool size: %d\n&quot;, size);
1987   fflush(0);
1988   return;
1989 } /* end print_cpool_bytes */
1990 
1991 
1992 // Returns size of constant pool entry.
1993 jint ConstantPool::cpool_entry_size(jint idx) {
1994   switch(tag_at(idx).value()) {
1995     case JVM_CONSTANT_Invalid:
1996     case JVM_CONSTANT_Unicode:
1997       return 1;
1998 
1999     case JVM_CONSTANT_Utf8:
2000       return 3 + symbol_at(idx)-&gt;utf8_length();
2001 
2002     case JVM_CONSTANT_Class:
2003     case JVM_CONSTANT_String:
2004     case JVM_CONSTANT_ClassIndex:
2005     case JVM_CONSTANT_UnresolvedClass:
2006     case JVM_CONSTANT_UnresolvedClassInError:
2007     case JVM_CONSTANT_StringIndex:
2008     case JVM_CONSTANT_MethodType:
2009     case JVM_CONSTANT_MethodTypeInError:
2010       return 3;
2011 
2012     case JVM_CONSTANT_MethodHandle:
2013     case JVM_CONSTANT_MethodHandleInError:
2014       return 4; //tag, ref_kind, ref_index
2015 
2016     case JVM_CONSTANT_Integer:
2017     case JVM_CONSTANT_Float:
2018     case JVM_CONSTANT_Fieldref:
2019     case JVM_CONSTANT_Methodref:
2020     case JVM_CONSTANT_InterfaceMethodref:
2021     case JVM_CONSTANT_NameAndType:
2022       return 5;
2023 
2024     case JVM_CONSTANT_Dynamic:
2025     case JVM_CONSTANT_DynamicInError:
2026     case JVM_CONSTANT_InvokeDynamic:
2027       // u1 tag, u2 bsm, u2 nt
2028       return 5;
2029 
2030     case JVM_CONSTANT_Long:
2031     case JVM_CONSTANT_Double:
2032       return 9;
2033   }
2034   assert(false, &quot;cpool_entry_size: Invalid constant pool entry tag&quot;);
2035   return 1;
2036 } /* end cpool_entry_size */
2037 
2038 
2039 // SymbolHashMap is used to find a constant pool index from a string.
2040 // This function fills in SymbolHashMaps, one for utf8s and one for
2041 // class names, returns size of the cpool raw bytes.
2042 jint ConstantPool::hash_entries_to(SymbolHashMap *symmap,
2043                                           SymbolHashMap *classmap) {
2044   jint size = 0;
2045 
2046   for (u2 idx = 1; idx &lt; length(); idx++) {
2047     u2 tag = tag_at(idx).value();
2048     size += cpool_entry_size(idx);
2049 
2050     switch(tag) {
2051       case JVM_CONSTANT_Utf8: {
2052         Symbol* sym = symbol_at(idx);
2053         symmap-&gt;add_entry(sym, idx);
2054         DBG(printf(&quot;adding symbol entry %s = %d\n&quot;, sym-&gt;as_utf8(), idx));
2055         break;
2056       }
2057       case JVM_CONSTANT_Class:
2058       case JVM_CONSTANT_UnresolvedClass:
2059       case JVM_CONSTANT_UnresolvedClassInError: {
2060         Symbol* sym = klass_name_at(idx);
2061         classmap-&gt;add_entry(sym, idx);
2062         DBG(printf(&quot;adding class entry %s = %d\n&quot;, sym-&gt;as_utf8(), idx));
2063         break;
2064       }
2065       case JVM_CONSTANT_Long:
2066       case JVM_CONSTANT_Double: {
2067         idx++; // Both Long and Double take two cpool slots
2068         break;
2069       }
2070     }
2071   }
2072   return size;
2073 } /* end hash_utf8_entries_to */
2074 
2075 
2076 // Copy cpool bytes.
2077 // Returns:
2078 //    0, in case of OutOfMemoryError
2079 //   -1, in case of internal error
2080 //  &gt; 0, count of the raw cpool bytes that have been copied
2081 int ConstantPool::copy_cpool_bytes(int cpool_size,
2082                                           SymbolHashMap* tbl,
2083                                           unsigned char *bytes) {
2084   u2   idx1, idx2;
2085   jint size  = 0;
2086   jint cnt   = length();
2087   unsigned char *start_bytes = bytes;
2088 
2089   for (jint idx = 1; idx &lt; cnt; idx++) {
2090     u1   tag      = tag_at(idx).value();
2091     jint ent_size = cpool_entry_size(idx);
2092 
2093     assert(size + ent_size &lt;= cpool_size, &quot;Size mismatch&quot;);
2094 
2095     *bytes = tag;
2096     DBG(printf(&quot;#%03hd tag=%03hd, &quot;, (short)idx, (short)tag));
2097     switch(tag) {
2098       case JVM_CONSTANT_Invalid: {
2099         DBG(printf(&quot;JVM_CONSTANT_Invalid&quot;));
2100         break;
2101       }
2102       case JVM_CONSTANT_Unicode: {
2103         assert(false, &quot;Wrong constant pool tag: JVM_CONSTANT_Unicode&quot;);
2104         DBG(printf(&quot;JVM_CONSTANT_Unicode&quot;));
2105         break;
2106       }
2107       case JVM_CONSTANT_Utf8: {
2108         Symbol* sym = symbol_at(idx);
2109         char*     str = sym-&gt;as_utf8();
2110         // Warning! It&#39;s crashing on x86 with len = sym-&gt;utf8_length()
2111         int       len = (int) strlen(str);
2112         Bytes::put_Java_u2((address) (bytes+1), (u2) len);
2113         for (int i = 0; i &lt; len; i++) {
2114             bytes[3+i] = (u1) str[i];
2115         }
2116         DBG(printf(&quot;JVM_CONSTANT_Utf8: %s &quot;, str));
2117         break;
2118       }
2119       case JVM_CONSTANT_Integer: {
2120         jint val = int_at(idx);
2121         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2122         break;
2123       }
2124       case JVM_CONSTANT_Float: {
2125         jfloat val = float_at(idx);
2126         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2127         break;
2128       }
2129       case JVM_CONSTANT_Long: {
2130         jlong val = long_at(idx);
2131         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2132         idx++;             // Long takes two cpool slots
2133         break;
2134       }
2135       case JVM_CONSTANT_Double: {
2136         jdouble val = double_at(idx);
2137         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2138         idx++;             // Double takes two cpool slots
2139         break;
2140       }
2141       case JVM_CONSTANT_Class:
2142       case JVM_CONSTANT_UnresolvedClass:
2143       case JVM_CONSTANT_UnresolvedClassInError: {
2144         assert(!tag_at(idx).is_Qdescriptor_klass(), &quot;Failed to encode QDesc&quot;);
2145         *bytes = JVM_CONSTANT_Class;
2146         Symbol* sym = klass_name_at(idx);
2147         idx1 = tbl-&gt;symbol_to_value(sym);
2148         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2149         Bytes::put_Java_u2((address) (bytes+1), idx1);
2150         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2151         break;
2152       }
2153       case JVM_CONSTANT_String: {
2154         *bytes = JVM_CONSTANT_String;
2155         Symbol* sym = unresolved_string_at(idx);
2156         idx1 = tbl-&gt;symbol_to_value(sym);
2157         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2158         Bytes::put_Java_u2((address) (bytes+1), idx1);
2159         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2160         break;
2161       }
2162       case JVM_CONSTANT_Fieldref:
2163       case JVM_CONSTANT_Methodref:
2164       case JVM_CONSTANT_InterfaceMethodref: {
2165         idx1 = uncached_klass_ref_index_at(idx);
2166         idx2 = uncached_name_and_type_ref_index_at(idx);
2167         Bytes::put_Java_u2((address) (bytes+1), idx1);
2168         Bytes::put_Java_u2((address) (bytes+3), idx2);
2169         DBG(printf(&quot;JVM_CONSTANT_Methodref: %hd %hd&quot;, idx1, idx2));
2170         break;
2171       }
2172       case JVM_CONSTANT_NameAndType: {
2173         idx1 = name_ref_index_at(idx);
2174         idx2 = signature_ref_index_at(idx);
2175         Bytes::put_Java_u2((address) (bytes+1), idx1);
2176         Bytes::put_Java_u2((address) (bytes+3), idx2);
2177         DBG(printf(&quot;JVM_CONSTANT_NameAndType: %hd %hd&quot;, idx1, idx2));
2178         break;
2179       }
2180       case JVM_CONSTANT_ClassIndex: {
2181         *bytes = JVM_CONSTANT_Class;
2182         idx1 = klass_index_at(idx);
2183         Bytes::put_Java_u2((address) (bytes+1), idx1);
2184         DBG(printf(&quot;JVM_CONSTANT_ClassIndex: %hd&quot;, idx1));
2185         break;
2186       }
2187       case JVM_CONSTANT_StringIndex: {
2188         *bytes = JVM_CONSTANT_String;
2189         idx1 = string_index_at(idx);
2190         Bytes::put_Java_u2((address) (bytes+1), idx1);
2191         DBG(printf(&quot;JVM_CONSTANT_StringIndex: %hd&quot;, idx1));
2192         break;
2193       }
2194       case JVM_CONSTANT_MethodHandle:
2195       case JVM_CONSTANT_MethodHandleInError: {
2196         *bytes = JVM_CONSTANT_MethodHandle;
2197         int kind = method_handle_ref_kind_at(idx);
2198         idx1 = method_handle_index_at(idx);
2199         *(bytes+1) = (unsigned char) kind;
2200         Bytes::put_Java_u2((address) (bytes+2), idx1);
2201         DBG(printf(&quot;JVM_CONSTANT_MethodHandle: %d %hd&quot;, kind, idx1));
2202         break;
2203       }
2204       case JVM_CONSTANT_MethodType:
2205       case JVM_CONSTANT_MethodTypeInError: {
2206         *bytes = JVM_CONSTANT_MethodType;
2207         idx1 = method_type_index_at(idx);
2208         Bytes::put_Java_u2((address) (bytes+1), idx1);
2209         DBG(printf(&quot;JVM_CONSTANT_MethodType: %hd&quot;, idx1));
2210         break;
2211       }
2212       case JVM_CONSTANT_Dynamic:
2213       case JVM_CONSTANT_DynamicInError: {
2214         *bytes = tag;
2215         idx1 = extract_low_short_from_int(*int_at_addr(idx));
2216         idx2 = extract_high_short_from_int(*int_at_addr(idx));
2217         assert(idx2 == bootstrap_name_and_type_ref_index_at(idx), &quot;correct half of u4&quot;);
2218         Bytes::put_Java_u2((address) (bytes+1), idx1);
2219         Bytes::put_Java_u2((address) (bytes+3), idx2);
2220         DBG(printf(&quot;JVM_CONSTANT_Dynamic: %hd %hd&quot;, idx1, idx2));
2221         break;
2222       }
2223       case JVM_CONSTANT_InvokeDynamic: {
2224         *bytes = tag;
2225         idx1 = extract_low_short_from_int(*int_at_addr(idx));
2226         idx2 = extract_high_short_from_int(*int_at_addr(idx));
2227         assert(idx2 == bootstrap_name_and_type_ref_index_at(idx), &quot;correct half of u4&quot;);
2228         Bytes::put_Java_u2((address) (bytes+1), idx1);
2229         Bytes::put_Java_u2((address) (bytes+3), idx2);
2230         DBG(printf(&quot;JVM_CONSTANT_InvokeDynamic: %hd %hd&quot;, idx1, idx2));
2231         break;
2232       }
2233     }
2234     DBG(printf(&quot;\n&quot;));
2235     bytes += ent_size;
2236     size  += ent_size;
2237   }
2238   assert(size == cpool_size, &quot;Size mismatch&quot;);
2239 
2240   // Keep temorarily for debugging until it&#39;s stable.
2241   DBG(print_cpool_bytes(cnt, start_bytes));
2242   return (int)(bytes - start_bytes);
2243 } /* end copy_cpool_bytes */
2244 
2245 #undef DBG
2246 
2247 
2248 void ConstantPool::set_on_stack(const bool value) {
2249   if (value) {
2250     // Only record if it&#39;s not already set.
2251     if (!on_stack()) {
2252       assert(!is_shared(), &quot;should always be set for shared constant pools&quot;);
2253       _flags |= _on_stack;
2254       MetadataOnStackMark::record(this);
2255     }
2256   } else {
2257     // Clearing is done single-threadedly.
2258     if (!is_shared()) {
2259       _flags &amp;= ~_on_stack;
2260     }
2261   }
2262 }
2263 
2264 // JSR 292 support for patching constant pool oops after the class is linked and
2265 // the oop array for resolved references are created.
2266 // We can&#39;t do this during classfile parsing, which is how the other indexes are
2267 // patched.  The other patches are applied early for some error checking
2268 // so only defer the pseudo_strings.
2269 void ConstantPool::patch_resolved_references(GrowableArray&lt;Handle&gt;* cp_patches) {
2270   for (int index = 1; index &lt; cp_patches-&gt;length(); index++) { // Index 0 is unused
2271     Handle patch = cp_patches-&gt;at(index);
2272     if (patch.not_null()) {
2273       assert (tag_at(index).is_string(), &quot;should only be string left&quot;);
2274       // Patching a string means pre-resolving it.
2275       // The spelling in the constant pool is ignored.
2276       // The constant reference may be any object whatever.
2277       // If it is not a real interned string, the constant is referred
2278       // to as a &quot;pseudo-string&quot;, and must be presented to the CP
2279       // explicitly, because it may require scavenging.
2280       int obj_index = cp_to_object_index(index);
2281       pseudo_string_at_put(index, obj_index, patch());
2282      DEBUG_ONLY(cp_patches-&gt;at_put(index, Handle());)
2283     }
2284   }
2285 #ifdef ASSERT
2286   // Ensure that all the patches have been used.
2287   for (int index = 0; index &lt; cp_patches-&gt;length(); index++) {
2288     assert(cp_patches-&gt;at(index).is_null(),
2289            &quot;Unused constant pool patch at %d in class file %s&quot;,
2290            index,
2291            pool_holder()-&gt;external_name());
2292   }
2293 #endif // ASSERT
2294 }
2295 
2296 // Printing
2297 
2298 void ConstantPool::print_on(outputStream* st) const {
2299   assert(is_constantPool(), &quot;must be constantPool&quot;);
2300   st-&gt;print_cr(&quot;%s&quot;, internal_name());
2301   if (flags() != 0) {
2302     st-&gt;print(&quot; - flags: 0x%x&quot;, flags());
2303     if (has_preresolution()) st-&gt;print(&quot; has_preresolution&quot;);
2304     if (on_stack()) st-&gt;print(&quot; on_stack&quot;);
2305     st-&gt;cr();
2306   }
2307   if (pool_holder() != NULL) {
2308     st-&gt;print_cr(&quot; - holder: &quot; INTPTR_FORMAT, p2i(pool_holder()));
2309   }
2310   st-&gt;print_cr(&quot; - cache: &quot; INTPTR_FORMAT, p2i(cache()));
2311   st-&gt;print_cr(&quot; - resolved_references: &quot; INTPTR_FORMAT, p2i(resolved_references()));
2312   st-&gt;print_cr(&quot; - reference_map: &quot; INTPTR_FORMAT, p2i(reference_map()));
2313   st-&gt;print_cr(&quot; - resolved_klasses: &quot; INTPTR_FORMAT, p2i(resolved_klasses()));
2314 
2315   for (int index = 1; index &lt; length(); index++) {      // Index 0 is unused
2316     ((ConstantPool*)this)-&gt;print_entry_on(index, st);
2317     switch (tag_at(index).value()) {
2318       case JVM_CONSTANT_Long :
2319       case JVM_CONSTANT_Double :
2320         index++;   // Skip entry following eigth-byte constant
2321     }
2322 
2323   }
2324   st-&gt;cr();
2325 }
2326 
2327 // Print one constant pool entry
2328 void ConstantPool::print_entry_on(const int index, outputStream* st) {
2329   EXCEPTION_MARK;
2330   st-&gt;print(&quot; - %3d : &quot;, index);
2331   tag_at(index).print_on(st);
2332   st-&gt;print(&quot; : &quot;);
2333   switch (tag_at(index).value()) {
2334     case JVM_CONSTANT_Class :
2335       { Klass* k = klass_at(index, CATCH);
2336         guarantee(k != NULL, &quot;need klass&quot;);
2337         k-&gt;print_value_on(st);
2338         st-&gt;print(&quot; {&quot; PTR_FORMAT &quot;}&quot;, p2i(k));
2339       }
2340       break;
2341     case JVM_CONSTANT_Fieldref :
2342     case JVM_CONSTANT_Methodref :
2343     case JVM_CONSTANT_InterfaceMethodref :
2344       st-&gt;print(&quot;klass_index=%d&quot;, uncached_klass_ref_index_at(index));
2345       st-&gt;print(&quot; name_and_type_index=%d&quot;, uncached_name_and_type_ref_index_at(index));
2346       break;
2347     case JVM_CONSTANT_String :
2348       if (is_pseudo_string_at(index)) {
2349         oop anObj = pseudo_string_at(index);
2350         anObj-&gt;print_value_on(st);
2351         st-&gt;print(&quot; {&quot; PTR_FORMAT &quot;}&quot;, p2i(anObj));
2352       } else {
2353         unresolved_string_at(index)-&gt;print_value_on(st);
2354       }
2355       break;
2356     case JVM_CONSTANT_Integer :
2357       st-&gt;print(&quot;%d&quot;, int_at(index));
2358       break;
2359     case JVM_CONSTANT_Float :
2360       st-&gt;print(&quot;%f&quot;, float_at(index));
2361       break;
2362     case JVM_CONSTANT_Long :
2363       st-&gt;print_jlong(long_at(index));
2364       break;
2365     case JVM_CONSTANT_Double :
2366       st-&gt;print(&quot;%lf&quot;, double_at(index));
2367       break;
2368     case JVM_CONSTANT_NameAndType :
2369       st-&gt;print(&quot;name_index=%d&quot;, name_ref_index_at(index));
2370       st-&gt;print(&quot; signature_index=%d&quot;, signature_ref_index_at(index));
2371       break;
2372     case JVM_CONSTANT_Utf8 :
2373       symbol_at(index)-&gt;print_value_on(st);
2374       break;
2375     case JVM_CONSTANT_ClassIndex: {
2376         int name_index = *int_at_addr(index);
2377         st-&gt;print(&quot;klass_index=%d &quot;, name_index);
2378         symbol_at(name_index)-&gt;print_value_on(st);
2379       }
2380       break;
2381     case JVM_CONSTANT_UnresolvedClass :               // fall-through
2382     case JVM_CONSTANT_UnresolvedClassInError: {
2383         CPKlassSlot kslot = klass_slot_at(index);
2384         int resolved_klass_index = kslot.resolved_klass_index();
2385         int name_index = kslot.name_index();
2386         assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
2387 
2388         Klass* klass = resolved_klasses()-&gt;at(resolved_klass_index);
2389         if (klass != NULL) {
2390           klass-&gt;print_value_on(st);
2391         } else {
2392           symbol_at(name_index)-&gt;print_value_on(st);
2393         }
2394       }
2395       break;
2396     case JVM_CONSTANT_MethodHandle :
2397     case JVM_CONSTANT_MethodHandleInError :
2398       st-&gt;print(&quot;ref_kind=%d&quot;, method_handle_ref_kind_at(index));
2399       st-&gt;print(&quot; ref_index=%d&quot;, method_handle_index_at(index));
2400       break;
2401     case JVM_CONSTANT_MethodType :
2402     case JVM_CONSTANT_MethodTypeInError :
2403       st-&gt;print(&quot;signature_index=%d&quot;, method_type_index_at(index));
2404       break;
2405     case JVM_CONSTANT_Dynamic :
2406     case JVM_CONSTANT_DynamicInError :
2407       {
2408         st-&gt;print(&quot;bootstrap_method_index=%d&quot;, bootstrap_method_ref_index_at(index));
2409         st-&gt;print(&quot; type_index=%d&quot;, bootstrap_name_and_type_ref_index_at(index));
2410         int argc = bootstrap_argument_count_at(index);
2411         if (argc &gt; 0) {
2412           for (int arg_i = 0; arg_i &lt; argc; arg_i++) {
2413             int arg = bootstrap_argument_index_at(index, arg_i);
2414             st-&gt;print((arg_i == 0 ? &quot; arguments={%d&quot; : &quot;, %d&quot;), arg);
2415           }
2416           st-&gt;print(&quot;}&quot;);
2417         }
2418       }
2419       break;
2420     case JVM_CONSTANT_InvokeDynamic :
2421       {
2422         st-&gt;print(&quot;bootstrap_method_index=%d&quot;, bootstrap_method_ref_index_at(index));
2423         st-&gt;print(&quot; name_and_type_index=%d&quot;, bootstrap_name_and_type_ref_index_at(index));
2424         int argc = bootstrap_argument_count_at(index);
2425         if (argc &gt; 0) {
2426           for (int arg_i = 0; arg_i &lt; argc; arg_i++) {
2427             int arg = bootstrap_argument_index_at(index, arg_i);
2428             st-&gt;print((arg_i == 0 ? &quot; arguments={%d&quot; : &quot;, %d&quot;), arg);
2429           }
2430           st-&gt;print(&quot;}&quot;);
2431         }
2432       }
2433       break;
2434     default:
2435       ShouldNotReachHere();
2436       break;
2437   }
2438   st-&gt;cr();
2439 }
2440 
2441 void ConstantPool::print_value_on(outputStream* st) const {
2442   assert(is_constantPool(), &quot;must be constantPool&quot;);
2443   st-&gt;print(&quot;constant pool [%d]&quot;, length());
2444   if (has_preresolution()) st-&gt;print(&quot;/preresolution&quot;);
2445   if (operands() != NULL)  st-&gt;print(&quot;/operands[%d]&quot;, operands()-&gt;length());
2446   print_address_on(st);
2447   if (pool_holder() != NULL) {
2448     st-&gt;print(&quot; for &quot;);
2449     pool_holder()-&gt;print_value_on(st);
2450     bool extra = (pool_holder()-&gt;constants() != this);
2451     if (extra)  st-&gt;print(&quot; (extra)&quot;);
2452   }
2453   if (cache() != NULL) {
2454     st-&gt;print(&quot; cache=&quot; PTR_FORMAT, p2i(cache()));
2455   }
2456 }
2457 
2458 // Verification
2459 
2460 void ConstantPool::verify_on(outputStream* st) {
2461   guarantee(is_constantPool(), &quot;object must be constant pool&quot;);
2462   for (int i = 0; i&lt; length();  i++) {
2463     constantTag tag = tag_at(i);
2464     if (tag.is_klass() || tag.is_unresolved_klass()) {
2465       guarantee(klass_name_at(i)-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2466     } else if (tag.is_symbol()) {
2467       CPSlot entry = slot_at(i);
2468       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2469     } else if (tag.is_string()) {
2470       CPSlot entry = slot_at(i);
2471       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2472     }
2473   }
2474   if (pool_holder() != NULL) {
2475     // Note: pool_holder() can be NULL in temporary constant pools
2476     // used during constant pool merging
2477     guarantee(pool_holder()-&gt;is_klass(),    &quot;should be klass&quot;);
2478   }
2479 }
2480 
2481 
2482 SymbolHashMap::~SymbolHashMap() {
2483   SymbolHashMapEntry* next;
2484   for (int i = 0; i &lt; _table_size; i++) {
2485     for (SymbolHashMapEntry* cur = bucket(i); cur != NULL; cur = next) {
2486       next = cur-&gt;next();
2487       delete(cur);
2488     }
2489   }
2490   FREE_C_HEAP_ARRAY(SymbolHashMapBucket, _buckets);
2491 }
2492 
2493 void SymbolHashMap::add_entry(Symbol* sym, u2 value) {
2494   char *str = sym-&gt;as_utf8();
2495   unsigned int hash = compute_hash(str, sym-&gt;utf8_length());
2496   unsigned int index = hash % table_size();
2497 
2498   // check if already in map
2499   // we prefer the first entry since it is more likely to be what was used in
2500   // the class file
2501   for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en-&gt;next()) {
2502     assert(en-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2503     if (en-&gt;hash() == hash &amp;&amp; en-&gt;symbol() == sym) {
2504         return;  // already there
2505     }
2506   }
2507 
2508   SymbolHashMapEntry* entry = new SymbolHashMapEntry(hash, sym, value);
2509   entry-&gt;set_next(bucket(index));
2510   _buckets[index].set_entry(entry);
2511   assert(entry-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2512 }
2513 
2514 SymbolHashMapEntry* SymbolHashMap::find_entry(Symbol* sym) {
2515   assert(sym != NULL, &quot;SymbolHashMap::find_entry - symbol is NULL&quot;);
2516   char *str = sym-&gt;as_utf8();
2517   int   len = sym-&gt;utf8_length();
2518   unsigned int hash = SymbolHashMap::compute_hash(str, len);
2519   unsigned int index = hash % table_size();
2520   for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en-&gt;next()) {
2521     assert(en-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2522     if (en-&gt;hash() == hash &amp;&amp; en-&gt;symbol() == sym) {
2523       return en;
2524     }
2525   }
2526   return NULL;
2527 }
2528 
2529 void SymbolHashMap::initialize_table(int table_size) {
2530   _table_size = table_size;
2531   _buckets = NEW_C_HEAP_ARRAY(SymbolHashMapBucket, table_size, mtSymbol);
2532   for (int index = 0; index &lt; table_size; index++) {
2533     _buckets[index].clear();
2534   }
2535 }
    </pre>
  </body>
</html>
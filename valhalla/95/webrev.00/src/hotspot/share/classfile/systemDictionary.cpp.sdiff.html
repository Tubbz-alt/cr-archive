<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1463 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1464                                                    Handle class_loader,
1465                                                    Handle protection_domain,
1466                                                    const ClassFileStream *cfs,
1467                                                    PackageEntry* pkg_entry,
1468                                                    TRAPS) {
1469   assert(ik != NULL, &quot;sanity&quot;);
1470   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1471   Symbol* class_name = ik-&gt;name();
1472 
1473   bool visible = is_shared_class_visible(
1474                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1475   if (!visible) {
1476     return NULL;
1477   }
1478 
1479   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1480     return NULL;
1481   }
1482 




















1483   InstanceKlass* new_ik = NULL;
1484   // CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).
1485   // It will be skipped for shared VM hidden lambda proxy classes.
1486   if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {
1487     new_ik = KlassFactory::check_shared_class_file_load_hook(
1488       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1489   }
1490   if (new_ik != NULL) {
1491     // The class is changed by CFLH. Return the new class. The shared class is
1492     // not used.
1493     return new_ik;
1494   }
1495 
1496   // Adjust methods to recover missing data.  They need addresses for
1497   // interpreter entry points and their default native method address
1498   // must be reset.
1499 
1500   // Updating methods must be done under a lock so multiple
1501   // threads don&#39;t update these in parallel
1502   //
1503   // Shared classes are all currently loaded by either the bootstrap or
1504   // internal parallel class loaders, so this will never cause a deadlock
1505   // on a custom class loader lock.
1506 
1507   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1508   {
1509     HandleMark hm(THREAD);
1510     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1511     check_loader_lock_contention(lockObject, THREAD);
1512     ObjectLocker ol(lockObject, THREAD, true);
1513     // prohibited package check assumes all classes loaded from archive call
1514     // restore_unshareable_info which calls ik-&gt;set_package()
1515     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1516   }
1517 
1518   load_shared_class_misc(ik, loader_data, CHECK_NULL);







1519   return ik;
1520 }
1521 
1522 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1523   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1524 
1525   // For boot loader, ensure that GetSystemPackage knows that a class in this
1526   // package was loaded.
1527   if (loader_data-&gt;is_the_null_class_loader_data()) {
1528     int path_index = ik-&gt;shared_classpath_index();
1529     ik-&gt;set_classpath_index(path_index, THREAD);
1530   }
1531 
1532   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1533     // Only dump the classes that can be stored into CDS archive
1534     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1535       ResourceMark rm(THREAD);
1536       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1537       classlist_file-&gt;flush();
1538     }
</pre>
<hr />
<pre>
1562   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1563   if (klass-&gt;class_loader_data() != NULL) {
1564     return;
1565   }
1566 
1567   // add super and interfaces first
1568   Klass* super = klass-&gt;super();
1569   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1570     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1571     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1572   }
1573 
1574   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1575   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1576     InstanceKlass* ik = ifs-&gt;at(i);
1577     if (ik-&gt;class_loader_data()  == NULL) {
1578       quick_resolve(ik, loader_data, domain, CHECK);
1579     }
1580   }
1581 















1582   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1583   load_shared_class_misc(klass, loader_data, CHECK);
1584   Dictionary* dictionary = loader_data-&gt;dictionary();
1585   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1586   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1587   add_to_hierarchy(klass, CHECK);
1588   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1589 }
1590 #endif // INCLUDE_CDS
1591 
1592 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1593 
1594   if (class_loader.is_null()) {
1595     ResourceMark rm(THREAD);
1596     PackageEntry* pkg_entry = NULL;
1597     bool search_only_bootloader_append = false;
1598     ClassLoaderData *loader_data = class_loader_data(class_loader);
1599 
1600     // Find the package in the boot loader&#39;s package entry table.
1601     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
</pre>
</td>
<td>
<hr />
<pre>
1463 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1464                                                    Handle class_loader,
1465                                                    Handle protection_domain,
1466                                                    const ClassFileStream *cfs,
1467                                                    PackageEntry* pkg_entry,
1468                                                    TRAPS) {
1469   assert(ik != NULL, &quot;sanity&quot;);
1470   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1471   Symbol* class_name = ik-&gt;name();
1472 
1473   bool visible = is_shared_class_visible(
1474                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1475   if (!visible) {
1476     return NULL;
1477   }
1478 
1479   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1480     return NULL;
1481   }
1482 
<span class="line-added">1483 </span>
<span class="line-added">1484   if (ik-&gt;has_inline_type_fields()) {</span>
<span class="line-added">1485     for (AllFieldStream fs(ik-&gt;fields(), ik-&gt;constants()); !fs.done(); fs.next()) {</span>
<span class="line-added">1486       if (Signature::basic_type(fs.signature()) == T_VALUETYPE) {</span>
<span class="line-added">1487         if (!fs.access_flags().is_static()) {</span>
<span class="line-added">1488           // Pre-load inline class</span>
<span class="line-added">1489           Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="line-added">1490             class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="line-added">1491           Klass* k = ik-&gt;get_inline_type_field_klass_or_null(fs.index());</span>
<span class="line-added">1492           if (real_k != k) {</span>
<span class="line-added">1493             // oops, the app has substituted a different version of k!</span>
<span class="line-added">1494             return NULL;</span>
<span class="line-added">1495           }</span>
<span class="line-added">1496         } else {</span>
<span class="line-added">1497          ik-&gt;reset_inline_type_field_klass(fs.index());</span>
<span class="line-added">1498         }</span>
<span class="line-added">1499       }</span>
<span class="line-added">1500     }</span>
<span class="line-added">1501   }</span>
<span class="line-added">1502 </span>
1503   InstanceKlass* new_ik = NULL;
1504   // CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).
1505   // It will be skipped for shared VM hidden lambda proxy classes.
1506   if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {
1507     new_ik = KlassFactory::check_shared_class_file_load_hook(
1508       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1509   }
1510   if (new_ik != NULL) {
1511     // The class is changed by CFLH. Return the new class. The shared class is
1512     // not used.
1513     return new_ik;
1514   }
1515 
1516   // Adjust methods to recover missing data.  They need addresses for
1517   // interpreter entry points and their default native method address
1518   // must be reset.
1519 
1520   // Updating methods must be done under a lock so multiple
1521   // threads don&#39;t update these in parallel
1522   //
1523   // Shared classes are all currently loaded by either the bootstrap or
1524   // internal parallel class loaders, so this will never cause a deadlock
1525   // on a custom class loader lock.
1526 
1527   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1528   {
1529     HandleMark hm(THREAD);
1530     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1531     check_loader_lock_contention(lockObject, THREAD);
1532     ObjectLocker ol(lockObject, THREAD, true);
1533     // prohibited package check assumes all classes loaded from archive call
1534     // restore_unshareable_info which calls ik-&gt;set_package()
1535     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1536   }
1537 
1538   load_shared_class_misc(ik, loader_data, CHECK_NULL);
<span class="line-added">1539 </span>
<span class="line-added">1540   if (ik-&gt;is_inline_klass()) {</span>
<span class="line-added">1541     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">1542     oop val = ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">1543     vk-&gt;set_default_value(val);</span>
<span class="line-added">1544   }</span>
<span class="line-added">1545 </span>
1546   return ik;
1547 }
1548 
1549 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1550   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1551 
1552   // For boot loader, ensure that GetSystemPackage knows that a class in this
1553   // package was loaded.
1554   if (loader_data-&gt;is_the_null_class_loader_data()) {
1555     int path_index = ik-&gt;shared_classpath_index();
1556     ik-&gt;set_classpath_index(path_index, THREAD);
1557   }
1558 
1559   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1560     // Only dump the classes that can be stored into CDS archive
1561     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1562       ResourceMark rm(THREAD);
1563       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1564       classlist_file-&gt;flush();
1565     }
</pre>
<hr />
<pre>
1589   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1590   if (klass-&gt;class_loader_data() != NULL) {
1591     return;
1592   }
1593 
1594   // add super and interfaces first
1595   Klass* super = klass-&gt;super();
1596   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1597     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1598     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1599   }
1600 
1601   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1602   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1603     InstanceKlass* ik = ifs-&gt;at(i);
1604     if (ik-&gt;class_loader_data()  == NULL) {
1605       quick_resolve(ik, loader_data, domain, CHECK);
1606     }
1607   }
1608 
<span class="line-added">1609   if (klass-&gt;has_inline_type_fields()) {</span>
<span class="line-added">1610     for (AllFieldStream fs(klass-&gt;fields(), klass-&gt;constants()); !fs.done(); fs.next()) {</span>
<span class="line-added">1611       if (Signature::basic_type(fs.signature()) == T_VALUETYPE) {</span>
<span class="line-added">1612         if (!fs.access_flags().is_static()) {</span>
<span class="line-added">1613           Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="line-added">1614             Handle(THREAD, loader_data-&gt;class_loader()), domain, true, CHECK);</span>
<span class="line-added">1615           Klass* k = klass-&gt;get_inline_type_field_klass_or_null(fs.index());</span>
<span class="line-added">1616           assert(real_k == k, &quot;oops, the app has substituted a different version of k!&quot;);</span>
<span class="line-added">1617         } else {</span>
<span class="line-added">1618           klass-&gt;reset_inline_type_field_klass(fs.index());</span>
<span class="line-added">1619         }</span>
<span class="line-added">1620       }</span>
<span class="line-added">1621     }</span>
<span class="line-added">1622   }</span>
<span class="line-added">1623 </span>
1624   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1625   load_shared_class_misc(klass, loader_data, CHECK);
1626   Dictionary* dictionary = loader_data-&gt;dictionary();
1627   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1628   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1629   add_to_hierarchy(klass, CHECK);
1630   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1631 }
1632 #endif // INCLUDE_CDS
1633 
1634 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1635 
1636   if (class_loader.is_null()) {
1637     ResourceMark rm(THREAD);
1638     PackageEntry* pkg_entry = NULL;
1639     bool search_only_bootloader_append = false;
1640     ClassLoaderData *loader_data = class_loader_data(class_loader);
1641 
1642     // Find the package in the boot loader&#39;s package entry table.
1643     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
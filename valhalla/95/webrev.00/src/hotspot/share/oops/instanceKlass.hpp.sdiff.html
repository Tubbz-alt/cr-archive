<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;utilities/accessFlags.hpp&quot;
  39 #include &quot;utilities/align.hpp&quot;
  40 #include &quot;utilities/macros.hpp&quot;
  41 #if INCLUDE_JFR
  42 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  43 #endif
  44 
  45 class RecordComponent;
  46 
  47 // An InstanceKlass is the VM level representation of a Java class.
  48 // It contains all information needed for at class at execution runtime.
  49 
  50 //  InstanceKlass embedded field layout (after declared fields):
  51 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  52 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  53 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  54 //      indicating where oops are located in instances of this klass.
  55 //    [EMBEDDED implementor of the interface] only exist for interface
  56 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  57 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true

  58 //    [EMBEDDED ValueKlassFixedBlock] only if is a ValueKlass instance
  59 
  60 
  61 // forward declaration for class -- see below for definition
  62 #if INCLUDE_JVMTI
  63 class BreakpointInfo;
  64 #endif
  65 class ClassFileParser;
  66 class ClassFileStream;
  67 class KlassDepChange;
  68 class DependencyContext;
  69 class fieldDescriptor;
  70 class jniIdMapBase;
  71 class JNIid;
  72 class JvmtiCachedClassFieldMap;
  73 class nmethodBucket;
  74 class OopMapCache;
  75 class BufferedValueTypeBlob;
  76 class InterpreterOopMap;
  77 class PackageEntry;
</pre>
<hr />
<pre>
 208   // attribute. If the EnclosingMethod attribute exists, it occupies the
 209   // last two shorts [class_index, method_index] of the array. If only
 210   // the InnerClasses attribute exists, the _inner_classes array length is
 211   // number_of_inner_classes * 4. If the class has both InnerClasses
 212   // and EnclosingMethod attributes the _inner_classes array length is
 213   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 214   Array&lt;jushort&gt;* _inner_classes;
 215 
 216   // The NestMembers attribute. An array of shorts, where each is a
 217   // class info index for the class that is a nest member. This data
 218   // has not been validated.
 219   Array&lt;jushort&gt;* _nest_members;
 220 
 221   // Resolved nest-host klass: either true nest-host or self if we are not
 222   // nested, or an error occurred resolving or validating the nominated
 223   // nest-host. Can also be set directly by JDK API&#39;s that establish nest
 224   // relationships.
 225   // By always being set it makes nest-member access checks simpler.
 226   InstanceKlass* _nest_host;
 227 
<span class="line-removed"> 228   Array&lt;InlineTypes&gt;* _inline_types;</span>
<span class="line-removed"> 229 </span>
 230   // The PermittedSubclasses attribute. An array of shorts, where each is a
 231   // class info index for the class that is a permitted subclass.
 232   Array&lt;jushort&gt;* _permitted_subclasses;
 233 
 234   // The contents of the Record attribute.
 235   Array&lt;RecordComponent*&gt;* _record_components;
 236 
 237   // the source debug extension for this klass, NULL if not specified.
 238   // Specified as UTF-8 string without terminating zero byte in the classfile,
 239   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 240   const char*     _source_debug_extension;
 241 
 242   // Number of heapOopSize words used by non-static fields in this klass
 243   // (including inherited fields but after header_size()).
 244   int             _nonstatic_field_size;
 245   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 246 
 247   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 248   int             _itable_len;           // length of Java itable (in words)
 249 
</pre>
<hr />
<pre>
 278   u1              _kind;                          // kind of InstanceKlass
 279 
 280   enum {
 281     _misc_rewritten                           = 1 &lt;&lt; 0,  // methods rewritten.
 282     _misc_has_nonstatic_fields                = 1 &lt;&lt; 1,  // for sizing with UseCompressedOops
 283     _misc_should_verify_class                 = 1 &lt;&lt; 2,  // allow caching of preverification
 284     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 3,  // has embedded _unsafe_anonymous_host field
 285     _misc_is_contended                        = 1 &lt;&lt; 4,  // marked with contended annotation
 286     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 5,  // class/superclass/implemented interfaces has non-static, concrete methods
 287     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 6,  // directly declares non-static, concrete methods
 288     _misc_has_been_redefined                  = 1 &lt;&lt; 7,  // class has been redefined
 289     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 8,  // when this class was loaded, the fingerprint computed from its
 290                                                          // code source was found to be matching the value recorded by AOT.
 291     _misc_is_scratch_class                    = 1 &lt;&lt; 9,  // class is the redefined scratch class
 292     _misc_is_shared_boot_class                = 1 &lt;&lt; 10, // defining class loader is boot class loader
 293     _misc_is_shared_platform_class            = 1 &lt;&lt; 11, // defining class loader is platform class loader
 294     _misc_is_shared_app_class                 = 1 &lt;&lt; 12, // defining class loader is app class loader
 295     _misc_has_resolved_methods                = 1 &lt;&lt; 13, // resolved methods table entries added for this class
 296     _misc_is_being_redefined                  = 1 &lt;&lt; 14, // used for locking redefinition
 297     _misc_has_contended_annotations           = 1 &lt;&lt; 15,  // has @Contended annotation
<span class="line-modified"> 298     _misc_has_inline_fields                   = 1 &lt;&lt; 16, // has inline fields and related embedded section is not empty</span>
 299     _misc_is_empty_inline_type                = 1 &lt;&lt; 17, // empty inline type
 300     _misc_is_naturally_atomic                 = 1 &lt;&lt; 18, // loaded/stored in one instruction
 301     _misc_is_declared_atomic                  = 1 &lt;&lt; 19, // implements jl.NonTearable
 302     _misc_invalid_inline_super                = 1 &lt;&lt; 20, // invalid super type for an inline type
 303     _misc_invalid_identity_super              = 1 &lt;&lt; 21, // invalid super type for an identity type
 304     _misc_has_injected_identityObject         = 1 &lt;&lt; 22  // IdentityObject has been injected by the JVM
 305   };
 306   u2 shared_loader_type_bits() const {
 307     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 308   }
 309   u4              _misc_flags;           // There is more space in access_flags for more flags.
 310 
 311   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 312   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 313   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 314   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 315   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 316   uint64_t        volatile _dep_context_last_cleaned;
 317   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 318 #if INCLUDE_JVMTI
</pre>
<hr />
<pre>
 341   // Int array containing the original order of method in the class file (for JVMTI).
 342   Array&lt;int&gt;*     _method_ordering;
 343   // Int array containing the vtable_indices for default_methods
 344   // offset matches _default_methods offset
 345   Array&lt;int&gt;*     _default_vtable_indices;
 346 
 347   // Instance and static variable information, starts with 6-tuples of shorts
 348   // [access, name index, sig index, initval index, low_offset, high_offset]
 349   // for all fields, followed by the generic signature data at the end of
 350   // the array. Only fields with generic signature attributes have the generic
 351   // signature data set in the array. The fields array looks like following:
 352   //
 353   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 354   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 355   //      ...
 356   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 357   //     [generic signature index]
 358   //     [generic signature index]
 359   //     ...
 360   Array&lt;u2&gt;*      _fields;
<span class="line-modified"> 361   const Klass**   _value_field_klasses; // For &quot;inline class&quot; fields, NULL if none present</span>
 362 
 363   const ValueKlassFixedBlock* _adr_valueklass_fixed_block;
 364 
 365   // embedded Java vtable follows here
 366   // embedded Java itables follows here
 367   // embedded static fields follows here
 368   // embedded nonstatic oop-map blocks follows here
 369   // embedded implementor of this interface follows here
 370   //   The embedded implementor only exists if the current klass is an
 371   //   iterface. The possible values of the implementor fall into following
 372   //   three cases:
 373   //     NULL: no implementor.
 374   //     A Klass* that&#39;s not itself: one implementor.
 375   //     Itself: more than one implementors.
 376   // embedded unsafe_anonymous_host klass follows here
 377   //   The embedded host klass only exists in an unsafe anonymous class for
 378   //   dynamic language support (JSR 292 enabled). The host class grants
 379   //   its access privileges to this class also. The host class is either
 380   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 381   //   or an anonymous class loaded through normal classloading does not
</pre>
<hr />
<pre>
 404 
 405   void clear_shared_class_loader_type() {
 406     _misc_flags &amp;= ~shared_loader_type_bits();
 407   }
 408 
 409   void set_shared_class_loader_type(s2 loader_type);
 410 
 411   void assign_class_loader_type();
 412 
 413   bool has_nonstatic_fields() const        {
 414     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 415   }
 416   void set_has_nonstatic_fields(bool b)    {
 417     if (b) {
 418       _misc_flags |= _misc_has_nonstatic_fields;
 419     } else {
 420       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 421     }
 422   }
 423 
<span class="line-modified"> 424   bool has_inline_fields() const          {</span>
<span class="line-modified"> 425     return (_misc_flags &amp; _misc_has_inline_fields) != 0;</span>
 426   }
<span class="line-modified"> 427   void set_has_inline_fields()  {</span>
<span class="line-modified"> 428     _misc_flags |= _misc_has_inline_fields;</span>
 429   }
 430 
 431   bool is_empty_inline_type() const {
 432     return (_misc_flags &amp; _misc_is_empty_inline_type) != 0;
 433   }
 434   void set_is_empty_inline_type() {
 435     _misc_flags |= _misc_is_empty_inline_type;
 436   }
 437 
 438   // Note:  The naturally_atomic property only applies to
 439   // inline classes; it is never true on identity classes.
 440   // The bit is placed on instanceKlass for convenience.
 441 
 442   // Query if h/w provides atomic load/store for instances.
 443   bool is_naturally_atomic() const {
 444     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;
 445   }
 446   // Initialized in the class file parser, not changed later.
 447   void set_is_naturally_atomic() {
 448     _misc_flags |= _misc_is_naturally_atomic;
</pre>
<hr />
<pre>
1123 
1124   // On-stack replacement support
1125   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
1126   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
1127   void add_osr_nmethod(nmethod* n);
1128   bool remove_osr_nmethod(nmethod* n);
1129   int mark_osr_nmethods(const Method* m);
1130   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
1131 
1132 #if INCLUDE_JVMTI
1133   // Breakpoint support (see methods on Method* for details)
1134   BreakpointInfo* breakpoints() const       { return _breakpoints; };
1135   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
1136 #endif
1137 
1138   // support for stub routines
1139   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
1140   JFR_ONLY(DEFINE_KLASS_TRACE_ID_OFFSET;)
1141   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
1142 
<span class="line-modified">1143   static ByteSize value_field_klasses_offset() { return in_ByteSize(offset_of(InstanceKlass, _value_field_klasses)); }</span>
1144   static ByteSize adr_valueklass_fixed_block_offset() { return in_ByteSize(offset_of(InstanceKlass, _adr_valueklass_fixed_block)); }
1145 
1146   // subclass/subinterface checks
1147   bool implements_interface(Klass* k) const;
1148   bool is_same_or_direct_interface(Klass* k) const;
1149 
1150 #ifdef ASSERT
1151   // check whether this class or one of its superclasses was redefined
1152   bool has_redefined_this_or_super() const;
1153 #endif
1154 
1155   // Access to the implementor of an interface.
1156   Klass* implementor() const;
1157   void set_implementor(Klass* k);
1158   int  nof_implementors() const;
1159   void add_implementor(Klass* k);  // k is a new class that implements this interface
1160   void init_implementor();           // initialize
1161 
1162   // link this class into the implementors list of every interface it implements
1163   void process_interfaces(Thread *thread);
</pre>
<hr />
<pre>
1200   static int size(int vtable_length, int itable_length,
1201                   int nonstatic_oop_map_size,
1202                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint,
1203                   int java_fields, bool is_inline_type) {
1204     return align_metadata_size(header_size() +
1205            vtable_length +
1206            itable_length +
1207            nonstatic_oop_map_size +
1208            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1209            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
1210            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0) +
1211            (java_fields * (int)sizeof(Klass*)/wordSize) +
1212            (is_inline_type ? (int)sizeof(ValueKlassFixedBlock) : 0));
1213   }
1214   int size() const                    { return size(vtable_length(),
1215                                                itable_length(),
1216                                                nonstatic_oop_map_size(),
1217                                                is_interface(),
1218                                                is_unsafe_anonymous(),
1219                                                has_stored_fingerprint(),
<span class="line-modified">1220                                                has_inline_fields() ? java_fields_count() : 0,</span>
1221                                                is_inline_klass());
1222   }
1223 
1224   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1225   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1226 
1227   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1228 
1229   oop static_field_base_raw() { return java_mirror(); }
1230 
1231   bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;
1232 
1233   OopMapBlock* start_of_nonstatic_oop_maps() const {
1234     return (OopMapBlock*)(start_of_itable() + itable_length());
1235   }
1236 
1237   Klass** end_of_nonstatic_oop_maps() const {
1238     return (Klass**)(start_of_nonstatic_oop_maps() +
1239                      nonstatic_oop_map_count());
1240   }
</pre>
<hr />
<pre>
1261   }
1262 
1263   address adr_fingerprint() const {
1264     if (has_stored_fingerprint()) {
1265       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1266       if (adr_host != NULL) {
1267         return (address)(adr_host + 1);
1268       }
1269 
1270       Klass* volatile* adr_impl = adr_implementor();
1271       if (adr_impl != NULL) {
1272         return (address)(adr_impl + 1);
1273       }
1274 
1275       return (address)end_of_nonstatic_oop_maps();
1276     } else {
1277       return NULL;
1278     }
1279   }
1280 
<span class="line-modified">1281   address adr_value_fields_klasses() const {</span>
<span class="line-modified">1282     if (has_inline_fields()) {</span>
1283       address adr_fing = adr_fingerprint();
1284       if (adr_fing != NULL) {
1285         return adr_fingerprint() + sizeof(u8);
1286       }
1287 
1288       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1289       if (adr_host != NULL) {
1290         return (address)(adr_host + 1);
1291       }
1292 
1293       Klass* volatile* adr_impl = adr_implementor();
1294       if (adr_impl != NULL) {
1295         return (address)(adr_impl + 1);
1296       }
1297 
1298       return (address)end_of_nonstatic_oop_maps();
1299     } else {
1300       return NULL;
1301     }
1302   }
1303 
<span class="line-modified">1304   Klass* get_value_field_klass(int idx) const {</span>
<span class="line-modified">1305     assert(has_inline_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-modified">1306     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];</span>

1307     assert(k != NULL, &quot;Should always be set before being read&quot;);
1308     assert(k-&gt;is_inline_klass(), &quot;Must be a inline type&quot;);
1309     return k;
1310   }
1311 
<span class="line-modified">1312   Klass* get_value_field_klass_or_null(int idx) const {</span>
<span class="line-modified">1313     assert(has_inline_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-modified">1314     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];</span>

1315     assert(k == NULL || k-&gt;is_inline_klass(), &quot;Must be a inline type&quot;);
1316     return k;
1317   }
1318 
<span class="line-modified">1319   void set_value_field_klass(int idx, Klass* k) {</span>
<span class="line-modified">1320     assert(has_inline_fields(), &quot;Sanity checking&quot;);</span>

1321     assert(k != NULL, &quot;Should not be set to NULL&quot;);
<span class="line-modified">1322     assert(((Klass**)adr_value_fields_klasses())[idx] == NULL, &quot;Should not be set twice&quot;);</span>
<span class="line-modified">1323     ((Klass**)adr_value_fields_klasses())[idx] = k;</span>






1324   }
1325 
1326   // Use this to return the size of an instance in heap words:
1327   virtual int size_helper() const {
1328     return layout_helper_to_size_helper(layout_helper());
1329   }
1330 
1331   // This bit is initialized in classFileParser.cpp.
1332   // It is false under any of the following conditions:
1333   //  - the class is abstract (including any interface)
1334   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1335   //  - the class size is larger than FastAllocateSizeLimit
1336   //  - the class is java/lang/Class, which cannot be allocated directly
1337   bool can_be_fastpath_allocated() const {
1338     return !layout_helper_needs_slow_path(layout_helper());
1339   }
1340 
1341   // Java itable
1342   klassItable itable() const;        // return klassItable wrapper
1343   Method* method_at_itable(Klass* holder, int index, TRAPS);
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;utilities/accessFlags.hpp&quot;
  39 #include &quot;utilities/align.hpp&quot;
  40 #include &quot;utilities/macros.hpp&quot;
  41 #if INCLUDE_JFR
  42 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  43 #endif
  44 
  45 class RecordComponent;
  46 
  47 // An InstanceKlass is the VM level representation of a Java class.
  48 // It contains all information needed for at class at execution runtime.
  49 
  50 //  InstanceKlass embedded field layout (after declared fields):
  51 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  52 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  53 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  54 //      indicating where oops are located in instances of this klass.
  55 //    [EMBEDDED implementor of the interface] only exist for interface
  56 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  57 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
<span class="line-added">  58 //    [EMBEDDED inline_type_field_klasses] only if has_inline_fields() == true</span>
  59 //    [EMBEDDED ValueKlassFixedBlock] only if is a ValueKlass instance
  60 
  61 
  62 // forward declaration for class -- see below for definition
  63 #if INCLUDE_JVMTI
  64 class BreakpointInfo;
  65 #endif
  66 class ClassFileParser;
  67 class ClassFileStream;
  68 class KlassDepChange;
  69 class DependencyContext;
  70 class fieldDescriptor;
  71 class jniIdMapBase;
  72 class JNIid;
  73 class JvmtiCachedClassFieldMap;
  74 class nmethodBucket;
  75 class OopMapCache;
  76 class BufferedValueTypeBlob;
  77 class InterpreterOopMap;
  78 class PackageEntry;
</pre>
<hr />
<pre>
 209   // attribute. If the EnclosingMethod attribute exists, it occupies the
 210   // last two shorts [class_index, method_index] of the array. If only
 211   // the InnerClasses attribute exists, the _inner_classes array length is
 212   // number_of_inner_classes * 4. If the class has both InnerClasses
 213   // and EnclosingMethod attributes the _inner_classes array length is
 214   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 215   Array&lt;jushort&gt;* _inner_classes;
 216 
 217   // The NestMembers attribute. An array of shorts, where each is a
 218   // class info index for the class that is a nest member. This data
 219   // has not been validated.
 220   Array&lt;jushort&gt;* _nest_members;
 221 
 222   // Resolved nest-host klass: either true nest-host or self if we are not
 223   // nested, or an error occurred resolving or validating the nominated
 224   // nest-host. Can also be set directly by JDK API&#39;s that establish nest
 225   // relationships.
 226   // By always being set it makes nest-member access checks simpler.
 227   InstanceKlass* _nest_host;
 228 


 229   // The PermittedSubclasses attribute. An array of shorts, where each is a
 230   // class info index for the class that is a permitted subclass.
 231   Array&lt;jushort&gt;* _permitted_subclasses;
 232 
 233   // The contents of the Record attribute.
 234   Array&lt;RecordComponent*&gt;* _record_components;
 235 
 236   // the source debug extension for this klass, NULL if not specified.
 237   // Specified as UTF-8 string without terminating zero byte in the classfile,
 238   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 239   const char*     _source_debug_extension;
 240 
 241   // Number of heapOopSize words used by non-static fields in this klass
 242   // (including inherited fields but after header_size()).
 243   int             _nonstatic_field_size;
 244   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 245 
 246   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 247   int             _itable_len;           // length of Java itable (in words)
 248 
</pre>
<hr />
<pre>
 277   u1              _kind;                          // kind of InstanceKlass
 278 
 279   enum {
 280     _misc_rewritten                           = 1 &lt;&lt; 0,  // methods rewritten.
 281     _misc_has_nonstatic_fields                = 1 &lt;&lt; 1,  // for sizing with UseCompressedOops
 282     _misc_should_verify_class                 = 1 &lt;&lt; 2,  // allow caching of preverification
 283     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 3,  // has embedded _unsafe_anonymous_host field
 284     _misc_is_contended                        = 1 &lt;&lt; 4,  // marked with contended annotation
 285     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 5,  // class/superclass/implemented interfaces has non-static, concrete methods
 286     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 6,  // directly declares non-static, concrete methods
 287     _misc_has_been_redefined                  = 1 &lt;&lt; 7,  // class has been redefined
 288     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 8,  // when this class was loaded, the fingerprint computed from its
 289                                                          // code source was found to be matching the value recorded by AOT.
 290     _misc_is_scratch_class                    = 1 &lt;&lt; 9,  // class is the redefined scratch class
 291     _misc_is_shared_boot_class                = 1 &lt;&lt; 10, // defining class loader is boot class loader
 292     _misc_is_shared_platform_class            = 1 &lt;&lt; 11, // defining class loader is platform class loader
 293     _misc_is_shared_app_class                 = 1 &lt;&lt; 12, // defining class loader is app class loader
 294     _misc_has_resolved_methods                = 1 &lt;&lt; 13, // resolved methods table entries added for this class
 295     _misc_is_being_redefined                  = 1 &lt;&lt; 14, // used for locking redefinition
 296     _misc_has_contended_annotations           = 1 &lt;&lt; 15,  // has @Contended annotation
<span class="line-modified"> 297     _misc_has_inline_type_fields              = 1 &lt;&lt; 16, // has inline fields and related embedded section is not empty</span>
 298     _misc_is_empty_inline_type                = 1 &lt;&lt; 17, // empty inline type
 299     _misc_is_naturally_atomic                 = 1 &lt;&lt; 18, // loaded/stored in one instruction
 300     _misc_is_declared_atomic                  = 1 &lt;&lt; 19, // implements jl.NonTearable
 301     _misc_invalid_inline_super                = 1 &lt;&lt; 20, // invalid super type for an inline type
 302     _misc_invalid_identity_super              = 1 &lt;&lt; 21, // invalid super type for an identity type
 303     _misc_has_injected_identityObject         = 1 &lt;&lt; 22  // IdentityObject has been injected by the JVM
 304   };
 305   u2 shared_loader_type_bits() const {
 306     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 307   }
 308   u4              _misc_flags;           // There is more space in access_flags for more flags.
 309 
 310   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 311   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 312   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 313   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 314   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 315   uint64_t        volatile _dep_context_last_cleaned;
 316   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 317 #if INCLUDE_JVMTI
</pre>
<hr />
<pre>
 340   // Int array containing the original order of method in the class file (for JVMTI).
 341   Array&lt;int&gt;*     _method_ordering;
 342   // Int array containing the vtable_indices for default_methods
 343   // offset matches _default_methods offset
 344   Array&lt;int&gt;*     _default_vtable_indices;
 345 
 346   // Instance and static variable information, starts with 6-tuples of shorts
 347   // [access, name index, sig index, initval index, low_offset, high_offset]
 348   // for all fields, followed by the generic signature data at the end of
 349   // the array. Only fields with generic signature attributes have the generic
 350   // signature data set in the array. The fields array looks like following:
 351   //
 352   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 353   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 354   //      ...
 355   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 356   //     [generic signature index]
 357   //     [generic signature index]
 358   //     ...
 359   Array&lt;u2&gt;*      _fields;
<span class="line-modified"> 360   const Klass**   _inline_type_field_klasses; // For &quot;inline class&quot; fields, NULL if none present</span>
 361 
 362   const ValueKlassFixedBlock* _adr_valueklass_fixed_block;
 363 
 364   // embedded Java vtable follows here
 365   // embedded Java itables follows here
 366   // embedded static fields follows here
 367   // embedded nonstatic oop-map blocks follows here
 368   // embedded implementor of this interface follows here
 369   //   The embedded implementor only exists if the current klass is an
 370   //   iterface. The possible values of the implementor fall into following
 371   //   three cases:
 372   //     NULL: no implementor.
 373   //     A Klass* that&#39;s not itself: one implementor.
 374   //     Itself: more than one implementors.
 375   // embedded unsafe_anonymous_host klass follows here
 376   //   The embedded host klass only exists in an unsafe anonymous class for
 377   //   dynamic language support (JSR 292 enabled). The host class grants
 378   //   its access privileges to this class also. The host class is either
 379   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 380   //   or an anonymous class loaded through normal classloading does not
</pre>
<hr />
<pre>
 403 
 404   void clear_shared_class_loader_type() {
 405     _misc_flags &amp;= ~shared_loader_type_bits();
 406   }
 407 
 408   void set_shared_class_loader_type(s2 loader_type);
 409 
 410   void assign_class_loader_type();
 411 
 412   bool has_nonstatic_fields() const        {
 413     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 414   }
 415   void set_has_nonstatic_fields(bool b)    {
 416     if (b) {
 417       _misc_flags |= _misc_has_nonstatic_fields;
 418     } else {
 419       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 420     }
 421   }
 422 
<span class="line-modified"> 423   bool has_inline_type_fields() const          {</span>
<span class="line-modified"> 424     return (_misc_flags &amp; _misc_has_inline_type_fields) != 0;</span>
 425   }
<span class="line-modified"> 426   void set_has_inline_type_fields()  {</span>
<span class="line-modified"> 427     _misc_flags |= _misc_has_inline_type_fields;</span>
 428   }
 429 
 430   bool is_empty_inline_type() const {
 431     return (_misc_flags &amp; _misc_is_empty_inline_type) != 0;
 432   }
 433   void set_is_empty_inline_type() {
 434     _misc_flags |= _misc_is_empty_inline_type;
 435   }
 436 
 437   // Note:  The naturally_atomic property only applies to
 438   // inline classes; it is never true on identity classes.
 439   // The bit is placed on instanceKlass for convenience.
 440 
 441   // Query if h/w provides atomic load/store for instances.
 442   bool is_naturally_atomic() const {
 443     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;
 444   }
 445   // Initialized in the class file parser, not changed later.
 446   void set_is_naturally_atomic() {
 447     _misc_flags |= _misc_is_naturally_atomic;
</pre>
<hr />
<pre>
1122 
1123   // On-stack replacement support
1124   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
1125   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
1126   void add_osr_nmethod(nmethod* n);
1127   bool remove_osr_nmethod(nmethod* n);
1128   int mark_osr_nmethods(const Method* m);
1129   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
1130 
1131 #if INCLUDE_JVMTI
1132   // Breakpoint support (see methods on Method* for details)
1133   BreakpointInfo* breakpoints() const       { return _breakpoints; };
1134   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
1135 #endif
1136 
1137   // support for stub routines
1138   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
1139   JFR_ONLY(DEFINE_KLASS_TRACE_ID_OFFSET;)
1140   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
1141 
<span class="line-modified">1142   static ByteSize inline_type_field_klasses_offset() { return in_ByteSize(offset_of(InstanceKlass, _inline_type_field_klasses)); }</span>
1143   static ByteSize adr_valueklass_fixed_block_offset() { return in_ByteSize(offset_of(InstanceKlass, _adr_valueklass_fixed_block)); }
1144 
1145   // subclass/subinterface checks
1146   bool implements_interface(Klass* k) const;
1147   bool is_same_or_direct_interface(Klass* k) const;
1148 
1149 #ifdef ASSERT
1150   // check whether this class or one of its superclasses was redefined
1151   bool has_redefined_this_or_super() const;
1152 #endif
1153 
1154   // Access to the implementor of an interface.
1155   Klass* implementor() const;
1156   void set_implementor(Klass* k);
1157   int  nof_implementors() const;
1158   void add_implementor(Klass* k);  // k is a new class that implements this interface
1159   void init_implementor();           // initialize
1160 
1161   // link this class into the implementors list of every interface it implements
1162   void process_interfaces(Thread *thread);
</pre>
<hr />
<pre>
1199   static int size(int vtable_length, int itable_length,
1200                   int nonstatic_oop_map_size,
1201                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint,
1202                   int java_fields, bool is_inline_type) {
1203     return align_metadata_size(header_size() +
1204            vtable_length +
1205            itable_length +
1206            nonstatic_oop_map_size +
1207            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1208            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
1209            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0) +
1210            (java_fields * (int)sizeof(Klass*)/wordSize) +
1211            (is_inline_type ? (int)sizeof(ValueKlassFixedBlock) : 0));
1212   }
1213   int size() const                    { return size(vtable_length(),
1214                                                itable_length(),
1215                                                nonstatic_oop_map_size(),
1216                                                is_interface(),
1217                                                is_unsafe_anonymous(),
1218                                                has_stored_fingerprint(),
<span class="line-modified">1219                                                has_inline_type_fields() ? java_fields_count() : 0,</span>
1220                                                is_inline_klass());
1221   }
1222 
1223   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1224   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1225 
1226   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1227 
1228   oop static_field_base_raw() { return java_mirror(); }
1229 
1230   bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;
1231 
1232   OopMapBlock* start_of_nonstatic_oop_maps() const {
1233     return (OopMapBlock*)(start_of_itable() + itable_length());
1234   }
1235 
1236   Klass** end_of_nonstatic_oop_maps() const {
1237     return (Klass**)(start_of_nonstatic_oop_maps() +
1238                      nonstatic_oop_map_count());
1239   }
</pre>
<hr />
<pre>
1260   }
1261 
1262   address adr_fingerprint() const {
1263     if (has_stored_fingerprint()) {
1264       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1265       if (adr_host != NULL) {
1266         return (address)(adr_host + 1);
1267       }
1268 
1269       Klass* volatile* adr_impl = adr_implementor();
1270       if (adr_impl != NULL) {
1271         return (address)(adr_impl + 1);
1272       }
1273 
1274       return (address)end_of_nonstatic_oop_maps();
1275     } else {
1276       return NULL;
1277     }
1278   }
1279 
<span class="line-modified">1280   address adr_inline_type_field_klasses() const {</span>
<span class="line-modified">1281     if (has_inline_type_fields()) {</span>
1282       address adr_fing = adr_fingerprint();
1283       if (adr_fing != NULL) {
1284         return adr_fingerprint() + sizeof(u8);
1285       }
1286 
1287       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1288       if (adr_host != NULL) {
1289         return (address)(adr_host + 1);
1290       }
1291 
1292       Klass* volatile* adr_impl = adr_implementor();
1293       if (adr_impl != NULL) {
1294         return (address)(adr_impl + 1);
1295       }
1296 
1297       return (address)end_of_nonstatic_oop_maps();
1298     } else {
1299       return NULL;
1300     }
1301   }
1302 
<span class="line-modified">1303   Klass* get_inline_type_field_klass(int idx) const {</span>
<span class="line-modified">1304     assert(has_inline_type_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-modified">1305     assert(idx &lt; java_fields_count(), &quot;IOOB&quot;);</span>
<span class="line-added">1306     Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];</span>
1307     assert(k != NULL, &quot;Should always be set before being read&quot;);
1308     assert(k-&gt;is_inline_klass(), &quot;Must be a inline type&quot;);
1309     return k;
1310   }
1311 
<span class="line-modified">1312   Klass* get_inline_type_field_klass_or_null(int idx) const {</span>
<span class="line-modified">1313     assert(has_inline_type_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-modified">1314     assert(idx &lt; java_fields_count(), &quot;IOOB&quot;);</span>
<span class="line-added">1315     Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];</span>
1316     assert(k == NULL || k-&gt;is_inline_klass(), &quot;Must be a inline type&quot;);
1317     return k;
1318   }
1319 
<span class="line-modified">1320   void set_inline_type_field_klass(int idx, Klass* k) {</span>
<span class="line-modified">1321     assert(has_inline_type_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-added">1322     assert(idx &lt; java_fields_count(), &quot;IOOB&quot;);</span>
1323     assert(k != NULL, &quot;Should not be set to NULL&quot;);
<span class="line-modified">1324     assert(((Klass**)adr_inline_type_field_klasses())[idx] == NULL, &quot;Should not be set twice&quot;);</span>
<span class="line-modified">1325     ((Klass**)adr_inline_type_field_klasses())[idx] = k;</span>
<span class="line-added">1326   }</span>
<span class="line-added">1327 </span>
<span class="line-added">1328   void reset_inline_type_field_klass(int idx) {</span>
<span class="line-added">1329     assert(has_inline_type_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-added">1330     assert(idx &lt; java_fields_count(), &quot;IOOB&quot;);</span>
<span class="line-added">1331     ((Klass**)adr_inline_type_field_klasses())[idx] = NULL;</span>
1332   }
1333 
1334   // Use this to return the size of an instance in heap words:
1335   virtual int size_helper() const {
1336     return layout_helper_to_size_helper(layout_helper());
1337   }
1338 
1339   // This bit is initialized in classFileParser.cpp.
1340   // It is false under any of the following conditions:
1341   //  - the class is abstract (including any interface)
1342   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1343   //  - the class size is larger than FastAllocateSizeLimit
1344   //  - the class is java/lang/Class, which cannot be allocated directly
1345   bool can_be_fastpath_allocated() const {
1346     return !layout_helper_needs_slow_path(layout_helper());
1347   }
1348 
1349   // Java itable
1350   klassItable itable() const;        // return klassItable wrapper
1351   Method* method_at_itable(Klass* holder, int index, TRAPS);
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
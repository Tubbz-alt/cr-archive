<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/memnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jni.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/memnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1915     // For klass/static loads, we expect the _type to be precise
1916   } else if (tp-&gt;base() == Type::RawPtr &amp;&amp; !StressReflectiveCode) {
1917     if (adr-&gt;is_Load() &amp;&amp; off == 0) {
1918       /* With mirrors being an indirect in the Klass*
1919        * the VM is now using two loads. LoadKlass(LoadP(LoadP(Klass, mirror_offset), zero_offset))
1920        * The LoadP from the Klass has a RawPtr type (see LibraryCallKit::load_mirror_from_klass).
1921        *
1922        * So check the type and klass of the node before the LoadP.
1923        */
1924       Node* adr2 = adr-&gt;in(MemNode::Address);
1925       const TypeKlassPtr* tkls = phase-&gt;type(adr2)-&gt;isa_klassptr();
1926       if (tkls != NULL) {
1927         ciKlass* klass = tkls-&gt;klass();
1928         if (klass != NULL &amp;&amp; klass-&gt;is_loaded() &amp;&amp; tkls-&gt;klass_is_exact() &amp;&amp; tkls-&gt;offset() == in_bytes(Klass::java_mirror_offset())) {
1929           assert(adr-&gt;Opcode() == Op_LoadP, &quot;must load an oop from _java_mirror&quot;);
1930           assert(Opcode() == Op_LoadP, &quot;must load an oop from _java_mirror&quot;);
1931           return TypeInstPtr::make(klass-&gt;java_mirror());
1932         }
1933       }
1934     } else {
<span class="line-modified">1935       // Check for a load of the default value offset from the ValueKlassFixedBlock:</span>
<span class="line-modified">1936       // LoadI(LoadP(value_klass, adr_valueklass_fixed_block_offset), default_value_offset_offset)</span>
1937       intptr_t offset = 0;
1938       Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);
<span class="line-modified">1939       if (base != NULL &amp;&amp; base-&gt;is_Load() &amp;&amp; offset == in_bytes(ValueKlass::default_value_offset_offset())) {</span>
1940         const TypeKlassPtr* tkls = phase-&gt;type(base-&gt;in(MemNode::Address))-&gt;isa_klassptr();
1941         if (tkls != NULL &amp;&amp; tkls-&gt;is_loaded() &amp;&amp; tkls-&gt;klass_is_exact() &amp;&amp; tkls-&gt;isa_valuetype() &amp;&amp;
<span class="line-modified">1942             tkls-&gt;offset() == in_bytes(InstanceKlass::adr_valueklass_fixed_block_offset())) {</span>
1943           assert(base-&gt;Opcode() == Op_LoadP, &quot;must load an oop from klass&quot;);
1944           assert(Opcode() == Op_LoadI, &quot;must load an int from fixed block&quot;);
1945           return TypeInt::make(tkls-&gt;klass()-&gt;as_value_klass()-&gt;default_value_offset());
1946         }
1947       }
1948     }
1949   }
1950 
1951   const TypeKlassPtr *tkls = tp-&gt;isa_klassptr();
1952   if (tkls != NULL &amp;&amp; !StressReflectiveCode) {
1953     ciKlass* klass = tkls-&gt;klass();
1954     if (tkls-&gt;is_loaded() &amp;&amp; tkls-&gt;klass_is_exact()) {
1955       // We are loading a field from a Klass metaobject whose identity
1956       // is known at compile time (the type is &quot;exact&quot; or &quot;precise&quot;).
1957       // Check for fields we know are maintained as constants by the VM.
1958       if (tkls-&gt;offset() == in_bytes(Klass::super_check_offset_offset())) {
1959         // The field is Klass::_super_check_offset.  Return its (constant) value.
1960         // (Folds up type checking code.)
1961         assert(Opcode() == Op_LoadI, &quot;must load an int from _super_check_offset&quot;);
1962         return TypeInt::make(klass-&gt;super_check_offset());
</pre>
</td>
<td>
<hr />
<pre>
1915     // For klass/static loads, we expect the _type to be precise
1916   } else if (tp-&gt;base() == Type::RawPtr &amp;&amp; !StressReflectiveCode) {
1917     if (adr-&gt;is_Load() &amp;&amp; off == 0) {
1918       /* With mirrors being an indirect in the Klass*
1919        * the VM is now using two loads. LoadKlass(LoadP(LoadP(Klass, mirror_offset), zero_offset))
1920        * The LoadP from the Klass has a RawPtr type (see LibraryCallKit::load_mirror_from_klass).
1921        *
1922        * So check the type and klass of the node before the LoadP.
1923        */
1924       Node* adr2 = adr-&gt;in(MemNode::Address);
1925       const TypeKlassPtr* tkls = phase-&gt;type(adr2)-&gt;isa_klassptr();
1926       if (tkls != NULL) {
1927         ciKlass* klass = tkls-&gt;klass();
1928         if (klass != NULL &amp;&amp; klass-&gt;is_loaded() &amp;&amp; tkls-&gt;klass_is_exact() &amp;&amp; tkls-&gt;offset() == in_bytes(Klass::java_mirror_offset())) {
1929           assert(adr-&gt;Opcode() == Op_LoadP, &quot;must load an oop from _java_mirror&quot;);
1930           assert(Opcode() == Op_LoadP, &quot;must load an oop from _java_mirror&quot;);
1931           return TypeInstPtr::make(klass-&gt;java_mirror());
1932         }
1933       }
1934     } else {
<span class="line-modified">1935       // Check for a load of the default value offset from the InlineKlassFixedBlock:</span>
<span class="line-modified">1936       // LoadI(LoadP(value_klass, adr_inlineklass_fixed_block_offset), default_value_offset_offset)</span>
1937       intptr_t offset = 0;
1938       Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);
<span class="line-modified">1939       if (base != NULL &amp;&amp; base-&gt;is_Load() &amp;&amp; offset == in_bytes(InlineKlass::default_value_offset_offset())) {</span>
1940         const TypeKlassPtr* tkls = phase-&gt;type(base-&gt;in(MemNode::Address))-&gt;isa_klassptr();
1941         if (tkls != NULL &amp;&amp; tkls-&gt;is_loaded() &amp;&amp; tkls-&gt;klass_is_exact() &amp;&amp; tkls-&gt;isa_valuetype() &amp;&amp;
<span class="line-modified">1942             tkls-&gt;offset() == in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())) {</span>
1943           assert(base-&gt;Opcode() == Op_LoadP, &quot;must load an oop from klass&quot;);
1944           assert(Opcode() == Op_LoadI, &quot;must load an int from fixed block&quot;);
1945           return TypeInt::make(tkls-&gt;klass()-&gt;as_value_klass()-&gt;default_value_offset());
1946         }
1947       }
1948     }
1949   }
1950 
1951   const TypeKlassPtr *tkls = tp-&gt;isa_klassptr();
1952   if (tkls != NULL &amp;&amp; !StressReflectiveCode) {
1953     ciKlass* klass = tkls-&gt;klass();
1954     if (tkls-&gt;is_loaded() &amp;&amp; tkls-&gt;klass_is_exact()) {
1955       // We are loading a field from a Klass metaobject whose identity
1956       // is known at compile time (the type is &quot;exact&quot; or &quot;precise&quot;).
1957       // Check for fields we know are maintained as constants by the VM.
1958       if (tkls-&gt;offset() == in_bytes(Klass::super_check_offset_offset())) {
1959         // The field is Klass::_super_check_offset.  Return its (constant) value.
1960         // (Folds up type checking code.)
1961         assert(Opcode() == Op_LoadI, &quot;must load an int from _super_check_offset&quot;);
1962         return TypeInt::make(klass-&gt;super_check_offset());
</pre>
</td>
</tr>
</table>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jni.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
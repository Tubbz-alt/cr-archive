<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/valueArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oopsHierarchy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/valueArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/moduleEntry.hpp&quot;
 27 #include &quot;classfile/packageEntry.hpp&quot;
 28 #include &quot;classfile/symbolTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 32 #include &quot;memory/iterator.inline.hpp&quot;
 33 #include &quot;memory/metadataFactory.hpp&quot;
 34 #include &quot;memory/metaspaceClosure.hpp&quot;
 35 #include &quot;memory/oopFactory.hpp&quot;
 36 #include &quot;memory/resourceArea.hpp&quot;
 37 #include &quot;memory/universe.hpp&quot;
 38 #include &quot;oops/arrayKlass.inline.hpp&quot;
 39 #include &quot;oops/arrayOop.hpp&quot;
 40 #include &quot;oops/instanceKlass.hpp&quot;
 41 #include &quot;oops/klass.inline.hpp&quot;
 42 #include &quot;oops/objArrayKlass.hpp&quot;
 43 #include &quot;oops/objArrayOop.inline.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified"> 45 #include &quot;oops/valueKlass.hpp&quot;</span>
 46 #include &quot;oops/valueArrayOop.hpp&quot;
 47 #include &quot;oops/valueArrayOop.inline.hpp&quot;
 48 #include &quot;oops/verifyOopClosure.hpp&quot;
 49 #include &quot;runtime/handles.inline.hpp&quot;
 50 #include &quot;runtime/mutexLocker.hpp&quot;
 51 #include &quot;utilities/copy.hpp&quot;
 52 #include &quot;utilities/macros.hpp&quot;
 53 
 54 #include &quot;oops/valueArrayKlass.hpp&quot;
 55 
 56 // Allocation...
 57 
 58 ValueArrayKlass::ValueArrayKlass(Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
 59   assert(element_klass-&gt;is_inline_klass(), &quot;Expected Inline&quot;);
 60 
<span class="line-modified"> 61   set_element_klass(ValueKlass::cast(element_klass));</span>
 62   set_class_loader_data(element_klass-&gt;class_loader_data());
<span class="line-modified"> 63   set_layout_helper(array_layout_helper(ValueKlass::cast(element_klass)));</span>
 64 
 65   assert(is_array_klass(), &quot;sanity&quot;);
 66   assert(is_valueArray_klass(), &quot;sanity&quot;);
 67 
 68   CMH(&quot;tweak name symbol refcnt ?&quot;)
 69 #ifndef PRODUCT
 70   if (PrintInlineArrayLayout) {
 71     print();
 72   }
 73 #endif
 74 }
 75 
<span class="line-modified"> 76 ValueKlass* ValueArrayKlass::element_klass() const {</span>
<span class="line-modified"> 77   return ValueKlass::cast(_element_klass);</span>
 78 }
 79 
 80 void ValueArrayKlass::set_element_klass(Klass* k) {
 81   _element_klass = k;
 82 }
 83 
 84 ValueArrayKlass* ValueArrayKlass::allocate_klass(Klass* element_klass, TRAPS) {
 85   guarantee((!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()), &quot;Really ?!&quot;);
 86   assert(ValueArrayFlatten, &quot;Flatten array required&quot;);
<span class="line-modified"> 87   assert(ValueKlass::cast(element_klass)-&gt;is_naturally_atomic() || (!InlineArrayAtomicAccess), &quot;Atomic by-default&quot;);</span>
 88 
 89   /*
 90    *  MVT-&gt;LWorld, now need to allocate secondaries array types, just like objArrayKlass...
 91    *  ...so now we are trying out covariant array types, just copy objArrayKlass
 92    *  TODO refactor any remaining commonality
 93    *
 94    */
 95   // Eagerly allocate the direct array supertype.
 96   Klass* super_klass = NULL;
 97   Klass* element_super = element_klass-&gt;super();
 98   if (element_super != NULL) {
 99     // The element type has a direct super.  E.g., String[] has direct super of Object[].
100     super_klass = element_super-&gt;array_klass_or_null();
101     bool supers_exist = super_klass != NULL;
102     // Also, see if the element has secondary supertypes.
103     // We need an array type for each.
104     const Array&lt;Klass*&gt;* element_supers = element_klass-&gt;secondary_supers();
105     for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
106       Klass* elem_super = element_supers-&gt;at(i);
107       if (elem_super-&gt;array_klass_or_null() == NULL) {
</pre>
<hr />
<pre>
142 
143 void ValueArrayKlass::initialize(TRAPS) {
144   element_klass()-&gt;initialize(THREAD);
145 }
146 
147 // Oops allocation...
148 valueArrayOop ValueArrayKlass::allocate(int length, TRAPS) {
149   check_array_allocation_length(length, max_elements(), CHECK_NULL);
150   int size = valueArrayOopDesc::object_size(layout_helper(), length);
151   return (valueArrayOop) Universe::heap()-&gt;array_allocate(this, size, length, true, THREAD);
152 }
153 
154 
155 oop ValueArrayKlass::multi_allocate(int rank, jint* last_size, TRAPS) {
156   // For valueArrays this is only called for the last dimension
157   assert(rank == 1, &quot;just checking&quot;);
158   int length = *last_size;
159   return allocate(length, THREAD);
160 }
161 
<span class="line-modified">162 jint ValueArrayKlass::array_layout_helper(ValueKlass* vk) {</span>
163   BasicType etype = T_INLINE_TYPE;
164   int esize = upper_log2(vk-&gt;raw_value_byte_size());
165   int hsize = arrayOopDesc::base_offset_in_bytes(etype);
166 
167   int lh = Klass::array_layout_helper(_lh_array_tag_vt_value, true, hsize, etype, esize);
168 
169   assert(lh &lt; (int)_lh_neutral_value, &quot;must look like an array layout&quot;);
170   assert(layout_helper_is_array(lh), &quot;correct kind&quot;);
171   assert(layout_helper_is_valueArray(lh), &quot;correct kind&quot;);
172   assert(!layout_helper_is_typeArray(lh), &quot;correct kind&quot;);
173   assert(!layout_helper_is_objArray(lh), &quot;correct kind&quot;);
174   assert(layout_helper_is_null_free(lh), &quot;correct kind&quot;);
175   assert(layout_helper_header_size(lh) == hsize, &quot;correct decode&quot;);
176   assert(layout_helper_element_type(lh) == etype, &quot;correct decode&quot;);
177   assert(layout_helper_log2_element_size(lh) == esize, &quot;correct decode&quot;);
178   assert((1 &lt;&lt; esize) &lt; BytesPerLong || is_aligned(hsize, HeapWordsPerLong), &quot;unaligned base&quot;);
179 
180   return lh;
181 }
182 
</pre>
<hr />
<pre>
234      THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
235    }
236    // Check zero copy
237    if (length == 0)
238      return;
239 
240    ArrayKlass* sk = ArrayKlass::cast(s-&gt;klass());
241    ArrayKlass* dk = ArrayKlass::cast(d-&gt;klass());
242    Klass* d_elem_klass = dk-&gt;element_klass();
243    Klass* s_elem_klass = sk-&gt;element_klass();
244    /**** CMH: compare and contrast impl, re-factor once we find edge cases... ****/
245 
246    if (sk-&gt;is_valueArray_klass()) {
247      assert(sk == this, &quot;Unexpected call to copy_array&quot;);
248      // Check subtype, all src homogeneous, so just once
249      if (!s_elem_klass-&gt;is_subtype_of(d_elem_klass)) {
250        THROW(vmSymbols::java_lang_ArrayStoreException());
251      }
252 
253      valueArrayOop sa = valueArrayOop(s);
<span class="line-modified">254      ValueKlass* s_elem_vklass = element_klass();</span>
255 
256      // valueArray-to-valueArray
257      if (dk-&gt;is_valueArray_klass()) {
258        // element types MUST be exact, subtype check would be dangerous
259        if (dk != this) {
260          THROW(vmSymbols::java_lang_ArrayStoreException());
261        }
262 
263        valueArrayOop da = valueArrayOop(d);
264        address dst = (address) da-&gt;value_at_addr(dst_pos, layout_helper());
265        address src = (address) sa-&gt;value_at_addr(src_pos, layout_helper());
266        if (contains_oops()) {
267          int elem_incr = 1 &lt;&lt; log2_element_size();
268          address src_end = src + (length &lt;&lt; log2_element_size());
269          if (needs_backwards_copy(s, src_pos, d, dst_pos, length)) {
270            swap(src, src_end);
271            dst = dst + (length &lt;&lt; log2_element_size());
272            do {
273              src -= elem_incr;
274              dst -= elem_incr;
</pre>
<hr />
<pre>
288          Copy::conjoint_memory_atomic(src, dst, (size_t)length &lt;&lt; log2_element_size());
289        }
290      }
291      else { // valueArray-to-objArray
292        assert(dk-&gt;is_objArray_klass(), &quot;Expected objArray here&quot;);
293        // Need to allocate each new src elem payload -&gt; dst oop
294        objArrayHandle dh(THREAD, (objArrayOop)d);
295        valueArrayHandle sh(THREAD, sa);
296        int dst_end = dst_pos + length;
297        while (dst_pos &lt; dst_end) {
298          oop o = valueArrayOopDesc::value_alloc_copy_from_index(sh, src_pos, CHECK);
299          dh-&gt;obj_at_put(dst_pos, o);
300          dst_pos++;
301          src_pos++;
302        }
303      }
304    } else {
305      assert(s-&gt;is_objArray(), &quot;Expected objArray&quot;);
306      objArrayOop sa = objArrayOop(s);
307      assert(d-&gt;is_valueArray(), &quot;Excepted valueArray&quot;);  // objArray-to-valueArray
<span class="line-modified">308      ValueKlass* d_elem_vklass = ValueKlass::cast(d_elem_klass);</span>
309      valueArrayOop da = valueArrayOop(d);
310 
311      int src_end = src_pos + length;
312      int delem_incr = 1 &lt;&lt; dk-&gt;log2_element_size();
313      address dst = (address) da-&gt;value_at_addr(dst_pos, layout_helper());
314      while (src_pos &lt; src_end) {
315        oop se = sa-&gt;obj_at(src_pos);
316        if (se == NULL) {
317          THROW(vmSymbols::java_lang_NullPointerException());
318        }
319        // Check exact type per element
320        if (se-&gt;klass() != d_elem_klass) {
321          THROW(vmSymbols::java_lang_ArrayStoreException());
322        }
<span class="line-modified">323        d_elem_vklass-&gt;value_copy_oop_to_payload(se, dst);</span>
324        dst += delem_incr;
325        src_pos++;
326      }
327    }
328 }
329 
330 
331 Klass* ValueArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
332   assert(dimension() &lt;= n, &quot;check order of chain&quot;);
333   int dim = dimension();
334   if (dim == n) return this;
335 
336   if (higher_dimension_acquire() == NULL) {
337     if (or_null)  return NULL;
338 
339     ResourceMark rm;
340     {
341       // Ensure atomic creation of higher dimensions
342       MutexLocker mu(THREAD, MultiArray_lock);
343 
</pre>
<hr />
<pre>
423 
424   int elem_size = element_byte_size();
425   st-&gt;print(&quot; - element size %i &quot;, elem_size);
426   st-&gt;print(&quot;aligned layout size %i&quot;, 1 &lt;&lt; layout_helper_log2_element_size(layout_helper()));
427   st-&gt;cr();
428 #endif //PRODUCT
429 }
430 
431 void ValueArrayKlass::print_value_on(outputStream* st) const {
432   assert(is_klass(), &quot;must be klass&quot;);
433 
434   element_klass()-&gt;print_value_on(st);
435   st-&gt;print(&quot;[]&quot;);
436 }
437 
438 
439 #ifndef PRODUCT
440 void ValueArrayKlass::oop_print_on(oop obj, outputStream* st) {
441   ArrayKlass::oop_print_on(obj, st);
442   valueArrayOop va = valueArrayOop(obj);
<span class="line-modified">443   ValueKlass* vk = element_klass();</span>
444   int print_len = MIN2((intx) va-&gt;length(), MaxElementPrintSize);
445   for(int index = 0; index &lt; print_len; index++) {
446     int off = (address) va-&gt;value_at_addr(index, layout_helper()) - cast_from_oop&lt;address&gt;(obj);
447     st-&gt;print_cr(&quot; - Index %3d offset %3d: &quot;, index, off);
448     oop obj = (oop) ((address)va-&gt;value_at_addr(index, layout_helper()) - vk-&gt;first_field_offset());
449     FieldPrinter print_field(st, obj);
450     vk-&gt;do_nonstatic_fields(&amp;print_field);
451     st-&gt;cr();
452   }
453   int remaining = va-&gt;length() - print_len;
454   if (remaining &gt; 0) {
455     st-&gt;print_cr(&quot; - &lt;%d more elements, increase MaxElementPrintSize to print&gt;&quot;, remaining);
456   }
457 }
458 #endif //PRODUCT
459 
460 void ValueArrayKlass::oop_print_value_on(oop obj, outputStream* st) {
461   assert(obj-&gt;is_valueArray(), &quot;must be valueArray&quot;);
462   st-&gt;print(&quot;a &quot;);
463   element_klass()-&gt;print_value_on(st);
</pre>
</td>
<td>
<hr />
<pre>
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/moduleEntry.hpp&quot;
 27 #include &quot;classfile/packageEntry.hpp&quot;
 28 #include &quot;classfile/symbolTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 32 #include &quot;memory/iterator.inline.hpp&quot;
 33 #include &quot;memory/metadataFactory.hpp&quot;
 34 #include &quot;memory/metaspaceClosure.hpp&quot;
 35 #include &quot;memory/oopFactory.hpp&quot;
 36 #include &quot;memory/resourceArea.hpp&quot;
 37 #include &quot;memory/universe.hpp&quot;
 38 #include &quot;oops/arrayKlass.inline.hpp&quot;
 39 #include &quot;oops/arrayOop.hpp&quot;
 40 #include &quot;oops/instanceKlass.hpp&quot;
 41 #include &quot;oops/klass.inline.hpp&quot;
 42 #include &quot;oops/objArrayKlass.hpp&quot;
 43 #include &quot;oops/objArrayOop.inline.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified"> 45 #include &quot;oops/inlineKlass.hpp&quot;</span>
 46 #include &quot;oops/valueArrayOop.hpp&quot;
 47 #include &quot;oops/valueArrayOop.inline.hpp&quot;
 48 #include &quot;oops/verifyOopClosure.hpp&quot;
 49 #include &quot;runtime/handles.inline.hpp&quot;
 50 #include &quot;runtime/mutexLocker.hpp&quot;
 51 #include &quot;utilities/copy.hpp&quot;
 52 #include &quot;utilities/macros.hpp&quot;
 53 
 54 #include &quot;oops/valueArrayKlass.hpp&quot;
 55 
 56 // Allocation...
 57 
 58 ValueArrayKlass::ValueArrayKlass(Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
 59   assert(element_klass-&gt;is_inline_klass(), &quot;Expected Inline&quot;);
 60 
<span class="line-modified"> 61   set_element_klass(InlineKlass::cast(element_klass));</span>
 62   set_class_loader_data(element_klass-&gt;class_loader_data());
<span class="line-modified"> 63   set_layout_helper(array_layout_helper(InlineKlass::cast(element_klass)));</span>
 64 
 65   assert(is_array_klass(), &quot;sanity&quot;);
 66   assert(is_valueArray_klass(), &quot;sanity&quot;);
 67 
 68   CMH(&quot;tweak name symbol refcnt ?&quot;)
 69 #ifndef PRODUCT
 70   if (PrintInlineArrayLayout) {
 71     print();
 72   }
 73 #endif
 74 }
 75 
<span class="line-modified"> 76 InlineKlass* ValueArrayKlass::element_klass() const {</span>
<span class="line-modified"> 77   return InlineKlass::cast(_element_klass);</span>
 78 }
 79 
 80 void ValueArrayKlass::set_element_klass(Klass* k) {
 81   _element_klass = k;
 82 }
 83 
 84 ValueArrayKlass* ValueArrayKlass::allocate_klass(Klass* element_klass, TRAPS) {
 85   guarantee((!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()), &quot;Really ?!&quot;);
 86   assert(ValueArrayFlatten, &quot;Flatten array required&quot;);
<span class="line-modified"> 87   assert(InlineKlass::cast(element_klass)-&gt;is_naturally_atomic() || (!InlineArrayAtomicAccess), &quot;Atomic by-default&quot;);</span>
 88 
 89   /*
 90    *  MVT-&gt;LWorld, now need to allocate secondaries array types, just like objArrayKlass...
 91    *  ...so now we are trying out covariant array types, just copy objArrayKlass
 92    *  TODO refactor any remaining commonality
 93    *
 94    */
 95   // Eagerly allocate the direct array supertype.
 96   Klass* super_klass = NULL;
 97   Klass* element_super = element_klass-&gt;super();
 98   if (element_super != NULL) {
 99     // The element type has a direct super.  E.g., String[] has direct super of Object[].
100     super_klass = element_super-&gt;array_klass_or_null();
101     bool supers_exist = super_klass != NULL;
102     // Also, see if the element has secondary supertypes.
103     // We need an array type for each.
104     const Array&lt;Klass*&gt;* element_supers = element_klass-&gt;secondary_supers();
105     for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
106       Klass* elem_super = element_supers-&gt;at(i);
107       if (elem_super-&gt;array_klass_or_null() == NULL) {
</pre>
<hr />
<pre>
142 
143 void ValueArrayKlass::initialize(TRAPS) {
144   element_klass()-&gt;initialize(THREAD);
145 }
146 
147 // Oops allocation...
148 valueArrayOop ValueArrayKlass::allocate(int length, TRAPS) {
149   check_array_allocation_length(length, max_elements(), CHECK_NULL);
150   int size = valueArrayOopDesc::object_size(layout_helper(), length);
151   return (valueArrayOop) Universe::heap()-&gt;array_allocate(this, size, length, true, THREAD);
152 }
153 
154 
155 oop ValueArrayKlass::multi_allocate(int rank, jint* last_size, TRAPS) {
156   // For valueArrays this is only called for the last dimension
157   assert(rank == 1, &quot;just checking&quot;);
158   int length = *last_size;
159   return allocate(length, THREAD);
160 }
161 
<span class="line-modified">162 jint ValueArrayKlass::array_layout_helper(InlineKlass* vk) {</span>
163   BasicType etype = T_INLINE_TYPE;
164   int esize = upper_log2(vk-&gt;raw_value_byte_size());
165   int hsize = arrayOopDesc::base_offset_in_bytes(etype);
166 
167   int lh = Klass::array_layout_helper(_lh_array_tag_vt_value, true, hsize, etype, esize);
168 
169   assert(lh &lt; (int)_lh_neutral_value, &quot;must look like an array layout&quot;);
170   assert(layout_helper_is_array(lh), &quot;correct kind&quot;);
171   assert(layout_helper_is_valueArray(lh), &quot;correct kind&quot;);
172   assert(!layout_helper_is_typeArray(lh), &quot;correct kind&quot;);
173   assert(!layout_helper_is_objArray(lh), &quot;correct kind&quot;);
174   assert(layout_helper_is_null_free(lh), &quot;correct kind&quot;);
175   assert(layout_helper_header_size(lh) == hsize, &quot;correct decode&quot;);
176   assert(layout_helper_element_type(lh) == etype, &quot;correct decode&quot;);
177   assert(layout_helper_log2_element_size(lh) == esize, &quot;correct decode&quot;);
178   assert((1 &lt;&lt; esize) &lt; BytesPerLong || is_aligned(hsize, HeapWordsPerLong), &quot;unaligned base&quot;);
179 
180   return lh;
181 }
182 
</pre>
<hr />
<pre>
234      THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
235    }
236    // Check zero copy
237    if (length == 0)
238      return;
239 
240    ArrayKlass* sk = ArrayKlass::cast(s-&gt;klass());
241    ArrayKlass* dk = ArrayKlass::cast(d-&gt;klass());
242    Klass* d_elem_klass = dk-&gt;element_klass();
243    Klass* s_elem_klass = sk-&gt;element_klass();
244    /**** CMH: compare and contrast impl, re-factor once we find edge cases... ****/
245 
246    if (sk-&gt;is_valueArray_klass()) {
247      assert(sk == this, &quot;Unexpected call to copy_array&quot;);
248      // Check subtype, all src homogeneous, so just once
249      if (!s_elem_klass-&gt;is_subtype_of(d_elem_klass)) {
250        THROW(vmSymbols::java_lang_ArrayStoreException());
251      }
252 
253      valueArrayOop sa = valueArrayOop(s);
<span class="line-modified">254      InlineKlass* s_elem_vklass = element_klass();</span>
255 
256      // valueArray-to-valueArray
257      if (dk-&gt;is_valueArray_klass()) {
258        // element types MUST be exact, subtype check would be dangerous
259        if (dk != this) {
260          THROW(vmSymbols::java_lang_ArrayStoreException());
261        }
262 
263        valueArrayOop da = valueArrayOop(d);
264        address dst = (address) da-&gt;value_at_addr(dst_pos, layout_helper());
265        address src = (address) sa-&gt;value_at_addr(src_pos, layout_helper());
266        if (contains_oops()) {
267          int elem_incr = 1 &lt;&lt; log2_element_size();
268          address src_end = src + (length &lt;&lt; log2_element_size());
269          if (needs_backwards_copy(s, src_pos, d, dst_pos, length)) {
270            swap(src, src_end);
271            dst = dst + (length &lt;&lt; log2_element_size());
272            do {
273              src -= elem_incr;
274              dst -= elem_incr;
</pre>
<hr />
<pre>
288          Copy::conjoint_memory_atomic(src, dst, (size_t)length &lt;&lt; log2_element_size());
289        }
290      }
291      else { // valueArray-to-objArray
292        assert(dk-&gt;is_objArray_klass(), &quot;Expected objArray here&quot;);
293        // Need to allocate each new src elem payload -&gt; dst oop
294        objArrayHandle dh(THREAD, (objArrayOop)d);
295        valueArrayHandle sh(THREAD, sa);
296        int dst_end = dst_pos + length;
297        while (dst_pos &lt; dst_end) {
298          oop o = valueArrayOopDesc::value_alloc_copy_from_index(sh, src_pos, CHECK);
299          dh-&gt;obj_at_put(dst_pos, o);
300          dst_pos++;
301          src_pos++;
302        }
303      }
304    } else {
305      assert(s-&gt;is_objArray(), &quot;Expected objArray&quot;);
306      objArrayOop sa = objArrayOop(s);
307      assert(d-&gt;is_valueArray(), &quot;Excepted valueArray&quot;);  // objArray-to-valueArray
<span class="line-modified">308      InlineKlass* d_elem_vklass = InlineKlass::cast(d_elem_klass);</span>
309      valueArrayOop da = valueArrayOop(d);
310 
311      int src_end = src_pos + length;
312      int delem_incr = 1 &lt;&lt; dk-&gt;log2_element_size();
313      address dst = (address) da-&gt;value_at_addr(dst_pos, layout_helper());
314      while (src_pos &lt; src_end) {
315        oop se = sa-&gt;obj_at(src_pos);
316        if (se == NULL) {
317          THROW(vmSymbols::java_lang_NullPointerException());
318        }
319        // Check exact type per element
320        if (se-&gt;klass() != d_elem_klass) {
321          THROW(vmSymbols::java_lang_ArrayStoreException());
322        }
<span class="line-modified">323        d_elem_vklass-&gt;inline_copy_oop_to_payload(se, dst);</span>
324        dst += delem_incr;
325        src_pos++;
326      }
327    }
328 }
329 
330 
331 Klass* ValueArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
332   assert(dimension() &lt;= n, &quot;check order of chain&quot;);
333   int dim = dimension();
334   if (dim == n) return this;
335 
336   if (higher_dimension_acquire() == NULL) {
337     if (or_null)  return NULL;
338 
339     ResourceMark rm;
340     {
341       // Ensure atomic creation of higher dimensions
342       MutexLocker mu(THREAD, MultiArray_lock);
343 
</pre>
<hr />
<pre>
423 
424   int elem_size = element_byte_size();
425   st-&gt;print(&quot; - element size %i &quot;, elem_size);
426   st-&gt;print(&quot;aligned layout size %i&quot;, 1 &lt;&lt; layout_helper_log2_element_size(layout_helper()));
427   st-&gt;cr();
428 #endif //PRODUCT
429 }
430 
431 void ValueArrayKlass::print_value_on(outputStream* st) const {
432   assert(is_klass(), &quot;must be klass&quot;);
433 
434   element_klass()-&gt;print_value_on(st);
435   st-&gt;print(&quot;[]&quot;);
436 }
437 
438 
439 #ifndef PRODUCT
440 void ValueArrayKlass::oop_print_on(oop obj, outputStream* st) {
441   ArrayKlass::oop_print_on(obj, st);
442   valueArrayOop va = valueArrayOop(obj);
<span class="line-modified">443   InlineKlass* vk = element_klass();</span>
444   int print_len = MIN2((intx) va-&gt;length(), MaxElementPrintSize);
445   for(int index = 0; index &lt; print_len; index++) {
446     int off = (address) va-&gt;value_at_addr(index, layout_helper()) - cast_from_oop&lt;address&gt;(obj);
447     st-&gt;print_cr(&quot; - Index %3d offset %3d: &quot;, index, off);
448     oop obj = (oop) ((address)va-&gt;value_at_addr(index, layout_helper()) - vk-&gt;first_field_offset());
449     FieldPrinter print_field(st, obj);
450     vk-&gt;do_nonstatic_fields(&amp;print_field);
451     st-&gt;cr();
452   }
453   int remaining = va-&gt;length() - print_len;
454   if (remaining &gt; 0) {
455     st-&gt;print_cr(&quot; - &lt;%d more elements, increase MaxElementPrintSize to print&gt;&quot;, remaining);
456   }
457 }
458 #endif //PRODUCT
459 
460 void ValueArrayKlass::oop_print_value_on(oop obj, outputStream* st) {
461   assert(obj-&gt;is_valueArray(), &quot;must be valueArray&quot;);
462   st-&gt;print(&quot;a &quot;);
463   element_klass()-&gt;print_value_on(st);
</pre>
</td>
</tr>
</table>
<center><a href="oopsHierarchy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
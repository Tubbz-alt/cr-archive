<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/code/Flags.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.code;
 27 
 28 import java.util.Collections;
 29 import java.util.EnumSet;
 30 import java.util.Map;
 31 import java.util.Set;
 32 import java.util.concurrent.ConcurrentHashMap;
 33 
 34 import javax.lang.model.element.Modifier;
 35 
 36 import com.sun.tools.javac.util.Assert;
 37 import com.sun.tools.javac.util.StringUtils;
 38 
 39 /** Access flags and other modifiers for Java classes and members.
 40  *
 41  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 42  *  If you write code that depends on this, you do so at your own risk.
 43  *  This code and its internal interfaces are subject to change or
 44  *  deletion without notice.&lt;/b&gt;
 45  */
 46 public class Flags {
 47 
 48     private Flags() {} // uninstantiable
 49 
 50     public static String toString(long flags) {
 51         StringBuilder buf = new StringBuilder();
 52         String sep = &quot;&quot;;
 53         for (Flag flag : asFlagSet(flags)) {
 54             buf.append(sep);
 55             buf.append(flag);
 56             sep = &quot; &quot;;
 57         }
 58         return buf.toString();
 59     }
 60 
 61     public static EnumSet&lt;Flag&gt; asFlagSet(long flags) {
 62         EnumSet&lt;Flag&gt; flagSet = EnumSet.noneOf(Flag.class);
 63         for (Flag flag : Flag.values()) {
 64             if ((flags &amp; flag.value) != 0) {
 65                 flagSet.add(flag);
 66                 flags &amp;= ~flag.value;
 67             }
 68         }
 69         Assert.check(flags == 0);
 70         return flagSet;
 71     }
 72 
 73     /* Standard Java flags.
 74      */
 75     public static final int PUBLIC       = 1;
 76     public static final int PRIVATE      = 1&lt;&lt;1;
 77     public static final int PROTECTED    = 1&lt;&lt;2;
 78     public static final int STATIC       = 1&lt;&lt;3;
 79     public static final int FINAL        = 1&lt;&lt;4;
 80     public static final int SYNCHRONIZED = 1&lt;&lt;5;
 81     public static final int VOLATILE     = 1&lt;&lt;6;
 82     public static final int TRANSIENT    = 1&lt;&lt;7;
 83     public static final int NATIVE       = 1&lt;&lt;8;
 84     public static final int INTERFACE    = 1&lt;&lt;9;
 85     public static final int ABSTRACT     = 1&lt;&lt;10;
 86     public static final int STRICTFP     = 1&lt;&lt;11;
 87 
 88     /* Flag that marks a symbol synthetic, added in classfile v49.0. */
 89     public static final int SYNTHETIC    = 1&lt;&lt;12;
 90 
 91     /** Flag that marks attribute interfaces, added in classfile v49.0. */
 92     public static final int ANNOTATION   = 1&lt;&lt;13;
 93 
 94     /** An enumeration type or an enumeration constant, added in
 95      *  classfile v49.0. */
 96     public static final int ENUM         = 1&lt;&lt;14;
 97 
 98     /** Added in SE8, represents constructs implicitly declared in source. */
 99     public static final int MANDATED     = 1&lt;&lt;15;
100 
101     /** Marks a type as a value-type */
102     public static final int VALUE        = 1&lt;&lt;16;
103 
104     public static final int StandardFlags = 0x0fff;
105 
106     // Because the following access flags are overloaded with other
107     // bit positions, we translate them when reading and writing class
108     // files into unique bits positions: ACC_SYNTHETIC &lt;-&gt; SYNTHETIC,
109     // for example.
110     public static final int ACC_SUPER    = 0x0020;
111     public static final int ACC_BRIDGE   = 0x0040;
112     public static final int ACC_VARARGS  = 0x0080;
113     public static final int ACC_VALUE    = 0x0100;
114     public static final int ACC_MODULE   = 0x8000;
115 
116     /*****************************************
117      * Internal compiler flags (no bits in the lower 16).
118      *****************************************/
119 
120     /** Flag is set if symbol is deprecated.  See also DEPRECATED_REMOVAL.
121      */
122     public static final int DEPRECATED   = 1&lt;&lt;17;
123 
124     /** Flag is set for a variable symbol if the variable&#39;s definition
125      *  has an initializer part.
126      */
127     public static final int HASINIT          = 1&lt;&lt;18;
128 
129     /** Flag is set for a value based class.
130      */
131     public static final int VALUEBASED       = 1&lt;&lt;19;
132 
133     /** Flag is set for compiler-generated anonymous method symbols
134      *  that `own&#39; an initializer block.
135      */
136     public static final int BLOCK            = 1&lt;&lt;20;
137 
138     /** Flag bit 21 is available. (used earlier to tag compiler-generated abstract methods that implement
139      *  an interface method (Miranda methods)).
140      */
141 
142     /** Flag is set for nested classes that do not access instance members
143      *  or `this&#39; of an outer class and therefore don&#39;t need to be passed
144      *  a this$n reference.  This value is currently set only for anonymous
145      *  classes in superclass constructor calls.
146      *  todo: use this value for optimizing away this$n parameters in
147      *  other cases.
148      */
149     public static final int NOOUTERTHIS  = 1&lt;&lt;22;
150 
151     /** Flag is set for package symbols if a package has a member or
152      *  directory and therefore exists.
153      */
154     public static final int EXISTS           = 1&lt;&lt;23;
155 
156     /** Flag is set for compiler-generated compound classes
157      *  representing multiple variable bounds
158      */
159     public static final int COMPOUND     = 1&lt;&lt;24;
160 
161     /** Flag is set for class symbols if a class file was found for this class.
162      */
163     public static final int CLASS_SEEN   = 1&lt;&lt;25;
164 
165     /** Flag is set for class symbols if a source file was found for this
166      *  class.
167      */
168     public static final int SOURCE_SEEN  = 1&lt;&lt;26;
169 
170     /* State flags (are reset during compilation).
171      */
172 
173     /** Flag for class symbols is set and later re-set as a lock in
174      *  Enter to detect cycles in the superclass/superinterface
175      *  relations.  Similarly for constructor call cycle detection in
176      *  Attr.
177      */
178     public static final int LOCKED           = 1&lt;&lt;27;
179 
180     /** Flag for class symbols is set and later re-set to indicate that a class
181      *  has been entered but has not yet been attributed.
182      */
183     public static final int UNATTRIBUTED = 1&lt;&lt;28;
184 
185     /** Flag for synthesized default constructors of anonymous classes.
186      */
187     public static final int ANONCONSTR   = 1&lt;&lt;29;
188 
189     /** Flag for class symbols to indicate it has been checked and found
190      *  acyclic.
191      */
192     public static final int ACYCLIC          = 1&lt;&lt;30;
193 
194     /** Flag that marks bridge methods.
195      */
196     public static final long BRIDGE          = 1L&lt;&lt;31;
197 
198     /** Flag that marks formal parameters.
199      */
200     public static final long PARAMETER   = 1L&lt;&lt;33;
201 
202     /** Flag that marks varargs methods.
203      */
204     public static final long VARARGS   = 1L&lt;&lt;34;
205 
206     /** Flag for annotation type symbols to indicate it has been
207      *  checked and found acyclic.
208      */
209     public static final long ACYCLIC_ANN      = 1L&lt;&lt;35;
210 
211     /** Flag that marks a generated default constructor.
212      */
213     public static final long GENERATEDCONSTR   = 1L&lt;&lt;36;
214 
215     /** Flag that marks a hypothetical method that need not really be
216      *  generated in the binary, but is present in the symbol table to
217      *  simplify checking for erasure clashes - also used for 292 poly sig methods.
218      */
219     public static final long HYPOTHETICAL   = 1L&lt;&lt;37;
220 
221     /**
222      * Flag that marks an internal proprietary class.
223      */
224     public static final long PROPRIETARY = 1L&lt;&lt;38;
225 
226     /**
227      * Flag that marks a multi-catch parameter.
228      */
229     public static final long UNION = 1L&lt;&lt;39;
230 
231     /**
232      * Flag that marks an &#39;effectively final&#39; local variable.
233      */
234     public static final long EFFECTIVELY_FINAL = 1L&lt;&lt;41;
235 
236     /**
237      * Flag that marks non-override equivalent methods with the same signature,
238      * or a conflicting match binding (BindingSymbol).
239      */
240     public static final long CLASH = 1L&lt;&lt;42;
241 
242     /**
243      * Flag that marks either a default method or an interface containing default methods.
244      */
245     public static final long DEFAULT = 1L&lt;&lt;43;
246 
247     /**
248      * Flag that marks class as auxiliary, ie a non-public class following
249      * the public class in a source file, that could block implicit compilation.
250      */
251     public static final long AUXILIARY = 1L&lt;&lt;44;
252 
253     /**
254      * Flag that marks that a symbol is not available in the current profile
255      */
256     public static final long NOT_IN_PROFILE = 1L&lt;&lt;45;
257 
258     /**
259      * Flag that indicates that an override error has been detected by Check.
260      */
261     public static final long BAD_OVERRIDE = 1L&lt;&lt;45;
262 
263     /**
264      * Flag that indicates a signature polymorphic method (292).
265      */
266     public static final long SIGNATURE_POLYMORPHIC = 1L&lt;&lt;46;
267 
268     /**
269      * Flag that indicates that an inference variable is used in a &#39;throws&#39; clause.
270      */
271     public static final long THROWS = 1L&lt;&lt;47;
272 
273     /**
274      * Flag that marks potentially ambiguous overloads
275      */
276     public static final long POTENTIALLY_AMBIGUOUS = 1L&lt;&lt;48;
277 
278     /**
279      * Flag that marks a synthetic method body for a lambda expression
280      */
281     public static final long LAMBDA_METHOD = 1L&lt;&lt;49;
282 
283     /**
284      * Flag to control recursion in TransTypes
285      */
286     public static final long TYPE_TRANSLATED = 1L&lt;&lt;50;
287 
288     /**
289      * Flag to indicate class symbol is for module-info
290      */
291     public static final long MODULE = 1L&lt;&lt;51;
292 
293     /**
294      * Flag to indicate the given ModuleSymbol is an automatic module.
295      */
296     public static final long AUTOMATIC_MODULE = 1L&lt;&lt;52; //ModuleSymbols only
297 
298     /**
299      * Flag to indicate the given PackageSymbol contains any non-.java and non-.class resources.
300      */
301     public static final long HAS_RESOURCE = 1L&lt;&lt;52; //PackageSymbols only
302 
303     /**
304      * Flag to indicate the given ParamSymbol has a user-friendly name filled.
305      */
306     public static final long NAME_FILLED = 1L&lt;&lt;52; //ParamSymbols only
307 
308     /**
309      * Flag to indicate the given ModuleSymbol is a system module.
310      */
311     public static final long SYSTEM_MODULE = 1L&lt;&lt;53;
312 
313     /**
314      * Flag to indicate the given symbol has a @Deprecated annotation.
315      */
316     public static final long DEPRECATED_ANNOTATION = 1L&lt;&lt;54;
317 
318     /**
319      * Flag to indicate the given symbol has been deprecated and marked for removal.
320      */
321     public static final long DEPRECATED_REMOVAL = 1L&lt;&lt;55;
322 
323     /**
324      * Flag to indicate the API element in question is for a preview API.
325      */
326     public static final long PREVIEW_API = 1L&lt;&lt;56; //any Symbol kind
327 
328     /**
329      * Flag for synthesized default constructors of anonymous classes that have an enclosing expression.
330      */
331     public static final long ANONCONSTR_BASED = 1L&lt;&lt;57;
332 
333     /**
334      * Flag that marks finalize block as body-only, should not be copied into catch clauses.
335      * Used to implement try-with-resources.
336      */
337     public static final long BODY_ONLY_FINALIZE = 1L&lt;&lt;17; //blocks only
338 
339     /**
340      * Flag to indicate the API element in question is for a preview API.
341      */
342     public static final long PREVIEW_ESSENTIAL_API = 1L&lt;&lt;58; //any Symbol kind
343 
344     /**
345      * Flag to indicate the given variable is a match binding variable.
346      */
347     public static final long MATCH_BINDING = 1L&lt;&lt;59;
348 
349     /**
350      * A flag to indicate a match binding variable whose scope extends after the current statement.
351      */
352     public static final long MATCH_BINDING_TO_OUTER = 1L&lt;&lt;60;
353 
354     /**
355      * Flag to indicate that a class is a record. The flag is also used to mark fields that are
356      * part of the state vector of a record and to mark the canonical constructor
357      */
358     public static final long RECORD = 1L&lt;&lt;61; // ClassSymbols, MethodSymbols and VarSymbols
359 
360     /**
361      * Flag to mark a record constructor as a compact one
362      */
363     public static final long COMPACT_RECORD_CONSTRUCTOR = 1L&lt;&lt;51; // MethodSymbols only
364 
365     /**
366      * Flag to mark a record field that was not initialized in the compact constructor
367      */
368     public static final long UNINITIALIZED_FIELD= 1L&lt;&lt;51; // VarSymbols only
369 
370     /** Flag is set for compiler-generated record members, it could be applied to
371      *  accessors and fields
372      */
373     public static final int GENERATED_MEMBER = 1&lt;&lt;24; // MethodSymbols and VarSymbols
374 
375     /** Modifier masks.
376      */
377     public static final int
378         AccessFlags           = PUBLIC | PROTECTED | PRIVATE,
379         LocalClassFlags       = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC | VALUE,
380         LocalRecordFlags      = LocalClassFlags | STATIC,
381         MemberClassFlags      = LocalClassFlags | INTERFACE | AccessFlags,
382         MemberRecordFlags     = MemberClassFlags | STATIC,
383         ClassFlags            = LocalClassFlags | INTERFACE | PUBLIC | ANNOTATION,
384         InterfaceVarFlags     = FINAL | STATIC | PUBLIC,
385         ConstructorFlags      = AccessFlags,
386         InterfaceMethodFlags  = ABSTRACT | PUBLIC,
387         MethodFlags           = AccessFlags | ABSTRACT | STATIC | NATIVE |
388                                 SYNCHRONIZED | FINAL | STRICTFP,
389         RecordMethodFlags     = AccessFlags | ABSTRACT | STATIC |
390                                 SYNCHRONIZED | FINAL | STRICTFP;
391     public static final long
392         ExtendedStandardFlags       = (long)StandardFlags | DEFAULT | VALUE,
393         ModifierFlags               = ((long)StandardFlags &amp; ~INTERFACE) | DEFAULT,
394         InterfaceMethodMask         = ABSTRACT | PRIVATE | STATIC | PUBLIC | STRICTFP | DEFAULT,
395         AnnotationTypeElementMask   = ABSTRACT | PUBLIC,
396         LocalVarFlags               = FINAL | PARAMETER,
397         VarFlags              = AccessFlags | FINAL | STATIC |
398                                 VOLATILE | TRANSIENT | ENUM,
399         ReceiverParamFlags          = PARAMETER;
400 
401 
402     public static Set&lt;Modifier&gt; asModifierSet(long flags) {
403         Set&lt;Modifier&gt; modifiers = modifierSets.get(flags);
404         if (modifiers == null) {
405             modifiers = java.util.EnumSet.noneOf(Modifier.class);
406             if (0 != (flags &amp; PUBLIC))    modifiers.add(Modifier.PUBLIC);
407             if (0 != (flags &amp; PROTECTED)) modifiers.add(Modifier.PROTECTED);
408             if (0 != (flags &amp; PRIVATE))   modifiers.add(Modifier.PRIVATE);
409             if (0 != (flags &amp; ABSTRACT))  modifiers.add(Modifier.ABSTRACT);
410             if (0 != (flags &amp; STATIC))    modifiers.add(Modifier.STATIC);
411             if (0 != (flags &amp; FINAL))     modifiers.add(Modifier.FINAL);
412             if (0 != (flags &amp; TRANSIENT)) modifiers.add(Modifier.TRANSIENT);
413             if (0 != (flags &amp; VOLATILE))  modifiers.add(Modifier.VOLATILE);
414             if (0 != (flags &amp; SYNCHRONIZED))
415                                           modifiers.add(Modifier.SYNCHRONIZED);
416             if (0 != (flags &amp; NATIVE))    modifiers.add(Modifier.NATIVE);
417             if (0 != (flags &amp; STRICTFP))  modifiers.add(Modifier.STRICTFP);
418             if (0 != (flags &amp; DEFAULT))   modifiers.add(Modifier.DEFAULT);
419             if (0 != (flags &amp; VALUE))     modifiers.add(Modifier.VALUE);
420             modifiers = Collections.unmodifiableSet(modifiers);
421             modifierSets.put(flags, modifiers);
422         }
423         return modifiers;
424     }
425 
426     // Cache of modifier sets.
427     private static final Map&lt;Long, Set&lt;Modifier&gt;&gt; modifierSets = new ConcurrentHashMap&lt;&gt;(64);
428 
429     public static boolean isStatic(Symbol symbol) {
430         return (symbol.flags() &amp; STATIC) != 0;
431     }
432 
433     public static boolean isEnum(Symbol symbol) {
434         return (symbol.flags() &amp; ENUM) != 0;
435     }
436 
437     public static boolean isConstant(Symbol.VarSymbol symbol) {
438         return symbol.getConstValue() != null;
439     }
440 
441 
442     public enum Flag {
443         PUBLIC(Flags.PUBLIC),
444         PRIVATE(Flags.PRIVATE),
445         PROTECTED(Flags.PROTECTED),
446         STATIC(Flags.STATIC),
447         FINAL(Flags.FINAL),
448         SYNCHRONIZED(Flags.SYNCHRONIZED),
449         VOLATILE(Flags.VOLATILE),
450         TRANSIENT(Flags.TRANSIENT),
451         NATIVE(Flags.NATIVE),
452         INTERFACE(Flags.INTERFACE),
453         ABSTRACT(Flags.ABSTRACT),
454         DEFAULT(Flags.DEFAULT),
455         STRICTFP(Flags.STRICTFP),
456         BRIDGE(Flags.BRIDGE),
457         SYNTHETIC(Flags.SYNTHETIC),
458         ANNOTATION(Flags.ANNOTATION),
459         DEPRECATED(Flags.DEPRECATED),
460         HASINIT(Flags.HASINIT),
461         BLOCK(Flags.BLOCK),
462         ENUM(Flags.ENUM),
463         MANDATED(Flags.MANDATED),
464         INLINE(Flags.VALUE),
465         NOOUTERTHIS(Flags.NOOUTERTHIS),
466         EXISTS(Flags.EXISTS),
467         COMPOUND(Flags.COMPOUND),
468         CLASS_SEEN(Flags.CLASS_SEEN),
469         SOURCE_SEEN(Flags.SOURCE_SEEN),
470         LOCKED(Flags.LOCKED),
471         UNATTRIBUTED(Flags.UNATTRIBUTED),
472         ANONCONSTR(Flags.ANONCONSTR),
473         ACYCLIC(Flags.ACYCLIC),
474         PARAMETER(Flags.PARAMETER),
475         VARARGS(Flags.VARARGS),
476         ACYCLIC_ANN(Flags.ACYCLIC_ANN),
477         GENERATEDCONSTR(Flags.GENERATEDCONSTR),
478         HYPOTHETICAL(Flags.HYPOTHETICAL),
479         PROPRIETARY(Flags.PROPRIETARY),
480         UNION(Flags.UNION),
481         EFFECTIVELY_FINAL(Flags.EFFECTIVELY_FINAL),
482         CLASH(Flags.CLASH),
483         AUXILIARY(Flags.AUXILIARY),
484         NOT_IN_PROFILE(Flags.NOT_IN_PROFILE),
485         BAD_OVERRIDE(Flags.BAD_OVERRIDE),
486         SIGNATURE_POLYMORPHIC(Flags.SIGNATURE_POLYMORPHIC),
487         THROWS(Flags.THROWS),
488         LAMBDA_METHOD(Flags.LAMBDA_METHOD),
489         TYPE_TRANSLATED(Flags.TYPE_TRANSLATED),
490         MODULE(Flags.MODULE),
491         AUTOMATIC_MODULE(Flags.AUTOMATIC_MODULE),
492         SYSTEM_MODULE(Flags.SYSTEM_MODULE),
493         DEPRECATED_ANNOTATION(Flags.DEPRECATED_ANNOTATION),
494         DEPRECATED_REMOVAL(Flags.DEPRECATED_REMOVAL),
495         HAS_RESOURCE(Flags.HAS_RESOURCE),
496         POTENTIALLY_AMBIGUOUS(Flags.POTENTIALLY_AMBIGUOUS),
497         ANONCONSTR_BASED(Flags.ANONCONSTR_BASED),
498         VALUEBASED(Flags.VALUEBASED),
499         NAME_FILLED(Flags.NAME_FILLED),
500         PREVIEW_API(Flags.PREVIEW_API),
501         PREVIEW_ESSENTIAL_API(Flags.PREVIEW_ESSENTIAL_API),
502         MATCH_BINDING(Flags.MATCH_BINDING),
503         MATCH_BINDING_TO_OUTER(Flags.MATCH_BINDING_TO_OUTER),
504         RECORD(Flags.RECORD);
505 
506         Flag(long flag) {
507             this.value = flag;
508             this.lowercaseName = StringUtils.toLowerCase(name());
509         }
510 
511         @Override
512         public String toString() {
513             return lowercaseName;
514         }
515 
516         final long value;
517         final String lowercaseName;
518     }
519 
520 }
    </pre>
  </body>
</html>
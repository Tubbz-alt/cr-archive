<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.net.URI;
  30 import java.net.URISyntaxException;
  31 import java.nio.CharBuffer;
  32 import java.nio.file.ClosedFileSystemException;
  33 import java.util.Arrays;
  34 import java.util.EnumSet;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Map;
  38 import java.util.Set;
  39 import java.util.function.IntFunction;
  40 
  41 import javax.lang.model.element.Modifier;
  42 import javax.lang.model.element.NestingKind;
  43 import javax.tools.JavaFileManager;
  44 import javax.tools.JavaFileObject;
  45 
  46 import com.sun.tools.javac.code.Source.Feature;
  47 import com.sun.tools.javac.comp.Annotate;
  48 import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
  49 import com.sun.tools.javac.code.*;
  50 import com.sun.tools.javac.code.Directive.*;
  51 import com.sun.tools.javac.code.Lint.LintCategory;
  52 import com.sun.tools.javac.code.Scope.WriteableScope;
  53 import com.sun.tools.javac.code.Symbol.*;
  54 import com.sun.tools.javac.code.Symtab;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  57 import com.sun.tools.javac.file.BaseFileManager;
  58 import com.sun.tools.javac.file.PathFileObject;
  59 import com.sun.tools.javac.jvm.ClassFile.Version;
  60 import com.sun.tools.javac.jvm.PoolConstant.NameAndType;
  61 import com.sun.tools.javac.main.Option;
  62 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  63 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  64 import com.sun.tools.javac.util.*;
  65 import com.sun.tools.javac.util.DefinedBy.Api;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 import static com.sun.tools.javac.code.Flags.*;
  69 import static com.sun.tools.javac.code.Kinds.Kind.*;
  70 
  71 import com.sun.tools.javac.code.Scope.LookupKind;
  72 
  73 import static com.sun.tools.javac.code.TypeTag.ARRAY;
  74 import static com.sun.tools.javac.code.TypeTag.CLASS;
  75 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  76 import static com.sun.tools.javac.jvm.ClassFile.*;
  77 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
  78 
  79 import static com.sun.tools.javac.main.Option.PARAMETERS;
  80 
  81 /** This class provides operations to read a classfile into an internal
  82  *  representation. The internal representation is anchored in a
  83  *  ClassSymbol which contains in its scope symbol representations
  84  *  for all other definitions in the classfile. Top-level Classes themselves
  85  *  appear as members of the scopes of PackageSymbols.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
 108     /** Switch: allow inline types.
 109      */
 110     boolean allowInlineTypes;
 111 
 112     /** Switch: allow records
 113      */
 114     boolean allowRecords;
 115 
 116    /** Lint option: warn about classfile issues
 117      */
 118     boolean lintClassfile;
 119 
 120     /** Switch: preserve parameter names from the variable table.
 121      */
 122     public boolean saveParameterNames;
 123 
 124     /** Switch: Should javac recongnize and handle value based classes specially ?
 125      */
 126     private boolean allowValueBasedClasses;
 127 
 128     /**
 129      * The currently selected profile.
 130      */
 131     public final Profile profile;
 132 
 133     /** The log to use for verbose output
 134      */
 135     final Log log;
 136 
 137     /** The symbol table. */
 138     Symtab syms;
 139 
 140     Types types;
 141 
 142     /** The name table. */
 143     final Names names;
 144 
 145     /** Access to files
 146      */
 147     private final JavaFileManager fileManager;
 148 
 149     /** Factory for diagnostics
 150      */
 151     JCDiagnostic.Factory diagFactory;
 152 
 153     DeferredCompletionFailureHandler dcfh;
 154 
 155     /**
 156      * Support for preview language features.
 157      */
 158     Preview preview;
 159 
 160     /** The current scope where type variables are entered.
 161      */
 162     protected WriteableScope typevars;
 163 
 164     private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
 165     private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
 166 
 167     /** The path name of the class file currently being read.
 168      */
 169     protected JavaFileObject currentClassFile = null;
 170 
 171     /** The class or method currently being read.
 172      */
 173     protected Symbol currentOwner = null;
 174 
 175     /** The module containing the class currently being read.
 176      */
 177     protected ModuleSymbol currentModule = null;
 178 
 179     /** The buffer containing the currently read class file.
 180      */
 181     ByteBuffer buf = new ByteBuffer(INITIAL_BUFFER_SIZE);
 182 
 183     /** The current input pointer.
 184      */
 185     protected int bp;
 186 
 187     /** The pool reader.
 188      */
 189     PoolReader poolReader;
 190 
 191     /** The major version number of the class file being read. */
 192     int majorVersion;
 193     /** The minor version number of the class file being read. */
 194     int minorVersion;
 195 
 196     /** A table to hold the constant pool indices for method parameter
 197      * names, as given in LocalVariableTable attributes.
 198      */
 199     int[] parameterNameIndices;
 200 
 201     /**
 202      * A table to hold annotations for method parameters.
 203      */
 204     ParameterAnnotations[] parameterAnnotations;
 205 
 206     /**
 207      * A holder for parameter annotations.
 208      */
 209     static class ParameterAnnotations {
 210         List&lt;CompoundAnnotationProxy&gt; proxies;
 211 
 212         void add(List&lt;CompoundAnnotationProxy&gt; newAnnotations) {
 213             if (proxies == null) {
 214                 proxies = newAnnotations;
 215             } else {
 216                 proxies = proxies.prependList(newAnnotations);
 217             }
 218         }
 219     }
 220 
 221     /**
 222      * Whether or not any parameter names have been found.
 223      */
 224     boolean haveParameterNameIndices;
 225 
 226     /** Set this to false every time we start reading a method
 227      * and are saving parameter names.  Set it to true when we see
 228      * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
 229      * then we ignore the parameter names from the LVT.
 230      */
 231     boolean sawMethodParameters;
 232 
 233     /**
 234      * The set of attribute names for which warnings have been generated for the current class
 235      */
 236     Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();
 237 
 238     /**
 239      * The prototype @Target Attribute.Compound if this class is an annotation annotated with
 240      * @Target
 241      */
 242     CompoundAnnotationProxy target;
 243 
 244     /**
 245      * The prototype @Repeatable Attribute.Compound if this class is an annotation annotated with
 246      * @Repeatable
 247      */
 248     CompoundAnnotationProxy repeatable;
 249 
 250     /** Get the ClassReader instance for this invocation. */
 251     public static ClassReader instance(Context context) {
 252         ClassReader instance = context.get(classReaderKey);
 253         if (instance == null)
 254             instance = new ClassReader(context);
 255         return instance;
 256     }
 257 
 258     /** Construct a new class reader. */
 259     protected ClassReader(Context context) {
 260         context.put(classReaderKey, this);
 261         annotate = Annotate.instance(context);
 262         names = Names.instance(context);
 263         syms = Symtab.instance(context);
 264         types = Types.instance(context);
 265         fileManager = context.get(JavaFileManager.class);
 266         if (fileManager == null)
 267             throw new AssertionError(&quot;FileManager initialization error&quot;);
 268         diagFactory = JCDiagnostic.Factory.instance(context);
 269         dcfh = DeferredCompletionFailureHandler.instance(context);
 270 
 271         log = Log.instance(context);
 272 
 273         Options options = Options.instance(context);
 274         verbose         = options.isSet(Option.VERBOSE);
 275 
 276         Source source = Source.instance(context);
 277         preview = Preview.instance(context);
 278         allowModules     = Feature.MODULES.allowedInSource(source);
 279         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);
 280         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 281                 Feature.RECORDS.allowedInSource(source);
 282 
 283         saveParameterNames = options.isSet(PARAMETERS);
 284         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 285 
 286         profile = Profile.instance(context);
 287 
 288         typevars = WriteableScope.create(syms.noSymbol);
 289 
 290         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 291 
 292         initAttributeReaders();
 293     }
 294 
 295     /** Add member to class unless it is synthetic.
 296      */
 297     private void enterMember(ClassSymbol c, Symbol sym) {
 298         // Synthetic members are not entered -- reason lost to history (optimization?).
 299         // Lambda methods must be entered because they may have inner classes (which reference them)
 300         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 301             c.members_field.enter(sym);
 302     }
 303 
 304 /************************************************************************
 305  * Error Diagnoses
 306  ***********************************************************************/
 307 
 308     public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
 309         return new ClassFinder.BadClassFile (
 310             currentOwner.enclClass(),
 311             currentClassFile,
 312             diagFactory.fragment(key, args),
 313             diagFactory,
 314             dcfh);
 315     }
 316 
 317     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 318         return new ClassFinder.BadEnclosingMethodAttr (
 319             currentOwner.enclClass(),
 320             currentClassFile,
 321             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
 322             diagFactory,
 323             dcfh);
 324     }
 325 
 326 /************************************************************************
 327  * Buffer Access
 328  ***********************************************************************/
 329 
 330     /** Read a character.
 331      */
 332     char nextChar() {
 333         char res = buf.getChar(bp);
 334         bp += 2;
 335         return res;
 336     }
 337 
 338     /** Read a byte.
 339      */
 340     int nextByte() {
 341         return buf.getByte(bp++) &amp; 0xFF;
 342     }
 343 
 344     /** Read an integer.
 345      */
 346     int nextInt() {
 347         int res = buf.getInt(bp);
 348         bp += 4;
 349         return res;
 350     }
 351 
 352 /************************************************************************
 353  * Constant Pool Access
 354  ***********************************************************************/
 355 
 356     /** Read module_flags.
 357      */
 358     Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
 359         Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
 360         for (ModuleFlags f : ModuleFlags.values()) {
 361             if ((flags &amp; f.value) != 0)
 362                 set.add(f);
 363         }
 364         return set;
 365     }
 366 
 367     /** Read resolution_flags.
 368      */
 369     Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
 370         Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
 371         for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
 372             if ((flags &amp; f.value) != 0)
 373                 set.add(f);
 374         }
 375         return set;
 376     }
 377 
 378     /** Read exports_flags.
 379      */
 380     Set&lt;ExportsFlag&gt; readExportsFlags(int flags) {
 381         Set&lt;ExportsFlag&gt; set = EnumSet.noneOf(ExportsFlag.class);
 382         for (ExportsFlag f: ExportsFlag.values()) {
 383             if ((flags &amp; f.value) != 0)
 384                 set.add(f);
 385         }
 386         return set;
 387     }
 388 
 389     /** Read opens_flags.
 390      */
 391     Set&lt;OpensFlag&gt; readOpensFlags(int flags) {
 392         Set&lt;OpensFlag&gt; set = EnumSet.noneOf(OpensFlag.class);
 393         for (OpensFlag f: OpensFlag.values()) {
 394             if ((flags &amp; f.value) != 0)
 395                 set.add(f);
 396         }
 397         return set;
 398     }
 399 
 400     /** Read requires_flags.
 401      */
 402     Set&lt;RequiresFlag&gt; readRequiresFlags(int flags) {
 403         Set&lt;RequiresFlag&gt; set = EnumSet.noneOf(RequiresFlag.class);
 404         for (RequiresFlag f: RequiresFlag.values()) {
 405             if ((flags &amp; f.value) != 0)
 406                 set.add(f);
 407         }
 408         return set;
 409     }
 410 
 411 /************************************************************************
 412  * Reading Types
 413  ***********************************************************************/
 414 
 415     /** The unread portion of the currently read type is
 416      *  signature[sigp..siglimit-1].
 417      */
 418     byte[] signature;
 419     int sigp;
 420     int siglimit;
 421     boolean sigEnterPhase = false;
 422 
 423     /** Convert signature to type, where signature is a byte array segment.
 424      */
 425     Type sigToType(byte[] sig, int offset, int len) {
 426         signature = sig;
 427         sigp = offset;
 428         siglimit = offset + len;
 429         return sigToType();
 430     }
 431 
 432     /** Convert signature to type, where signature is implicit.
 433      */
 434     Type sigToType() {
 435         switch ((char) signature[sigp]) {
 436         case &#39;T&#39;:
 437             sigp++;
 438             int start = sigp;
 439             while (signature[sigp] != &#39;;&#39;) sigp++;
 440             sigp++;
 441             return sigEnterPhase
 442                 ? Type.noType
 443                 : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));
 444         case &#39;+&#39;: {
 445             sigp++;
 446             Type t = sigToType();
 447             return new WildcardType(t, BoundKind.EXTENDS, syms.boundClass);
 448         }
 449         case &#39;*&#39;:
 450             sigp++;
 451             return new WildcardType(syms.objectType, BoundKind.UNBOUND,
 452                                     syms.boundClass);
 453         case &#39;-&#39;: {
 454             sigp++;
 455             Type t = sigToType();
 456             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 457         }
 458         case &#39;B&#39;:
 459             sigp++;
 460             return syms.byteType;
 461         case &#39;C&#39;:
 462             sigp++;
 463             return syms.charType;
 464         case &#39;D&#39;:
 465             sigp++;
 466             return syms.doubleType;
 467         case &#39;F&#39;:
 468             sigp++;
 469             return syms.floatType;
 470         case &#39;I&#39;:
 471             sigp++;
 472             return syms.intType;
 473         case &#39;J&#39;:
 474             sigp++;
 475             return syms.longType;
 476         case &#39;Q&#39;:
 477         case &#39;L&#39;:
 478             {
 479                 // int oldsigp = sigp;
 480                 Type t = classSigToType();
 481                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 482                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 483                                        &quot;(please recompile from source)&quot;);
 484                 /*
 485                 System.err.println(&quot; decoded &quot; +
 486                                    new String(signature, oldsigp, sigp-oldsigp) +
 487                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 488                 */
 489                 return t;
 490             }
 491         case &#39;S&#39;:
 492             sigp++;
 493             return syms.shortType;
 494         case &#39;V&#39;:
 495             sigp++;
 496             return syms.voidType;
 497         case &#39;Z&#39;:
 498             sigp++;
 499             return syms.booleanType;
 500         case &#39;[&#39;:
 501             sigp++;
 502             return new ArrayType(sigToType(), syms.arrayClass);
 503         case &#39;(&#39;:
 504             sigp++;
 505             List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
 506             Type restype = sigToType();
 507             List&lt;Type&gt; thrown = List.nil();
 508             while (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;^&#39;) {
 509                 sigp++;
 510                 thrown = thrown.prepend(sigToType());
 511             }
 512             // if there is a typevar in the throws clause we should state it.
 513             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
 514                 if (l.head.hasTag(TYPEVAR)) {
 515                     l.head.tsym.flags_field |= THROWS;
 516                 }
 517             }
 518             return new MethodType(argtypes,
 519                                   restype,
 520                                   thrown.reverse(),
 521                                   syms.methodClass);
 522         case &#39;&lt;&#39;:
 523             typevars = typevars.dup(currentOwner);
 524             Type poly = new ForAll(sigToTypeParams(), sigToType());
 525             typevars = typevars.leave();
 526             return poly;
 527         default:
 528             throw badClassFile(&quot;bad.signature&quot;,
 529                                Convert.utf2string(signature, sigp, 10));
 530         }
 531     }
 532 
 533     byte[] signatureBuffer = new byte[0];
 534     int sbp = 0;
 535     /** Convert class signature to type, where signature is implicit.
 536      */
 537     Type classSigToType() {
 538         if (signature[sigp] != &#39;L&#39; &amp;&amp; signature[sigp] != &#39;Q&#39;)
 539             throw badClassFile(&quot;bad.class.signature&quot;,
 540                                Convert.utf2string(signature, sigp, 10));
 541         sigp++;
 542         Type outer = Type.noType;
 543         int startSbp = sbp;
 544 
 545         while (true) {
 546             final byte c = signature[sigp++];
 547             switch (c) {
 548 
 549             case &#39;;&#39;: {         // end
 550                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 551                                                          startSbp,
 552                                                          sbp - startSbp));
 553 
 554                 try {
 555                     return (outer == Type.noType) ?
 556                             t.erasure(types) :
 557                         new ClassType(outer, List.nil(), t);
 558                 } finally {
 559                     sbp = startSbp;
 560                 }
 561             }
 562 
 563             case &#39;&lt;&#39;:           // generic arguments
 564                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 565                                                          startSbp,
 566                                                          sbp - startSbp));
 567                 outer = new ClassType(outer, sigToTypes(&#39;&gt;&#39;), t) {
 568                         boolean completed = false;
 569                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 570                         public Type getEnclosingType() {
 571                             if (!completed) {
 572                                 completed = true;
 573                                 tsym.complete();
 574                                 Type enclosingType = tsym.type.getEnclosingType();
 575                                 if (enclosingType != Type.noType) {
 576                                     List&lt;Type&gt; typeArgs =
 577                                         super.getEnclosingType().allparams();
 578                                     List&lt;Type&gt; typeParams =
 579                                         enclosingType.allparams();
 580                                     if (typeParams.length() != typeArgs.length()) {
 581                                         // no &quot;rare&quot; types
 582                                         super.setEnclosingType(types.erasure(enclosingType));
 583                                     } else {
 584                                         super.setEnclosingType(types.subst(enclosingType,
 585                                                                            typeParams,
 586                                                                            typeArgs));
 587                                     }
 588                                 } else {
 589                                     super.setEnclosingType(Type.noType);
 590                                 }
 591                             }
 592                             return super.getEnclosingType();
 593                         }
 594                         @Override
 595                         public void setEnclosingType(Type outer) {
 596                             throw new UnsupportedOperationException();
 597                         }
 598                     };
 599                 switch (signature[sigp++]) {
 600                 case &#39;;&#39;:
 601                     if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;) {
 602                         // support old-style GJC signatures
 603                         // The signature produced was
 604                         // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
 605                         // rather than say
 606                         // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
 607                         // so we skip past &quot;.Lfoo/Outer$&quot;
 608                         sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
 609                             3;  // &quot;.L&quot; and &quot;$&quot;
 610                         signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 611                         break;
 612                     } else {
 613                         sbp = startSbp;
 614                         return outer;
 615                     }
 616                 case &#39;.&#39;:
 617                     signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 618                     break;
 619                 default:
 620                     throw new AssertionError(signature[sigp-1]);
 621                 }
 622                 continue;
 623 
 624             case &#39;.&#39;:
 625                 //we have seen an enclosing non-generic class
 626                 if (outer != Type.noType) {
 627                     t = enterClass(names.fromUtf(signatureBuffer,
 628                                                  startSbp,
 629                                                  sbp - startSbp));
 630                     outer = new ClassType(outer, List.nil(), t);
 631                 }
 632                 signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 633                 continue;
 634             case &#39;/&#39;:
 635                 signatureBuffer[sbp++] = (byte)&#39;.&#39;;
 636                 continue;
 637             default:
 638                 signatureBuffer[sbp++] = c;
 639                 continue;
 640             }
 641         }
 642     }
 643 
 644     /** Convert (implicit) signature to list of types
 645      *  until `terminator&#39; is encountered.
 646      */
 647     List&lt;Type&gt; sigToTypes(char terminator) {
 648         List&lt;Type&gt; head = List.of(null);
 649         List&lt;Type&gt; tail = head;
 650         while (signature[sigp] != terminator)
 651             tail = tail.setTail(List.of(sigToType()));
 652         sigp++;
 653         return head.tail;
 654     }
 655 
 656     /** Convert signature to type parameters, where signature is a byte
 657      *  array segment.
 658      */
 659     List&lt;Type&gt; sigToTypeParams(byte[] sig, int offset, int len) {
 660         signature = sig;
 661         sigp = offset;
 662         siglimit = offset + len;
 663         return sigToTypeParams();
 664     }
 665 
 666     /** Convert signature to type parameters, where signature is implicit.
 667      */
 668     List&lt;Type&gt; sigToTypeParams() {
 669         List&lt;Type&gt; tvars = List.nil();
 670         if (signature[sigp] == &#39;&lt;&#39;) {
 671             sigp++;
 672             int start = sigp;
 673             sigEnterPhase = true;
 674             while (signature[sigp] != &#39;&gt;&#39;)
 675                 tvars = tvars.prepend(sigToTypeParam());
 676             sigEnterPhase = false;
 677             sigp = start;
 678             while (signature[sigp] != &#39;&gt;&#39;)
 679                 sigToTypeParam();
 680             sigp++;
 681         }
 682         return tvars.reverse();
 683     }
 684 
 685     /** Convert (implicit) signature to type parameter.
 686      */
 687     Type sigToTypeParam() {
 688         int start = sigp;
 689         while (signature[sigp] != &#39;:&#39;) sigp++;
 690         Name name = names.fromUtf(signature, start, sigp - start);
 691         TypeVar tvar;
 692         if (sigEnterPhase) {
 693             tvar = new TypeVar(name, currentOwner, syms.botType);
 694             typevars.enter(tvar.tsym);
 695         } else {
 696             tvar = (TypeVar)findTypeVar(name);
 697         }
 698         List&lt;Type&gt; bounds = List.nil();
 699         boolean allInterfaces = false;
 700         if (signature[sigp] == &#39;:&#39; &amp;&amp; signature[sigp+1] == &#39;:&#39;) {
 701             sigp++;
 702             allInterfaces = true;
 703         }
 704         while (signature[sigp] == &#39;:&#39;) {
 705             sigp++;
 706             bounds = bounds.prepend(sigToType());
 707         }
 708         if (!sigEnterPhase) {
 709             types.setBounds(tvar, bounds.reverse(), allInterfaces);
 710         }
 711         return tvar;
 712     }
 713 
 714     /** Find type variable with given name in `typevars&#39; scope.
 715      */
 716     Type findTypeVar(Name name) {
 717         Symbol s = typevars.findFirst(name);
 718         if (s != null) {
 719             return s.type;
 720         } else {
 721             if (readingClassAttr) {
 722                 // While reading the class attribute, the supertypes
 723                 // might refer to a type variable from an enclosing element
 724                 // (method or class).
 725                 // If the type variable is defined in the enclosing class,
 726                 // we can actually find it in
 727                 // currentOwner.owner.type.getTypeArguments()
 728                 // However, until we have read the enclosing method attribute
 729                 // we don&#39;t know for sure if this owner is correct.  It could
 730                 // be a method and there is no way to tell before reading the
 731                 // enclosing method attribute.
 732                 TypeVar t = new TypeVar(name, currentOwner, syms.botType);
 733                 missingTypeVariables = missingTypeVariables.prepend(t);
 734                 // System.err.println(&quot;Missing type var &quot; + name);
 735                 return t;
 736             }
 737             throw badClassFile(&quot;undecl.type.var&quot;, name);
 738         }
 739     }
 740 
 741 /************************************************************************
 742  * Reading Attributes
 743  ***********************************************************************/
 744 
 745     protected enum AttributeKind { CLASS, MEMBER }
 746 
 747     protected abstract class AttributeReader {
 748         protected AttributeReader(Name name, ClassFile.Version version, Set&lt;AttributeKind&gt; kinds) {
 749             this.name = name;
 750             this.version = version;
 751             this.kinds = kinds;
 752         }
 753 
 754         protected boolean accepts(AttributeKind kind) {
 755             if (kinds.contains(kind)) {
 756                 if (majorVersion &gt; version.major || (majorVersion == version.major &amp;&amp; minorVersion &gt;= version.minor))
 757                     return true;
 758 
 759                 if (lintClassfile &amp;&amp; !warnedAttrs.contains(name)) {
 760                     JavaFileObject prev = log.useSource(currentClassFile);
 761                     try {
 762                         log.warning(LintCategory.CLASSFILE, (DiagnosticPosition) null,
 763                                     Warnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));
 764                     } finally {
 765                         log.useSource(prev);
 766                     }
 767                     warnedAttrs.add(name);
 768                 }
 769             }
 770             return false;
 771         }
 772 
 773         protected abstract void read(Symbol sym, int attrLen);
 774 
 775         protected final Name name;
 776         protected final ClassFile.Version version;
 777         protected final Set&lt;AttributeKind&gt; kinds;
 778     }
 779 
 780     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 781             EnumSet.of(AttributeKind.CLASS);
 782     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 783             EnumSet.of(AttributeKind.MEMBER);
 784     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 785             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 786 
 787     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 788 
 789     private void initAttributeReaders() {
 790         AttributeReader[] readers = {
 791             // v45.3 attributes
 792 
 793             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 794                 protected void read(Symbol sym, int attrLen) {
<a name="1" id="anc1"></a>










 795                     if (saveParameterNames)
 796                         ((MethodSymbol)sym).code = readCode(sym);
 797                     else
 798                         bp = bp + attrLen;
 799                 }
 800             },
 801 
 802             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 803                 protected void read(Symbol sym, int attrLen) {
 804                     Object v = poolReader.getConstant(nextChar());
 805                     // Ignore ConstantValue attribute if field not final.
 806                     if ((sym.flags() &amp; FINAL) == 0) {
 807                         return;
 808                     }
 809                     VarSymbol var = (VarSymbol) sym;
 810                     switch (var.type.getTag()) {
 811                        case BOOLEAN:
 812                        case BYTE:
 813                        case CHAR:
 814                        case SHORT:
 815                        case INT:
 816                            checkType(var, Integer.class, v);
 817                            break;
 818                        case LONG:
 819                            checkType(var, Long.class, v);
 820                            break;
 821                        case FLOAT:
 822                            checkType(var, Float.class, v);
 823                            break;
 824                        case DOUBLE:
 825                            checkType(var, Double.class, v);
 826                            break;
 827                        case CLASS:
 828                            if (var.type.tsym == syms.stringType.tsym) {
 829                                checkType(var, String.class, v);
 830                            } else {
 831                                throw badClassFile(&quot;bad.constant.value.type&quot;, var.type);
 832                            }
 833                            break;
 834                        default:
 835                            // ignore ConstantValue attribute if type is not primitive or String
 836                            return;
 837                     }
 838                     if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
 839                         throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
 840                     }
 841                     var.setData(v);
 842                 }
 843 
 844                 void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {
 845                     if (!clazz.isInstance(value)) {
 846                         throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
 847                     }
 848                 }
 849             },
 850 
 851             new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 852                 protected void read(Symbol sym, int attrLen) {
 853                     Symbol s = sym.owner.kind == MDL ? sym.owner : sym;
 854 
 855                     s.flags_field |= DEPRECATED;
 856                 }
 857             },
 858 
 859             new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 860                 protected void read(Symbol sym, int attrLen) {
 861                     int nexceptions = nextChar();
 862                     List&lt;Type&gt; thrown = List.nil();
 863                     for (int j = 0; j &lt; nexceptions; j++)
 864                         thrown = thrown.prepend(poolReader.getClass(nextChar()).type);
 865                     if (sym.type.getThrownTypes().isEmpty())
 866                         sym.type.asMethodType().thrown = thrown.reverse();
 867                 }
 868             },
 869 
 870             new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {
 871                 protected void read(Symbol sym, int attrLen) {
 872                     ClassSymbol c = (ClassSymbol) sym;
 873                     if (currentModule.module_info == c) {
 874                         //prevent entering the classes too soon:
 875                         skipInnerClasses();
 876                     } else {
 877                         readInnerClasses(c);
 878                     }
 879                 }
 880             },
 881 
 882             new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 883                 protected void read(Symbol sym, int attrLen) {
 884                     int newbp = bp + attrLen;
 885                     if (saveParameterNames &amp;&amp; !sawMethodParameters) {
 886                         // Pick up parameter names from the variable table.
 887                         // Parameter names are not explicitly identified as such,
 888                         // but all parameter name entries in the LocalVariableTable
 889                         // have a start_pc of 0.  Therefore, we record the name
 890                         // indices of all slots with a start_pc of zero in the
 891                         // parameterNameIndices array.
 892                         // Note that this implicitly honors the JVMS spec that
 893                         // there may be more than one LocalVariableTable, and that
 894                         // there is no specified ordering for the entries.
 895                         int numEntries = nextChar();
 896                         for (int i = 0; i &lt; numEntries; i++) {
 897                             int start_pc = nextChar();
 898                             int length = nextChar();
 899                             int nameIndex = nextChar();
 900                             int sigIndex = nextChar();
 901                             int register = nextChar();
 902                             if (start_pc == 0) {
 903                                 // ensure array large enough
 904                                 if (register &gt;= parameterNameIndices.length) {
 905                                     int newSize =
 906                                             Math.max(register + 1, parameterNameIndices.length + 8);
 907                                     parameterNameIndices =
 908                                             Arrays.copyOf(parameterNameIndices, newSize);
 909                                 }
 910                                 parameterNameIndices[register] = nameIndex;
 911                                 haveParameterNameIndices = true;
 912                             }
 913                         }
 914                     }
 915                     bp = newbp;
 916                 }
 917             },
 918 
 919             new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
 920                 protected void read(Symbol sym, int attrLen) {
 921                     ClassSymbol c = (ClassSymbol) sym;
 922                     Name n = poolReader.getName(nextChar());
 923                     c.sourcefile = new SourceFileObject(n);
 924                     // If the class is a toplevel class, originating from a Java source file,
 925                     // but the class name does not match the file name, then it is
 926                     // an auxiliary class.
 927                     String sn = n.toString();
 928                     if (c.owner.kind == PCK &amp;&amp;
 929                         sn.endsWith(&quot;.java&quot;) &amp;&amp;
 930                         !sn.equals(c.name.toString()+&quot;.java&quot;)) {
 931                         c.flags_field |= AUXILIARY;
 932                     }
 933                 }
 934             },
 935 
 936             new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 937                 protected void read(Symbol sym, int attrLen) {
 938                     sym.flags_field |= SYNTHETIC;
 939                 }
 940             },
 941 
 942             // standard v49 attributes
 943 
 944             new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {
 945                 protected void read(Symbol sym, int attrLen) {
 946                     int newbp = bp + attrLen;
 947                     readEnclosingMethodAttr(sym);
 948                     bp = newbp;
 949                 }
 950             },
 951 
 952             new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 953                 protected void read(Symbol sym, int attrLen) {
 954                     if (sym.kind == TYP) {
 955                         ClassSymbol c = (ClassSymbol) sym;
 956                         readingClassAttr = true;
 957                         try {
 958                             ClassType ct1 = (ClassType)c.type;
 959                             Assert.check(c == currentOwner);
 960                             ct1.typarams_field = poolReader.getName(nextChar())
 961                                     .map(ClassReader.this::sigToTypeParams);
 962                             ct1.supertype_field = sigToType();
 963                             ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
 964                             while (sigp != siglimit) is.append(sigToType());
 965                             ct1.interfaces_field = is.toList();
 966                         } finally {
 967                             readingClassAttr = false;
 968                         }
 969                     } else {
 970                         List&lt;Type&gt; thrown = sym.type.getThrownTypes();
 971                         sym.type = poolReader.getType(nextChar());
 972                         //- System.err.println(&quot; # &quot; + sym.type);
 973                         if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
 974                             sym.type.asMethodType().thrown = thrown;
 975 
 976                     }
 977                 }
 978             },
 979 
 980             // v49 annotation attributes
 981 
 982             new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 983                 protected void read(Symbol sym, int attrLen) {
 984                     attachAnnotationDefault(sym);
 985                 }
 986             },
 987 
 988             new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 989                 protected void read(Symbol sym, int attrLen) {
 990                     attachAnnotations(sym);
 991                 }
 992             },
 993 
 994             new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 995                 protected void read(Symbol sym, int attrLen) {
 996                     readParameterAnnotations(sym);
 997                 }
 998             },
 999 
1000             new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1001                 protected void read(Symbol sym, int attrLen) {
1002                     attachAnnotations(sym);
1003                 }
1004             },
1005 
1006             new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1007                 protected void read(Symbol sym, int attrLen) {
1008                     readParameterAnnotations(sym);
1009                 }
1010             },
1011 
1012             // additional &quot;legacy&quot; v49 attributes, superseded by flags
1013 
1014             new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1015                 protected void read(Symbol sym, int attrLen) {
1016                     sym.flags_field |= ANNOTATION;
1017                 }
1018             },
1019 
1020             new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {
1021                 protected void read(Symbol sym, int attrLen) {
1022                     sym.flags_field |= BRIDGE;
1023                 }
1024             },
1025 
1026             new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1027                 protected void read(Symbol sym, int attrLen) {
1028                     sym.flags_field |= ENUM;
1029                 }
1030             },
1031 
1032             new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1033                 protected void read(Symbol sym, int attrLen) {
1034                     sym.flags_field |= VARARGS;
1035                 }
1036             },
1037 
1038             new AttributeReader(names.RuntimeVisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1039                 protected void read(Symbol sym, int attrLen) {
1040                     attachTypeAnnotations(sym);
1041                 }
1042             },
1043 
1044             new AttributeReader(names.RuntimeInvisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1045                 protected void read(Symbol sym, int attrLen) {
1046                     attachTypeAnnotations(sym);
1047                 }
1048             },
1049 
1050             // The following attributes for a Code attribute are not currently handled
1051             // StackMapTable
1052             // SourceDebugExtension
1053             // LineNumberTable
1054             // LocalVariableTypeTable
1055 
1056             // standard v52 attributes
1057 
1058             new AttributeReader(names.MethodParameters, V52, MEMBER_ATTRIBUTE) {
1059                 protected void read(Symbol sym, int attrlen) {
1060                     int newbp = bp + attrlen;
1061                     if (saveParameterNames) {
1062                         sawMethodParameters = true;
1063                         int numEntries = nextByte();
1064                         parameterNameIndices = new int[numEntries];
1065                         haveParameterNameIndices = true;
1066                         int index = 0;
1067                         for (int i = 0; i &lt; numEntries; i++) {
1068                             int nameIndex = nextChar();
1069                             int flags = nextChar();
1070                             if ((flags &amp; (Flags.MANDATED | Flags.SYNTHETIC)) != 0) {
1071                                 continue;
1072                             }
1073                             parameterNameIndices[index++] = nameIndex;
1074                         }
1075                     }
1076                     bp = newbp;
1077                 }
1078             },
1079 
1080             // standard v53 attributes
1081 
1082             new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {
1083                 @Override
1084                 protected boolean accepts(AttributeKind kind) {
1085                     return super.accepts(kind) &amp;&amp; allowModules;
1086                 }
1087                 protected void read(Symbol sym, int attrLen) {
1088                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1089                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1090                         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
1091 
1092                         Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);
1093                         if (currentModule.name != moduleName) {
1094                             throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
1095                         }
1096 
1097                         Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
1098                         msym.flags.addAll(moduleFlags);
1099                         msym.version = optPoolEntry(nextChar(), poolReader::getName, null);
1100 
1101                         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
1102                         int nrequires = nextChar();
1103                         for (int i = 0; i &lt; nrequires; i++) {
1104                             ModuleSymbol rsym = poolReader.getModule(nextChar());
1105                             Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
1106                             if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
1107                                 if (flags.contains(RequiresFlag.TRANSITIVE)) {
1108                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
1109                                 }
1110                                 if (flags.contains(RequiresFlag.STATIC_PHASE)) {
1111                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
1112                                 }
1113                             }
1114                             nextChar(); // skip compiled version
1115                             requires.add(new RequiresDirective(rsym, flags));
1116                         }
1117                         msym.requires = requires.toList();
1118                         directives.addAll(msym.requires);
1119 
1120                         ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
1121                         int nexports = nextChar();
1122                         for (int i = 0; i &lt; nexports; i++) {
1123                             PackageSymbol p = poolReader.getPackage(nextChar());
1124                             Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
1125                             int nto = nextChar();
1126                             List&lt;ModuleSymbol&gt; to;
1127                             if (nto == 0) {
1128                                 to = null;
1129                             } else {
1130                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1131                                 for (int t = 0; t &lt; nto; t++)
1132                                     lb.append(poolReader.getModule(nextChar()));
1133                                 to = lb.toList();
1134                             }
1135                             exports.add(new ExportsDirective(p, to, flags));
1136                         }
1137                         msym.exports = exports.toList();
1138                         directives.addAll(msym.exports);
1139                         ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
1140                         int nopens = nextChar();
1141                         if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
1142                             throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
1143                         }
1144                         for (int i = 0; i &lt; nopens; i++) {
1145                             PackageSymbol p = poolReader.getPackage(nextChar());
1146                             Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
1147                             int nto = nextChar();
1148                             List&lt;ModuleSymbol&gt; to;
1149                             if (nto == 0) {
1150                                 to = null;
1151                             } else {
1152                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1153                                 for (int t = 0; t &lt; nto; t++)
1154                                     lb.append(poolReader.getModule(nextChar()));
1155                                 to = lb.toList();
1156                             }
1157                             opens.add(new OpensDirective(p, to, flags));
1158                         }
1159                         msym.opens = opens.toList();
1160                         directives.addAll(msym.opens);
1161 
1162                         msym.directives = directives.toList();
1163 
1164                         ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
1165                         int nuses = nextChar();
1166                         for (int i = 0; i &lt; nuses; i++) {
1167                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1168                             uses.add(new InterimUsesDirective(srvc));
1169                         }
1170                         interimUses = uses.toList();
1171 
1172                         ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
1173                         int nprovides = nextChar();
1174                         for (int p = 0; p &lt; nprovides; p++) {
1175                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1176                             int nimpls = nextChar();
1177                             ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
1178                             for (int i = 0; i &lt; nimpls; i++) {
1179                                 impls.append(poolReader.peekClassName(nextChar(), this::classNameMapper));
1180                             provides.add(new InterimProvidesDirective(srvc, impls.toList()));
1181                             }
1182                         }
1183                         interimProvides = provides.toList();
1184                     }
1185                 }
1186 
1187                 private Name classNameMapper(byte[] arr, int offset, int length) {
1188                     return names.fromUtf(ClassFile.internalize(arr, offset, length));
1189                 }
1190             },
1191 
1192             new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
1193                 @Override
1194                 protected boolean accepts(AttributeKind kind) {
1195                     return super.accepts(kind) &amp;&amp; allowModules;
1196                 }
1197                 protected void read(Symbol sym, int attrLen) {
1198                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1199                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1200                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1201                     }
1202                 }
1203             },
1204 
1205             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1206                 @Override
1207                 protected boolean accepts(AttributeKind kind) {
1208                     return super.accepts(kind) &amp;&amp; allowRecords;
1209                 }
1210                 protected void read(Symbol sym, int attrLen) {
1211                     if (sym.kind == TYP) {
1212                         sym.flags_field |= RECORD;
1213                     }
1214                     bp = bp + attrLen;
1215                 }
1216             }
1217         };
1218 
1219         for (AttributeReader r: readers)
1220             attributeReaders.put(r.name, r);
1221     }
1222 
1223     protected void readEnclosingMethodAttr(Symbol sym) {
1224         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1225         // remove sym from it&#39;s current owners scope and place it in
1226         // the scope specified by the attribute
1227         sym.owner.members().remove(sym);
1228         ClassSymbol self = (ClassSymbol)sym;
1229         ClassSymbol c = poolReader.getClass(nextChar());
1230         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1231 
1232         if (c.members_field == null || c.kind != TYP)
1233             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1234 
1235         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1236         if (nt != null &amp;&amp; m == null)
1237             throw badEnclosingMethod(self);
1238 
1239         self.name = simpleBinaryName(self.flatname, c.flatname) ;
1240         self.owner = m != null ? m : c;
1241         if (self.name.isEmpty())
1242             self.fullname = names.empty;
1243         else
1244             self.fullname = ClassSymbol.formFullName(self.name, self.owner);
1245 
1246         if (m != null) {
1247             ((ClassType)sym.type).setEnclosingType(m.type);
1248         } else if ((self.flags_field &amp; STATIC) == 0) {
1249             ((ClassType)sym.type).setEnclosingType(c.type);
1250         } else {
1251             ((ClassType)sym.type).setEnclosingType(Type.noType);
1252         }
1253         enterTypevars(self, self.type);
1254         if (!missingTypeVariables.isEmpty()) {
1255             ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();
1256             for (Type typevar : missingTypeVariables) {
1257                 typeVars.append(findTypeVar(typevar.tsym.name));
1258             }
1259             foundTypeVariables = typeVars.toList();
1260         } else {
1261             foundTypeVariables = List.nil();
1262         }
1263     }
1264 
1265     // See java.lang.Class
1266     private Name simpleBinaryName(Name self, Name enclosing) {
1267         if (!self.startsWith(enclosing)) {
1268             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1269         }
1270 
1271         String simpleBinaryName = self.toString().substring(enclosing.toString().length());
1272         if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
1273             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1274         int index = 1;
1275         while (index &lt; simpleBinaryName.length() &amp;&amp;
1276                isAsciiDigit(simpleBinaryName.charAt(index)))
1277             index++;
1278         return names.fromString(simpleBinaryName.substring(index));
1279     }
1280 
1281     private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
1282         if (nt == null)
1283             return null;
1284 
1285         MethodType type = nt.type.asMethodType();
1286 
1287         for (Symbol sym : scope.getSymbolsByName(nt.name)) {
1288             if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
1289                 return (MethodSymbol)sym;
1290         }
1291 
1292         if (nt.name != names.init)
1293             // not a constructor
1294             return null;
1295         if ((flags &amp; INTERFACE) != 0)
1296             // no enclosing instance
1297             return null;
1298         if (nt.type.getParameterTypes().isEmpty())
1299             // no parameters
1300             return null;
1301 
1302         // A constructor of an inner class.
1303         // Remove the first argument (the enclosing instance)
1304         nt = new NameAndType(nt.name, new MethodType(nt.type.getParameterTypes().tail,
1305                                  nt.type.getReturnType(),
1306                                  nt.type.getThrownTypes(),
1307                                  syms.methodClass));
1308         // Try searching again
1309         return findMethod(nt, scope, flags);
1310     }
1311 
1312     /** Similar to Types.isSameType but avoids completion */
1313     private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {
1314         List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())
1315             .prepend(types.erasure(mt1.getReturnType()));
1316         List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());
1317         while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {
1318             if (types1.head.tsym != types2.head.tsym)
1319                 return false;
1320             types1 = types1.tail;
1321             types2 = types2.tail;
1322         }
1323         return types1.isEmpty() &amp;&amp; types2.isEmpty();
1324     }
1325 
1326     /**
1327      * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
1328      * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
1329      */
1330     private static boolean isAsciiDigit(char c) {
1331         return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
1332     }
1333 
1334     /** Read member attributes.
1335      */
1336     void readMemberAttrs(Symbol sym) {
1337         readAttrs(sym, AttributeKind.MEMBER);
1338     }
1339 
1340     void readAttrs(Symbol sym, AttributeKind kind) {
1341         char ac = nextChar();
1342         for (int i = 0; i &lt; ac; i++) {
1343             Name attrName = poolReader.getName(nextChar());
1344             int attrLen = nextInt();
1345             AttributeReader r = attributeReaders.get(attrName);
1346             if (r != null &amp;&amp; r.accepts(kind))
1347                 r.read(sym, attrLen);
1348             else  {
1349                 bp = bp + attrLen;
1350             }
1351         }
1352     }
1353 
1354     private boolean readingClassAttr = false;
1355     private List&lt;Type&gt; missingTypeVariables = List.nil();
1356     private List&lt;Type&gt; foundTypeVariables = List.nil();
1357 
1358     /** Read class attributes.
1359      */
1360     void readClassAttrs(ClassSymbol c) {
1361         readAttrs(c, AttributeKind.CLASS);
1362     }
1363 
1364     /** Read code block.
1365      */
1366     Code readCode(Symbol owner) {
1367         nextChar(); // max_stack
1368         nextChar(); // max_locals
1369         final int  code_length = nextInt();
1370         bp += code_length;
1371         final char exception_table_length = nextChar();
1372         bp += exception_table_length * 8;
1373         readMemberAttrs(owner);
1374         return null;
1375     }
1376 
1377 /************************************************************************
1378  * Reading Java-language annotations
1379  ***********************************************************************/
1380 
1381     /**
1382      * Save annotations.
1383      */
1384     List&lt;CompoundAnnotationProxy&gt; readAnnotations() {
1385         int numAttributes = nextChar();
1386         ListBuffer&lt;CompoundAnnotationProxy&gt; annotations = new ListBuffer&lt;&gt;();
1387         for (int i = 0; i &lt; numAttributes; i++) {
1388             annotations.append(readCompoundAnnotation());
1389         }
1390         return annotations.toList();
1391     }
1392 
1393     /** Attach annotations.
1394      */
1395     void attachAnnotations(final Symbol sym) {
1396         attachAnnotations(sym, readAnnotations());
1397     }
1398 
1399     /**
1400      * Attach annotations.
1401      */
1402     void attachAnnotations(final Symbol sym, List&lt;CompoundAnnotationProxy&gt; annotations) {
1403         if (annotations.isEmpty()) {
1404             return;
1405         }
1406         ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1407         for (CompoundAnnotationProxy proxy : annotations) {
1408             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1409                 sym.flags_field |= PROPRIETARY;
1410             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1411                 if (profile != Profile.DEFAULT) {
1412                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1413                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1414                             Attribute.Constant c = (Attribute.Constant)v.snd;
1415                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1416                                 sym.flags_field |= NOT_IN_PROFILE;
1417                             }
1418                         }
1419                     }
1420                 }
1421             } else {
1422                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1423                     target = proxy;
1424                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1425                     repeatable = proxy;
1426                 } else if (allowValueBasedClasses &amp;&amp; sym.kind == TYP &amp;&amp; proxy.type.tsym == syms.valueBasedType.tsym) {
1427                     sym.flags_field |= VALUEBASED;
1428                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1429                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1430                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1431                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1432                     sym.flags_field |= PREVIEW_API;
1433                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1434                 }
1435                 proxies.append(proxy);
1436             }
1437         }
1438         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1439     }
1440     //where:
1441         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1442             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1443                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1444                     Attribute.Constant c = (Attribute.Constant)v.snd;
1445                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1446                         sym.flags_field |= flag;
1447                     }
1448                 }
1449             }
1450         }
1451 
1452     /** Read parameter annotations.
1453      */
1454     void readParameterAnnotations(Symbol meth) {
1455         int numParameters = buf.getByte(bp++) &amp; 0xFF;
1456         if (parameterAnnotations == null) {
1457             parameterAnnotations = new ParameterAnnotations[numParameters];
1458         } else if (parameterAnnotations.length != numParameters) {
1459             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
1460         }
1461         for (int pnum = 0; pnum &lt; numParameters; pnum++) {
1462             if (parameterAnnotations[pnum] == null) {
1463                 parameterAnnotations[pnum] = new ParameterAnnotations();
1464             }
1465             parameterAnnotations[pnum].add(readAnnotations());
1466         }
1467     }
1468 
1469     void attachTypeAnnotations(final Symbol sym) {
1470         int numAttributes = nextChar();
1471         if (numAttributes != 0) {
1472             ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1473             for (int i = 0; i &lt; numAttributes; i++)
1474                 proxies.append(readTypeAnnotation());
1475             annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));
1476         }
1477     }
1478 
1479     /** Attach the default value for an annotation element.
1480      */
1481     void attachAnnotationDefault(final Symbol sym) {
1482         final MethodSymbol meth = (MethodSymbol)sym; // only on methods
1483         final Attribute value = readAttributeValue();
1484 
1485         // The default value is set later during annotation. It might
1486         // be the case that the Symbol sym is annotated _after_ the
1487         // repeating instances that depend on this default value,
1488         // because of this we set an interim value that tells us this
1489         // element (most likely) has a default.
1490         //
1491         // Set interim value for now, reset just before we do this
1492         // properly at annotate time.
1493         meth.defaultValue = value;
1494         annotate.normal(new AnnotationDefaultCompleter(meth, value));
1495     }
1496 
1497     Type readTypeOrClassSymbol(int i) {
1498         // support preliminary jsr175-format class files
1499         if (poolReader.hasTag(i, CONSTANT_Class))
1500             return poolReader.getClass(i).type;
1501         return readTypeToProxy(i);
1502     }
1503     Type readTypeToProxy(int i) {
1504         if (currentModule.module_info == currentOwner) {
1505             return new ProxyType(i);
1506         } else {
1507             return poolReader.getType(i);
1508         }
1509     }
1510 
1511     CompoundAnnotationProxy readCompoundAnnotation() {
1512         Type t;
1513         if (currentModule.module_info == currentOwner) {
1514             int cpIndex = nextChar();
1515             t = new ProxyType(cpIndex);
1516         } else {
1517             t = readTypeOrClassSymbol(nextChar());
1518         }
1519         int numFields = nextChar();
1520         ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
1521         for (int i=0; i&lt;numFields; i++) {
1522             Name name = poolReader.getName(nextChar());
1523             Attribute value = readAttributeValue();
1524             pairs.append(new Pair&lt;&gt;(name, value));
1525         }
1526         return new CompoundAnnotationProxy(t, pairs.toList());
1527     }
1528 
1529     TypeAnnotationProxy readTypeAnnotation() {
1530         TypeAnnotationPosition position = readPosition();
1531         CompoundAnnotationProxy proxy = readCompoundAnnotation();
1532 
1533         return new TypeAnnotationProxy(proxy, position);
1534     }
1535 
1536     TypeAnnotationPosition readPosition() {
1537         int tag = nextByte(); // TargetType tag is a byte
1538 
1539         if (!TargetType.isValidTargetTypeValue(tag))
1540             throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
1541 
1542         TargetType type = TargetType.fromTargetTypeValue(tag);
1543 
1544         switch (type) {
1545         // instanceof
1546         case INSTANCEOF: {
1547             final int offset = nextChar();
1548             final TypeAnnotationPosition position =
1549                 TypeAnnotationPosition.instanceOf(readTypePath());
1550             position.offset = offset;
1551             return position;
1552         }
1553         // new expression
1554         case NEW: {
1555             final int offset = nextChar();
1556             final TypeAnnotationPosition position =
1557                 TypeAnnotationPosition.newObj(readTypePath());
1558             position.offset = offset;
1559             return position;
1560         }
1561         // constructor/method reference receiver
1562         case CONSTRUCTOR_REFERENCE: {
1563             final int offset = nextChar();
1564             final TypeAnnotationPosition position =
1565                 TypeAnnotationPosition.constructorRef(readTypePath());
1566             position.offset = offset;
1567             return position;
1568         }
1569         case METHOD_REFERENCE: {
1570             final int offset = nextChar();
1571             final TypeAnnotationPosition position =
1572                 TypeAnnotationPosition.methodRef(readTypePath());
1573             position.offset = offset;
1574             return position;
1575         }
1576         // local variable
1577         case LOCAL_VARIABLE: {
1578             final int table_length = nextChar();
1579             final int[] newLvarOffset = new int[table_length];
1580             final int[] newLvarLength = new int[table_length];
1581             final int[] newLvarIndex = new int[table_length];
1582 
1583             for (int i = 0; i &lt; table_length; ++i) {
1584                 newLvarOffset[i] = nextChar();
1585                 newLvarLength[i] = nextChar();
1586                 newLvarIndex[i] = nextChar();
1587             }
1588 
1589             final TypeAnnotationPosition position =
1590                     TypeAnnotationPosition.localVariable(readTypePath());
1591             position.lvarOffset = newLvarOffset;
1592             position.lvarLength = newLvarLength;
1593             position.lvarIndex = newLvarIndex;
1594             return position;
1595         }
1596         // resource variable
1597         case RESOURCE_VARIABLE: {
1598             final int table_length = nextChar();
1599             final int[] newLvarOffset = new int[table_length];
1600             final int[] newLvarLength = new int[table_length];
1601             final int[] newLvarIndex = new int[table_length];
1602 
1603             for (int i = 0; i &lt; table_length; ++i) {
1604                 newLvarOffset[i] = nextChar();
1605                 newLvarLength[i] = nextChar();
1606                 newLvarIndex[i] = nextChar();
1607             }
1608 
1609             final TypeAnnotationPosition position =
1610                     TypeAnnotationPosition.resourceVariable(readTypePath());
1611             position.lvarOffset = newLvarOffset;
1612             position.lvarLength = newLvarLength;
1613             position.lvarIndex = newLvarIndex;
1614             return position;
1615         }
1616         // exception parameter
1617         case EXCEPTION_PARAMETER: {
1618             final int exception_index = nextChar();
1619             final TypeAnnotationPosition position =
1620                 TypeAnnotationPosition.exceptionParameter(readTypePath());
1621             position.setExceptionIndex(exception_index);
1622             return position;
1623         }
1624         // method receiver
1625         case METHOD_RECEIVER:
1626             return TypeAnnotationPosition.methodReceiver(readTypePath());
1627         // type parameter
1628         case CLASS_TYPE_PARAMETER: {
1629             final int parameter_index = nextByte();
1630             return TypeAnnotationPosition
1631                 .typeParameter(readTypePath(), parameter_index);
1632         }
1633         case METHOD_TYPE_PARAMETER: {
1634             final int parameter_index = nextByte();
1635             return TypeAnnotationPosition
1636                 .methodTypeParameter(readTypePath(), parameter_index);
1637         }
1638         // type parameter bound
1639         case CLASS_TYPE_PARAMETER_BOUND: {
1640             final int parameter_index = nextByte();
1641             final int bound_index = nextByte();
1642             return TypeAnnotationPosition
1643                 .typeParameterBound(readTypePath(), parameter_index,
1644                                     bound_index);
1645         }
1646         case METHOD_TYPE_PARAMETER_BOUND: {
1647             final int parameter_index = nextByte();
1648             final int bound_index = nextByte();
1649             return TypeAnnotationPosition
1650                 .methodTypeParameterBound(readTypePath(), parameter_index,
1651                                           bound_index);
1652         }
1653         // class extends or implements clause
1654         case CLASS_EXTENDS: {
1655             final int type_index = nextChar();
1656             return TypeAnnotationPosition.classExtends(readTypePath(),
1657                                                        type_index);
1658         }
1659         // throws
1660         case THROWS: {
1661             final int type_index = nextChar();
1662             return TypeAnnotationPosition.methodThrows(readTypePath(),
1663                                                        type_index);
1664         }
1665         // method parameter
1666         case METHOD_FORMAL_PARAMETER: {
1667             final int parameter_index = nextByte();
1668             return TypeAnnotationPosition.methodParameter(readTypePath(),
1669                                                           parameter_index);
1670         }
1671         // type cast
1672         case CAST: {
1673             final int offset = nextChar();
1674             final int type_index = nextByte();
1675             final TypeAnnotationPosition position =
1676                 TypeAnnotationPosition.typeCast(readTypePath(), type_index);
1677             position.offset = offset;
1678             return position;
1679         }
1680         // method/constructor/reference type argument
1681         case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: {
1682             final int offset = nextChar();
1683             final int type_index = nextByte();
1684             final TypeAnnotationPosition position = TypeAnnotationPosition
1685                 .constructorInvocationTypeArg(readTypePath(), type_index);
1686             position.offset = offset;
1687             return position;
1688         }
1689         case METHOD_INVOCATION_TYPE_ARGUMENT: {
1690             final int offset = nextChar();
1691             final int type_index = nextByte();
1692             final TypeAnnotationPosition position = TypeAnnotationPosition
1693                 .methodInvocationTypeArg(readTypePath(), type_index);
1694             position.offset = offset;
1695             return position;
1696         }
1697         case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: {
1698             final int offset = nextChar();
1699             final int type_index = nextByte();
1700             final TypeAnnotationPosition position = TypeAnnotationPosition
1701                 .constructorRefTypeArg(readTypePath(), type_index);
1702             position.offset = offset;
1703             return position;
1704         }
1705         case METHOD_REFERENCE_TYPE_ARGUMENT: {
1706             final int offset = nextChar();
1707             final int type_index = nextByte();
1708             final TypeAnnotationPosition position = TypeAnnotationPosition
1709                 .methodRefTypeArg(readTypePath(), type_index);
1710             position.offset = offset;
1711             return position;
1712         }
1713         // We don&#39;t need to worry about these
1714         case METHOD_RETURN:
1715             return TypeAnnotationPosition.methodReturn(readTypePath());
1716         case FIELD:
1717             return TypeAnnotationPosition.field(readTypePath());
1718         case UNKNOWN:
1719             throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
1720         default:
1721             throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);
1722         }
1723     }
1724 
1725     List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
1726         int len = nextByte();
1727         ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();
1728         for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)
1729             loc = loc.append(nextByte());
1730 
1731         return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
1732 
1733     }
1734 
1735     /**
1736      * Helper function to read an optional pool entry (with given function); this is used while parsing
1737      * InnerClasses and EnclosingMethod attributes, as well as when parsing supertype descriptor,
1738      * as per JVMS.
1739      */
1740     &lt;Z&gt; Z optPoolEntry(int index, IntFunction&lt;Z&gt; poolFunc, Z defaultValue) {
1741         return (index == 0) ?
1742                 defaultValue :
1743                 poolFunc.apply(index);
1744     }
1745 
1746     Attribute readAttributeValue() {
1747         char c = (char) buf.getByte(bp++);
1748         switch (c) {
1749         case &#39;B&#39;:
1750             return new Attribute.Constant(syms.byteType, poolReader.getConstant(nextChar()));
1751         case &#39;C&#39;:
1752             return new Attribute.Constant(syms.charType, poolReader.getConstant(nextChar()));
1753         case &#39;D&#39;:
1754             return new Attribute.Constant(syms.doubleType, poolReader.getConstant(nextChar()));
1755         case &#39;F&#39;:
1756             return new Attribute.Constant(syms.floatType, poolReader.getConstant(nextChar()));
1757         case &#39;I&#39;:
1758             return new Attribute.Constant(syms.intType, poolReader.getConstant(nextChar()));
1759         case &#39;J&#39;:
1760             return new Attribute.Constant(syms.longType, poolReader.getConstant(nextChar()));
1761         case &#39;S&#39;:
1762             return new Attribute.Constant(syms.shortType, poolReader.getConstant(nextChar()));
1763         case &#39;Z&#39;:
1764             return new Attribute.Constant(syms.booleanType, poolReader.getConstant(nextChar()));
1765         case &#39;s&#39;:
1766             return new Attribute.Constant(syms.stringType, poolReader.getName(nextChar()).toString());
1767         case &#39;e&#39;:
1768             return new EnumAttributeProxy(readTypeToProxy(nextChar()), poolReader.getName(nextChar()));
1769         case &#39;c&#39;:
1770             return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
1771         case &#39;[&#39;: {
1772             int n = nextChar();
1773             ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
1774             for (int i=0; i&lt;n; i++)
1775                 l.append(readAttributeValue());
1776             return new ArrayAttributeProxy(l.toList());
1777         }
1778         case &#39;@&#39;:
1779             return readCompoundAnnotation();
1780         default:
1781             throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);
1782         }
1783     }
1784 
1785     interface ProxyVisitor extends Attribute.Visitor {
1786         void visitEnumAttributeProxy(EnumAttributeProxy proxy);
1787         void visitClassAttributeProxy(ClassAttributeProxy proxy);
1788         void visitArrayAttributeProxy(ArrayAttributeProxy proxy);
1789         void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy);
1790     }
1791 
1792     static class EnumAttributeProxy extends Attribute {
1793         Type enumType;
1794         Name enumerator;
1795         public EnumAttributeProxy(Type enumType, Name enumerator) {
1796             super(null);
1797             this.enumType = enumType;
1798             this.enumerator = enumerator;
1799         }
1800         public void accept(Visitor v) { ((ProxyVisitor)v).visitEnumAttributeProxy(this); }
1801         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1802         public String toString() {
1803             return &quot;/*proxy enum*/&quot; + enumType + &quot;.&quot; + enumerator;
1804         }
1805     }
1806 
1807     static class ClassAttributeProxy extends Attribute {
1808         Type classType;
1809         public ClassAttributeProxy(Type classType) {
1810             super(null);
1811             this.classType = classType;
1812         }
1813         public void accept(Visitor v) { ((ProxyVisitor)v).visitClassAttributeProxy(this); }
1814         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1815         public String toString() {
1816             return &quot;/*proxy class*/&quot; + classType + &quot;.class&quot;;
1817         }
1818     }
1819 
1820     static class ArrayAttributeProxy extends Attribute {
1821         List&lt;Attribute&gt; values;
1822         ArrayAttributeProxy(List&lt;Attribute&gt; values) {
1823             super(null);
1824             this.values = values;
1825         }
1826         public void accept(Visitor v) { ((ProxyVisitor)v).visitArrayAttributeProxy(this); }
1827         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1828         public String toString() {
1829             return &quot;{&quot; + values + &quot;}&quot;;
1830         }
1831     }
1832 
1833     /** A temporary proxy representing a compound attribute.
1834      */
1835     static class CompoundAnnotationProxy extends Attribute {
1836         final List&lt;Pair&lt;Name,Attribute&gt;&gt; values;
1837         public CompoundAnnotationProxy(Type type,
1838                                       List&lt;Pair&lt;Name,Attribute&gt;&gt; values) {
1839             super(type);
1840             this.values = values;
1841         }
1842         public void accept(Visitor v) { ((ProxyVisitor)v).visitCompoundAnnotationProxy(this); }
1843         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1844         public String toString() {
1845             StringBuilder buf = new StringBuilder();
1846             buf.append(&quot;@&quot;);
1847             buf.append(type.tsym.getQualifiedName());
1848             buf.append(&quot;/*proxy*/{&quot;);
1849             boolean first = true;
1850             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; v = values;
1851                  v.nonEmpty(); v = v.tail) {
1852                 Pair&lt;Name,Attribute&gt; value = v.head;
1853                 if (!first) buf.append(&quot;,&quot;);
1854                 first = false;
1855                 buf.append(value.fst);
1856                 buf.append(&quot;=&quot;);
1857                 buf.append(value.snd);
1858             }
1859             buf.append(&quot;}&quot;);
1860             return buf.toString();
1861         }
1862     }
1863 
1864     /** A temporary proxy representing a type annotation.
1865      */
1866     static class TypeAnnotationProxy {
1867         final CompoundAnnotationProxy compound;
1868         final TypeAnnotationPosition position;
1869         public TypeAnnotationProxy(CompoundAnnotationProxy compound,
1870                 TypeAnnotationPosition position) {
1871             this.compound = compound;
1872             this.position = position;
1873         }
1874     }
1875 
1876     class AnnotationDeproxy implements ProxyVisitor {
1877         private ClassSymbol requestingOwner;
1878 
1879         AnnotationDeproxy(ClassSymbol owner) {
1880             this.requestingOwner = owner;
1881         }
1882 
1883         List&lt;Attribute.Compound&gt; deproxyCompoundList(List&lt;CompoundAnnotationProxy&gt; pl) {
1884             // also must fill in types!!!!
1885             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
1886             for (List&lt;CompoundAnnotationProxy&gt; l = pl; l.nonEmpty(); l=l.tail) {
1887                 buf.append(deproxyCompound(l.head));
1888             }
1889             return buf.toList();
1890         }
1891 
1892         Attribute.Compound deproxyCompound(CompoundAnnotationProxy a) {
1893             Type annotationType = resolvePossibleProxyType(a.type);
1894             ListBuffer&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; buf = new ListBuffer&lt;&gt;();
1895             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; l = a.values;
1896                  l.nonEmpty();
1897                  l = l.tail) {
1898                 MethodSymbol meth = findAccessMethod(annotationType, l.head.fst);
1899                 buf.append(new Pair&lt;&gt;(meth, deproxy(meth.type.getReturnType(), l.head.snd)));
1900             }
1901             return new Attribute.Compound(annotationType, buf.toList());
1902         }
1903 
1904         MethodSymbol findAccessMethod(Type container, Name name) {
1905             CompletionFailure failure = null;
1906             try {
1907                 for (Symbol sym : container.tsym.members().getSymbolsByName(name)) {
1908                     if (sym.kind == MTH &amp;&amp; sym.type.getParameterTypes().length() == 0)
1909                         return (MethodSymbol) sym;
1910                 }
1911             } catch (CompletionFailure ex) {
1912                 failure = ex;
1913             }
1914             // The method wasn&#39;t found: emit a warning and recover
1915             JavaFileObject prevSource = log.useSource(requestingOwner.classfile);
1916             try {
1917                 if (lintClassfile) {
1918                     if (failure == null) {
1919                         log.warning(Warnings.AnnotationMethodNotFound(container, name));
1920                     } else {
1921                         log.warning(Warnings.AnnotationMethodNotFoundReason(container,
1922                                                                             name,
1923                                                                             failure.getDetailValue()));//diagnostic, if present
1924                     }
1925                 }
1926             } finally {
1927                 log.useSource(prevSource);
1928             }
1929             // Construct a new method type and symbol.  Use bottom
1930             // type (typeof null) as return type because this type is
1931             // a subtype of all reference types and can be converted
1932             // to primitive types by unboxing.
1933             MethodType mt = new MethodType(List.nil(),
1934                                            syms.botType,
1935                                            List.nil(),
1936                                            syms.methodClass);
1937             return new MethodSymbol(PUBLIC | ABSTRACT, name, mt, container.tsym);
1938         }
1939 
1940         Attribute result;
1941         Type type;
1942         Attribute deproxy(Type t, Attribute a) {
1943             Type oldType = type;
1944             try {
1945                 type = t;
1946                 a.accept(this);
1947                 return result;
1948             } finally {
1949                 type = oldType;
1950             }
1951         }
1952 
1953         // implement Attribute.Visitor below
1954 
1955         public void visitConstant(Attribute.Constant value) {
1956             // assert value.type == type;
1957             result = value;
1958         }
1959 
1960         public void visitClass(Attribute.Class clazz) {
1961             result = clazz;
1962         }
1963 
1964         public void visitEnum(Attribute.Enum e) {
1965             throw new AssertionError(); // shouldn&#39;t happen
1966         }
1967 
1968         public void visitCompound(Attribute.Compound compound) {
1969             throw new AssertionError(); // shouldn&#39;t happen
1970         }
1971 
1972         public void visitArray(Attribute.Array array) {
1973             throw new AssertionError(); // shouldn&#39;t happen
1974         }
1975 
1976         public void visitError(Attribute.Error e) {
1977             throw new AssertionError(); // shouldn&#39;t happen
1978         }
1979 
1980         public void visitEnumAttributeProxy(EnumAttributeProxy proxy) {
1981             // type.tsym.flatName() should == proxy.enumFlatName
1982             Type enumType = resolvePossibleProxyType(proxy.enumType);
1983             TypeSymbol enumTypeSym = enumType.tsym;
1984             VarSymbol enumerator = null;
1985             CompletionFailure failure = null;
1986             try {
1987                 for (Symbol sym : enumTypeSym.members().getSymbolsByName(proxy.enumerator)) {
1988                     if (sym.kind == VAR) {
1989                         enumerator = (VarSymbol)sym;
1990                         break;
1991                     }
1992                 }
1993             }
1994             catch (CompletionFailure ex) {
1995                 failure = ex;
1996             }
1997             if (enumerator == null) {
1998                 if (failure != null) {
1999                     log.warning(Warnings.UnknownEnumConstantReason(currentClassFile,
2000                                                                    enumTypeSym,
2001                                                                    proxy.enumerator,
2002                                                                    failure.getDiagnostic()));
2003                 } else {
2004                     log.warning(Warnings.UnknownEnumConstant(currentClassFile,
2005                                                              enumTypeSym,
2006                                                              proxy.enumerator));
2007                 }
2008                 result = new Attribute.Enum(enumTypeSym.type,
2009                         new VarSymbol(0, proxy.enumerator, syms.botType, enumTypeSym));
2010             } else {
2011                 result = new Attribute.Enum(enumTypeSym.type, enumerator);
2012             }
2013         }
2014 
2015         @Override
2016         public void visitClassAttributeProxy(ClassAttributeProxy proxy) {
2017             Type classType = resolvePossibleProxyType(proxy.classType);
2018             result = new Attribute.Class(types, classType);
2019         }
2020 
2021         public void visitArrayAttributeProxy(ArrayAttributeProxy proxy) {
2022             int length = proxy.values.length();
2023             Attribute[] ats = new Attribute[length];
2024             Type elemtype = types.elemtype(type);
2025             int i = 0;
2026             for (List&lt;Attribute&gt; p = proxy.values; p.nonEmpty(); p = p.tail) {
2027                 ats[i++] = deproxy(elemtype, p.head);
2028             }
2029             result = new Attribute.Array(type, ats);
2030         }
2031 
2032         public void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy) {
2033             result = deproxyCompound(proxy);
2034         }
2035 
2036         Type resolvePossibleProxyType(Type t) {
2037             if (t instanceof ProxyType) {
2038                 Assert.check(requestingOwner.owner.kind == MDL);
2039                 ModuleSymbol prevCurrentModule = currentModule;
2040                 currentModule = (ModuleSymbol) requestingOwner.owner;
2041                 try {
2042                     return ((ProxyType) t).resolve();
2043                 } finally {
2044                     currentModule = prevCurrentModule;
2045                 }
2046             } else {
2047                 return t;
2048             }
2049         }
2050     }
2051 
2052     class AnnotationDefaultCompleter extends AnnotationDeproxy implements Runnable {
2053         final MethodSymbol sym;
2054         final Attribute value;
2055         final JavaFileObject classFile = currentClassFile;
2056 
2057         AnnotationDefaultCompleter(MethodSymbol sym, Attribute value) {
2058             super(currentOwner.kind == MTH
2059                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2060             this.sym = sym;
2061             this.value = value;
2062         }
2063 
2064         @Override
2065         public void run() {
2066             JavaFileObject previousClassFile = currentClassFile;
2067             try {
2068                 // Reset the interim value set earlier in
2069                 // attachAnnotationDefault().
2070                 sym.defaultValue = null;
2071                 currentClassFile = classFile;
2072                 sym.defaultValue = deproxy(sym.type.getReturnType(), value);
2073             } finally {
2074                 currentClassFile = previousClassFile;
2075             }
2076         }
2077 
2078         @Override
2079         public String toString() {
2080             return &quot; ClassReader store default for &quot; + sym.owner + &quot;.&quot; + sym + &quot; is &quot; + value;
2081         }
2082     }
2083 
2084     class AnnotationCompleter extends AnnotationDeproxy implements Runnable {
2085         final Symbol sym;
2086         final List&lt;CompoundAnnotationProxy&gt; l;
2087         final JavaFileObject classFile;
2088 
2089         AnnotationCompleter(Symbol sym, List&lt;CompoundAnnotationProxy&gt; l) {
2090             super(currentOwner.kind == MTH
2091                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2092             if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
2093                 this.sym = sym.owner;
2094             } else {
2095                 this.sym = sym;
2096             }
2097             this.l = l;
2098             this.classFile = currentClassFile;
2099         }
2100 
2101         @Override
2102         public void run() {
2103             JavaFileObject previousClassFile = currentClassFile;
2104             try {
2105                 currentClassFile = classFile;
2106                 List&lt;Attribute.Compound&gt; newList = deproxyCompoundList(l);
2107                 for (Attribute.Compound attr : newList) {
2108                     if (attr.type.tsym == syms.deprecatedType.tsym) {
2109                         sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
2110                         Attribute forRemoval = attr.member(names.forRemoval);
2111                         if (forRemoval instanceof Attribute.Constant) {
2112                             Attribute.Constant c = (Attribute.Constant) forRemoval;
2113                             if (c.type == syms.booleanType &amp;&amp; ((Integer) c.value) != 0) {
2114                                 sym.flags_field |= DEPRECATED_REMOVAL;
2115                             }
2116                         }
2117                     }
2118                 }
2119                 if (sym.annotationsPendingCompletion()) {
2120                     sym.setDeclarationAttributes(newList);
2121                 } else {
2122                     sym.appendAttributes(newList);
2123                 }
2124             } finally {
2125                 currentClassFile = previousClassFile;
2126             }
2127         }
2128 
2129         @Override
2130         public String toString() {
2131             return &quot; ClassReader annotate &quot; + sym.owner + &quot;.&quot; + sym + &quot; with &quot; + l;
2132         }
2133     }
2134 
2135     class TypeAnnotationCompleter extends AnnotationCompleter {
2136 
2137         List&lt;TypeAnnotationProxy&gt; proxies;
2138 
2139         TypeAnnotationCompleter(Symbol sym,
2140                 List&lt;TypeAnnotationProxy&gt; proxies) {
2141             super(sym, List.nil());
2142             this.proxies = proxies;
2143         }
2144 
2145         List&lt;Attribute.TypeCompound&gt; deproxyTypeCompoundList(List&lt;TypeAnnotationProxy&gt; proxies) {
2146             ListBuffer&lt;Attribute.TypeCompound&gt; buf = new ListBuffer&lt;&gt;();
2147             for (TypeAnnotationProxy proxy: proxies) {
2148                 Attribute.Compound compound = deproxyCompound(proxy.compound);
2149                 Attribute.TypeCompound typeCompound = new Attribute.TypeCompound(compound, proxy.position);
2150                 buf.add(typeCompound);
2151             }
2152             return buf.toList();
2153         }
2154 
2155         @Override
2156         public void run() {
2157             JavaFileObject previousClassFile = currentClassFile;
2158             try {
2159                 currentClassFile = classFile;
2160                 List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
2161                 sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
2162             } finally {
2163                 currentClassFile = previousClassFile;
2164             }
2165         }
2166     }
2167 
2168 
2169 /************************************************************************
2170  * Reading Symbols
2171  ***********************************************************************/
2172 
2173     /** Read a field.
2174      */
2175     VarSymbol readField() {
2176         long flags = adjustFieldFlags(nextChar());
2177         Name name = poolReader.getName(nextChar());
2178         Type type = poolReader.getType(nextChar());
2179         VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
2180         readMemberAttrs(v);
2181         return v;
2182     }
2183 
2184     /** Read a method.
2185      */
2186     MethodSymbol readMethod() {
2187         long flags = adjustMethodFlags(nextChar());
2188         Name name = poolReader.getName(nextChar());
2189         Type type = poolReader.getType(nextChar());
2190         if (currentOwner.isInterface() &amp;&amp;
2191                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2192             if (majorVersion &gt; Version.V52.major ||
2193                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2194                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2195                     currentOwner.flags_field |= DEFAULT;
2196                     flags |= DEFAULT | ABSTRACT;
2197                 }
2198             } else {
2199                 //protect against ill-formed classfiles
2200                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2201                                    Integer.toString(majorVersion),
2202                                    Integer.toString(minorVersion));
2203             }
2204         }
2205         if (name == names.init &amp;&amp; ((flags &amp; STATIC) != 0)) {
2206             flags &amp;= ~STATIC;
2207             type = new MethodType(type.getParameterTypes(),
2208                     syms.voidType,
2209                     type.getThrownTypes(),
2210                     syms.methodClass);
2211         }
2212         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2213             // Sometimes anonymous classes don&#39;t have an outer
2214             // instance, however, there is no reliable way to tell so
2215             // we never strip this$n
2216             // ditto for local classes. Local classes that have an enclosing method set
2217             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2218             // enclosing method (i.e. from initializers) will pass that check.
2219             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2220             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2221                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2222                                       type.getReturnType(),
2223                                       type.getThrownTypes(),
2224                                       syms.methodClass);
2225         }
2226         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2227         if (types.isSignaturePolymorphic(m)) {
2228             m.flags_field |= SIGNATURE_POLYMORPHIC;
2229         }
2230         if (saveParameterNames)
2231             initParameterNames(m);
2232         Symbol prevOwner = currentOwner;
2233         currentOwner = m;
2234         try {
2235             readMemberAttrs(m);
2236         } finally {
2237             currentOwner = prevOwner;
2238         }
2239         setParameters(m, type);
2240 
2241         if ((flags &amp; VARARGS) != 0) {
2242             final Type last = type.getParameterTypes().last();
2243             if (last == null || !last.hasTag(ARRAY)) {
2244                 m.flags_field &amp;= ~VARARGS;
2245                 throw badClassFile(&quot;malformed.vararg.method&quot;, m);
2246             }
2247         }
2248 
2249         return m;
2250     }
2251 
2252     private List&lt;Type&gt; adjustMethodParams(long flags, List&lt;Type&gt; args) {
2253         if (args.isEmpty()) {
2254             return args;
2255         }
2256         boolean isVarargs = (flags &amp; VARARGS) != 0;
2257         if (isVarargs) {
2258             Type varargsElem = args.last();
2259             ListBuffer&lt;Type&gt; adjustedArgs = new ListBuffer&lt;&gt;();
2260             for (Type t : args) {
2261                 adjustedArgs.append(t != varargsElem ?
2262                     t :
2263                     ((ArrayType)t).makeVarargs());
2264             }
2265             args = adjustedArgs.toList();
2266         }
2267         return args.tail;
2268     }
2269 
2270     /**
2271      * Init the parameter names array.
2272      * Parameter names are currently inferred from the names in the
2273      * LocalVariableTable attributes of a Code attribute.
2274      * (Note: this means parameter names are currently not available for
2275      * methods without a Code attribute.)
2276      * This method initializes an array in which to store the name indexes
2277      * of parameter names found in LocalVariableTable attributes. It is
2278      * slightly supersized to allow for additional slots with a start_pc of 0.
2279      */
2280     void initParameterNames(MethodSymbol sym) {
2281         // make allowance for synthetic parameters.
2282         final int excessSlots = 4;
2283         int expectedParameterSlots =
2284                 Code.width(sym.type.getParameterTypes()) + excessSlots;
2285         if (parameterNameIndices == null
2286                 || parameterNameIndices.length &lt; expectedParameterSlots) {
2287             parameterNameIndices = new int[expectedParameterSlots];
2288         } else
2289             Arrays.fill(parameterNameIndices, 0);
2290         haveParameterNameIndices = false;
2291         sawMethodParameters = false;
2292     }
2293 
2294     /**
2295      * Set the parameters for a method symbol, including any names and
2296      * annotations that were read.
2297      *
2298      * &lt;p&gt;The type of the symbol may have changed while reading the
2299      * method attributes (see the Signature attribute). This may be
2300      * because of generic information or because anonymous synthetic
2301      * parameters were added.   The original type (as read from the
2302      * method descriptor) is used to help guess the existence of
2303      * anonymous synthetic parameters.
2304      */
2305     void setParameters(MethodSymbol sym, Type jvmType) {
2306         // If we get parameter names from MethodParameters, then we
2307         // don&#39;t need to skip.
2308         int firstParam = 0;
2309         if (!sawMethodParameters) {
2310             firstParam = ((sym.flags() &amp; STATIC) == 0) ? 1 : 0;
2311             // the code in readMethod may have skipped the first
2312             // parameter when setting up the MethodType. If so, we
2313             // make a corresponding allowance here for the position of
2314             // the first parameter.  Note that this assumes the
2315             // skipped parameter has a width of 1 -- i.e. it is not
2316             // a double width type (long or double.)
2317             if (sym.name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2318                 // Sometimes anonymous classes don&#39;t have an outer
2319                 // instance, however, there is no reliable way to tell so
2320                 // we never strip this$n
2321                 if (!currentOwner.name.isEmpty())
2322                     firstParam += 1;
2323             }
2324 
2325             if (sym.type != jvmType) {
2326                 // reading the method attributes has caused the
2327                 // symbol&#39;s type to be changed. (i.e. the Signature
2328                 // attribute.)  This may happen if there are hidden
2329                 // (synthetic) parameters in the descriptor, but not
2330                 // in the Signature.  The position of these hidden
2331                 // parameters is unspecified; for now, assume they are
2332                 // at the beginning, and so skip over them. The
2333                 // primary case for this is two hidden parameters
2334                 // passed into Enum constructors.
2335                 int skip = Code.width(jvmType.getParameterTypes())
2336                         - Code.width(sym.type.getParameterTypes());
2337                 firstParam += skip;
2338             }
2339         }
2340         Set&lt;Name&gt; paramNames = new HashSet&lt;&gt;();
2341         ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
2342         int nameIndex = firstParam;
2343         int annotationIndex = 0;
2344         for (Type t: sym.type.getParameterTypes()) {
2345             VarSymbol param = parameter(nameIndex, t, sym, paramNames);
2346             params.append(param);
2347             if (parameterAnnotations != null) {
2348                 ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
2349                 if (annotations != null &amp;&amp; annotations.proxies != null
2350                         &amp;&amp; !annotations.proxies.isEmpty()) {
2351                     annotate.normal(new AnnotationCompleter(param, annotations.proxies));
2352                 }
2353             }
2354             nameIndex += sawMethodParameters ? 1 : Code.width(t);
2355             annotationIndex++;
2356         }
2357         if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
2358             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
2359         }
2360         Assert.checkNull(sym.params);
2361         sym.params = params.toList();
2362         parameterAnnotations = null;
2363         parameterNameIndices = null;
2364     }
2365 
2366 
2367     // Returns the name for the parameter at position &#39;index&#39;, either using
2368     // names read from the MethodParameters, or by synthesizing a name that
2369     // is not on the &#39;exclude&#39; list.
2370     private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set&lt;Name&gt; exclude) {
2371         long flags = PARAMETER;
2372         Name argName;
2373         if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
2374                 &amp;&amp; parameterNameIndices[index] != 0) {
2375             argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);
2376             flags |= NAME_FILLED;
2377         } else {
2378             String prefix = &quot;arg&quot;;
2379             while (true) {
2380                 argName = names.fromString(prefix + exclude.size());
2381                 if (!exclude.contains(argName))
2382                     break;
2383                 prefix += &quot;$&quot;;
2384             }
2385         }
2386         exclude.add(argName);
2387         return new ParamSymbol(flags, argName, t, owner);
2388     }
2389 
2390     /**
2391      * skip n bytes
2392      */
2393     void skipBytes(int n) {
2394         bp = bp + n;
2395     }
2396 
2397     /** Skip a field or method
2398      */
2399     void skipMember() {
2400         bp = bp + 6;
2401         char ac = nextChar();
2402         for (int i = 0; i &lt; ac; i++) {
2403             bp = bp + 2;
2404             int attrLen = nextInt();
2405             bp = bp + attrLen;
2406         }
2407     }
2408 
2409     void skipInnerClasses() {
2410         int n = nextChar();
2411         for (int i = 0; i &lt; n; i++) {
2412             nextChar();
2413             nextChar();
2414             nextChar();
2415             nextChar();
2416         }
2417     }
2418 
2419     /** Enter type variables of this classtype and all enclosing ones in
2420      *  `typevars&#39;.
2421      */
2422     protected void enterTypevars(Symbol sym, Type t) {
2423         if (t.getEnclosingType() != null) {
2424             if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
2425                 enterTypevars(sym.owner, t.getEnclosingType());
2426             }
2427         } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
2428             enterTypevars(sym.owner, sym.owner.type);
2429         }
2430         for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
2431             typevars.enter(xs.head.tsym);
2432         }
2433     }
2434 
2435     protected ClassSymbol enterClass(Name name) {
2436         return syms.enterClass(currentModule, name);
2437     }
2438 
2439     protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
2440         return syms.enterClass(currentModule, name, owner);
2441     }
2442 
2443     /** Read contents of a given class symbol `c&#39;. Both external and internal
2444      *  versions of an inner class are read.
2445      */
2446     void readClass(ClassSymbol c) {
2447         ClassType ct = (ClassType)c.type;
2448 
2449         // allocate scope for members
2450         c.members_field = WriteableScope.create(c);
2451 
2452         // prepare type variable table
2453         typevars = typevars.dup(currentOwner);
2454         if (ct.getEnclosingType().hasTag(CLASS))
2455             enterTypevars(c.owner, ct.getEnclosingType());
2456 
2457         // read flags, or skip if this is an inner class
2458         long f = nextChar();
2459         long flags = adjustClassFlags(f);
2460         if ((flags &amp; MODULE) == 0) {
2461             if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
2462             // read own class name and check that it matches
2463             currentModule = c.packge().modle;
2464             ClassSymbol self = poolReader.getClass(nextChar());
2465             if (c != self) {
2466                 throw badClassFile(&quot;class.file.wrong.class&quot;,
2467                                    self.flatname);
2468             }
2469         } else {
2470             if (majorVersion &lt; Version.V53.major) {
2471                 throw badClassFile(&quot;anachronistic.module.info&quot;,
2472                         Integer.toString(majorVersion),
2473                         Integer.toString(minorVersion));
2474             }
2475             c.flags_field = flags;
2476             currentModule = (ModuleSymbol) c.owner;
2477             int this_class = nextChar();
2478             // temp, no check on this_class
2479         }
2480 
2481         // class attributes must be read before class
2482         // skip ahead to read class attributes
2483         int startbp = bp;
2484         nextChar();
2485         char interfaceCount = nextChar();
2486         bp += interfaceCount * 2;
2487         char fieldCount = nextChar();
2488         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2489         char methodCount = nextChar();
2490         for (int i = 0; i &lt; methodCount; i++) skipMember();
2491         readClassAttrs(c);
2492 
2493         // reset and read rest of classinfo
2494         bp = startbp;
2495         int n = nextChar();
2496         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2497             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2498         }
2499         if (ct.supertype_field == null)
2500             ct.supertype_field =
2501                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2502         n = nextChar();
2503         List&lt;Type&gt; is = List.nil();
2504         for (int i = 0; i &lt; n; i++) {
2505             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2506             is = is.prepend(_inter);
2507         }
2508         if (ct.interfaces_field == null)
2509             ct.interfaces_field = is.reverse();
2510 
2511         Assert.check(fieldCount == nextChar());
2512         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
2513         Assert.check(methodCount == nextChar());
2514         for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
2515 
2516         typevars = typevars.leave();
2517     }
2518 
2519     /** Read inner class info. For each inner/outer pair allocate a
2520      *  member class.
2521      */
2522     void readInnerClasses(ClassSymbol c) {
2523         int n = nextChar();
2524         for (int i = 0; i &lt; n; i++) {
2525             nextChar(); // skip inner class symbol
2526             int outerIdx = nextChar();
2527             int nameIdx = nextChar();
2528             ClassSymbol outer = optPoolEntry(outerIdx, poolReader::getClass, null);
2529             Name name = optPoolEntry(nameIdx, poolReader::getName, names.empty);
2530             if (name == null) name = names.empty;
2531             long flags = adjustClassFlags(nextChar());
2532             if (outer != null) { // we have a member class
2533                 if (name == names.empty)
2534                     name = names.one;
2535                 ClassSymbol member = enterClass(name, outer);
2536                 if ((flags &amp; STATIC) == 0) {
2537                     ((ClassType)member.type).setEnclosingType(outer.type);
2538                     if (member.erasure_field != null)
2539                         ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));
2540                 }
2541                 if (c == outer) {
2542                     member.flags_field = flags;
2543                     enterMember(c, member);
2544                 }
2545             }
2546         }
2547     }
2548 
2549     /** Read a class definition from the bytes in buf.
2550      */
2551     private void readClassBuffer(ClassSymbol c) throws IOException {
2552         int magic = nextInt();
2553         if (magic != JAVA_MAGIC)
2554             throw badClassFile(&quot;illegal.start.of.class.file&quot;);
2555 
2556         minorVersion = nextChar();
2557         majorVersion = nextChar();
2558         int maxMajor = Version.MAX().major;
2559         int maxMinor = Version.MAX().minor;
2560         if (majorVersion &gt; maxMajor ||
2561             majorVersion * 1000 + minorVersion &lt;
2562             Version.MIN().major * 1000 + Version.MIN().minor) {
2563             if (majorVersion == (maxMajor + 1))
2564                 log.warning(Warnings.BigMajorVersion(currentClassFile,
2565                                                      majorVersion,
2566                                                      maxMajor));
2567             else
2568                 throw badClassFile(&quot;wrong.version&quot;,
2569                                    Integer.toString(majorVersion),
2570                                    Integer.toString(minorVersion),
2571                                    Integer.toString(maxMajor),
2572                                    Integer.toString(maxMinor));
2573         }
2574 
2575         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2576             if (!preview.isEnabled()) {
2577                 log.error(preview.disabledError(currentClassFile, majorVersion));
2578             } else {
2579                 preview.warnPreview(c.classfile, majorVersion);
2580             }
2581         }
2582 
2583         poolReader = new PoolReader(this, names, syms);
2584         bp = poolReader.readPool(buf, bp);
2585         if (signatureBuffer.length &lt; bp) {
2586             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2587             signatureBuffer = new byte[ns];
2588         }
2589         readClass(c);
2590     }
2591 
2592     public void readClassFile(ClassSymbol c) {
2593         currentOwner = c;
2594         currentClassFile = c.classfile;
2595         warnedAttrs.clear();
2596         filling = true;
2597         target = null;
2598         repeatable = null;
2599         try {
2600             bp = 0;
2601             buf.reset();
2602             buf.appendStream(c.classfile.openInputStream());
2603             readClassBuffer(c);
2604             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2605                 List&lt;Type&gt; missing = missingTypeVariables;
2606                 List&lt;Type&gt; found = foundTypeVariables;
2607                 missingTypeVariables = List.nil();
2608                 foundTypeVariables = List.nil();
2609                 interimUses = List.nil();
2610                 interimProvides = List.nil();
2611                 filling = false;
2612                 ClassType ct = (ClassType)currentOwner.type;
2613                 ct.supertype_field =
2614                     types.subst(ct.supertype_field, missing, found);
2615                 ct.interfaces_field =
2616                     types.subst(ct.interfaces_field, missing, found);
2617                 ct.typarams_field =
2618                     types.substBounds(ct.typarams_field, missing, found);
2619                 for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {
2620                     types.head.tsym.type = types.head;
2621                 }
2622             } else if (missingTypeVariables.isEmpty() !=
2623                        foundTypeVariables.isEmpty()) {
2624                 Name name = missingTypeVariables.head.tsym.name;
2625                 throw badClassFile(&quot;undecl.type.var&quot;, name);
2626             }
2627 
2628             if ((c.flags_field &amp; Flags.ANNOTATION) != 0) {
2629                 c.setAnnotationTypeMetadata(new AnnotationTypeMetadata(c, new CompleterDeproxy(c, target, repeatable)));
2630             } else {
2631                 c.setAnnotationTypeMetadata(AnnotationTypeMetadata.notAnAnnotationType());
2632             }
2633 
2634             if (c == currentModule.module_info) {
2635                 if (interimUses.nonEmpty() || interimProvides.nonEmpty()) {
2636                     Assert.check(currentModule.isCompleted());
2637                     currentModule.usesProvidesCompleter =
2638                             new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
2639                 } else {
2640                     currentModule.uses = List.nil();
2641                     currentModule.provides = List.nil();
2642                 }
2643             }
2644         } catch (IOException | ClosedFileSystemException ex) {
2645             throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
2646         } catch (ArrayIndexOutOfBoundsException ex) {
2647             throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
2648         } finally {
2649             interimUses = List.nil();
2650             interimProvides = List.nil();
2651             missingTypeVariables = List.nil();
2652             foundTypeVariables = List.nil();
2653             filling = false;
2654         }
2655     }
2656 
2657     /** We can only read a single class file at a time; this
2658      *  flag keeps track of when we are currently reading a class
2659      *  file.
2660      */
2661     public boolean filling = false;
2662 
2663 /************************************************************************
2664  * Adjusting flags
2665  ***********************************************************************/
2666 
2667     long adjustFieldFlags(long flags) {
2668         return flags;
2669     }
2670 
2671     long adjustMethodFlags(long flags) {
2672         if ((flags &amp; ACC_BRIDGE) != 0) {
2673             flags &amp;= ~ACC_BRIDGE;
2674             flags |= BRIDGE;
2675         }
2676         if ((flags &amp; ACC_VARARGS) != 0) {
2677             flags &amp;= ~ACC_VARARGS;
2678             flags |= VARARGS;
2679         }
2680         return flags;
2681     }
2682 
2683     long adjustClassFlags(long flags) {
2684         if ((flags &amp; ACC_MODULE) != 0) {
2685             flags &amp;= ~ACC_MODULE;
2686             flags |= MODULE;
2687         }
2688         if ((flags &amp; ACC_VALUE) != 0) {
2689             flags &amp;= ~ACC_VALUE;
2690             flags |= allowInlineTypes ? VALUE : allowValueBasedClasses ? VALUEBASED : 0;
2691         }
2692         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2693     }
2694 
2695     /**
2696      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2697      * The attribute is only the last component of the original filename, so is unlikely
2698      * to be valid as is, so operations other than those to access the name throw
2699      * UnsupportedOperationException
2700      */
2701     private static class SourceFileObject implements JavaFileObject {
2702 
2703         /** The file&#39;s name.
2704          */
2705         private final Name name;
2706 
2707         public SourceFileObject(Name name) {
2708             this.name = name;
2709         }
2710 
2711         @Override @DefinedBy(Api.COMPILER)
2712         public URI toUri() {
2713             try {
2714                 return new URI(null, name.toString(), null);
2715             } catch (URISyntaxException e) {
2716                 throw new PathFileObject.CannotCreateUriError(name.toString(), e);
2717             }
2718         }
2719 
2720         @Override @DefinedBy(Api.COMPILER)
2721         public String getName() {
2722             return name.toString();
2723         }
2724 
2725         @Override @DefinedBy(Api.COMPILER)
2726         public JavaFileObject.Kind getKind() {
2727             return BaseFileManager.getKind(getName());
2728         }
2729 
2730         @Override @DefinedBy(Api.COMPILER)
2731         public InputStream openInputStream() {
2732             throw new UnsupportedOperationException();
2733         }
2734 
2735         @Override @DefinedBy(Api.COMPILER)
2736         public OutputStream openOutputStream() {
2737             throw new UnsupportedOperationException();
2738         }
2739 
2740         @Override @DefinedBy(Api.COMPILER)
2741         public CharBuffer getCharContent(boolean ignoreEncodingErrors) {
2742             throw new UnsupportedOperationException();
2743         }
2744 
2745         @Override @DefinedBy(Api.COMPILER)
2746         public Reader openReader(boolean ignoreEncodingErrors) {
2747             throw new UnsupportedOperationException();
2748         }
2749 
2750         @Override @DefinedBy(Api.COMPILER)
2751         public Writer openWriter() {
2752             throw new UnsupportedOperationException();
2753         }
2754 
2755         @Override @DefinedBy(Api.COMPILER)
2756         public long getLastModified() {
2757             throw new UnsupportedOperationException();
2758         }
2759 
2760         @Override @DefinedBy(Api.COMPILER)
2761         public boolean delete() {
2762             throw new UnsupportedOperationException();
2763         }
2764 
2765         @Override @DefinedBy(Api.COMPILER)
2766         public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {
2767             return true; // fail-safe mode
2768         }
2769 
2770         @Override @DefinedBy(Api.COMPILER)
2771         public NestingKind getNestingKind() {
2772             return null;
2773         }
2774 
2775         @Override @DefinedBy(Api.COMPILER)
2776         public Modifier getAccessLevel() {
2777             return null;
2778         }
2779 
2780         /**
2781          * Check if two file objects are equal.
2782          * SourceFileObjects are just placeholder objects for the value of a
2783          * SourceFile attribute, and do not directly represent specific files.
2784          * Two SourceFileObjects are equal if their names are equal.
2785          */
2786         @Override
2787         public boolean equals(Object other) {
2788             if (this == other)
2789                 return true;
2790 
2791             if (!(other instanceof SourceFileObject))
2792                 return false;
2793 
2794             SourceFileObject o = (SourceFileObject) other;
2795             return name.equals(o.name);
2796         }
2797 
2798         @Override
2799         public int hashCode() {
2800             return name.hashCode();
2801         }
2802     }
2803 
2804     private class CompleterDeproxy implements AnnotationTypeCompleter {
2805         ClassSymbol proxyOn;
2806         CompoundAnnotationProxy target;
2807         CompoundAnnotationProxy repeatable;
2808 
2809         public CompleterDeproxy(ClassSymbol c, CompoundAnnotationProxy target,
2810                 CompoundAnnotationProxy repeatable)
2811         {
2812             this.proxyOn = c;
2813             this.target = target;
2814             this.repeatable = repeatable;
2815         }
2816 
2817         @Override
2818         public void complete(ClassSymbol sym) {
2819             Assert.check(proxyOn == sym);
2820             Attribute.Compound theTarget = null, theRepeatable = null;
2821             AnnotationDeproxy deproxy;
2822 
2823             try {
2824                 if (target != null) {
2825                     deproxy = new AnnotationDeproxy(proxyOn);
2826                     theTarget = deproxy.deproxyCompound(target);
2827                 }
2828 
2829                 if (repeatable != null) {
2830                     deproxy = new AnnotationDeproxy(proxyOn);
2831                     theRepeatable = deproxy.deproxyCompound(repeatable);
2832                 }
2833             } catch (Exception e) {
2834                 throw new CompletionFailure(sym,
2835                                             () -&gt; ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),
2836                                             dcfh);
2837             }
2838 
2839             sym.getAnnotationTypeMetadata().setTarget(theTarget);
2840             sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
2841         }
2842     }
2843 
2844     private class ProxyType extends Type {
2845 
2846         private final Name name;
2847 
2848         public ProxyType(int index) {
2849             super(syms.noSymbol, TypeMetadata.EMPTY);
2850             this.name = poolReader.getName(index);
2851         }
2852 
2853         @Override
2854         public TypeTag getTag() {
2855             return TypeTag.NONE;
2856         }
2857 
2858         @Override
2859         public Type cloneWithMetadata(TypeMetadata metadata) {
2860             throw new UnsupportedOperationException();
2861         }
2862 
2863         public Type resolve() {
2864             return name.map(ClassReader.this::sigToType);
2865         }
2866 
2867         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2868         public String toString() {
2869             return &quot;&lt;ProxyType&gt;&quot;;
2870         }
2871 
2872     }
2873 
2874     private static final class InterimUsesDirective {
2875         public final Name service;
2876 
2877         public InterimUsesDirective(Name service) {
2878             this.service = service;
2879         }
2880 
2881     }
2882 
2883     private static final class InterimProvidesDirective {
2884         public final Name service;
2885         public final List&lt;Name&gt; impls;
2886 
2887         public InterimProvidesDirective(Name service, List&lt;Name&gt; impls) {
2888             this.service = service;
2889             this.impls = impls;
2890         }
2891 
2892     }
2893 
2894     private final class UsesProvidesCompleter implements Completer {
2895         private final ModuleSymbol currentModule;
2896         private final List&lt;InterimUsesDirective&gt; interimUsesCopy;
2897         private final List&lt;InterimProvidesDirective&gt; interimProvidesCopy;
2898 
2899         public UsesProvidesCompleter(ModuleSymbol currentModule, List&lt;InterimUsesDirective&gt; interimUsesCopy, List&lt;InterimProvidesDirective&gt; interimProvidesCopy) {
2900             this.currentModule = currentModule;
2901             this.interimUsesCopy = interimUsesCopy;
2902             this.interimProvidesCopy = interimProvidesCopy;
2903         }
2904 
2905         @Override
2906         public void complete(Symbol sym) throws CompletionFailure {
2907             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
2908             directives.addAll(currentModule.directives);
2909             ListBuffer&lt;UsesDirective&gt; uses = new ListBuffer&lt;&gt;();
2910             for (InterimUsesDirective interim : interimUsesCopy) {
2911                 UsesDirective d = new UsesDirective(syms.enterClass(currentModule, interim.service));
2912                 uses.add(d);
2913                 directives.add(d);
2914             }
2915             currentModule.uses = uses.toList();
2916             ListBuffer&lt;ProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
2917             for (InterimProvidesDirective interim : interimProvidesCopy) {
2918                 ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
2919                 for (Name impl : interim.impls) {
2920                     impls.append(syms.enterClass(currentModule, impl));
2921                 }
2922                 ProvidesDirective d = new ProvidesDirective(syms.enterClass(currentModule, interim.service),
2923                                                             impls.toList());
2924                 provides.add(d);
2925                 directives.add(d);
2926             }
2927             currentModule.provides = provides.toList();
2928             currentModule.directives = directives.toList();
2929         }
2930     }
2931 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.Supplier;
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileManager;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.Compound;
  36 import com.sun.tools.javac.code.Directive.ExportsDirective;
  37 import com.sun.tools.javac.code.Directive.RequiresDirective;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  40 import com.sun.tools.javac.jvm.*;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  51 import com.sun.tools.javac.util.List;
  52 
  53 import com.sun.tools.javac.code.Lint;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Scope.WriteableScope;
  56 import com.sun.tools.javac.code.Type.*;
  57 import com.sun.tools.javac.code.Symbol.*;
  58 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  59 import com.sun.tools.javac.tree.JCTree.*;
  60 
  61 import static com.sun.tools.javac.code.Flags.*;
  62 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  63 import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
  64 import static com.sun.tools.javac.code.Kinds.*;
  65 import static com.sun.tools.javac.code.Kinds.Kind.*;
  66 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  67 import static com.sun.tools.javac.code.TypeTag.*;
  68 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  69 
  70 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  71 
  72 /** Type checking helper class for the attribution phase.
  73  *
  74  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  75  *  If you write code that depends on this, you do so at your own risk.
  76  *  This code and its internal interfaces are subject to change or
  77  *  deletion without notice.&lt;/b&gt;
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;
  98     private final boolean allowGenericsOverValues;
  99     private final boolean allowValueBasedClasses;
 100 
 101     // The set of lint options currently in effect. It is initialized
 102     // from the context, and then is set/reset as needed by Attr as it
 103     // visits all the various parts of the trees during attribution.
 104     private Lint lint;
 105 
 106     // The method being analyzed in Attr - it is set/reset as needed by
 107     // Attr as it visits new method declarations.
 108     private MethodSymbol method;
 109 
 110     public static Check instance(Context context) {
 111         Check instance = context.get(checkKey);
 112         if (instance == null)
 113             instance = new Check(context);
 114         return instance;
 115     }
 116 
 117     protected Check(Context context) {
 118         context.put(checkKey, this);
 119 
 120         names = Names.instance(context);
 121         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 122             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 123             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 124         log = Log.instance(context);
 125         rs = Resolve.instance(context);
 126         syms = Symtab.instance(context);
 127         enter = Enter.instance(context);
 128         deferredAttr = DeferredAttr.instance(context);
 129         infer = Infer.instance(context);
 130         types = Types.instance(context);
 131         typeAnnotations = TypeAnnotations.instance(context);
 132         diags = JCDiagnostic.Factory.instance(context);
 133         Options options = Options.instance(context);
 134         lint = Lint.instance(context);
 135         fileManager = context.get(JavaFileManager.class);
 136 
 137         source = Source.instance(context);
 138         target = Target.instance(context);
 139         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
 140         allowGenericsOverValues = options.isSet(&quot;allowGenericsOverValues&quot;);
 141         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 142         Target target = Target.instance(context);
 143         syntheticNameChar = target.syntheticNameChar();
 144 
 145         profile = Profile.instance(context);
 146         preview = Preview.instance(context);
 147 
 148         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 149         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 150         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 151         boolean enforceMandatoryWarnings = true;
 152 
 153         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 154                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 155         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 156                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 157         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 158                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 159         sunApiHandler = new MandatoryWarningHandler(log, false,
 160                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 161 
 162         deferredLintHandler = DeferredLintHandler.instance(context);
 163 
 164         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 165                 Feature.RECORDS.allowedInSource(source);
 166     }
 167 
 168     /** Character for synthetic names
 169      */
 170     char syntheticNameChar;
 171 
 172     /** A table mapping flat names of all compiled classes for each module in this run
 173      *  to their symbols; maintained from outside.
 174      */
 175     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 176 
 177     /** A handler for messages about deprecated usage.
 178      */
 179     private MandatoryWarningHandler deprecationHandler;
 180 
 181     /** A handler for messages about deprecated-for-removal usage.
 182      */
 183     private MandatoryWarningHandler removalHandler;
 184 
 185     /** A handler for messages about unchecked or unsafe usage.
 186      */
 187     private MandatoryWarningHandler uncheckedHandler;
 188 
 189     /** A handler for messages about using proprietary API.
 190      */
 191     private MandatoryWarningHandler sunApiHandler;
 192 
 193     /** A handler for deferred lint warnings.
 194      */
 195     private DeferredLintHandler deferredLintHandler;
 196 
 197     /** Are records allowed
 198      */
 199     private final boolean allowRecords;
 200 
 201 /* *************************************************************************
 202  * Errors and Warnings
 203  **************************************************************************/
 204 
 205     Lint setLint(Lint newLint) {
 206         Lint prev = lint;
 207         lint = newLint;
 208         return prev;
 209     }
 210 
 211     MethodSymbol setMethod(MethodSymbol newMethod) {
 212         MethodSymbol prev = method;
 213         method = newMethod;
 214         return prev;
 215     }
 216 
 217     /** Warn about deprecated symbol.
 218      *  @param pos        Position to be used for error reporting.
 219      *  @param sym        The deprecated symbol.
 220      */
 221     void warnDeprecated(DiagnosticPosition pos, Symbol sym) {
 222         if (sym.isDeprecatedForRemoval()) {
 223             if (!lint.isSuppressed(LintCategory.REMOVAL)) {
 224                 if (sym.kind == MDL) {
 225                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemovalModule(sym));
 226                 } else {
 227                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemoval(sym, sym.location()));
 228                 }
 229             }
 230         } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {
 231             if (sym.kind == MDL) {
 232                 deprecationHandler.report(pos, Warnings.HasBeenDeprecatedModule(sym));
 233             } else {
 234                 deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));
 235             }
 236         }
 237     }
 238 
 239     /** Warn about deprecated symbol.
 240      *  @param pos        Position to be used for error reporting.
 241      *  @param sym        The deprecated symbol.
 242      */
 243     void warnPreview(DiagnosticPosition pos, Symbol sym) {
 244         warnPreview(pos, Warnings.IsPreview(sym));
 245     }
 246 
 247     /** Log a preview warning.
 248      *  @param pos        Position to be used for error reporting.
 249      *  @param msg        A Warning describing the problem.
 250      */
 251     public void warnPreview(DiagnosticPosition pos, Warning warnKey) {
 252         if (!lint.isSuppressed(LintCategory.PREVIEW))
 253             preview.reportPreviewWarning(pos, warnKey);
 254     }
 255 
 256     /** Warn about unchecked operation.
 257      *  @param pos        Position to be used for error reporting.
 258      *  @param msg        A string describing the problem.
 259      */
 260     public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {
 261         if (!lint.isSuppressed(LintCategory.UNCHECKED))
 262             uncheckedHandler.report(pos, warnKey);
 263     }
 264 
 265     /** Warn about unsafe vararg method decl.
 266      *  @param pos        Position to be used for error reporting.
 267      */
 268     void warnUnsafeVararg(DiagnosticPosition pos, Warning warnKey) {
 269         if (lint.isEnabled(LintCategory.VARARGS))
 270             log.warning(LintCategory.VARARGS, pos, warnKey);
 271     }
 272 
 273     public void warnStatic(DiagnosticPosition pos, Warning warnKey) {
 274         if (lint.isEnabled(LintCategory.STATIC))
 275             log.warning(LintCategory.STATIC, pos, warnKey);
 276     }
 277 
 278     /** Warn about division by integer constant zero.
 279      *  @param pos        Position to be used for error reporting.
 280      */
 281     void warnDivZero(DiagnosticPosition pos) {
 282         if (lint.isEnabled(LintCategory.DIVZERO))
 283             log.warning(LintCategory.DIVZERO, pos, Warnings.DivZero);
 284     }
 285 
 286     /**
 287      * Report any deferred diagnostics.
 288      */
 289     public void reportDeferredDiagnostics() {
 290         deprecationHandler.reportDeferredDiagnostic();
 291         removalHandler.reportDeferredDiagnostic();
 292         uncheckedHandler.reportDeferredDiagnostic();
 293         sunApiHandler.reportDeferredDiagnostic();
 294     }
 295 
 296 
 297     /** Report a failure to complete a class.
 298      *  @param pos        Position to be used for error reporting.
 299      *  @param ex         The failure to report.
 300      */
 301     public Type completionError(DiagnosticPosition pos, CompletionFailure ex) {
 302         log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));
 303         return syms.errType;
 304     }
 305 
 306     /** Report an error that wrong type tag was found.
 307      *  @param pos        Position to be used for error reporting.
 308      *  @param required   An internationalized string describing the type tag
 309      *                    required.
 310      *  @param found      The type that was found.
 311      */
 312     Type typeTagError(DiagnosticPosition pos, JCDiagnostic required, Object found) {
 313         // this error used to be raised by the parser,
 314         // but has been delayed to this point:
 315         if (found instanceof Type &amp;&amp; ((Type)found).hasTag(VOID)) {
 316             log.error(pos, Errors.IllegalStartOfType);
 317             return syms.errType;
 318         }
 319         log.error(pos, Errors.TypeFoundReq(found, required));
 320         return types.createErrorType(found instanceof Type ? (Type)found : syms.errType);
 321     }
 322 
 323     /** Report an error that symbol cannot be referenced before super
 324      *  has been called.
 325      *  @param pos        Position to be used for error reporting.
 326      *  @param sym        The referenced symbol.
 327      */
 328     void earlyRefError(DiagnosticPosition pos, Symbol sym) {
 329         log.error(pos, Errors.CantRefBeforeCtorCalled(sym));
 330     }
 331 
 332     /** Report duplicate declaration error.
 333      */
 334     void duplicateError(DiagnosticPosition pos, Symbol sym) {
 335         if (!sym.type.isErroneous()) {
 336             Symbol location = sym.location();
 337             if (location.kind == MTH &amp;&amp;
 338                     ((MethodSymbol)location).isStaticOrInstanceInit()) {
 339                 log.error(pos,
 340                           Errors.AlreadyDefinedInClinit(kindName(sym),
 341                                                         sym,
 342                                                         kindName(sym.location()),
 343                                                         kindName(sym.location().enclClass()),
 344                                                         sym.location().enclClass()));
 345             } else {
 346                 /* dont error if this is a duplicated parameter of a generated canonical constructor
 347                  * as we should have issued an error for the duplicated fields
 348                  */
 349                 if (location.kind != MTH ||
 350                         ((sym.owner.flags_field &amp; GENERATEDCONSTR) == 0) ||
 351                         ((sym.owner.flags_field &amp; RECORD) == 0)) {
 352                     log.error(pos,
 353                             Errors.AlreadyDefined(kindName(sym),
 354                                     sym,
 355                                     kindName(sym.location()),
 356                                     sym.location()));
 357                 }
 358             }
 359         }
 360     }
 361 
 362     /** Report array/varargs duplicate declaration
 363      */
 364     void varargsDuplicateError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
 365         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
 366             log.error(pos, Errors.ArrayAndVarargs(sym1, sym2, sym2.location()));
 367         }
 368     }
 369 
 370 /* ************************************************************************
 371  * duplicate declaration checking
 372  *************************************************************************/
 373 
 374     /** Check that variable does not hide variable with same name in
 375      *  immediately enclosing local scope.
 376      *  @param pos           Position for error reporting.
 377      *  @param v             The symbol.
 378      *  @param s             The scope.
 379      */
 380     void checkTransparentVar(DiagnosticPosition pos, VarSymbol v, Scope s) {
 381         for (Symbol sym : s.getSymbolsByName(v.name)) {
 382             if (sym.owner != v.owner) break;
 383             if (sym.kind == VAR &amp;&amp;
 384                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 385                 v.name != names.error) {
 386                 duplicateError(pos, sym);
 387                 return;
 388             }
 389         }
 390     }
 391 
 392     /** Check that a class or interface does not hide a class or
 393      *  interface with same name in immediately enclosing local scope.
 394      *  @param pos           Position for error reporting.
 395      *  @param c             The symbol.
 396      *  @param s             The scope.
 397      */
 398     void checkTransparentClass(DiagnosticPosition pos, ClassSymbol c, Scope s) {
 399         for (Symbol sym : s.getSymbolsByName(c.name)) {
 400             if (sym.owner != c.owner) break;
 401             if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR) &amp;&amp;
 402                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 403                 c.name != names.error) {
 404                 duplicateError(pos, sym);
 405                 return;
 406             }
 407         }
 408     }
 409 
 410     /** Check that class does not have the same name as one of
 411      *  its enclosing classes, or as a class defined in its enclosing scope.
 412      *  return true if class is unique in its enclosing scope.
 413      *  @param pos           Position for error reporting.
 414      *  @param name          The class name.
 415      *  @param s             The enclosing scope.
 416      */
 417     boolean checkUniqueClassName(DiagnosticPosition pos, Name name, Scope s) {
 418         for (Symbol sym : s.getSymbolsByName(name, NON_RECURSIVE)) {
 419             if (sym.kind == TYP &amp;&amp; sym.name != names.error) {
 420                 duplicateError(pos, sym);
 421                 return false;
 422             }
 423         }
 424         for (Symbol sym = s.owner; sym != null; sym = sym.owner) {
 425             if (sym.kind == TYP &amp;&amp; sym.name == name &amp;&amp; sym.name != names.error) {
 426                 duplicateError(pos, sym);
 427                 return true;
 428             }
 429         }
 430         return true;
 431     }
 432 
 433 /* *************************************************************************
 434  * Class name generation
 435  **************************************************************************/
 436 
 437 
 438     private Map&lt;Pair&lt;Name, Name&gt;, Integer&gt; localClassNameIndexes = new HashMap&lt;&gt;();
 439 
 440     /** Return name of local class.
 441      *  This is of the form   {@code &lt;enclClass&gt; $ n &lt;classname&gt; }
 442      *  where
 443      *    enclClass is the flat name of the enclosing class,
 444      *    classname is the simple name of the local class
 445      */
 446     public Name localClassName(ClassSymbol c) {
 447         Name enclFlatname = c.owner.enclClass().flatname;
 448         String enclFlatnameStr = enclFlatname.toString();
 449         Pair&lt;Name, Name&gt; key = new Pair&lt;&gt;(enclFlatname, c.name);
 450         Integer index = localClassNameIndexes.get(key);
 451         for (int i = (index == null) ? 1 : index; ; i++) {
 452             Name flatname = names.fromString(enclFlatnameStr
 453                     + syntheticNameChar + i + c.name);
 454             if (getCompiled(c.packge().modle, flatname) == null) {
 455                 localClassNameIndexes.put(key, i + 1);
 456                 return flatname;
 457             }
 458         }
 459     }
 460 
 461     public void clearLocalClassNameIndexes(ClassSymbol c) {
 462         if (c.owner != null &amp;&amp; c.owner.kind != NIL) {
 463             localClassNameIndexes.remove(new Pair&lt;&gt;(
 464                     c.owner.enclClass().flatname, c.name));
 465         }
 466     }
 467 
 468     public void newRound() {
 469         compiled.clear();
 470         localClassNameIndexes.clear();
 471     }
 472 
 473     public void clear() {
 474         deprecationHandler.clear();
 475         removalHandler.clear();
 476         uncheckedHandler.clear();
 477         sunApiHandler.clear();
 478     }
 479 
 480     public void putCompiled(ClassSymbol csym) {
 481         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 482     }
 483 
 484     public ClassSymbol getCompiled(ClassSymbol csym) {
 485         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 486     }
 487 
 488     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 489         return compiled.get(Pair.of(msym, flatname));
 490     }
 491 
 492     public void removeCompiled(ClassSymbol csym) {
 493         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 494     }
 495 
 496     /* *************************************************************************
 497  * Type Checking
 498  **************************************************************************/
 499 
 500     /**
 501      * A check context is an object that can be used to perform compatibility
 502      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 503      * vary significantly.
 504      */
 505     public interface CheckContext {
 506         /**
 507          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 508          */
 509         boolean compatible(Type found, Type req, Warner warn);
 510         /**
 511          * Report a check error
 512          */
 513         void report(DiagnosticPosition pos, JCDiagnostic details);
 514         /**
 515          * Obtain a warner for this check context
 516          */
 517         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req);
 518 
 519         public InferenceContext inferenceContext();
 520 
 521         public DeferredAttr.DeferredAttrContext deferredAttrContext();
 522     }
 523 
 524     /**
 525      * This class represent a check context that is nested within another check
 526      * context - useful to check sub-expressions. The default behavior simply
 527      * redirects all method calls to the enclosing check context leveraging
 528      * the forwarding pattern.
 529      */
 530     static class NestedCheckContext implements CheckContext {
 531         CheckContext enclosingContext;
 532 
 533         NestedCheckContext(CheckContext enclosingContext) {
 534             this.enclosingContext = enclosingContext;
 535         }
 536 
 537         public boolean compatible(Type found, Type req, Warner warn) {
 538             return enclosingContext.compatible(found, req, warn);
 539         }
 540 
 541         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 542             enclosingContext.report(pos, details);
 543         }
 544 
 545         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 546             return enclosingContext.checkWarner(pos, found, req);
 547         }
 548 
 549         public InferenceContext inferenceContext() {
 550             return enclosingContext.inferenceContext();
 551         }
 552 
 553         public DeferredAttrContext deferredAttrContext() {
 554             return enclosingContext.deferredAttrContext();
 555         }
 556     }
 557 
 558     /**
 559      * Check context to be used when evaluating assignment/return statements
 560      */
 561     CheckContext basicHandler = new CheckContext() {
 562         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 563             log.error(pos, Errors.ProbFoundReq(details));
 564         }
 565         public boolean compatible(Type found, Type req, Warner warn) {
 566             return types.isAssignable(found, req, warn);
 567         }
 568 
 569         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 570             return convertWarner(pos, found, req);
 571         }
 572 
 573         public InferenceContext inferenceContext() {
 574             return infer.emptyContext;
 575         }
 576 
 577         public DeferredAttrContext deferredAttrContext() {
 578             return deferredAttr.emptyDeferredAttrContext;
 579         }
 580 
 581         @Override
 582         public String toString() {
 583             return &quot;CheckContext: basicHandler&quot;;
 584         }
 585     };
 586 
 587     /** Check that a given type is assignable to a given proto-type.
 588      *  If it is, return the type, otherwise return errType.
 589      *  @param pos        Position to be used for error reporting.
 590      *  @param found      The type that was found.
 591      *  @param req        The type that was required.
 592      */
 593     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 594         return checkType(pos, found, req, basicHandler);
 595     }
 596 
 597     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 598         final InferenceContext inferenceContext = checkContext.inferenceContext();
 599         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 600             inferenceContext.addFreeTypeListener(List.of(req, found),
 601                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
 602         } else {
 603             if (found.hasTag(CLASS)) {
 604                 checkParameterizationWithValues(pos, found);
 605             }
 606         }
 607         if (req.hasTag(ERROR))
 608             return req;
 609         if (req.hasTag(NONE))
 610             return found;
 611         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
 612             if (found.hasTag(BOT) &amp;&amp; types.isValueBased(req)) {
 613                 log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));
 614             }
 615             return found;
 616         } else {
 617             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 618                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 619                 return types.createErrorType(found);
 620             }
 621             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 622             return types.createErrorType(found);
 623         }
 624     }
 625 
 626     /** Check that a given type can be cast to a given target type.
 627      *  Return the result of the cast.
 628      *  @param pos        Position to be used for error reporting.
 629      *  @param found      The type that is being cast.
 630      *  @param req        The target type of the cast.
 631      */
 632     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 633         return checkCastable(pos, found, req, basicHandler);
 634     }
 635     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 636         if (types.isCastable(found, req, castWarner(pos, found, req))) {
 637             if (types.isValueBased(req)) {
 638                 if (found.hasTag(BOT)) {
 639                     log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));
 640                 } else if (!types.isValueBased(found)) {
 641                     log.warning(pos, Warnings.PotentialNullPollution(found));
 642                 }
 643             }
 644             return req;
 645         } else {
 646             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 647             return types.createErrorType(found);
 648         }
 649     }
 650 
 651     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 652      * The problem should only be reported for non-292 cast
 653      */
 654     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 655         if (!tree.type.isErroneous()
 656                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 657                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 658                 &amp;&amp; !is292targetTypeCast(tree)) {
 659             deferredLintHandler.report(() -&gt; {
 660                 if (lint.isEnabled(LintCategory.CAST))
 661                     log.warning(LintCategory.CAST,
 662                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 663             });
 664         }
 665     }
 666     //where
 667         private boolean is292targetTypeCast(JCTypeCast tree) {
 668             boolean is292targetTypeCast = false;
 669             JCExpression expr = TreeInfo.skipParens(tree.expr);
 670             if (expr.hasTag(APPLY)) {
 671                 JCMethodInvocation apply = (JCMethodInvocation)expr;
 672                 Symbol sym = TreeInfo.symbol(apply.meth);
 673                 is292targetTypeCast = sym != null &amp;&amp;
 674                     sym.kind == MTH &amp;&amp;
 675                     (sym.flags() &amp; HYPOTHETICAL) != 0;
 676             }
 677             return is292targetTypeCast;
 678         }
 679 
 680         private static final boolean ignoreAnnotatedCasts = true;
 681 
 682     /** Check that a type is within some bounds.
 683      *
 684      *  Used in TypeApply to verify that, e.g., X in {@code V&lt;X&gt;} is a valid
 685      *  type argument.
 686      *  @param a             The type that should be bounded by bs.
 687      *  @param bound         The bound.
 688      */
 689     private boolean checkExtends(Type a, Type bound) {
 690          if (a.isUnbound()) {
 691              return true;
 692          } else if (!a.hasTag(WILDCARD)) {
 693              a = types.cvarUpperBound(a);
 694              return types.isSubtype(a, bound);
 695          } else if (a.isExtendsBound()) {
 696              return types.isCastable(bound, types.wildUpperBound(a), types.noWarnings);
 697          } else if (a.isSuperBound()) {
 698              return !types.notSoftSubtype(types.wildLowerBound(a), bound);
 699          }
 700          return true;
 701      }
 702 
 703     /** Check that type is different from &#39;void&#39;.
 704      *  @param pos           Position to be used for error reporting.
 705      *  @param t             The type to be checked.
 706      */
 707     Type checkNonVoid(DiagnosticPosition pos, Type t) {
 708         if (t.hasTag(VOID)) {
 709             log.error(pos, Errors.VoidNotAllowedHere);
 710             return types.createErrorType(t);
 711         } else {
 712             return t;
 713         }
 714     }
 715 
 716     Type checkClassOrArrayType(DiagnosticPosition pos, Type t) {
 717         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ARRAY) &amp;&amp; !t.hasTag(ERROR)) {
 718             return typeTagError(pos,
 719                                 diags.fragment(Fragments.TypeReqClassArray),
 720                                 asTypeParam(t));
 721         } else {
 722             return t;
 723         }
 724     }
 725 
 726     /** Check that type is a class or interface type.
 727      *  @param pos           Position to be used for error reporting.
 728      *  @param t             The type to be checked.
 729      */
 730     Type checkClassType(DiagnosticPosition pos, Type t) {
 731         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 732             return typeTagError(pos,
 733                                 diags.fragment(Fragments.TypeReqClass),
 734                                 asTypeParam(t));
 735         } else {
 736             return t;
 737         }
 738     }
 739     //where
 740         private Object asTypeParam(Type t) {
 741             return (t.hasTag(TYPEVAR))
 742                                     ? diags.fragment(Fragments.TypeParameter(t))
 743                                     : t;
 744         }
 745 
<a name="1" id="anc1"></a><span class="line-added"> 746     void checkConstraintsOfInlineSuper(DiagnosticPosition pos, ClassSymbol c) {</span>
<span class="line-added"> 747         boolean indirectSuper = false;</span>
<span class="line-added"> 748         for(Type st = types.supertype(c.type); st != Type.noType; indirectSuper = true, st = types.supertype(st)) {</span>
<span class="line-added"> 749             if (st == null || st.tsym == null || st.tsym.kind == ERR)</span>
<span class="line-added"> 750                 return;</span>
<span class="line-added"> 751             if  (indirectSuper &amp;&amp; st.tsym == syms.objectType.tsym)</span>
<span class="line-added"> 752                 return;</span>
<span class="line-added"> 753             if (!st.tsym.isAbstract()) {</span>
<span class="line-added"> 754                 log.error(pos, Errors.ConcreteSupertypeForInlineClass(c, st));</span>
<span class="line-added"> 755             }</span>
<span class="line-added"> 756             if ((st.tsym.flags() &amp; HASINITBLOCK) != 0) {</span>
<span class="line-added"> 757                 log.error(pos, Errors.SuperClassDeclaresInitBlock(c, st));</span>
<span class="line-added"> 758             }</span>
<span class="line-added"> 759             // No instance fields and no arged constructors both mean inner classes cannot be inline supers.</span>
<span class="line-added"> 760             Type encl = st.getEnclosingType();</span>
<span class="line-added"> 761             if (encl != null &amp;&amp; encl.hasTag(CLASS)) {</span>
<span class="line-added"> 762                 log.error(pos, Errors.SuperClassCannotBeInner(c, st));</span>
<span class="line-added"> 763             }</span>
<span class="line-added"> 764             for (Symbol s : st.tsym.members().getSymbols(NON_RECURSIVE)) {</span>
<span class="line-added"> 765                 switch (s.kind) {</span>
<span class="line-added"> 766                 case VAR:</span>
<span class="line-added"> 767                     if ((s.flags() &amp; STATIC) == 0) {</span>
<span class="line-added"> 768                         log.error(pos, Errors.SuperFieldNotAllowed(s, c, st));</span>
<span class="line-added"> 769                     }</span>
<span class="line-added"> 770                     break;</span>
<span class="line-added"> 771                 case MTH:</span>
<span class="line-added"> 772                     if ((s.flags() &amp; SYNCHRONIZED) != 0) {</span>
<span class="line-added"> 773                         log.error(pos, Errors.SuperMethodCannotBeSynchronized(s, c, st));</span>
<span class="line-added"> 774                     } else if (s.isConstructor()) {</span>
<span class="line-added"> 775                         MethodSymbol m = (MethodSymbol)s;</span>
<span class="line-added"> 776                         if (m.getParameters().size() &gt; 0) {</span>
<span class="line-added"> 777                             log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, c, st));</span>
<span class="line-added"> 778                         } else {</span>
<span class="line-added"> 779                             if ((m.flags() &amp; (GENERATEDCONSTR | EMPTYNOARGCONSTR)) == 0) {</span>
<span class="line-added"> 780                                 log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, c, st));</span>
<span class="line-added"> 781                             }</span>
<span class="line-added"> 782                         }</span>
<span class="line-added"> 783                     }</span>
<span class="line-added"> 784                     break;</span>
<span class="line-added"> 785                 }</span>
<span class="line-added"> 786             }</span>
<span class="line-added"> 787         }</span>
<span class="line-added"> 788     }</span>
<span class="line-added"> 789 </span>
 790     /** Check that type is a valid qualifier for a constructor reference expression
 791      */
 792     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 793         t = checkClassOrArrayType(pos, t);
 794         if (t.hasTag(CLASS)) {
 795             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 796                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 797                 t = types.createErrorType(t);
 798             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 799                 log.error(pos, Errors.EnumCantBeInstantiated);
 800                 t = types.createErrorType(t);
 801             } else {
 802                 t = checkClassType(pos, t, true);
 803             }
 804         } else if (t.hasTag(ARRAY)) {
 805             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 806                 log.error(pos, Errors.GenericArrayCreation);
 807                 t = types.createErrorType(t);
 808             }
 809         }
 810         return t;
 811     }
 812 
 813     /** Check that type is a class or interface type.
 814      *  @param pos           Position to be used for error reporting.
 815      *  @param t             The type to be checked.
 816      *  @param noBounds    True if type bounds are illegal here.
 817      */
 818     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 819         t = checkClassType(pos, t);
 820         if (noBounds &amp;&amp; t.isParameterized()) {
 821             List&lt;Type&gt; args = t.getTypeArguments();
 822             while (args.nonEmpty()) {
 823                 if (args.head.hasTag(WILDCARD))
 824                     return typeTagError(pos,
 825                                         diags.fragment(Fragments.TypeReqExact),
 826                                         args.head);
 827                 args = args.tail;
 828             }
 829         }
 830         return t;
 831     }
 832 
 833     /** Check that type is a reference type, i.e. a class, interface or array type
 834      *  or a type variable.
 835      *  @param pos           Position to be used for error reporting.
 836      *  @param t             The type to be checked.
 837      *  @param valueOK       If false, a value class does not qualify
 838      */
 839     Type checkRefType(DiagnosticPosition pos, Type t, boolean valueOK) {
 840         if (t.isReference() &amp;&amp; (valueOK || !types.isValue(t)))
 841             return t;
 842         else
 843             return typeTagError(pos,
 844                                 diags.fragment(Fragments.TypeReqRef),
 845                                 t);
 846     }
 847 
 848     /** Check that type is a reference type, i.e. a class, interface or array type
 849      *  or a type variable.
 850      *  @param pos           Position to be used for error reporting.
 851      *  @param t             The type to be checked.
 852      */
 853     Type checkRefType(DiagnosticPosition pos, Type t) {
 854         return checkRefType(pos, t, true);
 855     }
 856 
 857     /** Check that each type is a reference type, i.e. a class, interface or array type
 858      *  or a type variable.
 859      *  @param trees         Original trees, used for error reporting.
 860      *  @param types         The types to be checked.
 861      */
 862     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 863         List&lt;JCExpression&gt; tl = trees;
 864         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
 865             l.head = checkRefType(tl.head.pos(), l.head, allowGenericsOverValues);
 866             tl = tl.tail;
 867         }
 868         return types;
 869     }
 870 
 871     /** Check that type is a null or reference type.
 872      *  @param pos           Position to be used for error reporting.
 873      *  @param t             The type to be checked.
 874      */
 875     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 876         if (t.isReference() || t.hasTag(BOT))
 877             return t;
 878         else
 879             return typeTagError(pos,
 880                                 diags.fragment(Fragments.TypeReqRef),
 881                                 t);
 882     }
 883 
 884     /** Check that flag set does not contain elements of two conflicting sets. s
 885      *  Return true if it doesn&#39;t.
 886      *  @param pos           Position to be used for error reporting.
 887      *  @param flags         The set of flags to be checked.
 888      *  @param set1          Conflicting flags set #1.
 889      *  @param set2          Conflicting flags set #2.
 890      */
 891     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 892         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 893             log.error(pos,
 894                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 895                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 896             return false;
 897         } else
 898             return true;
 899     }
 900 
 901     void checkParameterizationWithValues(DiagnosticPosition pos, Type t) {
 902         if (!allowGenericsOverValues &amp;&amp; t.tsym != syms.classType.tsym) { // tolerate Value.class for now.
 903             valueParameterizationChecker.visit(t, pos);
 904         }
 905     }
 906 
 907     /** valueParameterizationChecker: A type visitor that descends down the given type looking for instances of value types
 908      *  being used as type arguments and issues error against those usages.
 909      */
 910     private final Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt; valueParameterizationChecker = new Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt;() {
 911 
 912         @Override
 913         public Void visitType(Type t, DiagnosticPosition pos) {
 914             return null;
 915         }
 916 
 917         @Override
 918         public Void visitClassType(ClassType t, DiagnosticPosition pos) {
 919             for (Type targ : t.allparams()) {
 920                 if (types.isValue(targ) &amp;&amp; !allowGenericsOverValues) {
 921                     log.error(pos, Errors.GenericParameterizationWithValueType(t));
 922                 }
 923                 visit(targ, pos);
 924             }
 925             return null;
 926         }
 927 
 928         @Override
 929         public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {
 930              return null;
 931         }
 932 
 933         @Override
 934         public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {
 935             return null;
 936         }
 937 
 938         @Override
 939         public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {
 940             return visit(t.elemtype, pos);
 941         }
 942 
 943         @Override
 944         public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {
 945             return visit(t.type, pos);
 946         }
 947     };
 948 
 949 
 950 
 951     /** Check that usage of diamond operator is correct (i.e. diamond should not
 952      * be used with non-generic classes or in anonymous class creation expressions)
 953      */
 954     Type checkDiamond(JCNewClass tree, Type t) {
 955         if (!TreeInfo.isDiamond(tree) ||
 956                 t.isErroneous()) {
 957             return checkClassType(tree.clazz.pos(), t, true);
 958         } else {
 959             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 960                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 961                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 962             }
 963             if (t.tsym.type.getTypeArguments().isEmpty()) {
 964                 log.error(tree.clazz.pos(),
 965                           Errors.CantApplyDiamond1(t,
 966                                                    Fragments.DiamondNonGeneric(t)));
 967                 return types.createErrorType(t);
 968             } else if (tree.typeargs != null &amp;&amp;
 969                     tree.typeargs.nonEmpty()) {
 970                 log.error(tree.clazz.pos(),
 971                           Errors.CantApplyDiamond1(t,
 972                                                    Fragments.DiamondAndExplicitParams(t)));
 973                 return types.createErrorType(t);
 974             } else {
 975                 return t;
 976             }
 977         }
 978     }
 979 
 980     /** Check that the type inferred using the diamond operator does not contain
 981      *  non-denotable types such as captured types or intersection types.
 982      *  @param t the type inferred using the diamond operator
 983      *  @return  the (possibly empty) list of non-denotable types.
 984      */
 985     List&lt;Type&gt; checkDiamondDenotable(ClassType t) {
 986         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 987         for (Type arg : t.allparams()) {
 988             if (!checkDenotable(arg)) {
 989                 buf.append(arg);
 990             }
 991         }
 992         return buf.toList();
 993     }
 994 
 995     public boolean checkDenotable(Type t) {
 996         return denotableChecker.visit(t, null);
 997     }
 998         // where
 999 
1000         /** diamondTypeChecker: A type visitor that descends down the given type looking for non-denotable
1001          *  types. The visit methods return false as soon as a non-denotable type is encountered and true
1002          *  otherwise.
1003          */
1004         private static final Types.SimpleVisitor&lt;Boolean, Void&gt; denotableChecker = new Types.SimpleVisitor&lt;Boolean, Void&gt;() {
1005             @Override
1006             public Boolean visitType(Type t, Void s) {
1007                 return true;
1008             }
1009             @Override
1010             public Boolean visitClassType(ClassType t, Void s) {
1011                 if (t.isUnion() || t.isIntersection()) {
1012                     return false;
1013                 }
1014                 for (Type targ : t.allparams()) {
1015                     if (!visit(targ, s)) {
1016                         return false;
1017                     }
1018                 }
1019                 return true;
1020             }
1021 
1022             @Override
1023             public Boolean visitTypeVar(TypeVar t, Void s) {
1024                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
1025                   (i.e cannot have been produced by inference (18.4))
1026                 */
1027                 return (t.tsym.flags() &amp; SYNTHETIC) == 0;
1028             }
1029 
1030             @Override
1031             public Boolean visitCapturedType(CapturedType t, Void s) {
1032                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
1033                   (i.e cannot have been produced by capture conversion (5.1.10))
1034                 */
1035                 return false;
1036             }
1037 
1038             @Override
1039             public Boolean visitArrayType(ArrayType t, Void s) {
1040                 return visit(t.elemtype, s);
1041             }
1042 
1043             @Override
1044             public Boolean visitWildcardType(WildcardType t, Void s) {
1045                 return visit(t.type, s);
1046             }
1047         };
1048 
1049     void checkVarargsMethodDecl(Env&lt;AttrContext&gt; env, JCMethodDecl tree) {
1050         MethodSymbol m = tree.sym;
1051         boolean hasTrustMeAnno = m.attribute(syms.trustMeType.tsym) != null;
1052         Type varargElemType = null;
1053         if (m.isVarArgs()) {
1054             varargElemType = types.elemtype(tree.params.last().type);
1055         }
1056         if (hasTrustMeAnno &amp;&amp; !isTrustMeAllowedOnMethod(m)) {
1057             if (varargElemType != null) {
1058                 JCDiagnostic msg = Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ?
1059                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargs(m)) :
1060                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargsFinalOnly(m));
1061                 log.error(tree,
1062                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
1063                                                            msg));
1064             } else {
1065                 log.error(tree,
1066                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
1067                                                            Fragments.VarargsTrustmeOnNonVarargsMeth(m)));
1068             }
1069         } else if (hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
1070                             types.isReifiable(varargElemType)) {
1071             warnUnsafeVararg(tree, Warnings.VarargsRedundantTrustmeAnno(
1072                                 syms.trustMeType.tsym,
1073                                 diags.fragment(Fragments.VarargsTrustmeOnReifiableVarargs(varargElemType))));
1074         }
1075         else if (!hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
1076                 !types.isReifiable(varargElemType)) {
1077             warnUnchecked(tree.params.head.pos(), Warnings.UncheckedVarargsNonReifiableType(varargElemType));
1078         }
1079     }
1080     //where
1081         private boolean isTrustMeAllowedOnMethod(Symbol s) {
1082             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
1083                 (s.isConstructor() ||
1084                     (s.flags() &amp; (STATIC | FINAL |
1085                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
1086         }
1087 
1088     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
1089         //check that resulting type is not the null type
1090         if (t.hasTag(BOT)) {
1091             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
1092             return types.createErrorType(t);
1093         } else if (t.hasTag(VOID)) {
1094             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
1095             return types.createErrorType(t);
1096         }
1097 
1098         //upward project the initializer type
1099         Type varType = types.upward(t, types.captures(t));
1100         if (varType.hasTag(CLASS)) {
1101             checkParameterizationWithValues(pos, varType);
1102         }
1103         return varType;
1104     }
1105 
1106     public void checkForSuspectClassLiteralComparison(
1107             final JCBinary tree,
1108             final Type leftType,
1109             final Type rightType) {
1110 
1111         if (lint.isEnabled(LintCategory.MIGRATION)) {
1112             if (isInvocationOfGetClass(tree.lhs) &amp;&amp; isClassOfSomeInterface(rightType) ||
1113                     isInvocationOfGetClass(tree.rhs) &amp;&amp; isClassOfSomeInterface(leftType)) {
1114                 log.warning(LintCategory.MIGRATION, tree.pos(), Warnings.GetClassComparedWithInterface);
1115             }
1116         }
1117     }
1118     //where
1119     private boolean isClassOfSomeInterface(Type someClass) {
1120         if (someClass.tsym.flatName() == names.java_lang_Class) {
1121             List&lt;Type&gt; arguments = someClass.getTypeArguments();
1122             if (arguments.length() == 1) {
1123                 return arguments.head.isInterface();
1124             }
1125         }
1126         return false;
1127     }
1128     //where
1129     private boolean isInvocationOfGetClass(JCExpression tree) {
1130         tree = TreeInfo.skipParens(tree);
1131         if (tree.hasTag(APPLY)) {
1132             JCMethodInvocation apply = (JCMethodInvocation)tree;
1133             MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(apply.meth);
1134             return msym.name == names.getClass &amp;&amp; msym.implementedIn(syms.objectType.tsym, types) != null;
1135         }
1136         return false;
1137     }
1138 
1139     Type checkMethod(final Type mtype,
1140             final Symbol sym,
1141             final Env&lt;AttrContext&gt; env,
1142             final List&lt;JCExpression&gt; argtrees,
1143             final List&lt;Type&gt; argtypes,
1144             final boolean useVarargs,
1145             InferenceContext inferenceContext) {
1146         // System.out.println(&quot;call   : &quot; + env.tree);
1147         // System.out.println(&quot;method : &quot; + owntype);
1148         // System.out.println(&quot;actuals: &quot; + argtypes);
1149         if (inferenceContext.free(mtype)) {
1150             inferenceContext.addFreeTypeListener(List.of(mtype),
1151                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
1152             return mtype;
1153         }
1154         Type owntype = mtype;
1155         List&lt;Type&gt; formals = owntype.getParameterTypes();
1156         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
1157         if (nonInferred.length() != formals.length()) nonInferred = formals;
1158         Type last = useVarargs ? formals.last() : null;
1159         if (sym.name == names.init &amp;&amp; sym.owner == syms.enumSym) {
1160             formals = formals.tail.tail;
1161             nonInferred = nonInferred.tail.tail;
1162         }
1163         if ((sym.flags() &amp; ANONCONSTR_BASED) != 0) {
1164             formals = formals.tail;
1165             nonInferred = nonInferred.tail;
1166         }
1167         List&lt;JCExpression&gt; args = argtrees;
1168         if (args != null) {
1169             //this is null when type-checking a method reference
1170             while (formals.head != last) {
1171                 JCTree arg = args.head;
1172                 Warner warn = convertWarner(arg.pos(), arg.type, nonInferred.head);
1173                 assertConvertible(arg, arg.type, formals.head, warn);
1174                 args = args.tail;
1175                 formals = formals.tail;
1176                 nonInferred = nonInferred.tail;
1177             }
1178             if (useVarargs) {
1179                 Type varArg = types.elemtype(last);
1180                 while (args.tail != null) {
1181                     JCTree arg = args.head;
1182                     Warner warn = convertWarner(arg.pos(), arg.type, varArg);
1183                     assertConvertible(arg, arg.type, varArg, warn);
1184                     args = args.tail;
1185                 }
1186             } else if ((sym.flags() &amp; (VARARGS | SIGNATURE_POLYMORPHIC)) == VARARGS) {
1187                 // non-varargs call to varargs method
1188                 Type varParam = owntype.getParameterTypes().last();
1189                 Type lastArg = argtypes.last();
1190                 if (types.isSubtypeUnchecked(lastArg, types.elemtype(varParam)) &amp;&amp;
1191                     !types.isSameType(types.erasure(varParam), types.erasure(lastArg)))
1192                     log.warning(argtrees.last().pos(),
1193                                 Warnings.InexactNonVarargsCall(types.elemtype(varParam),varParam));
1194             }
1195         }
1196         if (useVarargs) {
1197             Type argtype = owntype.getParameterTypes().last();
1198             if (!types.isReifiable(argtype) &amp;&amp;
1199                 (sym.baseSymbol().attribute(syms.trustMeType.tsym) == null ||
1200                  !isTrustMeAllowedOnMethod(sym))) {
1201                 warnUnchecked(env.tree.pos(), Warnings.UncheckedGenericArrayCreation(argtype));
1202             }
1203             TreeInfo.setVarargsElement(env.tree, types.elemtype(argtype));
1204          }
1205          return owntype;
1206     }
1207     //where
1208     private void assertConvertible(JCTree tree, Type actual, Type formal, Warner warn) {
1209         if (types.isConvertible(actual, formal, warn))
1210             return;
1211 
1212         if (formal.isCompound()
1213             &amp;&amp; types.isSubtype(actual, types.supertype(formal))
1214             &amp;&amp; types.isSubtypeUnchecked(actual, types.interfaces(formal), warn))
1215             return;
1216     }
1217 
1218     /**
1219      * Check that type &#39;t&#39; is a valid instantiation of a generic class
1220      * (see JLS 4.5)
1221      *
1222      * @param t class type to be checked
1223      * @return true if &#39;t&#39; is well-formed
1224      */
1225     public boolean checkValidGenericType(Type t) {
1226         return firstIncompatibleTypeArg(t) == null;
1227     }
1228     //WHERE
1229         private Type firstIncompatibleTypeArg(Type type) {
1230             List&lt;Type&gt; formals = type.tsym.type.allparams();
1231             List&lt;Type&gt; actuals = type.allparams();
1232             List&lt;Type&gt; args = type.getTypeArguments();
1233             List&lt;Type&gt; forms = type.tsym.type.getTypeArguments();
1234             ListBuffer&lt;Type&gt; bounds_buf = new ListBuffer&lt;&gt;();
1235 
1236             // For matching pairs of actual argument types `a&#39; and
1237             // formal type parameters with declared bound `b&#39; ...
1238             while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1239                 // exact type arguments needs to know their
1240                 // bounds (for upper and lower bound
1241                 // calculations).  So we create new bounds where
1242                 // type-parameters are replaced with actuals argument types.
1243                 bounds_buf.append(types.subst(forms.head.getUpperBound(), formals, actuals));
1244                 args = args.tail;
1245                 forms = forms.tail;
1246             }
1247 
1248             args = type.getTypeArguments();
1249             List&lt;Type&gt; tvars_cap = types.substBounds(formals,
1250                                       formals,
1251                                       types.capture(type).allparams());
1252             while (args.nonEmpty() &amp;&amp; tvars_cap.nonEmpty()) {
1253                 // Let the actual arguments know their bound
1254                 args.head.withTypeVar((TypeVar)tvars_cap.head);
1255                 args = args.tail;
1256                 tvars_cap = tvars_cap.tail;
1257             }
1258 
1259             args = type.getTypeArguments();
1260             List&lt;Type&gt; bounds = bounds_buf.toList();
1261 
1262             while (args.nonEmpty() &amp;&amp; bounds.nonEmpty()) {
1263                 Type actual = args.head;
1264                 if (!isTypeArgErroneous(actual) &amp;&amp;
1265                         !bounds.head.isErroneous() &amp;&amp;
1266                         !checkExtends(actual, bounds.head)) {
1267                     return args.head;
1268                 }
1269                 args = args.tail;
1270                 bounds = bounds.tail;
1271             }
1272 
1273             args = type.getTypeArguments();
1274             bounds = bounds_buf.toList();
1275 
1276             for (Type arg : types.capture(type).getTypeArguments()) {
1277                 if (arg.hasTag(TYPEVAR) &amp;&amp;
1278                         arg.getUpperBound().isErroneous() &amp;&amp;
1279                         !bounds.head.isErroneous() &amp;&amp;
1280                         !isTypeArgErroneous(args.head)) {
1281                     return args.head;
1282                 }
1283                 bounds = bounds.tail;
1284                 args = args.tail;
1285             }
1286 
1287             return null;
1288         }
1289         //where
1290         boolean isTypeArgErroneous(Type t) {
1291             return isTypeArgErroneous.visit(t);
1292         }
1293 
1294         Types.UnaryVisitor&lt;Boolean&gt; isTypeArgErroneous = new Types.UnaryVisitor&lt;Boolean&gt;() {
1295             public Boolean visitType(Type t, Void s) {
1296                 return t.isErroneous();
1297             }
1298             @Override
1299             public Boolean visitTypeVar(TypeVar t, Void s) {
1300                 return visit(t.getUpperBound());
1301             }
1302             @Override
1303             public Boolean visitCapturedType(CapturedType t, Void s) {
1304                 return visit(t.getUpperBound()) ||
1305                         visit(t.getLowerBound());
1306             }
1307             @Override
1308             public Boolean visitWildcardType(WildcardType t, Void s) {
1309                 return visit(t.type);
1310             }
1311         };
1312 
1313     /** Check that given modifiers are legal for given symbol and
1314      *  return modifiers together with any implicit modifiers for that symbol.
1315      *  Warning: we can&#39;t use flags() here since this method
1316      *  is called during class enter, when flags() would cause a premature
1317      *  completion.
1318      *  @param pos           Position to be used for error reporting.
1319      *  @param flags         The set of modifiers given in a definition.
1320      *  @param sym           The defined symbol.
1321      */
1322     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1323         long mask;
1324         long implicit = 0;
1325 
1326         switch (sym.kind) {
1327         case VAR:
1328             if (TreeInfo.isReceiverParam(tree))
1329                 mask = ReceiverParamFlags;
1330             else if (sym.owner.kind != TYP)
1331                 mask = LocalVarFlags;
1332             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1333                 mask = implicit = InterfaceVarFlags;
1334             else {
1335                 mask = VarFlags;
1336                 if (types.isValue(sym.owner.type) &amp;&amp; (flags &amp; STATIC) == 0) {
1337                     implicit |= FINAL;
1338                 }
1339             }
1340             break;
1341         case MTH:
1342             if (sym.name == names.init) {
1343                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1344                     // enum constructors cannot be declared public or
1345                     // protected and must be implicitly or explicitly
1346                     // private
1347                     implicit = PRIVATE;
1348                     mask = PRIVATE;
1349                 } else
1350                     mask = ConstructorFlags;
1351             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1352                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1353                     mask = AnnotationTypeElementMask;
1354                     implicit = PUBLIC | ABSTRACT;
1355                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1356                     mask = InterfaceMethodMask;
1357                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1358                     if ((flags &amp; DEFAULT) != 0) {
1359                         implicit |= ABSTRACT;
1360                     }
1361                 } else {
1362                     mask = implicit = InterfaceMethodFlags;
1363                 }
1364             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1365                 mask = RecordMethodFlags;
1366             } else {
1367                 // instance methods of value types do not have a monitor associated with their `this&#39;
1368                 mask = ((sym.owner.flags_field &amp; VALUE) != 0 &amp;&amp; (flags &amp; Flags.STATIC) == 0) ?
1369                         MethodFlags &amp; ~SYNCHRONIZED : MethodFlags;
1370             }
1371             // Imply STRICTFP if owner has STRICTFP set.
1372             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1373                 ((flags) &amp; Flags.DEFAULT) != 0)
1374                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1375             break;
1376         case TYP:
1377             if (sym.isLocal()) {
1378                 mask = (flags &amp; RECORD) != 0 ? LocalRecordFlags : LocalClassFlags;
1379                 if ((flags &amp; RECORD) != 0) {
1380                     implicit = STATIC;
1381                     if (sym.owner.kind == TYP) {
1382                         log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1383                     }
1384                 }
1385                 if ((sym.owner.flags_field &amp; STATIC) == 0 &amp;&amp;
1386                     (flags &amp; ENUM) != 0) {
1387                     log.error(pos, Errors.EnumsMustBeStatic);
1388                 }
1389             } else if (sym.owner.kind == TYP) {
1390                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;
1391                 if (sym.owner.owner.kind == PCK ||
1392                     (sym.owner.flags_field &amp; STATIC) != 0)
1393                     mask |= STATIC;
1394                 else if ((flags &amp; ENUM) != 0) {
1395                     log.error(pos, Errors.EnumsMustBeStatic);
1396                 } else if ((flags &amp; RECORD) != 0) {
1397                     log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1398                 }
1399                 // Nested interfaces and enums are always STATIC (Spec ???)
1400                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1401             } else {
1402                 mask = ClassFlags;
1403             }
1404             // Interfaces are always ABSTRACT
1405             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1406 
1407             if ((flags &amp; ENUM) != 0) {
1408                 // enums can&#39;t be declared abstract or final or value type
1409                 mask &amp;= ~(ABSTRACT | FINAL | VALUE);
1410                 implicit |= implicitEnumFinalFlag(tree);
1411             }
1412             if ((flags &amp; RECORD) != 0) {
1413                 // records can&#39;t be declared abstract
1414                 mask &amp;= ~ABSTRACT;
1415                 implicit |= FINAL;
1416             }
1417             // Imply STRICTFP if owner has STRICTFP set.
1418             implicit |= sym.owner.flags_field &amp; STRICTFP;
1419             break;
1420         default:
1421             throw new AssertionError();
1422         }
1423         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1424         if (illegal != 0) {
1425             if ((illegal &amp; INTERFACE) != 0) {
1426                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1427                 mask |= INTERFACE;
1428             }
1429             else {
1430                 log.error(pos,
1431                           Errors.ModNotAllowedHere(asFlagSet(illegal)));
1432             }
1433         }
1434         else if ((sym.kind == TYP ||
1435                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1436                   // in the presence of inner classes. Should it be deleted here?
1437                   checkDisjoint(pos, flags,
1438                                 ABSTRACT,
1439                                 PRIVATE | STATIC | DEFAULT))
1440                  &amp;&amp;
1441                  checkDisjoint(pos, flags,
1442                                 STATIC | PRIVATE,
1443                                 DEFAULT)
1444                  &amp;&amp;
1445                  checkDisjoint(pos, flags,
1446                                ABSTRACT | INTERFACE,
1447                                FINAL | NATIVE | SYNCHRONIZED | VALUE)
1448                  &amp;&amp;
1449                  checkDisjoint(pos, flags,
1450                                PUBLIC,
1451                                PRIVATE | PROTECTED)
1452                  &amp;&amp;
1453                  checkDisjoint(pos, flags,
1454                                PRIVATE,
1455                                PUBLIC | PROTECTED)
1456                  &amp;&amp;
1457                  checkDisjoint(pos, flags,
1458                                FINAL,
1459                                VOLATILE)
1460                  &amp;&amp;
1461                  (sym.kind == TYP ||
1462                   checkDisjoint(pos, flags,
1463                                 ABSTRACT | NATIVE,
1464                                 STRICTFP))) {
1465             // skip
1466         }
1467         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1468     }
1469 
1470 
1471     /** Determine if this enum should be implicitly final.
1472      *
1473      *  If the enum has no specialized enum constants, it is final.
1474      *
1475      *  If the enum does have specialized enum constants, it is
1476      *  &lt;i&gt;not&lt;/i&gt; final.
1477      */
1478     private long implicitEnumFinalFlag(JCTree tree) {
1479         if (!tree.hasTag(CLASSDEF)) return 0;
1480         class SpecialTreeVisitor extends JCTree.Visitor {
1481             boolean specialized;
1482             SpecialTreeVisitor() {
1483                 this.specialized = false;
1484             }
1485 
1486             @Override
1487             public void visitTree(JCTree tree) { /* no-op */ }
1488 
1489             @Override
1490             public void visitVarDef(JCVariableDecl tree) {
1491                 if ((tree.mods.flags &amp; ENUM) != 0) {
1492                     if (tree.init instanceof JCNewClass &amp;&amp;
1493                         ((JCNewClass) tree.init).def != null) {
1494                         specialized = true;
1495                     }
1496                 }
1497             }
1498         }
1499 
1500         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1501         JCClassDecl cdef = (JCClassDecl) tree;
1502         for (JCTree defs: cdef.defs) {
1503             defs.accept(sts);
1504             if (sts.specialized) return 0;
1505         }
1506         return FINAL;
1507     }
1508 
1509 /* *************************************************************************
1510  * Type Validation
1511  **************************************************************************/
1512 
1513     /** Validate a type expression. That is,
1514      *  check that all type arguments of a parametric type are within
1515      *  their bounds. This must be done in a second phase after type attribution
1516      *  since a class might have a subclass as type parameter bound. E.g:
1517      *
1518      *  &lt;pre&gt;{@code
1519      *  class B&lt;A extends C&gt; { ... }
1520      *  class C extends B&lt;C&gt; { ... }
1521      *  }&lt;/pre&gt;
1522      *
1523      *  and we can&#39;t make sure that the bound is already attributed because
1524      *  of possible cycles.
1525      *
1526      * Visitor method: Validate a type expression, if it is not null, catching
1527      *  and reporting any completion failures.
1528      */
1529     void validate(JCTree tree, Env&lt;AttrContext&gt; env) {
1530         validate(tree, env, true);
1531     }
1532     void validate(JCTree tree, Env&lt;AttrContext&gt; env, boolean checkRaw) {
1533         new Validator(env).validateTree(tree, checkRaw, true);
1534     }
1535 
1536     /** Visitor method: Validate a list of type expressions.
1537      */
1538     void validate(List&lt;? extends JCTree&gt; trees, Env&lt;AttrContext&gt; env) {
1539         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1540             validate(l.head, env);
1541     }
1542 
1543     /** A visitor class for type validation.
1544      */
1545     class Validator extends JCTree.Visitor {
1546 
1547         boolean checkRaw;
1548         boolean isOuter;
1549         Env&lt;AttrContext&gt; env;
1550 
1551         Validator(Env&lt;AttrContext&gt; env) {
1552             this.env = env;
1553         }
1554 
1555         @Override
1556         public void visitTypeArray(JCArrayTypeTree tree) {
1557             validateTree(tree.elemtype, checkRaw, isOuter);
1558         }
1559 
1560         @Override
1561         public void visitTypeApply(JCTypeApply tree) {
1562             if (tree.type.hasTag(CLASS)) {
1563                 List&lt;JCExpression&gt; args = tree.arguments;
1564                 List&lt;Type&gt; forms = tree.type.tsym.type.getTypeArguments();
1565 
1566                 Type incompatibleArg = firstIncompatibleTypeArg(tree.type);
1567                 if (incompatibleArg != null) {
1568                     for (JCTree arg : tree.arguments) {
1569                         if (arg.type == incompatibleArg) {
1570                             log.error(arg, Errors.NotWithinBounds(incompatibleArg, forms.head));
1571                         }
1572                         forms = forms.tail;
1573                      }
1574                  }
1575 
1576                 forms = tree.type.tsym.type.getTypeArguments();
1577 
1578                 boolean is_java_lang_Class = tree.type.tsym.flatName() == names.java_lang_Class;
1579 
1580                 // For matching pairs of actual argument types `a&#39; and
1581                 // formal type parameters with declared bound `b&#39; ...
1582                 while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1583                     validateTree(args.head,
1584                             !(isOuter &amp;&amp; is_java_lang_Class),
1585                             false);
1586                     args = args.tail;
1587                     forms = forms.tail;
1588                 }
1589 
1590                 // Check that this type is either fully parameterized, or
1591                 // not parameterized at all.
1592                 if (tree.type.getEnclosingType().isRaw())
1593                     log.error(tree.pos(), Errors.ImproperlyFormedTypeInnerRawParam);
1594                 if (tree.clazz.hasTag(SELECT))
1595                     visitSelectInternal((JCFieldAccess)tree.clazz);
1596             }
1597         }
1598 
1599         @Override
1600         public void visitTypeParameter(JCTypeParameter tree) {
1601             validateTrees(tree.bounds, true, isOuter);
1602             checkClassBounds(tree.pos(), tree.type);
1603         }
1604 
1605         @Override
1606         public void visitWildcard(JCWildcard tree) {
1607             if (tree.inner != null)
1608                 validateTree(tree.inner, true, isOuter);
1609         }
1610 
1611         @Override
1612         public void visitSelect(JCFieldAccess tree) {
1613             if (tree.type.hasTag(CLASS)) {
1614                 visitSelectInternal(tree);
1615 
1616                 // Check that this type is either fully parameterized, or
1617                 // not parameterized at all.
1618                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1619                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1620             }
1621         }
1622 
1623         public void visitSelectInternal(JCFieldAccess tree) {
1624             if (tree.type.tsym.isStatic() &amp;&amp;
1625                 tree.selected.type.isParameterized()) {
1626                 // The enclosing type is not a class, so we are
1627                 // looking at a static member type.  However, the
1628                 // qualifying expression is parameterized.
1629                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1630             } else {
1631                 // otherwise validate the rest of the expression
1632                 tree.selected.accept(this);
1633             }
1634         }
1635 
1636         @Override
1637         public void visitAnnotatedType(JCAnnotatedType tree) {
1638             tree.underlyingType.accept(this);
1639         }
1640 
1641         @Override
1642         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1643             if (that.type.hasTag(TypeTag.VOID)) {
1644                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1645             }
1646             super.visitTypeIdent(that);
1647         }
1648 
1649         /** Default visitor method: do nothing.
1650          */
1651         @Override
1652         public void visitTree(JCTree tree) {
1653         }
1654 
1655         public void validateTree(JCTree tree, boolean checkRaw, boolean isOuter) {
1656             if (tree != null) {
1657                 boolean prevCheckRaw = this.checkRaw;
1658                 this.checkRaw = checkRaw;
1659                 this.isOuter = isOuter;
1660 
1661                 try {
1662                     tree.accept(this);
1663                     if (checkRaw)
1664                         checkRaw(tree, env);
1665                 } catch (CompletionFailure ex) {
1666                     completionError(tree.pos(), ex);
1667                 } finally {
1668                     this.checkRaw = prevCheckRaw;
1669                 }
1670             }
1671         }
1672 
1673         public void validateTrees(List&lt;? extends JCTree&gt; trees, boolean checkRaw, boolean isOuter) {
1674             for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1675                 validateTree(l.head, checkRaw, isOuter);
1676         }
1677     }
1678 
1679     void checkRaw(JCTree tree, Env&lt;AttrContext&gt; env) {
1680         if (lint.isEnabled(LintCategory.RAW) &amp;&amp;
1681             tree.type.hasTag(CLASS) &amp;&amp;
1682             !TreeInfo.isDiamond(tree) &amp;&amp;
1683             !withinAnonConstr(env) &amp;&amp;
1684             tree.type.isRaw()) {
1685             log.warning(LintCategory.RAW,
1686                     tree.pos(), Warnings.RawClassUse(tree.type, tree.type.tsym.type));
1687         }
1688     }
1689     //where
1690         private boolean withinAnonConstr(Env&lt;AttrContext&gt; env) {
1691             return env.enclClass.name.isEmpty() &amp;&amp;
1692                     env.enclMethod != null &amp;&amp; env.enclMethod.name == names.init;
1693         }
1694 
1695 /* *************************************************************************
1696  * Exception checking
1697  **************************************************************************/
1698 
1699     /* The following methods treat classes as sets that contain
1700      * the class itself and all their subclasses
1701      */
1702 
1703     /** Is given type a subtype of some of the types in given list?
1704      */
1705     boolean subset(Type t, List&lt;Type&gt; ts) {
1706         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1707             if (types.isSubtype(t, l.head)) return true;
1708         return false;
1709     }
1710 
1711     /** Is given type a subtype or supertype of
1712      *  some of the types in given list?
1713      */
1714     boolean intersects(Type t, List&lt;Type&gt; ts) {
1715         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1716             if (types.isSubtype(t, l.head) || types.isSubtype(l.head, t)) return true;
1717         return false;
1718     }
1719 
1720     /** Add type set to given type list, unless it is a subclass of some class
1721      *  in the list.
1722      */
1723     List&lt;Type&gt; incl(Type t, List&lt;Type&gt; ts) {
1724         return subset(t, ts) ? ts : excl(t, ts).prepend(t);
1725     }
1726 
1727     /** Remove type set from type set list.
1728      */
1729     List&lt;Type&gt; excl(Type t, List&lt;Type&gt; ts) {
1730         if (ts.isEmpty()) {
1731             return ts;
1732         } else {
1733             List&lt;Type&gt; ts1 = excl(t, ts.tail);
1734             if (types.isSubtype(ts.head, t)) return ts1;
1735             else if (ts1 == ts.tail) return ts;
1736             else return ts1.prepend(ts.head);
1737         }
1738     }
1739 
1740     /** Form the union of two type set lists.
1741      */
1742     List&lt;Type&gt; union(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1743         List&lt;Type&gt; ts = ts1;
1744         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1745             ts = incl(l.head, ts);
1746         return ts;
1747     }
1748 
1749     /** Form the difference of two type lists.
1750      */
1751     List&lt;Type&gt; diff(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1752         List&lt;Type&gt; ts = ts1;
1753         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1754             ts = excl(l.head, ts);
1755         return ts;
1756     }
1757 
1758     /** Form the intersection of two type lists.
1759      */
1760     public List&lt;Type&gt; intersect(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1761         List&lt;Type&gt; ts = List.nil();
1762         for (List&lt;Type&gt; l = ts1; l.nonEmpty(); l = l.tail)
1763             if (subset(l.head, ts2)) ts = incl(l.head, ts);
1764         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1765             if (subset(l.head, ts1)) ts = incl(l.head, ts);
1766         return ts;
1767     }
1768 
1769     /** Is exc an exception symbol that need not be declared?
1770      */
1771     boolean isUnchecked(ClassSymbol exc) {
1772         return
1773             exc.kind == ERR ||
1774             exc.isSubClass(syms.errorType.tsym, types) ||
1775             exc.isSubClass(syms.runtimeExceptionType.tsym, types);
1776     }
1777 
1778     /** Is exc an exception type that need not be declared?
1779      */
1780     boolean isUnchecked(Type exc) {
1781         return
1782             (exc.hasTag(TYPEVAR)) ? isUnchecked(types.supertype(exc)) :
1783             (exc.hasTag(CLASS)) ? isUnchecked((ClassSymbol)exc.tsym) :
1784             exc.hasTag(BOT);
1785     }
1786 
1787     boolean isChecked(Type exc) {
1788         return !isUnchecked(exc);
1789     }
1790 
1791     /** Same, but handling completion failures.
1792      */
1793     boolean isUnchecked(DiagnosticPosition pos, Type exc) {
1794         try {
1795             return isUnchecked(exc);
1796         } catch (CompletionFailure ex) {
1797             completionError(pos, ex);
1798             return true;
1799         }
1800     }
1801 
1802     /** Is exc handled by given exception list?
1803      */
1804     boolean isHandled(Type exc, List&lt;Type&gt; handled) {
1805         return isUnchecked(exc) || subset(exc, handled);
1806     }
1807 
1808     /** Return all exceptions in thrown list that are not in handled list.
1809      *  @param thrown     The list of thrown exceptions.
1810      *  @param handled    The list of handled exceptions.
1811      */
1812     List&lt;Type&gt; unhandled(List&lt;Type&gt; thrown, List&lt;Type&gt; handled) {
1813         List&lt;Type&gt; unhandled = List.nil();
1814         for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1815             if (!isHandled(l.head, handled)) unhandled = unhandled.prepend(l.head);
1816         return unhandled;
1817     }
1818 
1819 /* *************************************************************************
1820  * Overriding/Implementation checking
1821  **************************************************************************/
1822 
1823     /** The level of access protection given by a flag set,
1824      *  where PRIVATE is highest and PUBLIC is lowest.
1825      */
1826     static int protection(long flags) {
1827         switch ((short)(flags &amp; AccessFlags)) {
1828         case PRIVATE: return 3;
1829         case PROTECTED: return 1;
1830         default:
1831         case PUBLIC: return 0;
1832         case 0: return 2;
1833         }
1834     }
1835 
1836     /** A customized &quot;cannot override&quot; error message.
1837      *  @param m      The overriding method.
1838      *  @param other  The overridden method.
1839      *  @return       An internationalized string.
1840      */
1841     Fragment cannotOverride(MethodSymbol m, MethodSymbol other) {
1842         Symbol mloc = m.location();
1843         Symbol oloc = other.location();
1844 
1845         if ((other.owner.flags() &amp; INTERFACE) == 0)
1846             return Fragments.CantOverride(m, mloc, other, oloc);
1847         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1848             return Fragments.CantImplement(m, mloc, other, oloc);
1849         else
1850             return Fragments.ClashesWith(m, mloc, other, oloc);
1851     }
1852 
1853     /** A customized &quot;override&quot; warning message.
1854      *  @param m      The overriding method.
1855      *  @param other  The overridden method.
1856      *  @return       An internationalized string.
1857      */
1858     Fragment uncheckedOverrides(MethodSymbol m, MethodSymbol other) {
1859         Symbol mloc = m.location();
1860         Symbol oloc = other.location();
1861 
1862         if ((other.owner.flags() &amp; INTERFACE) == 0)
1863             return Fragments.UncheckedOverride(m, mloc, other, oloc);
1864         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1865             return Fragments.UncheckedImplement(m, mloc, other, oloc);
1866         else
1867             return Fragments.UncheckedClashWith(m, mloc, other, oloc);
1868     }
1869 
1870     /** A customized &quot;override&quot; warning message.
1871      *  @param m      The overriding method.
1872      *  @param other  The overridden method.
1873      *  @return       An internationalized string.
1874      */
1875     Fragment varargsOverrides(MethodSymbol m, MethodSymbol other) {
1876         Symbol mloc = m.location();
1877         Symbol oloc = other.location();
1878 
1879         if ((other.owner.flags() &amp; INTERFACE) == 0)
1880             return Fragments.VarargsOverride(m, mloc, other, oloc);
1881         else  if ((m.owner.flags() &amp; INTERFACE) == 0)
1882             return Fragments.VarargsImplement(m, mloc, other, oloc);
1883         else
1884             return Fragments.VarargsClashWith(m, mloc, other, oloc);
1885     }
1886 
1887     /** Check that this method conforms with overridden method &#39;other&#39;.
1888      *  where `origin&#39; is the class where checking started.
1889      *  Complications:
1890      *  (1) Do not check overriding of synthetic methods
1891      *      (reason: they might be final).
1892      *      todo: check whether this is still necessary.
1893      *  (2) Admit the case where an interface proxy throws fewer exceptions
1894      *      than the method it implements. Augment the proxy methods with the
1895      *      undeclared exceptions in this case.
1896      *  (3) When generics are enabled, admit the case where an interface proxy
1897      *      has a result type
1898      *      extended by the result type of the method it implements.
1899      *      Change the proxies result type to the smaller type in this case.
1900      *
1901      *  @param tree         The tree from which positions
1902      *                      are extracted for errors.
1903      *  @param m            The overriding method.
1904      *  @param other        The overridden method.
1905      *  @param origin       The class of which the overriding method
1906      *                      is a member.
1907      */
1908     void checkOverride(JCTree tree,
1909                        MethodSymbol m,
1910                        MethodSymbol other,
1911                        ClassSymbol origin) {
1912         // Don&#39;t check overriding of synthetic methods or by bridge methods.
1913         if ((m.flags() &amp; (SYNTHETIC|BRIDGE)) != 0 || (other.flags() &amp; SYNTHETIC) != 0) {
1914             return;
1915         }
1916 
1917         // Error if static method overrides instance method (JLS 8.4.6.2).
1918         if ((m.flags() &amp; STATIC) != 0 &amp;&amp;
1919                    (other.flags() &amp; STATIC) == 0) {
1920             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1921                       Errors.OverrideStatic(cannotOverride(m, other)));
1922             m.flags_field |= BAD_OVERRIDE;
1923             return;
1924         }
1925 
1926         // Error if instance method overrides static or final
1927         // method (JLS 8.4.6.1).
1928         if ((other.flags() &amp; FINAL) != 0 ||
1929                  (m.flags() &amp; STATIC) == 0 &amp;&amp;
1930                  (other.flags() &amp; STATIC) != 0) {
1931             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1932                       Errors.OverrideMeth(cannotOverride(m, other),
1933                                           asFlagSet(other.flags() &amp; (FINAL | STATIC))));
1934             m.flags_field |= BAD_OVERRIDE;
1935             return;
1936         }
1937 
1938         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1939             // handled in validateAnnotationMethod
1940             return;
1941         }
1942 
1943         // Error if overriding method has weaker access (JLS 8.4.6.3).
1944         if (protection(m.flags()) &gt; protection(other.flags())) {
1945             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1946                       (other.flags() &amp; AccessFlags) == 0 ?
1947                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1948                                                           &quot;package&quot;) :
1949                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1950                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1951             m.flags_field |= BAD_OVERRIDE;
1952             return;
1953         }
1954 
1955         if (origin.isValue() &amp;&amp; other.owner == syms.objectType.tsym &amp;&amp; m.type.getParameterTypes().size() == 0) {
1956             if (m.name == names.clone || m.name == names.finalize) {
1957                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1958                         Errors.InlineClassMayNotOverride(m.name));
1959                 m.flags_field |= BAD_OVERRIDE;
1960                 return;
1961             }
1962         }
1963 
1964         Type mt = types.memberType(origin.type, m);
1965         Type ot = types.memberType(origin.type, other);
1966         // Error if overriding result type is different
1967         // (or, in the case of generics mode, not a subtype) of
1968         // overridden result type. We have to rename any type parameters
1969         // before comparing types.
1970         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1971         List&lt;Type&gt; otvars = ot.getTypeArguments();
1972         Type mtres = mt.getReturnType();
1973         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1974 
1975         overrideWarner.clear();
1976         boolean resultTypesOK =
1977             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1978         if (!resultTypesOK) {
1979             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1980                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1981                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1982                                         other.location()), mtres, otres));
1983                 m.flags_field |= BAD_OVERRIDE;
1984             } else {
1985                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1986                           Errors.OverrideIncompatibleRet(cannotOverride(m, other), mtres, otres));
1987                 m.flags_field |= BAD_OVERRIDE;
1988             }
1989             return;
1990         } else if (overrideWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
1991             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
1992                     Warnings.OverrideUncheckedRet(uncheckedOverrides(m, other), mtres, otres));
1993         }
1994 
1995         // Error if overriding method throws an exception not reported
1996         // by overridden method.
1997         List&lt;Type&gt; otthrown = types.subst(ot.getThrownTypes(), otvars, mtvars);
1998         List&lt;Type&gt; unhandledErased = unhandled(mt.getThrownTypes(), types.erasure(otthrown));
1999         List&lt;Type&gt; unhandledUnerased = unhandled(mt.getThrownTypes(), otthrown);
2000         if (unhandledErased.nonEmpty()) {
2001             log.error(TreeInfo.diagnosticPositionFor(m, tree),
2002                       Errors.OverrideMethDoesntThrow(cannotOverride(m, other), unhandledUnerased.head));
2003             m.flags_field |= BAD_OVERRIDE;
2004             return;
2005         }
2006         else if (unhandledUnerased.nonEmpty()) {
2007             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
2008                           Warnings.OverrideUncheckedThrown(cannotOverride(m, other), unhandledUnerased.head));
2009             return;
2010         }
2011 
2012         // Optional warning if varargs don&#39;t agree
2013         if ((((m.flags() ^ other.flags()) &amp; Flags.VARARGS) != 0)
2014             &amp;&amp; lint.isEnabled(LintCategory.OVERRIDES)) {
2015             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
2016                         ((m.flags() &amp; Flags.VARARGS) != 0)
2017                         ? Warnings.OverrideVarargsMissing(varargsOverrides(m, other))
2018                         : Warnings.OverrideVarargsExtra(varargsOverrides(m, other)));
2019         }
2020 
2021         // Warn if instance method overrides bridge method (compiler spec ??)
2022         if ((other.flags() &amp; BRIDGE) != 0) {
2023             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
2024                         Warnings.OverrideBridge(uncheckedOverrides(m, other)));
2025         }
2026 
2027         // Warn if a deprecated method overridden by a non-deprecated one.
2028         if (!isDeprecatedOverrideIgnorable(other, origin)) {
2029             Lint prevLint = setLint(lint.augment(m));
2030             try {
2031                 checkDeprecated(() -&gt; TreeInfo.diagnosticPositionFor(m, tree), m, other);
2032             } finally {
2033                 setLint(prevLint);
2034             }
2035         }
2036     }
2037     // where
2038         private boolean isDeprecatedOverrideIgnorable(MethodSymbol m, ClassSymbol origin) {
2039             // If the method, m, is defined in an interface, then ignore the issue if the method
2040             // is only inherited via a supertype and also implemented in the supertype,
2041             // because in that case, we will rediscover the issue when examining the method
2042             // in the supertype.
2043             // If the method, m, is not defined in an interface, then the only time we need to
2044             // address the issue is when the method is the supertype implementation: any other
2045             // case, we will have dealt with when examining the supertype classes
2046             ClassSymbol mc = m.enclClass();
2047             Type st = types.supertype(origin.type);
2048             if (!st.hasTag(CLASS))
2049                 return true;
2050             MethodSymbol stimpl = m.implementation((ClassSymbol)st.tsym, types, false);
2051 
2052             if (mc != null &amp;&amp; ((mc.flags() &amp; INTERFACE) != 0)) {
2053                 List&lt;Type&gt; intfs = types.interfaces(origin.type);
2054                 return (intfs.contains(mc.type) ? false : (stimpl != null));
2055             }
2056             else
2057                 return (stimpl != m);
2058         }
2059 
2060 
2061     // used to check if there were any unchecked conversions
2062     Warner overrideWarner = new Warner();
2063 
2064     /** Check that a class does not inherit two concrete methods
2065      *  with the same signature.
2066      *  @param pos          Position to be used for error reporting.
2067      *  @param site         The class type to be checked.
2068      */
2069     public void checkCompatibleConcretes(DiagnosticPosition pos, Type site) {
2070         Type sup = types.supertype(site);
2071         if (!sup.hasTag(CLASS)) return;
2072 
2073         for (Type t1 = sup;
2074              t1.hasTag(CLASS) &amp;&amp; t1.tsym.type.isParameterized();
2075              t1 = types.supertype(t1)) {
2076             for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2077                 if (s1.kind != MTH ||
2078                     (s1.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
2079                     !s1.isInheritedIn(site.tsym, types) ||
2080                     ((MethodSymbol)s1).implementation(site.tsym,
2081                                                       types,
2082                                                       true) != s1)
2083                     continue;
2084                 Type st1 = types.memberType(t1, s1);
2085                 int s1ArgsLength = st1.getParameterTypes().length();
2086                 if (st1 == s1.type) continue;
2087 
2088                 for (Type t2 = sup;
2089                      t2.hasTag(CLASS);
2090                      t2 = types.supertype(t2)) {
2091                     for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2092                         if (s2 == s1 ||
2093                             s2.kind != MTH ||
2094                             (s2.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
2095                             s2.type.getParameterTypes().length() != s1ArgsLength ||
2096                             !s2.isInheritedIn(site.tsym, types) ||
2097                             ((MethodSymbol)s2).implementation(site.tsym,
2098                                                               types,
2099                                                               true) != s2)
2100                             continue;
2101                         Type st2 = types.memberType(t2, s2);
2102                         if (types.overrideEquivalent(st1, st2))
2103                             log.error(pos,
2104                                       Errors.ConcreteInheritanceConflict(s1, t1, s2, t2, sup));
2105                     }
2106                 }
2107             }
2108         }
2109     }
2110 
2111     /** Check that classes (or interfaces) do not each define an abstract
2112      *  method with same name and arguments but incompatible return types.
2113      *  @param pos          Position to be used for error reporting.
2114      *  @param t1           The first argument type.
2115      *  @param t2           The second argument type.
2116      */
2117     public boolean checkCompatibleAbstracts(DiagnosticPosition pos,
2118                                             Type t1,
2119                                             Type t2,
2120                                             Type site) {
2121         if ((site.tsym.flags() &amp; COMPOUND) != 0) {
2122             // special case for intersections: need to eliminate wildcards in supertypes
2123             t1 = types.capture(t1);
2124             t2 = types.capture(t2);
2125         }
2126         return firstIncompatibility(pos, t1, t2, site) == null;
2127     }
2128 
2129     /** Return the first method which is defined with same args
2130      *  but different return types in two given interfaces, or null if none
2131      *  exists.
2132      *  @param t1     The first type.
2133      *  @param t2     The second type.
2134      *  @param site   The most derived type.
2135      *  @return symbol from t2 that conflicts with one in t1.
2136      */
2137     private Symbol firstIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2138         Map&lt;TypeSymbol,Type&gt; interfaces1 = new HashMap&lt;&gt;();
2139         closure(t1, interfaces1);
2140         Map&lt;TypeSymbol,Type&gt; interfaces2;
2141         if (t1 == t2)
2142             interfaces2 = interfaces1;
2143         else
2144             closure(t2, interfaces1, interfaces2 = new HashMap&lt;&gt;());
2145 
2146         for (Type t3 : interfaces1.values()) {
2147             for (Type t4 : interfaces2.values()) {
2148                 Symbol s = firstDirectIncompatibility(pos, t3, t4, site);
2149                 if (s != null) return s;
2150             }
2151         }
2152         return null;
2153     }
2154 
2155     /** Compute all the supertypes of t, indexed by type symbol. */
2156     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typeMap) {
2157         if (!t.hasTag(CLASS)) return;
2158         if (typeMap.put(t.tsym, t) == null) {
2159             closure(types.supertype(t), typeMap);
2160             for (Type i : types.interfaces(t))
2161                 closure(i, typeMap);
2162         }
2163     }
2164 
2165     /** Compute all the supertypes of t, indexed by type symbol (except those in typesSkip). */
2166     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typesSkip, Map&lt;TypeSymbol,Type&gt; typeMap) {
2167         if (!t.hasTag(CLASS)) return;
2168         if (typesSkip.get(t.tsym) != null) return;
2169         if (typeMap.put(t.tsym, t) == null) {
2170             closure(types.supertype(t), typesSkip, typeMap);
2171             for (Type i : types.interfaces(t))
2172                 closure(i, typesSkip, typeMap);
2173         }
2174     }
2175 
2176     /** Return the first method in t2 that conflicts with a method from t1. */
2177     private Symbol firstDirectIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2178         for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2179             Type st1 = null;
2180             if (s1.kind != MTH || !s1.isInheritedIn(site.tsym, types) ||
2181                     (s1.flags() &amp; SYNTHETIC) != 0) continue;
2182             Symbol impl = ((MethodSymbol)s1).implementation(site.tsym, types, false);
2183             if (impl != null &amp;&amp; (impl.flags() &amp; ABSTRACT) == 0) continue;
2184             for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2185                 if (s1 == s2) continue;
2186                 if (s2.kind != MTH || !s2.isInheritedIn(site.tsym, types) ||
2187                         (s2.flags() &amp; SYNTHETIC) != 0) continue;
2188                 if (st1 == null) st1 = types.memberType(t1, s1);
2189                 Type st2 = types.memberType(t2, s2);
2190                 if (types.overrideEquivalent(st1, st2)) {
2191                     List&lt;Type&gt; tvars1 = st1.getTypeArguments();
2192                     List&lt;Type&gt; tvars2 = st2.getTypeArguments();
2193                     Type rt1 = st1.getReturnType();
2194                     Type rt2 = types.subst(st2.getReturnType(), tvars2, tvars1);
2195                     boolean compat =
2196                         types.isSameType(rt1, rt2) ||
2197                         !rt1.isPrimitiveOrVoid() &amp;&amp;
2198                         !rt2.isPrimitiveOrVoid() &amp;&amp;
2199                         (types.covariantReturnType(rt1, rt2, types.noWarnings) ||
2200                          types.covariantReturnType(rt2, rt1, types.noWarnings)) ||
2201                          checkCommonOverriderIn(s1,s2,site);
2202                     if (!compat) {
2203                         log.error(pos, Errors.TypesIncompatible(t1, t2,
2204                                 Fragments.IncompatibleDiffRet(s2.name, types.memberType(t2, s2).getParameterTypes())));
2205                         return s2;
2206                     }
2207                 } else if (checkNameClash((ClassSymbol)site.tsym, s1, s2) &amp;&amp;
2208                         !checkCommonOverriderIn(s1, s2, site)) {
2209                     log.error(pos, Errors.NameClashSameErasureNoOverride(
2210                             s1.name, types.memberType(site, s1).asMethodType().getParameterTypes(), s1.location(),
2211                             s2.name, types.memberType(site, s2).asMethodType().getParameterTypes(), s2.location()));
2212                     return s2;
2213                 }
2214             }
2215         }
2216         return null;
2217     }
2218     //WHERE
2219     boolean checkCommonOverriderIn(Symbol s1, Symbol s2, Type site) {
2220         Map&lt;TypeSymbol,Type&gt; supertypes = new HashMap&lt;&gt;();
2221         Type st1 = types.memberType(site, s1);
2222         Type st2 = types.memberType(site, s2);
2223         closure(site, supertypes);
2224         for (Type t : supertypes.values()) {
2225             for (Symbol s3 : t.tsym.members().getSymbolsByName(s1.name)) {
2226                 if (s3 == s1 || s3 == s2 || s3.kind != MTH || (s3.flags() &amp; (BRIDGE|SYNTHETIC)) != 0) continue;
2227                 Type st3 = types.memberType(site,s3);
2228                 if (types.overrideEquivalent(st3, st1) &amp;&amp;
2229                         types.overrideEquivalent(st3, st2) &amp;&amp;
2230                         types.returnTypeSubstitutable(st3, st1) &amp;&amp;
2231                         types.returnTypeSubstitutable(st3, st2)) {
2232                     return true;
2233                 }
2234             }
2235         }
2236         return false;
2237     }
2238 
2239     /** Check that a given method conforms with any method it overrides.
2240      *  @param tree         The tree from which positions are extracted
2241      *                      for errors.
2242      *  @param m            The overriding method.
2243      */
2244     void checkOverride(Env&lt;AttrContext&gt; env, JCMethodDecl tree, MethodSymbol m) {
2245         ClassSymbol origin = (ClassSymbol)m.owner;
2246         if ((origin.flags() &amp; ENUM) != 0 &amp;&amp; names.finalize.equals(m.name))
2247             if (m.overrides(syms.enumFinalFinalize, origin, types, false)) {
2248                 log.error(tree.pos(), Errors.EnumNoFinalize);
2249                 return;
2250             }
2251         for (Type t = origin.type; t.hasTag(CLASS);
2252              t = types.supertype(t)) {
2253             if (t != origin.type) {
2254                 checkOverride(tree, t, origin, m);
2255             }
2256             for (Type t2 : types.interfaces(t)) {
2257                 checkOverride(tree, t2, origin, m);
2258             }
2259         }
2260 
2261         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2262         // Check if this method must override a super method due to being annotated with @Override
2263         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2264         // be treated &quot;as if as they were annotated&quot; with @Override.
2265         boolean mustOverride = explicitOverride ||
2266                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate() &amp;&amp;
2267                         (!m.owner.isValue() || (tree.body.flags &amp; SYNTHETIC) == 0));
2268         if (mustOverride &amp;&amp; !isOverrider(m)) {
2269             DiagnosticPosition pos = tree.pos();
2270             for (JCAnnotation a : tree.getModifiers().annotations) {
2271                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2272                     pos = a.pos();
2273                     break;
2274                 }
2275             }
2276             log.error(pos,
2277                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2278                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2279         }
2280     }
2281 
2282     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2283         TypeSymbol c = site.tsym;
2284         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2285             if (m.overrides(sym, origin, types, false)) {
2286                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2287                     checkOverride(tree, m, (MethodSymbol)sym, origin);
2288                 }
2289             }
2290         }
2291     }
2292 
2293     private Filter&lt;Symbol&gt; equalsHasCodeFilter = s -&gt; MethodSymbol.implementation_filter.accepts(s) &amp;&amp;
2294             (s.flags() &amp; BAD_OVERRIDE) == 0;
2295 
2296     public void checkClassOverrideEqualsAndHashIfNeeded(DiagnosticPosition pos,
2297             ClassSymbol someClass) {
2298         /* At present, annotations cannot possibly have a method that is override
2299          * equivalent with Object.equals(Object) but in any case the condition is
2300          * fine for completeness.
2301          */
2302         if (someClass == (ClassSymbol)syms.objectType.tsym ||
2303             someClass.isInterface() || someClass.isEnum() ||
2304             (someClass.flags() &amp; ANNOTATION) != 0 ||
2305             (someClass.flags() &amp; ABSTRACT) != 0) return;
2306         //anonymous inner classes implementing interfaces need especial treatment
2307         if (someClass.isAnonymous()) {
2308             List&lt;Type&gt; interfaces =  types.interfaces(someClass.type);
2309             if (interfaces != null &amp;&amp; !interfaces.isEmpty() &amp;&amp;
2310                 interfaces.head.tsym == syms.comparatorType.tsym) return;
2311         }
2312         checkClassOverrideEqualsAndHash(pos, someClass);
2313     }
2314 
2315     private void checkClassOverrideEqualsAndHash(DiagnosticPosition pos,
2316             ClassSymbol someClass) {
2317         if (lint.isEnabled(LintCategory.OVERRIDES)) {
2318             MethodSymbol equalsAtObject = (MethodSymbol)syms.objectType
2319                     .tsym.members().findFirst(names.equals);
2320             MethodSymbol hashCodeAtObject = (MethodSymbol)syms.objectType
2321                     .tsym.members().findFirst(names.hashCode);
2322             boolean overridesEquals = types.implementation(equalsAtObject,
2323                 someClass, false, equalsHasCodeFilter).owner == someClass;
2324             boolean overridesHashCode = types.implementation(hashCodeAtObject,
2325                 someClass, false, equalsHasCodeFilter) != hashCodeAtObject;
2326 
2327             if (overridesEquals &amp;&amp; !overridesHashCode) {
2328                 log.warning(LintCategory.OVERRIDES, pos,
2329                             Warnings.OverrideEqualsButNotHashcode(someClass));
2330             }
2331         }
2332     }
2333 
2334     public void checkModuleName (JCModuleDecl tree) {
2335         Name moduleName = tree.sym.name;
2336         Assert.checkNonNull(moduleName);
2337         if (lint.isEnabled(LintCategory.MODULE)) {
2338             JCExpression qualId = tree.qualId;
2339             while (qualId != null) {
2340                 Name componentName;
2341                 DiagnosticPosition pos;
2342                 switch (qualId.getTag()) {
2343                     case SELECT:
2344                         JCFieldAccess selectNode = ((JCFieldAccess) qualId);
2345                         componentName = selectNode.name;
2346                         pos = selectNode.pos();
2347                         qualId = selectNode.selected;
2348                         break;
2349                     case IDENT:
2350                         componentName = ((JCIdent) qualId).name;
2351                         pos = qualId.pos();
2352                         qualId = null;
2353                         break;
2354                     default:
2355                         throw new AssertionError(&quot;Unexpected qualified identifier: &quot; + qualId.toString());
2356                 }
2357                 if (componentName != null) {
2358                     String moduleNameComponentString = componentName.toString();
2359                     int nameLength = moduleNameComponentString.length();
2360                     if (nameLength &gt; 0 &amp;&amp; Character.isDigit(moduleNameComponentString.charAt(nameLength - 1))) {
2361                         log.warning(Lint.LintCategory.MODULE, pos, Warnings.PoorChoiceForModuleName(componentName));
2362                     }
2363                 }
2364             }
2365         }
2366     }
2367 
2368     private boolean checkNameClash(ClassSymbol origin, Symbol s1, Symbol s2) {
2369         ClashFilter cf = new ClashFilter(origin.type);
2370         return (cf.accepts(s1) &amp;&amp;
2371                 cf.accepts(s2) &amp;&amp;
2372                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2373     }
2374 
2375 
2376     /** Check that all abstract members of given class have definitions.
2377      *  @param pos          Position to be used for error reporting.
2378      *  @param c            The class.
2379      */
2380     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2381         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2382         if (undef != null) {
2383             MethodSymbol undef1 =
2384                 new MethodSymbol(undef.flags(), undef.name,
2385                                  types.memberType(c.type, undef), undef.owner);
2386             log.error(pos,
2387                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2388         }
2389     }
2390 
2391     // A value class cannot contain a field of its own type either or indirectly.
2392     void checkNonCyclicMembership(JCClassDecl tree) {
2393         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
2394         try {
2395             tree.sym.flags_field |= LOCKED;
2396             for (List&lt;? extends JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2397                 if (l.head.hasTag(VARDEF)) {
2398                     JCVariableDecl field = (JCVariableDecl) l.head;
2399                     if (cyclePossible(field.sym)) {
2400                         Type fieldType = field.sym.type;
2401                         checkNonCyclicMembership((ClassSymbol) fieldType.tsym, field.pos());
2402                     }
2403                 }
2404             }
2405         } finally {
2406             tree.sym.flags_field &amp;= ~LOCKED;
2407         }
2408 
2409     }
2410     // where
2411     private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {
2412         if ((c.flags_field &amp; LOCKED) != 0) {
2413             log.error(pos, Errors.CyclicValueTypeMembership(c));
2414             return;
2415         }
2416         try {
2417             c.flags_field |= LOCKED;
2418             for (Symbol fld : c.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; cyclePossible((VarSymbol) s), NON_RECURSIVE)) {
2419                 checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);
2420             }
2421         } finally {
2422             c.flags_field &amp;= ~LOCKED;
2423         }
2424     }
2425         // where
2426         private boolean cyclePossible(VarSymbol symbol) {
2427             return (symbol.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(symbol.type);
2428         }
2429 
2430     void checkNonCyclicDecl(JCClassDecl tree) {
2431         CycleChecker cc = new CycleChecker();
2432         cc.scan(tree);
2433         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2434             tree.sym.flags_field |= ACYCLIC;
2435         }
2436     }
2437 
2438     class CycleChecker extends TreeScanner {
2439 
2440         List&lt;Symbol&gt; seenClasses = List.nil();
2441         boolean errorFound = false;
2442         boolean partialCheck = false;
2443 
2444         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2445             if (sym != null &amp;&amp; sym.kind == TYP) {
2446                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2447                 if (classEnv != null) {
2448                     DiagnosticSource prevSource = log.currentSource();
2449                     try {
2450                         log.useSource(classEnv.toplevel.sourcefile);
2451                         scan(classEnv.tree);
2452                     }
2453                     finally {
2454                         log.useSource(prevSource.getFile());
2455                     }
2456                 } else if (sym.kind == TYP) {
2457                     checkClass(pos, sym, List.nil());
2458                 }
2459             } else {
2460                 //not completed yet
2461                 partialCheck = true;
2462             }
2463         }
2464 
2465         @Override
2466         public void visitSelect(JCFieldAccess tree) {
2467             super.visitSelect(tree);
2468             checkSymbol(tree.pos(), tree.sym);
2469         }
2470 
2471         @Override
2472         public void visitIdent(JCIdent tree) {
2473             checkSymbol(tree.pos(), tree.sym);
2474         }
2475 
2476         @Override
2477         public void visitTypeApply(JCTypeApply tree) {
2478             scan(tree.clazz);
2479         }
2480 
2481         @Override
2482         public void visitTypeArray(JCArrayTypeTree tree) {
2483             scan(tree.elemtype);
2484         }
2485 
2486         @Override
2487         public void visitClassDef(JCClassDecl tree) {
2488             List&lt;JCTree&gt; supertypes = List.nil();
2489             if (tree.getExtendsClause() != null) {
2490                 supertypes = supertypes.prepend(tree.getExtendsClause());
2491             }
2492             if (tree.getImplementsClause() != null) {
2493                 for (JCTree intf : tree.getImplementsClause()) {
2494                     supertypes = supertypes.prepend(intf);
2495                 }
2496             }
2497             checkClass(tree.pos(), tree.sym, supertypes);
2498         }
2499 
2500         void checkClass(DiagnosticPosition pos, Symbol c, List&lt;JCTree&gt; supertypes) {
2501             if ((c.flags_field &amp; ACYCLIC) != 0)
2502                 return;
2503             if (seenClasses.contains(c)) {
2504                 errorFound = true;
2505                 noteCyclic(pos, (ClassSymbol)c);
2506             } else if (!c.type.isErroneous()) {
2507                 try {
2508                     seenClasses = seenClasses.prepend(c);
2509                     if (c.type.hasTag(CLASS)) {
2510                         if (supertypes.nonEmpty()) {
2511                             scan(supertypes);
2512                         }
2513                         else {
2514                             ClassType ct = (ClassType)c.type;
2515                             if (ct.supertype_field == null ||
2516                                     ct.interfaces_field == null) {
2517                                 //not completed yet
2518                                 partialCheck = true;
2519                                 return;
2520                             }
2521                             checkSymbol(pos, ct.supertype_field.tsym);
2522                             for (Type intf : ct.interfaces_field) {
2523                                 checkSymbol(pos, intf.tsym);
2524                             }
2525                         }
2526                         if (c.owner.kind == TYP) {
2527                             checkSymbol(pos, c.owner);
2528                         }
2529                     }
2530                 } finally {
2531                     seenClasses = seenClasses.tail;
2532                 }
2533             }
2534         }
2535     }
2536 
2537     /** Check for cyclic references. Issue an error if the
2538      *  symbol of the type referred to has a LOCKED flag set.
2539      *
2540      *  @param pos      Position to be used for error reporting.
2541      *  @param t        The type referred to.
2542      */
2543     void checkNonCyclic(DiagnosticPosition pos, Type t) {
2544         checkNonCyclicInternal(pos, t);
2545     }
2546 
2547 
2548     void checkNonCyclic(DiagnosticPosition pos, TypeVar t) {
2549         checkNonCyclic1(pos, t, List.nil());
2550     }
2551 
2552     private void checkNonCyclic1(DiagnosticPosition pos, Type t, List&lt;TypeVar&gt; seen) {
2553         final TypeVar tv;
2554         if  (t.hasTag(TYPEVAR) &amp;&amp; (t.tsym.flags() &amp; UNATTRIBUTED) != 0)
2555             return;
2556         if (seen.contains(t)) {
2557             tv = (TypeVar)t;
2558             tv.setUpperBound(types.createErrorType(t));
2559             log.error(pos, Errors.CyclicInheritance(t));
2560         } else if (t.hasTag(TYPEVAR)) {
2561             tv = (TypeVar)t;
2562             seen = seen.prepend(tv);
2563             for (Type b : types.getBounds(tv))
2564                 checkNonCyclic1(pos, b, seen);
2565         }
2566     }
2567 
2568     /** Check for cyclic references. Issue an error if the
2569      *  symbol of the type referred to has a LOCKED flag set.
2570      *
2571      *  @param pos      Position to be used for error reporting.
2572      *  @param t        The type referred to.
2573      *  @returns        True if the check completed on all attributed classes
2574      */
2575     private boolean checkNonCyclicInternal(DiagnosticPosition pos, Type t) {
2576         boolean complete = true; // was the check complete?
2577         //- System.err.println(&quot;checkNonCyclicInternal(&quot;+t+&quot;);&quot;);//DEBUG
2578         Symbol c = t.tsym;
2579         if ((c.flags_field &amp; ACYCLIC) != 0) return true;
2580 
2581         if ((c.flags_field &amp; LOCKED) != 0) {
2582             noteCyclic(pos, (ClassSymbol)c);
2583         } else if (!c.type.isErroneous()) {
2584             try {
2585                 c.flags_field |= LOCKED;
2586                 if (c.type.hasTag(CLASS)) {
2587                     ClassType clazz = (ClassType)c.type;
2588                     if (clazz.interfaces_field != null)
2589                         for (List&lt;Type&gt; l=clazz.interfaces_field; l.nonEmpty(); l=l.tail)
2590                             complete &amp;= checkNonCyclicInternal(pos, l.head);
2591                     if (clazz.supertype_field != null) {
2592                         Type st = clazz.supertype_field;
2593                         if (st != null &amp;&amp; st.hasTag(CLASS))
2594                             complete &amp;= checkNonCyclicInternal(pos, st);
2595                     }
2596                     if (c.owner.kind == TYP)
2597                         complete &amp;= checkNonCyclicInternal(pos, c.owner.type);
2598                 }
2599             } finally {
2600                 c.flags_field &amp;= ~LOCKED;
2601             }
2602         }
2603         if (complete)
2604             complete = ((c.flags_field &amp; UNATTRIBUTED) == 0) &amp;&amp; c.isCompleted();
2605         if (complete) c.flags_field |= ACYCLIC;
2606         return complete;
2607     }
2608 
2609     /** Note that we found an inheritance cycle. */
2610     private void noteCyclic(DiagnosticPosition pos, ClassSymbol c) {
2611         log.error(pos, Errors.CyclicInheritance(c));
2612         for (List&lt;Type&gt; l=types.interfaces(c.type); l.nonEmpty(); l=l.tail)
2613             l.head = types.createErrorType((ClassSymbol)l.head.tsym, Type.noType);
2614         Type st = types.supertype(c.type);
2615         if (st.hasTag(CLASS))
2616             ((ClassType)c.type).supertype_field = types.createErrorType((ClassSymbol)st.tsym, Type.noType);
2617         c.type = types.createErrorType(c, c.type);
2618         c.flags_field |= ACYCLIC;
2619     }
2620 
2621     /** Check that all methods which implement some
2622      *  method conform to the method they implement.
2623      *  @param tree         The class definition whose members are checked.
2624      */
2625     void checkImplementations(JCClassDecl tree) {
2626         checkImplementations(tree, tree.sym, tree.sym);
2627     }
2628     //where
2629         /** Check that all methods which implement some
2630          *  method in `ic&#39; conform to the method they implement.
2631          */
2632         void checkImplementations(JCTree tree, ClassSymbol origin, ClassSymbol ic) {
2633             for (List&lt;Type&gt; l = types.closure(ic.type); l.nonEmpty(); l = l.tail) {
2634                 ClassSymbol lc = (ClassSymbol)l.head.tsym;
2635                 if ((lc.flags() &amp; ABSTRACT) != 0) {
2636                     for (Symbol sym : lc.members().getSymbols(NON_RECURSIVE)) {
2637                         if (sym.kind == MTH &amp;&amp;
2638                             (sym.flags() &amp; (STATIC|ABSTRACT)) == ABSTRACT) {
2639                             MethodSymbol absmeth = (MethodSymbol)sym;
2640                             MethodSymbol implmeth = absmeth.implementation(origin, types, false);
2641                             if (implmeth != null &amp;&amp; implmeth != absmeth &amp;&amp;
2642                                 (implmeth.owner.flags() &amp; INTERFACE) ==
2643                                 (origin.flags() &amp; INTERFACE)) {
2644                                 // don&#39;t check if implmeth is in a class, yet
2645                                 // origin is an interface. This case arises only
2646                                 // if implmeth is declared in Object. The reason is
2647                                 // that interfaces really don&#39;t inherit from
2648                                 // Object it&#39;s just that the compiler represents
2649                                 // things that way.
2650                                 checkOverride(tree, implmeth, absmeth, origin);
2651                             }
2652                         }
2653                     }
2654                 }
2655             }
2656         }
2657 
2658     /** Check that all abstract methods implemented by a class are
2659      *  mutually compatible.
2660      *  @param pos          Position to be used for error reporting.
2661      *  @param c            The class whose interfaces are checked.
2662      */
2663     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2664         List&lt;Type&gt; supertypes = types.interfaces(c);
2665         Type supertype = types.supertype(c);
2666         if (supertype.hasTag(CLASS) &amp;&amp;
2667             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2668             supertypes = supertypes.prepend(supertype);
2669         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2670             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2671                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2672                 return;
2673             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2674                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2675                     return;
2676         }
2677         checkCompatibleConcretes(pos, c);
2678         boolean isIdentityObject = types.asSuper(c, syms.identityObjectType.tsym) != null;
2679         boolean isInlineObject = types.asSuper(c, syms.inlineObjectType.tsym) != null;
2680         if (types.isValue(c) &amp;&amp; isIdentityObject) {
2681             log.error(pos, Errors.InlineTypeMustNotImplementIdentityObject(c));
2682         } else if (!c.isInterface() &amp;&amp; !types.isValue(c) &amp;&amp; isInlineObject) {
2683             log.error(pos, Errors.IdentityTypeMustNotImplementInlineObject(c));
2684         } else if (isIdentityObject &amp;&amp; isInlineObject) {
2685             log.error(pos, Errors.MutuallyIncompatibleInterfaces(c));
2686         }
2687     }
2688 
2689     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2690      *  are mutually compatible (JLS 8.4.8/9.4.1).
2691      *
2692      *  @param pos  Position to be used for error reporting.
2693      *  @param site The class whose methods are checked.
2694      *  @param sym  The method symbol to be checked.
2695      */
2696     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2697          ClashFilter cf = new ClashFilter(site);
2698         //for each method m1 that is overridden (directly or indirectly)
2699         //by method &#39;sym&#39; in &#39;site&#39;...
2700 
2701         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2702         boolean overridesAny = false;
2703         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2704         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2705         for (Symbol m1 : symbolsByName) {
2706             if (!sym.overrides(m1, site.tsym, types, false)) {
2707                 if (m1 == sym) {
2708                     continue;
2709                 }
2710 
2711                 if (!overridesAny) {
2712                     potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);
2713                 }
2714                 continue;
2715             }
2716 
2717             if (m1 != sym) {
2718                 overridesAny = true;
2719                 potentiallyAmbiguousList = List.nil();
2720             }
2721 
2722             //...check each method m2 that is a member of &#39;site&#39;
2723             for (Symbol m2 : symbolsByName) {
2724                 if (m2 == m1) continue;
2725                 //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2726                 //a member of &#39;site&#39;) and (ii) m1 has the same erasure as m2, issue an error
2727                 if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &amp;&amp;
2728                         types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
2729                     sym.flags_field |= CLASH;
2730                     if (m1 == sym) {
2731                         log.error(pos, Errors.NameClashSameErasureNoOverride(
2732                             m1.name, types.memberType(site, m1).asMethodType().getParameterTypes(), m1.location(),
2733                             m2.name, types.memberType(site, m2).asMethodType().getParameterTypes(), m2.location()));
2734                     } else {
2735                         ClassType ct = (ClassType)site;
2736                         String kind = ct.isInterface() ? &quot;interface&quot; : &quot;class&quot;;
2737                         log.error(pos, Errors.NameClashSameErasureNoOverride1(
2738                             kind,
2739                             ct.tsym.name,
2740                             m1.name,
2741                             types.memberType(site, m1).asMethodType().getParameterTypes(),
2742                             m1.location(),
2743                             m2.name,
2744                             types.memberType(site, m2).asMethodType().getParameterTypes(),
2745                             m2.location()));
2746                     }
2747                     return;
2748                 }
2749             }
2750         }
2751 
2752         if (!overridesAny) {
2753             for (MethodSymbol m: potentiallyAmbiguousList) {
2754                 checkPotentiallyAmbiguousOverloads(pos, site, sym, m);
2755             }
2756         }
2757     }
2758 
2759     /** Check that all static methods accessible from &#39;site&#39; are
2760      *  mutually compatible (JLS 8.4.8).
2761      *
2762      *  @param pos  Position to be used for error reporting.
2763      *  @param site The class whose methods are checked.
2764      *  @param sym  The method symbol to be checked.
2765      */
2766     void checkHideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2767         ClashFilter cf = new ClashFilter(site);
2768         //for each method m1 that is a member of &#39;site&#39;...
2769         for (Symbol s : types.membersClosure(site, true).getSymbolsByName(sym.name, cf)) {
2770             //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2771             //a member of &#39;site&#39;) and (ii) &#39;sym&#39; has the same erasure as m1, issue an error
2772             if (!types.isSubSignature(sym.type, types.memberType(site, s), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source))) {
2773                 if (types.hasSameArgs(s.erasure(types), sym.erasure(types))) {
2774                     log.error(pos,
2775                               Errors.NameClashSameErasureNoHide(sym, sym.location(), s, s.location()));
2776                     return;
2777                 } else {
2778                     checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);
2779                 }
2780             }
2781          }
2782      }
2783 
2784      //where
2785      private class ClashFilter implements Filter&lt;Symbol&gt; {
2786 
2787          Type site;
2788 
2789          ClashFilter(Type site) {
2790              this.site = site;
2791          }
2792 
2793          boolean shouldSkip(Symbol s) {
2794              return (s.flags() &amp; CLASH) != 0 &amp;&amp;
2795                 s.owner == site.tsym;
2796          }
2797 
2798          public boolean accepts(Symbol s) {
2799              return s.kind == MTH &amp;&amp;
2800                      (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
2801                      !shouldSkip(s) &amp;&amp;
2802                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2803                      !s.isConstructor();
2804          }
2805      }
2806 
2807     void checkDefaultMethodClashes(DiagnosticPosition pos, Type site) {
2808         DefaultMethodClashFilter dcf = new DefaultMethodClashFilter(site);
2809         for (Symbol m : types.membersClosure(site, false).getSymbols(dcf)) {
2810             Assert.check(m.kind == MTH);
2811             List&lt;MethodSymbol&gt; prov = types.interfaceCandidates(site, (MethodSymbol)m);
2812             if (prov.size() &gt; 1) {
2813                 ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
2814                 ListBuffer&lt;Symbol&gt; defaults = new ListBuffer&lt;&gt;();
2815                 for (MethodSymbol provSym : prov) {
2816                     if ((provSym.flags() &amp; DEFAULT) != 0) {
2817                         defaults = defaults.append(provSym);
2818                     } else if ((provSym.flags() &amp; ABSTRACT) != 0) {
2819                         abstracts = abstracts.append(provSym);
2820                     }
2821                     if (defaults.nonEmpty() &amp;&amp; defaults.size() + abstracts.size() &gt;= 2) {
2822                         //strong semantics - issue an error if two sibling interfaces
2823                         //have two override-equivalent defaults - or if one is abstract
2824                         //and the other is default
2825                         Fragment diagKey;
2826                         Symbol s1 = defaults.first();
2827                         Symbol s2;
2828                         if (defaults.size() &gt; 1) {
2829                             s2 = defaults.toList().tail.head;
2830                             diagKey = Fragments.IncompatibleUnrelatedDefaults(Kinds.kindName(site.tsym), site,
2831                                     m.name, types.memberType(site, m).getParameterTypes(),
2832                                     s1.location(), s2.location());
2833 
2834                         } else {
2835                             s2 = abstracts.first();
2836                             diagKey = Fragments.IncompatibleAbstractDefault(Kinds.kindName(site.tsym), site,
2837                                     m.name, types.memberType(site, m).getParameterTypes(),
2838                                     s1.location(), s2.location());
2839                         }
2840                         log.error(pos, Errors.TypesIncompatible(s1.location().type, s2.location().type, diagKey));
2841                         break;
2842                     }
2843                 }
2844             }
2845         }
2846     }
2847 
2848     //where
2849      private class DefaultMethodClashFilter implements Filter&lt;Symbol&gt; {
2850 
2851          Type site;
2852 
2853          DefaultMethodClashFilter(Type site) {
2854              this.site = site;
2855          }
2856 
2857          public boolean accepts(Symbol s) {
2858              return s.kind == MTH &amp;&amp;
2859                      (s.flags() &amp; DEFAULT) != 0 &amp;&amp;
2860                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2861                      !s.isConstructor();
2862          }
2863      }
2864 
2865     /**
2866       * Report warnings for potentially ambiguous method declarations. Two declarations
2867       * are potentially ambiguous if they feature two unrelated functional interface
2868       * in same argument position (in which case, a call site passing an implicit
2869       * lambda would be ambiguous).
2870       */
2871     void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,
2872             MethodSymbol msym1, MethodSymbol msym2) {
2873         if (msym1 != msym2 &amp;&amp;
2874                 Feature.DEFAULT_METHODS.allowedInSource(source) &amp;&amp;
2875                 lint.isEnabled(LintCategory.OVERLOADS) &amp;&amp;
2876                 (msym1.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0 &amp;&amp;
2877                 (msym2.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0) {
2878             Type mt1 = types.memberType(site, msym1);
2879             Type mt2 = types.memberType(site, msym2);
2880             //if both generic methods, adjust type variables
2881             if (mt1.hasTag(FORALL) &amp;&amp; mt2.hasTag(FORALL) &amp;&amp;
2882                     types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {
2883                 mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);
2884             }
2885             //expand varargs methods if needed
2886             int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());
2887             List&lt;Type&gt; args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);
2888             List&lt;Type&gt; args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);
2889             //if arities don&#39;t match, exit
2890             if (args1.length() != args2.length()) return;
2891             boolean potentiallyAmbiguous = false;
2892             while (args1.nonEmpty() &amp;&amp; args2.nonEmpty()) {
2893                 Type s = args1.head;
2894                 Type t = args2.head;
2895                 if (!types.isSubtype(t, s) &amp;&amp; !types.isSubtype(s, t)) {
2896                     if (types.isFunctionalInterface(s) &amp;&amp; types.isFunctionalInterface(t) &amp;&amp;
2897                             types.findDescriptorType(s).getParameterTypes().length() &gt; 0 &amp;&amp;
2898                             types.findDescriptorType(s).getParameterTypes().length() ==
2899                             types.findDescriptorType(t).getParameterTypes().length()) {
2900                         potentiallyAmbiguous = true;
2901                     } else {
2902                         break;
2903                     }
2904                 }
2905                 args1 = args1.tail;
2906                 args2 = args2.tail;
2907             }
2908             if (potentiallyAmbiguous) {
2909                 //we found two incompatible functional interfaces with same arity
2910                 //this means a call site passing an implicit lambda would be ambiguous
2911                 msym1.flags_field |= POTENTIALLY_AMBIGUOUS;
2912                 msym2.flags_field |= POTENTIALLY_AMBIGUOUS;
2913                 log.warning(LintCategory.OVERLOADS, pos,
2914                             Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),
2915                                                                   msym2, msym2.location()));
2916                 return;
2917             }
2918         }
2919     }
2920 
2921     void checkAccessFromSerializableElement(final JCTree tree, boolean isLambda) {
2922         if (warnOnAnyAccessToMembers ||
2923             (lint.isEnabled(LintCategory.SERIAL) &amp;&amp;
2924             !lint.isSuppressed(LintCategory.SERIAL) &amp;&amp;
2925             isLambda)) {
2926             Symbol sym = TreeInfo.symbol(tree);
2927             if (!sym.kind.matches(KindSelector.VAL_MTH)) {
2928                 return;
2929             }
2930 
2931             if (sym.kind == VAR) {
2932                 if ((sym.flags() &amp; PARAMETER) != 0 ||
2933                     sym.isLocal() ||
2934                     sym.name == names._this ||
2935                     sym.name == names._super) {
2936                     return;
2937                 }
2938             }
2939 
2940             if (!types.isSubtype(sym.owner.type, syms.serializableType) &amp;&amp;
2941                 isEffectivelyNonPublic(sym)) {
2942                 if (isLambda) {
2943                     if (belongsToRestrictedPackage(sym)) {
2944                         log.warning(LintCategory.SERIAL, tree.pos(),
2945                                     Warnings.AccessToMemberFromSerializableLambda(sym));
2946                     }
2947                 } else {
2948                     log.warning(tree.pos(),
2949                                 Warnings.AccessToMemberFromSerializableElement(sym));
2950                 }
2951             }
2952         }
2953     }
2954 
2955     private boolean isEffectivelyNonPublic(Symbol sym) {
2956         if (sym.packge() == syms.rootPackage) {
2957             return false;
2958         }
2959 
2960         while (sym.kind != PCK) {
2961             if ((sym.flags() &amp; PUBLIC) == 0) {
2962                 return true;
2963             }
2964             sym = sym.owner;
2965         }
2966         return false;
2967     }
2968 
2969     private boolean belongsToRestrictedPackage(Symbol sym) {
2970         String fullName = sym.packge().fullname.toString();
2971         return fullName.startsWith(&quot;java.&quot;) ||
2972                 fullName.startsWith(&quot;javax.&quot;) ||
2973                 fullName.startsWith(&quot;sun.&quot;) ||
2974                 fullName.contains(&quot;.internal.&quot;);
2975     }
2976 
2977     /** Check that class c does not implement directly or indirectly
2978      *  the same parameterized interface with two different argument lists.
2979      *  @param pos          Position to be used for error reporting.
2980      *  @param type         The type whose interfaces are checked.
2981      */
2982     void checkClassBounds(DiagnosticPosition pos, Type type) {
2983         checkClassBounds(pos, new HashMap&lt;TypeSymbol,Type&gt;(), type);
2984     }
2985 //where
2986         /** Enter all interfaces of type `type&#39; into the hash table `seensofar&#39;
2987          *  with their class symbol as key and their type as value. Make
2988          *  sure no class is entered with two different types.
2989          */
2990         void checkClassBounds(DiagnosticPosition pos,
2991                               Map&lt;TypeSymbol,Type&gt; seensofar,
2992                               Type type) {
2993             if (type.isErroneous()) return;
2994             for (List&lt;Type&gt; l = types.interfaces(type); l.nonEmpty(); l = l.tail) {
2995                 Type it = l.head;
2996                 if (type.hasTag(CLASS) &amp;&amp; !it.hasTag(CLASS)) continue; // JLS 8.1.5
2997 
2998                 Type oldit = seensofar.put(it.tsym, it);
2999                 if (oldit != null) {
3000                     List&lt;Type&gt; oldparams = oldit.allparams();
3001                     List&lt;Type&gt; newparams = it.allparams();
3002                     if (!types.containsTypeEquivalent(oldparams, newparams))
3003                         log.error(pos,
3004                                   Errors.CantInheritDiffArg(it.tsym,
3005                                                             Type.toString(oldparams),
3006                                                             Type.toString(newparams)));
3007                 }
3008                 checkClassBounds(pos, seensofar, it);
3009             }
3010             Type st = types.supertype(type);
3011             if (type.hasTag(CLASS) &amp;&amp; !st.hasTag(CLASS)) return; // JLS 8.1.4
3012             if (st != Type.noType) checkClassBounds(pos, seensofar, st);
3013         }
3014 
3015     /** Enter interface into into set.
3016      *  If it existed already, issue a &quot;repeated interface&quot; error.
3017      */
3018     void checkNotRepeated(DiagnosticPosition pos, Type it, Set&lt;Type&gt; its) {
3019         if (its.contains(it))
3020             log.error(pos, Errors.RepeatedInterface);
3021         else {
3022             its.add(it);
3023         }
3024     }
3025 
3026 /* *************************************************************************
3027  * Check annotations
3028  **************************************************************************/
3029 
3030     /**
3031      * Recursively validate annotations values
3032      */
3033     void validateAnnotationTree(JCTree tree) {
3034         class AnnotationValidator extends TreeScanner {
3035             @Override
3036             public void visitAnnotation(JCAnnotation tree) {
3037                 if (!tree.type.isErroneous() &amp;&amp; tree.type.tsym.isAnnotationType()) {
3038                     super.visitAnnotation(tree);
3039                     validateAnnotation(tree);
3040                 }
3041             }
3042         }
3043         tree.accept(new AnnotationValidator());
3044     }
3045 
3046     /**
3047      *  {@literal
3048      *  Annotation types are restricted to primitives, String, an
3049      *  enum, an annotation, Class, Class&lt;?&gt;, Class&lt;? extends
3050      *  Anything&gt;, arrays of the preceding.
3051      *  }
3052      */
3053     void validateAnnotationType(JCTree restype) {
3054         // restype may be null if an error occurred, so don&#39;t bother validating it
3055         if (restype != null) {
3056             validateAnnotationType(restype.pos(), restype.type);
3057         }
3058     }
3059 
3060     void validateAnnotationType(DiagnosticPosition pos, Type type) {
3061         if (type.isPrimitive()) return;
3062         if (types.isSameType(type, syms.stringType)) return;
3063         if ((type.tsym.flags() &amp; Flags.ENUM) != 0) return;
3064         if ((type.tsym.flags() &amp; Flags.ANNOTATION) != 0) return;
3065         if (types.cvarLowerBound(type).tsym == syms.classType.tsym) return;
3066         if (types.isArray(type) &amp;&amp; !types.isArray(types.elemtype(type))) {
3067             validateAnnotationType(pos, types.elemtype(type));
3068             return;
3069         }
3070         log.error(pos, Errors.InvalidAnnotationMemberType);
3071     }
3072 
3073     /**
3074      * &quot;It is also a compile-time error if any method declared in an
3075      * annotation type has a signature that is override-equivalent to
3076      * that of any public or protected method declared in class Object
3077      * or in the interface annotation.Annotation.&quot;
3078      *
3079      * @jls 9.6 Annotation Types
3080      */
3081     void validateAnnotationMethod(DiagnosticPosition pos, MethodSymbol m) {
3082         for (Type sup = syms.annotationType; sup.hasTag(CLASS); sup = types.supertype(sup)) {
3083             Scope s = sup.tsym.members();
3084             for (Symbol sym : s.getSymbolsByName(m.name)) {
3085                 if (sym.kind == MTH &amp;&amp;
3086                     (sym.flags() &amp; (PUBLIC | PROTECTED)) != 0 &amp;&amp;
3087                     types.overrideEquivalent(m.type, sym.type))
3088                     log.error(pos, Errors.IntfAnnotationMemberClash(sym, sup));
3089             }
3090         }
3091     }
3092 
3093     /** Check the annotations of a symbol.
3094      */
3095     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, JCTree declarationTree, Symbol s) {
3096         for (JCAnnotation a : annotations)
3097             validateAnnotation(a, declarationTree, s);
3098     }
3099 
3100     /** Check the type annotations.
3101      */
3102     public void validateTypeAnnotations(List&lt;JCAnnotation&gt; annotations, boolean isTypeParameter) {
3103         for (JCAnnotation a : annotations)
3104             validateTypeAnnotation(a, isTypeParameter);
3105     }
3106 
3107     /** Check an annotation of a symbol.
3108      */
3109     private void validateAnnotation(JCAnnotation a, JCTree declarationTree, Symbol s) {
3110         validateAnnotationTree(a);
3111         boolean isRecordMember = (s.flags_field &amp; RECORD) != 0 || s.enclClass() != null &amp;&amp; s.enclClass().isRecord();
3112 
3113         boolean isRecordField = isRecordMember &amp;&amp;
3114                 (s.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
3115                 declarationTree.hasTag(VARDEF) &amp;&amp;
3116                 s.owner.kind == TYP;
3117 
3118         if (isRecordField) {
3119             // first we need to check if the annotation is applicable to records
3120             Name[] targets = getTargetNames(a);
3121             boolean appliesToRecords = false;
3122             for (Name target : targets) {
3123                 appliesToRecords =
3124                                 target == names.FIELD ||
3125                                 target == names.PARAMETER ||
3126                                 target == names.METHOD ||
3127                                 target == names.TYPE_USE ||
3128                                 target == names.RECORD_COMPONENT;
3129                 if (appliesToRecords) {
3130                     break;
3131                 }
3132             }
3133             if (!appliesToRecords) {
3134                 log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3135             } else {
3136                 /* lets now find the annotations in the field that are targeted to record components and append them to
3137                  * the corresponding record component
3138                  */
3139                 ClassSymbol recordClass = (ClassSymbol) s.owner;
3140                 RecordComponent rc = recordClass.getRecordComponent((VarSymbol)s);
3141                 SymbolMetadata metadata = rc.getMetadata();
3142                 if (metadata == null || metadata.isEmpty()) {
3143                     /* if not is empty then we have already been here, which is the case if multiple annotations are applied
3144                      * to the record component declaration
3145                      */
3146                     rc.appendAttributes(s.getRawAttributes().stream().filter(anno -&gt;
3147                             Arrays.stream(getTargetNames(anno.type.tsym)).anyMatch(name -&gt; name == names.RECORD_COMPONENT)
3148                     ).collect(List.collector()));
3149                     rc.setTypeAttributes(s.getRawTypeAttributes());
3150                     // to get all the type annotations applied to the type
3151                     rc.type = s.type;
3152                 }
3153             }
3154         }
3155 
3156         /* the section below is tricky. Annotations applied to record components are propagated to the corresponding
3157          * record member so if an annotation has target: FIELD, it is propagated to the corresponding FIELD, if it has
3158          * target METHOD, it is propagated to the accessor and so on. But at the moment when method members are generated
3159          * there is no enough information to propagate only the right annotations. So all the annotations are propagated
3160          * to all the possible locations.
3161          *
3162          * At this point we need to remove all the annotations that are not in place before going on with the annotation
3163          * party. On top of the above there is the issue that there is no AST representing record components, just symbols
3164          * so the corresponding field has been holding all the annotations and it&#39;s metadata has been modified as if it
3165          * was both a field and a record component.
3166          *
3167          * So there are two places where we need to trim annotations from: the metadata of the symbol and / or the modifiers
3168          * in the AST. Whatever is in the metadata will be written to the class file, whatever is in the modifiers could
3169          * be see by annotation processors.
3170          *
3171          * The metadata contains both type annotations and declaration annotations. At this point of the game we don&#39;t
3172          * need to care about type annotations, they are all in the right place. But we could need to remove declaration
3173          * annotations. So for declaration annotations if they are not applicable to the record member, excluding type
3174          * annotations which are already correct, then we will remove it. For the AST modifiers if the annotation is not
3175          * applicable either as type annotation and or declaration annotation, only in that case it will be removed.
3176          *
3177          * So it could be that annotation is removed as a declaration annotation but it is kept in the AST modifier for
3178          * further inspection by annotation processors.
3179          *
3180          * For example:
3181          *
3182          *     import java.lang.annotation.*;
3183          *
3184          *     @Target({ElementType.TYPE_USE, ElementType.RECORD_COMPONENT})
3185          *     @Retention(RetentionPolicy.RUNTIME)
3186          *     @interface Anno { }
3187          *
3188          *     record R(@Anno String s) {}
3189          *
3190          * at this point we will have for the case of the generated field:
3191          *   - @Anno in the modifier
3192          *   - @Anno as a type annotation
3193          *   - @Anno as a declaration annotation
3194          *
3195          * the last one should be removed because the annotation has not FIELD as target but it was applied as a
3196          * declaration annotation because the field was being treated both as a field and as a record component
3197          * as we have already copied the annotations to the record component, now the field doesn&#39;t need to hold
3198          * annotations that are not intended for it anymore. Still @Anno has to be kept in the AST&#39;s modifiers as it
3199          * is applicable as a type annotation to the type of the field.
3200          */
3201 
3202         if (a.type.tsym.isAnnotationType()) {
3203             Optional&lt;Set&lt;Name&gt;&gt; applicableTargetsOp = getApplicableTargets(a, s);
3204             if (!applicableTargetsOp.isEmpty()) {
3205                 Set&lt;Name&gt; applicableTargets = applicableTargetsOp.get();
3206                 boolean notApplicableOrIsTypeUseOnly = applicableTargets.isEmpty() ||
3207                         applicableTargets.size() == 1 &amp;&amp; applicableTargets.contains(names.TYPE_USE);
3208                 boolean isRecordMemberWithNonApplicableDeclAnno =
3209                         isRecordMember &amp;&amp; (s.flags_field &amp; Flags.GENERATED_MEMBER) != 0 &amp;&amp; notApplicableOrIsTypeUseOnly;
3210 
3211                 if (applicableTargets.isEmpty() || isRecordMemberWithNonApplicableDeclAnno) {
3212                     if (isRecordMemberWithNonApplicableDeclAnno) {
3213                             /* so we have found an annotation that is not applicable to a record member that was generated by the
3214                              * compiler. This was intentionally done at TypeEnter, now is the moment strip away the annotations
3215                              * that are not applicable to the given record member
3216                              */
3217                         JCModifiers modifiers = TreeInfo.getModifiers(declarationTree);
3218                             /* lets first remove the annotation from the modifier if it is not applicable, we have to check again as
3219                              * it could be a type annotation
3220                              */
3221                         if (modifiers != null &amp;&amp; applicableTargets.isEmpty()) {
3222                             ListBuffer&lt;JCAnnotation&gt; newAnnotations = new ListBuffer&lt;&gt;();
3223                             for (JCAnnotation anno : modifiers.annotations) {
3224                                 if (anno != a) {
3225                                     newAnnotations.add(anno);
3226                                 }
3227                             }
3228                             modifiers.annotations = newAnnotations.toList();
3229                         }
3230                         // now lets remove it from the symbol
3231                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3232                     } else {
3233                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3234                     }
3235                 }
3236             }
3237         }
3238 
3239         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3240             if (s.kind != TYP) {
3241                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3242             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3243                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3244             }
3245         }
3246         if (a.annotationType.type.tsym == syms.valueBasedType.tsym) {
3247             if (s.isInterface() || s.isEnum()) {
3248                 log.error(a.pos(), Errors.BadValueBasedAnno);
3249             } else if (allowValueBasedClasses) {
3250                 s.flags_field |= VALUEBASED;
3251             }
3252         }
3253     }
3254 
3255     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3256         Assert.checkNonNull(a.type);
3257         validateAnnotationTree(a);
3258 
3259         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3260                 !a.annotationType.type.isErroneous() &amp;&amp;
3261                 !isTypeAnnotation(a, isTypeParameter)) {
3262             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3263         }
3264     }
3265 
3266     /**
3267      * Validate the proposed container &#39;repeatable&#39; on the
3268      * annotation type symbol &#39;s&#39;. Report errors at position
3269      * &#39;pos&#39;.
3270      *
3271      * @param s The (annotation)type declaration annotated with a @Repeatable
3272      * @param repeatable the @Repeatable on &#39;s&#39;
3273      * @param pos where to report errors
3274      */
3275     public void validateRepeatable(TypeSymbol s, Attribute.Compound repeatable, DiagnosticPosition pos) {
3276         Assert.check(types.isSameType(repeatable.type, syms.repeatableType));
3277 
3278         Type t = null;
3279         List&lt;Pair&lt;MethodSymbol,Attribute&gt;&gt; l = repeatable.values;
3280         if (!l.isEmpty()) {
3281             Assert.check(l.head.fst.name == names.value);
3282             t = ((Attribute.Class)l.head.snd).getValue();
3283         }
3284 
3285         if (t == null) {
3286             // errors should already have been reported during Annotate
3287             return;
3288         }
3289 
3290         validateValue(t.tsym, s, pos);
3291         validateRetention(t.tsym, s, pos);
3292         validateDocumented(t.tsym, s, pos);
3293         validateInherited(t.tsym, s, pos);
3294         validateTarget(t.tsym, s, pos);
3295         validateDefault(t.tsym, pos);
3296     }
3297 
3298     private void validateValue(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3299         Symbol sym = container.members().findFirst(names.value);
3300         if (sym != null &amp;&amp; sym.kind == MTH) {
3301             MethodSymbol m = (MethodSymbol) sym;
3302             Type ret = m.getReturnType();
3303             if (!(ret.hasTag(ARRAY) &amp;&amp; types.isSameType(((ArrayType)ret).elemtype, contained.type))) {
3304                 log.error(pos,
3305                           Errors.InvalidRepeatableAnnotationValueReturn(container,
3306                                                                         ret,
3307                                                                         types.makeArrayType(contained.type)));
3308             }
3309         } else {
3310             log.error(pos, Errors.InvalidRepeatableAnnotationNoValue(container));
3311         }
3312     }
3313 
3314     private void validateRetention(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3315         Attribute.RetentionPolicy containerRetention = types.getRetention(container);
3316         Attribute.RetentionPolicy containedRetention = types.getRetention(contained);
3317 
3318         boolean error = false;
3319         switch (containedRetention) {
3320         case RUNTIME:
3321             if (containerRetention != Attribute.RetentionPolicy.RUNTIME) {
3322                 error = true;
3323             }
3324             break;
3325         case CLASS:
3326             if (containerRetention == Attribute.RetentionPolicy.SOURCE)  {
3327                 error = true;
3328             }
3329         }
3330         if (error ) {
3331             log.error(pos,
3332                       Errors.InvalidRepeatableAnnotationRetention(container,
3333                                                                   containerRetention.name(),
3334                                                                   contained,
3335                                                                   containedRetention.name()));
3336         }
3337     }
3338 
3339     private void validateDocumented(Symbol container, Symbol contained, DiagnosticPosition pos) {
3340         if (contained.attribute(syms.documentedType.tsym) != null) {
3341             if (container.attribute(syms.documentedType.tsym) == null) {
3342                 log.error(pos, Errors.InvalidRepeatableAnnotationNotDocumented(container, contained));
3343             }
3344         }
3345     }
3346 
3347     private void validateInherited(Symbol container, Symbol contained, DiagnosticPosition pos) {
3348         if (contained.attribute(syms.inheritedType.tsym) != null) {
3349             if (container.attribute(syms.inheritedType.tsym) == null) {
3350                 log.error(pos, Errors.InvalidRepeatableAnnotationNotInherited(container, contained));
3351             }
3352         }
3353     }
3354 
3355     private void validateTarget(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3356         // The set of targets the container is applicable to must be a subset
3357         // (with respect to annotation target semantics) of the set of targets
3358         // the contained is applicable to. The target sets may be implicit or
3359         // explicit.
3360 
3361         Set&lt;Name&gt; containerTargets;
3362         Attribute.Array containerTarget = getAttributeTargetAttribute(container);
3363         if (containerTarget == null) {
3364             containerTargets = getDefaultTargetSet();
3365         } else {
3366             containerTargets = new HashSet&lt;&gt;();
3367             for (Attribute app : containerTarget.values) {
3368                 if (!(app instanceof Attribute.Enum)) {
3369                     continue; // recovery
3370                 }
3371                 Attribute.Enum e = (Attribute.Enum)app;
3372                 containerTargets.add(e.value.name);
3373             }
3374         }
3375 
3376         Set&lt;Name&gt; containedTargets;
3377         Attribute.Array containedTarget = getAttributeTargetAttribute(contained);
3378         if (containedTarget == null) {
3379             containedTargets = getDefaultTargetSet();
3380         } else {
3381             containedTargets = new HashSet&lt;&gt;();
3382             for (Attribute app : containedTarget.values) {
3383                 if (!(app instanceof Attribute.Enum)) {
3384                     continue; // recovery
3385                 }
3386                 Attribute.Enum e = (Attribute.Enum)app;
3387                 containedTargets.add(e.value.name);
3388             }
3389         }
3390 
3391         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3392             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3393         }
3394     }
3395 
3396     /* get a set of names for the default target */
3397     private Set&lt;Name&gt; getDefaultTargetSet() {
3398         if (defaultTargets == null) {
3399             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3400             targets.add(names.ANNOTATION_TYPE);
3401             targets.add(names.CONSTRUCTOR);
3402             targets.add(names.FIELD);
3403             if (allowRecords) {
3404                 targets.add(names.RECORD_COMPONENT);
3405             }
3406             targets.add(names.LOCAL_VARIABLE);
3407             targets.add(names.METHOD);
3408             targets.add(names.PACKAGE);
3409             targets.add(names.PARAMETER);
3410             targets.add(names.TYPE);
3411 
3412             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3413         }
3414 
3415         return defaultTargets;
3416     }
3417     private Set&lt;Name&gt; defaultTargets;
3418 
3419 
3420     /** Checks that s is a subset of t, with respect to ElementType
3421      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3422      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3423      * TYPE_PARAMETER}.
3424      */
3425     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
3426         // Check that all elements in s are present in t
3427         for (Name n2 : s) {
3428             boolean currentElementOk = false;
3429             for (Name n1 : t) {
3430                 if (n1 == n2) {
3431                     currentElementOk = true;
3432                     break;
3433                 } else if (n1 == names.TYPE &amp;&amp; n2 == names.ANNOTATION_TYPE) {
3434                     currentElementOk = true;
3435                     break;
3436                 } else if (n1 == names.TYPE_USE &amp;&amp;
3437                         (n2 == names.TYPE ||
3438                          n2 == names.ANNOTATION_TYPE ||
3439                          n2 == names.TYPE_PARAMETER)) {
3440                     currentElementOk = true;
3441                     break;
3442                 }
3443             }
3444             if (!currentElementOk)
3445                 return false;
3446         }
3447         return true;
3448     }
3449 
3450     private void validateDefault(Symbol container, DiagnosticPosition pos) {
3451         // validate that all other elements of containing type has defaults
3452         Scope scope = container.members();
3453         for(Symbol elm : scope.getSymbols()) {
3454             if (elm.name != names.value &amp;&amp;
3455                 elm.kind == MTH &amp;&amp;
3456                 ((MethodSymbol)elm).defaultValue == null) {
3457                 log.error(pos,
3458                           Errors.InvalidRepeatableAnnotationElemNondefault(container, elm));
3459             }
3460         }
3461     }
3462 
3463     /** Is s a method symbol that overrides a method in a superclass? */
3464     boolean isOverrider(Symbol s) {
3465         if (s.kind != MTH || s.isStatic())
3466             return false;
3467         MethodSymbol m = (MethodSymbol)s;
3468         TypeSymbol owner = (TypeSymbol)m.owner;
3469         for (Type sup : types.closure(owner.type)) {
3470             if (sup == owner.type)
3471                 continue; // skip &quot;this&quot;
3472             Scope scope = sup.tsym.members();
3473             for (Symbol sym : scope.getSymbolsByName(m.name)) {
3474                 if (!sym.isStatic() &amp;&amp; m.overrides(sym, owner, types, true))
3475                     return true;
3476             }
3477         }
3478         return false;
3479     }
3480 
3481     /** Is the annotation applicable to types? */
3482     protected boolean isTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3483         List&lt;Attribute&gt; targets = typeAnnotations.annotationTargets(a.annotationType.type.tsym);
3484         return (targets == null) ?
3485                 false :
3486                 targets.stream()
3487                         .anyMatch(attr -&gt; isTypeAnnotation(attr, isTypeParameter));
3488     }
3489     //where
3490         boolean isTypeAnnotation(Attribute a, boolean isTypeParameter) {
3491             Attribute.Enum e = (Attribute.Enum)a;
3492             return (e.value.name == names.TYPE_USE ||
3493                     (isTypeParameter &amp;&amp; e.value.name == names.TYPE_PARAMETER));
3494         }
3495 
3496     /** Is the annotation applicable to the symbol? */
3497     Name[] getTargetNames(JCAnnotation a) {
3498         return getTargetNames(a.annotationType.type.tsym);
3499     }
3500 
3501     public Name[] getTargetNames(TypeSymbol annoSym) {
3502         Attribute.Array arr = getAttributeTargetAttribute(annoSym);
3503         Name[] targets;
3504         if (arr == null) {
3505             targets = defaultTargetMetaInfo();
3506         } else {
3507             // TODO: can we optimize this?
3508             targets = new Name[arr.values.length];
3509             for (int i=0; i&lt;arr.values.length; ++i) {
3510                 Attribute app = arr.values[i];
3511                 if (!(app instanceof Attribute.Enum)) {
3512                     return new Name[0];
3513                 }
3514                 Attribute.Enum e = (Attribute.Enum) app;
3515                 targets[i] = e.value.name;
3516             }
3517         }
3518         return targets;
3519     }
3520 
3521     boolean annotationApplicable(JCAnnotation a, Symbol s) {
3522         Optional&lt;Set&lt;Name&gt;&gt; targets = getApplicableTargets(a, s);
3523         /* the optional could be emtpy if the annotation is unknown in that case
3524          * we return that it is applicable and if it is erroneous that should imply
3525          * an error at the declaration site
3526          */
3527         return targets.isEmpty() || targets.isPresent() &amp;&amp; !targets.get().isEmpty();
3528     }
3529 
3530     @SuppressWarnings(&quot;preview&quot;)
3531     Optional&lt;Set&lt;Name&gt;&gt; getApplicableTargets(JCAnnotation a, Symbol s) {
3532         Attribute.Array arr = getAttributeTargetAttribute(a.annotationType.type.tsym);
3533         Name[] targets;
3534         Set&lt;Name&gt; applicableTargets = new HashSet&lt;&gt;();
3535 
3536         if (arr == null) {
3537             targets = defaultTargetMetaInfo();
3538         } else {
3539             // TODO: can we optimize this?
3540             targets = new Name[arr.values.length];
3541             for (int i=0; i&lt;arr.values.length; ++i) {
3542                 Attribute app = arr.values[i];
3543                 if (!(app instanceof Attribute.Enum)) {
3544                     // recovery
3545                     return Optional.empty();
3546                 }
3547                 Attribute.Enum e = (Attribute.Enum) app;
3548                 targets[i] = e.value.name;
3549             }
3550         }
3551         for (Name target : targets) {
3552             if (target == names.TYPE) {
3553                 if (s.kind == TYP)
3554                     applicableTargets.add(names.TYPE);
3555             } else if (target == names.FIELD) {
3556                 if (s.kind == VAR &amp;&amp; s.owner.kind != MTH)
3557                     applicableTargets.add(names.FIELD);
3558             } else if (target == names.RECORD_COMPONENT) {
3559                 if (s.getKind() == ElementKind.RECORD_COMPONENT) {
3560                     applicableTargets.add(names.RECORD_COMPONENT);
3561                 }
3562             } else if (target == names.METHOD) {
3563                 if (s.kind == MTH &amp;&amp; !s.isConstructor())
3564                     applicableTargets.add(names.METHOD);
3565             } else if (target == names.PARAMETER) {
3566                 if (s.kind == VAR &amp;&amp;
3567                     (s.owner.kind == MTH &amp;&amp; (s.flags() &amp; PARAMETER) != 0)) {
3568                     applicableTargets.add(names.PARAMETER);
3569                 }
3570             } else if (target == names.CONSTRUCTOR) {
3571                 if (s.kind == MTH &amp;&amp; s.isConstructor())
3572                     applicableTargets.add(names.CONSTRUCTOR);
3573             } else if (target == names.LOCAL_VARIABLE) {
3574                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;
3575                       (s.flags() &amp; PARAMETER) == 0) {
3576                     applicableTargets.add(names.LOCAL_VARIABLE);
3577                 }
3578             } else if (target == names.ANNOTATION_TYPE) {
3579                 if (s.kind == TYP &amp;&amp; (s.flags() &amp; ANNOTATION) != 0) {
3580                     applicableTargets.add(names.ANNOTATION_TYPE);
3581                 }
3582             } else if (target == names.PACKAGE) {
3583                 if (s.kind == PCK)
3584                     applicableTargets.add(names.PACKAGE);
3585             } else if (target == names.TYPE_USE) {
3586                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp; s.type.hasTag(NONE)) {
3587                     //cannot type annotate implicitly typed locals
3588                     continue;
3589                 } else if (s.kind == TYP || s.kind == VAR ||
3590                         (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
3591                                 !s.type.getReturnType().hasTag(VOID)) ||
3592                         (s.kind == MTH &amp;&amp; s.isConstructor())) {
3593                     applicableTargets.add(names.TYPE_USE);
3594                 }
3595             } else if (target == names.TYPE_PARAMETER) {
3596                 if (s.kind == TYP &amp;&amp; s.type.hasTag(TYPEVAR))
3597                     applicableTargets.add(names.TYPE_PARAMETER);
3598             } else
3599                 return Optional.empty(); // Unknown ElementType. This should be an error at declaration site,
3600                                          // assume applicable.
3601         }
3602         return Optional.of(applicableTargets);
3603     }
3604 
3605     Attribute.Array getAttributeTargetAttribute(TypeSymbol s) {
3606         Attribute.Compound atTarget = s.getAnnotationTypeMetadata().getTarget();
3607         if (atTarget == null) return null; // ok, is applicable
3608         Attribute atValue = atTarget.member(names.value);
3609         if (!(atValue instanceof Attribute.Array)) return null; // error recovery
3610         return (Attribute.Array) atValue;
3611     }
3612 
3613     public final Name[] dfltTargetMeta;
3614     private Name[] defaultTargetMetaInfo() {
3615         return dfltTargetMeta;
3616     }
3617 
3618     /** Check an annotation value.
3619      *
3620      * @param a The annotation tree to check
3621      * @return true if this annotation tree is valid, otherwise false
3622      */
3623     public boolean validateAnnotationDeferErrors(JCAnnotation a) {
3624         boolean res = false;
3625         final Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
3626         try {
3627             res = validateAnnotation(a);
3628         } finally {
3629             log.popDiagnosticHandler(diagHandler);
3630         }
3631         return res;
3632     }
3633 
3634     private boolean validateAnnotation(JCAnnotation a) {
3635         boolean isValid = true;
3636         AnnotationTypeMetadata metadata = a.annotationType.type.tsym.getAnnotationTypeMetadata();
3637 
3638         // collect an inventory of the annotation elements
3639         Set&lt;MethodSymbol&gt; elements = metadata.getAnnotationElements();
3640 
3641         // remove the ones that are assigned values
3642         for (JCTree arg : a.args) {
3643             if (!arg.hasTag(ASSIGN)) continue; // recovery
3644             JCAssign assign = (JCAssign)arg;
3645             Symbol m = TreeInfo.symbol(assign.lhs);
3646             if (m == null || m.type.isErroneous()) continue;
3647             if (!elements.remove(m)) {
3648                 isValid = false;
3649                 log.error(assign.lhs.pos(),
3650                           Errors.DuplicateAnnotationMemberValue(m.name, a.type));
3651             }
3652         }
3653 
3654         // all the remaining ones better have default values
3655         List&lt;Name&gt; missingDefaults = List.nil();
3656         Set&lt;MethodSymbol&gt; membersWithDefault = metadata.getAnnotationElementsWithDefault();
3657         for (MethodSymbol m : elements) {
3658             if (m.type.isErroneous())
3659                 continue;
3660 
3661             if (!membersWithDefault.contains(m))
3662                 missingDefaults = missingDefaults.append(m.name);
3663         }
3664         missingDefaults = missingDefaults.reverse();
3665         if (missingDefaults.nonEmpty()) {
3666             isValid = false;
3667             Error errorKey = (missingDefaults.size() &gt; 1)
3668                     ? Errors.AnnotationMissingDefaultValue1(a.type, missingDefaults)
3669                     : Errors.AnnotationMissingDefaultValue(a.type, missingDefaults);
3670             log.error(a.pos(), errorKey);
3671         }
3672 
3673         return isValid &amp;&amp; validateTargetAnnotationValue(a);
3674     }
3675 
3676     /* Validate the special java.lang.annotation.Target annotation */
3677     boolean validateTargetAnnotationValue(JCAnnotation a) {
3678         // special case: java.lang.annotation.Target must not have
3679         // repeated values in its value member
3680         if (a.annotationType.type.tsym != syms.annotationTargetType.tsym ||
3681                 a.args.tail == null)
3682             return true;
3683 
3684         boolean isValid = true;
3685         if (!a.args.head.hasTag(ASSIGN)) return false; // error recovery
3686         JCAssign assign = (JCAssign) a.args.head;
3687         Symbol m = TreeInfo.symbol(assign.lhs);
3688         if (m.name != names.value) return false;
3689         JCTree rhs = assign.rhs;
3690         if (!rhs.hasTag(NEWARRAY)) return false;
3691         JCNewArray na = (JCNewArray) rhs;
3692         Set&lt;Symbol&gt; targets = new HashSet&lt;&gt;();
3693         for (JCTree elem : na.elems) {
3694             if (!targets.add(TreeInfo.symbol(elem))) {
3695                 isValid = false;
3696                 log.error(elem.pos(), Errors.RepeatedAnnotationTarget);
3697             }
3698         }
3699         return isValid;
3700     }
3701 
3702     void checkDeprecatedAnnotation(DiagnosticPosition pos, Symbol s) {
3703         if (lint.isEnabled(LintCategory.DEP_ANN) &amp;&amp; s.isDeprecatableViaAnnotation() &amp;&amp;
3704             (s.flags() &amp; DEPRECATED) != 0 &amp;&amp;
3705             !syms.deprecatedType.isErroneous() &amp;&amp;
3706             s.attribute(syms.deprecatedType.tsym) == null) {
3707             log.warning(LintCategory.DEP_ANN,
3708                     pos, Warnings.MissingDeprecatedAnnotation);
3709         }
3710         // Note: @Deprecated has no effect on local variables, parameters and package decls.
3711         if (lint.isEnabled(LintCategory.DEPRECATION) &amp;&amp; !s.isDeprecatableViaAnnotation()) {
3712             if (!syms.deprecatedType.isErroneous() &amp;&amp; s.attribute(syms.deprecatedType.tsym) != null) {
3713                 log.warning(LintCategory.DEPRECATION, pos,
3714                             Warnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));
3715             }
3716         }
3717     }
3718 
3719     void checkDeprecated(final DiagnosticPosition pos, final Symbol other, final Symbol s) {
3720         checkDeprecated(() -&gt; pos, other, s);
3721     }
3722 
3723     void checkDeprecated(Supplier&lt;DiagnosticPosition&gt; pos, final Symbol other, final Symbol s) {
3724         if ( (s.isDeprecatedForRemoval()
3725                 || s.isDeprecated() &amp;&amp; !other.isDeprecated())
3726                 &amp;&amp; (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {
3727             deferredLintHandler.report(() -&gt; warnDeprecated(pos.get(), s));
3728         }
3729     }
3730 
3731     void checkSunAPI(final DiagnosticPosition pos, final Symbol s) {
3732         if ((s.flags() &amp; PROPRIETARY) != 0) {
3733             deferredLintHandler.report(() -&gt; {
3734                 log.mandatoryWarning(pos, Warnings.SunProprietary(s));
3735             });
3736         }
3737     }
3738 
3739     void checkProfile(final DiagnosticPosition pos, final Symbol s) {
3740         if (profile != Profile.DEFAULT &amp;&amp; (s.flags() &amp; NOT_IN_PROFILE) != 0) {
3741             log.error(pos, Errors.NotInProfile(s, profile));
3742         }
3743     }
3744 
3745     void checkPreview(DiagnosticPosition pos, Symbol s) {
3746         if ((s.flags() &amp; PREVIEW_API) != 0) {
3747             if ((s.flags() &amp; PREVIEW_ESSENTIAL_API) != 0 &amp;&amp; !preview.isEnabled()) {
3748                 log.error(pos, Errors.IsPreview(s));
3749             } else {
3750                 deferredLintHandler.report(() -&gt; warnPreview(pos, s));
3751             }
3752         }
3753     }
3754 
3755 /* *************************************************************************
3756  * Check for recursive annotation elements.
3757  **************************************************************************/
3758 
3759     /** Check for cycles in the graph of annotation elements.
3760      */
3761     void checkNonCyclicElements(JCClassDecl tree) {
3762         if ((tree.sym.flags_field &amp; ANNOTATION) == 0) return;
3763         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
3764         try {
3765             tree.sym.flags_field |= LOCKED;
3766             for (JCTree def : tree.defs) {
3767                 if (!def.hasTag(METHODDEF)) continue;
3768                 JCMethodDecl meth = (JCMethodDecl)def;
3769                 checkAnnotationResType(meth.pos(), meth.restype.type);
3770             }
3771         } finally {
3772             tree.sym.flags_field &amp;= ~LOCKED;
3773             tree.sym.flags_field |= ACYCLIC_ANN;
3774         }
3775     }
3776 
3777     void checkNonCyclicElementsInternal(DiagnosticPosition pos, TypeSymbol tsym) {
3778         if ((tsym.flags_field &amp; ACYCLIC_ANN) != 0)
3779             return;
3780         if ((tsym.flags_field &amp; LOCKED) != 0) {
3781             log.error(pos, Errors.CyclicAnnotationElement(tsym));
3782             return;
3783         }
3784         try {
3785             tsym.flags_field |= LOCKED;
3786             for (Symbol s : tsym.members().getSymbols(NON_RECURSIVE)) {
3787                 if (s.kind != MTH)
3788                     continue;
3789                 checkAnnotationResType(pos, ((MethodSymbol)s).type.getReturnType());
3790             }
3791         } finally {
3792             tsym.flags_field &amp;= ~LOCKED;
3793             tsym.flags_field |= ACYCLIC_ANN;
3794         }
3795     }
3796 
3797     void checkAnnotationResType(DiagnosticPosition pos, Type type) {
3798         switch (type.getTag()) {
3799         case CLASS:
3800             if ((type.tsym.flags() &amp; ANNOTATION) != 0)
3801                 checkNonCyclicElementsInternal(pos, type.tsym);
3802             break;
3803         case ARRAY:
3804             checkAnnotationResType(pos, types.elemtype(type));
3805             break;
3806         default:
3807             break; // int etc
3808         }
3809     }
3810 
3811 /* *************************************************************************
3812  * Check for cycles in the constructor call graph.
3813  **************************************************************************/
3814 
3815     /** Check for cycles in the graph of constructors calling other
3816      *  constructors.
3817      */
3818     void checkCyclicConstructors(JCClassDecl tree) {
3819         Map&lt;Symbol,Symbol&gt; callMap = new HashMap&lt;&gt;();
3820 
3821         // enter each constructor this-call into the map
3822         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
3823             JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);
3824             if (app == null) continue;
3825             JCMethodDecl meth = (JCMethodDecl) l.head;
3826             if (TreeInfo.name(app.meth) == names._this) {
3827                 callMap.put(meth.sym, TreeInfo.symbol(app.meth));
3828             } else {
3829                 meth.sym.flags_field |= ACYCLIC;
3830             }
3831         }
3832 
3833         // Check for cycles in the map
3834         Symbol[] ctors = new Symbol[0];
3835         ctors = callMap.keySet().toArray(ctors);
3836         for (Symbol caller : ctors) {
3837             checkCyclicConstructor(tree, caller, callMap);
3838         }
3839     }
3840 
3841     /** Look in the map to see if the given constructor is part of a
3842      *  call cycle.
3843      */
3844     private void checkCyclicConstructor(JCClassDecl tree, Symbol ctor,
3845                                         Map&lt;Symbol,Symbol&gt; callMap) {
3846         if (ctor != null &amp;&amp; (ctor.flags_field &amp; ACYCLIC) == 0) {
3847             if ((ctor.flags_field &amp; LOCKED) != 0) {
3848                 log.error(TreeInfo.diagnosticPositionFor(ctor, tree),
3849                           Errors.RecursiveCtorInvocation);
3850             } else {
3851                 ctor.flags_field |= LOCKED;
3852                 checkCyclicConstructor(tree, callMap.remove(ctor), callMap);
3853                 ctor.flags_field &amp;= ~LOCKED;
3854             }
3855             ctor.flags_field |= ACYCLIC;
3856         }
3857     }
3858 
3859 /* *************************************************************************
3860  * Miscellaneous
3861  **************************************************************************/
3862 
3863     /**
3864      *  Check for division by integer constant zero
3865      *  @param pos           Position for error reporting.
3866      *  @param operator      The operator for the expression
3867      *  @param operand       The right hand operand for the expression
3868      */
3869     void checkDivZero(final DiagnosticPosition pos, Symbol operator, Type operand) {
3870         if (operand.constValue() != null
3871             &amp;&amp; operand.getTag().isSubRangeOf(LONG)
3872             &amp;&amp; ((Number) (operand.constValue())).longValue() == 0) {
3873             int opc = ((OperatorSymbol)operator).opcode;
3874             if (opc == ByteCodes.idiv || opc == ByteCodes.imod
3875                 || opc == ByteCodes.ldiv || opc == ByteCodes.lmod) {
3876                 deferredLintHandler.report(() -&gt; warnDivZero(pos));
3877             }
3878         }
3879     }
3880 
3881     /**
3882      * Check for empty statements after if
3883      */
3884     void checkEmptyIf(JCIf tree) {
3885         if (tree.thenpart.hasTag(SKIP) &amp;&amp; tree.elsepart == null &amp;&amp;
3886                 lint.isEnabled(LintCategory.EMPTY))
3887             log.warning(LintCategory.EMPTY, tree.thenpart.pos(), Warnings.EmptyIf);
3888     }
3889 
3890     /** Check that symbol is unique in given scope.
3891      *  @param pos           Position for error reporting.
3892      *  @param sym           The symbol.
3893      *  @param s             The scope.
3894      */
3895     boolean checkUnique(DiagnosticPosition pos, Symbol sym, Scope s) {
3896         if (sym.type.isErroneous())
3897             return true;
3898         if (sym.owner.name == names.any) return false;
3899         for (Symbol byName : s.getSymbolsByName(sym.name, NON_RECURSIVE)) {
3900             if (sym != byName &amp;&amp;
3901                     (byName.flags() &amp; CLASH) == 0 &amp;&amp;
3902                     sym.kind == byName.kind &amp;&amp;
3903                     sym.name != names.error &amp;&amp;
3904                     (sym.kind != MTH ||
3905                      types.hasSameArgs(sym.type, byName.type) ||
3906                      types.hasSameArgs(types.erasure(sym.type), types.erasure(byName.type)))) {
3907                 if ((sym.flags() &amp; VARARGS) != (byName.flags() &amp; VARARGS)) {
3908                     sym.flags_field |= CLASH;
3909                     varargsDuplicateError(pos, sym, byName);
3910                     return true;
3911                 } else if (sym.kind == MTH &amp;&amp; !types.hasSameArgs(sym.type, byName.type, false)) {
3912                     duplicateErasureError(pos, sym, byName);
3913                     sym.flags_field |= CLASH;
3914                     return true;
3915                 } else if ((sym.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3916                            (byName.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3917                            (byName.flags() &amp; MATCH_BINDING_TO_OUTER) == 0) {
3918                     if (!sym.type.isErroneous()) {
3919                         log.error(pos, Errors.MatchBindingExists);
3920                         sym.flags_field |= CLASH;
3921                     }
3922                     return false;
3923                 } else {
3924                     duplicateError(pos, byName);
3925                     return false;
3926                 }
3927             }
3928         }
3929         return true;
3930     }
3931 
3932     /** Report duplicate declaration error.
3933      */
3934     void duplicateErasureError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
3935         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
3936             log.error(pos, Errors.NameClashSameErasure(sym1, sym2));
3937         }
3938     }
3939 
3940     /**Check that types imported through the ordinary imports don&#39;t clash with types imported
3941      * by other (static or ordinary) imports. Note that two static imports may import two clashing
3942      * types without an error on the imports.
3943      * @param toplevel       The toplevel tree for which the test should be performed.
3944      */
3945     void checkImportsUnique(JCCompilationUnit toplevel) {
3946         WriteableScope ordinallyImportedSoFar = WriteableScope.create(toplevel.packge);
3947         WriteableScope staticallyImportedSoFar = WriteableScope.create(toplevel.packge);
3948         WriteableScope topLevelScope = toplevel.toplevelScope;
3949 
3950         for (JCTree def : toplevel.defs) {
3951             if (!def.hasTag(IMPORT))
3952                 continue;
3953 
3954             JCImport imp = (JCImport) def;
3955 
3956             if (imp.importScope == null)
3957                 continue;
3958 
3959             for (Symbol sym : imp.importScope.getSymbols(sym -&gt; sym.kind == TYP)) {
3960                 if (imp.isStatic()) {
3961                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, true);
3962                     staticallyImportedSoFar.enter(sym);
3963                 } else {
3964                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, false);
3965                     ordinallyImportedSoFar.enter(sym);
3966                 }
3967             }
3968 
3969             imp.importScope = null;
3970         }
3971     }
3972 
3973     /** Check that single-type import is not already imported or top-level defined,
3974      *  but make an exception for two single-type imports which denote the same type.
3975      *  @param pos                     Position for error reporting.
3976      *  @param ordinallyImportedSoFar  A Scope containing types imported so far through
3977      *                                 ordinary imports.
3978      *  @param staticallyImportedSoFar A Scope containing types imported so far through
3979      *                                 static imports.
3980      *  @param topLevelScope           The current file&#39;s top-level Scope
3981      *  @param sym                     The symbol.
3982      *  @param staticImport            Whether or not this was a static import
3983      */
3984     private boolean checkUniqueImport(DiagnosticPosition pos, Scope ordinallyImportedSoFar,
3985                                       Scope staticallyImportedSoFar, Scope topLevelScope,
3986                                       Symbol sym, boolean staticImport) {
3987         Filter&lt;Symbol&gt; duplicates = candidate -&gt; candidate != sym &amp;&amp; !candidate.type.isErroneous();
3988         Symbol ordinaryClashing = ordinallyImportedSoFar.findFirst(sym.name, duplicates);
3989         Symbol staticClashing = null;
3990         if (ordinaryClashing == null &amp;&amp; !staticImport) {
3991             staticClashing = staticallyImportedSoFar.findFirst(sym.name, duplicates);
3992         }
3993         if (ordinaryClashing != null || staticClashing != null) {
3994             if (ordinaryClashing != null)
3995                 log.error(pos, Errors.AlreadyDefinedSingleImport(ordinaryClashing));
3996             else
3997                 log.error(pos, Errors.AlreadyDefinedStaticSingleImport(staticClashing));
3998             return false;
3999         }
4000         Symbol clashing = topLevelScope.findFirst(sym.name, duplicates);
4001         if (clashing != null) {
4002             log.error(pos, Errors.AlreadyDefinedThisUnit(clashing));
4003             return false;
4004         }
4005         return true;
4006     }
4007 
4008     /** Check that a qualified name is in canonical form (for import decls).
4009      */
4010     public void checkCanonical(JCTree tree) {
4011         if (!isCanonical(tree))
4012             log.error(tree.pos(),
4013                       Errors.ImportRequiresCanonical(TreeInfo.symbol(tree)));
4014     }
4015         // where
4016         private boolean isCanonical(JCTree tree) {
4017             while (tree.hasTag(SELECT)) {
4018                 JCFieldAccess s = (JCFieldAccess) tree;
4019                 if (s.sym.owner.getQualifiedName() != TreeInfo.symbol(s.selected).getQualifiedName())
4020                     return false;
4021                 tree = s.selected;
4022             }
4023             return true;
4024         }
4025 
4026     /** Check that an auxiliary class is not accessed from any other file than its own.
4027      */
4028     void checkForBadAuxiliaryClassAccess(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, ClassSymbol c) {
4029         if (lint.isEnabled(Lint.LintCategory.AUXILIARYCLASS) &amp;&amp;
4030             (c.flags() &amp; AUXILIARY) != 0 &amp;&amp;
4031             rs.isAccessible(env, c) &amp;&amp;
4032             !fileManager.isSameFile(c.sourcefile, env.toplevel.sourcefile))
4033         {
4034             log.warning(pos,
4035                         Warnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));
4036         }
4037     }
4038 
4039     private class ConversionWarner extends Warner {
4040         final String uncheckedKey;
4041         final Type found;
4042         final Type expected;
4043         public ConversionWarner(DiagnosticPosition pos, String uncheckedKey, Type found, Type expected) {
4044             super(pos);
4045             this.uncheckedKey = uncheckedKey;
4046             this.found = found;
4047             this.expected = expected;
4048         }
4049 
4050         @Override
4051         public void warn(LintCategory lint) {
4052             boolean warned = this.warned;
4053             super.warn(lint);
4054             if (warned) return; // suppress redundant diagnostics
4055             switch (lint) {
4056                 case UNCHECKED:
4057                     Check.this.warnUnchecked(pos(), Warnings.ProbFoundReq(diags.fragment(uncheckedKey), found, expected));
4058                     break;
4059                 case VARARGS:
4060                     if (method != null &amp;&amp;
4061                             method.attribute(syms.trustMeType.tsym) != null &amp;&amp;
4062                             isTrustMeAllowedOnMethod(method) &amp;&amp;
4063                             !types.isReifiable(method.type.getParameterTypes().last())) {
4064                         Check.this.warnUnsafeVararg(pos(), Warnings.VarargsUnsafeUseVarargsParam(method.params.last()));
4065                     }
4066                     break;
4067                 default:
4068                     throw new AssertionError(&quot;Unexpected lint: &quot; + lint);
4069             }
4070         }
4071     }
4072 
4073     public Warner castWarner(DiagnosticPosition pos, Type found, Type expected) {
4074         return new ConversionWarner(pos, &quot;unchecked.cast.to.type&quot;, found, expected);
4075     }
4076 
4077     public Warner convertWarner(DiagnosticPosition pos, Type found, Type expected) {
4078         return new ConversionWarner(pos, &quot;unchecked.assign&quot;, found, expected);
4079     }
4080 
4081     public void checkFunctionalInterface(JCClassDecl tree, ClassSymbol cs) {
4082         Compound functionalType = cs.attribute(syms.functionalInterfaceType.tsym);
4083 
4084         if (functionalType != null) {
4085             try {
4086                 types.findDescriptorSymbol((TypeSymbol)cs);
4087             } catch (Types.FunctionDescriptorLookupError ex) {
4088                 DiagnosticPosition pos = tree.pos();
4089                 for (JCAnnotation a : tree.getModifiers().annotations) {
4090                     if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
4091                         pos = a.pos();
4092                         break;
4093                     }
4094                 }
4095                 log.error(pos, Errors.BadFunctionalIntfAnno1(ex.getDiagnostic()));
4096             }
4097         }
4098     }
4099 
4100     public void checkImportsResolvable(final JCCompilationUnit toplevel) {
4101         for (final JCImport imp : toplevel.getImports()) {
4102             if (!imp.staticImport || !imp.qualid.hasTag(SELECT))
4103                 continue;
4104             final JCFieldAccess select = (JCFieldAccess) imp.qualid;
4105             final Symbol origin;
4106             if (select.name == names.asterisk || (origin = TreeInfo.symbol(select.selected)) == null || origin.kind != TYP)
4107                 continue;
4108 
4109             TypeSymbol site = (TypeSymbol) TreeInfo.symbol(select.selected);
4110             if (!checkTypeContainsImportableElement(site, site, toplevel.packge, select.name, new HashSet&lt;Symbol&gt;())) {
4111                 log.error(imp.pos(),
4112                           Errors.CantResolveLocation(KindName.STATIC,
4113                                                      select.name,
4114                                                      null,
4115                                                      null,
4116                                                      Fragments.Location(kindName(site),
4117                                                                         site,
4118                                                                         null)));
4119             }
4120         }
4121     }
4122 
4123     // Check that packages imported are in scope (JLS 7.4.3, 6.3, 6.5.3.1, 6.5.3.2)
4124     public void checkImportedPackagesObservable(final JCCompilationUnit toplevel) {
4125         OUTER: for (JCImport imp : toplevel.getImports()) {
4126             if (!imp.staticImport &amp;&amp; TreeInfo.name(imp.qualid) == names.asterisk) {
4127                 TypeSymbol tsym = ((JCFieldAccess)imp.qualid).selected.type.tsym;
4128                 if (tsym.kind == PCK &amp;&amp; tsym.members().isEmpty() &amp;&amp;
4129                     !(Feature.IMPORT_ON_DEMAND_OBSERVABLE_PACKAGES.allowedInSource(source) &amp;&amp; tsym.exists())) {
4130                     log.error(DiagnosticFlag.RESOLVE_ERROR, imp.pos, Errors.DoesntExist(tsym));
4131                 }
4132             }
4133         }
4134     }
4135 
4136     private boolean checkTypeContainsImportableElement(TypeSymbol tsym, TypeSymbol origin, PackageSymbol packge, Name name, Set&lt;Symbol&gt; processed) {
4137         if (tsym == null || !processed.add(tsym))
4138             return false;
4139 
4140             // also search through inherited names
4141         if (checkTypeContainsImportableElement(types.supertype(tsym.type).tsym, origin, packge, name, processed))
4142             return true;
4143 
4144         for (Type t : types.interfaces(tsym.type))
4145             if (checkTypeContainsImportableElement(t.tsym, origin, packge, name, processed))
4146                 return true;
4147 
4148         for (Symbol sym : tsym.members().getSymbolsByName(name)) {
4149             if (sym.isStatic() &amp;&amp;
4150                 importAccessible(sym, packge) &amp;&amp;
4151                 sym.isMemberOf(origin, types)) {
4152                 return true;
4153             }
4154         }
4155 
4156         return false;
4157     }
4158 
4159     // is the sym accessible everywhere in packge?
4160     public boolean importAccessible(Symbol sym, PackageSymbol packge) {
4161         try {
4162             int flags = (int)(sym.flags() &amp; AccessFlags);
4163             switch (flags) {
4164             default:
4165             case PUBLIC:
4166                 return true;
4167             case PRIVATE:
4168                 return false;
4169             case 0:
4170             case PROTECTED:
4171                 return sym.packge() == packge;
4172             }
4173         } catch (ClassFinder.BadClassFile err) {
4174             throw err;
4175         } catch (CompletionFailure ex) {
4176             return false;
4177         }
4178     }
4179 
4180     public void checkLeaksNotAccessible(Env&lt;AttrContext&gt; env, JCClassDecl check) {
4181         JCCompilationUnit toplevel = env.toplevel;
4182 
4183         if (   toplevel.modle == syms.unnamedModule
4184             || toplevel.modle == syms.noModule
4185             || (check.sym.flags() &amp; COMPOUND) != 0) {
4186             return ;
4187         }
4188 
4189         ExportsDirective currentExport = findExport(toplevel.packge);
4190 
4191         if (   currentExport == null //not exported
4192             || currentExport.modules != null) //don&#39;t check classes in qualified export
4193             return ;
4194 
4195         new TreeScanner() {
4196             Lint lint = env.info.lint;
4197             boolean inSuperType;
4198 
4199             @Override
4200             public void visitBlock(JCBlock tree) {
4201             }
4202             @Override
4203             public void visitMethodDef(JCMethodDecl tree) {
4204                 if (!isAPISymbol(tree.sym))
4205                     return;
4206                 Lint prevLint = lint;
4207                 try {
4208                     lint = lint.augment(tree.sym);
4209                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4210                         super.visitMethodDef(tree);
4211                     }
4212                 } finally {
4213                     lint = prevLint;
4214                 }
4215             }
4216             @Override
4217             public void visitVarDef(JCVariableDecl tree) {
4218                 if (!isAPISymbol(tree.sym) &amp;&amp; tree.sym.owner.kind != MTH)
4219                     return;
4220                 Lint prevLint = lint;
4221                 try {
4222                     lint = lint.augment(tree.sym);
4223                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4224                         scan(tree.mods);
4225                         scan(tree.vartype);
4226                     }
4227                 } finally {
4228                     lint = prevLint;
4229                 }
4230             }
4231             @Override
4232             public void visitClassDef(JCClassDecl tree) {
4233                 if (tree != check)
4234                     return ;
4235 
4236                 if (!isAPISymbol(tree.sym))
4237                     return ;
4238 
4239                 Lint prevLint = lint;
4240                 try {
4241                     lint = lint.augment(tree.sym);
4242                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4243                         scan(tree.mods);
4244                         scan(tree.typarams);
4245                         try {
4246                             inSuperType = true;
4247                             scan(tree.extending);
4248                             scan(tree.implementing);
4249                         } finally {
4250                             inSuperType = false;
4251                         }
4252                         scan(tree.defs);
4253                     }
4254                 } finally {
4255                     lint = prevLint;
4256                 }
4257             }
4258             @Override
4259             public void visitTypeApply(JCTypeApply tree) {
4260                 scan(tree.clazz);
4261                 boolean oldInSuperType = inSuperType;
4262                 try {
4263                     inSuperType = false;
4264                     scan(tree.arguments);
4265                 } finally {
4266                     inSuperType = oldInSuperType;
4267                 }
4268             }
4269             @Override
4270             public void visitIdent(JCIdent tree) {
4271                 Symbol sym = TreeInfo.symbol(tree);
4272                 if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR)) {
4273                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4274                 }
4275             }
4276 
4277             @Override
4278             public void visitSelect(JCFieldAccess tree) {
4279                 Symbol sym = TreeInfo.symbol(tree);
4280                 Symbol sitesym = TreeInfo.symbol(tree.selected);
4281                 if (sym.kind == TYP &amp;&amp; sitesym.kind == PCK) {
4282                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4283                 } else {
4284                     super.visitSelect(tree);
4285                 }
4286             }
4287 
4288             @Override
4289             public void visitAnnotation(JCAnnotation tree) {
4290                 if (tree.attribute.type.tsym.getAnnotation(java.lang.annotation.Documented.class) != null)
4291                     super.visitAnnotation(tree);
4292             }
4293 
4294         }.scan(check);
4295     }
4296         //where:
4297         private ExportsDirective findExport(PackageSymbol pack) {
4298             for (ExportsDirective d : pack.modle.exports) {
4299                 if (d.packge == pack)
4300                     return d;
4301             }
4302 
4303             return null;
4304         }
4305         private boolean isAPISymbol(Symbol sym) {
4306             while (sym.kind != PCK) {
4307                 if ((sym.flags() &amp; Flags.PUBLIC) == 0 &amp;&amp; (sym.flags() &amp; Flags.PROTECTED) == 0) {
4308                     return false;
4309                 }
4310                 sym = sym.owner;
4311             }
4312             return true;
4313         }
4314         private void checkVisible(DiagnosticPosition pos, Symbol what, PackageSymbol inPackage, boolean inSuperType) {
4315             if (!isAPISymbol(what) &amp;&amp; !inSuperType) { //package private/private element
4316                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessible(kindName(what), what, what.packge().modle));
4317                 return ;
4318             }
4319 
4320             PackageSymbol whatPackage = what.packge();
4321             ExportsDirective whatExport = findExport(whatPackage);
4322             ExportsDirective inExport = findExport(inPackage);
4323 
4324             if (whatExport == null) { //package not exported:
4325                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexported(kindName(what), what, what.packge().modle));
4326                 return ;
4327             }
4328 
4329             if (whatExport.modules != null) {
4330                 if (inExport.modules == null || !whatExport.modules.containsAll(inExport.modules)) {
4331                     log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexportedQualified(kindName(what), what, what.packge().modle));
4332                 }
4333             }
4334 
4335             if (whatPackage.modle != inPackage.modle &amp;&amp; whatPackage.modle != syms.java_base) {
4336                 //check that relativeTo.modle requires transitive what.modle, somehow:
4337                 List&lt;ModuleSymbol&gt; todo = List.of(inPackage.modle);
4338 
4339                 while (todo.nonEmpty()) {
4340                     ModuleSymbol current = todo.head;
4341                     todo = todo.tail;
4342                     if (current == whatPackage.modle)
4343                         return ; //OK
4344                     if ((current.flags() &amp; Flags.AUTOMATIC_MODULE) != 0)
4345                         continue; //for automatic modules, don&#39;t look into their dependencies
4346                     for (RequiresDirective req : current.requires) {
4347                         if (req.isTransitive()) {
4348                             todo = todo.prepend(req.module);
4349                         }
4350                     }
4351                 }
4352 
4353                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleNotRequiredTransitive(kindName(what), what, what.packge().modle));
4354             }
4355         }
4356 
4357     void checkModuleExists(final DiagnosticPosition pos, ModuleSymbol msym) {
4358         if (msym.kind != MDL) {
4359             deferredLintHandler.report(() -&gt; {
4360                 if (lint.isEnabled(LintCategory.MODULE))
4361                     log.warning(LintCategory.MODULE, pos, Warnings.ModuleNotFound(msym));
4362             });
4363         }
4364     }
4365 
4366     void checkPackageExistsForOpens(final DiagnosticPosition pos, PackageSymbol packge) {
4367         if (packge.members().isEmpty() &amp;&amp;
4368             ((packge.flags() &amp; Flags.HAS_RESOURCE) == 0)) {
4369             deferredLintHandler.report(() -&gt; {
4370                 if (lint.isEnabled(LintCategory.OPENS))
4371                     log.warning(pos, Warnings.PackageEmptyOrNotFound(packge));
4372             });
4373         }
4374     }
4375 
4376     void checkModuleRequires(final DiagnosticPosition pos, final RequiresDirective rd) {
4377         if ((rd.module.flags() &amp; Flags.AUTOMATIC_MODULE) != 0) {
4378             deferredLintHandler.report(() -&gt; {
4379                 if (rd.isTransitive() &amp;&amp; lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {
4380                     log.warning(pos, Warnings.RequiresTransitiveAutomatic);
4381                 } else if (lint.isEnabled(LintCategory.REQUIRES_AUTOMATIC)) {
4382                     log.warning(pos, Warnings.RequiresAutomatic);
4383                 }
4384             });
4385         }
4386     }
4387 
4388 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
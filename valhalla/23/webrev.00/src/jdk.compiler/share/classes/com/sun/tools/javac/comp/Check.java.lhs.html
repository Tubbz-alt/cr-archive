<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.Supplier;
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileManager;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.Compound;
  36 import com.sun.tools.javac.code.Directive.ExportsDirective;
  37 import com.sun.tools.javac.code.Directive.RequiresDirective;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  40 import com.sun.tools.javac.jvm.*;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  51 import com.sun.tools.javac.util.List;
  52 
  53 import com.sun.tools.javac.code.Lint;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Scope.WriteableScope;
  56 import com.sun.tools.javac.code.Type.*;
  57 import com.sun.tools.javac.code.Symbol.*;
  58 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  59 import com.sun.tools.javac.tree.JCTree.*;
  60 
  61 import static com.sun.tools.javac.code.Flags.*;
  62 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  63 import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
  64 import static com.sun.tools.javac.code.Kinds.*;
  65 import static com.sun.tools.javac.code.Kinds.Kind.*;
  66 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  67 import static com.sun.tools.javac.code.TypeTag.*;
  68 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  69 
  70 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  71 
  72 /** Type checking helper class for the attribution phase.
  73  *
  74  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  75  *  If you write code that depends on this, you do so at your own risk.
  76  *  This code and its internal interfaces are subject to change or
  77  *  deletion without notice.&lt;/b&gt;
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;
  98     private final boolean allowGenericsOverValues;
  99     private final boolean allowValueBasedClasses;
 100 
 101     // The set of lint options currently in effect. It is initialized
 102     // from the context, and then is set/reset as needed by Attr as it
 103     // visits all the various parts of the trees during attribution.
 104     private Lint lint;
 105 
 106     // The method being analyzed in Attr - it is set/reset as needed by
 107     // Attr as it visits new method declarations.
 108     private MethodSymbol method;
 109 
 110     public static Check instance(Context context) {
 111         Check instance = context.get(checkKey);
 112         if (instance == null)
 113             instance = new Check(context);
 114         return instance;
 115     }
 116 
 117     protected Check(Context context) {
 118         context.put(checkKey, this);
 119 
 120         names = Names.instance(context);
 121         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 122             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 123             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 124         log = Log.instance(context);
 125         rs = Resolve.instance(context);
 126         syms = Symtab.instance(context);
 127         enter = Enter.instance(context);
 128         deferredAttr = DeferredAttr.instance(context);
 129         infer = Infer.instance(context);
 130         types = Types.instance(context);
 131         typeAnnotations = TypeAnnotations.instance(context);
 132         diags = JCDiagnostic.Factory.instance(context);
 133         Options options = Options.instance(context);
 134         lint = Lint.instance(context);
 135         fileManager = context.get(JavaFileManager.class);
 136 
 137         source = Source.instance(context);
 138         target = Target.instance(context);
 139         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
 140         allowGenericsOverValues = options.isSet(&quot;allowGenericsOverValues&quot;);
 141         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 142         Target target = Target.instance(context);
 143         syntheticNameChar = target.syntheticNameChar();
 144 
 145         profile = Profile.instance(context);
 146         preview = Preview.instance(context);
 147 
 148         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 149         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 150         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 151         boolean enforceMandatoryWarnings = true;
 152 
 153         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 154                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 155         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 156                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 157         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 158                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 159         sunApiHandler = new MandatoryWarningHandler(log, false,
 160                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 161 
 162         deferredLintHandler = DeferredLintHandler.instance(context);
 163 
 164         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 165                 Feature.RECORDS.allowedInSource(source);
 166     }
 167 
 168     /** Character for synthetic names
 169      */
 170     char syntheticNameChar;
 171 
 172     /** A table mapping flat names of all compiled classes for each module in this run
 173      *  to their symbols; maintained from outside.
 174      */
 175     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 176 
 177     /** A handler for messages about deprecated usage.
 178      */
 179     private MandatoryWarningHandler deprecationHandler;
 180 
 181     /** A handler for messages about deprecated-for-removal usage.
 182      */
 183     private MandatoryWarningHandler removalHandler;
 184 
 185     /** A handler for messages about unchecked or unsafe usage.
 186      */
 187     private MandatoryWarningHandler uncheckedHandler;
 188 
 189     /** A handler for messages about using proprietary API.
 190      */
 191     private MandatoryWarningHandler sunApiHandler;
 192 
 193     /** A handler for deferred lint warnings.
 194      */
 195     private DeferredLintHandler deferredLintHandler;
 196 
 197     /** Are records allowed
 198      */
 199     private final boolean allowRecords;
 200 
 201 /* *************************************************************************
 202  * Errors and Warnings
 203  **************************************************************************/
 204 
 205     Lint setLint(Lint newLint) {
 206         Lint prev = lint;
 207         lint = newLint;
 208         return prev;
 209     }
 210 
 211     MethodSymbol setMethod(MethodSymbol newMethod) {
 212         MethodSymbol prev = method;
 213         method = newMethod;
 214         return prev;
 215     }
 216 
 217     /** Warn about deprecated symbol.
 218      *  @param pos        Position to be used for error reporting.
 219      *  @param sym        The deprecated symbol.
 220      */
 221     void warnDeprecated(DiagnosticPosition pos, Symbol sym) {
 222         if (sym.isDeprecatedForRemoval()) {
 223             if (!lint.isSuppressed(LintCategory.REMOVAL)) {
 224                 if (sym.kind == MDL) {
 225                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemovalModule(sym));
 226                 } else {
 227                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemoval(sym, sym.location()));
 228                 }
 229             }
 230         } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {
 231             if (sym.kind == MDL) {
 232                 deprecationHandler.report(pos, Warnings.HasBeenDeprecatedModule(sym));
 233             } else {
 234                 deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));
 235             }
 236         }
 237     }
 238 
 239     /** Warn about deprecated symbol.
 240      *  @param pos        Position to be used for error reporting.
 241      *  @param sym        The deprecated symbol.
 242      */
 243     void warnPreview(DiagnosticPosition pos, Symbol sym) {
 244         warnPreview(pos, Warnings.IsPreview(sym));
 245     }
 246 
 247     /** Log a preview warning.
 248      *  @param pos        Position to be used for error reporting.
 249      *  @param msg        A Warning describing the problem.
 250      */
 251     public void warnPreview(DiagnosticPosition pos, Warning warnKey) {
 252         if (!lint.isSuppressed(LintCategory.PREVIEW))
 253             preview.reportPreviewWarning(pos, warnKey);
 254     }
 255 
 256     /** Warn about unchecked operation.
 257      *  @param pos        Position to be used for error reporting.
 258      *  @param msg        A string describing the problem.
 259      */
 260     public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {
 261         if (!lint.isSuppressed(LintCategory.UNCHECKED))
 262             uncheckedHandler.report(pos, warnKey);
 263     }
 264 
 265     /** Warn about unsafe vararg method decl.
 266      *  @param pos        Position to be used for error reporting.
 267      */
 268     void warnUnsafeVararg(DiagnosticPosition pos, Warning warnKey) {
 269         if (lint.isEnabled(LintCategory.VARARGS))
 270             log.warning(LintCategory.VARARGS, pos, warnKey);
 271     }
 272 
 273     public void warnStatic(DiagnosticPosition pos, Warning warnKey) {
 274         if (lint.isEnabled(LintCategory.STATIC))
 275             log.warning(LintCategory.STATIC, pos, warnKey);
 276     }
 277 
 278     /** Warn about division by integer constant zero.
 279      *  @param pos        Position to be used for error reporting.
 280      */
 281     void warnDivZero(DiagnosticPosition pos) {
 282         if (lint.isEnabled(LintCategory.DIVZERO))
 283             log.warning(LintCategory.DIVZERO, pos, Warnings.DivZero);
 284     }
 285 
 286     /**
 287      * Report any deferred diagnostics.
 288      */
 289     public void reportDeferredDiagnostics() {
 290         deprecationHandler.reportDeferredDiagnostic();
 291         removalHandler.reportDeferredDiagnostic();
 292         uncheckedHandler.reportDeferredDiagnostic();
 293         sunApiHandler.reportDeferredDiagnostic();
 294     }
 295 
 296 
 297     /** Report a failure to complete a class.
 298      *  @param pos        Position to be used for error reporting.
 299      *  @param ex         The failure to report.
 300      */
 301     public Type completionError(DiagnosticPosition pos, CompletionFailure ex) {
 302         log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));
 303         return syms.errType;
 304     }
 305 
 306     /** Report an error that wrong type tag was found.
 307      *  @param pos        Position to be used for error reporting.
 308      *  @param required   An internationalized string describing the type tag
 309      *                    required.
 310      *  @param found      The type that was found.
 311      */
 312     Type typeTagError(DiagnosticPosition pos, JCDiagnostic required, Object found) {
 313         // this error used to be raised by the parser,
 314         // but has been delayed to this point:
 315         if (found instanceof Type &amp;&amp; ((Type)found).hasTag(VOID)) {
 316             log.error(pos, Errors.IllegalStartOfType);
 317             return syms.errType;
 318         }
 319         log.error(pos, Errors.TypeFoundReq(found, required));
 320         return types.createErrorType(found instanceof Type ? (Type)found : syms.errType);
 321     }
 322 
 323     /** Report an error that symbol cannot be referenced before super
 324      *  has been called.
 325      *  @param pos        Position to be used for error reporting.
 326      *  @param sym        The referenced symbol.
 327      */
 328     void earlyRefError(DiagnosticPosition pos, Symbol sym) {
 329         log.error(pos, Errors.CantRefBeforeCtorCalled(sym));
 330     }
 331 
 332     /** Report duplicate declaration error.
 333      */
 334     void duplicateError(DiagnosticPosition pos, Symbol sym) {
 335         if (!sym.type.isErroneous()) {
 336             Symbol location = sym.location();
 337             if (location.kind == MTH &amp;&amp;
 338                     ((MethodSymbol)location).isStaticOrInstanceInit()) {
 339                 log.error(pos,
 340                           Errors.AlreadyDefinedInClinit(kindName(sym),
 341                                                         sym,
 342                                                         kindName(sym.location()),
 343                                                         kindName(sym.location().enclClass()),
 344                                                         sym.location().enclClass()));
 345             } else {
 346                 /* dont error if this is a duplicated parameter of a generated canonical constructor
 347                  * as we should have issued an error for the duplicated fields
 348                  */
 349                 if (location.kind != MTH ||
 350                         ((sym.owner.flags_field &amp; GENERATEDCONSTR) == 0) ||
 351                         ((sym.owner.flags_field &amp; RECORD) == 0)) {
 352                     log.error(pos,
 353                             Errors.AlreadyDefined(kindName(sym),
 354                                     sym,
 355                                     kindName(sym.location()),
 356                                     sym.location()));
 357                 }
 358             }
 359         }
 360     }
 361 
 362     /** Report array/varargs duplicate declaration
 363      */
 364     void varargsDuplicateError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
 365         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
 366             log.error(pos, Errors.ArrayAndVarargs(sym1, sym2, sym2.location()));
 367         }
 368     }
 369 
 370 /* ************************************************************************
 371  * duplicate declaration checking
 372  *************************************************************************/
 373 
 374     /** Check that variable does not hide variable with same name in
 375      *  immediately enclosing local scope.
 376      *  @param pos           Position for error reporting.
 377      *  @param v             The symbol.
 378      *  @param s             The scope.
 379      */
 380     void checkTransparentVar(DiagnosticPosition pos, VarSymbol v, Scope s) {
 381         for (Symbol sym : s.getSymbolsByName(v.name)) {
 382             if (sym.owner != v.owner) break;
 383             if (sym.kind == VAR &amp;&amp;
 384                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 385                 v.name != names.error) {
 386                 duplicateError(pos, sym);
 387                 return;
 388             }
 389         }
 390     }
 391 
 392     /** Check that a class or interface does not hide a class or
 393      *  interface with same name in immediately enclosing local scope.
 394      *  @param pos           Position for error reporting.
 395      *  @param c             The symbol.
 396      *  @param s             The scope.
 397      */
 398     void checkTransparentClass(DiagnosticPosition pos, ClassSymbol c, Scope s) {
 399         for (Symbol sym : s.getSymbolsByName(c.name)) {
 400             if (sym.owner != c.owner) break;
 401             if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR) &amp;&amp;
 402                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 403                 c.name != names.error) {
 404                 duplicateError(pos, sym);
 405                 return;
 406             }
 407         }
 408     }
 409 
 410     /** Check that class does not have the same name as one of
 411      *  its enclosing classes, or as a class defined in its enclosing scope.
 412      *  return true if class is unique in its enclosing scope.
 413      *  @param pos           Position for error reporting.
 414      *  @param name          The class name.
 415      *  @param s             The enclosing scope.
 416      */
 417     boolean checkUniqueClassName(DiagnosticPosition pos, Name name, Scope s) {
 418         for (Symbol sym : s.getSymbolsByName(name, NON_RECURSIVE)) {
 419             if (sym.kind == TYP &amp;&amp; sym.name != names.error) {
 420                 duplicateError(pos, sym);
 421                 return false;
 422             }
 423         }
 424         for (Symbol sym = s.owner; sym != null; sym = sym.owner) {
 425             if (sym.kind == TYP &amp;&amp; sym.name == name &amp;&amp; sym.name != names.error) {
 426                 duplicateError(pos, sym);
 427                 return true;
 428             }
 429         }
 430         return true;
 431     }
 432 
 433 /* *************************************************************************
 434  * Class name generation
 435  **************************************************************************/
 436 
 437 
 438     private Map&lt;Pair&lt;Name, Name&gt;, Integer&gt; localClassNameIndexes = new HashMap&lt;&gt;();
 439 
 440     /** Return name of local class.
 441      *  This is of the form   {@code &lt;enclClass&gt; $ n &lt;classname&gt; }
 442      *  where
 443      *    enclClass is the flat name of the enclosing class,
 444      *    classname is the simple name of the local class
 445      */
 446     public Name localClassName(ClassSymbol c) {
 447         Name enclFlatname = c.owner.enclClass().flatname;
 448         String enclFlatnameStr = enclFlatname.toString();
 449         Pair&lt;Name, Name&gt; key = new Pair&lt;&gt;(enclFlatname, c.name);
 450         Integer index = localClassNameIndexes.get(key);
 451         for (int i = (index == null) ? 1 : index; ; i++) {
 452             Name flatname = names.fromString(enclFlatnameStr
 453                     + syntheticNameChar + i + c.name);
 454             if (getCompiled(c.packge().modle, flatname) == null) {
 455                 localClassNameIndexes.put(key, i + 1);
 456                 return flatname;
 457             }
 458         }
 459     }
 460 
 461     public void clearLocalClassNameIndexes(ClassSymbol c) {
 462         if (c.owner != null &amp;&amp; c.owner.kind != NIL) {
 463             localClassNameIndexes.remove(new Pair&lt;&gt;(
 464                     c.owner.enclClass().flatname, c.name));
 465         }
 466     }
 467 
 468     public void newRound() {
 469         compiled.clear();
 470         localClassNameIndexes.clear();
 471     }
 472 
 473     public void clear() {
 474         deprecationHandler.clear();
 475         removalHandler.clear();
 476         uncheckedHandler.clear();
 477         sunApiHandler.clear();
 478     }
 479 
 480     public void putCompiled(ClassSymbol csym) {
 481         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 482     }
 483 
 484     public ClassSymbol getCompiled(ClassSymbol csym) {
 485         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 486     }
 487 
 488     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 489         return compiled.get(Pair.of(msym, flatname));
 490     }
 491 
 492     public void removeCompiled(ClassSymbol csym) {
 493         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 494     }
 495 
 496     /* *************************************************************************
 497  * Type Checking
 498  **************************************************************************/
 499 
 500     /**
 501      * A check context is an object that can be used to perform compatibility
 502      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 503      * vary significantly.
 504      */
 505     public interface CheckContext {
 506         /**
 507          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 508          */
 509         boolean compatible(Type found, Type req, Warner warn);
 510         /**
 511          * Report a check error
 512          */
 513         void report(DiagnosticPosition pos, JCDiagnostic details);
 514         /**
 515          * Obtain a warner for this check context
 516          */
 517         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req);
 518 
 519         public InferenceContext inferenceContext();
 520 
 521         public DeferredAttr.DeferredAttrContext deferredAttrContext();
 522     }
 523 
 524     /**
 525      * This class represent a check context that is nested within another check
 526      * context - useful to check sub-expressions. The default behavior simply
 527      * redirects all method calls to the enclosing check context leveraging
 528      * the forwarding pattern.
 529      */
 530     static class NestedCheckContext implements CheckContext {
 531         CheckContext enclosingContext;
 532 
 533         NestedCheckContext(CheckContext enclosingContext) {
 534             this.enclosingContext = enclosingContext;
 535         }
 536 
 537         public boolean compatible(Type found, Type req, Warner warn) {
 538             return enclosingContext.compatible(found, req, warn);
 539         }
 540 
 541         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 542             enclosingContext.report(pos, details);
 543         }
 544 
 545         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 546             return enclosingContext.checkWarner(pos, found, req);
 547         }
 548 
 549         public InferenceContext inferenceContext() {
 550             return enclosingContext.inferenceContext();
 551         }
 552 
 553         public DeferredAttrContext deferredAttrContext() {
 554             return enclosingContext.deferredAttrContext();
 555         }
 556     }
 557 
 558     /**
 559      * Check context to be used when evaluating assignment/return statements
 560      */
 561     CheckContext basicHandler = new CheckContext() {
 562         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 563             log.error(pos, Errors.ProbFoundReq(details));
 564         }
 565         public boolean compatible(Type found, Type req, Warner warn) {
 566             return types.isAssignable(found, req, warn);
 567         }
 568 
 569         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 570             return convertWarner(pos, found, req);
 571         }
 572 
 573         public InferenceContext inferenceContext() {
 574             return infer.emptyContext;
 575         }
 576 
 577         public DeferredAttrContext deferredAttrContext() {
 578             return deferredAttr.emptyDeferredAttrContext;
 579         }
 580 
 581         @Override
 582         public String toString() {
 583             return &quot;CheckContext: basicHandler&quot;;
 584         }
 585     };
 586 
 587     /** Check that a given type is assignable to a given proto-type.
 588      *  If it is, return the type, otherwise return errType.
 589      *  @param pos        Position to be used for error reporting.
 590      *  @param found      The type that was found.
 591      *  @param req        The type that was required.
 592      */
 593     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 594         return checkType(pos, found, req, basicHandler);
 595     }
 596 
 597     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 598         final InferenceContext inferenceContext = checkContext.inferenceContext();
 599         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 600             inferenceContext.addFreeTypeListener(List.of(req, found),
 601                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
 602         } else {
 603             if (found.hasTag(CLASS)) {
 604                 checkParameterizationWithValues(pos, found);
 605             }
 606         }
 607         if (req.hasTag(ERROR))
 608             return req;
 609         if (req.hasTag(NONE))
 610             return found;
 611         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
 612             if (found.hasTag(BOT) &amp;&amp; types.isValueBased(req)) {
 613                 log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));
 614             }
 615             return found;
 616         } else {
 617             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 618                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 619                 return types.createErrorType(found);
 620             }
 621             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 622             return types.createErrorType(found);
 623         }
 624     }
 625 
 626     /** Check that a given type can be cast to a given target type.
 627      *  Return the result of the cast.
 628      *  @param pos        Position to be used for error reporting.
 629      *  @param found      The type that is being cast.
 630      *  @param req        The target type of the cast.
 631      */
 632     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 633         return checkCastable(pos, found, req, basicHandler);
 634     }
 635     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 636         if (types.isCastable(found, req, castWarner(pos, found, req))) {
 637             if (types.isValueBased(req)) {
 638                 if (found.hasTag(BOT)) {
 639                     log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));
 640                 } else if (!types.isValueBased(found)) {
 641                     log.warning(pos, Warnings.PotentialNullPollution(found));
 642                 }
 643             }
 644             return req;
 645         } else {
 646             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 647             return types.createErrorType(found);
 648         }
 649     }
 650 
 651     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 652      * The problem should only be reported for non-292 cast
 653      */
 654     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 655         if (!tree.type.isErroneous()
 656                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 657                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 658                 &amp;&amp; !is292targetTypeCast(tree)) {
 659             deferredLintHandler.report(() -&gt; {
 660                 if (lint.isEnabled(LintCategory.CAST))
 661                     log.warning(LintCategory.CAST,
 662                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 663             });
 664         }
 665     }
 666     //where
 667         private boolean is292targetTypeCast(JCTypeCast tree) {
 668             boolean is292targetTypeCast = false;
 669             JCExpression expr = TreeInfo.skipParens(tree.expr);
 670             if (expr.hasTag(APPLY)) {
 671                 JCMethodInvocation apply = (JCMethodInvocation)expr;
 672                 Symbol sym = TreeInfo.symbol(apply.meth);
 673                 is292targetTypeCast = sym != null &amp;&amp;
 674                     sym.kind == MTH &amp;&amp;
 675                     (sym.flags() &amp; HYPOTHETICAL) != 0;
 676             }
 677             return is292targetTypeCast;
 678         }
 679 
 680         private static final boolean ignoreAnnotatedCasts = true;
 681 
 682     /** Check that a type is within some bounds.
 683      *
 684      *  Used in TypeApply to verify that, e.g., X in {@code V&lt;X&gt;} is a valid
 685      *  type argument.
 686      *  @param a             The type that should be bounded by bs.
 687      *  @param bound         The bound.
 688      */
 689     private boolean checkExtends(Type a, Type bound) {
 690          if (a.isUnbound()) {
 691              return true;
 692          } else if (!a.hasTag(WILDCARD)) {
 693              a = types.cvarUpperBound(a);
 694              return types.isSubtype(a, bound);
 695          } else if (a.isExtendsBound()) {
 696              return types.isCastable(bound, types.wildUpperBound(a), types.noWarnings);
 697          } else if (a.isSuperBound()) {
 698              return !types.notSoftSubtype(types.wildLowerBound(a), bound);
 699          }
 700          return true;
 701      }
 702 
 703     /** Check that type is different from &#39;void&#39;.
 704      *  @param pos           Position to be used for error reporting.
 705      *  @param t             The type to be checked.
 706      */
 707     Type checkNonVoid(DiagnosticPosition pos, Type t) {
 708         if (t.hasTag(VOID)) {
 709             log.error(pos, Errors.VoidNotAllowedHere);
 710             return types.createErrorType(t);
 711         } else {
 712             return t;
 713         }
 714     }
 715 
 716     Type checkClassOrArrayType(DiagnosticPosition pos, Type t) {
 717         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ARRAY) &amp;&amp; !t.hasTag(ERROR)) {
 718             return typeTagError(pos,
 719                                 diags.fragment(Fragments.TypeReqClassArray),
 720                                 asTypeParam(t));
 721         } else {
 722             return t;
 723         }
 724     }
 725 
 726     /** Check that type is a class or interface type.
 727      *  @param pos           Position to be used for error reporting.
 728      *  @param t             The type to be checked.
 729      */
 730     Type checkClassType(DiagnosticPosition pos, Type t) {
 731         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 732             return typeTagError(pos,
 733                                 diags.fragment(Fragments.TypeReqClass),
 734                                 asTypeParam(t));
 735         } else {
 736             return t;
 737         }
 738     }
 739     //where
 740         private Object asTypeParam(Type t) {
 741             return (t.hasTag(TYPEVAR))
 742                                     ? diags.fragment(Fragments.TypeParameter(t))
 743                                     : t;
 744         }
 745 
<a name="1" id="anc1"></a>











































 746     /** Check that type is a valid qualifier for a constructor reference expression
 747      */
 748     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 749         t = checkClassOrArrayType(pos, t);
 750         if (t.hasTag(CLASS)) {
 751             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 752                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 753                 t = types.createErrorType(t);
 754             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 755                 log.error(pos, Errors.EnumCantBeInstantiated);
 756                 t = types.createErrorType(t);
 757             } else {
 758                 t = checkClassType(pos, t, true);
 759             }
 760         } else if (t.hasTag(ARRAY)) {
 761             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 762                 log.error(pos, Errors.GenericArrayCreation);
 763                 t = types.createErrorType(t);
 764             }
 765         }
 766         return t;
 767     }
 768 
 769     /** Check that type is a class or interface type.
 770      *  @param pos           Position to be used for error reporting.
 771      *  @param t             The type to be checked.
 772      *  @param noBounds    True if type bounds are illegal here.
 773      */
 774     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 775         t = checkClassType(pos, t);
 776         if (noBounds &amp;&amp; t.isParameterized()) {
 777             List&lt;Type&gt; args = t.getTypeArguments();
 778             while (args.nonEmpty()) {
 779                 if (args.head.hasTag(WILDCARD))
 780                     return typeTagError(pos,
 781                                         diags.fragment(Fragments.TypeReqExact),
 782                                         args.head);
 783                 args = args.tail;
 784             }
 785         }
 786         return t;
 787     }
 788 
 789     /** Check that type is a reference type, i.e. a class, interface or array type
 790      *  or a type variable.
 791      *  @param pos           Position to be used for error reporting.
 792      *  @param t             The type to be checked.
 793      *  @param valueOK       If false, a value class does not qualify
 794      */
 795     Type checkRefType(DiagnosticPosition pos, Type t, boolean valueOK) {
 796         if (t.isReference() &amp;&amp; (valueOK || !types.isValue(t)))
 797             return t;
 798         else
 799             return typeTagError(pos,
 800                                 diags.fragment(Fragments.TypeReqRef),
 801                                 t);
 802     }
 803 
 804     /** Check that type is a reference type, i.e. a class, interface or array type
 805      *  or a type variable.
 806      *  @param pos           Position to be used for error reporting.
 807      *  @param t             The type to be checked.
 808      */
 809     Type checkRefType(DiagnosticPosition pos, Type t) {
 810         return checkRefType(pos, t, true);
 811     }
 812 
 813     /** Check that each type is a reference type, i.e. a class, interface or array type
 814      *  or a type variable.
 815      *  @param trees         Original trees, used for error reporting.
 816      *  @param types         The types to be checked.
 817      */
 818     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 819         List&lt;JCExpression&gt; tl = trees;
 820         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
 821             l.head = checkRefType(tl.head.pos(), l.head, allowGenericsOverValues);
 822             tl = tl.tail;
 823         }
 824         return types;
 825     }
 826 
 827     /** Check that type is a null or reference type.
 828      *  @param pos           Position to be used for error reporting.
 829      *  @param t             The type to be checked.
 830      */
 831     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 832         if (t.isReference() || t.hasTag(BOT))
 833             return t;
 834         else
 835             return typeTagError(pos,
 836                                 diags.fragment(Fragments.TypeReqRef),
 837                                 t);
 838     }
 839 
 840     /** Check that flag set does not contain elements of two conflicting sets. s
 841      *  Return true if it doesn&#39;t.
 842      *  @param pos           Position to be used for error reporting.
 843      *  @param flags         The set of flags to be checked.
 844      *  @param set1          Conflicting flags set #1.
 845      *  @param set2          Conflicting flags set #2.
 846      */
 847     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 848         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 849             log.error(pos,
 850                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 851                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 852             return false;
 853         } else
 854             return true;
 855     }
 856 
 857     void checkParameterizationWithValues(DiagnosticPosition pos, Type t) {
 858         if (!allowGenericsOverValues &amp;&amp; t.tsym != syms.classType.tsym) { // tolerate Value.class for now.
 859             valueParameterizationChecker.visit(t, pos);
 860         }
 861     }
 862 
 863     /** valueParameterizationChecker: A type visitor that descends down the given type looking for instances of value types
 864      *  being used as type arguments and issues error against those usages.
 865      */
 866     private final Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt; valueParameterizationChecker = new Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt;() {
 867 
 868         @Override
 869         public Void visitType(Type t, DiagnosticPosition pos) {
 870             return null;
 871         }
 872 
 873         @Override
 874         public Void visitClassType(ClassType t, DiagnosticPosition pos) {
 875             for (Type targ : t.allparams()) {
 876                 if (types.isValue(targ) &amp;&amp; !allowGenericsOverValues) {
 877                     log.error(pos, Errors.GenericParameterizationWithValueType(t));
 878                 }
 879                 visit(targ, pos);
 880             }
 881             return null;
 882         }
 883 
 884         @Override
 885         public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {
 886              return null;
 887         }
 888 
 889         @Override
 890         public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {
 891             return null;
 892         }
 893 
 894         @Override
 895         public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {
 896             return visit(t.elemtype, pos);
 897         }
 898 
 899         @Override
 900         public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {
 901             return visit(t.type, pos);
 902         }
 903     };
 904 
 905 
 906 
 907     /** Check that usage of diamond operator is correct (i.e. diamond should not
 908      * be used with non-generic classes or in anonymous class creation expressions)
 909      */
 910     Type checkDiamond(JCNewClass tree, Type t) {
 911         if (!TreeInfo.isDiamond(tree) ||
 912                 t.isErroneous()) {
 913             return checkClassType(tree.clazz.pos(), t, true);
 914         } else {
 915             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 916                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 917                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 918             }
 919             if (t.tsym.type.getTypeArguments().isEmpty()) {
 920                 log.error(tree.clazz.pos(),
 921                           Errors.CantApplyDiamond1(t,
 922                                                    Fragments.DiamondNonGeneric(t)));
 923                 return types.createErrorType(t);
 924             } else if (tree.typeargs != null &amp;&amp;
 925                     tree.typeargs.nonEmpty()) {
 926                 log.error(tree.clazz.pos(),
 927                           Errors.CantApplyDiamond1(t,
 928                                                    Fragments.DiamondAndExplicitParams(t)));
 929                 return types.createErrorType(t);
 930             } else {
 931                 return t;
 932             }
 933         }
 934     }
 935 
 936     /** Check that the type inferred using the diamond operator does not contain
 937      *  non-denotable types such as captured types or intersection types.
 938      *  @param t the type inferred using the diamond operator
 939      *  @return  the (possibly empty) list of non-denotable types.
 940      */
 941     List&lt;Type&gt; checkDiamondDenotable(ClassType t) {
 942         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 943         for (Type arg : t.allparams()) {
 944             if (!checkDenotable(arg)) {
 945                 buf.append(arg);
 946             }
 947         }
 948         return buf.toList();
 949     }
 950 
 951     public boolean checkDenotable(Type t) {
 952         return denotableChecker.visit(t, null);
 953     }
 954         // where
 955 
 956         /** diamondTypeChecker: A type visitor that descends down the given type looking for non-denotable
 957          *  types. The visit methods return false as soon as a non-denotable type is encountered and true
 958          *  otherwise.
 959          */
 960         private static final Types.SimpleVisitor&lt;Boolean, Void&gt; denotableChecker = new Types.SimpleVisitor&lt;Boolean, Void&gt;() {
 961             @Override
 962             public Boolean visitType(Type t, Void s) {
 963                 return true;
 964             }
 965             @Override
 966             public Boolean visitClassType(ClassType t, Void s) {
 967                 if (t.isUnion() || t.isIntersection()) {
 968                     return false;
 969                 }
 970                 for (Type targ : t.allparams()) {
 971                     if (!visit(targ, s)) {
 972                         return false;
 973                     }
 974                 }
 975                 return true;
 976             }
 977 
 978             @Override
 979             public Boolean visitTypeVar(TypeVar t, Void s) {
 980                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
 981                   (i.e cannot have been produced by inference (18.4))
 982                 */
 983                 return (t.tsym.flags() &amp; SYNTHETIC) == 0;
 984             }
 985 
 986             @Override
 987             public Boolean visitCapturedType(CapturedType t, Void s) {
 988                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
 989                   (i.e cannot have been produced by capture conversion (5.1.10))
 990                 */
 991                 return false;
 992             }
 993 
 994             @Override
 995             public Boolean visitArrayType(ArrayType t, Void s) {
 996                 return visit(t.elemtype, s);
 997             }
 998 
 999             @Override
1000             public Boolean visitWildcardType(WildcardType t, Void s) {
1001                 return visit(t.type, s);
1002             }
1003         };
1004 
1005     void checkVarargsMethodDecl(Env&lt;AttrContext&gt; env, JCMethodDecl tree) {
1006         MethodSymbol m = tree.sym;
1007         boolean hasTrustMeAnno = m.attribute(syms.trustMeType.tsym) != null;
1008         Type varargElemType = null;
1009         if (m.isVarArgs()) {
1010             varargElemType = types.elemtype(tree.params.last().type);
1011         }
1012         if (hasTrustMeAnno &amp;&amp; !isTrustMeAllowedOnMethod(m)) {
1013             if (varargElemType != null) {
1014                 JCDiagnostic msg = Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ?
1015                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargs(m)) :
1016                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargsFinalOnly(m));
1017                 log.error(tree,
1018                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
1019                                                            msg));
1020             } else {
1021                 log.error(tree,
1022                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
1023                                                            Fragments.VarargsTrustmeOnNonVarargsMeth(m)));
1024             }
1025         } else if (hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
1026                             types.isReifiable(varargElemType)) {
1027             warnUnsafeVararg(tree, Warnings.VarargsRedundantTrustmeAnno(
1028                                 syms.trustMeType.tsym,
1029                                 diags.fragment(Fragments.VarargsTrustmeOnReifiableVarargs(varargElemType))));
1030         }
1031         else if (!hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
1032                 !types.isReifiable(varargElemType)) {
1033             warnUnchecked(tree.params.head.pos(), Warnings.UncheckedVarargsNonReifiableType(varargElemType));
1034         }
1035     }
1036     //where
1037         private boolean isTrustMeAllowedOnMethod(Symbol s) {
1038             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
1039                 (s.isConstructor() ||
1040                     (s.flags() &amp; (STATIC | FINAL |
1041                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
1042         }
1043 
1044     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
1045         //check that resulting type is not the null type
1046         if (t.hasTag(BOT)) {
1047             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
1048             return types.createErrorType(t);
1049         } else if (t.hasTag(VOID)) {
1050             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
1051             return types.createErrorType(t);
1052         }
1053 
1054         //upward project the initializer type
1055         Type varType = types.upward(t, types.captures(t));
1056         if (varType.hasTag(CLASS)) {
1057             checkParameterizationWithValues(pos, varType);
1058         }
1059         return varType;
1060     }
1061 
1062     public void checkForSuspectClassLiteralComparison(
1063             final JCBinary tree,
1064             final Type leftType,
1065             final Type rightType) {
1066 
1067         if (lint.isEnabled(LintCategory.MIGRATION)) {
1068             if (isInvocationOfGetClass(tree.lhs) &amp;&amp; isClassOfSomeInterface(rightType) ||
1069                     isInvocationOfGetClass(tree.rhs) &amp;&amp; isClassOfSomeInterface(leftType)) {
1070                 log.warning(LintCategory.MIGRATION, tree.pos(), Warnings.GetClassComparedWithInterface);
1071             }
1072         }
1073     }
1074     //where
1075     private boolean isClassOfSomeInterface(Type someClass) {
1076         if (someClass.tsym.flatName() == names.java_lang_Class) {
1077             List&lt;Type&gt; arguments = someClass.getTypeArguments();
1078             if (arguments.length() == 1) {
1079                 return arguments.head.isInterface();
1080             }
1081         }
1082         return false;
1083     }
1084     //where
1085     private boolean isInvocationOfGetClass(JCExpression tree) {
1086         tree = TreeInfo.skipParens(tree);
1087         if (tree.hasTag(APPLY)) {
1088             JCMethodInvocation apply = (JCMethodInvocation)tree;
1089             MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(apply.meth);
1090             return msym.name == names.getClass &amp;&amp; msym.implementedIn(syms.objectType.tsym, types) != null;
1091         }
1092         return false;
1093     }
1094 
1095     Type checkMethod(final Type mtype,
1096             final Symbol sym,
1097             final Env&lt;AttrContext&gt; env,
1098             final List&lt;JCExpression&gt; argtrees,
1099             final List&lt;Type&gt; argtypes,
1100             final boolean useVarargs,
1101             InferenceContext inferenceContext) {
1102         // System.out.println(&quot;call   : &quot; + env.tree);
1103         // System.out.println(&quot;method : &quot; + owntype);
1104         // System.out.println(&quot;actuals: &quot; + argtypes);
1105         if (inferenceContext.free(mtype)) {
1106             inferenceContext.addFreeTypeListener(List.of(mtype),
1107                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
1108             return mtype;
1109         }
1110         Type owntype = mtype;
1111         List&lt;Type&gt; formals = owntype.getParameterTypes();
1112         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
1113         if (nonInferred.length() != formals.length()) nonInferred = formals;
1114         Type last = useVarargs ? formals.last() : null;
1115         if (sym.name == names.init &amp;&amp; sym.owner == syms.enumSym) {
1116             formals = formals.tail.tail;
1117             nonInferred = nonInferred.tail.tail;
1118         }
1119         if ((sym.flags() &amp; ANONCONSTR_BASED) != 0) {
1120             formals = formals.tail;
1121             nonInferred = nonInferred.tail;
1122         }
1123         List&lt;JCExpression&gt; args = argtrees;
1124         if (args != null) {
1125             //this is null when type-checking a method reference
1126             while (formals.head != last) {
1127                 JCTree arg = args.head;
1128                 Warner warn = convertWarner(arg.pos(), arg.type, nonInferred.head);
1129                 assertConvertible(arg, arg.type, formals.head, warn);
1130                 args = args.tail;
1131                 formals = formals.tail;
1132                 nonInferred = nonInferred.tail;
1133             }
1134             if (useVarargs) {
1135                 Type varArg = types.elemtype(last);
1136                 while (args.tail != null) {
1137                     JCTree arg = args.head;
1138                     Warner warn = convertWarner(arg.pos(), arg.type, varArg);
1139                     assertConvertible(arg, arg.type, varArg, warn);
1140                     args = args.tail;
1141                 }
1142             } else if ((sym.flags() &amp; (VARARGS | SIGNATURE_POLYMORPHIC)) == VARARGS) {
1143                 // non-varargs call to varargs method
1144                 Type varParam = owntype.getParameterTypes().last();
1145                 Type lastArg = argtypes.last();
1146                 if (types.isSubtypeUnchecked(lastArg, types.elemtype(varParam)) &amp;&amp;
1147                     !types.isSameType(types.erasure(varParam), types.erasure(lastArg)))
1148                     log.warning(argtrees.last().pos(),
1149                                 Warnings.InexactNonVarargsCall(types.elemtype(varParam),varParam));
1150             }
1151         }
1152         if (useVarargs) {
1153             Type argtype = owntype.getParameterTypes().last();
1154             if (!types.isReifiable(argtype) &amp;&amp;
1155                 (sym.baseSymbol().attribute(syms.trustMeType.tsym) == null ||
1156                  !isTrustMeAllowedOnMethod(sym))) {
1157                 warnUnchecked(env.tree.pos(), Warnings.UncheckedGenericArrayCreation(argtype));
1158             }
1159             TreeInfo.setVarargsElement(env.tree, types.elemtype(argtype));
1160          }
1161          return owntype;
1162     }
1163     //where
1164     private void assertConvertible(JCTree tree, Type actual, Type formal, Warner warn) {
1165         if (types.isConvertible(actual, formal, warn))
1166             return;
1167 
1168         if (formal.isCompound()
1169             &amp;&amp; types.isSubtype(actual, types.supertype(formal))
1170             &amp;&amp; types.isSubtypeUnchecked(actual, types.interfaces(formal), warn))
1171             return;
1172     }
1173 
1174     /**
1175      * Check that type &#39;t&#39; is a valid instantiation of a generic class
1176      * (see JLS 4.5)
1177      *
1178      * @param t class type to be checked
1179      * @return true if &#39;t&#39; is well-formed
1180      */
1181     public boolean checkValidGenericType(Type t) {
1182         return firstIncompatibleTypeArg(t) == null;
1183     }
1184     //WHERE
1185         private Type firstIncompatibleTypeArg(Type type) {
1186             List&lt;Type&gt; formals = type.tsym.type.allparams();
1187             List&lt;Type&gt; actuals = type.allparams();
1188             List&lt;Type&gt; args = type.getTypeArguments();
1189             List&lt;Type&gt; forms = type.tsym.type.getTypeArguments();
1190             ListBuffer&lt;Type&gt; bounds_buf = new ListBuffer&lt;&gt;();
1191 
1192             // For matching pairs of actual argument types `a&#39; and
1193             // formal type parameters with declared bound `b&#39; ...
1194             while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1195                 // exact type arguments needs to know their
1196                 // bounds (for upper and lower bound
1197                 // calculations).  So we create new bounds where
1198                 // type-parameters are replaced with actuals argument types.
1199                 bounds_buf.append(types.subst(forms.head.getUpperBound(), formals, actuals));
1200                 args = args.tail;
1201                 forms = forms.tail;
1202             }
1203 
1204             args = type.getTypeArguments();
1205             List&lt;Type&gt; tvars_cap = types.substBounds(formals,
1206                                       formals,
1207                                       types.capture(type).allparams());
1208             while (args.nonEmpty() &amp;&amp; tvars_cap.nonEmpty()) {
1209                 // Let the actual arguments know their bound
1210                 args.head.withTypeVar((TypeVar)tvars_cap.head);
1211                 args = args.tail;
1212                 tvars_cap = tvars_cap.tail;
1213             }
1214 
1215             args = type.getTypeArguments();
1216             List&lt;Type&gt; bounds = bounds_buf.toList();
1217 
1218             while (args.nonEmpty() &amp;&amp; bounds.nonEmpty()) {
1219                 Type actual = args.head;
1220                 if (!isTypeArgErroneous(actual) &amp;&amp;
1221                         !bounds.head.isErroneous() &amp;&amp;
1222                         !checkExtends(actual, bounds.head)) {
1223                     return args.head;
1224                 }
1225                 args = args.tail;
1226                 bounds = bounds.tail;
1227             }
1228 
1229             args = type.getTypeArguments();
1230             bounds = bounds_buf.toList();
1231 
1232             for (Type arg : types.capture(type).getTypeArguments()) {
1233                 if (arg.hasTag(TYPEVAR) &amp;&amp;
1234                         arg.getUpperBound().isErroneous() &amp;&amp;
1235                         !bounds.head.isErroneous() &amp;&amp;
1236                         !isTypeArgErroneous(args.head)) {
1237                     return args.head;
1238                 }
1239                 bounds = bounds.tail;
1240                 args = args.tail;
1241             }
1242 
1243             return null;
1244         }
1245         //where
1246         boolean isTypeArgErroneous(Type t) {
1247             return isTypeArgErroneous.visit(t);
1248         }
1249 
1250         Types.UnaryVisitor&lt;Boolean&gt; isTypeArgErroneous = new Types.UnaryVisitor&lt;Boolean&gt;() {
1251             public Boolean visitType(Type t, Void s) {
1252                 return t.isErroneous();
1253             }
1254             @Override
1255             public Boolean visitTypeVar(TypeVar t, Void s) {
1256                 return visit(t.getUpperBound());
1257             }
1258             @Override
1259             public Boolean visitCapturedType(CapturedType t, Void s) {
1260                 return visit(t.getUpperBound()) ||
1261                         visit(t.getLowerBound());
1262             }
1263             @Override
1264             public Boolean visitWildcardType(WildcardType t, Void s) {
1265                 return visit(t.type);
1266             }
1267         };
1268 
1269     /** Check that given modifiers are legal for given symbol and
1270      *  return modifiers together with any implicit modifiers for that symbol.
1271      *  Warning: we can&#39;t use flags() here since this method
1272      *  is called during class enter, when flags() would cause a premature
1273      *  completion.
1274      *  @param pos           Position to be used for error reporting.
1275      *  @param flags         The set of modifiers given in a definition.
1276      *  @param sym           The defined symbol.
1277      */
1278     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1279         long mask;
1280         long implicit = 0;
1281 
1282         switch (sym.kind) {
1283         case VAR:
1284             if (TreeInfo.isReceiverParam(tree))
1285                 mask = ReceiverParamFlags;
1286             else if (sym.owner.kind != TYP)
1287                 mask = LocalVarFlags;
1288             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1289                 mask = implicit = InterfaceVarFlags;
1290             else {
1291                 mask = VarFlags;
1292                 if (types.isValue(sym.owner.type) &amp;&amp; (flags &amp; STATIC) == 0) {
1293                     implicit |= FINAL;
1294                 }
1295             }
1296             break;
1297         case MTH:
1298             if (sym.name == names.init) {
1299                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1300                     // enum constructors cannot be declared public or
1301                     // protected and must be implicitly or explicitly
1302                     // private
1303                     implicit = PRIVATE;
1304                     mask = PRIVATE;
1305                 } else
1306                     mask = ConstructorFlags;
1307             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1308                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1309                     mask = AnnotationTypeElementMask;
1310                     implicit = PUBLIC | ABSTRACT;
1311                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1312                     mask = InterfaceMethodMask;
1313                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1314                     if ((flags &amp; DEFAULT) != 0) {
1315                         implicit |= ABSTRACT;
1316                     }
1317                 } else {
1318                     mask = implicit = InterfaceMethodFlags;
1319                 }
1320             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1321                 mask = RecordMethodFlags;
1322             } else {
1323                 // instance methods of value types do not have a monitor associated with their `this&#39;
1324                 mask = ((sym.owner.flags_field &amp; VALUE) != 0 &amp;&amp; (flags &amp; Flags.STATIC) == 0) ?
1325                         MethodFlags &amp; ~SYNCHRONIZED : MethodFlags;
1326             }
1327             // Imply STRICTFP if owner has STRICTFP set.
1328             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1329                 ((flags) &amp; Flags.DEFAULT) != 0)
1330                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1331             break;
1332         case TYP:
1333             if (sym.isLocal()) {
1334                 mask = (flags &amp; RECORD) != 0 ? LocalRecordFlags : LocalClassFlags;
1335                 if ((flags &amp; RECORD) != 0) {
1336                     implicit = STATIC;
1337                     if (sym.owner.kind == TYP) {
1338                         log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1339                     }
1340                 }
1341                 if ((sym.owner.flags_field &amp; STATIC) == 0 &amp;&amp;
1342                     (flags &amp; ENUM) != 0) {
1343                     log.error(pos, Errors.EnumsMustBeStatic);
1344                 }
1345             } else if (sym.owner.kind == TYP) {
1346                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;
1347                 if (sym.owner.owner.kind == PCK ||
1348                     (sym.owner.flags_field &amp; STATIC) != 0)
1349                     mask |= STATIC;
1350                 else if ((flags &amp; ENUM) != 0) {
1351                     log.error(pos, Errors.EnumsMustBeStatic);
1352                 } else if ((flags &amp; RECORD) != 0) {
1353                     log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1354                 }
1355                 // Nested interfaces and enums are always STATIC (Spec ???)
1356                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1357             } else {
1358                 mask = ClassFlags;
1359             }
1360             // Interfaces are always ABSTRACT
1361             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1362 
1363             if ((flags &amp; ENUM) != 0) {
1364                 // enums can&#39;t be declared abstract or final or value type
1365                 mask &amp;= ~(ABSTRACT | FINAL | VALUE);
1366                 implicit |= implicitEnumFinalFlag(tree);
1367             }
1368             if ((flags &amp; RECORD) != 0) {
1369                 // records can&#39;t be declared abstract
1370                 mask &amp;= ~ABSTRACT;
1371                 implicit |= FINAL;
1372             }
1373             // Imply STRICTFP if owner has STRICTFP set.
1374             implicit |= sym.owner.flags_field &amp; STRICTFP;
1375             break;
1376         default:
1377             throw new AssertionError();
1378         }
1379         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1380         if (illegal != 0) {
1381             if ((illegal &amp; INTERFACE) != 0) {
1382                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1383                 mask |= INTERFACE;
1384             }
1385             else {
1386                 log.error(pos,
1387                           Errors.ModNotAllowedHere(asFlagSet(illegal)));
1388             }
1389         }
1390         else if ((sym.kind == TYP ||
1391                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1392                   // in the presence of inner classes. Should it be deleted here?
1393                   checkDisjoint(pos, flags,
1394                                 ABSTRACT,
1395                                 PRIVATE | STATIC | DEFAULT))
1396                  &amp;&amp;
1397                  checkDisjoint(pos, flags,
1398                                 STATIC | PRIVATE,
1399                                 DEFAULT)
1400                  &amp;&amp;
1401                  checkDisjoint(pos, flags,
1402                                ABSTRACT | INTERFACE,
1403                                FINAL | NATIVE | SYNCHRONIZED | VALUE)
1404                  &amp;&amp;
1405                  checkDisjoint(pos, flags,
1406                                PUBLIC,
1407                                PRIVATE | PROTECTED)
1408                  &amp;&amp;
1409                  checkDisjoint(pos, flags,
1410                                PRIVATE,
1411                                PUBLIC | PROTECTED)
1412                  &amp;&amp;
1413                  checkDisjoint(pos, flags,
1414                                FINAL,
1415                                VOLATILE)
1416                  &amp;&amp;
1417                  (sym.kind == TYP ||
1418                   checkDisjoint(pos, flags,
1419                                 ABSTRACT | NATIVE,
1420                                 STRICTFP))) {
1421             // skip
1422         }
1423         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1424     }
1425 
1426 
1427     /** Determine if this enum should be implicitly final.
1428      *
1429      *  If the enum has no specialized enum constants, it is final.
1430      *
1431      *  If the enum does have specialized enum constants, it is
1432      *  &lt;i&gt;not&lt;/i&gt; final.
1433      */
1434     private long implicitEnumFinalFlag(JCTree tree) {
1435         if (!tree.hasTag(CLASSDEF)) return 0;
1436         class SpecialTreeVisitor extends JCTree.Visitor {
1437             boolean specialized;
1438             SpecialTreeVisitor() {
1439                 this.specialized = false;
1440             }
1441 
1442             @Override
1443             public void visitTree(JCTree tree) { /* no-op */ }
1444 
1445             @Override
1446             public void visitVarDef(JCVariableDecl tree) {
1447                 if ((tree.mods.flags &amp; ENUM) != 0) {
1448                     if (tree.init instanceof JCNewClass &amp;&amp;
1449                         ((JCNewClass) tree.init).def != null) {
1450                         specialized = true;
1451                     }
1452                 }
1453             }
1454         }
1455 
1456         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1457         JCClassDecl cdef = (JCClassDecl) tree;
1458         for (JCTree defs: cdef.defs) {
1459             defs.accept(sts);
1460             if (sts.specialized) return 0;
1461         }
1462         return FINAL;
1463     }
1464 
1465 /* *************************************************************************
1466  * Type Validation
1467  **************************************************************************/
1468 
1469     /** Validate a type expression. That is,
1470      *  check that all type arguments of a parametric type are within
1471      *  their bounds. This must be done in a second phase after type attribution
1472      *  since a class might have a subclass as type parameter bound. E.g:
1473      *
1474      *  &lt;pre&gt;{@code
1475      *  class B&lt;A extends C&gt; { ... }
1476      *  class C extends B&lt;C&gt; { ... }
1477      *  }&lt;/pre&gt;
1478      *
1479      *  and we can&#39;t make sure that the bound is already attributed because
1480      *  of possible cycles.
1481      *
1482      * Visitor method: Validate a type expression, if it is not null, catching
1483      *  and reporting any completion failures.
1484      */
1485     void validate(JCTree tree, Env&lt;AttrContext&gt; env) {
1486         validate(tree, env, true);
1487     }
1488     void validate(JCTree tree, Env&lt;AttrContext&gt; env, boolean checkRaw) {
1489         new Validator(env).validateTree(tree, checkRaw, true);
1490     }
1491 
1492     /** Visitor method: Validate a list of type expressions.
1493      */
1494     void validate(List&lt;? extends JCTree&gt; trees, Env&lt;AttrContext&gt; env) {
1495         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1496             validate(l.head, env);
1497     }
1498 
1499     /** A visitor class for type validation.
1500      */
1501     class Validator extends JCTree.Visitor {
1502 
1503         boolean checkRaw;
1504         boolean isOuter;
1505         Env&lt;AttrContext&gt; env;
1506 
1507         Validator(Env&lt;AttrContext&gt; env) {
1508             this.env = env;
1509         }
1510 
1511         @Override
1512         public void visitTypeArray(JCArrayTypeTree tree) {
1513             validateTree(tree.elemtype, checkRaw, isOuter);
1514         }
1515 
1516         @Override
1517         public void visitTypeApply(JCTypeApply tree) {
1518             if (tree.type.hasTag(CLASS)) {
1519                 List&lt;JCExpression&gt; args = tree.arguments;
1520                 List&lt;Type&gt; forms = tree.type.tsym.type.getTypeArguments();
1521 
1522                 Type incompatibleArg = firstIncompatibleTypeArg(tree.type);
1523                 if (incompatibleArg != null) {
1524                     for (JCTree arg : tree.arguments) {
1525                         if (arg.type == incompatibleArg) {
1526                             log.error(arg, Errors.NotWithinBounds(incompatibleArg, forms.head));
1527                         }
1528                         forms = forms.tail;
1529                      }
1530                  }
1531 
1532                 forms = tree.type.tsym.type.getTypeArguments();
1533 
1534                 boolean is_java_lang_Class = tree.type.tsym.flatName() == names.java_lang_Class;
1535 
1536                 // For matching pairs of actual argument types `a&#39; and
1537                 // formal type parameters with declared bound `b&#39; ...
1538                 while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1539                     validateTree(args.head,
1540                             !(isOuter &amp;&amp; is_java_lang_Class),
1541                             false);
1542                     args = args.tail;
1543                     forms = forms.tail;
1544                 }
1545 
1546                 // Check that this type is either fully parameterized, or
1547                 // not parameterized at all.
1548                 if (tree.type.getEnclosingType().isRaw())
1549                     log.error(tree.pos(), Errors.ImproperlyFormedTypeInnerRawParam);
1550                 if (tree.clazz.hasTag(SELECT))
1551                     visitSelectInternal((JCFieldAccess)tree.clazz);
1552             }
1553         }
1554 
1555         @Override
1556         public void visitTypeParameter(JCTypeParameter tree) {
1557             validateTrees(tree.bounds, true, isOuter);
1558             checkClassBounds(tree.pos(), tree.type);
1559         }
1560 
1561         @Override
1562         public void visitWildcard(JCWildcard tree) {
1563             if (tree.inner != null)
1564                 validateTree(tree.inner, true, isOuter);
1565         }
1566 
1567         @Override
1568         public void visitSelect(JCFieldAccess tree) {
1569             if (tree.type.hasTag(CLASS)) {
1570                 visitSelectInternal(tree);
1571 
1572                 // Check that this type is either fully parameterized, or
1573                 // not parameterized at all.
1574                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1575                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1576             }
1577         }
1578 
1579         public void visitSelectInternal(JCFieldAccess tree) {
1580             if (tree.type.tsym.isStatic() &amp;&amp;
1581                 tree.selected.type.isParameterized()) {
1582                 // The enclosing type is not a class, so we are
1583                 // looking at a static member type.  However, the
1584                 // qualifying expression is parameterized.
1585                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1586             } else {
1587                 // otherwise validate the rest of the expression
1588                 tree.selected.accept(this);
1589             }
1590         }
1591 
1592         @Override
1593         public void visitAnnotatedType(JCAnnotatedType tree) {
1594             tree.underlyingType.accept(this);
1595         }
1596 
1597         @Override
1598         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1599             if (that.type.hasTag(TypeTag.VOID)) {
1600                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1601             }
1602             super.visitTypeIdent(that);
1603         }
1604 
1605         /** Default visitor method: do nothing.
1606          */
1607         @Override
1608         public void visitTree(JCTree tree) {
1609         }
1610 
1611         public void validateTree(JCTree tree, boolean checkRaw, boolean isOuter) {
1612             if (tree != null) {
1613                 boolean prevCheckRaw = this.checkRaw;
1614                 this.checkRaw = checkRaw;
1615                 this.isOuter = isOuter;
1616 
1617                 try {
1618                     tree.accept(this);
1619                     if (checkRaw)
1620                         checkRaw(tree, env);
1621                 } catch (CompletionFailure ex) {
1622                     completionError(tree.pos(), ex);
1623                 } finally {
1624                     this.checkRaw = prevCheckRaw;
1625                 }
1626             }
1627         }
1628 
1629         public void validateTrees(List&lt;? extends JCTree&gt; trees, boolean checkRaw, boolean isOuter) {
1630             for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1631                 validateTree(l.head, checkRaw, isOuter);
1632         }
1633     }
1634 
1635     void checkRaw(JCTree tree, Env&lt;AttrContext&gt; env) {
1636         if (lint.isEnabled(LintCategory.RAW) &amp;&amp;
1637             tree.type.hasTag(CLASS) &amp;&amp;
1638             !TreeInfo.isDiamond(tree) &amp;&amp;
1639             !withinAnonConstr(env) &amp;&amp;
1640             tree.type.isRaw()) {
1641             log.warning(LintCategory.RAW,
1642                     tree.pos(), Warnings.RawClassUse(tree.type, tree.type.tsym.type));
1643         }
1644     }
1645     //where
1646         private boolean withinAnonConstr(Env&lt;AttrContext&gt; env) {
1647             return env.enclClass.name.isEmpty() &amp;&amp;
1648                     env.enclMethod != null &amp;&amp; env.enclMethod.name == names.init;
1649         }
1650 
1651 /* *************************************************************************
1652  * Exception checking
1653  **************************************************************************/
1654 
1655     /* The following methods treat classes as sets that contain
1656      * the class itself and all their subclasses
1657      */
1658 
1659     /** Is given type a subtype of some of the types in given list?
1660      */
1661     boolean subset(Type t, List&lt;Type&gt; ts) {
1662         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1663             if (types.isSubtype(t, l.head)) return true;
1664         return false;
1665     }
1666 
1667     /** Is given type a subtype or supertype of
1668      *  some of the types in given list?
1669      */
1670     boolean intersects(Type t, List&lt;Type&gt; ts) {
1671         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1672             if (types.isSubtype(t, l.head) || types.isSubtype(l.head, t)) return true;
1673         return false;
1674     }
1675 
1676     /** Add type set to given type list, unless it is a subclass of some class
1677      *  in the list.
1678      */
1679     List&lt;Type&gt; incl(Type t, List&lt;Type&gt; ts) {
1680         return subset(t, ts) ? ts : excl(t, ts).prepend(t);
1681     }
1682 
1683     /** Remove type set from type set list.
1684      */
1685     List&lt;Type&gt; excl(Type t, List&lt;Type&gt; ts) {
1686         if (ts.isEmpty()) {
1687             return ts;
1688         } else {
1689             List&lt;Type&gt; ts1 = excl(t, ts.tail);
1690             if (types.isSubtype(ts.head, t)) return ts1;
1691             else if (ts1 == ts.tail) return ts;
1692             else return ts1.prepend(ts.head);
1693         }
1694     }
1695 
1696     /** Form the union of two type set lists.
1697      */
1698     List&lt;Type&gt; union(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1699         List&lt;Type&gt; ts = ts1;
1700         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1701             ts = incl(l.head, ts);
1702         return ts;
1703     }
1704 
1705     /** Form the difference of two type lists.
1706      */
1707     List&lt;Type&gt; diff(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1708         List&lt;Type&gt; ts = ts1;
1709         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1710             ts = excl(l.head, ts);
1711         return ts;
1712     }
1713 
1714     /** Form the intersection of two type lists.
1715      */
1716     public List&lt;Type&gt; intersect(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1717         List&lt;Type&gt; ts = List.nil();
1718         for (List&lt;Type&gt; l = ts1; l.nonEmpty(); l = l.tail)
1719             if (subset(l.head, ts2)) ts = incl(l.head, ts);
1720         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1721             if (subset(l.head, ts1)) ts = incl(l.head, ts);
1722         return ts;
1723     }
1724 
1725     /** Is exc an exception symbol that need not be declared?
1726      */
1727     boolean isUnchecked(ClassSymbol exc) {
1728         return
1729             exc.kind == ERR ||
1730             exc.isSubClass(syms.errorType.tsym, types) ||
1731             exc.isSubClass(syms.runtimeExceptionType.tsym, types);
1732     }
1733 
1734     /** Is exc an exception type that need not be declared?
1735      */
1736     boolean isUnchecked(Type exc) {
1737         return
1738             (exc.hasTag(TYPEVAR)) ? isUnchecked(types.supertype(exc)) :
1739             (exc.hasTag(CLASS)) ? isUnchecked((ClassSymbol)exc.tsym) :
1740             exc.hasTag(BOT);
1741     }
1742 
1743     boolean isChecked(Type exc) {
1744         return !isUnchecked(exc);
1745     }
1746 
1747     /** Same, but handling completion failures.
1748      */
1749     boolean isUnchecked(DiagnosticPosition pos, Type exc) {
1750         try {
1751             return isUnchecked(exc);
1752         } catch (CompletionFailure ex) {
1753             completionError(pos, ex);
1754             return true;
1755         }
1756     }
1757 
1758     /** Is exc handled by given exception list?
1759      */
1760     boolean isHandled(Type exc, List&lt;Type&gt; handled) {
1761         return isUnchecked(exc) || subset(exc, handled);
1762     }
1763 
1764     /** Return all exceptions in thrown list that are not in handled list.
1765      *  @param thrown     The list of thrown exceptions.
1766      *  @param handled    The list of handled exceptions.
1767      */
1768     List&lt;Type&gt; unhandled(List&lt;Type&gt; thrown, List&lt;Type&gt; handled) {
1769         List&lt;Type&gt; unhandled = List.nil();
1770         for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1771             if (!isHandled(l.head, handled)) unhandled = unhandled.prepend(l.head);
1772         return unhandled;
1773     }
1774 
1775 /* *************************************************************************
1776  * Overriding/Implementation checking
1777  **************************************************************************/
1778 
1779     /** The level of access protection given by a flag set,
1780      *  where PRIVATE is highest and PUBLIC is lowest.
1781      */
1782     static int protection(long flags) {
1783         switch ((short)(flags &amp; AccessFlags)) {
1784         case PRIVATE: return 3;
1785         case PROTECTED: return 1;
1786         default:
1787         case PUBLIC: return 0;
1788         case 0: return 2;
1789         }
1790     }
1791 
1792     /** A customized &quot;cannot override&quot; error message.
1793      *  @param m      The overriding method.
1794      *  @param other  The overridden method.
1795      *  @return       An internationalized string.
1796      */
1797     Fragment cannotOverride(MethodSymbol m, MethodSymbol other) {
1798         Symbol mloc = m.location();
1799         Symbol oloc = other.location();
1800 
1801         if ((other.owner.flags() &amp; INTERFACE) == 0)
1802             return Fragments.CantOverride(m, mloc, other, oloc);
1803         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1804             return Fragments.CantImplement(m, mloc, other, oloc);
1805         else
1806             return Fragments.ClashesWith(m, mloc, other, oloc);
1807     }
1808 
1809     /** A customized &quot;override&quot; warning message.
1810      *  @param m      The overriding method.
1811      *  @param other  The overridden method.
1812      *  @return       An internationalized string.
1813      */
1814     Fragment uncheckedOverrides(MethodSymbol m, MethodSymbol other) {
1815         Symbol mloc = m.location();
1816         Symbol oloc = other.location();
1817 
1818         if ((other.owner.flags() &amp; INTERFACE) == 0)
1819             return Fragments.UncheckedOverride(m, mloc, other, oloc);
1820         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1821             return Fragments.UncheckedImplement(m, mloc, other, oloc);
1822         else
1823             return Fragments.UncheckedClashWith(m, mloc, other, oloc);
1824     }
1825 
1826     /** A customized &quot;override&quot; warning message.
1827      *  @param m      The overriding method.
1828      *  @param other  The overridden method.
1829      *  @return       An internationalized string.
1830      */
1831     Fragment varargsOverrides(MethodSymbol m, MethodSymbol other) {
1832         Symbol mloc = m.location();
1833         Symbol oloc = other.location();
1834 
1835         if ((other.owner.flags() &amp; INTERFACE) == 0)
1836             return Fragments.VarargsOverride(m, mloc, other, oloc);
1837         else  if ((m.owner.flags() &amp; INTERFACE) == 0)
1838             return Fragments.VarargsImplement(m, mloc, other, oloc);
1839         else
1840             return Fragments.VarargsClashWith(m, mloc, other, oloc);
1841     }
1842 
1843     /** Check that this method conforms with overridden method &#39;other&#39;.
1844      *  where `origin&#39; is the class where checking started.
1845      *  Complications:
1846      *  (1) Do not check overriding of synthetic methods
1847      *      (reason: they might be final).
1848      *      todo: check whether this is still necessary.
1849      *  (2) Admit the case where an interface proxy throws fewer exceptions
1850      *      than the method it implements. Augment the proxy methods with the
1851      *      undeclared exceptions in this case.
1852      *  (3) When generics are enabled, admit the case where an interface proxy
1853      *      has a result type
1854      *      extended by the result type of the method it implements.
1855      *      Change the proxies result type to the smaller type in this case.
1856      *
1857      *  @param tree         The tree from which positions
1858      *                      are extracted for errors.
1859      *  @param m            The overriding method.
1860      *  @param other        The overridden method.
1861      *  @param origin       The class of which the overriding method
1862      *                      is a member.
1863      */
1864     void checkOverride(JCTree tree,
1865                        MethodSymbol m,
1866                        MethodSymbol other,
1867                        ClassSymbol origin) {
1868         // Don&#39;t check overriding of synthetic methods or by bridge methods.
1869         if ((m.flags() &amp; (SYNTHETIC|BRIDGE)) != 0 || (other.flags() &amp; SYNTHETIC) != 0) {
1870             return;
1871         }
1872 
1873         // Error if static method overrides instance method (JLS 8.4.6.2).
1874         if ((m.flags() &amp; STATIC) != 0 &amp;&amp;
1875                    (other.flags() &amp; STATIC) == 0) {
1876             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1877                       Errors.OverrideStatic(cannotOverride(m, other)));
1878             m.flags_field |= BAD_OVERRIDE;
1879             return;
1880         }
1881 
1882         // Error if instance method overrides static or final
1883         // method (JLS 8.4.6.1).
1884         if ((other.flags() &amp; FINAL) != 0 ||
1885                  (m.flags() &amp; STATIC) == 0 &amp;&amp;
1886                  (other.flags() &amp; STATIC) != 0) {
1887             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1888                       Errors.OverrideMeth(cannotOverride(m, other),
1889                                           asFlagSet(other.flags() &amp; (FINAL | STATIC))));
1890             m.flags_field |= BAD_OVERRIDE;
1891             return;
1892         }
1893 
1894         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1895             // handled in validateAnnotationMethod
1896             return;
1897         }
1898 
1899         // Error if overriding method has weaker access (JLS 8.4.6.3).
1900         if (protection(m.flags()) &gt; protection(other.flags())) {
1901             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1902                       (other.flags() &amp; AccessFlags) == 0 ?
1903                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1904                                                           &quot;package&quot;) :
1905                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1906                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1907             m.flags_field |= BAD_OVERRIDE;
1908             return;
1909         }
1910 
1911         if (origin.isValue() &amp;&amp; other.owner == syms.objectType.tsym &amp;&amp; m.type.getParameterTypes().size() == 0) {
1912             if (m.name == names.clone || m.name == names.finalize) {
1913                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1914                         Errors.InlineClassMayNotOverride(m.name));
1915                 m.flags_field |= BAD_OVERRIDE;
1916                 return;
1917             }
1918         }
1919 
1920         Type mt = types.memberType(origin.type, m);
1921         Type ot = types.memberType(origin.type, other);
1922         // Error if overriding result type is different
1923         // (or, in the case of generics mode, not a subtype) of
1924         // overridden result type. We have to rename any type parameters
1925         // before comparing types.
1926         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1927         List&lt;Type&gt; otvars = ot.getTypeArguments();
1928         Type mtres = mt.getReturnType();
1929         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1930 
1931         overrideWarner.clear();
1932         boolean resultTypesOK =
1933             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1934         if (!resultTypesOK) {
1935             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1936                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1937                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1938                                         other.location()), mtres, otres));
1939                 m.flags_field |= BAD_OVERRIDE;
1940             } else {
1941                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1942                           Errors.OverrideIncompatibleRet(cannotOverride(m, other), mtres, otres));
1943                 m.flags_field |= BAD_OVERRIDE;
1944             }
1945             return;
1946         } else if (overrideWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
1947             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
1948                     Warnings.OverrideUncheckedRet(uncheckedOverrides(m, other), mtres, otres));
1949         }
1950 
1951         // Error if overriding method throws an exception not reported
1952         // by overridden method.
1953         List&lt;Type&gt; otthrown = types.subst(ot.getThrownTypes(), otvars, mtvars);
1954         List&lt;Type&gt; unhandledErased = unhandled(mt.getThrownTypes(), types.erasure(otthrown));
1955         List&lt;Type&gt; unhandledUnerased = unhandled(mt.getThrownTypes(), otthrown);
1956         if (unhandledErased.nonEmpty()) {
1957             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1958                       Errors.OverrideMethDoesntThrow(cannotOverride(m, other), unhandledUnerased.head));
1959             m.flags_field |= BAD_OVERRIDE;
1960             return;
1961         }
1962         else if (unhandledUnerased.nonEmpty()) {
1963             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
1964                           Warnings.OverrideUncheckedThrown(cannotOverride(m, other), unhandledUnerased.head));
1965             return;
1966         }
1967 
1968         // Optional warning if varargs don&#39;t agree
1969         if ((((m.flags() ^ other.flags()) &amp; Flags.VARARGS) != 0)
1970             &amp;&amp; lint.isEnabled(LintCategory.OVERRIDES)) {
1971             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
1972                         ((m.flags() &amp; Flags.VARARGS) != 0)
1973                         ? Warnings.OverrideVarargsMissing(varargsOverrides(m, other))
1974                         : Warnings.OverrideVarargsExtra(varargsOverrides(m, other)));
1975         }
1976 
1977         // Warn if instance method overrides bridge method (compiler spec ??)
1978         if ((other.flags() &amp; BRIDGE) != 0) {
1979             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
1980                         Warnings.OverrideBridge(uncheckedOverrides(m, other)));
1981         }
1982 
1983         // Warn if a deprecated method overridden by a non-deprecated one.
1984         if (!isDeprecatedOverrideIgnorable(other, origin)) {
1985             Lint prevLint = setLint(lint.augment(m));
1986             try {
1987                 checkDeprecated(() -&gt; TreeInfo.diagnosticPositionFor(m, tree), m, other);
1988             } finally {
1989                 setLint(prevLint);
1990             }
1991         }
1992     }
1993     // where
1994         private boolean isDeprecatedOverrideIgnorable(MethodSymbol m, ClassSymbol origin) {
1995             // If the method, m, is defined in an interface, then ignore the issue if the method
1996             // is only inherited via a supertype and also implemented in the supertype,
1997             // because in that case, we will rediscover the issue when examining the method
1998             // in the supertype.
1999             // If the method, m, is not defined in an interface, then the only time we need to
2000             // address the issue is when the method is the supertype implementation: any other
2001             // case, we will have dealt with when examining the supertype classes
2002             ClassSymbol mc = m.enclClass();
2003             Type st = types.supertype(origin.type);
2004             if (!st.hasTag(CLASS))
2005                 return true;
2006             MethodSymbol stimpl = m.implementation((ClassSymbol)st.tsym, types, false);
2007 
2008             if (mc != null &amp;&amp; ((mc.flags() &amp; INTERFACE) != 0)) {
2009                 List&lt;Type&gt; intfs = types.interfaces(origin.type);
2010                 return (intfs.contains(mc.type) ? false : (stimpl != null));
2011             }
2012             else
2013                 return (stimpl != m);
2014         }
2015 
2016 
2017     // used to check if there were any unchecked conversions
2018     Warner overrideWarner = new Warner();
2019 
2020     /** Check that a class does not inherit two concrete methods
2021      *  with the same signature.
2022      *  @param pos          Position to be used for error reporting.
2023      *  @param site         The class type to be checked.
2024      */
2025     public void checkCompatibleConcretes(DiagnosticPosition pos, Type site) {
2026         Type sup = types.supertype(site);
2027         if (!sup.hasTag(CLASS)) return;
2028 
2029         for (Type t1 = sup;
2030              t1.hasTag(CLASS) &amp;&amp; t1.tsym.type.isParameterized();
2031              t1 = types.supertype(t1)) {
2032             for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2033                 if (s1.kind != MTH ||
2034                     (s1.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
2035                     !s1.isInheritedIn(site.tsym, types) ||
2036                     ((MethodSymbol)s1).implementation(site.tsym,
2037                                                       types,
2038                                                       true) != s1)
2039                     continue;
2040                 Type st1 = types.memberType(t1, s1);
2041                 int s1ArgsLength = st1.getParameterTypes().length();
2042                 if (st1 == s1.type) continue;
2043 
2044                 for (Type t2 = sup;
2045                      t2.hasTag(CLASS);
2046                      t2 = types.supertype(t2)) {
2047                     for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2048                         if (s2 == s1 ||
2049                             s2.kind != MTH ||
2050                             (s2.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
2051                             s2.type.getParameterTypes().length() != s1ArgsLength ||
2052                             !s2.isInheritedIn(site.tsym, types) ||
2053                             ((MethodSymbol)s2).implementation(site.tsym,
2054                                                               types,
2055                                                               true) != s2)
2056                             continue;
2057                         Type st2 = types.memberType(t2, s2);
2058                         if (types.overrideEquivalent(st1, st2))
2059                             log.error(pos,
2060                                       Errors.ConcreteInheritanceConflict(s1, t1, s2, t2, sup));
2061                     }
2062                 }
2063             }
2064         }
2065     }
2066 
2067     /** Check that classes (or interfaces) do not each define an abstract
2068      *  method with same name and arguments but incompatible return types.
2069      *  @param pos          Position to be used for error reporting.
2070      *  @param t1           The first argument type.
2071      *  @param t2           The second argument type.
2072      */
2073     public boolean checkCompatibleAbstracts(DiagnosticPosition pos,
2074                                             Type t1,
2075                                             Type t2,
2076                                             Type site) {
2077         if ((site.tsym.flags() &amp; COMPOUND) != 0) {
2078             // special case for intersections: need to eliminate wildcards in supertypes
2079             t1 = types.capture(t1);
2080             t2 = types.capture(t2);
2081         }
2082         return firstIncompatibility(pos, t1, t2, site) == null;
2083     }
2084 
2085     /** Return the first method which is defined with same args
2086      *  but different return types in two given interfaces, or null if none
2087      *  exists.
2088      *  @param t1     The first type.
2089      *  @param t2     The second type.
2090      *  @param site   The most derived type.
2091      *  @return symbol from t2 that conflicts with one in t1.
2092      */
2093     private Symbol firstIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2094         Map&lt;TypeSymbol,Type&gt; interfaces1 = new HashMap&lt;&gt;();
2095         closure(t1, interfaces1);
2096         Map&lt;TypeSymbol,Type&gt; interfaces2;
2097         if (t1 == t2)
2098             interfaces2 = interfaces1;
2099         else
2100             closure(t2, interfaces1, interfaces2 = new HashMap&lt;&gt;());
2101 
2102         for (Type t3 : interfaces1.values()) {
2103             for (Type t4 : interfaces2.values()) {
2104                 Symbol s = firstDirectIncompatibility(pos, t3, t4, site);
2105                 if (s != null) return s;
2106             }
2107         }
2108         return null;
2109     }
2110 
2111     /** Compute all the supertypes of t, indexed by type symbol. */
2112     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typeMap) {
2113         if (!t.hasTag(CLASS)) return;
2114         if (typeMap.put(t.tsym, t) == null) {
2115             closure(types.supertype(t), typeMap);
2116             for (Type i : types.interfaces(t))
2117                 closure(i, typeMap);
2118         }
2119     }
2120 
2121     /** Compute all the supertypes of t, indexed by type symbol (except those in typesSkip). */
2122     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typesSkip, Map&lt;TypeSymbol,Type&gt; typeMap) {
2123         if (!t.hasTag(CLASS)) return;
2124         if (typesSkip.get(t.tsym) != null) return;
2125         if (typeMap.put(t.tsym, t) == null) {
2126             closure(types.supertype(t), typesSkip, typeMap);
2127             for (Type i : types.interfaces(t))
2128                 closure(i, typesSkip, typeMap);
2129         }
2130     }
2131 
2132     /** Return the first method in t2 that conflicts with a method from t1. */
2133     private Symbol firstDirectIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2134         for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2135             Type st1 = null;
2136             if (s1.kind != MTH || !s1.isInheritedIn(site.tsym, types) ||
2137                     (s1.flags() &amp; SYNTHETIC) != 0) continue;
2138             Symbol impl = ((MethodSymbol)s1).implementation(site.tsym, types, false);
2139             if (impl != null &amp;&amp; (impl.flags() &amp; ABSTRACT) == 0) continue;
2140             for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2141                 if (s1 == s2) continue;
2142                 if (s2.kind != MTH || !s2.isInheritedIn(site.tsym, types) ||
2143                         (s2.flags() &amp; SYNTHETIC) != 0) continue;
2144                 if (st1 == null) st1 = types.memberType(t1, s1);
2145                 Type st2 = types.memberType(t2, s2);
2146                 if (types.overrideEquivalent(st1, st2)) {
2147                     List&lt;Type&gt; tvars1 = st1.getTypeArguments();
2148                     List&lt;Type&gt; tvars2 = st2.getTypeArguments();
2149                     Type rt1 = st1.getReturnType();
2150                     Type rt2 = types.subst(st2.getReturnType(), tvars2, tvars1);
2151                     boolean compat =
2152                         types.isSameType(rt1, rt2) ||
2153                         !rt1.isPrimitiveOrVoid() &amp;&amp;
2154                         !rt2.isPrimitiveOrVoid() &amp;&amp;
2155                         (types.covariantReturnType(rt1, rt2, types.noWarnings) ||
2156                          types.covariantReturnType(rt2, rt1, types.noWarnings)) ||
2157                          checkCommonOverriderIn(s1,s2,site);
2158                     if (!compat) {
2159                         log.error(pos, Errors.TypesIncompatible(t1, t2,
2160                                 Fragments.IncompatibleDiffRet(s2.name, types.memberType(t2, s2).getParameterTypes())));
2161                         return s2;
2162                     }
2163                 } else if (checkNameClash((ClassSymbol)site.tsym, s1, s2) &amp;&amp;
2164                         !checkCommonOverriderIn(s1, s2, site)) {
2165                     log.error(pos, Errors.NameClashSameErasureNoOverride(
2166                             s1.name, types.memberType(site, s1).asMethodType().getParameterTypes(), s1.location(),
2167                             s2.name, types.memberType(site, s2).asMethodType().getParameterTypes(), s2.location()));
2168                     return s2;
2169                 }
2170             }
2171         }
2172         return null;
2173     }
2174     //WHERE
2175     boolean checkCommonOverriderIn(Symbol s1, Symbol s2, Type site) {
2176         Map&lt;TypeSymbol,Type&gt; supertypes = new HashMap&lt;&gt;();
2177         Type st1 = types.memberType(site, s1);
2178         Type st2 = types.memberType(site, s2);
2179         closure(site, supertypes);
2180         for (Type t : supertypes.values()) {
2181             for (Symbol s3 : t.tsym.members().getSymbolsByName(s1.name)) {
2182                 if (s3 == s1 || s3 == s2 || s3.kind != MTH || (s3.flags() &amp; (BRIDGE|SYNTHETIC)) != 0) continue;
2183                 Type st3 = types.memberType(site,s3);
2184                 if (types.overrideEquivalent(st3, st1) &amp;&amp;
2185                         types.overrideEquivalent(st3, st2) &amp;&amp;
2186                         types.returnTypeSubstitutable(st3, st1) &amp;&amp;
2187                         types.returnTypeSubstitutable(st3, st2)) {
2188                     return true;
2189                 }
2190             }
2191         }
2192         return false;
2193     }
2194 
2195     /** Check that a given method conforms with any method it overrides.
2196      *  @param tree         The tree from which positions are extracted
2197      *                      for errors.
2198      *  @param m            The overriding method.
2199      */
2200     void checkOverride(Env&lt;AttrContext&gt; env, JCMethodDecl tree, MethodSymbol m) {
2201         ClassSymbol origin = (ClassSymbol)m.owner;
2202         if ((origin.flags() &amp; ENUM) != 0 &amp;&amp; names.finalize.equals(m.name))
2203             if (m.overrides(syms.enumFinalFinalize, origin, types, false)) {
2204                 log.error(tree.pos(), Errors.EnumNoFinalize);
2205                 return;
2206             }
2207         for (Type t = origin.type; t.hasTag(CLASS);
2208              t = types.supertype(t)) {
2209             if (t != origin.type) {
2210                 checkOverride(tree, t, origin, m);
2211             }
2212             for (Type t2 : types.interfaces(t)) {
2213                 checkOverride(tree, t2, origin, m);
2214             }
2215         }
2216 
2217         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2218         // Check if this method must override a super method due to being annotated with @Override
2219         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2220         // be treated &quot;as if as they were annotated&quot; with @Override.
2221         boolean mustOverride = explicitOverride ||
2222                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate() &amp;&amp;
2223                         (!m.owner.isValue() || (tree.body.flags &amp; SYNTHETIC) == 0));
2224         if (mustOverride &amp;&amp; !isOverrider(m)) {
2225             DiagnosticPosition pos = tree.pos();
2226             for (JCAnnotation a : tree.getModifiers().annotations) {
2227                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2228                     pos = a.pos();
2229                     break;
2230                 }
2231             }
2232             log.error(pos,
2233                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2234                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2235         }
2236     }
2237 
2238     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2239         TypeSymbol c = site.tsym;
2240         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2241             if (m.overrides(sym, origin, types, false)) {
2242                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2243                     checkOverride(tree, m, (MethodSymbol)sym, origin);
2244                 }
2245             }
2246         }
2247     }
2248 
2249     private Filter&lt;Symbol&gt; equalsHasCodeFilter = s -&gt; MethodSymbol.implementation_filter.accepts(s) &amp;&amp;
2250             (s.flags() &amp; BAD_OVERRIDE) == 0;
2251 
2252     public void checkClassOverrideEqualsAndHashIfNeeded(DiagnosticPosition pos,
2253             ClassSymbol someClass) {
2254         /* At present, annotations cannot possibly have a method that is override
2255          * equivalent with Object.equals(Object) but in any case the condition is
2256          * fine for completeness.
2257          */
2258         if (someClass == (ClassSymbol)syms.objectType.tsym ||
2259             someClass.isInterface() || someClass.isEnum() ||
2260             (someClass.flags() &amp; ANNOTATION) != 0 ||
2261             (someClass.flags() &amp; ABSTRACT) != 0) return;
2262         //anonymous inner classes implementing interfaces need especial treatment
2263         if (someClass.isAnonymous()) {
2264             List&lt;Type&gt; interfaces =  types.interfaces(someClass.type);
2265             if (interfaces != null &amp;&amp; !interfaces.isEmpty() &amp;&amp;
2266                 interfaces.head.tsym == syms.comparatorType.tsym) return;
2267         }
2268         checkClassOverrideEqualsAndHash(pos, someClass);
2269     }
2270 
2271     private void checkClassOverrideEqualsAndHash(DiagnosticPosition pos,
2272             ClassSymbol someClass) {
2273         if (lint.isEnabled(LintCategory.OVERRIDES)) {
2274             MethodSymbol equalsAtObject = (MethodSymbol)syms.objectType
2275                     .tsym.members().findFirst(names.equals);
2276             MethodSymbol hashCodeAtObject = (MethodSymbol)syms.objectType
2277                     .tsym.members().findFirst(names.hashCode);
2278             boolean overridesEquals = types.implementation(equalsAtObject,
2279                 someClass, false, equalsHasCodeFilter).owner == someClass;
2280             boolean overridesHashCode = types.implementation(hashCodeAtObject,
2281                 someClass, false, equalsHasCodeFilter) != hashCodeAtObject;
2282 
2283             if (overridesEquals &amp;&amp; !overridesHashCode) {
2284                 log.warning(LintCategory.OVERRIDES, pos,
2285                             Warnings.OverrideEqualsButNotHashcode(someClass));
2286             }
2287         }
2288     }
2289 
2290     public void checkModuleName (JCModuleDecl tree) {
2291         Name moduleName = tree.sym.name;
2292         Assert.checkNonNull(moduleName);
2293         if (lint.isEnabled(LintCategory.MODULE)) {
2294             JCExpression qualId = tree.qualId;
2295             while (qualId != null) {
2296                 Name componentName;
2297                 DiagnosticPosition pos;
2298                 switch (qualId.getTag()) {
2299                     case SELECT:
2300                         JCFieldAccess selectNode = ((JCFieldAccess) qualId);
2301                         componentName = selectNode.name;
2302                         pos = selectNode.pos();
2303                         qualId = selectNode.selected;
2304                         break;
2305                     case IDENT:
2306                         componentName = ((JCIdent) qualId).name;
2307                         pos = qualId.pos();
2308                         qualId = null;
2309                         break;
2310                     default:
2311                         throw new AssertionError(&quot;Unexpected qualified identifier: &quot; + qualId.toString());
2312                 }
2313                 if (componentName != null) {
2314                     String moduleNameComponentString = componentName.toString();
2315                     int nameLength = moduleNameComponentString.length();
2316                     if (nameLength &gt; 0 &amp;&amp; Character.isDigit(moduleNameComponentString.charAt(nameLength - 1))) {
2317                         log.warning(Lint.LintCategory.MODULE, pos, Warnings.PoorChoiceForModuleName(componentName));
2318                     }
2319                 }
2320             }
2321         }
2322     }
2323 
2324     private boolean checkNameClash(ClassSymbol origin, Symbol s1, Symbol s2) {
2325         ClashFilter cf = new ClashFilter(origin.type);
2326         return (cf.accepts(s1) &amp;&amp;
2327                 cf.accepts(s2) &amp;&amp;
2328                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2329     }
2330 
2331 
2332     /** Check that all abstract members of given class have definitions.
2333      *  @param pos          Position to be used for error reporting.
2334      *  @param c            The class.
2335      */
2336     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2337         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2338         if (undef != null) {
2339             MethodSymbol undef1 =
2340                 new MethodSymbol(undef.flags(), undef.name,
2341                                  types.memberType(c.type, undef), undef.owner);
2342             log.error(pos,
2343                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2344         }
2345     }
2346 
2347     // A value class cannot contain a field of its own type either or indirectly.
2348     void checkNonCyclicMembership(JCClassDecl tree) {
2349         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
2350         try {
2351             tree.sym.flags_field |= LOCKED;
2352             for (List&lt;? extends JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2353                 if (l.head.hasTag(VARDEF)) {
2354                     JCVariableDecl field = (JCVariableDecl) l.head;
2355                     if (cyclePossible(field.sym)) {
2356                         Type fieldType = field.sym.type;
2357                         checkNonCyclicMembership((ClassSymbol) fieldType.tsym, field.pos());
2358                     }
2359                 }
2360             }
2361         } finally {
2362             tree.sym.flags_field &amp;= ~LOCKED;
2363         }
2364 
2365     }
2366     // where
2367     private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {
2368         if ((c.flags_field &amp; LOCKED) != 0) {
2369             log.error(pos, Errors.CyclicValueTypeMembership(c));
2370             return;
2371         }
2372         try {
2373             c.flags_field |= LOCKED;
2374             for (Symbol fld : c.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; cyclePossible((VarSymbol) s), NON_RECURSIVE)) {
2375                 checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);
2376             }
2377         } finally {
2378             c.flags_field &amp;= ~LOCKED;
2379         }
2380     }
2381         // where
2382         private boolean cyclePossible(VarSymbol symbol) {
2383             return (symbol.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(symbol.type);
2384         }
2385 
2386     void checkNonCyclicDecl(JCClassDecl tree) {
2387         CycleChecker cc = new CycleChecker();
2388         cc.scan(tree);
2389         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2390             tree.sym.flags_field |= ACYCLIC;
2391         }
2392     }
2393 
2394     class CycleChecker extends TreeScanner {
2395 
2396         List&lt;Symbol&gt; seenClasses = List.nil();
2397         boolean errorFound = false;
2398         boolean partialCheck = false;
2399 
2400         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2401             if (sym != null &amp;&amp; sym.kind == TYP) {
2402                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2403                 if (classEnv != null) {
2404                     DiagnosticSource prevSource = log.currentSource();
2405                     try {
2406                         log.useSource(classEnv.toplevel.sourcefile);
2407                         scan(classEnv.tree);
2408                     }
2409                     finally {
2410                         log.useSource(prevSource.getFile());
2411                     }
2412                 } else if (sym.kind == TYP) {
2413                     checkClass(pos, sym, List.nil());
2414                 }
2415             } else {
2416                 //not completed yet
2417                 partialCheck = true;
2418             }
2419         }
2420 
2421         @Override
2422         public void visitSelect(JCFieldAccess tree) {
2423             super.visitSelect(tree);
2424             checkSymbol(tree.pos(), tree.sym);
2425         }
2426 
2427         @Override
2428         public void visitIdent(JCIdent tree) {
2429             checkSymbol(tree.pos(), tree.sym);
2430         }
2431 
2432         @Override
2433         public void visitTypeApply(JCTypeApply tree) {
2434             scan(tree.clazz);
2435         }
2436 
2437         @Override
2438         public void visitTypeArray(JCArrayTypeTree tree) {
2439             scan(tree.elemtype);
2440         }
2441 
2442         @Override
2443         public void visitClassDef(JCClassDecl tree) {
2444             List&lt;JCTree&gt; supertypes = List.nil();
2445             if (tree.getExtendsClause() != null) {
2446                 supertypes = supertypes.prepend(tree.getExtendsClause());
2447             }
2448             if (tree.getImplementsClause() != null) {
2449                 for (JCTree intf : tree.getImplementsClause()) {
2450                     supertypes = supertypes.prepend(intf);
2451                 }
2452             }
2453             checkClass(tree.pos(), tree.sym, supertypes);
2454         }
2455 
2456         void checkClass(DiagnosticPosition pos, Symbol c, List&lt;JCTree&gt; supertypes) {
2457             if ((c.flags_field &amp; ACYCLIC) != 0)
2458                 return;
2459             if (seenClasses.contains(c)) {
2460                 errorFound = true;
2461                 noteCyclic(pos, (ClassSymbol)c);
2462             } else if (!c.type.isErroneous()) {
2463                 try {
2464                     seenClasses = seenClasses.prepend(c);
2465                     if (c.type.hasTag(CLASS)) {
2466                         if (supertypes.nonEmpty()) {
2467                             scan(supertypes);
2468                         }
2469                         else {
2470                             ClassType ct = (ClassType)c.type;
2471                             if (ct.supertype_field == null ||
2472                                     ct.interfaces_field == null) {
2473                                 //not completed yet
2474                                 partialCheck = true;
2475                                 return;
2476                             }
2477                             checkSymbol(pos, ct.supertype_field.tsym);
2478                             for (Type intf : ct.interfaces_field) {
2479                                 checkSymbol(pos, intf.tsym);
2480                             }
2481                         }
2482                         if (c.owner.kind == TYP) {
2483                             checkSymbol(pos, c.owner);
2484                         }
2485                     }
2486                 } finally {
2487                     seenClasses = seenClasses.tail;
2488                 }
2489             }
2490         }
2491     }
2492 
2493     /** Check for cyclic references. Issue an error if the
2494      *  symbol of the type referred to has a LOCKED flag set.
2495      *
2496      *  @param pos      Position to be used for error reporting.
2497      *  @param t        The type referred to.
2498      */
2499     void checkNonCyclic(DiagnosticPosition pos, Type t) {
2500         checkNonCyclicInternal(pos, t);
2501     }
2502 
2503 
2504     void checkNonCyclic(DiagnosticPosition pos, TypeVar t) {
2505         checkNonCyclic1(pos, t, List.nil());
2506     }
2507 
2508     private void checkNonCyclic1(DiagnosticPosition pos, Type t, List&lt;TypeVar&gt; seen) {
2509         final TypeVar tv;
2510         if  (t.hasTag(TYPEVAR) &amp;&amp; (t.tsym.flags() &amp; UNATTRIBUTED) != 0)
2511             return;
2512         if (seen.contains(t)) {
2513             tv = (TypeVar)t;
2514             tv.setUpperBound(types.createErrorType(t));
2515             log.error(pos, Errors.CyclicInheritance(t));
2516         } else if (t.hasTag(TYPEVAR)) {
2517             tv = (TypeVar)t;
2518             seen = seen.prepend(tv);
2519             for (Type b : types.getBounds(tv))
2520                 checkNonCyclic1(pos, b, seen);
2521         }
2522     }
2523 
2524     /** Check for cyclic references. Issue an error if the
2525      *  symbol of the type referred to has a LOCKED flag set.
2526      *
2527      *  @param pos      Position to be used for error reporting.
2528      *  @param t        The type referred to.
2529      *  @returns        True if the check completed on all attributed classes
2530      */
2531     private boolean checkNonCyclicInternal(DiagnosticPosition pos, Type t) {
2532         boolean complete = true; // was the check complete?
2533         //- System.err.println(&quot;checkNonCyclicInternal(&quot;+t+&quot;);&quot;);//DEBUG
2534         Symbol c = t.tsym;
2535         if ((c.flags_field &amp; ACYCLIC) != 0) return true;
2536 
2537         if ((c.flags_field &amp; LOCKED) != 0) {
2538             noteCyclic(pos, (ClassSymbol)c);
2539         } else if (!c.type.isErroneous()) {
2540             try {
2541                 c.flags_field |= LOCKED;
2542                 if (c.type.hasTag(CLASS)) {
2543                     ClassType clazz = (ClassType)c.type;
2544                     if (clazz.interfaces_field != null)
2545                         for (List&lt;Type&gt; l=clazz.interfaces_field; l.nonEmpty(); l=l.tail)
2546                             complete &amp;= checkNonCyclicInternal(pos, l.head);
2547                     if (clazz.supertype_field != null) {
2548                         Type st = clazz.supertype_field;
2549                         if (st != null &amp;&amp; st.hasTag(CLASS))
2550                             complete &amp;= checkNonCyclicInternal(pos, st);
2551                     }
2552                     if (c.owner.kind == TYP)
2553                         complete &amp;= checkNonCyclicInternal(pos, c.owner.type);
2554                 }
2555             } finally {
2556                 c.flags_field &amp;= ~LOCKED;
2557             }
2558         }
2559         if (complete)
2560             complete = ((c.flags_field &amp; UNATTRIBUTED) == 0) &amp;&amp; c.isCompleted();
2561         if (complete) c.flags_field |= ACYCLIC;
2562         return complete;
2563     }
2564 
2565     /** Note that we found an inheritance cycle. */
2566     private void noteCyclic(DiagnosticPosition pos, ClassSymbol c) {
2567         log.error(pos, Errors.CyclicInheritance(c));
2568         for (List&lt;Type&gt; l=types.interfaces(c.type); l.nonEmpty(); l=l.tail)
2569             l.head = types.createErrorType((ClassSymbol)l.head.tsym, Type.noType);
2570         Type st = types.supertype(c.type);
2571         if (st.hasTag(CLASS))
2572             ((ClassType)c.type).supertype_field = types.createErrorType((ClassSymbol)st.tsym, Type.noType);
2573         c.type = types.createErrorType(c, c.type);
2574         c.flags_field |= ACYCLIC;
2575     }
2576 
2577     /** Check that all methods which implement some
2578      *  method conform to the method they implement.
2579      *  @param tree         The class definition whose members are checked.
2580      */
2581     void checkImplementations(JCClassDecl tree) {
2582         checkImplementations(tree, tree.sym, tree.sym);
2583     }
2584     //where
2585         /** Check that all methods which implement some
2586          *  method in `ic&#39; conform to the method they implement.
2587          */
2588         void checkImplementations(JCTree tree, ClassSymbol origin, ClassSymbol ic) {
2589             for (List&lt;Type&gt; l = types.closure(ic.type); l.nonEmpty(); l = l.tail) {
2590                 ClassSymbol lc = (ClassSymbol)l.head.tsym;
2591                 if ((lc.flags() &amp; ABSTRACT) != 0) {
2592                     for (Symbol sym : lc.members().getSymbols(NON_RECURSIVE)) {
2593                         if (sym.kind == MTH &amp;&amp;
2594                             (sym.flags() &amp; (STATIC|ABSTRACT)) == ABSTRACT) {
2595                             MethodSymbol absmeth = (MethodSymbol)sym;
2596                             MethodSymbol implmeth = absmeth.implementation(origin, types, false);
2597                             if (implmeth != null &amp;&amp; implmeth != absmeth &amp;&amp;
2598                                 (implmeth.owner.flags() &amp; INTERFACE) ==
2599                                 (origin.flags() &amp; INTERFACE)) {
2600                                 // don&#39;t check if implmeth is in a class, yet
2601                                 // origin is an interface. This case arises only
2602                                 // if implmeth is declared in Object. The reason is
2603                                 // that interfaces really don&#39;t inherit from
2604                                 // Object it&#39;s just that the compiler represents
2605                                 // things that way.
2606                                 checkOverride(tree, implmeth, absmeth, origin);
2607                             }
2608                         }
2609                     }
2610                 }
2611             }
2612         }
2613 
2614     /** Check that all abstract methods implemented by a class are
2615      *  mutually compatible.
2616      *  @param pos          Position to be used for error reporting.
2617      *  @param c            The class whose interfaces are checked.
2618      */
2619     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2620         List&lt;Type&gt; supertypes = types.interfaces(c);
2621         Type supertype = types.supertype(c);
2622         if (supertype.hasTag(CLASS) &amp;&amp;
2623             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2624             supertypes = supertypes.prepend(supertype);
2625         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2626             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2627                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2628                 return;
2629             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2630                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2631                     return;
2632         }
2633         checkCompatibleConcretes(pos, c);
2634         boolean isIdentityObject = types.asSuper(c, syms.identityObjectType.tsym) != null;
2635         boolean isInlineObject = types.asSuper(c, syms.inlineObjectType.tsym) != null;
2636         if (types.isValue(c) &amp;&amp; isIdentityObject) {
2637             log.error(pos, Errors.InlineTypeMustNotImplementIdentityObject(c));
2638         } else if (!c.isInterface() &amp;&amp; !types.isValue(c) &amp;&amp; isInlineObject) {
2639             log.error(pos, Errors.IdentityTypeMustNotImplementInlineObject(c));
2640         } else if (isIdentityObject &amp;&amp; isInlineObject) {
2641             log.error(pos, Errors.MutuallyIncompatibleInterfaces(c));
2642         }
2643     }
2644 
2645     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2646      *  are mutually compatible (JLS 8.4.8/9.4.1).
2647      *
2648      *  @param pos  Position to be used for error reporting.
2649      *  @param site The class whose methods are checked.
2650      *  @param sym  The method symbol to be checked.
2651      */
2652     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2653          ClashFilter cf = new ClashFilter(site);
2654         //for each method m1 that is overridden (directly or indirectly)
2655         //by method &#39;sym&#39; in &#39;site&#39;...
2656 
2657         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2658         boolean overridesAny = false;
2659         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2660         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2661         for (Symbol m1 : symbolsByName) {
2662             if (!sym.overrides(m1, site.tsym, types, false)) {
2663                 if (m1 == sym) {
2664                     continue;
2665                 }
2666 
2667                 if (!overridesAny) {
2668                     potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);
2669                 }
2670                 continue;
2671             }
2672 
2673             if (m1 != sym) {
2674                 overridesAny = true;
2675                 potentiallyAmbiguousList = List.nil();
2676             }
2677 
2678             //...check each method m2 that is a member of &#39;site&#39;
2679             for (Symbol m2 : symbolsByName) {
2680                 if (m2 == m1) continue;
2681                 //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2682                 //a member of &#39;site&#39;) and (ii) m1 has the same erasure as m2, issue an error
2683                 if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &amp;&amp;
2684                         types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
2685                     sym.flags_field |= CLASH;
2686                     if (m1 == sym) {
2687                         log.error(pos, Errors.NameClashSameErasureNoOverride(
2688                             m1.name, types.memberType(site, m1).asMethodType().getParameterTypes(), m1.location(),
2689                             m2.name, types.memberType(site, m2).asMethodType().getParameterTypes(), m2.location()));
2690                     } else {
2691                         ClassType ct = (ClassType)site;
2692                         String kind = ct.isInterface() ? &quot;interface&quot; : &quot;class&quot;;
2693                         log.error(pos, Errors.NameClashSameErasureNoOverride1(
2694                             kind,
2695                             ct.tsym.name,
2696                             m1.name,
2697                             types.memberType(site, m1).asMethodType().getParameterTypes(),
2698                             m1.location(),
2699                             m2.name,
2700                             types.memberType(site, m2).asMethodType().getParameterTypes(),
2701                             m2.location()));
2702                     }
2703                     return;
2704                 }
2705             }
2706         }
2707 
2708         if (!overridesAny) {
2709             for (MethodSymbol m: potentiallyAmbiguousList) {
2710                 checkPotentiallyAmbiguousOverloads(pos, site, sym, m);
2711             }
2712         }
2713     }
2714 
2715     /** Check that all static methods accessible from &#39;site&#39; are
2716      *  mutually compatible (JLS 8.4.8).
2717      *
2718      *  @param pos  Position to be used for error reporting.
2719      *  @param site The class whose methods are checked.
2720      *  @param sym  The method symbol to be checked.
2721      */
2722     void checkHideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2723         ClashFilter cf = new ClashFilter(site);
2724         //for each method m1 that is a member of &#39;site&#39;...
2725         for (Symbol s : types.membersClosure(site, true).getSymbolsByName(sym.name, cf)) {
2726             //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2727             //a member of &#39;site&#39;) and (ii) &#39;sym&#39; has the same erasure as m1, issue an error
2728             if (!types.isSubSignature(sym.type, types.memberType(site, s), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source))) {
2729                 if (types.hasSameArgs(s.erasure(types), sym.erasure(types))) {
2730                     log.error(pos,
2731                               Errors.NameClashSameErasureNoHide(sym, sym.location(), s, s.location()));
2732                     return;
2733                 } else {
2734                     checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);
2735                 }
2736             }
2737          }
2738      }
2739 
2740      //where
2741      private class ClashFilter implements Filter&lt;Symbol&gt; {
2742 
2743          Type site;
2744 
2745          ClashFilter(Type site) {
2746              this.site = site;
2747          }
2748 
2749          boolean shouldSkip(Symbol s) {
2750              return (s.flags() &amp; CLASH) != 0 &amp;&amp;
2751                 s.owner == site.tsym;
2752          }
2753 
2754          public boolean accepts(Symbol s) {
2755              return s.kind == MTH &amp;&amp;
2756                      (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
2757                      !shouldSkip(s) &amp;&amp;
2758                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2759                      !s.isConstructor();
2760          }
2761      }
2762 
2763     void checkDefaultMethodClashes(DiagnosticPosition pos, Type site) {
2764         DefaultMethodClashFilter dcf = new DefaultMethodClashFilter(site);
2765         for (Symbol m : types.membersClosure(site, false).getSymbols(dcf)) {
2766             Assert.check(m.kind == MTH);
2767             List&lt;MethodSymbol&gt; prov = types.interfaceCandidates(site, (MethodSymbol)m);
2768             if (prov.size() &gt; 1) {
2769                 ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
2770                 ListBuffer&lt;Symbol&gt; defaults = new ListBuffer&lt;&gt;();
2771                 for (MethodSymbol provSym : prov) {
2772                     if ((provSym.flags() &amp; DEFAULT) != 0) {
2773                         defaults = defaults.append(provSym);
2774                     } else if ((provSym.flags() &amp; ABSTRACT) != 0) {
2775                         abstracts = abstracts.append(provSym);
2776                     }
2777                     if (defaults.nonEmpty() &amp;&amp; defaults.size() + abstracts.size() &gt;= 2) {
2778                         //strong semantics - issue an error if two sibling interfaces
2779                         //have two override-equivalent defaults - or if one is abstract
2780                         //and the other is default
2781                         Fragment diagKey;
2782                         Symbol s1 = defaults.first();
2783                         Symbol s2;
2784                         if (defaults.size() &gt; 1) {
2785                             s2 = defaults.toList().tail.head;
2786                             diagKey = Fragments.IncompatibleUnrelatedDefaults(Kinds.kindName(site.tsym), site,
2787                                     m.name, types.memberType(site, m).getParameterTypes(),
2788                                     s1.location(), s2.location());
2789 
2790                         } else {
2791                             s2 = abstracts.first();
2792                             diagKey = Fragments.IncompatibleAbstractDefault(Kinds.kindName(site.tsym), site,
2793                                     m.name, types.memberType(site, m).getParameterTypes(),
2794                                     s1.location(), s2.location());
2795                         }
2796                         log.error(pos, Errors.TypesIncompatible(s1.location().type, s2.location().type, diagKey));
2797                         break;
2798                     }
2799                 }
2800             }
2801         }
2802     }
2803 
2804     //where
2805      private class DefaultMethodClashFilter implements Filter&lt;Symbol&gt; {
2806 
2807          Type site;
2808 
2809          DefaultMethodClashFilter(Type site) {
2810              this.site = site;
2811          }
2812 
2813          public boolean accepts(Symbol s) {
2814              return s.kind == MTH &amp;&amp;
2815                      (s.flags() &amp; DEFAULT) != 0 &amp;&amp;
2816                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2817                      !s.isConstructor();
2818          }
2819      }
2820 
2821     /**
2822       * Report warnings for potentially ambiguous method declarations. Two declarations
2823       * are potentially ambiguous if they feature two unrelated functional interface
2824       * in same argument position (in which case, a call site passing an implicit
2825       * lambda would be ambiguous).
2826       */
2827     void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,
2828             MethodSymbol msym1, MethodSymbol msym2) {
2829         if (msym1 != msym2 &amp;&amp;
2830                 Feature.DEFAULT_METHODS.allowedInSource(source) &amp;&amp;
2831                 lint.isEnabled(LintCategory.OVERLOADS) &amp;&amp;
2832                 (msym1.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0 &amp;&amp;
2833                 (msym2.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0) {
2834             Type mt1 = types.memberType(site, msym1);
2835             Type mt2 = types.memberType(site, msym2);
2836             //if both generic methods, adjust type variables
2837             if (mt1.hasTag(FORALL) &amp;&amp; mt2.hasTag(FORALL) &amp;&amp;
2838                     types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {
2839                 mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);
2840             }
2841             //expand varargs methods if needed
2842             int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());
2843             List&lt;Type&gt; args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);
2844             List&lt;Type&gt; args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);
2845             //if arities don&#39;t match, exit
2846             if (args1.length() != args2.length()) return;
2847             boolean potentiallyAmbiguous = false;
2848             while (args1.nonEmpty() &amp;&amp; args2.nonEmpty()) {
2849                 Type s = args1.head;
2850                 Type t = args2.head;
2851                 if (!types.isSubtype(t, s) &amp;&amp; !types.isSubtype(s, t)) {
2852                     if (types.isFunctionalInterface(s) &amp;&amp; types.isFunctionalInterface(t) &amp;&amp;
2853                             types.findDescriptorType(s).getParameterTypes().length() &gt; 0 &amp;&amp;
2854                             types.findDescriptorType(s).getParameterTypes().length() ==
2855                             types.findDescriptorType(t).getParameterTypes().length()) {
2856                         potentiallyAmbiguous = true;
2857                     } else {
2858                         break;
2859                     }
2860                 }
2861                 args1 = args1.tail;
2862                 args2 = args2.tail;
2863             }
2864             if (potentiallyAmbiguous) {
2865                 //we found two incompatible functional interfaces with same arity
2866                 //this means a call site passing an implicit lambda would be ambiguous
2867                 msym1.flags_field |= POTENTIALLY_AMBIGUOUS;
2868                 msym2.flags_field |= POTENTIALLY_AMBIGUOUS;
2869                 log.warning(LintCategory.OVERLOADS, pos,
2870                             Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),
2871                                                                   msym2, msym2.location()));
2872                 return;
2873             }
2874         }
2875     }
2876 
2877     void checkAccessFromSerializableElement(final JCTree tree, boolean isLambda) {
2878         if (warnOnAnyAccessToMembers ||
2879             (lint.isEnabled(LintCategory.SERIAL) &amp;&amp;
2880             !lint.isSuppressed(LintCategory.SERIAL) &amp;&amp;
2881             isLambda)) {
2882             Symbol sym = TreeInfo.symbol(tree);
2883             if (!sym.kind.matches(KindSelector.VAL_MTH)) {
2884                 return;
2885             }
2886 
2887             if (sym.kind == VAR) {
2888                 if ((sym.flags() &amp; PARAMETER) != 0 ||
2889                     sym.isLocal() ||
2890                     sym.name == names._this ||
2891                     sym.name == names._super) {
2892                     return;
2893                 }
2894             }
2895 
2896             if (!types.isSubtype(sym.owner.type, syms.serializableType) &amp;&amp;
2897                 isEffectivelyNonPublic(sym)) {
2898                 if (isLambda) {
2899                     if (belongsToRestrictedPackage(sym)) {
2900                         log.warning(LintCategory.SERIAL, tree.pos(),
2901                                     Warnings.AccessToMemberFromSerializableLambda(sym));
2902                     }
2903                 } else {
2904                     log.warning(tree.pos(),
2905                                 Warnings.AccessToMemberFromSerializableElement(sym));
2906                 }
2907             }
2908         }
2909     }
2910 
2911     private boolean isEffectivelyNonPublic(Symbol sym) {
2912         if (sym.packge() == syms.rootPackage) {
2913             return false;
2914         }
2915 
2916         while (sym.kind != PCK) {
2917             if ((sym.flags() &amp; PUBLIC) == 0) {
2918                 return true;
2919             }
2920             sym = sym.owner;
2921         }
2922         return false;
2923     }
2924 
2925     private boolean belongsToRestrictedPackage(Symbol sym) {
2926         String fullName = sym.packge().fullname.toString();
2927         return fullName.startsWith(&quot;java.&quot;) ||
2928                 fullName.startsWith(&quot;javax.&quot;) ||
2929                 fullName.startsWith(&quot;sun.&quot;) ||
2930                 fullName.contains(&quot;.internal.&quot;);
2931     }
2932 
2933     /** Check that class c does not implement directly or indirectly
2934      *  the same parameterized interface with two different argument lists.
2935      *  @param pos          Position to be used for error reporting.
2936      *  @param type         The type whose interfaces are checked.
2937      */
2938     void checkClassBounds(DiagnosticPosition pos, Type type) {
2939         checkClassBounds(pos, new HashMap&lt;TypeSymbol,Type&gt;(), type);
2940     }
2941 //where
2942         /** Enter all interfaces of type `type&#39; into the hash table `seensofar&#39;
2943          *  with their class symbol as key and their type as value. Make
2944          *  sure no class is entered with two different types.
2945          */
2946         void checkClassBounds(DiagnosticPosition pos,
2947                               Map&lt;TypeSymbol,Type&gt; seensofar,
2948                               Type type) {
2949             if (type.isErroneous()) return;
2950             for (List&lt;Type&gt; l = types.interfaces(type); l.nonEmpty(); l = l.tail) {
2951                 Type it = l.head;
2952                 if (type.hasTag(CLASS) &amp;&amp; !it.hasTag(CLASS)) continue; // JLS 8.1.5
2953 
2954                 Type oldit = seensofar.put(it.tsym, it);
2955                 if (oldit != null) {
2956                     List&lt;Type&gt; oldparams = oldit.allparams();
2957                     List&lt;Type&gt; newparams = it.allparams();
2958                     if (!types.containsTypeEquivalent(oldparams, newparams))
2959                         log.error(pos,
2960                                   Errors.CantInheritDiffArg(it.tsym,
2961                                                             Type.toString(oldparams),
2962                                                             Type.toString(newparams)));
2963                 }
2964                 checkClassBounds(pos, seensofar, it);
2965             }
2966             Type st = types.supertype(type);
2967             if (type.hasTag(CLASS) &amp;&amp; !st.hasTag(CLASS)) return; // JLS 8.1.4
2968             if (st != Type.noType) checkClassBounds(pos, seensofar, st);
2969         }
2970 
2971     /** Enter interface into into set.
2972      *  If it existed already, issue a &quot;repeated interface&quot; error.
2973      */
2974     void checkNotRepeated(DiagnosticPosition pos, Type it, Set&lt;Type&gt; its) {
2975         if (its.contains(it))
2976             log.error(pos, Errors.RepeatedInterface);
2977         else {
2978             its.add(it);
2979         }
2980     }
2981 
2982 /* *************************************************************************
2983  * Check annotations
2984  **************************************************************************/
2985 
2986     /**
2987      * Recursively validate annotations values
2988      */
2989     void validateAnnotationTree(JCTree tree) {
2990         class AnnotationValidator extends TreeScanner {
2991             @Override
2992             public void visitAnnotation(JCAnnotation tree) {
2993                 if (!tree.type.isErroneous() &amp;&amp; tree.type.tsym.isAnnotationType()) {
2994                     super.visitAnnotation(tree);
2995                     validateAnnotation(tree);
2996                 }
2997             }
2998         }
2999         tree.accept(new AnnotationValidator());
3000     }
3001 
3002     /**
3003      *  {@literal
3004      *  Annotation types are restricted to primitives, String, an
3005      *  enum, an annotation, Class, Class&lt;?&gt;, Class&lt;? extends
3006      *  Anything&gt;, arrays of the preceding.
3007      *  }
3008      */
3009     void validateAnnotationType(JCTree restype) {
3010         // restype may be null if an error occurred, so don&#39;t bother validating it
3011         if (restype != null) {
3012             validateAnnotationType(restype.pos(), restype.type);
3013         }
3014     }
3015 
3016     void validateAnnotationType(DiagnosticPosition pos, Type type) {
3017         if (type.isPrimitive()) return;
3018         if (types.isSameType(type, syms.stringType)) return;
3019         if ((type.tsym.flags() &amp; Flags.ENUM) != 0) return;
3020         if ((type.tsym.flags() &amp; Flags.ANNOTATION) != 0) return;
3021         if (types.cvarLowerBound(type).tsym == syms.classType.tsym) return;
3022         if (types.isArray(type) &amp;&amp; !types.isArray(types.elemtype(type))) {
3023             validateAnnotationType(pos, types.elemtype(type));
3024             return;
3025         }
3026         log.error(pos, Errors.InvalidAnnotationMemberType);
3027     }
3028 
3029     /**
3030      * &quot;It is also a compile-time error if any method declared in an
3031      * annotation type has a signature that is override-equivalent to
3032      * that of any public or protected method declared in class Object
3033      * or in the interface annotation.Annotation.&quot;
3034      *
3035      * @jls 9.6 Annotation Types
3036      */
3037     void validateAnnotationMethod(DiagnosticPosition pos, MethodSymbol m) {
3038         for (Type sup = syms.annotationType; sup.hasTag(CLASS); sup = types.supertype(sup)) {
3039             Scope s = sup.tsym.members();
3040             for (Symbol sym : s.getSymbolsByName(m.name)) {
3041                 if (sym.kind == MTH &amp;&amp;
3042                     (sym.flags() &amp; (PUBLIC | PROTECTED)) != 0 &amp;&amp;
3043                     types.overrideEquivalent(m.type, sym.type))
3044                     log.error(pos, Errors.IntfAnnotationMemberClash(sym, sup));
3045             }
3046         }
3047     }
3048 
3049     /** Check the annotations of a symbol.
3050      */
3051     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, JCTree declarationTree, Symbol s) {
3052         for (JCAnnotation a : annotations)
3053             validateAnnotation(a, declarationTree, s);
3054     }
3055 
3056     /** Check the type annotations.
3057      */
3058     public void validateTypeAnnotations(List&lt;JCAnnotation&gt; annotations, boolean isTypeParameter) {
3059         for (JCAnnotation a : annotations)
3060             validateTypeAnnotation(a, isTypeParameter);
3061     }
3062 
3063     /** Check an annotation of a symbol.
3064      */
3065     private void validateAnnotation(JCAnnotation a, JCTree declarationTree, Symbol s) {
3066         validateAnnotationTree(a);
3067         boolean isRecordMember = (s.flags_field &amp; RECORD) != 0 || s.enclClass() != null &amp;&amp; s.enclClass().isRecord();
3068 
3069         boolean isRecordField = isRecordMember &amp;&amp;
3070                 (s.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
3071                 declarationTree.hasTag(VARDEF) &amp;&amp;
3072                 s.owner.kind == TYP;
3073 
3074         if (isRecordField) {
3075             // first we need to check if the annotation is applicable to records
3076             Name[] targets = getTargetNames(a);
3077             boolean appliesToRecords = false;
3078             for (Name target : targets) {
3079                 appliesToRecords =
3080                                 target == names.FIELD ||
3081                                 target == names.PARAMETER ||
3082                                 target == names.METHOD ||
3083                                 target == names.TYPE_USE ||
3084                                 target == names.RECORD_COMPONENT;
3085                 if (appliesToRecords) {
3086                     break;
3087                 }
3088             }
3089             if (!appliesToRecords) {
3090                 log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3091             } else {
3092                 /* lets now find the annotations in the field that are targeted to record components and append them to
3093                  * the corresponding record component
3094                  */
3095                 ClassSymbol recordClass = (ClassSymbol) s.owner;
3096                 RecordComponent rc = recordClass.getRecordComponent((VarSymbol)s);
3097                 SymbolMetadata metadata = rc.getMetadata();
3098                 if (metadata == null || metadata.isEmpty()) {
3099                     /* if not is empty then we have already been here, which is the case if multiple annotations are applied
3100                      * to the record component declaration
3101                      */
3102                     rc.appendAttributes(s.getRawAttributes().stream().filter(anno -&gt;
3103                             Arrays.stream(getTargetNames(anno.type.tsym)).anyMatch(name -&gt; name == names.RECORD_COMPONENT)
3104                     ).collect(List.collector()));
3105                     rc.setTypeAttributes(s.getRawTypeAttributes());
3106                     // to get all the type annotations applied to the type
3107                     rc.type = s.type;
3108                 }
3109             }
3110         }
3111 
3112         /* the section below is tricky. Annotations applied to record components are propagated to the corresponding
3113          * record member so if an annotation has target: FIELD, it is propagated to the corresponding FIELD, if it has
3114          * target METHOD, it is propagated to the accessor and so on. But at the moment when method members are generated
3115          * there is no enough information to propagate only the right annotations. So all the annotations are propagated
3116          * to all the possible locations.
3117          *
3118          * At this point we need to remove all the annotations that are not in place before going on with the annotation
3119          * party. On top of the above there is the issue that there is no AST representing record components, just symbols
3120          * so the corresponding field has been holding all the annotations and it&#39;s metadata has been modified as if it
3121          * was both a field and a record component.
3122          *
3123          * So there are two places where we need to trim annotations from: the metadata of the symbol and / or the modifiers
3124          * in the AST. Whatever is in the metadata will be written to the class file, whatever is in the modifiers could
3125          * be see by annotation processors.
3126          *
3127          * The metadata contains both type annotations and declaration annotations. At this point of the game we don&#39;t
3128          * need to care about type annotations, they are all in the right place. But we could need to remove declaration
3129          * annotations. So for declaration annotations if they are not applicable to the record member, excluding type
3130          * annotations which are already correct, then we will remove it. For the AST modifiers if the annotation is not
3131          * applicable either as type annotation and or declaration annotation, only in that case it will be removed.
3132          *
3133          * So it could be that annotation is removed as a declaration annotation but it is kept in the AST modifier for
3134          * further inspection by annotation processors.
3135          *
3136          * For example:
3137          *
3138          *     import java.lang.annotation.*;
3139          *
3140          *     @Target({ElementType.TYPE_USE, ElementType.RECORD_COMPONENT})
3141          *     @Retention(RetentionPolicy.RUNTIME)
3142          *     @interface Anno { }
3143          *
3144          *     record R(@Anno String s) {}
3145          *
3146          * at this point we will have for the case of the generated field:
3147          *   - @Anno in the modifier
3148          *   - @Anno as a type annotation
3149          *   - @Anno as a declaration annotation
3150          *
3151          * the last one should be removed because the annotation has not FIELD as target but it was applied as a
3152          * declaration annotation because the field was being treated both as a field and as a record component
3153          * as we have already copied the annotations to the record component, now the field doesn&#39;t need to hold
3154          * annotations that are not intended for it anymore. Still @Anno has to be kept in the AST&#39;s modifiers as it
3155          * is applicable as a type annotation to the type of the field.
3156          */
3157 
3158         if (a.type.tsym.isAnnotationType()) {
3159             Optional&lt;Set&lt;Name&gt;&gt; applicableTargetsOp = getApplicableTargets(a, s);
3160             if (!applicableTargetsOp.isEmpty()) {
3161                 Set&lt;Name&gt; applicableTargets = applicableTargetsOp.get();
3162                 boolean notApplicableOrIsTypeUseOnly = applicableTargets.isEmpty() ||
3163                         applicableTargets.size() == 1 &amp;&amp; applicableTargets.contains(names.TYPE_USE);
3164                 boolean isRecordMemberWithNonApplicableDeclAnno =
3165                         isRecordMember &amp;&amp; (s.flags_field &amp; Flags.GENERATED_MEMBER) != 0 &amp;&amp; notApplicableOrIsTypeUseOnly;
3166 
3167                 if (applicableTargets.isEmpty() || isRecordMemberWithNonApplicableDeclAnno) {
3168                     if (isRecordMemberWithNonApplicableDeclAnno) {
3169                             /* so we have found an annotation that is not applicable to a record member that was generated by the
3170                              * compiler. This was intentionally done at TypeEnter, now is the moment strip away the annotations
3171                              * that are not applicable to the given record member
3172                              */
3173                         JCModifiers modifiers = TreeInfo.getModifiers(declarationTree);
3174                             /* lets first remove the annotation from the modifier if it is not applicable, we have to check again as
3175                              * it could be a type annotation
3176                              */
3177                         if (modifiers != null &amp;&amp; applicableTargets.isEmpty()) {
3178                             ListBuffer&lt;JCAnnotation&gt; newAnnotations = new ListBuffer&lt;&gt;();
3179                             for (JCAnnotation anno : modifiers.annotations) {
3180                                 if (anno != a) {
3181                                     newAnnotations.add(anno);
3182                                 }
3183                             }
3184                             modifiers.annotations = newAnnotations.toList();
3185                         }
3186                         // now lets remove it from the symbol
3187                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3188                     } else {
3189                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3190                     }
3191                 }
3192             }
3193         }
3194 
3195         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3196             if (s.kind != TYP) {
3197                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3198             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3199                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3200             }
3201         }
3202         if (a.annotationType.type.tsym == syms.valueBasedType.tsym) {
3203             if (s.isInterface() || s.isEnum()) {
3204                 log.error(a.pos(), Errors.BadValueBasedAnno);
3205             } else if (allowValueBasedClasses) {
3206                 s.flags_field |= VALUEBASED;
3207             }
3208         }
3209     }
3210 
3211     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3212         Assert.checkNonNull(a.type);
3213         validateAnnotationTree(a);
3214 
3215         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3216                 !a.annotationType.type.isErroneous() &amp;&amp;
3217                 !isTypeAnnotation(a, isTypeParameter)) {
3218             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3219         }
3220     }
3221 
3222     /**
3223      * Validate the proposed container &#39;repeatable&#39; on the
3224      * annotation type symbol &#39;s&#39;. Report errors at position
3225      * &#39;pos&#39;.
3226      *
3227      * @param s The (annotation)type declaration annotated with a @Repeatable
3228      * @param repeatable the @Repeatable on &#39;s&#39;
3229      * @param pos where to report errors
3230      */
3231     public void validateRepeatable(TypeSymbol s, Attribute.Compound repeatable, DiagnosticPosition pos) {
3232         Assert.check(types.isSameType(repeatable.type, syms.repeatableType));
3233 
3234         Type t = null;
3235         List&lt;Pair&lt;MethodSymbol,Attribute&gt;&gt; l = repeatable.values;
3236         if (!l.isEmpty()) {
3237             Assert.check(l.head.fst.name == names.value);
3238             t = ((Attribute.Class)l.head.snd).getValue();
3239         }
3240 
3241         if (t == null) {
3242             // errors should already have been reported during Annotate
3243             return;
3244         }
3245 
3246         validateValue(t.tsym, s, pos);
3247         validateRetention(t.tsym, s, pos);
3248         validateDocumented(t.tsym, s, pos);
3249         validateInherited(t.tsym, s, pos);
3250         validateTarget(t.tsym, s, pos);
3251         validateDefault(t.tsym, pos);
3252     }
3253 
3254     private void validateValue(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3255         Symbol sym = container.members().findFirst(names.value);
3256         if (sym != null &amp;&amp; sym.kind == MTH) {
3257             MethodSymbol m = (MethodSymbol) sym;
3258             Type ret = m.getReturnType();
3259             if (!(ret.hasTag(ARRAY) &amp;&amp; types.isSameType(((ArrayType)ret).elemtype, contained.type))) {
3260                 log.error(pos,
3261                           Errors.InvalidRepeatableAnnotationValueReturn(container,
3262                                                                         ret,
3263                                                                         types.makeArrayType(contained.type)));
3264             }
3265         } else {
3266             log.error(pos, Errors.InvalidRepeatableAnnotationNoValue(container));
3267         }
3268     }
3269 
3270     private void validateRetention(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3271         Attribute.RetentionPolicy containerRetention = types.getRetention(container);
3272         Attribute.RetentionPolicy containedRetention = types.getRetention(contained);
3273 
3274         boolean error = false;
3275         switch (containedRetention) {
3276         case RUNTIME:
3277             if (containerRetention != Attribute.RetentionPolicy.RUNTIME) {
3278                 error = true;
3279             }
3280             break;
3281         case CLASS:
3282             if (containerRetention == Attribute.RetentionPolicy.SOURCE)  {
3283                 error = true;
3284             }
3285         }
3286         if (error ) {
3287             log.error(pos,
3288                       Errors.InvalidRepeatableAnnotationRetention(container,
3289                                                                   containerRetention.name(),
3290                                                                   contained,
3291                                                                   containedRetention.name()));
3292         }
3293     }
3294 
3295     private void validateDocumented(Symbol container, Symbol contained, DiagnosticPosition pos) {
3296         if (contained.attribute(syms.documentedType.tsym) != null) {
3297             if (container.attribute(syms.documentedType.tsym) == null) {
3298                 log.error(pos, Errors.InvalidRepeatableAnnotationNotDocumented(container, contained));
3299             }
3300         }
3301     }
3302 
3303     private void validateInherited(Symbol container, Symbol contained, DiagnosticPosition pos) {
3304         if (contained.attribute(syms.inheritedType.tsym) != null) {
3305             if (container.attribute(syms.inheritedType.tsym) == null) {
3306                 log.error(pos, Errors.InvalidRepeatableAnnotationNotInherited(container, contained));
3307             }
3308         }
3309     }
3310 
3311     private void validateTarget(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3312         // The set of targets the container is applicable to must be a subset
3313         // (with respect to annotation target semantics) of the set of targets
3314         // the contained is applicable to. The target sets may be implicit or
3315         // explicit.
3316 
3317         Set&lt;Name&gt; containerTargets;
3318         Attribute.Array containerTarget = getAttributeTargetAttribute(container);
3319         if (containerTarget == null) {
3320             containerTargets = getDefaultTargetSet();
3321         } else {
3322             containerTargets = new HashSet&lt;&gt;();
3323             for (Attribute app : containerTarget.values) {
3324                 if (!(app instanceof Attribute.Enum)) {
3325                     continue; // recovery
3326                 }
3327                 Attribute.Enum e = (Attribute.Enum)app;
3328                 containerTargets.add(e.value.name);
3329             }
3330         }
3331 
3332         Set&lt;Name&gt; containedTargets;
3333         Attribute.Array containedTarget = getAttributeTargetAttribute(contained);
3334         if (containedTarget == null) {
3335             containedTargets = getDefaultTargetSet();
3336         } else {
3337             containedTargets = new HashSet&lt;&gt;();
3338             for (Attribute app : containedTarget.values) {
3339                 if (!(app instanceof Attribute.Enum)) {
3340                     continue; // recovery
3341                 }
3342                 Attribute.Enum e = (Attribute.Enum)app;
3343                 containedTargets.add(e.value.name);
3344             }
3345         }
3346 
3347         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3348             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3349         }
3350     }
3351 
3352     /* get a set of names for the default target */
3353     private Set&lt;Name&gt; getDefaultTargetSet() {
3354         if (defaultTargets == null) {
3355             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3356             targets.add(names.ANNOTATION_TYPE);
3357             targets.add(names.CONSTRUCTOR);
3358             targets.add(names.FIELD);
3359             if (allowRecords) {
3360                 targets.add(names.RECORD_COMPONENT);
3361             }
3362             targets.add(names.LOCAL_VARIABLE);
3363             targets.add(names.METHOD);
3364             targets.add(names.PACKAGE);
3365             targets.add(names.PARAMETER);
3366             targets.add(names.TYPE);
3367 
3368             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3369         }
3370 
3371         return defaultTargets;
3372     }
3373     private Set&lt;Name&gt; defaultTargets;
3374 
3375 
3376     /** Checks that s is a subset of t, with respect to ElementType
3377      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3378      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3379      * TYPE_PARAMETER}.
3380      */
3381     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
3382         // Check that all elements in s are present in t
3383         for (Name n2 : s) {
3384             boolean currentElementOk = false;
3385             for (Name n1 : t) {
3386                 if (n1 == n2) {
3387                     currentElementOk = true;
3388                     break;
3389                 } else if (n1 == names.TYPE &amp;&amp; n2 == names.ANNOTATION_TYPE) {
3390                     currentElementOk = true;
3391                     break;
3392                 } else if (n1 == names.TYPE_USE &amp;&amp;
3393                         (n2 == names.TYPE ||
3394                          n2 == names.ANNOTATION_TYPE ||
3395                          n2 == names.TYPE_PARAMETER)) {
3396                     currentElementOk = true;
3397                     break;
3398                 }
3399             }
3400             if (!currentElementOk)
3401                 return false;
3402         }
3403         return true;
3404     }
3405 
3406     private void validateDefault(Symbol container, DiagnosticPosition pos) {
3407         // validate that all other elements of containing type has defaults
3408         Scope scope = container.members();
3409         for(Symbol elm : scope.getSymbols()) {
3410             if (elm.name != names.value &amp;&amp;
3411                 elm.kind == MTH &amp;&amp;
3412                 ((MethodSymbol)elm).defaultValue == null) {
3413                 log.error(pos,
3414                           Errors.InvalidRepeatableAnnotationElemNondefault(container, elm));
3415             }
3416         }
3417     }
3418 
3419     /** Is s a method symbol that overrides a method in a superclass? */
3420     boolean isOverrider(Symbol s) {
3421         if (s.kind != MTH || s.isStatic())
3422             return false;
3423         MethodSymbol m = (MethodSymbol)s;
3424         TypeSymbol owner = (TypeSymbol)m.owner;
3425         for (Type sup : types.closure(owner.type)) {
3426             if (sup == owner.type)
3427                 continue; // skip &quot;this&quot;
3428             Scope scope = sup.tsym.members();
3429             for (Symbol sym : scope.getSymbolsByName(m.name)) {
3430                 if (!sym.isStatic() &amp;&amp; m.overrides(sym, owner, types, true))
3431                     return true;
3432             }
3433         }
3434         return false;
3435     }
3436 
3437     /** Is the annotation applicable to types? */
3438     protected boolean isTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3439         List&lt;Attribute&gt; targets = typeAnnotations.annotationTargets(a.annotationType.type.tsym);
3440         return (targets == null) ?
3441                 false :
3442                 targets.stream()
3443                         .anyMatch(attr -&gt; isTypeAnnotation(attr, isTypeParameter));
3444     }
3445     //where
3446         boolean isTypeAnnotation(Attribute a, boolean isTypeParameter) {
3447             Attribute.Enum e = (Attribute.Enum)a;
3448             return (e.value.name == names.TYPE_USE ||
3449                     (isTypeParameter &amp;&amp; e.value.name == names.TYPE_PARAMETER));
3450         }
3451 
3452     /** Is the annotation applicable to the symbol? */
3453     Name[] getTargetNames(JCAnnotation a) {
3454         return getTargetNames(a.annotationType.type.tsym);
3455     }
3456 
3457     public Name[] getTargetNames(TypeSymbol annoSym) {
3458         Attribute.Array arr = getAttributeTargetAttribute(annoSym);
3459         Name[] targets;
3460         if (arr == null) {
3461             targets = defaultTargetMetaInfo();
3462         } else {
3463             // TODO: can we optimize this?
3464             targets = new Name[arr.values.length];
3465             for (int i=0; i&lt;arr.values.length; ++i) {
3466                 Attribute app = arr.values[i];
3467                 if (!(app instanceof Attribute.Enum)) {
3468                     return new Name[0];
3469                 }
3470                 Attribute.Enum e = (Attribute.Enum) app;
3471                 targets[i] = e.value.name;
3472             }
3473         }
3474         return targets;
3475     }
3476 
3477     boolean annotationApplicable(JCAnnotation a, Symbol s) {
3478         Optional&lt;Set&lt;Name&gt;&gt; targets = getApplicableTargets(a, s);
3479         /* the optional could be emtpy if the annotation is unknown in that case
3480          * we return that it is applicable and if it is erroneous that should imply
3481          * an error at the declaration site
3482          */
3483         return targets.isEmpty() || targets.isPresent() &amp;&amp; !targets.get().isEmpty();
3484     }
3485 
3486     @SuppressWarnings(&quot;preview&quot;)
3487     Optional&lt;Set&lt;Name&gt;&gt; getApplicableTargets(JCAnnotation a, Symbol s) {
3488         Attribute.Array arr = getAttributeTargetAttribute(a.annotationType.type.tsym);
3489         Name[] targets;
3490         Set&lt;Name&gt; applicableTargets = new HashSet&lt;&gt;();
3491 
3492         if (arr == null) {
3493             targets = defaultTargetMetaInfo();
3494         } else {
3495             // TODO: can we optimize this?
3496             targets = new Name[arr.values.length];
3497             for (int i=0; i&lt;arr.values.length; ++i) {
3498                 Attribute app = arr.values[i];
3499                 if (!(app instanceof Attribute.Enum)) {
3500                     // recovery
3501                     return Optional.empty();
3502                 }
3503                 Attribute.Enum e = (Attribute.Enum) app;
3504                 targets[i] = e.value.name;
3505             }
3506         }
3507         for (Name target : targets) {
3508             if (target == names.TYPE) {
3509                 if (s.kind == TYP)
3510                     applicableTargets.add(names.TYPE);
3511             } else if (target == names.FIELD) {
3512                 if (s.kind == VAR &amp;&amp; s.owner.kind != MTH)
3513                     applicableTargets.add(names.FIELD);
3514             } else if (target == names.RECORD_COMPONENT) {
3515                 if (s.getKind() == ElementKind.RECORD_COMPONENT) {
3516                     applicableTargets.add(names.RECORD_COMPONENT);
3517                 }
3518             } else if (target == names.METHOD) {
3519                 if (s.kind == MTH &amp;&amp; !s.isConstructor())
3520                     applicableTargets.add(names.METHOD);
3521             } else if (target == names.PARAMETER) {
3522                 if (s.kind == VAR &amp;&amp;
3523                     (s.owner.kind == MTH &amp;&amp; (s.flags() &amp; PARAMETER) != 0)) {
3524                     applicableTargets.add(names.PARAMETER);
3525                 }
3526             } else if (target == names.CONSTRUCTOR) {
3527                 if (s.kind == MTH &amp;&amp; s.isConstructor())
3528                     applicableTargets.add(names.CONSTRUCTOR);
3529             } else if (target == names.LOCAL_VARIABLE) {
3530                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;
3531                       (s.flags() &amp; PARAMETER) == 0) {
3532                     applicableTargets.add(names.LOCAL_VARIABLE);
3533                 }
3534             } else if (target == names.ANNOTATION_TYPE) {
3535                 if (s.kind == TYP &amp;&amp; (s.flags() &amp; ANNOTATION) != 0) {
3536                     applicableTargets.add(names.ANNOTATION_TYPE);
3537                 }
3538             } else if (target == names.PACKAGE) {
3539                 if (s.kind == PCK)
3540                     applicableTargets.add(names.PACKAGE);
3541             } else if (target == names.TYPE_USE) {
3542                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp; s.type.hasTag(NONE)) {
3543                     //cannot type annotate implicitly typed locals
3544                     continue;
3545                 } else if (s.kind == TYP || s.kind == VAR ||
3546                         (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
3547                                 !s.type.getReturnType().hasTag(VOID)) ||
3548                         (s.kind == MTH &amp;&amp; s.isConstructor())) {
3549                     applicableTargets.add(names.TYPE_USE);
3550                 }
3551             } else if (target == names.TYPE_PARAMETER) {
3552                 if (s.kind == TYP &amp;&amp; s.type.hasTag(TYPEVAR))
3553                     applicableTargets.add(names.TYPE_PARAMETER);
3554             } else
3555                 return Optional.empty(); // Unknown ElementType. This should be an error at declaration site,
3556                                          // assume applicable.
3557         }
3558         return Optional.of(applicableTargets);
3559     }
3560 
3561     Attribute.Array getAttributeTargetAttribute(TypeSymbol s) {
3562         Attribute.Compound atTarget = s.getAnnotationTypeMetadata().getTarget();
3563         if (atTarget == null) return null; // ok, is applicable
3564         Attribute atValue = atTarget.member(names.value);
3565         if (!(atValue instanceof Attribute.Array)) return null; // error recovery
3566         return (Attribute.Array) atValue;
3567     }
3568 
3569     public final Name[] dfltTargetMeta;
3570     private Name[] defaultTargetMetaInfo() {
3571         return dfltTargetMeta;
3572     }
3573 
3574     /** Check an annotation value.
3575      *
3576      * @param a The annotation tree to check
3577      * @return true if this annotation tree is valid, otherwise false
3578      */
3579     public boolean validateAnnotationDeferErrors(JCAnnotation a) {
3580         boolean res = false;
3581         final Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
3582         try {
3583             res = validateAnnotation(a);
3584         } finally {
3585             log.popDiagnosticHandler(diagHandler);
3586         }
3587         return res;
3588     }
3589 
3590     private boolean validateAnnotation(JCAnnotation a) {
3591         boolean isValid = true;
3592         AnnotationTypeMetadata metadata = a.annotationType.type.tsym.getAnnotationTypeMetadata();
3593 
3594         // collect an inventory of the annotation elements
3595         Set&lt;MethodSymbol&gt; elements = metadata.getAnnotationElements();
3596 
3597         // remove the ones that are assigned values
3598         for (JCTree arg : a.args) {
3599             if (!arg.hasTag(ASSIGN)) continue; // recovery
3600             JCAssign assign = (JCAssign)arg;
3601             Symbol m = TreeInfo.symbol(assign.lhs);
3602             if (m == null || m.type.isErroneous()) continue;
3603             if (!elements.remove(m)) {
3604                 isValid = false;
3605                 log.error(assign.lhs.pos(),
3606                           Errors.DuplicateAnnotationMemberValue(m.name, a.type));
3607             }
3608         }
3609 
3610         // all the remaining ones better have default values
3611         List&lt;Name&gt; missingDefaults = List.nil();
3612         Set&lt;MethodSymbol&gt; membersWithDefault = metadata.getAnnotationElementsWithDefault();
3613         for (MethodSymbol m : elements) {
3614             if (m.type.isErroneous())
3615                 continue;
3616 
3617             if (!membersWithDefault.contains(m))
3618                 missingDefaults = missingDefaults.append(m.name);
3619         }
3620         missingDefaults = missingDefaults.reverse();
3621         if (missingDefaults.nonEmpty()) {
3622             isValid = false;
3623             Error errorKey = (missingDefaults.size() &gt; 1)
3624                     ? Errors.AnnotationMissingDefaultValue1(a.type, missingDefaults)
3625                     : Errors.AnnotationMissingDefaultValue(a.type, missingDefaults);
3626             log.error(a.pos(), errorKey);
3627         }
3628 
3629         return isValid &amp;&amp; validateTargetAnnotationValue(a);
3630     }
3631 
3632     /* Validate the special java.lang.annotation.Target annotation */
3633     boolean validateTargetAnnotationValue(JCAnnotation a) {
3634         // special case: java.lang.annotation.Target must not have
3635         // repeated values in its value member
3636         if (a.annotationType.type.tsym != syms.annotationTargetType.tsym ||
3637                 a.args.tail == null)
3638             return true;
3639 
3640         boolean isValid = true;
3641         if (!a.args.head.hasTag(ASSIGN)) return false; // error recovery
3642         JCAssign assign = (JCAssign) a.args.head;
3643         Symbol m = TreeInfo.symbol(assign.lhs);
3644         if (m.name != names.value) return false;
3645         JCTree rhs = assign.rhs;
3646         if (!rhs.hasTag(NEWARRAY)) return false;
3647         JCNewArray na = (JCNewArray) rhs;
3648         Set&lt;Symbol&gt; targets = new HashSet&lt;&gt;();
3649         for (JCTree elem : na.elems) {
3650             if (!targets.add(TreeInfo.symbol(elem))) {
3651                 isValid = false;
3652                 log.error(elem.pos(), Errors.RepeatedAnnotationTarget);
3653             }
3654         }
3655         return isValid;
3656     }
3657 
3658     void checkDeprecatedAnnotation(DiagnosticPosition pos, Symbol s) {
3659         if (lint.isEnabled(LintCategory.DEP_ANN) &amp;&amp; s.isDeprecatableViaAnnotation() &amp;&amp;
3660             (s.flags() &amp; DEPRECATED) != 0 &amp;&amp;
3661             !syms.deprecatedType.isErroneous() &amp;&amp;
3662             s.attribute(syms.deprecatedType.tsym) == null) {
3663             log.warning(LintCategory.DEP_ANN,
3664                     pos, Warnings.MissingDeprecatedAnnotation);
3665         }
3666         // Note: @Deprecated has no effect on local variables, parameters and package decls.
3667         if (lint.isEnabled(LintCategory.DEPRECATION) &amp;&amp; !s.isDeprecatableViaAnnotation()) {
3668             if (!syms.deprecatedType.isErroneous() &amp;&amp; s.attribute(syms.deprecatedType.tsym) != null) {
3669                 log.warning(LintCategory.DEPRECATION, pos,
3670                             Warnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));
3671             }
3672         }
3673     }
3674 
3675     void checkDeprecated(final DiagnosticPosition pos, final Symbol other, final Symbol s) {
3676         checkDeprecated(() -&gt; pos, other, s);
3677     }
3678 
3679     void checkDeprecated(Supplier&lt;DiagnosticPosition&gt; pos, final Symbol other, final Symbol s) {
3680         if ( (s.isDeprecatedForRemoval()
3681                 || s.isDeprecated() &amp;&amp; !other.isDeprecated())
3682                 &amp;&amp; (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {
3683             deferredLintHandler.report(() -&gt; warnDeprecated(pos.get(), s));
3684         }
3685     }
3686 
3687     void checkSunAPI(final DiagnosticPosition pos, final Symbol s) {
3688         if ((s.flags() &amp; PROPRIETARY) != 0) {
3689             deferredLintHandler.report(() -&gt; {
3690                 log.mandatoryWarning(pos, Warnings.SunProprietary(s));
3691             });
3692         }
3693     }
3694 
3695     void checkProfile(final DiagnosticPosition pos, final Symbol s) {
3696         if (profile != Profile.DEFAULT &amp;&amp; (s.flags() &amp; NOT_IN_PROFILE) != 0) {
3697             log.error(pos, Errors.NotInProfile(s, profile));
3698         }
3699     }
3700 
3701     void checkPreview(DiagnosticPosition pos, Symbol s) {
3702         if ((s.flags() &amp; PREVIEW_API) != 0) {
3703             if ((s.flags() &amp; PREVIEW_ESSENTIAL_API) != 0 &amp;&amp; !preview.isEnabled()) {
3704                 log.error(pos, Errors.IsPreview(s));
3705             } else {
3706                 deferredLintHandler.report(() -&gt; warnPreview(pos, s));
3707             }
3708         }
3709     }
3710 
3711 /* *************************************************************************
3712  * Check for recursive annotation elements.
3713  **************************************************************************/
3714 
3715     /** Check for cycles in the graph of annotation elements.
3716      */
3717     void checkNonCyclicElements(JCClassDecl tree) {
3718         if ((tree.sym.flags_field &amp; ANNOTATION) == 0) return;
3719         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
3720         try {
3721             tree.sym.flags_field |= LOCKED;
3722             for (JCTree def : tree.defs) {
3723                 if (!def.hasTag(METHODDEF)) continue;
3724                 JCMethodDecl meth = (JCMethodDecl)def;
3725                 checkAnnotationResType(meth.pos(), meth.restype.type);
3726             }
3727         } finally {
3728             tree.sym.flags_field &amp;= ~LOCKED;
3729             tree.sym.flags_field |= ACYCLIC_ANN;
3730         }
3731     }
3732 
3733     void checkNonCyclicElementsInternal(DiagnosticPosition pos, TypeSymbol tsym) {
3734         if ((tsym.flags_field &amp; ACYCLIC_ANN) != 0)
3735             return;
3736         if ((tsym.flags_field &amp; LOCKED) != 0) {
3737             log.error(pos, Errors.CyclicAnnotationElement(tsym));
3738             return;
3739         }
3740         try {
3741             tsym.flags_field |= LOCKED;
3742             for (Symbol s : tsym.members().getSymbols(NON_RECURSIVE)) {
3743                 if (s.kind != MTH)
3744                     continue;
3745                 checkAnnotationResType(pos, ((MethodSymbol)s).type.getReturnType());
3746             }
3747         } finally {
3748             tsym.flags_field &amp;= ~LOCKED;
3749             tsym.flags_field |= ACYCLIC_ANN;
3750         }
3751     }
3752 
3753     void checkAnnotationResType(DiagnosticPosition pos, Type type) {
3754         switch (type.getTag()) {
3755         case CLASS:
3756             if ((type.tsym.flags() &amp; ANNOTATION) != 0)
3757                 checkNonCyclicElementsInternal(pos, type.tsym);
3758             break;
3759         case ARRAY:
3760             checkAnnotationResType(pos, types.elemtype(type));
3761             break;
3762         default:
3763             break; // int etc
3764         }
3765     }
3766 
3767 /* *************************************************************************
3768  * Check for cycles in the constructor call graph.
3769  **************************************************************************/
3770 
3771     /** Check for cycles in the graph of constructors calling other
3772      *  constructors.
3773      */
3774     void checkCyclicConstructors(JCClassDecl tree) {
3775         Map&lt;Symbol,Symbol&gt; callMap = new HashMap&lt;&gt;();
3776 
3777         // enter each constructor this-call into the map
3778         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
3779             JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);
3780             if (app == null) continue;
3781             JCMethodDecl meth = (JCMethodDecl) l.head;
3782             if (TreeInfo.name(app.meth) == names._this) {
3783                 callMap.put(meth.sym, TreeInfo.symbol(app.meth));
3784             } else {
3785                 meth.sym.flags_field |= ACYCLIC;
3786             }
3787         }
3788 
3789         // Check for cycles in the map
3790         Symbol[] ctors = new Symbol[0];
3791         ctors = callMap.keySet().toArray(ctors);
3792         for (Symbol caller : ctors) {
3793             checkCyclicConstructor(tree, caller, callMap);
3794         }
3795     }
3796 
3797     /** Look in the map to see if the given constructor is part of a
3798      *  call cycle.
3799      */
3800     private void checkCyclicConstructor(JCClassDecl tree, Symbol ctor,
3801                                         Map&lt;Symbol,Symbol&gt; callMap) {
3802         if (ctor != null &amp;&amp; (ctor.flags_field &amp; ACYCLIC) == 0) {
3803             if ((ctor.flags_field &amp; LOCKED) != 0) {
3804                 log.error(TreeInfo.diagnosticPositionFor(ctor, tree),
3805                           Errors.RecursiveCtorInvocation);
3806             } else {
3807                 ctor.flags_field |= LOCKED;
3808                 checkCyclicConstructor(tree, callMap.remove(ctor), callMap);
3809                 ctor.flags_field &amp;= ~LOCKED;
3810             }
3811             ctor.flags_field |= ACYCLIC;
3812         }
3813     }
3814 
3815 /* *************************************************************************
3816  * Miscellaneous
3817  **************************************************************************/
3818 
3819     /**
3820      *  Check for division by integer constant zero
3821      *  @param pos           Position for error reporting.
3822      *  @param operator      The operator for the expression
3823      *  @param operand       The right hand operand for the expression
3824      */
3825     void checkDivZero(final DiagnosticPosition pos, Symbol operator, Type operand) {
3826         if (operand.constValue() != null
3827             &amp;&amp; operand.getTag().isSubRangeOf(LONG)
3828             &amp;&amp; ((Number) (operand.constValue())).longValue() == 0) {
3829             int opc = ((OperatorSymbol)operator).opcode;
3830             if (opc == ByteCodes.idiv || opc == ByteCodes.imod
3831                 || opc == ByteCodes.ldiv || opc == ByteCodes.lmod) {
3832                 deferredLintHandler.report(() -&gt; warnDivZero(pos));
3833             }
3834         }
3835     }
3836 
3837     /**
3838      * Check for empty statements after if
3839      */
3840     void checkEmptyIf(JCIf tree) {
3841         if (tree.thenpart.hasTag(SKIP) &amp;&amp; tree.elsepart == null &amp;&amp;
3842                 lint.isEnabled(LintCategory.EMPTY))
3843             log.warning(LintCategory.EMPTY, tree.thenpart.pos(), Warnings.EmptyIf);
3844     }
3845 
3846     /** Check that symbol is unique in given scope.
3847      *  @param pos           Position for error reporting.
3848      *  @param sym           The symbol.
3849      *  @param s             The scope.
3850      */
3851     boolean checkUnique(DiagnosticPosition pos, Symbol sym, Scope s) {
3852         if (sym.type.isErroneous())
3853             return true;
3854         if (sym.owner.name == names.any) return false;
3855         for (Symbol byName : s.getSymbolsByName(sym.name, NON_RECURSIVE)) {
3856             if (sym != byName &amp;&amp;
3857                     (byName.flags() &amp; CLASH) == 0 &amp;&amp;
3858                     sym.kind == byName.kind &amp;&amp;
3859                     sym.name != names.error &amp;&amp;
3860                     (sym.kind != MTH ||
3861                      types.hasSameArgs(sym.type, byName.type) ||
3862                      types.hasSameArgs(types.erasure(sym.type), types.erasure(byName.type)))) {
3863                 if ((sym.flags() &amp; VARARGS) != (byName.flags() &amp; VARARGS)) {
3864                     sym.flags_field |= CLASH;
3865                     varargsDuplicateError(pos, sym, byName);
3866                     return true;
3867                 } else if (sym.kind == MTH &amp;&amp; !types.hasSameArgs(sym.type, byName.type, false)) {
3868                     duplicateErasureError(pos, sym, byName);
3869                     sym.flags_field |= CLASH;
3870                     return true;
3871                 } else if ((sym.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3872                            (byName.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3873                            (byName.flags() &amp; MATCH_BINDING_TO_OUTER) == 0) {
3874                     if (!sym.type.isErroneous()) {
3875                         log.error(pos, Errors.MatchBindingExists);
3876                         sym.flags_field |= CLASH;
3877                     }
3878                     return false;
3879                 } else {
3880                     duplicateError(pos, byName);
3881                     return false;
3882                 }
3883             }
3884         }
3885         return true;
3886     }
3887 
3888     /** Report duplicate declaration error.
3889      */
3890     void duplicateErasureError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
3891         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
3892             log.error(pos, Errors.NameClashSameErasure(sym1, sym2));
3893         }
3894     }
3895 
3896     /**Check that types imported through the ordinary imports don&#39;t clash with types imported
3897      * by other (static or ordinary) imports. Note that two static imports may import two clashing
3898      * types without an error on the imports.
3899      * @param toplevel       The toplevel tree for which the test should be performed.
3900      */
3901     void checkImportsUnique(JCCompilationUnit toplevel) {
3902         WriteableScope ordinallyImportedSoFar = WriteableScope.create(toplevel.packge);
3903         WriteableScope staticallyImportedSoFar = WriteableScope.create(toplevel.packge);
3904         WriteableScope topLevelScope = toplevel.toplevelScope;
3905 
3906         for (JCTree def : toplevel.defs) {
3907             if (!def.hasTag(IMPORT))
3908                 continue;
3909 
3910             JCImport imp = (JCImport) def;
3911 
3912             if (imp.importScope == null)
3913                 continue;
3914 
3915             for (Symbol sym : imp.importScope.getSymbols(sym -&gt; sym.kind == TYP)) {
3916                 if (imp.isStatic()) {
3917                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, true);
3918                     staticallyImportedSoFar.enter(sym);
3919                 } else {
3920                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, false);
3921                     ordinallyImportedSoFar.enter(sym);
3922                 }
3923             }
3924 
3925             imp.importScope = null;
3926         }
3927     }
3928 
3929     /** Check that single-type import is not already imported or top-level defined,
3930      *  but make an exception for two single-type imports which denote the same type.
3931      *  @param pos                     Position for error reporting.
3932      *  @param ordinallyImportedSoFar  A Scope containing types imported so far through
3933      *                                 ordinary imports.
3934      *  @param staticallyImportedSoFar A Scope containing types imported so far through
3935      *                                 static imports.
3936      *  @param topLevelScope           The current file&#39;s top-level Scope
3937      *  @param sym                     The symbol.
3938      *  @param staticImport            Whether or not this was a static import
3939      */
3940     private boolean checkUniqueImport(DiagnosticPosition pos, Scope ordinallyImportedSoFar,
3941                                       Scope staticallyImportedSoFar, Scope topLevelScope,
3942                                       Symbol sym, boolean staticImport) {
3943         Filter&lt;Symbol&gt; duplicates = candidate -&gt; candidate != sym &amp;&amp; !candidate.type.isErroneous();
3944         Symbol ordinaryClashing = ordinallyImportedSoFar.findFirst(sym.name, duplicates);
3945         Symbol staticClashing = null;
3946         if (ordinaryClashing == null &amp;&amp; !staticImport) {
3947             staticClashing = staticallyImportedSoFar.findFirst(sym.name, duplicates);
3948         }
3949         if (ordinaryClashing != null || staticClashing != null) {
3950             if (ordinaryClashing != null)
3951                 log.error(pos, Errors.AlreadyDefinedSingleImport(ordinaryClashing));
3952             else
3953                 log.error(pos, Errors.AlreadyDefinedStaticSingleImport(staticClashing));
3954             return false;
3955         }
3956         Symbol clashing = topLevelScope.findFirst(sym.name, duplicates);
3957         if (clashing != null) {
3958             log.error(pos, Errors.AlreadyDefinedThisUnit(clashing));
3959             return false;
3960         }
3961         return true;
3962     }
3963 
3964     /** Check that a qualified name is in canonical form (for import decls).
3965      */
3966     public void checkCanonical(JCTree tree) {
3967         if (!isCanonical(tree))
3968             log.error(tree.pos(),
3969                       Errors.ImportRequiresCanonical(TreeInfo.symbol(tree)));
3970     }
3971         // where
3972         private boolean isCanonical(JCTree tree) {
3973             while (tree.hasTag(SELECT)) {
3974                 JCFieldAccess s = (JCFieldAccess) tree;
3975                 if (s.sym.owner.getQualifiedName() != TreeInfo.symbol(s.selected).getQualifiedName())
3976                     return false;
3977                 tree = s.selected;
3978             }
3979             return true;
3980         }
3981 
3982     /** Check that an auxiliary class is not accessed from any other file than its own.
3983      */
3984     void checkForBadAuxiliaryClassAccess(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, ClassSymbol c) {
3985         if (lint.isEnabled(Lint.LintCategory.AUXILIARYCLASS) &amp;&amp;
3986             (c.flags() &amp; AUXILIARY) != 0 &amp;&amp;
3987             rs.isAccessible(env, c) &amp;&amp;
3988             !fileManager.isSameFile(c.sourcefile, env.toplevel.sourcefile))
3989         {
3990             log.warning(pos,
3991                         Warnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));
3992         }
3993     }
3994 
3995     private class ConversionWarner extends Warner {
3996         final String uncheckedKey;
3997         final Type found;
3998         final Type expected;
3999         public ConversionWarner(DiagnosticPosition pos, String uncheckedKey, Type found, Type expected) {
4000             super(pos);
4001             this.uncheckedKey = uncheckedKey;
4002             this.found = found;
4003             this.expected = expected;
4004         }
4005 
4006         @Override
4007         public void warn(LintCategory lint) {
4008             boolean warned = this.warned;
4009             super.warn(lint);
4010             if (warned) return; // suppress redundant diagnostics
4011             switch (lint) {
4012                 case UNCHECKED:
4013                     Check.this.warnUnchecked(pos(), Warnings.ProbFoundReq(diags.fragment(uncheckedKey), found, expected));
4014                     break;
4015                 case VARARGS:
4016                     if (method != null &amp;&amp;
4017                             method.attribute(syms.trustMeType.tsym) != null &amp;&amp;
4018                             isTrustMeAllowedOnMethod(method) &amp;&amp;
4019                             !types.isReifiable(method.type.getParameterTypes().last())) {
4020                         Check.this.warnUnsafeVararg(pos(), Warnings.VarargsUnsafeUseVarargsParam(method.params.last()));
4021                     }
4022                     break;
4023                 default:
4024                     throw new AssertionError(&quot;Unexpected lint: &quot; + lint);
4025             }
4026         }
4027     }
4028 
4029     public Warner castWarner(DiagnosticPosition pos, Type found, Type expected) {
4030         return new ConversionWarner(pos, &quot;unchecked.cast.to.type&quot;, found, expected);
4031     }
4032 
4033     public Warner convertWarner(DiagnosticPosition pos, Type found, Type expected) {
4034         return new ConversionWarner(pos, &quot;unchecked.assign&quot;, found, expected);
4035     }
4036 
4037     public void checkFunctionalInterface(JCClassDecl tree, ClassSymbol cs) {
4038         Compound functionalType = cs.attribute(syms.functionalInterfaceType.tsym);
4039 
4040         if (functionalType != null) {
4041             try {
4042                 types.findDescriptorSymbol((TypeSymbol)cs);
4043             } catch (Types.FunctionDescriptorLookupError ex) {
4044                 DiagnosticPosition pos = tree.pos();
4045                 for (JCAnnotation a : tree.getModifiers().annotations) {
4046                     if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
4047                         pos = a.pos();
4048                         break;
4049                     }
4050                 }
4051                 log.error(pos, Errors.BadFunctionalIntfAnno1(ex.getDiagnostic()));
4052             }
4053         }
4054     }
4055 
4056     public void checkImportsResolvable(final JCCompilationUnit toplevel) {
4057         for (final JCImport imp : toplevel.getImports()) {
4058             if (!imp.staticImport || !imp.qualid.hasTag(SELECT))
4059                 continue;
4060             final JCFieldAccess select = (JCFieldAccess) imp.qualid;
4061             final Symbol origin;
4062             if (select.name == names.asterisk || (origin = TreeInfo.symbol(select.selected)) == null || origin.kind != TYP)
4063                 continue;
4064 
4065             TypeSymbol site = (TypeSymbol) TreeInfo.symbol(select.selected);
4066             if (!checkTypeContainsImportableElement(site, site, toplevel.packge, select.name, new HashSet&lt;Symbol&gt;())) {
4067                 log.error(imp.pos(),
4068                           Errors.CantResolveLocation(KindName.STATIC,
4069                                                      select.name,
4070                                                      null,
4071                                                      null,
4072                                                      Fragments.Location(kindName(site),
4073                                                                         site,
4074                                                                         null)));
4075             }
4076         }
4077     }
4078 
4079     // Check that packages imported are in scope (JLS 7.4.3, 6.3, 6.5.3.1, 6.5.3.2)
4080     public void checkImportedPackagesObservable(final JCCompilationUnit toplevel) {
4081         OUTER: for (JCImport imp : toplevel.getImports()) {
4082             if (!imp.staticImport &amp;&amp; TreeInfo.name(imp.qualid) == names.asterisk) {
4083                 TypeSymbol tsym = ((JCFieldAccess)imp.qualid).selected.type.tsym;
4084                 if (tsym.kind == PCK &amp;&amp; tsym.members().isEmpty() &amp;&amp;
4085                     !(Feature.IMPORT_ON_DEMAND_OBSERVABLE_PACKAGES.allowedInSource(source) &amp;&amp; tsym.exists())) {
4086                     log.error(DiagnosticFlag.RESOLVE_ERROR, imp.pos, Errors.DoesntExist(tsym));
4087                 }
4088             }
4089         }
4090     }
4091 
4092     private boolean checkTypeContainsImportableElement(TypeSymbol tsym, TypeSymbol origin, PackageSymbol packge, Name name, Set&lt;Symbol&gt; processed) {
4093         if (tsym == null || !processed.add(tsym))
4094             return false;
4095 
4096             // also search through inherited names
4097         if (checkTypeContainsImportableElement(types.supertype(tsym.type).tsym, origin, packge, name, processed))
4098             return true;
4099 
4100         for (Type t : types.interfaces(tsym.type))
4101             if (checkTypeContainsImportableElement(t.tsym, origin, packge, name, processed))
4102                 return true;
4103 
4104         for (Symbol sym : tsym.members().getSymbolsByName(name)) {
4105             if (sym.isStatic() &amp;&amp;
4106                 importAccessible(sym, packge) &amp;&amp;
4107                 sym.isMemberOf(origin, types)) {
4108                 return true;
4109             }
4110         }
4111 
4112         return false;
4113     }
4114 
4115     // is the sym accessible everywhere in packge?
4116     public boolean importAccessible(Symbol sym, PackageSymbol packge) {
4117         try {
4118             int flags = (int)(sym.flags() &amp; AccessFlags);
4119             switch (flags) {
4120             default:
4121             case PUBLIC:
4122                 return true;
4123             case PRIVATE:
4124                 return false;
4125             case 0:
4126             case PROTECTED:
4127                 return sym.packge() == packge;
4128             }
4129         } catch (ClassFinder.BadClassFile err) {
4130             throw err;
4131         } catch (CompletionFailure ex) {
4132             return false;
4133         }
4134     }
4135 
4136     public void checkLeaksNotAccessible(Env&lt;AttrContext&gt; env, JCClassDecl check) {
4137         JCCompilationUnit toplevel = env.toplevel;
4138 
4139         if (   toplevel.modle == syms.unnamedModule
4140             || toplevel.modle == syms.noModule
4141             || (check.sym.flags() &amp; COMPOUND) != 0) {
4142             return ;
4143         }
4144 
4145         ExportsDirective currentExport = findExport(toplevel.packge);
4146 
4147         if (   currentExport == null //not exported
4148             || currentExport.modules != null) //don&#39;t check classes in qualified export
4149             return ;
4150 
4151         new TreeScanner() {
4152             Lint lint = env.info.lint;
4153             boolean inSuperType;
4154 
4155             @Override
4156             public void visitBlock(JCBlock tree) {
4157             }
4158             @Override
4159             public void visitMethodDef(JCMethodDecl tree) {
4160                 if (!isAPISymbol(tree.sym))
4161                     return;
4162                 Lint prevLint = lint;
4163                 try {
4164                     lint = lint.augment(tree.sym);
4165                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4166                         super.visitMethodDef(tree);
4167                     }
4168                 } finally {
4169                     lint = prevLint;
4170                 }
4171             }
4172             @Override
4173             public void visitVarDef(JCVariableDecl tree) {
4174                 if (!isAPISymbol(tree.sym) &amp;&amp; tree.sym.owner.kind != MTH)
4175                     return;
4176                 Lint prevLint = lint;
4177                 try {
4178                     lint = lint.augment(tree.sym);
4179                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4180                         scan(tree.mods);
4181                         scan(tree.vartype);
4182                     }
4183                 } finally {
4184                     lint = prevLint;
4185                 }
4186             }
4187             @Override
4188             public void visitClassDef(JCClassDecl tree) {
4189                 if (tree != check)
4190                     return ;
4191 
4192                 if (!isAPISymbol(tree.sym))
4193                     return ;
4194 
4195                 Lint prevLint = lint;
4196                 try {
4197                     lint = lint.augment(tree.sym);
4198                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4199                         scan(tree.mods);
4200                         scan(tree.typarams);
4201                         try {
4202                             inSuperType = true;
4203                             scan(tree.extending);
4204                             scan(tree.implementing);
4205                         } finally {
4206                             inSuperType = false;
4207                         }
4208                         scan(tree.defs);
4209                     }
4210                 } finally {
4211                     lint = prevLint;
4212                 }
4213             }
4214             @Override
4215             public void visitTypeApply(JCTypeApply tree) {
4216                 scan(tree.clazz);
4217                 boolean oldInSuperType = inSuperType;
4218                 try {
4219                     inSuperType = false;
4220                     scan(tree.arguments);
4221                 } finally {
4222                     inSuperType = oldInSuperType;
4223                 }
4224             }
4225             @Override
4226             public void visitIdent(JCIdent tree) {
4227                 Symbol sym = TreeInfo.symbol(tree);
4228                 if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR)) {
4229                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4230                 }
4231             }
4232 
4233             @Override
4234             public void visitSelect(JCFieldAccess tree) {
4235                 Symbol sym = TreeInfo.symbol(tree);
4236                 Symbol sitesym = TreeInfo.symbol(tree.selected);
4237                 if (sym.kind == TYP &amp;&amp; sitesym.kind == PCK) {
4238                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4239                 } else {
4240                     super.visitSelect(tree);
4241                 }
4242             }
4243 
4244             @Override
4245             public void visitAnnotation(JCAnnotation tree) {
4246                 if (tree.attribute.type.tsym.getAnnotation(java.lang.annotation.Documented.class) != null)
4247                     super.visitAnnotation(tree);
4248             }
4249 
4250         }.scan(check);
4251     }
4252         //where:
4253         private ExportsDirective findExport(PackageSymbol pack) {
4254             for (ExportsDirective d : pack.modle.exports) {
4255                 if (d.packge == pack)
4256                     return d;
4257             }
4258 
4259             return null;
4260         }
4261         private boolean isAPISymbol(Symbol sym) {
4262             while (sym.kind != PCK) {
4263                 if ((sym.flags() &amp; Flags.PUBLIC) == 0 &amp;&amp; (sym.flags() &amp; Flags.PROTECTED) == 0) {
4264                     return false;
4265                 }
4266                 sym = sym.owner;
4267             }
4268             return true;
4269         }
4270         private void checkVisible(DiagnosticPosition pos, Symbol what, PackageSymbol inPackage, boolean inSuperType) {
4271             if (!isAPISymbol(what) &amp;&amp; !inSuperType) { //package private/private element
4272                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessible(kindName(what), what, what.packge().modle));
4273                 return ;
4274             }
4275 
4276             PackageSymbol whatPackage = what.packge();
4277             ExportsDirective whatExport = findExport(whatPackage);
4278             ExportsDirective inExport = findExport(inPackage);
4279 
4280             if (whatExport == null) { //package not exported:
4281                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexported(kindName(what), what, what.packge().modle));
4282                 return ;
4283             }
4284 
4285             if (whatExport.modules != null) {
4286                 if (inExport.modules == null || !whatExport.modules.containsAll(inExport.modules)) {
4287                     log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexportedQualified(kindName(what), what, what.packge().modle));
4288                 }
4289             }
4290 
4291             if (whatPackage.modle != inPackage.modle &amp;&amp; whatPackage.modle != syms.java_base) {
4292                 //check that relativeTo.modle requires transitive what.modle, somehow:
4293                 List&lt;ModuleSymbol&gt; todo = List.of(inPackage.modle);
4294 
4295                 while (todo.nonEmpty()) {
4296                     ModuleSymbol current = todo.head;
4297                     todo = todo.tail;
4298                     if (current == whatPackage.modle)
4299                         return ; //OK
4300                     if ((current.flags() &amp; Flags.AUTOMATIC_MODULE) != 0)
4301                         continue; //for automatic modules, don&#39;t look into their dependencies
4302                     for (RequiresDirective req : current.requires) {
4303                         if (req.isTransitive()) {
4304                             todo = todo.prepend(req.module);
4305                         }
4306                     }
4307                 }
4308 
4309                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleNotRequiredTransitive(kindName(what), what, what.packge().modle));
4310             }
4311         }
4312 
4313     void checkModuleExists(final DiagnosticPosition pos, ModuleSymbol msym) {
4314         if (msym.kind != MDL) {
4315             deferredLintHandler.report(() -&gt; {
4316                 if (lint.isEnabled(LintCategory.MODULE))
4317                     log.warning(LintCategory.MODULE, pos, Warnings.ModuleNotFound(msym));
4318             });
4319         }
4320     }
4321 
4322     void checkPackageExistsForOpens(final DiagnosticPosition pos, PackageSymbol packge) {
4323         if (packge.members().isEmpty() &amp;&amp;
4324             ((packge.flags() &amp; Flags.HAS_RESOURCE) == 0)) {
4325             deferredLintHandler.report(() -&gt; {
4326                 if (lint.isEnabled(LintCategory.OPENS))
4327                     log.warning(pos, Warnings.PackageEmptyOrNotFound(packge));
4328             });
4329         }
4330     }
4331 
4332     void checkModuleRequires(final DiagnosticPosition pos, final RequiresDirective rd) {
4333         if ((rd.module.flags() &amp; Flags.AUTOMATIC_MODULE) != 0) {
4334             deferredLintHandler.report(() -&gt; {
4335                 if (rd.isTransitive() &amp;&amp; lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {
4336                     log.warning(pos, Warnings.RequiresTransitiveAutomatic);
4337                 } else if (lint.isEnabled(LintCategory.REQUIRES_AUTOMATIC)) {
4338                     log.warning(pos, Warnings.RequiresAutomatic);
4339                 }
4340             });
4341         }
4342     }
4343 
4344 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
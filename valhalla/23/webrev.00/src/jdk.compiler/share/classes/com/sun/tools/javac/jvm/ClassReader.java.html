<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.net.URI;
  30 import java.net.URISyntaxException;
  31 import java.nio.CharBuffer;
  32 import java.nio.file.ClosedFileSystemException;
  33 import java.util.Arrays;
  34 import java.util.EnumSet;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Map;
  38 import java.util.Set;
  39 import java.util.function.IntFunction;
  40 
  41 import javax.lang.model.element.Modifier;
  42 import javax.lang.model.element.NestingKind;
  43 import javax.tools.JavaFileManager;
  44 import javax.tools.JavaFileObject;
  45 
  46 import com.sun.tools.javac.code.Source.Feature;
  47 import com.sun.tools.javac.comp.Annotate;
  48 import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
  49 import com.sun.tools.javac.code.*;
  50 import com.sun.tools.javac.code.Directive.*;
  51 import com.sun.tools.javac.code.Lint.LintCategory;
  52 import com.sun.tools.javac.code.Scope.WriteableScope;
  53 import com.sun.tools.javac.code.Symbol.*;
  54 import com.sun.tools.javac.code.Symtab;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  57 import com.sun.tools.javac.file.BaseFileManager;
  58 import com.sun.tools.javac.file.PathFileObject;
  59 import com.sun.tools.javac.jvm.ClassFile.Version;
  60 import com.sun.tools.javac.jvm.PoolConstant.NameAndType;
  61 import com.sun.tools.javac.main.Option;
  62 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  63 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  64 import com.sun.tools.javac.util.*;
  65 import com.sun.tools.javac.util.DefinedBy.Api;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 import static com.sun.tools.javac.code.Flags.*;
  69 import static com.sun.tools.javac.code.Kinds.Kind.*;
  70 
  71 import com.sun.tools.javac.code.Scope.LookupKind;
  72 
  73 import static com.sun.tools.javac.code.TypeTag.ARRAY;
  74 import static com.sun.tools.javac.code.TypeTag.CLASS;
  75 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  76 import static com.sun.tools.javac.jvm.ClassFile.*;
  77 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
  78 
  79 import static com.sun.tools.javac.main.Option.PARAMETERS;
  80 
  81 /** This class provides operations to read a classfile into an internal
  82  *  representation. The internal representation is anchored in a
  83  *  ClassSymbol which contains in its scope symbol representations
  84  *  for all other definitions in the classfile. Top-level Classes themselves
  85  *  appear as members of the scopes of PackageSymbols.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
 108     /** Switch: allow inline types.
 109      */
 110     boolean allowInlineTypes;
 111 
 112     /** Switch: allow records
 113      */
 114     boolean allowRecords;
 115 
 116    /** Lint option: warn about classfile issues
 117      */
 118     boolean lintClassfile;
 119 
 120     /** Switch: preserve parameter names from the variable table.
 121      */
 122     public boolean saveParameterNames;
 123 
 124     /** Switch: Should javac recongnize and handle value based classes specially ?
 125      */
 126     private boolean allowValueBasedClasses;
 127 
 128     /**
 129      * The currently selected profile.
 130      */
 131     public final Profile profile;
 132 
 133     /** The log to use for verbose output
 134      */
 135     final Log log;
 136 
 137     /** The symbol table. */
 138     Symtab syms;
 139 
 140     Types types;
 141 
 142     /** The name table. */
 143     final Names names;
 144 
 145     /** Access to files
 146      */
 147     private final JavaFileManager fileManager;
 148 
 149     /** Factory for diagnostics
 150      */
 151     JCDiagnostic.Factory diagFactory;
 152 
 153     DeferredCompletionFailureHandler dcfh;
 154 
 155     /**
 156      * Support for preview language features.
 157      */
 158     Preview preview;
 159 
 160     /** The current scope where type variables are entered.
 161      */
 162     protected WriteableScope typevars;
 163 
 164     private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
 165     private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
 166 
 167     /** The path name of the class file currently being read.
 168      */
 169     protected JavaFileObject currentClassFile = null;
 170 
 171     /** The class or method currently being read.
 172      */
 173     protected Symbol currentOwner = null;
 174 
 175     /** The module containing the class currently being read.
 176      */
 177     protected ModuleSymbol currentModule = null;
 178 
 179     /** The buffer containing the currently read class file.
 180      */
 181     ByteBuffer buf = new ByteBuffer(INITIAL_BUFFER_SIZE);
 182 
 183     /** The current input pointer.
 184      */
 185     protected int bp;
 186 
 187     /** The pool reader.
 188      */
 189     PoolReader poolReader;
 190 
 191     /** The major version number of the class file being read. */
 192     int majorVersion;
 193     /** The minor version number of the class file being read. */
 194     int minorVersion;
 195 
 196     /** A table to hold the constant pool indices for method parameter
 197      * names, as given in LocalVariableTable attributes.
 198      */
 199     int[] parameterNameIndices;
 200 
 201     /**
 202      * A table to hold annotations for method parameters.
 203      */
 204     ParameterAnnotations[] parameterAnnotations;
 205 
 206     /**
 207      * A holder for parameter annotations.
 208      */
 209     static class ParameterAnnotations {
 210         List&lt;CompoundAnnotationProxy&gt; proxies;
 211 
 212         void add(List&lt;CompoundAnnotationProxy&gt; newAnnotations) {
 213             if (proxies == null) {
 214                 proxies = newAnnotations;
 215             } else {
 216                 proxies = proxies.prependList(newAnnotations);
 217             }
 218         }
 219     }
 220 
 221     /**
 222      * Whether or not any parameter names have been found.
 223      */
 224     boolean haveParameterNameIndices;
 225 
 226     /** Set this to false every time we start reading a method
 227      * and are saving parameter names.  Set it to true when we see
 228      * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
 229      * then we ignore the parameter names from the LVT.
 230      */
 231     boolean sawMethodParameters;
 232 
 233     /**
 234      * The set of attribute names for which warnings have been generated for the current class
 235      */
 236     Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();
 237 
 238     /**
 239      * The prototype @Target Attribute.Compound if this class is an annotation annotated with
 240      * @Target
 241      */
 242     CompoundAnnotationProxy target;
 243 
 244     /**
 245      * The prototype @Repeatable Attribute.Compound if this class is an annotation annotated with
 246      * @Repeatable
 247      */
 248     CompoundAnnotationProxy repeatable;
 249 
 250     /** Get the ClassReader instance for this invocation. */
 251     public static ClassReader instance(Context context) {
 252         ClassReader instance = context.get(classReaderKey);
 253         if (instance == null)
 254             instance = new ClassReader(context);
 255         return instance;
 256     }
 257 
 258     /** Construct a new class reader. */
 259     protected ClassReader(Context context) {
 260         context.put(classReaderKey, this);
 261         annotate = Annotate.instance(context);
 262         names = Names.instance(context);
 263         syms = Symtab.instance(context);
 264         types = Types.instance(context);
 265         fileManager = context.get(JavaFileManager.class);
 266         if (fileManager == null)
 267             throw new AssertionError(&quot;FileManager initialization error&quot;);
 268         diagFactory = JCDiagnostic.Factory.instance(context);
 269         dcfh = DeferredCompletionFailureHandler.instance(context);
 270 
 271         log = Log.instance(context);
 272 
 273         Options options = Options.instance(context);
 274         verbose         = options.isSet(Option.VERBOSE);
 275 
 276         Source source = Source.instance(context);
 277         preview = Preview.instance(context);
 278         allowModules     = Feature.MODULES.allowedInSource(source);
 279         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);
 280         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 281                 Feature.RECORDS.allowedInSource(source);
 282 
 283         saveParameterNames = options.isSet(PARAMETERS);
 284         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 285 
 286         profile = Profile.instance(context);
 287 
 288         typevars = WriteableScope.create(syms.noSymbol);
 289 
 290         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 291 
 292         initAttributeReaders();
 293     }
 294 
 295     /** Add member to class unless it is synthetic.
 296      */
 297     private void enterMember(ClassSymbol c, Symbol sym) {
 298         // Synthetic members are not entered -- reason lost to history (optimization?).
 299         // Lambda methods must be entered because they may have inner classes (which reference them)
 300         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 301             c.members_field.enter(sym);
 302     }
 303 
 304 /************************************************************************
 305  * Error Diagnoses
 306  ***********************************************************************/
 307 
 308     public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
 309         return new ClassFinder.BadClassFile (
 310             currentOwner.enclClass(),
 311             currentClassFile,
 312             diagFactory.fragment(key, args),
 313             diagFactory,
 314             dcfh);
 315     }
 316 
 317     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 318         return new ClassFinder.BadEnclosingMethodAttr (
 319             currentOwner.enclClass(),
 320             currentClassFile,
 321             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
 322             diagFactory,
 323             dcfh);
 324     }
 325 
 326 /************************************************************************
 327  * Buffer Access
 328  ***********************************************************************/
 329 
 330     /** Read a character.
 331      */
 332     char nextChar() {
 333         char res = buf.getChar(bp);
 334         bp += 2;
 335         return res;
 336     }
 337 
 338     /** Read a byte.
 339      */
 340     int nextByte() {
 341         return buf.getByte(bp++) &amp; 0xFF;
 342     }
 343 
 344     /** Read an integer.
 345      */
 346     int nextInt() {
 347         int res = buf.getInt(bp);
 348         bp += 4;
 349         return res;
 350     }
 351 
 352 /************************************************************************
 353  * Constant Pool Access
 354  ***********************************************************************/
 355 
 356     /** Read module_flags.
 357      */
 358     Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
 359         Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
 360         for (ModuleFlags f : ModuleFlags.values()) {
 361             if ((flags &amp; f.value) != 0)
 362                 set.add(f);
 363         }
 364         return set;
 365     }
 366 
 367     /** Read resolution_flags.
 368      */
 369     Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
 370         Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
 371         for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
 372             if ((flags &amp; f.value) != 0)
 373                 set.add(f);
 374         }
 375         return set;
 376     }
 377 
 378     /** Read exports_flags.
 379      */
 380     Set&lt;ExportsFlag&gt; readExportsFlags(int flags) {
 381         Set&lt;ExportsFlag&gt; set = EnumSet.noneOf(ExportsFlag.class);
 382         for (ExportsFlag f: ExportsFlag.values()) {
 383             if ((flags &amp; f.value) != 0)
 384                 set.add(f);
 385         }
 386         return set;
 387     }
 388 
 389     /** Read opens_flags.
 390      */
 391     Set&lt;OpensFlag&gt; readOpensFlags(int flags) {
 392         Set&lt;OpensFlag&gt; set = EnumSet.noneOf(OpensFlag.class);
 393         for (OpensFlag f: OpensFlag.values()) {
 394             if ((flags &amp; f.value) != 0)
 395                 set.add(f);
 396         }
 397         return set;
 398     }
 399 
 400     /** Read requires_flags.
 401      */
 402     Set&lt;RequiresFlag&gt; readRequiresFlags(int flags) {
 403         Set&lt;RequiresFlag&gt; set = EnumSet.noneOf(RequiresFlag.class);
 404         for (RequiresFlag f: RequiresFlag.values()) {
 405             if ((flags &amp; f.value) != 0)
 406                 set.add(f);
 407         }
 408         return set;
 409     }
 410 
 411 /************************************************************************
 412  * Reading Types
 413  ***********************************************************************/
 414 
 415     /** The unread portion of the currently read type is
 416      *  signature[sigp..siglimit-1].
 417      */
 418     byte[] signature;
 419     int sigp;
 420     int siglimit;
 421     boolean sigEnterPhase = false;
 422 
 423     /** Convert signature to type, where signature is a byte array segment.
 424      */
 425     Type sigToType(byte[] sig, int offset, int len) {
 426         signature = sig;
 427         sigp = offset;
 428         siglimit = offset + len;
 429         return sigToType();
 430     }
 431 
 432     /** Convert signature to type, where signature is implicit.
 433      */
 434     Type sigToType() {
 435         switch ((char) signature[sigp]) {
 436         case &#39;T&#39;:
 437             sigp++;
 438             int start = sigp;
 439             while (signature[sigp] != &#39;;&#39;) sigp++;
 440             sigp++;
 441             return sigEnterPhase
 442                 ? Type.noType
 443                 : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));
 444         case &#39;+&#39;: {
 445             sigp++;
 446             Type t = sigToType();
 447             return new WildcardType(t, BoundKind.EXTENDS, syms.boundClass);
 448         }
 449         case &#39;*&#39;:
 450             sigp++;
 451             return new WildcardType(syms.objectType, BoundKind.UNBOUND,
 452                                     syms.boundClass);
 453         case &#39;-&#39;: {
 454             sigp++;
 455             Type t = sigToType();
 456             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 457         }
 458         case &#39;B&#39;:
 459             sigp++;
 460             return syms.byteType;
 461         case &#39;C&#39;:
 462             sigp++;
 463             return syms.charType;
 464         case &#39;D&#39;:
 465             sigp++;
 466             return syms.doubleType;
 467         case &#39;F&#39;:
 468             sigp++;
 469             return syms.floatType;
 470         case &#39;I&#39;:
 471             sigp++;
 472             return syms.intType;
 473         case &#39;J&#39;:
 474             sigp++;
 475             return syms.longType;
 476         case &#39;Q&#39;:
 477         case &#39;L&#39;:
 478             {
 479                 // int oldsigp = sigp;
 480                 Type t = classSigToType();
 481                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 482                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 483                                        &quot;(please recompile from source)&quot;);
 484                 /*
 485                 System.err.println(&quot; decoded &quot; +
 486                                    new String(signature, oldsigp, sigp-oldsigp) +
 487                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 488                 */
 489                 return t;
 490             }
 491         case &#39;S&#39;:
 492             sigp++;
 493             return syms.shortType;
 494         case &#39;V&#39;:
 495             sigp++;
 496             return syms.voidType;
 497         case &#39;Z&#39;:
 498             sigp++;
 499             return syms.booleanType;
 500         case &#39;[&#39;:
 501             sigp++;
 502             return new ArrayType(sigToType(), syms.arrayClass);
 503         case &#39;(&#39;:
 504             sigp++;
 505             List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
 506             Type restype = sigToType();
 507             List&lt;Type&gt; thrown = List.nil();
 508             while (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;^&#39;) {
 509                 sigp++;
 510                 thrown = thrown.prepend(sigToType());
 511             }
 512             // if there is a typevar in the throws clause we should state it.
 513             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
 514                 if (l.head.hasTag(TYPEVAR)) {
 515                     l.head.tsym.flags_field |= THROWS;
 516                 }
 517             }
 518             return new MethodType(argtypes,
 519                                   restype,
 520                                   thrown.reverse(),
 521                                   syms.methodClass);
 522         case &#39;&lt;&#39;:
 523             typevars = typevars.dup(currentOwner);
 524             Type poly = new ForAll(sigToTypeParams(), sigToType());
 525             typevars = typevars.leave();
 526             return poly;
 527         default:
 528             throw badClassFile(&quot;bad.signature&quot;,
 529                                Convert.utf2string(signature, sigp, 10));
 530         }
 531     }
 532 
 533     byte[] signatureBuffer = new byte[0];
 534     int sbp = 0;
 535     /** Convert class signature to type, where signature is implicit.
 536      */
 537     Type classSigToType() {
 538         if (signature[sigp] != &#39;L&#39; &amp;&amp; signature[sigp] != &#39;Q&#39;)
 539             throw badClassFile(&quot;bad.class.signature&quot;,
 540                                Convert.utf2string(signature, sigp, 10));
 541         sigp++;
 542         Type outer = Type.noType;
 543         int startSbp = sbp;
 544 
 545         while (true) {
 546             final byte c = signature[sigp++];
 547             switch (c) {
 548 
 549             case &#39;;&#39;: {         // end
 550                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 551                                                          startSbp,
 552                                                          sbp - startSbp));
 553 
 554                 try {
 555                     return (outer == Type.noType) ?
 556                             t.erasure(types) :
 557                         new ClassType(outer, List.nil(), t);
 558                 } finally {
 559                     sbp = startSbp;
 560                 }
 561             }
 562 
 563             case &#39;&lt;&#39;:           // generic arguments
 564                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 565                                                          startSbp,
 566                                                          sbp - startSbp));
 567                 outer = new ClassType(outer, sigToTypes(&#39;&gt;&#39;), t) {
 568                         boolean completed = false;
 569                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 570                         public Type getEnclosingType() {
 571                             if (!completed) {
 572                                 completed = true;
 573                                 tsym.complete();
 574                                 Type enclosingType = tsym.type.getEnclosingType();
 575                                 if (enclosingType != Type.noType) {
 576                                     List&lt;Type&gt; typeArgs =
 577                                         super.getEnclosingType().allparams();
 578                                     List&lt;Type&gt; typeParams =
 579                                         enclosingType.allparams();
 580                                     if (typeParams.length() != typeArgs.length()) {
 581                                         // no &quot;rare&quot; types
 582                                         super.setEnclosingType(types.erasure(enclosingType));
 583                                     } else {
 584                                         super.setEnclosingType(types.subst(enclosingType,
 585                                                                            typeParams,
 586                                                                            typeArgs));
 587                                     }
 588                                 } else {
 589                                     super.setEnclosingType(Type.noType);
 590                                 }
 591                             }
 592                             return super.getEnclosingType();
 593                         }
 594                         @Override
 595                         public void setEnclosingType(Type outer) {
 596                             throw new UnsupportedOperationException();
 597                         }
 598                     };
 599                 switch (signature[sigp++]) {
 600                 case &#39;;&#39;:
 601                     if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;) {
 602                         // support old-style GJC signatures
 603                         // The signature produced was
 604                         // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
 605                         // rather than say
 606                         // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
 607                         // so we skip past &quot;.Lfoo/Outer$&quot;
 608                         sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
 609                             3;  // &quot;.L&quot; and &quot;$&quot;
 610                         signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 611                         break;
 612                     } else {
 613                         sbp = startSbp;
 614                         return outer;
 615                     }
 616                 case &#39;.&#39;:
 617                     signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 618                     break;
 619                 default:
 620                     throw new AssertionError(signature[sigp-1]);
 621                 }
 622                 continue;
 623 
 624             case &#39;.&#39;:
 625                 //we have seen an enclosing non-generic class
 626                 if (outer != Type.noType) {
 627                     t = enterClass(names.fromUtf(signatureBuffer,
 628                                                  startSbp,
 629                                                  sbp - startSbp));
 630                     outer = new ClassType(outer, List.nil(), t);
 631                 }
 632                 signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 633                 continue;
 634             case &#39;/&#39;:
 635                 signatureBuffer[sbp++] = (byte)&#39;.&#39;;
 636                 continue;
 637             default:
 638                 signatureBuffer[sbp++] = c;
 639                 continue;
 640             }
 641         }
 642     }
 643 
 644     /** Convert (implicit) signature to list of types
 645      *  until `terminator&#39; is encountered.
 646      */
 647     List&lt;Type&gt; sigToTypes(char terminator) {
 648         List&lt;Type&gt; head = List.of(null);
 649         List&lt;Type&gt; tail = head;
 650         while (signature[sigp] != terminator)
 651             tail = tail.setTail(List.of(sigToType()));
 652         sigp++;
 653         return head.tail;
 654     }
 655 
 656     /** Convert signature to type parameters, where signature is a byte
 657      *  array segment.
 658      */
 659     List&lt;Type&gt; sigToTypeParams(byte[] sig, int offset, int len) {
 660         signature = sig;
 661         sigp = offset;
 662         siglimit = offset + len;
 663         return sigToTypeParams();
 664     }
 665 
 666     /** Convert signature to type parameters, where signature is implicit.
 667      */
 668     List&lt;Type&gt; sigToTypeParams() {
 669         List&lt;Type&gt; tvars = List.nil();
 670         if (signature[sigp] == &#39;&lt;&#39;) {
 671             sigp++;
 672             int start = sigp;
 673             sigEnterPhase = true;
 674             while (signature[sigp] != &#39;&gt;&#39;)
 675                 tvars = tvars.prepend(sigToTypeParam());
 676             sigEnterPhase = false;
 677             sigp = start;
 678             while (signature[sigp] != &#39;&gt;&#39;)
 679                 sigToTypeParam();
 680             sigp++;
 681         }
 682         return tvars.reverse();
 683     }
 684 
 685     /** Convert (implicit) signature to type parameter.
 686      */
 687     Type sigToTypeParam() {
 688         int start = sigp;
 689         while (signature[sigp] != &#39;:&#39;) sigp++;
 690         Name name = names.fromUtf(signature, start, sigp - start);
 691         TypeVar tvar;
 692         if (sigEnterPhase) {
 693             tvar = new TypeVar(name, currentOwner, syms.botType);
 694             typevars.enter(tvar.tsym);
 695         } else {
 696             tvar = (TypeVar)findTypeVar(name);
 697         }
 698         List&lt;Type&gt; bounds = List.nil();
 699         boolean allInterfaces = false;
 700         if (signature[sigp] == &#39;:&#39; &amp;&amp; signature[sigp+1] == &#39;:&#39;) {
 701             sigp++;
 702             allInterfaces = true;
 703         }
 704         while (signature[sigp] == &#39;:&#39;) {
 705             sigp++;
 706             bounds = bounds.prepend(sigToType());
 707         }
 708         if (!sigEnterPhase) {
 709             types.setBounds(tvar, bounds.reverse(), allInterfaces);
 710         }
 711         return tvar;
 712     }
 713 
 714     /** Find type variable with given name in `typevars&#39; scope.
 715      */
 716     Type findTypeVar(Name name) {
 717         Symbol s = typevars.findFirst(name);
 718         if (s != null) {
 719             return s.type;
 720         } else {
 721             if (readingClassAttr) {
 722                 // While reading the class attribute, the supertypes
 723                 // might refer to a type variable from an enclosing element
 724                 // (method or class).
 725                 // If the type variable is defined in the enclosing class,
 726                 // we can actually find it in
 727                 // currentOwner.owner.type.getTypeArguments()
 728                 // However, until we have read the enclosing method attribute
 729                 // we don&#39;t know for sure if this owner is correct.  It could
 730                 // be a method and there is no way to tell before reading the
 731                 // enclosing method attribute.
 732                 TypeVar t = new TypeVar(name, currentOwner, syms.botType);
 733                 missingTypeVariables = missingTypeVariables.prepend(t);
 734                 // System.err.println(&quot;Missing type var &quot; + name);
 735                 return t;
 736             }
 737             throw badClassFile(&quot;undecl.type.var&quot;, name);
 738         }
 739     }
 740 
 741 /************************************************************************
 742  * Reading Attributes
 743  ***********************************************************************/
 744 
 745     protected enum AttributeKind { CLASS, MEMBER }
 746 
 747     protected abstract class AttributeReader {
 748         protected AttributeReader(Name name, ClassFile.Version version, Set&lt;AttributeKind&gt; kinds) {
 749             this.name = name;
 750             this.version = version;
 751             this.kinds = kinds;
 752         }
 753 
 754         protected boolean accepts(AttributeKind kind) {
 755             if (kinds.contains(kind)) {
 756                 if (majorVersion &gt; version.major || (majorVersion == version.major &amp;&amp; minorVersion &gt;= version.minor))
 757                     return true;
 758 
 759                 if (lintClassfile &amp;&amp; !warnedAttrs.contains(name)) {
 760                     JavaFileObject prev = log.useSource(currentClassFile);
 761                     try {
 762                         log.warning(LintCategory.CLASSFILE, (DiagnosticPosition) null,
 763                                     Warnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));
 764                     } finally {
 765                         log.useSource(prev);
 766                     }
 767                     warnedAttrs.add(name);
 768                 }
 769             }
 770             return false;
 771         }
 772 
 773         protected abstract void read(Symbol sym, int attrLen);
 774 
 775         protected final Name name;
 776         protected final ClassFile.Version version;
 777         protected final Set&lt;AttributeKind&gt; kinds;
 778     }
 779 
 780     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 781             EnumSet.of(AttributeKind.CLASS);
 782     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 783             EnumSet.of(AttributeKind.MEMBER);
 784     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 785             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 786 
 787     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 788 
 789     private void initAttributeReaders() {
 790         AttributeReader[] readers = {
 791             // v45.3 attributes
 792 
 793             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 794                 protected void read(Symbol sym, int attrLen) {
 795                     if (allowInlineTypes) {
 796                         if (sym.isConstructor()  &amp;&amp; ((MethodSymbol) sym).type.getParameterTypes().size() == 0) {
 797                             int code_length = buf.getInt(bp + 4);
 798                             if ((code_length == 1 &amp;&amp; buf.getByte( bp + 8) == (byte) ByteCodes.return_) ||
 799                                     (code_length == 5 &amp;&amp; buf.getByte(bp + 8) == ByteCodes.aload_0 &amp;&amp;
 800                                         buf.getByte( bp + 9) == (byte) ByteCodes.invokespecial &amp;&amp;
 801                                                 buf.getByte( bp + 12) == (byte) ByteCodes.return_)) {
 802                                     sym.flags_field |= EMPTYNOARGCONSTR;
 803                             }
 804                         }
 805                     }
 806                     if (saveParameterNames)
 807                         ((MethodSymbol)sym).code = readCode(sym);
 808                     else
 809                         bp = bp + attrLen;
 810                 }
 811             },
 812 
 813             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 814                 protected void read(Symbol sym, int attrLen) {
 815                     Object v = poolReader.getConstant(nextChar());
 816                     // Ignore ConstantValue attribute if field not final.
 817                     if ((sym.flags() &amp; FINAL) == 0) {
 818                         return;
 819                     }
 820                     VarSymbol var = (VarSymbol) sym;
 821                     switch (var.type.getTag()) {
 822                        case BOOLEAN:
 823                        case BYTE:
 824                        case CHAR:
 825                        case SHORT:
 826                        case INT:
 827                            checkType(var, Integer.class, v);
 828                            break;
 829                        case LONG:
 830                            checkType(var, Long.class, v);
 831                            break;
 832                        case FLOAT:
 833                            checkType(var, Float.class, v);
 834                            break;
 835                        case DOUBLE:
 836                            checkType(var, Double.class, v);
 837                            break;
 838                        case CLASS:
 839                            if (var.type.tsym == syms.stringType.tsym) {
 840                                checkType(var, String.class, v);
 841                            } else {
 842                                throw badClassFile(&quot;bad.constant.value.type&quot;, var.type);
 843                            }
 844                            break;
 845                        default:
 846                            // ignore ConstantValue attribute if type is not primitive or String
 847                            return;
 848                     }
 849                     if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
 850                         throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
 851                     }
 852                     var.setData(v);
 853                 }
 854 
 855                 void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {
 856                     if (!clazz.isInstance(value)) {
 857                         throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
 858                     }
 859                 }
 860             },
 861 
 862             new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 863                 protected void read(Symbol sym, int attrLen) {
 864                     Symbol s = sym.owner.kind == MDL ? sym.owner : sym;
 865 
 866                     s.flags_field |= DEPRECATED;
 867                 }
 868             },
 869 
 870             new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 871                 protected void read(Symbol sym, int attrLen) {
 872                     int nexceptions = nextChar();
 873                     List&lt;Type&gt; thrown = List.nil();
 874                     for (int j = 0; j &lt; nexceptions; j++)
 875                         thrown = thrown.prepend(poolReader.getClass(nextChar()).type);
 876                     if (sym.type.getThrownTypes().isEmpty())
 877                         sym.type.asMethodType().thrown = thrown.reverse();
 878                 }
 879             },
 880 
 881             new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {
 882                 protected void read(Symbol sym, int attrLen) {
 883                     ClassSymbol c = (ClassSymbol) sym;
 884                     if (currentModule.module_info == c) {
 885                         //prevent entering the classes too soon:
 886                         skipInnerClasses();
 887                     } else {
 888                         readInnerClasses(c);
 889                     }
 890                 }
 891             },
 892 
 893             new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 894                 protected void read(Symbol sym, int attrLen) {
 895                     int newbp = bp + attrLen;
 896                     if (saveParameterNames &amp;&amp; !sawMethodParameters) {
 897                         // Pick up parameter names from the variable table.
 898                         // Parameter names are not explicitly identified as such,
 899                         // but all parameter name entries in the LocalVariableTable
 900                         // have a start_pc of 0.  Therefore, we record the name
 901                         // indices of all slots with a start_pc of zero in the
 902                         // parameterNameIndices array.
 903                         // Note that this implicitly honors the JVMS spec that
 904                         // there may be more than one LocalVariableTable, and that
 905                         // there is no specified ordering for the entries.
 906                         int numEntries = nextChar();
 907                         for (int i = 0; i &lt; numEntries; i++) {
 908                             int start_pc = nextChar();
 909                             int length = nextChar();
 910                             int nameIndex = nextChar();
 911                             int sigIndex = nextChar();
 912                             int register = nextChar();
 913                             if (start_pc == 0) {
 914                                 // ensure array large enough
 915                                 if (register &gt;= parameterNameIndices.length) {
 916                                     int newSize =
 917                                             Math.max(register + 1, parameterNameIndices.length + 8);
 918                                     parameterNameIndices =
 919                                             Arrays.copyOf(parameterNameIndices, newSize);
 920                                 }
 921                                 parameterNameIndices[register] = nameIndex;
 922                                 haveParameterNameIndices = true;
 923                             }
 924                         }
 925                     }
 926                     bp = newbp;
 927                 }
 928             },
 929 
 930             new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
 931                 protected void read(Symbol sym, int attrLen) {
 932                     ClassSymbol c = (ClassSymbol) sym;
 933                     Name n = poolReader.getName(nextChar());
 934                     c.sourcefile = new SourceFileObject(n);
 935                     // If the class is a toplevel class, originating from a Java source file,
 936                     // but the class name does not match the file name, then it is
 937                     // an auxiliary class.
 938                     String sn = n.toString();
 939                     if (c.owner.kind == PCK &amp;&amp;
 940                         sn.endsWith(&quot;.java&quot;) &amp;&amp;
 941                         !sn.equals(c.name.toString()+&quot;.java&quot;)) {
 942                         c.flags_field |= AUXILIARY;
 943                     }
 944                 }
 945             },
 946 
 947             new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 948                 protected void read(Symbol sym, int attrLen) {
 949                     sym.flags_field |= SYNTHETIC;
 950                 }
 951             },
 952 
 953             // standard v49 attributes
 954 
 955             new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {
 956                 protected void read(Symbol sym, int attrLen) {
 957                     int newbp = bp + attrLen;
 958                     readEnclosingMethodAttr(sym);
 959                     bp = newbp;
 960                 }
 961             },
 962 
 963             new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 964                 protected void read(Symbol sym, int attrLen) {
 965                     if (sym.kind == TYP) {
 966                         ClassSymbol c = (ClassSymbol) sym;
 967                         readingClassAttr = true;
 968                         try {
 969                             ClassType ct1 = (ClassType)c.type;
 970                             Assert.check(c == currentOwner);
 971                             ct1.typarams_field = poolReader.getName(nextChar())
 972                                     .map(ClassReader.this::sigToTypeParams);
 973                             ct1.supertype_field = sigToType();
 974                             ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
 975                             while (sigp != siglimit) is.append(sigToType());
 976                             ct1.interfaces_field = is.toList();
 977                         } finally {
 978                             readingClassAttr = false;
 979                         }
 980                     } else {
 981                         List&lt;Type&gt; thrown = sym.type.getThrownTypes();
 982                         sym.type = poolReader.getType(nextChar());
 983                         //- System.err.println(&quot; # &quot; + sym.type);
 984                         if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
 985                             sym.type.asMethodType().thrown = thrown;
 986 
 987                     }
 988                 }
 989             },
 990 
 991             // v49 annotation attributes
 992 
 993             new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 994                 protected void read(Symbol sym, int attrLen) {
 995                     attachAnnotationDefault(sym);
 996                 }
 997             },
 998 
 999             new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1000                 protected void read(Symbol sym, int attrLen) {
1001                     attachAnnotations(sym);
1002                 }
1003             },
1004 
1005             new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1006                 protected void read(Symbol sym, int attrLen) {
1007                     readParameterAnnotations(sym);
1008                 }
1009             },
1010 
1011             new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1012                 protected void read(Symbol sym, int attrLen) {
1013                     attachAnnotations(sym);
1014                 }
1015             },
1016 
1017             new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1018                 protected void read(Symbol sym, int attrLen) {
1019                     readParameterAnnotations(sym);
1020                 }
1021             },
1022 
1023             // additional &quot;legacy&quot; v49 attributes, superseded by flags
1024 
1025             new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1026                 protected void read(Symbol sym, int attrLen) {
1027                     sym.flags_field |= ANNOTATION;
1028                 }
1029             },
1030 
1031             new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {
1032                 protected void read(Symbol sym, int attrLen) {
1033                     sym.flags_field |= BRIDGE;
1034                 }
1035             },
1036 
1037             new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1038                 protected void read(Symbol sym, int attrLen) {
1039                     sym.flags_field |= ENUM;
1040                 }
1041             },
1042 
1043             new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1044                 protected void read(Symbol sym, int attrLen) {
1045                     sym.flags_field |= VARARGS;
1046                 }
1047             },
1048 
1049             new AttributeReader(names.RuntimeVisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1050                 protected void read(Symbol sym, int attrLen) {
1051                     attachTypeAnnotations(sym);
1052                 }
1053             },
1054 
1055             new AttributeReader(names.RuntimeInvisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1056                 protected void read(Symbol sym, int attrLen) {
1057                     attachTypeAnnotations(sym);
1058                 }
1059             },
1060 
1061             // The following attributes for a Code attribute are not currently handled
1062             // StackMapTable
1063             // SourceDebugExtension
1064             // LineNumberTable
1065             // LocalVariableTypeTable
1066 
1067             // standard v52 attributes
1068 
1069             new AttributeReader(names.MethodParameters, V52, MEMBER_ATTRIBUTE) {
1070                 protected void read(Symbol sym, int attrlen) {
1071                     int newbp = bp + attrlen;
1072                     if (saveParameterNames) {
1073                         sawMethodParameters = true;
1074                         int numEntries = nextByte();
1075                         parameterNameIndices = new int[numEntries];
1076                         haveParameterNameIndices = true;
1077                         int index = 0;
1078                         for (int i = 0; i &lt; numEntries; i++) {
1079                             int nameIndex = nextChar();
1080                             int flags = nextChar();
1081                             if ((flags &amp; (Flags.MANDATED | Flags.SYNTHETIC)) != 0) {
1082                                 continue;
1083                             }
1084                             parameterNameIndices[index++] = nameIndex;
1085                         }
1086                     }
1087                     bp = newbp;
1088                 }
1089             },
1090 
1091             // standard v53 attributes
1092 
1093             new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {
1094                 @Override
1095                 protected boolean accepts(AttributeKind kind) {
1096                     return super.accepts(kind) &amp;&amp; allowModules;
1097                 }
1098                 protected void read(Symbol sym, int attrLen) {
1099                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1100                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1101                         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
1102 
1103                         Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);
1104                         if (currentModule.name != moduleName) {
1105                             throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
1106                         }
1107 
1108                         Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
1109                         msym.flags.addAll(moduleFlags);
1110                         msym.version = optPoolEntry(nextChar(), poolReader::getName, null);
1111 
1112                         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
1113                         int nrequires = nextChar();
1114                         for (int i = 0; i &lt; nrequires; i++) {
1115                             ModuleSymbol rsym = poolReader.getModule(nextChar());
1116                             Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
1117                             if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
1118                                 if (flags.contains(RequiresFlag.TRANSITIVE)) {
1119                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
1120                                 }
1121                                 if (flags.contains(RequiresFlag.STATIC_PHASE)) {
1122                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
1123                                 }
1124                             }
1125                             nextChar(); // skip compiled version
1126                             requires.add(new RequiresDirective(rsym, flags));
1127                         }
1128                         msym.requires = requires.toList();
1129                         directives.addAll(msym.requires);
1130 
1131                         ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
1132                         int nexports = nextChar();
1133                         for (int i = 0; i &lt; nexports; i++) {
1134                             PackageSymbol p = poolReader.getPackage(nextChar());
1135                             Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
1136                             int nto = nextChar();
1137                             List&lt;ModuleSymbol&gt; to;
1138                             if (nto == 0) {
1139                                 to = null;
1140                             } else {
1141                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1142                                 for (int t = 0; t &lt; nto; t++)
1143                                     lb.append(poolReader.getModule(nextChar()));
1144                                 to = lb.toList();
1145                             }
1146                             exports.add(new ExportsDirective(p, to, flags));
1147                         }
1148                         msym.exports = exports.toList();
1149                         directives.addAll(msym.exports);
1150                         ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
1151                         int nopens = nextChar();
1152                         if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
1153                             throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
1154                         }
1155                         for (int i = 0; i &lt; nopens; i++) {
1156                             PackageSymbol p = poolReader.getPackage(nextChar());
1157                             Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
1158                             int nto = nextChar();
1159                             List&lt;ModuleSymbol&gt; to;
1160                             if (nto == 0) {
1161                                 to = null;
1162                             } else {
1163                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1164                                 for (int t = 0; t &lt; nto; t++)
1165                                     lb.append(poolReader.getModule(nextChar()));
1166                                 to = lb.toList();
1167                             }
1168                             opens.add(new OpensDirective(p, to, flags));
1169                         }
1170                         msym.opens = opens.toList();
1171                         directives.addAll(msym.opens);
1172 
1173                         msym.directives = directives.toList();
1174 
1175                         ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
1176                         int nuses = nextChar();
1177                         for (int i = 0; i &lt; nuses; i++) {
1178                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1179                             uses.add(new InterimUsesDirective(srvc));
1180                         }
1181                         interimUses = uses.toList();
1182 
1183                         ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
1184                         int nprovides = nextChar();
1185                         for (int p = 0; p &lt; nprovides; p++) {
1186                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1187                             int nimpls = nextChar();
1188                             ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
1189                             for (int i = 0; i &lt; nimpls; i++) {
1190                                 impls.append(poolReader.peekClassName(nextChar(), this::classNameMapper));
1191                             provides.add(new InterimProvidesDirective(srvc, impls.toList()));
1192                             }
1193                         }
1194                         interimProvides = provides.toList();
1195                     }
1196                 }
1197 
1198                 private Name classNameMapper(byte[] arr, int offset, int length) {
1199                     return names.fromUtf(ClassFile.internalize(arr, offset, length));
1200                 }
1201             },
1202 
1203             new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
1204                 @Override
1205                 protected boolean accepts(AttributeKind kind) {
1206                     return super.accepts(kind) &amp;&amp; allowModules;
1207                 }
1208                 protected void read(Symbol sym, int attrLen) {
1209                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1210                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1211                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1212                     }
1213                 }
1214             },
1215 
1216             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1217                 @Override
1218                 protected boolean accepts(AttributeKind kind) {
1219                     return super.accepts(kind) &amp;&amp; allowRecords;
1220                 }
1221                 protected void read(Symbol sym, int attrLen) {
1222                     if (sym.kind == TYP) {
1223                         sym.flags_field |= RECORD;
1224                     }
1225                     bp = bp + attrLen;
1226                 }
1227             }
1228         };
1229 
1230         for (AttributeReader r: readers)
1231             attributeReaders.put(r.name, r);
1232     }
1233 
1234     protected void readEnclosingMethodAttr(Symbol sym) {
1235         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1236         // remove sym from it&#39;s current owners scope and place it in
1237         // the scope specified by the attribute
1238         sym.owner.members().remove(sym);
1239         ClassSymbol self = (ClassSymbol)sym;
1240         ClassSymbol c = poolReader.getClass(nextChar());
1241         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1242 
1243         if (c.members_field == null || c.kind != TYP)
1244             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1245 
1246         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1247         if (nt != null &amp;&amp; m == null)
1248             throw badEnclosingMethod(self);
1249 
1250         self.name = simpleBinaryName(self.flatname, c.flatname) ;
1251         self.owner = m != null ? m : c;
1252         if (self.name.isEmpty())
1253             self.fullname = names.empty;
1254         else
1255             self.fullname = ClassSymbol.formFullName(self.name, self.owner);
1256 
1257         if (m != null) {
1258             ((ClassType)sym.type).setEnclosingType(m.type);
1259         } else if ((self.flags_field &amp; STATIC) == 0) {
1260             ((ClassType)sym.type).setEnclosingType(c.type);
1261         } else {
1262             ((ClassType)sym.type).setEnclosingType(Type.noType);
1263         }
1264         enterTypevars(self, self.type);
1265         if (!missingTypeVariables.isEmpty()) {
1266             ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();
1267             for (Type typevar : missingTypeVariables) {
1268                 typeVars.append(findTypeVar(typevar.tsym.name));
1269             }
1270             foundTypeVariables = typeVars.toList();
1271         } else {
1272             foundTypeVariables = List.nil();
1273         }
1274     }
1275 
1276     // See java.lang.Class
1277     private Name simpleBinaryName(Name self, Name enclosing) {
1278         if (!self.startsWith(enclosing)) {
1279             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1280         }
1281 
1282         String simpleBinaryName = self.toString().substring(enclosing.toString().length());
1283         if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
1284             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1285         int index = 1;
1286         while (index &lt; simpleBinaryName.length() &amp;&amp;
1287                isAsciiDigit(simpleBinaryName.charAt(index)))
1288             index++;
1289         return names.fromString(simpleBinaryName.substring(index));
1290     }
1291 
1292     private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
1293         if (nt == null)
1294             return null;
1295 
1296         MethodType type = nt.type.asMethodType();
1297 
1298         for (Symbol sym : scope.getSymbolsByName(nt.name)) {
1299             if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
1300                 return (MethodSymbol)sym;
1301         }
1302 
1303         if (nt.name != names.init)
1304             // not a constructor
1305             return null;
1306         if ((flags &amp; INTERFACE) != 0)
1307             // no enclosing instance
1308             return null;
1309         if (nt.type.getParameterTypes().isEmpty())
1310             // no parameters
1311             return null;
1312 
1313         // A constructor of an inner class.
1314         // Remove the first argument (the enclosing instance)
1315         nt = new NameAndType(nt.name, new MethodType(nt.type.getParameterTypes().tail,
1316                                  nt.type.getReturnType(),
1317                                  nt.type.getThrownTypes(),
1318                                  syms.methodClass));
1319         // Try searching again
1320         return findMethod(nt, scope, flags);
1321     }
1322 
1323     /** Similar to Types.isSameType but avoids completion */
1324     private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {
1325         List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())
1326             .prepend(types.erasure(mt1.getReturnType()));
1327         List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());
1328         while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {
1329             if (types1.head.tsym != types2.head.tsym)
1330                 return false;
1331             types1 = types1.tail;
1332             types2 = types2.tail;
1333         }
1334         return types1.isEmpty() &amp;&amp; types2.isEmpty();
1335     }
1336 
1337     /**
1338      * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
1339      * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
1340      */
1341     private static boolean isAsciiDigit(char c) {
1342         return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
1343     }
1344 
1345     /** Read member attributes.
1346      */
1347     void readMemberAttrs(Symbol sym) {
1348         readAttrs(sym, AttributeKind.MEMBER);
1349     }
1350 
1351     void readAttrs(Symbol sym, AttributeKind kind) {
1352         char ac = nextChar();
1353         for (int i = 0; i &lt; ac; i++) {
1354             Name attrName = poolReader.getName(nextChar());
1355             int attrLen = nextInt();
1356             AttributeReader r = attributeReaders.get(attrName);
1357             if (r != null &amp;&amp; r.accepts(kind))
1358                 r.read(sym, attrLen);
1359             else  {
1360                 bp = bp + attrLen;
1361             }
1362         }
1363     }
1364 
1365     private boolean readingClassAttr = false;
1366     private List&lt;Type&gt; missingTypeVariables = List.nil();
1367     private List&lt;Type&gt; foundTypeVariables = List.nil();
1368 
1369     /** Read class attributes.
1370      */
1371     void readClassAttrs(ClassSymbol c) {
1372         readAttrs(c, AttributeKind.CLASS);
1373     }
1374 
1375     /** Read code block.
1376      */
1377     Code readCode(Symbol owner) {
1378         nextChar(); // max_stack
1379         nextChar(); // max_locals
1380         final int  code_length = nextInt();
1381         bp += code_length;
1382         final char exception_table_length = nextChar();
1383         bp += exception_table_length * 8;
1384         readMemberAttrs(owner);
1385         return null;
1386     }
1387 
1388 /************************************************************************
1389  * Reading Java-language annotations
1390  ***********************************************************************/
1391 
1392     /**
1393      * Save annotations.
1394      */
1395     List&lt;CompoundAnnotationProxy&gt; readAnnotations() {
1396         int numAttributes = nextChar();
1397         ListBuffer&lt;CompoundAnnotationProxy&gt; annotations = new ListBuffer&lt;&gt;();
1398         for (int i = 0; i &lt; numAttributes; i++) {
1399             annotations.append(readCompoundAnnotation());
1400         }
1401         return annotations.toList();
1402     }
1403 
1404     /** Attach annotations.
1405      */
1406     void attachAnnotations(final Symbol sym) {
1407         attachAnnotations(sym, readAnnotations());
1408     }
1409 
1410     /**
1411      * Attach annotations.
1412      */
1413     void attachAnnotations(final Symbol sym, List&lt;CompoundAnnotationProxy&gt; annotations) {
1414         if (annotations.isEmpty()) {
1415             return;
1416         }
1417         ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1418         for (CompoundAnnotationProxy proxy : annotations) {
1419             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1420                 sym.flags_field |= PROPRIETARY;
1421             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1422                 if (profile != Profile.DEFAULT) {
1423                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1424                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1425                             Attribute.Constant c = (Attribute.Constant)v.snd;
1426                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1427                                 sym.flags_field |= NOT_IN_PROFILE;
1428                             }
1429                         }
1430                     }
1431                 }
1432             } else {
1433                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1434                     target = proxy;
1435                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1436                     repeatable = proxy;
1437                 } else if (allowValueBasedClasses &amp;&amp; sym.kind == TYP &amp;&amp; proxy.type.tsym == syms.valueBasedType.tsym) {
1438                     sym.flags_field |= VALUEBASED;
1439                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1440                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1441                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1442                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1443                     sym.flags_field |= PREVIEW_API;
1444                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1445                 }
1446                 proxies.append(proxy);
1447             }
1448         }
1449         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1450     }
1451     //where:
1452         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1453             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1454                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1455                     Attribute.Constant c = (Attribute.Constant)v.snd;
1456                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1457                         sym.flags_field |= flag;
1458                     }
1459                 }
1460             }
1461         }
1462 
1463     /** Read parameter annotations.
1464      */
1465     void readParameterAnnotations(Symbol meth) {
1466         int numParameters = buf.getByte(bp++) &amp; 0xFF;
1467         if (parameterAnnotations == null) {
1468             parameterAnnotations = new ParameterAnnotations[numParameters];
1469         } else if (parameterAnnotations.length != numParameters) {
1470             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
1471         }
1472         for (int pnum = 0; pnum &lt; numParameters; pnum++) {
1473             if (parameterAnnotations[pnum] == null) {
1474                 parameterAnnotations[pnum] = new ParameterAnnotations();
1475             }
1476             parameterAnnotations[pnum].add(readAnnotations());
1477         }
1478     }
1479 
1480     void attachTypeAnnotations(final Symbol sym) {
1481         int numAttributes = nextChar();
1482         if (numAttributes != 0) {
1483             ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1484             for (int i = 0; i &lt; numAttributes; i++)
1485                 proxies.append(readTypeAnnotation());
1486             annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));
1487         }
1488     }
1489 
1490     /** Attach the default value for an annotation element.
1491      */
1492     void attachAnnotationDefault(final Symbol sym) {
1493         final MethodSymbol meth = (MethodSymbol)sym; // only on methods
1494         final Attribute value = readAttributeValue();
1495 
1496         // The default value is set later during annotation. It might
1497         // be the case that the Symbol sym is annotated _after_ the
1498         // repeating instances that depend on this default value,
1499         // because of this we set an interim value that tells us this
1500         // element (most likely) has a default.
1501         //
1502         // Set interim value for now, reset just before we do this
1503         // properly at annotate time.
1504         meth.defaultValue = value;
1505         annotate.normal(new AnnotationDefaultCompleter(meth, value));
1506     }
1507 
1508     Type readTypeOrClassSymbol(int i) {
1509         // support preliminary jsr175-format class files
1510         if (poolReader.hasTag(i, CONSTANT_Class))
1511             return poolReader.getClass(i).type;
1512         return readTypeToProxy(i);
1513     }
1514     Type readTypeToProxy(int i) {
1515         if (currentModule.module_info == currentOwner) {
1516             return new ProxyType(i);
1517         } else {
1518             return poolReader.getType(i);
1519         }
1520     }
1521 
1522     CompoundAnnotationProxy readCompoundAnnotation() {
1523         Type t;
1524         if (currentModule.module_info == currentOwner) {
1525             int cpIndex = nextChar();
1526             t = new ProxyType(cpIndex);
1527         } else {
1528             t = readTypeOrClassSymbol(nextChar());
1529         }
1530         int numFields = nextChar();
1531         ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
1532         for (int i=0; i&lt;numFields; i++) {
1533             Name name = poolReader.getName(nextChar());
1534             Attribute value = readAttributeValue();
1535             pairs.append(new Pair&lt;&gt;(name, value));
1536         }
1537         return new CompoundAnnotationProxy(t, pairs.toList());
1538     }
1539 
1540     TypeAnnotationProxy readTypeAnnotation() {
1541         TypeAnnotationPosition position = readPosition();
1542         CompoundAnnotationProxy proxy = readCompoundAnnotation();
1543 
1544         return new TypeAnnotationProxy(proxy, position);
1545     }
1546 
1547     TypeAnnotationPosition readPosition() {
1548         int tag = nextByte(); // TargetType tag is a byte
1549 
1550         if (!TargetType.isValidTargetTypeValue(tag))
1551             throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
1552 
1553         TargetType type = TargetType.fromTargetTypeValue(tag);
1554 
1555         switch (type) {
1556         // instanceof
1557         case INSTANCEOF: {
1558             final int offset = nextChar();
1559             final TypeAnnotationPosition position =
1560                 TypeAnnotationPosition.instanceOf(readTypePath());
1561             position.offset = offset;
1562             return position;
1563         }
1564         // new expression
1565         case NEW: {
1566             final int offset = nextChar();
1567             final TypeAnnotationPosition position =
1568                 TypeAnnotationPosition.newObj(readTypePath());
1569             position.offset = offset;
1570             return position;
1571         }
1572         // constructor/method reference receiver
1573         case CONSTRUCTOR_REFERENCE: {
1574             final int offset = nextChar();
1575             final TypeAnnotationPosition position =
1576                 TypeAnnotationPosition.constructorRef(readTypePath());
1577             position.offset = offset;
1578             return position;
1579         }
1580         case METHOD_REFERENCE: {
1581             final int offset = nextChar();
1582             final TypeAnnotationPosition position =
1583                 TypeAnnotationPosition.methodRef(readTypePath());
1584             position.offset = offset;
1585             return position;
1586         }
1587         // local variable
1588         case LOCAL_VARIABLE: {
1589             final int table_length = nextChar();
1590             final int[] newLvarOffset = new int[table_length];
1591             final int[] newLvarLength = new int[table_length];
1592             final int[] newLvarIndex = new int[table_length];
1593 
1594             for (int i = 0; i &lt; table_length; ++i) {
1595                 newLvarOffset[i] = nextChar();
1596                 newLvarLength[i] = nextChar();
1597                 newLvarIndex[i] = nextChar();
1598             }
1599 
1600             final TypeAnnotationPosition position =
1601                     TypeAnnotationPosition.localVariable(readTypePath());
1602             position.lvarOffset = newLvarOffset;
1603             position.lvarLength = newLvarLength;
1604             position.lvarIndex = newLvarIndex;
1605             return position;
1606         }
1607         // resource variable
1608         case RESOURCE_VARIABLE: {
1609             final int table_length = nextChar();
1610             final int[] newLvarOffset = new int[table_length];
1611             final int[] newLvarLength = new int[table_length];
1612             final int[] newLvarIndex = new int[table_length];
1613 
1614             for (int i = 0; i &lt; table_length; ++i) {
1615                 newLvarOffset[i] = nextChar();
1616                 newLvarLength[i] = nextChar();
1617                 newLvarIndex[i] = nextChar();
1618             }
1619 
1620             final TypeAnnotationPosition position =
1621                     TypeAnnotationPosition.resourceVariable(readTypePath());
1622             position.lvarOffset = newLvarOffset;
1623             position.lvarLength = newLvarLength;
1624             position.lvarIndex = newLvarIndex;
1625             return position;
1626         }
1627         // exception parameter
1628         case EXCEPTION_PARAMETER: {
1629             final int exception_index = nextChar();
1630             final TypeAnnotationPosition position =
1631                 TypeAnnotationPosition.exceptionParameter(readTypePath());
1632             position.setExceptionIndex(exception_index);
1633             return position;
1634         }
1635         // method receiver
1636         case METHOD_RECEIVER:
1637             return TypeAnnotationPosition.methodReceiver(readTypePath());
1638         // type parameter
1639         case CLASS_TYPE_PARAMETER: {
1640             final int parameter_index = nextByte();
1641             return TypeAnnotationPosition
1642                 .typeParameter(readTypePath(), parameter_index);
1643         }
1644         case METHOD_TYPE_PARAMETER: {
1645             final int parameter_index = nextByte();
1646             return TypeAnnotationPosition
1647                 .methodTypeParameter(readTypePath(), parameter_index);
1648         }
1649         // type parameter bound
1650         case CLASS_TYPE_PARAMETER_BOUND: {
1651             final int parameter_index = nextByte();
1652             final int bound_index = nextByte();
1653             return TypeAnnotationPosition
1654                 .typeParameterBound(readTypePath(), parameter_index,
1655                                     bound_index);
1656         }
1657         case METHOD_TYPE_PARAMETER_BOUND: {
1658             final int parameter_index = nextByte();
1659             final int bound_index = nextByte();
1660             return TypeAnnotationPosition
1661                 .methodTypeParameterBound(readTypePath(), parameter_index,
1662                                           bound_index);
1663         }
1664         // class extends or implements clause
1665         case CLASS_EXTENDS: {
1666             final int type_index = nextChar();
1667             return TypeAnnotationPosition.classExtends(readTypePath(),
1668                                                        type_index);
1669         }
1670         // throws
1671         case THROWS: {
1672             final int type_index = nextChar();
1673             return TypeAnnotationPosition.methodThrows(readTypePath(),
1674                                                        type_index);
1675         }
1676         // method parameter
1677         case METHOD_FORMAL_PARAMETER: {
1678             final int parameter_index = nextByte();
1679             return TypeAnnotationPosition.methodParameter(readTypePath(),
1680                                                           parameter_index);
1681         }
1682         // type cast
1683         case CAST: {
1684             final int offset = nextChar();
1685             final int type_index = nextByte();
1686             final TypeAnnotationPosition position =
1687                 TypeAnnotationPosition.typeCast(readTypePath(), type_index);
1688             position.offset = offset;
1689             return position;
1690         }
1691         // method/constructor/reference type argument
1692         case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: {
1693             final int offset = nextChar();
1694             final int type_index = nextByte();
1695             final TypeAnnotationPosition position = TypeAnnotationPosition
1696                 .constructorInvocationTypeArg(readTypePath(), type_index);
1697             position.offset = offset;
1698             return position;
1699         }
1700         case METHOD_INVOCATION_TYPE_ARGUMENT: {
1701             final int offset = nextChar();
1702             final int type_index = nextByte();
1703             final TypeAnnotationPosition position = TypeAnnotationPosition
1704                 .methodInvocationTypeArg(readTypePath(), type_index);
1705             position.offset = offset;
1706             return position;
1707         }
1708         case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: {
1709             final int offset = nextChar();
1710             final int type_index = nextByte();
1711             final TypeAnnotationPosition position = TypeAnnotationPosition
1712                 .constructorRefTypeArg(readTypePath(), type_index);
1713             position.offset = offset;
1714             return position;
1715         }
1716         case METHOD_REFERENCE_TYPE_ARGUMENT: {
1717             final int offset = nextChar();
1718             final int type_index = nextByte();
1719             final TypeAnnotationPosition position = TypeAnnotationPosition
1720                 .methodRefTypeArg(readTypePath(), type_index);
1721             position.offset = offset;
1722             return position;
1723         }
1724         // We don&#39;t need to worry about these
1725         case METHOD_RETURN:
1726             return TypeAnnotationPosition.methodReturn(readTypePath());
1727         case FIELD:
1728             return TypeAnnotationPosition.field(readTypePath());
1729         case UNKNOWN:
1730             throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
1731         default:
1732             throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);
1733         }
1734     }
1735 
1736     List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
1737         int len = nextByte();
1738         ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();
1739         for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)
1740             loc = loc.append(nextByte());
1741 
1742         return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
1743 
1744     }
1745 
1746     /**
1747      * Helper function to read an optional pool entry (with given function); this is used while parsing
1748      * InnerClasses and EnclosingMethod attributes, as well as when parsing supertype descriptor,
1749      * as per JVMS.
1750      */
1751     &lt;Z&gt; Z optPoolEntry(int index, IntFunction&lt;Z&gt; poolFunc, Z defaultValue) {
1752         return (index == 0) ?
1753                 defaultValue :
1754                 poolFunc.apply(index);
1755     }
1756 
1757     Attribute readAttributeValue() {
1758         char c = (char) buf.getByte(bp++);
1759         switch (c) {
1760         case &#39;B&#39;:
1761             return new Attribute.Constant(syms.byteType, poolReader.getConstant(nextChar()));
1762         case &#39;C&#39;:
1763             return new Attribute.Constant(syms.charType, poolReader.getConstant(nextChar()));
1764         case &#39;D&#39;:
1765             return new Attribute.Constant(syms.doubleType, poolReader.getConstant(nextChar()));
1766         case &#39;F&#39;:
1767             return new Attribute.Constant(syms.floatType, poolReader.getConstant(nextChar()));
1768         case &#39;I&#39;:
1769             return new Attribute.Constant(syms.intType, poolReader.getConstant(nextChar()));
1770         case &#39;J&#39;:
1771             return new Attribute.Constant(syms.longType, poolReader.getConstant(nextChar()));
1772         case &#39;S&#39;:
1773             return new Attribute.Constant(syms.shortType, poolReader.getConstant(nextChar()));
1774         case &#39;Z&#39;:
1775             return new Attribute.Constant(syms.booleanType, poolReader.getConstant(nextChar()));
1776         case &#39;s&#39;:
1777             return new Attribute.Constant(syms.stringType, poolReader.getName(nextChar()).toString());
1778         case &#39;e&#39;:
1779             return new EnumAttributeProxy(readTypeToProxy(nextChar()), poolReader.getName(nextChar()));
1780         case &#39;c&#39;:
1781             return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
1782         case &#39;[&#39;: {
1783             int n = nextChar();
1784             ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
1785             for (int i=0; i&lt;n; i++)
1786                 l.append(readAttributeValue());
1787             return new ArrayAttributeProxy(l.toList());
1788         }
1789         case &#39;@&#39;:
1790             return readCompoundAnnotation();
1791         default:
1792             throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);
1793         }
1794     }
1795 
1796     interface ProxyVisitor extends Attribute.Visitor {
1797         void visitEnumAttributeProxy(EnumAttributeProxy proxy);
1798         void visitClassAttributeProxy(ClassAttributeProxy proxy);
1799         void visitArrayAttributeProxy(ArrayAttributeProxy proxy);
1800         void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy);
1801     }
1802 
1803     static class EnumAttributeProxy extends Attribute {
1804         Type enumType;
1805         Name enumerator;
1806         public EnumAttributeProxy(Type enumType, Name enumerator) {
1807             super(null);
1808             this.enumType = enumType;
1809             this.enumerator = enumerator;
1810         }
1811         public void accept(Visitor v) { ((ProxyVisitor)v).visitEnumAttributeProxy(this); }
1812         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1813         public String toString() {
1814             return &quot;/*proxy enum*/&quot; + enumType + &quot;.&quot; + enumerator;
1815         }
1816     }
1817 
1818     static class ClassAttributeProxy extends Attribute {
1819         Type classType;
1820         public ClassAttributeProxy(Type classType) {
1821             super(null);
1822             this.classType = classType;
1823         }
1824         public void accept(Visitor v) { ((ProxyVisitor)v).visitClassAttributeProxy(this); }
1825         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1826         public String toString() {
1827             return &quot;/*proxy class*/&quot; + classType + &quot;.class&quot;;
1828         }
1829     }
1830 
1831     static class ArrayAttributeProxy extends Attribute {
1832         List&lt;Attribute&gt; values;
1833         ArrayAttributeProxy(List&lt;Attribute&gt; values) {
1834             super(null);
1835             this.values = values;
1836         }
1837         public void accept(Visitor v) { ((ProxyVisitor)v).visitArrayAttributeProxy(this); }
1838         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1839         public String toString() {
1840             return &quot;{&quot; + values + &quot;}&quot;;
1841         }
1842     }
1843 
1844     /** A temporary proxy representing a compound attribute.
1845      */
1846     static class CompoundAnnotationProxy extends Attribute {
1847         final List&lt;Pair&lt;Name,Attribute&gt;&gt; values;
1848         public CompoundAnnotationProxy(Type type,
1849                                       List&lt;Pair&lt;Name,Attribute&gt;&gt; values) {
1850             super(type);
1851             this.values = values;
1852         }
1853         public void accept(Visitor v) { ((ProxyVisitor)v).visitCompoundAnnotationProxy(this); }
1854         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1855         public String toString() {
1856             StringBuilder buf = new StringBuilder();
1857             buf.append(&quot;@&quot;);
1858             buf.append(type.tsym.getQualifiedName());
1859             buf.append(&quot;/*proxy*/{&quot;);
1860             boolean first = true;
1861             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; v = values;
1862                  v.nonEmpty(); v = v.tail) {
1863                 Pair&lt;Name,Attribute&gt; value = v.head;
1864                 if (!first) buf.append(&quot;,&quot;);
1865                 first = false;
1866                 buf.append(value.fst);
1867                 buf.append(&quot;=&quot;);
1868                 buf.append(value.snd);
1869             }
1870             buf.append(&quot;}&quot;);
1871             return buf.toString();
1872         }
1873     }
1874 
1875     /** A temporary proxy representing a type annotation.
1876      */
1877     static class TypeAnnotationProxy {
1878         final CompoundAnnotationProxy compound;
1879         final TypeAnnotationPosition position;
1880         public TypeAnnotationProxy(CompoundAnnotationProxy compound,
1881                 TypeAnnotationPosition position) {
1882             this.compound = compound;
1883             this.position = position;
1884         }
1885     }
1886 
1887     class AnnotationDeproxy implements ProxyVisitor {
1888         private ClassSymbol requestingOwner;
1889 
1890         AnnotationDeproxy(ClassSymbol owner) {
1891             this.requestingOwner = owner;
1892         }
1893 
1894         List&lt;Attribute.Compound&gt; deproxyCompoundList(List&lt;CompoundAnnotationProxy&gt; pl) {
1895             // also must fill in types!!!!
1896             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
1897             for (List&lt;CompoundAnnotationProxy&gt; l = pl; l.nonEmpty(); l=l.tail) {
1898                 buf.append(deproxyCompound(l.head));
1899             }
1900             return buf.toList();
1901         }
1902 
1903         Attribute.Compound deproxyCompound(CompoundAnnotationProxy a) {
1904             Type annotationType = resolvePossibleProxyType(a.type);
1905             ListBuffer&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; buf = new ListBuffer&lt;&gt;();
1906             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; l = a.values;
1907                  l.nonEmpty();
1908                  l = l.tail) {
1909                 MethodSymbol meth = findAccessMethod(annotationType, l.head.fst);
1910                 buf.append(new Pair&lt;&gt;(meth, deproxy(meth.type.getReturnType(), l.head.snd)));
1911             }
1912             return new Attribute.Compound(annotationType, buf.toList());
1913         }
1914 
1915         MethodSymbol findAccessMethod(Type container, Name name) {
1916             CompletionFailure failure = null;
1917             try {
1918                 for (Symbol sym : container.tsym.members().getSymbolsByName(name)) {
1919                     if (sym.kind == MTH &amp;&amp; sym.type.getParameterTypes().length() == 0)
1920                         return (MethodSymbol) sym;
1921                 }
1922             } catch (CompletionFailure ex) {
1923                 failure = ex;
1924             }
1925             // The method wasn&#39;t found: emit a warning and recover
1926             JavaFileObject prevSource = log.useSource(requestingOwner.classfile);
1927             try {
1928                 if (lintClassfile) {
1929                     if (failure == null) {
1930                         log.warning(Warnings.AnnotationMethodNotFound(container, name));
1931                     } else {
1932                         log.warning(Warnings.AnnotationMethodNotFoundReason(container,
1933                                                                             name,
1934                                                                             failure.getDetailValue()));//diagnostic, if present
1935                     }
1936                 }
1937             } finally {
1938                 log.useSource(prevSource);
1939             }
1940             // Construct a new method type and symbol.  Use bottom
1941             // type (typeof null) as return type because this type is
1942             // a subtype of all reference types and can be converted
1943             // to primitive types by unboxing.
1944             MethodType mt = new MethodType(List.nil(),
1945                                            syms.botType,
1946                                            List.nil(),
1947                                            syms.methodClass);
1948             return new MethodSymbol(PUBLIC | ABSTRACT, name, mt, container.tsym);
1949         }
1950 
1951         Attribute result;
1952         Type type;
1953         Attribute deproxy(Type t, Attribute a) {
1954             Type oldType = type;
1955             try {
1956                 type = t;
1957                 a.accept(this);
1958                 return result;
1959             } finally {
1960                 type = oldType;
1961             }
1962         }
1963 
1964         // implement Attribute.Visitor below
1965 
1966         public void visitConstant(Attribute.Constant value) {
1967             // assert value.type == type;
1968             result = value;
1969         }
1970 
1971         public void visitClass(Attribute.Class clazz) {
1972             result = clazz;
1973         }
1974 
1975         public void visitEnum(Attribute.Enum e) {
1976             throw new AssertionError(); // shouldn&#39;t happen
1977         }
1978 
1979         public void visitCompound(Attribute.Compound compound) {
1980             throw new AssertionError(); // shouldn&#39;t happen
1981         }
1982 
1983         public void visitArray(Attribute.Array array) {
1984             throw new AssertionError(); // shouldn&#39;t happen
1985         }
1986 
1987         public void visitError(Attribute.Error e) {
1988             throw new AssertionError(); // shouldn&#39;t happen
1989         }
1990 
1991         public void visitEnumAttributeProxy(EnumAttributeProxy proxy) {
1992             // type.tsym.flatName() should == proxy.enumFlatName
1993             Type enumType = resolvePossibleProxyType(proxy.enumType);
1994             TypeSymbol enumTypeSym = enumType.tsym;
1995             VarSymbol enumerator = null;
1996             CompletionFailure failure = null;
1997             try {
1998                 for (Symbol sym : enumTypeSym.members().getSymbolsByName(proxy.enumerator)) {
1999                     if (sym.kind == VAR) {
2000                         enumerator = (VarSymbol)sym;
2001                         break;
2002                     }
2003                 }
2004             }
2005             catch (CompletionFailure ex) {
2006                 failure = ex;
2007             }
2008             if (enumerator == null) {
2009                 if (failure != null) {
2010                     log.warning(Warnings.UnknownEnumConstantReason(currentClassFile,
2011                                                                    enumTypeSym,
2012                                                                    proxy.enumerator,
2013                                                                    failure.getDiagnostic()));
2014                 } else {
2015                     log.warning(Warnings.UnknownEnumConstant(currentClassFile,
2016                                                              enumTypeSym,
2017                                                              proxy.enumerator));
2018                 }
2019                 result = new Attribute.Enum(enumTypeSym.type,
2020                         new VarSymbol(0, proxy.enumerator, syms.botType, enumTypeSym));
2021             } else {
2022                 result = new Attribute.Enum(enumTypeSym.type, enumerator);
2023             }
2024         }
2025 
2026         @Override
2027         public void visitClassAttributeProxy(ClassAttributeProxy proxy) {
2028             Type classType = resolvePossibleProxyType(proxy.classType);
2029             result = new Attribute.Class(types, classType);
2030         }
2031 
2032         public void visitArrayAttributeProxy(ArrayAttributeProxy proxy) {
2033             int length = proxy.values.length();
2034             Attribute[] ats = new Attribute[length];
2035             Type elemtype = types.elemtype(type);
2036             int i = 0;
2037             for (List&lt;Attribute&gt; p = proxy.values; p.nonEmpty(); p = p.tail) {
2038                 ats[i++] = deproxy(elemtype, p.head);
2039             }
2040             result = new Attribute.Array(type, ats);
2041         }
2042 
2043         public void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy) {
2044             result = deproxyCompound(proxy);
2045         }
2046 
2047         Type resolvePossibleProxyType(Type t) {
2048             if (t instanceof ProxyType) {
2049                 Assert.check(requestingOwner.owner.kind == MDL);
2050                 ModuleSymbol prevCurrentModule = currentModule;
2051                 currentModule = (ModuleSymbol) requestingOwner.owner;
2052                 try {
2053                     return ((ProxyType) t).resolve();
2054                 } finally {
2055                     currentModule = prevCurrentModule;
2056                 }
2057             } else {
2058                 return t;
2059             }
2060         }
2061     }
2062 
2063     class AnnotationDefaultCompleter extends AnnotationDeproxy implements Runnable {
2064         final MethodSymbol sym;
2065         final Attribute value;
2066         final JavaFileObject classFile = currentClassFile;
2067 
2068         AnnotationDefaultCompleter(MethodSymbol sym, Attribute value) {
2069             super(currentOwner.kind == MTH
2070                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2071             this.sym = sym;
2072             this.value = value;
2073         }
2074 
2075         @Override
2076         public void run() {
2077             JavaFileObject previousClassFile = currentClassFile;
2078             try {
2079                 // Reset the interim value set earlier in
2080                 // attachAnnotationDefault().
2081                 sym.defaultValue = null;
2082                 currentClassFile = classFile;
2083                 sym.defaultValue = deproxy(sym.type.getReturnType(), value);
2084             } finally {
2085                 currentClassFile = previousClassFile;
2086             }
2087         }
2088 
2089         @Override
2090         public String toString() {
2091             return &quot; ClassReader store default for &quot; + sym.owner + &quot;.&quot; + sym + &quot; is &quot; + value;
2092         }
2093     }
2094 
2095     class AnnotationCompleter extends AnnotationDeproxy implements Runnable {
2096         final Symbol sym;
2097         final List&lt;CompoundAnnotationProxy&gt; l;
2098         final JavaFileObject classFile;
2099 
2100         AnnotationCompleter(Symbol sym, List&lt;CompoundAnnotationProxy&gt; l) {
2101             super(currentOwner.kind == MTH
2102                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2103             if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
2104                 this.sym = sym.owner;
2105             } else {
2106                 this.sym = sym;
2107             }
2108             this.l = l;
2109             this.classFile = currentClassFile;
2110         }
2111 
2112         @Override
2113         public void run() {
2114             JavaFileObject previousClassFile = currentClassFile;
2115             try {
2116                 currentClassFile = classFile;
2117                 List&lt;Attribute.Compound&gt; newList = deproxyCompoundList(l);
2118                 for (Attribute.Compound attr : newList) {
2119                     if (attr.type.tsym == syms.deprecatedType.tsym) {
2120                         sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
2121                         Attribute forRemoval = attr.member(names.forRemoval);
2122                         if (forRemoval instanceof Attribute.Constant) {
2123                             Attribute.Constant c = (Attribute.Constant) forRemoval;
2124                             if (c.type == syms.booleanType &amp;&amp; ((Integer) c.value) != 0) {
2125                                 sym.flags_field |= DEPRECATED_REMOVAL;
2126                             }
2127                         }
2128                     }
2129                 }
2130                 if (sym.annotationsPendingCompletion()) {
2131                     sym.setDeclarationAttributes(newList);
2132                 } else {
2133                     sym.appendAttributes(newList);
2134                 }
2135             } finally {
2136                 currentClassFile = previousClassFile;
2137             }
2138         }
2139 
2140         @Override
2141         public String toString() {
2142             return &quot; ClassReader annotate &quot; + sym.owner + &quot;.&quot; + sym + &quot; with &quot; + l;
2143         }
2144     }
2145 
2146     class TypeAnnotationCompleter extends AnnotationCompleter {
2147 
2148         List&lt;TypeAnnotationProxy&gt; proxies;
2149 
2150         TypeAnnotationCompleter(Symbol sym,
2151                 List&lt;TypeAnnotationProxy&gt; proxies) {
2152             super(sym, List.nil());
2153             this.proxies = proxies;
2154         }
2155 
2156         List&lt;Attribute.TypeCompound&gt; deproxyTypeCompoundList(List&lt;TypeAnnotationProxy&gt; proxies) {
2157             ListBuffer&lt;Attribute.TypeCompound&gt; buf = new ListBuffer&lt;&gt;();
2158             for (TypeAnnotationProxy proxy: proxies) {
2159                 Attribute.Compound compound = deproxyCompound(proxy.compound);
2160                 Attribute.TypeCompound typeCompound = new Attribute.TypeCompound(compound, proxy.position);
2161                 buf.add(typeCompound);
2162             }
2163             return buf.toList();
2164         }
2165 
2166         @Override
2167         public void run() {
2168             JavaFileObject previousClassFile = currentClassFile;
2169             try {
2170                 currentClassFile = classFile;
2171                 List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
2172                 sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
2173             } finally {
2174                 currentClassFile = previousClassFile;
2175             }
2176         }
2177     }
2178 
2179 
2180 /************************************************************************
2181  * Reading Symbols
2182  ***********************************************************************/
2183 
2184     /** Read a field.
2185      */
2186     VarSymbol readField() {
2187         long flags = adjustFieldFlags(nextChar());
2188         Name name = poolReader.getName(nextChar());
2189         Type type = poolReader.getType(nextChar());
2190         VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
2191         readMemberAttrs(v);
2192         return v;
2193     }
2194 
2195     /** Read a method.
2196      */
2197     MethodSymbol readMethod() {
2198         long flags = adjustMethodFlags(nextChar());
2199         Name name = poolReader.getName(nextChar());
2200         Type type = poolReader.getType(nextChar());
2201         if (currentOwner.isInterface() &amp;&amp;
2202                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2203             if (majorVersion &gt; Version.V52.major ||
2204                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2205                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2206                     currentOwner.flags_field |= DEFAULT;
2207                     flags |= DEFAULT | ABSTRACT;
2208                 }
2209             } else {
2210                 //protect against ill-formed classfiles
2211                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2212                                    Integer.toString(majorVersion),
2213                                    Integer.toString(minorVersion));
2214             }
2215         }
2216         if (name == names.init &amp;&amp; ((flags &amp; STATIC) != 0)) {
2217             flags &amp;= ~STATIC;
2218             type = new MethodType(type.getParameterTypes(),
2219                     syms.voidType,
2220                     type.getThrownTypes(),
2221                     syms.methodClass);
2222         }
2223         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2224             // Sometimes anonymous classes don&#39;t have an outer
2225             // instance, however, there is no reliable way to tell so
2226             // we never strip this$n
2227             // ditto for local classes. Local classes that have an enclosing method set
2228             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2229             // enclosing method (i.e. from initializers) will pass that check.
2230             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2231             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2232                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2233                                       type.getReturnType(),
2234                                       type.getThrownTypes(),
2235                                       syms.methodClass);
2236         }
2237         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2238         if (types.isSignaturePolymorphic(m)) {
2239             m.flags_field |= SIGNATURE_POLYMORPHIC;
2240         }
2241         if (saveParameterNames)
2242             initParameterNames(m);
2243         Symbol prevOwner = currentOwner;
2244         currentOwner = m;
2245         try {
2246             readMemberAttrs(m);
2247         } finally {
2248             currentOwner = prevOwner;
2249         }
2250         setParameters(m, type);
2251 
2252         if ((flags &amp; VARARGS) != 0) {
2253             final Type last = type.getParameterTypes().last();
2254             if (last == null || !last.hasTag(ARRAY)) {
2255                 m.flags_field &amp;= ~VARARGS;
2256                 throw badClassFile(&quot;malformed.vararg.method&quot;, m);
2257             }
2258         }
2259 
2260         return m;
2261     }
2262 
2263     private List&lt;Type&gt; adjustMethodParams(long flags, List&lt;Type&gt; args) {
2264         if (args.isEmpty()) {
2265             return args;
2266         }
2267         boolean isVarargs = (flags &amp; VARARGS) != 0;
2268         if (isVarargs) {
2269             Type varargsElem = args.last();
2270             ListBuffer&lt;Type&gt; adjustedArgs = new ListBuffer&lt;&gt;();
2271             for (Type t : args) {
2272                 adjustedArgs.append(t != varargsElem ?
2273                     t :
2274                     ((ArrayType)t).makeVarargs());
2275             }
2276             args = adjustedArgs.toList();
2277         }
2278         return args.tail;
2279     }
2280 
2281     /**
2282      * Init the parameter names array.
2283      * Parameter names are currently inferred from the names in the
2284      * LocalVariableTable attributes of a Code attribute.
2285      * (Note: this means parameter names are currently not available for
2286      * methods without a Code attribute.)
2287      * This method initializes an array in which to store the name indexes
2288      * of parameter names found in LocalVariableTable attributes. It is
2289      * slightly supersized to allow for additional slots with a start_pc of 0.
2290      */
2291     void initParameterNames(MethodSymbol sym) {
2292         // make allowance for synthetic parameters.
2293         final int excessSlots = 4;
2294         int expectedParameterSlots =
2295                 Code.width(sym.type.getParameterTypes()) + excessSlots;
2296         if (parameterNameIndices == null
2297                 || parameterNameIndices.length &lt; expectedParameterSlots) {
2298             parameterNameIndices = new int[expectedParameterSlots];
2299         } else
2300             Arrays.fill(parameterNameIndices, 0);
2301         haveParameterNameIndices = false;
2302         sawMethodParameters = false;
2303     }
2304 
2305     /**
2306      * Set the parameters for a method symbol, including any names and
2307      * annotations that were read.
2308      *
2309      * &lt;p&gt;The type of the symbol may have changed while reading the
2310      * method attributes (see the Signature attribute). This may be
2311      * because of generic information or because anonymous synthetic
2312      * parameters were added.   The original type (as read from the
2313      * method descriptor) is used to help guess the existence of
2314      * anonymous synthetic parameters.
2315      */
2316     void setParameters(MethodSymbol sym, Type jvmType) {
2317         // If we get parameter names from MethodParameters, then we
2318         // don&#39;t need to skip.
2319         int firstParam = 0;
2320         if (!sawMethodParameters) {
2321             firstParam = ((sym.flags() &amp; STATIC) == 0) ? 1 : 0;
2322             // the code in readMethod may have skipped the first
2323             // parameter when setting up the MethodType. If so, we
2324             // make a corresponding allowance here for the position of
2325             // the first parameter.  Note that this assumes the
2326             // skipped parameter has a width of 1 -- i.e. it is not
2327             // a double width type (long or double.)
2328             if (sym.name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2329                 // Sometimes anonymous classes don&#39;t have an outer
2330                 // instance, however, there is no reliable way to tell so
2331                 // we never strip this$n
2332                 if (!currentOwner.name.isEmpty())
2333                     firstParam += 1;
2334             }
2335 
2336             if (sym.type != jvmType) {
2337                 // reading the method attributes has caused the
2338                 // symbol&#39;s type to be changed. (i.e. the Signature
2339                 // attribute.)  This may happen if there are hidden
2340                 // (synthetic) parameters in the descriptor, but not
2341                 // in the Signature.  The position of these hidden
2342                 // parameters is unspecified; for now, assume they are
2343                 // at the beginning, and so skip over them. The
2344                 // primary case for this is two hidden parameters
2345                 // passed into Enum constructors.
2346                 int skip = Code.width(jvmType.getParameterTypes())
2347                         - Code.width(sym.type.getParameterTypes());
2348                 firstParam += skip;
2349             }
2350         }
2351         Set&lt;Name&gt; paramNames = new HashSet&lt;&gt;();
2352         ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
2353         int nameIndex = firstParam;
2354         int annotationIndex = 0;
2355         for (Type t: sym.type.getParameterTypes()) {
2356             VarSymbol param = parameter(nameIndex, t, sym, paramNames);
2357             params.append(param);
2358             if (parameterAnnotations != null) {
2359                 ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
2360                 if (annotations != null &amp;&amp; annotations.proxies != null
2361                         &amp;&amp; !annotations.proxies.isEmpty()) {
2362                     annotate.normal(new AnnotationCompleter(param, annotations.proxies));
2363                 }
2364             }
2365             nameIndex += sawMethodParameters ? 1 : Code.width(t);
2366             annotationIndex++;
2367         }
2368         if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
2369             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
2370         }
2371         Assert.checkNull(sym.params);
2372         sym.params = params.toList();
2373         parameterAnnotations = null;
2374         parameterNameIndices = null;
2375     }
2376 
2377 
2378     // Returns the name for the parameter at position &#39;index&#39;, either using
2379     // names read from the MethodParameters, or by synthesizing a name that
2380     // is not on the &#39;exclude&#39; list.
2381     private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set&lt;Name&gt; exclude) {
2382         long flags = PARAMETER;
2383         Name argName;
2384         if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
2385                 &amp;&amp; parameterNameIndices[index] != 0) {
2386             argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);
2387             flags |= NAME_FILLED;
2388         } else {
2389             String prefix = &quot;arg&quot;;
2390             while (true) {
2391                 argName = names.fromString(prefix + exclude.size());
2392                 if (!exclude.contains(argName))
2393                     break;
2394                 prefix += &quot;$&quot;;
2395             }
2396         }
2397         exclude.add(argName);
2398         return new ParamSymbol(flags, argName, t, owner);
2399     }
2400 
2401     /**
2402      * skip n bytes
2403      */
2404     void skipBytes(int n) {
2405         bp = bp + n;
2406     }
2407 
2408     /** Skip a field or method
2409      */
2410     void skipMember() {
2411         bp = bp + 6;
2412         char ac = nextChar();
2413         for (int i = 0; i &lt; ac; i++) {
2414             bp = bp + 2;
2415             int attrLen = nextInt();
2416             bp = bp + attrLen;
2417         }
2418     }
2419 
2420     void skipInnerClasses() {
2421         int n = nextChar();
2422         for (int i = 0; i &lt; n; i++) {
2423             nextChar();
2424             nextChar();
2425             nextChar();
2426             nextChar();
2427         }
2428     }
2429 
2430     /** Enter type variables of this classtype and all enclosing ones in
2431      *  `typevars&#39;.
2432      */
2433     protected void enterTypevars(Symbol sym, Type t) {
2434         if (t.getEnclosingType() != null) {
2435             if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
2436                 enterTypevars(sym.owner, t.getEnclosingType());
2437             }
2438         } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
2439             enterTypevars(sym.owner, sym.owner.type);
2440         }
2441         for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
2442             typevars.enter(xs.head.tsym);
2443         }
2444     }
2445 
2446     protected ClassSymbol enterClass(Name name) {
2447         return syms.enterClass(currentModule, name);
2448     }
2449 
2450     protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
2451         return syms.enterClass(currentModule, name, owner);
2452     }
2453 
2454     /** Read contents of a given class symbol `c&#39;. Both external and internal
2455      *  versions of an inner class are read.
2456      */
2457     void readClass(ClassSymbol c) {
2458         ClassType ct = (ClassType)c.type;
2459 
2460         // allocate scope for members
2461         c.members_field = WriteableScope.create(c);
2462 
2463         // prepare type variable table
2464         typevars = typevars.dup(currentOwner);
2465         if (ct.getEnclosingType().hasTag(CLASS))
2466             enterTypevars(c.owner, ct.getEnclosingType());
2467 
2468         // read flags, or skip if this is an inner class
2469         long f = nextChar();
2470         long flags = adjustClassFlags(f);
2471         if ((flags &amp; MODULE) == 0) {
2472             if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
2473             // read own class name and check that it matches
2474             currentModule = c.packge().modle;
2475             ClassSymbol self = poolReader.getClass(nextChar());
2476             if (c != self) {
2477                 throw badClassFile(&quot;class.file.wrong.class&quot;,
2478                                    self.flatname);
2479             }
2480         } else {
2481             if (majorVersion &lt; Version.V53.major) {
2482                 throw badClassFile(&quot;anachronistic.module.info&quot;,
2483                         Integer.toString(majorVersion),
2484                         Integer.toString(minorVersion));
2485             }
2486             c.flags_field = flags;
2487             currentModule = (ModuleSymbol) c.owner;
2488             int this_class = nextChar();
2489             // temp, no check on this_class
2490         }
2491 
2492         // class attributes must be read before class
2493         // skip ahead to read class attributes
2494         int startbp = bp;
2495         nextChar();
2496         char interfaceCount = nextChar();
2497         bp += interfaceCount * 2;
2498         char fieldCount = nextChar();
2499         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2500         char methodCount = nextChar();
2501         for (int i = 0; i &lt; methodCount; i++) skipMember();
2502         readClassAttrs(c);
2503 
2504         // reset and read rest of classinfo
2505         bp = startbp;
2506         int n = nextChar();
2507         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2508             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2509         }
2510         if (ct.supertype_field == null)
2511             ct.supertype_field =
2512                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2513         n = nextChar();
2514         List&lt;Type&gt; is = List.nil();
2515         for (int i = 0; i &lt; n; i++) {
2516             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2517             is = is.prepend(_inter);
2518         }
2519         if (ct.interfaces_field == null)
2520             ct.interfaces_field = is.reverse();
2521 
2522         Assert.check(fieldCount == nextChar());
2523         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
2524         Assert.check(methodCount == nextChar());
2525         for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
2526 
2527         typevars = typevars.leave();
2528     }
2529 
2530     /** Read inner class info. For each inner/outer pair allocate a
2531      *  member class.
2532      */
2533     void readInnerClasses(ClassSymbol c) {
2534         int n = nextChar();
2535         for (int i = 0; i &lt; n; i++) {
2536             nextChar(); // skip inner class symbol
2537             int outerIdx = nextChar();
2538             int nameIdx = nextChar();
2539             ClassSymbol outer = optPoolEntry(outerIdx, poolReader::getClass, null);
2540             Name name = optPoolEntry(nameIdx, poolReader::getName, names.empty);
2541             if (name == null) name = names.empty;
2542             long flags = adjustClassFlags(nextChar());
2543             if (outer != null) { // we have a member class
2544                 if (name == names.empty)
2545                     name = names.one;
2546                 ClassSymbol member = enterClass(name, outer);
2547                 if ((flags &amp; STATIC) == 0) {
2548                     ((ClassType)member.type).setEnclosingType(outer.type);
2549                     if (member.erasure_field != null)
2550                         ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));
2551                 }
2552                 if (c == outer) {
2553                     member.flags_field = flags;
2554                     enterMember(c, member);
2555                 }
2556             }
2557         }
2558     }
2559 
2560     /** Read a class definition from the bytes in buf.
2561      */
2562     private void readClassBuffer(ClassSymbol c) throws IOException {
2563         int magic = nextInt();
2564         if (magic != JAVA_MAGIC)
2565             throw badClassFile(&quot;illegal.start.of.class.file&quot;);
2566 
2567         minorVersion = nextChar();
2568         majorVersion = nextChar();
2569         int maxMajor = Version.MAX().major;
2570         int maxMinor = Version.MAX().minor;
2571         if (majorVersion &gt; maxMajor ||
2572             majorVersion * 1000 + minorVersion &lt;
2573             Version.MIN().major * 1000 + Version.MIN().minor) {
2574             if (majorVersion == (maxMajor + 1))
2575                 log.warning(Warnings.BigMajorVersion(currentClassFile,
2576                                                      majorVersion,
2577                                                      maxMajor));
2578             else
2579                 throw badClassFile(&quot;wrong.version&quot;,
2580                                    Integer.toString(majorVersion),
2581                                    Integer.toString(minorVersion),
2582                                    Integer.toString(maxMajor),
2583                                    Integer.toString(maxMinor));
2584         }
2585 
2586         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2587             if (!preview.isEnabled()) {
2588                 log.error(preview.disabledError(currentClassFile, majorVersion));
2589             } else {
2590                 preview.warnPreview(c.classfile, majorVersion);
2591             }
2592         }
2593 
2594         poolReader = new PoolReader(this, names, syms);
2595         bp = poolReader.readPool(buf, bp);
2596         if (signatureBuffer.length &lt; bp) {
2597             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2598             signatureBuffer = new byte[ns];
2599         }
2600         readClass(c);
2601     }
2602 
2603     public void readClassFile(ClassSymbol c) {
2604         currentOwner = c;
2605         currentClassFile = c.classfile;
2606         warnedAttrs.clear();
2607         filling = true;
2608         target = null;
2609         repeatable = null;
2610         try {
2611             bp = 0;
2612             buf.reset();
2613             buf.appendStream(c.classfile.openInputStream());
2614             readClassBuffer(c);
2615             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2616                 List&lt;Type&gt; missing = missingTypeVariables;
2617                 List&lt;Type&gt; found = foundTypeVariables;
2618                 missingTypeVariables = List.nil();
2619                 foundTypeVariables = List.nil();
2620                 interimUses = List.nil();
2621                 interimProvides = List.nil();
2622                 filling = false;
2623                 ClassType ct = (ClassType)currentOwner.type;
2624                 ct.supertype_field =
2625                     types.subst(ct.supertype_field, missing, found);
2626                 ct.interfaces_field =
2627                     types.subst(ct.interfaces_field, missing, found);
2628                 ct.typarams_field =
2629                     types.substBounds(ct.typarams_field, missing, found);
2630                 for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {
2631                     types.head.tsym.type = types.head;
2632                 }
2633             } else if (missingTypeVariables.isEmpty() !=
2634                        foundTypeVariables.isEmpty()) {
2635                 Name name = missingTypeVariables.head.tsym.name;
2636                 throw badClassFile(&quot;undecl.type.var&quot;, name);
2637             }
2638 
2639             if ((c.flags_field &amp; Flags.ANNOTATION) != 0) {
2640                 c.setAnnotationTypeMetadata(new AnnotationTypeMetadata(c, new CompleterDeproxy(c, target, repeatable)));
2641             } else {
2642                 c.setAnnotationTypeMetadata(AnnotationTypeMetadata.notAnAnnotationType());
2643             }
2644 
2645             if (c == currentModule.module_info) {
2646                 if (interimUses.nonEmpty() || interimProvides.nonEmpty()) {
2647                     Assert.check(currentModule.isCompleted());
2648                     currentModule.usesProvidesCompleter =
2649                             new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
2650                 } else {
2651                     currentModule.uses = List.nil();
2652                     currentModule.provides = List.nil();
2653                 }
2654             }
2655         } catch (IOException | ClosedFileSystemException ex) {
2656             throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
2657         } catch (ArrayIndexOutOfBoundsException ex) {
2658             throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
2659         } finally {
2660             interimUses = List.nil();
2661             interimProvides = List.nil();
2662             missingTypeVariables = List.nil();
2663             foundTypeVariables = List.nil();
2664             filling = false;
2665         }
2666     }
2667 
2668     /** We can only read a single class file at a time; this
2669      *  flag keeps track of when we are currently reading a class
2670      *  file.
2671      */
2672     public boolean filling = false;
2673 
2674 /************************************************************************
2675  * Adjusting flags
2676  ***********************************************************************/
2677 
2678     long adjustFieldFlags(long flags) {
2679         return flags;
2680     }
2681 
2682     long adjustMethodFlags(long flags) {
2683         if ((flags &amp; ACC_BRIDGE) != 0) {
2684             flags &amp;= ~ACC_BRIDGE;
2685             flags |= BRIDGE;
2686         }
2687         if ((flags &amp; ACC_VARARGS) != 0) {
2688             flags &amp;= ~ACC_VARARGS;
2689             flags |= VARARGS;
2690         }
2691         return flags;
2692     }
2693 
2694     long adjustClassFlags(long flags) {
2695         if ((flags &amp; ACC_MODULE) != 0) {
2696             flags &amp;= ~ACC_MODULE;
2697             flags |= MODULE;
2698         }
2699         if ((flags &amp; ACC_VALUE) != 0) {
2700             flags &amp;= ~ACC_VALUE;
2701             flags |= allowInlineTypes ? VALUE : allowValueBasedClasses ? VALUEBASED : 0;
2702         }
2703         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2704     }
2705 
2706     /**
2707      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2708      * The attribute is only the last component of the original filename, so is unlikely
2709      * to be valid as is, so operations other than those to access the name throw
2710      * UnsupportedOperationException
2711      */
2712     private static class SourceFileObject implements JavaFileObject {
2713 
2714         /** The file&#39;s name.
2715          */
2716         private final Name name;
2717 
2718         public SourceFileObject(Name name) {
2719             this.name = name;
2720         }
2721 
2722         @Override @DefinedBy(Api.COMPILER)
2723         public URI toUri() {
2724             try {
2725                 return new URI(null, name.toString(), null);
2726             } catch (URISyntaxException e) {
2727                 throw new PathFileObject.CannotCreateUriError(name.toString(), e);
2728             }
2729         }
2730 
2731         @Override @DefinedBy(Api.COMPILER)
2732         public String getName() {
2733             return name.toString();
2734         }
2735 
2736         @Override @DefinedBy(Api.COMPILER)
2737         public JavaFileObject.Kind getKind() {
2738             return BaseFileManager.getKind(getName());
2739         }
2740 
2741         @Override @DefinedBy(Api.COMPILER)
2742         public InputStream openInputStream() {
2743             throw new UnsupportedOperationException();
2744         }
2745 
2746         @Override @DefinedBy(Api.COMPILER)
2747         public OutputStream openOutputStream() {
2748             throw new UnsupportedOperationException();
2749         }
2750 
2751         @Override @DefinedBy(Api.COMPILER)
2752         public CharBuffer getCharContent(boolean ignoreEncodingErrors) {
2753             throw new UnsupportedOperationException();
2754         }
2755 
2756         @Override @DefinedBy(Api.COMPILER)
2757         public Reader openReader(boolean ignoreEncodingErrors) {
2758             throw new UnsupportedOperationException();
2759         }
2760 
2761         @Override @DefinedBy(Api.COMPILER)
2762         public Writer openWriter() {
2763             throw new UnsupportedOperationException();
2764         }
2765 
2766         @Override @DefinedBy(Api.COMPILER)
2767         public long getLastModified() {
2768             throw new UnsupportedOperationException();
2769         }
2770 
2771         @Override @DefinedBy(Api.COMPILER)
2772         public boolean delete() {
2773             throw new UnsupportedOperationException();
2774         }
2775 
2776         @Override @DefinedBy(Api.COMPILER)
2777         public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {
2778             return true; // fail-safe mode
2779         }
2780 
2781         @Override @DefinedBy(Api.COMPILER)
2782         public NestingKind getNestingKind() {
2783             return null;
2784         }
2785 
2786         @Override @DefinedBy(Api.COMPILER)
2787         public Modifier getAccessLevel() {
2788             return null;
2789         }
2790 
2791         /**
2792          * Check if two file objects are equal.
2793          * SourceFileObjects are just placeholder objects for the value of a
2794          * SourceFile attribute, and do not directly represent specific files.
2795          * Two SourceFileObjects are equal if their names are equal.
2796          */
2797         @Override
2798         public boolean equals(Object other) {
2799             if (this == other)
2800                 return true;
2801 
2802             if (!(other instanceof SourceFileObject))
2803                 return false;
2804 
2805             SourceFileObject o = (SourceFileObject) other;
2806             return name.equals(o.name);
2807         }
2808 
2809         @Override
2810         public int hashCode() {
2811             return name.hashCode();
2812         }
2813     }
2814 
2815     private class CompleterDeproxy implements AnnotationTypeCompleter {
2816         ClassSymbol proxyOn;
2817         CompoundAnnotationProxy target;
2818         CompoundAnnotationProxy repeatable;
2819 
2820         public CompleterDeproxy(ClassSymbol c, CompoundAnnotationProxy target,
2821                 CompoundAnnotationProxy repeatable)
2822         {
2823             this.proxyOn = c;
2824             this.target = target;
2825             this.repeatable = repeatable;
2826         }
2827 
2828         @Override
2829         public void complete(ClassSymbol sym) {
2830             Assert.check(proxyOn == sym);
2831             Attribute.Compound theTarget = null, theRepeatable = null;
2832             AnnotationDeproxy deproxy;
2833 
2834             try {
2835                 if (target != null) {
2836                     deproxy = new AnnotationDeproxy(proxyOn);
2837                     theTarget = deproxy.deproxyCompound(target);
2838                 }
2839 
2840                 if (repeatable != null) {
2841                     deproxy = new AnnotationDeproxy(proxyOn);
2842                     theRepeatable = deproxy.deproxyCompound(repeatable);
2843                 }
2844             } catch (Exception e) {
2845                 throw new CompletionFailure(sym,
2846                                             () -&gt; ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),
2847                                             dcfh);
2848             }
2849 
2850             sym.getAnnotationTypeMetadata().setTarget(theTarget);
2851             sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
2852         }
2853     }
2854 
2855     private class ProxyType extends Type {
2856 
2857         private final Name name;
2858 
2859         public ProxyType(int index) {
2860             super(syms.noSymbol, TypeMetadata.EMPTY);
2861             this.name = poolReader.getName(index);
2862         }
2863 
2864         @Override
2865         public TypeTag getTag() {
2866             return TypeTag.NONE;
2867         }
2868 
2869         @Override
2870         public Type cloneWithMetadata(TypeMetadata metadata) {
2871             throw new UnsupportedOperationException();
2872         }
2873 
2874         public Type resolve() {
2875             return name.map(ClassReader.this::sigToType);
2876         }
2877 
2878         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2879         public String toString() {
2880             return &quot;&lt;ProxyType&gt;&quot;;
2881         }
2882 
2883     }
2884 
2885     private static final class InterimUsesDirective {
2886         public final Name service;
2887 
2888         public InterimUsesDirective(Name service) {
2889             this.service = service;
2890         }
2891 
2892     }
2893 
2894     private static final class InterimProvidesDirective {
2895         public final Name service;
2896         public final List&lt;Name&gt; impls;
2897 
2898         public InterimProvidesDirective(Name service, List&lt;Name&gt; impls) {
2899             this.service = service;
2900             this.impls = impls;
2901         }
2902 
2903     }
2904 
2905     private final class UsesProvidesCompleter implements Completer {
2906         private final ModuleSymbol currentModule;
2907         private final List&lt;InterimUsesDirective&gt; interimUsesCopy;
2908         private final List&lt;InterimProvidesDirective&gt; interimProvidesCopy;
2909 
2910         public UsesProvidesCompleter(ModuleSymbol currentModule, List&lt;InterimUsesDirective&gt; interimUsesCopy, List&lt;InterimProvidesDirective&gt; interimProvidesCopy) {
2911             this.currentModule = currentModule;
2912             this.interimUsesCopy = interimUsesCopy;
2913             this.interimProvidesCopy = interimProvidesCopy;
2914         }
2915 
2916         @Override
2917         public void complete(Symbol sym) throws CompletionFailure {
2918             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
2919             directives.addAll(currentModule.directives);
2920             ListBuffer&lt;UsesDirective&gt; uses = new ListBuffer&lt;&gt;();
2921             for (InterimUsesDirective interim : interimUsesCopy) {
2922                 UsesDirective d = new UsesDirective(syms.enterClass(currentModule, interim.service));
2923                 uses.add(d);
2924                 directives.add(d);
2925             }
2926             currentModule.uses = uses.toList();
2927             ListBuffer&lt;ProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
2928             for (InterimProvidesDirective interim : interimProvidesCopy) {
2929                 ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
2930                 for (Name impl : interim.impls) {
2931                     impls.append(syms.enterClass(currentModule, impl));
2932                 }
2933                 ProvidesDirective d = new ProvidesDirective(syms.enterClass(currentModule, interim.service),
2934                                                             impls.toList());
2935                 provides.add(d);
2936                 directives.add(d);
2937             }
2938             currentModule.provides = provides.toList();
2939             currentModule.directives = directives.toList();
2940         }
2941     }
2942 }
    </pre>
  </body>
</html>
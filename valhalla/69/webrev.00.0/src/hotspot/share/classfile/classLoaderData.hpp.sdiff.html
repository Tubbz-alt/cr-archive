<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderData.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
300   void add_class(Klass* k, bool publicize = true);
301   void remove_class(Klass* k);
302   bool contains_klass(Klass* k);
303   void record_dependency(const Klass* to);
304   PackageEntryTable* packages() { return _packages; }
305   ModuleEntry* unnamed_module() { return _unnamed_module; }
306   ModuleEntryTable* modules();
307   bool modules_defined() { return (_modules != NULL); }
308 
309   // Offsets
310   static ByteSize holder_offset()     { return in_ByteSize(offset_of(ClassLoaderData, _holder)); }
311   static ByteSize keep_alive_offset() { return in_ByteSize(offset_of(ClassLoaderData, _keep_alive)); }
312 
313   // Loaded class dictionary
314   Dictionary* dictionary() const { return _dictionary; }
315 
316   void add_to_deallocate_list(Metadata* m);
317 
318   static ClassLoaderData* class_loader_data(oop loader);
319   static ClassLoaderData* class_loader_data_or_null(oop loader);
<span class="line-removed">320   static ClassLoaderData* has_class_mirror_holder_cld(Handle loader);</span>
321 
322   // Returns Klass* of associated class loader, or NULL if associated loader is &#39;bootstrap&#39;.
323   // Also works if unloading.
324   Klass* class_loader_klass() const { return _class_loader_klass; }
325 
326   // Returns the class loader&#39;s explict name as specified during
327   // construction or the class loader&#39;s qualified class name.
328   // Works during unloading.
329   const char* loader_name() const;
330   // Returns the explicitly specified class loader name or NULL.
331   Symbol* name() const { return _name; }
332 
333   // Obtain the class loader&#39;s _name_and_id, works during unloading.
334   const char* loader_name_and_id() const;
335   Symbol* name_and_id() const { return _name_and_id; }
336 
337   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
338 };
339 
340 #endif // SHARE_CLASSFILE_CLASSLOADERDATA_HPP
</pre>
</td>
<td>
<hr />
<pre>
300   void add_class(Klass* k, bool publicize = true);
301   void remove_class(Klass* k);
302   bool contains_klass(Klass* k);
303   void record_dependency(const Klass* to);
304   PackageEntryTable* packages() { return _packages; }
305   ModuleEntry* unnamed_module() { return _unnamed_module; }
306   ModuleEntryTable* modules();
307   bool modules_defined() { return (_modules != NULL); }
308 
309   // Offsets
310   static ByteSize holder_offset()     { return in_ByteSize(offset_of(ClassLoaderData, _holder)); }
311   static ByteSize keep_alive_offset() { return in_ByteSize(offset_of(ClassLoaderData, _keep_alive)); }
312 
313   // Loaded class dictionary
314   Dictionary* dictionary() const { return _dictionary; }
315 
316   void add_to_deallocate_list(Metadata* m);
317 
318   static ClassLoaderData* class_loader_data(oop loader);
319   static ClassLoaderData* class_loader_data_or_null(oop loader);

320 
321   // Returns Klass* of associated class loader, or NULL if associated loader is &#39;bootstrap&#39;.
322   // Also works if unloading.
323   Klass* class_loader_klass() const { return _class_loader_klass; }
324 
325   // Returns the class loader&#39;s explict name as specified during
326   // construction or the class loader&#39;s qualified class name.
327   // Works during unloading.
328   const char* loader_name() const;
329   // Returns the explicitly specified class loader name or NULL.
330   Symbol* name() const { return _name; }
331 
332   // Obtain the class loader&#39;s _name_and_id, works during unloading.
333   const char* loader_name_and_id() const;
334   Symbol* name_and_id() const { return _name_and_id; }
335 
336   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
337 };
338 
339 #endif // SHARE_CLASSFILE_CLASSLOADERDATA_HPP
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1528   java_class-&gt;obj_field_put(_ref_type_mirror_offset, mirror);
1529 }
1530 
1531 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1532   // This should be improved by adding a field at the Java level or by
1533   // introducing a new VM klass (see comment in ClassFileParser)
1534   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1535   if (type != T_VOID) {
1536     Klass* aklass = Universe::typeArrayKlassObj(type);
1537     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1538     release_set_array_klass(java_class, aklass);
1539   }
1540 #ifdef ASSERT
1541   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1542   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1543 #endif
1544   return java_class;
1545 }
1546 
1547 
<span class="line-removed">1548 Klass* java_lang_Class::as_Klass(oop java_class) {</span>
<span class="line-removed">1549   //%note memory_2</span>
<span class="line-removed">1550   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);</span>
<span class="line-removed">1551   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));</span>
<span class="line-removed">1552   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);</span>
<span class="line-removed">1553   return k;</span>
<span class="line-removed">1554 }</span>
<span class="line-removed">1555 </span>
1556 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1557   //%note memory_2
1558   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1559   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1560   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1561   return k;
1562 }
1563 
1564 
1565 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1566   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1567   java_class-&gt;metadata_field_put(_klass_offset, klass);
1568 }
1569 
1570 
1571 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1572   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1573   Symbol* name = NULL;
1574   bool is_instance = false;
1575   bool is_value = false;
</pre>
<hr />
<pre>
4859   return base-&gt;obj_field(_static_FALSE_offset);
4860 }
4861 
4862 Symbol* java_lang_Boolean::symbol() {
4863   return vmSymbols::java_lang_Boolean();
4864 }
4865 
4866 #if INCLUDE_CDS
4867 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4868   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4869 }
4870 #endif
4871 #undef BOOLEAN_CACHE_FIELDS_DO
4872 
4873 jboolean java_lang_Boolean::value(oop obj) {
4874    jvalue v;
4875    java_lang_boxing_object::get_value(obj, &amp;v);
4876    return v.z;
4877 }
4878 
<span class="line-modified">4879 static int member_offset(int hardcoded_offset) {</span>
<span class="line-modified">4880   return (hardcoded_offset * heapOopSize) + instanceOopDesc::base_offset_in_bytes();</span>


4881 }
4882 
4883 #define RECORDCOMPONENT_FIELDS_DO(macro) \
4884   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
4885   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \
4886   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \
4887   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
4888   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
4889   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
4890   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
4891 
4892 // Support for java_lang_reflect_RecordComponent
4893 void java_lang_reflect_RecordComponent::compute_offsets() {
4894   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4895   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4896 }
4897 
4898 #if INCLUDE_CDS
4899 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4900   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
</pre>
<hr />
<pre>
4918 }
4919 
4920 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
4921   element-&gt;obj_field_put(signature_offset, value);
4922 }
4923 
4924 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
4925   element-&gt;obj_field_put(annotations_offset, value);
4926 }
4927 
4928 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
4929   element-&gt;obj_field_put(typeAnnotations_offset, value);
4930 }
4931 
4932 // Compute hard-coded offsets
4933 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4934 // are not available to determine the offset_of_static_fields.
4935 void JavaClasses::compute_hard_coded_offsets() {
4936 
4937   // java_lang_boxing_object
<span class="line-modified">4938   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);</span>
<span class="line-modified">4939   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);</span>
4940 
4941   // java_lang_ref_Reference
<span class="line-modified">4942   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);</span>
<span class="line-modified">4943   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);</span>
<span class="line-modified">4944   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);</span>
<span class="line-modified">4945   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);</span>
4946 }
4947 
4948 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4949 
4950 // Compute non-hard-coded field offsets of all the classes in this file
4951 void JavaClasses::compute_offsets() {
4952   if (UseSharedSpaces) {
4953     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4954                                                          JvmtiExport::has_early_class_hook_env()),
4955                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4956     // None of the classes used by the rest of this function can be replaced by
4957     // JMVTI ClassFileLoadHook.
4958     // We are safe to use the archived offsets, which have already been restored
4959     // by JavaClasses::serialize_offsets, without computing the offsets again.
4960     return;
4961   }
4962 
4963   // We have already called the compute_offsets() of the
4964   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4965   // earlier inside SystemDictionary::resolve_well_known_classes()
</pre>
</td>
<td>
<hr />
<pre>
1528   java_class-&gt;obj_field_put(_ref_type_mirror_offset, mirror);
1529 }
1530 
1531 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1532   // This should be improved by adding a field at the Java level or by
1533   // introducing a new VM klass (see comment in ClassFileParser)
1534   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1535   if (type != T_VOID) {
1536     Klass* aklass = Universe::typeArrayKlassObj(type);
1537     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1538     release_set_array_klass(java_class, aklass);
1539   }
1540 #ifdef ASSERT
1541   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1542   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1543 #endif
1544   return java_class;
1545 }
1546 
1547 








1548 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1549   //%note memory_2
1550   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1551   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1552   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1553   return k;
1554 }
1555 
1556 
1557 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1558   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1559   java_class-&gt;metadata_field_put(_klass_offset, klass);
1560 }
1561 
1562 
1563 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1564   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1565   Symbol* name = NULL;
1566   bool is_instance = false;
1567   bool is_value = false;
</pre>
<hr />
<pre>
4851   return base-&gt;obj_field(_static_FALSE_offset);
4852 }
4853 
4854 Symbol* java_lang_Boolean::symbol() {
4855   return vmSymbols::java_lang_Boolean();
4856 }
4857 
4858 #if INCLUDE_CDS
4859 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4860   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4861 }
4862 #endif
4863 #undef BOOLEAN_CACHE_FIELDS_DO
4864 
4865 jboolean java_lang_Boolean::value(oop obj) {
4866    jvalue v;
4867    java_lang_boxing_object::get_value(obj, &amp;v);
4868    return v.z;
4869 }
4870 
<span class="line-modified">4871 // Use with care. This function makes a lot of assumptions about the contents of the object.</span>
<span class="line-modified">4872 // So naturally, only hardcode offsets if you know what you are doing.</span>
<span class="line-added">4873 static int member_offset(int hardcoded_offset, int elementSize) {</span>
<span class="line-added">4874   return align_up((hardcoded_offset * elementSize) + instanceOopDesc::base_offset_in_bytes(), elementSize);</span>
4875 }
4876 
4877 #define RECORDCOMPONENT_FIELDS_DO(macro) \
4878   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
4879   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \
4880   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \
4881   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
4882   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
4883   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
4884   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
4885 
4886 // Support for java_lang_reflect_RecordComponent
4887 void java_lang_reflect_RecordComponent::compute_offsets() {
4888   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4889   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4890 }
4891 
4892 #if INCLUDE_CDS
4893 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4894   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
</pre>
<hr />
<pre>
4912 }
4913 
4914 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
4915   element-&gt;obj_field_put(signature_offset, value);
4916 }
4917 
4918 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
4919   element-&gt;obj_field_put(annotations_offset, value);
4920 }
4921 
4922 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
4923   element-&gt;obj_field_put(typeAnnotations_offset, value);
4924 }
4925 
4926 // Compute hard-coded offsets
4927 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4928 // are not available to determine the offset_of_static_fields.
4929 void JavaClasses::compute_hard_coded_offsets() {
4930 
4931   // java_lang_boxing_object
<span class="line-modified">4932   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset, BytesPerInt);</span>
<span class="line-modified">4933   java_lang_boxing_object::long_value_offset = member_offset(java_lang_boxing_object::hc_value_offset, BytesPerLong);</span>
4934 
4935   // java_lang_ref_Reference
<span class="line-modified">4936   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset, heapOopSize);</span>
<span class="line-modified">4937   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset, heapOopSize);</span>
<span class="line-modified">4938   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset, heapOopSize);</span>
<span class="line-modified">4939   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset, heapOopSize);</span>
4940 }
4941 
4942 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4943 
4944 // Compute non-hard-coded field offsets of all the classes in this file
4945 void JavaClasses::compute_offsets() {
4946   if (UseSharedSpaces) {
4947     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4948                                                          JvmtiExport::has_early_class_hook_env()),
4949                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4950     // None of the classes used by the rest of this function can be replaced by
4951     // JMVTI ClassFileLoadHook.
4952     // We are safe to use the archived offsets, which have already been restored
4953     // by JavaClasses::serialize_offsets, without computing the offsets again.
4954     return;
4955   }
4956 
4957   // We have already called the compute_offsets() of the
4958   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4959   // earlier inside SystemDictionary::resolve_well_known_classes()
</pre>
</td>
</tr>
</table>
<center><a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
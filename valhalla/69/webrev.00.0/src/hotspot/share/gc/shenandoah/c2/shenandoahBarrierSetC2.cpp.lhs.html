<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed">  30 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;</span>
  31 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  33 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  34 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
<a name="2" id="anc2"></a>
  35 #include &quot;opto/arraycopynode.hpp&quot;
  36 #include &quot;opto/escape.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;
  38 #include &quot;opto/idealKit.hpp&quot;
  39 #include &quot;opto/macro.hpp&quot;
  40 #include &quot;opto/movenode.hpp&quot;
  41 #include &quot;opto/narrowptrnode.hpp&quot;
  42 #include &quot;opto/rootnode.hpp&quot;
  43 #include &quot;opto/runtime.hpp&quot;
  44 
  45 ShenandoahBarrierSetC2* ShenandoahBarrierSetC2::bsc2() {
  46   return reinterpret_cast&lt;ShenandoahBarrierSetC2*&gt;(BarrierSet::barrier_set()-&gt;barrier_set_c2());
  47 }
  48 
  49 ShenandoahBarrierSetC2State::ShenandoahBarrierSetC2State(Arena* comp_arena)
  50   : _enqueue_barriers(new (comp_arena) GrowableArray&lt;ShenandoahEnqueueBarrierNode*&gt;(comp_arena, 8,  0, NULL)),
  51     _load_reference_barriers(new (comp_arena) GrowableArray&lt;ShenandoahLoadReferenceBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {
  52 }
  53 
  54 int ShenandoahBarrierSetC2State::enqueue_barriers_count() const {
  55   return _enqueue_barriers-&gt;length();
  56 }
  57 
  58 ShenandoahEnqueueBarrierNode* ShenandoahBarrierSetC2State::enqueue_barrier(int idx) const {
  59   return _enqueue_barriers-&gt;at(idx);
  60 }
  61 
  62 void ShenandoahBarrierSetC2State::add_enqueue_barrier(ShenandoahEnqueueBarrierNode * n) {
  63   assert(!_enqueue_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);
  64   _enqueue_barriers-&gt;append(n);
  65 }
  66 
  67 void ShenandoahBarrierSetC2State::remove_enqueue_barrier(ShenandoahEnqueueBarrierNode * n) {
  68   if (_enqueue_barriers-&gt;contains(n)) {
  69     _enqueue_barriers-&gt;remove(n);
  70   }
  71 }
  72 
  73 int ShenandoahBarrierSetC2State::load_reference_barriers_count() const {
  74   return _load_reference_barriers-&gt;length();
  75 }
  76 
  77 ShenandoahLoadReferenceBarrierNode* ShenandoahBarrierSetC2State::load_reference_barrier(int idx) const {
  78   return _load_reference_barriers-&gt;at(idx);
  79 }
  80 
  81 void ShenandoahBarrierSetC2State::add_load_reference_barrier(ShenandoahLoadReferenceBarrierNode * n) {
  82   assert(!_load_reference_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);
  83   _load_reference_barriers-&gt;append(n);
  84 }
  85 
  86 void ShenandoahBarrierSetC2State::remove_load_reference_barrier(ShenandoahLoadReferenceBarrierNode * n) {
  87   if (_load_reference_barriers-&gt;contains(n)) {
  88     _load_reference_barriers-&gt;remove(n);
  89   }
  90 }
  91 
  92 Node* ShenandoahBarrierSetC2::shenandoah_storeval_barrier(GraphKit* kit, Node* obj) const {
  93   if (ShenandoahStoreValEnqueueBarrier) {
  94     obj = shenandoah_enqueue_barrier(kit, obj);
  95   }
  96   return obj;
  97 }
  98 
  99 #define __ kit-&gt;
 100 
 101 bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,
 102                                                          BasicType bt, uint adr_idx) const {
 103   intptr_t offset = 0;
 104   Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);
 105   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, phase);
 106 
 107   if (offset == Type::OffsetBot) {
 108     return false; // cannot unalias unless there are precise offsets
 109   }
 110 
 111   if (alloc == NULL) {
 112     return false; // No allocation found
 113   }
 114 
 115   intptr_t size_in_bytes = type2aelembytes(bt);
 116 
 117   Node* mem = __ memory(adr_idx); // start searching here...
 118 
 119   for (int cnt = 0; cnt &lt; 50; cnt++) {
 120 
 121     if (mem-&gt;is_Store()) {
 122 
 123       Node* st_adr = mem-&gt;in(MemNode::Address);
 124       intptr_t st_offset = 0;
 125       Node* st_base = AddPNode::Ideal_base_and_offset(st_adr, phase, st_offset);
 126 
 127       if (st_base == NULL) {
 128         break; // inscrutable pointer
 129       }
 130 
 131       // Break we have found a store with same base and offset as ours so break
 132       if (st_base == base &amp;&amp; st_offset == offset) {
 133         break;
 134       }
 135 
 136       if (st_offset != offset &amp;&amp; st_offset != Type::OffsetBot) {
 137         const int MAX_STORE = BytesPerLong;
 138         if (st_offset &gt;= offset + size_in_bytes ||
 139             st_offset &lt;= offset - MAX_STORE ||
 140             st_offset &lt;= offset - mem-&gt;as_Store()-&gt;memory_size()) {
 141           // Success:  The offsets are provably independent.
 142           // (You may ask, why not just test st_offset != offset and be done?
 143           // The answer is that stores of different sizes can co-exist
 144           // in the same sequence of RawMem effects.  We sometimes initialize
 145           // a whole &#39;tile&#39; of array elements with a single jint or jlong.)
 146           mem = mem-&gt;in(MemNode::Memory);
 147           continue; // advance through independent store memory
 148         }
 149       }
 150 
 151       if (st_base != base
 152           &amp;&amp; MemNode::detect_ptr_independence(base, alloc, st_base,
 153                                               AllocateNode::Ideal_allocation(st_base, phase),
 154                                               phase)) {
 155         // Success:  The bases are provably independent.
 156         mem = mem-&gt;in(MemNode::Memory);
 157         continue; // advance through independent store memory
 158       }
 159     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Initialize()) {
 160 
 161       InitializeNode* st_init = mem-&gt;in(0)-&gt;as_Initialize();
 162       AllocateNode* st_alloc = st_init-&gt;allocation();
 163 
 164       // Make sure that we are looking at the same allocation site.
 165       // The alloc variable is guaranteed to not be null here from earlier check.
 166       if (alloc == st_alloc) {
 167         // Check that the initialization is storing NULL so that no previous store
 168         // has been moved up and directly write a reference
 169         Node* captured_store = st_init-&gt;find_captured_store(offset,
 170                                                             type2aelembytes(T_OBJECT),
 171                                                             phase);
 172         if (captured_store == NULL || captured_store == st_init-&gt;zero_memory()) {
 173           return true;
 174         }
 175       }
 176     }
 177 
 178     // Unless there is an explicit &#39;continue&#39;, we must bail out here,
 179     // because &#39;mem&#39; is an inscrutable memory state (e.g., a call).
 180     break;
 181   }
 182 
 183   return false;
 184 }
 185 
 186 #undef __
 187 #define __ ideal.
 188 
 189 void ShenandoahBarrierSetC2::satb_write_barrier_pre(GraphKit* kit,
 190                                                     bool do_load,
 191                                                     Node* obj,
 192                                                     Node* adr,
 193                                                     uint alias_idx,
 194                                                     Node* val,
 195                                                     const TypeOopPtr* val_type,
 196                                                     Node* pre_val,
 197                                                     BasicType bt) const {
 198   // Some sanity checks
 199   // Note: val is unused in this routine.
 200 
 201   if (do_load) {
 202     // We need to generate the load of the previous value
 203     assert(obj != NULL, &quot;must have a base&quot;);
 204     assert(adr != NULL, &quot;where are loading from?&quot;);
 205     assert(pre_val == NULL, &quot;loaded already?&quot;);
 206     assert(val_type != NULL, &quot;need a type&quot;);
 207 
 208     if (ReduceInitialCardMarks
 209         &amp;&amp; satb_can_remove_pre_barrier(kit, &amp;kit-&gt;gvn(), adr, bt, alias_idx)) {
 210       return;
 211     }
 212 
 213   } else {
 214     // In this case both val_type and alias_idx are unused.
 215     assert(pre_val != NULL, &quot;must be loaded already&quot;);
 216     // Nothing to be done if pre_val is null.
 217     if (pre_val-&gt;bottom_type() == TypePtr::NULL_PTR) return;
 218     assert(pre_val-&gt;bottom_type()-&gt;basic_type() == T_OBJECT, &quot;or we shouldn&#39;t be here&quot;);
 219   }
 220   assert(bt == T_OBJECT, &quot;or we shouldn&#39;t be here&quot;);
 221 
 222   IdealKit ideal(kit, true);
 223 
 224   Node* tls = __ thread(); // ThreadLocalStorage
 225 
 226   Node* no_base = __ top();
 227   Node* zero  = __ ConI(0);
 228   Node* zeroX = __ ConX(0);
 229 
 230   float likely  = PROB_LIKELY(0.999);
 231   float unlikely  = PROB_UNLIKELY(0.999);
 232 
 233   // Offsets into the thread
 234   const int index_offset   = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());
 235   const int buffer_offset  = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
 236 
 237   // Now the actual pointers into the thread
 238   Node* buffer_adr  = __ AddP(no_base, tls, __ ConX(buffer_offset));
 239   Node* index_adr   = __ AddP(no_base, tls, __ ConX(index_offset));
 240 
 241   // Now some of the values
 242   Node* marking;
 243   Node* gc_state = __ AddP(no_base, tls, __ ConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset())));
 244   Node* ld = __ load(__ ctrl(), gc_state, TypeInt::BYTE, T_BYTE, Compile::AliasIdxRaw);
 245   marking = __ AndI(ld, __ ConI(ShenandoahHeap::MARKING));
 246   assert(ShenandoahBarrierC2Support::is_gc_state_load(ld), &quot;Should match the shape&quot;);
 247 
 248   // if (!marking)
 249   __ if_then(marking, BoolTest::ne, zero, unlikely); {
 250     BasicType index_bt = TypeX_X-&gt;basic_type();
 251     assert(sizeof(size_t) == type2aelembytes(index_bt), &quot;Loading G1 SATBMarkQueue::_index with wrong size.&quot;);
 252     Node* index   = __ load(__ ctrl(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);
 253 
 254     if (do_load) {
 255       // load original value
 256       // alias_idx correct??
 257       pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx);
 258     }
 259 
 260     // if (pre_val != NULL)
 261     __ if_then(pre_val, BoolTest::ne, kit-&gt;null()); {
 262       Node* buffer  = __ load(__ ctrl(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);
 263 
 264       // is the queue for this thread full?
 265       __ if_then(index, BoolTest::ne, zeroX, likely); {
 266 
 267         // decrement the index
 268         Node* next_index = kit-&gt;gvn().transform(new SubXNode(index, __ ConX(sizeof(intptr_t))));
 269 
 270         // Now get the buffer location we will log the previous value into and store it
 271         Node *log_addr = __ AddP(no_base, buffer, next_index);
 272         __ store(__ ctrl(), log_addr, pre_val, T_OBJECT, Compile::AliasIdxRaw, MemNode::unordered);
 273         // update the index
 274         __ store(__ ctrl(), index_adr, next_index, index_bt, Compile::AliasIdxRaw, MemNode::unordered);
 275 
 276       } __ else_(); {
 277 
 278         // logging buffer is full, call the runtime
 279         const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type();
 280         __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, pre_val, tls);
 281       } __ end_if();  // (!index)
 282     } __ end_if();  // (pre_val != NULL)
 283   } __ end_if();  // (!marking)
 284 
 285   // Final sync IdealKit and GraphKit.
 286   kit-&gt;final_sync(ideal);
 287 
 288   if (ShenandoahSATBBarrier &amp;&amp; adr != NULL) {
 289     Node* c = kit-&gt;control();
 290     Node* call = c-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(0);
 291     assert(is_shenandoah_wb_pre_call(call), &quot;shenandoah_wb_pre call expected&quot;);
 292     call-&gt;add_req(adr);
 293   }
 294 }
 295 
 296 bool ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(Node* call) {
 297   return call-&gt;is_CallLeaf() &amp;&amp;
 298          call-&gt;as_CallLeaf()-&gt;entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry);
 299 }
 300 
 301 bool ShenandoahBarrierSetC2::is_shenandoah_lrb_call(Node* call) {
 302   if (!call-&gt;is_CallLeaf()) {
 303     return false;
 304   }
 305 
 306   address entry_point = call-&gt;as_CallLeaf()-&gt;entry_point();
 307   return (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier)) ||
 308          (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow)) ||
 309          (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));
 310 }
 311 
 312 bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseTransform *phase, Node* n) {
 313   if (n-&gt;Opcode() != Op_If) {
 314     return false;
 315   }
 316 
 317   Node* bol = n-&gt;in(1);
 318   assert(bol-&gt;is_Bool(), &quot;&quot;);
 319   Node* cmpx = bol-&gt;in(1);
 320   if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 321       cmpx-&gt;is_Cmp() &amp;&amp; cmpx-&gt;in(2) == phase-&gt;intcon(0) &amp;&amp;
 322       is_shenandoah_state_load(cmpx-&gt;in(1)-&gt;in(1)) &amp;&amp;
 323       cmpx-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp;
 324       cmpx-&gt;in(1)-&gt;in(2) == phase-&gt;intcon(ShenandoahHeap::MARKING)) {
 325     return true;
 326   }
 327 
 328   return false;
 329 }
 330 
 331 bool ShenandoahBarrierSetC2::is_shenandoah_state_load(Node* n) {
 332   if (!n-&gt;is_Load()) return false;
 333   const int state_offset = in_bytes(ShenandoahThreadLocalData::gc_state_offset());
 334   return n-&gt;in(2)-&gt;is_AddP() &amp;&amp; n-&gt;in(2)-&gt;in(2)-&gt;Opcode() == Op_ThreadLocal
 335          &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;is_Con()
 336          &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() == state_offset;
 337 }
 338 
 339 void ShenandoahBarrierSetC2::shenandoah_write_barrier_pre(GraphKit* kit,
 340                                                           bool do_load,
 341                                                           Node* obj,
 342                                                           Node* adr,
 343                                                           uint alias_idx,
 344                                                           Node* val,
 345                                                           const TypeOopPtr* val_type,
 346                                                           Node* pre_val,
 347                                                           BasicType bt) const {
 348   if (ShenandoahSATBBarrier) {
 349     IdealKit ideal(kit);
 350     kit-&gt;sync_kit(ideal);
 351 
 352     satb_write_barrier_pre(kit, do_load, obj, adr, alias_idx, val, val_type, pre_val, bt);
 353 
 354     ideal.sync_kit(kit);
 355     kit-&gt;final_sync(ideal);
 356   }
 357 }
 358 
 359 Node* ShenandoahBarrierSetC2::shenandoah_enqueue_barrier(GraphKit* kit, Node* pre_val) const {
 360   return kit-&gt;gvn().transform(new ShenandoahEnqueueBarrierNode(pre_val));
 361 }
 362 
 363 // Helper that guards and inserts a pre-barrier.
 364 void ShenandoahBarrierSetC2::insert_pre_barrier(GraphKit* kit, Node* base_oop, Node* offset,
 365                                                 Node* pre_val, bool need_mem_bar) const {
 366   // We could be accessing the referent field of a reference object. If so, when G1
 367   // is enabled, we need to log the value in the referent field in an SATB buffer.
 368   // This routine performs some compile time filters and generates suitable
 369   // runtime filters that guard the pre-barrier code.
 370   // Also add memory barrier for non volatile load from the referent field
 371   // to prevent commoning of loads across safepoint.
 372 
 373   // Some compile time checks.
 374 
 375   // If offset is a constant, is it java_lang_ref_Reference::_reference_offset?
 376   const TypeX* otype = offset-&gt;find_intptr_t_type();
 377   if (otype != NULL &amp;&amp; otype-&gt;is_con() &amp;&amp;
 378       otype-&gt;get_con() != java_lang_ref_Reference::referent_offset) {
 379     // Constant offset but not the reference_offset so just return
 380     return;
 381   }
 382 
 383   // We only need to generate the runtime guards for instances.
 384   const TypeOopPtr* btype = base_oop-&gt;bottom_type()-&gt;isa_oopptr();
 385   if (btype != NULL) {
 386     if (btype-&gt;isa_aryptr()) {
 387       // Array type so nothing to do
 388       return;
 389     }
 390 
 391     const TypeInstPtr* itype = btype-&gt;isa_instptr();
 392     if (itype != NULL) {
 393       // Can the klass of base_oop be statically determined to be
 394       // _not_ a sub-class of Reference and _not_ Object?
 395       ciKlass* klass = itype-&gt;klass();
 396       if ( klass-&gt;is_loaded() &amp;&amp;
 397           !klass-&gt;is_subtype_of(kit-&gt;env()-&gt;Reference_klass()) &amp;&amp;
 398           !kit-&gt;env()-&gt;Object_klass()-&gt;is_subtype_of(klass)) {
 399         return;
 400       }
 401     }
 402   }
 403 
 404   // The compile time filters did not reject base_oop/offset so
 405   // we need to generate the following runtime filters
 406   //
 407   // if (offset == java_lang_ref_Reference::_reference_offset) {
 408   //   if (instance_of(base, java.lang.ref.Reference)) {
 409   //     pre_barrier(_, pre_val, ...);
 410   //   }
 411   // }
 412 
 413   float likely   = PROB_LIKELY(  0.999);
 414   float unlikely = PROB_UNLIKELY(0.999);
 415 
 416   IdealKit ideal(kit);
 417 
 418   Node* referent_off = __ ConX(java_lang_ref_Reference::referent_offset);
 419 
 420   __ if_then(offset, BoolTest::eq, referent_off, unlikely); {
 421       // Update graphKit memory and control from IdealKit.
 422       kit-&gt;sync_kit(ideal);
 423 
 424       Node* ref_klass_con = kit-&gt;makecon(TypeKlassPtr::make(kit-&gt;env()-&gt;Reference_klass()));
 425       Node* is_instof = kit-&gt;gen_instanceof(base_oop, ref_klass_con);
 426 
 427       // Update IdealKit memory and control from graphKit.
 428       __ sync_kit(kit);
 429 
 430       Node* one = __ ConI(1);
 431       // is_instof == 0 if base_oop == NULL
 432       __ if_then(is_instof, BoolTest::eq, one, unlikely); {
 433 
 434         // Update graphKit from IdeakKit.
 435         kit-&gt;sync_kit(ideal);
 436 
 437         // Use the pre-barrier to record the value in the referent field
 438         satb_write_barrier_pre(kit, false /* do_load */,
 439                                NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,
 440                                pre_val /* pre_val */,
 441                                T_OBJECT);
 442         if (need_mem_bar) {
 443           // Add memory barrier to prevent commoning reads from this field
 444           // across safepoint since GC can change its value.
 445           kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);
 446         }
 447         // Update IdealKit from graphKit.
 448         __ sync_kit(kit);
 449 
 450       } __ end_if(); // _ref_type != ref_none
 451   } __ end_if(); // offset == referent_offset
 452 
 453   // Final sync IdealKit and GraphKit.
 454   kit-&gt;final_sync(ideal);
 455 }
 456 
 457 #undef __
 458 
 459 const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type() {
 460   const Type **fields = TypeTuple::fields(2);
 461   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
 462   fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; // thread
 463   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 464 
 465   // create result type (range)
 466   fields = TypeTuple::fields(0);
 467   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 468 
 469   return TypeFunc::make(domain, range);
 470 }
 471 
 472 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {
 473   const Type **fields = TypeTuple::fields(1);
 474   fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; // src oop
 475   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 476 
 477   // create result type (range)
 478   fields = TypeTuple::fields(0);
 479   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 480 
 481   return TypeFunc::make(domain, range);
 482 }
 483 
 484 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type() {
 485   const Type **fields = TypeTuple::fields(2);
 486   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
 487   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;   // original load address
 488 
 489   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 490 
 491   // create result type (range)
 492   fields = TypeTuple::fields(1);
 493   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;
 494   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 495 
 496   return TypeFunc::make(domain, range);
 497 }
 498 
 499 Node* ShenandoahBarrierSetC2::store_at_resolved(C2Access&amp; access, C2AccessValue&amp; val) const {
 500   DecoratorSet decorators = access.decorators();
 501 
 502   const TypePtr* adr_type = access.addr().type();
 503   Node* adr = access.addr().node();
 504 
 505   bool anonymous = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 506   bool on_heap = (decorators &amp; IN_HEAP) != 0;
 507 
 508   if (!access.is_oop() || (!on_heap &amp;&amp; !anonymous)) {
 509     return BarrierSetC2::store_at_resolved(access, val);
 510   }
 511 
 512   if (access.is_parse_access()) {
 513     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 514     GraphKit* kit = parse_access.kit();
 515 
 516     uint adr_idx = kit-&gt;C-&gt;get_alias_index(adr_type);
 517     assert(adr_idx != Compile::AliasIdxTop, &quot;use other store_to_memory factory&quot; );
 518     Node* value = val.node();
 519     value = shenandoah_storeval_barrier(kit, value);
 520     val.set_node(value);
 521     shenandoah_write_barrier_pre(kit, true /* do_load */, /*kit-&gt;control(),*/ access.base(), adr, adr_idx, val.node(),
 522                                  static_cast&lt;const TypeOopPtr*&gt;(val.type()), NULL /* pre_val */, access.type());
 523   } else {
 524     assert(access.is_opt_access(), &quot;only for optimization passes&quot;);
 525     assert(((decorators &amp; C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) &amp;&amp; (decorators &amp; C2_ARRAY_COPY) != 0, &quot;unexpected caller of this code&quot;);
 526     C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
 527     PhaseGVN&amp; gvn =  opt_access.gvn();
 528     MergeMemNode* mm = opt_access.mem();
 529 
 530     if (ShenandoahStoreValEnqueueBarrier) {
 531       Node* enqueue = gvn.transform(new ShenandoahEnqueueBarrierNode(val.node()));
 532       val.set_node(enqueue);
 533     }
 534   }
 535   return BarrierSetC2::store_at_resolved(access, val);
 536 }
 537 
 538 Node* ShenandoahBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
 539   // 1: non-reference load, no additional barrier is needed
 540   if (!access.is_oop()) {
 541     return BarrierSetC2::load_at_resolved(access, val_type);;
 542   }
 543 
 544   Node* load = BarrierSetC2::load_at_resolved(access, val_type);
 545   DecoratorSet decorators = access.decorators();
 546   BasicType type = access.type();
 547 
 548   // 2: apply LRB if needed
 549   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {
 550     load = new ShenandoahLoadReferenceBarrierNode(NULL,
 551                                                   load,
 552                                                   ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type));
 553     if (access.is_parse_access()) {
 554       load = static_cast&lt;C2ParseAccess &amp;&gt;(access).kit()-&gt;gvn().transform(load);
 555     } else {
 556       load = static_cast&lt;C2OptAccess &amp;&gt;(access).gvn().transform(load);
 557     }
 558   }
 559 
 560   // 3: apply keep-alive barrier if needed
 561   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {
 562     Node* top = Compile::current()-&gt;top();
 563     Node* adr = access.addr().node();
 564     Node* offset = adr-&gt;is_AddP() ? adr-&gt;in(AddPNode::Offset) : top;
 565     Node* obj = access.base();
 566 
 567     bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 568     bool on_weak_ref = (decorators &amp; (ON_WEAK_OOP_REF | ON_PHANTOM_OOP_REF)) != 0;
 569     bool keep_alive = (decorators &amp; AS_NO_KEEPALIVE) == 0;
 570 
 571     // If we are reading the value of the referent field of a Reference
 572     // object (either by using Unsafe directly or through reflection)
 573     // then, if SATB is enabled, we need to record the referent in an
 574     // SATB log buffer using the pre-barrier mechanism.
 575     // Also we need to add memory barrier to prevent commoning reads
 576     // from this field across safepoint since GC can change its value.
 577     if (!on_weak_ref || (unknown &amp;&amp; (offset == top || obj == top)) || !keep_alive) {
 578       return load;
 579     }
 580 
 581     assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);
 582     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 583     GraphKit* kit = parse_access.kit();
 584     bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;
 585     bool is_unordered = (decorators &amp; MO_UNORDERED) != 0;
 586     bool in_native = (decorators &amp; IN_NATIVE) != 0;
 587     bool need_cpu_mem_bar = !is_unordered || mismatched || in_native;
 588 
 589     if (on_weak_ref) {
 590       // Use the pre-barrier to record the value in the referent field
 591       satb_write_barrier_pre(kit, false /* do_load */,
 592                              NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,
 593                              load /* pre_val */, T_OBJECT);
 594       // Add memory barrier to prevent commoning reads from this field
 595       // across safepoint since GC can change its value.
 596       kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);
 597     } else if (unknown) {
 598       // We do not require a mem bar inside pre_barrier if need_mem_bar
 599       // is set: the barriers would be emitted by us.
 600       insert_pre_barrier(kit, obj, offset, load, !need_cpu_mem_bar);
 601     }
 602   }
 603 
 604   return load;
 605 }
 606 
 607 Node* ShenandoahBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 608                                                    Node* new_val, const Type* value_type) const {
 609   GraphKit* kit = access.kit();
 610   if (access.is_oop()) {
 611     new_val = shenandoah_storeval_barrier(kit, new_val);
 612     shenandoah_write_barrier_pre(kit, false /* do_load */,
 613                                  NULL, NULL, max_juint, NULL, NULL,
 614                                  expected_val /* pre_val */, T_OBJECT);
 615 
 616     MemNode::MemOrd mo = access.mem_node_mo();
 617     Node* mem = access.memory();
 618     Node* adr = access.addr().node();
 619     const TypePtr* adr_type = access.addr().type();
 620     Node* load_store = NULL;
 621 
 622 #ifdef _LP64
 623     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 624       Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
 625       Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
 626       if (ShenandoahCASBarrier) {
 627         load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));
 628       } else {
 629         load_store = kit-&gt;gvn().transform(new CompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));
 630       }
 631     } else
 632 #endif
 633     {
 634       if (ShenandoahCASBarrier) {
 635         load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));
 636       } else {
 637         load_store = kit-&gt;gvn().transform(new CompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));
 638       }
 639     }
 640 
 641     access.set_raw_access(load_store);
 642     pin_atomic_op(access);
 643 
 644 #ifdef _LP64
 645     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 646       load_store = kit-&gt;gvn().transform(new DecodeNNode(load_store, load_store-&gt;get_ptr_type()));
 647     }
 648 #endif
 649     load_store = kit-&gt;gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, load_store, false));
 650     return load_store;
 651   }
 652   return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);
 653 }
 654 
 655 Node* ShenandoahBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 656                                                               Node* new_val, const Type* value_type) const {
 657   GraphKit* kit = access.kit();
 658   if (access.is_oop()) {
 659     new_val = shenandoah_storeval_barrier(kit, new_val);
 660     shenandoah_write_barrier_pre(kit, false /* do_load */,
 661                                  NULL, NULL, max_juint, NULL, NULL,
 662                                  expected_val /* pre_val */, T_OBJECT);
 663     DecoratorSet decorators = access.decorators();
 664     MemNode::MemOrd mo = access.mem_node_mo();
 665     Node* mem = access.memory();
 666     bool is_weak_cas = (decorators &amp; C2_WEAK_CMPXCHG) != 0;
 667     Node* load_store = NULL;
 668     Node* adr = access.addr().node();
 669 #ifdef _LP64
 670     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 671       Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
 672       Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
 673       if (ShenandoahCASBarrier) {
 674         if (is_weak_cas) {
 675           load_store = kit-&gt;gvn().transform(new ShenandoahWeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 676         } else {
 677           load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 678         }
 679       } else {
 680         if (is_weak_cas) {
 681           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 682         } else {
 683           load_store = kit-&gt;gvn().transform(new CompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 684         }
 685       }
 686     } else
 687 #endif
 688     {
 689       if (ShenandoahCASBarrier) {
 690         if (is_weak_cas) {
 691           load_store = kit-&gt;gvn().transform(new ShenandoahWeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 692         } else {
 693           load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 694         }
 695       } else {
 696         if (is_weak_cas) {
 697           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 698         } else {
 699           load_store = kit-&gt;gvn().transform(new CompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 700         }
 701       }
 702     }
 703     access.set_raw_access(load_store);
 704     pin_atomic_op(access);
 705     return load_store;
 706   }
 707   return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);
 708 }
 709 
 710 Node* ShenandoahBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access, Node* val, const Type* value_type) const {
 711   GraphKit* kit = access.kit();
 712   if (access.is_oop()) {
 713     val = shenandoah_storeval_barrier(kit, val);
 714   }
 715   Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, val, value_type);
 716   if (access.is_oop()) {
 717     result = kit-&gt;gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, result, false));
 718     shenandoah_write_barrier_pre(kit, false /* do_load */,
 719                                  NULL, NULL, max_juint, NULL, NULL,
 720                                  result /* pre_val */, T_OBJECT);
 721   }
 722   return result;
 723 }
 724 
 725 // Support for GC barriers emitted during parsing
 726 bool ShenandoahBarrierSetC2::is_gc_barrier_node(Node* node) const {
 727   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) return true;
 728   if (node-&gt;Opcode() != Op_CallLeaf &amp;&amp; node-&gt;Opcode() != Op_CallLeafNoFP) {
 729     return false;
 730   }
 731   CallLeafNode *call = node-&gt;as_CallLeaf();
 732   if (call-&gt;_name == NULL) {
 733     return false;
 734   }
 735 
 736   return strcmp(call-&gt;_name, &quot;shenandoah_clone_barrier&quot;) == 0 ||
 737          strcmp(call-&gt;_name, &quot;shenandoah_cas_obj&quot;) == 0 ||
 738          strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;) == 0;
 739 }
 740 
 741 Node* ShenandoahBarrierSetC2::step_over_gc_barrier(Node* c) const {
 742   if (c == NULL) {
 743     return c;
 744   }
 745   if (c-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {
 746     return c-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
 747   }
 748   if (c-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 749     c = c-&gt;in(1);
 750   }
 751   return c;
 752 }
 753 
 754 bool ShenandoahBarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const {
 755   return !ShenandoahBarrierC2Support::expand(C, igvn);
 756 }
 757 
 758 bool ShenandoahBarrierSetC2::optimize_loops(PhaseIdealLoop* phase, LoopOptsMode mode, VectorSet&amp; visited, Node_Stack&amp; nstack, Node_List&amp; worklist) const {
 759   if (mode == LoopOptsShenandoahExpand) {
 760     assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
 761     ShenandoahBarrierC2Support::pin_and_expand(phase);
 762     return true;
 763   } else if (mode == LoopOptsShenandoahPostExpand) {
 764     assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
 765     visited.clear();
 766     ShenandoahBarrierC2Support::optimize_after_expansion(visited, nstack, worklist, phase);
 767     return true;
 768   }
 769   return false;
 770 }
 771 
 772 bool ShenandoahBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {
 773   bool is_oop = is_reference_type(type);
 774   if (!is_oop) {
 775     return false;
 776   }
 777   if (ShenandoahSATBBarrier &amp;&amp; tightly_coupled_alloc) {
 778     if (phase == Optimization) {
 779       return false;
 780     }
 781     return !is_clone;
 782   }
 783   if (phase == Optimization) {
 784     return !ShenandoahStoreValEnqueueBarrier;
 785   }
 786   return true;
 787 }
 788 
 789 bool ShenandoahBarrierSetC2::clone_needs_barrier(Node* src, PhaseGVN&amp; gvn) {
 790   const TypeOopPtr* src_type = gvn.type(src)-&gt;is_oopptr();
 791   if (src_type-&gt;isa_instptr() != NULL) {
 792     ciInstanceKlass* ik = src_type-&gt;klass()-&gt;as_instance_klass();
 793     if ((src_type-&gt;klass_is_exact() || (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass())) &amp;&amp; !ik-&gt;has_injected_fields()) {
 794       if (ik-&gt;has_object_fields()) {
 795         return true;
 796       } else {
 797         if (!src_type-&gt;klass_is_exact()) {
 798           Compile::current()-&gt;dependencies()-&gt;assert_leaf_type(ik);
 799         }
 800       }
 801     } else {
 802       return true;
 803         }
 804   } else if (src_type-&gt;isa_aryptr()) {
 805     BasicType src_elem  = src_type-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
 806     if (is_reference_type(src_elem)) {
 807       return true;
 808     }
 809   } else {
 810     return true;
 811   }
 812   return false;
 813 }
 814 
 815 void ShenandoahBarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {
 816   Node* ctrl = ac-&gt;in(TypeFunc::Control);
 817   Node* mem = ac-&gt;in(TypeFunc::Memory);
 818   Node* src_base = ac-&gt;in(ArrayCopyNode::Src);
 819   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);
 820   Node* dest_base = ac-&gt;in(ArrayCopyNode::Dest);
 821   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);
 822   Node* length = ac-&gt;in(ArrayCopyNode::Length);
 823 
 824   Node* src = phase-&gt;basic_plus_adr(src_base, src_offset);
 825   Node* dest = phase-&gt;basic_plus_adr(dest_base, dest_offset);
 826 
 827   if (ShenandoahCloneBarrier &amp;&amp; clone_needs_barrier(src, phase-&gt;igvn())) {
 828     // Check if heap is has forwarded objects. If it does, we need to call into the special
 829     // routine that would fix up source references before we can continue.
 830 
 831     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };
 832     Node* region = new RegionNode(PATH_LIMIT);
 833     Node* mem_phi = new PhiNode(region, Type::MEMORY, TypeRawPtr::BOTTOM);
 834 
 835     Node* thread = phase-&gt;transform_later(new ThreadLocalNode());
 836     Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 837     Node* gc_state_addr = phase-&gt;transform_later(new AddPNode(phase-&gt;C-&gt;top(), thread, offset));
 838 
 839     uint gc_state_idx = Compile::AliasIdxRaw;
 840     const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument
 841     debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));
 842 
 843     Node* gc_state    = phase-&gt;transform_later(new LoadBNode(ctrl, mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered));
 844     int flags = ShenandoahHeap::HAS_FORWARDED;
 845     if (ShenandoahStoreValEnqueueBarrier) {
 846       flags |= ShenandoahHeap::MARKING;
 847     }
 848     Node* stable_and  = phase-&gt;transform_later(new AndINode(gc_state, phase-&gt;igvn().intcon(flags)));
 849     Node* stable_cmp  = phase-&gt;transform_later(new CmpINode(stable_and, phase-&gt;igvn().zerocon(T_INT)));
 850     Node* stable_test = phase-&gt;transform_later(new BoolNode(stable_cmp, BoolTest::ne));
 851 
 852     IfNode* stable_iff  = phase-&gt;transform_later(new IfNode(ctrl, stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN))-&gt;as_If();
 853     Node* stable_ctrl   = phase-&gt;transform_later(new IfFalseNode(stable_iff));
 854     Node* unstable_ctrl = phase-&gt;transform_later(new IfTrueNode(stable_iff));
 855 
 856     // Heap is stable, no need to do anything additional
 857     region-&gt;init_req(_heap_stable, stable_ctrl);
 858     mem_phi-&gt;init_req(_heap_stable, mem);
 859 
 860     // Heap is unstable, call into clone barrier stub
 861     Node* call = phase-&gt;make_leaf_call(unstable_ctrl, mem,
 862                     ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),
 863                     CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),
 864                     &quot;shenandoah_clone&quot;,
 865                     TypeRawPtr::BOTTOM,
 866                     src_base);
 867     call = phase-&gt;transform_later(call);
 868 
 869     ctrl = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Control));
 870     mem = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Memory));
 871     region-&gt;init_req(_heap_unstable, ctrl);
 872     mem_phi-&gt;init_req(_heap_unstable, mem);
 873 
 874     // Wire up the actual arraycopy stub now
 875     ctrl = phase-&gt;transform_later(region);
 876     mem = phase-&gt;transform_later(mem_phi);
 877 
 878     const char* name = &quot;arraycopy&quot;;
 879     call = phase-&gt;make_leaf_call(ctrl, mem,
 880                                  OptoRuntime::fast_arraycopy_Type(),
 881                                  phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL, true, name, true),
 882                                  name, TypeRawPtr::BOTTOM,
 883                                  src, dest, length
 884                                  LP64_ONLY(COMMA phase-&gt;top()));
 885     call = phase-&gt;transform_later(call);
 886 
 887     // Hook up the whole thing into the graph
 888     phase-&gt;igvn().replace_node(ac, call);
 889   } else {
 890     BarrierSetC2::clone_at_expansion(phase, ac);
 891   }
 892 }
 893 
 894 
 895 // Support for macro expanded GC barriers
 896 void ShenandoahBarrierSetC2::register_potential_barrier_node(Node* node) const {
 897   if (node-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 898     state()-&gt;add_enqueue_barrier((ShenandoahEnqueueBarrierNode*) node);
 899   }
 900   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {
 901     state()-&gt;add_load_reference_barrier((ShenandoahLoadReferenceBarrierNode*) node);
 902   }
 903 }
 904 
 905 void ShenandoahBarrierSetC2::unregister_potential_barrier_node(Node* node) const {
 906   if (node-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 907     state()-&gt;remove_enqueue_barrier((ShenandoahEnqueueBarrierNode*) node);
 908   }
 909   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {
 910     state()-&gt;remove_load_reference_barrier((ShenandoahLoadReferenceBarrierNode*) node);
 911   }
 912 }
 913 
 914 void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* n) const {
 915   if (is_shenandoah_wb_pre_call(n)) {
 916     shenandoah_eliminate_wb_pre(n, &amp;macro-&gt;igvn());
 917   }
 918 }
 919 
 920 void ShenandoahBarrierSetC2::shenandoah_eliminate_wb_pre(Node* call, PhaseIterGVN* igvn) const {
 921   assert(UseShenandoahGC &amp;&amp; is_shenandoah_wb_pre_call(call), &quot;&quot;);
 922   Node* c = call-&gt;as_Call()-&gt;proj_out(TypeFunc::Control);
 923   c = c-&gt;unique_ctrl_out();
 924   assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
 925   c = c-&gt;unique_ctrl_out();
 926   assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
 927   Node* iff = c-&gt;in(1)-&gt;is_IfProj() ? c-&gt;in(1)-&gt;in(0) : c-&gt;in(2)-&gt;in(0);
 928   assert(iff-&gt;is_If(), &quot;expect test&quot;);
 929   if (!is_shenandoah_marking_if(igvn, iff)) {
 930     c = c-&gt;unique_ctrl_out();
 931     assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
 932     iff = c-&gt;in(1)-&gt;is_IfProj() ? c-&gt;in(1)-&gt;in(0) : c-&gt;in(2)-&gt;in(0);
 933     assert(is_shenandoah_marking_if(igvn, iff), &quot;expect marking test&quot;);
 934   }
 935   Node* cmpx = iff-&gt;in(1)-&gt;in(1);
 936   igvn-&gt;replace_node(cmpx, igvn-&gt;makecon(TypeInt::CC_EQ));
 937   igvn-&gt;rehash_node_delayed(call);
 938   call-&gt;del_req(call-&gt;req()-1);
 939 }
 940 
 941 void ShenandoahBarrierSetC2::enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const {
 942   if (node-&gt;Opcode() == Op_AddP &amp;&amp; ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(node)) {
 943     igvn-&gt;add_users_to_worklist(node);
 944   }
 945 }
 946 
 947 void ShenandoahBarrierSetC2::eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const {
 948   for (uint i = 0; i &lt; useful.size(); i++) {
 949     Node* n = useful.at(i);
 950     if (n-&gt;Opcode() == Op_AddP &amp;&amp; ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(n)) {
 951       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 952         C-&gt;record_for_igvn(n-&gt;fast_out(i));
 953       }
 954     }
 955   }
 956   for (int i = state()-&gt;enqueue_barriers_count() - 1; i &gt;= 0; i--) {
 957     ShenandoahEnqueueBarrierNode* n = state()-&gt;enqueue_barrier(i);
 958     if (!useful.member(n)) {
 959       state()-&gt;remove_enqueue_barrier(n);
 960     }
 961   }
 962   for (int i = state()-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
 963     ShenandoahLoadReferenceBarrierNode* n = state()-&gt;load_reference_barrier(i);
 964     if (!useful.member(n)) {
 965       state()-&gt;remove_load_reference_barrier(n);
 966     }
 967   }
 968 }
 969 
 970 void* ShenandoahBarrierSetC2::create_barrier_state(Arena* comp_arena) const {
 971   return new(comp_arena) ShenandoahBarrierSetC2State(comp_arena);
 972 }
 973 
 974 ShenandoahBarrierSetC2State* ShenandoahBarrierSetC2::state() const {
 975   return reinterpret_cast&lt;ShenandoahBarrierSetC2State*&gt;(Compile::current()-&gt;barrier_set_state());
 976 }
 977 
 978 // If the BarrierSetC2 state has kept macro nodes in its compilation unit state to be
 979 // expanded later, then now is the time to do so.
 980 bool ShenandoahBarrierSetC2::expand_macro_nodes(PhaseMacroExpand* macro) const { return false; }
 981 
 982 #ifdef ASSERT
 983 void ShenandoahBarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {
 984   if (ShenandoahVerifyOptoBarriers &amp;&amp; phase == BarrierSetC2::BeforeMacroExpand) {
 985     ShenandoahBarrierC2Support::verify(Compile::current()-&gt;root());
 986   } else if (phase == BarrierSetC2::BeforeCodeGen) {
 987     // Verify G1 pre-barriers
 988     const int marking_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset());
 989 
 990     ResourceArea *area = Thread::current()-&gt;resource_area();
 991     Unique_Node_List visited(area);
 992     Node_List worklist(area);
 993     // We&#39;re going to walk control flow backwards starting from the Root
 994     worklist.push(compile-&gt;root());
 995     while (worklist.size() &gt; 0) {
 996       Node *x = worklist.pop();
 997       if (x == NULL || x == compile-&gt;top()) continue;
 998       if (visited.member(x)) {
 999         continue;
1000       } else {
1001         visited.push(x);
1002       }
1003 
1004       if (x-&gt;is_Region()) {
1005         for (uint i = 1; i &lt; x-&gt;req(); i++) {
1006           worklist.push(x-&gt;in(i));
1007         }
1008       } else {
1009         worklist.push(x-&gt;in(0));
1010         // We are looking for the pattern:
1011         //                            /-&gt;ThreadLocal
1012         // If-&gt;Bool-&gt;CmpI-&gt;LoadB-&gt;AddP-&gt;ConL(marking_offset)
1013         //              \-&gt;ConI(0)
1014         // We want to verify that the If and the LoadB have the same control
1015         // See GraphKit::g1_write_barrier_pre()
1016         if (x-&gt;is_If()) {
1017           IfNode *iff = x-&gt;as_If();
1018           if (iff-&gt;in(1)-&gt;is_Bool() &amp;&amp; iff-&gt;in(1)-&gt;in(1)-&gt;is_Cmp()) {
1019             CmpNode *cmp = iff-&gt;in(1)-&gt;in(1)-&gt;as_Cmp();
1020             if (cmp-&gt;Opcode() == Op_CmpI &amp;&amp; cmp-&gt;in(2)-&gt;is_Con() &amp;&amp; cmp-&gt;in(2)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0
1021                 &amp;&amp; cmp-&gt;in(1)-&gt;is_Load()) {
1022               LoadNode *load = cmp-&gt;in(1)-&gt;as_Load();
1023               if (load-&gt;Opcode() == Op_LoadB &amp;&amp; load-&gt;in(2)-&gt;is_AddP() &amp;&amp; load-&gt;in(2)-&gt;in(2)-&gt;Opcode() == Op_ThreadLocal
1024                   &amp;&amp; load-&gt;in(2)-&gt;in(3)-&gt;is_Con()
1025                   &amp;&amp; load-&gt;in(2)-&gt;in(3)-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() == marking_offset) {
1026 
1027                 Node *if_ctrl = iff-&gt;in(0);
1028                 Node *load_ctrl = load-&gt;in(0);
1029 
1030                 if (if_ctrl != load_ctrl) {
1031                   // Skip possible CProj-&gt;NeverBranch in infinite loops
1032                   if ((if_ctrl-&gt;is_Proj() &amp;&amp; if_ctrl-&gt;Opcode() == Op_CProj)
1033                       &amp;&amp; (if_ctrl-&gt;in(0)-&gt;is_MultiBranch() &amp;&amp; if_ctrl-&gt;in(0)-&gt;Opcode() == Op_NeverBranch)) {
1034                     if_ctrl = if_ctrl-&gt;in(0)-&gt;in(0);
1035                   }
1036                 }
1037                 assert(load_ctrl != NULL &amp;&amp; if_ctrl == load_ctrl, &quot;controls must match&quot;);
1038               }
1039             }
1040           }
1041         }
1042       }
1043     }
1044   }
1045 }
1046 #endif
1047 
1048 Node* ShenandoahBarrierSetC2::ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const {
1049   if (is_shenandoah_wb_pre_call(n)) {
1050     uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain_sig()-&gt;cnt();
1051     if (n-&gt;req() &gt; cnt) {
1052       Node* addp = n-&gt;in(cnt);
1053       if (has_only_shenandoah_wb_pre_uses(addp)) {
1054         n-&gt;del_req(cnt);
1055         if (can_reshape) {
1056           phase-&gt;is_IterGVN()-&gt;_worklist.push(addp);
1057         }
1058         return n;
1059       }
1060     }
1061   }
1062   if (n-&gt;Opcode() == Op_CmpP) {
1063     Node* in1 = n-&gt;in(1);
1064     Node* in2 = n-&gt;in(2);
1065     if (in1-&gt;bottom_type() == TypePtr::NULL_PTR) {
1066       in2 = step_over_gc_barrier(in2);
1067     }
1068     if (in2-&gt;bottom_type() == TypePtr::NULL_PTR) {
1069       in1 = step_over_gc_barrier(in1);
1070     }
1071     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1072     if (in1 != n-&gt;in(1)) {
1073       if (igvn != NULL) {
1074         n-&gt;set_req_X(1, in1, igvn);
1075       } else {
1076         n-&gt;set_req(1, in1);
1077       }
1078       assert(in2 == n-&gt;in(2), &quot;only one change&quot;);
1079       return n;
1080     }
1081     if (in2 != n-&gt;in(2)) {
1082       if (igvn != NULL) {
1083         n-&gt;set_req_X(2, in2, igvn);
1084       } else {
1085         n-&gt;set_req(2, in2);
1086       }
1087       return n;
1088     }
1089   } else if (can_reshape &amp;&amp;
1090              n-&gt;Opcode() == Op_If &amp;&amp;
1091              ShenandoahBarrierC2Support::is_heap_stable_test(n) &amp;&amp;
1092              n-&gt;in(0) != NULL) {
1093     Node* dom = n-&gt;in(0);
1094     Node* prev_dom = n;
1095     int op = n-&gt;Opcode();
1096     int dist = 16;
1097     // Search up the dominator tree for another heap stable test
1098     while (dom-&gt;Opcode() != op    ||  // Not same opcode?
1099            !ShenandoahBarrierC2Support::is_heap_stable_test(dom) ||  // Not same input 1?
1100            prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1101       if (dist &lt; 0) return NULL;
1102 
1103       dist--;
1104       prev_dom = dom;
1105       dom = IfNode::up_one_dom(dom);
1106       if (!dom) return NULL;
1107     }
1108 
1109     // Check that we did not follow a loop back to ourselves
1110     if (n == dom) {
1111       return NULL;
1112     }
1113 
1114     return n-&gt;as_If()-&gt;dominated_by(prev_dom, phase-&gt;is_IterGVN());
1115   }
1116 
1117   return NULL;
1118 }
1119 
1120 bool ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(Node* n) {
1121   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1122     Node* u = n-&gt;fast_out(i);
1123     if (!is_shenandoah_wb_pre_call(u)) {
1124       return false;
1125     }
1126   }
1127   return n-&gt;outcnt() &gt; 0;
1128 }
1129 
1130 bool ShenandoahBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {
1131   switch (opcode) {
1132     case Op_CallLeaf:
1133     case Op_CallLeafNoFP: {
1134       assert (n-&gt;is_Call(), &quot;&quot;);
1135       CallNode *call = n-&gt;as_Call();
1136       if (ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(call)) {
1137         uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain_sig()-&gt;cnt();
1138         if (call-&gt;req() &gt; cnt) {
1139           assert(call-&gt;req() == cnt + 1, &quot;only one extra input&quot;);
1140           Node *addp = call-&gt;in(cnt);
1141           assert(!ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(addp), &quot;useless address computation?&quot;);
1142           call-&gt;del_req(cnt);
1143         }
1144       }
1145       return false;
1146     }
1147     case Op_ShenandoahCompareAndSwapP:
1148     case Op_ShenandoahCompareAndSwapN:
1149     case Op_ShenandoahWeakCompareAndSwapN:
1150     case Op_ShenandoahWeakCompareAndSwapP:
1151     case Op_ShenandoahCompareAndExchangeP:
1152     case Op_ShenandoahCompareAndExchangeN:
1153 #ifdef ASSERT
1154       if( VerifyOptoOopOffsets ) {
1155         MemNode* mem  = n-&gt;as_Mem();
1156         // Check to see if address types have grounded out somehow.
1157         const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
1158         ciInstanceKlass *k = tp-&gt;klass()-&gt;as_instance_klass();
1159         bool oop_offset_is_sane = k-&gt;contains_field_offset(tp-&gt;offset());
1160         assert( !tp || oop_offset_is_sane, &quot;&quot; );
1161       }
1162 #endif
1163       return true;
1164     case Op_ShenandoahLoadReferenceBarrier:
1165       assert(false, &quot;should have been expanded already&quot;);
1166       return true;
1167     default:
1168       return false;
1169   }
1170 }
1171 
1172 bool ShenandoahBarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {
1173   switch (opcode) {
1174     case Op_ShenandoahCompareAndExchangeP:
1175     case Op_ShenandoahCompareAndExchangeN:
1176       conn_graph-&gt;add_objload_to_connection_graph(n, delayed_worklist);
1177       // fallthrough
1178     case Op_ShenandoahWeakCompareAndSwapP:
1179     case Op_ShenandoahWeakCompareAndSwapN:
1180     case Op_ShenandoahCompareAndSwapP:
1181     case Op_ShenandoahCompareAndSwapN:
1182       conn_graph-&gt;add_to_congraph_unsafe_access(n, opcode, delayed_worklist);
1183       return true;
1184     case Op_StoreP: {
1185       Node* adr = n-&gt;in(MemNode::Address);
1186       const Type* adr_type = gvn-&gt;type(adr);
1187       // Pointer stores in G1 barriers looks like unsafe access.
1188       // Ignore such stores to be able scalar replace non-escaping
1189       // allocations.
1190       if (adr_type-&gt;isa_rawptr() &amp;&amp; adr-&gt;is_AddP()) {
1191         Node* base = conn_graph-&gt;get_addp_base(adr);
1192         if (base-&gt;Opcode() == Op_LoadP &amp;&amp;
1193           base-&gt;in(MemNode::Address)-&gt;is_AddP()) {
1194           adr = base-&gt;in(MemNode::Address);
1195           Node* tls = conn_graph-&gt;get_addp_base(adr);
1196           if (tls-&gt;Opcode() == Op_ThreadLocal) {
1197              int offs = (int) gvn-&gt;find_intptr_t_con(adr-&gt;in(AddPNode::Offset), Type::OffsetBot);
1198              const int buf_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
1199              if (offs == buf_offset) {
1200                return true; // Pre barrier previous oop value store.
1201              }
1202           }
1203         }
1204       }
1205       return false;
1206     }
1207     case Op_ShenandoahEnqueueBarrier:
1208       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), delayed_worklist);
1209       break;
1210     case Op_ShenandoahLoadReferenceBarrier:
1211       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn), delayed_worklist);
1212       return true;
1213     default:
1214       // Nothing
1215       break;
1216   }
1217   return false;
1218 }
1219 
1220 bool ShenandoahBarrierSetC2::escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const {
1221   switch (opcode) {
1222     case Op_ShenandoahCompareAndExchangeP:
1223     case Op_ShenandoahCompareAndExchangeN: {
1224       Node *adr = n-&gt;in(MemNode::Address);
1225       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);
1226       // fallthrough
1227     }
1228     case Op_ShenandoahCompareAndSwapP:
1229     case Op_ShenandoahCompareAndSwapN:
1230     case Op_ShenandoahWeakCompareAndSwapP:
1231     case Op_ShenandoahWeakCompareAndSwapN:
1232       return conn_graph-&gt;add_final_edges_unsafe_access(n, opcode);
1233     case Op_ShenandoahEnqueueBarrier:
1234       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), NULL);
1235       return true;
1236     case Op_ShenandoahLoadReferenceBarrier:
1237       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn), NULL);
1238       return true;
1239     default:
1240       // Nothing
1241       break;
1242   }
1243   return false;
1244 }
1245 
1246 bool ShenandoahBarrierSetC2::escape_has_out_with_unsafe_object(Node* n) const {
1247   return n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeP) || n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeN) ||
1248          n-&gt;has_out_with(Op_ShenandoahCompareAndSwapP, Op_ShenandoahCompareAndSwapN, Op_ShenandoahWeakCompareAndSwapP, Op_ShenandoahWeakCompareAndSwapN);
1249 
1250 }
1251 
1252 bool ShenandoahBarrierSetC2::matcher_find_shared_post_visit(Matcher* matcher, Node* n, uint opcode) const {
1253   switch (opcode) {
1254     case Op_ShenandoahCompareAndExchangeP:
1255     case Op_ShenandoahCompareAndExchangeN:
1256     case Op_ShenandoahWeakCompareAndSwapP:
1257     case Op_ShenandoahWeakCompareAndSwapN:
1258     case Op_ShenandoahCompareAndSwapP:
1259     case Op_ShenandoahCompareAndSwapN: {   // Convert trinary to binary-tree
1260       Node* newval = n-&gt;in(MemNode::ValueIn);
1261       Node* oldval = n-&gt;in(LoadStoreConditionalNode::ExpectedIn);
1262       Node* pair = new BinaryNode(oldval, newval);
1263       n-&gt;set_req(MemNode::ValueIn,pair);
1264       n-&gt;del_req(LoadStoreConditionalNode::ExpectedIn);
1265       return true;
1266     }
1267     default:
1268       break;
1269   }
1270   return false;
1271 }
1272 
1273 bool ShenandoahBarrierSetC2::matcher_is_store_load_barrier(Node* x, uint xop) const {
1274   return xop == Op_ShenandoahCompareAndExchangeP ||
1275          xop == Op_ShenandoahCompareAndExchangeN ||
1276          xop == Op_ShenandoahWeakCompareAndSwapP ||
1277          xop == Op_ShenandoahWeakCompareAndSwapN ||
1278          xop == Op_ShenandoahCompareAndSwapN ||
1279          xop == Op_ShenandoahCompareAndSwapP;
1280 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 305   bool                  _has_flattened_accesses; // Any known flattened array accesses?
 306   bool                  _flattened_accesses_share_alias; // Initially all flattened array share a single slice
 307 
 308   // Compilation environment.
 309   Arena                 _comp_arena;            // Arena with lifetime equivalent to Compile
 310   void*                 _barrier_set_state;     // Potential GC barrier state for Compile
 311   ciEnv*                _env;                   // CI interface
 312   DirectiveSet*         _directive;             // Compiler directive
 313   CompileLog*           _log;                   // from CompilerThread
 314   const char*           _failure_reason;        // for record_failure/failing pattern
 315   GrowableArray&lt;CallGenerator*&gt;* _intrinsics;   // List of intrinsics.
 316   GrowableArray&lt;Node*&gt;* _macro_nodes;           // List of nodes which need to be expanded before matching.
 317   GrowableArray&lt;Node*&gt;* _predicate_opaqs;       // List of Opaque1 nodes for the loop predicates.
 318   GrowableArray&lt;Node*&gt;* _expensive_nodes;       // List of nodes that are expensive to compute and that we&#39;d better not let the GVN freely common
 319   GrowableArray&lt;Node*&gt;* _range_check_casts;     // List of CastII nodes with a range check dependency
 320   GrowableArray&lt;Node*&gt;* _opaque4_nodes;         // List of Opaque4 nodes that have a default value
 321   Unique_Node_List*     _value_type_nodes;      // List of ValueType nodes
 322   ConnectionGraph*      _congraph;
 323 #ifndef PRODUCT
 324   IdealGraphPrinter*    _printer;


 325 #endif
 326 
 327 
 328   // Node management
 329   uint                  _unique;                // Counter for unique Node indices
 330   VectorSet             _dead_node_list;        // Set of dead nodes
 331   uint                  _dead_node_count;       // Number of dead nodes; VectorSet::Size() is O(N).
 332                                                 // So use this to keep count and make the call O(1).
 333   DEBUG_ONLY( Unique_Node_List* _modified_nodes; )  // List of nodes which inputs were modified
 334 
 335   debug_only(static int _debug_idx;)            // Monotonic counter (not reset), use -XX:BreakAtNode=&lt;idx&gt;
 336   Arena                 _node_arena;            // Arena for new-space Nodes
 337   Arena                 _old_arena;             // Arena for old-space Nodes, lifetime during xform
 338   RootNode*             _root;                  // Unique root of compilation, or NULL after bail-out.
 339   Node*                 _top;                   // Unique top node.  (Reset by various phases.)
 340 
 341   Node*                 _immutable_memory;      // Initial memory state
 342 
 343   Node*                 _recent_alloc_obj;
 344   Node*                 _recent_alloc_ctl;
</pre>
<hr />
<pre>
 634   }
 635 
 636   bool should_print(int level = 1) {
 637 #ifndef PRODUCT
 638     return (_printer &amp;&amp; _printer-&gt;should_print(level));
 639 #else
 640     return false;
 641 #endif
 642   }
 643 
 644   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0) {
 645     EventCompilerPhase event;
 646     if (event.should_commit()) {
 647       CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, cpt, C-&gt;_compile_id, level);
 648     }
 649 
 650 #ifndef PRODUCT
 651     if (should_print(level)) {
 652       char output[1024];
 653       if (idx != 0) {
<span class="line-modified"> 654         sprintf(output, &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);</span>
 655       } else {
<span class="line-modified"> 656         sprintf(output, &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));</span>
 657       }
 658       _printer-&gt;print_method(output, level);
 659     }
 660 #endif
 661     C-&gt;_latest_stage_start_counter.stamp();
 662   }
 663 







 664   void end_method(int level = 1) {
 665     EventCompilerPhase event;
 666     if (event.should_commit()) {
 667       CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, PHASE_END, C-&gt;_compile_id, level);
 668     }
 669 
 670 #ifndef PRODUCT
 671     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {
 672       _printer-&gt;end_method();
 673     }
 674 #endif
 675   }
 676 
 677   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 678   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 679   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 680   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
 681   Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs-&gt;at(idx);}
 682   Node*         expensive_node(int idx)   const { return _expensive_nodes-&gt;at(idx); }
 683   ConnectionGraph* congraph()                   { return _congraph;}
</pre>
</td>
<td>
<hr />
<pre>
 305   bool                  _has_flattened_accesses; // Any known flattened array accesses?
 306   bool                  _flattened_accesses_share_alias; // Initially all flattened array share a single slice
 307 
 308   // Compilation environment.
 309   Arena                 _comp_arena;            // Arena with lifetime equivalent to Compile
 310   void*                 _barrier_set_state;     // Potential GC barrier state for Compile
 311   ciEnv*                _env;                   // CI interface
 312   DirectiveSet*         _directive;             // Compiler directive
 313   CompileLog*           _log;                   // from CompilerThread
 314   const char*           _failure_reason;        // for record_failure/failing pattern
 315   GrowableArray&lt;CallGenerator*&gt;* _intrinsics;   // List of intrinsics.
 316   GrowableArray&lt;Node*&gt;* _macro_nodes;           // List of nodes which need to be expanded before matching.
 317   GrowableArray&lt;Node*&gt;* _predicate_opaqs;       // List of Opaque1 nodes for the loop predicates.
 318   GrowableArray&lt;Node*&gt;* _expensive_nodes;       // List of nodes that are expensive to compute and that we&#39;d better not let the GVN freely common
 319   GrowableArray&lt;Node*&gt;* _range_check_casts;     // List of CastII nodes with a range check dependency
 320   GrowableArray&lt;Node*&gt;* _opaque4_nodes;         // List of Opaque4 nodes that have a default value
 321   Unique_Node_List*     _value_type_nodes;      // List of ValueType nodes
 322   ConnectionGraph*      _congraph;
 323 #ifndef PRODUCT
 324   IdealGraphPrinter*    _printer;
<span class="line-added"> 325   static IdealGraphPrinter* _debug_file_printer;</span>
<span class="line-added"> 326   static IdealGraphPrinter* _debug_network_printer;</span>
 327 #endif
 328 
 329 
 330   // Node management
 331   uint                  _unique;                // Counter for unique Node indices
 332   VectorSet             _dead_node_list;        // Set of dead nodes
 333   uint                  _dead_node_count;       // Number of dead nodes; VectorSet::Size() is O(N).
 334                                                 // So use this to keep count and make the call O(1).
 335   DEBUG_ONLY( Unique_Node_List* _modified_nodes; )  // List of nodes which inputs were modified
 336 
 337   debug_only(static int _debug_idx;)            // Monotonic counter (not reset), use -XX:BreakAtNode=&lt;idx&gt;
 338   Arena                 _node_arena;            // Arena for new-space Nodes
 339   Arena                 _old_arena;             // Arena for old-space Nodes, lifetime during xform
 340   RootNode*             _root;                  // Unique root of compilation, or NULL after bail-out.
 341   Node*                 _top;                   // Unique top node.  (Reset by various phases.)
 342 
 343   Node*                 _immutable_memory;      // Initial memory state
 344 
 345   Node*                 _recent_alloc_obj;
 346   Node*                 _recent_alloc_ctl;
</pre>
<hr />
<pre>
 636   }
 637 
 638   bool should_print(int level = 1) {
 639 #ifndef PRODUCT
 640     return (_printer &amp;&amp; _printer-&gt;should_print(level));
 641 #else
 642     return false;
 643 #endif
 644   }
 645 
 646   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0) {
 647     EventCompilerPhase event;
 648     if (event.should_commit()) {
 649       CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, cpt, C-&gt;_compile_id, level);
 650     }
 651 
 652 #ifndef PRODUCT
 653     if (should_print(level)) {
 654       char output[1024];
 655       if (idx != 0) {
<span class="line-modified"> 656         jio_snprintf(output, sizeof(output), &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);</span>
 657       } else {
<span class="line-modified"> 658         jio_snprintf(output, sizeof(output), &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));</span>
 659       }
 660       _printer-&gt;print_method(output, level);
 661     }
 662 #endif
 663     C-&gt;_latest_stage_start_counter.stamp();
 664   }
 665 
<span class="line-added"> 666 #ifndef PRODUCT</span>
<span class="line-added"> 667   void igv_print_method_to_file(const char* phase_name = &quot;Debug&quot;, bool append = false);</span>
<span class="line-added"> 668   void igv_print_method_to_network(const char* phase_name = &quot;Debug&quot;);</span>
<span class="line-added"> 669   static IdealGraphPrinter* debug_file_printer() { return _debug_file_printer; }</span>
<span class="line-added"> 670   static IdealGraphPrinter* debug_network_printer() { return _debug_network_printer; }</span>
<span class="line-added"> 671 #endif</span>
<span class="line-added"> 672 </span>
 673   void end_method(int level = 1) {
 674     EventCompilerPhase event;
 675     if (event.should_commit()) {
 676       CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, PHASE_END, C-&gt;_compile_id, level);
 677     }
 678 
 679 #ifndef PRODUCT
 680     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {
 681       _printer-&gt;end_method();
 682     }
 683 #endif
 684   }
 685 
 686   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 687   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 688   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 689   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
 690   Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs-&gt;at(idx);}
 691   Node*         expensive_node(int idx)   const { return _expensive_nodes-&gt;at(idx); }
 692   ConnectionGraph* congraph()                   { return _congraph;}
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
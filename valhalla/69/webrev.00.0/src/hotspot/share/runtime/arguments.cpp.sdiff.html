<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/arguments.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../prims/whitebox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/arguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1649   LP64_ONLY(return OopEncodingHeapMax - displacement_due_to_null_page);
1650   NOT_LP64(ShouldNotReachHere(); return 0);
1651 }
1652 
1653 void Arguments::set_use_compressed_oops() {
1654 #ifndef ZERO
1655 #ifdef _LP64
1656   // MaxHeapSize is not set up properly at this point, but
1657   // the only value that can override MaxHeapSize if we are
1658   // to use UseCompressedOops are InitialHeapSize and MinHeapSize.
1659   size_t max_heap_size = MAX3(MaxHeapSize, InitialHeapSize, MinHeapSize);
1660 
1661   if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
1662     if (FLAG_IS_DEFAULT(UseCompressedOops)) {
1663       FLAG_SET_ERGO(UseCompressedOops, true);
1664     }
1665   } else {
1666     if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
1667       warning(&quot;Max heap size too large for Compressed Oops&quot;);
1668       FLAG_SET_DEFAULT(UseCompressedOops, false);
<span class="line-modified">1669       FLAG_SET_DEFAULT(UseCompressedClassPointers, false);</span>


1670     }
1671   }
1672 #endif // _LP64
1673 #endif // ZERO
1674 }
1675 
1676 
1677 // NOTE: set_use_compressed_klass_ptrs() must be called after calling
1678 // set_use_compressed_oops().
1679 void Arguments::set_use_compressed_klass_ptrs() {
1680 #ifndef ZERO
1681 #ifdef _LP64
<span class="line-modified">1682   // UseCompressedOops must be on for UseCompressedClassPointers to be on.</span>
<span class="line-modified">1683   if (!UseCompressedOops) {</span>






1684     if (UseCompressedClassPointers) {
1685       warning(&quot;UseCompressedClassPointers requires UseCompressedOops&quot;);
1686     }
1687     FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1688   } else {
1689     // Turn on UseCompressedClassPointers too
1690     if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
1691       FLAG_SET_ERGO(UseCompressedClassPointers, true);
1692     }
1693     // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
1694     if (UseCompressedClassPointers) {
1695       if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
1696         warning(&quot;CompressedClassSpaceSize is too large for UseCompressedClassPointers&quot;);
1697         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1698       }
1699     }
1700   }
1701 #endif // _LP64
1702 #endif // !ZERO
1703 }
</pre>
<hr />
<pre>
1792   // then set it as fraction of the size of physical memory,
1793   // respecting the maximum and minimum sizes of the heap.
1794   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1795     julong reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
1796     const julong reasonable_min = (julong)((phys_mem * MinRAMPercentage) / 100);
1797     if (reasonable_min &lt; MaxHeapSize) {
1798       // Small physical memory, so use a minimum fraction of it for the heap
1799       reasonable_max = reasonable_min;
1800     } else {
1801       // Not-small physical memory, so require a heap at least
1802       // as large as MaxHeapSize
1803       reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
1804     }
1805 
1806     if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
1807       // Limit the heap size to ErgoHeapSizeLimit
1808       reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
1809     }
1810 
1811 #ifdef _LP64
<span class="line-modified">1812     if (UseCompressedOops) {</span>
<span class="line-removed">1813       // Limit the heap size to the maximum possible when using compressed oops</span>
<span class="line-removed">1814       julong max_coop_heap = (julong)max_heap_for_compressed_oops();</span>
<span class="line-removed">1815 </span>
1816       // HeapBaseMinAddress can be greater than default but not less than.
1817       if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
1818         if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
1819           // matches compressed oops printing flags
1820           log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
1821                                      &quot; (&quot; SIZE_FORMAT &quot;G) which is greater than value given &quot; SIZE_FORMAT,
1822                                      DefaultHeapBaseMinAddress,
1823                                      DefaultHeapBaseMinAddress/G,
1824                                      HeapBaseMinAddress);
1825           FLAG_SET_ERGO(HeapBaseMinAddress, DefaultHeapBaseMinAddress);
1826         }
1827       }




1828 
1829       if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
1830         // Heap should be above HeapBaseMinAddress to get zero based compressed oops
1831         // but it should be not less than default MaxHeapSize.
1832         max_coop_heap -= HeapBaseMinAddress;
1833       }
1834 
1835       // If user specified flags prioritizing os physical
1836       // memory limits, then disable compressed oops if
1837       // limits exceed max_coop_heap and UseCompressedOops
1838       // was not specified.
1839       if (reasonable_max &gt; max_coop_heap) {
1840         if (FLAG_IS_ERGO(UseCompressedOops) &amp;&amp; override_coop_limit) {
1841           log_info(cds)(&quot;UseCompressedOops and UseCompressedClassPointers have been disabled due to&quot;
1842             &quot; max heap &quot; SIZE_FORMAT &quot; &gt; compressed oop heap &quot; SIZE_FORMAT &quot;. &quot;
1843             &quot;Please check the setting of MaxRAMPercentage %5.2f.&quot;
1844             ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);
1845           FLAG_SET_ERGO(UseCompressedOops, false);
<span class="line-modified">1846           FLAG_SET_ERGO(UseCompressedClassPointers, false);</span>


1847         } else {
1848           reasonable_max = MIN2(reasonable_max, max_coop_heap);
1849         }
1850       }
1851     }
1852 #endif // _LP64
1853 
1854     reasonable_max = limit_by_allocatable_memory(reasonable_max);
1855 
1856     if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
1857       // An initial heap size was specified on the command line,
1858       // so be sure that the maximum size is consistent.  Done
1859       // after call to limit_by_allocatable_memory because that
1860       // method might reduce the allocation size.
1861       reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
1862     } else if (!FLAG_IS_DEFAULT(MinHeapSize)) {
1863       reasonable_max = MAX2(reasonable_max, (julong)MinHeapSize);
1864     }
1865 
1866     log_trace(gc, heap)(&quot;  Maximum heap size &quot; SIZE_FORMAT, (size_t) reasonable_max);
</pre>
</td>
<td>
<hr />
<pre>
1649   LP64_ONLY(return OopEncodingHeapMax - displacement_due_to_null_page);
1650   NOT_LP64(ShouldNotReachHere(); return 0);
1651 }
1652 
1653 void Arguments::set_use_compressed_oops() {
1654 #ifndef ZERO
1655 #ifdef _LP64
1656   // MaxHeapSize is not set up properly at this point, but
1657   // the only value that can override MaxHeapSize if we are
1658   // to use UseCompressedOops are InitialHeapSize and MinHeapSize.
1659   size_t max_heap_size = MAX3(MaxHeapSize, InitialHeapSize, MinHeapSize);
1660 
1661   if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
1662     if (FLAG_IS_DEFAULT(UseCompressedOops)) {
1663       FLAG_SET_ERGO(UseCompressedOops, true);
1664     }
1665   } else {
1666     if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
1667       warning(&quot;Max heap size too large for Compressed Oops&quot;);
1668       FLAG_SET_DEFAULT(UseCompressedOops, false);
<span class="line-modified">1669       if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {</span>
<span class="line-added">1670         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);</span>
<span class="line-added">1671       }</span>
1672     }
1673   }
1674 #endif // _LP64
1675 #endif // ZERO
1676 }
1677 
1678 
1679 // NOTE: set_use_compressed_klass_ptrs() must be called after calling
1680 // set_use_compressed_oops().
1681 void Arguments::set_use_compressed_klass_ptrs() {
1682 #ifndef ZERO
1683 #ifdef _LP64
<span class="line-modified">1684   // On some architectures, the use of UseCompressedClassPointers implies the use of</span>
<span class="line-modified">1685   // UseCompressedOops. The reason is that the rheap_base register of said platforms</span>
<span class="line-added">1686   // is reused to perform some optimized spilling, in order to use rheap_base as a</span>
<span class="line-added">1687   // temp register. But by treating it as any other temp register, spilling can typically</span>
<span class="line-added">1688   // be completely avoided instead. So it is better not to perform this trick. And by</span>
<span class="line-added">1689   // not having that reliance, large heaps, or heaps not supporting compressed oops,</span>
<span class="line-added">1690   // can still use compressed class pointers.</span>
<span class="line-added">1691   if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS &amp;&amp; !UseCompressedOops) {</span>
1692     if (UseCompressedClassPointers) {
1693       warning(&quot;UseCompressedClassPointers requires UseCompressedOops&quot;);
1694     }
1695     FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1696   } else {
1697     // Turn on UseCompressedClassPointers too
1698     if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
1699       FLAG_SET_ERGO(UseCompressedClassPointers, true);
1700     }
1701     // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
1702     if (UseCompressedClassPointers) {
1703       if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
1704         warning(&quot;CompressedClassSpaceSize is too large for UseCompressedClassPointers&quot;);
1705         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1706       }
1707     }
1708   }
1709 #endif // _LP64
1710 #endif // !ZERO
1711 }
</pre>
<hr />
<pre>
1800   // then set it as fraction of the size of physical memory,
1801   // respecting the maximum and minimum sizes of the heap.
1802   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1803     julong reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
1804     const julong reasonable_min = (julong)((phys_mem * MinRAMPercentage) / 100);
1805     if (reasonable_min &lt; MaxHeapSize) {
1806       // Small physical memory, so use a minimum fraction of it for the heap
1807       reasonable_max = reasonable_min;
1808     } else {
1809       // Not-small physical memory, so require a heap at least
1810       // as large as MaxHeapSize
1811       reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
1812     }
1813 
1814     if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
1815       // Limit the heap size to ErgoHeapSizeLimit
1816       reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
1817     }
1818 
1819 #ifdef _LP64
<span class="line-modified">1820     if (UseCompressedOops || UseCompressedClassPointers) {</span>



1821       // HeapBaseMinAddress can be greater than default but not less than.
1822       if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
1823         if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
1824           // matches compressed oops printing flags
1825           log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
1826                                      &quot; (&quot; SIZE_FORMAT &quot;G) which is greater than value given &quot; SIZE_FORMAT,
1827                                      DefaultHeapBaseMinAddress,
1828                                      DefaultHeapBaseMinAddress/G,
1829                                      HeapBaseMinAddress);
1830           FLAG_SET_ERGO(HeapBaseMinAddress, DefaultHeapBaseMinAddress);
1831         }
1832       }
<span class="line-added">1833     }</span>
<span class="line-added">1834     if (UseCompressedOops) {</span>
<span class="line-added">1835       // Limit the heap size to the maximum possible when using compressed oops</span>
<span class="line-added">1836       julong max_coop_heap = (julong)max_heap_for_compressed_oops();</span>
1837 
1838       if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
1839         // Heap should be above HeapBaseMinAddress to get zero based compressed oops
1840         // but it should be not less than default MaxHeapSize.
1841         max_coop_heap -= HeapBaseMinAddress;
1842       }
1843 
1844       // If user specified flags prioritizing os physical
1845       // memory limits, then disable compressed oops if
1846       // limits exceed max_coop_heap and UseCompressedOops
1847       // was not specified.
1848       if (reasonable_max &gt; max_coop_heap) {
1849         if (FLAG_IS_ERGO(UseCompressedOops) &amp;&amp; override_coop_limit) {
1850           log_info(cds)(&quot;UseCompressedOops and UseCompressedClassPointers have been disabled due to&quot;
1851             &quot; max heap &quot; SIZE_FORMAT &quot; &gt; compressed oop heap &quot; SIZE_FORMAT &quot;. &quot;
1852             &quot;Please check the setting of MaxRAMPercentage %5.2f.&quot;
1853             ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);
1854           FLAG_SET_ERGO(UseCompressedOops, false);
<span class="line-modified">1855           if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {</span>
<span class="line-added">1856             FLAG_SET_ERGO(UseCompressedClassPointers, false);</span>
<span class="line-added">1857           }</span>
1858         } else {
1859           reasonable_max = MIN2(reasonable_max, max_coop_heap);
1860         }
1861       }
1862     }
1863 #endif // _LP64
1864 
1865     reasonable_max = limit_by_allocatable_memory(reasonable_max);
1866 
1867     if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
1868       // An initial heap size was specified on the command line,
1869       // so be sure that the maximum size is consistent.  Done
1870       // after call to limit_by_allocatable_memory because that
1871       // method might reduce the allocation size.
1872       reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
1873     } else if (!FLAG_IS_DEFAULT(MinHeapSize)) {
1874       reasonable_max = MAX2(reasonable_max, (julong)MinHeapSize);
1875     }
1876 
1877     log_trace(gc, heap)(&quot;  Maximum heap size &quot; SIZE_FORMAT, (size_t) reasonable_max);
</pre>
</td>
</tr>
</table>
<center><a href="../prims/whitebox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
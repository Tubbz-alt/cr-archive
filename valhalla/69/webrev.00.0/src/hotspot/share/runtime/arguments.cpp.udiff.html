<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/arguments.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../prims/whitebox.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/arguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1664,11 +1664,13 @@</span>
      }
    } else {
      if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
        warning(&quot;Max heap size too large for Compressed Oops&quot;);
        FLAG_SET_DEFAULT(UseCompressedOops, false);
<span class="udiff-line-modified-removed">-       FLAG_SET_DEFAULT(UseCompressedClassPointers, false);</span>
<span class="udiff-line-modified-added">+       if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {</span>
<span class="udiff-line-added">+         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);</span>
<span class="udiff-line-added">+       }</span>
      }
    }
  #endif // _LP64
  #endif // ZERO
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1677,12 +1679,18 @@</span>
  // NOTE: set_use_compressed_klass_ptrs() must be called after calling
  // set_use_compressed_oops().
  void Arguments::set_use_compressed_klass_ptrs() {
  #ifndef ZERO
  #ifdef _LP64
<span class="udiff-line-modified-removed">-   // UseCompressedOops must be on for UseCompressedClassPointers to be on.</span>
<span class="udiff-line-modified-removed">-   if (!UseCompressedOops) {</span>
<span class="udiff-line-modified-added">+   // On some architectures, the use of UseCompressedClassPointers implies the use of</span>
<span class="udiff-line-modified-added">+   // UseCompressedOops. The reason is that the rheap_base register of said platforms</span>
<span class="udiff-line-added">+   // is reused to perform some optimized spilling, in order to use rheap_base as a</span>
<span class="udiff-line-added">+   // temp register. But by treating it as any other temp register, spilling can typically</span>
<span class="udiff-line-added">+   // be completely avoided instead. So it is better not to perform this trick. And by</span>
<span class="udiff-line-added">+   // not having that reliance, large heaps, or heaps not supporting compressed oops,</span>
<span class="udiff-line-added">+   // can still use compressed class pointers.</span>
<span class="udiff-line-added">+   if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS &amp;&amp; !UseCompressedOops) {</span>
      if (UseCompressedClassPointers) {
        warning(&quot;UseCompressedClassPointers requires UseCompressedOops&quot;);
      }
      FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1807,14 +1815,11 @@</span>
        // Limit the heap size to ErgoHeapSizeLimit
        reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
      }
  
  #ifdef _LP64
<span class="udiff-line-modified-removed">-     if (UseCompressedOops) {</span>
<span class="udiff-line-removed">-       // Limit the heap size to the maximum possible when using compressed oops</span>
<span class="udiff-line-removed">-       julong max_coop_heap = (julong)max_heap_for_compressed_oops();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     if (UseCompressedOops || UseCompressedClassPointers) {</span>
        // HeapBaseMinAddress can be greater than default but not less than.
        if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
          if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
            // matches compressed oops printing flags
            log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1823,10 +1828,14 @@</span>
                                       DefaultHeapBaseMinAddress/G,
                                       HeapBaseMinAddress);
            FLAG_SET_ERGO(HeapBaseMinAddress, DefaultHeapBaseMinAddress);
          }
        }
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (UseCompressedOops) {</span>
<span class="udiff-line-added">+       // Limit the heap size to the maximum possible when using compressed oops</span>
<span class="udiff-line-added">+       julong max_coop_heap = (julong)max_heap_for_compressed_oops();</span>
  
        if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
          // Heap should be above HeapBaseMinAddress to get zero based compressed oops
          // but it should be not less than default MaxHeapSize.
          max_coop_heap -= HeapBaseMinAddress;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1841,11 +1850,13 @@</span>
            log_info(cds)(&quot;UseCompressedOops and UseCompressedClassPointers have been disabled due to&quot;
              &quot; max heap &quot; SIZE_FORMAT &quot; &gt; compressed oop heap &quot; SIZE_FORMAT &quot;. &quot;
              &quot;Please check the setting of MaxRAMPercentage %5.2f.&quot;
              ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);
            FLAG_SET_ERGO(UseCompressedOops, false);
<span class="udiff-line-modified-removed">-           FLAG_SET_ERGO(UseCompressedClassPointers, false);</span>
<span class="udiff-line-modified-added">+           if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {</span>
<span class="udiff-line-added">+             FLAG_SET_ERGO(UseCompressedClassPointers, false);</span>
<span class="udiff-line-added">+           }</span>
          } else {
            reasonable_max = MIN2(reasonable_max, max_coop_heap);
          }
        }
      }
</pre>
<center><a href="../prims/whitebox.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
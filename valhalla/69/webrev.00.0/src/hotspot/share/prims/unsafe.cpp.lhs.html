<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/unsafe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
<a name="1" id="anc1"></a>
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;jfr/jfrEvents.hpp&quot;
  32 #include &quot;memory/allocation.inline.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;logging/logStream.hpp&quot;
  36 #include &quot;oops/access.inline.hpp&quot;
  37 #include &quot;oops/fieldStreams.inline.hpp&quot;
<a name="2" id="anc2"></a>
  38 #include &quot;oops/objArrayOop.inline.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  41 #include &quot;oops/valueArrayKlass.hpp&quot;
  42 #include &quot;oops/valueArrayOop.inline.hpp&quot;
  43 #include &quot;oops/valueKlass.inline.hpp&quot;
  44 #include &quot;prims/unsafe.hpp&quot;
  45 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  46 #include &quot;runtime/globals.hpp&quot;
  47 #include &quot;runtime/handles.inline.hpp&quot;
  48 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  49 #include &quot;runtime/jniHandles.inline.hpp&quot;
  50 #include &quot;runtime/orderAccess.hpp&quot;
  51 #include &quot;runtime/reflection.hpp&quot;
  52 #include &quot;runtime/sharedRuntime.hpp&quot;
  53 #include &quot;runtime/thread.hpp&quot;
  54 #include &quot;runtime/threadSMR.hpp&quot;
  55 #include &quot;runtime/vm_version.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/copy.hpp&quot;
  59 #include &quot;utilities/dtrace.hpp&quot;
  60 #include &quot;utilities/macros.hpp&quot;
  61 
  62 /**
  63  * Implementation of the jdk.internal.misc.Unsafe class
  64  */
  65 
  66 
  67 #define MAX_OBJECT_SIZE \
  68   ( arrayOopDesc::header_size(T_DOUBLE) * HeapWordSize \
  69     + ((julong)max_jint * sizeof(double)) )
  70 
  71 
  72 #define UNSAFE_ENTRY(result_type, header) \
  73   JVM_ENTRY(static result_type, header)
  74 
  75 #define UNSAFE_LEAF(result_type, header) \
  76   JVM_LEAF(static result_type, header)
  77 
  78 #define UNSAFE_END JVM_END
  79 
  80 
  81 static inline void* addr_from_java(jlong addr) {
  82   // This assert fails in a variety of ways on 32-bit systems.
  83   // It is impossible to predict whether native code that converts
  84   // pointers to longs will sign-extend or zero-extend the addresses.
  85   //assert(addr == (uintptr_t)addr, &quot;must not be odd high bits&quot;);
  86   return (void*)(uintptr_t)addr;
  87 }
  88 
  89 static inline jlong addr_to_java(void* p) {
  90   assert(p == (void*)(uintptr_t)p, &quot;must not be odd high bits&quot;);
  91   return (uintptr_t)p;
  92 }
  93 
  94 
  95 // Note: The VM&#39;s obj_field and related accessors use byte-scaled
  96 // (&quot;unscaled&quot;) offsets, just as the unsafe methods do.
  97 
  98 // However, the method Unsafe.fieldOffset explicitly declines to
  99 // guarantee this.  The field offset values manipulated by the Java user
 100 // through the Unsafe API are opaque cookies that just happen to be byte
 101 // offsets.  We represent this state of affairs by passing the cookies
 102 // through conversion functions when going between the VM and the Unsafe API.
 103 // The conversion functions just happen to be no-ops at present.
 104 
 105 static inline jlong field_offset_to_byte_offset(jlong field_offset) {
 106   return field_offset;
 107 }
 108 
 109 static inline jlong field_offset_from_byte_offset(jlong byte_offset) {
 110   return byte_offset;
 111 }
 112 
 113 static inline void assert_field_offset_sane(oop p, jlong field_offset) {
 114 #ifdef ASSERT
 115   jlong byte_offset = field_offset_to_byte_offset(field_offset);
 116 
 117   if (p != NULL) {
 118     assert(byte_offset &gt;= 0 &amp;&amp; byte_offset &lt;= (jlong)MAX_OBJECT_SIZE, &quot;sane offset&quot;);
 119     if (byte_offset == (jint)byte_offset) {
 120       void* ptr_plus_disp = cast_from_oop&lt;address&gt;(p) + byte_offset;
 121       assert(p-&gt;field_addr_raw((jint)byte_offset) == ptr_plus_disp,
 122              &quot;raw [ptr+disp] must be consistent with oop::field_addr_raw&quot;);
 123     }
 124     jlong p_size = HeapWordSize * (jlong)(p-&gt;size());
 125     assert(byte_offset &lt; p_size, &quot;Unsafe access: offset &quot; INT64_FORMAT &quot; &gt; object&#39;s size &quot; INT64_FORMAT, (int64_t)byte_offset, (int64_t)p_size);
 126   }
 127 #endif
 128 }
 129 
 130 static inline void* index_oop_from_field_offset_long(oop p, jlong field_offset) {
 131   assert_field_offset_sane(p, field_offset);
 132   jlong byte_offset = field_offset_to_byte_offset(field_offset);
 133 
 134   if (p != NULL) {
 135     p = Access&lt;&gt;::resolve(p);
 136   }
 137 
 138   if (sizeof(char*) == sizeof(jint)) {   // (this constant folds!)
 139     return cast_from_oop&lt;address&gt;(p) + (jint) byte_offset;
 140   } else {
 141     return cast_from_oop&lt;address&gt;(p) +        byte_offset;
 142   }
 143 }
 144 
 145 // Externally callable versions:
 146 // (Use these in compiler intrinsics which emulate unsafe primitives.)
 147 jlong Unsafe_field_offset_to_byte_offset(jlong field_offset) {
 148   return field_offset;
 149 }
 150 jlong Unsafe_field_offset_from_byte_offset(jlong byte_offset) {
 151   return byte_offset;
 152 }
 153 
 154 ///// Data read/writes on the Java heap and in native (off-heap) memory
 155 
 156 /**
 157  * Helper class to wrap memory accesses in JavaThread::doing_unsafe_access()
 158  */
 159 class GuardUnsafeAccess {
 160   JavaThread* _thread;
 161 
 162 public:
 163   GuardUnsafeAccess(JavaThread* thread) : _thread(thread) {
 164     // native/off-heap access which may raise SIGBUS if accessing
 165     // memory mapped file data in a region of the file which has
 166     // been truncated and is now invalid.
 167     _thread-&gt;set_doing_unsafe_access(true);
 168   }
 169 
 170   ~GuardUnsafeAccess() {
 171     _thread-&gt;set_doing_unsafe_access(false);
 172   }
 173 };
 174 
 175 /**
 176  * Helper class for accessing memory.
 177  *
 178  * Normalizes values and wraps accesses in
 179  * JavaThread::doing_unsafe_access() if needed.
 180  */
 181 template &lt;typename T&gt;
 182 class MemoryAccess : StackObj {
 183   JavaThread* _thread;
 184   oop _obj;
 185   ptrdiff_t _offset;
 186 
 187   // Resolves and returns the address of the memory access.
 188   // This raw memory access may fault, so we make sure it happens within the
 189   // guarded scope by making the access volatile at least. Since the store
 190   // of Thread::set_doing_unsafe_access() is also volatile, these accesses
 191   // can not be reordered by the compiler. Therefore, if the access triggers
 192   // a fault, we will know that Thread::doing_unsafe_access() returns true.
 193   volatile T* addr() {
 194     void* addr = index_oop_from_field_offset_long(_obj, _offset);
 195     return static_cast&lt;volatile T*&gt;(addr);
 196   }
 197 
 198   template &lt;typename U&gt;
 199   U normalize_for_write(U x) {
 200     return x;
 201   }
 202 
 203   jboolean normalize_for_write(jboolean x) {
 204     return x &amp; 1;
 205   }
 206 
 207   template &lt;typename U&gt;
 208   U normalize_for_read(U x) {
 209     return x;
 210   }
 211 
 212   jboolean normalize_for_read(jboolean x) {
 213     return x != 0;
 214   }
 215 
 216 public:
 217   MemoryAccess(JavaThread* thread, jobject obj, jlong offset)
 218     : _thread(thread), _obj(JNIHandles::resolve(obj)), _offset((ptrdiff_t)offset) {
 219     assert_field_offset_sane(_obj, offset);
 220   }
 221 
 222   T get() {
 223     if (_obj == NULL) {
 224       GuardUnsafeAccess guard(_thread);
 225       T ret = RawAccess&lt;&gt;::load(addr());
 226       return normalize_for_read(ret);
 227     } else {
 228       T ret = HeapAccess&lt;&gt;::load_at(_obj, _offset);
 229       return normalize_for_read(ret);
 230     }
 231   }
 232 
 233   void put(T x) {
 234     if (_obj == NULL) {
 235       GuardUnsafeAccess guard(_thread);
 236       RawAccess&lt;&gt;::store(addr(), normalize_for_write(x));
 237     } else {
 238       assert(!_obj-&gt;is_value() || _obj-&gt;mark().is_larval_state(), &quot;must be an object instance or a larval value&quot;);
 239       HeapAccess&lt;&gt;::store_at(_obj, _offset, normalize_for_write(x));
 240     }
 241   }
 242 
 243   T get_volatile() {
 244     if (_obj == NULL) {
 245       GuardUnsafeAccess guard(_thread);
 246       volatile T ret = RawAccess&lt;MO_SEQ_CST&gt;::load(addr());
 247       return normalize_for_read(ret);
 248     } else {
 249       T ret = HeapAccess&lt;MO_SEQ_CST&gt;::load_at(_obj, _offset);
 250       return normalize_for_read(ret);
 251     }
 252   }
 253 
 254   void put_volatile(T x) {
 255     if (_obj == NULL) {
 256       GuardUnsafeAccess guard(_thread);
 257       RawAccess&lt;MO_SEQ_CST&gt;::store(addr(), normalize_for_write(x));
 258     } else {
 259       HeapAccess&lt;MO_SEQ_CST&gt;::store_at(_obj, _offset, normalize_for_write(x));
 260     }
 261   }
 262 };
 263 
 264 #ifdef ASSERT
 265 /*
 266  * Get the field descriptor of the field of the given object at the given offset.
 267  */
 268 static bool get_field_descriptor(oop p, jlong offset, fieldDescriptor* fd) {
 269   bool found = false;
 270   Klass* k = p-&gt;klass();
 271   if (k-&gt;is_instance_klass()) {
 272     InstanceKlass* ik = InstanceKlass::cast(k);
 273     found = ik-&gt;find_field_from_offset((int)offset, false, fd);
 274     if (!found &amp;&amp; ik-&gt;is_mirror_instance_klass()) {
 275       Klass* k2 = java_lang_Class::as_Klass(p);
 276       if (k2-&gt;is_instance_klass()) {
 277         ik = InstanceKlass::cast(k2);
 278         found = ik-&gt;find_field_from_offset((int)offset, true, fd);
 279       }
 280     }
 281   }
 282   return found;
 283 }
 284 #endif // ASSERT
 285 
 286 static void assert_and_log_unsafe_value_access(oop p, jlong offset, ValueKlass* vk) {
 287   Klass* k = p-&gt;klass();
 288 #ifdef ASSERT
 289   if (k-&gt;is_instance_klass()) {
 290     assert_field_offset_sane(p, offset);
 291     fieldDescriptor fd;
 292     bool found = get_field_descriptor(p, offset, &amp;fd);
 293     if (found) {
 294       assert(found, &quot;value field not found&quot;);
 295       assert(fd.is_flattened(), &quot;field not flat&quot;);
 296     } else {
 297       if (log_is_enabled(Trace, valuetypes)) {
 298         log_trace(valuetypes)(&quot;not a field in %s at offset &quot; SIZE_FORMAT_HEX,
 299                               p-&gt;klass()-&gt;external_name(), offset);
 300       }
 301     }
 302   } else if (k-&gt;is_valueArray_klass()) {
 303     ValueArrayKlass* vak = ValueArrayKlass::cast(k);
 304     int index = (offset - vak-&gt;array_header_in_bytes()) / vak-&gt;element_byte_size();
 305     address dest = (address)((valueArrayOop)p)-&gt;value_at_addr(index, vak-&gt;layout_helper());
 306     assert(dest == (cast_from_oop&lt;address&gt;(p) + offset), &quot;invalid offset&quot;);
 307   } else {
 308     ShouldNotReachHere();
 309   }
 310 #endif // ASSERT
 311   if (log_is_enabled(Trace, valuetypes)) {
 312     if (k-&gt;is_valueArray_klass()) {
 313       ValueArrayKlass* vak = ValueArrayKlass::cast(k);
 314       int index = (offset - vak-&gt;array_header_in_bytes()) / vak-&gt;element_byte_size();
 315       address dest = (address)((valueArrayOop)p)-&gt;value_at_addr(index, vak-&gt;layout_helper());
 316       log_trace(valuetypes)(&quot;%s array type %s index %d element size %d offset &quot; SIZE_FORMAT_HEX &quot; at &quot; INTPTR_FORMAT,
 317                             p-&gt;klass()-&gt;external_name(), vak-&gt;external_name(),
 318                             index, vak-&gt;element_byte_size(), offset, p2i(dest));
 319     } else {
 320       log_trace(valuetypes)(&quot;%s field type %s at offset &quot; SIZE_FORMAT_HEX,
 321                             p-&gt;klass()-&gt;external_name(), vk-&gt;external_name(), offset);
 322     }
 323   }
 324 }
 325 
 326 // These functions allow a null base pointer with an arbitrary address.
 327 // But if the base pointer is non-null, the offset should make some sense.
 328 // That is, it should be in the range [0, MAX_OBJECT_SIZE].
 329 UNSAFE_ENTRY(jobject, Unsafe_GetReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 330   oop p = JNIHandles::resolve(obj);
 331   assert_field_offset_sane(p, offset);
 332   oop v = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(p, offset);
 333   return JNIHandles::make_local(env, v);
 334 } UNSAFE_END
 335 
 336 UNSAFE_ENTRY(void, Unsafe_PutReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 337   oop x = JNIHandles::resolve(x_h);
 338   oop p = JNIHandles::resolve(obj);
 339   assert_field_offset_sane(p, offset);
 340   assert(!p-&gt;is_value() || p-&gt;mark().is_larval_state(), &quot;must be an object instance or a larval value&quot;);
 341   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 342 } UNSAFE_END
 343 
 344 UNSAFE_ENTRY(jlong, Unsafe_ValueHeaderSize(JNIEnv *env, jobject unsafe, jclass c)) {
 345   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));
 346   ValueKlass* vk = ValueKlass::cast(k);
 347   return vk-&gt;first_field_offset();
 348 } UNSAFE_END
 349 
 350 UNSAFE_ENTRY(jboolean, Unsafe_IsFlattenedArray(JNIEnv *env, jobject unsafe, jclass c)) {
 351   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));
 352   return k-&gt;is_valueArray_klass();
 353 } UNSAFE_END
 354 
 355 UNSAFE_ENTRY(jobject, Unsafe_UninitializedDefaultValue(JNIEnv *env, jobject unsafe, jclass vc)) {
 356   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));
 357   ValueKlass* vk = ValueKlass::cast(k);
 358   oop v = vk-&gt;default_value();
 359   return JNIHandles::make_local(env, v);
 360 } UNSAFE_END
 361 
 362 UNSAFE_ENTRY(jobject, Unsafe_GetValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc)) {
 363   oop base = JNIHandles::resolve(obj);
 364   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));
 365   ValueKlass* vk = ValueKlass::cast(k);
 366   assert_and_log_unsafe_value_access(base, offset, vk);
 367   Handle base_h(THREAD, base);
 368   oop v = vk-&gt;read_flattened_field(base_h(), offset, CHECK_NULL);
 369   return JNIHandles::make_local(env, v);
 370 } UNSAFE_END
 371 
 372 UNSAFE_ENTRY(void, Unsafe_PutValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc, jobject value)) {
 373   oop base = JNIHandles::resolve(obj);
 374   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));
 375   ValueKlass* vk = ValueKlass::cast(k);
 376   assert(!base-&gt;is_value() || base-&gt;mark().is_larval_state(), &quot;must be an object instance or a larval value&quot;);
 377   assert_and_log_unsafe_value_access(base, offset, vk);
 378   oop v = JNIHandles::resolve(value);
 379   vk-&gt;write_flattened_field(base, offset, v, CHECK);
 380 } UNSAFE_END
 381 
 382 UNSAFE_ENTRY(jobject, Unsafe_MakePrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {
 383   oop v = JNIHandles::resolve_non_null(value);
 384   assert(v-&gt;is_value(), &quot;must be a value instance&quot;);
 385   Handle vh(THREAD, v);
 386   ValueKlass* vk = ValueKlass::cast(v-&gt;klass());
 387   instanceOop new_value = vk-&gt;allocate_instance(CHECK_NULL);
 388   vk-&gt;value_copy_oop_to_new_oop(vh(),  new_value);
 389   markWord mark = new_value-&gt;mark();
 390   new_value-&gt;set_mark(mark.enter_larval_state());
 391   return JNIHandles::make_local(env, new_value);
 392 } UNSAFE_END
 393 
 394 UNSAFE_ENTRY(jobject, Unsafe_FinishPrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {
 395   oop v = JNIHandles::resolve(value);
 396   assert(v-&gt;mark().is_larval_state(), &quot;must be a larval value&quot;);
 397   markWord mark = v-&gt;mark();
 398   v-&gt;set_mark(mark.exit_larval_state());
 399   return JNIHandles::make_local(env, v);
 400 } UNSAFE_END
 401 
 402 UNSAFE_ENTRY(jobject, Unsafe_GetReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 403   oop p = JNIHandles::resolve(obj);
 404   assert_field_offset_sane(p, offset);
 405   oop v = HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_load_at(p, offset);
 406   return JNIHandles::make_local(env, v);
 407 } UNSAFE_END
 408 
 409 UNSAFE_ENTRY(void, Unsafe_PutReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 410   oop x = JNIHandles::resolve(x_h);
 411   oop p = JNIHandles::resolve(obj);
 412   assert_field_offset_sane(p, offset);
 413   HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 414 } UNSAFE_END
 415 
 416 UNSAFE_ENTRY(jobject, Unsafe_GetUncompressedObject(JNIEnv *env, jobject unsafe, jlong addr)) {
 417   oop v = *(oop*) (address) addr;
 418   return JNIHandles::make_local(env, v);
 419 } UNSAFE_END
 420 
 421 #define DEFINE_GETSETOOP(java_type, Type) \
 422  \
 423 UNSAFE_ENTRY(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \
 424   return MemoryAccess&lt;java_type&gt;(thread, obj, offset).get(); \
 425 } UNSAFE_END \
 426  \
 427 UNSAFE_ENTRY(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \
 428   MemoryAccess&lt;java_type&gt;(thread, obj, offset).put(x); \
 429 } UNSAFE_END \
 430  \
 431 // END DEFINE_GETSETOOP.
 432 
 433 DEFINE_GETSETOOP(jboolean, Boolean)
 434 DEFINE_GETSETOOP(jbyte, Byte)
 435 DEFINE_GETSETOOP(jshort, Short);
 436 DEFINE_GETSETOOP(jchar, Char);
 437 DEFINE_GETSETOOP(jint, Int);
 438 DEFINE_GETSETOOP(jlong, Long);
 439 DEFINE_GETSETOOP(jfloat, Float);
 440 DEFINE_GETSETOOP(jdouble, Double);
 441 
 442 #undef DEFINE_GETSETOOP
 443 
 444 #define DEFINE_GETSETOOP_VOLATILE(java_type, Type) \
 445  \
 446 UNSAFE_ENTRY(java_type, Unsafe_Get##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \
 447   return MemoryAccess&lt;java_type&gt;(thread, obj, offset).get_volatile(); \
 448 } UNSAFE_END \
 449  \
 450 UNSAFE_ENTRY(void, Unsafe_Put##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \
 451   MemoryAccess&lt;java_type&gt;(thread, obj, offset).put_volatile(x); \
 452 } UNSAFE_END \
 453  \
 454 // END DEFINE_GETSETOOP_VOLATILE.
 455 
 456 DEFINE_GETSETOOP_VOLATILE(jboolean, Boolean)
 457 DEFINE_GETSETOOP_VOLATILE(jbyte, Byte)
 458 DEFINE_GETSETOOP_VOLATILE(jshort, Short);
 459 DEFINE_GETSETOOP_VOLATILE(jchar, Char);
 460 DEFINE_GETSETOOP_VOLATILE(jint, Int);
 461 DEFINE_GETSETOOP_VOLATILE(jlong, Long);
 462 DEFINE_GETSETOOP_VOLATILE(jfloat, Float);
 463 DEFINE_GETSETOOP_VOLATILE(jdouble, Double);
 464 
 465 #undef DEFINE_GETSETOOP_VOLATILE
 466 
 467 UNSAFE_LEAF(void, Unsafe_LoadFence(JNIEnv *env, jobject unsafe)) {
 468   OrderAccess::acquire();
 469 } UNSAFE_END
 470 
 471 UNSAFE_LEAF(void, Unsafe_StoreFence(JNIEnv *env, jobject unsafe)) {
 472   OrderAccess::release();
 473 } UNSAFE_END
 474 
 475 UNSAFE_LEAF(void, Unsafe_FullFence(JNIEnv *env, jobject unsafe)) {
 476   OrderAccess::fence();
 477 } UNSAFE_END
 478 
 479 ////// Allocation requests
 480 
 481 UNSAFE_ENTRY(jobject, Unsafe_AllocateInstance(JNIEnv *env, jobject unsafe, jclass cls)) {
<a name="3" id="anc3"></a><span class="line-modified"> 482   ThreadToNativeFromVM ttnfv(thread);</span>
<span class="line-modified"> 483   return env-&gt;AllocObject(cls);</span>
 484 } UNSAFE_END
 485 
 486 UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)) {
 487   size_t sz = (size_t)size;
 488 
 489   assert(is_aligned(sz, HeapWordSize), &quot;sz not aligned&quot;);
 490 
 491   void* x = os::malloc(sz, mtOther);
 492 
 493   return addr_to_java(x);
 494 } UNSAFE_END
 495 
 496 UNSAFE_ENTRY(jlong, Unsafe_ReallocateMemory0(JNIEnv *env, jobject unsafe, jlong addr, jlong size)) {
 497   void* p = addr_from_java(addr);
 498   size_t sz = (size_t)size;
 499 
 500   assert(is_aligned(sz, HeapWordSize), &quot;sz not aligned&quot;);
 501 
 502   void* x = os::realloc(p, sz, mtOther);
 503 
 504   return addr_to_java(x);
 505 } UNSAFE_END
 506 
 507 UNSAFE_ENTRY(void, Unsafe_FreeMemory0(JNIEnv *env, jobject unsafe, jlong addr)) {
 508   void* p = addr_from_java(addr);
 509 
 510   os::free(p);
 511 } UNSAFE_END
 512 
 513 UNSAFE_ENTRY(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {
 514   size_t sz = (size_t)size;
 515 
 516   oop base = JNIHandles::resolve(obj);
 517   void* p = index_oop_from_field_offset_long(base, offset);
 518 
 519   Copy::fill_to_memory_atomic(p, sz, value);
 520 } UNSAFE_END
 521 
 522 UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {
 523   size_t sz = (size_t)size;
 524 
 525   oop srcp = JNIHandles::resolve(srcObj);
 526   oop dstp = JNIHandles::resolve(dstObj);
 527 
 528   void* src = index_oop_from_field_offset_long(srcp, srcOffset);
 529   void* dst = index_oop_from_field_offset_long(dstp, dstOffset);
 530   {
 531     GuardUnsafeAccess guard(thread);
 532     if (StubRoutines::unsafe_arraycopy() != NULL) {
 533       StubRoutines::UnsafeArrayCopy_stub()(src, dst, sz);
 534     } else {
 535       Copy::conjoint_memory_atomic(src, dst, sz);
 536     }
 537   }
 538 } UNSAFE_END
 539 
 540 // This function is a leaf since if the source and destination are both in native memory
 541 // the copy may potentially be very large, and we don&#39;t want to disable GC if we can avoid it.
 542 // If either source or destination (or both) are on the heap, the function will enter VM using
 543 // JVM_ENTRY_FROM_LEAF
 544 UNSAFE_LEAF(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {
 545   size_t sz = (size_t)size;
 546   size_t esz = (size_t)elemSize;
 547 
 548   if (srcObj == NULL &amp;&amp; dstObj == NULL) {
 549     // Both src &amp; dst are in native memory
 550     address src = (address)srcOffset;
 551     address dst = (address)dstOffset;
 552 
 553     {
 554       JavaThread* thread = JavaThread::thread_from_jni_environment(env);
 555       GuardUnsafeAccess guard(thread);
 556       Copy::conjoint_swap(src, dst, sz, esz);
 557     }
 558   } else {
 559     // At least one of src/dst are on heap, transition to VM to access raw pointers
 560 
 561     JVM_ENTRY_FROM_LEAF(env, void, Unsafe_CopySwapMemory0) {
 562       oop srcp = JNIHandles::resolve(srcObj);
 563       oop dstp = JNIHandles::resolve(dstObj);
 564 
 565       address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);
 566       address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);
 567 
 568       {
 569         GuardUnsafeAccess guard(thread);
 570         Copy::conjoint_swap(src, dst, sz, esz);
 571       }
 572     } JVM_END
 573   }
 574 } UNSAFE_END
 575 
 576 UNSAFE_LEAF (void, Unsafe_WriteBack0(JNIEnv *env, jobject unsafe, jlong line)) {
 577   assert(VM_Version::supports_data_cache_line_flush(), &quot;should not get here&quot;);
 578 #ifdef ASSERT
 579   if (TraceMemoryWriteback) {
 580     tty-&gt;print_cr(&quot;Unsafe: writeback 0x%p&quot;, addr_from_java(line));
 581   }
 582 #endif
 583 
 584   assert(StubRoutines::data_cache_writeback() != NULL, &quot;sanity&quot;);
 585   (StubRoutines::DataCacheWriteback_stub())(addr_from_java(line));
 586 } UNSAFE_END
 587 
 588 static void doWriteBackSync0(bool is_pre)
 589 {
 590   assert(StubRoutines::data_cache_writeback_sync() != NULL, &quot;sanity&quot;);
 591   (StubRoutines::DataCacheWritebackSync_stub())(is_pre);
 592 }
 593 
 594 UNSAFE_LEAF (void, Unsafe_WriteBackPreSync0(JNIEnv *env, jobject unsafe)) {
 595   assert(VM_Version::supports_data_cache_line_flush(), &quot;should not get here&quot;);
 596 #ifdef ASSERT
 597   if (TraceMemoryWriteback) {
 598       tty-&gt;print_cr(&quot;Unsafe: writeback pre-sync&quot;);
 599   }
 600 #endif
 601 
 602   doWriteBackSync0(true);
 603 } UNSAFE_END
 604 
 605 UNSAFE_LEAF (void, Unsafe_WriteBackPostSync0(JNIEnv *env, jobject unsafe)) {
 606   assert(VM_Version::supports_data_cache_line_flush(), &quot;should not get here&quot;);
 607 #ifdef ASSERT
 608   if (TraceMemoryWriteback) {
 609     tty-&gt;print_cr(&quot;Unsafe: writeback pre-sync&quot;);
 610   }
 611 #endif
 612 
 613   doWriteBackSync0(false);
 614 } UNSAFE_END
 615 
 616 ////// Random queries
 617 
 618 static jlong find_field_offset(jclass clazz, jstring name, TRAPS) {
 619   assert(clazz != NULL, &quot;clazz must not be NULL&quot;);
 620   assert(name != NULL, &quot;name must not be NULL&quot;);
 621 
 622   ResourceMark rm(THREAD);
 623   char *utf_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
 624 
 625   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 626 
 627   jint offset = -1;
 628   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
 629     Symbol *name = fs.name();
 630     if (name-&gt;equals(utf_name)) {
 631       offset = fs.offset();
 632       break;
 633     }
 634   }
 635   if (offset &lt; 0) {
 636     THROW_0(vmSymbols::java_lang_InternalError());
 637   }
 638   return field_offset_from_byte_offset(offset);
 639 }
 640 
 641 static jlong find_field_offset(jobject field, int must_be_static, TRAPS) {
 642   assert(field != NULL, &quot;field must not be NULL&quot;);
 643 
 644   oop reflected   = JNIHandles::resolve_non_null(field);
 645   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 646   Klass* k        = java_lang_Class::as_Klass(mirror);
 647   int slot        = java_lang_reflect_Field::slot(reflected);
 648   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 649 
 650   if (must_be_static &gt;= 0) {
 651     int really_is_static = ((modifiers &amp; JVM_ACC_STATIC) != 0);
 652     if (must_be_static != really_is_static) {
 653       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 654     }
 655   }
 656 
 657   int offset = InstanceKlass::cast(k)-&gt;field_offset(slot);
 658   return field_offset_from_byte_offset(offset);
 659 }
 660 
 661 UNSAFE_ENTRY(jlong, Unsafe_ObjectFieldOffset0(JNIEnv *env, jobject unsafe, jobject field)) {
 662   return find_field_offset(field, 0, THREAD);
 663 } UNSAFE_END
 664 
 665 UNSAFE_ENTRY(jlong, Unsafe_ObjectFieldOffset1(JNIEnv *env, jobject unsafe, jclass c, jstring name)) {
 666   return find_field_offset(c, name, THREAD);
 667 } UNSAFE_END
 668 
 669 UNSAFE_ENTRY(jlong, Unsafe_StaticFieldOffset0(JNIEnv *env, jobject unsafe, jobject field)) {
 670   return find_field_offset(field, 1, THREAD);
 671 } UNSAFE_END
 672 
 673 UNSAFE_ENTRY(jobject, Unsafe_StaticFieldBase0(JNIEnv *env, jobject unsafe, jobject field)) {
 674   assert(field != NULL, &quot;field must not be NULL&quot;);
 675 
 676   // Note:  In this VM implementation, a field address is always a short
 677   // offset from the base of a a klass metaobject.  Thus, the full dynamic
 678   // range of the return type is never used.  However, some implementations
 679   // might put the static field inside an array shared by many classes,
 680   // or even at a fixed address, in which case the address could be quite
 681   // large.  In that last case, this function would return NULL, since
 682   // the address would operate alone, without any base pointer.
 683 
 684   oop reflected   = JNIHandles::resolve_non_null(field);
 685   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 686   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 687 
 688   if ((modifiers &amp; JVM_ACC_STATIC) == 0) {
 689     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 690   }
 691 
 692   return JNIHandles::make_local(env, mirror);
 693 } UNSAFE_END
 694 
 695 UNSAFE_ENTRY(void, Unsafe_EnsureClassInitialized0(JNIEnv *env, jobject unsafe, jobject clazz)) {
 696   assert(clazz != NULL, &quot;clazz must not be NULL&quot;);
 697 
 698   oop mirror = JNIHandles::resolve_non_null(clazz);
 699 
 700   Klass* klass = java_lang_Class::as_Klass(mirror);
 701   if (klass != NULL &amp;&amp; klass-&gt;should_be_initialized()) {
 702     InstanceKlass* k = InstanceKlass::cast(klass);
 703     k-&gt;initialize(CHECK);
 704   }
 705 }
 706 UNSAFE_END
 707 
 708 UNSAFE_ENTRY(jboolean, Unsafe_ShouldBeInitialized0(JNIEnv *env, jobject unsafe, jobject clazz)) {
 709   assert(clazz != NULL, &quot;clazz must not be NULL&quot;);
 710 
 711   oop mirror = JNIHandles::resolve_non_null(clazz);
 712   Klass* klass = java_lang_Class::as_Klass(mirror);
 713 
 714   if (klass != NULL &amp;&amp; klass-&gt;should_be_initialized()) {
 715     return true;
 716   }
 717 
 718   return false;
 719 }
 720 UNSAFE_END
 721 
 722 static void getBaseAndScale(int&amp; base, int&amp; scale, jclass clazz, TRAPS) {
 723   assert(clazz != NULL, &quot;clazz must not be NULL&quot;);
 724 
 725   oop mirror = JNIHandles::resolve_non_null(clazz);
 726   Klass* k = java_lang_Class::as_Klass(mirror);
 727 
 728   if (k == NULL || !k-&gt;is_array_klass()) {
 729     THROW(vmSymbols::java_lang_InvalidClassException());
 730   } else if (k-&gt;is_objArray_klass()) {
 731     base  = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
 732     scale = heapOopSize;
 733   } else if (k-&gt;is_typeArray_klass()) {
 734     TypeArrayKlass* tak = TypeArrayKlass::cast(k);
 735     base  = tak-&gt;array_header_in_bytes();
 736     assert(base == arrayOopDesc::base_offset_in_bytes(tak-&gt;element_type()), &quot;array_header_size semantics ok&quot;);
 737     scale = (1 &lt;&lt; tak-&gt;log2_element_size());
 738   } else if (k-&gt;is_valueArray_klass()) {
 739     ValueArrayKlass* vak = ValueArrayKlass::cast(k);
 740     ValueKlass* vklass = vak-&gt;element_klass();
 741     base = vak-&gt;array_header_in_bytes();
 742     scale = vak-&gt;element_byte_size();
 743   } else {
 744     ShouldNotReachHere();
 745   }
 746 }
 747 
 748 UNSAFE_ENTRY(jint, Unsafe_ArrayBaseOffset0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 749   int base = 0, scale = 0;
 750   getBaseAndScale(base, scale, clazz, CHECK_0);
 751 
 752   return field_offset_from_byte_offset(base);
 753 } UNSAFE_END
 754 
 755 
 756 UNSAFE_ENTRY(jint, Unsafe_ArrayIndexScale0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 757   int base = 0, scale = 0;
 758   getBaseAndScale(base, scale, clazz, CHECK_0);
 759 
 760   // This VM packs both fields and array elements down to the byte.
 761   // But watch out:  If this changes, so that array references for
 762   // a given primitive type (say, T_BOOLEAN) use different memory units
 763   // than fields, this method MUST return zero for such arrays.
 764   // For example, the VM used to store sub-word sized fields in full
 765   // words in the object layout, so that accessors like getByte(Object,int)
 766   // did not really do what one might expect for arrays.  Therefore,
 767   // this function used to report a zero scale factor, so that the user
 768   // would know not to attempt to access sub-word array elements.
 769   // // Code for unpacked fields:
 770   // if (scale &lt; wordSize)  return 0;
 771 
 772   // The following allows for a pretty general fieldOffset cookie scheme,
 773   // but requires it to be linear in byte offset.
 774   return field_offset_from_byte_offset(scale) - field_offset_from_byte_offset(0);
 775 } UNSAFE_END
 776 
 777 
 778 UNSAFE_ENTRY(jlong, Unsafe_GetObjectSize0(JNIEnv* env, jobject o, jobject obj))
 779   oop p = JNIHandles::resolve(obj);
 780   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 781 UNSAFE_END
 782 
 783 
 784 static inline void throw_new(JNIEnv *env, const char *ename) {
 785   jclass cls = env-&gt;FindClass(ename);
 786   if (env-&gt;ExceptionCheck()) {
 787     env-&gt;ExceptionClear();
 788     tty-&gt;print_cr(&quot;Unsafe: cannot throw %s because FindClass has failed&quot;, ename);
 789     return;
 790   }
 791 
 792   env-&gt;ThrowNew(cls, NULL);
 793 }
 794 
 795 static jclass Unsafe_DefineClass_impl(JNIEnv *env, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd) {
 796   // Code lifted from JDK 1.3 ClassLoader.c
 797 
 798   jbyte *body;
 799   char *utfName = NULL;
 800   jclass result = 0;
 801   char buf[128];
 802 
 803   assert(data != NULL, &quot;Class bytes must not be NULL&quot;);
 804   assert(length &gt;= 0, &quot;length must not be negative: %d&quot;, length);
 805 
 806   if (UsePerfData) {
 807     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 808   }
 809 
 810   body = NEW_C_HEAP_ARRAY_RETURN_NULL(jbyte, length, mtInternal);
 811   if (body == NULL) {
 812     throw_new(env, &quot;java/lang/OutOfMemoryError&quot;);
 813     return 0;
 814   }
 815 
 816   env-&gt;GetByteArrayRegion(data, offset, length, body);
 817   if (env-&gt;ExceptionOccurred()) {
 818     goto free_body;
 819   }
 820 
 821   if (name != NULL) {
 822     uint len = env-&gt;GetStringUTFLength(name);
 823     int unicode_len = env-&gt;GetStringLength(name);
 824 
 825     if (len &gt;= sizeof(buf)) {
 826       utfName = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len + 1, mtInternal);
 827       if (utfName == NULL) {
 828         throw_new(env, &quot;java/lang/OutOfMemoryError&quot;);
 829         goto free_body;
 830       }
 831     } else {
 832       utfName = buf;
 833     }
 834 
 835     env-&gt;GetStringUTFRegion(name, 0, unicode_len, utfName);
 836 
 837     for (uint i = 0; i &lt; len; i++) {
 838       if (utfName[i] == &#39;.&#39;)   utfName[i] = &#39;/&#39;;
 839     }
 840   }
 841 
 842   result = JVM_DefineClass(env, utfName, loader, body, length, pd);
 843 
 844   if (utfName &amp;&amp; utfName != buf) {
 845     FREE_C_HEAP_ARRAY(char, utfName);
 846   }
 847 
 848  free_body:
 849   FREE_C_HEAP_ARRAY(jbyte, body);
 850   return result;
 851 }
 852 
 853 
 854 UNSAFE_ENTRY(jclass, Unsafe_DefineClass0(JNIEnv *env, jobject unsafe, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd)) {
 855   ThreadToNativeFromVM ttnfv(thread);
 856 
 857   return Unsafe_DefineClass_impl(env, name, data, offset, length, loader, pd);
 858 } UNSAFE_END
 859 
 860 
 861 // define a class but do not make it known to the class loader or system dictionary
 862 // - host_class:  supplies context for linkage, access control, protection domain, and class loader
 863 //                if host_class is itself anonymous then it is replaced with its host class.
 864 // - data:  bytes of a class file, a raw memory address (length gives the number of bytes)
 865 // - cp_patches:  where non-null entries exist, they replace corresponding CP entries in data
 866 
 867 // When you load an anonymous class U, it works as if you changed its name just before loading,
 868 // to a name that you will never use again.  Since the name is lost, no other class can directly
 869 // link to any member of U.  Just after U is loaded, the only way to use it is reflectively,
 870 // through java.lang.Class methods like Class.newInstance.
 871 
 872 // The package of an anonymous class must either match its host&#39;s class&#39;s package or be in the
 873 // unnamed package.  If it is in the unnamed package then it will be put in its host class&#39;s
 874 // package.
 875 //
 876 
 877 // Access checks for linkage sites within U continue to follow the same rules as for named classes.
 878 // An anonymous class also has special privileges to access any member of its host class.
 879 // This is the main reason why this loading operation is unsafe.  The purpose of this is to
 880 // allow language implementations to simulate &quot;open classes&quot;; a host class in effect gets
 881 // new code when an anonymous class is loaded alongside it.  A less convenient but more
 882 // standard way to do this is with reflection, which can also be set to ignore access
 883 // restrictions.
 884 
 885 // Access into an anonymous class is possible only through reflection.  Therefore, there
 886 // are no special access rules for calling into an anonymous class.  The relaxed access
 887 // rule for the host class is applied in the opposite direction:  A host class reflectively
 888 // access one of its anonymous classes.
 889 
 890 // If you load the same bytecodes twice, you get two different classes.  You can reload
 891 // the same bytecodes with or without varying CP patches.
 892 
 893 // By using the CP patching array, you can have a new anonymous class U2 refer to an older one U1.
 894 // The bytecodes for U2 should refer to U1 by a symbolic name (doesn&#39;t matter what the name is).
 895 // The CONSTANT_Class entry for that name can be patched to refer directly to U1.
 896 
 897 // This allows, for example, U2 to use U1 as a superclass or super-interface, or as
 898 // an outer class (so that U2 is an anonymous inner class of anonymous U1).
 899 // It is not possible for a named class, or an older anonymous class, to refer by
 900 // name (via its CP) to a newer anonymous class.
 901 
 902 // CP patching may also be used to modify (i.e., hack) the names of methods, classes,
 903 // or type descriptors used in the loaded anonymous class.
 904 
 905 // Finally, CP patching may be used to introduce &quot;live&quot; objects into the constant pool,
 906 // instead of &quot;dead&quot; strings.  A compiled statement like println((Object)&quot;hello&quot;) can
 907 // be changed to println(greeting), where greeting is an arbitrary object created before
 908 // the anonymous class is loaded.  This is useful in dynamic languages, in which
 909 // various kinds of metaobjects must be introduced as constants into bytecode.
 910 // Note the cast (Object), which tells the verifier to expect an arbitrary object,
 911 // not just a literal string.  For such ldc instructions, the verifier uses the
 912 // type Object instead of String, if the loaded constant is not in fact a String.
 913 
 914 static InstanceKlass*
 915 Unsafe_DefineAnonymousClass_impl(JNIEnv *env,
 916                                  jclass host_class, jbyteArray data, jobjectArray cp_patches_jh,
 917                                  u1** temp_alloc,
 918                                  TRAPS) {
 919   assert(host_class != NULL, &quot;host_class must not be NULL&quot;);
 920   assert(data != NULL, &quot;data must not be NULL&quot;);
 921 
 922   if (UsePerfData) {
 923     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 924   }
 925 
 926   jint length = typeArrayOop(JNIHandles::resolve_non_null(data))-&gt;length();
 927   assert(length &gt;= 0, &quot;class_bytes_length must not be negative: %d&quot;, length);
 928 
 929   int class_bytes_length = (int) length;
 930 
 931   u1* class_bytes = NEW_C_HEAP_ARRAY_RETURN_NULL(u1, length, mtInternal);
 932   if (class_bytes == NULL) {
 933     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
 934   }
 935 
 936   // caller responsible to free it:
 937   *temp_alloc = class_bytes;
 938 
 939   ArrayAccess&lt;&gt;::arraycopy_to_native(arrayOop(JNIHandles::resolve_non_null(data)), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0),
 940                                      reinterpret_cast&lt;jbyte*&gt;(class_bytes), length);
 941 
 942   objArrayHandle cp_patches_h;
 943   if (cp_patches_jh != NULL) {
 944     oop p = JNIHandles::resolve_non_null(cp_patches_jh);
 945     assert(p-&gt;is_objArray(), &quot;cp_patches must be an object[]&quot;);
 946     cp_patches_h = objArrayHandle(THREAD, (objArrayOop)p);
 947   }
 948 
 949   const Klass* host_klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(host_class));
 950 
 951   // Make sure it&#39;s the real host class, not another anonymous class.
 952   while (host_klass != NULL &amp;&amp; host_klass-&gt;is_instance_klass() &amp;&amp;
 953          InstanceKlass::cast(host_klass)-&gt;is_unsafe_anonymous()) {
 954     host_klass = InstanceKlass::cast(host_klass)-&gt;unsafe_anonymous_host();
 955   }
 956 
 957   // Primitive types have NULL Klass* fields in their java.lang.Class instances.
 958   if (host_klass == NULL) {
 959     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Host class is null&quot;);
 960   }
 961 
 962   assert(host_klass-&gt;is_instance_klass(), &quot;Host class must be an instance class&quot;);
 963 
 964   const char* host_source = host_klass-&gt;external_name();
 965   Handle      host_loader(THREAD, host_klass-&gt;class_loader());
 966   Handle      host_domain(THREAD, host_klass-&gt;protection_domain());
 967 
 968   GrowableArray&lt;Handle&gt;* cp_patches = NULL;
 969 
 970   if (cp_patches_h.not_null()) {
 971     int alen = cp_patches_h-&gt;length();
 972 
 973     for (int i = alen-1; i &gt;= 0; i--) {
 974       oop p = cp_patches_h-&gt;obj_at(i);
 975       if (p != NULL) {
 976         Handle patch(THREAD, p);
 977 
 978         if (cp_patches == NULL) {
 979           cp_patches = new GrowableArray&lt;Handle&gt;(i+1, i+1, Handle());
 980         }
 981 
 982         cp_patches-&gt;at_put(i, patch);
 983       }
 984     }
 985   }
 986 
 987   ClassFileStream st(class_bytes, class_bytes_length, host_source, ClassFileStream::verify);
 988 
 989   Symbol* no_class_name = NULL;
 990   ClassLoadInfo cl_info(host_domain,
 991                         InstanceKlass::cast(host_klass),
 992                         cp_patches,
 993                         NULL,     // dynamic_nest_host
 994                         Handle(), // classData
 995                         false,    // is_hidden
 996                         false,    // is_strong_hidden
 997                         true);    // can_access_vm_annotations
 998 
 999   Klass* anonk = SystemDictionary::parse_stream(no_class_name,
1000                                                 host_loader,
1001                                                 &amp;st,
1002                                                 cl_info,
1003                                                 CHECK_NULL);
1004   if (anonk == NULL) {
1005     return NULL;
1006   }
1007 
1008   return InstanceKlass::cast(anonk);
1009 }
1010 
1011 UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh)) {
1012   ResourceMark rm(THREAD);
1013 
1014   jobject res_jh = NULL;
1015   u1* temp_alloc = NULL;
1016 
1017   InstanceKlass* anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data, cp_patches_jh, &amp;temp_alloc, THREAD);
1018   if (anon_klass != NULL) {
1019     res_jh = JNIHandles::make_local(env, anon_klass-&gt;java_mirror());
1020   }
1021 
1022   // try/finally clause:
1023   FREE_C_HEAP_ARRAY(u1, temp_alloc);
1024 
1025   // The anonymous class loader data has been artificially been kept alive to
1026   // this point.   The mirror and any instances of this class have to keep
1027   // it alive afterwards.
1028   if (anon_klass != NULL) {
1029     anon_klass-&gt;class_loader_data()-&gt;dec_keep_alive();
1030   }
1031 
1032   // let caller initialize it as needed...
1033 
1034   return (jclass) res_jh;
1035 } UNSAFE_END
1036 
1037 
1038 
1039 UNSAFE_ENTRY(void, Unsafe_ThrowException(JNIEnv *env, jobject unsafe, jthrowable thr)) {
1040   ThreadToNativeFromVM ttnfv(thread);
1041   env-&gt;Throw(thr);
1042 } UNSAFE_END
1043 
1044 // JSR166 ------------------------------------------------------------------
1045 
1046 UNSAFE_ENTRY(jobject, Unsafe_CompareAndExchangeReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h)) {
1047   oop x = JNIHandles::resolve(x_h);
1048   oop e = JNIHandles::resolve(e_h);
1049   oop p = JNIHandles::resolve(obj);
1050   assert_field_offset_sane(p, offset);
1051   oop res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);
1052   return JNIHandles::make_local(env, res);
1053 } UNSAFE_END
1054 
1055 UNSAFE_ENTRY(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {
1056   oop p = JNIHandles::resolve(obj);
1057   if (p == NULL) {
1058     volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);
1059     return RawAccess&lt;&gt;::atomic_cmpxchg(addr, e, x);
1060   } else {
1061     assert_field_offset_sane(p, offset);
1062     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);
1063   }
1064 } UNSAFE_END
1065 
1066 UNSAFE_ENTRY(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {
1067   oop p = JNIHandles::resolve(obj);
1068   if (p == NULL) {
1069     volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);
1070     return RawAccess&lt;&gt;::atomic_cmpxchg(addr, e, x);
1071   } else {
1072     assert_field_offset_sane(p, offset);
1073     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);
1074   }
1075 } UNSAFE_END
1076 
1077 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h)) {
1078   oop x = JNIHandles::resolve(x_h);
1079   oop e = JNIHandles::resolve(e_h);
1080   oop p = JNIHandles::resolve(obj);
1081   assert_field_offset_sane(p, offset);
1082   oop ret = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);
1083   return ret == e;
1084 } UNSAFE_END
1085 
1086 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {
1087   oop p = JNIHandles::resolve(obj);
1088   if (p == NULL) {
1089     volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);
1090     return RawAccess&lt;&gt;::atomic_cmpxchg(addr, e, x) == e;
1091   } else {
1092     assert_field_offset_sane(p, offset);
1093     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;
1094   }
1095 } UNSAFE_END
1096 
1097 UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {
1098   oop p = JNIHandles::resolve(obj);
1099   if (p == NULL) {
1100     volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);
1101     return RawAccess&lt;&gt;::atomic_cmpxchg(addr, e, x) == e;
1102   } else {
1103     assert_field_offset_sane(p, offset);
1104     return HeapAccess&lt;&gt;::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;
1105   }
1106 } UNSAFE_END
1107 
1108 static void post_thread_park_event(EventThreadPark* event, const oop obj, jlong timeout_nanos, jlong until_epoch_millis) {
1109   assert(event != NULL, &quot;invariant&quot;);
1110   assert(event-&gt;should_commit(), &quot;invariant&quot;);
1111   event-&gt;set_parkedClass((obj != NULL) ? obj-&gt;klass() : NULL);
1112   event-&gt;set_timeout(timeout_nanos);
1113   event-&gt;set_until(until_epoch_millis);
1114   event-&gt;set_address((obj != NULL) ? (u8)cast_from_oop&lt;uintptr_t&gt;(obj) : 0);
1115   event-&gt;commit();
1116 }
1117 
1118 UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time)) {
1119   HOTSPOT_THREAD_PARK_BEGIN((uintptr_t) thread-&gt;parker(), (int) isAbsolute, time);
1120   EventThreadPark event;
1121 
1122   JavaThreadParkedState jtps(thread, time != 0);
1123   thread-&gt;parker()-&gt;park(isAbsolute != 0, time);
1124   if (event.should_commit()) {
1125     const oop obj = thread-&gt;current_park_blocker();
1126     if (time == 0) {
1127       post_thread_park_event(&amp;event, obj, min_jlong, min_jlong);
1128     } else {
1129       if (isAbsolute != 0) {
1130         post_thread_park_event(&amp;event, obj, min_jlong, time);
1131       } else {
1132         post_thread_park_event(&amp;event, obj, time, min_jlong);
1133       }
1134     }
1135   }
1136   HOTSPOT_THREAD_PARK_END((uintptr_t) thread-&gt;parker());
1137 } UNSAFE_END
1138 
1139 UNSAFE_ENTRY(void, Unsafe_Unpark(JNIEnv *env, jobject unsafe, jobject jthread)) {
1140   Parker* p = NULL;
1141 
1142   if (jthread != NULL) {
1143     ThreadsListHandle tlh;
1144     JavaThread* thr = NULL;
1145     oop java_thread = NULL;
1146     (void) tlh.cv_internal_thread_to_JavaThread(jthread, &amp;thr, &amp;java_thread);
1147     if (java_thread != NULL) {
1148       // This is a valid oop.
1149       if (thr != NULL) {
1150         // The JavaThread is alive.
1151         p = thr-&gt;parker();
1152       }
1153     }
1154   } // ThreadsListHandle is destroyed here.
1155 
1156   // &#39;p&#39; points to type-stable-memory if non-NULL. If the target
1157   // thread terminates before we get here the new user of this
1158   // Parker will get a &#39;spurious&#39; unpark - which is perfectly valid.
1159   if (p != NULL) {
1160     HOTSPOT_THREAD_UNPARK((uintptr_t) p);
1161     p-&gt;unpark();
1162   }
1163 } UNSAFE_END
1164 
1165 UNSAFE_ENTRY(jint, Unsafe_GetLoadAverage0(JNIEnv *env, jobject unsafe, jdoubleArray loadavg, jint nelem)) {
1166   const int max_nelem = 3;
1167   double la[max_nelem];
1168   jint ret;
1169 
1170   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(loadavg));
1171   assert(a-&gt;is_typeArray(), &quot;must be type array&quot;);
1172 
1173   ret = os::loadavg(la, nelem);
1174   if (ret == -1) {
1175     return -1;
1176   }
1177 
1178   // if successful, ret is the number of samples actually retrieved.
1179   assert(ret &gt;= 0 &amp;&amp; ret &lt;= max_nelem, &quot;Unexpected loadavg return value&quot;);
1180   switch(ret) {
1181     case 3: a-&gt;double_at_put(2, (jdouble)la[2]); // fall through
1182     case 2: a-&gt;double_at_put(1, (jdouble)la[1]); // fall through
1183     case 1: a-&gt;double_at_put(0, (jdouble)la[0]); break;
1184   }
1185 
1186   return ret;
1187 } UNSAFE_END
1188 
1189 
1190 /// JVM_RegisterUnsafeMethods
1191 
1192 #define ADR &quot;J&quot;
1193 
1194 #define LANG &quot;Ljava/lang/&quot;
1195 
1196 #define OBJ LANG &quot;Object;&quot;
1197 #define CLS LANG &quot;Class;&quot;
1198 #define FLD LANG &quot;reflect/Field;&quot;
1199 #define THR LANG &quot;Throwable;&quot;
1200 
1201 #define DC_Args  LANG &quot;String;[BII&quot; LANG &quot;ClassLoader;&quot; &quot;Ljava/security/ProtectionDomain;&quot;
1202 #define DAC_Args CLS &quot;[B[&quot; OBJ
1203 
1204 #define CC (char*)  /*cast a literal from (const char*)*/
1205 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
1206 
1207 #define DECLARE_GETPUTOOP(Type, Desc) \
1208     {CC &quot;get&quot;  #Type,      CC &quot;(&quot; OBJ &quot;J)&quot; #Desc,                 FN_PTR(Unsafe_Get##Type)}, \
1209     {CC &quot;put&quot;  #Type,      CC &quot;(&quot; OBJ &quot;J&quot; #Desc &quot;)V&quot;,             FN_PTR(Unsafe_Put##Type)}, \
1210     {CC &quot;get&quot;  #Type &quot;Volatile&quot;,      CC &quot;(&quot; OBJ &quot;J)&quot; #Desc,      FN_PTR(Unsafe_Get##Type##Volatile)}, \
1211     {CC &quot;put&quot;  #Type &quot;Volatile&quot;,      CC &quot;(&quot; OBJ &quot;J&quot; #Desc &quot;)V&quot;,  FN_PTR(Unsafe_Put##Type##Volatile)}
1212 
1213 
1214 static JNINativeMethod jdk_internal_misc_Unsafe_methods[] = {
1215     {CC &quot;getReference&quot;,         CC &quot;(&quot; OBJ &quot;J)&quot; OBJ &quot;&quot;,   FN_PTR(Unsafe_GetReference)},
1216     {CC &quot;putReference&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;)V&quot;,  FN_PTR(Unsafe_PutReference)},
1217     {CC &quot;getReferenceVolatile&quot;, CC &quot;(&quot; OBJ &quot;J)&quot; OBJ,      FN_PTR(Unsafe_GetReferenceVolatile)},
1218     {CC &quot;putReferenceVolatile&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;)V&quot;,  FN_PTR(Unsafe_PutReferenceVolatile)},
1219 
1220     {CC &quot;isFlattenedArray&quot;, CC &quot;(&quot; CLS &quot;)Z&quot;,                     FN_PTR(Unsafe_IsFlattenedArray)},
1221     {CC &quot;getValue&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; CLS &quot;)&quot; OBJ,          FN_PTR(Unsafe_GetValue)},
1222     {CC &quot;putValue&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; CLS OBJ &quot;)V&quot;,         FN_PTR(Unsafe_PutValue)},
1223     {CC &quot;uninitializedDefaultValue&quot;, CC &quot;(&quot; CLS &quot;)&quot; OBJ,         FN_PTR(Unsafe_UninitializedDefaultValue)},
1224     {CC &quot;makePrivateBuffer&quot;,     CC &quot;(&quot; OBJ &quot;)&quot; OBJ,             FN_PTR(Unsafe_MakePrivateBuffer)},
1225     {CC &quot;finishPrivateBuffer&quot;,   CC &quot;(&quot; OBJ &quot;)&quot; OBJ,             FN_PTR(Unsafe_FinishPrivateBuffer)},
1226     {CC &quot;valueHeaderSize&quot;,       CC &quot;(&quot; CLS &quot;)J&quot;,                FN_PTR(Unsafe_ValueHeaderSize)},
1227 
1228     {CC &quot;getUncompressedObject&quot;, CC &quot;(&quot; ADR &quot;)&quot; OBJ,  FN_PTR(Unsafe_GetUncompressedObject)},
1229 
1230     DECLARE_GETPUTOOP(Boolean, Z),
1231     DECLARE_GETPUTOOP(Byte, B),
1232     DECLARE_GETPUTOOP(Short, S),
1233     DECLARE_GETPUTOOP(Char, C),
1234     DECLARE_GETPUTOOP(Int, I),
1235     DECLARE_GETPUTOOP(Long, J),
1236     DECLARE_GETPUTOOP(Float, F),
1237     DECLARE_GETPUTOOP(Double, D),
1238 
1239     {CC &quot;allocateMemory0&quot;,    CC &quot;(J)&quot; ADR,              FN_PTR(Unsafe_AllocateMemory0)},
1240     {CC &quot;reallocateMemory0&quot;,  CC &quot;(&quot; ADR &quot;J)&quot; ADR,       FN_PTR(Unsafe_ReallocateMemory0)},
1241     {CC &quot;freeMemory0&quot;,        CC &quot;(&quot; ADR &quot;)V&quot;,           FN_PTR(Unsafe_FreeMemory0)},
1242 
1243     {CC &quot;objectFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_ObjectFieldOffset0)},
1244     {CC &quot;objectFieldOffset1&quot;, CC &quot;(&quot; CLS LANG &quot;String;)J&quot;, FN_PTR(Unsafe_ObjectFieldOffset1)},
1245     {CC &quot;staticFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_StaticFieldOffset0)},
1246     {CC &quot;staticFieldBase0&quot;,   CC &quot;(&quot; FLD &quot;)&quot; OBJ,        FN_PTR(Unsafe_StaticFieldBase0)},
1247     {CC &quot;ensureClassInitialized0&quot;, CC &quot;(&quot; CLS &quot;)V&quot;,      FN_PTR(Unsafe_EnsureClassInitialized0)},
1248     {CC &quot;arrayBaseOffset0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayBaseOffset0)},
1249     {CC &quot;arrayIndexScale0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayIndexScale0)},
1250     {CC &quot;getObjectSize0&quot;,     CC &quot;(Ljava/lang/Object;)J&quot;, FN_PTR(Unsafe_GetObjectSize0)},
1251 
1252     {CC &quot;defineClass0&quot;,       CC &quot;(&quot; DC_Args &quot;)&quot; CLS,    FN_PTR(Unsafe_DefineClass0)},
1253     {CC &quot;allocateInstance&quot;,   CC &quot;(&quot; CLS &quot;)&quot; OBJ,        FN_PTR(Unsafe_AllocateInstance)},
1254     {CC &quot;throwException&quot;,     CC &quot;(&quot; THR &quot;)V&quot;,           FN_PTR(Unsafe_ThrowException)},
1255     {CC &quot;compareAndSetReference&quot;,CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)Z&quot;, FN_PTR(Unsafe_CompareAndSetReference)},
1256     {CC &quot;compareAndSetInt&quot;,   CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetInt)},
1257     {CC &quot;compareAndSetLong&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetLong)},
1258     {CC &quot;compareAndExchangeReference&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)&quot; OBJ, FN_PTR(Unsafe_CompareAndExchangeReference)},
1259     {CC &quot;compareAndExchangeInt&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)I&quot;, FN_PTR(Unsafe_CompareAndExchangeInt)},
1260     {CC &quot;compareAndExchangeLong&quot;, CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)J&quot;, FN_PTR(Unsafe_CompareAndExchangeLong)},
1261 
1262     {CC &quot;park&quot;,               CC &quot;(ZJ)V&quot;,                FN_PTR(Unsafe_Park)},
1263     {CC &quot;unpark&quot;,             CC &quot;(&quot; OBJ &quot;)V&quot;,           FN_PTR(Unsafe_Unpark)},
1264 
1265     {CC &quot;getLoadAverage0&quot;,    CC &quot;([DI)I&quot;,               FN_PTR(Unsafe_GetLoadAverage0)},
1266 
1267     {CC &quot;copyMemory0&quot;,        CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJ)V&quot;, FN_PTR(Unsafe_CopyMemory0)},
1268     {CC &quot;copySwapMemory0&quot;,    CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJJ)V&quot;, FN_PTR(Unsafe_CopySwapMemory0)},
1269     {CC &quot;writeback0&quot;,         CC &quot;(&quot; &quot;J&quot; &quot;)V&quot;,           FN_PTR(Unsafe_WriteBack0)},
1270     {CC &quot;writebackPreSync0&quot;,  CC &quot;()V&quot;,                  FN_PTR(Unsafe_WriteBackPreSync0)},
1271     {CC &quot;writebackPostSync0&quot;, CC &quot;()V&quot;,                  FN_PTR(Unsafe_WriteBackPostSync0)},
1272     {CC &quot;setMemory0&quot;,         CC &quot;(&quot; OBJ &quot;JJB)V&quot;,        FN_PTR(Unsafe_SetMemory0)},
1273 
1274     {CC &quot;defineAnonymousClass0&quot;, CC &quot;(&quot; DAC_Args &quot;)&quot; CLS, FN_PTR(Unsafe_DefineAnonymousClass0)},
1275 
1276     {CC &quot;shouldBeInitialized0&quot;, CC &quot;(&quot; CLS &quot;)Z&quot;,         FN_PTR(Unsafe_ShouldBeInitialized0)},
1277 
1278     {CC &quot;loadFence&quot;,          CC &quot;()V&quot;,                  FN_PTR(Unsafe_LoadFence)},
1279     {CC &quot;storeFence&quot;,         CC &quot;()V&quot;,                  FN_PTR(Unsafe_StoreFence)},
1280     {CC &quot;fullFence&quot;,          CC &quot;()V&quot;,                  FN_PTR(Unsafe_FullFence)},
1281 };
1282 
1283 #undef CC
1284 #undef FN_PTR
1285 
1286 #undef ADR
1287 #undef LANG
1288 #undef OBJ
1289 #undef CLS
1290 #undef FLD
1291 #undef THR
1292 #undef DC_Args
1293 #undef DAC_Args
1294 
1295 #undef DECLARE_GETPUTOOP
1296 
1297 
1298 // This function is exported, used by NativeLookup.
1299 // The Unsafe_xxx functions above are called only from the interpreter.
1300 // The optimizer looks at names and signatures to recognize
1301 // individual functions.
1302 
1303 JVM_ENTRY(void, JVM_RegisterJDKInternalMiscUnsafeMethods(JNIEnv *env, jclass unsafeclass)) {
1304   ThreadToNativeFromVM ttnfv(thread);
1305 
1306   int ok = env-&gt;RegisterNatives(unsafeclass, jdk_internal_misc_Unsafe_methods, sizeof(jdk_internal_misc_Unsafe_methods)/sizeof(JNINativeMethod));
1307   guarantee(ok == 0, &quot;register jdk.internal.misc.Unsafe natives&quot;);
1308 } JVM_END
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
<a name="1" id="anc1"></a>
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;compiler/methodMatcher.hpp&quot;
  37 #include &quot;compiler/directivesParser.hpp&quot;
  38 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  39 #include &quot;gc/shared/gcConfig.hpp&quot;
  40 #include &quot;gc/shared/genArguments.hpp&quot;
  41 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  42 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  43 #include &quot;memory/filemap.hpp&quot;
  44 #include &quot;memory/heapShared.inline.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/iterator.inline.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;memory/oopFactory.hpp&quot;
  51 #include &quot;oops/array.hpp&quot;
  52 #include &quot;oops/compressedOops.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/constantPool.inline.hpp&quot;
  55 #include &quot;oops/method.inline.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/objArrayOop.inline.hpp&quot;
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  61 #include &quot;prims/resolvedMethodTable.hpp&quot;
  62 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  63 #include &quot;prims/whitebox.inline.hpp&quot;
  64 #include &quot;runtime/arguments.hpp&quot;
  65 #include &quot;runtime/atomic.hpp&quot;
  66 #include &quot;runtime/deoptimization.hpp&quot;
  67 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  68 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  69 #include &quot;runtime/frame.inline.hpp&quot;
  70 #include &quot;runtime/handles.inline.hpp&quot;
  71 #include &quot;runtime/handshake.hpp&quot;
  72 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/os.hpp&quot;
  76 #include &quot;runtime/sweeper.hpp&quot;
  77 #include &quot;runtime/thread.hpp&quot;
  78 #include &quot;runtime/threadSMR.hpp&quot;
  79 #include &quot;runtime/vm_version.hpp&quot;
  80 #include &quot;services/memoryService.hpp&quot;
  81 #include &quot;utilities/align.hpp&quot;
  82 #include &quot;utilities/debug.hpp&quot;
  83 #include &quot;utilities/elfFile.hpp&quot;
  84 #include &quot;utilities/exceptions.hpp&quot;
  85 #include &quot;utilities/macros.hpp&quot;
  86 #if INCLUDE_CDS
  87 #include &quot;prims/cdsoffsets.hpp&quot;
  88 #endif // INCLUDE_CDS
  89 #if INCLUDE_G1GC
  90 #include &quot;gc/g1/g1Arguments.hpp&quot;
  91 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  92 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  93 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  94 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  95 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  96 #endif // INCLUDE_G1GC
  97 #if INCLUDE_PARALLELGC
  98 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  99 #endif // INCLUDE_PARALLELGC
 100 #if INCLUDE_NMT
 101 #include &quot;services/mallocSiteTable.hpp&quot;
 102 #include &quot;services/memTracker.hpp&quot;
 103 #include &quot;utilities/nativeCallStack.hpp&quot;
 104 #endif // INCLUDE_NMT
 105 #if INCLUDE_AOT
 106 #include &quot;aot/aotLoader.hpp&quot;
 107 #endif // INCLUDE_AOT
 108 
 109 #ifdef LINUX
 110 #include &quot;osContainer_linux.hpp&quot;
 111 #include &quot;cgroupSubsystem_linux.hpp&quot;
 112 #endif
 113 
 114 #define SIZE_T_MAX_VALUE ((size_t) -1)
 115 
 116 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 117   do {                                                                 \
 118     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 119     THREAD-&gt;clear_pending_jni_exception_check();                       \
 120     if (HAS_PENDING_EXCEPTION) {                                       \
 121       return(value);                                                   \
 122     }                                                                  \
 123   } while (0)
 124 
 125 #define CHECK_JNI_EXCEPTION(env)                                       \
 126   do {                                                                 \
 127     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 128     THREAD-&gt;clear_pending_jni_exception_check();                       \
 129     if (HAS_PENDING_EXCEPTION) {                                       \
 130       return;                                                          \
 131     }                                                                  \
 132   } while (0)
 133 
 134 bool WhiteBox::_used = false;
 135 volatile bool WhiteBox::compilation_locked = false;
 136 
 137 class VM_WhiteBoxOperation : public VM_Operation {
 138  public:
 139   VM_WhiteBoxOperation()                         { }
 140   VMOp_Type type()                  const        { return VMOp_WhiteBoxOperation; }
 141   bool allow_nested_vm_operations() const        { return true; }
 142 };
 143 
 144 
 145 WB_ENTRY(jlong, WB_GetObjectAddress(JNIEnv* env, jobject o, jobject obj))
 146   return (jlong)(void*)JNIHandles::resolve(obj);
 147 WB_END
 148 
 149 WB_ENTRY(jint, WB_GetHeapOopSize(JNIEnv* env, jobject o))
 150   return heapOopSize;
 151 WB_END
 152 
 153 WB_ENTRY(jint, WB_GetVMPageSize(JNIEnv* env, jobject o))
 154   return os::vm_page_size();
 155 WB_END
 156 
 157 WB_ENTRY(jlong, WB_GetVMAllocationGranularity(JNIEnv* env, jobject o))
 158   return os::vm_allocation_granularity();
 159 WB_END
 160 
 161 WB_ENTRY(jlong, WB_GetVMLargePageSize(JNIEnv* env, jobject o))
 162   return os::large_page_size();
 163 WB_END
 164 
 165 class WBIsKlassAliveClosure : public LockedClassesDo {
 166     Symbol* _name;
 167     int _count;
 168 public:
 169     WBIsKlassAliveClosure(Symbol* name) : _name(name), _count(0) {}
 170 
 171     void do_klass(Klass* k) {
 172       Symbol* ksym = k-&gt;name();
 173       if (ksym-&gt;fast_compare(_name) == 0) {
 174         _count++;
 175       }
 176     }
 177 
 178     int count() const {
 179         return _count;
 180     }
 181 };
 182 
 183 WB_ENTRY(jint, WB_CountAliveClasses(JNIEnv* env, jobject target, jstring name))
 184   oop h_name = JNIHandles::resolve(name);
 185   if (h_name == NULL) return false;
 186   Symbol* sym = java_lang_String::as_symbol(h_name);
 187   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 188 
 189   WBIsKlassAliveClosure closure(sym);
 190   ClassLoaderDataGraph::classes_do(&amp;closure);
 191 
 192   // Return the count of alive classes with this name.
 193   return closure.count();
 194 WB_END
 195 
 196 WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
 197   oop h_name = JNIHandles::resolve(name);
 198   if (h_name == NULL) return false;
 199   Symbol* sym = java_lang_String::as_symbol(h_name);
 200   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 201   return (jint)sym-&gt;refcount();
 202 WB_END
 203 
 204 
 205 WB_ENTRY(void, WB_AddToBootstrapClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 206 #if INCLUDE_JVMTI
 207   ResourceMark rm;
 208   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 209   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 210   jvmtiError err = jvmti_env-&gt;AddToBootstrapClassLoaderSearch(seg);
 211   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 212 #endif
 213 }
 214 WB_END
 215 
 216 WB_ENTRY(void, WB_AddToSystemClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 217 #if INCLUDE_JVMTI
 218   ResourceMark rm;
 219   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 220   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 221   jvmtiError err = jvmti_env-&gt;AddToSystemClassLoaderSearch(seg);
 222   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 223 #endif
 224 }
 225 WB_END
 226 
 227 
 228 WB_ENTRY(jlong, WB_GetCompressedOopsMaxHeapSize(JNIEnv* env, jobject o)) {
 229   return (jlong)Arguments::max_heap_for_compressed_oops();
 230 }
 231 WB_END
 232 
 233 WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
 234   tty-&gt;print_cr(&quot;Minimum heap &quot; SIZE_FORMAT &quot; Initial heap &quot; SIZE_FORMAT &quot; &quot;
 235                 &quot;Maximum heap &quot; SIZE_FORMAT &quot; Space alignment &quot; SIZE_FORMAT &quot; Heap alignment &quot; SIZE_FORMAT,
 236                 MinHeapSize,
 237                 InitialHeapSize,
 238                 MaxHeapSize,
 239                 SpaceAlignment,
 240                 HeapAlignment);
 241 }
 242 WB_END
 243 
 244 #ifndef PRODUCT
 245 // Forward declaration
 246 void TestReservedSpace_test();
 247 void TestReserveMemorySpecial_test();
 248 void TestVirtualSpace_test();
 249 #endif
 250 
 251 WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
 252 #ifndef PRODUCT
 253   TestReservedSpace_test();
 254   TestReserveMemorySpecial_test();
 255   TestVirtualSpace_test();
 256 #endif
 257 WB_END
 258 
 259 WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
 260   size_t granularity = os::vm_allocation_granularity();
 261   ReservedHeapSpace rhs(100 * granularity, granularity, false);
 262   VirtualSpace vs;
 263   vs.initialize(rhs, 50 * granularity);
 264 
 265   // Check if constraints are complied
 266   if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
 267          CompressedOops::base() != NULL &amp;&amp;
 268          CompressedOops::use_implicit_null_checks() )) {
 269     tty-&gt;print_cr(&quot;WB_ReadFromNoaccessArea method is useless:\n &quot;
 270                   &quot;\tUseCompressedOops is %d\n&quot;
 271                   &quot;\trhs.base() is &quot; PTR_FORMAT &quot;\n&quot;
 272                   &quot;\tCompressedOops::base() is &quot; PTR_FORMAT &quot;\n&quot;
 273                   &quot;\tCompressedOops::use_implicit_null_checks() is %d&quot;,
 274                   UseCompressedOops,
 275                   p2i(rhs.base()),
 276                   p2i(CompressedOops::base()),
 277                   CompressedOops::use_implicit_null_checks());
 278     return;
 279   }
 280   tty-&gt;print_cr(&quot;Reading from no access area... &quot;);
 281   tty-&gt;print_cr(&quot;*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c&quot;,
 282                 *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
 283 WB_END
 284 
 285 static jint wb_stress_virtual_space_resize(size_t reserved_space_size,
 286                                            size_t magnitude, size_t iterations) {
 287   size_t granularity = os::vm_allocation_granularity();
 288   ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, false);
 289   VirtualSpace vs;
 290   if (!vs.initialize(rhs, 0)) {
 291     tty-&gt;print_cr(&quot;Failed to initialize VirtualSpace. Can&#39;t proceed.&quot;);
 292     return 3;
 293   }
 294 
 295   int seed = os::random();
 296   tty-&gt;print_cr(&quot;Random seed is %d&quot;, seed);
 297   os::init_random(seed);
 298 
 299   for (size_t i = 0; i &lt; iterations; i++) {
 300 
 301     // Whether we will shrink or grow
 302     bool shrink = os::random() % 2L == 0;
 303 
 304     // Get random delta to resize virtual space
 305     size_t delta = (size_t)os::random() % magnitude;
 306 
 307     // If we are about to shrink virtual space below zero, then expand instead
 308     if (shrink &amp;&amp; vs.committed_size() &lt; delta) {
 309       shrink = false;
 310     }
 311 
 312     // Resizing by delta
 313     if (shrink) {
 314       vs.shrink_by(delta);
 315     } else {
 316       // If expanding fails expand_by will silently return false
 317       vs.expand_by(delta, true);
 318     }
 319   }
 320   return 0;
 321 }
 322 
 323 WB_ENTRY(jint, WB_StressVirtualSpaceResize(JNIEnv* env, jobject o,
 324         jlong reserved_space_size, jlong magnitude, jlong iterations))
 325   tty-&gt;print_cr(&quot;reservedSpaceSize=&quot; JLONG_FORMAT &quot;, magnitude=&quot; JLONG_FORMAT &quot;, &quot;
 326                 &quot;iterations=&quot; JLONG_FORMAT &quot;\n&quot;, reserved_space_size, magnitude,
 327                 iterations);
 328   if (reserved_space_size &lt; 0 || magnitude &lt; 0 || iterations &lt; 0) {
 329     tty-&gt;print_cr(&quot;One of variables printed above is negative. Can&#39;t proceed.\n&quot;);
 330     return 1;
 331   }
 332 
 333   // sizeof(size_t) depends on whether OS is 32bit or 64bit. sizeof(jlong) is
 334   // always 8 byte. That&#39;s why we should avoid overflow in case of 32bit platform.
 335   if (sizeof(size_t) &lt; sizeof(jlong)) {
 336     jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;
 337     if (reserved_space_size &gt; size_t_max_value || magnitude &gt; size_t_max_value
 338         || iterations &gt; size_t_max_value) {
 339       tty-&gt;print_cr(&quot;One of variables printed above overflows size_t. Can&#39;t proceed.\n&quot;);
 340       return 2;
 341     }
 342   }
 343 
 344   return wb_stress_virtual_space_resize((size_t) reserved_space_size,
 345                                         (size_t) magnitude, (size_t) iterations);
 346 WB_END
 347 
 348 WB_ENTRY(jboolean, WB_IsGCSupported(JNIEnv* env, jobject o, jint name))
 349   return GCConfig::is_gc_supported((CollectedHeap::Name)name);
 350 WB_END
 351 
 352 WB_ENTRY(jboolean, WB_IsGCSelected(JNIEnv* env, jobject o, jint name))
 353   return GCConfig::is_gc_selected((CollectedHeap::Name)name);
 354 WB_END
 355 
 356 WB_ENTRY(jboolean, WB_IsGCSelectedErgonomically(JNIEnv* env, jobject o))
 357   return GCConfig::is_gc_selected_ergonomically();
 358 WB_END
 359 
 360 WB_ENTRY(jboolean, WB_isObjectInOldGen(JNIEnv* env, jobject o, jobject obj))
 361   oop p = JNIHandles::resolve(obj);
 362 #if INCLUDE_G1GC
 363   if (UseG1GC) {
 364     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 365     const HeapRegion* hr = g1h-&gt;heap_region_containing(p);
 366     if (hr == NULL) {
 367       return false;
 368     }
 369     return !(hr-&gt;is_young());
 370   }
 371 #endif
 372 #if INCLUDE_PARALLELGC
 373   if (UseParallelGC) {
 374     ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();
 375     return !psh-&gt;is_in_young(p);
 376   }
 377 #endif
 378 #if INCLUDE_ZGC
 379   if (UseZGC) {
 380     return Universe::heap()-&gt;is_in(p);
 381   }
 382 #endif
 383   GenCollectedHeap* gch = GenCollectedHeap::heap();
 384   return !gch-&gt;is_in_young(p);
 385 WB_END
 386 
 387 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 388   oop p = JNIHandles::resolve(obj);
 389   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 390 WB_END
 391 
 392 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 393   return (jlong)SpaceAlignment;
 394 WB_END
 395 
 396 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 397   return (jlong)HeapAlignment;
 398 WB_END
 399 
 400 WB_ENTRY(jboolean, WB_SupportsConcurrentGCBreakpoints(JNIEnv* env, jobject o))
 401   return Universe::heap()-&gt;supports_concurrent_gc_breakpoints();
 402 WB_END
 403 
 404 WB_ENTRY(void, WB_ConcurrentGCAcquireControl(JNIEnv* env, jobject o))
 405   ConcurrentGCBreakpoints::acquire_control();
 406 WB_END
 407 
 408 WB_ENTRY(void, WB_ConcurrentGCReleaseControl(JNIEnv* env, jobject o))
 409   ConcurrentGCBreakpoints::release_control();
 410 WB_END
 411 
 412 WB_ENTRY(void, WB_ConcurrentGCRunToIdle(JNIEnv* env, jobject o))
 413   ConcurrentGCBreakpoints::run_to_idle();
 414 WB_END
 415 
 416 WB_ENTRY(jboolean, WB_ConcurrentGCRunTo(JNIEnv* env, jobject o, jobject at))
 417   Handle h_name(THREAD, JNIHandles::resolve(at));
 418   ResourceMark rm;
 419   const char* c_name = java_lang_String::as_utf8_string(h_name());
 420   return ConcurrentGCBreakpoints::run_to(c_name);
 421 WB_END
 422 
 423 #if INCLUDE_G1GC
 424 
 425 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 426   if (UseG1GC) {
 427     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 428     oop result = JNIHandles::resolve(obj);
 429     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 430     return hr-&gt;is_humongous();
 431   }
 432   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 433 WB_END
 434 
 435 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 436   if (UseG1GC) {
 437     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 438     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 439     return hr-&gt;is_humongous();
 440   }
 441   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToHumongousRegion: G1 GC is not enabled&quot;);
 442 WB_END
 443 
 444 WB_ENTRY(jboolean, WB_G1BelongsToFreeRegion(JNIEnv* env, jobject o, jlong addr))
 445   if (UseG1GC) {
 446     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 447     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 448     return hr-&gt;is_free();
 449   }
 450   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToFreeRegion: G1 GC is not enabled&quot;);
 451 WB_END
 452 
 453 WB_ENTRY(jlong, WB_G1NumMaxRegions(JNIEnv* env, jobject o))
 454   if (UseG1GC) {
 455     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 456     size_t nr = g1h-&gt;max_regions();
 457     return (jlong)nr;
 458   }
 459   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumMaxRegions: G1 GC is not enabled&quot;);
 460 WB_END
 461 
 462 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 463   if (UseG1GC) {
 464     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 465     size_t nr = g1h-&gt;num_free_regions();
 466     return (jlong)nr;
 467   }
 468   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 469 WB_END
 470 
 471 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 472   if (UseG1GC) {
 473     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 474     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 475   }
 476   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 477 WB_END
 478 
 479 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 480   if (UseG1GC) {
 481     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 482     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 483       g1h-&gt;collect(GCCause::_wb_conc_mark);
 484       return true;
 485     }
 486     return false;
 487   }
 488   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 489 WB_END
 490 
 491 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 492   if (UseG1GC) {
 493     return (jint)HeapRegion::GrainBytes;
 494   }
 495   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 496 WB_END
 497 
 498 #endif // INCLUDE_G1GC
 499 
 500 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
 501 WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))
 502 #if INCLUDE_G1GC
 503   if (UseG1GC) {
 504     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 505     if (g1h-&gt;is_heterogeneous_heap()) {
 506       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_dram();
 507       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 508     } else {
 509       return (jlong)g1h-&gt;base();
 510     }
 511   }
 512 #endif // INCLUDE_G1GC
 513 #if INCLUDE_PARALLELGC
 514   if (UseParallelGC) {
 515     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 516     if (AllocateOldGenAt != NULL) {
 517       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 518       return (jlong)reserved.start();
 519     } else {
 520       return (jlong)ps_heap-&gt;base();
 521     }
 522   }
 523 #endif // INCLUDE_PARALLELGC
 524   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedStart: enabled only for G1 and Parallel GC&quot;);
 525 WB_END
 526 
 527 WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))
 528 #if INCLUDE_G1GC
 529   if (UseG1GC) {
 530     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 531     if (g1h-&gt;is_heterogeneous_heap()) {
 532       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
 533       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 534     } else {
 535       return (jlong)g1h-&gt;base() + G1Arguments::heap_max_size_bytes();
 536     }
 537   }
 538 #endif // INCLUDE_G1GC
 539 #if INCLUDE_PARALLELGC
 540   if (UseParallelGC) {
 541     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 542     if (AllocateOldGenAt != NULL) {
 543       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 544       return (jlong)reserved.end();
 545     } else {
 546       return (jlong)ps_heap-&gt;reserved_region().end();
 547     }
 548   }
 549 #endif // INCLUDE_PARALLELGC
 550   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedEnd: enabled only for G1 and Parallel GC&quot;);
 551 WB_END
 552 
 553 WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))
 554 #if INCLUDE_G1GC
 555   if (UseG1GC) {
 556     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 557     if (g1h-&gt;is_heterogeneous_heap()) {
 558       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 559       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 560     } else {
 561       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 562     }
 563   }
 564 #endif // INCLUDE_G1GC
 565 #if INCLUDE_PARALLELGC
 566   if (UseParallelGC) {
 567     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 568     if (AllocateOldGenAt != NULL) {
 569       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 570       return (jlong)reserved.start();
 571     } else {
 572       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 573     }
 574   }
 575 #endif // INCLUDE_PARALLELGC
 576   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: enabled only for G1 and Parallel GC&quot;);
 577 WB_END
 578 
 579 WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))
 580 #if INCLUDE_G1GC
 581   if (UseG1GC) {
 582     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 583     if (g1h-&gt;is_heterogeneous_heap()) {
 584       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 585       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 586     } else {
 587       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 588     }
 589   }
 590 #endif // INCLUDE_G1GC
 591 #if INCLUDE_PARALLELGC
 592   if (UseParallelGC) {
 593     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 594     if (AllocateOldGenAt != NULL) {
 595       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 596       return (jlong)reserved.end();
 597       } else {
 598       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 599     }
 600   }
 601 #endif // INCLUDE_PARALLELGC
 602   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC&quot;);
 603 WB_END
 604 
 605 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
 606 
 607 #if INCLUDE_PARALLELGC
 608 
 609 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
 610   if (UseParallelGC) {
 611     return GenAlignment;
 612   }
 613   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSVirtualSpaceAlignment: Parallel GC is not enabled&quot;);
 614 WB_END
 615 
 616 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
 617   if (UseParallelGC) {
 618     return GenAlignment;
 619   }
 620   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSHeapGenerationAlignment: Parallel GC is not enabled&quot;);
 621 WB_END
 622 
 623 #endif // INCLUDE_PARALLELGC
 624 
 625 #if INCLUDE_G1GC
 626 
 627 WB_ENTRY(jobject, WB_G1AuxiliaryMemoryUsage(JNIEnv* env))
 628   if (UseG1GC) {
 629     ResourceMark rm(THREAD);
 630     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 631     MemoryUsage usage = g1h-&gt;get_auxiliary_data_memory_usage();
 632     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 633     return JNIHandles::make_local(env, h());
 634   }
 635   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled&quot;);
 636 WB_END
 637 
 638 WB_ENTRY(jint, WB_G1ActiveMemoryNodeCount(JNIEnv* env, jobject o))
 639   if (UseG1GC) {
 640     G1NUMA* numa = G1NUMA::numa();
 641     return (jint)numa-&gt;num_active_nodes();
 642   }
 643   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1ActiveMemoryNodeCount: G1 GC is not enabled&quot;);
 644 WB_END
 645 
 646 WB_ENTRY(jintArray, WB_G1MemoryNodeIds(JNIEnv* env, jobject o))
 647   if (UseG1GC) {
 648     G1NUMA* numa = G1NUMA::numa();
 649     int num_node_ids = (int)numa-&gt;num_active_nodes();
 650     const int* node_ids = numa-&gt;node_ids();
 651 
 652     typeArrayOop result = oopFactory::new_intArray(num_node_ids, CHECK_NULL);
 653     for (int i = 0; i &lt; num_node_ids; i++) {
 654       result-&gt;int_at_put(i, (jint)node_ids[i]);
 655     }
 656     return (jintArray) JNIHandles::make_local(env, result);
 657   }
 658   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1MemoryNodeIds: G1 GC is not enabled&quot;);
 659 WB_END
 660 
 661 class OldRegionsLivenessClosure: public HeapRegionClosure {
 662 
 663  private:
 664   const int _liveness;
 665   size_t _total_count;
 666   size_t _total_memory;
 667   size_t _total_memory_to_free;
 668 
 669  public:
 670   OldRegionsLivenessClosure(int liveness) :
 671     _liveness(liveness),
 672     _total_count(0),
 673     _total_memory(0),
 674     _total_memory_to_free(0) { }
 675 
 676     size_t total_count() { return _total_count; }
 677     size_t total_memory() { return _total_memory; }
 678     size_t total_memory_to_free() { return _total_memory_to_free; }
 679 
 680   bool do_heap_region(HeapRegion* r) {
 681     if (r-&gt;is_old()) {
 682       size_t prev_live = r-&gt;marked_bytes();
 683       size_t live = r-&gt;live_bytes();
 684       size_t size = r-&gt;used();
 685       size_t reg_size = HeapRegion::GrainBytes;
 686       if (size &gt; 0 &amp;&amp; ((int)(live * 100 / size) &lt; _liveness)) {
 687         _total_memory += size;
 688         ++_total_count;
 689         if (size == reg_size) {
 690         // we don&#39;t include non-full regions since they are unlikely included in mixed gc
 691         // for testing purposes it&#39;s enough to have lowest estimation of total memory that is expected to be freed
 692           _total_memory_to_free += size - prev_live;
 693         }
 694       }
 695     }
 696     return false;
 697   }
 698 };
 699 
 700 
 701 WB_ENTRY(jlongArray, WB_G1GetMixedGCInfo(JNIEnv* env, jobject o, jint liveness))
 702   if (!UseG1GC) {
 703     THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1GetMixedGCInfo: G1 GC is not enabled&quot;);
 704   }
 705   if (liveness &lt; 0) {
 706     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;liveness value should be non-negative&quot;);
 707   }
 708 
 709   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 710   OldRegionsLivenessClosure rli(liveness);
 711   g1h-&gt;heap_region_iterate(&amp;rli);
 712 
 713   typeArrayOop result = oopFactory::new_longArray(3, CHECK_NULL);
 714   result-&gt;long_at_put(0, rli.total_count());
 715   result-&gt;long_at_put(1, rli.total_memory());
 716   result-&gt;long_at_put(2, rli.total_memory_to_free());
 717   return (jlongArray) JNIHandles::make_local(env, result);
 718 WB_END
 719 
 720 #endif // INCLUDE_G1GC
 721 
 722 #if INCLUDE_NMT
 723 // Alloc memory using the test memory type so that we can use that to see if
 724 // NMT picks it up correctly
 725 WB_ENTRY(jlong, WB_NMTMalloc(JNIEnv* env, jobject o, jlong size))
 726   jlong addr = 0;
 727   addr = (jlong)(uintptr_t)os::malloc(size, mtTest);
 728   return addr;
 729 WB_END
 730 
 731 // Alloc memory with pseudo call stack. The test can create psudo malloc
 732 // allocation site to stress the malloc tracking.
 733 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStack(JNIEnv* env, jobject o, jlong size, jint pseudo_stack))
 734   address pc = (address)(size_t)pseudo_stack;
 735   NativeCallStack stack(&amp;pc, 1);
 736   return (jlong)(uintptr_t)os::malloc(size, mtTest, stack);
 737 WB_END
 738 
 739 // Alloc memory with pseudo call stack and specific memory type.
 740 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))
 741   address pc = (address)(size_t)pseudo_stack;
 742   NativeCallStack stack(&amp;pc, 1);
 743   return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);
 744 WB_END
 745 
 746 // Free the memory allocated by NMTAllocTest
 747 WB_ENTRY(void, WB_NMTFree(JNIEnv* env, jobject o, jlong mem))
 748   os::free((void*)(uintptr_t)mem);
 749 WB_END
 750 
 751 WB_ENTRY(jlong, WB_NMTReserveMemory(JNIEnv* env, jobject o, jlong size))
 752   jlong addr = 0;
 753 
 754   addr = (jlong)(uintptr_t)os::reserve_memory(size);
 755   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 756 
 757   return addr;
 758 WB_END
 759 
 760 WB_ENTRY(jlong, WB_NMTAttemptReserveMemoryAt(JNIEnv* env, jobject o, jlong addr, jlong size))
 761   addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((size_t)size, (char*)(uintptr_t)addr);
 762   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 763 
 764   return addr;
 765 WB_END
 766 
 767 WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 768   os::commit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 769   MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);
 770 WB_END
 771 
 772 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 773   os::uncommit_memory((char *)(uintptr_t)addr, size);
 774 WB_END
 775 
 776 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 777   os::release_memory((char *)(uintptr_t)addr, size);
 778 WB_END
 779 
 780 WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))
 781   // Test that we can downgrade NMT levels but not upgrade them.
 782   if (MemTracker::tracking_level() == NMT_off) {
 783     MemTracker::transition_to(NMT_off);
 784     return MemTracker::tracking_level() == NMT_off;
 785   } else {
 786     assert(MemTracker::tracking_level() == NMT_detail, &quot;Should start out as detail tracking&quot;);
 787     MemTracker::transition_to(NMT_summary);
 788     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should be summary now&quot;);
 789 
 790     // Can&#39;t go to detail once NMT is set to summary.
 791     MemTracker::transition_to(NMT_detail);
 792     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should still be summary now&quot;);
 793 
 794     // Shutdown sets tracking level to minimal.
 795     MemTracker::shutdown();
 796     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should be minimal now&quot;);
 797 
 798     // Once the tracking level is minimal, we cannot increase to summary.
 799     // The code ignores this request instead of asserting because if the malloc site
 800     // table overflows in another thread, it tries to change the code to summary.
 801     MemTracker::transition_to(NMT_summary);
 802     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 803 
 804     // Really can never go up to detail, verify that the code would never do this.
 805     MemTracker::transition_to(NMT_detail);
 806     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 807     return MemTracker::tracking_level() == NMT_minimal;
 808   }
 809 WB_END
 810 
 811 WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
 812   int hash_size = MallocSiteTable::hash_buckets();
 813   assert(hash_size &gt; 0, &quot;NMT hash_size should be &gt; 0&quot;);
 814   return (jint)hash_size;
 815 WB_END
 816 
 817 WB_ENTRY(jlong, WB_NMTNewArena(JNIEnv* env, jobject o, jlong init_size))
 818   Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));
 819   return (jlong)arena;
 820 WB_END
 821 
 822 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 823   Arena* a = (Arena*)arena;
 824   delete a;
 825 WB_END
 826 
 827 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 828   Arena* a = (Arena*)arena;
 829   a-&gt;Amalloc(size_t(size));
 830 WB_END
 831 #endif // INCLUDE_NMT
 832 
 833 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 834   assert(method != NULL, &quot;method should not be null&quot;);
 835   ThreadToNativeFromVM ttn(thread);
 836   return env-&gt;FromReflectedMethod(method);
 837 }
 838 
 839 static CompLevel highestCompLevel() {
 840   return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;
 841 }
 842 
 843 // Deoptimizes all compiled frames and makes nmethods not entrant if it&#39;s requested
 844 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 845  private:
 846   int _result;
 847   const bool _make_not_entrant;
 848  public:
 849   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 850         _result(0), _make_not_entrant(make_not_entrant) { }
 851   int  result() const { return _result; }
 852 
 853   void doit() {
 854     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 855       if (t-&gt;has_last_Java_frame()) {
 856         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {
 857           frame* f = fst.current();
 858           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
 859             Deoptimization::deoptimize(t, *f);
 860             if (_make_not_entrant) {
 861                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 862                 assert(cm != NULL, &quot;sanity check&quot;);
 863                 cm-&gt;make_not_entrant();
 864             }
 865             ++_result;
 866           }
 867         }
 868       }
 869     }
 870   }
 871 };
 872 
 873 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 874   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 875   VMThread::execute(&amp;op);
 876   return op.result();
 877 WB_END
 878 
 879 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
 880   CodeCache::mark_all_nmethods_for_deoptimization();
 881   Deoptimization::deoptimize_all_marked();
 882 WB_END
 883 
 884 WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 885   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 886   int result = 0;
 887   CHECK_JNI_EXCEPTION_(env, result);
 888   MutexLocker mu(Compile_lock);
 889   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 890   if (is_osr) {
 891     result += mh-&gt;mark_osr_nmethods();
 892   } else if (mh-&gt;code() != NULL) {
 893     mh-&gt;code()-&gt;mark_for_deoptimization();
 894     ++result;
 895   }
 896   result += CodeCache::mark_for_deoptimization(mh());
 897   if (result &gt; 0) {
 898     Deoptimization::deoptimize_all_marked();
 899   }
 900   return result;
 901 WB_END
 902 
 903 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 904   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 905   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 906   MutexLocker mu(Compile_lock);
 907   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 908   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 909   if (code == NULL) {
 910     return JNI_FALSE;
 911   }
 912   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 913 WB_END
 914 
 915 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 916   if (method == NULL || comp_level &gt; highestCompLevel()) {
 917     return false;
 918   }
 919   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 920   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 921   MutexLocker mu(Compile_lock);
 922   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 923   if (is_osr) {
 924     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 925   } else {
 926     return CompilationPolicy::can_be_compiled(mh, comp_level);
 927   }
 928 WB_END
 929 
 930 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 931   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 932   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 933   MutexLocker mu(Compile_lock);
 934   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 935   return mh-&gt;queued_for_compilation();
 936 WB_END
 937 
 938 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
 939   if (compLevel &lt; CompLevel_none || compLevel &gt; highestCompLevel()) {
 940     return false; // Intrinsic is not available on a non-existent compilation level.
 941   }
 942   jmethodID method_id, compilation_context_id;
 943   method_id = reflected_method_to_jmid(thread, env, method);
 944   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 945   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 946 
 947   DirectiveSet* directive;
 948   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 949   assert(comp != NULL, &quot;compiler not available&quot;);
 950   if (compilation_context != NULL) {
 951     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 952     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 953     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 954     directive = DirectivesStack::getMatchingDirective(cch, comp);
 955   } else {
 956     // Calling with NULL matches default directive
 957     directive = DirectivesStack::getDefaultDirective(comp);
 958   }
 959   bool result = comp-&gt;is_intrinsic_available(mh, directive);
 960   DirectivesStack::release(directive);
 961   return result;
 962 WB_END
 963 
 964 WB_ENTRY(jint, WB_GetMethodCompilationLevel(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 965   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 966   CHECK_JNI_EXCEPTION_(env, CompLevel_none);
 967   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 968   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 969   return (code != NULL ? code-&gt;comp_level() : CompLevel_none);
 970 WB_END
 971 
 972 WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 973   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 974   CHECK_JNI_EXCEPTION(env);
 975   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 976   if (is_osr) {
 977     mh-&gt;set_not_osr_compilable(&quot;WhiteBox&quot;, comp_level);
 978   } else {
 979     mh-&gt;set_not_compilable(&quot;WhiteBox&quot;, comp_level);
 980   }
 981 WB_END
 982 
 983 WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
 984   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 985   CHECK_JNI_EXCEPTION_(env, InvocationEntryBci);
 986   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 987   CompiledMethod* code = mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);
 988   return (code != NULL &amp;&amp; code-&gt;is_osr_method() ? code-&gt;osr_entry_bci() : InvocationEntryBci);
 989 WB_END
 990 
 991 WB_ENTRY(jboolean, WB_TestSetDontInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 992   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 993   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 994   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 995   bool result = mh-&gt;dont_inline();
 996   mh-&gt;set_dont_inline(value == JNI_TRUE);
 997   return result;
 998 WB_END
 999 
1000 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
1001   if (comp_level == CompLevel_any) {
1002     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
1003         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
1004   } else {
1005     return CompileBroker::queue_size(comp_level);
1006   }
1007 WB_END
1008 
1009 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1010   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1011   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1012   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1013   bool result = mh-&gt;force_inline();
1014   mh-&gt;set_force_inline(value == JNI_TRUE);
1015   return result;
1016 WB_END
1017 
1018 #ifdef LINUX
1019 bool WhiteBox::validate_cgroup(const char* proc_cgroups,
1020                                const char* proc_self_cgroup,
1021                                const char* proc_self_mountinfo,
1022                                u1* cg_flags) {
1023   CgroupInfo cg_infos[4];
1024   return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,
1025                                                     proc_self_cgroup,
1026                                                     proc_self_mountinfo, cg_flags);
1027 }
1028 #endif
1029 
1030 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1031   // Screen for unavailable/bad comp level or null method
1032   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1033   if (method == NULL) {
1034     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
1035     return false;
1036   }
1037   if (comp_level &gt; highestCompLevel()) {
1038     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
1039     return false;
1040   }
1041   if (comp == NULL) {
1042     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
1043     return false;
1044   }
1045 
1046   // Check if compilation is blocking
1047   methodHandle mh(THREAD, method);
1048   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1049   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1050   DirectivesStack::release(directive);
1051 
1052   // Compile method and check result
1053   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1054   MutexLocker mu(THREAD, Compile_lock);
1055   bool is_queued = mh-&gt;queued_for_compilation();
1056   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1057     return true;
1058   }
1059   tty-&gt;print(&quot;WB error: failed to %s compile at level %d method &quot;, is_blocking ? &quot;blocking&quot; : &quot;&quot;, comp_level);
1060   mh-&gt;print_short_name(tty);
1061   tty-&gt;cr();
1062   if (is_blocking &amp;&amp; is_queued) {
1063     tty-&gt;print_cr(&quot;WB error: blocking compilation is still in queue!&quot;);
1064   }
1065   return false;
1066 }
1067 
1068 WB_ENTRY(jboolean, WB_EnqueueMethodForCompilation(JNIEnv* env, jobject o, jobject method, jint comp_level, jint bci))
1069   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1070   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1071   return WhiteBox::compile_method(Method::checked_resolve_jmethod_id(jmid), comp_level, bci, THREAD);
1072 WB_END
1073 
1074 WB_ENTRY(jboolean, WB_EnqueueInitializerForCompilation(JNIEnv* env, jobject o, jclass klass, jint comp_level))
1075   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1076   Method* clinit = ik-&gt;class_initializer();
1077   if (clinit == NULL) {
1078     return false;
1079   }
1080   return WhiteBox::compile_method(clinit, comp_level, InvocationEntryBci, THREAD);
1081 WB_END
1082 
1083 WB_ENTRY(jboolean, WB_ShouldPrintAssembly(JNIEnv* env, jobject o, jobject method, jint comp_level))
1084   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1085   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1086 
1087   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1088   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, CompileBroker::compiler(comp_level));
1089   bool result = directive-&gt;PrintAssemblyOption;
1090   DirectivesStack::release(directive);
1091 
1092   return result;
1093 WB_END
1094 
1095 WB_ENTRY(jint, WB_MatchesInline(JNIEnv* env, jobject o, jobject method, jstring pattern))
1096   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1097   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1098 
1099   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1100 
1101   ResourceMark rm(THREAD);
1102   const char* error_msg = NULL;
1103   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1104   InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
1105 
1106   if (m == NULL) {
1107     assert(error_msg != NULL, &quot;Always have an error message&quot;);
1108     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1109     return -1; // Pattern failed
1110   }
1111 
1112   // Pattern works - now check if it matches
1113   int result;
1114   if (m-&gt;match(mh, InlineMatcher::force_inline)) {
1115     result = 2; // Force inline match
1116   } else if (m-&gt;match(mh, InlineMatcher::dont_inline)) {
1117     result = 1; // Dont inline match
1118   } else {
1119     result = 0; // No match
1120   }
1121   delete m;
1122   return result;
1123 WB_END
1124 
1125 WB_ENTRY(jint, WB_MatchesMethod(JNIEnv* env, jobject o, jobject method, jstring pattern))
1126   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1127   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1128 
1129   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1130 
1131   ResourceMark rm;
1132   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1133 
1134   const char* error_msg = NULL;
1135 
1136   BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);
1137   if (m == NULL) {
1138     assert(error_msg != NULL, &quot;Must have error_msg&quot;);
1139     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1140     return -1;
1141   }
1142 
1143   // Pattern works - now check if it matches
1144   int result = m-&gt;matches(mh);
1145   delete m;
1146   assert(result == 0 || result == 1, &quot;Result out of range&quot;);
1147   return result;
1148 WB_END
1149 
1150 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1151   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1152   CHECK_JNI_EXCEPTION(env);
1153   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1154 
1155   MethodData* mdo = mh-&gt;method_data();
1156   if (mdo == NULL) {
1157     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1158     mdo = mh-&gt;method_data();
1159   }
1160   mdo-&gt;init();
1161   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1162   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1163   // set i-counter according to TieredThresholdPolicy::is_method_profiled
1164   icnt-&gt;set(Tier4MinInvocationThreshold);
1165   bcnt-&gt;set(Tier4CompileThreshold);
1166 WB_END
1167 
1168 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1169   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1170   CHECK_JNI_EXCEPTION(env);
1171   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1172   MutexLocker mu(THREAD, Compile_lock);
1173   MethodData* mdo = mh-&gt;method_data();
1174   MethodCounters* mcs = mh-&gt;method_counters();
1175 
1176   if (mdo != NULL) {
1177     mdo-&gt;init();
1178     ResourceMark rm(THREAD);
1179     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1180     for (int i = 0; i &lt; arg_count; i++) {
1181       mdo-&gt;set_arg_modified(i, 0);
1182     }
1183     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1184     mdo-&gt;clean_method_data(/*always_clean*/true);
1185   }
1186 
1187   mh-&gt;clear_not_c1_compilable();
1188   mh-&gt;clear_not_c2_compilable();
1189   mh-&gt;clear_not_c2_osr_compilable();
1190   NOT_PRODUCT(mh-&gt;set_compiled_invocation_count(0));
1191   if (mcs != NULL) {
1192     mcs-&gt;backedge_counter()-&gt;init();
1193     mcs-&gt;invocation_counter()-&gt;init();
1194     mcs-&gt;set_interpreter_invocation_count(0);
1195     mcs-&gt;set_interpreter_throwout_count(0);
1196 
1197 #ifdef TIERED
1198     mcs-&gt;set_rate(0.0F);
1199     mh-&gt;set_prev_event_count(0);
1200     mh-&gt;set_prev_time(0);
1201 #endif
1202   }
1203 WB_END
1204 
1205 template &lt;typename T&gt;
1206 static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {
1207   if (name == NULL) {
1208     return false;
1209   }
1210   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1211   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1212   CHECK_JNI_EXCEPTION_(env, false);
1213   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
1214   JVMFlag::Error result = (*TAt)(flag, value);
1215   env-&gt;ReleaseStringUTFChars(name, flag_name);
1216   return (result == JVMFlag::SUCCESS);
1217 }
1218 
1219 template &lt;typename T&gt;
1220 static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {
1221   if (name == NULL) {
1222     return false;
1223   }
1224   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1225   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1226   CHECK_JNI_EXCEPTION_(env, false);
1227   JVMFlag* flag = JVMFlag::find_flag(flag_name);
1228   JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);
1229   env-&gt;ReleaseStringUTFChars(name, flag_name);
1230   return (result == JVMFlag::SUCCESS);
1231 }
1232 
1233 template &lt;typename T&gt;
1234 static jobject box(JavaThread* thread, JNIEnv* env, Symbol* name, Symbol* sig, T value) {
1235   ResourceMark rm(thread);
1236   jclass clazz = env-&gt;FindClass(name-&gt;as_C_string());
1237   CHECK_JNI_EXCEPTION_(env, NULL);
1238   jmethodID methodID = env-&gt;GetStaticMethodID(clazz,
1239         vmSymbols::valueOf_name()-&gt;as_C_string(),
1240         sig-&gt;as_C_string());
1241   CHECK_JNI_EXCEPTION_(env, NULL);
1242   jobject result = env-&gt;CallStaticObjectMethod(clazz, methodID, value);
1243   CHECK_JNI_EXCEPTION_(env, NULL);
1244   return result;
1245 }
1246 
1247 static jobject booleanBox(JavaThread* thread, JNIEnv* env, jboolean value) {
1248   return box(thread, env, vmSymbols::java_lang_Boolean(), vmSymbols::Boolean_valueOf_signature(), value);
1249 }
1250 static jobject integerBox(JavaThread* thread, JNIEnv* env, jint value) {
1251   return box(thread, env, vmSymbols::java_lang_Integer(), vmSymbols::Integer_valueOf_signature(), value);
1252 }
1253 static jobject longBox(JavaThread* thread, JNIEnv* env, jlong value) {
1254   return box(thread, env, vmSymbols::java_lang_Long(), vmSymbols::Long_valueOf_signature(), value);
1255 }
1256 /* static jobject floatBox(JavaThread* thread, JNIEnv* env, jfloat value) {
1257   return box(thread, env, vmSymbols::java_lang_Float(), vmSymbols::Float_valueOf_signature(), value);
1258 }*/
1259 static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
1260   return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
1261 }
1262 
1263 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
1264   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1265   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1266   CHECK_JNI_EXCEPTION_(env, NULL);
1267   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
1268   env-&gt;ReleaseStringUTFChars(name, flag_name);
1269   return result;
1270 }
1271 
1272 WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
1273   const JVMFlag* flag = getVMFlag(thread, env, name);
1274   return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
1275 WB_END
1276 
1277 WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
1278   const JVMFlag* flag = getVMFlag(thread, env, name);
1279   return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
1280 WB_END
1281 
1282 WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
1283   bool result;
1284   if (GetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAt)) {
1285     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1286     return booleanBox(thread, env, result);
1287   }
1288   return NULL;
1289 WB_END
1290 
1291 WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
1292   int result;
1293   if (GetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAt)) {
1294     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1295     return longBox(thread, env, result);
1296   }
1297   return NULL;
1298 WB_END
1299 
1300 WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
1301   uint result;
1302   if (GetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAt)) {
1303     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1304     return longBox(thread, env, result);
1305   }
1306   return NULL;
1307 WB_END
1308 
1309 WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
1310   intx result;
1311   if (GetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAt)) {
1312     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1313     return longBox(thread, env, result);
1314   }
1315   return NULL;
1316 WB_END
1317 
1318 WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
1319   uintx result;
1320   if (GetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAt)) {
1321     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1322     return longBox(thread, env, result);
1323   }
1324   return NULL;
1325 WB_END
1326 
1327 WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
1328   uint64_t result;
1329   if (GetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAt)) {
1330     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1331     return longBox(thread, env, result);
1332   }
1333   return NULL;
1334 WB_END
1335 
1336 WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
1337   size_t result;
1338   if (GetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAt)) {
1339     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1340     return longBox(thread, env, result);
1341   }
1342   return NULL;
1343 WB_END
1344 
1345 WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
1346   double result;
1347   if (GetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAt)) {
1348     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1349     return doubleBox(thread, env, result);
1350   }
1351   return NULL;
1352 WB_END
1353 
1354 WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
1355   ccstr ccstrResult;
1356   if (GetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAt)) {
1357     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1358     jstring result = env-&gt;NewStringUTF(ccstrResult);
1359     CHECK_JNI_EXCEPTION_(env, NULL);
1360     return result;
1361   }
1362   return NULL;
1363 WB_END
1364 
1365 WB_ENTRY(void, WB_SetBooleanVMFlag(JNIEnv* env, jobject o, jstring name, jboolean value))
1366   bool result = value == JNI_TRUE ? true : false;
1367   SetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAtPut);
1368 WB_END
1369 
1370 WB_ENTRY(void, WB_SetIntVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1371   int result = value;
1372   SetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAtPut);
1373 WB_END
1374 
1375 WB_ENTRY(void, WB_SetUintVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1376   uint result = value;
1377   SetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAtPut);
1378 WB_END
1379 
1380 WB_ENTRY(void, WB_SetIntxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1381   intx result = value;
1382   SetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAtPut);
1383 WB_END
1384 
1385 WB_ENTRY(void, WB_SetUintxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1386   uintx result = value;
1387   SetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAtPut);
1388 WB_END
1389 
1390 WB_ENTRY(void, WB_SetUint64VMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1391   uint64_t result = value;
1392   SetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAtPut);
1393 WB_END
1394 
1395 WB_ENTRY(void, WB_SetSizeTVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1396   size_t result = value;
1397   SetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAtPut);
1398 WB_END
1399 
1400 WB_ENTRY(void, WB_SetDoubleVMFlag(JNIEnv* env, jobject o, jstring name, jdouble value))
1401   double result = value;
1402   SetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAtPut);
1403 WB_END
1404 
1405 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
1406   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1407   const char* ccstrValue;
1408   if (value == NULL) {
1409     ccstrValue = NULL;
1410   }
1411   else {
1412     ccstrValue = env-&gt;GetStringUTFChars(value, NULL);
1413     CHECK_JNI_EXCEPTION(env);
1414   }
1415   ccstr ccstrResult = ccstrValue;
1416   bool needFree;
1417   {
1418     ThreadInVMfromNative ttvfn(thread); // back to VM
1419     needFree = SetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAtPut);
1420   }
1421   if (value != NULL) {
1422     env-&gt;ReleaseStringUTFChars(value, ccstrValue);
1423   }
1424   if (needFree) {
1425     FREE_C_HEAP_ARRAY(char, ccstrResult);
1426   }
1427 WB_END
1428 
1429 WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
1430   WhiteBox::compilation_locked = true;
1431 WB_END
1432 
1433 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1434   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1435   WhiteBox::compilation_locked = false;
1436   mo.notify_all();
1437 WB_END
1438 
1439 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1440   // Force a code cache sweep and block until it finished
1441   NMethodSweeper::force_sweep();
1442 WB_END
1443 
1444 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1445   ResourceMark rm(THREAD);
1446   int len;
1447   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1448   return (StringTable::lookup(name, len) != NULL);
1449 WB_END
1450 
1451 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
1452   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1453   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1454 #if INCLUDE_G1GC
1455   if (UseG1GC) {
1456     // Needs to be cleared explicitly for G1
1457     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1458   }
1459 #endif // INCLUDE_G1GC
1460 WB_END
1461 
1462 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1463   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1464 WB_END
1465 
1466 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1467   // static+volatile in order to force the read to happen
1468   // (not be eliminated by the compiler)
1469   static char c;
1470   static volatile char* p;
1471 
1472   p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);
1473   if (p == NULL) {
1474     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), &quot;Failed to reserve memory&quot;);
1475   }
1476 
1477   c = *p;
1478 WB_END
1479 
1480 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
1481   const char* features = VM_Version::features_string();
1482   ThreadToNativeFromVM ttn(thread);
1483   jstring features_string = env-&gt;NewStringUTF(features);
1484 
1485   CHECK_JNI_EXCEPTION_(env, NULL);
1486 
1487   return features_string;
1488 WB_END
1489 
1490 int WhiteBox::get_blob_type(const CodeBlob* code) {
1491   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1492   if (code-&gt;is_aot()) {
1493     return -1;
1494   }
1495   return CodeCache::get_code_heap(code)-&gt;code_blob_type();
1496 }
1497 
1498 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1499   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1500   return CodeCache::get_code_heap(blob_type);
1501 }
1502 
1503 struct CodeBlobStub {
1504   CodeBlobStub(const CodeBlob* blob) :
1505       name(os::strdup(blob-&gt;name())),
1506       size(blob-&gt;size()),
1507       blob_type(WhiteBox::get_blob_type(blob)),
1508       address((jlong) blob) { }
1509   ~CodeBlobStub() { os::free((void*) name); }
1510   const char* const name;
1511   const jint        size;
1512   const jint        blob_type;
1513   const jlong       address;
1514 };
1515 
1516 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
1517   ResourceMark rm;
1518   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1519   CHECK_JNI_EXCEPTION_(env, NULL);
1520   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1521 
1522   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1523   CHECK_JNI_EXCEPTION_(env, NULL);
1524   env-&gt;SetObjectArrayElement(result, 0, name);
1525 
1526   jobject obj = integerBox(thread, env, cb-&gt;size);
1527   CHECK_JNI_EXCEPTION_(env, NULL);
1528   env-&gt;SetObjectArrayElement(result, 1, obj);
1529 
1530   obj = integerBox(thread, env, cb-&gt;blob_type);
1531   CHECK_JNI_EXCEPTION_(env, NULL);
1532   env-&gt;SetObjectArrayElement(result, 2, obj);
1533 
1534   obj = longBox(thread, env, cb-&gt;address);
1535   CHECK_JNI_EXCEPTION_(env, NULL);
1536   env-&gt;SetObjectArrayElement(result, 3, obj);
1537 
1538   return result;
1539 }
1540 
1541 WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
1542   ResourceMark rm(THREAD);
1543   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1544   CHECK_JNI_EXCEPTION_(env, NULL);
1545   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1546   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
1547   jobjectArray result = NULL;
1548   if (code == NULL) {
1549     return result;
1550   }
1551   int comp_level = code-&gt;comp_level();
1552   int insts_size = comp_level == CompLevel_aot ? code-&gt;code_end() - code-&gt;code_begin() : code-&gt;insts_size();
1553 
1554   ThreadToNativeFromVM ttn(thread);
1555   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1556   CHECK_JNI_EXCEPTION_(env, NULL);
1557   result = env-&gt;NewObjectArray(5, clazz, NULL);
1558   if (result == NULL) {
1559     return result;
1560   }
1561 
1562   CodeBlobStub stub(code);
1563   jobjectArray codeBlob = codeBlob2objectArray(thread, env, &amp;stub);
1564   CHECK_JNI_EXCEPTION_(env, NULL);
1565   env-&gt;SetObjectArrayElement(result, 0, codeBlob);
1566 
1567   jobject level = integerBox(thread, env, comp_level);
1568   CHECK_JNI_EXCEPTION_(env, NULL);
1569   env-&gt;SetObjectArrayElement(result, 1, level);
1570 
1571   jbyteArray insts = env-&gt;NewByteArray(insts_size);
1572   CHECK_JNI_EXCEPTION_(env, NULL);
1573   env-&gt;SetByteArrayRegion(insts, 0, insts_size, (jbyte*) code-&gt;insts_begin());
1574   env-&gt;SetObjectArrayElement(result, 2, insts);
1575 
1576   jobject id = integerBox(thread, env, code-&gt;compile_id());
1577   CHECK_JNI_EXCEPTION_(env, NULL);
1578   env-&gt;SetObjectArrayElement(result, 3, id);
1579 
1580   jobject entry_point = longBox(thread, env, (jlong) code-&gt;entry_point());
1581   CHECK_JNI_EXCEPTION_(env, NULL);
1582   env-&gt;SetObjectArrayElement(result, 4, entry_point);
1583 
1584   return result;
1585 WB_END
1586 
1587 CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {
1588   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1589   BufferBlob* blob;
1590   int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
1591   if (full_size &lt; size) {
1592     full_size += align_up(size - full_size, oopSize);
1593   }
1594   {
1595     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1596     blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
1597     if (blob != NULL) {
1598       ::new (blob) BufferBlob(&quot;WB::DummyBlob&quot;, full_size);
1599     }
1600   }
1601   // Track memory usage statistic after releasing CodeCache_lock
1602   MemoryService::track_code_cache_memory_usage();
1603   return blob;
1604 }
1605 
1606 WB_ENTRY(jlong, WB_AllocateCodeBlob(JNIEnv* env, jobject o, jint size, jint blob_type))
1607   if (size &lt; 0) {
1608     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1609       err_msg(&quot;WB_AllocateCodeBlob: size is negative: &quot; INT32_FORMAT, size));
1610   }
1611   return (jlong) WhiteBox::allocate_code_blob(size, blob_type);
1612 WB_END
1613 
1614 WB_ENTRY(void, WB_FreeCodeBlob(JNIEnv* env, jobject o, jlong addr))
1615   if (addr == 0) {
1616     return;
1617   }
1618   BufferBlob::free((BufferBlob*) addr);
1619 WB_END
1620 
1621 WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
1622   ResourceMark rm;
1623   GrowableArray&lt;CodeBlobStub*&gt; blobs;
1624   {
1625     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1626     CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
1627     if (heap == NULL) {
1628       return NULL;
1629     }
1630     for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
1631          cb != NULL; cb = (CodeBlob*) heap-&gt;next(cb)) {
1632       CodeBlobStub* stub = NEW_RESOURCE_OBJ(CodeBlobStub);
1633       new (stub) CodeBlobStub(cb);
1634       blobs.append(stub);
1635     }
1636   }
1637   ThreadToNativeFromVM ttn(thread);
1638   jobjectArray result = NULL;
1639   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1640   CHECK_JNI_EXCEPTION_(env, NULL);
1641   result = env-&gt;NewObjectArray(blobs.length(), clazz, NULL);
1642   CHECK_JNI_EXCEPTION_(env, NULL);
1643   if (result == NULL) {
1644     return result;
1645   }
1646   int i = 0;
1647   for (GrowableArrayIterator&lt;CodeBlobStub*&gt; it = blobs.begin();
1648        it != blobs.end(); ++it) {
1649     jobjectArray obj = codeBlob2objectArray(thread, env, *it);
1650     CHECK_JNI_EXCEPTION_(env, NULL);
1651     env-&gt;SetObjectArrayElement(result, i, obj);
1652     CHECK_JNI_EXCEPTION_(env, NULL);
1653     ++i;
1654   }
1655   return result;
1656 WB_END
1657 
1658 WB_ENTRY(jint, WB_GetCompilationActivityMode(JNIEnv* env, jobject o))
1659   return CompileBroker::get_compilation_activity_mode();
1660 WB_END
1661 
1662 WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
1663   if (addr == 0) {
1664     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
1665       &quot;WB_GetCodeBlob: addr is null&quot;);
1666   }
1667   ThreadToNativeFromVM ttn(thread);
1668   CodeBlobStub stub((CodeBlob*) addr);
1669   return codeBlob2objectArray(thread, env, &amp;stub);
1670 WB_END
1671 
1672 WB_ENTRY(jlong, WB_GetMethodData(JNIEnv* env, jobject wv, jobject method))
1673   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1674   CHECK_JNI_EXCEPTION_(env, 0);
1675   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1676   return (jlong) mh-&gt;method_data();
1677 WB_END
1678 
1679 WB_ENTRY(jlong, WB_GetThreadStackSize(JNIEnv* env, jobject o))
1680   return (jlong) Thread::current()-&gt;stack_size();
1681 WB_END
1682 
1683 WB_ENTRY(jlong, WB_GetThreadRemainingStackSize(JNIEnv* env, jobject o))
1684   JavaThread* t = JavaThread::current();
1685   return (jlong) t-&gt;stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();
1686 WB_END
1687 
1688 
1689 int WhiteBox::array_bytes_to_length(size_t bytes) {
1690   return Array&lt;u1&gt;::bytes_to_length(bytes);
1691 }
1692 
1693 WB_ENTRY(jlong, WB_AllocateMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong size))
1694   if (size &lt; 0) {
1695     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1696         err_msg(&quot;WB_AllocateMetaspace: size is negative: &quot; JLONG_FORMAT, size));
1697   }
1698 
1699   oop class_loader_oop = JNIHandles::resolve(class_loader);
1700   ClassLoaderData* cld = class_loader_oop != NULL
1701       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1702       : ClassLoaderData::the_null_class_loader_data();
1703 
1704   void* metadata = MetadataFactory::new_array&lt;u1&gt;(cld, WhiteBox::array_bytes_to_length((size_t)size), thread);
1705 
1706   return (jlong)(uintptr_t)metadata;
1707 WB_END
1708 
1709 WB_ENTRY(void, WB_FreeMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong addr, jlong size))
1710   oop class_loader_oop = JNIHandles::resolve(class_loader);
1711   ClassLoaderData* cld = class_loader_oop != NULL
1712       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1713       : ClassLoaderData::the_null_class_loader_data();
1714 
1715   MetadataFactory::free_array(cld, (Array&lt;u1&gt;*)(uintptr_t)addr);
1716 WB_END
1717 
1718 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
1719                                 jstring version, jstring location, jobjectArray packages))
1720   Modules::define_module(module, is_open, version, location, packages, CHECK);
1721 WB_END
1722 
1723 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
1724   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1725 WB_END
1726 
1727 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
1728   Modules::add_module_exports_to_all_unnamed(module, package, CHECK);
1729 WB_END
1730 
1731 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
1732   Modules::add_module_exports(module, package, NULL, CHECK);
1733 WB_END
1734 
1735 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
1736   Modules::add_reads_module(from_module, source_module, CHECK);
1737 WB_END
1738 
1739 WB_ENTRY(jlong, WB_IncMetaspaceCapacityUntilGC(JNIEnv* env, jobject wb, jlong inc))
1740   if (inc &lt; 0) {
1741     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1742         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc is negative: &quot; JLONG_FORMAT, inc));
1743   }
1744 
1745   jlong max_size_t = (jlong) ((size_t) -1);
1746   if (inc &gt; max_size_t) {
1747     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1748         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc does not fit in size_t: &quot; JLONG_FORMAT, inc));
1749   }
1750 
1751   size_t new_cap_until_GC = 0;
1752   size_t aligned_inc = align_down((size_t) inc, Metaspace::commit_alignment());
1753   bool success = MetaspaceGC::inc_capacity_until_GC(aligned_inc, &amp;new_cap_until_GC);
1754   if (!success) {
1755     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(),
1756                 &quot;WB_IncMetaspaceCapacityUntilGC: could not increase capacity until GC &quot;
1757                 &quot;due to contention with another thread&quot;);
1758   }
1759   return (jlong) new_cap_until_GC;
1760 WB_END
1761 
1762 WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
1763   return (jlong) MetaspaceGC::capacity_until_GC();
1764 WB_END
1765 
1766 WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
1767   return (jlong)Metaspace::reserve_alignment();
1768 WB_END
1769 
1770 WB_ENTRY(void, WB_AssertMatchingSafepointCalls(JNIEnv* env, jobject o, jboolean mutexSafepointValue, jboolean attemptedNoSafepointValue))
1771   Mutex::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?
1772                                            Mutex::_safepoint_check_always :
1773                                            Mutex::_safepoint_check_never;
1774   Mutex::SafepointCheckFlag sfpt_check_attempted = attemptedNoSafepointValue ?
1775                                            Mutex::_no_safepoint_check_flag :
1776                                            Mutex::_safepoint_check_flag;
1777   MutexLocker ml(new Mutex(Mutex::leaf, &quot;SFPT_Test_lock&quot;, true, sfpt_check_required),
1778                  sfpt_check_attempted);
1779 WB_END
1780 
1781 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1782   // Create a special lock violating condition in value
1783   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1784                                            Mutex::_safepoint_check_always :
1785                                            Mutex::_safepoint_check_never;
1786   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1787                                            Monitor::_safepoint_check_flag :
1788                                            Monitor::_no_safepoint_check_flag;
1789 
1790   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);
1791   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1792   ThreadBlockInVM tbivm(JavaThread::current());
1793 WB_END
1794 
1795 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1796   oop obj_oop = JNIHandles::resolve(obj);
1797   return (jboolean) obj_oop-&gt;mark().has_monitor();
1798 WB_END
1799 
1800 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
1801   VM_ForceSafepoint force_safepoint_op;
1802   VMThread::execute(&amp;force_safepoint_op);
1803 WB_END
1804 
1805 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1806   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1807   return (jlong) ik-&gt;constants();
1808 WB_END
1809 
1810 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1811   return ConstantPool::CPCACHE_INDEX_TAG;
1812 WB_END
1813 
1814 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1815   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1816   ConstantPool* cp = ik-&gt;constants();
1817   if (cp-&gt;cache() == NULL) {
1818       return -1;
1819   }
1820   return cp-&gt;cache()-&gt;length();
1821 WB_END
1822 
1823 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1824   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1825   ConstantPool* cp = ik-&gt;constants();
1826   if (cp-&gt;cache() == NULL) {
1827     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), &quot;Constant pool does not have a cache&quot;);
1828   }
1829   jint cpci = index;
1830   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1831   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1832     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool cache index is out of range&quot;);
1833   }
1834   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1835   return cpi;
1836 WB_END
1837 
1838 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1839   return ConstantPool::encode_invokedynamic_index(index);
1840 WB_END
1841 
1842 WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))
1843   oop aoop = JNIHandles::resolve(thing);
1844   if (!aoop-&gt;is_instance()) {
1845     return NULL;
1846   }
1847   instanceHandle ih(THREAD, (instanceOop) aoop);
1848   InstanceKlass* klass = InstanceKlass::cast(aoop-&gt;klass());
1849   if (klass-&gt;nonstatic_oop_map_count() == 0) {
1850     return NULL;
1851   }
1852   const OopMapBlock* map = klass-&gt;start_of_nonstatic_oop_maps();
1853   const OopMapBlock* const end = map + klass-&gt;nonstatic_oop_map_count();
1854   int oop_count = 0;
1855   while (map &lt; end) {
1856     oop_count += map-&gt;count();
1857     map++;
1858   }
1859 
1860   objArrayOop result_array =
1861       oopFactory::new_objArray(SystemDictionary::Object_klass(), oop_count, CHECK_NULL);
1862   map = klass-&gt;start_of_nonstatic_oop_maps();
1863   instanceOop ioop = ih();
1864   int index = 0;
1865   while (map &lt; end) {
1866     int offset = map-&gt;offset();
1867     for (unsigned int j = 0; j &lt; map-&gt;count(); j++) {
1868       result_array-&gt;obj_at_put(index++, ioop-&gt;obj_field(offset));
1869       offset += heapOopSize;
1870     }
1871     map++;
1872   }
1873   return (jobjectArray)JNIHandles::make_local(env, result_array);
1874 WB_END
1875 
1876 class CollectOops : public BasicOopIterateClosure {
1877  public:
1878   GrowableArray&lt;Handle&gt;* array;
1879 
1880   objArrayOop create_results(TRAPS) {
1881     objArrayOop result_array =
1882         oopFactory::new_objArray(SystemDictionary::Object_klass(), array-&gt;length(), CHECK_NULL);
1883     for (int i = 0 ; i &lt; array-&gt;length(); i++) {
1884       result_array-&gt;obj_at_put(i, array-&gt;at(i)());
1885     }
1886     return result_array;
1887   }
1888 
1889   jobjectArray create_jni_result(JNIEnv* env, TRAPS) {
1890     return (jobjectArray)JNIHandles::make_local(env, create_results(THREAD));
1891   }
1892 
1893   void add_oop(oop o) {
1894     // Value might be oop, but JLS can&#39;t see as Object, just iterate through it...
1895     if (o != NULL &amp;&amp; o-&gt;is_value()) {
1896       o-&gt;oop_iterate(this);
1897     } else {
1898       array-&gt;append(Handle(Thread::current(), o));
1899     }
1900   }
1901 
1902   void do_oop(oop* o) { add_oop(*o); }
1903   void do_oop(narrowOop* v) { add_oop(CompressedOops::decode(*v)); }
1904 };
1905 
1906 
1907 WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))
1908   ResourceMark rm(THREAD);
1909   GrowableArray&lt;Handle&gt;* array = new GrowableArray&lt;Handle&gt;(128);
1910   CollectOops collectOops;
1911   collectOops.array = array;
1912 
1913   JNIHandles::resolve(thing)-&gt;oop_iterate(&amp;collectOops);
1914 
1915   return collectOops.create_jni_result(env, THREAD);
1916 WB_END
1917 
1918 WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))
1919   ResourceMark rm(THREAD);
1920   GrowableArray&lt;Handle&gt;* array = new GrowableArray&lt;Handle&gt;(128);
1921   CollectOops collectOops;
1922   collectOops.array = array;
1923   StackFrameStream sfs(thread);
1924   while (depth &gt; 0) { // Skip the native WB API frame
1925     sfs.next();
1926     frame* f = sfs.current();
1927     f-&gt;oops_do(&amp;collectOops, NULL, sfs.register_map());
1928     depth--;
1929   }
1930   return collectOops.create_jni_result(env, THREAD);
1931 WB_END
1932 
1933 
1934 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1935   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1936   VMThread::execute(&amp;clear_ics);
1937 WB_END
1938 
1939 template &lt;typename T&gt;
1940 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1941   assert(value != NULL, &quot;sanity&quot;);
1942   if (method == NULL || name == NULL) {
1943     return false;
1944   }
1945   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1946   CHECK_JNI_EXCEPTION_(env, false);
1947   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1948   // can&#39;t be in VM when we call JNI
1949   ThreadToNativeFromVM ttnfv(thread);
1950   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1951   CHECK_JNI_EXCEPTION_(env, false);
1952   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1953   env-&gt;ReleaseStringUTFChars(name, flag_name);
1954   return result;
1955 }
1956 
1957 WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1958   bool result;
1959   if (GetMethodOption&lt;bool&gt; (thread, env, method, name, &amp;result)) {
1960     // can&#39;t be in VM when we call JNI
1961     ThreadToNativeFromVM ttnfv(thread);
1962     return booleanBox(thread, env, result);
1963   }
1964   return NULL;
1965 WB_END
1966 
1967 WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1968   intx result;
1969   if (GetMethodOption &lt;intx&gt; (thread, env, method, name, &amp;result)) {
1970     // can&#39;t be in VM when we call JNI
1971     ThreadToNativeFromVM ttnfv(thread);
1972     return longBox(thread, env, result);
1973   }
1974   return NULL;
1975 WB_END
1976 
1977 WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1978   uintx result;
1979   if (GetMethodOption &lt;uintx&gt; (thread, env, method, name, &amp;result)) {
1980     // can&#39;t be in VM when we call JNI
1981     ThreadToNativeFromVM ttnfv(thread);
1982     return longBox(thread, env, result);
1983   }
1984   return NULL;
1985 WB_END
1986 
1987 WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1988   double result;
1989   if (GetMethodOption &lt;double&gt; (thread, env, method, name, &amp;result)) {
1990     // can&#39;t be in VM when we call JNI
1991     ThreadToNativeFromVM ttnfv(thread);
1992     return doubleBox(thread, env, result);
1993   }
1994   return NULL;
1995 WB_END
1996 
1997 WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1998   ccstr ccstrResult;
1999   if (GetMethodOption &lt;ccstr&gt; (thread, env, method, name, &amp;ccstrResult)) {
2000     // can&#39;t be in VM when we call JNI
2001     ThreadToNativeFromVM ttnfv(thread);
2002     jstring result = env-&gt;NewStringUTF(ccstrResult);
2003     CHECK_JNI_EXCEPTION_(env, NULL);
2004     return result;
2005   }
2006   return NULL;
2007 WB_END
2008 
2009 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
2010   const char* p = Arguments::get_default_shared_archive_path();
2011   ThreadToNativeFromVM ttn(thread);
2012   jstring path_string = env-&gt;NewStringUTF(p);
2013 
2014   CHECK_JNI_EXCEPTION_(env, NULL);
2015 
2016   return path_string;
2017 WB_END
2018 
2019 WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
2020   return UseSharedSpaces;
2021 WB_END
2022 
2023 WB_ENTRY(jboolean, WB_CDSMemoryMappingFailed(JNIEnv* env, jobject wb))
2024   return FileMapInfo::memory_mapping_failed();
2025 WB_END
2026 
2027 WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
2028   oop obj_oop = JNIHandles::resolve(obj);
2029   return HeapShared::is_archived_object(obj_oop);
2030 WB_END
2031 
2032 WB_ENTRY(jboolean, WB_IsSharedClass(JNIEnv* env, jobject wb, jclass clazz))
2033   return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
2034 WB_END
2035 
2036 WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))
2037   return !HeapShared::closed_archive_heap_region_mapped();
2038 WB_END
2039 
2040 WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))
2041   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2042   if (k-&gt;is_instance_klass()) {
2043     InstanceKlass *ik = InstanceKlass::cast(k);
2044     ConstantPool *cp = ik-&gt;constants();
2045     objArrayOop refs =  cp-&gt;resolved_references();
2046     return (jobject)JNIHandles::make_local(env, refs);
2047   } else {
2048     return NULL;
2049   }
2050 WB_END
2051 
2052 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
2053   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2054   if (!k-&gt;is_instance_klass()) {
2055     return;
2056   }
2057   InstanceKlass *ik = InstanceKlass::cast(k);
2058   ik-&gt;link_class(THREAD); // may throw verification error
2059 WB_END
2060 
2061 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
2062   return HeapShared::open_archive_heap_region_mapped();
2063 WB_END
2064 
2065 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
2066 #if INCLUDE_CDS
2067   return true;
2068 #else
2069   return false;
2070 #endif // INCLUDE_CDS
2071 WB_END
2072 
2073 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
2074 #if COMPILER2_OR_JVMCI
2075   return true;
2076 #else
2077   return false;
2078 #endif
2079 WB_END
2080 
2081 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2082   return HeapShared::is_heap_object_archiving_allowed();
2083 WB_END
2084 
2085 
2086 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
2087 #if INCLUDE_JFR
2088   return true;
2089 #else
2090   return false;
2091 #endif // INCLUDE_JFR
2092 WB_END
2093 
2094 #if INCLUDE_CDS
2095 
2096 WB_ENTRY(jint, WB_GetOffsetForName(JNIEnv* env, jobject o, jstring name))
2097   ResourceMark rm;
2098   char* c_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
2099   int result = CDSOffsets::find_offset(c_name);
2100   return (jint)result;
2101 WB_END
2102 
2103 #endif // INCLUDE_CDS
2104 
2105 WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
2106   class TraceSelfClosure : public HandshakeClosure {
2107     jint _num_threads_completed;
2108 
2109     void do_thread(Thread* th) {
2110       assert(th-&gt;is_Java_thread(), &quot;sanity&quot;);
2111       JavaThread* jt = (JavaThread*)th;
2112       ResourceMark rm;
2113 
2114       jt-&gt;print_on(tty);
2115       jt-&gt;print_stack_on(tty);
2116       tty-&gt;cr();
2117       Atomic::inc(&amp;_num_threads_completed);
2118     }
2119 
2120   public:
2121     TraceSelfClosure() : HandshakeClosure(&quot;WB_TraceSelf&quot;), _num_threads_completed(0) {}
2122 
2123     jint num_threads_completed() const { return _num_threads_completed; }
2124   };
2125   TraceSelfClosure tsc;
2126 
2127   if (all_threads) {
2128     Handshake::execute(&amp;tsc);
2129   } else {
2130     oop thread_oop = JNIHandles::resolve(thread_handle);
2131     if (thread_oop != NULL) {
2132       JavaThread* target = java_lang_Thread::thread(thread_oop);
2133       Handshake::execute(&amp;tsc, target);
2134     }
2135   }
2136   return tsc.num_threads_completed();
2137 WB_END
2138 
2139 //Some convenience methods to deal with objects from java
2140 int WhiteBox::offset_for_field(const char* field_name, oop object,
2141     Symbol* signature_symbol) {
2142   assert(field_name != NULL &amp;&amp; strlen(field_name) &gt; 0, &quot;Field name not valid&quot;);
2143   Thread* THREAD = Thread::current();
2144 
2145   //Get the class of our object
2146   Klass* arg_klass = object-&gt;klass();
2147   //Turn it into an instance-klass
2148   InstanceKlass* ik = InstanceKlass::cast(arg_klass);
2149 
2150   //Create symbols to look for in the class
2151   TempNewSymbol name_symbol = SymbolTable::new_symbol(field_name);
2152 
2153   //To be filled in with an offset of the field we&#39;re looking for
2154   fieldDescriptor fd;
2155 
2156   Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
2157   if (res == NULL) {
2158     tty-&gt;print_cr(&quot;Invalid layout of %s at %s&quot;, ik-&gt;external_name(),
2159         name_symbol-&gt;as_C_string());
2160     vm_exit_during_initialization(&quot;Invalid layout of preloaded class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
2161   }
2162 
2163   //fetch the field at the offset we&#39;ve found
2164   int dest_offset = fd.offset();
2165 
2166   return dest_offset;
2167 }
2168 
2169 
2170 const char* WhiteBox::lookup_jstring(const char* field_name, oop object) {
2171   int offset = offset_for_field(field_name, object,
2172       vmSymbols::string_signature());
2173   oop string = object-&gt;obj_field(offset);
2174   if (string == NULL) {
2175     return NULL;
2176   }
2177   const char* ret = java_lang_String::as_utf8_string(string);
2178   return ret;
2179 }
2180 
2181 bool WhiteBox::lookup_bool(const char* field_name, oop object) {
2182   int offset =
2183       offset_for_field(field_name, object, vmSymbols::bool_signature());
2184   bool ret = (object-&gt;bool_field(offset) == JNI_TRUE);
2185   return ret;
2186 }
2187 
2188 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
2189   ResourceMark rm;
2190   ThreadToNativeFromVM ttnfv(thread); // can&#39;t be in VM when we call JNI
2191 
2192   //  one by one registration natives for exception catching
2193   jclass no_such_method_error_klass = env-&gt;FindClass(vmSymbols::java_lang_NoSuchMethodError()-&gt;as_C_string());
2194   CHECK_JNI_EXCEPTION(env);
2195   for (int i = 0, n = method_count; i &lt; n; ++i) {
2196     // Skip dummy entries
2197     if (method_array[i].fnPtr == NULL) continue;
2198     if (env-&gt;RegisterNatives(wbclass, &amp;method_array[i], 1) != 0) {
2199       jthrowable throwable_obj = env-&gt;ExceptionOccurred();
2200       if (throwable_obj != NULL) {
2201         env-&gt;ExceptionClear();
2202         if (env-&gt;IsInstanceOf(throwable_obj, no_such_method_error_klass)) {
2203           // NoSuchMethodError is thrown when a method can&#39;t be found or a method is not native.
2204           // Ignoring the exception since it is not preventing use of other WhiteBox methods.
2205           tty-&gt;print_cr(&quot;Warning: &#39;NoSuchMethodError&#39; on register of sun.hotspot.WhiteBox::%s%s&quot;,
2206               method_array[i].name, method_array[i].signature);
2207         }
2208       } else {
2209         // Registration failed unexpectedly.
2210         tty-&gt;print_cr(&quot;Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered&quot;,
2211             method_array[i].name, method_array[i].signature);
2212         env-&gt;UnregisterNatives(wbclass);
2213         break;
2214       }
2215     }
2216   }
2217 }
2218 
2219 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
2220   // can&#39;t be in VM when we call JNI
2221   ThreadToNativeFromVM ttnfv(thread);
2222   const char* dir = env-&gt;GetStringUTFChars(compDirect, NULL);
2223   CHECK_JNI_EXCEPTION_(env, 0);
2224   int ret;
2225   {
2226     ThreadInVMfromNative ttvfn(thread); // back to VM
2227     ret = DirectivesParser::parse_string(dir, tty);
2228   }
2229   env-&gt;ReleaseStringUTFChars(compDirect, dir);
2230   // -1 for error parsing directive. Return 0 as number of directives added.
2231   if (ret == -1) {
2232     ret = 0;
2233   }
2234   return (jint) ret;
2235 WB_END
2236 
2237 WB_ENTRY(void, WB_RemoveCompilerDirective(JNIEnv* env, jobject o, jint count))
2238   DirectivesStack::pop(count);
2239 WB_END
2240 
2241 // Checks that the library libfile has the noexecstack bit set.
2242 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2243   jboolean ret = false;
2244 #ifdef LINUX
2245   // Can&#39;t be in VM when we call JNI.
2246   ThreadToNativeFromVM ttnfv(thread);
2247   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2248   CHECK_JNI_EXCEPTION_(env, 0);
2249   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2250   env-&gt;ReleaseStringUTFChars(libfile, lf);
2251 #endif
2252   return ret;
2253 WB_END
2254 
2255 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2256   LINUX_ONLY(return OSContainer::is_containerized();)
2257   return false;
2258 WB_END
2259 
2260 WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,
2261                                     jobject o,
2262                                     jstring proc_cgroups,
2263                                     jstring proc_self_cgroup,
2264                                     jstring proc_self_mountinfo))
2265   jint ret = 0;
2266 #ifdef LINUX
2267   ThreadToNativeFromVM ttnfv(thread);
2268   const char* p_cgroups = env-&gt;GetStringUTFChars(proc_cgroups, NULL);
2269   CHECK_JNI_EXCEPTION_(env, 0);
2270   const char* p_s_cgroup = env-&gt;GetStringUTFChars(proc_self_cgroup, NULL);
2271   CHECK_JNI_EXCEPTION_(env, 0);
2272   const char* p_s_mountinfo = env-&gt;GetStringUTFChars(proc_self_mountinfo, NULL);
2273   CHECK_JNI_EXCEPTION_(env, 0);
2274   u1 cg_type_flags = 0;
2275   // This sets cg_type_flags
2276   WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &amp;cg_type_flags);
2277   ret = (jint)cg_type_flags;
2278   env-&gt;ReleaseStringUTFChars(proc_cgroups, p_cgroups);
2279   env-&gt;ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);
2280   env-&gt;ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);
2281 #endif
2282   return ret;
2283 WB_END
2284 
2285 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2286   os::print_os_info(tty);
2287 WB_END
2288 
2289 // Elf decoder
2290 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2291 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2292   ElfFile::_do_not_cache_elf_section = true;
2293 #endif
2294 WB_END
2295 
2296 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2297   return (jlong) ResolvedMethodTable::items_count();
2298 WB_END
2299 
2300 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2301   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2302 WB_END
2303 
2304 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
2305   jint result = 0;
2306 #if INCLUDE_AOT
2307   result = (jint) AOTLoader::heaps_count();
2308 #endif
2309   return result;
2310 WB_END
2311 
2312 WB_ENTRY(jint, WB_GetKlassMetadataSize(JNIEnv* env, jobject wb, jclass mirror))
2313   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2314   // Return size in bytes.
2315   return k-&gt;size() * wordSize;
2316 WB_END
2317 
2318 #define CC (char*)
2319 
2320 static JNINativeMethod methods[] = {
2321   {CC&quot;getObjectAddress0&quot;,                CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectAddress  },
2322   {CC&quot;getObjectSize0&quot;,                   CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectSize     },
2323   {CC&quot;isObjectInOldGen0&quot;,                CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_isObjectInOldGen  },
2324   {CC&quot;getHeapOopSize&quot;,                   CC&quot;()I&quot;,                   (void*)&amp;WB_GetHeapOopSize    },
2325   {CC&quot;getVMPageSize&quot;,                    CC&quot;()I&quot;,                   (void*)&amp;WB_GetVMPageSize     },
2326   {CC&quot;getVMAllocationGranularity&quot;,       CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMAllocationGranularity },
2327   {CC&quot;getVMLargePageSize&quot;,               CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMLargePageSize},
2328   {CC&quot;getHeapSpaceAlignment&quot;,            CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapSpaceAlignment},
2329   {CC&quot;getHeapAlignment&quot;,                 CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapAlignment},
2330   {CC&quot;countAliveClasses0&quot;,               CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_CountAliveClasses },
2331   {CC&quot;getSymbolRefcount&quot;,                CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_GetSymbolRefcount },
2332   {CC&quot;parseCommandLine0&quot;,
2333       CC&quot;(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;&quot;,
2334       (void*) &amp;WB_ParseCommandLine
2335   },
2336   {CC&quot;addToBootstrapClassLoaderSearch0&quot;, CC&quot;(Ljava/lang/String;)V&quot;,
2337                                                       (void*)&amp;WB_AddToBootstrapClassLoaderSearch},
2338   {CC&quot;addToSystemClassLoaderSearch0&quot;,    CC&quot;(Ljava/lang/String;)V&quot;,
2339                                                       (void*)&amp;WB_AddToSystemClassLoaderSearch},
2340   {CC&quot;getCompressedOopsMaxHeapSize&quot;, CC&quot;()J&quot;,
2341       (void*)&amp;WB_GetCompressedOopsMaxHeapSize},
2342   {CC&quot;printHeapSizes&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_PrintHeapSizes    },
2343   {CC&quot;runMemoryUnitTests&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_RunMemoryUnitTests},
2344   {CC&quot;readFromNoaccessArea&quot;,CC&quot;()V&quot;,                  (void*)&amp;WB_ReadFromNoaccessArea},
2345   {CC&quot;stressVirtualSpaceResize&quot;,CC&quot;(JJJ)I&quot;,           (void*)&amp;WB_StressVirtualSpaceResize},
2346 #if INCLUDE_CDS
2347   {CC&quot;getOffsetForName0&quot;, CC&quot;(Ljava/lang/String;)I&quot;,  (void*)&amp;WB_GetOffsetForName},
2348 #endif
2349 #if INCLUDE_G1GC
2350   {CC&quot;g1InConcurrentMark&quot;, CC&quot;()Z&quot;,                   (void*)&amp;WB_G1InConcurrentMark},
2351   {CC&quot;g1IsHumongous0&quot;,      CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_G1IsHumongous     },
2352   {CC&quot;g1BelongsToHumongousRegion0&quot;, CC&quot;(J)Z&quot;,         (void*)&amp;WB_G1BelongsToHumongousRegion},
2353   {CC&quot;g1BelongsToFreeRegion0&quot;, CC&quot;(J)Z&quot;,              (void*)&amp;WB_G1BelongsToFreeRegion},
2354   {CC&quot;g1NumMaxRegions&quot;,    CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumMaxRegions  },
2355   {CC&quot;g1NumFreeRegions&quot;,   CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumFreeRegions  },
2356   {CC&quot;g1RegionSize&quot;,       CC&quot;()I&quot;,                   (void*)&amp;WB_G1RegionSize      },
2357   {CC&quot;g1StartConcMarkCycle&quot;,       CC&quot;()Z&quot;,           (void*)&amp;WB_G1StartMarkCycle  },
2358   {CC&quot;g1AuxiliaryMemoryUsage&quot;, CC&quot;()Ljava/lang/management/MemoryUsage;&quot;,
2359                                                       (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
2360   {CC&quot;g1ActiveMemoryNodeCount&quot;, CC&quot;()I&quot;,              (void*)&amp;WB_G1ActiveMemoryNodeCount },
2361   {CC&quot;g1MemoryNodeIds&quot;,    CC&quot;()[I&quot;,                  (void*)&amp;WB_G1MemoryNodeIds },
2362   {CC&quot;g1GetMixedGCInfo&quot;,   CC&quot;(I)[J&quot;,                 (void*)&amp;WB_G1GetMixedGCInfo },
2363 #endif // INCLUDE_G1GC
2364 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
2365   {CC&quot;dramReservedStart&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedStart },
2366   {CC&quot;dramReservedEnd&quot;,     CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedEnd },
2367   {CC&quot;nvdimmReservedStart&quot;, CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedStart },
2368   {CC&quot;nvdimmReservedEnd&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedEnd },
2369 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
2370 #if INCLUDE_PARALLELGC
2371   {CC&quot;psVirtualSpaceAlignment&quot;,CC&quot;()J&quot;,               (void*)&amp;WB_PSVirtualSpaceAlignment},
2372   {CC&quot;psHeapGenerationAlignment&quot;,CC&quot;()J&quot;,             (void*)&amp;WB_PSHeapGenerationAlignment},
2373 #endif
2374 #if INCLUDE_NMT
2375   {CC&quot;NMTMalloc&quot;,           CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTMalloc          },
2376   {CC&quot;NMTMallocWithPseudoStack&quot;, CC&quot;(JI)J&quot;,           (void*)&amp;WB_NMTMallocWithPseudoStack},
2377   {CC&quot;NMTMallocWithPseudoStackAndType&quot;, CC&quot;(JII)J&quot;,   (void*)&amp;WB_NMTMallocWithPseudoStackAndType},
2378   {CC&quot;NMTFree&quot;,             CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFree            },
2379   {CC&quot;NMTReserveMemory&quot;,    CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTReserveMemory   },
2380   {CC&quot;NMTAttemptReserveMemoryAt&quot;,    CC&quot;(JJ)J&quot;,       (void*)&amp;WB_NMTAttemptReserveMemoryAt },
2381   {CC&quot;NMTCommitMemory&quot;,     CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTCommitMemory    },
2382   {CC&quot;NMTUncommitMemory&quot;,   CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTUncommitMemory  },
2383   {CC&quot;NMTReleaseMemory&quot;,    CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTReleaseMemory   },
2384   {CC&quot;NMTChangeTrackingLevel&quot;, CC&quot;()Z&quot;,               (void*)&amp;WB_NMTChangeTrackingLevel},
2385   {CC&quot;NMTGetHashSize&quot;,      CC&quot;()I&quot;,                  (void*)&amp;WB_NMTGetHashSize     },
2386   {CC&quot;NMTNewArena&quot;,         CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTNewArena        },
2387   {CC&quot;NMTFreeArena&quot;,        CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFreeArena       },
2388   {CC&quot;NMTArenaMalloc&quot;,      CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTArenaMalloc     },
2389 #endif // INCLUDE_NMT
2390   {CC&quot;deoptimizeFrames&quot;,   CC&quot;(Z)I&quot;,                  (void*)&amp;WB_DeoptimizeFrames  },
2391   {CC&quot;deoptimizeAll&quot;,      CC&quot;()V&quot;,                   (void*)&amp;WB_DeoptimizeAll     },
2392   {CC&quot;deoptimizeMethod0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,
2393                                                       (void*)&amp;WB_DeoptimizeMethod  },
2394   {CC&quot;isMethodCompiled0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,
2395                                                       (void*)&amp;WB_IsMethodCompiled  },
2396   {CC&quot;isMethodCompilable0&quot;, CC&quot;(Ljava/lang/reflect/Executable;IZ)Z&quot;,
2397                                                       (void*)&amp;WB_IsMethodCompilable},
2398   {CC&quot;isMethodQueuedForCompilation0&quot;,
2399       CC&quot;(Ljava/lang/reflect/Executable;)Z&quot;,          (void*)&amp;WB_IsMethodQueuedForCompilation},
2400   {CC&quot;isIntrinsicAvailable0&quot;,
2401       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/reflect/Executable;I)Z&quot;,
2402                                                       (void*)&amp;WB_IsIntrinsicAvailable},
2403   {CC&quot;makeMethodNotCompilable0&quot;,
2404       CC&quot;(Ljava/lang/reflect/Executable;IZ)V&quot;,        (void*)&amp;WB_MakeMethodNotCompilable},
2405   {CC&quot;testSetDontInlineMethod0&quot;,
2406       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetDontInlineMethod},
2407   {CC&quot;getMethodCompilationLevel0&quot;,
2408       CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,         (void*)&amp;WB_GetMethodCompilationLevel},
2409   {CC&quot;getMethodEntryBci0&quot;,
2410       CC&quot;(Ljava/lang/reflect/Executable;)I&quot;,          (void*)&amp;WB_GetMethodEntryBci},
2411   {CC&quot;getCompileQueueSize&quot;,
2412       CC&quot;(I)I&quot;,                                       (void*)&amp;WB_GetCompileQueueSize},
2413   {CC&quot;testSetForceInlineMethod0&quot;,
2414       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetForceInlineMethod},
2415   {CC&quot;enqueueMethodForCompilation0&quot;,
2416       CC&quot;(Ljava/lang/reflect/Executable;II)Z&quot;,        (void*)&amp;WB_EnqueueMethodForCompilation},
2417   {CC&quot;enqueueInitializerForCompilation0&quot;,
2418       CC&quot;(Ljava/lang/Class;I)Z&quot;,                      (void*)&amp;WB_EnqueueInitializerForCompilation},
2419   {CC&quot;markMethodProfiled&quot;,
2420       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_MarkMethodProfiled},
2421   {CC&quot;clearMethodState0&quot;,
2422       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_ClearMethodState},
2423   {CC&quot;lockCompilation&quot;,    CC&quot;()V&quot;,                   (void*)&amp;WB_LockCompilation},
2424   {CC&quot;unlockCompilation&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_UnlockCompilation},
2425   {CC&quot;matchesMethod&quot;,
2426       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2427                                                       (void*)&amp;WB_MatchesMethod},
2428   {CC&quot;matchesInline&quot;,
2429       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2430                                                       (void*)&amp;WB_MatchesInline},
2431   {CC&quot;shouldPrintAssembly&quot;,
2432         CC&quot;(Ljava/lang/reflect/Executable;I)Z&quot;,
2433                                                         (void*)&amp;WB_ShouldPrintAssembly},
2434 
2435   {CC&quot;isConstantVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsConstantVMFlag},
2436   {CC&quot;isLockedVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsLockedVMFlag},
2437   {CC&quot;setBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;Z)V&quot;,(void*)&amp;WB_SetBooleanVMFlag},
2438   {CC&quot;setIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntVMFlag},
2439   {CC&quot;setUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintVMFlag},
2440   {CC&quot;setIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntxVMFlag},
2441   {CC&quot;setUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintxVMFlag},
2442   {CC&quot;setUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUint64VMFlag},
2443   {CC&quot;setSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetSizeTVMFlag},
2444   {CC&quot;setDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;D)V&quot;,(void*)&amp;WB_SetDoubleVMFlag},
2445   {CC&quot;setStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;,
2446                                                       (void*)&amp;WB_SetStringVMFlag},
2447   {CC&quot;getBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2448                                                       (void*)&amp;WB_GetBooleanVMFlag},
2449   {CC&quot;getIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2450                                                       (void*)&amp;WB_GetIntVMFlag},
2451   {CC&quot;getUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2452                                                       (void*)&amp;WB_GetUintVMFlag},
2453   {CC&quot;getIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2454                                                       (void*)&amp;WB_GetIntxVMFlag},
2455   {CC&quot;getUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2456                                                       (void*)&amp;WB_GetUintxVMFlag},
2457   {CC&quot;getUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2458                                                       (void*)&amp;WB_GetUint64VMFlag},
2459   {CC&quot;getSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2460                                                       (void*)&amp;WB_GetSizeTVMFlag},
2461   {CC&quot;getDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Double;&quot;,
2462                                                       (void*)&amp;WB_GetDoubleVMFlag},
2463   {CC&quot;getStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;,
2464                                                       (void*)&amp;WB_GetStringVMFlag},
2465   {CC&quot;isInStringTable&quot;,    CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsInStringTable  },
2466   {CC&quot;fullGC&quot;,   CC&quot;()V&quot;,                             (void*)&amp;WB_FullGC },
2467   {CC&quot;youngGC&quot;,  CC&quot;()V&quot;,                             (void*)&amp;WB_YoungGC },
2468   {CC&quot;readReservedMemory&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_ReadReservedMemory },
2469   {CC&quot;allocateMetaspace&quot;,
2470      CC&quot;(Ljava/lang/ClassLoader;J)J&quot;,                 (void*)&amp;WB_AllocateMetaspace },
2471   {CC&quot;freeMetaspace&quot;,
2472      CC&quot;(Ljava/lang/ClassLoader;JJ)V&quot;,                (void*)&amp;WB_FreeMetaspace },
2473   {CC&quot;incMetaspaceCapacityUntilGC&quot;, CC&quot;(J)J&quot;,         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
2474   {CC&quot;metaspaceCapacityUntilGC&quot;, CC&quot;()J&quot;,             (void*)&amp;WB_MetaspaceCapacityUntilGC },
2475   {CC&quot;metaspaceReserveAlignment&quot;, CC&quot;()J&quot;,            (void*)&amp;WB_MetaspaceReserveAlignment },
2476   {CC&quot;getCPUFeatures&quot;,     CC&quot;()Ljava/lang/String;&quot;,  (void*)&amp;WB_GetCPUFeatures     },
2477   {CC&quot;getNMethod0&quot;,         CC&quot;(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;&quot;,
2478                                                       (void*)&amp;WB_GetNMethod         },
2479   {CC&quot;forceNMethodSweep&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_ForceNMethodSweep  },
2480   {CC&quot;allocateCodeBlob&quot;,   CC&quot;(II)J&quot;,                 (void*)&amp;WB_AllocateCodeBlob   },
2481   {CC&quot;freeCodeBlob&quot;,       CC&quot;(J)V&quot;,                  (void*)&amp;WB_FreeCodeBlob       },
2482   {CC&quot;getCodeHeapEntries&quot;, CC&quot;(I)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeHeapEntries },
2483   {CC&quot;getCompilationActivityMode&quot;,
2484                            CC&quot;()I&quot;,                   (void*)&amp;WB_GetCompilationActivityMode},
2485   {CC&quot;getMethodData0&quot;,     CC&quot;(Ljava/lang/reflect/Executable;)J&quot;,
2486                                                       (void*)&amp;WB_GetMethodData      },
2487   {CC&quot;getCodeBlob&quot;,        CC&quot;(J)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeBlob        },
2488   {CC&quot;getThreadStackSize&quot;, CC&quot;()J&quot;,                   (void*)&amp;WB_GetThreadStackSize },
2489   {CC&quot;getThreadRemainingStackSize&quot;, CC&quot;()J&quot;,          (void*)&amp;WB_GetThreadRemainingStackSize },
2490   {CC&quot;DefineModule&quot;,       CC&quot;(Ljava/lang/Object;ZLjava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V&quot;,
2491                                                       (void*)&amp;WB_DefineModule },
2492   {CC&quot;AddModuleExports&quot;,   CC&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,
2493                                                       (void*)&amp;WB_AddModuleExports },
2494   {CC&quot;AddReadsModule&quot;,     CC&quot;(Ljava/lang/Object;Ljava/lang/Object;)V&quot;,
2495                                                       (void*)&amp;WB_AddReadsModule },
2496   {CC&quot;AddModuleExportsToAllUnnamed&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2497                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2498   {CC&quot;AddModuleExportsToAll&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2499                                                       (void*)&amp;WB_AddModuleExportsToAll },
2500   {CC&quot;assertMatchingSafepointCalls&quot;, CC&quot;(ZZ)V&quot;,       (void*)&amp;WB_AssertMatchingSafepointCalls },
2501   {CC&quot;assertSpecialLock&quot;,  CC&quot;(ZZ)V&quot;,                 (void*)&amp;WB_AssertSpecialLock },
2502   {CC&quot;isMonitorInflated0&quot;, CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsMonitorInflated  },
2503   {CC&quot;forceSafepoint&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_ForceSafepoint     },
2504   {CC&quot;getConstantPool0&quot;,   CC&quot;(Ljava/lang/Class;)J&quot;,  (void*)&amp;WB_GetConstantPool    },
2505   {CC&quot;getConstantPoolCacheIndexTag0&quot;, CC&quot;()I&quot;,  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2506   {CC&quot;getConstantPoolCacheLength0&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,  (void*)&amp;WB_GetConstantPoolCacheLength},
2507   {CC&quot;remapInstructionOperandFromCPCache0&quot;,
2508       CC&quot;(Ljava/lang/Class;I)I&quot;,                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2509   {CC&quot;encodeConstantPoolIndyIndex0&quot;,
2510       CC&quot;(I)I&quot;,                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
2511   {CC&quot;getObjectsViaKlassOopMaps0&quot;,
2512       CC&quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;,    (void*)&amp;WB_getObjectsViaKlassOopMaps},
2513   {CC&quot;getObjectsViaOopIterator0&quot;,
2514           CC&quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;,(void*)&amp;WB_getObjectsViaOopIterator},
2515   {CC&quot;getObjectsViaFrameOopIterator&quot;,
2516       CC&quot;(I)[Ljava/lang/Object;&quot;,                     (void*)&amp;WB_getObjectsViaFrameOopIterator},
2517   {CC&quot;getMethodBooleanOption&quot;,
2518       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2519                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2520   {CC&quot;getMethodIntxOption&quot;,
2521       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2522                                                       (void*)&amp;WB_GetMethodIntxOption},
2523   {CC&quot;getMethodUintxOption&quot;,
2524       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2525                                                       (void*)&amp;WB_GetMethodUintxOption},
2526   {CC&quot;getMethodDoubleOption&quot;,
2527       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;&quot;,
2528                                                       (void*)&amp;WB_GetMethodDoubleOption},
2529   {CC&quot;getMethodStringOption&quot;,
2530       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;&quot;,
2531                                                       (void*)&amp;WB_GetMethodStringOption},
2532   {CC&quot;getDefaultArchivePath&quot;,             CC&quot;()Ljava/lang/String;&quot;,
2533                                                       (void*)&amp;WB_GetDefaultArchivePath},
2534   {CC&quot;isSharingEnabled&quot;,   CC&quot;()Z&quot;,                   (void*)&amp;WB_IsSharingEnabled},
2535   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2536   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2537   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2538   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
2539   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},
2540   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2541   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2542   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2543   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2544   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2545   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },
2546 
2547   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2548   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2549   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2550                                                       (void*)&amp;WB_AddCompilerDirective },
2551   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2552   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2553   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2554   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
2555   {CC&quot;supportsConcurrentGCBreakpoints&quot;, CC&quot;()Z&quot;,      (void*)&amp;WB_SupportsConcurrentGCBreakpoints},
2556   {CC&quot;concurrentGCAcquireControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCAcquireControl},
2557   {CC&quot;concurrentGCReleaseControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCReleaseControl},
2558   {CC&quot;concurrentGCRunToIdle0&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_ConcurrentGCRunToIdle},
2559   {CC&quot;concurrentGCRunTo0&quot;,        CC&quot;(Ljava/lang/String;)Z&quot;,
2560                                                       (void*)&amp;WB_ConcurrentGCRunTo},
2561   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2562                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2563   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },
2564   {CC&quot;validateCgroup&quot;,
2565       CC&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I&quot;,
2566                                                       (void*)&amp;WB_ValidateCgroup },
2567   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2568   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
2569   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },
2570   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2571   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
2572   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},
2573 };
2574 
2575 
2576 #undef CC
2577 
2578 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2579   {
2580     if (WhiteBoxAPI) {
2581       // Make sure that wbclass is loaded by the null classloader
2582       InstanceKlass* ik = InstanceKlass::cast(JNIHandles::resolve(wbclass)-&gt;klass());
2583       Handle loader(THREAD, ik-&gt;class_loader());
2584       if (loader.is_null()) {
2585         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2586         WhiteBox::set_used();
2587       }
2588     }
2589   }
2590 JVM_END
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
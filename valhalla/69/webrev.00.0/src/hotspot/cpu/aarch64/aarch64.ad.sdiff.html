<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../.hgtags.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../x86/c1_LIRAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
10644 
10645   ins_encode %{
10646     __ mulw(rscratch1, as_Register($src1$$reg), as_Register($src2$$reg));
10647     __ maddw(as_Register($dst$$reg), as_Register($src3$$reg), as_Register($src4$$reg), rscratch1); %}
10648 
10649   ins_pipe(imac_reg_reg);
10650 %}
10651 
10652 // Integer Divide
10653 
10654 instruct divI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{
10655   match(Set dst (DivI src1 src2));
10656 
10657   ins_cost(INSN_COST * 19);
10658   format %{ &quot;sdivw  $dst, $src1, $src2&quot; %}
10659 
10660   ins_encode(aarch64_enc_divw(dst, src1, src2));
10661   ins_pipe(idiv_reg_reg);
10662 %}
10663 
<span class="line-removed">10664 instruct signExtract(iRegINoSp dst, iRegIorL2I src1, immI_31 div1, immI_31 div2) %{</span>
<span class="line-removed">10665   match(Set dst (URShiftI (RShiftI src1 div1) div2));</span>
<span class="line-removed">10666   ins_cost(INSN_COST);</span>
<span class="line-removed">10667   format %{ &quot;lsrw $dst, $src1, $div1&quot; %}</span>
<span class="line-removed">10668   ins_encode %{</span>
<span class="line-removed">10669     __ lsrw(as_Register($dst$$reg), as_Register($src1$$reg), 31);</span>
<span class="line-removed">10670   %}</span>
<span class="line-removed">10671   ins_pipe(ialu_reg_shift);</span>
<span class="line-removed">10672 %}</span>
<span class="line-removed">10673 </span>
<span class="line-removed">10674 instruct div2Round(iRegINoSp dst, iRegIorL2I src, immI_31 div1, immI_31 div2) %{</span>
<span class="line-removed">10675   match(Set dst (AddI src (URShiftI (RShiftI src div1) div2)));</span>
<span class="line-removed">10676   ins_cost(INSN_COST);</span>
<span class="line-removed">10677   format %{ &quot;addw $dst, $src, LSR $div1&quot; %}</span>
<span class="line-removed">10678 </span>
<span class="line-removed">10679   ins_encode %{</span>
<span class="line-removed">10680     __ addw(as_Register($dst$$reg),</span>
<span class="line-removed">10681               as_Register($src$$reg),</span>
<span class="line-removed">10682               as_Register($src$$reg),</span>
<span class="line-removed">10683               Assembler::LSR, 31);</span>
<span class="line-removed">10684   %}</span>
<span class="line-removed">10685   ins_pipe(ialu_reg);</span>
<span class="line-removed">10686 %}</span>
<span class="line-removed">10687 </span>
10688 // Long Divide
10689 
10690 instruct divL(iRegLNoSp dst, iRegL src1, iRegL src2) %{
10691   match(Set dst (DivL src1 src2));
10692 
10693   ins_cost(INSN_COST * 35);
10694   format %{ &quot;sdiv   $dst, $src1, $src2&quot; %}
10695 
10696   ins_encode(aarch64_enc_div(dst, src1, src2));
10697   ins_pipe(ldiv_reg_reg);
10698 %}
10699 
<span class="line-removed">10700 instruct signExtractL(iRegLNoSp dst, iRegL src1, immI_63 div1, immI_63 div2) %{</span>
<span class="line-removed">10701   match(Set dst (URShiftL (RShiftL src1 div1) div2));</span>
<span class="line-removed">10702   ins_cost(INSN_COST);</span>
<span class="line-removed">10703   format %{ &quot;lsr $dst, $src1, $div1&quot; %}</span>
<span class="line-removed">10704   ins_encode %{</span>
<span class="line-removed">10705     __ lsr(as_Register($dst$$reg), as_Register($src1$$reg), 63);</span>
<span class="line-removed">10706   %}</span>
<span class="line-removed">10707   ins_pipe(ialu_reg_shift);</span>
<span class="line-removed">10708 %}</span>
<span class="line-removed">10709 </span>
<span class="line-removed">10710 instruct div2RoundL(iRegLNoSp dst, iRegL src, immI_63 div1, immI_63 div2) %{</span>
<span class="line-removed">10711   match(Set dst (AddL src (URShiftL (RShiftL src div1) div2)));</span>
<span class="line-removed">10712   ins_cost(INSN_COST);</span>
<span class="line-removed">10713   format %{ &quot;add $dst, $src, $div1&quot; %}</span>
<span class="line-removed">10714 </span>
<span class="line-removed">10715   ins_encode %{</span>
<span class="line-removed">10716     __ add(as_Register($dst$$reg),</span>
<span class="line-removed">10717               as_Register($src$$reg),</span>
<span class="line-removed">10718               as_Register($src$$reg),</span>
<span class="line-removed">10719               Assembler::LSR, 63);</span>
<span class="line-removed">10720   %}</span>
<span class="line-removed">10721   ins_pipe(ialu_reg);</span>
<span class="line-removed">10722 %}</span>
<span class="line-removed">10723 </span>
10724 // Integer Remainder
10725 
10726 instruct modI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{
10727   match(Set dst (ModI src1 src2));
10728 
10729   ins_cost(INSN_COST * 22);
10730   format %{ &quot;sdivw  rscratch1, $src1, $src2\n\t&quot;
10731             &quot;msubw($dst, rscratch1, $src2, $src1&quot; %}
10732 
10733   ins_encode(aarch64_enc_modw(dst, src1, src2));
10734   ins_pipe(idiv_reg_reg);
10735 %}
10736 
10737 // Long Remainder
10738 
10739 instruct modL(iRegLNoSp dst, iRegL src1, iRegL src2) %{
10740   match(Set dst (ModL src1 src2));
10741 
10742   ins_cost(INSN_COST * 38);
10743   format %{ &quot;sdiv   rscratch1, $src1, $src2\n&quot;
</pre>
<hr />
<pre>
15386 // epilog node loads ret address into lr as part of frame pop
15387 instruct Ret()
15388 %{
15389   match(Return);
15390 
15391   format %{ &quot;ret\t// return register&quot; %}
15392 
15393   ins_encode( aarch64_enc_ret() );
15394 
15395   ins_pipe(pipe_branch);
15396 %}
15397 
15398 // Die now.
15399 instruct ShouldNotReachHere() %{
15400   match(Halt);
15401 
15402   ins_cost(CALL_COST);
15403   format %{ &quot;ShouldNotReachHere&quot; %}
15404 
15405   ins_encode %{
<span class="line-modified">15406     // +1 so NativeInstruction::is_sigill_zombie_not_entrant() doesn&#39;t</span>
<span class="line-modified">15407     // return true</span>
<span class="line-modified">15408     __ dpcs1(0xdead + 1);</span>
15409   %}
15410 
15411   ins_pipe(pipe_class_default);
15412 %}
15413 
15414 // ============================================================================
15415 // Partial Subtype Check
15416 //
15417 // superklass array for an instance of the superklass.  Set a hidden
15418 // internal cache on a hit (cache is checked with exposed code in
15419 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
15420 // encoding ALSO sets flags.
15421 
15422 instruct partialSubtypeCheck(iRegP_R4 sub, iRegP_R0 super, iRegP_R2 temp, iRegP_R5 result, rFlagsReg cr)
15423 %{
15424   match(Set result (PartialSubtypeCheck sub super));
15425   effect(KILL cr, KILL temp);
15426 
15427   ins_cost(1100);  // slightly larger than the next version
15428   format %{ &quot;partialSubtypeCheck $result, $sub, $super&quot; %}
</pre>
</td>
<td>
<hr />
<pre>
10644 
10645   ins_encode %{
10646     __ mulw(rscratch1, as_Register($src1$$reg), as_Register($src2$$reg));
10647     __ maddw(as_Register($dst$$reg), as_Register($src3$$reg), as_Register($src4$$reg), rscratch1); %}
10648 
10649   ins_pipe(imac_reg_reg);
10650 %}
10651 
10652 // Integer Divide
10653 
10654 instruct divI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{
10655   match(Set dst (DivI src1 src2));
10656 
10657   ins_cost(INSN_COST * 19);
10658   format %{ &quot;sdivw  $dst, $src1, $src2&quot; %}
10659 
10660   ins_encode(aarch64_enc_divw(dst, src1, src2));
10661   ins_pipe(idiv_reg_reg);
10662 %}
10663 
























10664 // Long Divide
10665 
10666 instruct divL(iRegLNoSp dst, iRegL src1, iRegL src2) %{
10667   match(Set dst (DivL src1 src2));
10668 
10669   ins_cost(INSN_COST * 35);
10670   format %{ &quot;sdiv   $dst, $src1, $src2&quot; %}
10671 
10672   ins_encode(aarch64_enc_div(dst, src1, src2));
10673   ins_pipe(ldiv_reg_reg);
10674 %}
10675 
























10676 // Integer Remainder
10677 
10678 instruct modI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{
10679   match(Set dst (ModI src1 src2));
10680 
10681   ins_cost(INSN_COST * 22);
10682   format %{ &quot;sdivw  rscratch1, $src1, $src2\n\t&quot;
10683             &quot;msubw($dst, rscratch1, $src2, $src1&quot; %}
10684 
10685   ins_encode(aarch64_enc_modw(dst, src1, src2));
10686   ins_pipe(idiv_reg_reg);
10687 %}
10688 
10689 // Long Remainder
10690 
10691 instruct modL(iRegLNoSp dst, iRegL src1, iRegL src2) %{
10692   match(Set dst (ModL src1 src2));
10693 
10694   ins_cost(INSN_COST * 38);
10695   format %{ &quot;sdiv   rscratch1, $src1, $src2\n&quot;
</pre>
<hr />
<pre>
15338 // epilog node loads ret address into lr as part of frame pop
15339 instruct Ret()
15340 %{
15341   match(Return);
15342 
15343   format %{ &quot;ret\t// return register&quot; %}
15344 
15345   ins_encode( aarch64_enc_ret() );
15346 
15347   ins_pipe(pipe_branch);
15348 %}
15349 
15350 // Die now.
15351 instruct ShouldNotReachHere() %{
15352   match(Halt);
15353 
15354   ins_cost(CALL_COST);
15355   format %{ &quot;ShouldNotReachHere&quot; %}
15356 
15357   ins_encode %{
<span class="line-modified">15358     if (is_reachable()) {</span>
<span class="line-modified">15359       __ dpcs1(0xdead + 1);</span>
<span class="line-modified">15360     }</span>
15361   %}
15362 
15363   ins_pipe(pipe_class_default);
15364 %}
15365 
15366 // ============================================================================
15367 // Partial Subtype Check
15368 //
15369 // superklass array for an instance of the superklass.  Set a hidden
15370 // internal cache on a hit (cache is checked with exposed code in
15371 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
15372 // encoding ALSO sets flags.
15373 
15374 instruct partialSubtypeCheck(iRegP_R4 sub, iRegP_R0 super, iRegP_R2 temp, iRegP_R5 result, rFlagsReg cr)
15375 %{
15376   match(Set result (PartialSubtypeCheck sub super));
15377   effect(KILL cr, KILL temp);
15378 
15379   ins_cost(1100);  // slightly larger than the next version
15380   format %{ &quot;partialSubtypeCheck $result, $sub, $super&quot; %}
</pre>
</td>
</tr>
</table>
<center><a href="../../../../.hgtags.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../x86/c1_LIRAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/accessDecorators.hpp&quot;
  37 #include &quot;oops/compressedOops.inline.hpp&quot;
  38 #include &quot;oops/klass.inline.hpp&quot;
  39 #include &quot;prims/methodHandles.hpp&quot;
  40 #include &quot;runtime/biasedLocking.hpp&quot;
  41 #include &quot;runtime/flags/flagSetting.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/signature_cc.hpp&quot;
  49 #include &quot;runtime/stubRoutines.hpp&quot;
  50 #include &quot;runtime/thread.hpp&quot;
  51 #include &quot;utilities/macros.hpp&quot;
  52 #include &quot;vmreg_x86.inline.hpp&quot;
  53 #include &quot;crc32c.h&quot;
  54 #ifdef COMPILER2
  55 #include &quot;opto/output.hpp&quot;
  56 #endif
  57 
  58 #ifdef PRODUCT
  59 #define BLOCK_COMMENT(str) /* nothing */
  60 #define STOP(error) stop(error)
  61 #else
  62 #define BLOCK_COMMENT(str) block_comment(str)
  63 #define STOP(error) block_comment(error); stop(error)
  64 #endif
  65 
  66 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  67 
  68 #ifdef ASSERT
  69 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
  70 #endif
  71 
  72 static Assembler::Condition reverse[] = {
  73     Assembler::noOverflow     /* overflow      = 0x0 */ ,
  74     Assembler::overflow       /* noOverflow    = 0x1 */ ,
  75     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
  76     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
  77     Assembler::notZero        /* zero          = 0x4, equal         = 0x4 */ ,
  78     Assembler::zero           /* notZero       = 0x5, notEqual      = 0x5 */ ,
  79     Assembler::above          /* belowEqual    = 0x6 */ ,
  80     Assembler::belowEqual     /* above         = 0x7 */ ,
  81     Assembler::positive       /* negative      = 0x8 */ ,
  82     Assembler::negative       /* positive      = 0x9 */ ,
  83     Assembler::noParity       /* parity        = 0xa */ ,
  84     Assembler::parity         /* noParity      = 0xb */ ,
  85     Assembler::greaterEqual   /* less          = 0xc */ ,
  86     Assembler::less           /* greaterEqual  = 0xd */ ,
  87     Assembler::greater        /* lessEqual     = 0xe */ ,
  88     Assembler::lessEqual      /* greater       = 0xf, */
  89 
  90 };
  91 
  92 
  93 // Implementation of MacroAssembler
  94 
  95 // First all the versions that have distinct versions depending on 32/64 bit
  96 // Unless the difference is trivial (1 line or so).
  97 
  98 #ifndef _LP64
  99 
 100 // 32bit versions
 101 
 102 Address MacroAssembler::as_Address(AddressLiteral adr) {
 103   return Address(adr.target(), adr.rspec());
 104 }
 105 
 106 Address MacroAssembler::as_Address(ArrayAddress adr) {
 107   return Address::make_array(adr);
 108 }
 109 
 110 void MacroAssembler::call_VM_leaf_base(address entry_point,
 111                                        int number_of_arguments) {
 112   call(RuntimeAddress(entry_point));
 113   increment(rsp, number_of_arguments * wordSize);
 114 }
 115 
 116 void MacroAssembler::cmpklass(Address src1, Metadata* obj) {
 117   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 118 }
 119 
 120 void MacroAssembler::cmpklass(Register src1, Metadata* obj) {
 121   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 122 }
 123 
 124 void MacroAssembler::cmpoop_raw(Address src1, jobject obj) {
 125   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 126 }
 127 
 128 void MacroAssembler::cmpoop_raw(Register src1, jobject obj) {
 129   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 130 }
 131 
 132 void MacroAssembler::cmpoop(Address src1, jobject obj) {
 133   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 134   bs-&gt;obj_equals(this, src1, obj);
 135 }
 136 
 137 void MacroAssembler::cmpoop(Register src1, jobject obj) {
 138   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 139   bs-&gt;obj_equals(this, src1, obj);
 140 }
 141 
 142 void MacroAssembler::extend_sign(Register hi, Register lo) {
 143   // According to Intel Doc. AP-526, &quot;Integer Divide&quot;, p.18.
 144   if (VM_Version::is_P6() &amp;&amp; hi == rdx &amp;&amp; lo == rax) {
 145     cdql();
 146   } else {
 147     movl(hi, lo);
 148     sarl(hi, 31);
 149   }
 150 }
 151 
 152 void MacroAssembler::jC2(Register tmp, Label&amp; L) {
 153   // set parity bit if FPU flag C2 is set (via rax)
 154   save_rax(tmp);
 155   fwait(); fnstsw_ax();
 156   sahf();
 157   restore_rax(tmp);
 158   // branch
 159   jcc(Assembler::parity, L);
 160 }
 161 
 162 void MacroAssembler::jnC2(Register tmp, Label&amp; L) {
 163   // set parity bit if FPU flag C2 is set (via rax)
 164   save_rax(tmp);
 165   fwait(); fnstsw_ax();
 166   sahf();
 167   restore_rax(tmp);
 168   // branch
 169   jcc(Assembler::noParity, L);
 170 }
 171 
 172 // 32bit can do a case table jump in one instruction but we no longer allow the base
 173 // to be installed in the Address class
 174 void MacroAssembler::jump(ArrayAddress entry) {
 175   jmp(as_Address(entry));
 176 }
 177 
 178 // Note: y_lo will be destroyed
 179 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 180   // Long compare for Java (semantics as described in JVM spec.)
 181   Label high, low, done;
 182 
 183   cmpl(x_hi, y_hi);
 184   jcc(Assembler::less, low);
 185   jcc(Assembler::greater, high);
 186   // x_hi is the return register
 187   xorl(x_hi, x_hi);
 188   cmpl(x_lo, y_lo);
 189   jcc(Assembler::below, low);
 190   jcc(Assembler::equal, done);
 191 
 192   bind(high);
 193   xorl(x_hi, x_hi);
 194   increment(x_hi);
 195   jmp(done);
 196 
 197   bind(low);
 198   xorl(x_hi, x_hi);
 199   decrementl(x_hi);
 200 
 201   bind(done);
 202 }
 203 
 204 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 205     mov_literal32(dst, (int32_t)src.target(), src.rspec());
 206 }
 207 
 208 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 209   // leal(dst, as_Address(adr));
 210   // see note in movl as to why we must use a move
 211   mov_literal32(dst, (int32_t) adr.target(), adr.rspec());
 212 }
 213 
 214 void MacroAssembler::leave() {
 215   mov(rsp, rbp);
 216   pop(rbp);
 217 }
 218 
 219 void MacroAssembler::lmul(int x_rsp_offset, int y_rsp_offset) {
 220   // Multiplication of two Java long values stored on the stack
 221   // as illustrated below. Result is in rdx:rax.
 222   //
 223   // rsp ---&gt; [  ??  ] \               \
 224   //            ....    | y_rsp_offset  |
 225   //          [ y_lo ] /  (in bytes)    | x_rsp_offset
 226   //          [ y_hi ]                  | (in bytes)
 227   //            ....                    |
 228   //          [ x_lo ]                 /
 229   //          [ x_hi ]
 230   //            ....
 231   //
 232   // Basic idea: lo(result) = lo(x_lo * y_lo)
 233   //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 234   Address x_hi(rsp, x_rsp_offset + wordSize); Address x_lo(rsp, x_rsp_offset);
 235   Address y_hi(rsp, y_rsp_offset + wordSize); Address y_lo(rsp, y_rsp_offset);
 236   Label quick;
 237   // load x_hi, y_hi and check if quick
 238   // multiplication is possible
 239   movl(rbx, x_hi);
 240   movl(rcx, y_hi);
 241   movl(rax, rbx);
 242   orl(rbx, rcx);                                 // rbx, = 0 &lt;=&gt; x_hi = 0 and y_hi = 0
 243   jcc(Assembler::zero, quick);                   // if rbx, = 0 do quick multiply
 244   // do full multiplication
 245   // 1st step
 246   mull(y_lo);                                    // x_hi * y_lo
 247   movl(rbx, rax);                                // save lo(x_hi * y_lo) in rbx,
 248   // 2nd step
 249   movl(rax, x_lo);
 250   mull(rcx);                                     // x_lo * y_hi
 251   addl(rbx, rax);                                // add lo(x_lo * y_hi) to rbx,
 252   // 3rd step
 253   bind(quick);                                   // note: rbx, = 0 if quick multiply!
 254   movl(rax, x_lo);
 255   mull(y_lo);                                    // x_lo * y_lo
 256   addl(rdx, rbx);                                // correct hi(x_lo * y_lo)
 257 }
 258 
 259 void MacroAssembler::lneg(Register hi, Register lo) {
 260   negl(lo);
 261   adcl(hi, 0);
 262   negl(hi);
 263 }
 264 
 265 void MacroAssembler::lshl(Register hi, Register lo) {
 266   // Java shift left long support (semantics as described in JVM spec., p.305)
 267   // (basic idea for shift counts s &gt;= n: x &lt;&lt; s == (x &lt;&lt; n) &lt;&lt; (s - n))
 268   // shift value is in rcx !
 269   assert(hi != rcx, &quot;must not use rcx&quot;);
 270   assert(lo != rcx, &quot;must not use rcx&quot;);
 271   const Register s = rcx;                        // shift count
 272   const int      n = BitsPerWord;
 273   Label L;
 274   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 275   cmpl(s, n);                                    // if (s &lt; n)
 276   jcc(Assembler::less, L);                       // else (s &gt;= n)
 277   movl(hi, lo);                                  // x := x &lt;&lt; n
 278   xorl(lo, lo);
 279   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 280   bind(L);                                       // s (mod n) &lt; n
 281   shldl(hi, lo);                                 // x := x &lt;&lt; s
 282   shll(lo);
 283 }
 284 
 285 
 286 void MacroAssembler::lshr(Register hi, Register lo, bool sign_extension) {
 287   // Java shift right long support (semantics as described in JVM spec., p.306 &amp; p.310)
 288   // (basic idea for shift counts s &gt;= n: x &gt;&gt; s == (x &gt;&gt; n) &gt;&gt; (s - n))
 289   assert(hi != rcx, &quot;must not use rcx&quot;);
 290   assert(lo != rcx, &quot;must not use rcx&quot;);
 291   const Register s = rcx;                        // shift count
 292   const int      n = BitsPerWord;
 293   Label L;
 294   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 295   cmpl(s, n);                                    // if (s &lt; n)
 296   jcc(Assembler::less, L);                       // else (s &gt;= n)
 297   movl(lo, hi);                                  // x := x &gt;&gt; n
 298   if (sign_extension) sarl(hi, 31);
 299   else                xorl(hi, hi);
 300   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 301   bind(L);                                       // s (mod n) &lt; n
 302   shrdl(lo, hi);                                 // x := x &gt;&gt; s
 303   if (sign_extension) sarl(hi);
 304   else                shrl(hi);
 305 }
 306 
 307 void MacroAssembler::movoop(Register dst, jobject obj) {
 308   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 309 }
 310 
 311 void MacroAssembler::movoop(Address dst, jobject obj) {
 312   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 313 }
 314 
 315 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 316   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 317 }
 318 
 319 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 320   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 321 }
 322 
 323 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 324   // scratch register is not used,
 325   // it is defined to match parameters of 64-bit version of this method.
 326   if (src.is_lval()) {
 327     mov_literal32(dst, (intptr_t)src.target(), src.rspec());
 328   } else {
 329     movl(dst, as_Address(src));
 330   }
 331 }
 332 
 333 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 334   movl(as_Address(dst), src);
 335 }
 336 
 337 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 338   movl(dst, as_Address(src));
 339 }
 340 
 341 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 342 void MacroAssembler::movptr(Address dst, intptr_t src) {
 343   movl(dst, src);
 344 }
 345 
 346 
 347 void MacroAssembler::pop_callee_saved_registers() {
 348   pop(rcx);
 349   pop(rdx);
 350   pop(rdi);
 351   pop(rsi);
 352 }
 353 
 354 void MacroAssembler::push_callee_saved_registers() {
 355   push(rsi);
 356   push(rdi);
 357   push(rdx);
 358   push(rcx);
 359 }
 360 
 361 void MacroAssembler::pushoop(jobject obj) {
 362   push_literal32((int32_t)obj, oop_Relocation::spec_for_immediate());
 363 }
 364 
 365 void MacroAssembler::pushklass(Metadata* obj) {
 366   push_literal32((int32_t)obj, metadata_Relocation::spec_for_immediate());
 367 }
 368 
 369 void MacroAssembler::pushptr(AddressLiteral src) {
 370   if (src.is_lval()) {
 371     push_literal32((int32_t)src.target(), src.rspec());
 372   } else {
 373     pushl(as_Address(src));
 374   }
 375 }
 376 
 377 void MacroAssembler::set_word_if_not_zero(Register dst) {
 378   xorl(dst, dst);
 379   set_byte_if_not_zero(dst);
 380 }
 381 
 382 static void pass_arg0(MacroAssembler* masm, Register arg) {
 383   masm-&gt;push(arg);
 384 }
 385 
 386 static void pass_arg1(MacroAssembler* masm, Register arg) {
 387   masm-&gt;push(arg);
 388 }
 389 
 390 static void pass_arg2(MacroAssembler* masm, Register arg) {
 391   masm-&gt;push(arg);
 392 }
 393 
 394 static void pass_arg3(MacroAssembler* masm, Register arg) {
 395   masm-&gt;push(arg);
 396 }
 397 
 398 #ifndef PRODUCT
 399 extern &quot;C&quot; void findpc(intptr_t x);
 400 #endif
 401 
 402 void MacroAssembler::debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg) {
 403   // In order to get locks to work, we need to fake a in_VM state
 404   JavaThread* thread = JavaThread::current();
 405   JavaThreadState saved_state = thread-&gt;thread_state();
 406   thread-&gt;set_thread_state(_thread_in_vm);
 407   if (ShowMessageBoxOnError) {
 408     JavaThread* thread = JavaThread::current();
 409     JavaThreadState saved_state = thread-&gt;thread_state();
 410     thread-&gt;set_thread_state(_thread_in_vm);
 411     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 412       ttyLocker ttyl;
 413       BytecodeCounter::print();
 414     }
 415     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 416     // This is the value of eip which points to where verify_oop will return.
 417     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 418       print_state32(rdi, rsi, rbp, rsp, rbx, rdx, rcx, rax, eip);
 419       BREAKPOINT;
 420     }
 421   }
 422   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 423 }
 424 
 425 void MacroAssembler::print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip) {
 426   ttyLocker ttyl;
 427   FlagSetting fs(Debugging, true);
 428   tty-&gt;print_cr(&quot;eip = 0x%08x&quot;, eip);
 429 #ifndef PRODUCT
 430   if ((WizardMode || Verbose) &amp;&amp; PrintMiscellaneous) {
 431     tty-&gt;cr();
 432     findpc(eip);
 433     tty-&gt;cr();
 434   }
 435 #endif
 436 #define PRINT_REG(rax) \
 437   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, rax); }
 438   PRINT_REG(rax);
 439   PRINT_REG(rbx);
 440   PRINT_REG(rcx);
 441   PRINT_REG(rdx);
 442   PRINT_REG(rdi);
 443   PRINT_REG(rsi);
 444   PRINT_REG(rbp);
 445   PRINT_REG(rsp);
 446 #undef PRINT_REG
 447   // Print some words near top of staack.
 448   int* dump_sp = (int*) rsp;
 449   for (int col1 = 0; col1 &lt; 8; col1++) {
 450     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 451     os::print_location(tty, *dump_sp++);
 452   }
 453   for (int row = 0; row &lt; 16; row++) {
 454     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 455     for (int col = 0; col &lt; 8; col++) {
 456       tty-&gt;print(&quot; 0x%08x&quot;, *dump_sp++);
 457     }
 458     tty-&gt;cr();
 459   }
 460   // Print some instructions around pc:
 461   Disassembler::decode((address)eip-64, (address)eip);
 462   tty-&gt;print_cr(&quot;--------&quot;);
 463   Disassembler::decode((address)eip, (address)eip+32);
 464 }
 465 
 466 void MacroAssembler::stop(const char* msg) {
 467   ExternalAddress message((address)msg);
 468   // push address of message
 469   pushptr(message.addr());
 470   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 471   pusha();                                            // push registers
 472   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
 473   hlt();
 474 }
 475 
 476 void MacroAssembler::warn(const char* msg) {
 477   push_CPU_state();
 478 
 479   ExternalAddress message((address) msg);
 480   // push address of message
 481   pushptr(message.addr());
 482 
 483   call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));
 484   addl(rsp, wordSize);       // discard argument
 485   pop_CPU_state();
 486 }
 487 
 488 void MacroAssembler::print_state() {
 489   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 490   pusha();                                            // push registers
 491 
 492   push_CPU_state();
 493   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::print_state32)));
 494   pop_CPU_state();
 495 
 496   popa();
 497   addl(rsp, wordSize);
 498 }
 499 
 500 #else // _LP64
 501 
 502 // 64 bit versions
 503 
 504 Address MacroAssembler::as_Address(AddressLiteral adr) {
 505   // amd64 always does this as a pc-rel
 506   // we can be absolute or disp based on the instruction type
 507   // jmp/call are displacements others are absolute
 508   assert(!adr.is_lval(), &quot;must be rval&quot;);
 509   assert(reachable(adr), &quot;must be&quot;);
 510   return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());
 511 
 512 }
 513 
 514 Address MacroAssembler::as_Address(ArrayAddress adr) {
 515   AddressLiteral base = adr.base();
 516   lea(rscratch1, base);
 517   Address index = adr.index();
 518   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
 519   Address array(rscratch1, index._index, index._scale, index._disp);
 520   return array;
 521 }
 522 
 523 void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) {
 524   Label L, E;
 525 
 526 #ifdef _WIN64
 527   // Windows always allocates space for it&#39;s register args
 528   assert(num_args &lt;= 4, &quot;only register arguments supported&quot;);
 529   subq(rsp,  frame::arg_reg_save_area_bytes);
 530 #endif
 531 
 532   // Align stack if necessary
 533   testl(rsp, 15);
 534   jcc(Assembler::zero, L);
 535 
 536   subq(rsp, 8);
 537   {
 538     call(RuntimeAddress(entry_point));
 539   }
 540   addq(rsp, 8);
 541   jmp(E);
 542 
 543   bind(L);
 544   {
 545     call(RuntimeAddress(entry_point));
 546   }
 547 
 548   bind(E);
 549 
 550 #ifdef _WIN64
 551   // restore stack pointer
 552   addq(rsp, frame::arg_reg_save_area_bytes);
 553 #endif
 554 
 555 }
 556 
 557 void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {
 558   assert(!src2.is_lval(), &quot;should use cmpptr&quot;);
 559 
 560   if (reachable(src2)) {
 561     cmpq(src1, as_Address(src2));
 562   } else {
 563     lea(rscratch1, src2);
 564     Assembler::cmpq(src1, Address(rscratch1, 0));
 565   }
 566 }
 567 
 568 int MacroAssembler::corrected_idivq(Register reg) {
 569   // Full implementation of Java ldiv and lrem; checks for special
 570   // case as described in JVM spec., p.243 &amp; p.271.  The function
 571   // returns the (pc) offset of the idivl instruction - may be needed
 572   // for implicit exceptions.
 573   //
 574   //         normal case                           special case
 575   //
 576   // input : rax: dividend                         min_long
 577   //         reg: divisor   (may not be eax/edx)   -1
 578   //
 579   // output: rax: quotient  (= rax idiv reg)       min_long
 580   //         rdx: remainder (= rax irem reg)       0
 581   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax or rdx register&quot;);
 582   static const int64_t min_long = 0x8000000000000000;
 583   Label normal_case, special_case;
 584 
 585   // check for special case
 586   cmp64(rax, ExternalAddress((address) &amp;min_long));
 587   jcc(Assembler::notEqual, normal_case);
 588   xorl(rdx, rdx); // prepare rdx for possible special case (where
 589                   // remainder = 0)
 590   cmpq(reg, -1);
 591   jcc(Assembler::equal, special_case);
 592 
 593   // handle normal case
 594   bind(normal_case);
 595   cdqq();
 596   int idivq_offset = offset();
 597   idivq(reg);
 598 
 599   // normal and special case exit
 600   bind(special_case);
 601 
 602   return idivq_offset;
 603 }
 604 
 605 void MacroAssembler::decrementq(Register reg, int value) {
 606   if (value == min_jint) { subq(reg, value); return; }
 607   if (value &lt;  0) { incrementq(reg, -value); return; }
 608   if (value == 0) {                        ; return; }
 609   if (value == 1 &amp;&amp; UseIncDec) { decq(reg) ; return; }
 610   /* else */      { subq(reg, value)       ; return; }
 611 }
 612 
 613 void MacroAssembler::decrementq(Address dst, int value) {
 614   if (value == min_jint) { subq(dst, value); return; }
 615   if (value &lt;  0) { incrementq(dst, -value); return; }
 616   if (value == 0) {                        ; return; }
 617   if (value == 1 &amp;&amp; UseIncDec) { decq(dst) ; return; }
 618   /* else */      { subq(dst, value)       ; return; }
 619 }
 620 
 621 void MacroAssembler::incrementq(AddressLiteral dst) {
 622   if (reachable(dst)) {
 623     incrementq(as_Address(dst));
 624   } else {
 625     lea(rscratch1, dst);
 626     incrementq(Address(rscratch1, 0));
 627   }
 628 }
 629 
 630 void MacroAssembler::incrementq(Register reg, int value) {
 631   if (value == min_jint) { addq(reg, value); return; }
 632   if (value &lt;  0) { decrementq(reg, -value); return; }
 633   if (value == 0) {                        ; return; }
 634   if (value == 1 &amp;&amp; UseIncDec) { incq(reg) ; return; }
 635   /* else */      { addq(reg, value)       ; return; }
 636 }
 637 
 638 void MacroAssembler::incrementq(Address dst, int value) {
 639   if (value == min_jint) { addq(dst, value); return; }
 640   if (value &lt;  0) { decrementq(dst, -value); return; }
 641   if (value == 0) {                        ; return; }
 642   if (value == 1 &amp;&amp; UseIncDec) { incq(dst) ; return; }
 643   /* else */      { addq(dst, value)       ; return; }
 644 }
 645 
 646 // 32bit can do a case table jump in one instruction but we no longer allow the base
 647 // to be installed in the Address class
 648 void MacroAssembler::jump(ArrayAddress entry) {
 649   lea(rscratch1, entry.base());
 650   Address dispatch = entry.index();
 651   assert(dispatch._base == noreg, &quot;must be&quot;);
 652   dispatch._base = rscratch1;
 653   jmp(dispatch);
 654 }
 655 
 656 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 657   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 658   cmpq(x_lo, y_lo);
 659 }
 660 
 661 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 662     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 663 }
 664 
 665 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 666   mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());
 667   movptr(dst, rscratch1);
 668 }
 669 
 670 void MacroAssembler::leave() {
 671   // %%% is this really better? Why not on 32bit too?
 672   emit_int8((unsigned char)0xC9); // LEAVE
 673 }
 674 
 675 void MacroAssembler::lneg(Register hi, Register lo) {
 676   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 677   negq(lo);
 678 }
 679 
 680 void MacroAssembler::movoop(Register dst, jobject obj) {
 681   mov_literal64(dst, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 682 }
 683 
 684 void MacroAssembler::movoop(Address dst, jobject obj) {
 685   mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 686   movq(dst, rscratch1);
 687 }
 688 
 689 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 690   mov_literal64(dst, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 691 }
 692 
 693 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 694   mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 695   movq(dst, rscratch1);
 696 }
 697 
 698 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 699   if (src.is_lval()) {
 700     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 701   } else {
 702     if (reachable(src)) {
 703       movq(dst, as_Address(src));
 704     } else {
 705       lea(scratch, src);
 706       movq(dst, Address(scratch, 0));
 707     }
 708   }
 709 }
 710 
 711 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 712   movq(as_Address(dst), src);
 713 }
 714 
 715 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 716   movq(dst, as_Address(src));
 717 }
 718 
 719 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 720 void MacroAssembler::movptr(Address dst, intptr_t src) {
 721   mov64(rscratch1, src);
 722   movq(dst, rscratch1);
 723 }
 724 
 725 // These are mostly for initializing NULL
 726 void MacroAssembler::movptr(Address dst, int32_t src) {
 727   movslq(dst, src);
 728 }
 729 
 730 void MacroAssembler::movptr(Register dst, int32_t src) {
 731   mov64(dst, (intptr_t)src);
 732 }
 733 
 734 void MacroAssembler::pushoop(jobject obj) {
 735   movoop(rscratch1, obj);
 736   push(rscratch1);
 737 }
 738 
 739 void MacroAssembler::pushklass(Metadata* obj) {
 740   mov_metadata(rscratch1, obj);
 741   push(rscratch1);
 742 }
 743 
 744 void MacroAssembler::pushptr(AddressLiteral src) {
 745   lea(rscratch1, src);
 746   if (src.is_lval()) {
 747     push(rscratch1);
 748   } else {
 749     pushq(Address(rscratch1, 0));
 750   }
 751 }
 752 
 753 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 754   // we must set sp to zero to clear frame
 755   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
 756   // must clear fp, so that compiled frames are not confused; it is
 757   // possible that we need it only for debugging
 758   if (clear_fp) {
 759     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
 760   }
 761 
 762   // Always clear the pc because it could have been set by make_walkable()
 763   movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
 764   vzeroupper();
 765 }
 766 
 767 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 768                                          Register last_java_fp,
 769                                          address  last_java_pc) {
 770   vzeroupper();
 771   // determine last_java_sp register
 772   if (!last_java_sp-&gt;is_valid()) {
 773     last_java_sp = rsp;
 774   }
 775 
 776   // last_java_fp is optional
 777   if (last_java_fp-&gt;is_valid()) {
 778     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),
 779            last_java_fp);
 780   }
 781 
 782   // last_java_pc is optional
 783   if (last_java_pc != NULL) {
 784     Address java_pc(r15_thread,
 785                     JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 786     lea(rscratch1, InternalAddress(last_java_pc));
 787     movptr(java_pc, rscratch1);
 788   }
 789 
 790   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
 791 }
 792 
 793 static void pass_arg0(MacroAssembler* masm, Register arg) {
 794   if (c_rarg0 != arg ) {
 795     masm-&gt;mov(c_rarg0, arg);
 796   }
 797 }
 798 
 799 static void pass_arg1(MacroAssembler* masm, Register arg) {
 800   if (c_rarg1 != arg ) {
 801     masm-&gt;mov(c_rarg1, arg);
 802   }
 803 }
 804 
 805 static void pass_arg2(MacroAssembler* masm, Register arg) {
 806   if (c_rarg2 != arg ) {
 807     masm-&gt;mov(c_rarg2, arg);
 808   }
 809 }
 810 
 811 static void pass_arg3(MacroAssembler* masm, Register arg) {
 812   if (c_rarg3 != arg ) {
 813     masm-&gt;mov(c_rarg3, arg);
 814   }
 815 }
 816 
 817 void MacroAssembler::stop(const char* msg) {
 818   if (ShowMessageBoxOnError) {
 819     address rip = pc();
 820     pusha(); // get regs on stack
 821     lea(c_rarg1, InternalAddress(rip));
 822     movq(c_rarg2, rsp); // pass pointer to regs array
 823   }
 824   lea(c_rarg0, ExternalAddress((address) msg));
 825   andq(rsp, -16); // align stack as required by ABI
 826   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
 827   hlt();
 828 }
 829 
 830 void MacroAssembler::warn(const char* msg) {
 831   push(rbp);
 832   movq(rbp, rsp);
 833   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 834   push_CPU_state();   // keeps alignment at 16 bytes
 835   lea(c_rarg0, ExternalAddress((address) msg));
 836   lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));
 837   call(rax);
 838   pop_CPU_state();
 839   mov(rsp, rbp);
 840   pop(rbp);
 841 }
 842 
 843 void MacroAssembler::print_state() {
 844   address rip = pc();
 845   pusha();            // get regs on stack
 846   push(rbp);
 847   movq(rbp, rsp);
 848   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 849   push_CPU_state();   // keeps alignment at 16 bytes
 850 
 851   lea(c_rarg0, InternalAddress(rip));
 852   lea(c_rarg1, Address(rbp, wordSize)); // pass pointer to regs array
 853   call_VM_leaf(CAST_FROM_FN_PTR(address, MacroAssembler::print_state64), c_rarg0, c_rarg1);
 854 
 855   pop_CPU_state();
 856   mov(rsp, rbp);
 857   pop(rbp);
 858   popa();
 859 }
 860 
 861 #ifndef PRODUCT
 862 extern &quot;C&quot; void findpc(intptr_t x);
 863 #endif
 864 
 865 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[]) {
 866   // In order to get locks to work, we need to fake a in_VM state
 867   if (ShowMessageBoxOnError) {
 868     JavaThread* thread = JavaThread::current();
 869     JavaThreadState saved_state = thread-&gt;thread_state();
 870     thread-&gt;set_thread_state(_thread_in_vm);
 871 #ifndef PRODUCT
 872     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 873       ttyLocker ttyl;
 874       BytecodeCounter::print();
 875     }
 876 #endif
 877     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 878     // XXX correct this offset for amd64
 879     // This is the value of eip which points to where verify_oop will return.
 880     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 881       print_state64(pc, regs);
 882       BREAKPOINT;
 883     }
 884   }
 885   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 886 }
 887 
 888 void MacroAssembler::print_state64(int64_t pc, int64_t regs[]) {
 889   ttyLocker ttyl;
 890   FlagSetting fs(Debugging, true);
 891   tty-&gt;print_cr(&quot;rip = 0x%016lx&quot;, (intptr_t)pc);
 892 #ifndef PRODUCT
 893   tty-&gt;cr();
 894   findpc(pc);
 895   tty-&gt;cr();
 896 #endif
 897 #define PRINT_REG(rax, value) \
 898   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, value); }
 899   PRINT_REG(rax, regs[15]);
 900   PRINT_REG(rbx, regs[12]);
 901   PRINT_REG(rcx, regs[14]);
 902   PRINT_REG(rdx, regs[13]);
 903   PRINT_REG(rdi, regs[8]);
 904   PRINT_REG(rsi, regs[9]);
 905   PRINT_REG(rbp, regs[10]);
 906   PRINT_REG(rsp, regs[11]);
 907   PRINT_REG(r8 , regs[7]);
 908   PRINT_REG(r9 , regs[6]);
 909   PRINT_REG(r10, regs[5]);
 910   PRINT_REG(r11, regs[4]);
 911   PRINT_REG(r12, regs[3]);
 912   PRINT_REG(r13, regs[2]);
 913   PRINT_REG(r14, regs[1]);
 914   PRINT_REG(r15, regs[0]);
 915 #undef PRINT_REG
 916   // Print some words near top of staack.
 917   int64_t* rsp = (int64_t*) regs[11];
 918   int64_t* dump_sp = rsp;
 919   for (int col1 = 0; col1 &lt; 8; col1++) {
 920     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 921     os::print_location(tty, *dump_sp++);
 922   }
 923   for (int row = 0; row &lt; 25; row++) {
 924     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 925     for (int col = 0; col &lt; 4; col++) {
 926       tty-&gt;print(&quot; 0x%016lx&quot;, (intptr_t)*dump_sp++);
 927     }
 928     tty-&gt;cr();
 929   }
 930   // Print some instructions around pc:
 931   Disassembler::decode((address)pc-64, (address)pc);
 932   tty-&gt;print_cr(&quot;--------&quot;);
 933   Disassembler::decode((address)pc, (address)pc+32);
 934 }
 935 
 936 #endif // _LP64
 937 
 938 // Now versions that are common to 32/64 bit
 939 
 940 void MacroAssembler::addptr(Register dst, int32_t imm32) {
 941   LP64_ONLY(addq(dst, imm32)) NOT_LP64(addl(dst, imm32));
 942 }
 943 
 944 void MacroAssembler::addptr(Register dst, Register src) {
 945   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 946 }
 947 
 948 void MacroAssembler::addptr(Address dst, Register src) {
 949   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 950 }
 951 
 952 void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {
 953   if (reachable(src)) {
 954     Assembler::addsd(dst, as_Address(src));
 955   } else {
 956     lea(rscratch1, src);
 957     Assembler::addsd(dst, Address(rscratch1, 0));
 958   }
 959 }
 960 
 961 void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {
 962   if (reachable(src)) {
 963     addss(dst, as_Address(src));
 964   } else {
 965     lea(rscratch1, src);
 966     addss(dst, Address(rscratch1, 0));
 967   }
 968 }
 969 
 970 void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {
 971   if (reachable(src)) {
 972     Assembler::addpd(dst, as_Address(src));
 973   } else {
 974     lea(rscratch1, src);
 975     Assembler::addpd(dst, Address(rscratch1, 0));
 976   }
 977 }
 978 
 979 void MacroAssembler::align(int modulus) {
 980   align(modulus, offset());
 981 }
 982 
 983 void MacroAssembler::align(int modulus, int target) {
 984   if (target % modulus != 0) {
 985     nop(modulus - (target % modulus));
 986   }
 987 }
 988 
 989 void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 990   // Used in sign-masking with aligned address.
 991   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 992   if (reachable(src)) {
 993     Assembler::andpd(dst, as_Address(src));
 994   } else {
 995     lea(scratch_reg, src);
 996     Assembler::andpd(dst, Address(scratch_reg, 0));
 997   }
 998 }
 999 
1000 void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
1001   // Used in sign-masking with aligned address.
1002   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
1003   if (reachable(src)) {
1004     Assembler::andps(dst, as_Address(src));
1005   } else {
1006     lea(scratch_reg, src);
1007     Assembler::andps(dst, Address(scratch_reg, 0));
1008   }
1009 }
1010 
1011 void MacroAssembler::andptr(Register dst, int32_t imm32) {
1012   LP64_ONLY(andq(dst, imm32)) NOT_LP64(andl(dst, imm32));
1013 }
1014 
1015 void MacroAssembler::atomic_incl(Address counter_addr) {
1016   lock();
1017   incrementl(counter_addr);
1018 }
1019 
1020 void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {
1021   if (reachable(counter_addr)) {
1022     atomic_incl(as_Address(counter_addr));
1023   } else {
1024     lea(scr, counter_addr);
1025     atomic_incl(Address(scr, 0));
1026   }
1027 }
1028 
1029 #ifdef _LP64
1030 void MacroAssembler::atomic_incq(Address counter_addr) {
1031   lock();
1032   incrementq(counter_addr);
1033 }
1034 
1035 void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {
1036   if (reachable(counter_addr)) {
1037     atomic_incq(as_Address(counter_addr));
1038   } else {
1039     lea(scr, counter_addr);
1040     atomic_incq(Address(scr, 0));
1041   }
1042 }
1043 #endif
1044 
1045 // Writes to stack successive pages until offset reached to check for
1046 // stack overflow + shadow pages.  This clobbers tmp.
1047 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
1048   movptr(tmp, rsp);
1049   // Bang stack for total size given plus shadow page size.
1050   // Bang one page at a time because large size can bang beyond yellow and
1051   // red zones.
1052   Label loop;
1053   bind(loop);
1054   movl(Address(tmp, (-os::vm_page_size())), size );
1055   subptr(tmp, os::vm_page_size());
1056   subl(size, os::vm_page_size());
1057   jcc(Assembler::greater, loop);
1058 
1059   // Bang down shadow pages too.
1060   // At this point, (tmp-0) is the last address touched, so don&#39;t
1061   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
1062   // was post-decremented.)  Skip this address by starting at i=1, and
1063   // touch a few more pages below.  N.B.  It is important to touch all
1064   // the way down including all pages in the shadow zone.
1065   for (int i = 1; i &lt; ((int)JavaThread::stack_shadow_zone_size() / os::vm_page_size()); i++) {
1066     // this could be any sized move but this is can be a debugging crumb
1067     // so the bigger the better.
1068     movptr(Address(tmp, (-i*os::vm_page_size())), size );
1069   }
1070 }
1071 
1072 void MacroAssembler::reserved_stack_check() {
1073     // testing if reserved zone needs to be enabled
1074     Label no_reserved_zone_enabling;
1075     Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
1076     NOT_LP64(get_thread(rsi);)
1077 
1078     cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));
1079     jcc(Assembler::below, no_reserved_zone_enabling);
1080 
1081     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);
1082     jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
1083     should_not_reach_here();
1084 
1085     bind(no_reserved_zone_enabling);
1086 }
1087 
1088 int MacroAssembler::biased_locking_enter(Register lock_reg,
1089                                          Register obj_reg,
1090                                          Register swap_reg,
1091                                          Register tmp_reg,
<a name="1" id="anc1"></a><span class="line-added">1092                                          Register tmp_reg2,</span>
1093                                          bool swap_reg_contains_mark,
1094                                          Label&amp; done,
1095                                          Label* slow_case,
1096                                          BiasedLockingCounters* counters) {
1097   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1098   assert(swap_reg == rax, &quot;swap_reg must be rax for cmpxchgq&quot;);
1099   assert(tmp_reg != noreg, &quot;tmp_reg must be supplied&quot;);
1100   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);
1101   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
1102   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
1103   NOT_LP64( Address saved_mark_addr(lock_reg, 0); )
1104 
1105   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL) {
1106     counters = BiasedLocking::counters();
1107   }
1108   // Biased locking
1109   // See whether the lock is currently biased toward our thread and
1110   // whether the epoch is still valid
1111   // Note that the runtime guarantees sufficient alignment of JavaThread
1112   // pointers to allow age to be placed into low bits
1113   // First check to see whether biasing is even enabled for this object
1114   Label cas_label;
1115   int null_check_offset = -1;
1116   if (!swap_reg_contains_mark) {
1117     null_check_offset = offset();
1118     movptr(swap_reg, mark_addr);
1119   }
1120   movptr(tmp_reg, swap_reg);
1121   andptr(tmp_reg, markWord::biased_lock_mask_in_place);
1122   cmpptr(tmp_reg, markWord::biased_lock_pattern);
1123   jcc(Assembler::notEqual, cas_label);
1124   // The bias pattern is present in the object&#39;s header. Need to check
1125   // whether the bias owner and the epoch are both still current.
1126 #ifndef _LP64
1127   // Note that because there is no current thread register on x86_32 we
1128   // need to store off the mark word we read out of the object to
1129   // avoid reloading it and needing to recheck invariants below. This
1130   // store is unfortunate but it makes the overall code shorter and
1131   // simpler.
1132   movptr(saved_mark_addr, swap_reg);
1133 #endif
1134   if (swap_reg_contains_mark) {
1135     null_check_offset = offset();
1136   }
<a name="2" id="anc2"></a><span class="line-modified">1137   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);</span>
1138 #ifdef _LP64
1139   orptr(tmp_reg, r15_thread);
1140   xorptr(tmp_reg, swap_reg);
1141   Register header_reg = tmp_reg;
1142 #else
1143   xorptr(tmp_reg, swap_reg);
1144   get_thread(swap_reg);
1145   xorptr(swap_reg, tmp_reg);
1146   Register header_reg = swap_reg;
1147 #endif
1148   andptr(header_reg, ~((int) markWord::age_mask_in_place));
1149   if (counters != NULL) {
1150     cond_inc32(Assembler::zero,
1151                ExternalAddress((address) counters-&gt;biased_lock_entry_count_addr()));
1152   }
1153   jcc(Assembler::equal, done);
1154 
1155   Label try_revoke_bias;
1156   Label try_rebias;
1157 
1158   // At this point we know that the header has the bias pattern and
1159   // that we are not the bias owner in the current epoch. We need to
1160   // figure out more details about the state of the header in order to
1161   // know what operations can be legally performed on the object&#39;s
1162   // header.
1163 
1164   // If the low three bits in the xor result aren&#39;t clear, that means
1165   // the prototype header is no longer biased and we have to revoke
1166   // the bias on this object.
1167   testptr(header_reg, markWord::biased_lock_mask_in_place);
1168   jccb(Assembler::notZero, try_revoke_bias);
1169 
1170   // Biasing is still enabled for this data type. See whether the
1171   // epoch of the current bias is still valid, meaning that the epoch
1172   // bits of the mark word are equal to the epoch bits of the
1173   // prototype header. (Note that the prototype header&#39;s epoch bits
1174   // only change at a safepoint.) If not, attempt to rebias the object
1175   // toward the current thread. Note that we must be absolutely sure
1176   // that the current epoch is invalid in order to do this because
1177   // otherwise the manipulations it performs on the mark word are
1178   // illegal.
1179   testptr(header_reg, markWord::epoch_mask_in_place);
1180   jccb(Assembler::notZero, try_rebias);
1181 
1182   // The epoch of the current bias is still valid but we know nothing
1183   // about the owner; it might be set or it might be clear. Try to
1184   // acquire the bias of the object using an atomic operation. If this
1185   // fails we will go in to the runtime to revoke the object&#39;s bias.
1186   // Note that we first construct the presumed unbiased header so we
1187   // don&#39;t accidentally blow away another thread&#39;s valid bias.
1188   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1189   andptr(swap_reg,
1190          markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
1191 #ifdef _LP64
1192   movptr(tmp_reg, swap_reg);
1193   orptr(tmp_reg, r15_thread);
1194 #else
1195   get_thread(tmp_reg);
1196   orptr(tmp_reg, swap_reg);
1197 #endif
1198   lock();
1199   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1200   // If the biasing toward our thread failed, this means that
1201   // another thread succeeded in biasing it toward itself and we
1202   // need to revoke that bias. The revocation will occur in the
1203   // interpreter runtime in the slow case.
1204   if (counters != NULL) {
1205     cond_inc32(Assembler::zero,
1206                ExternalAddress((address) counters-&gt;anonymously_biased_lock_entry_count_addr()));
1207   }
1208   if (slow_case != NULL) {
1209     jcc(Assembler::notZero, *slow_case);
1210   }
1211   jmp(done);
1212 
1213   bind(try_rebias);
1214   // At this point we know the epoch has expired, meaning that the
1215   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
1216   // circumstances _only_, we are allowed to use the current header&#39;s
1217   // value as the comparison value when doing the cas to acquire the
1218   // bias in the current epoch. In other words, we allow transfer of
1219   // the bias from one thread to another directly in this situation.
1220   //
1221   // FIXME: due to a lack of registers we currently blow away the age
1222   // bits in this situation. Should attempt to preserve them.
<a name="3" id="anc3"></a><span class="line-modified">1223   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);</span>
1224 #ifdef _LP64
1225   orptr(tmp_reg, r15_thread);
1226 #else
1227   get_thread(swap_reg);
1228   orptr(tmp_reg, swap_reg);
1229   movptr(swap_reg, saved_mark_addr);
1230 #endif
1231   lock();
1232   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1233   // If the biasing toward our thread failed, then another thread
1234   // succeeded in biasing it toward itself and we need to revoke that
1235   // bias. The revocation will occur in the runtime in the slow case.
1236   if (counters != NULL) {
1237     cond_inc32(Assembler::zero,
1238                ExternalAddress((address) counters-&gt;rebiased_lock_entry_count_addr()));
1239   }
1240   if (slow_case != NULL) {
1241     jcc(Assembler::notZero, *slow_case);
1242   }
1243   jmp(done);
1244 
1245   bind(try_revoke_bias);
1246   // The prototype mark in the klass doesn&#39;t have the bias bit set any
1247   // more, indicating that objects of this data type are not supposed
1248   // to be biased any more. We are going to try to reset the mark of
1249   // this object to the prototype value and fall through to the
1250   // CAS-based locking scheme. Note that if our CAS fails, it means
1251   // that another thread raced us for the privilege of revoking the
1252   // bias of this particular object, so it&#39;s okay to continue in the
1253   // normal locking code.
1254   //
1255   // FIXME: due to a lack of registers we currently blow away the age
1256   // bits in this situation. Should attempt to preserve them.
1257   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
<a name="4" id="anc4"></a><span class="line-modified">1258   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);</span>
1259   lock();
1260   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1261   // Fall through to the normal CAS-based lock, because no matter what
1262   // the result of the above CAS, some thread must have succeeded in
1263   // removing the bias bit from the object&#39;s header.
1264   if (counters != NULL) {
1265     cond_inc32(Assembler::zero,
1266                ExternalAddress((address) counters-&gt;revoked_lock_entry_count_addr()));
1267   }
1268 
1269   bind(cas_label);
1270 
1271   return null_check_offset;
1272 }
1273 
1274 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
1275   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1276 
1277   // Check for biased locking unlock case, which is a no-op
1278   // Note: we do not have to check the thread ID for two reasons.
1279   // First, the interpreter checks for IllegalMonitorStateException at
1280   // a higher level. Second, if the bias was revoked while we held the
1281   // lock, the object could not be rebiased toward another thread, so
1282   // the bias bit would be clear.
1283   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1284   andptr(temp_reg, markWord::biased_lock_mask_in_place);
1285   cmpptr(temp_reg, markWord::biased_lock_pattern);
1286   jcc(Assembler::equal, done);
1287 }
1288 
1289 void MacroAssembler::c2bool(Register x) {
1290   // implements x == 0 ? 0 : 1
1291   // note: must only look at least-significant byte of x
1292   //       since C-style booleans are stored in one byte
1293   //       only! (was bug)
1294   andl(x, 0xFF);
1295   setb(Assembler::notZero, x);
1296 }
1297 
1298 // Wouldn&#39;t need if AddressLiteral version had new name
1299 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
1300   Assembler::call(L, rtype);
1301 }
1302 
1303 void MacroAssembler::call(Register entry) {
1304   Assembler::call(entry);
1305 }
1306 
1307 void MacroAssembler::call(AddressLiteral entry) {
1308   if (reachable(entry)) {
1309     Assembler::call_literal(entry.target(), entry.rspec());
1310   } else {
1311     lea(rscratch1, entry);
1312     Assembler::call(rscratch1);
1313   }
1314 }
1315 
1316 void MacroAssembler::ic_call(address entry, jint method_index) {
1317   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
1318   movptr(rax, (intptr_t)Universe::non_oop_word());
1319   call(AddressLiteral(entry, rh));
1320 }
1321 
1322 // Implementation of call_VM versions
1323 
1324 void MacroAssembler::call_VM(Register oop_result,
1325                              address entry_point,
1326                              bool check_exceptions) {
1327   Label C, E;
1328   call(C, relocInfo::none);
1329   jmp(E);
1330 
1331   bind(C);
1332   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
1333   ret(0);
1334 
1335   bind(E);
1336 }
1337 
1338 void MacroAssembler::call_VM(Register oop_result,
1339                              address entry_point,
1340                              Register arg_1,
1341                              bool check_exceptions) {
1342   Label C, E;
1343   call(C, relocInfo::none);
1344   jmp(E);
1345 
1346   bind(C);
1347   pass_arg1(this, arg_1);
1348   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
1349   ret(0);
1350 
1351   bind(E);
1352 }
1353 
1354 void MacroAssembler::call_VM(Register oop_result,
1355                              address entry_point,
1356                              Register arg_1,
1357                              Register arg_2,
1358                              bool check_exceptions) {
1359   Label C, E;
1360   call(C, relocInfo::none);
1361   jmp(E);
1362 
1363   bind(C);
1364 
1365   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1366 
1367   pass_arg2(this, arg_2);
1368   pass_arg1(this, arg_1);
1369   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
1370   ret(0);
1371 
1372   bind(E);
1373 }
1374 
1375 void MacroAssembler::call_VM(Register oop_result,
1376                              address entry_point,
1377                              Register arg_1,
1378                              Register arg_2,
1379                              Register arg_3,
1380                              bool check_exceptions) {
1381   Label C, E;
1382   call(C, relocInfo::none);
1383   jmp(E);
1384 
1385   bind(C);
1386 
1387   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1388   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1389   pass_arg3(this, arg_3);
1390 
1391   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1392   pass_arg2(this, arg_2);
1393 
1394   pass_arg1(this, arg_1);
1395   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
1396   ret(0);
1397 
1398   bind(E);
1399 }
1400 
1401 void MacroAssembler::call_VM(Register oop_result,
1402                              Register last_java_sp,
1403                              address entry_point,
1404                              int number_of_arguments,
1405                              bool check_exceptions) {
1406   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1407   call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1408 }
1409 
1410 void MacroAssembler::call_VM(Register oop_result,
1411                              Register last_java_sp,
1412                              address entry_point,
1413                              Register arg_1,
1414                              bool check_exceptions) {
1415   pass_arg1(this, arg_1);
1416   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1417 }
1418 
1419 void MacroAssembler::call_VM(Register oop_result,
1420                              Register last_java_sp,
1421                              address entry_point,
1422                              Register arg_1,
1423                              Register arg_2,
1424                              bool check_exceptions) {
1425 
1426   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1427   pass_arg2(this, arg_2);
1428   pass_arg1(this, arg_1);
1429   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1430 }
1431 
1432 void MacroAssembler::call_VM(Register oop_result,
1433                              Register last_java_sp,
1434                              address entry_point,
1435                              Register arg_1,
1436                              Register arg_2,
1437                              Register arg_3,
1438                              bool check_exceptions) {
1439   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1440   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1441   pass_arg3(this, arg_3);
1442   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1443   pass_arg2(this, arg_2);
1444   pass_arg1(this, arg_1);
1445   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1446 }
1447 
1448 void MacroAssembler::super_call_VM(Register oop_result,
1449                                    Register last_java_sp,
1450                                    address entry_point,
1451                                    int number_of_arguments,
1452                                    bool check_exceptions) {
1453   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1454   MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1455 }
1456 
1457 void MacroAssembler::super_call_VM(Register oop_result,
1458                                    Register last_java_sp,
1459                                    address entry_point,
1460                                    Register arg_1,
1461                                    bool check_exceptions) {
1462   pass_arg1(this, arg_1);
1463   super_call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1464 }
1465 
1466 void MacroAssembler::super_call_VM(Register oop_result,
1467                                    Register last_java_sp,
1468                                    address entry_point,
1469                                    Register arg_1,
1470                                    Register arg_2,
1471                                    bool check_exceptions) {
1472 
1473   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1474   pass_arg2(this, arg_2);
1475   pass_arg1(this, arg_1);
1476   super_call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1477 }
1478 
1479 void MacroAssembler::super_call_VM(Register oop_result,
1480                                    Register last_java_sp,
1481                                    address entry_point,
1482                                    Register arg_1,
1483                                    Register arg_2,
1484                                    Register arg_3,
1485                                    bool check_exceptions) {
1486   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1487   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1488   pass_arg3(this, arg_3);
1489   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1490   pass_arg2(this, arg_2);
1491   pass_arg1(this, arg_1);
1492   super_call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1493 }
1494 
1495 void MacroAssembler::call_VM_base(Register oop_result,
1496                                   Register java_thread,
1497                                   Register last_java_sp,
1498                                   address  entry_point,
1499                                   int      number_of_arguments,
1500                                   bool     check_exceptions) {
1501   // determine java_thread register
1502   if (!java_thread-&gt;is_valid()) {
1503 #ifdef _LP64
1504     java_thread = r15_thread;
1505 #else
1506     java_thread = rdi;
1507     get_thread(java_thread);
1508 #endif // LP64
1509   }
1510   // determine last_java_sp register
1511   if (!last_java_sp-&gt;is_valid()) {
1512     last_java_sp = rsp;
1513   }
1514   // debugging support
1515   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
1516   LP64_ONLY(assert(java_thread == r15_thread, &quot;unexpected register&quot;));
1517 #ifdef ASSERT
1518   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
1519   // r12 is the heapbase.
<a name="5" id="anc5"></a><span class="line-modified">1520   LP64_ONLY(if (UseCompressedOops &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);)</span>
1521 #endif // ASSERT
1522 
1523   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
1524   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
1525 
1526   // push java thread (becomes first argument of C function)
1527 
1528   NOT_LP64(push(java_thread); number_of_arguments++);
1529   LP64_ONLY(mov(c_rarg0, r15_thread));
1530 
1531   // set last Java frame before call
1532   assert(last_java_sp != rbp, &quot;can&#39;t use ebp/rbp&quot;);
1533 
1534   // Only interpreter should have to set fp
1535   set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);
1536 
1537   // do the call, remove parameters
1538   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments);
1539 
1540   // restore the thread (cannot use the pushed argument since arguments
1541   // may be overwritten by C code generated by an optimizing compiler);
1542   // however can use the register value directly if it is callee saved.
1543   if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {
1544     // rdi &amp; rsi (also r15) are callee saved -&gt; nothing to do
1545 #ifdef ASSERT
1546     guarantee(java_thread != rax, &quot;change this code&quot;);
1547     push(rax);
1548     { Label L;
1549       get_thread(rax);
1550       cmpptr(java_thread, rax);
1551       jcc(Assembler::equal, L);
1552       STOP(&quot;MacroAssembler::call_VM_base: rdi not callee saved?&quot;);
1553       bind(L);
1554     }
1555     pop(rax);
1556 #endif
1557   } else {
1558     get_thread(java_thread);
1559   }
1560   // reset last Java frame
1561   // Only interpreter should have to clear fp
1562   reset_last_Java_frame(java_thread, true);
1563 
1564    // C++ interp handles this in the interpreter
1565   check_and_handle_popframe(java_thread);
1566   check_and_handle_earlyret(java_thread);
1567 
1568   if (check_exceptions) {
1569     // check for pending exceptions (java_thread is set upon return)
1570     cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
1571 #ifndef _LP64
1572     jump_cc(Assembler::notEqual,
1573             RuntimeAddress(StubRoutines::forward_exception_entry()));
1574 #else
1575     // This used to conditionally jump to forward_exception however it is
1576     // possible if we relocate that the branch will not reach. So we must jump
1577     // around so we can always reach
1578 
1579     Label ok;
1580     jcc(Assembler::equal, ok);
1581     jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
1582     bind(ok);
1583 #endif // LP64
1584   }
1585 
1586   // get oop result if there is one and reset the value in the thread
1587   if (oop_result-&gt;is_valid()) {
1588     get_vm_result(oop_result, java_thread);
1589   }
1590 }
1591 
1592 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
1593 
1594   // Calculate the value for last_Java_sp
1595   // somewhat subtle. call_VM does an intermediate call
1596   // which places a return address on the stack just under the
1597   // stack pointer as the user finsihed with it. This allows
1598   // use to retrieve last_Java_pc from last_Java_sp[-1].
1599   // On 32bit we then have to push additional args on the stack to accomplish
1600   // the actual requested call. On 64bit call_VM only can use register args
1601   // so the only extra space is the return address that call_VM created.
1602   // This hopefully explains the calculations here.
1603 
1604 #ifdef _LP64
1605   // We&#39;ve pushed one address, correct last_Java_sp
1606   lea(rax, Address(rsp, wordSize));
1607 #else
1608   lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));
1609 #endif // LP64
1610 
1611   call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);
1612 
1613 }
1614 
1615 // Use this method when MacroAssembler version of call_VM_leaf_base() should be called from Interpreter.
1616 void MacroAssembler::call_VM_leaf0(address entry_point) {
1617   MacroAssembler::call_VM_leaf_base(entry_point, 0);
1618 }
1619 
1620 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1621   call_VM_leaf_base(entry_point, number_of_arguments);
1622 }
1623 
1624 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1625   pass_arg0(this, arg_0);
1626   call_VM_leaf(entry_point, 1);
1627 }
1628 
1629 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1630 
1631   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1632   pass_arg1(this, arg_1);
1633   pass_arg0(this, arg_0);
1634   call_VM_leaf(entry_point, 2);
1635 }
1636 
1637 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1638   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1639   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1640   pass_arg2(this, arg_2);
1641   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1642   pass_arg1(this, arg_1);
1643   pass_arg0(this, arg_0);
1644   call_VM_leaf(entry_point, 3);
1645 }
1646 
1647 void MacroAssembler::super_call_VM_leaf(address entry_point) {
1648   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1649 }
1650 
1651 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1652   pass_arg0(this, arg_0);
1653   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1654 }
1655 
1656 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1657 
1658   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1659   pass_arg1(this, arg_1);
1660   pass_arg0(this, arg_0);
1661   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1662 }
1663 
1664 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1665   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1666   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1667   pass_arg2(this, arg_2);
1668   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1669   pass_arg1(this, arg_1);
1670   pass_arg0(this, arg_0);
1671   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1672 }
1673 
1674 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1675   LP64_ONLY(assert(arg_0 != c_rarg3, &quot;smashed arg&quot;));
1676   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1677   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1678   pass_arg3(this, arg_3);
1679   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1680   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1681   pass_arg2(this, arg_2);
1682   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1683   pass_arg1(this, arg_1);
1684   pass_arg0(this, arg_0);
1685   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1686 }
1687 
1688 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
1689   movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
1690   movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);
1691   verify_oop_msg(oop_result, &quot;broken oop in call_VM_base&quot;);
1692 }
1693 
1694 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
1695   movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
1696   movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);
1697 }
1698 
1699 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
1700 }
1701 
1702 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
1703 }
1704 
1705 void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {
1706   if (reachable(src1)) {
1707     cmpl(as_Address(src1), imm);
1708   } else {
1709     lea(rscratch1, src1);
1710     cmpl(Address(rscratch1, 0), imm);
1711   }
1712 }
1713 
1714 void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {
1715   assert(!src2.is_lval(), &quot;use cmpptr&quot;);
1716   if (reachable(src2)) {
1717     cmpl(src1, as_Address(src2));
1718   } else {
1719     lea(rscratch1, src2);
1720     cmpl(src1, Address(rscratch1, 0));
1721   }
1722 }
1723 
1724 void MacroAssembler::cmp32(Register src1, int32_t imm) {
1725   Assembler::cmpl(src1, imm);
1726 }
1727 
1728 void MacroAssembler::cmp32(Register src1, Address src2) {
1729   Assembler::cmpl(src1, src2);
1730 }
1731 
1732 void MacroAssembler::cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1733   ucomisd(opr1, opr2);
1734 
1735   Label L;
1736   if (unordered_is_less) {
1737     movl(dst, -1);
1738     jcc(Assembler::parity, L);
1739     jcc(Assembler::below , L);
1740     movl(dst, 0);
1741     jcc(Assembler::equal , L);
1742     increment(dst);
1743   } else { // unordered is greater
1744     movl(dst, 1);
1745     jcc(Assembler::parity, L);
1746     jcc(Assembler::above , L);
1747     movl(dst, 0);
1748     jcc(Assembler::equal , L);
1749     decrementl(dst);
1750   }
1751   bind(L);
1752 }
1753 
1754 void MacroAssembler::cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1755   ucomiss(opr1, opr2);
1756 
1757   Label L;
1758   if (unordered_is_less) {
1759     movl(dst, -1);
1760     jcc(Assembler::parity, L);
1761     jcc(Assembler::below , L);
1762     movl(dst, 0);
1763     jcc(Assembler::equal , L);
1764     increment(dst);
1765   } else { // unordered is greater
1766     movl(dst, 1);
1767     jcc(Assembler::parity, L);
1768     jcc(Assembler::above , L);
1769     movl(dst, 0);
1770     jcc(Assembler::equal , L);
1771     decrementl(dst);
1772   }
1773   bind(L);
1774 }
1775 
1776 
1777 void MacroAssembler::cmp8(AddressLiteral src1, int imm) {
1778   if (reachable(src1)) {
1779     cmpb(as_Address(src1), imm);
1780   } else {
1781     lea(rscratch1, src1);
1782     cmpb(Address(rscratch1, 0), imm);
1783   }
1784 }
1785 
1786 void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {
1787 #ifdef _LP64
1788   if (src2.is_lval()) {
1789     movptr(rscratch1, src2);
1790     Assembler::cmpq(src1, rscratch1);
1791   } else if (reachable(src2)) {
1792     cmpq(src1, as_Address(src2));
1793   } else {
1794     lea(rscratch1, src2);
1795     Assembler::cmpq(src1, Address(rscratch1, 0));
1796   }
1797 #else
1798   if (src2.is_lval()) {
1799     cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1800   } else {
1801     cmpl(src1, as_Address(src2));
1802   }
1803 #endif // _LP64
1804 }
1805 
1806 void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {
1807   assert(src2.is_lval(), &quot;not a mem-mem compare&quot;);
1808 #ifdef _LP64
1809   // moves src2&#39;s literal address
1810   movptr(rscratch1, src2);
1811   Assembler::cmpq(src1, rscratch1);
1812 #else
1813   cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1814 #endif // _LP64
1815 }
1816 
1817 void MacroAssembler::cmpoop(Register src1, Register src2) {
1818   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1819   bs-&gt;obj_equals(this, src1, src2);
1820 }
1821 
1822 void MacroAssembler::cmpoop(Register src1, Address src2) {
1823   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1824   bs-&gt;obj_equals(this, src1, src2);
1825 }
1826 
1827 #ifdef _LP64
1828 void MacroAssembler::cmpoop(Register src1, jobject src2) {
1829   movoop(rscratch1, src2);
1830   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1831   bs-&gt;obj_equals(this, src1, rscratch1);
1832 }
1833 #endif
1834 
1835 void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {
1836   if (reachable(adr)) {
1837     lock();
1838     cmpxchgptr(reg, as_Address(adr));
1839   } else {
1840     lea(rscratch1, adr);
1841     lock();
1842     cmpxchgptr(reg, Address(rscratch1, 0));
1843   }
1844 }
1845 
1846 void MacroAssembler::cmpxchgptr(Register reg, Address adr) {
1847   LP64_ONLY(cmpxchgq(reg, adr)) NOT_LP64(cmpxchgl(reg, adr));
1848 }
1849 
1850 void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {
1851   if (reachable(src)) {
1852     Assembler::comisd(dst, as_Address(src));
1853   } else {
1854     lea(rscratch1, src);
1855     Assembler::comisd(dst, Address(rscratch1, 0));
1856   }
1857 }
1858 
1859 void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {
1860   if (reachable(src)) {
1861     Assembler::comiss(dst, as_Address(src));
1862   } else {
1863     lea(rscratch1, src);
1864     Assembler::comiss(dst, Address(rscratch1, 0));
1865   }
1866 }
1867 
1868 
1869 void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {
1870   Condition negated_cond = negate_condition(cond);
1871   Label L;
1872   jcc(negated_cond, L);
1873   pushf(); // Preserve flags
1874   atomic_incl(counter_addr);
1875   popf();
1876   bind(L);
1877 }
1878 
1879 int MacroAssembler::corrected_idivl(Register reg) {
1880   // Full implementation of Java idiv and irem; checks for
1881   // special case as described in JVM spec., p.243 &amp; p.271.
1882   // The function returns the (pc) offset of the idivl
1883   // instruction - may be needed for implicit exceptions.
1884   //
1885   //         normal case                           special case
1886   //
1887   // input : rax,: dividend                         min_int
1888   //         reg: divisor   (may not be rax,/rdx)   -1
1889   //
1890   // output: rax,: quotient  (= rax, idiv reg)       min_int
1891   //         rdx: remainder (= rax, irem reg)       0
1892   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax, or rdx register&quot;);
1893   const int min_int = 0x80000000;
1894   Label normal_case, special_case;
1895 
1896   // check for special case
1897   cmpl(rax, min_int);
1898   jcc(Assembler::notEqual, normal_case);
1899   xorl(rdx, rdx); // prepare rdx for possible special case (where remainder = 0)
1900   cmpl(reg, -1);
1901   jcc(Assembler::equal, special_case);
1902 
1903   // handle normal case
1904   bind(normal_case);
1905   cdql();
1906   int idivl_offset = offset();
1907   idivl(reg);
1908 
1909   // normal and special case exit
1910   bind(special_case);
1911 
1912   return idivl_offset;
1913 }
1914 
1915 
1916 
1917 void MacroAssembler::decrementl(Register reg, int value) {
1918   if (value == min_jint) {subl(reg, value) ; return; }
1919   if (value &lt;  0) { incrementl(reg, -value); return; }
1920   if (value == 0) {                        ; return; }
1921   if (value == 1 &amp;&amp; UseIncDec) { decl(reg) ; return; }
1922   /* else */      { subl(reg, value)       ; return; }
1923 }
1924 
1925 void MacroAssembler::decrementl(Address dst, int value) {
1926   if (value == min_jint) {subl(dst, value) ; return; }
1927   if (value &lt;  0) { incrementl(dst, -value); return; }
1928   if (value == 0) {                        ; return; }
1929   if (value == 1 &amp;&amp; UseIncDec) { decl(dst) ; return; }
1930   /* else */      { subl(dst, value)       ; return; }
1931 }
1932 
1933 void MacroAssembler::division_with_shift (Register reg, int shift_value) {
1934   assert (shift_value &gt; 0, &quot;illegal shift value&quot;);
1935   Label _is_positive;
1936   testl (reg, reg);
1937   jcc (Assembler::positive, _is_positive);
1938   int offset = (1 &lt;&lt; shift_value) - 1 ;
1939 
1940   if (offset == 1) {
1941     incrementl(reg);
1942   } else {
1943     addl(reg, offset);
1944   }
1945 
1946   bind (_is_positive);
1947   sarl(reg, shift_value);
1948 }
1949 
1950 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
1951   if (reachable(src)) {
1952     Assembler::divsd(dst, as_Address(src));
1953   } else {
1954     lea(rscratch1, src);
1955     Assembler::divsd(dst, Address(rscratch1, 0));
1956   }
1957 }
1958 
1959 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
1960   if (reachable(src)) {
1961     Assembler::divss(dst, as_Address(src));
1962   } else {
1963     lea(rscratch1, src);
1964     Assembler::divss(dst, Address(rscratch1, 0));
1965   }
1966 }
1967 
1968 void MacroAssembler::enter() {
1969   push(rbp);
1970   mov(rbp, rsp);
1971 }
1972 
1973 // A 5 byte nop that is safe for patching (see patch_verified_entry)
1974 void MacroAssembler::fat_nop() {
1975   if (UseAddressNop) {
1976     addr_nop_5();
1977   } else {
1978     emit_int8(0x26); // es:
1979     emit_int8(0x2e); // cs:
1980     emit_int8(0x64); // fs:
1981     emit_int8(0x65); // gs:
1982     emit_int8((unsigned char)0x90);
1983   }
1984 }
1985 
1986 #ifndef _LP64
1987 void MacroAssembler::fcmp(Register tmp) {
1988   fcmp(tmp, 1, true, true);
1989 }
1990 
1991 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
1992   assert(!pop_right || pop_left, &quot;usage error&quot;);
1993   if (VM_Version::supports_cmov()) {
1994     assert(tmp == noreg, &quot;unneeded temp&quot;);
1995     if (pop_left) {
1996       fucomip(index);
1997     } else {
1998       fucomi(index);
1999     }
2000     if (pop_right) {
2001       fpop();
2002     }
2003   } else {
2004     assert(tmp != noreg, &quot;need temp&quot;);
2005     if (pop_left) {
2006       if (pop_right) {
2007         fcompp();
2008       } else {
2009         fcomp(index);
2010       }
2011     } else {
2012       fcom(index);
2013     }
2014     // convert FPU condition into eflags condition via rax,
2015     save_rax(tmp);
2016     fwait(); fnstsw_ax();
2017     sahf();
2018     restore_rax(tmp);
2019   }
2020   // condition codes set as follows:
2021   //
2022   // CF (corresponds to C0) if x &lt; y
2023   // PF (corresponds to C2) if unordered
2024   // ZF (corresponds to C3) if x = y
2025 }
2026 
2027 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {
2028   fcmp2int(dst, unordered_is_less, 1, true, true);
2029 }
2030 
2031 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {
2032   fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);
2033   Label L;
2034   if (unordered_is_less) {
2035     movl(dst, -1);
2036     jcc(Assembler::parity, L);
2037     jcc(Assembler::below , L);
2038     movl(dst, 0);
2039     jcc(Assembler::equal , L);
2040     increment(dst);
2041   } else { // unordered is greater
2042     movl(dst, 1);
2043     jcc(Assembler::parity, L);
2044     jcc(Assembler::above , L);
2045     movl(dst, 0);
2046     jcc(Assembler::equal , L);
2047     decrementl(dst);
2048   }
2049   bind(L);
2050 }
2051 
2052 void MacroAssembler::fld_d(AddressLiteral src) {
2053   fld_d(as_Address(src));
2054 }
2055 
2056 void MacroAssembler::fld_s(AddressLiteral src) {
2057   fld_s(as_Address(src));
2058 }
2059 
2060 void MacroAssembler::fld_x(AddressLiteral src) {
2061   Assembler::fld_x(as_Address(src));
2062 }
2063 
2064 void MacroAssembler::fldcw(AddressLiteral src) {
2065   Assembler::fldcw(as_Address(src));
2066 }
2067 
2068 void MacroAssembler::fpop() {
2069   ffree();
2070   fincstp();
2071 }
2072 
2073 void MacroAssembler::fremr(Register tmp) {
2074   save_rax(tmp);
2075   { Label L;
2076     bind(L);
2077     fprem();
2078     fwait(); fnstsw_ax();
2079     sahf();
2080     jcc(Assembler::parity, L);
2081   }
2082   restore_rax(tmp);
2083   // Result is in ST0.
2084   // Note: fxch &amp; fpop to get rid of ST1
2085   // (otherwise FPU stack could overflow eventually)
2086   fxch(1);
2087   fpop();
2088 }
2089 
2090 void MacroAssembler::empty_FPU_stack() {
2091   if (VM_Version::supports_mmx()) {
2092     emms();
2093   } else {
2094     for (int i = 8; i-- &gt; 0; ) ffree(i);
2095   }
2096 }
2097 #endif // !LP64
2098 
2099 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
2100   if (reachable(src)) {
2101     Assembler::mulpd(dst, as_Address(src));
2102   } else {
2103     lea(rscratch1, src);
2104     Assembler::mulpd(dst, Address(rscratch1, 0));
2105   }
2106 }
2107 
2108 void MacroAssembler::load_float(Address src) {
2109 #ifdef _LP64
2110   movflt(xmm0, src);
2111 #else
2112   if (UseSSE &gt;= 1) {
2113     movflt(xmm0, src);
2114   } else {
2115     fld_s(src);
2116   }
2117 #endif // LP64
2118 }
2119 
2120 void MacroAssembler::store_float(Address dst) {
2121 #ifdef _LP64
2122   movflt(dst, xmm0);
2123 #else
2124   if (UseSSE &gt;= 1) {
2125     movflt(dst, xmm0);
2126   } else {
2127     fstp_s(dst);
2128   }
2129 #endif // LP64
2130 }
2131 
2132 void MacroAssembler::load_double(Address src) {
2133 #ifdef _LP64
2134   movdbl(xmm0, src);
2135 #else
2136   if (UseSSE &gt;= 2) {
2137     movdbl(xmm0, src);
2138   } else {
2139     fld_d(src);
2140   }
2141 #endif // LP64
2142 }
2143 
2144 void MacroAssembler::store_double(Address dst) {
2145 #ifdef _LP64
2146   movdbl(dst, xmm0);
2147 #else
2148   if (UseSSE &gt;= 2) {
2149     movdbl(dst, xmm0);
2150   } else {
2151     fstp_d(dst);
2152   }
2153 #endif // LP64
2154 }
2155 
2156 // dst = c = a * b + c
2157 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2158   Assembler::vfmadd231sd(c, a, b);
2159   if (dst != c) {
2160     movdbl(dst, c);
2161   }
2162 }
2163 
2164 // dst = c = a * b + c
2165 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2166   Assembler::vfmadd231ss(c, a, b);
2167   if (dst != c) {
2168     movflt(dst, c);
2169   }
2170 }
2171 
2172 // dst = c = a * b + c
2173 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2174   Assembler::vfmadd231pd(c, a, b, vector_len);
2175   if (dst != c) {
2176     vmovdqu(dst, c);
2177   }
2178 }
2179 
2180 // dst = c = a * b + c
2181 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2182   Assembler::vfmadd231ps(c, a, b, vector_len);
2183   if (dst != c) {
2184     vmovdqu(dst, c);
2185   }
2186 }
2187 
2188 // dst = c = a * b + c
2189 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2190   Assembler::vfmadd231pd(c, a, b, vector_len);
2191   if (dst != c) {
2192     vmovdqu(dst, c);
2193   }
2194 }
2195 
2196 // dst = c = a * b + c
2197 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2198   Assembler::vfmadd231ps(c, a, b, vector_len);
2199   if (dst != c) {
2200     vmovdqu(dst, c);
2201   }
2202 }
2203 
2204 void MacroAssembler::incrementl(AddressLiteral dst) {
2205   if (reachable(dst)) {
2206     incrementl(as_Address(dst));
2207   } else {
2208     lea(rscratch1, dst);
2209     incrementl(Address(rscratch1, 0));
2210   }
2211 }
2212 
2213 void MacroAssembler::incrementl(ArrayAddress dst) {
2214   incrementl(as_Address(dst));
2215 }
2216 
2217 void MacroAssembler::incrementl(Register reg, int value) {
2218   if (value == min_jint) {addl(reg, value) ; return; }
2219   if (value &lt;  0) { decrementl(reg, -value); return; }
2220   if (value == 0) {                        ; return; }
2221   if (value == 1 &amp;&amp; UseIncDec) { incl(reg) ; return; }
2222   /* else */      { addl(reg, value)       ; return; }
2223 }
2224 
2225 void MacroAssembler::incrementl(Address dst, int value) {
2226   if (value == min_jint) {addl(dst, value) ; return; }
2227   if (value &lt;  0) { decrementl(dst, -value); return; }
2228   if (value == 0) {                        ; return; }
2229   if (value == 1 &amp;&amp; UseIncDec) { incl(dst) ; return; }
2230   /* else */      { addl(dst, value)       ; return; }
2231 }
2232 
2233 void MacroAssembler::jump(AddressLiteral dst) {
2234   if (reachable(dst)) {
2235     jmp_literal(dst.target(), dst.rspec());
2236   } else {
2237     lea(rscratch1, dst);
2238     jmp(rscratch1);
2239   }
2240 }
2241 
2242 void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {
2243   if (reachable(dst)) {
2244     InstructionMark im(this);
2245     relocate(dst.reloc());
2246     const int short_size = 2;
2247     const int long_size = 6;
2248     int offs = (intptr_t)dst.target() - ((intptr_t)pc());
2249     if (dst.reloc() == relocInfo::none &amp;&amp; is8bit(offs - short_size)) {
2250       // 0111 tttn #8-bit disp
2251       emit_int8(0x70 | cc);
2252       emit_int8((offs - short_size) &amp; 0xFF);
2253     } else {
2254       // 0000 1111 1000 tttn #32-bit disp
2255       emit_int8(0x0F);
2256       emit_int8((unsigned char)(0x80 | cc));
2257       emit_int32(offs - long_size);
2258     }
2259   } else {
2260 #ifdef ASSERT
2261     warning(&quot;reversing conditional branch&quot;);
2262 #endif /* ASSERT */
2263     Label skip;
2264     jccb(reverse[cc], skip);
2265     lea(rscratch1, dst);
2266     Assembler::jmp(rscratch1);
2267     bind(skip);
2268   }
2269 }
2270 
2271 void MacroAssembler::ldmxcsr(AddressLiteral src) {
2272   if (reachable(src)) {
2273     Assembler::ldmxcsr(as_Address(src));
2274   } else {
2275     lea(rscratch1, src);
2276     Assembler::ldmxcsr(Address(rscratch1, 0));
2277   }
2278 }
2279 
2280 int MacroAssembler::load_signed_byte(Register dst, Address src) {
2281   int off;
2282   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2283     off = offset();
2284     movsbl(dst, src); // movsxb
2285   } else {
2286     off = load_unsigned_byte(dst, src);
2287     shll(dst, 24);
2288     sarl(dst, 24);
2289   }
2290   return off;
2291 }
2292 
2293 // Note: load_signed_short used to be called load_signed_word.
2294 // Although the &#39;w&#39; in x86 opcodes refers to the term &quot;word&quot; in the assembler
2295 // manual, which means 16 bits, that usage is found nowhere in HotSpot code.
2296 // The term &quot;word&quot; in HotSpot means a 32- or 64-bit machine word.
2297 int MacroAssembler::load_signed_short(Register dst, Address src) {
2298   int off;
2299   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2300     // This is dubious to me since it seems safe to do a signed 16 =&gt; 64 bit
2301     // version but this is what 64bit has always done. This seems to imply
2302     // that users are only using 32bits worth.
2303     off = offset();
2304     movswl(dst, src); // movsxw
2305   } else {
2306     off = load_unsigned_short(dst, src);
2307     shll(dst, 16);
2308     sarl(dst, 16);
2309   }
2310   return off;
2311 }
2312 
2313 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
2314   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2315   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2316   int off;
2317   if (LP64_ONLY(true || ) VM_Version::is_P6() || src.uses(dst)) {
2318     off = offset();
2319     movzbl(dst, src); // movzxb
2320   } else {
2321     xorl(dst, dst);
2322     off = offset();
2323     movb(dst, src);
2324   }
2325   return off;
2326 }
2327 
2328 // Note: load_unsigned_short used to be called load_unsigned_word.
2329 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
2330   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2331   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2332   int off;
2333   if (LP64_ONLY(true ||) VM_Version::is_P6() || src.uses(dst)) {
2334     off = offset();
2335     movzwl(dst, src); // movzxw
2336   } else {
2337     xorl(dst, dst);
2338     off = offset();
2339     movw(dst, src);
2340   }
2341   return off;
2342 }
2343 
2344 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
2345   switch (size_in_bytes) {
2346 #ifndef _LP64
2347   case  8:
2348     assert(dst2 != noreg, &quot;second dest register required&quot;);
2349     movl(dst,  src);
2350     movl(dst2, src.plus_disp(BytesPerInt));
2351     break;
2352 #else
2353   case  8:  movq(dst, src); break;
2354 #endif
2355   case  4:  movl(dst, src); break;
2356   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
2357   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
2358   default:  ShouldNotReachHere();
2359   }
2360 }
2361 
2362 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
2363   switch (size_in_bytes) {
2364 #ifndef _LP64
2365   case  8:
2366     assert(src2 != noreg, &quot;second source register required&quot;);
2367     movl(dst,                        src);
2368     movl(dst.plus_disp(BytesPerInt), src2);
2369     break;
2370 #else
2371   case  8:  movq(dst, src); break;
2372 #endif
2373   case  4:  movl(dst, src); break;
2374   case  2:  movw(dst, src); break;
2375   case  1:  movb(dst, src); break;
2376   default:  ShouldNotReachHere();
2377   }
2378 }
2379 
2380 void MacroAssembler::mov32(AddressLiteral dst, Register src) {
2381   if (reachable(dst)) {
2382     movl(as_Address(dst), src);
2383   } else {
2384     lea(rscratch1, dst);
2385     movl(Address(rscratch1, 0), src);
2386   }
2387 }
2388 
2389 void MacroAssembler::mov32(Register dst, AddressLiteral src) {
2390   if (reachable(src)) {
2391     movl(dst, as_Address(src));
2392   } else {
2393     lea(rscratch1, src);
2394     movl(dst, Address(rscratch1, 0));
2395   }
2396 }
2397 
2398 // C++ bool manipulation
2399 
2400 void MacroAssembler::movbool(Register dst, Address src) {
2401   if(sizeof(bool) == 1)
2402     movb(dst, src);
2403   else if(sizeof(bool) == 2)
2404     movw(dst, src);
2405   else if(sizeof(bool) == 4)
2406     movl(dst, src);
2407   else
2408     // unsupported
2409     ShouldNotReachHere();
2410 }
2411 
2412 void MacroAssembler::movbool(Address dst, bool boolconst) {
2413   if(sizeof(bool) == 1)
2414     movb(dst, (int) boolconst);
2415   else if(sizeof(bool) == 2)
2416     movw(dst, (int) boolconst);
2417   else if(sizeof(bool) == 4)
2418     movl(dst, (int) boolconst);
2419   else
2420     // unsupported
2421     ShouldNotReachHere();
2422 }
2423 
2424 void MacroAssembler::movbool(Address dst, Register src) {
2425   if(sizeof(bool) == 1)
2426     movb(dst, src);
2427   else if(sizeof(bool) == 2)
2428     movw(dst, src);
2429   else if(sizeof(bool) == 4)
2430     movl(dst, src);
2431   else
2432     // unsupported
2433     ShouldNotReachHere();
2434 }
2435 
2436 void MacroAssembler::movbyte(ArrayAddress dst, int src) {
2437   movb(as_Address(dst), src);
2438 }
2439 
2440 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
2441   if (reachable(src)) {
2442     movdl(dst, as_Address(src));
2443   } else {
2444     lea(rscratch1, src);
2445     movdl(dst, Address(rscratch1, 0));
2446   }
2447 }
2448 
2449 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
2450   if (reachable(src)) {
2451     movq(dst, as_Address(src));
2452   } else {
2453     lea(rscratch1, src);
2454     movq(dst, Address(rscratch1, 0));
2455   }
2456 }
2457 
2458 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
2459   if (reachable(src)) {
2460     if (UseXmmLoadAndClearUpper) {
2461       movsd (dst, as_Address(src));
2462     } else {
2463       movlpd(dst, as_Address(src));
2464     }
2465   } else {
2466     lea(rscratch1, src);
2467     if (UseXmmLoadAndClearUpper) {
2468       movsd (dst, Address(rscratch1, 0));
2469     } else {
2470       movlpd(dst, Address(rscratch1, 0));
2471     }
2472   }
2473 }
2474 
2475 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
2476   if (reachable(src)) {
2477     movss(dst, as_Address(src));
2478   } else {
2479     lea(rscratch1, src);
2480     movss(dst, Address(rscratch1, 0));
2481   }
2482 }
2483 
2484 void MacroAssembler::movptr(Register dst, Register src) {
2485   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2486 }
2487 
2488 void MacroAssembler::movptr(Register dst, Address src) {
2489   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2490 }
2491 
2492 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
2493 void MacroAssembler::movptr(Register dst, intptr_t src) {
2494   LP64_ONLY(mov64(dst, src)) NOT_LP64(movl(dst, src));
2495 }
2496 
2497 void MacroAssembler::movptr(Address dst, Register src) {
2498   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2499 }
2500 
2501 void MacroAssembler::movdqu(Address dst, XMMRegister src) {
2502     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2503     Assembler::movdqu(dst, src);
2504 }
2505 
2506 void MacroAssembler::movdqu(XMMRegister dst, Address src) {
2507     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2508     Assembler::movdqu(dst, src);
2509 }
2510 
2511 void MacroAssembler::movdqu(XMMRegister dst, XMMRegister src) {
2512     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2513     Assembler::movdqu(dst, src);
2514 }
2515 
2516 void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {
2517   if (reachable(src)) {
2518     movdqu(dst, as_Address(src));
2519   } else {
2520     lea(scratchReg, src);
2521     movdqu(dst, Address(scratchReg, 0));
2522   }
2523 }
2524 
2525 void MacroAssembler::vmovdqu(Address dst, XMMRegister src) {
2526     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2527     Assembler::vmovdqu(dst, src);
2528 }
2529 
2530 void MacroAssembler::vmovdqu(XMMRegister dst, Address src) {
2531     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2532     Assembler::vmovdqu(dst, src);
2533 }
2534 
2535 void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2536     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2537     Assembler::vmovdqu(dst, src);
2538 }
2539 
2540 void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2541   if (reachable(src)) {
2542     vmovdqu(dst, as_Address(src));
2543   }
2544   else {
2545     lea(scratch_reg, src);
2546     vmovdqu(dst, Address(scratch_reg, 0));
2547   }
2548 }
2549 
2550 void MacroAssembler::evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {
2551   if (reachable(src)) {
2552     Assembler::evmovdquq(dst, as_Address(src), vector_len);
2553   } else {
2554     lea(rscratch, src);
2555     Assembler::evmovdquq(dst, Address(rscratch, 0), vector_len);
2556   }
2557 }
2558 
2559 void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {
2560   if (reachable(src)) {
2561     Assembler::movdqa(dst, as_Address(src));
2562   } else {
2563     lea(rscratch1, src);
2564     Assembler::movdqa(dst, Address(rscratch1, 0));
2565   }
2566 }
2567 
2568 void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {
2569   if (reachable(src)) {
2570     Assembler::movsd(dst, as_Address(src));
2571   } else {
2572     lea(rscratch1, src);
2573     Assembler::movsd(dst, Address(rscratch1, 0));
2574   }
2575 }
2576 
2577 void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {
2578   if (reachable(src)) {
2579     Assembler::movss(dst, as_Address(src));
2580   } else {
2581     lea(rscratch1, src);
2582     Assembler::movss(dst, Address(rscratch1, 0));
2583   }
2584 }
2585 
2586 void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {
2587   if (reachable(src)) {
2588     Assembler::mulsd(dst, as_Address(src));
2589   } else {
2590     lea(rscratch1, src);
2591     Assembler::mulsd(dst, Address(rscratch1, 0));
2592   }
2593 }
2594 
2595 void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {
2596   if (reachable(src)) {
2597     Assembler::mulss(dst, as_Address(src));
2598   } else {
2599     lea(rscratch1, src);
2600     Assembler::mulss(dst, Address(rscratch1, 0));
2601   }
2602 }
2603 
2604 void MacroAssembler::null_check(Register reg, int offset) {
2605   if (needs_explicit_null_check(offset)) {
2606     // provoke OS NULL exception if reg = NULL by
2607     // accessing M[reg] w/o changing any (non-CC) registers
2608     // NOTE: cmpl is plenty here to provoke a segv
2609     cmpptr(rax, Address(reg, 0));
2610     // Note: should probably use testl(rax, Address(reg, 0));
2611     //       may be shorter code (however, this version of
2612     //       testl needs to be implemented first)
2613   } else {
2614     // nothing to do, (later) access of M[reg + offset]
2615     // will provoke OS NULL exception if reg = NULL
2616   }
2617 }
2618 
2619 void MacroAssembler::test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value) {
2620   movl(temp_reg, Address(klass, Klass::access_flags_offset()));
2621   testl(temp_reg, JVM_ACC_VALUE);
2622   jcc(Assembler::notZero, is_value);
2623 }
2624 
2625 void MacroAssembler::test_klass_is_empty_value(Register klass, Register temp_reg, Label&amp; is_empty_value) {
2626 #ifdef ASSERT
2627   {
2628     Label done_check;
2629     test_klass_is_value(klass, temp_reg, done_check);
2630     stop(&quot;test_klass_is_empty_value with non value klass&quot;);
2631     bind(done_check);
2632   }
2633 #endif
2634   movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));
2635   testl(temp_reg, InstanceKlass::misc_flags_is_empty_inline_type());
2636   jcc(Assembler::notZero, is_empty_value);
2637 }
2638 
2639 void MacroAssembler::test_field_is_flattenable(Register flags, Register temp_reg, Label&amp; is_flattenable) {
2640   movl(temp_reg, flags);
2641   shrl(temp_reg, ConstantPoolCacheEntry::is_flattenable_field_shift);
2642   andl(temp_reg, 0x1);
2643   testl(temp_reg, temp_reg);
2644   jcc(Assembler::notZero, is_flattenable);
2645 }
2646 
2647 void MacroAssembler::test_field_is_not_flattenable(Register flags, Register temp_reg, Label&amp; notFlattenable) {
2648   movl(temp_reg, flags);
2649   shrl(temp_reg, ConstantPoolCacheEntry::is_flattenable_field_shift);
2650   andl(temp_reg, 0x1);
2651   testl(temp_reg, temp_reg);
2652   jcc(Assembler::zero, notFlattenable);
2653 }
2654 
2655 void MacroAssembler::test_field_is_flattened(Register flags, Register temp_reg, Label&amp; is_flattened) {
2656   movl(temp_reg, flags);
2657   shrl(temp_reg, ConstantPoolCacheEntry::is_flattened_field_shift);
2658   andl(temp_reg, 0x1);
2659   testl(temp_reg, temp_reg);
2660   jcc(Assembler::notZero, is_flattened);
2661 }
2662 
2663 void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg,
2664                                               Label&amp;is_flattened_array) {
<a name="6" id="anc6"></a><span class="line-modified">2665   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">2666   load_klass(temp_reg, oop, tmp_load_klass);</span>
2667   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));
2668   test_flattened_array_layout(temp_reg, is_flattened_array);
2669 }
2670 
2671 void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,
2672                                                   Label&amp;is_non_flattened_array) {
<a name="7" id="anc7"></a><span class="line-modified">2673   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">2674   load_klass(temp_reg, oop, tmp_load_klass);</span>
2675   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));
2676   test_non_flattened_array_layout(temp_reg, is_non_flattened_array);
2677 }
2678 
2679 void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_null_free_array) {
<a name="8" id="anc8"></a><span class="line-modified">2680   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">2681   load_klass(temp_reg, oop, tmp_load_klass);</span>
2682   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));
2683   test_null_free_array_layout(temp_reg, is_null_free_array);
2684 }
2685 
2686 void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_non_null_free_array) {
<a name="9" id="anc9"></a><span class="line-modified">2687   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">2688   load_klass(temp_reg, oop, tmp_load_klass);</span>
2689   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));
2690   test_non_null_free_array_layout(temp_reg, is_non_null_free_array);
2691 }
2692 
2693 void MacroAssembler::test_flattened_array_layout(Register lh, Label&amp; is_flattened_array) {
2694   testl(lh, Klass::_lh_array_tag_vt_value_bit_inplace);
2695   jcc(Assembler::notZero, is_flattened_array);
2696 }
2697 void MacroAssembler::test_non_flattened_array_layout(Register lh, Label&amp; is_non_flattened_array) {
2698   testl(lh, Klass::_lh_array_tag_vt_value_bit_inplace);
2699   jcc(Assembler::zero, is_non_flattened_array);
2700 }
2701 
2702 void MacroAssembler::test_null_free_array_layout(Register lh, Label&amp; is_null_free_array) {
2703   testl(lh, Klass::_lh_null_free_bit_inplace);
2704   jcc(Assembler::notZero, is_null_free_array);
2705 }
2706 
2707 void MacroAssembler::test_non_null_free_array_layout(Register lh, Label&amp; is_non_null_free_array) {
2708   testl(lh, Klass::_lh_null_free_bit_inplace);
2709   jcc(Assembler::zero, is_non_null_free_array);
2710 }
2711 
2712 
2713 void MacroAssembler::os_breakpoint() {
2714   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
2715   // (e.g., MSVC can&#39;t call ps() otherwise)
2716   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
2717 }
2718 
2719 void MacroAssembler::unimplemented(const char* what) {
2720   const char* buf = NULL;
2721   {
2722     ResourceMark rm;
2723     stringStream ss;
2724     ss.print(&quot;unimplemented: %s&quot;, what);
2725     buf = code_string(ss.as_string());
2726   }
2727   stop(buf);
2728 }
2729 
2730 #ifdef _LP64
2731 #define XSTATE_BV 0x200
2732 #endif
2733 
2734 void MacroAssembler::pop_CPU_state() {
2735   pop_FPU_state();
2736   pop_IU_state();
2737 }
2738 
2739 void MacroAssembler::pop_FPU_state() {
2740 #ifndef _LP64
2741   frstor(Address(rsp, 0));
2742 #else
2743   fxrstor(Address(rsp, 0));
2744 #endif
2745   addptr(rsp, FPUStateSizeInWords * wordSize);
2746 }
2747 
2748 void MacroAssembler::pop_IU_state() {
2749   popa();
2750   LP64_ONLY(addq(rsp, 8));
2751   popf();
2752 }
2753 
2754 // Save Integer and Float state
2755 // Warning: Stack must be 16 byte aligned (64bit)
2756 void MacroAssembler::push_CPU_state() {
2757   push_IU_state();
2758   push_FPU_state();
2759 }
2760 
2761 void MacroAssembler::push_FPU_state() {
2762   subptr(rsp, FPUStateSizeInWords * wordSize);
2763 #ifndef _LP64
2764   fnsave(Address(rsp, 0));
2765   fwait();
2766 #else
2767   fxsave(Address(rsp, 0));
2768 #endif // LP64
2769 }
2770 
2771 void MacroAssembler::push_IU_state() {
2772   // Push flags first because pusha kills them
2773   pushf();
2774   // Make sure rsp stays 16-byte aligned
2775   LP64_ONLY(subq(rsp, 8));
2776   pusha();
2777 }
2778 
2779 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
2780   if (!java_thread-&gt;is_valid()) {
2781     java_thread = rdi;
2782     get_thread(java_thread);
2783   }
2784   // we must set sp to zero to clear frame
2785   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
2786   if (clear_fp) {
2787     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
2788   }
2789 
2790   // Always clear the pc because it could have been set by make_walkable()
2791   movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
2792 
2793   vzeroupper();
2794 }
2795 
2796 void MacroAssembler::restore_rax(Register tmp) {
2797   if (tmp == noreg) pop(rax);
2798   else if (tmp != rax) mov(rax, tmp);
2799 }
2800 
2801 void MacroAssembler::round_to(Register reg, int modulus) {
2802   addptr(reg, modulus - 1);
2803   andptr(reg, -modulus);
2804 }
2805 
2806 void MacroAssembler::save_rax(Register tmp) {
2807   if (tmp == noreg) push(rax);
2808   else if (tmp != rax) mov(tmp, rax);
2809 }
2810 
2811 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
2812 #ifdef _LP64
2813   assert(thread_reg == r15_thread, &quot;should be&quot;);
2814 #else
2815   if (thread_reg == noreg) {
2816     thread_reg = temp_reg;
2817     get_thread(thread_reg);
2818   }
2819 #endif
2820   testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2821   jcc(Assembler::notZero, slow_path); // handshake bit set implies poll
2822 }
2823 
2824 // Calls to C land
2825 //
2826 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
2827 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
2828 // has to be reset to 0. This is required to allow proper stack traversal.
2829 void MacroAssembler::set_last_Java_frame(Register java_thread,
2830                                          Register last_java_sp,
2831                                          Register last_java_fp,
2832                                          address  last_java_pc) {
2833   vzeroupper();
2834   // determine java_thread register
2835   if (!java_thread-&gt;is_valid()) {
2836     java_thread = rdi;
2837     get_thread(java_thread);
2838   }
2839   // determine last_java_sp register
2840   if (!last_java_sp-&gt;is_valid()) {
2841     last_java_sp = rsp;
2842   }
2843 
2844   // last_java_fp is optional
2845 
2846   if (last_java_fp-&gt;is_valid()) {
2847     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);
2848   }
2849 
2850   // last_java_pc is optional
2851 
2852   if (last_java_pc != NULL) {
2853     lea(Address(java_thread,
2854                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),
2855         InternalAddress(last_java_pc));
2856 
2857   }
2858   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
2859 }
2860 
2861 void MacroAssembler::shlptr(Register dst, int imm8) {
2862   LP64_ONLY(shlq(dst, imm8)) NOT_LP64(shll(dst, imm8));
2863 }
2864 
2865 void MacroAssembler::shrptr(Register dst, int imm8) {
2866   LP64_ONLY(shrq(dst, imm8)) NOT_LP64(shrl(dst, imm8));
2867 }
2868 
2869 void MacroAssembler::sign_extend_byte(Register reg) {
2870   if (LP64_ONLY(true ||) (VM_Version::is_P6() &amp;&amp; reg-&gt;has_byte_register())) {
2871     movsbl(reg, reg); // movsxb
2872   } else {
2873     shll(reg, 24);
2874     sarl(reg, 24);
2875   }
2876 }
2877 
2878 void MacroAssembler::sign_extend_short(Register reg) {
2879   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2880     movswl(reg, reg); // movsxw
2881   } else {
2882     shll(reg, 16);
2883     sarl(reg, 16);
2884   }
2885 }
2886 
2887 void MacroAssembler::testl(Register dst, AddressLiteral src) {
2888   assert(reachable(src), &quot;Address should be reachable&quot;);
2889   testl(dst, as_Address(src));
2890 }
2891 
2892 void MacroAssembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
2893   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2894   Assembler::pcmpeqb(dst, src);
2895 }
2896 
2897 void MacroAssembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
2898   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2899   Assembler::pcmpeqw(dst, src);
2900 }
2901 
2902 void MacroAssembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
2903   assert((dst-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2904   Assembler::pcmpestri(dst, src, imm8);
2905 }
2906 
2907 void MacroAssembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
2908   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2909   Assembler::pcmpestri(dst, src, imm8);
2910 }
2911 
2912 void MacroAssembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
2913   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2914   Assembler::pmovzxbw(dst, src);
2915 }
2916 
2917 void MacroAssembler::pmovzxbw(XMMRegister dst, Address src) {
2918   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2919   Assembler::pmovzxbw(dst, src);
2920 }
2921 
2922 void MacroAssembler::pmovmskb(Register dst, XMMRegister src) {
2923   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2924   Assembler::pmovmskb(dst, src);
2925 }
2926 
2927 void MacroAssembler::ptest(XMMRegister dst, XMMRegister src) {
2928   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2929   Assembler::ptest(dst, src);
2930 }
2931 
2932 void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {
2933   if (reachable(src)) {
2934     Assembler::sqrtsd(dst, as_Address(src));
2935   } else {
2936     lea(rscratch1, src);
2937     Assembler::sqrtsd(dst, Address(rscratch1, 0));
2938   }
2939 }
2940 
2941 void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {
2942   if (reachable(src)) {
2943     Assembler::sqrtss(dst, as_Address(src));
2944   } else {
2945     lea(rscratch1, src);
2946     Assembler::sqrtss(dst, Address(rscratch1, 0));
2947   }
2948 }
2949 
2950 void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {
2951   if (reachable(src)) {
2952     Assembler::subsd(dst, as_Address(src));
2953   } else {
2954     lea(rscratch1, src);
2955     Assembler::subsd(dst, Address(rscratch1, 0));
2956   }
2957 }
2958 
2959 void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {
2960   if (reachable(src)) {
2961     Assembler::roundsd(dst, as_Address(src), rmode);
2962   } else {
2963     lea(scratch_reg, src);
2964     Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);
2965   }
2966 }
2967 
2968 void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {
2969   if (reachable(src)) {
2970     Assembler::subss(dst, as_Address(src));
2971   } else {
2972     lea(rscratch1, src);
2973     Assembler::subss(dst, Address(rscratch1, 0));
2974   }
2975 }
2976 
2977 void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {
2978   if (reachable(src)) {
2979     Assembler::ucomisd(dst, as_Address(src));
2980   } else {
2981     lea(rscratch1, src);
2982     Assembler::ucomisd(dst, Address(rscratch1, 0));
2983   }
2984 }
2985 
2986 void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {
2987   if (reachable(src)) {
2988     Assembler::ucomiss(dst, as_Address(src));
2989   } else {
2990     lea(rscratch1, src);
2991     Assembler::ucomiss(dst, Address(rscratch1, 0));
2992   }
2993 }
2994 
2995 void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2996   // Used in sign-bit flipping with aligned address.
2997   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2998   if (reachable(src)) {
2999     Assembler::xorpd(dst, as_Address(src));
3000   } else {
3001     lea(scratch_reg, src);
3002     Assembler::xorpd(dst, Address(scratch_reg, 0));
3003   }
3004 }
3005 
3006 void MacroAssembler::xorpd(XMMRegister dst, XMMRegister src) {
3007   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
3008     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
3009   }
3010   else {
3011     Assembler::xorpd(dst, src);
3012   }
3013 }
3014 
3015 void MacroAssembler::xorps(XMMRegister dst, XMMRegister src) {
3016   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
3017     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
3018   } else {
3019     Assembler::xorps(dst, src);
3020   }
3021 }
3022 
3023 void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
3024   // Used in sign-bit flipping with aligned address.
3025   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
3026   if (reachable(src)) {
3027     Assembler::xorps(dst, as_Address(src));
3028   } else {
3029     lea(scratch_reg, src);
3030     Assembler::xorps(dst, Address(scratch_reg, 0));
3031   }
3032 }
3033 
3034 void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {
3035   // Used in sign-bit flipping with aligned address.
3036   bool aligned_adr = (((intptr_t)src.target() &amp; 15) == 0);
3037   assert((UseAVX &gt; 0) || aligned_adr, &quot;SSE mode requires address alignment 16 bytes&quot;);
3038   if (reachable(src)) {
3039     Assembler::pshufb(dst, as_Address(src));
3040   } else {
3041     lea(rscratch1, src);
3042     Assembler::pshufb(dst, Address(rscratch1, 0));
3043   }
3044 }
3045 
3046 // AVX 3-operands instructions
3047 
3048 void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3049   if (reachable(src)) {
3050     vaddsd(dst, nds, as_Address(src));
3051   } else {
3052     lea(rscratch1, src);
3053     vaddsd(dst, nds, Address(rscratch1, 0));
3054   }
3055 }
3056 
3057 void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3058   if (reachable(src)) {
3059     vaddss(dst, nds, as_Address(src));
3060   } else {
3061     lea(rscratch1, src);
3062     vaddss(dst, nds, Address(rscratch1, 0));
3063   }
3064 }
3065 
3066 void MacroAssembler::vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {
3067   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
3068   if (reachable(src)) {
3069     Assembler::vpaddd(dst, nds, as_Address(src), vector_len);
3070   } else {
3071     lea(rscratch, src);
3072     Assembler::vpaddd(dst, nds, Address(rscratch, 0), vector_len);
3073   }
3074 }
3075 
3076 void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
3077   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3078   vandps(dst, nds, negate_field, vector_len);
3079 }
3080 
3081 void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
3082   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3083   vandpd(dst, nds, negate_field, vector_len);
3084 }
3085 
3086 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3087   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3088   Assembler::vpaddb(dst, nds, src, vector_len);
3089 }
3090 
3091 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3092   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3093   Assembler::vpaddb(dst, nds, src, vector_len);
3094 }
3095 
3096 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3097   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3098   Assembler::vpaddw(dst, nds, src, vector_len);
3099 }
3100 
3101 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3102   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3103   Assembler::vpaddw(dst, nds, src, vector_len);
3104 }
3105 
3106 void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3107   if (reachable(src)) {
3108     Assembler::vpand(dst, nds, as_Address(src), vector_len);
3109   } else {
3110     lea(scratch_reg, src);
3111     Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);
3112   }
3113 }
3114 
3115 void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
3116   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3117   Assembler::vpbroadcastw(dst, src, vector_len);
3118 }
3119 
3120 void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3121   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3122   Assembler::vpcmpeqb(dst, nds, src, vector_len);
3123 }
3124 
3125 void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3126   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3127   Assembler::vpcmpeqw(dst, nds, src, vector_len);
3128 }
3129 
3130 void MacroAssembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3131   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3132   Assembler::vpmovzxbw(dst, src, vector_len);
3133 }
3134 
3135 void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {
3136   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3137   Assembler::vpmovmskb(dst, src);
3138 }
3139 
3140 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3141   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3142   Assembler::vpmullw(dst, nds, src, vector_len);
3143 }
3144 
3145 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3146   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3147   Assembler::vpmullw(dst, nds, src, vector_len);
3148 }
3149 
3150 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3151   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3152   Assembler::vpsubb(dst, nds, src, vector_len);
3153 }
3154 
3155 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3156   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3157   Assembler::vpsubb(dst, nds, src, vector_len);
3158 }
3159 
3160 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3161   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3162   Assembler::vpsubw(dst, nds, src, vector_len);
3163 }
3164 
3165 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3166   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3167   Assembler::vpsubw(dst, nds, src, vector_len);
3168 }
3169 
3170 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3171   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3172   Assembler::vpsraw(dst, nds, shift, vector_len);
3173 }
3174 
3175 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3176   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3177   Assembler::vpsraw(dst, nds, shift, vector_len);
3178 }
3179 
3180 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3181   assert(UseAVX &gt; 2,&quot;&quot;);
3182   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3183      vector_len = 2;
3184   }
3185   Assembler::evpsraq(dst, nds, shift, vector_len);
3186 }
3187 
3188 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3189   assert(UseAVX &gt; 2,&quot;&quot;);
3190   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3191      vector_len = 2;
3192   }
3193   Assembler::evpsraq(dst, nds, shift, vector_len);
3194 }
3195 
3196 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3197   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3198   Assembler::vpsrlw(dst, nds, shift, vector_len);
3199 }
3200 
3201 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3202   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3203   Assembler::vpsrlw(dst, nds, shift, vector_len);
3204 }
3205 
3206 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3207   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3208   Assembler::vpsllw(dst, nds, shift, vector_len);
3209 }
3210 
3211 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3212   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3213   Assembler::vpsllw(dst, nds, shift, vector_len);
3214 }
3215 
3216 void MacroAssembler::vptest(XMMRegister dst, XMMRegister src) {
3217   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3218   Assembler::vptest(dst, src);
3219 }
3220 
3221 void MacroAssembler::punpcklbw(XMMRegister dst, XMMRegister src) {
3222   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3223   Assembler::punpcklbw(dst, src);
3224 }
3225 
3226 void MacroAssembler::pshufd(XMMRegister dst, Address src, int mode) {
3227   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
3228   Assembler::pshufd(dst, src, mode);
3229 }
3230 
3231 void MacroAssembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
3232   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3233   Assembler::pshuflw(dst, src, mode);
3234 }
3235 
3236 void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3237   if (reachable(src)) {
3238     vandpd(dst, nds, as_Address(src), vector_len);
3239   } else {
3240     lea(scratch_reg, src);
3241     vandpd(dst, nds, Address(scratch_reg, 0), vector_len);
3242   }
3243 }
3244 
3245 void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3246   if (reachable(src)) {
3247     vandps(dst, nds, as_Address(src), vector_len);
3248   } else {
3249     lea(scratch_reg, src);
3250     vandps(dst, nds, Address(scratch_reg, 0), vector_len);
3251   }
3252 }
3253 
3254 void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3255   if (reachable(src)) {
3256     vdivsd(dst, nds, as_Address(src));
3257   } else {
3258     lea(rscratch1, src);
3259     vdivsd(dst, nds, Address(rscratch1, 0));
3260   }
3261 }
3262 
3263 void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3264   if (reachable(src)) {
3265     vdivss(dst, nds, as_Address(src));
3266   } else {
3267     lea(rscratch1, src);
3268     vdivss(dst, nds, Address(rscratch1, 0));
3269   }
3270 }
3271 
3272 void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3273   if (reachable(src)) {
3274     vmulsd(dst, nds, as_Address(src));
3275   } else {
3276     lea(rscratch1, src);
3277     vmulsd(dst, nds, Address(rscratch1, 0));
3278   }
3279 }
3280 
3281 void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3282   if (reachable(src)) {
3283     vmulss(dst, nds, as_Address(src));
3284   } else {
3285     lea(rscratch1, src);
3286     vmulss(dst, nds, Address(rscratch1, 0));
3287   }
3288 }
3289 
3290 void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3291   if (reachable(src)) {
3292     vsubsd(dst, nds, as_Address(src));
3293   } else {
3294     lea(rscratch1, src);
3295     vsubsd(dst, nds, Address(rscratch1, 0));
3296   }
3297 }
3298 
3299 void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3300   if (reachable(src)) {
3301     vsubss(dst, nds, as_Address(src));
3302   } else {
3303     lea(rscratch1, src);
3304     vsubss(dst, nds, Address(rscratch1, 0));
3305   }
3306 }
3307 
3308 void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3309   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3310   vxorps(dst, nds, src, Assembler::AVX_128bit);
3311 }
3312 
3313 void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3314   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3315   vxorpd(dst, nds, src, Assembler::AVX_128bit);
3316 }
3317 
3318 void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3319   if (reachable(src)) {
3320     vxorpd(dst, nds, as_Address(src), vector_len);
3321   } else {
3322     lea(scratch_reg, src);
3323     vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);
3324   }
3325 }
3326 
3327 void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3328   if (reachable(src)) {
3329     vxorps(dst, nds, as_Address(src), vector_len);
3330   } else {
3331     lea(scratch_reg, src);
3332     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
3333   }
3334 }
3335 
3336 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3337   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
3338     if (reachable(src)) {
3339       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
3340     } else {
3341       lea(scratch_reg, src);
3342       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
3343     }
3344   }
3345   else {
3346     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
3347   }
3348 }
3349 
3350 //-------------------------------------------------------------------------------------------
3351 
3352 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
3353   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
3354   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
3355   // The inverted mask is sign-extended
3356   andptr(possibly_jweak, inverted_jweak_mask);
3357 }
3358 
3359 void MacroAssembler::resolve_jobject(Register value,
3360                                      Register thread,
3361                                      Register tmp) {
3362   assert_different_registers(value, thread, tmp);
3363   Label done, not_weak;
3364   testptr(value, value);
3365   jcc(Assembler::zero, done);                // Use NULL as-is.
3366   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
3367   jcc(Assembler::zero, not_weak);
3368   // Resolve jweak.
3369   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3370                  value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);
3371   verify_oop(value);
3372   jmp(done);
3373   bind(not_weak);
3374   // Resolve (untagged) jobject.
3375   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
3376   verify_oop(value);
3377   bind(done);
3378 }
3379 
3380 void MacroAssembler::subptr(Register dst, int32_t imm32) {
3381   LP64_ONLY(subq(dst, imm32)) NOT_LP64(subl(dst, imm32));
3382 }
3383 
3384 // Force generation of a 4 byte immediate value even if it fits into 8bit
3385 void MacroAssembler::subptr_imm32(Register dst, int32_t imm32) {
3386   LP64_ONLY(subq_imm32(dst, imm32)) NOT_LP64(subl_imm32(dst, imm32));
3387 }
3388 
3389 void MacroAssembler::subptr(Register dst, Register src) {
3390   LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src));
3391 }
3392 
3393 // C++ bool manipulation
3394 void MacroAssembler::testbool(Register dst) {
3395   if(sizeof(bool) == 1)
3396     testb(dst, 0xff);
3397   else if(sizeof(bool) == 2) {
3398     // testw implementation needed for two byte bools
3399     ShouldNotReachHere();
3400   } else if(sizeof(bool) == 4)
3401     testl(dst, dst);
3402   else
3403     // unsupported
3404     ShouldNotReachHere();
3405 }
3406 
3407 void MacroAssembler::testptr(Register dst, Register src) {
3408   LP64_ONLY(testq(dst, src)) NOT_LP64(testl(dst, src));
3409 }
3410 
3411 // Object / value buffer allocation...
3412 //
3413 // Kills klass and rsi on LP64
3414 void MacroAssembler::allocate_instance(Register klass, Register new_obj,
3415                                        Register t1, Register t2,
3416                                        bool clear_fields, Label&amp; alloc_failed)
3417 {
3418   Label done, initialize_header, initialize_object, slow_case, slow_case_no_pop;
3419   Register layout_size = t1;
3420   assert(new_obj == rax, &quot;needs to be rax, according to barrier asm eden_allocate&quot;);
3421   assert_different_registers(klass, new_obj, t1, t2);
3422 
3423 #ifdef ASSERT
3424   {
3425     Label L;
3426     cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3427     jcc(Assembler::equal, L);
3428     stop(&quot;klass not initialized&quot;);
3429     bind(L);
3430   }
3431 #endif
3432 
3433   // get instance_size in InstanceKlass (scaled to a count of bytes)
3434   movl(layout_size, Address(klass, Klass::layout_helper_offset()));
3435   // test to see if it has a finalizer or is malformed in some way
3436   testl(layout_size, Klass::_lh_instance_slow_path_bit);
3437   jcc(Assembler::notZero, slow_case_no_pop);
3438 
3439   // Allocate the instance:
3440   //  If TLAB is enabled:
3441   //    Try to allocate in the TLAB.
3442   //    If fails, go to the slow path.
3443   //  Else If inline contiguous allocations are enabled:
3444   //    Try to allocate in eden.
3445   //    If fails due to heap end, go to slow path.
3446   //
3447   //  If TLAB is enabled OR inline contiguous is enabled:
3448   //    Initialize the allocation.
3449   //    Exit.
3450   //
3451   //  Go to slow path.
3452   const bool allow_shared_alloc =
3453     Universe::heap()-&gt;supports_inline_contig_alloc();
3454 
3455   push(klass);
3456   const Register thread = LP64_ONLY(r15_thread) NOT_LP64(klass);
3457 #ifndef _LP64
3458   if (UseTLAB || allow_shared_alloc) {
3459     get_thread(thread);
3460   }
3461 #endif // _LP64
3462 
3463   if (UseTLAB) {
3464     tlab_allocate(thread, new_obj, layout_size, 0, klass, t2, slow_case);
3465     if (ZeroTLAB || (!clear_fields)) {
3466       // the fields have been already cleared
3467       jmp(initialize_header);
3468     } else {
3469       // initialize both the header and fields
3470       jmp(initialize_object);
3471     }
3472   } else {
3473     // Allocation in the shared Eden, if allowed.
3474     //
3475     eden_allocate(thread, new_obj, layout_size, 0, t2, slow_case);
3476   }
3477 
3478   // If UseTLAB or allow_shared_alloc are true, the object is created above and
3479   // there is an initialize need. Otherwise, skip and go to the slow path.
3480   if (UseTLAB || allow_shared_alloc) {
3481     if (clear_fields) {
3482       // The object is initialized before the header.  If the object size is
3483       // zero, go directly to the header initialization.
3484       bind(initialize_object);
3485       decrement(layout_size, sizeof(oopDesc));
3486       jcc(Assembler::zero, initialize_header);
3487 
3488       // Initialize topmost object field, divide size by 8, check if odd and
3489       // test if zero.
3490       Register zero = klass;
3491       xorl(zero, zero);    // use zero reg to clear memory (shorter code)
3492       shrl(layout_size, LogBytesPerLong); // divide by 2*oopSize and set carry flag if odd
3493 
3494   #ifdef ASSERT
3495       // make sure instance_size was multiple of 8
3496       Label L;
3497       // Ignore partial flag stall after shrl() since it is debug VM
3498       jcc(Assembler::carryClear, L);
3499       stop(&quot;object size is not multiple of 2 - adjust this code&quot;);
3500       bind(L);
3501       // must be &gt; 0, no extra check needed here
3502   #endif
3503 
3504       // initialize remaining object fields: instance_size was a multiple of 8
3505       {
3506         Label loop;
3507         bind(loop);
3508         movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 1*oopSize), zero);
3509         NOT_LP64(movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 2*oopSize), zero));
3510         decrement(layout_size);
3511         jcc(Assembler::notZero, loop);
3512       }
3513     } // clear_fields
3514 
3515     // initialize object header only.
3516     bind(initialize_header);
3517     pop(klass);
3518     Register mark_word = t2;
3519     movptr(mark_word, Address(klass, Klass::prototype_header_offset()));
3520     movptr(Address(new_obj, oopDesc::mark_offset_in_bytes ()), mark_word);
3521 #ifdef _LP64
3522     xorl(rsi, rsi);                 // use zero reg to clear memory (shorter code)
3523     store_klass_gap(new_obj, rsi);  // zero klass gap for compressed oops
3524 #endif
3525     movptr(t2, klass);         // preserve klass
<a name="10" id="anc10"></a><span class="line-modified">3526     Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">3527     store_klass(new_obj, t2, tmp_store_klass);  // src klass reg is potentially compressed</span>
3528 
3529     jmp(done);
3530   }
3531 
3532   bind(slow_case);
3533   pop(klass);
3534   bind(slow_case_no_pop);
3535   jmp(alloc_failed);
3536 
3537   bind(done);
3538 }
3539 
3540 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
3541 void MacroAssembler::tlab_allocate(Register thread, Register obj,
3542                                    Register var_size_in_bytes,
3543                                    int con_size_in_bytes,
3544                                    Register t1,
3545                                    Register t2,
3546                                    Label&amp; slow_case) {
3547   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3548   bs-&gt;tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
3549 }
3550 
3551 // Defines obj, preserves var_size_in_bytes
3552 void MacroAssembler::eden_allocate(Register thread, Register obj,
3553                                    Register var_size_in_bytes,
3554                                    int con_size_in_bytes,
3555                                    Register t1,
3556                                    Label&amp; slow_case) {
3557   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3558   bs-&gt;eden_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
3559 }
3560 
3561 // Preserves the contents of address, destroys the contents length_in_bytes and temp.
3562 void MacroAssembler::zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp) {
3563   assert(address != length_in_bytes &amp;&amp; address != temp &amp;&amp; temp != length_in_bytes, &quot;registers must be different&quot;);
3564   assert((offset_in_bytes &amp; (BytesPerWord - 1)) == 0, &quot;offset must be a multiple of BytesPerWord&quot;);
3565   Label done;
3566 
3567   testptr(length_in_bytes, length_in_bytes);
3568   jcc(Assembler::zero, done);
3569 
3570   // initialize topmost word, divide index by 2, check if odd and test if zero
3571   // note: for the remaining code to work, index must be a multiple of BytesPerWord
3572 #ifdef ASSERT
3573   {
3574     Label L;
3575     testptr(length_in_bytes, BytesPerWord - 1);
3576     jcc(Assembler::zero, L);
3577     stop(&quot;length must be a multiple of BytesPerWord&quot;);
3578     bind(L);
3579   }
3580 #endif
3581   Register index = length_in_bytes;
3582   xorptr(temp, temp);    // use _zero reg to clear memory (shorter code)
3583   if (UseIncDec) {
3584     shrptr(index, 3);  // divide by 8/16 and set carry flag if bit 2 was set
3585   } else {
3586     shrptr(index, 2);  // use 2 instructions to avoid partial flag stall
3587     shrptr(index, 1);
3588   }
3589 #ifndef _LP64
3590   // index could have not been a multiple of 8 (i.e., bit 2 was set)
3591   {
3592     Label even;
3593     // note: if index was a multiple of 8, then it cannot
3594     //       be 0 now otherwise it must have been 0 before
3595     //       =&gt; if it is even, we don&#39;t need to check for 0 again
3596     jcc(Assembler::carryClear, even);
3597     // clear topmost word (no jump would be needed if conditional assignment worked here)
3598     movptr(Address(address, index, Address::times_8, offset_in_bytes - 0*BytesPerWord), temp);
3599     // index could be 0 now, must check again
3600     jcc(Assembler::zero, done);
3601     bind(even);
3602   }
3603 #endif // !_LP64
3604   // initialize remaining object fields: index is a multiple of 2 now
3605   {
3606     Label loop;
3607     bind(loop);
3608     movptr(Address(address, index, Address::times_8, offset_in_bytes - 1*BytesPerWord), temp);
3609     NOT_LP64(movptr(Address(address, index, Address::times_8, offset_in_bytes - 2*BytesPerWord), temp);)
3610     decrement(index);
3611     jcc(Assembler::notZero, loop);
3612   }
3613 
3614   bind(done);
3615 }
3616 
3617 void MacroAssembler::get_value_field_klass(Register klass, Register index, Register value_klass) {
3618   movptr(value_klass, Address(klass, InstanceKlass::value_field_klasses_offset()));
3619 #ifdef ASSERT
3620   {
3621     Label done;
3622     cmpptr(value_klass, 0);
3623     jcc(Assembler::notEqual, done);
3624     stop(&quot;get_value_field_klass contains no inline klasses&quot;);
3625     bind(done);
3626   }
3627 #endif
3628   movptr(value_klass, Address(value_klass, index, Address::times_ptr));
3629 }
3630 
3631 void MacroAssembler::get_default_value_oop(Register value_klass, Register temp_reg, Register obj) {
3632 #ifdef ASSERT
3633   {
3634     Label done_check;
3635     test_klass_is_value(value_klass, temp_reg, done_check);
3636     stop(&quot;get_default_value_oop from non-value klass&quot;);
3637     bind(done_check);
3638   }
3639 #endif
3640   Register offset = temp_reg;
3641   // Getting the offset of the pre-allocated default value
3642   movptr(offset, Address(value_klass, in_bytes(InstanceKlass::adr_valueklass_fixed_block_offset())));
3643   movl(offset, Address(offset, in_bytes(ValueKlass::default_value_offset_offset())));
3644 
3645   // Getting the mirror
3646   movptr(obj, Address(value_klass, in_bytes(Klass::java_mirror_offset())));
3647   resolve_oop_handle(obj, value_klass);
3648 
3649   // Getting the pre-allocated default value from the mirror
3650   Address field(obj, offset, Address::times_1);
3651   load_heap_oop(obj, field);
3652 }
3653 
3654 void MacroAssembler::get_empty_value_oop(Register value_klass, Register temp_reg, Register obj) {
3655 #ifdef ASSERT
3656   {
3657     Label done_check;
3658     test_klass_is_empty_value(value_klass, temp_reg, done_check);
3659     stop(&quot;get_empty_value from non-empty value klass&quot;);
3660     bind(done_check);
3661   }
3662 #endif
3663   get_default_value_oop(value_klass, temp_reg, obj);
3664 }
3665 
3666 
3667 // Look up the method for a megamorphic invokeinterface call.
3668 // The target method is determined by &lt;intf_klass, itable_index&gt;.
3669 // The receiver klass is in recv_klass.
3670 // On success, the result will be in method_result, and execution falls through.
3671 // On failure, execution transfers to the given label.
3672 void MacroAssembler::lookup_interface_method(Register recv_klass,
3673                                              Register intf_klass,
3674                                              RegisterOrConstant itable_index,
3675                                              Register method_result,
3676                                              Register scan_temp,
3677                                              Label&amp; L_no_such_interface,
3678                                              bool return_method) {
3679   assert_different_registers(recv_klass, intf_klass, scan_temp);
3680   assert_different_registers(method_result, intf_klass, scan_temp);
3681   assert(recv_klass != method_result || !return_method,
3682          &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
3683 
3684   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
3685          &quot;caller must use same register for non-constant itable index as for method&quot;);
3686 
3687   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
3688   int vtable_base = in_bytes(Klass::vtable_start_offset());
3689   int itentry_off = itableMethodEntry::method_offset_in_bytes();
3690   int scan_step   = itableOffsetEntry::size() * wordSize;
3691   int vte_size    = vtableEntry::size_in_bytes();
3692   Address::ScaleFactor times_vte_scale = Address::times_ptr;
3693   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
3694 
3695   movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
3696 
3697   // %%% Could store the aligned, prescaled offset in the klassoop.
3698   lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
3699 
3700   if (return_method) {
3701     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
3702     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
3703     lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
3704   }
3705 
3706   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
3707   //   if (scan-&gt;interface() == intf) {
3708   //     result = (klass + scan-&gt;offset() + itable_index);
3709   //   }
3710   // }
3711   Label search, found_method;
3712 
3713   for (int peel = 1; peel &gt;= 0; peel--) {
3714     movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
3715     cmpptr(intf_klass, method_result);
3716 
3717     if (peel) {
3718       jccb(Assembler::equal, found_method);
3719     } else {
3720       jccb(Assembler::notEqual, search);
3721       // (invert the test to fall through to found_method...)
3722     }
3723 
3724     if (!peel)  break;
3725 
3726     bind(search);
3727 
3728     // Check that the previous entry is non-null.  A null entry means that
3729     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
3730     // same as when the caller was compiled.
3731     testptr(method_result, method_result);
3732     jcc(Assembler::zero, L_no_such_interface);
3733     addptr(scan_temp, scan_step);
3734   }
3735 
3736   bind(found_method);
3737 
3738   if (return_method) {
3739     // Got a hit.
3740     movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
3741     movptr(method_result, Address(recv_klass, scan_temp, Address::times_1));
3742   }
3743 }
3744 
3745 
3746 // virtual method calling
3747 void MacroAssembler::lookup_virtual_method(Register recv_klass,
3748                                            RegisterOrConstant vtable_index,
3749                                            Register method_result) {
3750   const int base = in_bytes(Klass::vtable_start_offset());
3751   assert(vtableEntry::size() * wordSize == wordSize, &quot;else adjust the scaling in the code below&quot;);
3752   Address vtable_entry_addr(recv_klass,
3753                             vtable_index, Address::times_ptr,
3754                             base + vtableEntry::method_offset_in_bytes());
3755   movptr(method_result, vtable_entry_addr);
3756 }
3757 
3758 
3759 void MacroAssembler::check_klass_subtype(Register sub_klass,
3760                            Register super_klass,
3761                            Register temp_reg,
3762                            Label&amp; L_success) {
3763   Label L_failure;
3764   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
3765   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
3766   bind(L_failure);
3767 }
3768 
3769 
3770 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
3771                                                    Register super_klass,
3772                                                    Register temp_reg,
3773                                                    Label* L_success,
3774                                                    Label* L_failure,
3775                                                    Label* L_slow_path,
3776                                         RegisterOrConstant super_check_offset) {
3777   assert_different_registers(sub_klass, super_klass, temp_reg);
3778   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
3779   if (super_check_offset.is_register()) {
3780     assert_different_registers(sub_klass, super_klass,
3781                                super_check_offset.as_register());
3782   } else if (must_load_sco) {
3783     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
3784   }
3785 
3786   Label L_fallthrough;
3787   int label_nulls = 0;
3788   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3789   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3790   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
3791   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3792 
3793   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3794   int sco_offset = in_bytes(Klass::super_check_offset_offset());
3795   Address super_check_offset_addr(super_klass, sco_offset);
3796 
3797   // Hacked jcc, which &quot;knows&quot; that L_fallthrough, at least, is in
3798   // range of a jccb.  If this routine grows larger, reconsider at
3799   // least some of these.
3800 #define local_jcc(assembler_cond, label)                                \
3801   if (&amp;(label) == &amp;L_fallthrough)  jccb(assembler_cond, label);         \
3802   else                             jcc( assembler_cond, label) /*omit semi*/
3803 
3804   // Hacked jmp, which may only be used just before L_fallthrough.
3805 #define final_jmp(label)                                                \
3806   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3807   else                            jmp(label)                /*omit semi*/
3808 
3809   // If the pointers are equal, we are done (e.g., String[] elements).
3810   // This self-check enables sharing of secondary supertype arrays among
3811   // non-primary types such as array-of-interface.  Otherwise, each such
3812   // type would need its own customized SSA.
3813   // We move this check to the front of the fast path because many
3814   // type checks are in fact trivially successful in this manner,
3815   // so we get a nicely predicted branch right at the start of the check.
3816   cmpptr(sub_klass, super_klass);
3817   local_jcc(Assembler::equal, *L_success);
3818 
3819   // Check the supertype display:
3820   if (must_load_sco) {
3821     // Positive movl does right thing on LP64.
3822     movl(temp_reg, super_check_offset_addr);
3823     super_check_offset = RegisterOrConstant(temp_reg);
3824   }
3825   Address super_check_addr(sub_klass, super_check_offset, Address::times_1, 0);
3826   cmpptr(super_klass, super_check_addr); // load displayed supertype
3827 
3828   // This check has worked decisively for primary supers.
3829   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
3830   // (Secondary supers are interfaces and very deeply nested subtypes.)
3831   // This works in the same check above because of a tricky aliasing
3832   // between the super_cache and the primary super display elements.
3833   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3834   // Note that the cache is updated below if it does not help us find
3835   // what we need immediately.
3836   // So if it was a primary super, we can just fail immediately.
3837   // Otherwise, it&#39;s the slow path for us (no success at this point).
3838 
3839   if (super_check_offset.is_register()) {
3840     local_jcc(Assembler::equal, *L_success);
3841     cmpl(super_check_offset.as_register(), sc_offset);
3842     if (L_failure == &amp;L_fallthrough) {
3843       local_jcc(Assembler::equal, *L_slow_path);
3844     } else {
3845       local_jcc(Assembler::notEqual, *L_failure);
3846       final_jmp(*L_slow_path);
3847     }
3848   } else if (super_check_offset.as_constant() == sc_offset) {
3849     // Need a slow path; fast failure is impossible.
3850     if (L_slow_path == &amp;L_fallthrough) {
3851       local_jcc(Assembler::equal, *L_success);
3852     } else {
3853       local_jcc(Assembler::notEqual, *L_slow_path);
3854       final_jmp(*L_success);
3855     }
3856   } else {
3857     // No slow path; it&#39;s a fast decision.
3858     if (L_failure == &amp;L_fallthrough) {
3859       local_jcc(Assembler::equal, *L_success);
3860     } else {
3861       local_jcc(Assembler::notEqual, *L_failure);
3862       final_jmp(*L_success);
3863     }
3864   }
3865 
3866   bind(L_fallthrough);
3867 
3868 #undef local_jcc
3869 #undef final_jmp
3870 }
3871 
3872 
3873 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
3874                                                    Register super_klass,
3875                                                    Register temp_reg,
3876                                                    Register temp2_reg,
3877                                                    Label* L_success,
3878                                                    Label* L_failure,
3879                                                    bool set_cond_codes) {
3880   assert_different_registers(sub_klass, super_klass, temp_reg);
3881   if (temp2_reg != noreg)
3882     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg);
3883 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
3884 
3885   Label L_fallthrough;
3886   int label_nulls = 0;
3887   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3888   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3889   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3890 
3891   // a couple of useful fields in sub_klass:
3892   int ss_offset = in_bytes(Klass::secondary_supers_offset());
3893   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3894   Address secondary_supers_addr(sub_klass, ss_offset);
3895   Address super_cache_addr(     sub_klass, sc_offset);
3896 
3897   // Do a linear scan of the secondary super-klass chain.
3898   // This code is rarely used, so simplicity is a virtue here.
3899   // The repne_scan instruction uses fixed registers, which we must spill.
3900   // Don&#39;t worry too much about pre-existing connections with the input regs.
3901 
3902   assert(sub_klass != rax, &quot;killed reg&quot;); // killed by mov(rax, super)
3903   assert(sub_klass != rcx, &quot;killed reg&quot;); // killed by lea(rcx, &amp;pst_counter)
3904 
3905   // Get super_klass value into rax (even if it was in rdi or rcx).
3906   bool pushed_rax = false, pushed_rcx = false, pushed_rdi = false;
3907   if (super_klass != rax || UseCompressedOops) {
3908     if (!IS_A_TEMP(rax)) { push(rax); pushed_rax = true; }
3909     mov(rax, super_klass);
3910   }
3911   if (!IS_A_TEMP(rcx)) { push(rcx); pushed_rcx = true; }
3912   if (!IS_A_TEMP(rdi)) { push(rdi); pushed_rdi = true; }
3913 
3914 #ifndef PRODUCT
3915   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
3916   ExternalAddress pst_counter_addr((address) pst_counter);
3917   NOT_LP64(  incrementl(pst_counter_addr) );
3918   LP64_ONLY( lea(rcx, pst_counter_addr) );
3919   LP64_ONLY( incrementl(Address(rcx, 0)) );
3920 #endif //PRODUCT
3921 
3922   // We will consult the secondary-super array.
3923   movptr(rdi, secondary_supers_addr);
3924   // Load the array length.  (Positive movl does right thing on LP64.)
3925   movl(rcx, Address(rdi, Array&lt;Klass*&gt;::length_offset_in_bytes()));
3926   // Skip to start of data.
3927   addptr(rdi, Array&lt;Klass*&gt;::base_offset_in_bytes());
3928 
3929   // Scan RCX words at [RDI] for an occurrence of RAX.
3930   // Set NZ/Z based on last compare.
3931   // Z flag value will not be set by &#39;repne&#39; if RCX == 0 since &#39;repne&#39; does
3932   // not change flags (only scas instruction which is repeated sets flags).
3933   // Set Z = 0 (not equal) before &#39;repne&#39; to indicate that class was not found.
3934 
3935     testptr(rax,rax); // Set Z = 0
3936     repne_scan();
3937 
3938   // Unspill the temp. registers:
3939   if (pushed_rdi)  pop(rdi);
3940   if (pushed_rcx)  pop(rcx);
3941   if (pushed_rax)  pop(rax);
3942 
3943   if (set_cond_codes) {
3944     // Special hack for the AD files:  rdi is guaranteed non-zero.
3945     assert(!pushed_rdi, &quot;rdi must be left non-NULL&quot;);
3946     // Also, the condition codes are properly set Z/NZ on succeed/failure.
3947   }
3948 
3949   if (L_failure == &amp;L_fallthrough)
3950         jccb(Assembler::notEqual, *L_failure);
3951   else  jcc(Assembler::notEqual, *L_failure);
3952 
3953   // Success.  Cache the super we found and proceed in triumph.
3954   movptr(super_cache_addr, super_klass);
3955 
3956   if (L_success != &amp;L_fallthrough) {
3957     jmp(*L_success);
3958   }
3959 
3960 #undef IS_A_TEMP
3961 
3962   bind(L_fallthrough);
3963 }
3964 
3965 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
3966   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
3967 
3968   Label L_fallthrough;
3969   if (L_fast_path == NULL) {
3970     L_fast_path = &amp;L_fallthrough;
3971   } else if (L_slow_path == NULL) {
3972     L_slow_path = &amp;L_fallthrough;
3973   }
3974 
3975   // Fast path check: class is fully initialized
3976   cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3977   jcc(Assembler::equal, *L_fast_path);
3978 
3979   // Fast path check: current thread is initializer thread
3980   cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));
3981   if (L_slow_path == &amp;L_fallthrough) {
3982     jcc(Assembler::equal, *L_fast_path);
3983     bind(*L_slow_path);
3984   } else if (L_fast_path == &amp;L_fallthrough) {
3985     jcc(Assembler::notEqual, *L_slow_path);
3986     bind(*L_fast_path);
3987   } else {
3988     Unimplemented();
3989   }
3990 }
3991 
3992 void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
3993   if (VM_Version::supports_cmov()) {
3994     cmovl(cc, dst, src);
3995   } else {
3996     Label L;
3997     jccb(negate_condition(cc), L);
3998     movl(dst, src);
3999     bind(L);
4000   }
4001 }
4002 
4003 void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
4004   if (VM_Version::supports_cmov()) {
4005     cmovl(cc, dst, src);
4006   } else {
4007     Label L;
4008     jccb(negate_condition(cc), L);
4009     movl(dst, src);
4010     bind(L);
4011   }
4012 }
4013 
4014 void MacroAssembler::_verify_oop(Register reg, const char* s, const char* file, int line) {
4015   if (!VerifyOops || VerifyAdapterSharing) {
4016     // Below address of the code string confuses VerifyAdapterSharing
4017     // because it may differ between otherwise equivalent adapters.
4018     return;
4019   }
4020 
4021   // Pass register number to verify_oop_subroutine
4022   const char* b = NULL;
4023   {
4024     ResourceMark rm;
4025     stringStream ss;
4026     ss.print(&quot;verify_oop: %s: %s (%s:%d)&quot;, reg-&gt;name(), s, file, line);
4027     b = code_string(ss.as_string());
4028   }
4029   BLOCK_COMMENT(&quot;verify_oop {&quot;);
4030 #ifdef _LP64
4031   push(rscratch1);                    // save r10, trashed by movptr()
4032 #endif
4033   push(rax);                          // save rax,
4034   push(reg);                          // pass register argument
4035   ExternalAddress buffer((address) b);
4036   // avoid using pushptr, as it modifies scratch registers
4037   // and our contract is not to modify anything
4038   movptr(rax, buffer.addr());
4039   push(rax);
4040   // call indirectly to solve generation ordering problem
4041   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
4042   call(rax);
4043   // Caller pops the arguments (oop, message) and restores rax, r10
4044   BLOCK_COMMENT(&quot;} verify_oop&quot;);
4045 }
4046 
4047 void MacroAssembler::vallones(XMMRegister dst, int vector_len) {
4048   if (UseAVX &gt; 2 &amp;&amp; (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl())) {
4049     vpternlogd(dst, 0xFF, dst, dst, vector_len);
4050   } else {
4051     assert(UseAVX &gt; 0, &quot;&quot;);
4052     vpcmpeqb(dst, dst, dst, vector_len);
4053   }
4054 }
4055 
4056 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
4057                                                       Register tmp,
4058                                                       int offset) {
4059   intptr_t value = *delayed_value_addr;
4060   if (value != 0)
4061     return RegisterOrConstant(value + offset);
4062 
4063   // load indirectly to solve generation ordering problem
4064   movptr(tmp, ExternalAddress((address) delayed_value_addr));
4065 
4066 #ifdef ASSERT
4067   { Label L;
4068     testptr(tmp, tmp);
4069     if (WizardMode) {
4070       const char* buf = NULL;
4071       {
4072         ResourceMark rm;
4073         stringStream ss;
4074         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
4075         buf = code_string(ss.as_string());
4076       }
4077       jcc(Assembler::notZero, L);
4078       STOP(buf);
4079     } else {
4080       jccb(Assembler::notZero, L);
4081       hlt();
4082     }
4083     bind(L);
4084   }
4085 #endif
4086 
4087   if (offset != 0)
4088     addptr(tmp, offset);
4089 
4090   return RegisterOrConstant(tmp);
4091 }
4092 
4093 
4094 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
4095                                          int extra_slot_offset) {
4096   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
4097   int stackElementSize = Interpreter::stackElementSize;
4098   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
4099 #ifdef ASSERT
4100   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
4101   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
4102 #endif
4103   Register             scale_reg    = noreg;
4104   Address::ScaleFactor scale_factor = Address::no_scale;
4105   if (arg_slot.is_constant()) {
4106     offset += arg_slot.as_constant() * stackElementSize;
4107   } else {
4108     scale_reg    = arg_slot.as_register();
4109     scale_factor = Address::times(stackElementSize);
4110   }
4111   offset += wordSize;           // return PC is on stack
4112   return Address(rsp, scale_reg, scale_factor, offset);
4113 }
4114 
4115 
4116 void MacroAssembler::_verify_oop_addr(Address addr, const char* s, const char* file, int line) {
4117   if (!VerifyOops || VerifyAdapterSharing) {
4118     // Below address of the code string confuses VerifyAdapterSharing
4119     // because it may differ between otherwise equivalent adapters.
4120     return;
4121   }
4122 
4123   // Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);
4124   // Pass register number to verify_oop_subroutine
4125   const char* b = NULL;
4126   {
4127     ResourceMark rm;
4128     stringStream ss;
4129     ss.print(&quot;verify_oop_addr: %s (%s:%d)&quot;, s, file, line);
4130     b = code_string(ss.as_string());
4131   }
4132 #ifdef _LP64
4133   push(rscratch1);                    // save r10, trashed by movptr()
4134 #endif
4135   push(rax);                          // save rax,
4136   // addr may contain rsp so we will have to adjust it based on the push
4137   // we just did (and on 64 bit we do two pushes)
4138   // NOTE: 64bit seemed to have had a bug in that it did movq(addr, rax); which
4139   // stores rax into addr which is backwards of what was intended.
4140   if (addr.uses(rsp)) {
4141     lea(rax, addr);
4142     pushptr(Address(rax, LP64_ONLY(2 *) BytesPerWord));
4143   } else {
4144     pushptr(addr);
4145   }
4146 
4147   ExternalAddress buffer((address) b);
4148   // pass msg argument
4149   // avoid using pushptr, as it modifies scratch registers
4150   // and our contract is not to modify anything
4151   movptr(rax, buffer.addr());
4152   push(rax);
4153 
4154   // call indirectly to solve generation ordering problem
4155   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
4156   call(rax);
4157   // Caller pops the arguments (addr, message) and restores rax, r10.
4158 }
4159 
4160 void MacroAssembler::verify_tlab() {
4161 #ifdef ASSERT
4162   if (UseTLAB &amp;&amp; VerifyOops) {
4163     Label next, ok;
4164     Register t1 = rsi;
4165     Register thread_reg = NOT_LP64(rbx) LP64_ONLY(r15_thread);
4166 
4167     push(t1);
4168     NOT_LP64(push(thread_reg));
4169     NOT_LP64(get_thread(thread_reg));
4170 
4171     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
4172     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_start_offset())));
4173     jcc(Assembler::aboveEqual, next);
4174     STOP(&quot;assert(top &gt;= start)&quot;);
4175     should_not_reach_here();
4176 
4177     bind(next);
4178     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_end_offset())));
4179     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
4180     jcc(Assembler::aboveEqual, ok);
4181     STOP(&quot;assert(top &lt;= end)&quot;);
4182     should_not_reach_here();
4183 
4184     bind(ok);
4185     NOT_LP64(pop(thread_reg));
4186     pop(t1);
4187   }
4188 #endif
4189 }
4190 
4191 class ControlWord {
4192  public:
4193   int32_t _value;
4194 
4195   int  rounding_control() const        { return  (_value &gt;&gt; 10) &amp; 3      ; }
4196   int  precision_control() const       { return  (_value &gt;&gt;  8) &amp; 3      ; }
4197   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
4198   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4199   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
4200   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4201   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
4202   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4203 
4204   void print() const {
4205     // rounding control
4206     const char* rc;
4207     switch (rounding_control()) {
4208       case 0: rc = &quot;round near&quot;; break;
4209       case 1: rc = &quot;round down&quot;; break;
4210       case 2: rc = &quot;round up  &quot;; break;
4211       case 3: rc = &quot;chop      &quot;; break;
4212     };
4213     // precision control
4214     const char* pc;
4215     switch (precision_control()) {
4216       case 0: pc = &quot;24 bits &quot;; break;
4217       case 1: pc = &quot;reserved&quot;; break;
4218       case 2: pc = &quot;53 bits &quot;; break;
4219       case 3: pc = &quot;64 bits &quot;; break;
4220     };
4221     // flags
4222     char f[9];
4223     f[0] = &#39; &#39;;
4224     f[1] = &#39; &#39;;
4225     f[2] = (precision   ()) ? &#39;P&#39; : &#39;p&#39;;
4226     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;u&#39;;
4227     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;o&#39;;
4228     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;z&#39;;
4229     f[6] = (denormalized()) ? &#39;D&#39; : &#39;d&#39;;
4230     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;i&#39;;
4231     f[8] = &#39;\x0&#39;;
4232     // output
4233     printf(&quot;%04x  masks = %s, %s, %s&quot;, _value &amp; 0xFFFF, f, rc, pc);
4234   }
4235 
4236 };
4237 
4238 class StatusWord {
4239  public:
4240   int32_t _value;
4241 
4242   bool busy() const                    { return ((_value &gt;&gt; 15) &amp; 1) != 0; }
4243   bool C3() const                      { return ((_value &gt;&gt; 14) &amp; 1) != 0; }
4244   bool C2() const                      { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4245   bool C1() const                      { return ((_value &gt;&gt;  9) &amp; 1) != 0; }
4246   bool C0() const                      { return ((_value &gt;&gt;  8) &amp; 1) != 0; }
4247   int  top() const                     { return  (_value &gt;&gt; 11) &amp; 7      ; }
4248   bool error_status() const            { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4249   bool stack_fault() const             { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4250   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
4251   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4252   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
4253   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4254   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
4255   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4256 
4257   void print() const {
4258     // condition codes
4259     char c[5];
4260     c[0] = (C3()) ? &#39;3&#39; : &#39;-&#39;;
4261     c[1] = (C2()) ? &#39;2&#39; : &#39;-&#39;;
4262     c[2] = (C1()) ? &#39;1&#39; : &#39;-&#39;;
4263     c[3] = (C0()) ? &#39;0&#39; : &#39;-&#39;;
4264     c[4] = &#39;\x0&#39;;
4265     // flags
4266     char f[9];
4267     f[0] = (error_status()) ? &#39;E&#39; : &#39;-&#39;;
4268     f[1] = (stack_fault ()) ? &#39;S&#39; : &#39;-&#39;;
4269     f[2] = (precision   ()) ? &#39;P&#39; : &#39;-&#39;;
4270     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;-&#39;;
4271     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;-&#39;;
4272     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;-&#39;;
4273     f[6] = (denormalized()) ? &#39;D&#39; : &#39;-&#39;;
4274     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;-&#39;;
4275     f[8] = &#39;\x0&#39;;
4276     // output
4277     printf(&quot;%04x  flags = %s, cc =  %s, top = %d&quot;, _value &amp; 0xFFFF, f, c, top());
4278   }
4279 
4280 };
4281 
4282 class TagWord {
4283  public:
4284   int32_t _value;
4285 
4286   int tag_at(int i) const              { return (_value &gt;&gt; (i*2)) &amp; 3; }
4287 
4288   void print() const {
4289     printf(&quot;%04x&quot;, _value &amp; 0xFFFF);
4290   }
4291 
4292 };
4293 
4294 class FPU_Register {
4295  public:
4296   int32_t _m0;
4297   int32_t _m1;
4298   int16_t _ex;
4299 
4300   bool is_indefinite() const           {
4301     return _ex == -1 &amp;&amp; _m1 == (int32_t)0xC0000000 &amp;&amp; _m0 == 0;
4302   }
4303 
4304   void print() const {
4305     char  sign = (_ex &lt; 0) ? &#39;-&#39; : &#39;+&#39;;
4306     const char* kind = (_ex == 0x7FFF || _ex == (int16_t)-1) ? &quot;NaN&quot; : &quot;   &quot;;
4307     printf(&quot;%c%04hx.%08x%08x  %s&quot;, sign, _ex, _m1, _m0, kind);
4308   };
4309 
4310 };
4311 
4312 class FPU_State {
4313  public:
4314   enum {
4315     register_size       = 10,
4316     number_of_registers =  8,
4317     register_mask       =  7
4318   };
4319 
4320   ControlWord  _control_word;
4321   StatusWord   _status_word;
4322   TagWord      _tag_word;
4323   int32_t      _error_offset;
4324   int32_t      _error_selector;
4325   int32_t      _data_offset;
4326   int32_t      _data_selector;
4327   int8_t       _register[register_size * number_of_registers];
4328 
4329   int tag_for_st(int i) const          { return _tag_word.tag_at((_status_word.top() + i) &amp; register_mask); }
4330   FPU_Register* st(int i) const        { return (FPU_Register*)&amp;_register[register_size * i]; }
4331 
4332   const char* tag_as_string(int tag) const {
4333     switch (tag) {
4334       case 0: return &quot;valid&quot;;
4335       case 1: return &quot;zero&quot;;
4336       case 2: return &quot;special&quot;;
4337       case 3: return &quot;empty&quot;;
4338     }
4339     ShouldNotReachHere();
4340     return NULL;
4341   }
4342 
4343   void print() const {
4344     // print computation registers
4345     { int t = _status_word.top();
4346       for (int i = 0; i &lt; number_of_registers; i++) {
4347         int j = (i - t) &amp; register_mask;
4348         printf(&quot;%c r%d = ST%d = &quot;, (j == 0 ? &#39;*&#39; : &#39; &#39;), i, j);
4349         st(j)-&gt;print();
4350         printf(&quot; %s\n&quot;, tag_as_string(_tag_word.tag_at(i)));
4351       }
4352     }
4353     printf(&quot;\n&quot;);
4354     // print control registers
4355     printf(&quot;ctrl = &quot;); _control_word.print(); printf(&quot;\n&quot;);
4356     printf(&quot;stat = &quot;); _status_word .print(); printf(&quot;\n&quot;);
4357     printf(&quot;tags = &quot;); _tag_word    .print(); printf(&quot;\n&quot;);
4358   }
4359 
4360 };
4361 
4362 class Flag_Register {
4363  public:
4364   int32_t _value;
4365 
4366   bool overflow() const                { return ((_value &gt;&gt; 11) &amp; 1) != 0; }
4367   bool direction() const               { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4368   bool sign() const                    { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4369   bool zero() const                    { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4370   bool auxiliary_carry() const         { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4371   bool parity() const                  { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4372   bool carry() const                   { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4373 
4374   void print() const {
4375     // flags
4376     char f[8];
4377     f[0] = (overflow       ()) ? &#39;O&#39; : &#39;-&#39;;
4378     f[1] = (direction      ()) ? &#39;D&#39; : &#39;-&#39;;
4379     f[2] = (sign           ()) ? &#39;S&#39; : &#39;-&#39;;
4380     f[3] = (zero           ()) ? &#39;Z&#39; : &#39;-&#39;;
4381     f[4] = (auxiliary_carry()) ? &#39;A&#39; : &#39;-&#39;;
4382     f[5] = (parity         ()) ? &#39;P&#39; : &#39;-&#39;;
4383     f[6] = (carry          ()) ? &#39;C&#39; : &#39;-&#39;;
4384     f[7] = &#39;\x0&#39;;
4385     // output
4386     printf(&quot;%08x  flags = %s&quot;, _value, f);
4387   }
4388 
4389 };
4390 
4391 class IU_Register {
4392  public:
4393   int32_t _value;
4394 
4395   void print() const {
4396     printf(&quot;%08x  %11d&quot;, _value, _value);
4397   }
4398 
4399 };
4400 
4401 class IU_State {
4402  public:
4403   Flag_Register _eflags;
4404   IU_Register   _rdi;
4405   IU_Register   _rsi;
4406   IU_Register   _rbp;
4407   IU_Register   _rsp;
4408   IU_Register   _rbx;
4409   IU_Register   _rdx;
4410   IU_Register   _rcx;
4411   IU_Register   _rax;
4412 
4413   void print() const {
4414     // computation registers
4415     printf(&quot;rax,  = &quot;); _rax.print(); printf(&quot;\n&quot;);
4416     printf(&quot;rbx,  = &quot;); _rbx.print(); printf(&quot;\n&quot;);
4417     printf(&quot;rcx  = &quot;); _rcx.print(); printf(&quot;\n&quot;);
4418     printf(&quot;rdx  = &quot;); _rdx.print(); printf(&quot;\n&quot;);
4419     printf(&quot;rdi  = &quot;); _rdi.print(); printf(&quot;\n&quot;);
4420     printf(&quot;rsi  = &quot;); _rsi.print(); printf(&quot;\n&quot;);
4421     printf(&quot;rbp,  = &quot;); _rbp.print(); printf(&quot;\n&quot;);
4422     printf(&quot;rsp  = &quot;); _rsp.print(); printf(&quot;\n&quot;);
4423     printf(&quot;\n&quot;);
4424     // control registers
4425     printf(&quot;flgs = &quot;); _eflags.print(); printf(&quot;\n&quot;);
4426   }
4427 };
4428 
4429 
4430 class CPU_State {
4431  public:
4432   FPU_State _fpu_state;
4433   IU_State  _iu_state;
4434 
4435   void print() const {
4436     printf(&quot;--------------------------------------------------\n&quot;);
4437     _iu_state .print();
4438     printf(&quot;\n&quot;);
4439     _fpu_state.print();
4440     printf(&quot;--------------------------------------------------\n&quot;);
4441   }
4442 
4443 };
4444 
4445 
4446 static void _print_CPU_state(CPU_State* state) {
4447   state-&gt;print();
4448 };
4449 
4450 
4451 void MacroAssembler::print_CPU_state() {
4452   push_CPU_state();
4453   push(rsp);                // pass CPU state
4454   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _print_CPU_state)));
4455   addptr(rsp, wordSize);       // discard argument
4456   pop_CPU_state();
4457 }
4458 
4459 
4460 #ifndef _LP64
4461 static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {
4462   static int counter = 0;
4463   FPU_State* fs = &amp;state-&gt;_fpu_state;
4464   counter++;
4465   // For leaf calls, only verify that the top few elements remain empty.
4466   // We only need 1 empty at the top for C2 code.
4467   if( stack_depth &lt; 0 ) {
4468     if( fs-&gt;tag_for_st(7) != 3 ) {
4469       printf(&quot;FPR7 not empty\n&quot;);
4470       state-&gt;print();
4471       assert(false, &quot;error&quot;);
4472       return false;
4473     }
4474     return true;                // All other stack states do not matter
4475   }
4476 
4477   assert((fs-&gt;_control_word._value &amp; 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,
4478          &quot;bad FPU control word&quot;);
4479 
4480   // compute stack depth
4481   int i = 0;
4482   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i)  &lt; 3) i++;
4483   int d = i;
4484   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i) == 3) i++;
4485   // verify findings
4486   if (i != FPU_State::number_of_registers) {
4487     // stack not contiguous
4488     printf(&quot;%s: stack not contiguous at ST%d\n&quot;, s, i);
4489     state-&gt;print();
4490     assert(false, &quot;error&quot;);
4491     return false;
4492   }
4493   // check if computed stack depth corresponds to expected stack depth
4494   if (stack_depth &lt; 0) {
4495     // expected stack depth is -stack_depth or less
4496     if (d &gt; -stack_depth) {
4497       // too many elements on the stack
4498       printf(&quot;%s: &lt;= %d stack elements expected but found %d\n&quot;, s, -stack_depth, d);
4499       state-&gt;print();
4500       assert(false, &quot;error&quot;);
4501       return false;
4502     }
4503   } else {
4504     // expected stack depth is stack_depth
4505     if (d != stack_depth) {
4506       // wrong stack depth
4507       printf(&quot;%s: %d stack elements expected but found %d\n&quot;, s, stack_depth, d);
4508       state-&gt;print();
4509       assert(false, &quot;error&quot;);
4510       return false;
4511     }
4512   }
4513   // everything is cool
4514   return true;
4515 }
4516 
4517 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {
4518   if (!VerifyFPU) return;
4519   push_CPU_state();
4520   push(rsp);                // pass CPU state
4521   ExternalAddress msg((address) s);
4522   // pass message string s
4523   pushptr(msg.addr());
4524   push(stack_depth);        // pass stack depth
4525   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));
4526   addptr(rsp, 3 * wordSize);   // discard arguments
4527   // check for error
4528   { Label L;
4529     testl(rax, rax);
4530     jcc(Assembler::notZero, L);
4531     int3();                  // break if error condition
4532     bind(L);
4533   }
4534   pop_CPU_state();
4535 }
4536 #endif // _LP64
4537 
4538 void MacroAssembler::restore_cpu_control_state_after_jni() {
4539   // Either restore the MXCSR register after returning from the JNI Call
4540   // or verify that it wasn&#39;t changed (with -Xcheck:jni flag).
4541   if (VM_Version::supports_sse()) {
4542     if (RestoreMXCSROnJNICalls) {
4543       ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));
4544     } else if (CheckJNICalls) {
4545       call(RuntimeAddress(StubRoutines::x86::verify_mxcsr_entry()));
4546     }
4547   }
4548   // Clear upper bits of YMM registers to avoid SSE &lt;-&gt; AVX transition penalty.
4549   vzeroupper();
4550   // Reset k1 to 0xffff.
4551 
4552 #ifdef COMPILER2
4553   if (PostLoopMultiversioning &amp;&amp; VM_Version::supports_evex()) {
4554     push(rcx);
4555     movl(rcx, 0xffff);
4556     kmovwl(k1, rcx);
4557     pop(rcx);
4558   }
4559 #endif // COMPILER2
4560 
4561 #ifndef _LP64
4562   // Either restore the x87 floating pointer control word after returning
4563   // from the JNI call or verify that it wasn&#39;t changed.
4564   if (CheckJNICalls) {
4565     call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));
4566   }
4567 #endif // _LP64
4568 }
4569 
4570 // ((OopHandle)result).resolve();
4571 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
4572   assert_different_registers(result, tmp);
4573 
4574   // Only 64 bit platforms support GCs that require a tmp register
4575   // Only IN_HEAP loads require a thread_tmp register
4576   // OopHandle::resolve is an indirection like jobject.
4577   access_load_at(T_OBJECT, IN_NATIVE,
4578                  result, Address(result, 0), tmp, /*tmp_thread*/noreg);
4579 }
4580 
4581 // ((WeakHandle)result).resolve();
4582 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
4583   assert_different_registers(rresult, rtmp);
4584   Label resolved;
4585 
4586   // A null weak handle resolves to null.
4587   cmpptr(rresult, 0);
4588   jcc(Assembler::equal, resolved);
4589 
4590   // Only 64 bit platforms support GCs that require a tmp register
4591   // Only IN_HEAP loads require a thread_tmp register
4592   // WeakHandle::resolve is an indirection like jweak.
4593   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
4594                  rresult, Address(rresult, 0), rtmp, /*tmp_thread*/noreg);
4595   bind(resolved);
4596 }
4597 
4598 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
4599   // get mirror
4600   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
4601   load_method_holder(mirror, method);
4602   movptr(mirror, Address(mirror, mirror_offset));
4603   resolve_oop_handle(mirror, tmp);
4604 }
4605 
4606 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
4607   load_method_holder(rresult, rmethod);
4608   movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
4609 }
4610 
<a name="11" id="anc11"></a><span class="line-added">4611 void MacroAssembler::load_method_holder(Register holder, Register method) {</span>
<span class="line-added">4612   movptr(holder, Address(method, Method::const_offset()));                      // ConstMethod*</span>
<span class="line-added">4613   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*</span>
<span class="line-added">4614   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*</span>
<span class="line-added">4615 }</span>
<span class="line-added">4616 </span>
4617 void MacroAssembler::load_metadata(Register dst, Register src) {
4618   if (UseCompressedClassPointers) {
4619     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4620   } else {
4621     movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4622   }
4623 }
4624 
<a name="12" id="anc12"></a><span class="line-modified">4625 void MacroAssembler::load_klass(Register dst, Register src, Register tmp) {</span>
<span class="line-modified">4626   assert_different_registers(src, tmp);</span>
<span class="line-modified">4627   assert_different_registers(dst, tmp);</span>




4628 #ifdef _LP64
4629   if (UseCompressedClassPointers) {
4630     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
<a name="13" id="anc13"></a><span class="line-modified">4631     decode_klass_not_null(dst, tmp);</span>
4632   } else
4633 #endif
4634   movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4635 }
4636 
<a name="14" id="anc14"></a><span class="line-modified">4637 void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {</span>
<span class="line-modified">4638   load_klass(dst, src, tmp);</span>
4639   movptr(dst, Address(dst, Klass::prototype_header_offset()));
4640 }
4641 
<a name="15" id="anc15"></a><span class="line-modified">4642 void MacroAssembler::store_klass(Register dst, Register src, Register tmp) {</span>
<span class="line-added">4643   assert_different_registers(src, tmp);</span>
<span class="line-added">4644   assert_different_registers(dst, tmp);</span>
4645 #ifdef _LP64
4646   if (UseCompressedClassPointers) {
<a name="16" id="anc16"></a><span class="line-modified">4647     encode_klass_not_null(src, tmp);</span>
4648     movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4649   } else
4650 #endif
4651     movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4652 }
4653 
4654 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
4655                                     Register tmp1, Register thread_tmp) {
4656   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4657   decorators = AccessInternal::decorator_fixup(decorators);
4658   bool as_raw = (decorators &amp; AS_RAW) != 0;
4659   if (as_raw) {
4660     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4661   } else {
4662     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4663   }
4664 }
4665 
4666 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
4667                                      Register tmp1, Register tmp2, Register tmp3) {
4668   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4669   decorators = AccessInternal::decorator_fixup(decorators);
4670   bool as_raw = (decorators &amp; AS_RAW) != 0;
4671   if (as_raw) {
4672     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);
4673   } else {
4674     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);
4675   }
4676 }
4677 
4678 void MacroAssembler::access_value_copy(DecoratorSet decorators, Register src, Register dst,
4679                                        Register value_klass) {
4680   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4681   bs-&gt;value_copy(this, decorators, src, dst, value_klass);
4682 }
4683 
4684 void MacroAssembler::first_field_offset(Register value_klass, Register offset) {
4685   movptr(offset, Address(value_klass, InstanceKlass::adr_valueklass_fixed_block_offset()));
4686   movl(offset, Address(offset, ValueKlass::first_field_offset_offset()));
4687 }
4688 
4689 void MacroAssembler::data_for_oop(Register oop, Register data, Register value_klass) {
4690   // ((address) (void*) o) + vk-&gt;first_field_offset();
4691   Register offset = (data == oop) ? rscratch1 : data;
4692   first_field_offset(value_klass, offset);
4693   if (data == oop) {
4694     addptr(data, offset);
4695   } else {
4696     lea(data, Address(oop, offset));
4697   }
4698 }
4699 
4700 void MacroAssembler::data_for_value_array_index(Register array, Register array_klass,
4701                                                 Register index, Register data) {
4702   assert(index != rcx, &quot;index needs to shift by rcx&quot;);
4703   assert_different_registers(array, array_klass, index);
4704   assert_different_registers(rcx, array, index);
4705 
4706   // array-&gt;base() + (index &lt;&lt; Klass::layout_helper_log2_element_size(lh));
4707   movl(rcx, Address(array_klass, Klass::layout_helper_offset()));
4708 
4709   // Klass::layout_helper_log2_element_size(lh)
4710   // (lh &gt;&gt; _lh_log2_element_size_shift) &amp; _lh_log2_element_size_mask;
4711   shrl(rcx, Klass::_lh_log2_element_size_shift);
4712   andl(rcx, Klass::_lh_log2_element_size_mask);
4713   shlptr(index); // index &lt;&lt; rcx
4714 
4715   lea(data, Address(array, index, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_VALUETYPE)));
4716 }
4717 
4718 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4719   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4720   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4721     decorators |= ACCESS_READ | ACCESS_WRITE;
4722   }
4723   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4724   return bs-&gt;resolve(this, decorators, obj);
4725 }
4726 
4727 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4728                                    Register thread_tmp, DecoratorSet decorators) {
4729   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4730 }
4731 
4732 // Doesn&#39;t do verfication, generates fixed size code
4733 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4734                                             Register thread_tmp, DecoratorSet decorators) {
4735   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4736 }
4737 
4738 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4739                                     Register tmp2, Register tmp3, DecoratorSet decorators) {
4740   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);
4741 }
4742 
4743 // Used for storing NULLs.
4744 void MacroAssembler::store_heap_oop_null(Address dst) {
4745   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);
4746 }
4747 
4748 #ifdef _LP64
4749 void MacroAssembler::store_klass_gap(Register dst, Register src) {
4750   if (UseCompressedClassPointers) {
4751     // Store to klass gap in destination
4752     movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
4753   }
4754 }
4755 
4756 #ifdef ASSERT
4757 void MacroAssembler::verify_heapbase(const char* msg) {
4758   assert (UseCompressedOops, &quot;should be compressed&quot;);
4759   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4760   if (CheckCompressedOops) {
4761     Label ok;
4762     push(rscratch1); // cmpptr trashes rscratch1
4763     cmpptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4764     jcc(Assembler::equal, ok);
4765     STOP(msg);
4766     bind(ok);
4767     pop(rscratch1);
4768   }
4769 }
4770 #endif
4771 
4772 // Algorithm must match oop.inline.hpp encode_heap_oop.
4773 void MacroAssembler::encode_heap_oop(Register r) {
4774 #ifdef ASSERT
4775   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
4776 #endif
4777   verify_oop_msg(r, &quot;broken oop in encode_heap_oop&quot;);
4778   if (CompressedOops::base() == NULL) {
4779     if (CompressedOops::shift() != 0) {
4780       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4781       shrq(r, LogMinObjAlignmentInBytes);
4782     }
4783     return;
4784   }
4785   testq(r, r);
4786   cmovq(Assembler::equal, r, r12_heapbase);
4787   subq(r, r12_heapbase);
4788   shrq(r, LogMinObjAlignmentInBytes);
4789 }
4790 
4791 void MacroAssembler::encode_heap_oop_not_null(Register r) {
4792 #ifdef ASSERT
4793   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
4794   if (CheckCompressedOops) {
4795     Label ok;
4796     testq(r, r);
4797     jcc(Assembler::notEqual, ok);
4798     STOP(&quot;null oop passed to encode_heap_oop_not_null&quot;);
4799     bind(ok);
4800   }
4801 #endif
4802   verify_oop_msg(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
4803   if (CompressedOops::base() != NULL) {
4804     subq(r, r12_heapbase);
4805   }
4806   if (CompressedOops::shift() != 0) {
4807     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4808     shrq(r, LogMinObjAlignmentInBytes);
4809   }
4810 }
4811 
4812 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
4813 #ifdef ASSERT
4814   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
4815   if (CheckCompressedOops) {
4816     Label ok;
4817     testq(src, src);
4818     jcc(Assembler::notEqual, ok);
4819     STOP(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
4820     bind(ok);
4821   }
4822 #endif
4823   verify_oop_msg(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
4824   if (dst != src) {
4825     movq(dst, src);
4826   }
4827   if (CompressedOops::base() != NULL) {
4828     subq(dst, r12_heapbase);
4829   }
4830   if (CompressedOops::shift() != 0) {
4831     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4832     shrq(dst, LogMinObjAlignmentInBytes);
4833   }
4834 }
4835 
4836 void  MacroAssembler::decode_heap_oop(Register r) {
4837 #ifdef ASSERT
4838   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
4839 #endif
4840   if (CompressedOops::base() == NULL) {
4841     if (CompressedOops::shift() != 0) {
4842       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4843       shlq(r, LogMinObjAlignmentInBytes);
4844     }
4845   } else {
4846     Label done;
4847     shlq(r, LogMinObjAlignmentInBytes);
4848     jccb(Assembler::equal, done);
4849     addq(r, r12_heapbase);
4850     bind(done);
4851   }
4852   verify_oop_msg(r, &quot;broken oop in decode_heap_oop&quot;);
4853 }
4854 
4855 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
4856   // Note: it will change flags
4857   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4858   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4859   // Cannot assert, unverified entry point counts instructions (see .ad file)
4860   // vtableStubs also counts instructions in pd_code_size_limit.
4861   // Also do not verify_oop as this is called by verify_oop.
4862   if (CompressedOops::shift() != 0) {
4863     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4864     shlq(r, LogMinObjAlignmentInBytes);
4865     if (CompressedOops::base() != NULL) {
4866       addq(r, r12_heapbase);
4867     }
4868   } else {
4869     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4870   }
4871 }
4872 
4873 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
4874   // Note: it will change flags
4875   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4876   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4877   // Cannot assert, unverified entry point counts instructions (see .ad file)
4878   // vtableStubs also counts instructions in pd_code_size_limit.
4879   // Also do not verify_oop as this is called by verify_oop.
4880   if (CompressedOops::shift() != 0) {
4881     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4882     if (LogMinObjAlignmentInBytes == Address::times_8) {
4883       leaq(dst, Address(r12_heapbase, src, Address::times_8, 0));
4884     } else {
4885       if (dst != src) {
4886         movq(dst, src);
4887       }
4888       shlq(dst, LogMinObjAlignmentInBytes);
4889       if (CompressedOops::base() != NULL) {
4890         addq(dst, r12_heapbase);
4891       }
4892     }
4893   } else {
4894     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4895     if (dst != src) {
4896       movq(dst, src);
4897     }
4898   }
4899 }
4900 
<a name="17" id="anc17"></a><span class="line-modified">4901 void MacroAssembler::encode_klass_not_null(Register r, Register tmp) {</span>
<span class="line-added">4902   assert_different_registers(r, tmp);</span>
4903   if (CompressedKlassPointers::base() != NULL) {
<a name="18" id="anc18"></a><span class="line-modified">4904     mov64(tmp, (int64_t)CompressedKlassPointers::base());</span>
<span class="line-modified">4905     subq(r, tmp);</span>


4906   }
4907   if (CompressedKlassPointers::shift() != 0) {
4908     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4909     shrq(r, LogKlassAlignmentInBytes);
4910   }
<a name="19" id="anc19"></a>




















4911 }
4912 
<a name="20" id="anc20"></a><span class="line-modified">4913 void MacroAssembler::encode_and_move_klass_not_null(Register dst, Register src) {</span>
<span class="line-modified">4914   assert_different_registers(src, dst);</span>




4915   if (CompressedKlassPointers::base() != NULL) {
<a name="21" id="anc21"></a><span class="line-modified">4916     mov64(dst, -(int64_t)CompressedKlassPointers::base());</span>
<span class="line-modified">4917     addq(dst, src);</span>
4918   } else {
<a name="22" id="anc22"></a><span class="line-modified">4919     movptr(dst, src);</span>
<span class="line-modified">4920   }</span>
<span class="line-added">4921   if (CompressedKlassPointers::shift() != 0) {</span>
<span class="line-added">4922     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);</span>
<span class="line-added">4923     shrq(dst, LogKlassAlignmentInBytes);</span>
4924   }
4925 }
4926 
4927 // !!! If the instructions that get generated here change then function
4928 // instr_size_for_decode_klass_not_null() needs to get updated.
<a name="23" id="anc23"></a><span class="line-modified">4929 void  MacroAssembler::decode_klass_not_null(Register r, Register tmp) {</span>
<span class="line-added">4930   assert_different_registers(r, tmp);</span>
4931   // Note: it will change flags
<a name="24" id="anc24"></a><span class="line-modified">4932   assert(UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);</span>

4933   // Cannot assert, unverified entry point counts instructions (see .ad file)
4934   // vtableStubs also counts instructions in pd_code_size_limit.
4935   // Also do not verify_oop as this is called by verify_oop.
4936   if (CompressedKlassPointers::shift() != 0) {
4937     assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4938     shlq(r, LogKlassAlignmentInBytes);
4939   }
<a name="25" id="anc25"></a><span class="line-modified">4940   if (CompressedKlassPointers::base() != NULL) {</span>
<span class="line-modified">4941     mov64(tmp, (int64_t)CompressedKlassPointers::base());</span>


4942     addq(r, tmp);
4943   }
4944 }
4945 
<a name="26" id="anc26"></a><span class="line-modified">4946 void  MacroAssembler::decode_and_move_klass_not_null(Register dst, Register src) {</span>
<span class="line-added">4947   assert_different_registers(src, dst);</span>
4948   // Note: it will change flags
4949   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
<a name="27" id="anc27"></a><span class="line-modified">4950   // Cannot assert, unverified entry point counts instructions (see .ad file)</span>
<span class="line-modified">4951   // vtableStubs also counts instructions in pd_code_size_limit.</span>
<span class="line-added">4952   // Also do not verify_oop as this is called by verify_oop.</span>
<span class="line-added">4953 </span>
<span class="line-added">4954   if (CompressedKlassPointers::base() == NULL &amp;&amp;</span>
<span class="line-added">4955       CompressedKlassPointers::shift() == 0) {</span>
<span class="line-added">4956     // The best case scenario is that there is no base or shift. Then it is already</span>
<span class="line-added">4957     // a pointer that needs nothing but a register rename.</span>
<span class="line-added">4958     movl(dst, src);</span>
4959   } else {
<a name="28" id="anc28"></a><span class="line-modified">4960     if (CompressedKlassPointers::base() != NULL) {</span>
<span class="line-modified">4961       mov64(dst, (int64_t)CompressedKlassPointers::base());</span>
<span class="line-modified">4962     } else {</span>
<span class="line-modified">4963       xorq(dst, dst);</span>
<span class="line-added">4964     }</span>
4965     if (CompressedKlassPointers::shift() != 0) {
4966       assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4967       assert(LogKlassAlignmentInBytes == Address::times_8, &quot;klass not aligned on 64bits?&quot;);
4968       leaq(dst, Address(dst, src, Address::times_8, 0));
4969     } else {
4970       addq(dst, src);
4971     }
4972   }
4973 }
4974 
4975 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4976   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4977   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4978   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4979   int oop_index = oop_recorder()-&gt;find_index(obj);
4980   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4981   mov_narrow_oop(dst, oop_index, rspec);
4982 }
4983 
4984 void  MacroAssembler::set_narrow_oop(Address dst, jobject obj) {
4985   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4986   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4987   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4988   int oop_index = oop_recorder()-&gt;find_index(obj);
4989   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4990   mov_narrow_oop(dst, oop_index, rspec);
4991 }
4992 
4993 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4994   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4995   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4996   int klass_index = oop_recorder()-&gt;find_index(k);
4997   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4998   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4999 }
5000 
5001 void  MacroAssembler::set_narrow_klass(Address dst, Klass* k) {
5002   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5003   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5004   int klass_index = oop_recorder()-&gt;find_index(k);
5005   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5006   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5007 }
5008 
5009 void  MacroAssembler::cmp_narrow_oop(Register dst, jobject obj) {
5010   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
5011   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
5012   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5013   int oop_index = oop_recorder()-&gt;find_index(obj);
5014   RelocationHolder rspec = oop_Relocation::spec(oop_index);
5015   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
5016 }
5017 
5018 void  MacroAssembler::cmp_narrow_oop(Address dst, jobject obj) {
5019   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
5020   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
5021   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5022   int oop_index = oop_recorder()-&gt;find_index(obj);
5023   RelocationHolder rspec = oop_Relocation::spec(oop_index);
5024   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
5025 }
5026 
5027 void  MacroAssembler::cmp_narrow_klass(Register dst, Klass* k) {
5028   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5029   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5030   int klass_index = oop_recorder()-&gt;find_index(k);
5031   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5032   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5033 }
5034 
5035 void  MacroAssembler::cmp_narrow_klass(Address dst, Klass* k) {
5036   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5037   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5038   int klass_index = oop_recorder()-&gt;find_index(k);
5039   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5040   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5041 }
5042 
5043 void MacroAssembler::reinit_heapbase() {
<a name="29" id="anc29"></a><span class="line-modified">5044   if (UseCompressedOops) {</span>
5045     if (Universe::heap() != NULL) {
5046       if (CompressedOops::base() == NULL) {
5047         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
5048       } else {
5049         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
5050       }
5051     } else {
5052       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
5053     }
5054   }
5055 }
5056 
5057 #endif // _LP64
5058 
5059 // C2 compiled method&#39;s prolog code.
5060 void MacroAssembler::verified_entry(Compile* C, int sp_inc) {
5061   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
5062   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
5063   bool fp_mode_24b = false;
5064   int stack_bang_size = C-&gt;output()-&gt;need_stack_bang(bangsize) ? bangsize : 0;
5065 
5066   // WARNING: Initial instruction MUST be 5 bytes or longer so that
5067   // NativeJump::patch_verified_entry will be able to patch out the entry
5068   // code safely. The push to verify stack depth is ok at 5 bytes,
5069   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
5070   // stack bang then we must use the 6 byte frame allocation even if
5071   // we have no frame. :-(
5072   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
5073 
5074   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
5075   // Remove word for return addr
5076   framesize -= wordSize;
5077   stack_bang_size -= wordSize;
5078 
5079   // Calls to C2R adapters often do not accept exceptional returns.
5080   // We require that their callers must bang for them.  But be careful, because
5081   // some VM calls (such as call site linkage) can use several kilobytes of
5082   // stack.  But the stack safety zone should account for that.
5083   // See bugs 4446381, 4468289, 4497237.
5084   if (stack_bang_size &gt; 0) {
5085     generate_stack_overflow_check(stack_bang_size);
5086 
5087     // We always push rbp, so that on return to interpreter rbp, will be
5088     // restored correctly and we can correct the stack.
5089     push(rbp);
5090     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
5091     if (PreserveFramePointer) {
5092       mov(rbp, rsp);
5093     }
5094     // Remove word for ebp
5095     framesize -= wordSize;
5096 
5097     // Create frame
5098     if (framesize) {
5099       subptr(rsp, framesize);
5100     }
5101   } else {
5102     // Create frame (force generation of a 4 byte immediate value)
5103     subptr_imm32(rsp, framesize);
5104 
5105     // Save RBP register now.
5106     framesize -= wordSize;
5107     movptr(Address(rsp, framesize), rbp);
5108     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
5109     if (PreserveFramePointer) {
5110       movptr(rbp, rsp);
5111       if (framesize &gt; 0) {
5112         addptr(rbp, framesize);
5113       }
5114     }
5115   }
5116 
5117   if (C-&gt;needs_stack_repair()) {
5118     // Save stack increment (also account for fixed framesize and rbp)
5119     assert((sp_inc &amp; (StackAlignmentInBytes-1)) == 0, &quot;stack increment not aligned&quot;);
5120     movptr(Address(rsp, C-&gt;output()-&gt;sp_inc_offset()), sp_inc + framesize + wordSize);
5121   }
5122 
5123   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
5124     framesize -= wordSize;
5125     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
5126   }
5127 
5128 #ifndef _LP64
5129   // If method sets FPU control word do it now
5130   if (fp_mode_24b) {
5131     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
5132   }
5133   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
5134     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
5135   }
5136 #endif
5137 
5138 #ifdef ASSERT
5139   if (VerifyStackAtCalls) {
5140     Label L;
5141     push(rax);
5142     mov(rax, rsp);
5143     andptr(rax, StackAlignmentInBytes-1);
5144     cmpptr(rax, StackAlignmentInBytes-wordSize);
5145     pop(rax);
5146     jcc(Assembler::equal, L);
5147     STOP(&quot;Stack is not properly aligned!&quot;);
5148     bind(L);
5149   }
5150 #endif
5151 }
5152 
5153 // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
5154 void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp) {
5155   // cnt - number of qwords (8-byte words).
5156   // base - start address, qword aligned.
5157   Label L_zero_64_bytes, L_loop, L_sloop, L_tail, L_end;
5158   movdq(xtmp, val);
5159   if (UseAVX &gt;= 2) {
5160     punpcklqdq(xtmp, xtmp);
5161     vinserti128_high(xtmp, xtmp);
5162   } else {
5163     punpcklqdq(xtmp, xtmp);
5164   }
5165   jmp(L_zero_64_bytes);
5166 
5167   BIND(L_loop);
5168   if (UseAVX &gt;= 2) {
5169     vmovdqu(Address(base,  0), xtmp);
5170     vmovdqu(Address(base, 32), xtmp);
5171   } else {
5172     movdqu(Address(base,  0), xtmp);
5173     movdqu(Address(base, 16), xtmp);
5174     movdqu(Address(base, 32), xtmp);
5175     movdqu(Address(base, 48), xtmp);
5176   }
5177   addptr(base, 64);
5178 
5179   BIND(L_zero_64_bytes);
5180   subptr(cnt, 8);
5181   jccb(Assembler::greaterEqual, L_loop);
5182   addptr(cnt, 4);
5183   jccb(Assembler::less, L_tail);
5184   // Copy trailing 32 bytes
5185   if (UseAVX &gt;= 2) {
5186     vmovdqu(Address(base, 0), xtmp);
5187   } else {
5188     movdqu(Address(base,  0), xtmp);
5189     movdqu(Address(base, 16), xtmp);
5190   }
5191   addptr(base, 32);
5192   subptr(cnt, 4);
5193 
5194   BIND(L_tail);
5195   addptr(cnt, 4);
5196   jccb(Assembler::lessEqual, L_end);
5197   decrement(cnt);
5198 
5199   BIND(L_sloop);
5200   movq(Address(base, 0), xtmp);
5201   addptr(base, 8);
5202   decrement(cnt);
5203   jccb(Assembler::greaterEqual, L_sloop);
5204   BIND(L_end);
5205 }
5206 
5207 int MacroAssembler::store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {
5208   // A value type might be returned. If fields are in registers we
5209   // need to allocate a value type instance and initialize it with
5210   // the value of the fields.
5211   Label skip;
5212   // We only need a new buffered value if a new one is not returned
5213   testptr(rax, 1);
5214   jcc(Assembler::zero, skip);
5215   int call_offset = -1;
5216 
5217 #ifdef _LP64
5218   Label slow_case;
5219 
5220   // Try to allocate a new buffered value (from the heap)
5221   if (UseTLAB) {
5222     // FIXME -- for smaller code, the inline allocation (and the slow case) should be moved inside the pack handler.
5223     if (vk != NULL) {
5224       // Called from C1, where the return type is statically known.
5225       movptr(rbx, (intptr_t)vk-&gt;get_ValueKlass());
5226       jint lh = vk-&gt;layout_helper();
5227       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);
5228       movl(r14, lh);
5229     } else {
5230       // Call from interpreter. RAX contains ((the ValueKlass* of the return type) | 0x01)
5231       mov(rbx, rax);
5232       andptr(rbx, -2);
5233       movl(r14, Address(rbx, Klass::layout_helper_offset()));
5234     }
5235 
5236     movptr(r13, Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())));
5237     lea(r14, Address(r13, r14, Address::times_1));
5238     cmpptr(r14, Address(r15_thread, in_bytes(JavaThread::tlab_end_offset())));
5239     jcc(Assembler::above, slow_case);
5240     movptr(Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())), r14);
5241     movptr(Address(r13, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::always_locked_prototype().value());
5242 
5243     xorl(rax, rax); // use zero reg to clear memory (shorter code)
5244     store_klass_gap(r13, rax);  // zero klass gap for compressed oops
5245 
5246     if (vk == NULL) {
5247       // store_klass corrupts rbx, so save it in rax for later use (interpreter case only).
5248       mov(rax, rbx);
5249     }
<a name="30" id="anc30"></a><span class="line-modified">5250     Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">5251     store_klass(r13, rbx, tmp_store_klass);  // klass</span>
5252 
5253     // We have our new buffered value, initialize its fields with a
5254     // value class specific handler
5255     if (vk != NULL) {
5256       // FIXME -- do the packing in-line to avoid the runtime call
5257       mov(rax, r13);
5258       call(RuntimeAddress(vk-&gt;pack_handler())); // no need for call info as this will not safepoint.
5259     } else {
5260       movptr(rbx, Address(rax, InstanceKlass::adr_valueklass_fixed_block_offset()));
5261       movptr(rbx, Address(rbx, ValueKlass::pack_handler_offset()));
5262       mov(rax, r13);
5263       call(rbx);
5264     }
5265     jmp(skip);
5266   }
5267 
5268   bind(slow_case);
5269   // We failed to allocate a new value, fall back to a runtime
5270   // call. Some oop field may be live in some registers but we can&#39;t
5271   // tell. That runtime call will take care of preserving them
5272   // across a GC if there&#39;s one.
5273 #endif
5274 
5275   if (from_interpreter) {
5276     super_call_VM_leaf(StubRoutines::store_value_type_fields_to_buf());
5277   } else {
5278     call(RuntimeAddress(StubRoutines::store_value_type_fields_to_buf()));
5279     call_offset = offset();
5280   }
5281 
5282   bind(skip);
5283   return call_offset;
5284 }
5285 
5286 
5287 // Move a value between registers/stack slots and update the reg_state
5288 bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {
5289   if (reg_state[to-&gt;value()] == reg_written) {
5290     return true; // Already written
5291   }
5292   if (from != to &amp;&amp; bt != T_VOID) {
5293     if (reg_state[to-&gt;value()] == reg_readonly) {
5294       return false; // Not yet writable
5295     }
5296     if (from-&gt;is_reg()) {
5297       if (to-&gt;is_reg()) {
5298         if (from-&gt;is_XMMRegister()) {
5299           if (bt == T_DOUBLE) {
5300             movdbl(to-&gt;as_XMMRegister(), from-&gt;as_XMMRegister());
5301           } else {
5302             assert(bt == T_FLOAT, &quot;must be float&quot;);
5303             movflt(to-&gt;as_XMMRegister(), from-&gt;as_XMMRegister());
5304           }
5305         } else {
5306           movq(to-&gt;as_Register(), from-&gt;as_Register());
5307         }
5308       } else {
5309         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5310         assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5311         Address to_addr = Address(rsp, st_off);
5312         if (from-&gt;is_XMMRegister()) {
5313           if (bt == T_DOUBLE) {
5314             movdbl(to_addr, from-&gt;as_XMMRegister());
5315           } else {
5316             assert(bt == T_FLOAT, &quot;must be float&quot;);
5317             movflt(to_addr, from-&gt;as_XMMRegister());
5318           }
5319         } else {
5320           movq(to_addr, from-&gt;as_Register());
5321         }
5322       }
5323     } else {
5324       Address from_addr = Address(rsp, from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset);
5325       if (to-&gt;is_reg()) {
5326         if (to-&gt;is_XMMRegister()) {
5327           if (bt == T_DOUBLE) {
5328             movdbl(to-&gt;as_XMMRegister(), from_addr);
5329           } else {
5330             assert(bt == T_FLOAT, &quot;must be float&quot;);
5331             movflt(to-&gt;as_XMMRegister(), from_addr);
5332           }
5333         } else {
5334           movq(to-&gt;as_Register(), from_addr);
5335         }
5336       } else {
5337         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5338         assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5339         movq(r13, from_addr);
5340         movq(Address(rsp, st_off), r13);
5341       }
5342     }
5343   }
5344   // Update register states
5345   reg_state[from-&gt;value()] = reg_writable;
5346   reg_state[to-&gt;value()] = reg_written;
5347   return true;
5348 }
5349 
5350 // Read all fields from a value type oop and store the values in registers/stack slots
5351 bool MacroAssembler::unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to,
5352                                          int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {
5353   Register fromReg = from-&gt;is_reg() ? from-&gt;as_Register() : noreg;
5354   assert(sig-&gt;at(sig_index)._bt == T_VOID, &quot;should be at end delimiter&quot;);
5355 
5356   int vt = 1;
5357   bool done = true;
5358   bool mark_done = true;
5359   do {
5360     sig_index--;
5361     BasicType bt = sig-&gt;at(sig_index)._bt;
5362     if (bt == T_VALUETYPE) {
5363       vt--;
5364     } else if (bt == T_VOID &amp;&amp;
5365                sig-&gt;at(sig_index-1)._bt != T_LONG &amp;&amp;
5366                sig-&gt;at(sig_index-1)._bt != T_DOUBLE) {
5367       vt++;
5368     } else if (SigEntry::is_reserved_entry(sig, sig_index)) {
5369       to_index--; // Ignore this
5370     } else {
5371       assert(to_index &gt;= 0, &quot;invalid to_index&quot;);
5372       VMRegPair pair_to = regs_to[to_index--];
5373       VMReg to = pair_to.first();
5374 
5375       if (bt == T_VOID) continue;
5376 
5377       int idx = (int)to-&gt;value();
5378       if (reg_state[idx] == reg_readonly) {
5379          if (idx != from-&gt;value()) {
5380            mark_done = false;
5381          }
5382          done = false;
5383          continue;
5384       } else if (reg_state[idx] == reg_written) {
5385         continue;
5386       } else {
5387         assert(reg_state[idx] == reg_writable, &quot;must be writable&quot;);
5388         reg_state[idx] = reg_written;
5389        }
5390 
5391       if (fromReg == noreg) {
5392         int st_off = from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5393         movq(r10, Address(rsp, st_off));
5394         fromReg = r10;
5395       }
5396 
5397       int off = sig-&gt;at(sig_index)._offset;
5398       assert(off &gt; 0, &quot;offset in object should be positive&quot;);
5399       bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
5400 
5401       Address fromAddr = Address(fromReg, off);
5402       bool is_signed = (bt != T_CHAR) &amp;&amp; (bt != T_BOOLEAN);
5403       if (!to-&gt;is_XMMRegister()) {
5404         Register dst = to-&gt;is_stack() ? r13 : to-&gt;as_Register();
5405         if (is_oop) {
5406           load_heap_oop(dst, fromAddr);
5407         } else {
5408           load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);
5409         }
5410         if (to-&gt;is_stack()) {
5411           int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5412           assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5413           movq(Address(rsp, st_off), dst);
5414         }
5415       } else {
5416         if (bt == T_DOUBLE) {
5417           movdbl(to-&gt;as_XMMRegister(), fromAddr);
5418         } else {
5419           assert(bt == T_FLOAT, &quot;must be float&quot;);
5420           movflt(to-&gt;as_XMMRegister(), fromAddr);
5421         }
5422       }
5423     }
5424   } while (vt != 0);
5425   if (mark_done &amp;&amp; reg_state[from-&gt;value()] != reg_written) {
5426     // This is okay because no one else will write to that slot
5427     reg_state[from-&gt;value()] = reg_writable;
5428   }
5429   return done;
5430 }
5431 
5432 // Pack fields back into a value type oop
5433 bool MacroAssembler::pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
5434                                        VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
5435                                        int ret_off, int extra_stack_offset) {
5436   assert(sig-&gt;at(sig_index)._bt == T_VALUETYPE, &quot;should be at end delimiter&quot;);
5437   assert(to-&gt;is_valid(), &quot;must be&quot;);
5438 
5439   if (reg_state[to-&gt;value()] == reg_written) {
5440     skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5441     return true; // Already written
5442   }
5443 
5444   Register val_array = rax;
5445   Register val_obj_tmp = r11;
5446   Register from_reg_tmp = r14; // Be careful with r14 because it&#39;s used for spilling
5447   Register tmp1 = r10;
5448   Register tmp2 = r13;
5449   Register tmp3 = rbx;
5450   Register val_obj = to-&gt;is_stack() ? val_obj_tmp : to-&gt;as_Register();
5451 
5452   if (reg_state[to-&gt;value()] == reg_readonly) {
5453     if (!is_reg_in_unpacked_fields(sig, sig_index, to, regs_from, regs_from_count, from_index)) {
5454       skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5455       return false; // Not yet writable
5456     }
5457     val_obj = val_obj_tmp;
5458   }
5459 
5460   int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_VALUETYPE);
5461   load_heap_oop(val_obj, Address(val_array, index));
5462 
5463   ScalarizedValueArgsStream stream(sig, sig_index, regs_from, regs_from_count, from_index);
5464   VMRegPair from_pair;
5465   BasicType bt;
5466   while (stream.next(from_pair, bt)) {
5467     int off = sig-&gt;at(stream.sig_cc_index())._offset;
5468     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
5469     bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
5470     size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;
5471 
5472     VMReg from_r1 = from_pair.first();
5473     VMReg from_r2 = from_pair.second();
5474 
5475     // Pack the scalarized field into the value object.
5476     Address dst(val_obj, off);
5477     if (!from_r1-&gt;is_XMMRegister()) {
5478       Register from_reg;
5479       if (from_r1-&gt;is_stack()) {
5480         from_reg = from_reg_tmp;
5481         int ld_off = from_r1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5482         load_sized_value(from_reg, Address(rsp, ld_off), size_in_bytes, /* is_signed */ false);
5483       } else {
5484         from_reg = from_r1-&gt;as_Register();
5485       }
5486       assert_different_registers(dst.base(), from_reg, tmp1, tmp2, tmp3, val_array);
5487       if (is_oop) {
5488         store_heap_oop(dst, from_reg, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);
5489       } else {
5490         store_sized_value(dst, from_reg, size_in_bytes);
5491       }
5492     } else {
5493       if (from_r2-&gt;is_valid()) {
5494         movdbl(dst, from_r1-&gt;as_XMMRegister());
5495       } else {
5496         movflt(dst, from_r1-&gt;as_XMMRegister());
5497       }
5498     }
5499     reg_state[from_r1-&gt;value()] = reg_writable;
5500   }
5501   sig_index = stream.sig_cc_index();
5502   from_index = stream.regs_cc_index();
5503 
5504   assert(reg_state[to-&gt;value()] == reg_writable, &quot;must have already been read&quot;);
5505   bool success = move_helper(val_obj-&gt;as_VMReg(), to, T_OBJECT, reg_state, ret_off, extra_stack_offset);
5506   assert(success, &quot;to register must be writeable&quot;);
5507 
5508   return true;
5509 }
5510 
5511 // Unpack all value type arguments passed as oops
5512 void MacroAssembler::unpack_value_args(Compile* C, bool receiver_only) {
5513   int sp_inc = unpack_value_args_common(C, receiver_only);
5514   // Emit code for verified entry and save increment for stack repair on return
5515   verified_entry(C, sp_inc);
5516 }
5517 
5518 void MacroAssembler::shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,
5519                                         BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
5520                                         int args_passed, int args_on_stack, VMRegPair* regs,
5521                                         int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc) {
5522   // Check if we need to extend the stack for packing/unpacking
5523   if (sp_inc &gt; 0 &amp;&amp; !is_packing) {
5524     // Save the return address, adjust the stack (make sure it is properly
5525     // 16-byte aligned) and copy the return address to the new top of the stack.
5526     // (Note: C1 does this in C1_MacroAssembler::scalarized_entry).
5527     pop(r13);
5528     subptr(rsp, sp_inc);
5529     push(r13);
5530   }
5531 
5532   int ret_off; // make sure we don&#39;t overwrite the return address
5533   if (is_packing) {
5534     // For C1 code, the VVEP doesn&#39;t have reserved slots, so we store the returned address at
5535     // rsp[0] during shuffling.
5536     ret_off = 0;
5537   } else {
5538     // C2 code ensures that sp_inc is a reserved slot.
5539     ret_off = sp_inc;
5540   }
5541 
5542   shuffle_value_args_common(is_packing, receiver_only, extra_stack_offset,
5543                             sig_bt, sig_cc,
5544                             args_passed, args_on_stack, regs,
5545                             args_passed_to, args_on_stack_to, regs_to,
5546                             sp_inc, ret_off);
5547 }
5548 
5549 VMReg MacroAssembler::spill_reg_for(VMReg reg) {
5550   return reg-&gt;is_XMMRegister() ? xmm8-&gt;as_VMReg() : r14-&gt;as_VMReg();
5551 }
5552 
5553 void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset) {
5554   assert((initial_framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
5555   if (needs_stack_repair) {
5556     movq(rbp, Address(rsp, initial_framesize));
5557     addq(rsp, Address(rsp, sp_inc_offset));
5558   } else {
5559     if (initial_framesize &gt; 0) {
5560       addq(rsp, initial_framesize);
5561     }
5562     pop(rbp);
5563   }
5564 }
5565 
5566 void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only) {
5567   // cnt - number of qwords (8-byte words).
5568   // base - start address, qword aligned.
5569   // is_large - if optimizers know cnt is larger than InitArrayShortSize
5570   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
5571   assert(val==rax,   &quot;tmp register must be eax for rep stos&quot;);
5572   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
5573   assert(InitArrayShortSize % BytesPerLong == 0,
5574     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
5575 
5576   Label DONE;
5577 
5578   if (!is_large) {
5579     Label LOOP, LONG;
5580     cmpptr(cnt, InitArrayShortSize/BytesPerLong);
5581     jccb(Assembler::greater, LONG);
5582 
5583     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
5584 
5585     decrement(cnt);
5586     jccb(Assembler::negative, DONE); // Zero length
5587 
5588     // Use individual pointer-sized stores for small counts:
5589     BIND(LOOP);
5590     movptr(Address(base, cnt, Address::times_ptr), val);
5591     decrement(cnt);
5592     jccb(Assembler::greaterEqual, LOOP);
5593     jmpb(DONE);
5594 
5595     BIND(LONG);
5596   }
5597 
5598   // Use longer rep-prefixed ops for non-small counts:
5599   if (UseFastStosb &amp;&amp; !word_copy_only) {
5600     shlptr(cnt, 3); // convert to number of bytes
5601     rep_stosb();
5602   } else if (UseXMMForObjInit) {
5603     xmm_clear_mem(base, cnt, val, xtmp);
5604   } else {
5605     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
5606     rep_stos();
5607   }
5608 
5609   BIND(DONE);
5610 }
5611 
5612 void MacroAssembler::generate_fill(BasicType t, bool aligned,
5613                                    Register to, Register value, Register count,
5614                                    Register rtmp, XMMRegister xtmp) {
5615   ShortBranchVerifier sbv(this);
5616   assert_different_registers(to, value, count, rtmp);
5617   Label L_exit;
5618   Label L_fill_2_bytes, L_fill_4_bytes;
5619 
5620   int shift = -1;
5621   switch (t) {
5622     case T_BYTE:
5623       shift = 2;
5624       break;
5625     case T_SHORT:
5626       shift = 1;
5627       break;
5628     case T_INT:
5629       shift = 0;
5630       break;
5631     default: ShouldNotReachHere();
5632   }
5633 
5634   if (t == T_BYTE) {
5635     andl(value, 0xff);
5636     movl(rtmp, value);
5637     shll(rtmp, 8);
5638     orl(value, rtmp);
5639   }
5640   if (t == T_SHORT) {
5641     andl(value, 0xffff);
5642   }
5643   if (t == T_BYTE || t == T_SHORT) {
5644     movl(rtmp, value);
5645     shll(rtmp, 16);
5646     orl(value, rtmp);
5647   }
5648 
5649   cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) fill by element
5650   jcc(Assembler::below, L_fill_4_bytes); // use unsigned cmp
5651   if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {
5652     Label L_skip_align2;
5653     // align source address at 4 bytes address boundary
5654     if (t == T_BYTE) {
5655       Label L_skip_align1;
5656       // One byte misalignment happens only for byte arrays
5657       testptr(to, 1);
5658       jccb(Assembler::zero, L_skip_align1);
5659       movb(Address(to, 0), value);
5660       increment(to);
5661       decrement(count);
5662       BIND(L_skip_align1);
5663     }
5664     // Two bytes misalignment happens only for byte and short (char) arrays
5665     testptr(to, 2);
5666     jccb(Assembler::zero, L_skip_align2);
5667     movw(Address(to, 0), value);
5668     addptr(to, 2);
5669     subl(count, 1&lt;&lt;(shift-1));
5670     BIND(L_skip_align2);
5671   }
5672   if (UseSSE &lt; 2) {
5673     Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5674     // Fill 32-byte chunks
5675     subl(count, 8 &lt;&lt; shift);
5676     jcc(Assembler::less, L_check_fill_8_bytes);
5677     align(16);
5678 
5679     BIND(L_fill_32_bytes_loop);
5680 
5681     for (int i = 0; i &lt; 32; i += 4) {
5682       movl(Address(to, i), value);
5683     }
5684 
5685     addptr(to, 32);
5686     subl(count, 8 &lt;&lt; shift);
5687     jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5688     BIND(L_check_fill_8_bytes);
5689     addl(count, 8 &lt;&lt; shift);
5690     jccb(Assembler::zero, L_exit);
5691     jmpb(L_fill_8_bytes);
5692 
5693     //
5694     // length is too short, just fill qwords
5695     //
5696     BIND(L_fill_8_bytes_loop);
5697     movl(Address(to, 0), value);
5698     movl(Address(to, 4), value);
5699     addptr(to, 8);
5700     BIND(L_fill_8_bytes);
5701     subl(count, 1 &lt;&lt; (shift + 1));
5702     jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5703     // fall through to fill 4 bytes
5704   } else {
5705     Label L_fill_32_bytes;
5706     if (!UseUnalignedLoadStores) {
5707       // align to 8 bytes, we know we are 4 byte aligned to start
5708       testptr(to, 4);
5709       jccb(Assembler::zero, L_fill_32_bytes);
5710       movl(Address(to, 0), value);
5711       addptr(to, 4);
5712       subl(count, 1&lt;&lt;shift);
5713     }
5714     BIND(L_fill_32_bytes);
5715     {
5716       assert( UseSSE &gt;= 2, &quot;supported cpu only&quot; );
5717       Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5718       movdl(xtmp, value);
5719       if (UseAVX &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
5720         Label L_check_fill_32_bytes;
5721         if (UseAVX &gt; 2) {
5722           // Fill 64-byte chunks
5723           Label L_fill_64_bytes_loop_avx3, L_check_fill_64_bytes_avx2;
5724 
5725           // If number of bytes to fill &lt; AVX3Threshold, perform fill using AVX2
5726           cmpl(count, AVX3Threshold);
5727           jccb(Assembler::below, L_check_fill_64_bytes_avx2);
5728 
5729           vpbroadcastd(xtmp, xtmp, Assembler::AVX_512bit);
5730 
5731           subl(count, 16 &lt;&lt; shift);
5732           jccb(Assembler::less, L_check_fill_32_bytes);
5733           align(16);
5734 
5735           BIND(L_fill_64_bytes_loop_avx3);
5736           evmovdqul(Address(to, 0), xtmp, Assembler::AVX_512bit);
5737           addptr(to, 64);
5738           subl(count, 16 &lt;&lt; shift);
5739           jcc(Assembler::greaterEqual, L_fill_64_bytes_loop_avx3);
5740           jmpb(L_check_fill_32_bytes);
5741 
5742           BIND(L_check_fill_64_bytes_avx2);
5743         }
5744         // Fill 64-byte chunks
5745         Label L_fill_64_bytes_loop;
5746         vpbroadcastd(xtmp, xtmp, Assembler::AVX_256bit);
5747 
5748         subl(count, 16 &lt;&lt; shift);
5749         jcc(Assembler::less, L_check_fill_32_bytes);
5750         align(16);
5751 
5752         BIND(L_fill_64_bytes_loop);
5753         vmovdqu(Address(to, 0), xtmp);
5754         vmovdqu(Address(to, 32), xtmp);
5755         addptr(to, 64);
5756         subl(count, 16 &lt;&lt; shift);
5757         jcc(Assembler::greaterEqual, L_fill_64_bytes_loop);
5758 
5759         BIND(L_check_fill_32_bytes);
5760         addl(count, 8 &lt;&lt; shift);
5761         jccb(Assembler::less, L_check_fill_8_bytes);
5762         vmovdqu(Address(to, 0), xtmp);
5763         addptr(to, 32);
5764         subl(count, 8 &lt;&lt; shift);
5765 
5766         BIND(L_check_fill_8_bytes);
5767         // clean upper bits of YMM registers
5768         movdl(xtmp, value);
5769         pshufd(xtmp, xtmp, 0);
5770       } else {
5771         // Fill 32-byte chunks
5772         pshufd(xtmp, xtmp, 0);
5773 
5774         subl(count, 8 &lt;&lt; shift);
5775         jcc(Assembler::less, L_check_fill_8_bytes);
5776         align(16);
5777 
5778         BIND(L_fill_32_bytes_loop);
5779 
5780         if (UseUnalignedLoadStores) {
5781           movdqu(Address(to, 0), xtmp);
5782           movdqu(Address(to, 16), xtmp);
5783         } else {
5784           movq(Address(to, 0), xtmp);
5785           movq(Address(to, 8), xtmp);
5786           movq(Address(to, 16), xtmp);
5787           movq(Address(to, 24), xtmp);
5788         }
5789 
5790         addptr(to, 32);
5791         subl(count, 8 &lt;&lt; shift);
5792         jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5793 
5794         BIND(L_check_fill_8_bytes);
5795       }
5796       addl(count, 8 &lt;&lt; shift);
5797       jccb(Assembler::zero, L_exit);
5798       jmpb(L_fill_8_bytes);
5799 
5800       //
5801       // length is too short, just fill qwords
5802       //
5803       BIND(L_fill_8_bytes_loop);
5804       movq(Address(to, 0), xtmp);
5805       addptr(to, 8);
5806       BIND(L_fill_8_bytes);
5807       subl(count, 1 &lt;&lt; (shift + 1));
5808       jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5809     }
5810   }
5811   // fill trailing 4 bytes
5812   BIND(L_fill_4_bytes);
5813   testl(count, 1&lt;&lt;shift);
5814   jccb(Assembler::zero, L_fill_2_bytes);
5815   movl(Address(to, 0), value);
5816   if (t == T_BYTE || t == T_SHORT) {
5817     Label L_fill_byte;
5818     addptr(to, 4);
5819     BIND(L_fill_2_bytes);
5820     // fill trailing 2 bytes
5821     testl(count, 1&lt;&lt;(shift-1));
5822     jccb(Assembler::zero, L_fill_byte);
5823     movw(Address(to, 0), value);
5824     if (t == T_BYTE) {
5825       addptr(to, 2);
5826       BIND(L_fill_byte);
5827       // fill trailing byte
5828       testl(count, 1);
5829       jccb(Assembler::zero, L_exit);
5830       movb(Address(to, 0), value);
5831     } else {
5832       BIND(L_fill_byte);
5833     }
5834   } else {
5835     BIND(L_fill_2_bytes);
5836   }
5837   BIND(L_exit);
5838 }
5839 
5840 // encode char[] to byte[] in ISO_8859_1
5841    //@HotSpotIntrinsicCandidate
5842    //private static int implEncodeISOArray(byte[] sa, int sp,
5843    //byte[] da, int dp, int len) {
5844    //  int i = 0;
5845    //  for (; i &lt; len; i++) {
5846    //    char c = StringUTF16.getChar(sa, sp++);
5847    //    if (c &gt; &#39;\u00FF&#39;)
5848    //      break;
5849    //    da[dp++] = (byte)c;
5850    //  }
5851    //  return i;
5852    //}
5853 void MacroAssembler::encode_iso_array(Register src, Register dst, Register len,
5854   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
5855   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
5856   Register tmp5, Register result) {
5857 
5858   // rsi: src
5859   // rdi: dst
5860   // rdx: len
5861   // rcx: tmp5
5862   // rax: result
5863   ShortBranchVerifier sbv(this);
5864   assert_different_registers(src, dst, len, tmp5, result);
5865   Label L_done, L_copy_1_char, L_copy_1_char_exit;
5866 
5867   // set result
5868   xorl(result, result);
5869   // check for zero length
5870   testl(len, len);
5871   jcc(Assembler::zero, L_done);
5872 
5873   movl(result, len);
5874 
5875   // Setup pointers
5876   lea(src, Address(src, len, Address::times_2)); // char[]
5877   lea(dst, Address(dst, len, Address::times_1)); // byte[]
5878   negptr(len);
5879 
5880   if (UseSSE42Intrinsics || UseAVX &gt;= 2) {
5881     Label L_copy_8_chars, L_copy_8_chars_exit;
5882     Label L_chars_16_check, L_copy_16_chars, L_copy_16_chars_exit;
5883 
5884     if (UseAVX &gt;= 2) {
5885       Label L_chars_32_check, L_copy_32_chars, L_copy_32_chars_exit;
5886       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5887       movdl(tmp1Reg, tmp5);
5888       vpbroadcastd(tmp1Reg, tmp1Reg, Assembler::AVX_256bit);
5889       jmp(L_chars_32_check);
5890 
5891       bind(L_copy_32_chars);
5892       vmovdqu(tmp3Reg, Address(src, len, Address::times_2, -64));
5893       vmovdqu(tmp4Reg, Address(src, len, Address::times_2, -32));
5894       vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5895       vptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5896       jccb(Assembler::notZero, L_copy_32_chars_exit);
5897       vpackuswb(tmp3Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5898       vpermq(tmp4Reg, tmp3Reg, 0xD8, /* vector_len */ 1);
5899       vmovdqu(Address(dst, len, Address::times_1, -32), tmp4Reg);
5900 
5901       bind(L_chars_32_check);
5902       addptr(len, 32);
5903       jcc(Assembler::lessEqual, L_copy_32_chars);
5904 
5905       bind(L_copy_32_chars_exit);
5906       subptr(len, 16);
5907       jccb(Assembler::greater, L_copy_16_chars_exit);
5908 
5909     } else if (UseSSE42Intrinsics) {
5910       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5911       movdl(tmp1Reg, tmp5);
5912       pshufd(tmp1Reg, tmp1Reg, 0);
5913       jmpb(L_chars_16_check);
5914     }
5915 
5916     bind(L_copy_16_chars);
5917     if (UseAVX &gt;= 2) {
5918       vmovdqu(tmp2Reg, Address(src, len, Address::times_2, -32));
5919       vptest(tmp2Reg, tmp1Reg);
5920       jcc(Assembler::notZero, L_copy_16_chars_exit);
5921       vpackuswb(tmp2Reg, tmp2Reg, tmp1Reg, /* vector_len */ 1);
5922       vpermq(tmp3Reg, tmp2Reg, 0xD8, /* vector_len */ 1);
5923     } else {
5924       if (UseAVX &gt; 0) {
5925         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5926         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5927         vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 0);
5928       } else {
5929         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5930         por(tmp2Reg, tmp3Reg);
5931         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5932         por(tmp2Reg, tmp4Reg);
5933       }
5934       ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5935       jccb(Assembler::notZero, L_copy_16_chars_exit);
5936       packuswb(tmp3Reg, tmp4Reg);
5937     }
5938     movdqu(Address(dst, len, Address::times_1, -16), tmp3Reg);
5939 
5940     bind(L_chars_16_check);
5941     addptr(len, 16);
5942     jcc(Assembler::lessEqual, L_copy_16_chars);
5943 
5944     bind(L_copy_16_chars_exit);
5945     if (UseAVX &gt;= 2) {
5946       // clean upper bits of YMM registers
5947       vpxor(tmp2Reg, tmp2Reg);
5948       vpxor(tmp3Reg, tmp3Reg);
5949       vpxor(tmp4Reg, tmp4Reg);
5950       movdl(tmp1Reg, tmp5);
5951       pshufd(tmp1Reg, tmp1Reg, 0);
5952     }
5953     subptr(len, 8);
5954     jccb(Assembler::greater, L_copy_8_chars_exit);
5955 
5956     bind(L_copy_8_chars);
5957     movdqu(tmp3Reg, Address(src, len, Address::times_2, -16));
5958     ptest(tmp3Reg, tmp1Reg);
5959     jccb(Assembler::notZero, L_copy_8_chars_exit);
5960     packuswb(tmp3Reg, tmp1Reg);
5961     movq(Address(dst, len, Address::times_1, -8), tmp3Reg);
5962     addptr(len, 8);
5963     jccb(Assembler::lessEqual, L_copy_8_chars);
5964 
5965     bind(L_copy_8_chars_exit);
5966     subptr(len, 8);
5967     jccb(Assembler::zero, L_done);
5968   }
5969 
5970   bind(L_copy_1_char);
5971   load_unsigned_short(tmp5, Address(src, len, Address::times_2, 0));
5972   testl(tmp5, 0xff00);      // check if Unicode char
5973   jccb(Assembler::notZero, L_copy_1_char_exit);
5974   movb(Address(dst, len, Address::times_1, 0), tmp5);
5975   addptr(len, 1);
5976   jccb(Assembler::less, L_copy_1_char);
5977 
5978   bind(L_copy_1_char_exit);
5979   addptr(result, len); // len is negative count of not processed elements
5980 
5981   bind(L_done);
5982 }
5983 
5984 #ifdef _LP64
5985 /**
5986  * Helper for multiply_to_len().
5987  */
5988 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
5989   addq(dest_lo, src1);
5990   adcq(dest_hi, 0);
5991   addq(dest_lo, src2);
5992   adcq(dest_hi, 0);
5993 }
5994 
5995 /**
5996  * Multiply 64 bit by 64 bit first loop.
5997  */
5998 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
5999                                            Register y, Register y_idx, Register z,
6000                                            Register carry, Register product,
6001                                            Register idx, Register kdx) {
6002   //
6003   //  jlong carry, x[], y[], z[];
6004   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
6005   //    huge_128 product = y[idx] * x[xstart] + carry;
6006   //    z[kdx] = (jlong)product;
6007   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
6008   //  }
6009   //  z[xstart] = carry;
6010   //
6011 
6012   Label L_first_loop, L_first_loop_exit;
6013   Label L_one_x, L_one_y, L_multiply;
6014 
6015   decrementl(xstart);
6016   jcc(Assembler::negative, L_one_x);
6017 
6018   movq(x_xstart, Address(x, xstart, Address::times_4,  0));
6019   rorq(x_xstart, 32); // convert big-endian to little-endian
6020 
6021   bind(L_first_loop);
6022   decrementl(idx);
6023   jcc(Assembler::negative, L_first_loop_exit);
6024   decrementl(idx);
6025   jcc(Assembler::negative, L_one_y);
6026   movq(y_idx, Address(y, idx, Address::times_4,  0));
6027   rorq(y_idx, 32); // convert big-endian to little-endian
6028   bind(L_multiply);
6029   movq(product, x_xstart);
6030   mulq(y_idx); // product(rax) * y_idx -&gt; rdx:rax
6031   addq(product, carry);
6032   adcq(rdx, 0);
6033   subl(kdx, 2);
6034   movl(Address(z, kdx, Address::times_4,  4), product);
6035   shrq(product, 32);
6036   movl(Address(z, kdx, Address::times_4,  0), product);
6037   movq(carry, rdx);
6038   jmp(L_first_loop);
6039 
6040   bind(L_one_y);
6041   movl(y_idx, Address(y,  0));
6042   jmp(L_multiply);
6043 
6044   bind(L_one_x);
6045   movl(x_xstart, Address(x,  0));
6046   jmp(L_first_loop);
6047 
6048   bind(L_first_loop_exit);
6049 }
6050 
6051 /**
6052  * Multiply 64 bit by 64 bit and add 128 bit.
6053  */
6054 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y, Register z,
6055                                             Register yz_idx, Register idx,
6056                                             Register carry, Register product, int offset) {
6057   //     huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
6058   //     z[kdx] = (jlong)product;
6059 
6060   movq(yz_idx, Address(y, idx, Address::times_4,  offset));
6061   rorq(yz_idx, 32); // convert big-endian to little-endian
6062   movq(product, x_xstart);
6063   mulq(yz_idx);     // product(rax) * yz_idx -&gt; rdx:product(rax)
6064   movq(yz_idx, Address(z, idx, Address::times_4,  offset));
6065   rorq(yz_idx, 32); // convert big-endian to little-endian
6066 
6067   add2_with_carry(rdx, product, carry, yz_idx);
6068 
6069   movl(Address(z, idx, Address::times_4,  offset+4), product);
6070   shrq(product, 32);
6071   movl(Address(z, idx, Address::times_4,  offset), product);
6072 
6073 }
6074 
6075 /**
6076  * Multiply 128 bit by 128 bit. Unrolled inner loop.
6077  */
6078 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
6079                                              Register yz_idx, Register idx, Register jdx,
6080                                              Register carry, Register product,
6081                                              Register carry2) {
6082   //   jlong carry, x[], y[], z[];
6083   //   int kdx = ystart+1;
6084   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
6085   //     huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
6086   //     z[kdx+idx+1] = (jlong)product;
6087   //     jlong carry2  = (jlong)(product &gt;&gt;&gt; 64);
6088   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
6089   //     z[kdx+idx] = (jlong)product;
6090   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
6091   //   }
6092   //   idx += 2;
6093   //   if (idx &gt; 0) {
6094   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
6095   //     z[kdx+idx] = (jlong)product;
6096   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
6097   //   }
6098   //
6099 
6100   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
6101 
6102   movl(jdx, idx);
6103   andl(jdx, 0xFFFFFFFC);
6104   shrl(jdx, 2);
6105 
6106   bind(L_third_loop);
6107   subl(jdx, 1);
6108   jcc(Assembler::negative, L_third_loop_exit);
6109   subl(idx, 4);
6110 
6111   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
6112   movq(carry2, rdx);
6113 
6114   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
6115   movq(carry, rdx);
6116   jmp(L_third_loop);
6117 
6118   bind (L_third_loop_exit);
6119 
6120   andl (idx, 0x3);
6121   jcc(Assembler::zero, L_post_third_loop_done);
6122 
6123   Label L_check_1;
6124   subl(idx, 2);
6125   jcc(Assembler::negative, L_check_1);
6126 
6127   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
6128   movq(carry, rdx);
6129 
6130   bind (L_check_1);
6131   addl (idx, 0x2);
6132   andl (idx, 0x1);
6133   subl(idx, 1);
6134   jcc(Assembler::negative, L_post_third_loop_done);
6135 
6136   movl(yz_idx, Address(y, idx, Address::times_4,  0));
6137   movq(product, x_xstart);
6138   mulq(yz_idx); // product(rax) * yz_idx -&gt; rdx:product(rax)
6139   movl(yz_idx, Address(z, idx, Address::times_4,  0));
6140 
6141   add2_with_carry(rdx, product, yz_idx, carry);
6142 
6143   movl(Address(z, idx, Address::times_4,  0), product);
6144   shrq(product, 32);
6145 
6146   shlq(rdx, 32);
6147   orq(product, rdx);
6148   movq(carry, product);
6149 
6150   bind(L_post_third_loop_done);
6151 }
6152 
6153 /**
6154  * Multiply 128 bit by 128 bit using BMI2. Unrolled inner loop.
6155  *
6156  */
6157 void MacroAssembler::multiply_128_x_128_bmi2_loop(Register y, Register z,
6158                                                   Register carry, Register carry2,
6159                                                   Register idx, Register jdx,
6160                                                   Register yz_idx1, Register yz_idx2,
6161                                                   Register tmp, Register tmp3, Register tmp4) {
6162   assert(UseBMI2Instructions, &quot;should be used only when BMI2 is available&quot;);
6163 
6164   //   jlong carry, x[], y[], z[];
6165   //   int kdx = ystart+1;
6166   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
6167   //     huge_128 tmp3 = (y[idx+1] * rdx) + z[kdx+idx+1] + carry;
6168   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
6169   //     huge_128 tmp4 = (y[idx]   * rdx) + z[kdx+idx] + carry2;
6170   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
6171   //     z[kdx+idx+1] = (jlong)tmp3;
6172   //     z[kdx+idx] = (jlong)tmp4;
6173   //   }
6174   //   idx += 2;
6175   //   if (idx &gt; 0) {
6176   //     yz_idx1 = (y[idx] * rdx) + z[kdx+idx] + carry;
6177   //     z[kdx+idx] = (jlong)yz_idx1;
6178   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
6179   //   }
6180   //
6181 
6182   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
6183 
6184   movl(jdx, idx);
6185   andl(jdx, 0xFFFFFFFC);
6186   shrl(jdx, 2);
6187 
6188   bind(L_third_loop);
6189   subl(jdx, 1);
6190   jcc(Assembler::negative, L_third_loop_exit);
6191   subl(idx, 4);
6192 
6193   movq(yz_idx1,  Address(y, idx, Address::times_4,  8));
6194   rorxq(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
6195   movq(yz_idx2, Address(y, idx, Address::times_4,  0));
6196   rorxq(yz_idx2, yz_idx2, 32);
6197 
6198   mulxq(tmp4, tmp3, yz_idx1);  //  yz_idx1 * rdx -&gt; tmp4:tmp3
6199   mulxq(carry2, tmp, yz_idx2); //  yz_idx2 * rdx -&gt; carry2:tmp
6200 
6201   movq(yz_idx1,  Address(z, idx, Address::times_4,  8));
6202   rorxq(yz_idx1, yz_idx1, 32);
6203   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
6204   rorxq(yz_idx2, yz_idx2, 32);
6205 
6206   if (VM_Version::supports_adx()) {
6207     adcxq(tmp3, carry);
6208     adoxq(tmp3, yz_idx1);
6209 
6210     adcxq(tmp4, tmp);
6211     adoxq(tmp4, yz_idx2);
6212 
6213     movl(carry, 0); // does not affect flags
6214     adcxq(carry2, carry);
6215     adoxq(carry2, carry);
6216   } else {
6217     add2_with_carry(tmp4, tmp3, carry, yz_idx1);
6218     add2_with_carry(carry2, tmp4, tmp, yz_idx2);
6219   }
6220   movq(carry, carry2);
6221 
6222   movl(Address(z, idx, Address::times_4, 12), tmp3);
6223   shrq(tmp3, 32);
6224   movl(Address(z, idx, Address::times_4,  8), tmp3);
6225 
6226   movl(Address(z, idx, Address::times_4,  4), tmp4);
6227   shrq(tmp4, 32);
6228   movl(Address(z, idx, Address::times_4,  0), tmp4);
6229 
6230   jmp(L_third_loop);
6231 
6232   bind (L_third_loop_exit);
6233 
6234   andl (idx, 0x3);
6235   jcc(Assembler::zero, L_post_third_loop_done);
6236 
6237   Label L_check_1;
6238   subl(idx, 2);
6239   jcc(Assembler::negative, L_check_1);
6240 
6241   movq(yz_idx1, Address(y, idx, Address::times_4,  0));
6242   rorxq(yz_idx1, yz_idx1, 32);
6243   mulxq(tmp4, tmp3, yz_idx1); //  yz_idx1 * rdx -&gt; tmp4:tmp3
6244   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
6245   rorxq(yz_idx2, yz_idx2, 32);
6246 
6247   add2_with_carry(tmp4, tmp3, carry, yz_idx2);
6248 
6249   movl(Address(z, idx, Address::times_4,  4), tmp3);
6250   shrq(tmp3, 32);
6251   movl(Address(z, idx, Address::times_4,  0), tmp3);
6252   movq(carry, tmp4);
6253 
6254   bind (L_check_1);
6255   addl (idx, 0x2);
6256   andl (idx, 0x1);
6257   subl(idx, 1);
6258   jcc(Assembler::negative, L_post_third_loop_done);
6259   movl(tmp4, Address(y, idx, Address::times_4,  0));
6260   mulxq(carry2, tmp3, tmp4);  //  tmp4 * rdx -&gt; carry2:tmp3
6261   movl(tmp4, Address(z, idx, Address::times_4,  0));
6262 
6263   add2_with_carry(carry2, tmp3, tmp4, carry);
6264 
6265   movl(Address(z, idx, Address::times_4,  0), tmp3);
6266   shrq(tmp3, 32);
6267 
6268   shlq(carry2, 32);
6269   orq(tmp3, carry2);
6270   movq(carry, tmp3);
6271 
6272   bind(L_post_third_loop_done);
6273 }
6274 
6275 /**
6276  * Code for BigInteger::multiplyToLen() instrinsic.
6277  *
6278  * rdi: x
6279  * rax: xlen
6280  * rsi: y
6281  * rcx: ylen
6282  * r8:  z
6283  * r11: zlen
6284  * r12: tmp1
6285  * r13: tmp2
6286  * r14: tmp3
6287  * r15: tmp4
6288  * rbx: tmp5
6289  *
6290  */
6291 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
6292                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {
6293   ShortBranchVerifier sbv(this);
6294   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);
6295 
6296   push(tmp1);
6297   push(tmp2);
6298   push(tmp3);
6299   push(tmp4);
6300   push(tmp5);
6301 
6302   push(xlen);
6303   push(zlen);
6304 
6305   const Register idx = tmp1;
6306   const Register kdx = tmp2;
6307   const Register xstart = tmp3;
6308 
6309   const Register y_idx = tmp4;
6310   const Register carry = tmp5;
6311   const Register product  = xlen;
6312   const Register x_xstart = zlen;  // reuse register
6313 
6314   // First Loop.
6315   //
6316   //  final static long LONG_MASK = 0xffffffffL;
6317   //  int xstart = xlen - 1;
6318   //  int ystart = ylen - 1;
6319   //  long carry = 0;
6320   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
6321   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
6322   //    z[kdx] = (int)product;
6323   //    carry = product &gt;&gt;&gt; 32;
6324   //  }
6325   //  z[xstart] = (int)carry;
6326   //
6327 
6328   movl(idx, ylen);      // idx = ylen;
6329   movl(kdx, zlen);      // kdx = xlen+ylen;
6330   xorq(carry, carry);   // carry = 0;
6331 
6332   Label L_done;
6333 
6334   movl(xstart, xlen);
6335   decrementl(xstart);
6336   jcc(Assembler::negative, L_done);
6337 
6338   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
6339 
6340   Label L_second_loop;
6341   testl(kdx, kdx);
6342   jcc(Assembler::zero, L_second_loop);
6343 
6344   Label L_carry;
6345   subl(kdx, 1);
6346   jcc(Assembler::zero, L_carry);
6347 
6348   movl(Address(z, kdx, Address::times_4,  0), carry);
6349   shrq(carry, 32);
6350   subl(kdx, 1);
6351 
6352   bind(L_carry);
6353   movl(Address(z, kdx, Address::times_4,  0), carry);
6354 
6355   // Second and third (nested) loops.
6356   //
6357   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
6358   //   carry = 0;
6359   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
6360   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
6361   //                    (z[k] &amp; LONG_MASK) + carry;
6362   //     z[k] = (int)product;
6363   //     carry = product &gt;&gt;&gt; 32;
6364   //   }
6365   //   z[i] = (int)carry;
6366   // }
6367   //
6368   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
6369 
6370   const Register jdx = tmp1;
6371 
6372   bind(L_second_loop);
6373   xorl(carry, carry);    // carry = 0;
6374   movl(jdx, ylen);       // j = ystart+1
6375 
6376   subl(xstart, 1);       // i = xstart-1;
6377   jcc(Assembler::negative, L_done);
6378 
6379   push (z);
6380 
6381   Label L_last_x;
6382   lea(z, Address(z, xstart, Address::times_4, 4)); // z = z + k - j
6383   subl(xstart, 1);       // i = xstart-1;
6384   jcc(Assembler::negative, L_last_x);
6385 
6386   if (UseBMI2Instructions) {
6387     movq(rdx,  Address(x, xstart, Address::times_4,  0));
6388     rorxq(rdx, rdx, 32); // convert big-endian to little-endian
6389   } else {
6390     movq(x_xstart, Address(x, xstart, Address::times_4,  0));
6391     rorq(x_xstart, 32);  // convert big-endian to little-endian
6392   }
6393 
6394   Label L_third_loop_prologue;
6395   bind(L_third_loop_prologue);
6396 
6397   push (x);
6398   push (xstart);
6399   push (ylen);
6400 
6401 
6402   if (UseBMI2Instructions) {
6403     multiply_128_x_128_bmi2_loop(y, z, carry, x, jdx, ylen, product, tmp2, x_xstart, tmp3, tmp4);
6404   } else { // !UseBMI2Instructions
6405     multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
6406   }
6407 
6408   pop(ylen);
6409   pop(xlen);
6410   pop(x);
6411   pop(z);
6412 
6413   movl(tmp3, xlen);
6414   addl(tmp3, 1);
6415   movl(Address(z, tmp3, Address::times_4,  0), carry);
6416   subl(tmp3, 1);
6417   jccb(Assembler::negative, L_done);
6418 
6419   shrq(carry, 32);
6420   movl(Address(z, tmp3, Address::times_4,  0), carry);
6421   jmp(L_second_loop);
6422 
6423   // Next infrequent code is moved outside loops.
6424   bind(L_last_x);
6425   if (UseBMI2Instructions) {
6426     movl(rdx, Address(x,  0));
6427   } else {
6428     movl(x_xstart, Address(x,  0));
6429   }
6430   jmp(L_third_loop_prologue);
6431 
6432   bind(L_done);
6433 
6434   pop(zlen);
6435   pop(xlen);
6436 
6437   pop(tmp5);
6438   pop(tmp4);
6439   pop(tmp3);
6440   pop(tmp2);
6441   pop(tmp1);
6442 }
6443 
6444 void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
6445   Register result, Register tmp1, Register tmp2, XMMRegister rymm0, XMMRegister rymm1, XMMRegister rymm2){
6446   assert(UseSSE42Intrinsics, &quot;SSE4.2 must be enabled.&quot;);
6447   Label VECTOR16_LOOP, VECTOR8_LOOP, VECTOR4_LOOP;
6448   Label VECTOR8_TAIL, VECTOR4_TAIL;
6449   Label VECTOR32_NOT_EQUAL, VECTOR16_NOT_EQUAL, VECTOR8_NOT_EQUAL, VECTOR4_NOT_EQUAL;
6450   Label SAME_TILL_END, DONE;
6451   Label BYTES_LOOP, BYTES_TAIL, BYTES_NOT_EQUAL;
6452 
6453   //scale is in rcx in both Win64 and Unix
6454   ShortBranchVerifier sbv(this);
6455 
6456   shlq(length);
6457   xorq(result, result);
6458 
6459   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp;
6460       VM_Version::supports_avx512vlbw()) {
6461     Label VECTOR64_LOOP, VECTOR64_NOT_EQUAL, VECTOR32_TAIL;
6462 
6463     cmpq(length, 64);
6464     jcc(Assembler::less, VECTOR32_TAIL);
6465 
6466     movq(tmp1, length);
6467     andq(tmp1, 0x3F);      // tail count
6468     andq(length, ~(0x3F)); //vector count
6469 
6470     bind(VECTOR64_LOOP);
6471     // AVX512 code to compare 64 byte vectors.
6472     evmovdqub(rymm0, Address(obja, result), Assembler::AVX_512bit);
6473     evpcmpeqb(k7, rymm0, Address(objb, result), Assembler::AVX_512bit);
6474     kortestql(k7, k7);
6475     jcc(Assembler::aboveEqual, VECTOR64_NOT_EQUAL);     // mismatch
6476     addq(result, 64);
6477     subq(length, 64);
6478     jccb(Assembler::notZero, VECTOR64_LOOP);
6479 
6480     //bind(VECTOR64_TAIL);
6481     testq(tmp1, tmp1);
6482     jcc(Assembler::zero, SAME_TILL_END);
6483 
6484     //bind(VECTOR64_TAIL);
6485     // AVX512 code to compare upto 63 byte vectors.
6486     mov64(tmp2, 0xFFFFFFFFFFFFFFFF);
6487     shlxq(tmp2, tmp2, tmp1);
6488     notq(tmp2);
6489     kmovql(k3, tmp2);
6490 
6491     evmovdqub(rymm0, k3, Address(obja, result), Assembler::AVX_512bit);
6492     evpcmpeqb(k7, k3, rymm0, Address(objb, result), Assembler::AVX_512bit);
6493 
6494     ktestql(k7, k3);
6495     jcc(Assembler::below, SAME_TILL_END);     // not mismatch
6496 
6497     bind(VECTOR64_NOT_EQUAL);
6498     kmovql(tmp1, k7);
6499     notq(tmp1);
6500     tzcntq(tmp1, tmp1);
6501     addq(result, tmp1);
6502     shrq(result);
6503     jmp(DONE);
6504     bind(VECTOR32_TAIL);
6505   }
6506 
6507   cmpq(length, 8);
6508   jcc(Assembler::equal, VECTOR8_LOOP);
6509   jcc(Assembler::less, VECTOR4_TAIL);
6510 
6511   if (UseAVX &gt;= 2) {
6512     Label VECTOR16_TAIL, VECTOR32_LOOP;
6513 
6514     cmpq(length, 16);
6515     jcc(Assembler::equal, VECTOR16_LOOP);
6516     jcc(Assembler::less, VECTOR8_LOOP);
6517 
6518     cmpq(length, 32);
6519     jccb(Assembler::less, VECTOR16_TAIL);
6520 
6521     subq(length, 32);
6522     bind(VECTOR32_LOOP);
6523     vmovdqu(rymm0, Address(obja, result));
6524     vmovdqu(rymm1, Address(objb, result));
6525     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_256bit);
6526     vptest(rymm2, rymm2);
6527     jcc(Assembler::notZero, VECTOR32_NOT_EQUAL);//mismatch found
6528     addq(result, 32);
6529     subq(length, 32);
6530     jcc(Assembler::greaterEqual, VECTOR32_LOOP);
6531     addq(length, 32);
6532     jcc(Assembler::equal, SAME_TILL_END);
6533     //falling through if less than 32 bytes left //close the branch here.
6534 
6535     bind(VECTOR16_TAIL);
6536     cmpq(length, 16);
6537     jccb(Assembler::less, VECTOR8_TAIL);
6538     bind(VECTOR16_LOOP);
6539     movdqu(rymm0, Address(obja, result));
6540     movdqu(rymm1, Address(objb, result));
6541     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_128bit);
6542     ptest(rymm2, rymm2);
6543     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
6544     addq(result, 16);
6545     subq(length, 16);
6546     jcc(Assembler::equal, SAME_TILL_END);
6547     //falling through if less than 16 bytes left
6548   } else {//regular intrinsics
6549 
6550     cmpq(length, 16);
6551     jccb(Assembler::less, VECTOR8_TAIL);
6552 
6553     subq(length, 16);
6554     bind(VECTOR16_LOOP);
6555     movdqu(rymm0, Address(obja, result));
6556     movdqu(rymm1, Address(objb, result));
6557     pxor(rymm0, rymm1);
6558     ptest(rymm0, rymm0);
6559     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
6560     addq(result, 16);
6561     subq(length, 16);
6562     jccb(Assembler::greaterEqual, VECTOR16_LOOP);
6563     addq(length, 16);
6564     jcc(Assembler::equal, SAME_TILL_END);
6565     //falling through if less than 16 bytes left
6566   }
6567 
6568   bind(VECTOR8_TAIL);
6569   cmpq(length, 8);
6570   jccb(Assembler::less, VECTOR4_TAIL);
6571   bind(VECTOR8_LOOP);
6572   movq(tmp1, Address(obja, result));
6573   movq(tmp2, Address(objb, result));
6574   xorq(tmp1, tmp2);
6575   testq(tmp1, tmp1);
6576   jcc(Assembler::notZero, VECTOR8_NOT_EQUAL);//mismatch found
6577   addq(result, 8);
6578   subq(length, 8);
6579   jcc(Assembler::equal, SAME_TILL_END);
6580   //falling through if less than 8 bytes left
6581 
6582   bind(VECTOR4_TAIL);
6583   cmpq(length, 4);
6584   jccb(Assembler::less, BYTES_TAIL);
6585   bind(VECTOR4_LOOP);
6586   movl(tmp1, Address(obja, result));
6587   xorl(tmp1, Address(objb, result));
6588   testl(tmp1, tmp1);
6589   jcc(Assembler::notZero, VECTOR4_NOT_EQUAL);//mismatch found
6590   addq(result, 4);
6591   subq(length, 4);
6592   jcc(Assembler::equal, SAME_TILL_END);
6593   //falling through if less than 4 bytes left
6594 
6595   bind(BYTES_TAIL);
6596   bind(BYTES_LOOP);
6597   load_unsigned_byte(tmp1, Address(obja, result));
6598   load_unsigned_byte(tmp2, Address(objb, result));
6599   xorl(tmp1, tmp2);
6600   testl(tmp1, tmp1);
6601   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6602   decq(length);
6603   jcc(Assembler::zero, SAME_TILL_END);
6604   incq(result);
6605   load_unsigned_byte(tmp1, Address(obja, result));
6606   load_unsigned_byte(tmp2, Address(objb, result));
6607   xorl(tmp1, tmp2);
6608   testl(tmp1, tmp1);
6609   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6610   decq(length);
6611   jcc(Assembler::zero, SAME_TILL_END);
6612   incq(result);
6613   load_unsigned_byte(tmp1, Address(obja, result));
6614   load_unsigned_byte(tmp2, Address(objb, result));
6615   xorl(tmp1, tmp2);
6616   testl(tmp1, tmp1);
6617   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6618   jmp(SAME_TILL_END);
6619 
6620   if (UseAVX &gt;= 2) {
6621     bind(VECTOR32_NOT_EQUAL);
6622     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_256bit);
6623     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_256bit);
6624     vpxor(rymm0, rymm0, rymm2, Assembler::AVX_256bit);
6625     vpmovmskb(tmp1, rymm0);
6626     bsfq(tmp1, tmp1);
6627     addq(result, tmp1);
6628     shrq(result);
6629     jmp(DONE);
6630   }
6631 
6632   bind(VECTOR16_NOT_EQUAL);
6633   if (UseAVX &gt;= 2) {
6634     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_128bit);
6635     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_128bit);
6636     pxor(rymm0, rymm2);
6637   } else {
6638     pcmpeqb(rymm2, rymm2);
6639     pxor(rymm0, rymm1);
6640     pcmpeqb(rymm0, rymm1);
6641     pxor(rymm0, rymm2);
6642   }
6643   pmovmskb(tmp1, rymm0);
6644   bsfq(tmp1, tmp1);
6645   addq(result, tmp1);
6646   shrq(result);
6647   jmpb(DONE);
6648 
6649   bind(VECTOR8_NOT_EQUAL);
6650   bind(VECTOR4_NOT_EQUAL);
6651   bsfq(tmp1, tmp1);
6652   shrq(tmp1, 3);
6653   addq(result, tmp1);
6654   bind(BYTES_NOT_EQUAL);
6655   shrq(result);
6656   jmpb(DONE);
6657 
6658   bind(SAME_TILL_END);
6659   mov64(result, -1);
6660 
6661   bind(DONE);
6662 }
6663 
6664 //Helper functions for square_to_len()
6665 
6666 /**
6667  * Store the squares of x[], right shifted one bit (divided by 2) into z[]
6668  * Preserves x and z and modifies rest of the registers.
6669  */
6670 void MacroAssembler::square_rshift(Register x, Register xlen, Register z, Register tmp1, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6671   // Perform square and right shift by 1
6672   // Handle odd xlen case first, then for even xlen do the following
6673   // jlong carry = 0;
6674   // for (int j=0, i=0; j &lt; xlen; j+=2, i+=4) {
6675   //     huge_128 product = x[j:j+1] * x[j:j+1];
6676   //     z[i:i+1] = (carry &lt;&lt; 63) | (jlong)(product &gt;&gt;&gt; 65);
6677   //     z[i+2:i+3] = (jlong)(product &gt;&gt;&gt; 1);
6678   //     carry = (jlong)product;
6679   // }
6680 
6681   xorq(tmp5, tmp5);     // carry
6682   xorq(rdxReg, rdxReg);
6683   xorl(tmp1, tmp1);     // index for x
6684   xorl(tmp4, tmp4);     // index for z
6685 
6686   Label L_first_loop, L_first_loop_exit;
6687 
6688   testl(xlen, 1);
6689   jccb(Assembler::zero, L_first_loop); //jump if xlen is even
6690 
6691   // Square and right shift by 1 the odd element using 32 bit multiply
6692   movl(raxReg, Address(x, tmp1, Address::times_4, 0));
6693   imulq(raxReg, raxReg);
6694   shrq(raxReg, 1);
6695   adcq(tmp5, 0);
6696   movq(Address(z, tmp4, Address::times_4, 0), raxReg);
6697   incrementl(tmp1);
6698   addl(tmp4, 2);
6699 
6700   // Square and  right shift by 1 the rest using 64 bit multiply
6701   bind(L_first_loop);
6702   cmpptr(tmp1, xlen);
6703   jccb(Assembler::equal, L_first_loop_exit);
6704 
6705   // Square
6706   movq(raxReg, Address(x, tmp1, Address::times_4,  0));
6707   rorq(raxReg, 32);    // convert big-endian to little-endian
6708   mulq(raxReg);        // 64-bit multiply rax * rax -&gt; rdx:rax
6709 
6710   // Right shift by 1 and save carry
6711   shrq(tmp5, 1);       // rdx:rax:tmp5 = (tmp5:rdx:rax) &gt;&gt;&gt; 1
6712   rcrq(rdxReg, 1);
6713   rcrq(raxReg, 1);
6714   adcq(tmp5, 0);
6715 
6716   // Store result in z
6717   movq(Address(z, tmp4, Address::times_4, 0), rdxReg);
6718   movq(Address(z, tmp4, Address::times_4, 8), raxReg);
6719 
6720   // Update indices for x and z
6721   addl(tmp1, 2);
6722   addl(tmp4, 4);
6723   jmp(L_first_loop);
6724 
6725   bind(L_first_loop_exit);
6726 }
6727 
6728 
6729 /**
6730  * Perform the following multiply add operation using BMI2 instructions
6731  * carry:sum = sum + op1*op2 + carry
6732  * op2 should be in rdx
6733  * op2 is preserved, all other registers are modified
6734  */
6735 void MacroAssembler::multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry, Register tmp2) {
6736   // assert op2 is rdx
6737   mulxq(tmp2, op1, op1);  //  op1 * op2 -&gt; tmp2:op1
6738   addq(sum, carry);
6739   adcq(tmp2, 0);
6740   addq(sum, op1);
6741   adcq(tmp2, 0);
6742   movq(carry, tmp2);
6743 }
6744 
6745 /**
6746  * Perform the following multiply add operation:
6747  * carry:sum = sum + op1*op2 + carry
6748  * Preserves op1, op2 and modifies rest of registers
6749  */
6750 void MacroAssembler::multiply_add_64(Register sum, Register op1, Register op2, Register carry, Register rdxReg, Register raxReg) {
6751   // rdx:rax = op1 * op2
6752   movq(raxReg, op2);
6753   mulq(op1);
6754 
6755   //  rdx:rax = sum + carry + rdx:rax
6756   addq(sum, carry);
6757   adcq(rdxReg, 0);
6758   addq(sum, raxReg);
6759   adcq(rdxReg, 0);
6760 
6761   // carry:sum = rdx:sum
6762   movq(carry, rdxReg);
6763 }
6764 
6765 /**
6766  * Add 64 bit long carry into z[] with carry propogation.
6767  * Preserves z and carry register values and modifies rest of registers.
6768  *
6769  */
6770 void MacroAssembler::add_one_64(Register z, Register zlen, Register carry, Register tmp1) {
6771   Label L_fourth_loop, L_fourth_loop_exit;
6772 
6773   movl(tmp1, 1);
6774   subl(zlen, 2);
6775   addq(Address(z, zlen, Address::times_4, 0), carry);
6776 
6777   bind(L_fourth_loop);
6778   jccb(Assembler::carryClear, L_fourth_loop_exit);
6779   subl(zlen, 2);
6780   jccb(Assembler::negative, L_fourth_loop_exit);
6781   addq(Address(z, zlen, Address::times_4, 0), tmp1);
6782   jmp(L_fourth_loop);
6783   bind(L_fourth_loop_exit);
6784 }
6785 
6786 /**
6787  * Shift z[] left by 1 bit.
6788  * Preserves x, len, z and zlen registers and modifies rest of the registers.
6789  *
6790  */
6791 void MacroAssembler::lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {
6792 
6793   Label L_fifth_loop, L_fifth_loop_exit;
6794 
6795   // Fifth loop
6796   // Perform primitiveLeftShift(z, zlen, 1)
6797 
6798   const Register prev_carry = tmp1;
6799   const Register new_carry = tmp4;
6800   const Register value = tmp2;
6801   const Register zidx = tmp3;
6802 
6803   // int zidx, carry;
6804   // long value;
6805   // carry = 0;
6806   // for (zidx = zlen-2; zidx &gt;=0; zidx -= 2) {
6807   //    (carry:value)  = (z[i] &lt;&lt; 1) | carry ;
6808   //    z[i] = value;
6809   // }
6810 
6811   movl(zidx, zlen);
6812   xorl(prev_carry, prev_carry); // clear carry flag and prev_carry register
6813 
6814   bind(L_fifth_loop);
6815   decl(zidx);  // Use decl to preserve carry flag
6816   decl(zidx);
6817   jccb(Assembler::negative, L_fifth_loop_exit);
6818 
6819   if (UseBMI2Instructions) {
6820      movq(value, Address(z, zidx, Address::times_4, 0));
6821      rclq(value, 1);
6822      rorxq(value, value, 32);
6823      movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6824   }
6825   else {
6826     // clear new_carry
6827     xorl(new_carry, new_carry);
6828 
6829     // Shift z[i] by 1, or in previous carry and save new carry
6830     movq(value, Address(z, zidx, Address::times_4, 0));
6831     shlq(value, 1);
6832     adcl(new_carry, 0);
6833 
6834     orq(value, prev_carry);
6835     rorq(value, 0x20);
6836     movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6837 
6838     // Set previous carry = new carry
6839     movl(prev_carry, new_carry);
6840   }
6841   jmp(L_fifth_loop);
6842 
6843   bind(L_fifth_loop_exit);
6844 }
6845 
6846 
6847 /**
6848  * Code for BigInteger::squareToLen() intrinsic
6849  *
6850  * rdi: x
6851  * rsi: len
6852  * r8:  z
6853  * rcx: zlen
6854  * r12: tmp1
6855  * r13: tmp2
6856  * r14: tmp3
6857  * r15: tmp4
6858  * rbx: tmp5
6859  *
6860  */
6861 void MacroAssembler::square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6862 
6863   Label L_second_loop, L_second_loop_exit, L_third_loop, L_third_loop_exit, L_last_x, L_multiply;
6864   push(tmp1);
6865   push(tmp2);
6866   push(tmp3);
6867   push(tmp4);
6868   push(tmp5);
6869 
6870   // First loop
6871   // Store the squares, right shifted one bit (i.e., divided by 2).
6872   square_rshift(x, len, z, tmp1, tmp3, tmp4, tmp5, rdxReg, raxReg);
6873 
6874   // Add in off-diagonal sums.
6875   //
6876   // Second, third (nested) and fourth loops.
6877   // zlen +=2;
6878   // for (int xidx=len-2,zidx=zlen-4; xidx &gt; 0; xidx-=2,zidx-=4) {
6879   //    carry = 0;
6880   //    long op2 = x[xidx:xidx+1];
6881   //    for (int j=xidx-2,k=zidx; j &gt;= 0; j-=2) {
6882   //       k -= 2;
6883   //       long op1 = x[j:j+1];
6884   //       long sum = z[k:k+1];
6885   //       carry:sum = multiply_add_64(sum, op1, op2, carry, tmp_regs);
6886   //       z[k:k+1] = sum;
6887   //    }
6888   //    add_one_64(z, k, carry, tmp_regs);
6889   // }
6890 
6891   const Register carry = tmp5;
6892   const Register sum = tmp3;
6893   const Register op1 = tmp4;
6894   Register op2 = tmp2;
6895 
6896   push(zlen);
6897   push(len);
6898   addl(zlen,2);
6899   bind(L_second_loop);
6900   xorq(carry, carry);
6901   subl(zlen, 4);
6902   subl(len, 2);
6903   push(zlen);
6904   push(len);
6905   cmpl(len, 0);
6906   jccb(Assembler::lessEqual, L_second_loop_exit);
6907 
6908   // Multiply an array by one 64 bit long.
6909   if (UseBMI2Instructions) {
6910     op2 = rdxReg;
6911     movq(op2, Address(x, len, Address::times_4,  0));
6912     rorxq(op2, op2, 32);
6913   }
6914   else {
6915     movq(op2, Address(x, len, Address::times_4,  0));
6916     rorq(op2, 32);
6917   }
6918 
6919   bind(L_third_loop);
6920   decrementl(len);
6921   jccb(Assembler::negative, L_third_loop_exit);
6922   decrementl(len);
6923   jccb(Assembler::negative, L_last_x);
6924 
6925   movq(op1, Address(x, len, Address::times_4,  0));
6926   rorq(op1, 32);
6927 
6928   bind(L_multiply);
6929   subl(zlen, 2);
6930   movq(sum, Address(z, zlen, Address::times_4,  0));
6931 
6932   // Multiply 64 bit by 64 bit and add 64 bits lower half and upper 64 bits as carry.
6933   if (UseBMI2Instructions) {
6934     multiply_add_64_bmi2(sum, op1, op2, carry, tmp2);
6935   }
6936   else {
6937     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6938   }
6939 
6940   movq(Address(z, zlen, Address::times_4, 0), sum);
6941 
6942   jmp(L_third_loop);
6943   bind(L_third_loop_exit);
6944 
6945   // Fourth loop
6946   // Add 64 bit long carry into z with carry propogation.
6947   // Uses offsetted zlen.
6948   add_one_64(z, zlen, carry, tmp1);
6949 
6950   pop(len);
6951   pop(zlen);
6952   jmp(L_second_loop);
6953 
6954   // Next infrequent code is moved outside loops.
6955   bind(L_last_x);
6956   movl(op1, Address(x, 0));
6957   jmp(L_multiply);
6958 
6959   bind(L_second_loop_exit);
6960   pop(len);
6961   pop(zlen);
6962   pop(len);
6963   pop(zlen);
6964 
6965   // Fifth loop
6966   // Shift z left 1 bit.
6967   lshift_by_1(x, len, z, zlen, tmp1, tmp2, tmp3, tmp4);
6968 
6969   // z[zlen-1] |= x[len-1] &amp; 1;
6970   movl(tmp3, Address(x, len, Address::times_4, -4));
6971   andl(tmp3, 1);
6972   orl(Address(z, zlen, Address::times_4,  -4), tmp3);
6973 
6974   pop(tmp5);
6975   pop(tmp4);
6976   pop(tmp3);
6977   pop(tmp2);
6978   pop(tmp1);
6979 }
6980 
6981 /**
6982  * Helper function for mul_add()
6983  * Multiply the in[] by int k and add to out[] starting at offset offs using
6984  * 128 bit by 32 bit multiply and return the carry in tmp5.
6985  * Only quad int aligned length of in[] is operated on in this function.
6986  * k is in rdxReg for BMI2Instructions, for others it is in tmp2.
6987  * This function preserves out, in and k registers.
6988  * len and offset point to the appropriate index in &quot;in&quot; &amp; &quot;out&quot; correspondingly
6989  * tmp5 has the carry.
6990  * other registers are temporary and are modified.
6991  *
6992  */
6993 void MacroAssembler::mul_add_128_x_32_loop(Register out, Register in,
6994   Register offset, Register len, Register tmp1, Register tmp2, Register tmp3,
6995   Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6996 
6997   Label L_first_loop, L_first_loop_exit;
6998 
6999   movl(tmp1, len);
7000   shrl(tmp1, 2);
7001 
7002   bind(L_first_loop);
7003   subl(tmp1, 1);
7004   jccb(Assembler::negative, L_first_loop_exit);
7005 
7006   subl(len, 4);
7007   subl(offset, 4);
7008 
7009   Register op2 = tmp2;
7010   const Register sum = tmp3;
7011   const Register op1 = tmp4;
7012   const Register carry = tmp5;
7013 
7014   if (UseBMI2Instructions) {
7015     op2 = rdxReg;
7016   }
7017 
7018   movq(op1, Address(in, len, Address::times_4,  8));
7019   rorq(op1, 32);
7020   movq(sum, Address(out, offset, Address::times_4,  8));
7021   rorq(sum, 32);
7022   if (UseBMI2Instructions) {
7023     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7024   }
7025   else {
7026     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7027   }
7028   // Store back in big endian from little endian
7029   rorq(sum, 0x20);
7030   movq(Address(out, offset, Address::times_4,  8), sum);
7031 
7032   movq(op1, Address(in, len, Address::times_4,  0));
7033   rorq(op1, 32);
7034   movq(sum, Address(out, offset, Address::times_4,  0));
7035   rorq(sum, 32);
7036   if (UseBMI2Instructions) {
7037     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7038   }
7039   else {
7040     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7041   }
7042   // Store back in big endian from little endian
7043   rorq(sum, 0x20);
7044   movq(Address(out, offset, Address::times_4,  0), sum);
7045 
7046   jmp(L_first_loop);
7047   bind(L_first_loop_exit);
7048 }
7049 
7050 /**
7051  * Code for BigInteger::mulAdd() intrinsic
7052  *
7053  * rdi: out
7054  * rsi: in
7055  * r11: offs (out.length - offset)
7056  * rcx: len
7057  * r8:  k
7058  * r12: tmp1
7059  * r13: tmp2
7060  * r14: tmp3
7061  * r15: tmp4
7062  * rbx: tmp5
7063  * Multiply the in[] by word k and add to out[], return the carry in rax
7064  */
7065 void MacroAssembler::mul_add(Register out, Register in, Register offs,
7066    Register len, Register k, Register tmp1, Register tmp2, Register tmp3,
7067    Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
7068 
7069   Label L_carry, L_last_in, L_done;
7070 
7071 // carry = 0;
7072 // for (int j=len-1; j &gt;= 0; j--) {
7073 //    long product = (in[j] &amp; LONG_MASK) * kLong +
7074 //                   (out[offs] &amp; LONG_MASK) + carry;
7075 //    out[offs--] = (int)product;
7076 //    carry = product &gt;&gt;&gt; 32;
7077 // }
7078 //
7079   push(tmp1);
7080   push(tmp2);
7081   push(tmp3);
7082   push(tmp4);
7083   push(tmp5);
7084 
7085   Register op2 = tmp2;
7086   const Register sum = tmp3;
7087   const Register op1 = tmp4;
7088   const Register carry =  tmp5;
7089 
7090   if (UseBMI2Instructions) {
7091     op2 = rdxReg;
7092     movl(op2, k);
7093   }
7094   else {
7095     movl(op2, k);
7096   }
7097 
7098   xorq(carry, carry);
7099 
7100   //First loop
7101 
7102   //Multiply in[] by k in a 4 way unrolled loop using 128 bit by 32 bit multiply
7103   //The carry is in tmp5
7104   mul_add_128_x_32_loop(out, in, offs, len, tmp1, tmp2, tmp3, tmp4, tmp5, rdxReg, raxReg);
7105 
7106   //Multiply the trailing in[] entry using 64 bit by 32 bit, if any
7107   decrementl(len);
7108   jccb(Assembler::negative, L_carry);
7109   decrementl(len);
7110   jccb(Assembler::negative, L_last_in);
7111 
7112   movq(op1, Address(in, len, Address::times_4,  0));
7113   rorq(op1, 32);
7114 
7115   subl(offs, 2);
7116   movq(sum, Address(out, offs, Address::times_4,  0));
7117   rorq(sum, 32);
7118 
7119   if (UseBMI2Instructions) {
7120     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7121   }
7122   else {
7123     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7124   }
7125 
7126   // Store back in big endian from little endian
7127   rorq(sum, 0x20);
7128   movq(Address(out, offs, Address::times_4,  0), sum);
7129 
7130   testl(len, len);
7131   jccb(Assembler::zero, L_carry);
7132 
7133   //Multiply the last in[] entry, if any
7134   bind(L_last_in);
7135   movl(op1, Address(in, 0));
7136   movl(sum, Address(out, offs, Address::times_4,  -4));
7137 
7138   movl(raxReg, k);
7139   mull(op1); //tmp4 * eax -&gt; edx:eax
7140   addl(sum, carry);
7141   adcl(rdxReg, 0);
7142   addl(sum, raxReg);
7143   adcl(rdxReg, 0);
7144   movl(carry, rdxReg);
7145 
7146   movl(Address(out, offs, Address::times_4,  -4), sum);
7147 
7148   bind(L_carry);
7149   //return tmp5/carry as carry in rax
7150   movl(rax, carry);
7151 
7152   bind(L_done);
7153   pop(tmp5);
7154   pop(tmp4);
7155   pop(tmp3);
7156   pop(tmp2);
7157   pop(tmp1);
7158 }
7159 #endif
7160 
7161 /**
7162  * Emits code to update CRC-32 with a byte value according to constants in table
7163  *
7164  * @param [in,out]crc   Register containing the crc.
7165  * @param [in]val       Register containing the byte to fold into the CRC.
7166  * @param [in]table     Register containing the table of crc constants.
7167  *
7168  * uint32_t crc;
7169  * val = crc_table[(val ^ crc) &amp; 0xFF];
7170  * crc = val ^ (crc &gt;&gt; 8);
7171  *
7172  */
7173 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
7174   xorl(val, crc);
7175   andl(val, 0xFF);
7176   shrl(crc, 8); // unsigned shift
7177   xorl(crc, Address(table, val, Address::times_4, 0));
7178 }
7179 
7180 /**
7181 * Fold four 128-bit data chunks
7182 */
7183 void MacroAssembler::fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
7184   evpclmulhdq(xtmp, xK, xcrc, Assembler::AVX_512bit); // [123:64]
7185   evpclmulldq(xcrc, xK, xcrc, Assembler::AVX_512bit); // [63:0]
7186   evpxorq(xcrc, xcrc, Address(buf, offset), Assembler::AVX_512bit /* vector_len */);
7187   evpxorq(xcrc, xcrc, xtmp, Assembler::AVX_512bit /* vector_len */);
7188 }
7189 
7190 /**
7191  * Fold 128-bit data chunk
7192  */
7193 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
7194   if (UseAVX &gt; 0) {
7195     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
7196     vpclmulldq(xcrc, xK, xcrc); // [63:0]
7197     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
7198     pxor(xcrc, xtmp);
7199   } else {
7200     movdqa(xtmp, xcrc);
7201     pclmulhdq(xtmp, xK);   // [123:64]
7202     pclmulldq(xcrc, xK);   // [63:0]
7203     pxor(xcrc, xtmp);
7204     movdqu(xtmp, Address(buf, offset));
7205     pxor(xcrc, xtmp);
7206   }
7207 }
7208 
7209 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
7210   if (UseAVX &gt; 0) {
7211     vpclmulhdq(xtmp, xK, xcrc);
7212     vpclmulldq(xcrc, xK, xcrc);
7213     pxor(xcrc, xbuf);
7214     pxor(xcrc, xtmp);
7215   } else {
7216     movdqa(xtmp, xcrc);
7217     pclmulhdq(xtmp, xK);
7218     pclmulldq(xcrc, xK);
7219     pxor(xcrc, xbuf);
7220     pxor(xcrc, xtmp);
7221   }
7222 }
7223 
7224 /**
7225  * 8-bit folds to compute 32-bit CRC
7226  *
7227  * uint64_t xcrc;
7228  * timesXtoThe32[xcrc &amp; 0xFF] ^ (xcrc &gt;&gt; 8);
7229  */
7230 void MacroAssembler::fold_8bit_crc32(XMMRegister xcrc, Register table, XMMRegister xtmp, Register tmp) {
7231   movdl(tmp, xcrc);
7232   andl(tmp, 0xFF);
7233   movdl(xtmp, Address(table, tmp, Address::times_4, 0));
7234   psrldq(xcrc, 1); // unsigned shift one byte
7235   pxor(xcrc, xtmp);
7236 }
7237 
7238 /**
7239  * uint32_t crc;
7240  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
7241  */
7242 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
7243   movl(tmp, crc);
7244   andl(tmp, 0xFF);
7245   shrl(crc, 8);
7246   xorl(crc, Address(table, tmp, Address::times_4, 0));
7247 }
7248 
7249 /**
7250  * @param crc   register containing existing CRC (32-bit)
7251  * @param buf   register pointing to input byte buffer (byte*)
7252  * @param len   register containing number of bytes
7253  * @param table register that will contain address of CRC table
7254  * @param tmp   scratch register
7255  */
7256 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp) {
7257   assert_different_registers(crc, buf, len, table, tmp, rax);
7258 
7259   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
7260   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
7261 
7262   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
7263   // context for the registers used, where all instructions below are using 128-bit mode
7264   // On EVEX without VL and BW, these instructions will all be AVX.
7265   lea(table, ExternalAddress(StubRoutines::crc_table_addr()));
7266   notl(crc); // ~crc
7267   cmpl(len, 16);
7268   jcc(Assembler::less, L_tail);
7269 
7270   // Align buffer to 16 bytes
7271   movl(tmp, buf);
7272   andl(tmp, 0xF);
7273   jccb(Assembler::zero, L_aligned);
7274   subl(tmp,  16);
7275   addl(len, tmp);
7276 
7277   align(4);
7278   BIND(L_align_loop);
7279   movsbl(rax, Address(buf, 0)); // load byte with sign extension
7280   update_byte_crc32(crc, rax, table);
7281   increment(buf);
7282   incrementl(tmp);
7283   jccb(Assembler::less, L_align_loop);
7284 
7285   BIND(L_aligned);
7286   movl(tmp, len); // save
7287   shrl(len, 4);
7288   jcc(Assembler::zero, L_tail_restore);
7289 
7290   // Fold crc into first bytes of vector
7291   movdqa(xmm1, Address(buf, 0));
7292   movdl(rax, xmm1);
7293   xorl(crc, rax);
7294   if (VM_Version::supports_sse4_1()) {
7295     pinsrd(xmm1, crc, 0);
7296   } else {
7297     pinsrw(xmm1, crc, 0);
7298     shrl(crc, 16);
7299     pinsrw(xmm1, crc, 1);
7300   }
7301   addptr(buf, 16);
7302   subl(len, 4); // len &gt; 0
7303   jcc(Assembler::less, L_fold_tail);
7304 
7305   movdqa(xmm2, Address(buf,  0));
7306   movdqa(xmm3, Address(buf, 16));
7307   movdqa(xmm4, Address(buf, 32));
7308   addptr(buf, 48);
7309   subl(len, 3);
7310   jcc(Assembler::lessEqual, L_fold_512b);
7311 
7312   // Fold total 512 bits of polynomial on each iteration,
7313   // 128 bits per each of 4 parallel streams.
7314   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));
7315 
7316   align(32);
7317   BIND(L_fold_512b_loop);
7318   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
7319   fold_128bit_crc32(xmm2, xmm0, xmm5, buf, 16);
7320   fold_128bit_crc32(xmm3, xmm0, xmm5, buf, 32);
7321   fold_128bit_crc32(xmm4, xmm0, xmm5, buf, 48);
7322   addptr(buf, 64);
7323   subl(len, 4);
7324   jcc(Assembler::greater, L_fold_512b_loop);
7325 
7326   // Fold 512 bits to 128 bits.
7327   BIND(L_fold_512b);
7328   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
7329   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm2);
7330   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm3);
7331   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm4);
7332 
7333   // Fold the rest of 128 bits data chunks
7334   BIND(L_fold_tail);
7335   addl(len, 3);
7336   jccb(Assembler::lessEqual, L_fold_128b);
7337   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
7338 
7339   BIND(L_fold_tail_loop);
7340   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
7341   addptr(buf, 16);
7342   decrementl(len);
7343   jccb(Assembler::greater, L_fold_tail_loop);
7344 
7345   // Fold 128 bits in xmm1 down into 32 bits in crc register.
7346   BIND(L_fold_128b);
7347   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));
7348   if (UseAVX &gt; 0) {
7349     vpclmulqdq(xmm2, xmm0, xmm1, 0x1);
7350     vpand(xmm3, xmm0, xmm2, 0 /* vector_len */);
7351     vpclmulqdq(xmm0, xmm0, xmm3, 0x1);
7352   } else {
7353     movdqa(xmm2, xmm0);
7354     pclmulqdq(xmm2, xmm1, 0x1);
7355     movdqa(xmm3, xmm0);
7356     pand(xmm3, xmm2);
7357     pclmulqdq(xmm0, xmm3, 0x1);
7358   }
7359   psrldq(xmm1, 8);
7360   psrldq(xmm2, 4);
7361   pxor(xmm0, xmm1);
7362   pxor(xmm0, xmm2);
7363 
7364   // 8 8-bit folds to compute 32-bit CRC.
7365   for (int j = 0; j &lt; 4; j++) {
7366     fold_8bit_crc32(xmm0, table, xmm1, rax);
7367   }
7368   movdl(crc, xmm0); // mov 32 bits to general register
7369   for (int j = 0; j &lt; 4; j++) {
7370     fold_8bit_crc32(crc, table, rax);
7371   }
7372 
7373   BIND(L_tail_restore);
7374   movl(len, tmp); // restore
7375   BIND(L_tail);
7376   andl(len, 0xf);
7377   jccb(Assembler::zero, L_exit);
7378 
7379   // Fold the rest of bytes
7380   align(4);
7381   BIND(L_tail_loop);
7382   movsbl(rax, Address(buf, 0)); // load byte with sign extension
7383   update_byte_crc32(crc, rax, table);
7384   increment(buf);
7385   decrementl(len);
7386   jccb(Assembler::greater, L_tail_loop);
7387 
7388   BIND(L_exit);
7389   notl(crc); // ~c
7390 }
7391 
7392 #ifdef _LP64
7393 // S. Gueron / Information Processing Letters 112 (2012) 184
7394 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
7395 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
7396 // Output: the 64-bit carry-less product of B * CONST
7397 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
7398                                      Register tmp1, Register tmp2, Register tmp3) {
7399   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7400   if (n &gt; 0) {
7401     addq(tmp3, n * 256 * 8);
7402   }
7403   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7404   movl(tmp1, in);
7405   andl(tmp1, 0x000000FF);
7406   shll(tmp1, 3);
7407   addq(tmp1, tmp3);
7408   movq(tmp1, Address(tmp1, 0));
7409 
7410   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7411   movl(tmp2, in);
7412   shrl(tmp2, 8);
7413   andl(tmp2, 0x000000FF);
7414   shll(tmp2, 3);
7415   addq(tmp2, tmp3);
7416   movq(tmp2, Address(tmp2, 0));
7417 
7418   shlq(tmp2, 8);
7419   xorq(tmp1, tmp2);
7420 
7421   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7422   movl(tmp2, in);
7423   shrl(tmp2, 16);
7424   andl(tmp2, 0x000000FF);
7425   shll(tmp2, 3);
7426   addq(tmp2, tmp3);
7427   movq(tmp2, Address(tmp2, 0));
7428 
7429   shlq(tmp2, 16);
7430   xorq(tmp1, tmp2);
7431 
7432   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7433   shrl(in, 24);
7434   andl(in, 0x000000FF);
7435   shll(in, 3);
7436   addq(in, tmp3);
7437   movq(in, Address(in, 0));
7438 
7439   shlq(in, 24);
7440   xorq(in, tmp1);
7441   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7442 }
7443 
7444 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7445                                       Register in_out,
7446                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7447                                       XMMRegister w_xtmp2,
7448                                       Register tmp1,
7449                                       Register n_tmp2, Register n_tmp3) {
7450   if (is_pclmulqdq_supported) {
7451     movdl(w_xtmp1, in_out); // modified blindly
7452 
7453     movl(tmp1, const_or_pre_comp_const_index);
7454     movdl(w_xtmp2, tmp1);
7455     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7456 
7457     movdq(in_out, w_xtmp1);
7458   } else {
7459     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3);
7460   }
7461 }
7462 
7463 // Recombination Alternative 2: No bit-reflections
7464 // T1 = (CRC_A * U1) &lt;&lt; 1
7465 // T2 = (CRC_B * U2) &lt;&lt; 1
7466 // C1 = T1 &gt;&gt; 32
7467 // C2 = T2 &gt;&gt; 32
7468 // T1 = T1 &amp; 0xFFFFFFFF
7469 // T2 = T2 &amp; 0xFFFFFFFF
7470 // T1 = CRC32(0, T1)
7471 // T2 = CRC32(0, T2)
7472 // C1 = C1 ^ T1
7473 // C2 = C2 ^ T2
7474 // CRC = C1 ^ C2 ^ CRC_C
7475 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7476                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7477                                      Register tmp1, Register tmp2,
7478                                      Register n_tmp3) {
7479   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7480   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7481   shlq(in_out, 1);
7482   movl(tmp1, in_out);
7483   shrq(in_out, 32);
7484   xorl(tmp2, tmp2);
7485   crc32(tmp2, tmp1, 4);
7486   xorl(in_out, tmp2); // we don&#39;t care about upper 32 bit contents here
7487   shlq(in1, 1);
7488   movl(tmp1, in1);
7489   shrq(in1, 32);
7490   xorl(tmp2, tmp2);
7491   crc32(tmp2, tmp1, 4);
7492   xorl(in1, tmp2);
7493   xorl(in_out, in1);
7494   xorl(in_out, in2);
7495 }
7496 
7497 // Set N to predefined value
7498 // Subtract from a lenght of a buffer
7499 // execute in a loop:
7500 // CRC_A = 0xFFFFFFFF, CRC_B = 0, CRC_C = 0
7501 // for i = 1 to N do
7502 //  CRC_A = CRC32(CRC_A, A[i])
7503 //  CRC_B = CRC32(CRC_B, B[i])
7504 //  CRC_C = CRC32(CRC_C, C[i])
7505 // end for
7506 // Recombine
7507 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7508                                        Register in_out1, Register in_out2, Register in_out3,
7509                                        Register tmp1, Register tmp2, Register tmp3,
7510                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7511                                        Register tmp4, Register tmp5,
7512                                        Register n_tmp6) {
7513   Label L_processPartitions;
7514   Label L_processPartition;
7515   Label L_exit;
7516 
7517   bind(L_processPartitions);
7518   cmpl(in_out1, 3 * size);
7519   jcc(Assembler::less, L_exit);
7520     xorl(tmp1, tmp1);
7521     xorl(tmp2, tmp2);
7522     movq(tmp3, in_out2);
7523     addq(tmp3, size);
7524 
7525     bind(L_processPartition);
7526       crc32(in_out3, Address(in_out2, 0), 8);
7527       crc32(tmp1, Address(in_out2, size), 8);
7528       crc32(tmp2, Address(in_out2, size * 2), 8);
7529       addq(in_out2, 8);
7530       cmpq(in_out2, tmp3);
7531       jcc(Assembler::less, L_processPartition);
7532     crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
7533             w_xtmp1, w_xtmp2, w_xtmp3,
7534             tmp4, tmp5,
7535             n_tmp6);
7536     addq(in_out2, 2 * size);
7537     subl(in_out1, 3 * size);
7538     jmp(L_processPartitions);
7539 
7540   bind(L_exit);
7541 }
7542 #else
7543 void MacroAssembler::crc32c_ipl_alg4(Register in_out, uint32_t n,
7544                                      Register tmp1, Register tmp2, Register tmp3,
7545                                      XMMRegister xtmp1, XMMRegister xtmp2) {
7546   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7547   if (n &gt; 0) {
7548     addl(tmp3, n * 256 * 8);
7549   }
7550   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7551   movl(tmp1, in_out);
7552   andl(tmp1, 0x000000FF);
7553   shll(tmp1, 3);
7554   addl(tmp1, tmp3);
7555   movq(xtmp1, Address(tmp1, 0));
7556 
7557   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7558   movl(tmp2, in_out);
7559   shrl(tmp2, 8);
7560   andl(tmp2, 0x000000FF);
7561   shll(tmp2, 3);
7562   addl(tmp2, tmp3);
7563   movq(xtmp2, Address(tmp2, 0));
7564 
7565   psllq(xtmp2, 8);
7566   pxor(xtmp1, xtmp2);
7567 
7568   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7569   movl(tmp2, in_out);
7570   shrl(tmp2, 16);
7571   andl(tmp2, 0x000000FF);
7572   shll(tmp2, 3);
7573   addl(tmp2, tmp3);
7574   movq(xtmp2, Address(tmp2, 0));
7575 
7576   psllq(xtmp2, 16);
7577   pxor(xtmp1, xtmp2);
7578 
7579   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7580   shrl(in_out, 24);
7581   andl(in_out, 0x000000FF);
7582   shll(in_out, 3);
7583   addl(in_out, tmp3);
7584   movq(xtmp2, Address(in_out, 0));
7585 
7586   psllq(xtmp2, 24);
7587   pxor(xtmp1, xtmp2); // Result in CXMM
7588   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7589 }
7590 
7591 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7592                                       Register in_out,
7593                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7594                                       XMMRegister w_xtmp2,
7595                                       Register tmp1,
7596                                       Register n_tmp2, Register n_tmp3) {
7597   if (is_pclmulqdq_supported) {
7598     movdl(w_xtmp1, in_out);
7599 
7600     movl(tmp1, const_or_pre_comp_const_index);
7601     movdl(w_xtmp2, tmp1);
7602     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7603     // Keep result in XMM since GPR is 32 bit in length
7604   } else {
7605     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3, w_xtmp1, w_xtmp2);
7606   }
7607 }
7608 
7609 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7610                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7611                                      Register tmp1, Register tmp2,
7612                                      Register n_tmp3) {
7613   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7614   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7615 
7616   psllq(w_xtmp1, 1);
7617   movdl(tmp1, w_xtmp1);
7618   psrlq(w_xtmp1, 32);
7619   movdl(in_out, w_xtmp1);
7620 
7621   xorl(tmp2, tmp2);
7622   crc32(tmp2, tmp1, 4);
7623   xorl(in_out, tmp2);
7624 
7625   psllq(w_xtmp2, 1);
7626   movdl(tmp1, w_xtmp2);
7627   psrlq(w_xtmp2, 32);
7628   movdl(in1, w_xtmp2);
7629 
7630   xorl(tmp2, tmp2);
7631   crc32(tmp2, tmp1, 4);
7632   xorl(in1, tmp2);
7633   xorl(in_out, in1);
7634   xorl(in_out, in2);
7635 }
7636 
7637 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7638                                        Register in_out1, Register in_out2, Register in_out3,
7639                                        Register tmp1, Register tmp2, Register tmp3,
7640                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7641                                        Register tmp4, Register tmp5,
7642                                        Register n_tmp6) {
7643   Label L_processPartitions;
7644   Label L_processPartition;
7645   Label L_exit;
7646 
7647   bind(L_processPartitions);
7648   cmpl(in_out1, 3 * size);
7649   jcc(Assembler::less, L_exit);
7650     xorl(tmp1, tmp1);
7651     xorl(tmp2, tmp2);
7652     movl(tmp3, in_out2);
7653     addl(tmp3, size);
7654 
7655     bind(L_processPartition);
7656       crc32(in_out3, Address(in_out2, 0), 4);
7657       crc32(tmp1, Address(in_out2, size), 4);
7658       crc32(tmp2, Address(in_out2, size*2), 4);
7659       crc32(in_out3, Address(in_out2, 0+4), 4);
7660       crc32(tmp1, Address(in_out2, size+4), 4);
7661       crc32(tmp2, Address(in_out2, size*2+4), 4);
7662       addl(in_out2, 8);
7663       cmpl(in_out2, tmp3);
7664       jcc(Assembler::less, L_processPartition);
7665 
7666         push(tmp3);
7667         push(in_out1);
7668         push(in_out2);
7669         tmp4 = tmp3;
7670         tmp5 = in_out1;
7671         n_tmp6 = in_out2;
7672 
7673       crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
7674             w_xtmp1, w_xtmp2, w_xtmp3,
7675             tmp4, tmp5,
7676             n_tmp6);
7677 
7678         pop(in_out2);
7679         pop(in_out1);
7680         pop(tmp3);
7681 
7682     addl(in_out2, 2 * size);
7683     subl(in_out1, 3 * size);
7684     jmp(L_processPartitions);
7685 
7686   bind(L_exit);
7687 }
7688 #endif //LP64
7689 
7690 #ifdef _LP64
7691 // Algorithm 2: Pipelined usage of the CRC32 instruction.
7692 // Input: A buffer I of L bytes.
7693 // Output: the CRC32C value of the buffer.
7694 // Notations:
7695 // Write L = 24N + r, with N = floor (L/24).
7696 // r = L mod 24 (0 &lt;= r &lt; 24).
7697 // Consider I as the concatenation of A|B|C|R, where A, B, C, each,
7698 // N quadwords, and R consists of r bytes.
7699 // A[j] = I [8j+7:8j], j= 0, 1, ..., N-1
7700 // B[j] = I [N + 8j+7:N + 8j], j= 0, 1, ..., N-1
7701 // C[j] = I [2N + 8j+7:2N + 8j], j= 0, 1, ..., N-1
7702 // if r &gt; 0 R[j] = I [3N +j], j= 0, 1, ...,r-1
7703 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7704                                           Register tmp1, Register tmp2, Register tmp3,
7705                                           Register tmp4, Register tmp5, Register tmp6,
7706                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7707                                           bool is_pclmulqdq_supported) {
7708   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7709   Label L_wordByWord;
7710   Label L_byteByByteProlog;
7711   Label L_byteByByte;
7712   Label L_exit;
7713 
7714   if (is_pclmulqdq_supported ) {
7715     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7716     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);
7717 
7718     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7719     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7720 
7721     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7722     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7723     assert((CRC32C_NUM_PRECOMPUTED_CONSTANTS - 1 ) == 5, &quot;Checking whether you declared all of the constants based on the number of \&quot;chunks\&quot;&quot;);
7724   } else {
7725     const_or_pre_comp_const_index[0] = 1;
7726     const_or_pre_comp_const_index[1] = 0;
7727 
7728     const_or_pre_comp_const_index[2] = 3;
7729     const_or_pre_comp_const_index[3] = 2;
7730 
7731     const_or_pre_comp_const_index[4] = 5;
7732     const_or_pre_comp_const_index[5] = 4;
7733    }
7734   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7735                     in2, in1, in_out,
7736                     tmp1, tmp2, tmp3,
7737                     w_xtmp1, w_xtmp2, w_xtmp3,
7738                     tmp4, tmp5,
7739                     tmp6);
7740   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7741                     in2, in1, in_out,
7742                     tmp1, tmp2, tmp3,
7743                     w_xtmp1, w_xtmp2, w_xtmp3,
7744                     tmp4, tmp5,
7745                     tmp6);
7746   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7747                     in2, in1, in_out,
7748                     tmp1, tmp2, tmp3,
7749                     w_xtmp1, w_xtmp2, w_xtmp3,
7750                     tmp4, tmp5,
7751                     tmp6);
7752   movl(tmp1, in2);
7753   andl(tmp1, 0x00000007);
7754   negl(tmp1);
7755   addl(tmp1, in2);
7756   addq(tmp1, in1);
7757 
7758   BIND(L_wordByWord);
7759   cmpq(in1, tmp1);
7760   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7761     crc32(in_out, Address(in1, 0), 4);
7762     addq(in1, 4);
7763     jmp(L_wordByWord);
7764 
7765   BIND(L_byteByByteProlog);
7766   andl(in2, 0x00000007);
7767   movl(tmp2, 1);
7768 
7769   BIND(L_byteByByte);
7770   cmpl(tmp2, in2);
7771   jccb(Assembler::greater, L_exit);
7772     crc32(in_out, Address(in1, 0), 1);
7773     incq(in1);
7774     incl(tmp2);
7775     jmp(L_byteByByte);
7776 
7777   BIND(L_exit);
7778 }
7779 #else
7780 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7781                                           Register tmp1, Register  tmp2, Register tmp3,
7782                                           Register tmp4, Register  tmp5, Register tmp6,
7783                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7784                                           bool is_pclmulqdq_supported) {
7785   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7786   Label L_wordByWord;
7787   Label L_byteByByteProlog;
7788   Label L_byteByByte;
7789   Label L_exit;
7790 
7791   if (is_pclmulqdq_supported) {
7792     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7793     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);
7794 
7795     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7796     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7797 
7798     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7799     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7800   } else {
7801     const_or_pre_comp_const_index[0] = 1;
7802     const_or_pre_comp_const_index[1] = 0;
7803 
7804     const_or_pre_comp_const_index[2] = 3;
7805     const_or_pre_comp_const_index[3] = 2;
7806 
7807     const_or_pre_comp_const_index[4] = 5;
7808     const_or_pre_comp_const_index[5] = 4;
7809   }
7810   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7811                     in2, in1, in_out,
7812                     tmp1, tmp2, tmp3,
7813                     w_xtmp1, w_xtmp2, w_xtmp3,
7814                     tmp4, tmp5,
7815                     tmp6);
7816   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7817                     in2, in1, in_out,
7818                     tmp1, tmp2, tmp3,
7819                     w_xtmp1, w_xtmp2, w_xtmp3,
7820                     tmp4, tmp5,
7821                     tmp6);
7822   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7823                     in2, in1, in_out,
7824                     tmp1, tmp2, tmp3,
7825                     w_xtmp1, w_xtmp2, w_xtmp3,
7826                     tmp4, tmp5,
7827                     tmp6);
7828   movl(tmp1, in2);
7829   andl(tmp1, 0x00000007);
7830   negl(tmp1);
7831   addl(tmp1, in2);
7832   addl(tmp1, in1);
7833 
7834   BIND(L_wordByWord);
7835   cmpl(in1, tmp1);
7836   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7837     crc32(in_out, Address(in1,0), 4);
7838     addl(in1, 4);
7839     jmp(L_wordByWord);
7840 
7841   BIND(L_byteByByteProlog);
7842   andl(in2, 0x00000007);
7843   movl(tmp2, 1);
7844 
7845   BIND(L_byteByByte);
7846   cmpl(tmp2, in2);
7847   jccb(Assembler::greater, L_exit);
7848     movb(tmp1, Address(in1, 0));
7849     crc32(in_out, tmp1, 1);
7850     incl(in1);
7851     incl(tmp2);
7852     jmp(L_byteByByte);
7853 
7854   BIND(L_exit);
7855 }
7856 #endif // LP64
7857 #undef BIND
7858 #undef BLOCK_COMMENT
7859 
7860 // Compress char[] array to byte[].
7861 //   ..\jdk\src\java.base\share\classes\java\lang\StringUTF16.java
7862 //   @HotSpotIntrinsicCandidate
7863 //   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
7864 //     for (int i = 0; i &lt; len; i++) {
7865 //       int c = src[srcOff++];
7866 //       if (c &gt;&gt;&gt; 8 != 0) {
7867 //         return 0;
7868 //       }
7869 //       dst[dstOff++] = (byte)c;
7870 //     }
7871 //     return len;
7872 //   }
7873 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
7874   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
7875   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
7876   Register tmp5, Register result) {
7877   Label copy_chars_loop, return_length, return_zero, done;
7878 
7879   // rsi: src
7880   // rdi: dst
7881   // rdx: len
7882   // rcx: tmp5
7883   // rax: result
7884 
7885   // rsi holds start addr of source char[] to be compressed
7886   // rdi holds start addr of destination byte[]
7887   // rdx holds length
7888 
7889   assert(len != result, &quot;&quot;);
7890 
7891   // save length for return
7892   push(len);
7893 
7894   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
7895     VM_Version::supports_avx512vlbw() &amp;&amp;
7896     VM_Version::supports_bmi2()) {
7897 
7898     Label copy_32_loop, copy_loop_tail, below_threshold;
7899 
7900     // alignment
7901     Label post_alignment;
7902 
7903     // if length of the string is less than 16, handle it in an old fashioned way
7904     testl(len, -32);
7905     jcc(Assembler::zero, below_threshold);
7906 
7907     // First check whether a character is compressable ( &lt;= 0xFF).
7908     // Create mask to test for Unicode chars inside zmm vector
7909     movl(result, 0x00FF);
7910     evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);
7911 
7912     testl(len, -64);
7913     jcc(Assembler::zero, post_alignment);
7914 
7915     movl(tmp5, dst);
7916     andl(tmp5, (32 - 1));
7917     negl(tmp5);
7918     andl(tmp5, (32 - 1));
7919 
7920     // bail out when there is nothing to be done
7921     testl(tmp5, 0xFFFFFFFF);
7922     jcc(Assembler::zero, post_alignment);
7923 
7924     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7925     movl(result, 0xFFFFFFFF);
7926     shlxl(result, result, tmp5);
7927     notl(result);
7928     kmovdl(k3, result);
7929 
7930     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7931     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7932     ktestd(k2, k3);
7933     jcc(Assembler::carryClear, return_zero);
7934 
7935     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7936 
7937     addptr(src, tmp5);
7938     addptr(src, tmp5);
7939     addptr(dst, tmp5);
7940     subl(len, tmp5);
7941 
7942     bind(post_alignment);
7943     // end of alignment
7944 
7945     movl(tmp5, len);
7946     andl(tmp5, (32 - 1));    // tail count (in chars)
7947     andl(len, ~(32 - 1));    // vector count (in chars)
7948     jcc(Assembler::zero, copy_loop_tail);
7949 
7950     lea(src, Address(src, len, Address::times_2));
7951     lea(dst, Address(dst, len, Address::times_1));
7952     negptr(len);
7953 
7954     bind(copy_32_loop);
7955     evmovdquw(tmp1Reg, Address(src, len, Address::times_2), Assembler::AVX_512bit);
7956     evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7957     kortestdl(k2, k2);
7958     jcc(Assembler::carryClear, return_zero);
7959 
7960     // All elements in current processed chunk are valid candidates for
7961     // compression. Write a truncated byte elements to the memory.
7962     evpmovwb(Address(dst, len, Address::times_1), tmp1Reg, Assembler::AVX_512bit);
7963     addptr(len, 32);
7964     jcc(Assembler::notZero, copy_32_loop);
7965 
7966     bind(copy_loop_tail);
7967     // bail out when there is nothing to be done
7968     testl(tmp5, 0xFFFFFFFF);
7969     jcc(Assembler::zero, return_length);
7970 
7971     movl(len, tmp5);
7972 
7973     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7974     movl(result, 0xFFFFFFFF);
7975     shlxl(result, result, len);
7976     notl(result);
7977 
7978     kmovdl(k3, result);
7979 
7980     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7981     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7982     ktestd(k2, k3);
7983     jcc(Assembler::carryClear, return_zero);
7984 
7985     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7986     jmp(return_length);
7987 
7988     bind(below_threshold);
7989   }
7990 
7991   if (UseSSE42Intrinsics) {
7992     Label copy_32_loop, copy_16, copy_tail;
7993 
7994     movl(result, len);
7995 
7996     movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vectors
7997 
7998     // vectored compression
7999     andl(len, 0xfffffff0);    // vector count (in chars)
8000     andl(result, 0x0000000f);    // tail count (in chars)
8001     testl(len, len);
8002     jcc(Assembler::zero, copy_16);
8003 
8004     // compress 16 chars per iter
8005     movdl(tmp1Reg, tmp5);
8006     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
8007     pxor(tmp4Reg, tmp4Reg);
8008 
8009     lea(src, Address(src, len, Address::times_2));
8010     lea(dst, Address(dst, len, Address::times_1));
8011     negptr(len);
8012 
8013     bind(copy_32_loop);
8014     movdqu(tmp2Reg, Address(src, len, Address::times_2));     // load 1st 8 characters
8015     por(tmp4Reg, tmp2Reg);
8016     movdqu(tmp3Reg, Address(src, len, Address::times_2, 16)); // load next 8 characters
8017     por(tmp4Reg, tmp3Reg);
8018     ptest(tmp4Reg, tmp1Reg);       // check for Unicode chars in next vector
8019     jcc(Assembler::notZero, return_zero);
8020     packuswb(tmp2Reg, tmp3Reg);    // only ASCII chars; compress each to 1 byte
8021     movdqu(Address(dst, len, Address::times_1), tmp2Reg);
8022     addptr(len, 16);
8023     jcc(Assembler::notZero, copy_32_loop);
8024 
8025     // compress next vector of 8 chars (if any)
8026     bind(copy_16);
8027     movl(len, result);
8028     andl(len, 0xfffffff8);    // vector count (in chars)
8029     andl(result, 0x00000007);    // tail count (in chars)
8030     testl(len, len);
8031     jccb(Assembler::zero, copy_tail);
8032 
8033     movdl(tmp1Reg, tmp5);
8034     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
8035     pxor(tmp3Reg, tmp3Reg);
8036 
8037     movdqu(tmp2Reg, Address(src, 0));
8038     ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in vector
8039     jccb(Assembler::notZero, return_zero);
8040     packuswb(tmp2Reg, tmp3Reg);    // only LATIN1 chars; compress each to 1 byte
8041     movq(Address(dst, 0), tmp2Reg);
8042     addptr(src, 16);
8043     addptr(dst, 8);
8044 
8045     bind(copy_tail);
8046     movl(len, result);
8047   }
8048   // compress 1 char per iter
8049   testl(len, len);
8050   jccb(Assembler::zero, return_length);
8051   lea(src, Address(src, len, Address::times_2));
8052   lea(dst, Address(dst, len, Address::times_1));
8053   negptr(len);
8054 
8055   bind(copy_chars_loop);
8056   load_unsigned_short(result, Address(src, len, Address::times_2));
8057   testl(result, 0xff00);      // check if Unicode char
8058   jccb(Assembler::notZero, return_zero);
8059   movb(Address(dst, len, Address::times_1), result);  // ASCII char; compress to 1 byte
8060   increment(len);
8061   jcc(Assembler::notZero, copy_chars_loop);
8062 
8063   // if compression succeeded, return length
8064   bind(return_length);
8065   pop(result);
8066   jmpb(done);
8067 
8068   // if compression failed, return 0
8069   bind(return_zero);
8070   xorl(result, result);
8071   addptr(rsp, wordSize);
8072 
8073   bind(done);
8074 }
8075 
8076 // Inflate byte[] array to char[].
8077 //   ..\jdk\src\java.base\share\classes\java\lang\StringLatin1.java
8078 //   @HotSpotIntrinsicCandidate
8079 //   private static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
8080 //     for (int i = 0; i &lt; len; i++) {
8081 //       dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
8082 //     }
8083 //   }
8084 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
8085   XMMRegister tmp1, Register tmp2) {
8086   Label copy_chars_loop, done, below_threshold, avx3_threshold;
8087   // rsi: src
8088   // rdi: dst
8089   // rdx: len
8090   // rcx: tmp2
8091 
8092   // rsi holds start addr of source byte[] to be inflated
8093   // rdi holds start addr of destination char[]
8094   // rdx holds length
8095   assert_different_registers(src, dst, len, tmp2);
8096   movl(tmp2, len);
8097   if ((UseAVX &gt; 2) &amp;&amp; // AVX512
8098     VM_Version::supports_avx512vlbw() &amp;&amp;
8099     VM_Version::supports_bmi2()) {
8100 
8101     Label copy_32_loop, copy_tail;
8102     Register tmp3_aliased = len;
8103 
8104     // if length of the string is less than 16, handle it in an old fashioned way
8105     testl(len, -16);
8106     jcc(Assembler::zero, below_threshold);
8107 
8108     testl(len, -1 * AVX3Threshold);
8109     jcc(Assembler::zero, avx3_threshold);
8110 
8111     // In order to use only one arithmetic operation for the main loop we use
8112     // this pre-calculation
8113     andl(tmp2, (32 - 1)); // tail count (in chars), 32 element wide loop
8114     andl(len, -32);     // vector count
8115     jccb(Assembler::zero, copy_tail);
8116 
8117     lea(src, Address(src, len, Address::times_1));
8118     lea(dst, Address(dst, len, Address::times_2));
8119     negptr(len);
8120 
8121 
8122     // inflate 32 chars per iter
8123     bind(copy_32_loop);
8124     vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_512bit);
8125     evmovdquw(Address(dst, len, Address::times_2), tmp1, Assembler::AVX_512bit);
8126     addptr(len, 32);
8127     jcc(Assembler::notZero, copy_32_loop);
8128 
8129     bind(copy_tail);
8130     // bail out when there is nothing to be done
8131     testl(tmp2, -1); // we don&#39;t destroy the contents of tmp2 here
8132     jcc(Assembler::zero, done);
8133 
8134     // ~(~0 &lt;&lt; length), where length is the # of remaining elements to process
8135     movl(tmp3_aliased, -1);
8136     shlxl(tmp3_aliased, tmp3_aliased, tmp2);
8137     notl(tmp3_aliased);
8138     kmovdl(k2, tmp3_aliased);
8139     evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);
8140     evmovdquw(Address(dst, 0), k2, tmp1, Assembler::AVX_512bit);
8141 
8142     jmp(done);
8143     bind(avx3_threshold);
8144   }
8145   if (UseSSE42Intrinsics) {
8146     Label copy_16_loop, copy_8_loop, copy_bytes, copy_new_tail, copy_tail;
8147 
8148     if (UseAVX &gt; 1) {
8149       andl(tmp2, (16 - 1));
8150       andl(len, -16);
8151       jccb(Assembler::zero, copy_new_tail);
8152     } else {
8153       andl(tmp2, 0x00000007);   // tail count (in chars)
8154       andl(len, 0xfffffff8);    // vector count (in chars)
8155       jccb(Assembler::zero, copy_tail);
8156     }
8157 
8158     // vectored inflation
8159     lea(src, Address(src, len, Address::times_1));
8160     lea(dst, Address(dst, len, Address::times_2));
8161     negptr(len);
8162 
8163     if (UseAVX &gt; 1) {
8164       bind(copy_16_loop);
8165       vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_256bit);
8166       vmovdqu(Address(dst, len, Address::times_2), tmp1);
8167       addptr(len, 16);
8168       jcc(Assembler::notZero, copy_16_loop);
8169 
8170       bind(below_threshold);
8171       bind(copy_new_tail);
8172       movl(len, tmp2);
8173       andl(tmp2, 0x00000007);
8174       andl(len, 0xFFFFFFF8);
8175       jccb(Assembler::zero, copy_tail);
8176 
8177       pmovzxbw(tmp1, Address(src, 0));
8178       movdqu(Address(dst, 0), tmp1);
8179       addptr(src, 8);
8180       addptr(dst, 2 * 8);
8181 
8182       jmp(copy_tail, true);
8183     }
8184 
8185     // inflate 8 chars per iter
8186     bind(copy_8_loop);
8187     pmovzxbw(tmp1, Address(src, len, Address::times_1));  // unpack to 8 words
8188     movdqu(Address(dst, len, Address::times_2), tmp1);
8189     addptr(len, 8);
8190     jcc(Assembler::notZero, copy_8_loop);
8191 
8192     bind(copy_tail);
8193     movl(len, tmp2);
8194 
8195     cmpl(len, 4);
8196     jccb(Assembler::less, copy_bytes);
8197 
8198     movdl(tmp1, Address(src, 0));  // load 4 byte chars
8199     pmovzxbw(tmp1, tmp1);
8200     movq(Address(dst, 0), tmp1);
8201     subptr(len, 4);
8202     addptr(src, 4);
8203     addptr(dst, 8);
8204 
8205     bind(copy_bytes);
8206   } else {
8207     bind(below_threshold);
8208   }
8209 
8210   testl(len, len);
8211   jccb(Assembler::zero, done);
8212   lea(src, Address(src, len, Address::times_1));
8213   lea(dst, Address(dst, len, Address::times_2));
8214   negptr(len);
8215 
8216   // inflate 1 char per iter
8217   bind(copy_chars_loop);
8218   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
8219   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
8220   increment(len);
8221   jcc(Assembler::notZero, copy_chars_loop);
8222 
8223   bind(done);
8224 }
8225 
8226 #ifdef _LP64
8227 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
8228   Label done;
8229   cvttss2sil(dst, src);
8230   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
8231   cmpl(dst, 0x80000000); // float_sign_flip
8232   jccb(Assembler::notEqual, done);
8233   subptr(rsp, 8);
8234   movflt(Address(rsp, 0), src);
8235   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
8236   pop(dst);
8237   bind(done);
8238 }
8239 
8240 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
8241   Label done;
8242   cvttsd2sil(dst, src);
8243   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
8244   cmpl(dst, 0x80000000); // float_sign_flip
8245   jccb(Assembler::notEqual, done);
8246   subptr(rsp, 8);
8247   movdbl(Address(rsp, 0), src);
8248   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
8249   pop(dst);
8250   bind(done);
8251 }
8252 
8253 void MacroAssembler::convert_f2l(Register dst, XMMRegister src) {
8254   Label done;
8255   cvttss2siq(dst, src);
8256   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
8257   jccb(Assembler::notEqual, done);
8258   subptr(rsp, 8);
8259   movflt(Address(rsp, 0), src);
8260   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
8261   pop(dst);
8262   bind(done);
8263 }
8264 
8265 void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {
8266   Label done;
8267   cvttsd2siq(dst, src);
8268   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
8269   jccb(Assembler::notEqual, done);
8270   subptr(rsp, 8);
8271   movdbl(Address(rsp, 0), src);
8272   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
8273   pop(dst);
8274   bind(done);
8275 }
8276 
8277 void MacroAssembler::cache_wb(Address line)
8278 {
8279   // 64 bit cpus always support clflush
8280   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
8281   bool optimized = VM_Version::supports_clflushopt();
8282   bool no_evict = VM_Version::supports_clwb();
8283 
8284   // prefer clwb (writeback without evict) otherwise
8285   // prefer clflushopt (potentially parallel writeback with evict)
8286   // otherwise fallback on clflush (serial writeback with evict)
8287 
8288   if (optimized) {
8289     if (no_evict) {
8290       clwb(line);
8291     } else {
8292       clflushopt(line);
8293     }
8294   } else {
8295     // no need for fence when using CLFLUSH
8296     clflush(line);
8297   }
8298 }
8299 
8300 void MacroAssembler::cache_wbsync(bool is_pre)
8301 {
8302   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
8303   bool optimized = VM_Version::supports_clflushopt();
8304   bool no_evict = VM_Version::supports_clwb();
8305 
8306   // pick the correct implementation
8307 
8308   if (!is_pre &amp;&amp; (optimized || no_evict)) {
8309     // need an sfence for post flush when using clflushopt or clwb
8310     // otherwise no no need for any synchroniaztion
8311 
8312     sfence();
8313   }
8314 }
8315 #endif // _LP64
8316 
8317 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
8318   switch (cond) {
8319     // Note some conditions are synonyms for others
8320     case Assembler::zero:         return Assembler::notZero;
8321     case Assembler::notZero:      return Assembler::zero;
8322     case Assembler::less:         return Assembler::greaterEqual;
8323     case Assembler::lessEqual:    return Assembler::greater;
8324     case Assembler::greater:      return Assembler::lessEqual;
8325     case Assembler::greaterEqual: return Assembler::less;
8326     case Assembler::below:        return Assembler::aboveEqual;
8327     case Assembler::belowEqual:   return Assembler::above;
8328     case Assembler::above:        return Assembler::belowEqual;
8329     case Assembler::aboveEqual:   return Assembler::below;
8330     case Assembler::overflow:     return Assembler::noOverflow;
8331     case Assembler::noOverflow:   return Assembler::overflow;
8332     case Assembler::negative:     return Assembler::positive;
8333     case Assembler::positive:     return Assembler::negative;
8334     case Assembler::parity:       return Assembler::noParity;
8335     case Assembler::noParity:     return Assembler::parity;
8336   }
8337   ShouldNotReachHere(); return Assembler::overflow;
8338 }
8339 
8340 SkipIfEqual::SkipIfEqual(
8341     MacroAssembler* masm, const bool* flag_addr, bool value) {
8342   _masm = masm;
8343   _masm-&gt;cmp8(ExternalAddress((address)flag_addr), value);
8344   _masm-&gt;jcc(Assembler::equal, _label);
8345 }
8346 
8347 SkipIfEqual::~SkipIfEqual() {
8348   _masm-&gt;bind(_label);
8349 }
8350 
8351 // 32-bit Windows has its own fast-path implementation
8352 // of get_thread
8353 #if !defined(WIN32) || defined(_LP64)
8354 
8355 // This is simply a call to Thread::current()
8356 void MacroAssembler::get_thread(Register thread) {
8357   if (thread != rax) {
8358     push(rax);
8359   }
8360   LP64_ONLY(push(rdi);)
8361   LP64_ONLY(push(rsi);)
8362   push(rdx);
8363   push(rcx);
8364 #ifdef _LP64
8365   push(r8);
8366   push(r9);
8367   push(r10);
8368   push(r11);
8369 #endif
8370 
8371   MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, Thread::current), 0);
8372 
8373 #ifdef _LP64
8374   pop(r11);
8375   pop(r10);
8376   pop(r9);
8377   pop(r8);
8378 #endif
8379   pop(rcx);
8380   pop(rdx);
8381   LP64_ONLY(pop(rsi);)
8382   LP64_ONLY(pop(rdi);)
8383   if (thread != rax) {
8384     mov(thread, rax);
8385     pop(rax);
8386   }
8387 }
8388 
8389 #endif // !WIN32 || _LP64
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
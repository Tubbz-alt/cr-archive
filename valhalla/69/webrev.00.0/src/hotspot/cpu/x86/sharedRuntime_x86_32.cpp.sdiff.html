<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2111 
2112   // Lock a synchronized method
2113   if (method-&gt;is_synchronized()) {
2114     assert(!is_critical_native, &quot;unhandled&quot;);
2115 
2116 
2117     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
2118 
2119     // Get the handle (the 2nd argument)
2120     __ movptr(oop_handle_reg, Address(rsp, wordSize));
2121 
2122     // Get address of the box
2123 
2124     __ lea(lock_reg, Address(rbp, lock_slot_rbp_offset));
2125 
2126     // Load the oop from the handle
2127     __ movptr(obj_reg, Address(oop_handle_reg, 0));
2128 
2129     if (UseBiasedLocking) {
2130       // Note that oop_handle_reg is trashed during this call
<span class="line-modified">2131       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, oop_handle_reg, false, lock_done, &amp;slow_path_lock);</span>
2132     }
2133 
2134     // Load immediate 1 into swap_reg %rax,
2135     __ movptr(swap_reg, 1);
2136 
2137     // Load (object-&gt;mark() | 1) into swap_reg %rax,
2138     __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2139 
2140     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
2141     __ movptr(Address(lock_reg, mark_word_offset), swap_reg);
2142 
2143     // src -&gt; dest iff dest == rax, else rax, &lt;- dest
2144     // *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)
2145     __ lock();
2146     __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2147     __ jcc(Assembler::equal, lock_done);
2148 
2149     // Test if the oopMark is an obvious stack pointer, i.e.,
2150     //  1) (mark &amp; 3) == 0, and
2151     //  2) rsp &lt;= mark &lt; mark + os::pagesize()
</pre>
</td>
<td>
<hr />
<pre>
2111 
2112   // Lock a synchronized method
2113   if (method-&gt;is_synchronized()) {
2114     assert(!is_critical_native, &quot;unhandled&quot;);
2115 
2116 
2117     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
2118 
2119     // Get the handle (the 2nd argument)
2120     __ movptr(oop_handle_reg, Address(rsp, wordSize));
2121 
2122     // Get address of the box
2123 
2124     __ lea(lock_reg, Address(rbp, lock_slot_rbp_offset));
2125 
2126     // Load the oop from the handle
2127     __ movptr(obj_reg, Address(oop_handle_reg, 0));
2128 
2129     if (UseBiasedLocking) {
2130       // Note that oop_handle_reg is trashed during this call
<span class="line-modified">2131       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, oop_handle_reg, noreg, false, lock_done, &amp;slow_path_lock);</span>
2132     }
2133 
2134     // Load immediate 1 into swap_reg %rax,
2135     __ movptr(swap_reg, 1);
2136 
2137     // Load (object-&gt;mark() | 1) into swap_reg %rax,
2138     __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2139 
2140     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
2141     __ movptr(Address(lock_reg, mark_word_offset), swap_reg);
2142 
2143     // src -&gt; dest iff dest == rax, else rax, &lt;- dest
2144     // *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)
2145     __ lock();
2146     __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2147     __ jcc(Assembler::equal, lock_done);
2148 
2149     // Test if the oopMark is an obvious stack pointer, i.e.,
2150     //  1) (mark &amp; 3) == 0, and
2151     //  2) rsp &lt;= mark &lt; mark + os::pagesize()
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
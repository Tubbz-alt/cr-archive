<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 328 
 329   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 330   void c2bool(Register x);
 331 
 332   // C++ bool manipulation
 333 
 334   void movbool(Register dst, Address src);
 335   void movbool(Address dst, bool boolconst);
 336   void movbool(Address dst, Register src);
 337   void testbool(Register dst);
 338 
 339   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 340   void resolve_weak_handle(Register result, Register tmp);
 341   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 342   void load_method_holder_cld(Register rresult, Register rmethod);
 343 
 344   void load_method_holder(Register holder, Register method);
 345 
 346   // oop manipulations
 347   void load_metadata(Register dst, Register src);
<span class="line-modified"> 348   void load_klass(Register dst, Register src);</span>
<span class="line-modified"> 349   void store_klass(Register dst, Register src);</span>
 350 
 351   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 352                       Register tmp1, Register thread_tmp);
 353   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 354                        Register tmp1, Register tmp2, Register tmp3 = noreg);
 355 
 356   void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register value_klass);
 357 
 358   // value type data payload offsets...
 359   void first_field_offset(Register value_klass, Register offset);
 360   void data_for_oop(Register oop, Register data, Register value_klass);
 361   // get data payload ptr a flat value array at index, kills rcx and index
 362   void data_for_value_array_index(Register array, Register array_klass,
 363                                   Register index, Register data);
 364 
 365 
 366   // Resolves obj access. Result is placed in the same register.
 367   // All other registers are preserved.
 368   void resolve(DecoratorSet decorators, Register obj);
 369 
 370   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 371                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 372   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 373                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 374   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 375                       Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);
 376 
 377   // Used for storing NULL. All other oop constants should be
 378   // stored using routines that take a jobject.
 379   void store_heap_oop_null(Address dst);
 380 
<span class="line-modified"> 381   void load_prototype_header(Register dst, Register src);</span>
 382 
 383 #ifdef _LP64
 384   void store_klass_gap(Register dst, Register src);
 385 
 386   // This dummy is to prevent a call to store_heap_oop from
 387   // converting a zero (like NULL) into a Register by giving
 388   // the compiler two choices it can&#39;t resolve
 389 
 390   void store_heap_oop(Address dst, void* dummy);
 391 
 392   void encode_heap_oop(Register r);
 393   void decode_heap_oop(Register r);
 394   void encode_heap_oop_not_null(Register r);
 395   void decode_heap_oop_not_null(Register r);
 396   void encode_heap_oop_not_null(Register dst, Register src);
 397   void decode_heap_oop_not_null(Register dst, Register src);
 398 
 399   void set_narrow_oop(Register dst, jobject obj);
 400   void set_narrow_oop(Address dst, jobject obj);
 401   void cmp_narrow_oop(Register dst, jobject obj);
 402   void cmp_narrow_oop(Address dst, jobject obj);
 403 
<span class="line-modified"> 404   void encode_klass_not_null(Register r);</span>
<span class="line-modified"> 405   void decode_klass_not_null(Register r);</span>
<span class="line-modified"> 406   void encode_klass_not_null(Register dst, Register src);</span>
<span class="line-modified"> 407   void decode_klass_not_null(Register dst, Register src);</span>
 408   void set_narrow_klass(Register dst, Klass* k);
 409   void set_narrow_klass(Address dst, Klass* k);
 410   void cmp_narrow_klass(Register dst, Klass* k);
 411   void cmp_narrow_klass(Address dst, Klass* k);
 412 
<span class="line-removed"> 413   // Returns the byte size of the instructions generated by decode_klass_not_null()</span>
<span class="line-removed"> 414   // when compressed klass pointers are being used.</span>
<span class="line-removed"> 415   static int instr_size_for_decode_klass_not_null();</span>
<span class="line-removed"> 416 </span>
 417   // if heap base register is used - reinit it with the correct value
 418   void reinit_heapbase();
 419 
 420   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 421 
 422 #endif // _LP64
 423 
 424   // Int division/remainder for Java
 425   // (as idivl, but checks for special case as described in JVM spec.)
 426   // returns idivl instruction offset for implicit exception handling
 427   int corrected_idivl(Register reg);
 428 
 429   // Long division/remainder for Java
 430   // (as idivq, but checks for special case as described in JVM spec.)
 431   // returns idivq instruction offset for implicit exception handling
 432   int corrected_idivq(Register reg);
 433 
 434   void int3();
 435 
 436   // Long operation macros for a 32bit cpu
</pre>
<hr />
<pre>
 706   // If thread_reg is != noreg the code assumes the register passed contains
 707   // the thread (required on 64 bit).
 708   void safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg);
 709 
 710   void verify_tlab();
 711 
 712   // Biased locking support
 713   // lock_reg and obj_reg must be loaded up with the appropriate values.
 714   // swap_reg must be rax, and is killed.
 715   // tmp_reg is optional. If it is supplied (i.e., != noreg) it will
 716   // be killed; if not supplied, push/pop will be used internally to
 717   // allocate a temporary (inefficient, avoid if possible).
 718   // Optional slow case is for implementations (interpreter and C1) which branch to
 719   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 720   // Returns offset of first potentially-faulting instruction for null
 721   // check info (currently consumed only by C1). If
 722   // swap_reg_contains_mark is true then returns -1 as it is assumed
 723   // the calling code has already passed any potential faults.
 724   int biased_locking_enter(Register lock_reg, Register obj_reg,
 725                            Register swap_reg, Register tmp_reg,
<span class="line-modified"> 726                            bool swap_reg_contains_mark,</span>
 727                            Label&amp; done, Label* slow_case = NULL,
 728                            BiasedLockingCounters* counters = NULL);
 729   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 730 
 731   Condition negate_condition(Condition cond);
 732 
 733   // Instructions that use AddressLiteral operands. These instruction can handle 32bit/64bit
 734   // operands. In general the names are modified to avoid hiding the instruction in Assembler
 735   // so that we don&#39;t need to implement all the varieties in the Assembler with trivial wrappers
 736   // here in MacroAssembler. The major exception to this rule is call
 737 
 738   // Arithmetics
 739 
 740 
 741   void addptr(Address dst, int32_t src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)) ; }
 742   void addptr(Address dst, Register src);
 743 
 744   void addptr(Register dst, Address src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)); }
 745   void addptr(Register dst, int32_t src);
 746   void addptr(Register dst, Register src);
</pre>
</td>
<td>
<hr />
<pre>
 328 
 329   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 330   void c2bool(Register x);
 331 
 332   // C++ bool manipulation
 333 
 334   void movbool(Register dst, Address src);
 335   void movbool(Address dst, bool boolconst);
 336   void movbool(Address dst, Register src);
 337   void testbool(Register dst);
 338 
 339   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 340   void resolve_weak_handle(Register result, Register tmp);
 341   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 342   void load_method_holder_cld(Register rresult, Register rmethod);
 343 
 344   void load_method_holder(Register holder, Register method);
 345 
 346   // oop manipulations
 347   void load_metadata(Register dst, Register src);
<span class="line-modified"> 348   void load_klass(Register dst, Register src, Register tmp);</span>
<span class="line-modified"> 349   void store_klass(Register dst, Register src, Register tmp);</span>
 350 
 351   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 352                       Register tmp1, Register thread_tmp);
 353   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 354                        Register tmp1, Register tmp2, Register tmp3 = noreg);
 355 
 356   void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register value_klass);
 357 
 358   // value type data payload offsets...
 359   void first_field_offset(Register value_klass, Register offset);
 360   void data_for_oop(Register oop, Register data, Register value_klass);
 361   // get data payload ptr a flat value array at index, kills rcx and index
 362   void data_for_value_array_index(Register array, Register array_klass,
 363                                   Register index, Register data);
 364 
 365 
 366   // Resolves obj access. Result is placed in the same register.
 367   // All other registers are preserved.
 368   void resolve(DecoratorSet decorators, Register obj);
 369 
 370   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 371                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 372   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 373                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 374   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 375                       Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);
 376 
 377   // Used for storing NULL. All other oop constants should be
 378   // stored using routines that take a jobject.
 379   void store_heap_oop_null(Address dst);
 380 
<span class="line-modified"> 381   void load_prototype_header(Register dst, Register src, Register tmp);</span>
 382 
 383 #ifdef _LP64
 384   void store_klass_gap(Register dst, Register src);
 385 
 386   // This dummy is to prevent a call to store_heap_oop from
 387   // converting a zero (like NULL) into a Register by giving
 388   // the compiler two choices it can&#39;t resolve
 389 
 390   void store_heap_oop(Address dst, void* dummy);
 391 
 392   void encode_heap_oop(Register r);
 393   void decode_heap_oop(Register r);
 394   void encode_heap_oop_not_null(Register r);
 395   void decode_heap_oop_not_null(Register r);
 396   void encode_heap_oop_not_null(Register dst, Register src);
 397   void decode_heap_oop_not_null(Register dst, Register src);
 398 
 399   void set_narrow_oop(Register dst, jobject obj);
 400   void set_narrow_oop(Address dst, jobject obj);
 401   void cmp_narrow_oop(Register dst, jobject obj);
 402   void cmp_narrow_oop(Address dst, jobject obj);
 403 
<span class="line-modified"> 404   void encode_klass_not_null(Register r, Register tmp);</span>
<span class="line-modified"> 405   void decode_klass_not_null(Register r, Register tmp);</span>
<span class="line-modified"> 406   void encode_and_move_klass_not_null(Register dst, Register src);</span>
<span class="line-modified"> 407   void decode_and_move_klass_not_null(Register dst, Register src);</span>
 408   void set_narrow_klass(Register dst, Klass* k);
 409   void set_narrow_klass(Address dst, Klass* k);
 410   void cmp_narrow_klass(Register dst, Klass* k);
 411   void cmp_narrow_klass(Address dst, Klass* k);
 412 




 413   // if heap base register is used - reinit it with the correct value
 414   void reinit_heapbase();
 415 
 416   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 417 
 418 #endif // _LP64
 419 
 420   // Int division/remainder for Java
 421   // (as idivl, but checks for special case as described in JVM spec.)
 422   // returns idivl instruction offset for implicit exception handling
 423   int corrected_idivl(Register reg);
 424 
 425   // Long division/remainder for Java
 426   // (as idivq, but checks for special case as described in JVM spec.)
 427   // returns idivq instruction offset for implicit exception handling
 428   int corrected_idivq(Register reg);
 429 
 430   void int3();
 431 
 432   // Long operation macros for a 32bit cpu
</pre>
<hr />
<pre>
 702   // If thread_reg is != noreg the code assumes the register passed contains
 703   // the thread (required on 64 bit).
 704   void safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg);
 705 
 706   void verify_tlab();
 707 
 708   // Biased locking support
 709   // lock_reg and obj_reg must be loaded up with the appropriate values.
 710   // swap_reg must be rax, and is killed.
 711   // tmp_reg is optional. If it is supplied (i.e., != noreg) it will
 712   // be killed; if not supplied, push/pop will be used internally to
 713   // allocate a temporary (inefficient, avoid if possible).
 714   // Optional slow case is for implementations (interpreter and C1) which branch to
 715   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 716   // Returns offset of first potentially-faulting instruction for null
 717   // check info (currently consumed only by C1). If
 718   // swap_reg_contains_mark is true then returns -1 as it is assumed
 719   // the calling code has already passed any potential faults.
 720   int biased_locking_enter(Register lock_reg, Register obj_reg,
 721                            Register swap_reg, Register tmp_reg,
<span class="line-modified"> 722                            Register tmp_reg2, bool swap_reg_contains_mark,</span>
 723                            Label&amp; done, Label* slow_case = NULL,
 724                            BiasedLockingCounters* counters = NULL);
 725   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 726 
 727   Condition negate_condition(Condition cond);
 728 
 729   // Instructions that use AddressLiteral operands. These instruction can handle 32bit/64bit
 730   // operands. In general the names are modified to avoid hiding the instruction in Assembler
 731   // so that we don&#39;t need to implement all the varieties in the Assembler with trivial wrappers
 732   // here in MacroAssembler. The major exception to this rule is call
 733 
 734   // Arithmetics
 735 
 736 
 737   void addptr(Address dst, int32_t src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)) ; }
 738   void addptr(Address dst, Register src);
 739 
 740   void addptr(Register dst, Address src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)); }
 741   void addptr(Register dst, int32_t src);
 742   void addptr(Register dst, Register src);
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vtableStubs_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_Runtime1.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
<span class="line-modified">  360   return UseCompressedOops || UseCompressedClassPointers;</span>
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
</pre>
<hr />
<pre>
 1495 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1496 {
 1497   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1498   return (offset &lt; 0x80) ? 5 : 8; // REX
 1499 }
 1500 
 1501 //=============================================================================
 1502 #ifndef PRODUCT
 1503 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1504 {
 1505   st-&gt;print_cr(&quot;MachVEPNode&quot;);
 1506 }
 1507 #endif
 1508 
 1509 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1510 {
 1511   MacroAssembler masm(&amp;cbuf);
 1512   if (!_verified) {  
 1513     uint insts_size = cbuf.insts_size();
 1514     if (UseCompressedClassPointers) {
<span class="line-modified"> 1515       masm.load_klass(rscratch1, j_rarg0);</span>
 1516       masm.cmpptr(rax, rscratch1);
 1517     } else {
 1518       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1519     }
 1520     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1521   } else {
 1522     // Unpack value type args passed as oop and then jump to
 1523     // the verified entry point (skipping the unverified entry).
 1524     masm.unpack_value_args(ra_-&gt;C, _receiver_only);
 1525     masm.jmp(*_verified_entry);
 1526   }
 1527 }
 1528 
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1532 {
 1533   if (UseCompressedClassPointers) {
 1534     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1535     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1536     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1537   } else {
 1538     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1539                  &quot;# Inline cache check&quot;);
 1540   }
 1541   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1542   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1543 }
 1544 #endif
 1545 
 1546 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1547 {
 1548   MacroAssembler masm(&amp;cbuf);
 1549   uint insts_size = cbuf.insts_size();
 1550   if (UseCompressedClassPointers) {
<span class="line-modified"> 1551     masm.load_klass(rscratch1, j_rarg0);</span>
 1552     masm.cmpptr(rax, rscratch1);
 1553   } else {
 1554     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1555   }
 1556 
 1557   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1558 
 1559   /* WARNING these NOPs are critical so that verified entry point is properly
 1560      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1561   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1562   if (OptoBreakpoint) {
 1563     // Leave space for int3
 1564     nops_cnt -= 1;
 1565   }
 1566   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1567   if (nops_cnt &gt; 0)
 1568     masm.nop(nops_cnt);
 1569 }
 1570 
 1571 //=============================================================================
</pre>
<hr />
<pre>
 5947   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5948   opcode(0x89);
 5949   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5950   ins_pipe(ialu_mem_reg); // XXX
 5951 %}
 5952 
 5953 // Store Pointer
 5954 instruct storeP(memory mem, any_RegP src)
 5955 %{
 5956   match(Set mem (StoreP mem src));
 5957 
 5958   ins_cost(125); // XXX
 5959   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5960   opcode(0x89);
 5961   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5962   ins_pipe(ialu_mem_reg);
 5963 %}
 5964 
 5965 instruct storeImmP0(memory mem, immP0 zero)
 5966 %{
<span class="line-modified"> 5967   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 5968   match(Set mem (StoreP mem zero));
 5969 
 5970   ins_cost(125); // XXX
 5971   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5972   ins_encode %{
 5973     __ movq($mem$$Address, r12);
 5974   %}
 5975   ins_pipe(ialu_mem_reg);
 5976 %}
 5977 
 5978 // Store NULL Pointer, mark word, or other simple pointer constant.
 5979 instruct storeImmP(memory mem, immP31 src)
 5980 %{
 5981   match(Set mem (StoreP mem src));
 5982 
 5983   ins_cost(150); // XXX
 5984   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5985   opcode(0xC7); /* C7 /0 */
 5986   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5987   ins_pipe(ialu_mem_imm);
</pre>
<hr />
<pre>
 5997   ins_encode %{
 5998     __ movl($mem$$Address, $src$$Register);
 5999   %}
 6000   ins_pipe(ialu_mem_reg);
 6001 %}
 6002 
 6003 instruct storeNKlass(memory mem, rRegN src)
 6004 %{
 6005   match(Set mem (StoreNKlass mem src));
 6006 
 6007   ins_cost(125); // XXX
 6008   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6009   ins_encode %{
 6010     __ movl($mem$$Address, $src$$Register);
 6011   %}
 6012   ins_pipe(ialu_mem_reg);
 6013 %}
 6014 
 6015 instruct storeImmN0(memory mem, immN0 zero)
 6016 %{
<span class="line-modified"> 6017   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);</span>
 6018   match(Set mem (StoreN mem zero));
 6019 
 6020   ins_cost(125); // XXX
 6021   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6022   ins_encode %{
 6023     __ movl($mem$$Address, r12);
 6024   %}
 6025   ins_pipe(ialu_mem_reg);
 6026 %}
 6027 
 6028 instruct storeImmN(memory mem, immN src)
 6029 %{
 6030   match(Set mem (StoreN mem src));
 6031 
 6032   ins_cost(150); // XXX
 6033   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6034   ins_encode %{
 6035     address con = (address)$src$$constant;
 6036     if (con == NULL) {
 6037       __ movl($mem$$Address, (int32_t)0);
</pre>
<hr />
<pre>
 6040     }
 6041   %}
 6042   ins_pipe(ialu_mem_imm);
 6043 %}
 6044 
 6045 instruct storeImmNKlass(memory mem, immNKlass src)
 6046 %{
 6047   match(Set mem (StoreNKlass mem src));
 6048 
 6049   ins_cost(150); // XXX
 6050   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6051   ins_encode %{
 6052     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6053   %}
 6054   ins_pipe(ialu_mem_imm);
 6055 %}
 6056 
 6057 // Store Integer Immediate
 6058 instruct storeImmI0(memory mem, immI0 zero)
 6059 %{
<span class="line-modified"> 6060   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6061   match(Set mem (StoreI mem zero));
 6062 
 6063   ins_cost(125); // XXX
 6064   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6065   ins_encode %{
 6066     __ movl($mem$$Address, r12);
 6067   %}
 6068   ins_pipe(ialu_mem_reg);
 6069 %}
 6070 
 6071 instruct storeImmI(memory mem, immI src)
 6072 %{
 6073   match(Set mem (StoreI mem src));
 6074 
 6075   ins_cost(150);
 6076   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6077   opcode(0xC7); /* C7 /0 */
 6078   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6079   ins_pipe(ialu_mem_imm);
 6080 %}
 6081 
 6082 // Store Long Immediate
 6083 instruct storeImmL0(memory mem, immL0 zero)
 6084 %{
<span class="line-modified"> 6085   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6086   match(Set mem (StoreL mem zero));
 6087 
 6088   ins_cost(125); // XXX
 6089   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6090   ins_encode %{
 6091     __ movq($mem$$Address, r12);
 6092   %}
 6093   ins_pipe(ialu_mem_reg);
 6094 %}
 6095 
 6096 instruct storeImmL(memory mem, immL32 src)
 6097 %{
 6098   match(Set mem (StoreL mem src));
 6099 
 6100   ins_cost(150);
 6101   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6102   opcode(0xC7); /* C7 /0 */
 6103   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6104   ins_pipe(ialu_mem_imm);
 6105 %}
 6106 
 6107 // Store Short/Char Immediate
 6108 instruct storeImmC0(memory mem, immI0 zero)
 6109 %{
<span class="line-modified"> 6110   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6111   match(Set mem (StoreC mem zero));
 6112 
 6113   ins_cost(125); // XXX
 6114   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6115   ins_encode %{
 6116     __ movw($mem$$Address, r12);
 6117   %}
 6118   ins_pipe(ialu_mem_reg);
 6119 %}
 6120 
 6121 instruct storeImmI16(memory mem, immI16 src)
 6122 %{
 6123   predicate(UseStoreImmI16);
 6124   match(Set mem (StoreC mem src));
 6125 
 6126   ins_cost(150);
 6127   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6128   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6129   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6130   ins_pipe(ialu_mem_imm);
 6131 %}
 6132 
 6133 // Store Byte Immediate
 6134 instruct storeImmB0(memory mem, immI0 zero)
 6135 %{
<span class="line-modified"> 6136   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6137   match(Set mem (StoreB mem zero));
 6138 
 6139   ins_cost(125); // XXX
 6140   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6141   ins_encode %{
 6142     __ movb($mem$$Address, r12);
 6143   %}
 6144   ins_pipe(ialu_mem_reg);
 6145 %}
 6146 
 6147 instruct storeImmB(memory mem, immI8 src)
 6148 %{
 6149   match(Set mem (StoreB mem src));
 6150 
 6151   ins_cost(150); // XXX
 6152   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6153   opcode(0xC6); /* C6 /0 */
 6154   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6155   ins_pipe(ialu_mem_imm);
 6156 %}
 6157 
 6158 // Store CMS card-mark Immediate
 6159 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6160 %{
<span class="line-modified"> 6161   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6162   match(Set mem (StoreCM mem zero));
 6163 
 6164   ins_cost(125); // XXX
 6165   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6166   ins_encode %{
 6167     __ movb($mem$$Address, r12);
 6168   %}
 6169   ins_pipe(ialu_mem_reg);
 6170 %}
 6171 
 6172 instruct storeImmCM0(memory mem, immI0 src)
 6173 %{
 6174   match(Set mem (StoreCM mem src));
 6175 
 6176   ins_cost(150); // XXX
 6177   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6178   opcode(0xC6); /* C6 /0 */
 6179   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6180   ins_pipe(ialu_mem_imm);
 6181 %}
 6182 
 6183 // Store Float
 6184 instruct storeF(memory mem, regF src)
 6185 %{
 6186   match(Set mem (StoreF mem src));
 6187 
 6188   ins_cost(95); // XXX
 6189   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6190   ins_encode %{
 6191     __ movflt($mem$$Address, $src$$XMMRegister);
 6192   %}
 6193   ins_pipe(pipe_slow); // XXX
 6194 %}
 6195 
 6196 // Store immediate Float value (it is faster than store from XMM register)
 6197 instruct storeF0(memory mem, immF0 zero)
 6198 %{
<span class="line-modified"> 6199   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6200   match(Set mem (StoreF mem zero));
 6201 
 6202   ins_cost(25); // XXX
 6203   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6204   ins_encode %{
 6205     __ movl($mem$$Address, r12);
 6206   %}
 6207   ins_pipe(ialu_mem_reg);
 6208 %}
 6209 
 6210 instruct storeF_imm(memory mem, immF src)
 6211 %{
 6212   match(Set mem (StoreF mem src));
 6213 
 6214   ins_cost(50);
 6215   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6216   opcode(0xC7); /* C7 /0 */
 6217   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6218   ins_pipe(ialu_mem_imm);
 6219 %}
</pre>
<hr />
<pre>
 6229     __ movdbl($mem$$Address, $src$$XMMRegister);
 6230   %}
 6231   ins_pipe(pipe_slow); // XXX
 6232 %}
 6233 
 6234 // Store immediate double 0.0 (it is faster than store from XMM register)
 6235 instruct storeD0_imm(memory mem, immD0 src)
 6236 %{
 6237   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6238   match(Set mem (StoreD mem src));
 6239 
 6240   ins_cost(50);
 6241   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6242   opcode(0xC7); /* C7 /0 */
 6243   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6244   ins_pipe(ialu_mem_imm);
 6245 %}
 6246 
 6247 instruct storeD0(memory mem, immD0 zero)
 6248 %{
<span class="line-modified"> 6249   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6250   match(Set mem (StoreD mem zero));
 6251 
 6252   ins_cost(25); // XXX
 6253   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6254   ins_encode %{
 6255     __ movq($mem$$Address, r12);
 6256   %}
 6257   ins_pipe(ialu_mem_reg);
 6258 %}
 6259 
 6260 instruct storeSSI(stackSlotI dst, rRegI src)
 6261 %{
 6262   match(Set dst src);
 6263 
 6264   ins_cost(100);
 6265   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6266   opcode(0x89);
 6267   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6268   ins_pipe( ialu_mem_reg );
 6269 %}
</pre>
<hr />
<pre>
 6822 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6823   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6824             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6825   match(Set dst (DecodeN src));
 6826   effect(KILL cr);
 6827   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6828   ins_encode %{
 6829     Register s = $src$$Register;
 6830     Register d = $dst$$Register;
 6831     if (s != d) {
 6832       __ decode_heap_oop_not_null(d, s);
 6833     } else {
 6834       __ decode_heap_oop_not_null(d);
 6835     }
 6836   %}
 6837   ins_pipe(ialu_reg_long);
 6838 %}
 6839 
 6840 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6841   match(Set dst (EncodePKlass src));
<span class="line-modified"> 6842   effect(KILL cr);</span>
<span class="line-modified"> 6843   format %{ &quot;encode_klass_not_null $dst,$src&quot; %}</span>
 6844   ins_encode %{
<span class="line-modified"> 6845     __ encode_klass_not_null($dst$$Register, $src$$Register);</span>
 6846   %}
 6847   ins_pipe(ialu_reg_long);
 6848 %}
 6849 
 6850 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6851   match(Set dst (DecodeNKlass src));
<span class="line-modified"> 6852   effect(KILL cr);</span>
<span class="line-modified"> 6853   format %{ &quot;decode_klass_not_null $dst,$src&quot; %}</span>
 6854   ins_encode %{
<span class="line-modified"> 6855     Register s = $src$$Register;</span>
<span class="line-removed"> 6856     Register d = $dst$$Register;</span>
<span class="line-removed"> 6857     if (s != d) {</span>
<span class="line-removed"> 6858       __ decode_klass_not_null(d, s);</span>
<span class="line-removed"> 6859     } else {</span>
<span class="line-removed"> 6860       __ decode_klass_not_null(d);</span>
<span class="line-removed"> 6861     }</span>
 6862   %}
 6863   ins_pipe(ialu_reg_long);
 6864 %}
 6865 
<span class="line-removed"> 6866 </span>
 6867 //----------Conditional Move---------------------------------------------------
 6868 // Jump
 6869 // dummy instruction for generating temp registers
 6870 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6871   match(Jump (LShiftL switch_val shift));
 6872   ins_cost(350);
 6873   predicate(false);
 6874   effect(TEMP dest);
 6875 
 6876   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6877             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6878   ins_encode %{
 6879     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6880     // to do that and the compiler is using that register as one it can allocate.
 6881     // So we build it all by hand.
 6882     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6883     // ArrayAddress dispatch(table, index);
 6884     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6885     __ lea($dest$$Register, $constantaddress);
 6886     __ jmp(dispatch);
</pre>
<hr />
<pre>
11866 
11867 // This will generate a signed flags result. This should be OK since
11868 // any compare to a zero should be eq/neq.
11869 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11870 %{
11871   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11872             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11873   match(Set cr (CmpP (LoadP op) zero));
11874 
11875   ins_cost(500); // XXX
11876   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11877   opcode(0xF7); /* Opcode F7 /0 */
11878   ins_encode(REX_mem_wide(op),
11879              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11880   ins_pipe(ialu_cr_reg_imm);
11881 %}
11882 
11883 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11884 %{
11885   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
<span class="line-removed">11886             (CompressedKlassPointers::base() == NULL) &amp;&amp;</span>
11887             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11888   match(Set cr (CmpP (LoadP mem) zero));
11889 
11890   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11891   ins_encode %{
11892     __ cmpq(r12, $mem$$Address);
11893   %}
11894   ins_pipe(ialu_cr_reg_mem);
11895 %}
11896 
11897 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11898 %{
11899   match(Set cr (CmpN op1 op2));
11900 
11901   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11902   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11903   ins_pipe(ialu_cr_reg_reg);
11904 %}
11905 
11906 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
</pre>
<hr />
<pre>
11962   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11963   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11964   ins_pipe(ialu_cr_reg_imm);
11965 %}
11966 
11967 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11968 %{
11969   predicate(CompressedOops::base() != NULL);
11970   match(Set cr (CmpN (LoadN mem) zero));
11971 
11972   ins_cost(500); // XXX
11973   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11974   ins_encode %{
11975     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11976   %}
11977   ins_pipe(ialu_cr_reg_mem);
11978 %}
11979 
11980 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11981 %{
<span class="line-modified">11982   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
11983   match(Set cr (CmpN (LoadN mem) zero));
11984 
11985   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11986   ins_encode %{
11987     __ cmpl(r12, $mem$$Address);
11988   %}
11989   ins_pipe(ialu_cr_reg_mem);
11990 %}
11991 
11992 // Yanked all unsigned pointer compare operations.
11993 // Pointer compares are done with CmpP which is already unsigned.
11994 
11995 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11996 %{
11997   match(Set cr (CmpL op1 op2));
11998 
11999   format %{ &quot;cmpq    $op1, $op2&quot; %}
12000   opcode(0x3B);  /* Opcode 3B /r */
12001   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12002   ins_pipe(ialu_cr_reg_reg);
</pre>
<hr />
<pre>
12620 
12621 // ============================================================================
12622 // inlined locking and unlocking
12623 
12624 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12625   predicate(Compile::current()-&gt;use_rtm());
12626   match(Set cr (FastLock object box));
12627   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12628   ins_cost(300);
12629   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12630   ins_encode %{
12631     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12632                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12633                  _counters, _rtm_counters, _stack_rtm_counters,
12634                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12635                  true, ra_-&gt;C-&gt;profile_rtm());
12636   %}
12637   ins_pipe(pipe_slow);
12638 %}
12639 
<span class="line-modified">12640 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{</span>
12641   predicate(!Compile::current()-&gt;use_rtm());
12642   match(Set cr (FastLock object box));
<span class="line-modified">12643   effect(TEMP tmp, TEMP scr, USE_KILL box);</span>
12644   ins_cost(300);
12645   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12646   ins_encode %{
12647     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
<span class="line-modified">12648                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);</span>
12649   %}
12650   ins_pipe(pipe_slow);
12651 %}
12652 
12653 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12654   match(Set cr (FastUnlock object box));
12655   effect(TEMP tmp, USE_KILL box);
12656   ins_cost(300);
12657   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12658   ins_encode %{
12659     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12660   %}
12661   ins_pipe(pipe_slow);
12662 %}
12663 
12664 
12665 // ============================================================================
12666 // Safepoint Instructions
12667 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12668 %{
</pre>
</td>
<td>
<hr />
<pre>
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
<span class="line-modified">  360   return UseCompressedOops;</span>
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
</pre>
<hr />
<pre>
 1495 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1496 {
 1497   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1498   return (offset &lt; 0x80) ? 5 : 8; // REX
 1499 }
 1500 
 1501 //=============================================================================
 1502 #ifndef PRODUCT
 1503 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1504 {
 1505   st-&gt;print_cr(&quot;MachVEPNode&quot;);
 1506 }
 1507 #endif
 1508 
 1509 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1510 {
 1511   MacroAssembler masm(&amp;cbuf);
 1512   if (!_verified) {  
 1513     uint insts_size = cbuf.insts_size();
 1514     if (UseCompressedClassPointers) {
<span class="line-modified"> 1515       masm.load_klass(rscratch1, j_rarg0, rscratch2);</span>
 1516       masm.cmpptr(rax, rscratch1);
 1517     } else {
 1518       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1519     }
 1520     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1521   } else {
 1522     // Unpack value type args passed as oop and then jump to
 1523     // the verified entry point (skipping the unverified entry).
 1524     masm.unpack_value_args(ra_-&gt;C, _receiver_only);
 1525     masm.jmp(*_verified_entry);
 1526   }
 1527 }
 1528 
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1532 {
 1533   if (UseCompressedClassPointers) {
 1534     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1535     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1536     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1537   } else {
 1538     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1539                  &quot;# Inline cache check&quot;);
 1540   }
 1541   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1542   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1543 }
 1544 #endif
 1545 
 1546 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1547 {
 1548   MacroAssembler masm(&amp;cbuf);
 1549   uint insts_size = cbuf.insts_size();
 1550   if (UseCompressedClassPointers) {
<span class="line-modified"> 1551     masm.load_klass(rscratch1, j_rarg0, rscratch2);</span>
 1552     masm.cmpptr(rax, rscratch1);
 1553   } else {
 1554     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1555   }
 1556 
 1557   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1558 
 1559   /* WARNING these NOPs are critical so that verified entry point is properly
 1560      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1561   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1562   if (OptoBreakpoint) {
 1563     // Leave space for int3
 1564     nops_cnt -= 1;
 1565   }
 1566   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1567   if (nops_cnt &gt; 0)
 1568     masm.nop(nops_cnt);
 1569 }
 1570 
 1571 //=============================================================================
</pre>
<hr />
<pre>
 5947   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5948   opcode(0x89);
 5949   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5950   ins_pipe(ialu_mem_reg); // XXX
 5951 %}
 5952 
 5953 // Store Pointer
 5954 instruct storeP(memory mem, any_RegP src)
 5955 %{
 5956   match(Set mem (StoreP mem src));
 5957 
 5958   ins_cost(125); // XXX
 5959   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5960   opcode(0x89);
 5961   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5962   ins_pipe(ialu_mem_reg);
 5963 %}
 5964 
 5965 instruct storeImmP0(memory mem, immP0 zero)
 5966 %{
<span class="line-modified"> 5967   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 5968   match(Set mem (StoreP mem zero));
 5969 
 5970   ins_cost(125); // XXX
 5971   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5972   ins_encode %{
 5973     __ movq($mem$$Address, r12);
 5974   %}
 5975   ins_pipe(ialu_mem_reg);
 5976 %}
 5977 
 5978 // Store NULL Pointer, mark word, or other simple pointer constant.
 5979 instruct storeImmP(memory mem, immP31 src)
 5980 %{
 5981   match(Set mem (StoreP mem src));
 5982 
 5983   ins_cost(150); // XXX
 5984   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5985   opcode(0xC7); /* C7 /0 */
 5986   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5987   ins_pipe(ialu_mem_imm);
</pre>
<hr />
<pre>
 5997   ins_encode %{
 5998     __ movl($mem$$Address, $src$$Register);
 5999   %}
 6000   ins_pipe(ialu_mem_reg);
 6001 %}
 6002 
 6003 instruct storeNKlass(memory mem, rRegN src)
 6004 %{
 6005   match(Set mem (StoreNKlass mem src));
 6006 
 6007   ins_cost(125); // XXX
 6008   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6009   ins_encode %{
 6010     __ movl($mem$$Address, $src$$Register);
 6011   %}
 6012   ins_pipe(ialu_mem_reg);
 6013 %}
 6014 
 6015 instruct storeImmN0(memory mem, immN0 zero)
 6016 %{
<span class="line-modified"> 6017   predicate(CompressedOops::base() == NULL);</span>
 6018   match(Set mem (StoreN mem zero));
 6019 
 6020   ins_cost(125); // XXX
 6021   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6022   ins_encode %{
 6023     __ movl($mem$$Address, r12);
 6024   %}
 6025   ins_pipe(ialu_mem_reg);
 6026 %}
 6027 
 6028 instruct storeImmN(memory mem, immN src)
 6029 %{
 6030   match(Set mem (StoreN mem src));
 6031 
 6032   ins_cost(150); // XXX
 6033   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6034   ins_encode %{
 6035     address con = (address)$src$$constant;
 6036     if (con == NULL) {
 6037       __ movl($mem$$Address, (int32_t)0);
</pre>
<hr />
<pre>
 6040     }
 6041   %}
 6042   ins_pipe(ialu_mem_imm);
 6043 %}
 6044 
 6045 instruct storeImmNKlass(memory mem, immNKlass src)
 6046 %{
 6047   match(Set mem (StoreNKlass mem src));
 6048 
 6049   ins_cost(150); // XXX
 6050   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6051   ins_encode %{
 6052     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6053   %}
 6054   ins_pipe(ialu_mem_imm);
 6055 %}
 6056 
 6057 // Store Integer Immediate
 6058 instruct storeImmI0(memory mem, immI0 zero)
 6059 %{
<span class="line-modified"> 6060   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6061   match(Set mem (StoreI mem zero));
 6062 
 6063   ins_cost(125); // XXX
 6064   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6065   ins_encode %{
 6066     __ movl($mem$$Address, r12);
 6067   %}
 6068   ins_pipe(ialu_mem_reg);
 6069 %}
 6070 
 6071 instruct storeImmI(memory mem, immI src)
 6072 %{
 6073   match(Set mem (StoreI mem src));
 6074 
 6075   ins_cost(150);
 6076   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6077   opcode(0xC7); /* C7 /0 */
 6078   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6079   ins_pipe(ialu_mem_imm);
 6080 %}
 6081 
 6082 // Store Long Immediate
 6083 instruct storeImmL0(memory mem, immL0 zero)
 6084 %{
<span class="line-modified"> 6085   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6086   match(Set mem (StoreL mem zero));
 6087 
 6088   ins_cost(125); // XXX
 6089   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6090   ins_encode %{
 6091     __ movq($mem$$Address, r12);
 6092   %}
 6093   ins_pipe(ialu_mem_reg);
 6094 %}
 6095 
 6096 instruct storeImmL(memory mem, immL32 src)
 6097 %{
 6098   match(Set mem (StoreL mem src));
 6099 
 6100   ins_cost(150);
 6101   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6102   opcode(0xC7); /* C7 /0 */
 6103   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6104   ins_pipe(ialu_mem_imm);
 6105 %}
 6106 
 6107 // Store Short/Char Immediate
 6108 instruct storeImmC0(memory mem, immI0 zero)
 6109 %{
<span class="line-modified"> 6110   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6111   match(Set mem (StoreC mem zero));
 6112 
 6113   ins_cost(125); // XXX
 6114   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6115   ins_encode %{
 6116     __ movw($mem$$Address, r12);
 6117   %}
 6118   ins_pipe(ialu_mem_reg);
 6119 %}
 6120 
 6121 instruct storeImmI16(memory mem, immI16 src)
 6122 %{
 6123   predicate(UseStoreImmI16);
 6124   match(Set mem (StoreC mem src));
 6125 
 6126   ins_cost(150);
 6127   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6128   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6129   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6130   ins_pipe(ialu_mem_imm);
 6131 %}
 6132 
 6133 // Store Byte Immediate
 6134 instruct storeImmB0(memory mem, immI0 zero)
 6135 %{
<span class="line-modified"> 6136   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6137   match(Set mem (StoreB mem zero));
 6138 
 6139   ins_cost(125); // XXX
 6140   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6141   ins_encode %{
 6142     __ movb($mem$$Address, r12);
 6143   %}
 6144   ins_pipe(ialu_mem_reg);
 6145 %}
 6146 
 6147 instruct storeImmB(memory mem, immI8 src)
 6148 %{
 6149   match(Set mem (StoreB mem src));
 6150 
 6151   ins_cost(150); // XXX
 6152   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6153   opcode(0xC6); /* C6 /0 */
 6154   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6155   ins_pipe(ialu_mem_imm);
 6156 %}
 6157 
 6158 // Store CMS card-mark Immediate
 6159 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6160 %{
<span class="line-modified"> 6161   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6162   match(Set mem (StoreCM mem zero));
 6163 
 6164   ins_cost(125); // XXX
 6165   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6166   ins_encode %{
 6167     __ movb($mem$$Address, r12);
 6168   %}
 6169   ins_pipe(ialu_mem_reg);
 6170 %}
 6171 
 6172 instruct storeImmCM0(memory mem, immI0 src)
 6173 %{
 6174   match(Set mem (StoreCM mem src));
 6175 
 6176   ins_cost(150); // XXX
 6177   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6178   opcode(0xC6); /* C6 /0 */
 6179   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6180   ins_pipe(ialu_mem_imm);
 6181 %}
 6182 
 6183 // Store Float
 6184 instruct storeF(memory mem, regF src)
 6185 %{
 6186   match(Set mem (StoreF mem src));
 6187 
 6188   ins_cost(95); // XXX
 6189   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6190   ins_encode %{
 6191     __ movflt($mem$$Address, $src$$XMMRegister);
 6192   %}
 6193   ins_pipe(pipe_slow); // XXX
 6194 %}
 6195 
 6196 // Store immediate Float value (it is faster than store from XMM register)
 6197 instruct storeF0(memory mem, immF0 zero)
 6198 %{
<span class="line-modified"> 6199   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6200   match(Set mem (StoreF mem zero));
 6201 
 6202   ins_cost(25); // XXX
 6203   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6204   ins_encode %{
 6205     __ movl($mem$$Address, r12);
 6206   %}
 6207   ins_pipe(ialu_mem_reg);
 6208 %}
 6209 
 6210 instruct storeF_imm(memory mem, immF src)
 6211 %{
 6212   match(Set mem (StoreF mem src));
 6213 
 6214   ins_cost(50);
 6215   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6216   opcode(0xC7); /* C7 /0 */
 6217   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6218   ins_pipe(ialu_mem_imm);
 6219 %}
</pre>
<hr />
<pre>
 6229     __ movdbl($mem$$Address, $src$$XMMRegister);
 6230   %}
 6231   ins_pipe(pipe_slow); // XXX
 6232 %}
 6233 
 6234 // Store immediate double 0.0 (it is faster than store from XMM register)
 6235 instruct storeD0_imm(memory mem, immD0 src)
 6236 %{
 6237   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6238   match(Set mem (StoreD mem src));
 6239 
 6240   ins_cost(50);
 6241   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6242   opcode(0xC7); /* C7 /0 */
 6243   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6244   ins_pipe(ialu_mem_imm);
 6245 %}
 6246 
 6247 instruct storeD0(memory mem, immD0 zero)
 6248 %{
<span class="line-modified"> 6249   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6250   match(Set mem (StoreD mem zero));
 6251 
 6252   ins_cost(25); // XXX
 6253   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6254   ins_encode %{
 6255     __ movq($mem$$Address, r12);
 6256   %}
 6257   ins_pipe(ialu_mem_reg);
 6258 %}
 6259 
 6260 instruct storeSSI(stackSlotI dst, rRegI src)
 6261 %{
 6262   match(Set dst src);
 6263 
 6264   ins_cost(100);
 6265   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6266   opcode(0x89);
 6267   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6268   ins_pipe( ialu_mem_reg );
 6269 %}
</pre>
<hr />
<pre>
 6822 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6823   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6824             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6825   match(Set dst (DecodeN src));
 6826   effect(KILL cr);
 6827   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6828   ins_encode %{
 6829     Register s = $src$$Register;
 6830     Register d = $dst$$Register;
 6831     if (s != d) {
 6832       __ decode_heap_oop_not_null(d, s);
 6833     } else {
 6834       __ decode_heap_oop_not_null(d);
 6835     }
 6836   %}
 6837   ins_pipe(ialu_reg_long);
 6838 %}
 6839 
 6840 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6841   match(Set dst (EncodePKlass src));
<span class="line-modified"> 6842   effect(TEMP dst, KILL cr);</span>
<span class="line-modified"> 6843   format %{ &quot;encode_and_move_klass_not_null $dst,$src&quot; %}</span>
 6844   ins_encode %{
<span class="line-modified"> 6845     __ encode_and_move_klass_not_null($dst$$Register, $src$$Register);</span>
 6846   %}
 6847   ins_pipe(ialu_reg_long);
 6848 %}
 6849 
 6850 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6851   match(Set dst (DecodeNKlass src));
<span class="line-modified"> 6852   effect(TEMP dst, KILL cr);</span>
<span class="line-modified"> 6853   format %{ &quot;decode_and_move_klass_not_null $dst,$src&quot; %}</span>
 6854   ins_encode %{
<span class="line-modified"> 6855     __ decode_and_move_klass_not_null($dst$$Register, $src$$Register);</span>






 6856   %}
 6857   ins_pipe(ialu_reg_long);
 6858 %}
 6859 

 6860 //----------Conditional Move---------------------------------------------------
 6861 // Jump
 6862 // dummy instruction for generating temp registers
 6863 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6864   match(Jump (LShiftL switch_val shift));
 6865   ins_cost(350);
 6866   predicate(false);
 6867   effect(TEMP dest);
 6868 
 6869   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6870             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6871   ins_encode %{
 6872     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6873     // to do that and the compiler is using that register as one it can allocate.
 6874     // So we build it all by hand.
 6875     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6876     // ArrayAddress dispatch(table, index);
 6877     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6878     __ lea($dest$$Register, $constantaddress);
 6879     __ jmp(dispatch);
</pre>
<hr />
<pre>
11859 
11860 // This will generate a signed flags result. This should be OK since
11861 // any compare to a zero should be eq/neq.
11862 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11863 %{
11864   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11865             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11866   match(Set cr (CmpP (LoadP op) zero));
11867 
11868   ins_cost(500); // XXX
11869   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11870   opcode(0xF7); /* Opcode F7 /0 */
11871   ins_encode(REX_mem_wide(op),
11872              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11873   ins_pipe(ialu_cr_reg_imm);
11874 %}
11875 
11876 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11877 %{
11878   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;

11879             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11880   match(Set cr (CmpP (LoadP mem) zero));
11881 
11882   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11883   ins_encode %{
11884     __ cmpq(r12, $mem$$Address);
11885   %}
11886   ins_pipe(ialu_cr_reg_mem);
11887 %}
11888 
11889 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11890 %{
11891   match(Set cr (CmpN op1 op2));
11892 
11893   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11894   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11895   ins_pipe(ialu_cr_reg_reg);
11896 %}
11897 
11898 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
</pre>
<hr />
<pre>
11954   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11955   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11956   ins_pipe(ialu_cr_reg_imm);
11957 %}
11958 
11959 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11960 %{
11961   predicate(CompressedOops::base() != NULL);
11962   match(Set cr (CmpN (LoadN mem) zero));
11963 
11964   ins_cost(500); // XXX
11965   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11966   ins_encode %{
11967     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11968   %}
11969   ins_pipe(ialu_cr_reg_mem);
11970 %}
11971 
11972 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11973 %{
<span class="line-modified">11974   predicate(CompressedOops::base() == NULL);</span>
11975   match(Set cr (CmpN (LoadN mem) zero));
11976 
11977   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11978   ins_encode %{
11979     __ cmpl(r12, $mem$$Address);
11980   %}
11981   ins_pipe(ialu_cr_reg_mem);
11982 %}
11983 
11984 // Yanked all unsigned pointer compare operations.
11985 // Pointer compares are done with CmpP which is already unsigned.
11986 
11987 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11988 %{
11989   match(Set cr (CmpL op1 op2));
11990 
11991   format %{ &quot;cmpq    $op1, $op2&quot; %}
11992   opcode(0x3B);  /* Opcode 3B /r */
11993   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11994   ins_pipe(ialu_cr_reg_reg);
</pre>
<hr />
<pre>
12612 
12613 // ============================================================================
12614 // inlined locking and unlocking
12615 
12616 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12617   predicate(Compile::current()-&gt;use_rtm());
12618   match(Set cr (FastLock object box));
12619   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12620   ins_cost(300);
12621   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12622   ins_encode %{
12623     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12624                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12625                  _counters, _rtm_counters, _stack_rtm_counters,
12626                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12627                  true, ra_-&gt;C-&gt;profile_rtm());
12628   %}
12629   ins_pipe(pipe_slow);
12630 %}
12631 
<span class="line-modified">12632 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr, rRegP cx1) %{</span>
12633   predicate(!Compile::current()-&gt;use_rtm());
12634   match(Set cr (FastLock object box));
<span class="line-modified">12635   effect(TEMP tmp, TEMP scr, TEMP cx1, USE_KILL box);</span>
12636   ins_cost(300);
12637   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12638   ins_encode %{
12639     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
<span class="line-modified">12640                  $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);</span>
12641   %}
12642   ins_pipe(pipe_slow);
12643 %}
12644 
12645 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12646   match(Set cr (FastUnlock object box));
12647   effect(TEMP tmp, USE_KILL box);
12648   ins_cost(300);
12649   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12650   ins_encode %{
12651     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12652   %}
12653   ins_pipe(pipe_slow);
12654 %}
12655 
12656 
12657 // ============================================================================
12658 // Safepoint Instructions
12659 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12660 %{
</pre>
</td>
</tr>
</table>
<center><a href="vtableStubs_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_Runtime1.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
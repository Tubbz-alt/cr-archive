<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubGenerator_x86_64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs_x86_64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/templateTable_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1152,18 ***</span>
  
    __ testptr(rax, rax);
    __ jcc(Assembler::zero, is_null);
  
    // Move array class to rdi
<span class="line-modified">!   __ load_klass(rdi, rdx);</span>
    if (ValueArrayFlatten) {
      __ movl(rbx, Address(rdi, Klass::layout_helper_offset()));
      __ test_flattened_array_layout(rbx, is_flat_array);
    }
  
    // Move subklass into rbx
<span class="line-modified">!   __ load_klass(rbx, rax);</span>
    // Move array element superklass into rax
    __ movptr(rax, Address(rdi,
                           ObjArrayKlass::element_klass_offset()));
  
    // Generate subtype check.  Blows rcx, rdi
<span class="line-new-header">--- 1152,19 ---</span>
  
    __ testptr(rax, rax);
    __ jcc(Assembler::zero, is_null);
  
    // Move array class to rdi
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rdi, rdx, tmp_load_klass);</span>
    if (ValueArrayFlatten) {
      __ movl(rbx, Address(rdi, Klass::layout_helper_offset()));
      __ test_flattened_array_layout(rbx, is_flat_array);
    }
  
    // Move subklass into rbx
<span class="line-modified">!   __ load_klass(rbx, rax, tmp_load_klass);</span>
    // Move array element superklass into rax
    __ movptr(rax, Address(rdi,
                           ObjArrayKlass::element_klass_offset()));
  
    // Generate subtype check.  Blows rcx, rdi
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1208,11 ***</span>
      __ bind(is_flat_array); // Store non-null value to flat
  
      // Simplistic type check...
  
      // Profile the not-null value&#39;s klass.
<span class="line-modified">!     __ load_klass(rbx, rax);</span>
      // Move element klass into rax
      __ movptr(rax, Address(rdi, ArrayKlass::element_klass_offset()));
      // flat value array needs exact type match
      // is &quot;rax == rbx&quot; (value subclass == array element superclass)
      __ cmpptr(rax, rbx);
<span class="line-new-header">--- 1209,11 ---</span>
      __ bind(is_flat_array); // Store non-null value to flat
  
      // Simplistic type check...
  
      // Profile the not-null value&#39;s klass.
<span class="line-modified">!     __ load_klass(rbx, rax, tmp_load_klass);</span>
      // Move element klass into rax
      __ movptr(rax, Address(rdi, ArrayKlass::element_klass_offset()));
      // flat value array needs exact type match
      // is &quot;rax == rbx&quot; (value subclass == array element superclass)
      __ cmpptr(rax, rbx);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1248,11 ***</span>
    // rbx: index
    // rdx: array
    index_check(rdx, rbx); // prefer index in rbx
    // Need to check whether array is boolean or byte
    // since both types share the bastore bytecode.
<span class="line-modified">!   __ load_klass(rcx, rdx);</span>
    __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
    int diffbit = Klass::layout_helper_boolean_diffbit();
    __ testl(rcx, diffbit);
    Label L_skip;
    __ jccb(Assembler::zero, L_skip);
<span class="line-new-header">--- 1249,12 ---</span>
    // rbx: index
    // rdx: array
    index_check(rdx, rbx); // prefer index in rbx
    // Need to check whether array is boolean or byte
    // since both types share the bastore bytecode.
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rcx, rdx, tmp_load_klass);</span>
    __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
    int diffbit = Klass::layout_helper_boolean_diffbit();
    __ testl(rcx, diffbit);
    Label L_skip;
    __ jccb(Assembler::zero, L_skip);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2764,11 ***</span>
  
    if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
      assert(state == vtos, &quot;only valid state&quot;);
      Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);
      __ movptr(robj, aaddress(0));
<span class="line-modified">!     __ load_klass(rdi, robj);</span>
      __ movl(rdi, Address(rdi, Klass::access_flags_offset()));
      __ testl(rdi, JVM_ACC_HAS_FINALIZER);
      Label skip_register_finalizer;
      __ jcc(Assembler::zero, skip_register_finalizer);
  
<span class="line-new-header">--- 2766,12 ---</span>
  
    if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
      assert(state == vtos, &quot;only valid state&quot;);
      Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);
      __ movptr(robj, aaddress(0));
<span class="line-modified">!     Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+     __ load_klass(rdi, robj, tmp_load_klass);</span>
      __ movl(rdi, Address(rdi, Klass::access_flags_offset()));
      __ testl(rdi, JVM_ACC_HAS_FINALIZER);
      Label skip_register_finalizer;
      __ jcc(Assembler::zero, skip_register_finalizer);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3472,11 ***</span>
          do_oop_store(_masm, field, rax);
          __ jmp(rewriteFlattenable);
          __ bind(isFlattened);
          pop_and_check_object(obj);
          assert_different_registers(rax, rdx, obj, off);
<span class="line-modified">!         __ load_klass(rdx, rax);</span>
          __ data_for_oop(rax, rax, rdx);
          __ addptr(obj, off);
          __ access_value_copy(IN_HEAP, rax, obj, rdx);
          __ bind(rewriteFlattenable);
          if (rc == may_rewrite) {
<span class="line-new-header">--- 3475,11 ---</span>
          do_oop_store(_masm, field, rax);
          __ jmp(rewriteFlattenable);
          __ bind(isFlattened);
          pop_and_check_object(obj);
          assert_different_registers(rax, rdx, obj, off);
<span class="line-modified">!         __ load_klass(rdx, rax, rscratch1);</span>
          __ data_for_oop(rax, rax, rdx);
          __ addptr(obj, off);
          __ access_value_copy(IN_HEAP, rax, obj, rdx);
          __ bind(rewriteFlattenable);
          if (rc == may_rewrite) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3735,11 ***</span>
        // No Flattened case
        do_oop_store(_masm, field, rax);
        __ jmp(done);
        __ bind(isFlattened);
        // Flattened case
<span class="line-modified">!       __ load_klass(rdx, rax);</span>
        __ data_for_oop(rax, rax, rdx);
        __ lea(rcx, field);
        __ access_value_copy(IN_HEAP, rax, rcx, rdx);
        __ bind(done);
      }
<span class="line-new-header">--- 3738,11 ---</span>
        // No Flattened case
        do_oop_store(_masm, field, rax);
        __ jmp(done);
        __ bind(isFlattened);
        // Flattened case
<span class="line-modified">!       __ load_klass(rdx, rax, rscratch1);</span>
        __ data_for_oop(rax, rax, rdx);
        __ lea(rcx, field);
        __ access_value_copy(IN_HEAP, rax, rcx, rdx);
        __ bind(done);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4077,11 ***</span>
  
    __ bind(notFinal);
  
    // get receiver klass
    __ null_check(recv, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   __ load_klass(rax, recv);</span>
  
    // profile this call
    __ profile_virtual_call(rax, rlocals, rdx);
    // get target Method* &amp; entry point
    __ lookup_virtual_method(rax, index, method);
<span class="line-new-header">--- 4080,12 ---</span>
  
    __ bind(notFinal);
  
    // get receiver klass
    __ null_check(recv, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rax, recv, tmp_load_klass);</span>
  
    // profile this call
    __ profile_virtual_call(rax, rlocals, rdx);
    // get target Method* &amp; entry point
    __ lookup_virtual_method(rax, index, method);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4169,11 ***</span>
    __ andl(rlocals, (1 &lt;&lt; ConstantPoolCacheEntry::is_vfinal_shift));
    __ jcc(Assembler::zero, notVFinal);
  
    // Get receiver klass into rlocals - also a null check
    __ null_check(rcx, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   __ load_klass(rlocals, rcx);</span>
  
    Label subtype;
    __ check_klass_subtype(rlocals, rax, rbcp, subtype);
    // If we get here the typecheck failed
    recvKlass = rdx;
<span class="line-new-header">--- 4173,12 ---</span>
    __ andl(rlocals, (1 &lt;&lt; ConstantPoolCacheEntry::is_vfinal_shift));
    __ jcc(Assembler::zero, notVFinal);
  
    // Get receiver klass into rlocals - also a null check
    __ null_check(rcx, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rlocals, rcx, tmp_load_klass);</span>
  
    Label subtype;
    __ check_klass_subtype(rlocals, rax, rbcp, subtype);
    // If we get here the typecheck failed
    recvKlass = rdx;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4192,11 ***</span>
    __ bind(notVFinal);
  
    // Get receiver klass into rdx - also a null check
    __ restore_locals();  // restore r14
    __ null_check(rcx, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   __ load_klass(rdx, rcx);</span>
  
    Label no_such_method;
  
    // Preserve method for throw_AbstractMethodErrorVerbose.
    __ mov(rcx, rbx);
<span class="line-new-header">--- 4197,11 ---</span>
    __ bind(notVFinal);
  
    // Get receiver klass into rdx - also a null check
    __ restore_locals();  // restore r14
    __ null_check(rcx, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   __ load_klass(rdx, rcx, tmp_load_klass);</span>
  
    Label no_such_method;
  
    // Preserve method for throw_AbstractMethodErrorVerbose.
    __ mov(rcx, rbx);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4494,11 ***</span>
    __ bind(quicked);
    __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
    __ load_resolved_klass_at_index(rax, rcx, rbx);
  
    __ bind(resolved);
<span class="line-modified">!   __ load_klass(rbx, rdx);</span>
  
    // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
    // Superklass in rax.  Subklass in rbx.
    __ gen_subtype_check(rbx, ok_is_subtype);
  
<span class="line-new-header">--- 4499,12 ---</span>
    __ bind(quicked);
    __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
    __ load_resolved_klass_at_index(rax, rcx, rbx);
  
    __ bind(resolved);
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rbx, rdx, tmp_load_klass);</span>
  
    // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
    // Superklass in rax.  Subklass in rbx.
    __ gen_subtype_check(rbx, ok_is_subtype);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4566,16 ***</span>
    __ get_vm_result_2(rax, r15_thread);
  #endif
  
    __ pop_ptr(rdx); // restore receiver
    __ verify_oop(rdx);
<span class="line-modified">!   __ load_klass(rdx, rdx);</span>
    __ jmpb(resolved);
  
    // Get superklass in rax and subklass in rdx
    __ bind(quicked);
<span class="line-modified">!   __ load_klass(rdx, rax);</span>
    __ load_resolved_klass_at_index(rax, rcx, rbx);
  
    __ bind(resolved);
  
    // Generate subtype check.  Blows rcx, rdi
<span class="line-new-header">--- 4572,17 ---</span>
    __ get_vm_result_2(rax, r15_thread);
  #endif
  
    __ pop_ptr(rdx); // restore receiver
    __ verify_oop(rdx);
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rdx, rdx, tmp_load_klass);</span>
    __ jmpb(resolved);
  
    // Get superklass in rax and subklass in rdx
    __ bind(quicked);
<span class="line-modified">!   __ load_klass(rdx, rax, tmp_load_klass);</span>
    __ load_resolved_klass_at_index(rax, rcx, rbx);
  
    __ bind(resolved);
  
    // Generate subtype check.  Blows rcx, rdi
</pre>
<center><a href="stubGenerator_x86_64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs_x86_64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/stubGenerator_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/stubGenerator_x86_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1081     // make sure object is &#39;reasonable&#39;
1082     __ testptr(rax, rax);
1083     __ jcc(Assembler::zero, exit); // if obj is NULL it is OK
1084 
1085 #if INCLUDE_ZGC
1086     if (UseZGC) {
1087       // Check if metadata bits indicate a bad oop
1088       __ testptr(rax, Address(r15_thread, ZThreadLocalData::address_bad_mask_offset()));
1089       __ jcc(Assembler::notZero, error);
1090     }
1091 #endif
1092 
1093     // Check if the oop is in the right area of memory
1094     __ movptr(c_rarg2, rax);
1095     __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_mask());
1096     __ andptr(c_rarg2, c_rarg3);
1097     __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_bits());
1098     __ cmpptr(c_rarg2, c_rarg3);
1099     __ jcc(Assembler::notZero, error);
1100 
<span class="line-modified">1101     // set r12 to heapbase for load_klass()</span>
<span class="line-removed">1102     __ reinit_heapbase();</span>
<span class="line-removed">1103 </span>
<span class="line-removed">1104     // make sure klass is &#39;reasonable&#39;, which is not zero.</span>
1105     __ load_klass(rax, rax);  // get klass
1106     __ testptr(rax, rax);
1107     __ jcc(Assembler::zero, error); // if klass is NULL it is broken
1108 
1109     // return if everything seems ok
1110     __ bind(exit);
1111     __ movptr(rax, Address(rsp, saved_rax));     // get saved rax back
1112     __ movptr(rscratch1, Address(rsp, saved_r10)); // get saved r10 back
1113     __ pop(c_rarg3);                             // restore c_rarg3
1114     __ pop(c_rarg2);                             // restore c_rarg2
1115     __ pop(r12);                                 // restore r12
1116     __ popf();                                   // restore flags
1117     __ ret(4 * wordSize);                        // pop caller saved stuff
1118 
1119     // handle errors
1120     __ bind(error);
1121     __ movptr(rax, Address(rsp, saved_rax));     // get saved rax back
1122     __ movptr(rscratch1, Address(rsp, saved_r10)); // get saved r10 back
1123     __ pop(c_rarg3);                             // get saved c_rarg3 back
1124     __ pop(c_rarg2);                             // get saved c_rarg2 back
</pre>
<hr />
<pre>
2523     __ jmp(L_done);
2524 
2525     // ======== begin loop ========
2526     // (Loop is rotated; its entry is L_load_element.)
2527     // Loop control:
2528     //   for (count = -count; count != 0; count++)
2529     // Base pointers src, dst are biased by 8*(count-1),to last element.
2530     __ align(OptoLoopAlignment);
2531 
2532     __ BIND(L_store_element);
2533     __ store_heap_oop(to_element_addr, rax_oop, noreg, noreg, noreg, AS_RAW);  // store the oop
2534     __ increment(count);               // increment the count toward zero
2535     __ jcc(Assembler::zero, L_do_card_marks);
2536 
2537     // ======== loop entry is here ========
2538     __ BIND(L_load_element);
2539     __ load_heap_oop(rax_oop, from_element_addr, noreg, noreg, AS_RAW); // load the oop
2540     __ testptr(rax_oop, rax_oop);
2541     __ jcc(Assembler::zero, L_store_element);
2542 
<span class="line-modified">2543     __ load_klass(r11_klass, rax_oop);// query the object klass</span>
2544     generate_type_check(r11_klass, ckoff, ckval, L_store_element);
2545     // ======== end loop ========
2546 
2547     // It was a real error; we must depend on the caller to finish the job.
2548     // Register rdx = -1 * number of *remaining* oops, r14 = *total* oops.
2549     // Emit GC store barriers for the oops we have copied (r14 + rdx),
2550     // and report their number to the caller.
2551     assert_different_registers(rax, r14_length, count, to, end_to, rcx, rscratch1);
2552     Label L_post_barrier;
2553     __ addptr(r14_length, count);     // K = (original - remaining) oops
2554     __ movptr(rax, r14_length);       // save the value
2555     __ notptr(rax);                   // report (-1^K) to caller (does not affect flags)
2556     __ jccb(Assembler::notZero, L_post_barrier);
2557     __ jmp(L_done); // K == 0, nothing was copied, skip post barrier
2558 
2559     // Come here on success only.
2560     __ BIND(L_do_card_marks);
2561     __ xorptr(rax, rax);              // return 0 on success
2562 
2563     __ BIND(L_post_barrier);
</pre>
<hr />
<pre>
2687   //
2688   //  Output:
2689   //    rax ==  0  -  success
2690   //    rax == -1^K - failure, where K is partial transfer count
2691   //
2692   address generate_generic_copy(const char *name,
2693                                 address byte_copy_entry, address short_copy_entry,
2694                                 address int_copy_entry, address oop_copy_entry,
2695                                 address long_copy_entry, address checkcast_copy_entry) {
2696 
2697     Label L_failed, L_failed_0, L_objArray;
2698     Label L_copy_bytes, L_copy_shorts, L_copy_ints, L_copy_longs;
2699 
2700     // Input registers
2701     const Register src        = c_rarg0;  // source array oop
2702     const Register src_pos    = c_rarg1;  // source position
2703     const Register dst        = c_rarg2;  // destination array oop
2704     const Register dst_pos    = c_rarg3;  // destination position
2705 #ifndef _WIN64
2706     const Register length     = c_rarg4;

2707 #else
2708     const Address  length(rsp, 6 * wordSize);  // elements count is on stack on Win64

2709 #endif
2710 
2711     { int modulus = CodeEntryAlignment;
2712       int target  = modulus - 5; // 5 = sizeof jmp(L_failed)
2713       int advance = target - (__ offset() % modulus);
2714       if (advance &lt; 0)  advance += modulus;
2715       if (advance &gt; 0)  __ nop(advance);
2716     }
2717     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2718 
2719     // Short-hop target to L_failed.  Makes for denser prologue code.
2720     __ BIND(L_failed_0);
2721     __ jmp(L_failed);
2722     assert(__ offset() % CodeEntryAlignment == 0, &quot;no further alignment needed&quot;);
2723 
2724     __ align(CodeEntryAlignment);
2725     address start = __ pc();
2726 
2727     __ enter(); // required for proper stackwalking of RuntimeStub frame
2728 
</pre>
<hr />
<pre>
2761     size_t j4off = __ offset();
2762     __ jccb(Assembler::negative, L_failed_0);
2763 
2764     // The first four tests are very dense code,
2765     // but not quite dense enough to put four
2766     // jumps in a 16-byte instruction fetch buffer.
2767     // That&#39;s good, because some branch predicters
2768     // do not like jumps so close together.
2769     // Make sure of this.
2770     guarantee(((j1off ^ j4off) &amp; ~15) != 0, &quot;I$ line of 1st &amp; 4th jumps&quot;);
2771 
2772     // registers used as temp
2773     const Register r11_length    = r11; // elements count to copy
2774     const Register r10_src_klass = r10; // array klass
2775 
2776     //  if (length &lt; 0) return -1;
2777     __ movl(r11_length, length);        // length (elements count, 32-bits value)
2778     __ testl(r11_length, r11_length);
2779     __ jccb(Assembler::negative, L_failed_0);
2780 
<span class="line-modified">2781     __ load_klass(r10_src_klass, src);</span>
2782 #ifdef ASSERT
2783     //  assert(src-&gt;klass() != NULL);
2784     {
2785       BLOCK_COMMENT(&quot;assert klasses not null {&quot;);
2786       Label L1, L2;
2787       __ testptr(r10_src_klass, r10_src_klass);
2788       __ jcc(Assembler::notZero, L2);   // it is broken if klass is NULL
2789       __ bind(L1);
2790       __ stop(&quot;broken null klass&quot;);
2791       __ bind(L2);
<span class="line-modified">2792       __ load_klass(rax, dst);</span>
2793       __ cmpq(rax, 0);
2794       __ jcc(Assembler::equal, L1);     // this would be broken also
2795       BLOCK_COMMENT(&quot;} assert klasses not null done&quot;);
2796     }
2797 #endif
2798 
2799     // Load layout helper (32-bits)
2800     //
2801     //  |array_tag|     | header_size | element_type |     |log2_element_size|
2802     // 32        30    24            16              8     2                 0
2803     //
2804     //   array_tag: typeArray = 0x3, objArray = 0x2, non-array = 0x0
2805     //
2806 
2807     const int lh_offset = in_bytes(Klass::layout_helper_offset());
2808 
2809     // Handle objArrays completely differently...
2810     const jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2811     __ cmpl(Address(r10_src_klass, lh_offset), objArray_lh);
2812     __ jcc(Assembler::equal, L_objArray);
2813 
2814     //  if (src-&gt;klass() != dst-&gt;klass()) return -1;
<span class="line-modified">2815     __ load_klass(rax, dst);</span>
2816     __ cmpq(r10_src_klass, rax);
2817     __ jcc(Assembler::notEqual, L_failed);
2818 
2819     const Register rax_lh = rax;  // layout helper
2820     __ movl(rax_lh, Address(r10_src_klass, lh_offset));
2821 
2822     //  if (!src-&gt;is_Array()) return -1;
2823     __ cmpl(rax_lh, Klass::_lh_neutral_value);
2824     __ jcc(Assembler::greaterEqual, L_failed);
2825 
2826     // At this point, it is known to be a typeArray (array_tag 0x3).
2827 #ifdef ASSERT
2828     {
2829       BLOCK_COMMENT(&quot;assert primitive array {&quot;);
2830       Label L;
2831       __ cmpl(rax_lh, (Klass::_lh_array_tag_type_value &lt;&lt; Klass::_lh_array_tag_shift));
2832       __ jcc(Assembler::greaterEqual, L);
2833       __ stop(&quot;must be a primitive array&quot;);
2834       __ bind(L);
2835       BLOCK_COMMENT(&quot;} assert primitive array done&quot;);
</pre>
<hr />
<pre>
2894       BLOCK_COMMENT(&quot;assert long copy {&quot;);
2895       Label L;
2896       __ cmpl(rax_elsize, LogBytesPerLong);
2897       __ jcc(Assembler::equal, L);
2898       __ stop(&quot;must be long copy, but elsize is wrong&quot;);
2899       __ bind(L);
2900       BLOCK_COMMENT(&quot;} assert long copy done&quot;);
2901     }
2902 #endif
2903     __ lea(from, Address(src, src_pos, Address::times_8, 0));// src_addr
2904     __ lea(to,   Address(dst, dst_pos, Address::times_8, 0));// dst_addr
2905     __ movl2ptr(count, r11_length); // length
2906     __ jump(RuntimeAddress(long_copy_entry));
2907 
2908     // ObjArrayKlass
2909   __ BIND(L_objArray);
2910     // live at this point:  r10_src_klass, r11_length, src[_pos], dst[_pos]
2911 
2912     Label L_plain_copy, L_checkcast_copy;
2913     //  test array classes for subtyping
<span class="line-modified">2914     __ load_klass(rax, dst);</span>
2915     __ cmpq(r10_src_klass, rax); // usual case is exact equality
2916     __ jcc(Assembler::notEqual, L_checkcast_copy);
2917 
2918     // Identically typed arrays can be copied without element-wise checks.
2919     arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,
2920                            r10, L_failed);
2921 
2922     __ lea(from, Address(src, src_pos, TIMES_OOP,
2923                  arrayOopDesc::base_offset_in_bytes(T_OBJECT))); // src_addr
2924     __ lea(to,   Address(dst, dst_pos, TIMES_OOP,
2925                  arrayOopDesc::base_offset_in_bytes(T_OBJECT))); // dst_addr
2926     __ movl2ptr(count, r11_length); // length
2927   __ BIND(L_plain_copy);
2928     __ jump(RuntimeAddress(oop_copy_entry));
2929 
2930   __ BIND(L_checkcast_copy);
2931     // live at this point:  r10_src_klass, r11_length, rax (dst_klass)
2932     {
2933       // Before looking at dst.length, make sure dst is also an objArray.
2934       __ cmpl(Address(rax, lh_offset), objArray_lh);
2935       __ jcc(Assembler::notEqual, L_failed);
2936 
2937       // It is safe to examine both src.length and dst.length.
2938       arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,
2939                              rax, L_failed);
2940 
2941       const Register r11_dst_klass = r11;
<span class="line-modified">2942       __ load_klass(r11_dst_klass, dst); // reload</span>
2943 
2944       // Marshal the base address arguments now, freeing registers.
2945       __ lea(from, Address(src, src_pos, TIMES_OOP,
2946                    arrayOopDesc::base_offset_in_bytes(T_OBJECT)));
2947       __ lea(to,   Address(dst, dst_pos, TIMES_OOP,
2948                    arrayOopDesc::base_offset_in_bytes(T_OBJECT)));
2949       __ movl(count, length);           // length (reloaded)
2950       Register sco_temp = c_rarg3;      // this register is free now
2951       assert_different_registers(from, to, count, sco_temp,
2952                                  r11_dst_klass, r10_src_klass);
2953       assert_clean_int(count, sco_temp);
2954 
2955       // Generate the type check.
2956       const int sco_offset = in_bytes(Klass::super_check_offset_offset());
2957       __ movl(sco_temp, Address(r11_dst_klass, sco_offset));
2958       assert_clean_int(sco_temp, rax);
2959       generate_type_check(r10_src_klass, sco_temp, r11_dst_klass, L_plain_copy);
2960 
2961       // Fetch destination element klass from the ObjArrayKlass header.
2962       int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
</pre>
</td>
<td>
<hr />
<pre>
1081     // make sure object is &#39;reasonable&#39;
1082     __ testptr(rax, rax);
1083     __ jcc(Assembler::zero, exit); // if obj is NULL it is OK
1084 
1085 #if INCLUDE_ZGC
1086     if (UseZGC) {
1087       // Check if metadata bits indicate a bad oop
1088       __ testptr(rax, Address(r15_thread, ZThreadLocalData::address_bad_mask_offset()));
1089       __ jcc(Assembler::notZero, error);
1090     }
1091 #endif
1092 
1093     // Check if the oop is in the right area of memory
1094     __ movptr(c_rarg2, rax);
1095     __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_mask());
1096     __ andptr(c_rarg2, c_rarg3);
1097     __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_bits());
1098     __ cmpptr(c_rarg2, c_rarg3);
1099     __ jcc(Assembler::notZero, error);
1100 
<span class="line-modified">1101     // make sure klass is &#39;reasonable&#39;, which is not zero.</span>



1102     __ load_klass(rax, rax, rscratch1);  // get klass
1103     __ testptr(rax, rax);
1104     __ jcc(Assembler::zero, error); // if klass is NULL it is broken
1105 
1106     // return if everything seems ok
1107     __ bind(exit);
1108     __ movptr(rax, Address(rsp, saved_rax));     // get saved rax back
1109     __ movptr(rscratch1, Address(rsp, saved_r10)); // get saved r10 back
1110     __ pop(c_rarg3);                             // restore c_rarg3
1111     __ pop(c_rarg2);                             // restore c_rarg2
1112     __ pop(r12);                                 // restore r12
1113     __ popf();                                   // restore flags
1114     __ ret(4 * wordSize);                        // pop caller saved stuff
1115 
1116     // handle errors
1117     __ bind(error);
1118     __ movptr(rax, Address(rsp, saved_rax));     // get saved rax back
1119     __ movptr(rscratch1, Address(rsp, saved_r10)); // get saved r10 back
1120     __ pop(c_rarg3);                             // get saved c_rarg3 back
1121     __ pop(c_rarg2);                             // get saved c_rarg2 back
</pre>
<hr />
<pre>
2520     __ jmp(L_done);
2521 
2522     // ======== begin loop ========
2523     // (Loop is rotated; its entry is L_load_element.)
2524     // Loop control:
2525     //   for (count = -count; count != 0; count++)
2526     // Base pointers src, dst are biased by 8*(count-1),to last element.
2527     __ align(OptoLoopAlignment);
2528 
2529     __ BIND(L_store_element);
2530     __ store_heap_oop(to_element_addr, rax_oop, noreg, noreg, noreg, AS_RAW);  // store the oop
2531     __ increment(count);               // increment the count toward zero
2532     __ jcc(Assembler::zero, L_do_card_marks);
2533 
2534     // ======== loop entry is here ========
2535     __ BIND(L_load_element);
2536     __ load_heap_oop(rax_oop, from_element_addr, noreg, noreg, AS_RAW); // load the oop
2537     __ testptr(rax_oop, rax_oop);
2538     __ jcc(Assembler::zero, L_store_element);
2539 
<span class="line-modified">2540     __ load_klass(r11_klass, rax_oop, rscratch1);// query the object klass</span>
2541     generate_type_check(r11_klass, ckoff, ckval, L_store_element);
2542     // ======== end loop ========
2543 
2544     // It was a real error; we must depend on the caller to finish the job.
2545     // Register rdx = -1 * number of *remaining* oops, r14 = *total* oops.
2546     // Emit GC store barriers for the oops we have copied (r14 + rdx),
2547     // and report their number to the caller.
2548     assert_different_registers(rax, r14_length, count, to, end_to, rcx, rscratch1);
2549     Label L_post_barrier;
2550     __ addptr(r14_length, count);     // K = (original - remaining) oops
2551     __ movptr(rax, r14_length);       // save the value
2552     __ notptr(rax);                   // report (-1^K) to caller (does not affect flags)
2553     __ jccb(Assembler::notZero, L_post_barrier);
2554     __ jmp(L_done); // K == 0, nothing was copied, skip post barrier
2555 
2556     // Come here on success only.
2557     __ BIND(L_do_card_marks);
2558     __ xorptr(rax, rax);              // return 0 on success
2559 
2560     __ BIND(L_post_barrier);
</pre>
<hr />
<pre>
2684   //
2685   //  Output:
2686   //    rax ==  0  -  success
2687   //    rax == -1^K - failure, where K is partial transfer count
2688   //
2689   address generate_generic_copy(const char *name,
2690                                 address byte_copy_entry, address short_copy_entry,
2691                                 address int_copy_entry, address oop_copy_entry,
2692                                 address long_copy_entry, address checkcast_copy_entry) {
2693 
2694     Label L_failed, L_failed_0, L_objArray;
2695     Label L_copy_bytes, L_copy_shorts, L_copy_ints, L_copy_longs;
2696 
2697     // Input registers
2698     const Register src        = c_rarg0;  // source array oop
2699     const Register src_pos    = c_rarg1;  // source position
2700     const Register dst        = c_rarg2;  // destination array oop
2701     const Register dst_pos    = c_rarg3;  // destination position
2702 #ifndef _WIN64
2703     const Register length     = c_rarg4;
<span class="line-added">2704     const Register rklass_tmp = r9;  // load_klass</span>
2705 #else
2706     const Address  length(rsp, 6 * wordSize);  // elements count is on stack on Win64
<span class="line-added">2707     const Register rklass_tmp = rdi;  // load_klass</span>
2708 #endif
2709 
2710     { int modulus = CodeEntryAlignment;
2711       int target  = modulus - 5; // 5 = sizeof jmp(L_failed)
2712       int advance = target - (__ offset() % modulus);
2713       if (advance &lt; 0)  advance += modulus;
2714       if (advance &gt; 0)  __ nop(advance);
2715     }
2716     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2717 
2718     // Short-hop target to L_failed.  Makes for denser prologue code.
2719     __ BIND(L_failed_0);
2720     __ jmp(L_failed);
2721     assert(__ offset() % CodeEntryAlignment == 0, &quot;no further alignment needed&quot;);
2722 
2723     __ align(CodeEntryAlignment);
2724     address start = __ pc();
2725 
2726     __ enter(); // required for proper stackwalking of RuntimeStub frame
2727 
</pre>
<hr />
<pre>
2760     size_t j4off = __ offset();
2761     __ jccb(Assembler::negative, L_failed_0);
2762 
2763     // The first four tests are very dense code,
2764     // but not quite dense enough to put four
2765     // jumps in a 16-byte instruction fetch buffer.
2766     // That&#39;s good, because some branch predicters
2767     // do not like jumps so close together.
2768     // Make sure of this.
2769     guarantee(((j1off ^ j4off) &amp; ~15) != 0, &quot;I$ line of 1st &amp; 4th jumps&quot;);
2770 
2771     // registers used as temp
2772     const Register r11_length    = r11; // elements count to copy
2773     const Register r10_src_klass = r10; // array klass
2774 
2775     //  if (length &lt; 0) return -1;
2776     __ movl(r11_length, length);        // length (elements count, 32-bits value)
2777     __ testl(r11_length, r11_length);
2778     __ jccb(Assembler::negative, L_failed_0);
2779 
<span class="line-modified">2780     __ load_klass(r10_src_klass, src, rklass_tmp);</span>
2781 #ifdef ASSERT
2782     //  assert(src-&gt;klass() != NULL);
2783     {
2784       BLOCK_COMMENT(&quot;assert klasses not null {&quot;);
2785       Label L1, L2;
2786       __ testptr(r10_src_klass, r10_src_klass);
2787       __ jcc(Assembler::notZero, L2);   // it is broken if klass is NULL
2788       __ bind(L1);
2789       __ stop(&quot;broken null klass&quot;);
2790       __ bind(L2);
<span class="line-modified">2791       __ load_klass(rax, dst, rklass_tmp);</span>
2792       __ cmpq(rax, 0);
2793       __ jcc(Assembler::equal, L1);     // this would be broken also
2794       BLOCK_COMMENT(&quot;} assert klasses not null done&quot;);
2795     }
2796 #endif
2797 
2798     // Load layout helper (32-bits)
2799     //
2800     //  |array_tag|     | header_size | element_type |     |log2_element_size|
2801     // 32        30    24            16              8     2                 0
2802     //
2803     //   array_tag: typeArray = 0x3, objArray = 0x2, non-array = 0x0
2804     //
2805 
2806     const int lh_offset = in_bytes(Klass::layout_helper_offset());
2807 
2808     // Handle objArrays completely differently...
2809     const jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2810     __ cmpl(Address(r10_src_klass, lh_offset), objArray_lh);
2811     __ jcc(Assembler::equal, L_objArray);
2812 
2813     //  if (src-&gt;klass() != dst-&gt;klass()) return -1;
<span class="line-modified">2814     __ load_klass(rax, dst, rklass_tmp);</span>
2815     __ cmpq(r10_src_klass, rax);
2816     __ jcc(Assembler::notEqual, L_failed);
2817 
2818     const Register rax_lh = rax;  // layout helper
2819     __ movl(rax_lh, Address(r10_src_klass, lh_offset));
2820 
2821     //  if (!src-&gt;is_Array()) return -1;
2822     __ cmpl(rax_lh, Klass::_lh_neutral_value);
2823     __ jcc(Assembler::greaterEqual, L_failed);
2824 
2825     // At this point, it is known to be a typeArray (array_tag 0x3).
2826 #ifdef ASSERT
2827     {
2828       BLOCK_COMMENT(&quot;assert primitive array {&quot;);
2829       Label L;
2830       __ cmpl(rax_lh, (Klass::_lh_array_tag_type_value &lt;&lt; Klass::_lh_array_tag_shift));
2831       __ jcc(Assembler::greaterEqual, L);
2832       __ stop(&quot;must be a primitive array&quot;);
2833       __ bind(L);
2834       BLOCK_COMMENT(&quot;} assert primitive array done&quot;);
</pre>
<hr />
<pre>
2893       BLOCK_COMMENT(&quot;assert long copy {&quot;);
2894       Label L;
2895       __ cmpl(rax_elsize, LogBytesPerLong);
2896       __ jcc(Assembler::equal, L);
2897       __ stop(&quot;must be long copy, but elsize is wrong&quot;);
2898       __ bind(L);
2899       BLOCK_COMMENT(&quot;} assert long copy done&quot;);
2900     }
2901 #endif
2902     __ lea(from, Address(src, src_pos, Address::times_8, 0));// src_addr
2903     __ lea(to,   Address(dst, dst_pos, Address::times_8, 0));// dst_addr
2904     __ movl2ptr(count, r11_length); // length
2905     __ jump(RuntimeAddress(long_copy_entry));
2906 
2907     // ObjArrayKlass
2908   __ BIND(L_objArray);
2909     // live at this point:  r10_src_klass, r11_length, src[_pos], dst[_pos]
2910 
2911     Label L_plain_copy, L_checkcast_copy;
2912     //  test array classes for subtyping
<span class="line-modified">2913     __ load_klass(rax, dst, rklass_tmp);</span>
2914     __ cmpq(r10_src_klass, rax); // usual case is exact equality
2915     __ jcc(Assembler::notEqual, L_checkcast_copy);
2916 
2917     // Identically typed arrays can be copied without element-wise checks.
2918     arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,
2919                            r10, L_failed);
2920 
2921     __ lea(from, Address(src, src_pos, TIMES_OOP,
2922                  arrayOopDesc::base_offset_in_bytes(T_OBJECT))); // src_addr
2923     __ lea(to,   Address(dst, dst_pos, TIMES_OOP,
2924                  arrayOopDesc::base_offset_in_bytes(T_OBJECT))); // dst_addr
2925     __ movl2ptr(count, r11_length); // length
2926   __ BIND(L_plain_copy);
2927     __ jump(RuntimeAddress(oop_copy_entry));
2928 
2929   __ BIND(L_checkcast_copy);
2930     // live at this point:  r10_src_klass, r11_length, rax (dst_klass)
2931     {
2932       // Before looking at dst.length, make sure dst is also an objArray.
2933       __ cmpl(Address(rax, lh_offset), objArray_lh);
2934       __ jcc(Assembler::notEqual, L_failed);
2935 
2936       // It is safe to examine both src.length and dst.length.
2937       arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,
2938                              rax, L_failed);
2939 
2940       const Register r11_dst_klass = r11;
<span class="line-modified">2941       __ load_klass(r11_dst_klass, dst, rklass_tmp); // reload</span>
2942 
2943       // Marshal the base address arguments now, freeing registers.
2944       __ lea(from, Address(src, src_pos, TIMES_OOP,
2945                    arrayOopDesc::base_offset_in_bytes(T_OBJECT)));
2946       __ lea(to,   Address(dst, dst_pos, TIMES_OOP,
2947                    arrayOopDesc::base_offset_in_bytes(T_OBJECT)));
2948       __ movl(count, length);           // length (reloaded)
2949       Register sco_temp = c_rarg3;      // this register is free now
2950       assert_different_registers(from, to, count, sco_temp,
2951                                  r11_dst_klass, r10_src_klass);
2952       assert_clean_int(count, sco_temp);
2953 
2954       // Generate the type check.
2955       const int sco_offset = in_bytes(Klass::super_check_offset_offset());
2956       __ movl(sco_temp, Address(r11_dst_klass, sco_offset));
2957       assert_clean_int(sco_temp, rax);
2958       generate_type_check(r10_src_klass, sco_temp, r11_dst_klass, L_plain_copy);
2959 
2960       // Fetch destination element klass from the ObjArrayKlass header.
2961       int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/interp_masm_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/interp_masm_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 
  45 // Implementation of InterpreterMacroAssembler
  46 
  47 void InterpreterMacroAssembler::jump_to_entry(address entry) {
  48   assert(entry, &quot;Entry must have been generated by now&quot;);
  49   jump(RuntimeAddress(entry));
  50 }
  51 
  52 void InterpreterMacroAssembler::profile_obj_type(Register obj, const Address&amp; mdo_addr) {
  53   Label update, next, none;
  54 
  55   interp_verify_oop(obj, atos);
  56 
  57   testptr(obj, obj);
  58   jccb(Assembler::notZero, update);
  59   orptr(mdo_addr, TypeEntries::null_seen);
  60   jmpb(next);
  61 
  62   bind(update);
<span class="line-modified">  63   load_klass(obj, obj);</span>

  64 
  65   xorptr(obj, mdo_addr);
  66   testptr(obj, TypeEntries::type_klass_mask);
  67   jccb(Assembler::zero, next); // klass seen before, nothing to
  68                                // do. The unknown bit may have been
  69                                // set already but no need to check.
  70 
  71   testptr(obj, TypeEntries::type_unknown);
  72   jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
  73 
  74   cmpptr(mdo_addr, 0);
  75   jccb(Assembler::equal, none);
  76   cmpptr(mdo_addr, TypeEntries::null_seen);
  77   jccb(Assembler::equal, none);
  78   // There is a chance that the checks above (re-reading profiling
  79   // data from memory) fail if another thread has just set the
  80   // profiling to this obj&#39;s klass
  81   xorptr(obj, mdo_addr);
  82   testptr(obj, TypeEntries::type_klass_mask);
  83   jccb(Assembler::zero, next);
</pre>
<hr />
<pre>
1150 
1151   // remove activation
1152   // get sender sp
1153   movptr(rbx,
1154          Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));
1155 
1156   if (state == atos &amp;&amp; InlineTypeReturnedAsFields) {
1157     Label skip;
1158     // Test if the return type is an inline type
1159     movptr(rdi, Address(rbp, frame::interpreter_frame_method_offset * wordSize));
1160     movptr(rdi, Address(rdi, Method::const_offset()));
1161     load_unsigned_byte(rdi, Address(rdi, ConstMethod::result_type_offset()));
1162     cmpl(rdi, T_VALUETYPE);
1163     jcc(Assembler::notEqual, skip);
1164 
1165     // We are returning a value type, load its fields into registers
1166 #ifndef _LP64
1167     super_call_VM_leaf(StubRoutines::load_value_type_fields_in_regs());
1168 #else
1169     // Load fields from a buffered value with a value class specific handler
<span class="line-modified">1170     load_klass(rdi, rax);</span>

1171     movptr(rdi, Address(rdi, InstanceKlass::adr_valueklass_fixed_block_offset()));
1172     movptr(rdi, Address(rdi, ValueKlass::unpack_handler_offset()));
1173 
1174     testptr(rdi, rdi);
1175     jcc(Assembler::equal, skip);
1176 
1177     call(rdi);
1178 #endif
1179     // call above kills the value in rbx. Reload it.
1180     movptr(rbx, Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));
1181     bind(skip);
1182   }
1183   leave();                           // remove frame anchor
1184   pop(ret_addr);                     // get return address
1185   mov(rsp, rbx);                     // set sp to sender sp
1186 }
1187 
1188 void InterpreterMacroAssembler::get_method_counters(Register method,
1189                                                     Register mcs, Label&amp; skip) {
1190   Label has_counters;
</pre>
<hr />
<pre>
1253   bind(alloc_failed);
1254   pop(obj);
1255   pop(holder_klass);
1256   call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flattened_field),
1257           obj, field_index, holder_klass);
1258 
1259   bind(done);
1260 }
1261 
1262 void InterpreterMacroAssembler::read_flattened_element(Register array, Register index,
1263                                                        Register t1, Register t2,
1264                                                        Register obj) {
1265   assert_different_registers(array, index, t1, t2);
1266   Label alloc_failed, empty_value, done;
1267   const Register array_klass = t2;
1268   const Register elem_klass = t1;
1269   const Register alloc_temp = LP64_ONLY(rscratch1) NOT_LP64(rsi);
1270   const Register dst_temp   = LP64_ONLY(rscratch2) NOT_LP64(rdi);
1271 
1272   // load in array-&gt;klass()-&gt;element_klass()
<span class="line-modified">1273   load_klass(array_klass, array);</span>

1274   movptr(elem_klass, Address(array_klass, ArrayKlass::element_klass_offset()));
1275 
1276   //check for empty value klass
1277   test_klass_is_empty_value(elem_klass, dst_temp, empty_value);
1278 
1279   // calc source into &quot;array_klass&quot; and free up some regs
1280   const Register src = array_klass;
1281   push(index); // preserve index reg in case alloc_failed
1282   data_for_value_array_index(array, array_klass, index, src);
1283 
1284   allocate_instance(elem_klass, obj, alloc_temp, dst_temp, false, alloc_failed);
1285   // Have an oop instance buffer, copy into it
1286   store_ptr(0, obj); // preserve obj (overwrite index, no longer needed)
1287   data_for_oop(obj, dst_temp, elem_klass);
1288   access_value_copy(IS_DEST_UNINITIALIZED, src, dst_temp, elem_klass);
1289   pop(obj);
1290   jmp(done);
1291 
1292   bind(empty_value);
1293   get_empty_value_oop(elem_klass, dst_temp, obj);
</pre>
<hr />
<pre>
1322             lock_reg);
1323   } else {
1324     Label done;
1325 
1326     const Register swap_reg = rax; // Must use rax for cmpxchg instruction
1327     const Register tmp_reg = rbx; // Will be passed to biased_locking_enter to avoid a
1328                                   // problematic case where tmp_reg = no_reg.
1329     const Register obj_reg = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // Will contain the oop
1330 
1331     const int obj_offset = BasicObjectLock::obj_offset_in_bytes();
1332     const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();
1333     const int mark_offset = lock_offset +
1334                             BasicLock::displaced_header_offset_in_bytes();
1335 
1336     Label slow_case;
1337 
1338     // Load object pointer into obj_reg
1339     movptr(obj_reg, Address(lock_reg, obj_offset));
1340 
1341     if (UseBiasedLocking) {
<span class="line-modified">1342       biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, false, done, &amp;slow_case);</span>

1343     }
1344 
1345     // Load immediate 1 into swap_reg %rax
1346     movl(swap_reg, (int32_t)1);
1347 
1348     // Load (object-&gt;mark() | 1) into swap_reg %rax
1349     orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1350     if (EnableValhalla &amp;&amp; !UseBiasedLocking) {
1351       // For slow path is_always_locked, using biased, which is never natural for !UseBiasLocking
1352       andptr(swap_reg, ~((int) markWord::biased_lock_bit_in_place));
1353     }
1354 
1355     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
1356     movptr(Address(lock_reg, mark_offset), swap_reg);
1357 
1358     assert(lock_offset == 0,
1359            &quot;displaced header must be first word in BasicObjectLock&quot;);
1360 
1361     lock();
1362     cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
</pre>
</td>
<td>
<hr />
<pre>
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 
  45 // Implementation of InterpreterMacroAssembler
  46 
  47 void InterpreterMacroAssembler::jump_to_entry(address entry) {
  48   assert(entry, &quot;Entry must have been generated by now&quot;);
  49   jump(RuntimeAddress(entry));
  50 }
  51 
  52 void InterpreterMacroAssembler::profile_obj_type(Register obj, const Address&amp; mdo_addr) {
  53   Label update, next, none;
  54 
  55   interp_verify_oop(obj, atos);
  56 
  57   testptr(obj, obj);
  58   jccb(Assembler::notZero, update);
  59   orptr(mdo_addr, TypeEntries::null_seen);
  60   jmpb(next);
  61 
  62   bind(update);
<span class="line-modified">  63   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">  64   load_klass(obj, obj, tmp_load_klass);</span>
  65 
  66   xorptr(obj, mdo_addr);
  67   testptr(obj, TypeEntries::type_klass_mask);
  68   jccb(Assembler::zero, next); // klass seen before, nothing to
  69                                // do. The unknown bit may have been
  70                                // set already but no need to check.
  71 
  72   testptr(obj, TypeEntries::type_unknown);
  73   jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
  74 
  75   cmpptr(mdo_addr, 0);
  76   jccb(Assembler::equal, none);
  77   cmpptr(mdo_addr, TypeEntries::null_seen);
  78   jccb(Assembler::equal, none);
  79   // There is a chance that the checks above (re-reading profiling
  80   // data from memory) fail if another thread has just set the
  81   // profiling to this obj&#39;s klass
  82   xorptr(obj, mdo_addr);
  83   testptr(obj, TypeEntries::type_klass_mask);
  84   jccb(Assembler::zero, next);
</pre>
<hr />
<pre>
1151 
1152   // remove activation
1153   // get sender sp
1154   movptr(rbx,
1155          Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));
1156 
1157   if (state == atos &amp;&amp; InlineTypeReturnedAsFields) {
1158     Label skip;
1159     // Test if the return type is an inline type
1160     movptr(rdi, Address(rbp, frame::interpreter_frame_method_offset * wordSize));
1161     movptr(rdi, Address(rdi, Method::const_offset()));
1162     load_unsigned_byte(rdi, Address(rdi, ConstMethod::result_type_offset()));
1163     cmpl(rdi, T_VALUETYPE);
1164     jcc(Assembler::notEqual, skip);
1165 
1166     // We are returning a value type, load its fields into registers
1167 #ifndef _LP64
1168     super_call_VM_leaf(StubRoutines::load_value_type_fields_in_regs());
1169 #else
1170     // Load fields from a buffered value with a value class specific handler
<span class="line-modified">1171     Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">1172     load_klass(rdi, rax, tmp_load_klass);</span>
1173     movptr(rdi, Address(rdi, InstanceKlass::adr_valueklass_fixed_block_offset()));
1174     movptr(rdi, Address(rdi, ValueKlass::unpack_handler_offset()));
1175 
1176     testptr(rdi, rdi);
1177     jcc(Assembler::equal, skip);
1178 
1179     call(rdi);
1180 #endif
1181     // call above kills the value in rbx. Reload it.
1182     movptr(rbx, Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize));
1183     bind(skip);
1184   }
1185   leave();                           // remove frame anchor
1186   pop(ret_addr);                     // get return address
1187   mov(rsp, rbx);                     // set sp to sender sp
1188 }
1189 
1190 void InterpreterMacroAssembler::get_method_counters(Register method,
1191                                                     Register mcs, Label&amp; skip) {
1192   Label has_counters;
</pre>
<hr />
<pre>
1255   bind(alloc_failed);
1256   pop(obj);
1257   pop(holder_klass);
1258   call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flattened_field),
1259           obj, field_index, holder_klass);
1260 
1261   bind(done);
1262 }
1263 
1264 void InterpreterMacroAssembler::read_flattened_element(Register array, Register index,
1265                                                        Register t1, Register t2,
1266                                                        Register obj) {
1267   assert_different_registers(array, index, t1, t2);
1268   Label alloc_failed, empty_value, done;
1269   const Register array_klass = t2;
1270   const Register elem_klass = t1;
1271   const Register alloc_temp = LP64_ONLY(rscratch1) NOT_LP64(rsi);
1272   const Register dst_temp   = LP64_ONLY(rscratch2) NOT_LP64(rdi);
1273 
1274   // load in array-&gt;klass()-&gt;element_klass()
<span class="line-modified">1275   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">1276   load_klass(array_klass, array, tmp_load_klass);</span>
1277   movptr(elem_klass, Address(array_klass, ArrayKlass::element_klass_offset()));
1278 
1279   //check for empty value klass
1280   test_klass_is_empty_value(elem_klass, dst_temp, empty_value);
1281 
1282   // calc source into &quot;array_klass&quot; and free up some regs
1283   const Register src = array_klass;
1284   push(index); // preserve index reg in case alloc_failed
1285   data_for_value_array_index(array, array_klass, index, src);
1286 
1287   allocate_instance(elem_klass, obj, alloc_temp, dst_temp, false, alloc_failed);
1288   // Have an oop instance buffer, copy into it
1289   store_ptr(0, obj); // preserve obj (overwrite index, no longer needed)
1290   data_for_oop(obj, dst_temp, elem_klass);
1291   access_value_copy(IS_DEST_UNINITIALIZED, src, dst_temp, elem_klass);
1292   pop(obj);
1293   jmp(done);
1294 
1295   bind(empty_value);
1296   get_empty_value_oop(elem_klass, dst_temp, obj);
</pre>
<hr />
<pre>
1325             lock_reg);
1326   } else {
1327     Label done;
1328 
1329     const Register swap_reg = rax; // Must use rax for cmpxchg instruction
1330     const Register tmp_reg = rbx; // Will be passed to biased_locking_enter to avoid a
1331                                   // problematic case where tmp_reg = no_reg.
1332     const Register obj_reg = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // Will contain the oop
1333 
1334     const int obj_offset = BasicObjectLock::obj_offset_in_bytes();
1335     const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();
1336     const int mark_offset = lock_offset +
1337                             BasicLock::displaced_header_offset_in_bytes();
1338 
1339     Label slow_case;
1340 
1341     // Load object pointer into obj_reg
1342     movptr(obj_reg, Address(lock_reg, obj_offset));
1343 
1344     if (UseBiasedLocking) {
<span class="line-modified">1345       Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">1346       biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, rklass_decode_tmp, false, done, &amp;slow_case);</span>
1347     }
1348 
1349     // Load immediate 1 into swap_reg %rax
1350     movl(swap_reg, (int32_t)1);
1351 
1352     // Load (object-&gt;mark() | 1) into swap_reg %rax
1353     orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1354     if (EnableValhalla &amp;&amp; !UseBiasedLocking) {
1355       // For slow path is_always_locked, using biased, which is never natural for !UseBiasLocking
1356       andptr(swap_reg, ~((int) markWord::biased_lock_bit_in_place));
1357     }
1358 
1359     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
1360     movptr(Address(lock_reg, mark_offset), swap_reg);
1361 
1362     assert(lock_offset == 0,
1363            &quot;displaced header must be first word in BasicObjectLock&quot;);
1364 
1365     lock();
1366     cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
</pre>
</td>
</tr>
</table>
<center><a href="gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
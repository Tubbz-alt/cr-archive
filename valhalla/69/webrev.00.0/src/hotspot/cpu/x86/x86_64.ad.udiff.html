<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vtableStubs_x86_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_Runtime1.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -355,11 +355,11 @@</span>
  RegMask _STACK_OR_PTR_REG_mask;
  RegMask _STACK_OR_LONG_REG_mask;
  RegMask _STACK_OR_INT_REG_mask;
  
  static bool need_r12_heapbase() {
<span class="udiff-line-modified-removed">-   return UseCompressedOops || UseCompressedClassPointers;</span>
<span class="udiff-line-modified-added">+   return UseCompressedOops;</span>
  }
  
  void reg_mask_init() {
    // _ALL_REG_mask is generated by adlc from the all_reg register class below.
    // We derive a number of subsets from it.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1510,11 +1510,11 @@</span>
  {
    MacroAssembler masm(&amp;cbuf);
    if (!_verified) {  
      uint insts_size = cbuf.insts_size();
      if (UseCompressedClassPointers) {
<span class="udiff-line-modified-removed">-       masm.load_klass(rscratch1, j_rarg0);</span>
<span class="udiff-line-modified-added">+       masm.load_klass(rscratch1, j_rarg0, rscratch2);</span>
        masm.cmpptr(rax, rscratch1);
      } else {
        masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
      }
      masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1546,11 +1546,11 @@</span>
  void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  {
    MacroAssembler masm(&amp;cbuf);
    uint insts_size = cbuf.insts_size();
    if (UseCompressedClassPointers) {
<span class="udiff-line-modified-removed">-     masm.load_klass(rscratch1, j_rarg0);</span>
<span class="udiff-line-modified-added">+     masm.load_klass(rscratch1, j_rarg0, rscratch2);</span>
      masm.cmpptr(rax, rscratch1);
    } else {
      masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5962,11 +5962,11 @@</span>
    ins_pipe(ialu_mem_reg);
  %}
  
  instruct storeImmP0(memory mem, immP0 zero)
  %{
<span class="udiff-line-modified-removed">-   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
<span class="udiff-line-modified-added">+   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
    match(Set mem (StoreP mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6012,11 +6012,11 @@</span>
    ins_pipe(ialu_mem_reg);
  %}
  
  instruct storeImmN0(memory mem, immN0 zero)
  %{
<span class="udiff-line-modified-removed">-   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::base() == NULL);</span>
    match(Set mem (StoreN mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6055,11 +6055,11 @@</span>
  %}
  
  // Store Integer Immediate
  instruct storeImmI0(memory mem, immI0 zero)
  %{
<span class="udiff-line-modified-removed">-   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
<span class="udiff-line-modified-added">+   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
    match(Set mem (StoreI mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6080,11 +6080,11 @@</span>
  %}
  
  // Store Long Immediate
  instruct storeImmL0(memory mem, immL0 zero)
  %{
<span class="udiff-line-modified-removed">-   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
<span class="udiff-line-modified-added">+   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
    match(Set mem (StoreL mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6105,11 +6105,11 @@</span>
  %}
  
  // Store Short/Char Immediate
  instruct storeImmC0(memory mem, immI0 zero)
  %{
<span class="udiff-line-modified-removed">-   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
<span class="udiff-line-modified-added">+   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
    match(Set mem (StoreC mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6131,11 +6131,11 @@</span>
  %}
  
  // Store Byte Immediate
  instruct storeImmB0(memory mem, immI0 zero)
  %{
<span class="udiff-line-modified-removed">-   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
<span class="udiff-line-modified-added">+   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
    match(Set mem (StoreB mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6156,11 +6156,11 @@</span>
  %}
  
  // Store CMS card-mark Immediate
  instruct storeImmCM0_reg(memory mem, immI0 zero)
  %{
<span class="udiff-line-modified-removed">-   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
<span class="udiff-line-modified-added">+   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
    match(Set mem (StoreCM mem zero));
  
    ins_cost(125); // XXX
    format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6194,11 +6194,11 @@</span>
  %}
  
  // Store immediate Float value (it is faster than store from XMM register)
  instruct storeF0(memory mem, immF0 zero)
  %{
<span class="udiff-line-modified-removed">-   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
<span class="udiff-line-modified-added">+   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
    match(Set mem (StoreF mem zero));
  
    ins_cost(25); // XXX
    format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6244,11 +6244,11 @@</span>
    ins_pipe(ialu_mem_imm);
  %}
  
  instruct storeD0(memory mem, immD0 zero)
  %{
<span class="udiff-line-modified-removed">-   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
<span class="udiff-line-modified-added">+   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
    match(Set mem (StoreD mem zero));
  
    ins_cost(25); // XXX
    format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6837,35 +6837,28 @@</span>
    ins_pipe(ialu_reg_long);
  %}
  
  instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
    match(Set dst (EncodePKlass src));
<span class="udiff-line-modified-removed">-   effect(KILL cr);</span>
<span class="udiff-line-modified-removed">-   format %{ &quot;encode_klass_not_null $dst,$src&quot; %}</span>
<span class="udiff-line-modified-added">+   effect(TEMP dst, KILL cr);</span>
<span class="udiff-line-modified-added">+   format %{ &quot;encode_and_move_klass_not_null $dst,$src&quot; %}</span>
    ins_encode %{
<span class="udiff-line-modified-removed">-     __ encode_klass_not_null($dst$$Register, $src$$Register);</span>
<span class="udiff-line-modified-added">+     __ encode_and_move_klass_not_null($dst$$Register, $src$$Register);</span>
    %}
    ins_pipe(ialu_reg_long);
  %}
  
  instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
    match(Set dst (DecodeNKlass src));
<span class="udiff-line-modified-removed">-   effect(KILL cr);</span>
<span class="udiff-line-modified-removed">-   format %{ &quot;decode_klass_not_null $dst,$src&quot; %}</span>
<span class="udiff-line-modified-added">+   effect(TEMP dst, KILL cr);</span>
<span class="udiff-line-modified-added">+   format %{ &quot;decode_and_move_klass_not_null $dst,$src&quot; %}</span>
    ins_encode %{
<span class="udiff-line-modified-removed">-     Register s = $src$$Register;</span>
<span class="udiff-line-removed">-     Register d = $dst$$Register;</span>
<span class="udiff-line-removed">-     if (s != d) {</span>
<span class="udiff-line-removed">-       __ decode_klass_not_null(d, s);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       __ decode_klass_not_null(d);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     __ decode_and_move_klass_not_null($dst$$Register, $src$$Register);</span>
    %}
    ins_pipe(ialu_reg_long);
  %}
  
<span class="udiff-line-removed">- </span>
  //----------Conditional Move---------------------------------------------------
  // Jump
  // dummy instruction for generating temp registers
  instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
    match(Jump (LShiftL switch_val shift));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11881,11 +11874,10 @@</span>
  %}
  
  instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
  %{
    predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
<span class="udiff-line-removed">-             (CompressedKlassPointers::base() == NULL) &amp;&amp;</span>
              n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
    match(Set cr (CmpP (LoadP mem) zero));
  
    format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11977,11 +11969,11 @@</span>
    ins_pipe(ialu_cr_reg_mem);
  %}
  
  instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
  %{
<span class="udiff-line-modified-removed">-   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
<span class="udiff-line-modified-added">+   predicate(CompressedOops::base() == NULL);</span>
    match(Set cr (CmpN (LoadN mem) zero));
  
    format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
    ins_encode %{
      __ cmpl(r12, $mem$$Address);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12635,19 +12627,19 @@</span>
                   true, ra_-&gt;C-&gt;profile_rtm());
    %}
    ins_pipe(pipe_slow);
  %}
  
<span class="udiff-line-modified-removed">- instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{</span>
<span class="udiff-line-modified-added">+ instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr, rRegP cx1) %{</span>
    predicate(!Compile::current()-&gt;use_rtm());
    match(Set cr (FastLock object box));
<span class="udiff-line-modified-removed">-   effect(TEMP tmp, TEMP scr, USE_KILL box);</span>
<span class="udiff-line-modified-added">+   effect(TEMP tmp, TEMP scr, TEMP cx1, USE_KILL box);</span>
    ins_cost(300);
    format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
    ins_encode %{
      __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
<span class="udiff-line-modified-removed">-                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);</span>
<span class="udiff-line-modified-added">+                  $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);</span>
    %}
    ins_pipe(pipe_slow);
  %}
  
  instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
</pre>
<center><a href="vtableStubs_x86_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_Runtime1.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
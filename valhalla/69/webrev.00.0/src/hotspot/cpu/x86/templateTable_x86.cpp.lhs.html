<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;interpreter/interpreter.hpp&quot;
  29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  30 #include &quot;interpreter/interp_masm.hpp&quot;
  31 #include &quot;interpreter/templateTable.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/methodData.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;oops/valueKlass.hpp&quot;
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/synchronizer.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;
  44 
  45 #define __ Disassembler::hook&lt;InterpreterMacroAssembler&gt;(__FILE__, __LINE__, _masm)-&gt;
  46 
  47 // Global Register Names
  48 static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);
  49 static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);
  50 
  51 // Platform-dependent initialization
  52 void TemplateTable::pd_initialize() {
  53   // No x86 specific initialization
  54 }
  55 
  56 // Address Computation: local variables
  57 static inline Address iaddress(int n) {
  58   return Address(rlocals, Interpreter::local_offset_in_bytes(n));
  59 }
  60 
  61 static inline Address laddress(int n) {
  62   return iaddress(n + 1);
  63 }
  64 
  65 #ifndef _LP64
  66 static inline Address haddress(int n) {
  67   return iaddress(n + 0);
  68 }
  69 #endif
  70 
  71 static inline Address faddress(int n) {
  72   return iaddress(n);
  73 }
  74 
  75 static inline Address daddress(int n) {
  76   return laddress(n);
  77 }
  78 
  79 static inline Address aaddress(int n) {
  80   return iaddress(n);
  81 }
  82 
  83 static inline Address iaddress(Register r) {
  84   return Address(rlocals, r, Address::times_ptr);
  85 }
  86 
  87 static inline Address laddress(Register r) {
  88   return Address(rlocals, r, Address::times_ptr, Interpreter::local_offset_in_bytes(1));
  89 }
  90 
  91 #ifndef _LP64
  92 static inline Address haddress(Register r)       {
  93   return Address(rlocals, r, Interpreter::stackElementScale(), Interpreter::local_offset_in_bytes(0));
  94 }
  95 #endif
  96 
  97 static inline Address faddress(Register r) {
  98   return iaddress(r);
  99 }
 100 
 101 static inline Address daddress(Register r) {
 102   return laddress(r);
 103 }
 104 
 105 static inline Address aaddress(Register r) {
 106   return iaddress(r);
 107 }
 108 
 109 
 110 // expression stack
 111 // (Note: Must not use symmetric equivalents at_rsp_m1/2 since they store
 112 // data beyond the rsp which is potentially unsafe in an MT environment;
 113 // an interrupt may overwrite that data.)
 114 static inline Address at_rsp   () {
 115   return Address(rsp, 0);
 116 }
 117 
 118 // At top of Java expression stack which may be different than esp().  It
 119 // isn&#39;t for category 1 objects.
 120 static inline Address at_tos   () {
 121   return Address(rsp,  Interpreter::expr_offset_in_bytes(0));
 122 }
 123 
 124 static inline Address at_tos_p1() {
 125   return Address(rsp,  Interpreter::expr_offset_in_bytes(1));
 126 }
 127 
 128 static inline Address at_tos_p2() {
 129   return Address(rsp,  Interpreter::expr_offset_in_bytes(2));
 130 }
 131 
 132 // Condition conversion
 133 static Assembler::Condition j_not(TemplateTable::Condition cc) {
 134   switch (cc) {
 135   case TemplateTable::equal        : return Assembler::notEqual;
 136   case TemplateTable::not_equal    : return Assembler::equal;
 137   case TemplateTable::less         : return Assembler::greaterEqual;
 138   case TemplateTable::less_equal   : return Assembler::greater;
 139   case TemplateTable::greater      : return Assembler::lessEqual;
 140   case TemplateTable::greater_equal: return Assembler::less;
 141   }
 142   ShouldNotReachHere();
 143   return Assembler::zero;
 144 }
 145 
 146 
 147 
 148 // Miscelaneous helper routines
 149 // Store an oop (or NULL) at the address described by obj.
 150 // If val == noreg this means store a NULL
 151 
 152 
 153 static void do_oop_store(InterpreterMacroAssembler* _masm,
 154                          Address dst,
 155                          Register val,
 156                          DecoratorSet decorators = 0) {
 157   assert(val == noreg || val == rax, &quot;parameter is just for looks&quot;);
 158   __ store_heap_oop(dst, val, rdx, rbx, noreg, decorators);
 159 }
 160 
 161 static void do_oop_load(InterpreterMacroAssembler* _masm,
 162                         Address src,
 163                         Register dst,
 164                         DecoratorSet decorators = 0) {
 165   __ load_heap_oop(dst, src, rdx, rbx, decorators);
 166 }
 167 
 168 Address TemplateTable::at_bcp(int offset) {
 169   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 170   return Address(rbcp, offset);
 171 }
 172 
 173 
 174 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 175                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 176                                    int byte_no) {
 177   if (!RewriteBytecodes)  return;
 178   Label L_patch_done;
 179 
 180   switch (bc) {
 181   case Bytecodes::_fast_qputfield:
 182   case Bytecodes::_fast_aputfield:
 183   case Bytecodes::_fast_bputfield:
 184   case Bytecodes::_fast_zputfield:
 185   case Bytecodes::_fast_cputfield:
 186   case Bytecodes::_fast_dputfield:
 187   case Bytecodes::_fast_fputfield:
 188   case Bytecodes::_fast_iputfield:
 189   case Bytecodes::_fast_lputfield:
 190   case Bytecodes::_fast_sputfield:
 191     {
 192       // We skip bytecode quickening for putfield instructions when
 193       // the put_code written to the constant pool cache is zero.
 194       // This is required so that every execution of this instruction
 195       // calls out to InterpreterRuntime::resolve_get_put to do
 196       // additional, required work.
 197       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 198       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 199       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 200       __ movl(bc_reg, bc);
 201       __ cmpl(temp_reg, (int) 0);
 202       __ jcc(Assembler::zero, L_patch_done);  // don&#39;t patch
 203     }
 204     break;
 205   default:
 206     assert(byte_no == -1, &quot;sanity&quot;);
 207     // the pair bytecodes have already done the load.
 208     if (load_bc_into_bc_reg) {
 209       __ movl(bc_reg, bc);
 210     }
 211   }
 212 
 213   if (JvmtiExport::can_post_breakpoint()) {
 214     Label L_fast_patch;
 215     // if a breakpoint is present we can&#39;t rewrite the stream directly
 216     __ movzbl(temp_reg, at_bcp(0));
 217     __ cmpl(temp_reg, Bytecodes::_breakpoint);
 218     __ jcc(Assembler::notEqual, L_fast_patch);
 219     __ get_method(temp_reg);
 220     // Let breakpoint table handling rewrite to quicker bytecode
 221     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at), temp_reg, rbcp, bc_reg);
 222 #ifndef ASSERT
 223     __ jmpb(L_patch_done);
 224 #else
 225     __ jmp(L_patch_done);
 226 #endif
 227     __ bind(L_fast_patch);
 228   }
 229 
 230 #ifdef ASSERT
 231   Label L_okay;
 232   __ load_unsigned_byte(temp_reg, at_bcp(0));
 233   __ cmpl(temp_reg, (int) Bytecodes::java_code(bc));
 234   __ jcc(Assembler::equal, L_okay);
 235   __ cmpl(temp_reg, bc_reg);
 236   __ jcc(Assembler::equal, L_okay);
 237   __ stop(&quot;patching the wrong bytecode&quot;);
 238   __ bind(L_okay);
 239 #endif
 240 
 241   // patch bytecode
 242   __ movb(at_bcp(0), bc_reg);
 243   __ bind(L_patch_done);
 244 }
 245 // Individual instructions
 246 
 247 
 248 void TemplateTable::nop() {
 249   transition(vtos, vtos);
 250   // nothing to do
 251 }
 252 
 253 void TemplateTable::shouldnotreachhere() {
 254   transition(vtos, vtos);
 255   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 256 }
 257 
 258 void TemplateTable::aconst_null() {
 259   transition(vtos, atos);
 260   __ xorl(rax, rax);
 261 }
 262 
 263 void TemplateTable::iconst(int value) {
 264   transition(vtos, itos);
 265   if (value == 0) {
 266     __ xorl(rax, rax);
 267   } else {
 268     __ movl(rax, value);
 269   }
 270 }
 271 
 272 void TemplateTable::lconst(int value) {
 273   transition(vtos, ltos);
 274   if (value == 0) {
 275     __ xorl(rax, rax);
 276   } else {
 277     __ movl(rax, value);
 278   }
 279 #ifndef _LP64
 280   assert(value &gt;= 0, &quot;check this code&quot;);
 281   __ xorptr(rdx, rdx);
 282 #endif
 283 }
 284 
 285 
 286 
 287 void TemplateTable::fconst(int value) {
 288   transition(vtos, ftos);
 289   if (UseSSE &gt;= 1) {
 290     static float one = 1.0f, two = 2.0f;
 291     switch (value) {
 292     case 0:
 293       __ xorps(xmm0, xmm0);
 294       break;
 295     case 1:
 296       __ movflt(xmm0, ExternalAddress((address) &amp;one));
 297       break;
 298     case 2:
 299       __ movflt(xmm0, ExternalAddress((address) &amp;two));
 300       break;
 301     default:
 302       ShouldNotReachHere();
 303       break;
 304     }
 305   } else {
 306 #ifdef _LP64
 307     ShouldNotReachHere();
 308 #else
 309            if (value == 0) { __ fldz();
 310     } else if (value == 1) { __ fld1();
 311     } else if (value == 2) { __ fld1(); __ fld1(); __ faddp(); // should do a better solution here
 312     } else                 { ShouldNotReachHere();
 313     }
 314 #endif // _LP64
 315   }
 316 }
 317 
 318 void TemplateTable::dconst(int value) {
 319   transition(vtos, dtos);
 320   if (UseSSE &gt;= 2) {
 321     static double one = 1.0;
 322     switch (value) {
 323     case 0:
 324       __ xorpd(xmm0, xmm0);
 325       break;
 326     case 1:
 327       __ movdbl(xmm0, ExternalAddress((address) &amp;one));
 328       break;
 329     default:
 330       ShouldNotReachHere();
 331       break;
 332     }
 333   } else {
 334 #ifdef _LP64
 335     ShouldNotReachHere();
 336 #else
 337            if (value == 0) { __ fldz();
 338     } else if (value == 1) { __ fld1();
 339     } else                 { ShouldNotReachHere();
 340     }
 341 #endif
 342   }
 343 }
 344 
 345 void TemplateTable::bipush() {
 346   transition(vtos, itos);
 347   __ load_signed_byte(rax, at_bcp(1));
 348 }
 349 
 350 void TemplateTable::sipush() {
 351   transition(vtos, itos);
 352   __ load_unsigned_short(rax, at_bcp(1));
 353   __ bswapl(rax);
 354   __ sarl(rax, 16);
 355 }
 356 
 357 void TemplateTable::ldc(bool wide) {
 358   transition(vtos, vtos);
 359   Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 360   Label call_ldc, notFloat, notClass, notInt, Done;
 361 
 362   if (wide) {
 363     __ get_unsigned_2_byte_index_at_bcp(rbx, 1);
 364   } else {
 365     __ load_unsigned_byte(rbx, at_bcp(1));
 366   }
 367 
 368   __ get_cpool_and_tags(rcx, rax);
 369   const int base_offset = ConstantPool::header_size() * wordSize;
 370   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 371 
 372   // get type
 373   __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));
 374   __ andl(rdx, ~JVM_CONSTANT_QDescBit);
 375 
 376   // unresolved class - get the resolved class
 377   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClass);
 378   __ jccb(Assembler::equal, call_ldc);
 379 
 380   // unresolved class in error state - call into runtime to throw the error
 381   // from the first resolution attempt
 382   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClassInError);
 383   __ jccb(Assembler::equal, call_ldc);
 384 
 385   // resolved class - need to call vm to get java mirror of the class
 386   __ cmpl(rdx, JVM_CONSTANT_Class);
 387   __ jcc(Assembler::notEqual, notClass);
 388 
 389   __ bind(call_ldc);
 390 
 391   __ movl(rarg, wide);
 392   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), rarg);
 393 
 394   __ push(atos);
 395   __ jmp(Done);
 396 
 397   __ bind(notClass);
 398   __ cmpl(rdx, JVM_CONSTANT_Float);
 399   __ jccb(Assembler::notEqual, notFloat);
 400 
 401   // ftos
 402   __ load_float(Address(rcx, rbx, Address::times_ptr, base_offset));
 403   __ push(ftos);
 404   __ jmp(Done);
 405 
 406   __ bind(notFloat);
 407   __ cmpl(rdx, JVM_CONSTANT_Integer);
 408   __ jccb(Assembler::notEqual, notInt);
 409 
 410   // itos
 411   __ movl(rax, Address(rcx, rbx, Address::times_ptr, base_offset));
 412   __ push(itos);
 413   __ jmp(Done);
 414 
 415   // assume the tag is for condy; if not, the VM runtime will tell us
 416   __ bind(notInt);
 417   condy_helper(Done);
 418 
 419   __ bind(Done);
 420 }
 421 
 422 // Fast path for caching oop constants.
 423 void TemplateTable::fast_aldc(bool wide) {
 424   transition(vtos, atos);
 425 
 426   Register result = rax;
 427   Register tmp = rdx;
 428   Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 429   int index_size = wide ? sizeof(u2) : sizeof(u1);
 430 
 431   Label resolved;
 432 
 433   // We are resolved if the resolved reference cache entry contains a
 434   // non-null object (String, MethodType, etc.)
 435   assert_different_registers(result, tmp);
 436   __ get_cache_index_at_bcp(tmp, 1, index_size);
 437   __ load_resolved_reference_at_index(result, tmp);
 438   __ testptr(result, result);
 439   __ jcc(Assembler::notZero, resolved);
 440 
 441   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 442 
 443   // first time invocation - must resolve first
 444   __ movl(rarg, (int)bytecode());
 445   __ call_VM(result, entry, rarg);
 446   __ bind(resolved);
 447 
 448   { // Check for the null sentinel.
 449     // If we just called the VM, it already did the mapping for us,
 450     // but it&#39;s harmless to retry.
 451     Label notNull;
 452     ExternalAddress null_sentinel((address)Universe::the_null_sentinel_addr());
 453     __ movptr(tmp, null_sentinel);
 454     __ cmpoop(tmp, result);
 455     __ jccb(Assembler::notEqual, notNull);
 456     __ xorptr(result, result);  // NULL object reference
 457     __ bind(notNull);
 458   }
 459 
 460   if (VerifyOops) {
 461     __ verify_oop(result);
 462   }
 463 }
 464 
 465 void TemplateTable::ldc2_w() {
 466   transition(vtos, vtos);
 467   Label notDouble, notLong, Done;
 468   __ get_unsigned_2_byte_index_at_bcp(rbx, 1);
 469 
 470   __ get_cpool_and_tags(rcx, rax);
 471   const int base_offset = ConstantPool::header_size() * wordSize;
 472   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 473 
 474   // get type
 475   __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));
 476   __ cmpl(rdx, JVM_CONSTANT_Double);
 477   __ jccb(Assembler::notEqual, notDouble);
 478 
 479   // dtos
 480   __ load_double(Address(rcx, rbx, Address::times_ptr, base_offset));
 481   __ push(dtos);
 482 
 483   __ jmp(Done);
 484   __ bind(notDouble);
 485   __ cmpl(rdx, JVM_CONSTANT_Long);
 486   __ jccb(Assembler::notEqual, notLong);
 487 
 488   // ltos
 489   __ movptr(rax, Address(rcx, rbx, Address::times_ptr, base_offset + 0 * wordSize));
 490   NOT_LP64(__ movptr(rdx, Address(rcx, rbx, Address::times_ptr, base_offset + 1 * wordSize)));
 491   __ push(ltos);
 492   __ jmp(Done);
 493 
 494   __ bind(notLong);
 495   condy_helper(Done);
 496 
 497   __ bind(Done);
 498 }
 499 
 500 void TemplateTable::condy_helper(Label&amp; Done) {
 501   const Register obj = rax;
 502   const Register off = rbx;
 503   const Register flags = rcx;
 504   const Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 505   __ movl(rarg, (int)bytecode());
 506   call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc), rarg);
 507 #ifndef _LP64
 508   // borrow rdi from locals
 509   __ get_thread(rdi);
 510   __ get_vm_result_2(flags, rdi);
 511   __ restore_locals();
 512 #else
 513   __ get_vm_result_2(flags, r15_thread);
 514 #endif
 515   // VMr = obj = base address to find primitive value to push
 516   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 517   __ movl(off, flags);
 518   __ andl(off, ConstantPoolCacheEntry::field_index_mask);
 519   const Address field(obj, off, Address::times_1, 0*wordSize);
 520 
 521   // What sort of thing are we loading?
 522   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
 523   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
 524 
 525   switch (bytecode()) {
 526   case Bytecodes::_ldc:
 527   case Bytecodes::_ldc_w:
 528     {
 529       // tos in (itos, ftos, stos, btos, ctos, ztos)
 530       Label notInt, notFloat, notShort, notByte, notChar, notBool;
 531       __ cmpl(flags, itos);
 532       __ jcc(Assembler::notEqual, notInt);
 533       // itos
 534       __ movl(rax, field);
 535       __ push(itos);
 536       __ jmp(Done);
 537 
 538       __ bind(notInt);
 539       __ cmpl(flags, ftos);
 540       __ jcc(Assembler::notEqual, notFloat);
 541       // ftos
 542       __ load_float(field);
 543       __ push(ftos);
 544       __ jmp(Done);
 545 
 546       __ bind(notFloat);
 547       __ cmpl(flags, stos);
 548       __ jcc(Assembler::notEqual, notShort);
 549       // stos
 550       __ load_signed_short(rax, field);
 551       __ push(stos);
 552       __ jmp(Done);
 553 
 554       __ bind(notShort);
 555       __ cmpl(flags, btos);
 556       __ jcc(Assembler::notEqual, notByte);
 557       // btos
 558       __ load_signed_byte(rax, field);
 559       __ push(btos);
 560       __ jmp(Done);
 561 
 562       __ bind(notByte);
 563       __ cmpl(flags, ctos);
 564       __ jcc(Assembler::notEqual, notChar);
 565       // ctos
 566       __ load_unsigned_short(rax, field);
 567       __ push(ctos);
 568       __ jmp(Done);
 569 
 570       __ bind(notChar);
 571       __ cmpl(flags, ztos);
 572       __ jcc(Assembler::notEqual, notBool);
 573       // ztos
 574       __ load_signed_byte(rax, field);
 575       __ push(ztos);
 576       __ jmp(Done);
 577 
 578       __ bind(notBool);
 579       break;
 580     }
 581 
 582   case Bytecodes::_ldc2_w:
 583     {
 584       Label notLong, notDouble;
 585       __ cmpl(flags, ltos);
 586       __ jcc(Assembler::notEqual, notLong);
 587       // ltos
 588       // Loading high word first because movptr clobbers rax
 589       NOT_LP64(__ movptr(rdx, field.plus_disp(4)));
 590       __ movptr(rax, field);
 591       __ push(ltos);
 592       __ jmp(Done);
 593 
 594       __ bind(notLong);
 595       __ cmpl(flags, dtos);
 596       __ jcc(Assembler::notEqual, notDouble);
 597       // dtos
 598       __ load_double(field);
 599       __ push(dtos);
 600       __ jmp(Done);
 601 
 602       __ bind(notDouble);
 603       break;
 604     }
 605 
 606   default:
 607     ShouldNotReachHere();
 608   }
 609 
 610   __ stop(&quot;bad ldc/condy&quot;);
 611 }
 612 
 613 void TemplateTable::locals_index(Register reg, int offset) {
 614   __ load_unsigned_byte(reg, at_bcp(offset));
 615   __ negptr(reg);
 616 }
 617 
 618 void TemplateTable::iload() {
 619   iload_internal();
 620 }
 621 
 622 void TemplateTable::nofast_iload() {
 623   iload_internal(may_not_rewrite);
 624 }
 625 
 626 void TemplateTable::iload_internal(RewriteControl rc) {
 627   transition(vtos, itos);
 628   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 629     Label rewrite, done;
 630     const Register bc = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
 631     LP64_ONLY(assert(rbx != bc, &quot;register damaged&quot;));
 632 
 633     // get next byte
 634     __ load_unsigned_byte(rbx,
 635                           at_bcp(Bytecodes::length_for(Bytecodes::_iload)));
 636     // if _iload, wait to rewrite to iload2.  We only want to rewrite the
 637     // last two iloads in a pair.  Comparing against fast_iload means that
 638     // the next bytecode is neither an iload or a caload, and therefore
 639     // an iload pair.
 640     __ cmpl(rbx, Bytecodes::_iload);
 641     __ jcc(Assembler::equal, done);
 642 
 643     __ cmpl(rbx, Bytecodes::_fast_iload);
 644     __ movl(bc, Bytecodes::_fast_iload2);
 645 
 646     __ jccb(Assembler::equal, rewrite);
 647 
 648     // if _caload, rewrite to fast_icaload
 649     __ cmpl(rbx, Bytecodes::_caload);
 650     __ movl(bc, Bytecodes::_fast_icaload);
 651     __ jccb(Assembler::equal, rewrite);
 652 
 653     // rewrite so iload doesn&#39;t check again.
 654     __ movl(bc, Bytecodes::_fast_iload);
 655 
 656     // rewrite
 657     // bc: fast bytecode
 658     __ bind(rewrite);
 659     patch_bytecode(Bytecodes::_iload, bc, rbx, false);
 660     __ bind(done);
 661   }
 662 
 663   // Get the local value into tos
 664   locals_index(rbx);
 665   __ movl(rax, iaddress(rbx));
 666 }
 667 
 668 void TemplateTable::fast_iload2() {
 669   transition(vtos, itos);
 670   locals_index(rbx);
 671   __ movl(rax, iaddress(rbx));
 672   __ push(itos);
 673   locals_index(rbx, 3);
 674   __ movl(rax, iaddress(rbx));
 675 }
 676 
 677 void TemplateTable::fast_iload() {
 678   transition(vtos, itos);
 679   locals_index(rbx);
 680   __ movl(rax, iaddress(rbx));
 681 }
 682 
 683 void TemplateTable::lload() {
 684   transition(vtos, ltos);
 685   locals_index(rbx);
 686   __ movptr(rax, laddress(rbx));
 687   NOT_LP64(__ movl(rdx, haddress(rbx)));
 688 }
 689 
 690 void TemplateTable::fload() {
 691   transition(vtos, ftos);
 692   locals_index(rbx);
 693   __ load_float(faddress(rbx));
 694 }
 695 
 696 void TemplateTable::dload() {
 697   transition(vtos, dtos);
 698   locals_index(rbx);
 699   __ load_double(daddress(rbx));
 700 }
 701 
 702 void TemplateTable::aload() {
 703   transition(vtos, atos);
 704   locals_index(rbx);
 705   __ movptr(rax, aaddress(rbx));
 706 }
 707 
 708 void TemplateTable::locals_index_wide(Register reg) {
 709   __ load_unsigned_short(reg, at_bcp(2));
 710   __ bswapl(reg);
 711   __ shrl(reg, 16);
 712   __ negptr(reg);
 713 }
 714 
 715 void TemplateTable::wide_iload() {
 716   transition(vtos, itos);
 717   locals_index_wide(rbx);
 718   __ movl(rax, iaddress(rbx));
 719 }
 720 
 721 void TemplateTable::wide_lload() {
 722   transition(vtos, ltos);
 723   locals_index_wide(rbx);
 724   __ movptr(rax, laddress(rbx));
 725   NOT_LP64(__ movl(rdx, haddress(rbx)));
 726 }
 727 
 728 void TemplateTable::wide_fload() {
 729   transition(vtos, ftos);
 730   locals_index_wide(rbx);
 731   __ load_float(faddress(rbx));
 732 }
 733 
 734 void TemplateTable::wide_dload() {
 735   transition(vtos, dtos);
 736   locals_index_wide(rbx);
 737   __ load_double(daddress(rbx));
 738 }
 739 
 740 void TemplateTable::wide_aload() {
 741   transition(vtos, atos);
 742   locals_index_wide(rbx);
 743   __ movptr(rax, aaddress(rbx));
 744 }
 745 
 746 void TemplateTable::index_check(Register array, Register index) {
 747   // Pop ptr into array
 748   __ pop_ptr(array);
 749   index_check_without_pop(array, index);
 750 }
 751 
 752 void TemplateTable::index_check_without_pop(Register array, Register index) {
 753   // destroys rbx
 754   // check array
 755   __ null_check(array, arrayOopDesc::length_offset_in_bytes());
 756   // sign extend index for use by indexed load
 757   __ movl2ptr(index, index);
 758   // check index
 759   __ cmpl(index, Address(array, arrayOopDesc::length_offset_in_bytes()));
 760   if (index != rbx) {
 761     // ??? convention: move aberrant index into rbx for exception message
 762     assert(rbx != array, &quot;different registers&quot;);
 763     __ movl(rbx, index);
 764   }
 765   Label skip;
 766   __ jccb(Assembler::below, skip);
 767   // Pass array to create more detailed exceptions.
 768   __ mov(NOT_LP64(rax) LP64_ONLY(c_rarg1), array);
 769   __ jump(ExternalAddress(Interpreter::_throw_ArrayIndexOutOfBoundsException_entry));
 770   __ bind(skip);
 771 }
 772 
 773 void TemplateTable::iaload() {
 774   transition(itos, itos);
 775   // rax: index
 776   // rdx: array
 777   index_check(rdx, rax); // kills rbx
 778   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax,
 779                     Address(rdx, rax, Address::times_4,
 780                             arrayOopDesc::base_offset_in_bytes(T_INT)),
 781                     noreg, noreg);
 782 }
 783 
 784 void TemplateTable::laload() {
 785   transition(itos, ltos);
 786   // rax: index
 787   // rdx: array
 788   index_check(rdx, rax); // kills rbx
 789   NOT_LP64(__ mov(rbx, rax));
 790   // rbx,: index
 791   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg /* ltos */,
 792                     Address(rdx, rbx, Address::times_8,
 793                             arrayOopDesc::base_offset_in_bytes(T_LONG)),
 794                     noreg, noreg);
 795 }
 796 
 797 
 798 
 799 void TemplateTable::faload() {
 800   transition(itos, ftos);
 801   // rax: index
 802   // rdx: array
 803   index_check(rdx, rax); // kills rbx
 804   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg /* ftos */,
 805                     Address(rdx, rax,
 806                             Address::times_4,
 807                             arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
 808                     noreg, noreg);
 809 }
 810 
 811 void TemplateTable::daload() {
 812   transition(itos, dtos);
 813   // rax: index
 814   // rdx: array
 815   index_check(rdx, rax); // kills rbx
 816   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg /* dtos */,
 817                     Address(rdx, rax,
 818                             Address::times_8,
 819                             arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
 820                     noreg, noreg);
 821 }
 822 
 823 void TemplateTable::aaload() {
 824   transition(itos, atos);
 825   Register array = rdx;
 826   Register index = rax;
 827 
 828   index_check(array, index); // kills rbx
 829   __ profile_array(rbx, array, rcx);
 830   if (ValueArrayFlatten) {
 831     Label is_flat_array, done;
 832     __ test_flattened_array_oop(array, rbx, is_flat_array);
 833     do_oop_load(_masm,
 834                 Address(array, index,
 835                         UseCompressedOops ? Address::times_4 : Address::times_ptr,
 836                         arrayOopDesc::base_offset_in_bytes(T_OBJECT)),
 837                 rax,
 838                 IS_ARRAY);
 839     __ jmp(done);
 840     __ bind(is_flat_array);
 841     __ read_flattened_element(array, index, rbx, rcx, rax);
 842     __ bind(done);
 843   } else {
 844     do_oop_load(_masm,
 845                 Address(array, index,
 846                         UseCompressedOops ? Address::times_4 : Address::times_ptr,
 847                         arrayOopDesc::base_offset_in_bytes(T_OBJECT)),
 848                 rax,
 849                 IS_ARRAY);
 850   }
 851   __ profile_element(rbx, rax, rcx);
 852 }
 853 
 854 void TemplateTable::baload() {
 855   transition(itos, itos);
 856   // rax: index
 857   // rdx: array
 858   index_check(rdx, rax); // kills rbx
 859   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax,
 860                     Address(rdx, rax, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_BYTE)),
 861                     noreg, noreg);
 862 }
 863 
 864 void TemplateTable::caload() {
 865   transition(itos, itos);
 866   // rax: index
 867   // rdx: array
 868   index_check(rdx, rax); // kills rbx
 869   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,
 870                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),
 871                     noreg, noreg);
 872 }
 873 
 874 // iload followed by caload frequent pair
 875 void TemplateTable::fast_icaload() {
 876   transition(vtos, itos);
 877   // load index out of locals
 878   locals_index(rbx);
 879   __ movl(rax, iaddress(rbx));
 880 
 881   // rax: index
 882   // rdx: array
 883   index_check(rdx, rax); // kills rbx
 884   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,
 885                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),
 886                     noreg, noreg);
 887 }
 888 
 889 
 890 void TemplateTable::saload() {
 891   transition(itos, itos);
 892   // rax: index
 893   // rdx: array
 894   index_check(rdx, rax); // kills rbx
 895   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax,
 896                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_SHORT)),
 897                     noreg, noreg);
 898 }
 899 
 900 void TemplateTable::iload(int n) {
 901   transition(vtos, itos);
 902   __ movl(rax, iaddress(n));
 903 }
 904 
 905 void TemplateTable::lload(int n) {
 906   transition(vtos, ltos);
 907   __ movptr(rax, laddress(n));
 908   NOT_LP64(__ movptr(rdx, haddress(n)));
 909 }
 910 
 911 void TemplateTable::fload(int n) {
 912   transition(vtos, ftos);
 913   __ load_float(faddress(n));
 914 }
 915 
 916 void TemplateTable::dload(int n) {
 917   transition(vtos, dtos);
 918   __ load_double(daddress(n));
 919 }
 920 
 921 void TemplateTable::aload(int n) {
 922   transition(vtos, atos);
 923   __ movptr(rax, aaddress(n));
 924 }
 925 
 926 void TemplateTable::aload_0() {
 927   aload_0_internal();
 928 }
 929 
 930 void TemplateTable::nofast_aload_0() {
 931   aload_0_internal(may_not_rewrite);
 932 }
 933 
 934 void TemplateTable::aload_0_internal(RewriteControl rc) {
 935   transition(vtos, atos);
 936   // According to bytecode histograms, the pairs:
 937   //
 938   // _aload_0, _fast_igetfield
 939   // _aload_0, _fast_agetfield
 940   // _aload_0, _fast_fgetfield
 941   //
 942   // occur frequently. If RewriteFrequentPairs is set, the (slow)
 943   // _aload_0 bytecode checks if the next bytecode is either
 944   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
 945   // rewrites the current bytecode into a pair bytecode; otherwise it
 946   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
 947   // the pair check anymore.
 948   //
 949   // Note: If the next bytecode is _getfield, the rewrite must be
 950   //       delayed, otherwise we may miss an opportunity for a pair.
 951   //
 952   // Also rewrite frequent pairs
 953   //   aload_0, aload_1
 954   //   aload_0, iload_1
 955   // These bytecodes with a small amount of code are most profitable
 956   // to rewrite
 957   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 958     Label rewrite, done;
 959 
 960     const Register bc = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
 961     LP64_ONLY(assert(rbx != bc, &quot;register damaged&quot;));
 962 
 963     // get next byte
 964     __ load_unsigned_byte(rbx, at_bcp(Bytecodes::length_for(Bytecodes::_aload_0)));
 965 
 966     // if _getfield then wait with rewrite
 967     __ cmpl(rbx, Bytecodes::_getfield);
 968     __ jcc(Assembler::equal, done);
 969 
 970     // if _igetfield then rewrite to _fast_iaccess_0
 971     assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 972     __ cmpl(rbx, Bytecodes::_fast_igetfield);
 973     __ movl(bc, Bytecodes::_fast_iaccess_0);
 974     __ jccb(Assembler::equal, rewrite);
 975 
 976     // if _agetfield then rewrite to _fast_aaccess_0
 977     assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 978     __ cmpl(rbx, Bytecodes::_fast_agetfield);
 979     __ movl(bc, Bytecodes::_fast_aaccess_0);
 980     __ jccb(Assembler::equal, rewrite);
 981 
 982     // if _fgetfield then rewrite to _fast_faccess_0
 983     assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 984     __ cmpl(rbx, Bytecodes::_fast_fgetfield);
 985     __ movl(bc, Bytecodes::_fast_faccess_0);
 986     __ jccb(Assembler::equal, rewrite);
 987 
 988     // else rewrite to _fast_aload0
 989     assert(Bytecodes::java_code(Bytecodes::_fast_aload_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 990     __ movl(bc, Bytecodes::_fast_aload_0);
 991 
 992     // rewrite
 993     // bc: fast bytecode
 994     __ bind(rewrite);
 995     patch_bytecode(Bytecodes::_aload_0, bc, rbx, false);
 996 
 997     __ bind(done);
 998   }
 999 
1000   // Do actual aload_0 (must do this after patch_bytecode which might call VM and GC might change oop).
1001   aload(0);
1002 }
1003 
1004 void TemplateTable::istore() {
1005   transition(itos, vtos);
1006   locals_index(rbx);
1007   __ movl(iaddress(rbx), rax);
1008 }
1009 
1010 
1011 void TemplateTable::lstore() {
1012   transition(ltos, vtos);
1013   locals_index(rbx);
1014   __ movptr(laddress(rbx), rax);
1015   NOT_LP64(__ movptr(haddress(rbx), rdx));
1016 }
1017 
1018 void TemplateTable::fstore() {
1019   transition(ftos, vtos);
1020   locals_index(rbx);
1021   __ store_float(faddress(rbx));
1022 }
1023 
1024 void TemplateTable::dstore() {
1025   transition(dtos, vtos);
1026   locals_index(rbx);
1027   __ store_double(daddress(rbx));
1028 }
1029 
1030 void TemplateTable::astore() {
1031   transition(vtos, vtos);
1032   __ pop_ptr(rax);
1033   locals_index(rbx);
1034   __ movptr(aaddress(rbx), rax);
1035 }
1036 
1037 void TemplateTable::wide_istore() {
1038   transition(vtos, vtos);
1039   __ pop_i();
1040   locals_index_wide(rbx);
1041   __ movl(iaddress(rbx), rax);
1042 }
1043 
1044 void TemplateTable::wide_lstore() {
1045   transition(vtos, vtos);
1046   NOT_LP64(__ pop_l(rax, rdx));
1047   LP64_ONLY(__ pop_l());
1048   locals_index_wide(rbx);
1049   __ movptr(laddress(rbx), rax);
1050   NOT_LP64(__ movl(haddress(rbx), rdx));
1051 }
1052 
1053 void TemplateTable::wide_fstore() {
1054 #ifdef _LP64
1055   transition(vtos, vtos);
1056   __ pop_f(xmm0);
1057   locals_index_wide(rbx);
1058   __ movflt(faddress(rbx), xmm0);
1059 #else
1060   wide_istore();
1061 #endif
1062 }
1063 
1064 void TemplateTable::wide_dstore() {
1065 #ifdef _LP64
1066   transition(vtos, vtos);
1067   __ pop_d(xmm0);
1068   locals_index_wide(rbx);
1069   __ movdbl(daddress(rbx), xmm0);
1070 #else
1071   wide_lstore();
1072 #endif
1073 }
1074 
1075 void TemplateTable::wide_astore() {
1076   transition(vtos, vtos);
1077   __ pop_ptr(rax);
1078   locals_index_wide(rbx);
1079   __ movptr(aaddress(rbx), rax);
1080 }
1081 
1082 void TemplateTable::iastore() {
1083   transition(itos, vtos);
1084   __ pop_i(rbx);
1085   // rax: value
1086   // rbx: index
1087   // rdx: array
1088   index_check(rdx, rbx); // prefer index in rbx
1089   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY,
1090                      Address(rdx, rbx, Address::times_4,
1091                              arrayOopDesc::base_offset_in_bytes(T_INT)),
1092                      rax, noreg, noreg);
1093 }
1094 
1095 void TemplateTable::lastore() {
1096   transition(ltos, vtos);
1097   __ pop_i(rbx);
1098   // rax,: low(value)
1099   // rcx: array
1100   // rdx: high(value)
1101   index_check(rcx, rbx);  // prefer index in rbx,
1102   // rbx,: index
1103   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY,
1104                      Address(rcx, rbx, Address::times_8,
1105                              arrayOopDesc::base_offset_in_bytes(T_LONG)),
1106                      noreg /* ltos */, noreg, noreg);
1107 }
1108 
1109 
1110 void TemplateTable::fastore() {
1111   transition(ftos, vtos);
1112   __ pop_i(rbx);
1113   // value is in UseSSE &gt;= 1 ? xmm0 : ST(0)
1114   // rbx:  index
1115   // rdx:  array
1116   index_check(rdx, rbx); // prefer index in rbx
1117   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY,
1118                      Address(rdx, rbx, Address::times_4,
1119                              arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
1120                      noreg /* ftos */, noreg, noreg);
1121 }
1122 
1123 void TemplateTable::dastore() {
1124   transition(dtos, vtos);
1125   __ pop_i(rbx);
1126   // value is in UseSSE &gt;= 2 ? xmm0 : ST(0)
1127   // rbx:  index
1128   // rdx:  array
1129   index_check(rdx, rbx); // prefer index in rbx
1130   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY,
1131                      Address(rdx, rbx, Address::times_8,
1132                              arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
1133                      noreg /* dtos */, noreg, noreg);
1134 }
1135 
1136 void TemplateTable::aastore() {
1137   Label is_null, is_flat_array, ok_is_subtype, done;
1138   transition(vtos, vtos);
1139   // stack: ..., array, index, value
1140   __ movptr(rax, at_tos());    // value
1141   __ movl(rcx, at_tos_p1()); // index
1142   __ movptr(rdx, at_tos_p2()); // array
1143 
1144   Address element_address(rdx, rcx,
1145                           UseCompressedOops? Address::times_4 : Address::times_ptr,
1146                           arrayOopDesc::base_offset_in_bytes(T_OBJECT));
1147 
1148   index_check_without_pop(rdx, rcx);     // kills rbx
1149 
1150   __ profile_array(rdi, rdx, rbx);
1151   __ profile_element(rdi, rax, rbx);
1152 
1153   __ testptr(rax, rax);
1154   __ jcc(Assembler::zero, is_null);
1155 
1156   // Move array class to rdi
<a name="1" id="anc1"></a><span class="line-modified">1157   __ load_klass(rdi, rdx);</span>

1158   if (ValueArrayFlatten) {
1159     __ movl(rbx, Address(rdi, Klass::layout_helper_offset()));
1160     __ test_flattened_array_layout(rbx, is_flat_array);
1161   }
1162 
1163   // Move subklass into rbx
<a name="2" id="anc2"></a><span class="line-modified">1164   __ load_klass(rbx, rax);</span>
1165   // Move array element superklass into rax
1166   __ movptr(rax, Address(rdi,
1167                          ObjArrayKlass::element_klass_offset()));
1168 
1169   // Generate subtype check.  Blows rcx, rdi
1170   // Superklass in rax.  Subklass in rbx.
1171   // is &quot;rbx &lt;: rax&quot; ? (value subclass &lt;: array element superclass)
1172   __ gen_subtype_check(rbx, ok_is_subtype, false);
1173 
1174   // Come here on failure
1175   // object is at TOS
1176   __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));
1177 
1178   // Come here on success
1179   __ bind(ok_is_subtype);
1180 
1181   // Get the value we will store
1182   __ movptr(rax, at_tos());
1183   __ movl(rcx, at_tos_p1()); // index
1184   // Now store using the appropriate barrier
1185   do_oop_store(_masm, element_address, rax, IS_ARRAY);
1186   __ jmp(done);
1187 
1188   // Have a NULL in rax, rdx=array, ecx=index.  Store NULL at ary[idx]
1189   __ bind(is_null);
1190   if (EnableValhalla) {
1191     Label is_null_into_value_array_npe, store_null;
1192 
1193     // No way to store null in null-free array
1194     __ test_null_free_array_oop(rdx, rbx, is_null_into_value_array_npe);
1195     __ jmp(store_null);
1196 
1197     __ bind(is_null_into_value_array_npe);
1198     __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));
1199 
1200     __ bind(store_null);
1201   }
1202   // Store a NULL
1203   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
1204   __ jmp(done);
1205 
1206   if (EnableValhalla) {
1207     Label is_type_ok;
1208     __ bind(is_flat_array); // Store non-null value to flat
1209 
1210     // Simplistic type check...
1211 
1212     // Profile the not-null value&#39;s klass.
<a name="3" id="anc3"></a><span class="line-modified">1213     __ load_klass(rbx, rax);</span>
1214     // Move element klass into rax
1215     __ movptr(rax, Address(rdi, ArrayKlass::element_klass_offset()));
1216     // flat value array needs exact type match
1217     // is &quot;rax == rbx&quot; (value subclass == array element superclass)
1218     __ cmpptr(rax, rbx);
1219     __ jccb(Assembler::equal, is_type_ok);
1220 
1221     __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));
1222 
1223     __ bind(is_type_ok);
1224     // rbx: value&#39;s klass
1225     // rdx: array
1226     // rdi: array klass
1227     __ test_klass_is_empty_value(rbx, rax, done);
1228 
1229     // calc dst for copy
1230     __ movl(rax, at_tos_p1()); // index
1231     __ data_for_value_array_index(rdx, rdi, rax, rax);
1232 
1233     // ...and src for copy
1234     __ movptr(rcx, at_tos());  // value
1235     __ data_for_oop(rcx, rcx, rbx);
1236 
1237     __ access_value_copy(IN_HEAP, rcx, rax, rbx);
1238   }
1239   // Pop stack arguments
1240   __ bind(done);
1241   __ addptr(rsp, 3 * Interpreter::stackElementSize);
1242 }
1243 
1244 void TemplateTable::bastore() {
1245   transition(itos, vtos);
1246   __ pop_i(rbx);
1247   // rax: value
1248   // rbx: index
1249   // rdx: array
1250   index_check(rdx, rbx); // prefer index in rbx
1251   // Need to check whether array is boolean or byte
1252   // since both types share the bastore bytecode.
<a name="4" id="anc4"></a><span class="line-modified">1253   __ load_klass(rcx, rdx);</span>

1254   __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
1255   int diffbit = Klass::layout_helper_boolean_diffbit();
1256   __ testl(rcx, diffbit);
1257   Label L_skip;
1258   __ jccb(Assembler::zero, L_skip);
1259   __ andl(rax, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
1260   __ bind(L_skip);
1261   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY,
1262                      Address(rdx, rbx,Address::times_1,
1263                              arrayOopDesc::base_offset_in_bytes(T_BYTE)),
1264                      rax, noreg, noreg);
1265 }
1266 
1267 void TemplateTable::castore() {
1268   transition(itos, vtos);
1269   __ pop_i(rbx);
1270   // rax: value
1271   // rbx: index
1272   // rdx: array
1273   index_check(rdx, rbx);  // prefer index in rbx
1274   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY,
1275                      Address(rdx, rbx, Address::times_2,
1276                              arrayOopDesc::base_offset_in_bytes(T_CHAR)),
1277                      rax, noreg, noreg);
1278 }
1279 
1280 
1281 void TemplateTable::sastore() {
1282   castore();
1283 }
1284 
1285 void TemplateTable::istore(int n) {
1286   transition(itos, vtos);
1287   __ movl(iaddress(n), rax);
1288 }
1289 
1290 void TemplateTable::lstore(int n) {
1291   transition(ltos, vtos);
1292   __ movptr(laddress(n), rax);
1293   NOT_LP64(__ movptr(haddress(n), rdx));
1294 }
1295 
1296 void TemplateTable::fstore(int n) {
1297   transition(ftos, vtos);
1298   __ store_float(faddress(n));
1299 }
1300 
1301 void TemplateTable::dstore(int n) {
1302   transition(dtos, vtos);
1303   __ store_double(daddress(n));
1304 }
1305 
1306 
1307 void TemplateTable::astore(int n) {
1308   transition(vtos, vtos);
1309   __ pop_ptr(rax);
1310   __ movptr(aaddress(n), rax);
1311 }
1312 
1313 void TemplateTable::pop() {
1314   transition(vtos, vtos);
1315   __ addptr(rsp, Interpreter::stackElementSize);
1316 }
1317 
1318 void TemplateTable::pop2() {
1319   transition(vtos, vtos);
1320   __ addptr(rsp, 2 * Interpreter::stackElementSize);
1321 }
1322 
1323 
1324 void TemplateTable::dup() {
1325   transition(vtos, vtos);
1326   __ load_ptr(0, rax);
1327   __ push_ptr(rax);
1328   // stack: ..., a, a
1329 }
1330 
1331 void TemplateTable::dup_x1() {
1332   transition(vtos, vtos);
1333   // stack: ..., a, b
1334   __ load_ptr( 0, rax);  // load b
1335   __ load_ptr( 1, rcx);  // load a
1336   __ store_ptr(1, rax);  // store b
1337   __ store_ptr(0, rcx);  // store a
1338   __ push_ptr(rax);      // push b
1339   // stack: ..., b, a, b
1340 }
1341 
1342 void TemplateTable::dup_x2() {
1343   transition(vtos, vtos);
1344   // stack: ..., a, b, c
1345   __ load_ptr( 0, rax);  // load c
1346   __ load_ptr( 2, rcx);  // load a
1347   __ store_ptr(2, rax);  // store c in a
1348   __ push_ptr(rax);      // push c
1349   // stack: ..., c, b, c, c
1350   __ load_ptr( 2, rax);  // load b
1351   __ store_ptr(2, rcx);  // store a in b
1352   // stack: ..., c, a, c, c
1353   __ store_ptr(1, rax);  // store b in c
1354   // stack: ..., c, a, b, c
1355 }
1356 
1357 void TemplateTable::dup2() {
1358   transition(vtos, vtos);
1359   // stack: ..., a, b
1360   __ load_ptr(1, rax);  // load a
1361   __ push_ptr(rax);     // push a
1362   __ load_ptr(1, rax);  // load b
1363   __ push_ptr(rax);     // push b
1364   // stack: ..., a, b, a, b
1365 }
1366 
1367 
1368 void TemplateTable::dup2_x1() {
1369   transition(vtos, vtos);
1370   // stack: ..., a, b, c
1371   __ load_ptr( 0, rcx);  // load c
1372   __ load_ptr( 1, rax);  // load b
1373   __ push_ptr(rax);      // push b
1374   __ push_ptr(rcx);      // push c
1375   // stack: ..., a, b, c, b, c
1376   __ store_ptr(3, rcx);  // store c in b
1377   // stack: ..., a, c, c, b, c
1378   __ load_ptr( 4, rcx);  // load a
1379   __ store_ptr(2, rcx);  // store a in 2nd c
1380   // stack: ..., a, c, a, b, c
1381   __ store_ptr(4, rax);  // store b in a
1382   // stack: ..., b, c, a, b, c
1383 }
1384 
1385 void TemplateTable::dup2_x2() {
1386   transition(vtos, vtos);
1387   // stack: ..., a, b, c, d
1388   __ load_ptr( 0, rcx);  // load d
1389   __ load_ptr( 1, rax);  // load c
1390   __ push_ptr(rax);      // push c
1391   __ push_ptr(rcx);      // push d
1392   // stack: ..., a, b, c, d, c, d
1393   __ load_ptr( 4, rax);  // load b
1394   __ store_ptr(2, rax);  // store b in d
1395   __ store_ptr(4, rcx);  // store d in b
1396   // stack: ..., a, d, c, b, c, d
1397   __ load_ptr( 5, rcx);  // load a
1398   __ load_ptr( 3, rax);  // load c
1399   __ store_ptr(3, rcx);  // store a in c
1400   __ store_ptr(5, rax);  // store c in a
1401   // stack: ..., c, d, a, b, c, d
1402 }
1403 
1404 void TemplateTable::swap() {
1405   transition(vtos, vtos);
1406   // stack: ..., a, b
1407   __ load_ptr( 1, rcx);  // load a
1408   __ load_ptr( 0, rax);  // load b
1409   __ store_ptr(0, rcx);  // store a in b
1410   __ store_ptr(1, rax);  // store b in a
1411   // stack: ..., b, a
1412 }
1413 
1414 void TemplateTable::iop2(Operation op) {
1415   transition(itos, itos);
1416   switch (op) {
1417   case add  :                    __ pop_i(rdx); __ addl (rax, rdx); break;
1418   case sub  : __ movl(rdx, rax); __ pop_i(rax); __ subl (rax, rdx); break;
1419   case mul  :                    __ pop_i(rdx); __ imull(rax, rdx); break;
1420   case _and :                    __ pop_i(rdx); __ andl (rax, rdx); break;
1421   case _or  :                    __ pop_i(rdx); __ orl  (rax, rdx); break;
1422   case _xor :                    __ pop_i(rdx); __ xorl (rax, rdx); break;
1423   case shl  : __ movl(rcx, rax); __ pop_i(rax); __ shll (rax);      break;
1424   case shr  : __ movl(rcx, rax); __ pop_i(rax); __ sarl (rax);      break;
1425   case ushr : __ movl(rcx, rax); __ pop_i(rax); __ shrl (rax);      break;
1426   default   : ShouldNotReachHere();
1427   }
1428 }
1429 
1430 void TemplateTable::lop2(Operation op) {
1431   transition(ltos, ltos);
1432 #ifdef _LP64
1433   switch (op) {
1434   case add  :                    __ pop_l(rdx); __ addptr(rax, rdx); break;
1435   case sub  : __ mov(rdx, rax);  __ pop_l(rax); __ subptr(rax, rdx); break;
1436   case _and :                    __ pop_l(rdx); __ andptr(rax, rdx); break;
1437   case _or  :                    __ pop_l(rdx); __ orptr (rax, rdx); break;
1438   case _xor :                    __ pop_l(rdx); __ xorptr(rax, rdx); break;
1439   default   : ShouldNotReachHere();
1440   }
1441 #else
1442   __ pop_l(rbx, rcx);
1443   switch (op) {
1444     case add  : __ addl(rax, rbx); __ adcl(rdx, rcx); break;
1445     case sub  : __ subl(rbx, rax); __ sbbl(rcx, rdx);
1446                 __ mov (rax, rbx); __ mov (rdx, rcx); break;
1447     case _and : __ andl(rax, rbx); __ andl(rdx, rcx); break;
1448     case _or  : __ orl (rax, rbx); __ orl (rdx, rcx); break;
1449     case _xor : __ xorl(rax, rbx); __ xorl(rdx, rcx); break;
1450     default   : ShouldNotReachHere();
1451   }
1452 #endif
1453 }
1454 
1455 void TemplateTable::idiv() {
1456   transition(itos, itos);
1457   __ movl(rcx, rax);
1458   __ pop_i(rax);
1459   // Note: could xor rax and ecx and compare with (-1 ^ min_int). If
1460   //       they are not equal, one could do a normal division (no correction
1461   //       needed), which may speed up this implementation for the common case.
1462   //       (see also JVM spec., p.243 &amp; p.271)
1463   __ corrected_idivl(rcx);
1464 }
1465 
1466 void TemplateTable::irem() {
1467   transition(itos, itos);
1468   __ movl(rcx, rax);
1469   __ pop_i(rax);
1470   // Note: could xor rax and ecx and compare with (-1 ^ min_int). If
1471   //       they are not equal, one could do a normal division (no correction
1472   //       needed), which may speed up this implementation for the common case.
1473   //       (see also JVM spec., p.243 &amp; p.271)
1474   __ corrected_idivl(rcx);
1475   __ movl(rax, rdx);
1476 }
1477 
1478 void TemplateTable::lmul() {
1479   transition(ltos, ltos);
1480 #ifdef _LP64
1481   __ pop_l(rdx);
1482   __ imulq(rax, rdx);
1483 #else
1484   __ pop_l(rbx, rcx);
1485   __ push(rcx); __ push(rbx);
1486   __ push(rdx); __ push(rax);
1487   __ lmul(2 * wordSize, 0);
1488   __ addptr(rsp, 4 * wordSize);  // take off temporaries
1489 #endif
1490 }
1491 
1492 void TemplateTable::ldiv() {
1493   transition(ltos, ltos);
1494 #ifdef _LP64
1495   __ mov(rcx, rax);
1496   __ pop_l(rax);
1497   // generate explicit div0 check
1498   __ testq(rcx, rcx);
1499   __ jump_cc(Assembler::zero,
1500              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1501   // Note: could xor rax and rcx and compare with (-1 ^ min_int). If
1502   //       they are not equal, one could do a normal division (no correction
1503   //       needed), which may speed up this implementation for the common case.
1504   //       (see also JVM spec., p.243 &amp; p.271)
1505   __ corrected_idivq(rcx); // kills rbx
1506 #else
1507   __ pop_l(rbx, rcx);
1508   __ push(rcx); __ push(rbx);
1509   __ push(rdx); __ push(rax);
1510   // check if y = 0
1511   __ orl(rax, rdx);
1512   __ jump_cc(Assembler::zero,
1513              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1514   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::ldiv));
1515   __ addptr(rsp, 4 * wordSize);  // take off temporaries
1516 #endif
1517 }
1518 
1519 void TemplateTable::lrem() {
1520   transition(ltos, ltos);
1521 #ifdef _LP64
1522   __ mov(rcx, rax);
1523   __ pop_l(rax);
1524   __ testq(rcx, rcx);
1525   __ jump_cc(Assembler::zero,
1526              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1527   // Note: could xor rax and rcx and compare with (-1 ^ min_int). If
1528   //       they are not equal, one could do a normal division (no correction
1529   //       needed), which may speed up this implementation for the common case.
1530   //       (see also JVM spec., p.243 &amp; p.271)
1531   __ corrected_idivq(rcx); // kills rbx
1532   __ mov(rax, rdx);
1533 #else
1534   __ pop_l(rbx, rcx);
1535   __ push(rcx); __ push(rbx);
1536   __ push(rdx); __ push(rax);
1537   // check if y = 0
1538   __ orl(rax, rdx);
1539   __ jump_cc(Assembler::zero,
1540              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1541   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::lrem));
1542   __ addptr(rsp, 4 * wordSize);
1543 #endif
1544 }
1545 
1546 void TemplateTable::lshl() {
1547   transition(itos, ltos);
1548   __ movl(rcx, rax);                             // get shift count
1549   #ifdef _LP64
1550   __ pop_l(rax);                                 // get shift value
1551   __ shlq(rax);
1552 #else
1553   __ pop_l(rax, rdx);                            // get shift value
1554   __ lshl(rdx, rax);
1555 #endif
1556 }
1557 
1558 void TemplateTable::lshr() {
1559 #ifdef _LP64
1560   transition(itos, ltos);
1561   __ movl(rcx, rax);                             // get shift count
1562   __ pop_l(rax);                                 // get shift value
1563   __ sarq(rax);
1564 #else
1565   transition(itos, ltos);
1566   __ mov(rcx, rax);                              // get shift count
1567   __ pop_l(rax, rdx);                            // get shift value
1568   __ lshr(rdx, rax, true);
1569 #endif
1570 }
1571 
1572 void TemplateTable::lushr() {
1573   transition(itos, ltos);
1574 #ifdef _LP64
1575   __ movl(rcx, rax);                             // get shift count
1576   __ pop_l(rax);                                 // get shift value
1577   __ shrq(rax);
1578 #else
1579   __ mov(rcx, rax);                              // get shift count
1580   __ pop_l(rax, rdx);                            // get shift value
1581   __ lshr(rdx, rax);
1582 #endif
1583 }
1584 
1585 void TemplateTable::fop2(Operation op) {
1586   transition(ftos, ftos);
1587 
1588   if (UseSSE &gt;= 1) {
1589     switch (op) {
1590     case add:
1591       __ addss(xmm0, at_rsp());
1592       __ addptr(rsp, Interpreter::stackElementSize);
1593       break;
1594     case sub:
1595       __ movflt(xmm1, xmm0);
1596       __ pop_f(xmm0);
1597       __ subss(xmm0, xmm1);
1598       break;
1599     case mul:
1600       __ mulss(xmm0, at_rsp());
1601       __ addptr(rsp, Interpreter::stackElementSize);
1602       break;
1603     case div:
1604       __ movflt(xmm1, xmm0);
1605       __ pop_f(xmm0);
1606       __ divss(xmm0, xmm1);
1607       break;
1608     case rem:
1609       // On x86_64 platforms the SharedRuntime::frem method is called to perform the
1610       // modulo operation. The frem method calls the function
1611       // double fmod(double x, double y) in math.h. The documentation of fmod states:
1612       // &quot;If x or y is a NaN, a NaN is returned.&quot; without specifying what type of NaN
1613       // (signalling or quiet) is returned.
1614       //
1615       // On x86_32 platforms the FPU is used to perform the modulo operation. The
1616       // reason is that on 32-bit Windows the sign of modulo operations diverges from
1617       // what is considered the standard (e.g., -0.0f % -3.14f is 0.0f (and not -0.0f).
1618       // The fprem instruction used on x86_32 is functionally equivalent to
1619       // SharedRuntime::frem in that it returns a NaN.
1620 #ifdef _LP64
1621       __ movflt(xmm1, xmm0);
1622       __ pop_f(xmm0);
1623       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem), 2);
1624 #else
1625       __ push_f(xmm0);
1626       __ pop_f();
1627       __ fld_s(at_rsp());
1628       __ fremr(rax);
1629       __ f2ieee();
1630       __ pop(rax);  // pop second operand off the stack
1631       __ push_f();
1632       __ pop_f(xmm0);
1633 #endif
1634       break;
1635     default:
1636       ShouldNotReachHere();
1637       break;
1638     }
1639   } else {
1640 #ifdef _LP64
1641     ShouldNotReachHere();
1642 #else
1643     switch (op) {
1644     case add: __ fadd_s (at_rsp());                break;
1645     case sub: __ fsubr_s(at_rsp());                break;
1646     case mul: __ fmul_s (at_rsp());                break;
1647     case div: __ fdivr_s(at_rsp());                break;
1648     case rem: __ fld_s  (at_rsp()); __ fremr(rax); break;
1649     default : ShouldNotReachHere();
1650     }
1651     __ f2ieee();
1652     __ pop(rax);  // pop second operand off the stack
1653 #endif // _LP64
1654   }
1655 }
1656 
1657 void TemplateTable::dop2(Operation op) {
1658   transition(dtos, dtos);
1659   if (UseSSE &gt;= 2) {
1660     switch (op) {
1661     case add:
1662       __ addsd(xmm0, at_rsp());
1663       __ addptr(rsp, 2 * Interpreter::stackElementSize);
1664       break;
1665     case sub:
1666       __ movdbl(xmm1, xmm0);
1667       __ pop_d(xmm0);
1668       __ subsd(xmm0, xmm1);
1669       break;
1670     case mul:
1671       __ mulsd(xmm0, at_rsp());
1672       __ addptr(rsp, 2 * Interpreter::stackElementSize);
1673       break;
1674     case div:
1675       __ movdbl(xmm1, xmm0);
1676       __ pop_d(xmm0);
1677       __ divsd(xmm0, xmm1);
1678       break;
1679     case rem:
1680       // Similar to fop2(), the modulo operation is performed using the
1681       // SharedRuntime::drem method (on x86_64 platforms) or using the
1682       // FPU (on x86_32 platforms) for the same reasons as mentioned in fop2().
1683 #ifdef _LP64
1684       __ movdbl(xmm1, xmm0);
1685       __ pop_d(xmm0);
1686       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem), 2);
1687 #else
1688       __ push_d(xmm0);
1689       __ pop_d();
1690       __ fld_d(at_rsp());
1691       __ fremr(rax);
1692       __ d2ieee();
1693       __ pop(rax);
1694       __ pop(rdx);
1695       __ push_d();
1696       __ pop_d(xmm0);
1697 #endif
1698       break;
1699     default:
1700       ShouldNotReachHere();
1701       break;
1702     }
1703   } else {
1704 #ifdef _LP64
1705     ShouldNotReachHere();
1706 #else
1707     switch (op) {
1708     case add: __ fadd_d (at_rsp());                break;
1709     case sub: __ fsubr_d(at_rsp());                break;
1710     case mul: {
1711       Label L_strict;
1712       Label L_join;
1713       const Address access_flags      (rcx, Method::access_flags_offset());
1714       __ get_method(rcx);
1715       __ movl(rcx, access_flags);
1716       __ testl(rcx, JVM_ACC_STRICT);
1717       __ jccb(Assembler::notZero, L_strict);
1718       __ fmul_d (at_rsp());
1719       __ jmpb(L_join);
1720       __ bind(L_strict);
1721       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
1722       __ fmulp();
1723       __ fmul_d (at_rsp());
1724       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
1725       __ fmulp();
1726       __ bind(L_join);
1727       break;
1728     }
1729     case div: {
1730       Label L_strict;
1731       Label L_join;
1732       const Address access_flags      (rcx, Method::access_flags_offset());
1733       __ get_method(rcx);
1734       __ movl(rcx, access_flags);
1735       __ testl(rcx, JVM_ACC_STRICT);
1736       __ jccb(Assembler::notZero, L_strict);
1737       __ fdivr_d(at_rsp());
1738       __ jmp(L_join);
1739       __ bind(L_strict);
1740       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
1741       __ fmul_d (at_rsp());
1742       __ fdivrp();
1743       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
1744       __ fmulp();
1745       __ bind(L_join);
1746       break;
1747     }
1748     case rem: __ fld_d  (at_rsp()); __ fremr(rax); break;
1749     default : ShouldNotReachHere();
1750     }
1751     __ d2ieee();
1752     // Pop double precision number from rsp.
1753     __ pop(rax);
1754     __ pop(rdx);
1755 #endif
1756   }
1757 }
1758 
1759 void TemplateTable::ineg() {
1760   transition(itos, itos);
1761   __ negl(rax);
1762 }
1763 
1764 void TemplateTable::lneg() {
1765   transition(ltos, ltos);
1766   LP64_ONLY(__ negq(rax));
1767   NOT_LP64(__ lneg(rdx, rax));
1768 }
1769 
1770 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
1771 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
1772   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
1773   // of 128-bits operands for SSE instructions.
1774   jlong *operand = (jlong*)(((intptr_t)adr)&amp;((intptr_t)(~0xF)));
1775   // Store the value to a 128-bits operand.
1776   operand[0] = lo;
1777   operand[1] = hi;
1778   return operand;
1779 }
1780 
1781 // Buffer for 128-bits masks used by SSE instructions.
1782 static jlong float_signflip_pool[2*2];
1783 static jlong double_signflip_pool[2*2];
1784 
1785 void TemplateTable::fneg() {
1786   transition(ftos, ftos);
1787   if (UseSSE &gt;= 1) {
1788     static jlong *float_signflip  = double_quadword(&amp;float_signflip_pool[1],  CONST64(0x8000000080000000),  CONST64(0x8000000080000000));
1789     __ xorps(xmm0, ExternalAddress((address) float_signflip));
1790   } else {
1791     LP64_ONLY(ShouldNotReachHere());
1792     NOT_LP64(__ fchs());
1793   }
1794 }
1795 
1796 void TemplateTable::dneg() {
1797   transition(dtos, dtos);
1798   if (UseSSE &gt;= 2) {
1799     static jlong *double_signflip =
1800       double_quadword(&amp;double_signflip_pool[1], CONST64(0x8000000000000000), CONST64(0x8000000000000000));
1801     __ xorpd(xmm0, ExternalAddress((address) double_signflip));
1802   } else {
1803 #ifdef _LP64
1804     ShouldNotReachHere();
1805 #else
1806     __ fchs();
1807 #endif
1808   }
1809 }
1810 
1811 void TemplateTable::iinc() {
1812   transition(vtos, vtos);
1813   __ load_signed_byte(rdx, at_bcp(2)); // get constant
1814   locals_index(rbx);
1815   __ addl(iaddress(rbx), rdx);
1816 }
1817 
1818 void TemplateTable::wide_iinc() {
1819   transition(vtos, vtos);
1820   __ movl(rdx, at_bcp(4)); // get constant
1821   locals_index_wide(rbx);
1822   __ bswapl(rdx); // swap bytes &amp; sign-extend constant
1823   __ sarl(rdx, 16);
1824   __ addl(iaddress(rbx), rdx);
1825   // Note: should probably use only one movl to get both
1826   //       the index and the constant -&gt; fix this
1827 }
1828 
1829 void TemplateTable::convert() {
1830 #ifdef _LP64
1831   // Checking
1832 #ifdef ASSERT
1833   {
1834     TosState tos_in  = ilgl;
1835     TosState tos_out = ilgl;
1836     switch (bytecode()) {
1837     case Bytecodes::_i2l: // fall through
1838     case Bytecodes::_i2f: // fall through
1839     case Bytecodes::_i2d: // fall through
1840     case Bytecodes::_i2b: // fall through
1841     case Bytecodes::_i2c: // fall through
1842     case Bytecodes::_i2s: tos_in = itos; break;
1843     case Bytecodes::_l2i: // fall through
1844     case Bytecodes::_l2f: // fall through
1845     case Bytecodes::_l2d: tos_in = ltos; break;
1846     case Bytecodes::_f2i: // fall through
1847     case Bytecodes::_f2l: // fall through
1848     case Bytecodes::_f2d: tos_in = ftos; break;
1849     case Bytecodes::_d2i: // fall through
1850     case Bytecodes::_d2l: // fall through
1851     case Bytecodes::_d2f: tos_in = dtos; break;
1852     default             : ShouldNotReachHere();
1853     }
1854     switch (bytecode()) {
1855     case Bytecodes::_l2i: // fall through
1856     case Bytecodes::_f2i: // fall through
1857     case Bytecodes::_d2i: // fall through
1858     case Bytecodes::_i2b: // fall through
1859     case Bytecodes::_i2c: // fall through
1860     case Bytecodes::_i2s: tos_out = itos; break;
1861     case Bytecodes::_i2l: // fall through
1862     case Bytecodes::_f2l: // fall through
1863     case Bytecodes::_d2l: tos_out = ltos; break;
1864     case Bytecodes::_i2f: // fall through
1865     case Bytecodes::_l2f: // fall through
1866     case Bytecodes::_d2f: tos_out = ftos; break;
1867     case Bytecodes::_i2d: // fall through
1868     case Bytecodes::_l2d: // fall through
1869     case Bytecodes::_f2d: tos_out = dtos; break;
1870     default             : ShouldNotReachHere();
1871     }
1872     transition(tos_in, tos_out);
1873   }
1874 #endif // ASSERT
1875 
1876   static const int64_t is_nan = 0x8000000000000000L;
1877 
1878   // Conversion
1879   switch (bytecode()) {
1880   case Bytecodes::_i2l:
1881     __ movslq(rax, rax);
1882     break;
1883   case Bytecodes::_i2f:
1884     __ cvtsi2ssl(xmm0, rax);
1885     break;
1886   case Bytecodes::_i2d:
1887     __ cvtsi2sdl(xmm0, rax);
1888     break;
1889   case Bytecodes::_i2b:
1890     __ movsbl(rax, rax);
1891     break;
1892   case Bytecodes::_i2c:
1893     __ movzwl(rax, rax);
1894     break;
1895   case Bytecodes::_i2s:
1896     __ movswl(rax, rax);
1897     break;
1898   case Bytecodes::_l2i:
1899     __ movl(rax, rax);
1900     break;
1901   case Bytecodes::_l2f:
1902     __ cvtsi2ssq(xmm0, rax);
1903     break;
1904   case Bytecodes::_l2d:
1905     __ cvtsi2sdq(xmm0, rax);
1906     break;
1907   case Bytecodes::_f2i:
1908   {
1909     Label L;
1910     __ cvttss2sil(rax, xmm0);
1911     __ cmpl(rax, 0x80000000); // NaN or overflow/underflow?
1912     __ jcc(Assembler::notEqual, L);
1913     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i), 1);
1914     __ bind(L);
1915   }
1916     break;
1917   case Bytecodes::_f2l:
1918   {
1919     Label L;
1920     __ cvttss2siq(rax, xmm0);
1921     // NaN or overflow/underflow?
1922     __ cmp64(rax, ExternalAddress((address) &amp;is_nan));
1923     __ jcc(Assembler::notEqual, L);
1924     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l), 1);
1925     __ bind(L);
1926   }
1927     break;
1928   case Bytecodes::_f2d:
1929     __ cvtss2sd(xmm0, xmm0);
1930     break;
1931   case Bytecodes::_d2i:
1932   {
1933     Label L;
1934     __ cvttsd2sil(rax, xmm0);
1935     __ cmpl(rax, 0x80000000); // NaN or overflow/underflow?
1936     __ jcc(Assembler::notEqual, L);
1937     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i), 1);
1938     __ bind(L);
1939   }
1940     break;
1941   case Bytecodes::_d2l:
1942   {
1943     Label L;
1944     __ cvttsd2siq(rax, xmm0);
1945     // NaN or overflow/underflow?
1946     __ cmp64(rax, ExternalAddress((address) &amp;is_nan));
1947     __ jcc(Assembler::notEqual, L);
1948     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l), 1);
1949     __ bind(L);
1950   }
1951     break;
1952   case Bytecodes::_d2f:
1953     __ cvtsd2ss(xmm0, xmm0);
1954     break;
1955   default:
1956     ShouldNotReachHere();
1957   }
1958 #else
1959   // Checking
1960 #ifdef ASSERT
1961   { TosState tos_in  = ilgl;
1962     TosState tos_out = ilgl;
1963     switch (bytecode()) {
1964       case Bytecodes::_i2l: // fall through
1965       case Bytecodes::_i2f: // fall through
1966       case Bytecodes::_i2d: // fall through
1967       case Bytecodes::_i2b: // fall through
1968       case Bytecodes::_i2c: // fall through
1969       case Bytecodes::_i2s: tos_in = itos; break;
1970       case Bytecodes::_l2i: // fall through
1971       case Bytecodes::_l2f: // fall through
1972       case Bytecodes::_l2d: tos_in = ltos; break;
1973       case Bytecodes::_f2i: // fall through
1974       case Bytecodes::_f2l: // fall through
1975       case Bytecodes::_f2d: tos_in = ftos; break;
1976       case Bytecodes::_d2i: // fall through
1977       case Bytecodes::_d2l: // fall through
1978       case Bytecodes::_d2f: tos_in = dtos; break;
1979       default             : ShouldNotReachHere();
1980     }
1981     switch (bytecode()) {
1982       case Bytecodes::_l2i: // fall through
1983       case Bytecodes::_f2i: // fall through
1984       case Bytecodes::_d2i: // fall through
1985       case Bytecodes::_i2b: // fall through
1986       case Bytecodes::_i2c: // fall through
1987       case Bytecodes::_i2s: tos_out = itos; break;
1988       case Bytecodes::_i2l: // fall through
1989       case Bytecodes::_f2l: // fall through
1990       case Bytecodes::_d2l: tos_out = ltos; break;
1991       case Bytecodes::_i2f: // fall through
1992       case Bytecodes::_l2f: // fall through
1993       case Bytecodes::_d2f: tos_out = ftos; break;
1994       case Bytecodes::_i2d: // fall through
1995       case Bytecodes::_l2d: // fall through
1996       case Bytecodes::_f2d: tos_out = dtos; break;
1997       default             : ShouldNotReachHere();
1998     }
1999     transition(tos_in, tos_out);
2000   }
2001 #endif // ASSERT
2002 
2003   // Conversion
2004   // (Note: use push(rcx)/pop(rcx) for 1/2-word stack-ptr manipulation)
2005   switch (bytecode()) {
2006     case Bytecodes::_i2l:
2007       __ extend_sign(rdx, rax);
2008       break;
2009     case Bytecodes::_i2f:
2010       if (UseSSE &gt;= 1) {
2011         __ cvtsi2ssl(xmm0, rax);
2012       } else {
2013         __ push(rax);          // store int on tos
2014         __ fild_s(at_rsp());   // load int to ST0
2015         __ f2ieee();           // truncate to float size
2016         __ pop(rcx);           // adjust rsp
2017       }
2018       break;
2019     case Bytecodes::_i2d:
2020       if (UseSSE &gt;= 2) {
2021         __ cvtsi2sdl(xmm0, rax);
2022       } else {
2023       __ push(rax);          // add one slot for d2ieee()
2024       __ push(rax);          // store int on tos
2025       __ fild_s(at_rsp());   // load int to ST0
2026       __ d2ieee();           // truncate to double size
2027       __ pop(rcx);           // adjust rsp
2028       __ pop(rcx);
2029       }
2030       break;
2031     case Bytecodes::_i2b:
2032       __ shll(rax, 24);      // truncate upper 24 bits
2033       __ sarl(rax, 24);      // and sign-extend byte
2034       LP64_ONLY(__ movsbl(rax, rax));
2035       break;
2036     case Bytecodes::_i2c:
2037       __ andl(rax, 0xFFFF);  // truncate upper 16 bits
2038       LP64_ONLY(__ movzwl(rax, rax));
2039       break;
2040     case Bytecodes::_i2s:
2041       __ shll(rax, 16);      // truncate upper 16 bits
2042       __ sarl(rax, 16);      // and sign-extend short
2043       LP64_ONLY(__ movswl(rax, rax));
2044       break;
2045     case Bytecodes::_l2i:
2046       /* nothing to do */
2047       break;
2048     case Bytecodes::_l2f:
2049       // On 64-bit platforms, the cvtsi2ssq instruction is used to convert
2050       // 64-bit long values to floats. On 32-bit platforms it is not possible
2051       // to use that instruction with 64-bit operands, therefore the FPU is
2052       // used to perform the conversion.
2053       __ push(rdx);          // store long on tos
2054       __ push(rax);
2055       __ fild_d(at_rsp());   // load long to ST0
2056       __ f2ieee();           // truncate to float size
2057       __ pop(rcx);           // adjust rsp
2058       __ pop(rcx);
2059       if (UseSSE &gt;= 1) {
2060         __ push_f();
2061         __ pop_f(xmm0);
2062       }
2063       break;
2064     case Bytecodes::_l2d:
2065       // On 32-bit platforms the FPU is used for conversion because on
2066       // 32-bit platforms it is not not possible to use the cvtsi2sdq
2067       // instruction with 64-bit operands.
2068       __ push(rdx);          // store long on tos
2069       __ push(rax);
2070       __ fild_d(at_rsp());   // load long to ST0
2071       __ d2ieee();           // truncate to double size
2072       __ pop(rcx);           // adjust rsp
2073       __ pop(rcx);
2074       if (UseSSE &gt;= 2) {
2075         __ push_d();
2076         __ pop_d(xmm0);
2077       }
2078       break;
2079     case Bytecodes::_f2i:
2080       // SharedRuntime::f2i does not differentiate between sNaNs and qNaNs
2081       // as it returns 0 for any NaN.
2082       if (UseSSE &gt;= 1) {
2083         __ push_f(xmm0);
2084       } else {
2085         __ push(rcx);          // reserve space for argument
2086         __ fstp_s(at_rsp());   // pass float argument on stack
2087       }
2088       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i), 1);
2089       break;
2090     case Bytecodes::_f2l:
2091       // SharedRuntime::f2l does not differentiate between sNaNs and qNaNs
2092       // as it returns 0 for any NaN.
2093       if (UseSSE &gt;= 1) {
2094        __ push_f(xmm0);
2095       } else {
2096         __ push(rcx);          // reserve space for argument
2097         __ fstp_s(at_rsp());   // pass float argument on stack
2098       }
2099       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l), 1);
2100       break;
2101     case Bytecodes::_f2d:
2102       if (UseSSE &lt; 1) {
2103         /* nothing to do */
2104       } else if (UseSSE == 1) {
2105         __ push_f(xmm0);
2106         __ pop_f();
2107       } else { // UseSSE &gt;= 2
2108         __ cvtss2sd(xmm0, xmm0);
2109       }
2110       break;
2111     case Bytecodes::_d2i:
2112       if (UseSSE &gt;= 2) {
2113         __ push_d(xmm0);
2114       } else {
2115         __ push(rcx);          // reserve space for argument
2116         __ push(rcx);
2117         __ fstp_d(at_rsp());   // pass double argument on stack
2118       }
2119       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i), 2);
2120       break;
2121     case Bytecodes::_d2l:
2122       if (UseSSE &gt;= 2) {
2123         __ push_d(xmm0);
2124       } else {
2125         __ push(rcx);          // reserve space for argument
2126         __ push(rcx);
2127         __ fstp_d(at_rsp());   // pass double argument on stack
2128       }
2129       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l), 2);
2130       break;
2131     case Bytecodes::_d2f:
2132       if (UseSSE &lt;= 1) {
2133         __ push(rcx);          // reserve space for f2ieee()
2134         __ f2ieee();           // truncate to float size
2135         __ pop(rcx);           // adjust rsp
2136         if (UseSSE == 1) {
2137           // The cvtsd2ss instruction is not available if UseSSE==1, therefore
2138           // the conversion is performed using the FPU in this case.
2139           __ push_f();
2140           __ pop_f(xmm0);
2141         }
2142       } else { // UseSSE &gt;= 2
2143         __ cvtsd2ss(xmm0, xmm0);
2144       }
2145       break;
2146     default             :
2147       ShouldNotReachHere();
2148   }
2149 #endif
2150 }
2151 
2152 void TemplateTable::lcmp() {
2153   transition(ltos, itos);
2154 #ifdef _LP64
2155   Label done;
2156   __ pop_l(rdx);
2157   __ cmpq(rdx, rax);
2158   __ movl(rax, -1);
2159   __ jccb(Assembler::less, done);
2160   __ setb(Assembler::notEqual, rax);
2161   __ movzbl(rax, rax);
2162   __ bind(done);
2163 #else
2164 
2165   // y = rdx:rax
2166   __ pop_l(rbx, rcx);             // get x = rcx:rbx
2167   __ lcmp2int(rcx, rbx, rdx, rax);// rcx := cmp(x, y)
2168   __ mov(rax, rcx);
2169 #endif
2170 }
2171 
2172 void TemplateTable::float_cmp(bool is_float, int unordered_result) {
2173   if ((is_float &amp;&amp; UseSSE &gt;= 1) ||
2174       (!is_float &amp;&amp; UseSSE &gt;= 2)) {
2175     Label done;
2176     if (is_float) {
2177       // XXX get rid of pop here, use ... reg, mem32
2178       __ pop_f(xmm1);
2179       __ ucomiss(xmm1, xmm0);
2180     } else {
2181       // XXX get rid of pop here, use ... reg, mem64
2182       __ pop_d(xmm1);
2183       __ ucomisd(xmm1, xmm0);
2184     }
2185     if (unordered_result &lt; 0) {
2186       __ movl(rax, -1);
2187       __ jccb(Assembler::parity, done);
2188       __ jccb(Assembler::below, done);
2189       __ setb(Assembler::notEqual, rdx);
2190       __ movzbl(rax, rdx);
2191     } else {
2192       __ movl(rax, 1);
2193       __ jccb(Assembler::parity, done);
2194       __ jccb(Assembler::above, done);
2195       __ movl(rax, 0);
2196       __ jccb(Assembler::equal, done);
2197       __ decrementl(rax);
2198     }
2199     __ bind(done);
2200   } else {
2201 #ifdef _LP64
2202     ShouldNotReachHere();
2203 #else
2204     if (is_float) {
2205       __ fld_s(at_rsp());
2206     } else {
2207       __ fld_d(at_rsp());
2208       __ pop(rdx);
2209     }
2210     __ pop(rcx);
2211     __ fcmp2int(rax, unordered_result &lt; 0);
2212 #endif // _LP64
2213   }
2214 }
2215 
2216 void TemplateTable::branch(bool is_jsr, bool is_wide) {
2217   __ get_method(rcx); // rcx holds method
2218   __ profile_taken_branch(rax, rbx); // rax holds updated MDP, rbx
2219                                      // holds bumped taken count
2220 
2221   const ByteSize be_offset = MethodCounters::backedge_counter_offset() +
2222                              InvocationCounter::counter_offset();
2223   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() +
2224                               InvocationCounter::counter_offset();
2225 
2226   // Load up edx with the branch displacement
2227   if (is_wide) {
2228     __ movl(rdx, at_bcp(1));
2229   } else {
2230     __ load_signed_short(rdx, at_bcp(1));
2231   }
2232   __ bswapl(rdx);
2233 
2234   if (!is_wide) {
2235     __ sarl(rdx, 16);
2236   }
2237   LP64_ONLY(__ movl2ptr(rdx, rdx));
2238 
2239   // Handle all the JSR stuff here, then exit.
2240   // It&#39;s much shorter and cleaner than intermingling with the non-JSR
2241   // normal-branch stuff occurring below.
2242   if (is_jsr) {
2243     // Pre-load the next target bytecode into rbx
2244     __ load_unsigned_byte(rbx, Address(rbcp, rdx, Address::times_1, 0));
2245 
2246     // compute return address as bci in rax
2247     __ lea(rax, at_bcp((is_wide ? 5 : 3) -
2248                         in_bytes(ConstMethod::codes_offset())));
2249     __ subptr(rax, Address(rcx, Method::const_offset()));
2250     // Adjust the bcp in r13 by the displacement in rdx
2251     __ addptr(rbcp, rdx);
2252     // jsr returns atos that is not an oop
2253     __ push_i(rax);
2254     __ dispatch_only(vtos, true);
2255     return;
2256   }
2257 
2258   // Normal (non-jsr) branch handling
2259 
2260   // Adjust the bcp in r13 by the displacement in rdx
2261   __ addptr(rbcp, rdx);
2262 
2263   assert(UseLoopCounter || !UseOnStackReplacement,
2264          &quot;on-stack-replacement requires loop counters&quot;);
2265   Label backedge_counter_overflow;
2266   Label profile_method;
2267   Label dispatch;
2268   if (UseLoopCounter) {
2269     // increment backedge counter for backward branches
2270     // rax: MDO
2271     // rbx: MDO bumped taken-count
2272     // rcx: method
2273     // rdx: target offset
2274     // r13: target bcp
2275     // r14: locals pointer
2276     __ testl(rdx, rdx);             // check if forward or backward branch
2277     __ jcc(Assembler::positive, dispatch); // count only if backward branch
2278 
2279     // check if MethodCounters exists
2280     Label has_counters;
2281     __ movptr(rax, Address(rcx, Method::method_counters_offset()));
2282     __ testptr(rax, rax);
2283     __ jcc(Assembler::notZero, has_counters);
2284     __ push(rdx);
2285     __ push(rcx);
2286     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::build_method_counters),
2287                rcx);
2288     __ pop(rcx);
2289     __ pop(rdx);
2290     __ movptr(rax, Address(rcx, Method::method_counters_offset()));
2291     __ testptr(rax, rax);
2292     __ jcc(Assembler::zero, dispatch);
2293     __ bind(has_counters);
2294 
2295     if (TieredCompilation) {
2296       Label no_mdo;
2297       int increment = InvocationCounter::count_increment;
2298       if (ProfileInterpreter) {
2299         // Are we profiling?
2300         __ movptr(rbx, Address(rcx, in_bytes(Method::method_data_offset())));
2301         __ testptr(rbx, rbx);
2302         __ jccb(Assembler::zero, no_mdo);
2303         // Increment the MDO backedge counter
2304         const Address mdo_backedge_counter(rbx, in_bytes(MethodData::backedge_counter_offset()) +
2305                                            in_bytes(InvocationCounter::counter_offset()));
2306         const Address mask(rbx, in_bytes(MethodData::backedge_mask_offset()));
2307         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask, rax, false, Assembler::zero,
2308                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
2309         __ jmp(dispatch);
2310       }
2311       __ bind(no_mdo);
2312       // Increment backedge counter in MethodCounters*
2313       __ movptr(rcx, Address(rcx, Method::method_counters_offset()));
2314       const Address mask(rcx, in_bytes(MethodCounters::backedge_mask_offset()));
2315       __ increment_mask_and_jump(Address(rcx, be_offset), increment, mask,
2316                                  rax, false, Assembler::zero,
2317                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
2318     } else { // not TieredCompilation
2319       // increment counter
2320       __ movptr(rcx, Address(rcx, Method::method_counters_offset()));
2321       __ movl(rax, Address(rcx, be_offset));        // load backedge counter
2322       __ incrementl(rax, InvocationCounter::count_increment); // increment counter
2323       __ movl(Address(rcx, be_offset), rax);        // store counter
2324 
2325       __ movl(rax, Address(rcx, inv_offset));    // load invocation counter
2326 
2327       __ andl(rax, InvocationCounter::count_mask_value); // and the status bits
2328       __ addl(rax, Address(rcx, be_offset));        // add both counters
2329 
2330       if (ProfileInterpreter) {
2331         // Test to see if we should create a method data oop
2332         __ cmp32(rax, Address(rcx, in_bytes(MethodCounters::interpreter_profile_limit_offset())));
2333         __ jcc(Assembler::less, dispatch);
2334 
2335         // if no method data exists, go to profile method
2336         __ test_method_data_pointer(rax, profile_method);
2337 
2338         if (UseOnStackReplacement) {
2339           // check for overflow against rbx which is the MDO taken count
2340           __ cmp32(rbx, Address(rcx, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
2341           __ jcc(Assembler::below, dispatch);
2342 
2343           // When ProfileInterpreter is on, the backedge_count comes
2344           // from the MethodData*, which value does not get reset on
2345           // the call to frequency_counter_overflow().  To avoid
2346           // excessive calls to the overflow routine while the method is
2347           // being compiled, add a second test to make sure the overflow
2348           // function is called only once every overflow_frequency.
2349           const int overflow_frequency = 1024;
2350           __ andl(rbx, overflow_frequency - 1);
2351           __ jcc(Assembler::zero, backedge_counter_overflow);
2352 
2353         }
2354       } else {
2355         if (UseOnStackReplacement) {
2356           // check for overflow against rax, which is the sum of the
2357           // counters
2358           __ cmp32(rax, Address(rcx, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
2359           __ jcc(Assembler::aboveEqual, backedge_counter_overflow);
2360 
2361         }
2362       }
2363     }
2364     __ bind(dispatch);
2365   }
2366 
2367   // Pre-load the next target bytecode into rbx
2368   __ load_unsigned_byte(rbx, Address(rbcp, 0));
2369 
2370   // continue with the bytecode @ target
2371   // rax: return bci for jsr&#39;s, unused otherwise
2372   // rbx: target bytecode
2373   // r13: target bcp
2374   __ dispatch_only(vtos, true);
2375 
2376   if (UseLoopCounter) {
2377     if (ProfileInterpreter) {
2378       // Out-of-line code to allocate method data oop.
2379       __ bind(profile_method);
2380       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
2381       __ set_method_data_pointer_for_bcp();
2382       __ jmp(dispatch);
2383     }
2384 
2385     if (UseOnStackReplacement) {
2386       // invocation counter overflow
2387       __ bind(backedge_counter_overflow);
2388       __ negptr(rdx);
2389       __ addptr(rdx, rbcp); // branch bcp
2390       // IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)
2391       __ call_VM(noreg,
2392                  CAST_FROM_FN_PTR(address,
2393                                   InterpreterRuntime::frequency_counter_overflow),
2394                  rdx);
2395 
2396       // rax: osr nmethod (osr ok) or NULL (osr not possible)
2397       // rdx: scratch
2398       // r14: locals pointer
2399       // r13: bcp
2400       __ testptr(rax, rax);                        // test result
2401       __ jcc(Assembler::zero, dispatch);         // no osr if null
2402       // nmethod may have been invalidated (VM may block upon call_VM return)
2403       __ cmpb(Address(rax, nmethod::state_offset()), nmethod::in_use);
2404       __ jcc(Assembler::notEqual, dispatch);
2405 
2406       // We have the address of an on stack replacement routine in rax.
2407       // In preparation of invoking it, first we must migrate the locals
2408       // and monitors from off the interpreter frame on the stack.
2409       // Ensure to save the osr nmethod over the migration call,
2410       // it will be preserved in rbx.
2411       __ mov(rbx, rax);
2412 
2413       NOT_LP64(__ get_thread(rcx));
2414 
2415       call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
2416 
2417       // rax is OSR buffer, move it to expected parameter location
2418       LP64_ONLY(__ mov(j_rarg0, rax));
2419       NOT_LP64(__ mov(rcx, rax));
2420       // We use j_rarg definitions here so that registers don&#39;t conflict as parameter
2421       // registers change across platforms as we are in the midst of a calling
2422       // sequence to the OSR nmethod and we don&#39;t want collision. These are NOT parameters.
2423 
2424       const Register retaddr   = LP64_ONLY(j_rarg2) NOT_LP64(rdi);
2425       const Register sender_sp = LP64_ONLY(j_rarg1) NOT_LP64(rdx);
2426 
2427       // pop the interpreter frame
2428       __ movptr(sender_sp, Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize)); // get sender sp
2429       __ leave();                                // remove frame anchor
2430       __ pop(retaddr);                           // get return address
2431       __ mov(rsp, sender_sp);                   // set sp to sender sp
2432       // Ensure compiled code always sees stack at proper alignment
2433       __ andptr(rsp, -(StackAlignmentInBytes));
2434 
2435       // unlike x86 we need no specialized return from compiled code
2436       // to the interpreter or the call stub.
2437 
2438       // push the return address
2439       __ push(retaddr);
2440 
2441       // and begin the OSR nmethod
2442       __ jmp(Address(rbx, nmethod::osr_entry_point_offset()));
2443     }
2444   }
2445 }
2446 
2447 void TemplateTable::if_0cmp(Condition cc) {
2448   transition(itos, vtos);
2449   // assume branch is more often taken than not (loops use backward branches)
2450   Label not_taken;
2451   __ testl(rax, rax);
2452   __ jcc(j_not(cc), not_taken);
2453   branch(false, false);
2454   __ bind(not_taken);
2455   __ profile_not_taken_branch(rax);
2456 }
2457 
2458 void TemplateTable::if_icmp(Condition cc) {
2459   transition(itos, vtos);
2460   // assume branch is more often taken than not (loops use backward branches)
2461   Label not_taken;
2462   __ pop_i(rdx);
2463   __ cmpl(rdx, rax);
2464   __ jcc(j_not(cc), not_taken);
2465   branch(false, false);
2466   __ bind(not_taken);
2467   __ profile_not_taken_branch(rax);
2468 }
2469 
2470 void TemplateTable::if_nullcmp(Condition cc) {
2471   transition(atos, vtos);
2472   // assume branch is more often taken than not (loops use backward branches)
2473   Label not_taken;
2474   __ testptr(rax, rax);
2475   __ jcc(j_not(cc), not_taken);
2476   branch(false, false);
2477   __ bind(not_taken);
2478   __ profile_not_taken_branch(rax);
2479 }
2480 
2481 void TemplateTable::if_acmp(Condition cc) {
2482   transition(atos, vtos);
2483   // assume branch is more often taken than not (loops use backward branches)
2484   Label taken, not_taken;
2485   __ pop_ptr(rdx);
2486 
2487   const int is_value_mask = markWord::always_locked_pattern;
2488   if (EnableValhalla) {
2489     __ cmpoop(rdx, rax);
2490     __ jcc(Assembler::equal, (cc == equal) ? taken : not_taken);
2491 
2492     // might be substitutable, test if either rax or rdx is null
2493     __ movptr(rbx, rdx);
2494     __ andptr(rbx, rax);
2495     __ testptr(rbx, rbx);
2496     __ jcc(Assembler::zero, (cc == equal) ? not_taken : taken);
2497 
2498     // and both are values ?
2499     __ movptr(rbx, Address(rdx, oopDesc::mark_offset_in_bytes()));
2500     __ andptr(rbx, is_value_mask);
2501     __ movptr(rcx, Address(rax, oopDesc::mark_offset_in_bytes()));
2502     __ andptr(rbx, is_value_mask);
2503     __ andptr(rbx, rcx);
2504     __ cmpl(rbx, is_value_mask);
2505     __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);
2506 
2507     // same value klass ?
2508     __ load_metadata(rbx, rdx);
2509     __ load_metadata(rcx, rax);
2510     __ cmpptr(rbx, rcx);
2511     __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);
2512 
2513     // Know both are the same type, let&#39;s test for substitutability...
2514     if (cc == equal) {
2515       invoke_is_substitutable(rax, rdx, taken, not_taken);
2516     } else {
2517       invoke_is_substitutable(rax, rdx, not_taken, taken);
2518     }
2519     __ stop(&quot;Not reachable&quot;);
2520   }
2521 
2522   __ cmpoop(rdx, rax);
2523   __ jcc(j_not(cc), not_taken);
2524   __ bind(taken);
2525   branch(false, false);
2526   __ bind(not_taken);
2527   __ profile_not_taken_branch(rax);
2528 }
2529 
2530 void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,
2531                                             Label&amp; is_subst, Label&amp; not_subst) {
2532   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);
2533   // Restored...rax answer, jmp to outcome...
2534   __ testl(rax, rax);
2535   __ jcc(Assembler::zero, not_subst);
2536   __ jmp(is_subst);
2537 }
2538 
2539 void TemplateTable::ret() {
2540   transition(vtos, vtos);
2541   locals_index(rbx);
2542   LP64_ONLY(__ movslq(rbx, iaddress(rbx))); // get return bci, compute return bcp
2543   NOT_LP64(__ movptr(rbx, iaddress(rbx)));
2544   __ profile_ret(rbx, rcx);
2545   __ get_method(rax);
2546   __ movptr(rbcp, Address(rax, Method::const_offset()));
2547   __ lea(rbcp, Address(rbcp, rbx, Address::times_1,
2548                       ConstMethod::codes_offset()));
2549   __ dispatch_next(vtos, 0, true);
2550 }
2551 
2552 void TemplateTable::wide_ret() {
2553   transition(vtos, vtos);
2554   locals_index_wide(rbx);
2555   __ movptr(rbx, aaddress(rbx)); // get return bci, compute return bcp
2556   __ profile_ret(rbx, rcx);
2557   __ get_method(rax);
2558   __ movptr(rbcp, Address(rax, Method::const_offset()));
2559   __ lea(rbcp, Address(rbcp, rbx, Address::times_1, ConstMethod::codes_offset()));
2560   __ dispatch_next(vtos, 0, true);
2561 }
2562 
2563 void TemplateTable::tableswitch() {
2564   Label default_case, continue_execution;
2565   transition(itos, vtos);
2566 
2567   // align r13/rsi
2568   __ lea(rbx, at_bcp(BytesPerInt));
2569   __ andptr(rbx, -BytesPerInt);
2570   // load lo &amp; hi
2571   __ movl(rcx, Address(rbx, BytesPerInt));
2572   __ movl(rdx, Address(rbx, 2 * BytesPerInt));
2573   __ bswapl(rcx);
2574   __ bswapl(rdx);
2575   // check against lo &amp; hi
2576   __ cmpl(rax, rcx);
2577   __ jcc(Assembler::less, default_case);
2578   __ cmpl(rax, rdx);
2579   __ jcc(Assembler::greater, default_case);
2580   // lookup dispatch offset
2581   __ subl(rax, rcx);
2582   __ movl(rdx, Address(rbx, rax, Address::times_4, 3 * BytesPerInt));
2583   __ profile_switch_case(rax, rbx, rcx);
2584   // continue execution
2585   __ bind(continue_execution);
2586   __ bswapl(rdx);
2587   LP64_ONLY(__ movl2ptr(rdx, rdx));
2588   __ load_unsigned_byte(rbx, Address(rbcp, rdx, Address::times_1));
2589   __ addptr(rbcp, rdx);
2590   __ dispatch_only(vtos, true);
2591   // handle default
2592   __ bind(default_case);
2593   __ profile_switch_default(rax);
2594   __ movl(rdx, Address(rbx, 0));
2595   __ jmp(continue_execution);
2596 }
2597 
2598 void TemplateTable::lookupswitch() {
2599   transition(itos, itos);
2600   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2601 }
2602 
2603 void TemplateTable::fast_linearswitch() {
2604   transition(itos, vtos);
2605   Label loop_entry, loop, found, continue_execution;
2606   // bswap rax so we can avoid bswapping the table entries
2607   __ bswapl(rax);
2608   // align r13
2609   __ lea(rbx, at_bcp(BytesPerInt)); // btw: should be able to get rid of
2610                                     // this instruction (change offsets
2611                                     // below)
2612   __ andptr(rbx, -BytesPerInt);
2613   // set counter
2614   __ movl(rcx, Address(rbx, BytesPerInt));
2615   __ bswapl(rcx);
2616   __ jmpb(loop_entry);
2617   // table search
2618   __ bind(loop);
2619   __ cmpl(rax, Address(rbx, rcx, Address::times_8, 2 * BytesPerInt));
2620   __ jcc(Assembler::equal, found);
2621   __ bind(loop_entry);
2622   __ decrementl(rcx);
2623   __ jcc(Assembler::greaterEqual, loop);
2624   // default case
2625   __ profile_switch_default(rax);
2626   __ movl(rdx, Address(rbx, 0));
2627   __ jmp(continue_execution);
2628   // entry found -&gt; get offset
2629   __ bind(found);
2630   __ movl(rdx, Address(rbx, rcx, Address::times_8, 3 * BytesPerInt));
2631   __ profile_switch_case(rcx, rax, rbx);
2632   // continue execution
2633   __ bind(continue_execution);
2634   __ bswapl(rdx);
2635   __ movl2ptr(rdx, rdx);
2636   __ load_unsigned_byte(rbx, Address(rbcp, rdx, Address::times_1));
2637   __ addptr(rbcp, rdx);
2638   __ dispatch_only(vtos, true);
2639 }
2640 
2641 void TemplateTable::fast_binaryswitch() {
2642   transition(itos, vtos);
2643   // Implementation using the following core algorithm:
2644   //
2645   // int binary_search(int key, LookupswitchPair* array, int n) {
2646   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2647   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2648   //   int i = 0;
2649   //   int j = n;
2650   //   while (i+1 &lt; j) {
2651   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2652   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2653   //     // where a stands for the array and assuming that the (inexisting)
2654   //     // element a[n] is infinitely big.
2655   //     int h = (i + j) &gt;&gt; 1;
2656   //     // i &lt; h &lt; j
2657   //     if (key &lt; array[h].fast_match()) {
2658   //       j = h;
2659   //     } else {
2660   //       i = h;
2661   //     }
2662   //   }
2663   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2664   //   // (i.e., if key is within array, i is the correct index)
2665   //   return i;
2666   // }
2667 
2668   // Register allocation
2669   const Register key   = rax; // already set (tosca)
2670   const Register array = rbx;
2671   const Register i     = rcx;
2672   const Register j     = rdx;
2673   const Register h     = rdi;
2674   const Register temp  = rsi;
2675 
2676   // Find array start
2677   NOT_LP64(__ save_bcp());
2678 
2679   __ lea(array, at_bcp(3 * BytesPerInt)); // btw: should be able to
2680                                           // get rid of this
2681                                           // instruction (change
2682                                           // offsets below)
2683   __ andptr(array, -BytesPerInt);
2684 
2685   // Initialize i &amp; j
2686   __ xorl(i, i);                            // i = 0;
2687   __ movl(j, Address(array, -BytesPerInt)); // j = length(array);
2688 
2689   // Convert j into native byteordering
2690   __ bswapl(j);
2691 
2692   // And start
2693   Label entry;
2694   __ jmp(entry);
2695 
2696   // binary search loop
2697   {
2698     Label loop;
2699     __ bind(loop);
2700     // int h = (i + j) &gt;&gt; 1;
2701     __ leal(h, Address(i, j, Address::times_1)); // h = i + j;
2702     __ sarl(h, 1);                               // h = (i + j) &gt;&gt; 1;
2703     // if (key &lt; array[h].fast_match()) {
2704     //   j = h;
2705     // } else {
2706     //   i = h;
2707     // }
2708     // Convert array[h].match to native byte-ordering before compare
2709     __ movl(temp, Address(array, h, Address::times_8));
2710     __ bswapl(temp);
2711     __ cmpl(key, temp);
2712     // j = h if (key &lt;  array[h].fast_match())
2713     __ cmov32(Assembler::less, j, h);
2714     // i = h if (key &gt;= array[h].fast_match())
2715     __ cmov32(Assembler::greaterEqual, i, h);
2716     // while (i+1 &lt; j)
2717     __ bind(entry);
2718     __ leal(h, Address(i, 1)); // i+1
2719     __ cmpl(h, j);             // i+1 &lt; j
2720     __ jcc(Assembler::less, loop);
2721   }
2722 
2723   // end of binary search, result index is i (must check again!)
2724   Label default_case;
2725   // Convert array[i].match to native byte-ordering before compare
2726   __ movl(temp, Address(array, i, Address::times_8));
2727   __ bswapl(temp);
2728   __ cmpl(key, temp);
2729   __ jcc(Assembler::notEqual, default_case);
2730 
2731   // entry found -&gt; j = offset
2732   __ movl(j , Address(array, i, Address::times_8, BytesPerInt));
2733   __ profile_switch_case(i, key, array);
2734   __ bswapl(j);
2735   LP64_ONLY(__ movslq(j, j));
2736 
2737   NOT_LP64(__ restore_bcp());
2738   NOT_LP64(__ restore_locals());                           // restore rdi
2739 
2740   __ load_unsigned_byte(rbx, Address(rbcp, j, Address::times_1));
2741   __ addptr(rbcp, j);
2742   __ dispatch_only(vtos, true);
2743 
2744   // default case -&gt; j = default offset
2745   __ bind(default_case);
2746   __ profile_switch_default(i);
2747   __ movl(j, Address(array, -2 * BytesPerInt));
2748   __ bswapl(j);
2749   LP64_ONLY(__ movslq(j, j));
2750 
2751   NOT_LP64(__ restore_bcp());
2752   NOT_LP64(__ restore_locals());
2753 
2754   __ load_unsigned_byte(rbx, Address(rbcp, j, Address::times_1));
2755   __ addptr(rbcp, j);
2756   __ dispatch_only(vtos, true);
2757 }
2758 
2759 void TemplateTable::_return(TosState state) {
2760   transition(state, state);
2761 
2762   assert(_desc-&gt;calls_vm(),
2763          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2764 
2765   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2766     assert(state == vtos, &quot;only valid state&quot;);
2767     Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);
2768     __ movptr(robj, aaddress(0));
<a name="5" id="anc5"></a><span class="line-modified">2769     __ load_klass(rdi, robj);</span>

2770     __ movl(rdi, Address(rdi, Klass::access_flags_offset()));
2771     __ testl(rdi, JVM_ACC_HAS_FINALIZER);
2772     Label skip_register_finalizer;
2773     __ jcc(Assembler::zero, skip_register_finalizer);
2774 
2775     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), robj);
2776 
2777     __ bind(skip_register_finalizer);
2778   }
2779 
2780   if (_desc-&gt;bytecode() != Bytecodes::_return_register_finalizer) {
2781     Label no_safepoint;
2782     NOT_PRODUCT(__ block_comment(&quot;Thread-local Safepoint poll&quot;));
2783 #ifdef _LP64
2784     __ testb(Address(r15_thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2785 #else
2786     const Register thread = rdi;
2787     __ get_thread(thread);
2788     __ testb(Address(thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2789 #endif
2790     __ jcc(Assembler::zero, no_safepoint);
2791     __ push(state);
2792     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2793                                     InterpreterRuntime::at_safepoint));
2794     __ pop(state);
2795     __ bind(no_safepoint);
2796   }
2797 
2798   // Narrow result if state is itos but result type is smaller.
2799   // Need to narrow in the return bytecode rather than in generate_return_entry
2800   // since compiled code callers expect the result to already be narrowed.
2801   if (state == itos) {
2802     __ narrow(rax);
2803   }
2804 
2805   __ remove_activation(state, rbcp, true, true, true);
2806 
2807   __ jmp(rbcp);
2808 }
2809 
2810 // ----------------------------------------------------------------------------
2811 // Volatile variables demand their effects be made known to all CPU&#39;s
2812 // in order.  Store buffers on most chips allow reads &amp; writes to
2813 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2814 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2815 // the interpreter does not reorder volatile references, the hardware
2816 // also must not reorder them).
2817 //
2818 // According to the new Java Memory Model (JMM):
2819 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2820 //     writes act as aquire &amp; release, so:
2821 // (2) A read cannot let unrelated NON-volatile memory refs that
2822 //     happen after the read float up to before the read.  It&#39;s OK for
2823 //     non-volatile memory refs that happen before the volatile read to
2824 //     float down below it.
2825 // (3) Similar a volatile write cannot let unrelated NON-volatile
2826 //     memory refs that happen BEFORE the write float down to after the
2827 //     write.  It&#39;s OK for non-volatile memory refs that happen after the
2828 //     volatile write to float up before it.
2829 //
2830 // We only put in barriers around volatile refs (they are expensive),
2831 // not _between_ memory refs (that would require us to track the
2832 // flavor of the previous memory refs).  Requirements (2) and (3)
2833 // require some barriers before volatile stores and after volatile
2834 // loads.  These nearly cover requirement (1) but miss the
2835 // volatile-store-volatile-load case.  This final case is placed after
2836 // volatile-stores although it could just as well go before
2837 // volatile-loads.
2838 
2839 void TemplateTable::volatile_barrier(Assembler::Membar_mask_bits order_constraint ) {
2840   // Helper function to insert a is-volatile test and memory barrier
2841   __ membar(order_constraint);
2842 }
2843 
2844 void TemplateTable::resolve_cache_and_index(int byte_no,
2845                                             Register cache,
2846                                             Register index,
2847                                             size_t index_size) {
2848   const Register temp = rbx;
2849   assert_different_registers(cache, index, temp);
2850 
2851   Label L_clinit_barrier_slow;
2852   Label resolved;
2853 
2854   Bytecodes::Code code = bytecode();
2855   switch (code) {
2856   case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2857   case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2858   default: break;
2859   }
2860 
2861   assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2862   __ get_cache_and_index_and_bytecode_at_bcp(cache, index, temp, byte_no, 1, index_size);
2863   __ cmpl(temp, code);  // have we resolved this bytecode?
2864   __ jcc(Assembler::equal, resolved);
2865 
2866   // resolve first time through
2867   // Class initialization barrier slow path lands here as well.
2868   __ bind(L_clinit_barrier_slow);
2869   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2870   __ movl(temp, code);
2871   __ call_VM(noreg, entry, temp);
2872   // Update registers with resolved info
2873   __ get_cache_and_index_at_bcp(cache, index, 1, index_size);
2874 
2875   __ bind(resolved);
2876 
2877   // Class initialization barrier for static methods
2878   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {
2879     const Register method = temp;
2880     const Register klass  = temp;
2881     const Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
2882     assert(thread != noreg, &quot;x86_32 not supported&quot;);
2883 
2884     __ load_resolved_method_at_index(byte_no, method, cache, index);
2885     __ load_method_holder(klass, method);
2886     __ clinit_barrier(klass, thread, NULL /*L_fast_path*/, &amp;L_clinit_barrier_slow);
2887   }
2888 }
2889 
2890 // The cache and index registers must be set before call
2891 void TemplateTable::load_field_cp_cache_entry(Register obj,
2892                                               Register cache,
2893                                               Register index,
2894                                               Register off,
2895                                               Register flags,
2896                                               bool is_static = false) {
2897   assert_different_registers(cache, index, flags, off);
2898 
2899   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2900   // Field offset
2901   __ movptr(off, Address(cache, index, Address::times_ptr,
2902                          in_bytes(cp_base_offset +
2903                                   ConstantPoolCacheEntry::f2_offset())));
2904   // Flags
2905   __ movl(flags, Address(cache, index, Address::times_ptr,
2906                          in_bytes(cp_base_offset +
2907                                   ConstantPoolCacheEntry::flags_offset())));
2908 
2909   // klass overwrite register
2910   if (is_static) {
2911     __ movptr(obj, Address(cache, index, Address::times_ptr,
2912                            in_bytes(cp_base_offset +
2913                                     ConstantPoolCacheEntry::f1_offset())));
2914     const int mirror_offset = in_bytes(Klass::java_mirror_offset());
2915     __ movptr(obj, Address(obj, mirror_offset));
2916     __ resolve_oop_handle(obj);
2917   }
2918 }
2919 
2920 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2921                                                Register method,
2922                                                Register itable_index,
2923                                                Register flags,
2924                                                bool is_invokevirtual,
2925                                                bool is_invokevfinal, /*unused*/
2926                                                bool is_invokedynamic) {
2927   // setup registers
2928   const Register cache = rcx;
2929   const Register index = rdx;
2930   assert_different_registers(method, flags);
2931   assert_different_registers(method, cache, index);
2932   assert_different_registers(itable_index, flags);
2933   assert_different_registers(itable_index, cache, index);
2934   // determine constant pool cache field offsets
2935   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2936   const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +
2937                                     ConstantPoolCacheEntry::flags_offset());
2938   // access constant pool cache fields
2939   const int index_offset = in_bytes(ConstantPoolCache::base_offset() +
2940                                     ConstantPoolCacheEntry::f2_offset());
2941 
2942   size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));
2943   resolve_cache_and_index(byte_no, cache, index, index_size);
2944   __ load_resolved_method_at_index(byte_no, method, cache, index);
2945 
2946   if (itable_index != noreg) {
2947     // pick up itable or appendix index from f2 also:
2948     __ movptr(itable_index, Address(cache, index, Address::times_ptr, index_offset));
2949   }
2950   __ movl(flags, Address(cache, index, Address::times_ptr, flags_offset));
2951 }
2952 
2953 // The registers cache and index expected to be set before call.
2954 // Correct values of the cache and index registers are preserved.
2955 void TemplateTable::jvmti_post_field_access(Register cache,
2956                                             Register index,
2957                                             bool is_static,
2958                                             bool has_tos) {
2959   if (JvmtiExport::can_post_field_access()) {
2960     // Check to see if a field access watch has been set before we take
2961     // the time to call into the VM.
2962     Label L1;
2963     assert_different_registers(cache, index, rax);
2964     __ mov32(rax, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
2965     __ testl(rax,rax);
2966     __ jcc(Assembler::zero, L1);
2967 
2968     // cache entry pointer
2969     __ addptr(cache, in_bytes(ConstantPoolCache::base_offset()));
2970     __ shll(index, LogBytesPerWord);
2971     __ addptr(cache, index);
2972     if (is_static) {
2973       __ xorptr(rax, rax);      // NULL object reference
2974     } else {
2975       __ pop(atos);         // Get the object
2976       __ verify_oop(rax);
2977       __ push(atos);        // Restore stack state
2978     }
2979     // rax,:   object pointer or NULL
2980     // cache: cache entry pointer
2981     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access),
2982                rax, cache);
2983     __ get_cache_and_index_at_bcp(cache, index, 1);
2984     __ bind(L1);
2985   }
2986 }
2987 
2988 void TemplateTable::pop_and_check_object(Register r) {
2989   __ pop_ptr(r);
2990   __ null_check(r);  // for field access must check obj.
2991   __ verify_oop(r);
2992 }
2993 
2994 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2995   transition(vtos, vtos);
2996 
2997   const Register cache = rcx;
2998   const Register index = rdx;
2999   const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3000   const Register off   = rbx;
3001   const Register flags = rax;
3002   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // uses same reg as obj, so don&#39;t mix them
3003   const Register flags2 = rdx;
3004 
3005   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3006   jvmti_post_field_access(cache, index, is_static, false);
3007   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3008 
3009   const Address field(obj, off, Address::times_1, 0*wordSize);
3010 
3011   Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj, notValueType;
3012 
3013   if (!is_static) {
3014     __ movptr(rcx, Address(cache, index, Address::times_ptr,
3015                            in_bytes(ConstantPoolCache::base_offset() +
3016                                     ConstantPoolCacheEntry::f1_offset())));
3017   }
3018 
3019   __ movl(flags2, flags);
3020 
3021   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3022   // Make sure we don&#39;t need to mask edx after the above shift
3023   assert(btos == 0, &quot;change code, btos != 0&quot;);
3024 
3025   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3026 
3027   __ jcc(Assembler::notZero, notByte);
3028   // btos
3029   if (!is_static) pop_and_check_object(obj);
3030   __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3031   __ push(btos);
3032   // Rewrite bytecode to be faster
3033   if (!is_static &amp;&amp; rc == may_rewrite) {
3034     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3035   }
3036   __ jmp(Done);
3037 
3038   __ bind(notByte);
3039 
3040   __ cmpl(flags, ztos);
3041   __ jcc(Assembler::notEqual, notBool);
3042    if (!is_static) pop_and_check_object(obj);
3043   // ztos (same code as btos)
3044   __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg, noreg);
3045   __ push(ztos);
3046   // Rewrite bytecode to be faster
3047   if (!is_static &amp;&amp; rc == may_rewrite) {
3048     // use btos rewriting, no truncating to t/f bit is needed for getfield.
3049     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3050   }
3051   __ jmp(Done);
3052 
3053   __ bind(notBool);
3054   __ cmpl(flags, atos);
3055   __ jcc(Assembler::notEqual, notObj);
3056   // atos
3057   if (!EnableValhalla) {
3058     if (!is_static) pop_and_check_object(obj);
3059     do_oop_load(_masm, field, rax);
3060     __ push(atos);
3061     if (!is_static &amp;&amp; rc == may_rewrite) {
3062       patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);
3063     }
3064     __ jmp(Done);
3065   } else {
3066     if (is_static) {
3067       __ load_heap_oop(rax, field);
3068       Label isFlattenable, uninitialized;
3069       // Issue below if the static field has not been initialized yet
3070       __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);
3071         // Not flattenable case
3072         __ push(atos);
3073         __ jmp(Done);
3074       // Flattenable case, must not return null even if uninitialized
3075       __ bind(isFlattenable);
3076         __ testptr(rax, rax);
3077         __ jcc(Assembler::zero, uninitialized);
3078           __ push(atos);
3079           __ jmp(Done);
3080         __ bind(uninitialized);
3081           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);
3082 #ifdef _LP64
3083           Label slow_case, finish;
3084           __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3085           __ jcc(Assembler::notEqual, slow_case);
3086         __ get_default_value_oop(rcx, off, rax);
3087         __ jmp(finish);
3088         __ bind(slow_case);
3089 #endif // LP64
3090           __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_value_field),
3091                  obj, flags2);
3092 #ifdef _LP64
3093           __ bind(finish);
3094 #endif // _LP64
3095           __ verify_oop(rax);
3096           __ push(atos);
3097           __ jmp(Done);
3098     } else {
3099       Label isFlattened, nonnull, isFlattenable, rewriteFlattenable;
3100       __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);
3101         // Non-flattenable field case, also covers the object case
3102         pop_and_check_object(obj);
3103         __ load_heap_oop(rax, field);
3104         __ push(atos);
3105         if (rc == may_rewrite) {
3106           patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);
3107         }
3108         __ jmp(Done);
3109       __ bind(isFlattenable);
3110         __ test_field_is_flattened(flags2, rscratch1, isFlattened);
3111           // Non-flattened field case
3112           __ movptr(rax, rcx);  // small dance required to preserve the klass_holder somewhere
3113           pop_and_check_object(obj);
3114           __ push(rax);
3115           __ load_heap_oop(rax, field);
3116           __ pop(rcx);
3117           __ testptr(rax, rax);
3118           __ jcc(Assembler::notZero, nonnull);
3119             __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);
3120             __ get_value_field_klass(rcx, flags2, rbx);
3121             __ get_default_value_oop(rbx, rcx, rax);
3122           __ bind(nonnull);
3123           __ verify_oop(rax);
3124           __ push(atos);
3125           __ jmp(rewriteFlattenable);
3126         __ bind(isFlattened);
3127           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);
3128           pop_and_check_object(rax);
3129           __ read_flattened_field(rcx, flags2, rbx, rax);
3130           __ verify_oop(rax);
3131           __ push(atos);
3132       __ bind(rewriteFlattenable);
3133       if (rc == may_rewrite) {
3134         patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);
3135       }
3136       __ jmp(Done);
3137     }
3138   }
3139 
3140   __ bind(notObj);
3141 
3142   if (!is_static) pop_and_check_object(obj);
3143 
3144   __ cmpl(flags, itos);
3145   __ jcc(Assembler::notEqual, notInt);
3146   // itos
3147   __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3148   __ push(itos);
3149   // Rewrite bytecode to be faster
3150   if (!is_static &amp;&amp; rc == may_rewrite) {
3151     patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);
3152   }
3153   __ jmp(Done);
3154 
3155   __ bind(notInt);
3156   __ cmpl(flags, ctos);
3157   __ jcc(Assembler::notEqual, notChar);
3158   // ctos
3159   __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
3160   __ push(ctos);
3161   // Rewrite bytecode to be faster
3162   if (!is_static &amp;&amp; rc == may_rewrite) {
3163     patch_bytecode(Bytecodes::_fast_cgetfield, bc, rbx);
3164   }
3165   __ jmp(Done);
3166 
3167   __ bind(notChar);
3168   __ cmpl(flags, stos);
3169   __ jcc(Assembler::notEqual, notShort);
3170   // stos
3171   __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
3172   __ push(stos);
3173   // Rewrite bytecode to be faster
3174   if (!is_static &amp;&amp; rc == may_rewrite) {
3175     patch_bytecode(Bytecodes::_fast_sgetfield, bc, rbx);
3176   }
3177   __ jmp(Done);
3178 
3179   __ bind(notShort);
3180   __ cmpl(flags, ltos);
3181   __ jcc(Assembler::notEqual, notLong);
3182   // ltos
3183     // Generate code as if volatile (x86_32).  There just aren&#39;t enough registers to
3184     // save that information and this code is faster than the test.
3185   __ access_load_at(T_LONG, IN_HEAP | MO_RELAXED, noreg /* ltos */, field, noreg, noreg);
3186   __ push(ltos);
3187   // Rewrite bytecode to be faster
3188   LP64_ONLY(if (!is_static &amp;&amp; rc == may_rewrite) patch_bytecode(Bytecodes::_fast_lgetfield, bc, rbx));
3189   __ jmp(Done);
3190 
3191   __ bind(notLong);
3192   __ cmpl(flags, ftos);
3193   __ jcc(Assembler::notEqual, notFloat);
3194   // ftos
3195 
3196   __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3197   __ push(ftos);
3198   // Rewrite bytecode to be faster
3199   if (!is_static &amp;&amp; rc == may_rewrite) {
3200     patch_bytecode(Bytecodes::_fast_fgetfield, bc, rbx);
3201   }
3202   __ jmp(Done);
3203 
3204   __ bind(notFloat);
3205 #ifdef ASSERT
3206   Label notDouble;
3207   __ cmpl(flags, dtos);
3208   __ jcc(Assembler::notEqual, notDouble);
3209 #endif
3210   // dtos
3211   // MO_RELAXED: for the case of volatile field, in fact it adds no extra work for the underlying implementation
3212   __ access_load_at(T_DOUBLE, IN_HEAP | MO_RELAXED, noreg /* dtos */, field, noreg, noreg);
3213   __ push(dtos);
3214   // Rewrite bytecode to be faster
3215   if (!is_static &amp;&amp; rc == may_rewrite) {
3216     patch_bytecode(Bytecodes::_fast_dgetfield, bc, rbx);
3217   }
3218 #ifdef ASSERT
3219   __ jmp(Done);
3220 
3221   __ bind(notDouble);
3222   __ stop(&quot;Bad state&quot;);
3223 #endif
3224 
3225   __ bind(Done);
3226   // [jk] not needed currently
3227   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadLoad |
3228   //                                              Assembler::LoadStore));
3229 }
3230 
3231 void TemplateTable::getfield(int byte_no) {
3232   getfield_or_static(byte_no, false);
3233 }
3234 
3235 void TemplateTable::nofast_getfield(int byte_no) {
3236   getfield_or_static(byte_no, false, may_not_rewrite);
3237 }
3238 
3239 void TemplateTable::getstatic(int byte_no) {
3240   getfield_or_static(byte_no, true);
3241 }
3242 
3243 void TemplateTable::withfield() {
3244   transition(vtos, atos);
3245 
3246   Register cache = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
3247   Register index = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
3248 
3249   resolve_cache_and_index(f2_byte, cache, index, sizeof(u2));
3250 
3251   call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cache);
3252   // new value type is returned in rbx
3253   // stack adjustement is returned in rax
3254   __ verify_oop(rbx);
3255   __ addptr(rsp, rax);
3256   __ movptr(rax, rbx);
3257 }
3258 
3259 // The registers cache and index expected to be set before call.
3260 // The function may destroy various registers, just not the cache and index registers.
3261 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
3262 
3263   const Register robj = LP64_ONLY(c_rarg2)   NOT_LP64(rax);
3264   const Register RBX  = LP64_ONLY(c_rarg1)   NOT_LP64(rbx);
3265   const Register RCX  = LP64_ONLY(c_rarg3)   NOT_LP64(rcx);
3266   const Register RDX  = LP64_ONLY(rscratch1) NOT_LP64(rdx);
3267 
3268   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
3269 
3270   if (JvmtiExport::can_post_field_modification()) {
3271     // Check to see if a field modification watch has been set before
3272     // we take the time to call into the VM.
3273     Label L1;
3274     assert_different_registers(cache, index, rax);
3275     __ mov32(rax, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3276     __ testl(rax, rax);
3277     __ jcc(Assembler::zero, L1);
3278 
3279     __ get_cache_and_index_at_bcp(robj, RDX, 1);
3280 
3281 
3282     if (is_static) {
3283       // Life is simple.  Null out the object pointer.
3284       __ xorl(RBX, RBX);
3285 
3286     } else {
3287       // Life is harder. The stack holds the value on top, followed by
3288       // the object.  We don&#39;t know the size of the value, though; it
3289       // could be one or two words depending on its type. As a result,
3290       // we must find the type to determine where the object is.
3291 #ifndef _LP64
3292       Label two_word, valsize_known;
3293 #endif
3294       __ movl(RCX, Address(robj, RDX,
3295                            Address::times_ptr,
3296                            in_bytes(cp_base_offset +
3297                                      ConstantPoolCacheEntry::flags_offset())));
3298       NOT_LP64(__ mov(rbx, rsp));
3299       __ shrl(RCX, ConstantPoolCacheEntry::tos_state_shift);
3300 
3301       // Make sure we don&#39;t need to mask rcx after the above shift
3302       ConstantPoolCacheEntry::verify_tos_state_shift();
3303 #ifdef _LP64
3304       __ movptr(c_rarg1, at_tos_p1());  // initially assume a one word jvalue
3305       __ cmpl(c_rarg3, ltos);
3306       __ cmovptr(Assembler::equal,
3307                  c_rarg1, at_tos_p2()); // ltos (two word jvalue)
3308       __ cmpl(c_rarg3, dtos);
3309       __ cmovptr(Assembler::equal,
3310                  c_rarg1, at_tos_p2()); // dtos (two word jvalue)
3311 #else
3312       __ cmpl(rcx, ltos);
3313       __ jccb(Assembler::equal, two_word);
3314       __ cmpl(rcx, dtos);
3315       __ jccb(Assembler::equal, two_word);
3316       __ addptr(rbx, Interpreter::expr_offset_in_bytes(1)); // one word jvalue (not ltos, dtos)
3317       __ jmpb(valsize_known);
3318 
3319       __ bind(two_word);
3320       __ addptr(rbx, Interpreter::expr_offset_in_bytes(2)); // two words jvalue
3321 
3322       __ bind(valsize_known);
3323       // setup object pointer
3324       __ movptr(rbx, Address(rbx, 0));
3325 #endif
3326     }
3327     // cache entry pointer
3328     __ addptr(robj, in_bytes(cp_base_offset));
3329     __ shll(RDX, LogBytesPerWord);
3330     __ addptr(robj, RDX);
3331     // object (tos)
3332     __ mov(RCX, rsp);
3333     // c_rarg1: object pointer set up above (NULL if static)
3334     // c_rarg2: cache entry pointer
3335     // c_rarg3: jvalue object on the stack
3336     __ call_VM(noreg,
3337                CAST_FROM_FN_PTR(address,
3338                                 InterpreterRuntime::post_field_modification),
3339                RBX, robj, RCX);
3340     __ get_cache_and_index_at_bcp(cache, index, 1);
3341     __ bind(L1);
3342   }
3343 }
3344 
3345 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
3346   transition(vtos, vtos);
3347 
3348   const Register cache = rcx;
3349   const Register index = rdx;
3350   const Register obj   = rcx;
3351   const Register off   = rbx;
3352   const Register flags = rax;
3353   const Register flags2 = rdx;
3354 
3355   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3356   jvmti_post_field_mod(cache, index, is_static);
3357   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3358 
3359   // [jk] not needed currently
3360   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3361   //                                              Assembler::StoreStore));
3362 
3363   Label notVolatile, Done;
3364   __ movl(rdx, flags);
3365   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3366   __ andl(rdx, 0x1);
3367 
3368   // Check for volatile store
3369   __ testl(rdx, rdx);
3370   __ movl(flags2, flags);
3371   __ jcc(Assembler::zero, notVolatile);
3372 
3373   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);
3374   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3375                                                Assembler::StoreStore));
3376   __ jmp(Done);
3377   __ bind(notVolatile);
3378 
3379   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);
3380 
3381   __ bind(Done);
3382 }
3383 
3384 void TemplateTable::putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
3385                                               Register obj, Register off, Register flags, Register flags2) {
3386 
3387   // field addresses
3388   const Address field(obj, off, Address::times_1, 0*wordSize);
3389   NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)
3390 
3391   Label notByte, notBool, notInt, notShort, notChar,
3392         notLong, notFloat, notObj, notValueType;
3393   Label Done;
3394 
3395   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3396 
3397   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3398 
3399   assert(btos == 0, &quot;change code, btos != 0&quot;);
3400   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3401   __ jcc(Assembler::notZero, notByte);
3402 
3403   // btos
3404   {
3405     __ pop(btos);
3406     if (!is_static) pop_and_check_object(obj);
3407     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3408     if (!is_static &amp;&amp; rc == may_rewrite) {
3409       patch_bytecode(Bytecodes::_fast_bputfield, bc, rbx, true, byte_no);
3410     }
3411     __ jmp(Done);
3412   }
3413 
3414   __ bind(notByte);
3415   __ cmpl(flags, ztos);
3416   __ jcc(Assembler::notEqual, notBool);
3417 
3418   // ztos
3419   {
3420     __ pop(ztos);
3421     if (!is_static) pop_and_check_object(obj);
3422     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3423     if (!is_static &amp;&amp; rc == may_rewrite) {
3424       patch_bytecode(Bytecodes::_fast_zputfield, bc, rbx, true, byte_no);
3425     }
3426     __ jmp(Done);
3427   }
3428 
3429   __ bind(notBool);
3430   __ cmpl(flags, atos);
3431   __ jcc(Assembler::notEqual, notObj);
3432 
3433   // atos
3434   {
3435     if (!EnableValhalla) {
3436       __ pop(atos);
3437       if (!is_static) pop_and_check_object(obj);
3438       // Store into the field
3439       do_oop_store(_masm, field, rax);
3440       if (!is_static &amp;&amp; rc == may_rewrite) {
3441         patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);
3442       }
3443       __ jmp(Done);
3444     } else {
3445       __ pop(atos);
3446       if (is_static) {
3447         Label notFlattenable, notBuffered;
3448         __ test_field_is_not_flattenable(flags2, rscratch1, notFlattenable);
3449         __ null_check(rax);
3450         __ bind(notFlattenable);
3451         do_oop_store(_masm, field, rax);
3452         __ jmp(Done);
3453       } else {
3454         Label isFlattenable, isFlattened, notBuffered, notBuffered2, rewriteNotFlattenable, rewriteFlattenable;
3455         __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);
3456         // Not flattenable case, covers not flattenable values and objects
3457         pop_and_check_object(obj);
3458         // Store into the field
3459         do_oop_store(_masm, field, rax);
3460         __ bind(rewriteNotFlattenable);
3461         if (rc == may_rewrite) {
3462           patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);
3463         }
3464         __ jmp(Done);
3465         // Implementation of the flattenable semantic
3466         __ bind(isFlattenable);
3467         __ null_check(rax);
3468         __ test_field_is_flattened(flags2, rscratch1, isFlattened);
3469         // Not flattened case
3470         pop_and_check_object(obj);
3471         // Store into the field
3472         do_oop_store(_masm, field, rax);
3473         __ jmp(rewriteFlattenable);
3474         __ bind(isFlattened);
3475         pop_and_check_object(obj);
3476         assert_different_registers(rax, rdx, obj, off);
<a name="6" id="anc6"></a><span class="line-modified">3477         __ load_klass(rdx, rax);</span>
3478         __ data_for_oop(rax, rax, rdx);
3479         __ addptr(obj, off);
3480         __ access_value_copy(IN_HEAP, rax, obj, rdx);
3481         __ bind(rewriteFlattenable);
3482         if (rc == may_rewrite) {
3483           patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);
3484         }
3485         __ jmp(Done);
3486       }
3487     }
3488   }
3489 
3490   __ bind(notObj);
3491   __ cmpl(flags, itos);
3492   __ jcc(Assembler::notEqual, notInt);
3493 
3494   // itos
3495   {
3496     __ pop(itos);
3497     if (!is_static) pop_and_check_object(obj);
3498     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3499     if (!is_static &amp;&amp; rc == may_rewrite) {
3500       patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, true, byte_no);
3501     }
3502     __ jmp(Done);
3503   }
3504 
3505   __ bind(notInt);
3506   __ cmpl(flags, ctos);
3507   __ jcc(Assembler::notEqual, notChar);
3508 
3509   // ctos
3510   {
3511     __ pop(ctos);
3512     if (!is_static) pop_and_check_object(obj);
3513     __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg);
3514     if (!is_static &amp;&amp; rc == may_rewrite) {
3515       patch_bytecode(Bytecodes::_fast_cputfield, bc, rbx, true, byte_no);
3516     }
3517     __ jmp(Done);
3518   }
3519 
3520   __ bind(notChar);
3521   __ cmpl(flags, stos);
3522   __ jcc(Assembler::notEqual, notShort);
3523 
3524   // stos
3525   {
3526     __ pop(stos);
3527     if (!is_static) pop_and_check_object(obj);
3528     __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
3529     if (!is_static &amp;&amp; rc == may_rewrite) {
3530       patch_bytecode(Bytecodes::_fast_sputfield, bc, rbx, true, byte_no);
3531     }
3532     __ jmp(Done);
3533   }
3534 
3535   __ bind(notShort);
3536   __ cmpl(flags, ltos);
3537   __ jcc(Assembler::notEqual, notLong);
3538 
3539   // ltos
3540   {
3541     __ pop(ltos);
3542     if (!is_static) pop_and_check_object(obj);
3543     // MO_RELAXED: generate atomic store for the case of volatile field (important for x86_32)
3544     __ access_store_at(T_LONG, IN_HEAP | MO_RELAXED, field, noreg /* ltos*/, noreg, noreg);
3545 #ifdef _LP64
3546     if (!is_static &amp;&amp; rc == may_rewrite) {
3547       patch_bytecode(Bytecodes::_fast_lputfield, bc, rbx, true, byte_no);
3548     }
3549 #endif // _LP64
3550     __ jmp(Done);
3551   }
3552 
3553   __ bind(notLong);
3554   __ cmpl(flags, ftos);
3555   __ jcc(Assembler::notEqual, notFloat);
3556 
3557   // ftos
3558   {
3559     __ pop(ftos);
3560     if (!is_static) pop_and_check_object(obj);
3561     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3562     if (!is_static &amp;&amp; rc == may_rewrite) {
3563       patch_bytecode(Bytecodes::_fast_fputfield, bc, rbx, true, byte_no);
3564     }
3565     __ jmp(Done);
3566   }
3567 
3568   __ bind(notFloat);
3569 #ifdef ASSERT
3570   Label notDouble;
3571   __ cmpl(flags, dtos);
3572   __ jcc(Assembler::notEqual, notDouble);
3573 #endif
3574 
3575   // dtos
3576   {
3577     __ pop(dtos);
3578     if (!is_static) pop_and_check_object(obj);
3579     // MO_RELAXED: for the case of volatile field, in fact it adds no extra work for the underlying implementation
3580     __ access_store_at(T_DOUBLE, IN_HEAP | MO_RELAXED, field, noreg /* dtos */, noreg, noreg);
3581     if (!is_static &amp;&amp; rc == may_rewrite) {
3582       patch_bytecode(Bytecodes::_fast_dputfield, bc, rbx, true, byte_no);
3583     }
3584   }
3585 
3586 #ifdef ASSERT
3587   __ jmp(Done);
3588 
3589   __ bind(notDouble);
3590   __ stop(&quot;Bad state&quot;);
3591 #endif
3592 
3593   __ bind(Done);
3594 }
3595 
3596 void TemplateTable::putfield(int byte_no) {
3597   putfield_or_static(byte_no, false);
3598 }
3599 
3600 void TemplateTable::nofast_putfield(int byte_no) {
3601   putfield_or_static(byte_no, false, may_not_rewrite);
3602 }
3603 
3604 void TemplateTable::putstatic(int byte_no) {
3605   putfield_or_static(byte_no, true);
3606 }
3607 
3608 void TemplateTable::jvmti_post_fast_field_mod() {
3609 
3610   const Register scratch = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3611 
3612   if (JvmtiExport::can_post_field_modification()) {
3613     // Check to see if a field modification watch has been set before
3614     // we take the time to call into the VM.
3615     Label L2;
3616     __ mov32(scratch, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3617     __ testl(scratch, scratch);
3618     __ jcc(Assembler::zero, L2);
3619     __ pop_ptr(rbx);                  // copy the object pointer from tos
3620     __ verify_oop(rbx);
3621     __ push_ptr(rbx);                 // put the object pointer back on tos
3622     // Save tos values before call_VM() clobbers them. Since we have
3623     // to do it for every data type, we use the saved values as the
3624     // jvalue object.
3625     switch (bytecode()) {          // load values into the jvalue object
3626     case Bytecodes::_fast_qputfield: //fall through
3627     case Bytecodes::_fast_aputfield: __ push_ptr(rax); break;
3628     case Bytecodes::_fast_bputfield: // fall through
3629     case Bytecodes::_fast_zputfield: // fall through
3630     case Bytecodes::_fast_sputfield: // fall through
3631     case Bytecodes::_fast_cputfield: // fall through
3632     case Bytecodes::_fast_iputfield: __ push_i(rax); break;
3633     case Bytecodes::_fast_dputfield: __ push(dtos); break;
3634     case Bytecodes::_fast_fputfield: __ push(ftos); break;
3635     case Bytecodes::_fast_lputfield: __ push_l(rax); break;
3636 
3637     default:
3638       ShouldNotReachHere();
3639     }
3640     __ mov(scratch, rsp);             // points to jvalue on the stack
3641     // access constant pool cache entry
3642     LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rax, 1));
3643     NOT_LP64(__ get_cache_entry_pointer_at_bcp(rax, rdx, 1));
3644     __ verify_oop(rbx);
3645     // rbx: object pointer copied above
3646     // c_rarg2: cache entry pointer
3647     // c_rarg3: jvalue object on the stack
3648     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3));
3649     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, rax, rcx));
3650 
3651     switch (bytecode()) {             // restore tos values
3652     case Bytecodes::_fast_qputfield: // fall through
3653     case Bytecodes::_fast_aputfield: __ pop_ptr(rax); break;
3654     case Bytecodes::_fast_bputfield: // fall through
3655     case Bytecodes::_fast_zputfield: // fall through
3656     case Bytecodes::_fast_sputfield: // fall through
3657     case Bytecodes::_fast_cputfield: // fall through
3658     case Bytecodes::_fast_iputfield: __ pop_i(rax); break;
3659     case Bytecodes::_fast_dputfield: __ pop(dtos); break;
3660     case Bytecodes::_fast_fputfield: __ pop(ftos); break;
3661     case Bytecodes::_fast_lputfield: __ pop_l(rax); break;
3662     default: break;
3663     }
3664     __ bind(L2);
3665   }
3666 }
3667 
3668 void TemplateTable::fast_storefield(TosState state) {
3669   transition(state, vtos);
3670 
3671   ByteSize base = ConstantPoolCache::base_offset();
3672 
3673   jvmti_post_fast_field_mod();
3674 
3675   // access constant pool cache
3676   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3677 
3678   // test for volatile with rdx but rdx is tos register for lputfield.
3679   __ movl(rdx, Address(rcx, rbx, Address::times_ptr,
3680                        in_bytes(base +
3681                                 ConstantPoolCacheEntry::flags_offset())));
3682 
3683   // replace index with field offset from cache entry
3684   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,
3685                          in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
3686 
3687   // [jk] not needed currently
3688   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3689   //                                              Assembler::StoreStore));
3690 
3691   Label notVolatile, Done;
3692   if (bytecode() == Bytecodes::_fast_qputfield) {
3693     __ movl(rscratch2, rdx);  // saving flags for isFlattened test
3694   }
3695 
3696   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3697   __ andl(rdx, 0x1);
3698 
3699   // Get object from stack
3700   pop_and_check_object(rcx);
3701 
3702   // field address
3703   const Address field(rcx, rbx, Address::times_1);
3704 
3705   // Check for volatile store
3706   __ testl(rdx, rdx);
3707   __ jcc(Assembler::zero, notVolatile);
3708 
3709   if (bytecode() == Bytecodes::_fast_qputfield) {
3710     __ movl(rdx, rscratch2);  // restoring flags for isFlattened test
3711   }
3712   fast_storefield_helper(field, rax, rdx);
3713   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3714                                                Assembler::StoreStore));
3715   __ jmp(Done);
3716   __ bind(notVolatile);
3717 
3718   if (bytecode() == Bytecodes::_fast_qputfield) {
3719     __ movl(rdx, rscratch2);  // restoring flags for isFlattened test
3720   }
3721   fast_storefield_helper(field, rax, rdx);
3722 
3723   __ bind(Done);
3724 }
3725 
3726 void TemplateTable::fast_storefield_helper(Address field, Register rax, Register flags) {
3727 
3728   // access field
3729   switch (bytecode()) {
3730   case Bytecodes::_fast_qputfield:
3731     {
3732       Label isFlattened, done;
3733       __ null_check(rax);
3734       __ test_field_is_flattened(flags, rscratch1, isFlattened);
3735       // No Flattened case
3736       do_oop_store(_masm, field, rax);
3737       __ jmp(done);
3738       __ bind(isFlattened);
3739       // Flattened case
<a name="7" id="anc7"></a><span class="line-modified">3740       __ load_klass(rdx, rax);</span>
3741       __ data_for_oop(rax, rax, rdx);
3742       __ lea(rcx, field);
3743       __ access_value_copy(IN_HEAP, rax, rcx, rdx);
3744       __ bind(done);
3745     }
3746     break;
3747   case Bytecodes::_fast_aputfield:
3748     {
3749       do_oop_store(_masm, field, rax);
3750     }
3751     break;
3752   case Bytecodes::_fast_lputfield:
3753 #ifdef _LP64
3754     __ access_store_at(T_LONG, IN_HEAP, field, noreg /* ltos */, noreg, noreg);
3755 #else
3756   __ stop(&quot;should not be rewritten&quot;);
3757 #endif
3758     break;
3759   case Bytecodes::_fast_iputfield:
3760     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3761     break;
3762   case Bytecodes::_fast_zputfield:
3763     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3764     break;
3765   case Bytecodes::_fast_bputfield:
3766     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3767     break;
3768   case Bytecodes::_fast_sputfield:
3769     __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
3770     break;
3771   case Bytecodes::_fast_cputfield:
3772     __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg);
3773     break;
3774   case Bytecodes::_fast_fputfield:
3775     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos*/, noreg, noreg);
3776     break;
3777   case Bytecodes::_fast_dputfield:
3778     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos*/, noreg, noreg);
3779     break;
3780   default:
3781     ShouldNotReachHere();
3782   }
3783 }
3784 
3785 void TemplateTable::fast_accessfield(TosState state) {
3786   transition(atos, state);
3787 
3788   // Do the JVMTI work here to avoid disturbing the register state below
3789   if (JvmtiExport::can_post_field_access()) {
3790     // Check to see if a field access watch has been set before we
3791     // take the time to call into the VM.
3792     Label L1;
3793     __ mov32(rcx, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
3794     __ testl(rcx, rcx);
3795     __ jcc(Assembler::zero, L1);
3796     // access constant pool cache entry
3797     LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rcx, 1));
3798     NOT_LP64(__ get_cache_entry_pointer_at_bcp(rcx, rdx, 1));
3799     __ verify_oop(rax);
3800     __ push_ptr(rax);  // save object pointer before call_VM() clobbers it
3801     LP64_ONLY(__ mov(c_rarg1, rax));
3802     // c_rarg1: object pointer copied above
3803     // c_rarg2: cache entry pointer
3804     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2));
3805     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), rax, rcx));
3806     __ pop_ptr(rax); // restore object pointer
3807     __ bind(L1);
3808   }
3809 
3810   // access constant pool cache
3811   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3812   // replace index with field offset from cache entry
3813   // [jk] not needed currently
3814   // __ movl(rdx, Address(rcx, rbx, Address::times_8,
3815   //                      in_bytes(ConstantPoolCache::base_offset() +
3816   //                               ConstantPoolCacheEntry::flags_offset())));
3817   // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3818   // __ andl(rdx, 0x1);
3819   //
3820   __ movptr(rdx, Address(rcx, rbx, Address::times_ptr,
3821                          in_bytes(ConstantPoolCache::base_offset() +
3822                                   ConstantPoolCacheEntry::f2_offset())));
3823 
3824   // rax: object
3825   __ verify_oop(rax);
3826   __ null_check(rax);
3827   Address field(rax, rdx, Address::times_1);
3828 
3829   // access field
3830   switch (bytecode()) {
3831   case Bytecodes::_fast_qgetfield:
3832     {
3833       Label isFlattened, nonnull, Done;
3834       __ movptr(rscratch1, Address(rcx, rbx, Address::times_ptr,
3835                                    in_bytes(ConstantPoolCache::base_offset() +
3836                                             ConstantPoolCacheEntry::flags_offset())));
3837       __ test_field_is_flattened(rscratch1, rscratch2, isFlattened);
3838         // Non-flattened field case
3839         __ load_heap_oop(rax, field);
3840         __ testptr(rax, rax);
3841         __ jcc(Assembler::notZero, nonnull);
3842           __ movl(rdx, Address(rcx, rbx, Address::times_ptr,
3843                              in_bytes(ConstantPoolCache::base_offset() +
3844                                       ConstantPoolCacheEntry::flags_offset())));
3845           __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);
3846           __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,
3847                                        in_bytes(ConstantPoolCache::base_offset() +
3848                                                 ConstantPoolCacheEntry::f1_offset())));
3849           __ get_value_field_klass(rcx, rdx, rbx);
3850           __ get_default_value_oop(rbx, rcx, rax);
3851         __ bind(nonnull);
3852         __ verify_oop(rax);
3853         __ jmp(Done);
3854       __ bind(isFlattened);
3855         __ push(rdx); // save offset
3856         __ movl(rdx, Address(rcx, rbx, Address::times_ptr,
3857                            in_bytes(ConstantPoolCache::base_offset() +
3858                                     ConstantPoolCacheEntry::flags_offset())));
3859         __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);
3860         __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,
3861                                      in_bytes(ConstantPoolCache::base_offset() +
3862                                               ConstantPoolCacheEntry::f1_offset())));
3863         __ pop(rbx); // restore offset
3864         __ read_flattened_field(rcx, rdx, rbx, rax);
3865       __ bind(Done);
3866       __ verify_oop(rax);
3867     }
3868     break;
3869   case Bytecodes::_fast_agetfield:
3870     do_oop_load(_masm, field, rax);
3871     __ verify_oop(rax);
3872     break;
3873   case Bytecodes::_fast_lgetfield:
3874 #ifdef _LP64
3875     __ access_load_at(T_LONG, IN_HEAP, noreg /* ltos */, field, noreg, noreg);
3876 #else
3877   __ stop(&quot;should not be rewritten&quot;);
3878 #endif
3879     break;
3880   case Bytecodes::_fast_igetfield:
3881     __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3882     break;
3883   case Bytecodes::_fast_bgetfield:
3884     __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3885     break;
3886   case Bytecodes::_fast_sgetfield:
3887     __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
3888     break;
3889   case Bytecodes::_fast_cgetfield:
3890     __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
3891     break;
3892   case Bytecodes::_fast_fgetfield:
3893     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3894     break;
3895   case Bytecodes::_fast_dgetfield:
3896     __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* dtos */, field, noreg, noreg);
3897     break;
3898   default:
3899     ShouldNotReachHere();
3900   }
3901   // [jk] not needed currently
3902   //   Label notVolatile;
3903   //   __ testl(rdx, rdx);
3904   //   __ jcc(Assembler::zero, notVolatile);
3905   //   __ membar(Assembler::LoadLoad);
3906   //   __ bind(notVolatile);
3907 }
3908 
3909 void TemplateTable::fast_xaccess(TosState state) {
3910   transition(vtos, state);
3911 
3912   // get receiver
3913   __ movptr(rax, aaddress(0));
3914   // access constant pool cache
3915   __ get_cache_and_index_at_bcp(rcx, rdx, 2);
3916   __ movptr(rbx,
3917             Address(rcx, rdx, Address::times_ptr,
3918                     in_bytes(ConstantPoolCache::base_offset() +
3919                              ConstantPoolCacheEntry::f2_offset())));
3920   // make sure exception is reported in correct bcp range (getfield is
3921   // next instruction)
3922   __ increment(rbcp);
3923   __ null_check(rax);
3924   const Address field = Address(rax, rbx, Address::times_1, 0*wordSize);
3925   switch (state) {
3926   case itos:
3927     __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3928     break;
3929   case atos:
3930     do_oop_load(_masm, field, rax);
3931     __ verify_oop(rax);
3932     break;
3933   case ftos:
3934     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3935     break;
3936   default:
3937     ShouldNotReachHere();
3938   }
3939 
3940   // [jk] not needed currently
3941   // Label notVolatile;
3942   // __ movl(rdx, Address(rcx, rdx, Address::times_8,
3943   //                      in_bytes(ConstantPoolCache::base_offset() +
3944   //                               ConstantPoolCacheEntry::flags_offset())));
3945   // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3946   // __ testl(rdx, 0x1);
3947   // __ jcc(Assembler::zero, notVolatile);
3948   // __ membar(Assembler::LoadLoad);
3949   // __ bind(notVolatile);
3950 
3951   __ decrement(rbcp);
3952 }
3953 
3954 //-----------------------------------------------------------------------------
3955 // Calls
3956 
3957 void TemplateTable::count_calls(Register method, Register temp) {
3958   // implemented elsewhere
3959   ShouldNotReachHere();
3960 }
3961 
3962 void TemplateTable::prepare_invoke(int byte_no,
3963                                    Register method,  // linked method (or i-klass)
3964                                    Register index,   // itable index, MethodType, etc.
3965                                    Register recv,    // if caller wants to see it
3966                                    Register flags    // if caller wants to test it
3967                                    ) {
3968   // determine flags
3969   const Bytecodes::Code code = bytecode();
3970   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3971   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3972   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3973   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3974   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3975   const bool load_receiver       = (recv  != noreg);
3976   const bool save_flags          = (flags != noreg);
3977   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3978   assert(save_flags    == (is_invokeinterface || is_invokevirtual), &quot;need flags for vfinal&quot;);
3979   assert(flags == noreg || flags == rdx, &quot;&quot;);
3980   assert(recv  == noreg || recv  == rcx, &quot;&quot;);
3981 
3982   // setup registers &amp; access constant pool cache
3983   if (recv  == noreg)  recv  = rcx;
3984   if (flags == noreg)  flags = rdx;
3985   assert_different_registers(method, index, recv, flags);
3986 
3987   // save &#39;interpreter return address&#39;
3988   __ save_bcp();
3989 
3990   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3991 
3992   // maybe push appendix to arguments (just before return address)
3993   if (is_invokedynamic || is_invokehandle) {
3994     Label L_no_push;
3995     __ testl(flags, (1 &lt;&lt; ConstantPoolCacheEntry::has_appendix_shift));
3996     __ jcc(Assembler::zero, L_no_push);
3997     // Push the appendix as a trailing parameter.
3998     // This must be done before we get the receiver,
3999     // since the parameter_size includes it.
4000     __ push(rbx);
4001     __ mov(rbx, index);
4002     __ load_resolved_reference_at_index(index, rbx);
4003     __ pop(rbx);
4004     __ push(index);  // push appendix (MethodType, CallSite, etc.)
4005     __ bind(L_no_push);
4006   }
4007 
4008   // load receiver if needed (after appendix is pushed so parameter size is correct)
4009   // Note: no return address pushed yet
4010   if (load_receiver) {
4011     __ movl(recv, flags);
4012     __ andl(recv, ConstantPoolCacheEntry::parameter_size_mask);
4013     const int no_return_pc_pushed_yet = -1;  // argument slot correction before we push return address
4014     const int receiver_is_at_end      = -1;  // back off one slot to get receiver
4015     Address recv_addr = __ argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);
4016     __ movptr(recv, recv_addr);
4017     __ verify_oop(recv);
4018   }
4019 
4020   if (save_flags) {
4021     __ movl(rbcp, flags);
4022   }
4023 
4024   // compute return type
4025   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
4026   // Make sure we don&#39;t need to mask flags after the above shift
4027   ConstantPoolCacheEntry::verify_tos_state_shift();
4028   // load return address
4029   {
4030     const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);
4031     ExternalAddress table(table_addr);
4032     LP64_ONLY(__ lea(rscratch1, table));
4033     LP64_ONLY(__ movptr(flags, Address(rscratch1, flags, Address::times_ptr)));
4034     NOT_LP64(__ movptr(flags, ArrayAddress(table, Address(noreg, flags, Address::times_ptr))));
4035   }
4036 
4037   // push return address
4038   __ push(flags);
4039 
4040   // Restore flags value from the constant pool cache, and restore rsi
4041   // for later null checks.  r13 is the bytecode pointer
4042   if (save_flags) {
4043     __ movl(flags, rbcp);
4044     __ restore_bcp();
4045   }
4046 }
4047 
4048 void TemplateTable::invokevirtual_helper(Register index,
4049                                          Register recv,
4050                                          Register flags) {
4051   // Uses temporary registers rax, rdx
4052   assert_different_registers(index, recv, rax, rdx);
4053   assert(index == rbx, &quot;&quot;);
4054   assert(recv  == rcx, &quot;&quot;);
4055 
4056   // Test for an invoke of a final method
4057   Label notFinal;
4058   __ movl(rax, flags);
4059   __ andl(rax, (1 &lt;&lt; ConstantPoolCacheEntry::is_vfinal_shift));
4060   __ jcc(Assembler::zero, notFinal);
4061 
4062   const Register method = index;  // method must be rbx
4063   assert(method == rbx,
4064          &quot;Method* must be rbx for interpreter calling convention&quot;);
4065 
4066   // do the call - the index is actually the method to call
4067   // that is, f2 is a vtable index if !is_vfinal, else f2 is a Method*
4068 
4069   // It&#39;s final, need a null check here!
4070   __ null_check(recv);
4071 
4072   // profile this call
4073   __ profile_final_call(rax);
4074   __ profile_arguments_type(rax, method, rbcp, true);
4075 
4076   __ jump_from_interpreted(method, rax);
4077 
4078   __ bind(notFinal);
4079 
4080   // get receiver klass
4081   __ null_check(recv, oopDesc::klass_offset_in_bytes());
<a name="8" id="anc8"></a><span class="line-modified">4082   __ load_klass(rax, recv);</span>

4083 
4084   // profile this call
4085   __ profile_virtual_call(rax, rlocals, rdx);
4086   // get target Method* &amp; entry point
4087   __ lookup_virtual_method(rax, index, method);
4088 
4089   __ profile_arguments_type(rdx, method, rbcp, true);
4090   __ jump_from_interpreted(method, rdx);
4091 }
4092 
4093 void TemplateTable::invokevirtual(int byte_no) {
4094   transition(vtos, vtos);
4095   assert(byte_no == f2_byte, &quot;use this argument&quot;);
4096   prepare_invoke(byte_no,
4097                  rbx,    // method or vtable index
4098                  noreg,  // unused itable index
4099                  rcx, rdx); // recv, flags
4100 
4101   // rbx: index
4102   // rcx: receiver
4103   // rdx: flags
4104 
4105   invokevirtual_helper(rbx, rcx, rdx);
4106 }
4107 
4108 void TemplateTable::invokespecial(int byte_no) {
4109   transition(vtos, vtos);
4110   assert(byte_no == f1_byte, &quot;use this argument&quot;);
4111   prepare_invoke(byte_no, rbx, noreg,  // get f1 Method*
4112                  rcx);  // get receiver also for null check
4113   __ verify_oop(rcx);
4114   __ null_check(rcx);
4115   // do the call
4116   __ profile_call(rax);
4117   __ profile_arguments_type(rax, rbx, rbcp, false);
4118   __ jump_from_interpreted(rbx, rax);
4119 }
4120 
4121 void TemplateTable::invokestatic(int byte_no) {
4122   transition(vtos, vtos);
4123   assert(byte_no == f1_byte, &quot;use this argument&quot;);
4124   prepare_invoke(byte_no, rbx);  // get f1 Method*
4125   // do the call
4126   __ profile_call(rax);
4127   __ profile_arguments_type(rax, rbx, rbcp, false);
4128   __ jump_from_interpreted(rbx, rax);
4129 }
4130 
4131 
4132 void TemplateTable::fast_invokevfinal(int byte_no) {
4133   transition(vtos, vtos);
4134   assert(byte_no == f2_byte, &quot;use this argument&quot;);
4135   __ stop(&quot;fast_invokevfinal not used on x86&quot;);
4136 }
4137 
4138 
4139 void TemplateTable::invokeinterface(int byte_no) {
4140   transition(vtos, vtos);
4141   assert(byte_no == f1_byte, &quot;use this argument&quot;);
4142   prepare_invoke(byte_no, rax, rbx,  // get f1 Klass*, f2 Method*
4143                  rcx, rdx); // recv, flags
4144 
4145   // rax: reference klass (from f1) if interface method
4146   // rbx: method (from f2)
4147   // rcx: receiver
4148   // rdx: flags
4149 
4150   // First check for Object case, then private interface method,
4151   // then regular interface method.
4152 
4153   // Special case of invokeinterface called for virtual method of
4154   // java.lang.Object.  See cpCache.cpp for details.
4155   Label notObjectMethod;
4156   __ movl(rlocals, rdx);
4157   __ andl(rlocals, (1 &lt;&lt; ConstantPoolCacheEntry::is_forced_virtual_shift));
4158   __ jcc(Assembler::zero, notObjectMethod);
4159   invokevirtual_helper(rbx, rcx, rdx);
4160   // no return from above
4161   __ bind(notObjectMethod);
4162 
4163   Label no_such_interface; // for receiver subtype check
4164   Register recvKlass; // used for exception processing
4165 
4166   // Check for private method invocation - indicated by vfinal
4167   Label notVFinal;
4168   __ movl(rlocals, rdx);
4169   __ andl(rlocals, (1 &lt;&lt; ConstantPoolCacheEntry::is_vfinal_shift));
4170   __ jcc(Assembler::zero, notVFinal);
4171 
4172   // Get receiver klass into rlocals - also a null check
4173   __ null_check(rcx, oopDesc::klass_offset_in_bytes());
<a name="9" id="anc9"></a><span class="line-modified">4174   __ load_klass(rlocals, rcx);</span>

4175 
4176   Label subtype;
4177   __ check_klass_subtype(rlocals, rax, rbcp, subtype);
4178   // If we get here the typecheck failed
4179   recvKlass = rdx;
4180   __ mov(recvKlass, rlocals); // shuffle receiver class for exception use
4181   __ jmp(no_such_interface);
4182 
4183   __ bind(subtype);
4184 
4185   // do the call - rbx is actually the method to call
4186 
4187   __ profile_final_call(rdx);
4188   __ profile_arguments_type(rdx, rbx, rbcp, true);
4189 
4190   __ jump_from_interpreted(rbx, rdx);
4191   // no return from above
4192   __ bind(notVFinal);
4193 
4194   // Get receiver klass into rdx - also a null check
4195   __ restore_locals();  // restore r14
4196   __ null_check(rcx, oopDesc::klass_offset_in_bytes());
<a name="10" id="anc10"></a><span class="line-modified">4197   __ load_klass(rdx, rcx);</span>
4198 
4199   Label no_such_method;
4200 
4201   // Preserve method for throw_AbstractMethodErrorVerbose.
4202   __ mov(rcx, rbx);
4203   // Receiver subtype check against REFC.
4204   // Superklass in rax. Subklass in rdx. Blows rcx, rdi.
4205   __ lookup_interface_method(// inputs: rec. class, interface, itable index
4206                              rdx, rax, noreg,
4207                              // outputs: scan temp. reg, scan temp. reg
4208                              rbcp, rlocals,
4209                              no_such_interface,
4210                              /*return_method=*/false);
4211 
4212   // profile this call
4213   __ restore_bcp(); // rbcp was destroyed by receiver type check
4214   __ profile_virtual_call(rdx, rbcp, rlocals);
4215 
4216   // Get declaring interface class from method, and itable index
4217   __ load_method_holder(rax, rbx);
4218   __ movl(rbx, Address(rbx, Method::itable_index_offset()));
4219   __ subl(rbx, Method::itable_index_max);
4220   __ negl(rbx);
4221 
4222   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
4223   __ mov(rlocals, rdx);
4224   __ lookup_interface_method(// inputs: rec. class, interface, itable index
4225                              rlocals, rax, rbx,
4226                              // outputs: method, scan temp. reg
4227                              rbx, rbcp,
4228                              no_such_interface);
4229 
4230   // rbx: Method* to call
4231   // rcx: receiver
4232   // Check for abstract method error
4233   // Note: This should be done more efficiently via a throw_abstract_method_error
4234   //       interpreter entry point and a conditional jump to it in case of a null
4235   //       method.
4236   __ testptr(rbx, rbx);
4237   __ jcc(Assembler::zero, no_such_method);
4238 
4239   __ profile_arguments_type(rdx, rbx, rbcp, true);
4240 
4241   // do the call
4242   // rcx: receiver
4243   // rbx,: Method*
4244   __ jump_from_interpreted(rbx, rdx);
4245   __ should_not_reach_here();
4246 
4247   // exception handling code follows...
4248   // note: must restore interpreter registers to canonical
4249   //       state for exception handling to work correctly!
4250 
4251   __ bind(no_such_method);
4252   // throw exception
4253   __ pop(rbx);           // pop return address (pushed by prepare_invoke)
4254   __ restore_bcp();      // rbcp must be correct for exception handler   (was destroyed)
4255   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
4256   // Pass arguments for generating a verbose error message.
4257 #ifdef _LP64
4258   recvKlass = c_rarg1;
4259   Register method    = c_rarg2;
4260   if (recvKlass != rdx) { __ movq(recvKlass, rdx); }
4261   if (method != rcx)    { __ movq(method, rcx);    }
4262 #else
4263   recvKlass = rdx;
4264   Register method    = rcx;
4265 #endif
4266   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_AbstractMethodErrorVerbose),
4267              recvKlass, method);
4268   // The call_VM checks for exception, so we should never return here.
4269   __ should_not_reach_here();
4270 
4271   __ bind(no_such_interface);
4272   // throw exception
4273   __ pop(rbx);           // pop return address (pushed by prepare_invoke)
4274   __ restore_bcp();      // rbcp must be correct for exception handler   (was destroyed)
4275   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
4276   // Pass arguments for generating a verbose error message.
4277   LP64_ONLY( if (recvKlass != rdx) { __ movq(recvKlass, rdx); } )
4278   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose),
4279              recvKlass, rax);
4280   // the call_VM checks for exception, so we should never return here.
4281   __ should_not_reach_here();
4282 }
4283 
4284 void TemplateTable::invokehandle(int byte_no) {
4285   transition(vtos, vtos);
4286   assert(byte_no == f1_byte, &quot;use this argument&quot;);
4287   const Register rbx_method = rbx;
4288   const Register rax_mtype  = rax;
4289   const Register rcx_recv   = rcx;
4290   const Register rdx_flags  = rdx;
4291 
4292   prepare_invoke(byte_no, rbx_method, rax_mtype, rcx_recv);
4293   __ verify_method_ptr(rbx_method);
4294   __ verify_oop(rcx_recv);
4295   __ null_check(rcx_recv);
4296 
4297   // rax: MethodType object (from cpool-&gt;resolved_references[f1], if necessary)
4298   // rbx: MH.invokeExact_MT method (from f2)
4299 
4300   // Note:  rax_mtype is already pushed (if necessary) by prepare_invoke
4301 
4302   // FIXME: profile the LambdaForm also
4303   __ profile_final_call(rax);
4304   __ profile_arguments_type(rdx, rbx_method, rbcp, true);
4305 
4306   __ jump_from_interpreted(rbx_method, rdx);
4307 }
4308 
4309 void TemplateTable::invokedynamic(int byte_no) {
4310   transition(vtos, vtos);
4311   assert(byte_no == f1_byte, &quot;use this argument&quot;);
4312 
4313   const Register rbx_method   = rbx;
4314   const Register rax_callsite = rax;
4315 
4316   prepare_invoke(byte_no, rbx_method, rax_callsite);
4317 
4318   // rax: CallSite object (from cpool-&gt;resolved_references[f1])
4319   // rbx: MH.linkToCallSite method (from f2)
4320 
4321   // Note:  rax_callsite is already pushed by prepare_invoke
4322 
4323   // %%% should make a type profile for any invokedynamic that takes a ref argument
4324   // profile this call
4325   __ profile_call(rbcp);
4326   __ profile_arguments_type(rdx, rbx_method, rbcp, false);
4327 
4328   __ verify_oop(rax_callsite);
4329 
4330   __ jump_from_interpreted(rbx_method, rdx);
4331 }
4332 
4333 //-----------------------------------------------------------------------------
4334 // Allocation
4335 
4336 void TemplateTable::_new() {
4337   transition(vtos, atos);
4338   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
4339   Label slow_case;
4340   Label done;
4341   Label is_not_value;
4342 
4343   __ get_cpool_and_tags(rcx, rax);
4344 
4345   // Make sure the class we&#39;re about to instantiate has been resolved.
4346   // This is done before loading InstanceKlass to be consistent with the order
4347   // how Constant Pool is updated (see ConstantPool::klass_at_put)
4348   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
4349   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);
4350   __ jcc(Assembler::notEqual, slow_case);
4351 
4352   // get InstanceKlass
4353   __ load_resolved_klass_at_index(rcx, rcx, rdx);
4354 
4355   __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InstanceKlass::_kind_inline_type);
4356   __ jcc(Assembler::notEqual, is_not_value);
4357 
4358   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));
4359 
4360   __ bind(is_not_value);
4361 
4362   // make sure klass is initialized &amp; doesn&#39;t have finalizer
4363   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
4364   __ jcc(Assembler::notEqual, slow_case);
4365 
4366   __ allocate_instance(rcx, rax, rdx, rbx, true, slow_case);
4367   __ jmp(done);
4368 
4369   // slow case
4370   __ bind(slow_case);
4371 
4372   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);
4373   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4374 
4375   __ get_constant_pool(rarg1);
4376   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4377   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);
4378    __ verify_oop(rax);
4379 
4380   // continue
4381   __ bind(done);
4382 }
4383 
4384 void TemplateTable::defaultvalue() {
4385   transition(vtos, atos);
4386 
4387   Label slow_case;
4388   Label done;
4389   Label is_value;
4390 
4391   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
4392   __ get_cpool_and_tags(rcx, rax);
4393 
4394   // Make sure the class we&#39;re about to instantiate has been resolved.
4395   // This is done before loading InstanceKlass to be consistent with the order
4396   // how Constant Pool is updated (see ConstantPool::klass_at_put)
4397   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
4398   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);
4399   __ jcc(Assembler::notEqual, slow_case);
4400 
4401   // get InstanceKlass
4402   __ load_resolved_klass_at_index(rcx, rcx, rdx);
4403 
4404   __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InstanceKlass::_kind_inline_type);
4405   __ jcc(Assembler::equal, is_value);
4406 
4407   // in the future, defaultvalue will just return null instead of throwing an exception
4408   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeError));
4409 
4410   __ bind(is_value);
4411 
4412   // make sure klass is fully initialized
4413   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
4414   __ jcc(Assembler::notEqual, slow_case);
4415 
4416   // have a resolved ValueKlass in rcx, return the default value oop from it
4417   __ get_default_value_oop(rcx, rdx, rax);
4418   __ jmp(done);
4419 
4420   __ bind(slow_case);
4421 
4422   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4423   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4424 
4425   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4426   __ get_constant_pool(rarg1);
4427 
4428   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::defaultvalue),
4429       rarg1, rarg2);
4430 
4431   __ bind(done);
4432   __ verify_oop(rax);
4433 }
4434 
4435 void TemplateTable::newarray() {
4436   transition(itos, atos);
4437   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4438   __ load_unsigned_byte(rarg1, at_bcp(1));
4439   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
4440           rarg1, rax);
4441 }
4442 
4443 void TemplateTable::anewarray() {
4444   transition(itos, atos);
4445 
4446   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4447   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4448 
4449   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4450   __ get_constant_pool(rarg1);
4451   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
4452           rarg1, rarg2, rax);
4453 }
4454 
4455 void TemplateTable::arraylength() {
4456   transition(atos, itos);
4457   __ null_check(rax, arrayOopDesc::length_offset_in_bytes());
4458   __ movl(rax, Address(rax, arrayOopDesc::length_offset_in_bytes()));
4459 }
4460 
4461 void TemplateTable::checkcast() {
4462   transition(atos, atos);
4463   Label done, is_null, ok_is_subtype, quicked, resolved;
4464   __ testptr(rax, rax); // object is in rax
4465   __ jcc(Assembler::zero, is_null);
4466 
4467   // Get cpool &amp; tags index
4468   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4469   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4470   // See if bytecode has already been quicked
4471   __ movzbl(rdx, Address(rdx, rbx,
4472       Address::times_1,
4473       Array&lt;u1&gt;::base_offset_in_bytes()));
4474   __ andl (rdx, ~JVM_CONSTANT_QDescBit);
4475   __ cmpl(rdx, JVM_CONSTANT_Class);
4476   __ jcc(Assembler::equal, quicked);
4477   __ push(atos); // save receiver for result, and for GC
4478   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4479 
4480   // vm_result_2 has metadata result
4481 #ifndef _LP64
4482   // borrow rdi from locals
4483   __ get_thread(rdi);
4484   __ get_vm_result_2(rax, rdi);
4485   __ restore_locals();
4486 #else
4487   __ get_vm_result_2(rax, r15_thread);
4488 #endif
4489 
4490   __ pop_ptr(rdx); // restore receiver
4491   __ jmpb(resolved);
4492 
4493   // Get superklass in rax and subklass in rbx
4494   __ bind(quicked);
4495   __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
4496   __ load_resolved_klass_at_index(rax, rcx, rbx);
4497 
4498   __ bind(resolved);
<a name="11" id="anc11"></a><span class="line-modified">4499   __ load_klass(rbx, rdx);</span>

4500 
4501   // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
4502   // Superklass in rax.  Subklass in rbx.
4503   __ gen_subtype_check(rbx, ok_is_subtype);
4504 
4505   // Come here on failure
4506   __ push_ptr(rdx);
4507   // object is at TOS
4508   __ jump(ExternalAddress(Interpreter::_throw_ClassCastException_entry));
4509 
4510   // Come here on success
4511   __ bind(ok_is_subtype);
4512   __ mov(rax, rdx); // Restore object in rdx
4513   __ jmp(done);
4514 
4515   __ bind(is_null);
4516 
4517   // Collect counts on whether this check-cast sees NULLs a lot or not.
4518   if (ProfileInterpreter) {
4519     __ profile_null_seen(rcx);
4520   }
4521 
4522   if (EnableValhalla) {
4523     // Get cpool &amp; tags index
4524     __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4525     __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4526     // See if CP entry is a Q-descriptor
4527     __ movzbl(rcx, Address(rdx, rbx,
4528         Address::times_1,
4529         Array&lt;u1&gt;::base_offset_in_bytes()));
4530     __ andl (rcx, JVM_CONSTANT_QDescBit);
4531     __ cmpl(rcx, JVM_CONSTANT_QDescBit);
4532     __ jcc(Assembler::notEqual, done);
4533     __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));
4534   }
4535 
4536   __ bind(done);
4537 }
4538 
4539 void TemplateTable::instanceof() {
4540   transition(atos, itos);
4541   Label done, is_null, ok_is_subtype, quicked, resolved;
4542   __ testptr(rax, rax);
4543   __ jcc(Assembler::zero, is_null);
4544 
4545   // Get cpool &amp; tags index
4546   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4547   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4548   // See if bytecode has already been quicked
4549   __ movzbl(rdx, Address(rdx, rbx,
4550         Address::times_1,
4551         Array&lt;u1&gt;::base_offset_in_bytes()));
4552   __ andl (rdx, ~JVM_CONSTANT_QDescBit);
4553   __ cmpl(rdx, JVM_CONSTANT_Class);
4554   __ jcc(Assembler::equal, quicked);
4555 
4556   __ push(atos); // save receiver for result, and for GC
4557   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4558   // vm_result_2 has metadata result
4559 
4560 #ifndef _LP64
4561   // borrow rdi from locals
4562   __ get_thread(rdi);
4563   __ get_vm_result_2(rax, rdi);
4564   __ restore_locals();
4565 #else
4566   __ get_vm_result_2(rax, r15_thread);
4567 #endif
4568 
4569   __ pop_ptr(rdx); // restore receiver
4570   __ verify_oop(rdx);
<a name="12" id="anc12"></a><span class="line-modified">4571   __ load_klass(rdx, rdx);</span>

4572   __ jmpb(resolved);
4573 
4574   // Get superklass in rax and subklass in rdx
4575   __ bind(quicked);
<a name="13" id="anc13"></a><span class="line-modified">4576   __ load_klass(rdx, rax);</span>
4577   __ load_resolved_klass_at_index(rax, rcx, rbx);
4578 
4579   __ bind(resolved);
4580 
4581   // Generate subtype check.  Blows rcx, rdi
4582   // Superklass in rax.  Subklass in rdx.
4583   __ gen_subtype_check(rdx, ok_is_subtype);
4584 
4585   // Come here on failure
4586   __ xorl(rax, rax);
4587   __ jmpb(done);
4588   // Come here on success
4589   __ bind(ok_is_subtype);
4590   __ movl(rax, 1);
4591 
4592   // Collect counts on whether this test sees NULLs a lot or not.
4593   if (ProfileInterpreter) {
4594     __ jmp(done);
4595     __ bind(is_null);
4596     __ profile_null_seen(rcx);
4597   } else {
4598     __ bind(is_null);   // same as &#39;done&#39;
4599   }
4600   __ bind(done);
4601   // rax = 0: obj == NULL or  obj is not an instanceof the specified klass
4602   // rax = 1: obj != NULL and obj is     an instanceof the specified klass
4603 }
4604 
4605 //----------------------------------------------------------------------------------------------------
4606 // Breakpoints
4607 void TemplateTable::_breakpoint() {
4608   // Note: We get here even if we are single stepping..
4609   // jbug insists on setting breakpoints at every bytecode
4610   // even if we are in single step mode.
4611 
4612   transition(vtos, vtos);
4613 
4614   Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4615 
4616   // get the unpatched byte code
4617   __ get_method(rarg);
4618   __ call_VM(noreg,
4619              CAST_FROM_FN_PTR(address,
4620                               InterpreterRuntime::get_original_bytecode_at),
4621              rarg, rbcp);
4622   __ mov(rbx, rax);  // why?
4623 
4624   // post the breakpoint event
4625   __ get_method(rarg);
4626   __ call_VM(noreg,
4627              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
4628              rarg, rbcp);
4629 
4630   // complete the execution of original bytecode
4631   __ dispatch_only_normal(vtos);
4632 }
4633 
4634 //-----------------------------------------------------------------------------
4635 // Exceptions
4636 
4637 void TemplateTable::athrow() {
4638   transition(atos, vtos);
4639   __ null_check(rax);
4640   __ jump(ExternalAddress(Interpreter::throw_exception_entry()));
4641 }
4642 
4643 //-----------------------------------------------------------------------------
4644 // Synchronization
4645 //
4646 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
4647 //       in the assembly code structure as well
4648 //
4649 // Stack layout:
4650 //
4651 // [expressions  ] &lt;--- rsp               = expression stack top
4652 // ..
4653 // [expressions  ]
4654 // [monitor entry] &lt;--- monitor block top = expression stack bot
4655 // ..
4656 // [monitor entry]
4657 // [frame data   ] &lt;--- monitor block bot
4658 // ...
4659 // [saved rbp    ] &lt;--- rbp
4660 void TemplateTable::monitorenter() {
4661   transition(atos, vtos);
4662 
4663   // check for NULL object
4664   __ null_check(rax);
4665 
4666   __ resolve(IS_NOT_NULL, rax);
4667 
4668   const int is_value_mask = markWord::always_locked_pattern;
4669   Label has_identity;
4670   __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));
4671   __ andptr(rbx, is_value_mask);
4672   __ cmpl(rbx, is_value_mask);
4673   __ jcc(Assembler::notEqual, has_identity);
4674   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4675                      InterpreterRuntime::throw_illegal_monitor_state_exception));
4676   __ should_not_reach_here();
4677   __ bind(has_identity);
4678 
4679   const Address monitor_block_top(
4680         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4681   const Address monitor_block_bot(
4682         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4683   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4684 
4685   Label allocated;
4686 
4687   Register rtop = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
4688   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4689   Register rmon = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4690 
4691   // initialize entry pointer
4692   __ xorl(rmon, rmon); // points to free slot or NULL
4693 
4694   // find a free slot in the monitor block (result in rmon)
4695   {
4696     Label entry, loop, exit;
4697     __ movptr(rtop, monitor_block_top); // points to current entry,
4698                                         // starting with top-most entry
4699     __ lea(rbot, monitor_block_bot);    // points to word before bottom
4700                                         // of monitor block
4701     __ jmpb(entry);
4702 
4703     __ bind(loop);
4704     // check if current entry is used
4705     __ cmpptr(Address(rtop, BasicObjectLock::obj_offset_in_bytes()), (int32_t) NULL_WORD);
4706     // if not used then remember entry in rmon
4707     __ cmovptr(Assembler::equal, rmon, rtop);   // cmov =&gt; cmovptr
4708     // check if current entry is for same object
4709     __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset_in_bytes()));
4710     // if same object then stop searching
4711     __ jccb(Assembler::equal, exit);
4712     // otherwise advance to next entry
4713     __ addptr(rtop, entry_size);
4714     __ bind(entry);
4715     // check if bottom reached
4716     __ cmpptr(rtop, rbot);
4717     // if not at bottom then check this entry
4718     __ jcc(Assembler::notEqual, loop);
4719     __ bind(exit);
4720   }
4721 
4722   __ testptr(rmon, rmon); // check if a slot has been found
4723   __ jcc(Assembler::notZero, allocated); // if found, continue with that one
4724 
4725   // allocate one if there&#39;s no free slot
4726   {
4727     Label entry, loop;
4728     // 1. compute new pointers          // rsp: old expression stack top
4729     __ movptr(rmon, monitor_block_bot); // rmon: old expression stack bottom
4730     __ subptr(rsp, entry_size);         // move expression stack top
4731     __ subptr(rmon, entry_size);        // move expression stack bottom
4732     __ mov(rtop, rsp);                  // set start value for copy loop
4733     __ movptr(monitor_block_bot, rmon); // set new monitor block bottom
4734     __ jmp(entry);
4735     // 2. move expression stack contents
4736     __ bind(loop);
4737     __ movptr(rbot, Address(rtop, entry_size)); // load expression stack
4738                                                 // word from old location
4739     __ movptr(Address(rtop, 0), rbot);          // and store it at new location
4740     __ addptr(rtop, wordSize);                  // advance to next word
4741     __ bind(entry);
4742     __ cmpptr(rtop, rmon);                      // check if bottom reached
4743     __ jcc(Assembler::notEqual, loop);          // if not at bottom then
4744                                                 // copy next word
4745   }
4746 
4747   // call run-time routine
4748   // rmon: points to monitor entry
4749   __ bind(allocated);
4750 
4751   // Increment bcp to point to the next bytecode, so exception
4752   // handling for async. exceptions work correctly.
4753   // The object has already been poped from the stack, so the
4754   // expression stack looks correct.
4755   __ increment(rbcp);
4756 
4757   // store object
4758   __ movptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax);
4759   __ lock_object(rmon);
4760 
4761   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
4762   __ save_bcp();  // in case of exception
4763   __ generate_stack_overflow_check(0);
4764 
4765   // The bcp has already been incremented. Just need to dispatch to
4766   // next instruction.
4767   __ dispatch_next(vtos);
4768 }
4769 
4770 void TemplateTable::monitorexit() {
4771   transition(atos, vtos);
4772 
4773   // check for NULL object
4774   __ null_check(rax);
4775 
4776   __ resolve(IS_NOT_NULL, rax);
4777 
4778   const int is_value_mask = markWord::always_locked_pattern;
4779   Label has_identity;
4780   __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));
4781   __ andptr(rbx, is_value_mask);
4782   __ cmpl(rbx, is_value_mask);
4783   __ jcc(Assembler::notEqual, has_identity);
4784   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4785                      InterpreterRuntime::throw_illegal_monitor_state_exception));
4786   __ should_not_reach_here();
4787   __ bind(has_identity);
4788 
4789   const Address monitor_block_top(
4790         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4791   const Address monitor_block_bot(
4792         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4793   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4794 
4795   Register rtop = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4796   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4797 
4798   Label found;
4799 
4800   // find matching slot
4801   {
4802     Label entry, loop;
4803     __ movptr(rtop, monitor_block_top); // points to current entry,
4804                                         // starting with top-most entry
4805     __ lea(rbot, monitor_block_bot);    // points to word before bottom
4806                                         // of monitor block
4807     __ jmpb(entry);
4808 
4809     __ bind(loop);
4810     // check if current entry is for same object
4811     __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset_in_bytes()));
4812     // if same object then stop searching
4813     __ jcc(Assembler::equal, found);
4814     // otherwise advance to next entry
4815     __ addptr(rtop, entry_size);
4816     __ bind(entry);
4817     // check if bottom reached
4818     __ cmpptr(rtop, rbot);
4819     // if not at bottom then check this entry
4820     __ jcc(Assembler::notEqual, loop);
4821   }
4822 
4823   // error handling. Unlocking was not block-structured
4824   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4825                    InterpreterRuntime::throw_illegal_monitor_state_exception));
4826   __ should_not_reach_here();
4827 
4828   // call run-time routine
4829   __ bind(found);
4830   __ push_ptr(rax); // make sure object is on stack (contract with oopMaps)
4831   __ unlock_object(rtop);
4832   __ pop_ptr(rax); // discard object
4833 }
4834 
4835 // Wide instructions
4836 void TemplateTable::wide() {
4837   transition(vtos, vtos);
4838   __ load_unsigned_byte(rbx, at_bcp(1));
4839   ExternalAddress wtable((address)Interpreter::_wentry_point);
4840   __ jump(ArrayAddress(wtable, Address(noreg, rbx, Address::times_ptr)));
4841   // Note: the rbcp increment step is part of the individual wide bytecode implementations
4842 }
4843 
4844 // Multi arrays
4845 void TemplateTable::multianewarray() {
4846   transition(vtos, atos);
4847 
4848   Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rax);
4849   __ load_unsigned_byte(rax, at_bcp(3)); // get number of dimensions
4850   // last dim is on top of stack; we want address of first one:
4851   // first_addr = last_addr + (ndims - 1) * stackElementSize - 1*wordsize
4852   // the latter wordSize to point to the beginning of the array.
4853   __ lea(rarg, Address(rsp, rax, Interpreter::stackElementScale(), -wordSize));
4854   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray), rarg);
4855   __ load_unsigned_byte(rbx, at_bcp(3));
4856   __ lea(rsp, Address(rsp, rbx, Interpreter::stackElementScale()));  // get rid of counts
4857 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
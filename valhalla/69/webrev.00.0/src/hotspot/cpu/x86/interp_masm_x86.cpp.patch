diff a/src/hotspot/cpu/x86/interp_masm_x86.cpp b/src/hotspot/cpu/x86/interp_masm_x86.cpp
--- a/src/hotspot/cpu/x86/interp_masm_x86.cpp
+++ b/src/hotspot/cpu/x86/interp_masm_x86.cpp
@@ -58,11 +58,12 @@
   jccb(Assembler::notZero, update);
   orptr(mdo_addr, TypeEntries::null_seen);
   jmpb(next);
 
   bind(update);
-  load_klass(obj, obj);
+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
+  load_klass(obj, obj, tmp_load_klass);
 
   xorptr(obj, mdo_addr);
   testptr(obj, TypeEntries::type_klass_mask);
   jccb(Assembler::zero, next); // klass seen before, nothing to
                                // do. The unknown bit may have been
@@ -1165,11 +1166,12 @@
     // We are returning a value type, load its fields into registers
 #ifndef _LP64
     super_call_VM_leaf(StubRoutines::load_value_type_fields_in_regs());
 #else
     // Load fields from a buffered value with a value class specific handler
-    load_klass(rdi, rax);
+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
+    load_klass(rdi, rax, tmp_load_klass);
     movptr(rdi, Address(rdi, InstanceKlass::adr_valueklass_fixed_block_offset()));
     movptr(rdi, Address(rdi, ValueKlass::unpack_handler_offset()));
 
     testptr(rdi, rdi);
     jcc(Assembler::equal, skip);
@@ -1268,11 +1270,12 @@
   const Register elem_klass = t1;
   const Register alloc_temp = LP64_ONLY(rscratch1) NOT_LP64(rsi);
   const Register dst_temp   = LP64_ONLY(rscratch2) NOT_LP64(rdi);
 
   // load in array->klass()->element_klass()
-  load_klass(array_klass, array);
+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
+  load_klass(array_klass, array, tmp_load_klass);
   movptr(elem_klass, Address(array_klass, ArrayKlass::element_klass_offset()));
 
   //check for empty value klass
   test_klass_is_empty_value(elem_klass, dst_temp, empty_value);
 
@@ -1337,11 +1340,12 @@
 
     // Load object pointer into obj_reg
     movptr(obj_reg, Address(lock_reg, obj_offset));
 
     if (UseBiasedLocking) {
-      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, false, done, &slow_case);
+      Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);
+      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, rklass_decode_tmp, false, done, &slow_case);
     }
 
     // Load immediate 1 into swap_reg %rax
     movl(swap_reg, (int32_t)1);
 

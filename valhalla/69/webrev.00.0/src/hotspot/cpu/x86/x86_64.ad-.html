<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
  360   return UseCompressedOops || UseCompressedClassPointers;
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 //
  463 // Compute padding required for nodes which need alignment
  464 //
  465 
  466 // The address of the call instruction needs to be 4-byte aligned to
  467 // ensure that it does not span a cache line so that it can be patched.
  468 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  469 {
  470   current_offset += clear_avx_size(); // skip vzeroupper
  471   current_offset += 1; // skip call opcode byte
  472   return align_up(current_offset, alignment_required()) - current_offset;
  473 }
  474 
  475 // The address of the call instruction needs to be 4-byte aligned to
  476 // ensure that it does not span a cache line so that it can be patched.
  477 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  478 {
  479   current_offset += clear_avx_size(); // skip vzeroupper
  480   current_offset += 11; // skip movq instruction + call opcode byte
  481   return align_up(current_offset, alignment_required()) - current_offset;
  482 }
  483 
  484 // EMIT_RM()
  485 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  486   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  487   cbuf.insts()-&gt;emit_int8(c);
  488 }
  489 
  490 // EMIT_CC()
  491 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  492   unsigned char c = (unsigned char) (f1 | f2);
  493   cbuf.insts()-&gt;emit_int8(c);
  494 }
  495 
  496 // EMIT_OPCODE()
  497 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  498   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  499 }
  500 
  501 // EMIT_OPCODE() w/ relocation information
  502 void emit_opcode(CodeBuffer &amp;cbuf,
  503                  int code, relocInfo::relocType reloc, int offset, int format)
  504 {
  505   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  506   emit_opcode(cbuf, code);
  507 }
  508 
  509 // EMIT_D8()
  510 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  511   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  512 }
  513 
  514 // EMIT_D16()
  515 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  516   cbuf.insts()-&gt;emit_int16(d16);
  517 }
  518 
  519 // EMIT_D32()
  520 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  521   cbuf.insts()-&gt;emit_int32(d32);
  522 }
  523 
  524 // EMIT_D64()
  525 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  526   cbuf.insts()-&gt;emit_int64(d64);
  527 }
  528 
  529 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  530 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  531                     int d32,
  532                     relocInfo::relocType reloc,
  533                     int format)
  534 {
  535   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  536   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  537   cbuf.insts()-&gt;emit_int32(d32);
  538 }
  539 
  540 // emit 32 bit value and construct relocation entry from RelocationHolder
  541 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  542 #ifdef ASSERT
  543   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  544       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  545     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  546     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  547   }
  548 #endif
  549   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  550   cbuf.insts()-&gt;emit_int32(d32);
  551 }
  552 
  553 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  554   address next_ip = cbuf.insts_end() + 4;
  555   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  556                  external_word_Relocation::spec(addr),
  557                  RELOC_DISP32);
  558 }
  559 
  560 
  561 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  562 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  563   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  564   cbuf.insts()-&gt;emit_int64(d64);
  565 }
  566 
  567 // emit 64 bit value and construct relocation entry from RelocationHolder
  568 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  569 #ifdef ASSERT
  570   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  571       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  572     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  573     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  574   }
  575 #endif
  576   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  577   cbuf.insts()-&gt;emit_int64(d64);
  578 }
  579 
  580 // Access stack slot for load or store
  581 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  582 {
  583   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  584   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  585     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  586     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  587     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  588   } else {
  589     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  590     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  591     emit_d32(cbuf, disp);     // Displacement // R/M byte
  592   }
  593 }
  594 
  595    // rRegI ereg, memory mem) %{    // emit_reg_mem
  596 void encode_RegMem(CodeBuffer &amp;cbuf,
  597                    int reg,
  598                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  599 {
  600   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  601   int regenc = reg &amp; 7;
  602   int baseenc = base &amp; 7;
  603   int indexenc = index &amp; 7;
  604 
  605   // There is no index &amp; no scale, use form without SIB byte
  606   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  607     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  608     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  609       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  610     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  611       // If 8-bit displacement, mode 0x1
  612       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  613       emit_d8(cbuf, disp);
  614     } else {
  615       // If 32-bit displacement
  616       if (base == -1) { // Special flag for absolute address
  617         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  618         if (disp_reloc != relocInfo::none) {
  619           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  620         } else {
  621           emit_d32(cbuf, disp);
  622         }
  623       } else {
  624         // Normal base + offset
  625         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  626         if (disp_reloc != relocInfo::none) {
  627           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  628         } else {
  629           emit_d32(cbuf, disp);
  630         }
  631       }
  632     }
  633   } else {
  634     // Else, encode with the SIB byte
  635     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  636     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  637       // If no displacement
  638       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  639       emit_rm(cbuf, scale, indexenc, baseenc);
  640     } else {
  641       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  642         // If 8-bit displacement, mode 0x1
  643         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  644         emit_rm(cbuf, scale, indexenc, baseenc);
  645         emit_d8(cbuf, disp);
  646       } else {
  647         // If 32-bit displacement
  648         if (base == 0x04 ) {
  649           emit_rm(cbuf, 0x2, regenc, 0x4);
  650           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  651         } else {
  652           emit_rm(cbuf, 0x2, regenc, 0x4);
  653           emit_rm(cbuf, scale, indexenc, baseenc); // *
  654         }
  655         if (disp_reloc != relocInfo::none) {
  656           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  657         } else {
  658           emit_d32(cbuf, disp);
  659         }
  660       }
  661     }
  662   }
  663 }
  664 
  665 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  666 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  667   Label exit;
  668   __ jccb(Assembler::noParity, exit);
  669   __ pushf();
  670   //
  671   // comiss/ucomiss instructions set ZF,PF,CF flags and
  672   // zero OF,AF,SF for NaN values.
  673   // Fixup flags by zeroing ZF,PF so that compare of NaN
  674   // values returns &#39;less than&#39; result (CF is set).
  675   // Leave the rest of flags unchanged.
  676   //
  677   //    7 6 5 4 3 2 1 0
  678   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  679   //    0 0 1 0 1 0 1 1   (0x2B)
  680   //
  681   __ andq(Address(rsp, 0), 0xffffff2b);
  682   __ popf();
  683   __ bind(exit);
  684 }
  685 
  686 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  687   Label done;
  688   __ movl(dst, -1);
  689   __ jcc(Assembler::parity, done);
  690   __ jcc(Assembler::below, done);
  691   __ setb(Assembler::notEqual, dst);
  692   __ movzbl(dst, dst);
  693   __ bind(done);
  694 }
  695 
  696 // Math.min()    # Math.max()
  697 // --------------------------
  698 // ucomis[s/d]   #
  699 // ja   -&gt; b     # a
  700 // jp   -&gt; NaN   # NaN
  701 // jb   -&gt; a     # b
  702 // je            #
  703 // |-jz -&gt; a | b # a &amp; b
  704 // |    -&gt; a     #
  705 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  706                      XMMRegister a, XMMRegister b,
  707                      XMMRegister xmmt, Register rt,
  708                      bool min, bool single) {
  709 
  710   Label nan, zero, below, above, done;
  711 
  712   if (single)
  713     __ ucomiss(a, b);
  714   else
  715     __ ucomisd(a, b);
  716 
  717   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  718     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  719   else
  720     __ jccb(Assembler::above, done);
  721 
  722   __ jccb(Assembler::parity, nan);  // PF=1
  723   __ jccb(Assembler::below, below); // CF=1
  724 
  725   // equal
  726   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  727   if (single) {
  728     __ ucomiss(a, xmmt);
  729     __ jccb(Assembler::equal, zero);
  730 
  731     __ movflt(dst, a);
  732     __ jmp(done);
  733   }
  734   else {
  735     __ ucomisd(a, xmmt);
  736     __ jccb(Assembler::equal, zero);
  737 
  738     __ movdbl(dst, a);
  739     __ jmp(done);
  740   }
  741 
  742   __ bind(zero);
  743   if (min)
  744     __ vpor(dst, a, b, Assembler::AVX_128bit);
  745   else
  746     __ vpand(dst, a, b, Assembler::AVX_128bit);
  747 
  748   __ jmp(done);
  749 
  750   __ bind(above);
  751   if (single)
  752     __ movflt(dst, min ? b : a);
  753   else
  754     __ movdbl(dst, min ? b : a);
  755 
  756   __ jmp(done);
  757 
  758   __ bind(nan);
  759   if (single) {
  760     __ movl(rt, 0x7fc00000); // Float.NaN
  761     __ movdl(dst, rt);
  762   }
  763   else {
  764     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  765     __ movdq(dst, rt);
  766   }
  767   __ jmp(done);
  768 
  769   __ bind(below);
  770   if (single)
  771     __ movflt(dst, min ? a : b);
  772   else
  773     __ movdbl(dst, min ? a : b);
  774 
  775   __ bind(done);
  776 }
  777 
  778 //=============================================================================
  779 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  780 
  781 int ConstantTable::calculate_table_base_offset() const {
  782   return 0;  // absolute addressing, no offset
  783 }
  784 
  785 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  786 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  787   ShouldNotReachHere();
  788 }
  789 
  790 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  791   // Empty encoding
  792 }
  793 
  794 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  795   return 0;
  796 }
  797 
  798 #ifndef PRODUCT
  799 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  800   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  801 }
  802 #endif
  803 
  804 
  805 //=============================================================================
  806 #ifndef PRODUCT
  807 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  808   Compile* C = ra_-&gt;C;
  809 
  810   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  811   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  812   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  813   // Remove wordSize for return addr which is already pushed.
  814   framesize -= wordSize;
  815 
  816   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  817     framesize -= wordSize;
  818     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  819     st-&gt;print(&quot;\n\t&quot;);
  820     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  821     if (PreserveFramePointer) {
  822         st-&gt;print(&quot;\n\t&quot;);
  823         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  824     }
  825     if (framesize) {
  826       st-&gt;print(&quot;\n\t&quot;);
  827       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  828     }
  829   } else {
  830     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  831     st-&gt;print(&quot;\n\t&quot;);
  832     framesize -= wordSize;
  833     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  834     if (PreserveFramePointer) {
  835       st-&gt;print(&quot;\n\t&quot;);
  836       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  837       if (framesize &gt; 0) {
  838         st-&gt;print(&quot;\n\t&quot;);
  839         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  840       }
  841     }
  842   }
  843 
  844   if (VerifyStackAtCalls) {
  845     st-&gt;print(&quot;\n\t&quot;);
  846     framesize -= wordSize;
  847     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  848 #ifdef ASSERT
  849     st-&gt;print(&quot;\n\t&quot;);
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 
  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  872     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  873 
  874     Label L_skip_barrier;
  875     Register klass = rscratch1;
  876 
  877     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  879 
  880     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  881 
  882     __ bind(L_skip_barrier);
  883   }
  884 
  885   __ verified_entry(C);
  886   __ bind(*_verified_entry);
  887 
  888   if (C-&gt;stub_function() == NULL) {
  889     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  890     bs-&gt;nmethod_entry_barrier(&amp;_masm);
  891   }
  892 
  893   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  894 
  895   if (C-&gt;has_mach_constant_base_node()) {
  896     // NOTE: We set the table base offset here because users might be
  897     // emitted before MachConstantBaseNode.
  898     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  899     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  900   }
  901 }
  902 
  903 int MachPrologNode::reloc() const
  904 {
  905   return 0; // a large enough number
  906 }
  907 
  908 //=============================================================================
  909 #ifndef PRODUCT
  910 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  911 {
  912   Compile* C = ra_-&gt;C;
  913   if (generate_vzeroupper(C)) {
  914     st-&gt;print(&quot;vzeroupper&quot;);
  915     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  916   }
  917 
  918   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  919   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  920   // Remove word for return adr already pushed
  921   // and RBP
  922   framesize -= 2*wordSize;
  923 
  924   if (framesize) {
  925     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  926     st-&gt;print(&quot;\t&quot;);
  927   }
  928 
  929   st-&gt;print_cr(&quot;popq    rbp&quot;);
  930   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  931     st-&gt;print(&quot;\t&quot;);
  932     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  933                  &quot;testl   rax, [rscratch1]\t&quot;
  934                  &quot;# Safepoint: poll for GC&quot;);
  935   }
  936 }
  937 #endif
  938 
  939 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  940 {
  941   Compile* C = ra_-&gt;C;
  942   MacroAssembler _masm(&amp;cbuf);
  943 
  944   if (generate_vzeroupper(C)) {
  945     // Clear upper bits of YMM registers when current compiled code uses
  946     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  947     __ vzeroupper();
  948   }
  949 
  950   // Subtract two words to account for return address and rbp
  951   int initial_framesize = C-&gt;output()-&gt;frame_size_in_bytes() - 2*wordSize;
  952   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;output()-&gt;sp_inc_offset());
  953 
  954   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  955     __ reserved_stack_check();
  956   }
  957 
  958   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  959     MacroAssembler _masm(&amp;cbuf);
  960     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  961     __ relocate(relocInfo::poll_return_type);
  962     __ testl(rax, Address(rscratch1, 0));
  963   }
  964 }
  965 
  966 int MachEpilogNode::reloc() const
  967 {
  968   return 2; // a large enough number
  969 }
  970 
  971 const Pipeline* MachEpilogNode::pipeline() const
  972 {
  973   return MachNode::pipeline_class();
  974 }
  975 
  976 //=============================================================================
  977 
  978 enum RC {
  979   rc_bad,
  980   rc_int,
  981   rc_float,
  982   rc_stack
  983 };
  984 
  985 static enum RC rc_class(OptoReg::Name reg)
  986 {
  987   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  988 
  989   if (OptoReg::is_stack(reg)) return rc_stack;
  990 
  991   VMReg r = OptoReg::as_VMReg(reg);
  992 
  993   if (r-&gt;is_Register()) return rc_int;
  994 
  995   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  996   return rc_float;
  997 }
  998 
  999 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1000 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1001                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1002 
 1003 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1004                      int stack_offset, int reg, uint ireg, outputStream* st);
 1005 
 1006 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1007                                       int dst_offset, uint ireg, outputStream* st) {
 1008   if (cbuf) {
 1009     MacroAssembler _masm(cbuf);
 1010     switch (ireg) {
 1011     case Op_VecS:
 1012       __ movq(Address(rsp, -8), rax);
 1013       __ movl(rax, Address(rsp, src_offset));
 1014       __ movl(Address(rsp, dst_offset), rax);
 1015       __ movq(rax, Address(rsp, -8));
 1016       break;
 1017     case Op_VecD:
 1018       __ pushq(Address(rsp, src_offset));
 1019       __ popq (Address(rsp, dst_offset));
 1020       break;
 1021     case Op_VecX:
 1022       __ pushq(Address(rsp, src_offset));
 1023       __ popq (Address(rsp, dst_offset));
 1024       __ pushq(Address(rsp, src_offset+8));
 1025       __ popq (Address(rsp, dst_offset+8));
 1026       break;
 1027     case Op_VecY:
 1028       __ vmovdqu(Address(rsp, -32), xmm0);
 1029       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1030       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1031       __ vmovdqu(xmm0, Address(rsp, -32));
 1032       break;
 1033     case Op_VecZ:
 1034       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1035       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1036       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1037       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1038       break;
 1039     default:
 1040       ShouldNotReachHere();
 1041     }
 1042 #ifndef PRODUCT
 1043   } else {
 1044     switch (ireg) {
 1045     case Op_VecS:
 1046       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1047                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1048                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1049                 &quot;movq    rax, [rsp - #8]&quot;,
 1050                 src_offset, dst_offset);
 1051       break;
 1052     case Op_VecD:
 1053       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1054                 &quot;popq    [rsp + #%d]&quot;,
 1055                 src_offset, dst_offset);
 1056       break;
 1057      case Op_VecX:
 1058       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1059                 &quot;popq    [rsp + #%d]\n\t&quot;
 1060                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1061                 &quot;popq    [rsp + #%d]&quot;,
 1062                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1063       break;
 1064     case Op_VecY:
 1065       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1066                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1067                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1068                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1069                 src_offset, dst_offset);
 1070       break;
 1071     case Op_VecZ:
 1072       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1073                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1074                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1075                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1076                 src_offset, dst_offset);
 1077       break;
 1078     default:
 1079       ShouldNotReachHere();
 1080     }
 1081 #endif
 1082   }
 1083 }
 1084 
 1085 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1086                                        PhaseRegAlloc* ra_,
 1087                                        bool do_size,
 1088                                        outputStream* st) const {
 1089   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1090   // Get registers to move
 1091   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1092   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1093   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1094   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1095 
 1096   enum RC src_second_rc = rc_class(src_second);
 1097   enum RC src_first_rc = rc_class(src_first);
 1098   enum RC dst_second_rc = rc_class(dst_second);
 1099   enum RC dst_first_rc = rc_class(dst_first);
 1100 
 1101   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1102          &quot;must move at least 1 register&quot; );
 1103 
 1104   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1105     // Self copy, no move
 1106     return 0;
 1107   }
 1108   if (bottom_type()-&gt;isa_vect() != NULL) {
 1109     uint ireg = ideal_reg();
 1110     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1111     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1112     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1113       // mem -&gt; mem
 1114       int src_offset = ra_-&gt;reg2offset(src_first);
 1115       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1116       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1117     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1118       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1119     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1120       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1121       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1122     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1123       int stack_offset = ra_-&gt;reg2offset(src_first);
 1124       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1125     } else {
 1126       ShouldNotReachHere();
 1127     }
 1128     return 0;
 1129   }
 1130   if (src_first_rc == rc_stack) {
 1131     // mem -&gt;
 1132     if (dst_first_rc == rc_stack) {
 1133       // mem -&gt; mem
 1134       assert(src_second != dst_first, &quot;overlap&quot;);
 1135       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1136           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1137         // 64-bit
 1138         int src_offset = ra_-&gt;reg2offset(src_first);
 1139         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1140         if (cbuf) {
 1141           MacroAssembler _masm(cbuf);
 1142           __ pushq(Address(rsp, src_offset));
 1143           __ popq (Address(rsp, dst_offset));
 1144 #ifndef PRODUCT
 1145         } else {
 1146           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1147                     &quot;popq    [rsp + #%d]&quot;,
 1148                      src_offset, dst_offset);
 1149 #endif
 1150         }
 1151       } else {
 1152         // 32-bit
 1153         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1154         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1155         // No pushl/popl, so:
 1156         int src_offset = ra_-&gt;reg2offset(src_first);
 1157         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1158         if (cbuf) {
 1159           MacroAssembler _masm(cbuf);
 1160           __ movq(Address(rsp, -8), rax);
 1161           __ movl(rax, Address(rsp, src_offset));
 1162           __ movl(Address(rsp, dst_offset), rax);
 1163           __ movq(rax, Address(rsp, -8));
 1164 #ifndef PRODUCT
 1165         } else {
 1166           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1167                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1168                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1169                     &quot;movq    rax, [rsp - #8]&quot;,
 1170                      src_offset, dst_offset);
 1171 #endif
 1172         }
 1173       }
 1174       return 0;
 1175     } else if (dst_first_rc == rc_int) {
 1176       // mem -&gt; gpr
 1177       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1178           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1179         // 64-bit
 1180         int offset = ra_-&gt;reg2offset(src_first);
 1181         if (cbuf) {
 1182           MacroAssembler _masm(cbuf);
 1183           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1184 #ifndef PRODUCT
 1185         } else {
 1186           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1187                      Matcher::regName[dst_first],
 1188                      offset);
 1189 #endif
 1190         }
 1191       } else {
 1192         // 32-bit
 1193         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1194         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1195         int offset = ra_-&gt;reg2offset(src_first);
 1196         if (cbuf) {
 1197           MacroAssembler _masm(cbuf);
 1198           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1199 #ifndef PRODUCT
 1200         } else {
 1201           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1202                      Matcher::regName[dst_first],
 1203                      offset);
 1204 #endif
 1205         }
 1206       }
 1207       return 0;
 1208     } else if (dst_first_rc == rc_float) {
 1209       // mem-&gt; xmm
 1210       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1211           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1212         // 64-bit
 1213         int offset = ra_-&gt;reg2offset(src_first);
 1214         if (cbuf) {
 1215           MacroAssembler _masm(cbuf);
 1216           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1217 #ifndef PRODUCT
 1218         } else {
 1219           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1220                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1221                      Matcher::regName[dst_first],
 1222                      offset);
 1223 #endif
 1224         }
 1225       } else {
 1226         // 32-bit
 1227         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1228         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1229         int offset = ra_-&gt;reg2offset(src_first);
 1230         if (cbuf) {
 1231           MacroAssembler _masm(cbuf);
 1232           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1233 #ifndef PRODUCT
 1234         } else {
 1235           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1236                      Matcher::regName[dst_first],
 1237                      offset);
 1238 #endif
 1239         }
 1240       }
 1241       return 0;
 1242     }
 1243   } else if (src_first_rc == rc_int) {
 1244     // gpr -&gt;
 1245     if (dst_first_rc == rc_stack) {
 1246       // gpr -&gt; mem
 1247       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1248           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1249         // 64-bit
 1250         int offset = ra_-&gt;reg2offset(dst_first);
 1251         if (cbuf) {
 1252           MacroAssembler _masm(cbuf);
 1253           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1254 #ifndef PRODUCT
 1255         } else {
 1256           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1257                      offset,
 1258                      Matcher::regName[src_first]);
 1259 #endif
 1260         }
 1261       } else {
 1262         // 32-bit
 1263         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1264         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1265         int offset = ra_-&gt;reg2offset(dst_first);
 1266         if (cbuf) {
 1267           MacroAssembler _masm(cbuf);
 1268           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1269 #ifndef PRODUCT
 1270         } else {
 1271           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1272                      offset,
 1273                      Matcher::regName[src_first]);
 1274 #endif
 1275         }
 1276       }
 1277       return 0;
 1278     } else if (dst_first_rc == rc_int) {
 1279       // gpr -&gt; gpr
 1280       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1281           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1282         // 64-bit
 1283         if (cbuf) {
 1284           MacroAssembler _masm(cbuf);
 1285           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1286                   as_Register(Matcher::_regEncode[src_first]));
 1287 #ifndef PRODUCT
 1288         } else {
 1289           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1290                      Matcher::regName[dst_first],
 1291                      Matcher::regName[src_first]);
 1292 #endif
 1293         }
 1294         return 0;
 1295       } else {
 1296         // 32-bit
 1297         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1298         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1299         if (cbuf) {
 1300           MacroAssembler _masm(cbuf);
 1301           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1302                   as_Register(Matcher::_regEncode[src_first]));
 1303 #ifndef PRODUCT
 1304         } else {
 1305           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1306                      Matcher::regName[dst_first],
 1307                      Matcher::regName[src_first]);
 1308 #endif
 1309         }
 1310         return 0;
 1311       }
 1312     } else if (dst_first_rc == rc_float) {
 1313       // gpr -&gt; xmm
 1314       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1315           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1316         // 64-bit
 1317         if (cbuf) {
 1318           MacroAssembler _masm(cbuf);
 1319           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1320 #ifndef PRODUCT
 1321         } else {
 1322           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1323                      Matcher::regName[dst_first],
 1324                      Matcher::regName[src_first]);
 1325 #endif
 1326         }
 1327       } else {
 1328         // 32-bit
 1329         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1330         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1331         if (cbuf) {
 1332           MacroAssembler _masm(cbuf);
 1333           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1334 #ifndef PRODUCT
 1335         } else {
 1336           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1337                      Matcher::regName[dst_first],
 1338                      Matcher::regName[src_first]);
 1339 #endif
 1340         }
 1341       }
 1342       return 0;
 1343     }
 1344   } else if (src_first_rc == rc_float) {
 1345     // xmm -&gt;
 1346     if (dst_first_rc == rc_stack) {
 1347       // xmm -&gt; mem
 1348       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1349           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1350         // 64-bit
 1351         int offset = ra_-&gt;reg2offset(dst_first);
 1352         if (cbuf) {
 1353           MacroAssembler _masm(cbuf);
 1354           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1355 #ifndef PRODUCT
 1356         } else {
 1357           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1358                      offset,
 1359                      Matcher::regName[src_first]);
 1360 #endif
 1361         }
 1362       } else {
 1363         // 32-bit
 1364         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1365         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1366         int offset = ra_-&gt;reg2offset(dst_first);
 1367         if (cbuf) {
 1368           MacroAssembler _masm(cbuf);
 1369           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1370 #ifndef PRODUCT
 1371         } else {
 1372           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1373                      offset,
 1374                      Matcher::regName[src_first]);
 1375 #endif
 1376         }
 1377       }
 1378       return 0;
 1379     } else if (dst_first_rc == rc_int) {
 1380       // xmm -&gt; gpr
 1381       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1382           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1383         // 64-bit
 1384         if (cbuf) {
 1385           MacroAssembler _masm(cbuf);
 1386           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1387 #ifndef PRODUCT
 1388         } else {
 1389           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1390                      Matcher::regName[dst_first],
 1391                      Matcher::regName[src_first]);
 1392 #endif
 1393         }
 1394       } else {
 1395         // 32-bit
 1396         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1397         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1398         if (cbuf) {
 1399           MacroAssembler _masm(cbuf);
 1400           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1401 #ifndef PRODUCT
 1402         } else {
 1403           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1404                      Matcher::regName[dst_first],
 1405                      Matcher::regName[src_first]);
 1406 #endif
 1407         }
 1408       }
 1409       return 0;
 1410     } else if (dst_first_rc == rc_float) {
 1411       // xmm -&gt; xmm
 1412       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1413           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1414         // 64-bit
 1415         if (cbuf) {
 1416           MacroAssembler _masm(cbuf);
 1417           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1418 #ifndef PRODUCT
 1419         } else {
 1420           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1421                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1422                      Matcher::regName[dst_first],
 1423                      Matcher::regName[src_first]);
 1424 #endif
 1425         }
 1426       } else {
 1427         // 32-bit
 1428         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1429         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1430         if (cbuf) {
 1431           MacroAssembler _masm(cbuf);
 1432           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1433 #ifndef PRODUCT
 1434         } else {
 1435           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1436                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1437                      Matcher::regName[dst_first],
 1438                      Matcher::regName[src_first]);
 1439 #endif
 1440         }
 1441       }
 1442       return 0;
 1443     }
 1444   }
 1445 
 1446   assert(0,&quot; foo &quot;);
 1447   Unimplemented();
 1448   return 0;
 1449 }
 1450 
 1451 #ifndef PRODUCT
 1452 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1453   implementation(NULL, ra_, false, st);
 1454 }
 1455 #endif
 1456 
 1457 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1458   implementation(&amp;cbuf, ra_, false, NULL);
 1459 }
 1460 
 1461 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1462   return MachNode::size(ra_);
 1463 }
 1464 
 1465 //=============================================================================
 1466 #ifndef PRODUCT
 1467 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1468 {
 1469   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1470   int reg = ra_-&gt;get_reg_first(this);
 1471   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1472             Matcher::regName[reg], offset);
 1473 }
 1474 #endif
 1475 
 1476 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1477 {
 1478   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1479   int reg = ra_-&gt;get_encode(this);
 1480   if (offset &gt;= 0x80) {
 1481     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1482     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1483     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1484     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1485     emit_d32(cbuf, offset);
 1486   } else {
 1487     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1488     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1489     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1490     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1491     emit_d8(cbuf, offset);
 1492   }
 1493 }
 1494 
 1495 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1496 {
 1497   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1498   return (offset &lt; 0x80) ? 5 : 8; // REX
 1499 }
 1500 
 1501 //=============================================================================
 1502 #ifndef PRODUCT
 1503 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1504 {
 1505   st-&gt;print_cr(&quot;MachVEPNode&quot;);
 1506 }
 1507 #endif
 1508 
 1509 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1510 {
 1511   MacroAssembler masm(&amp;cbuf);
 1512   if (!_verified) {  
 1513     uint insts_size = cbuf.insts_size();
 1514     if (UseCompressedClassPointers) {
 1515       masm.load_klass(rscratch1, j_rarg0);
 1516       masm.cmpptr(rax, rscratch1);
 1517     } else {
 1518       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1519     }
 1520     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1521   } else {
 1522     // Unpack value type args passed as oop and then jump to
 1523     // the verified entry point (skipping the unverified entry).
 1524     masm.unpack_value_args(ra_-&gt;C, _receiver_only);
 1525     masm.jmp(*_verified_entry);
 1526   }
 1527 }
 1528 
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1532 {
 1533   if (UseCompressedClassPointers) {
 1534     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1535     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1536     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1537   } else {
 1538     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1539                  &quot;# Inline cache check&quot;);
 1540   }
 1541   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1542   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1543 }
 1544 #endif
 1545 
 1546 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1547 {
 1548   MacroAssembler masm(&amp;cbuf);
 1549   uint insts_size = cbuf.insts_size();
 1550   if (UseCompressedClassPointers) {
 1551     masm.load_klass(rscratch1, j_rarg0);
 1552     masm.cmpptr(rax, rscratch1);
 1553   } else {
 1554     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1555   }
 1556 
 1557   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1558 
 1559   /* WARNING these NOPs are critical so that verified entry point is properly
 1560      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1561   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1562   if (OptoBreakpoint) {
 1563     // Leave space for int3
 1564     nops_cnt -= 1;
 1565   }
 1566   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1567   if (nops_cnt &gt; 0)
 1568     masm.nop(nops_cnt);
 1569 }
 1570 
 1571 //=============================================================================
 1572 
 1573 int Matcher::regnum_to_fpu_offset(int regnum)
 1574 {
 1575   return regnum - 32; // The FP registers are in the second chunk
 1576 }
 1577 
 1578 // This is UltraSparc specific, true just means we have fast l2f conversion
 1579 const bool Matcher::convL2FSupported(void) {
 1580   return true;
 1581 }
 1582 
 1583 // Is this branch offset short enough that a short branch can be used?
 1584 //
 1585 // NOTE: If the platform does not provide any short branch variants, then
 1586 //       this method should return false for offset 0.
 1587 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1588   // The passed offset is relative to address of the branch.
 1589   // On 86 a branch displacement is calculated relative to address
 1590   // of a next instruction.
 1591   offset -= br_size;
 1592 
 1593   // the short version of jmpConUCF2 contains multiple branches,
 1594   // making the reach slightly less
 1595   if (rule == jmpConUCF2_rule)
 1596     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1597   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1598 }
 1599 
 1600 const bool Matcher::isSimpleConstant64(jlong value) {
 1601   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1602   //return value == (int) value;  // Cf. storeImmL and immL32.
 1603 
 1604   // Probably always true, even if a temp register is required.
 1605   return true;
 1606 }
 1607 
 1608 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1609 const bool Matcher::init_array_count_is_in_bytes = false;
 1610 
 1611 // No additional cost for CMOVL.
 1612 const int Matcher::long_cmove_cost() { return 0; }
 1613 
 1614 // No CMOVF/CMOVD with SSE2
 1615 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1616 
 1617 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1618 const bool Matcher::require_postalloc_expand = false;
 1619 
 1620 // Do we need to mask the count passed to shift instructions or does
 1621 // the cpu only look at the lower 5/6 bits anyway?
 1622 const bool Matcher::need_masked_shift_count = false;
 1623 
 1624 bool Matcher::narrow_oop_use_complex_address() {
 1625   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1626   return (LogMinObjAlignmentInBytes &lt;= 3);
 1627 }
 1628 
 1629 bool Matcher::narrow_klass_use_complex_address() {
 1630   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1631   return (LogKlassAlignmentInBytes &lt;= 3);
 1632 }
 1633 
 1634 bool Matcher::const_oop_prefer_decode() {
 1635   // Prefer ConN+DecodeN over ConP.
 1636   return true;
 1637 }
 1638 
 1639 bool Matcher::const_klass_prefer_decode() {
 1640   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1641   //       or condisider the following:
 1642   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1643   //return CompressedKlassPointers::base() == NULL;
 1644   return true;
 1645 }
 1646 
 1647 // Is it better to copy float constants, or load them directly from
 1648 // memory?  Intel can load a float constant from a direct address,
 1649 // requiring no extra registers.  Most RISCs will have to materialize
 1650 // an address into a register first, so they would do better to copy
 1651 // the constant from stack.
 1652 const bool Matcher::rematerialize_float_constants = true; // XXX
 1653 
 1654 // If CPU can load and store mis-aligned doubles directly then no
 1655 // fixup is needed.  Else we split the double into 2 integer pieces
 1656 // and move it piece-by-piece.  Only happens when passing doubles into
 1657 // C code as the Java calling convention forces doubles to be aligned.
 1658 const bool Matcher::misaligned_doubles_ok = true;
 1659 
 1660 // No-op on amd64
 1661 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1662 
 1663 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1664 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1665 
 1666 // Are floats conerted to double when stored to stack during deoptimization?
 1667 // On x64 it is stored without convertion so we can use normal access.
 1668 bool Matcher::float_in_double() { return false; }
 1669 
 1670 // Do ints take an entire long register or just half?
 1671 const bool Matcher::int_in_long = true;
 1672 
 1673 // Return whether or not this register is ever used as an argument.
 1674 // This function is used on startup to build the trampoline stubs in
 1675 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1676 // call in the trampoline, and arguments in those registers not be
 1677 // available to the callee.
 1678 bool Matcher::can_be_java_arg(int reg)
 1679 {
 1680   return
 1681     reg ==  RDI_num || reg == RDI_H_num ||
 1682     reg ==  RSI_num || reg == RSI_H_num ||
 1683     reg ==  RDX_num || reg == RDX_H_num ||
 1684     reg ==  RCX_num || reg == RCX_H_num ||
 1685     reg ==   R8_num || reg ==  R8_H_num ||
 1686     reg ==   R9_num || reg ==  R9_H_num ||
 1687     reg ==  R12_num || reg == R12_H_num ||
 1688     reg == XMM0_num || reg == XMM0b_num ||
 1689     reg == XMM1_num || reg == XMM1b_num ||
 1690     reg == XMM2_num || reg == XMM2b_num ||
 1691     reg == XMM3_num || reg == XMM3b_num ||
 1692     reg == XMM4_num || reg == XMM4b_num ||
 1693     reg == XMM5_num || reg == XMM5b_num ||
 1694     reg == XMM6_num || reg == XMM6b_num ||
 1695     reg == XMM7_num || reg == XMM7b_num;
 1696 }
 1697 
 1698 bool Matcher::is_spillable_arg(int reg)
 1699 {
 1700   return can_be_java_arg(reg);
 1701 }
 1702 
 1703 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1704   // In 64 bit mode a code which use multiply when
 1705   // devisor is constant is faster than hardware
 1706   // DIV instruction (it uses MulHiL).
 1707   return false;
 1708 }
 1709 
 1710 // Register for DIVI projection of divmodI
 1711 RegMask Matcher::divI_proj_mask() {
 1712   return INT_RAX_REG_mask();
 1713 }
 1714 
 1715 // Register for MODI projection of divmodI
 1716 RegMask Matcher::modI_proj_mask() {
 1717   return INT_RDX_REG_mask();
 1718 }
 1719 
 1720 // Register for DIVL projection of divmodL
 1721 RegMask Matcher::divL_proj_mask() {
 1722   return LONG_RAX_REG_mask();
 1723 }
 1724 
 1725 // Register for MODL projection of divmodL
 1726 RegMask Matcher::modL_proj_mask() {
 1727   return LONG_RDX_REG_mask();
 1728 }
 1729 
 1730 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1731 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1732     return NO_REG_mask();
 1733 }
 1734 
 1735 %}
 1736 
 1737 //----------ENCODING BLOCK-----------------------------------------------------
 1738 // This block specifies the encoding classes used by the compiler to
 1739 // output byte streams.  Encoding classes are parameterized macros
 1740 // used by Machine Instruction Nodes in order to generate the bit
 1741 // encoding of the instruction.  Operands specify their base encoding
 1742 // interface with the interface keyword.  There are currently
 1743 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1744 // COND_INTER.  REG_INTER causes an operand to generate a function
 1745 // which returns its register number when queried.  CONST_INTER causes
 1746 // an operand to generate a function which returns the value of the
 1747 // constant when queried.  MEMORY_INTER causes an operand to generate
 1748 // four functions which return the Base Register, the Index Register,
 1749 // the Scale Value, and the Offset Value of the operand when queried.
 1750 // COND_INTER causes an operand to generate six functions which return
 1751 // the encoding code (ie - encoding bits for the instruction)
 1752 // associated with each basic boolean condition for a conditional
 1753 // instruction.
 1754 //
 1755 // Instructions specify two basic values for encoding.  Again, a
 1756 // function is available to check if the constant displacement is an
 1757 // oop. They use the ins_encode keyword to specify their encoding
 1758 // classes (which must be a sequence of enc_class names, and their
 1759 // parameters, specified in the encoding block), and they use the
 1760 // opcode keyword to specify, in order, their primary, secondary, and
 1761 // tertiary opcode.  Only the opcode sections which a particular
 1762 // instruction needs for encoding need to be specified.
 1763 encode %{
 1764   // Build emit functions for each basic byte or larger field in the
 1765   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1766   // from C++ code in the enc_class source block.  Emit functions will
 1767   // live in the main source block for now.  In future, we can
 1768   // generalize this by adding a syntax that specifies the sizes of
 1769   // fields in an order, so that the adlc can build the emit functions
 1770   // automagically
 1771 
 1772   // Emit primary opcode
 1773   enc_class OpcP
 1774   %{
 1775     emit_opcode(cbuf, $primary);
 1776   %}
 1777 
 1778   // Emit secondary opcode
 1779   enc_class OpcS
 1780   %{
 1781     emit_opcode(cbuf, $secondary);
 1782   %}
 1783 
 1784   // Emit tertiary opcode
 1785   enc_class OpcT
 1786   %{
 1787     emit_opcode(cbuf, $tertiary);
 1788   %}
 1789 
 1790   // Emit opcode directly
 1791   enc_class Opcode(immI d8)
 1792   %{
 1793     emit_opcode(cbuf, $d8$$constant);
 1794   %}
 1795 
 1796   // Emit size prefix
 1797   enc_class SizePrefix
 1798   %{
 1799     emit_opcode(cbuf, 0x66);
 1800   %}
 1801 
 1802   enc_class reg(rRegI reg)
 1803   %{
 1804     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1805   %}
 1806 
 1807   enc_class reg_reg(rRegI dst, rRegI src)
 1808   %{
 1809     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1810   %}
 1811 
 1812   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1813   %{
 1814     emit_opcode(cbuf, $opcode$$constant);
 1815     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1816   %}
 1817 
 1818   enc_class cdql_enc(no_rax_rdx_RegI div)
 1819   %{
 1820     // Full implementation of Java idiv and irem; checks for
 1821     // special case as described in JVM spec., p.243 &amp; p.271.
 1822     //
 1823     //         normal case                           special case
 1824     //
 1825     // input : rax: dividend                         min_int
 1826     //         reg: divisor                          -1
 1827     //
 1828     // output: rax: quotient  (= rax idiv reg)       min_int
 1829     //         rdx: remainder (= rax irem reg)       0
 1830     //
 1831     //  Code sequnce:
 1832     //
 1833     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1834     //    5:   75 07/08                jne    e &lt;normal&gt;
 1835     //    7:   33 d2                   xor    %edx,%edx
 1836     //  [div &gt;= 8 -&gt; offset + 1]
 1837     //  [REX_B]
 1838     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1839     //    c:   74 03/04                je     11 &lt;done&gt;
 1840     // 000000000000000e &lt;normal&gt;:
 1841     //    e:   99                      cltd
 1842     //  [div &gt;= 8 -&gt; offset + 1]
 1843     //  [REX_B]
 1844     //    f:   f7 f9                   idiv   $div
 1845     // 0000000000000011 &lt;done&gt;:
 1846 
 1847     // cmp    $0x80000000,%eax
 1848     emit_opcode(cbuf, 0x3d);
 1849     emit_d8(cbuf, 0x00);
 1850     emit_d8(cbuf, 0x00);
 1851     emit_d8(cbuf, 0x00);
 1852     emit_d8(cbuf, 0x80);
 1853 
 1854     // jne    e &lt;normal&gt;
 1855     emit_opcode(cbuf, 0x75);
 1856     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1857 
 1858     // xor    %edx,%edx
 1859     emit_opcode(cbuf, 0x33);
 1860     emit_d8(cbuf, 0xD2);
 1861 
 1862     // cmp    $0xffffffffffffffff,%ecx
 1863     if ($div$$reg &gt;= 8) {
 1864       emit_opcode(cbuf, Assembler::REX_B);
 1865     }
 1866     emit_opcode(cbuf, 0x83);
 1867     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1868     emit_d8(cbuf, 0xFF);
 1869 
 1870     // je     11 &lt;done&gt;
 1871     emit_opcode(cbuf, 0x74);
 1872     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1873 
 1874     // &lt;normal&gt;
 1875     // cltd
 1876     emit_opcode(cbuf, 0x99);
 1877 
 1878     // idivl (note: must be emitted by the user of this rule)
 1879     // &lt;done&gt;
 1880   %}
 1881 
 1882   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1883   %{
 1884     // Full implementation of Java ldiv and lrem; checks for
 1885     // special case as described in JVM spec., p.243 &amp; p.271.
 1886     //
 1887     //         normal case                           special case
 1888     //
 1889     // input : rax: dividend                         min_long
 1890     //         reg: divisor                          -1
 1891     //
 1892     // output: rax: quotient  (= rax idiv reg)       min_long
 1893     //         rdx: remainder (= rax irem reg)       0
 1894     //
 1895     //  Code sequnce:
 1896     //
 1897     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1898     //    7:   00 00 80
 1899     //    a:   48 39 d0                cmp    %rdx,%rax
 1900     //    d:   75 08                   jne    17 &lt;normal&gt;
 1901     //    f:   33 d2                   xor    %edx,%edx
 1902     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1903     //   15:   74 05                   je     1c &lt;done&gt;
 1904     // 0000000000000017 &lt;normal&gt;:
 1905     //   17:   48 99                   cqto
 1906     //   19:   48 f7 f9                idiv   $div
 1907     // 000000000000001c &lt;done&gt;:
 1908 
 1909     // mov    $0x8000000000000000,%rdx
 1910     emit_opcode(cbuf, Assembler::REX_W);
 1911     emit_opcode(cbuf, 0xBA);
 1912     emit_d8(cbuf, 0x00);
 1913     emit_d8(cbuf, 0x00);
 1914     emit_d8(cbuf, 0x00);
 1915     emit_d8(cbuf, 0x00);
 1916     emit_d8(cbuf, 0x00);
 1917     emit_d8(cbuf, 0x00);
 1918     emit_d8(cbuf, 0x00);
 1919     emit_d8(cbuf, 0x80);
 1920 
 1921     // cmp    %rdx,%rax
 1922     emit_opcode(cbuf, Assembler::REX_W);
 1923     emit_opcode(cbuf, 0x39);
 1924     emit_d8(cbuf, 0xD0);
 1925 
 1926     // jne    17 &lt;normal&gt;
 1927     emit_opcode(cbuf, 0x75);
 1928     emit_d8(cbuf, 0x08);
 1929 
 1930     // xor    %edx,%edx
 1931     emit_opcode(cbuf, 0x33);
 1932     emit_d8(cbuf, 0xD2);
 1933 
 1934     // cmp    $0xffffffffffffffff,$div
 1935     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1936     emit_opcode(cbuf, 0x83);
 1937     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1938     emit_d8(cbuf, 0xFF);
 1939 
 1940     // je     1e &lt;done&gt;
 1941     emit_opcode(cbuf, 0x74);
 1942     emit_d8(cbuf, 0x05);
 1943 
 1944     // &lt;normal&gt;
 1945     // cqto
 1946     emit_opcode(cbuf, Assembler::REX_W);
 1947     emit_opcode(cbuf, 0x99);
 1948 
 1949     // idivq (note: must be emitted by the user of this rule)
 1950     // &lt;done&gt;
 1951   %}
 1952 
 1953   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1954   enc_class OpcSE(immI imm)
 1955   %{
 1956     // Emit primary opcode and set sign-extend bit
 1957     // Check for 8-bit immediate, and set sign extend bit in opcode
 1958     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1959       emit_opcode(cbuf, $primary | 0x02);
 1960     } else {
 1961       // 32-bit immediate
 1962       emit_opcode(cbuf, $primary);
 1963     }
 1964   %}
 1965 
 1966   enc_class OpcSErm(rRegI dst, immI imm)
 1967   %{
 1968     // OpcSEr/m
 1969     int dstenc = $dst$$reg;
 1970     if (dstenc &gt;= 8) {
 1971       emit_opcode(cbuf, Assembler::REX_B);
 1972       dstenc -= 8;
 1973     }
 1974     // Emit primary opcode and set sign-extend bit
 1975     // Check for 8-bit immediate, and set sign extend bit in opcode
 1976     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1977       emit_opcode(cbuf, $primary | 0x02);
 1978     } else {
 1979       // 32-bit immediate
 1980       emit_opcode(cbuf, $primary);
 1981     }
 1982     // Emit r/m byte with secondary opcode, after primary opcode.
 1983     emit_rm(cbuf, 0x3, $secondary, dstenc);
 1984   %}
 1985 
 1986   enc_class OpcSErm_wide(rRegL dst, immI imm)
 1987   %{
 1988     // OpcSEr/m
 1989     int dstenc = $dst$$reg;
 1990     if (dstenc &lt; 8) {
 1991       emit_opcode(cbuf, Assembler::REX_W);
 1992     } else {
 1993       emit_opcode(cbuf, Assembler::REX_WB);
 1994       dstenc -= 8;
 1995     }
 1996     // Emit primary opcode and set sign-extend bit
 1997     // Check for 8-bit immediate, and set sign extend bit in opcode
 1998     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1999       emit_opcode(cbuf, $primary | 0x02);
 2000     } else {
 2001       // 32-bit immediate
 2002       emit_opcode(cbuf, $primary);
 2003     }
 2004     // Emit r/m byte with secondary opcode, after primary opcode.
 2005     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2006   %}
 2007 
 2008   enc_class Con8or32(immI imm)
 2009   %{
 2010     // Check for 8-bit immediate, and set sign extend bit in opcode
 2011     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2012       $$$emit8$imm$$constant;
 2013     } else {
 2014       // 32-bit immediate
 2015       $$$emit32$imm$$constant;
 2016     }
 2017   %}
 2018 
 2019   enc_class opc2_reg(rRegI dst)
 2020   %{
 2021     // BSWAP
 2022     emit_cc(cbuf, $secondary, $dst$$reg);
 2023   %}
 2024 
 2025   enc_class opc3_reg(rRegI dst)
 2026   %{
 2027     // BSWAP
 2028     emit_cc(cbuf, $tertiary, $dst$$reg);
 2029   %}
 2030 
 2031   enc_class reg_opc(rRegI div)
 2032   %{
 2033     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2034     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2035   %}
 2036 
 2037   enc_class enc_cmov(cmpOp cop)
 2038   %{
 2039     // CMOV
 2040     $$$emit8$primary;
 2041     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2042   %}
 2043 
 2044   enc_class enc_PartialSubtypeCheck()
 2045   %{
 2046     Register Rrdi = as_Register(RDI_enc); // result register
 2047     Register Rrax = as_Register(RAX_enc); // super class
 2048     Register Rrcx = as_Register(RCX_enc); // killed
 2049     Register Rrsi = as_Register(RSI_enc); // sub class
 2050     Label miss;
 2051     const bool set_cond_codes = true;
 2052 
 2053     MacroAssembler _masm(&amp;cbuf);
 2054     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2055                                      NULL, &amp;miss,
 2056                                      /*set_cond_codes:*/ true);
 2057     if ($primary) {
 2058       __ xorptr(Rrdi, Rrdi);
 2059     }
 2060     __ bind(miss);
 2061   %}
 2062 
 2063   enc_class clear_avx %{
 2064     debug_only(int off0 = cbuf.insts_size());
 2065     if (generate_vzeroupper(Compile::current())) {
 2066       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2067       // Clear upper bits of YMM registers when current compiled code uses
 2068       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2069       MacroAssembler _masm(&amp;cbuf);
 2070       __ vzeroupper();
 2071     }
 2072     debug_only(int off1 = cbuf.insts_size());
 2073     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2074   %}
 2075 
 2076   enc_class Java_To_Runtime(method meth) %{
 2077     // No relocation needed
 2078     MacroAssembler _masm(&amp;cbuf);
 2079     __ mov64(r10, (int64_t) $meth$$method);
 2080     __ call(r10);
 2081   %}
 2082 
 2083   enc_class Java_To_Interpreter(method meth)
 2084   %{
 2085     // CALL Java_To_Interpreter
 2086     // This is the instruction starting address for relocation info.
 2087     cbuf.set_insts_mark();
 2088     $$$emit8$primary;
 2089     // CALL directly to the runtime
 2090     emit_d32_reloc(cbuf,
 2091                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2092                    runtime_call_Relocation::spec(),
 2093                    RELOC_DISP32);
 2094   %}
 2095 
 2096   enc_class Java_Static_Call(method meth)
 2097   %{
 2098     // JAVA STATIC CALL
 2099     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2100     // determine who we intended to call.
 2101     cbuf.set_insts_mark();
 2102     $$$emit8$primary;
 2103 
 2104     if (!_method) {
 2105       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2106                      runtime_call_Relocation::spec(),
 2107                      RELOC_DISP32);
 2108     } else {
 2109       int method_index = resolved_method_index(cbuf);
 2110       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2111                                                   : static_call_Relocation::spec(method_index);
 2112       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2113                      rspec, RELOC_DISP32);
 2114       // Emit stubs for static call.
 2115       address mark = cbuf.insts_mark();
 2116       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2117       if (stub == NULL) {
 2118         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2119         return;
 2120       }
 2121 #if INCLUDE_AOT
 2122       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2123 #endif
 2124     }
 2125   %}
 2126 
 2127   enc_class Java_Dynamic_Call(method meth) %{
 2128     MacroAssembler _masm(&amp;cbuf);
 2129     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2130   %}
 2131 
 2132   enc_class Java_Compiled_Call(method meth)
 2133   %{
 2134     // JAVA COMPILED CALL
 2135     int disp = in_bytes(Method:: from_compiled_offset());
 2136 
 2137     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2138     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2139 
 2140     // callq *disp(%rax)
 2141     cbuf.set_insts_mark();
 2142     $$$emit8$primary;
 2143     if (disp &lt; 0x80) {
 2144       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2145       emit_d8(cbuf, disp); // Displacement
 2146     } else {
 2147       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2148       emit_d32(cbuf, disp); // Displacement
 2149     }
 2150   %}
 2151 
 2152   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2153   %{
 2154     // SAL, SAR, SHR
 2155     int dstenc = $dst$$reg;
 2156     if (dstenc &gt;= 8) {
 2157       emit_opcode(cbuf, Assembler::REX_B);
 2158       dstenc -= 8;
 2159     }
 2160     $$$emit8$primary;
 2161     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2162     $$$emit8$shift$$constant;
 2163   %}
 2164 
 2165   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2166   %{
 2167     // SAL, SAR, SHR
 2168     int dstenc = $dst$$reg;
 2169     if (dstenc &lt; 8) {
 2170       emit_opcode(cbuf, Assembler::REX_W);
 2171     } else {
 2172       emit_opcode(cbuf, Assembler::REX_WB);
 2173       dstenc -= 8;
 2174     }
 2175     $$$emit8$primary;
 2176     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2177     $$$emit8$shift$$constant;
 2178   %}
 2179 
 2180   enc_class load_immI(rRegI dst, immI src)
 2181   %{
 2182     int dstenc = $dst$$reg;
 2183     if (dstenc &gt;= 8) {
 2184       emit_opcode(cbuf, Assembler::REX_B);
 2185       dstenc -= 8;
 2186     }
 2187     emit_opcode(cbuf, 0xB8 | dstenc);
 2188     $$$emit32$src$$constant;
 2189   %}
 2190 
 2191   enc_class load_immL(rRegL dst, immL src)
 2192   %{
 2193     int dstenc = $dst$$reg;
 2194     if (dstenc &lt; 8) {
 2195       emit_opcode(cbuf, Assembler::REX_W);
 2196     } else {
 2197       emit_opcode(cbuf, Assembler::REX_WB);
 2198       dstenc -= 8;
 2199     }
 2200     emit_opcode(cbuf, 0xB8 | dstenc);
 2201     emit_d64(cbuf, $src$$constant);
 2202   %}
 2203 
 2204   enc_class load_immUL32(rRegL dst, immUL32 src)
 2205   %{
 2206     // same as load_immI, but this time we care about zeroes in the high word
 2207     int dstenc = $dst$$reg;
 2208     if (dstenc &gt;= 8) {
 2209       emit_opcode(cbuf, Assembler::REX_B);
 2210       dstenc -= 8;
 2211     }
 2212     emit_opcode(cbuf, 0xB8 | dstenc);
 2213     $$$emit32$src$$constant;
 2214   %}
 2215 
 2216   enc_class load_immL32(rRegL dst, immL32 src)
 2217   %{
 2218     int dstenc = $dst$$reg;
 2219     if (dstenc &lt; 8) {
 2220       emit_opcode(cbuf, Assembler::REX_W);
 2221     } else {
 2222       emit_opcode(cbuf, Assembler::REX_WB);
 2223       dstenc -= 8;
 2224     }
 2225     emit_opcode(cbuf, 0xC7);
 2226     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2227     $$$emit32$src$$constant;
 2228   %}
 2229 
 2230   enc_class load_immP31(rRegP dst, immP32 src)
 2231   %{
 2232     // same as load_immI, but this time we care about zeroes in the high word
 2233     int dstenc = $dst$$reg;
 2234     if (dstenc &gt;= 8) {
 2235       emit_opcode(cbuf, Assembler::REX_B);
 2236       dstenc -= 8;
 2237     }
 2238     emit_opcode(cbuf, 0xB8 | dstenc);
 2239     $$$emit32$src$$constant;
 2240   %}
 2241 
 2242   enc_class load_immP(rRegP dst, immP src)
 2243   %{
 2244     int dstenc = $dst$$reg;
 2245     if (dstenc &lt; 8) {
 2246       emit_opcode(cbuf, Assembler::REX_W);
 2247     } else {
 2248       emit_opcode(cbuf, Assembler::REX_WB);
 2249       dstenc -= 8;
 2250     }
 2251     emit_opcode(cbuf, 0xB8 | dstenc);
 2252     // This next line should be generated from ADLC
 2253     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2254       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2255     } else {
 2256       emit_d64(cbuf, $src$$constant);
 2257     }
 2258   %}
 2259 
 2260   enc_class Con32(immI src)
 2261   %{
 2262     // Output immediate
 2263     $$$emit32$src$$constant;
 2264   %}
 2265 
 2266   enc_class Con32F_as_bits(immF src)
 2267   %{
 2268     // Output Float immediate bits
 2269     jfloat jf = $src$$constant;
 2270     jint jf_as_bits = jint_cast(jf);
 2271     emit_d32(cbuf, jf_as_bits);
 2272   %}
 2273 
 2274   enc_class Con16(immI src)
 2275   %{
 2276     // Output immediate
 2277     $$$emit16$src$$constant;
 2278   %}
 2279 
 2280   // How is this different from Con32??? XXX
 2281   enc_class Con_d32(immI src)
 2282   %{
 2283     emit_d32(cbuf,$src$$constant);
 2284   %}
 2285 
 2286   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2287     // Output immediate memory reference
 2288     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2289     emit_d32(cbuf, 0x00);
 2290   %}
 2291 
 2292   enc_class lock_prefix()
 2293   %{
 2294     emit_opcode(cbuf, 0xF0); // lock
 2295   %}
 2296 
 2297   enc_class REX_mem(memory mem)
 2298   %{
 2299     if ($mem$$base &gt;= 8) {
 2300       if ($mem$$index &lt; 8) {
 2301         emit_opcode(cbuf, Assembler::REX_B);
 2302       } else {
 2303         emit_opcode(cbuf, Assembler::REX_XB);
 2304       }
 2305     } else {
 2306       if ($mem$$index &gt;= 8) {
 2307         emit_opcode(cbuf, Assembler::REX_X);
 2308       }
 2309     }
 2310   %}
 2311 
 2312   enc_class REX_mem_wide(memory mem)
 2313   %{
 2314     if ($mem$$base &gt;= 8) {
 2315       if ($mem$$index &lt; 8) {
 2316         emit_opcode(cbuf, Assembler::REX_WB);
 2317       } else {
 2318         emit_opcode(cbuf, Assembler::REX_WXB);
 2319       }
 2320     } else {
 2321       if ($mem$$index &lt; 8) {
 2322         emit_opcode(cbuf, Assembler::REX_W);
 2323       } else {
 2324         emit_opcode(cbuf, Assembler::REX_WX);
 2325       }
 2326     }
 2327   %}
 2328 
 2329   // for byte regs
 2330   enc_class REX_breg(rRegI reg)
 2331   %{
 2332     if ($reg$$reg &gt;= 4) {
 2333       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2334     }
 2335   %}
 2336 
 2337   // for byte regs
 2338   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2339   %{
 2340     if ($dst$$reg &lt; 8) {
 2341       if ($src$$reg &gt;= 4) {
 2342         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2343       }
 2344     } else {
 2345       if ($src$$reg &lt; 8) {
 2346         emit_opcode(cbuf, Assembler::REX_R);
 2347       } else {
 2348         emit_opcode(cbuf, Assembler::REX_RB);
 2349       }
 2350     }
 2351   %}
 2352 
 2353   // for byte regs
 2354   enc_class REX_breg_mem(rRegI reg, memory mem)
 2355   %{
 2356     if ($reg$$reg &lt; 8) {
 2357       if ($mem$$base &lt; 8) {
 2358         if ($mem$$index &gt;= 8) {
 2359           emit_opcode(cbuf, Assembler::REX_X);
 2360         } else if ($reg$$reg &gt;= 4) {
 2361           emit_opcode(cbuf, Assembler::REX);
 2362         }
 2363       } else {
 2364         if ($mem$$index &lt; 8) {
 2365           emit_opcode(cbuf, Assembler::REX_B);
 2366         } else {
 2367           emit_opcode(cbuf, Assembler::REX_XB);
 2368         }
 2369       }
 2370     } else {
 2371       if ($mem$$base &lt; 8) {
 2372         if ($mem$$index &lt; 8) {
 2373           emit_opcode(cbuf, Assembler::REX_R);
 2374         } else {
 2375           emit_opcode(cbuf, Assembler::REX_RX);
 2376         }
 2377       } else {
 2378         if ($mem$$index &lt; 8) {
 2379           emit_opcode(cbuf, Assembler::REX_RB);
 2380         } else {
 2381           emit_opcode(cbuf, Assembler::REX_RXB);
 2382         }
 2383       }
 2384     }
 2385   %}
 2386 
 2387   enc_class REX_reg(rRegI reg)
 2388   %{
 2389     if ($reg$$reg &gt;= 8) {
 2390       emit_opcode(cbuf, Assembler::REX_B);
 2391     }
 2392   %}
 2393 
 2394   enc_class REX_reg_wide(rRegI reg)
 2395   %{
 2396     if ($reg$$reg &lt; 8) {
 2397       emit_opcode(cbuf, Assembler::REX_W);
 2398     } else {
 2399       emit_opcode(cbuf, Assembler::REX_WB);
 2400     }
 2401   %}
 2402 
 2403   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2404   %{
 2405     if ($dst$$reg &lt; 8) {
 2406       if ($src$$reg &gt;= 8) {
 2407         emit_opcode(cbuf, Assembler::REX_B);
 2408       }
 2409     } else {
 2410       if ($src$$reg &lt; 8) {
 2411         emit_opcode(cbuf, Assembler::REX_R);
 2412       } else {
 2413         emit_opcode(cbuf, Assembler::REX_RB);
 2414       }
 2415     }
 2416   %}
 2417 
 2418   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2419   %{
 2420     if ($dst$$reg &lt; 8) {
 2421       if ($src$$reg &lt; 8) {
 2422         emit_opcode(cbuf, Assembler::REX_W);
 2423       } else {
 2424         emit_opcode(cbuf, Assembler::REX_WB);
 2425       }
 2426     } else {
 2427       if ($src$$reg &lt; 8) {
 2428         emit_opcode(cbuf, Assembler::REX_WR);
 2429       } else {
 2430         emit_opcode(cbuf, Assembler::REX_WRB);
 2431       }
 2432     }
 2433   %}
 2434 
 2435   enc_class REX_reg_mem(rRegI reg, memory mem)
 2436   %{
 2437     if ($reg$$reg &lt; 8) {
 2438       if ($mem$$base &lt; 8) {
 2439         if ($mem$$index &gt;= 8) {
 2440           emit_opcode(cbuf, Assembler::REX_X);
 2441         }
 2442       } else {
 2443         if ($mem$$index &lt; 8) {
 2444           emit_opcode(cbuf, Assembler::REX_B);
 2445         } else {
 2446           emit_opcode(cbuf, Assembler::REX_XB);
 2447         }
 2448       }
 2449     } else {
 2450       if ($mem$$base &lt; 8) {
 2451         if ($mem$$index &lt; 8) {
 2452           emit_opcode(cbuf, Assembler::REX_R);
 2453         } else {
 2454           emit_opcode(cbuf, Assembler::REX_RX);
 2455         }
 2456       } else {
 2457         if ($mem$$index &lt; 8) {
 2458           emit_opcode(cbuf, Assembler::REX_RB);
 2459         } else {
 2460           emit_opcode(cbuf, Assembler::REX_RXB);
 2461         }
 2462       }
 2463     }
 2464   %}
 2465 
 2466   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2467   %{
 2468     if ($reg$$reg &lt; 8) {
 2469       if ($mem$$base &lt; 8) {
 2470         if ($mem$$index &lt; 8) {
 2471           emit_opcode(cbuf, Assembler::REX_W);
 2472         } else {
 2473           emit_opcode(cbuf, Assembler::REX_WX);
 2474         }
 2475       } else {
 2476         if ($mem$$index &lt; 8) {
 2477           emit_opcode(cbuf, Assembler::REX_WB);
 2478         } else {
 2479           emit_opcode(cbuf, Assembler::REX_WXB);
 2480         }
 2481       }
 2482     } else {
 2483       if ($mem$$base &lt; 8) {
 2484         if ($mem$$index &lt; 8) {
 2485           emit_opcode(cbuf, Assembler::REX_WR);
 2486         } else {
 2487           emit_opcode(cbuf, Assembler::REX_WRX);
 2488         }
 2489       } else {
 2490         if ($mem$$index &lt; 8) {
 2491           emit_opcode(cbuf, Assembler::REX_WRB);
 2492         } else {
 2493           emit_opcode(cbuf, Assembler::REX_WRXB);
 2494         }
 2495       }
 2496     }
 2497   %}
 2498 
 2499   enc_class reg_mem(rRegI ereg, memory mem)
 2500   %{
 2501     // High registers handle in encode_RegMem
 2502     int reg = $ereg$$reg;
 2503     int base = $mem$$base;
 2504     int index = $mem$$index;
 2505     int scale = $mem$$scale;
 2506     int disp = $mem$$disp;
 2507     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2508 
 2509     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2510   %}
 2511 
 2512   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2513   %{
 2514     int rm_byte_opcode = $rm_opcode$$constant;
 2515 
 2516     // High registers handle in encode_RegMem
 2517     int base = $mem$$base;
 2518     int index = $mem$$index;
 2519     int scale = $mem$$scale;
 2520     int displace = $mem$$disp;
 2521 
 2522     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2523                                             // working with static
 2524                                             // globals
 2525     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2526                   disp_reloc);
 2527   %}
 2528 
 2529   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2530   %{
 2531     int reg_encoding = $dst$$reg;
 2532     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2533     int index        = 0x04;            // 0x04 indicates no index
 2534     int scale        = 0x00;            // 0x00 indicates no scale
 2535     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2536     relocInfo::relocType disp_reloc = relocInfo::none;
 2537     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2538                   disp_reloc);
 2539   %}
 2540 
 2541   enc_class neg_reg(rRegI dst)
 2542   %{
 2543     int dstenc = $dst$$reg;
 2544     if (dstenc &gt;= 8) {
 2545       emit_opcode(cbuf, Assembler::REX_B);
 2546       dstenc -= 8;
 2547     }
 2548     // NEG $dst
 2549     emit_opcode(cbuf, 0xF7);
 2550     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2551   %}
 2552 
 2553   enc_class neg_reg_wide(rRegI dst)
 2554   %{
 2555     int dstenc = $dst$$reg;
 2556     if (dstenc &lt; 8) {
 2557       emit_opcode(cbuf, Assembler::REX_W);
 2558     } else {
 2559       emit_opcode(cbuf, Assembler::REX_WB);
 2560       dstenc -= 8;
 2561     }
 2562     // NEG $dst
 2563     emit_opcode(cbuf, 0xF7);
 2564     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2565   %}
 2566 
 2567   enc_class setLT_reg(rRegI dst)
 2568   %{
 2569     int dstenc = $dst$$reg;
 2570     if (dstenc &gt;= 8) {
 2571       emit_opcode(cbuf, Assembler::REX_B);
 2572       dstenc -= 8;
 2573     } else if (dstenc &gt;= 4) {
 2574       emit_opcode(cbuf, Assembler::REX);
 2575     }
 2576     // SETLT $dst
 2577     emit_opcode(cbuf, 0x0F);
 2578     emit_opcode(cbuf, 0x9C);
 2579     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2580   %}
 2581 
 2582   enc_class setNZ_reg(rRegI dst)
 2583   %{
 2584     int dstenc = $dst$$reg;
 2585     if (dstenc &gt;= 8) {
 2586       emit_opcode(cbuf, Assembler::REX_B);
 2587       dstenc -= 8;
 2588     } else if (dstenc &gt;= 4) {
 2589       emit_opcode(cbuf, Assembler::REX);
 2590     }
 2591     // SETNZ $dst
 2592     emit_opcode(cbuf, 0x0F);
 2593     emit_opcode(cbuf, 0x95);
 2594     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2595   %}
 2596 
 2597 
 2598   // Compare the lonogs and set -1, 0, or 1 into dst
 2599   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2600   %{
 2601     int src1enc = $src1$$reg;
 2602     int src2enc = $src2$$reg;
 2603     int dstenc = $dst$$reg;
 2604 
 2605     // cmpq $src1, $src2
 2606     if (src1enc &lt; 8) {
 2607       if (src2enc &lt; 8) {
 2608         emit_opcode(cbuf, Assembler::REX_W);
 2609       } else {
 2610         emit_opcode(cbuf, Assembler::REX_WB);
 2611       }
 2612     } else {
 2613       if (src2enc &lt; 8) {
 2614         emit_opcode(cbuf, Assembler::REX_WR);
 2615       } else {
 2616         emit_opcode(cbuf, Assembler::REX_WRB);
 2617       }
 2618     }
 2619     emit_opcode(cbuf, 0x3B);
 2620     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2621 
 2622     // movl $dst, -1
 2623     if (dstenc &gt;= 8) {
 2624       emit_opcode(cbuf, Assembler::REX_B);
 2625     }
 2626     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2627     emit_d32(cbuf, -1);
 2628 
 2629     // jl,s done
 2630     emit_opcode(cbuf, 0x7C);
 2631     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2632 
 2633     // setne $dst
 2634     if (dstenc &gt;= 4) {
 2635       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2636     }
 2637     emit_opcode(cbuf, 0x0F);
 2638     emit_opcode(cbuf, 0x95);
 2639     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2640 
 2641     // movzbl $dst, $dst
 2642     if (dstenc &gt;= 4) {
 2643       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2644     }
 2645     emit_opcode(cbuf, 0x0F);
 2646     emit_opcode(cbuf, 0xB6);
 2647     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2648   %}
 2649 
 2650   enc_class Push_ResultXD(regD dst) %{
 2651     MacroAssembler _masm(&amp;cbuf);
 2652     __ fstp_d(Address(rsp, 0));
 2653     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2654     __ addptr(rsp, 8);
 2655   %}
 2656 
 2657   enc_class Push_SrcXD(regD src) %{
 2658     MacroAssembler _masm(&amp;cbuf);
 2659     __ subptr(rsp, 8);
 2660     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2661     __ fld_d(Address(rsp, 0));
 2662   %}
 2663 
 2664 
 2665   enc_class enc_rethrow()
 2666   %{
 2667     cbuf.set_insts_mark();
 2668     emit_opcode(cbuf, 0xE9); // jmp entry
 2669     emit_d32_reloc(cbuf,
 2670                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2671                    runtime_call_Relocation::spec(),
 2672                    RELOC_DISP32);
 2673   %}
 2674 
 2675 %}
 2676 
 2677 
 2678 
 2679 //----------FRAME--------------------------------------------------------------
 2680 // Definition of frame structure and management information.
 2681 //
 2682 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2683 //                             |   (to get allocators register number
 2684 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2685 //  r   CALLER     |        |
 2686 //  o     |        +--------+      pad to even-align allocators stack-slot
 2687 //  w     V        |  pad0  |        numbers; owned by CALLER
 2688 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2689 //  h     ^        |   in   |  5
 2690 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2691 //  |     |        |        |  3
 2692 //  |     |        +--------+
 2693 //  V     |        | old out|      Empty on Intel, window on Sparc
 2694 //        |    old |preserve|      Must be even aligned.
 2695 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2696 //        |        |   in   |  3   area for Intel ret address
 2697 //     Owned by    |preserve|      Empty on Sparc.
 2698 //       SELF      +--------+
 2699 //        |        |  pad2  |  2   pad to align old SP
 2700 //        |        +--------+  1
 2701 //        |        | locks  |  0
 2702 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2703 //        |        |  pad1  | 11   pad to align new SP
 2704 //        |        +--------+
 2705 //        |        |        | 10
 2706 //        |        | spills |  9   spills
 2707 //        V        |        |  8   (pad0 slot for callee)
 2708 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2709 //        ^        |  out   |  7
 2710 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2711 //     Owned by    +--------+
 2712 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2713 //        |    new |preserve|      Must be even-aligned.
 2714 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2715 //        |        |        |
 2716 //
 2717 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2718 //         known from SELF&#39;s arguments and the Java calling convention.
 2719 //         Region 6-7 is determined per call site.
 2720 // Note 2: If the calling convention leaves holes in the incoming argument
 2721 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2722 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2723 //         incoming area, as the Java calling convention is completely under
 2724 //         the control of the AD file.  Doubles can be sorted and packed to
 2725 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2726 //         varargs C calling conventions.
 2727 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2728 //         even aligned with pad0 as needed.
 2729 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2730 //         region 6-11 is even aligned; it may be padded out more so that
 2731 //         the region from SP to FP meets the minimum stack alignment.
 2732 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2733 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2734 //         SP meets the minimum alignment.
 2735 
 2736 frame
 2737 %{
 2738   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2739   stack_direction(TOWARDS_LOW);
 2740 
 2741   // These three registers define part of the calling convention
 2742   // between compiled code and the interpreter.
 2743   inline_cache_reg(RAX);                // Inline Cache Register
 2744   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2745                                         // calling interpreter
 2746 
 2747   // Optional: name the operand used by cisc-spilling to access
 2748   // [stack_pointer + offset]
 2749   cisc_spilling_operand_name(indOffset32);
 2750 
 2751   // Number of stack slots consumed by locking an object
 2752   sync_stack_slots(2);
 2753 
 2754   // Compiled code&#39;s Frame Pointer
 2755   frame_pointer(RSP);
 2756 
 2757   // Interpreter stores its frame pointer in a register which is
 2758   // stored to the stack by I2CAdaptors.
 2759   // I2CAdaptors convert from interpreted java to compiled java.
 2760   interpreter_frame_pointer(RBP);
 2761 
 2762   // Stack alignment requirement
 2763   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2764 
 2765   // Number of stack slots between incoming argument block and the start of
 2766   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2767   // EPILOG must remove this many slots.  amd64 needs two slots for
 2768   // return address.
 2769   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2770 
 2771   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2772   // for calls to C.  Supports the var-args backing area for register parms.
 2773   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2774 
 2775   // The after-PROLOG location of the return address.  Location of
 2776   // return address specifies a type (REG or STACK) and a number
 2777   // representing the register number (i.e. - use a register name) or
 2778   // stack slot.
 2779   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2780   // Otherwise, it is above the locks and verification slot and alignment word
 2781   return_addr(STACK - 2 +
 2782               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2783                         Compile::current()-&gt;fixed_slots()),
 2784                        stack_alignment_in_slots()));
 2785 
 2786   // Body of function which returns an integer array locating
 2787   // arguments either in registers or in stack slots.  Passed an array
 2788   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2789   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2790   // arguments for a CALLEE.  Incoming stack arguments are
 2791   // automatically biased by the preserve_stack_slots field above.
 2792 
 2793   calling_convention
 2794   %{
 2795     // No difference between ingoing/outgoing just pass false
 2796     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2797   %}
 2798 
 2799   c_calling_convention
 2800   %{
 2801     // This is obviously always outgoing
 2802     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2803   %}
 2804 
 2805   // Location of compiled Java return values.  Same as C for now.
 2806   return_value
 2807   %{
 2808     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2809            &quot;only return normal values&quot;);
 2810 
 2811     static const int lo[Op_RegL + 1] = {
 2812       0,
 2813       0,
 2814       RAX_num,  // Op_RegN
 2815       RAX_num,  // Op_RegI
 2816       RAX_num,  // Op_RegP
 2817       XMM0_num, // Op_RegF
 2818       XMM0_num, // Op_RegD
 2819       RAX_num   // Op_RegL
 2820     };
 2821     static const int hi[Op_RegL + 1] = {
 2822       0,
 2823       0,
 2824       OptoReg::Bad, // Op_RegN
 2825       OptoReg::Bad, // Op_RegI
 2826       RAX_H_num,    // Op_RegP
 2827       OptoReg::Bad, // Op_RegF
 2828       XMM0b_num,    // Op_RegD
 2829       RAX_H_num     // Op_RegL
 2830     };
 2831     // Excluded flags and vector registers.
 2832     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2833     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2834   %}
 2835 %}
 2836 
 2837 //----------ATTRIBUTES---------------------------------------------------------
 2838 //----------Operand Attributes-------------------------------------------------
 2839 op_attrib op_cost(0);        // Required cost attribute
 2840 
 2841 //----------Instruction Attributes---------------------------------------------
 2842 ins_attrib ins_cost(100);       // Required cost attribute
 2843 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2844 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2845                                 // a non-matching short branch variant
 2846                                 // of some long branch?
 2847 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2848                                 // be a power of 2) specifies the
 2849                                 // alignment that some part of the
 2850                                 // instruction (not necessarily the
 2851                                 // start) requires.  If &gt; 1, a
 2852                                 // compute_padding() function must be
 2853                                 // provided for the instruction
 2854 
 2855 //----------OPERANDS-----------------------------------------------------------
 2856 // Operand definitions must precede instruction definitions for correct parsing
 2857 // in the ADLC because operands constitute user defined types which are used in
 2858 // instruction definitions.
 2859 
 2860 //----------Simple Operands----------------------------------------------------
 2861 // Immediate Operands
 2862 // Integer Immediate
 2863 operand immI()
 2864 %{
 2865   match(ConI);
 2866 
 2867   op_cost(10);
 2868   format %{ %}
 2869   interface(CONST_INTER);
 2870 %}
 2871 
 2872 // Constant for test vs zero
 2873 operand immI0()
 2874 %{
 2875   predicate(n-&gt;get_int() == 0);
 2876   match(ConI);
 2877 
 2878   op_cost(0);
 2879   format %{ %}
 2880   interface(CONST_INTER);
 2881 %}
 2882 
 2883 // Constant for increment
 2884 operand immI1()
 2885 %{
 2886   predicate(n-&gt;get_int() == 1);
 2887   match(ConI);
 2888 
 2889   op_cost(0);
 2890   format %{ %}
 2891   interface(CONST_INTER);
 2892 %}
 2893 
 2894 // Constant for decrement
 2895 operand immI_M1()
 2896 %{
 2897   predicate(n-&gt;get_int() == -1);
 2898   match(ConI);
 2899 
 2900   op_cost(0);
 2901   format %{ %}
 2902   interface(CONST_INTER);
 2903 %}
 2904 
 2905 // Valid scale values for addressing modes
 2906 operand immI2()
 2907 %{
 2908   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2909   match(ConI);
 2910 
 2911   format %{ %}
 2912   interface(CONST_INTER);
 2913 %}
 2914 
 2915 operand immI8()
 2916 %{
 2917   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2918   match(ConI);
 2919 
 2920   op_cost(5);
 2921   format %{ %}
 2922   interface(CONST_INTER);
 2923 %}
 2924 
 2925 operand immU8()
 2926 %{
 2927   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2928   match(ConI);
 2929 
 2930   op_cost(5);
 2931   format %{ %}
 2932   interface(CONST_INTER);
 2933 %}
 2934 
 2935 operand immI16()
 2936 %{
 2937   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2938   match(ConI);
 2939 
 2940   op_cost(10);
 2941   format %{ %}
 2942   interface(CONST_INTER);
 2943 %}
 2944 
 2945 // Int Immediate non-negative
 2946 operand immU31()
 2947 %{
 2948   predicate(n-&gt;get_int() &gt;= 0);
 2949   match(ConI);
 2950 
 2951   op_cost(0);
 2952   format %{ %}
 2953   interface(CONST_INTER);
 2954 %}
 2955 
 2956 // Constant for long shifts
 2957 operand immI_32()
 2958 %{
 2959   predicate( n-&gt;get_int() == 32 );
 2960   match(ConI);
 2961 
 2962   op_cost(0);
 2963   format %{ %}
 2964   interface(CONST_INTER);
 2965 %}
 2966 
 2967 // Constant for long shifts
 2968 operand immI_64()
 2969 %{
 2970   predicate( n-&gt;get_int() == 64 );
 2971   match(ConI);
 2972 
 2973   op_cost(0);
 2974   format %{ %}
 2975   interface(CONST_INTER);
 2976 %}
 2977 
 2978 // Pointer Immediate
 2979 operand immP()
 2980 %{
 2981   match(ConP);
 2982 
 2983   op_cost(10);
 2984   format %{ %}
 2985   interface(CONST_INTER);
 2986 %}
 2987 
 2988 // NULL Pointer Immediate
 2989 operand immP0()
 2990 %{
 2991   predicate(n-&gt;get_ptr() == 0);
 2992   match(ConP);
 2993 
 2994   op_cost(5);
 2995   format %{ %}
 2996   interface(CONST_INTER);
 2997 %}
 2998 
 2999 // Pointer Immediate
 3000 operand immN() %{
 3001   match(ConN);
 3002 
 3003   op_cost(10);
 3004   format %{ %}
 3005   interface(CONST_INTER);
 3006 %}
 3007 
 3008 operand immNKlass() %{
 3009   match(ConNKlass);
 3010 
 3011   op_cost(10);
 3012   format %{ %}
 3013   interface(CONST_INTER);
 3014 %}
 3015 
 3016 // NULL Pointer Immediate
 3017 operand immN0() %{
 3018   predicate(n-&gt;get_narrowcon() == 0);
 3019   match(ConN);
 3020 
 3021   op_cost(5);
 3022   format %{ %}
 3023   interface(CONST_INTER);
 3024 %}
 3025 
 3026 operand immP31()
 3027 %{
 3028   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3029             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3030   match(ConP);
 3031 
 3032   op_cost(5);
 3033   format %{ %}
 3034   interface(CONST_INTER);
 3035 %}
 3036 
 3037 
 3038 // Long Immediate
 3039 operand immL()
 3040 %{
 3041   match(ConL);
 3042 
 3043   op_cost(20);
 3044   format %{ %}
 3045   interface(CONST_INTER);
 3046 %}
 3047 
 3048 // Long Immediate 8-bit
 3049 operand immL8()
 3050 %{
 3051   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3052   match(ConL);
 3053 
 3054   op_cost(5);
 3055   format %{ %}
 3056   interface(CONST_INTER);
 3057 %}
 3058 
 3059 // Long Immediate 32-bit unsigned
 3060 operand immUL32()
 3061 %{
 3062   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3063   match(ConL);
 3064 
 3065   op_cost(10);
 3066   format %{ %}
 3067   interface(CONST_INTER);
 3068 %}
 3069 
 3070 // Long Immediate 32-bit signed
 3071 operand immL32()
 3072 %{
 3073   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3074   match(ConL);
 3075 
 3076   op_cost(15);
 3077   format %{ %}
 3078   interface(CONST_INTER);
 3079 %}
 3080 
 3081 operand immL_Pow2()
 3082 %{
 3083   predicate(is_power_of_2((julong)n-&gt;get_long()));
 3084   match(ConL);
 3085 
 3086   op_cost(15);
 3087   format %{ %}
 3088   interface(CONST_INTER);
 3089 %}
 3090 
 3091 operand immL_NotPow2()
 3092 %{
 3093   predicate(is_power_of_2((julong)~n-&gt;get_long()));
 3094   match(ConL);
 3095 
 3096   op_cost(15);
 3097   format %{ %}
 3098   interface(CONST_INTER);
 3099 %}
 3100 
 3101 // Long Immediate zero
 3102 operand immL0()
 3103 %{
 3104   predicate(n-&gt;get_long() == 0L);
 3105   match(ConL);
 3106 
 3107   op_cost(10);
 3108   format %{ %}
 3109   interface(CONST_INTER);
 3110 %}
 3111 
 3112 // Constant for increment
 3113 operand immL1()
 3114 %{
 3115   predicate(n-&gt;get_long() == 1);
 3116   match(ConL);
 3117 
 3118   format %{ %}
 3119   interface(CONST_INTER);
 3120 %}
 3121 
 3122 // Constant for decrement
 3123 operand immL_M1()
 3124 %{
 3125   predicate(n-&gt;get_long() == -1);
 3126   match(ConL);
 3127 
 3128   format %{ %}
 3129   interface(CONST_INTER);
 3130 %}
 3131 
 3132 // Long Immediate: the value 10
 3133 operand immL10()
 3134 %{
 3135   predicate(n-&gt;get_long() == 10);
 3136   match(ConL);
 3137 
 3138   format %{ %}
 3139   interface(CONST_INTER);
 3140 %}
 3141 
 3142 // Long immediate from 0 to 127.
 3143 // Used for a shorter form of long mul by 10.
 3144 operand immL_127()
 3145 %{
 3146   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3147   match(ConL);
 3148 
 3149   op_cost(10);
 3150   format %{ %}
 3151   interface(CONST_INTER);
 3152 %}
 3153 
 3154 // Long Immediate: low 32-bit mask
 3155 operand immL_32bits()
 3156 %{
 3157   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3158   match(ConL);
 3159   op_cost(20);
 3160 
 3161   format %{ %}
 3162   interface(CONST_INTER);
 3163 %}
 3164 
 3165 // Float Immediate zero
 3166 operand immF0()
 3167 %{
 3168   predicate(jint_cast(n-&gt;getf()) == 0);
 3169   match(ConF);
 3170 
 3171   op_cost(5);
 3172   format %{ %}
 3173   interface(CONST_INTER);
 3174 %}
 3175 
 3176 // Float Immediate
 3177 operand immF()
 3178 %{
 3179   match(ConF);
 3180 
 3181   op_cost(15);
 3182   format %{ %}
 3183   interface(CONST_INTER);
 3184 %}
 3185 
 3186 // Double Immediate zero
 3187 operand immD0()
 3188 %{
 3189   predicate(jlong_cast(n-&gt;getd()) == 0);
 3190   match(ConD);
 3191 
 3192   op_cost(5);
 3193   format %{ %}
 3194   interface(CONST_INTER);
 3195 %}
 3196 
 3197 // Double Immediate
 3198 operand immD()
 3199 %{
 3200   match(ConD);
 3201 
 3202   op_cost(15);
 3203   format %{ %}
 3204   interface(CONST_INTER);
 3205 %}
 3206 
 3207 // Immediates for special shifts (sign extend)
 3208 
 3209 // Constants for increment
 3210 operand immI_16()
 3211 %{
 3212   predicate(n-&gt;get_int() == 16);
 3213   match(ConI);
 3214 
 3215   format %{ %}
 3216   interface(CONST_INTER);
 3217 %}
 3218 
 3219 operand immI_24()
 3220 %{
 3221   predicate(n-&gt;get_int() == 24);
 3222   match(ConI);
 3223 
 3224   format %{ %}
 3225   interface(CONST_INTER);
 3226 %}
 3227 
 3228 // Constant for byte-wide masking
 3229 operand immI_255()
 3230 %{
 3231   predicate(n-&gt;get_int() == 255);
 3232   match(ConI);
 3233 
 3234   format %{ %}
 3235   interface(CONST_INTER);
 3236 %}
 3237 
 3238 // Constant for short-wide masking
 3239 operand immI_65535()
 3240 %{
 3241   predicate(n-&gt;get_int() == 65535);
 3242   match(ConI);
 3243 
 3244   format %{ %}
 3245   interface(CONST_INTER);
 3246 %}
 3247 
 3248 // Constant for byte-wide masking
 3249 operand immL_255()
 3250 %{
 3251   predicate(n-&gt;get_long() == 255);
 3252   match(ConL);
 3253 
 3254   format %{ %}
 3255   interface(CONST_INTER);
 3256 %}
 3257 
 3258 // Constant for short-wide masking
 3259 operand immL_65535()
 3260 %{
 3261   predicate(n-&gt;get_long() == 65535);
 3262   match(ConL);
 3263 
 3264   format %{ %}
 3265   interface(CONST_INTER);
 3266 %}
 3267 
 3268 // Register Operands
 3269 // Integer Register
 3270 operand rRegI()
 3271 %{
 3272   constraint(ALLOC_IN_RC(int_reg));
 3273   match(RegI);
 3274 
 3275   match(rax_RegI);
 3276   match(rbx_RegI);
 3277   match(rcx_RegI);
 3278   match(rdx_RegI);
 3279   match(rdi_RegI);
 3280 
 3281   format %{ %}
 3282   interface(REG_INTER);
 3283 %}
 3284 
 3285 // Special Registers
 3286 operand rax_RegI()
 3287 %{
 3288   constraint(ALLOC_IN_RC(int_rax_reg));
 3289   match(RegI);
 3290   match(rRegI);
 3291 
 3292   format %{ &quot;RAX&quot; %}
 3293   interface(REG_INTER);
 3294 %}
 3295 
 3296 // Special Registers
 3297 operand rbx_RegI()
 3298 %{
 3299   constraint(ALLOC_IN_RC(int_rbx_reg));
 3300   match(RegI);
 3301   match(rRegI);
 3302 
 3303   format %{ &quot;RBX&quot; %}
 3304   interface(REG_INTER);
 3305 %}
 3306 
 3307 operand rcx_RegI()
 3308 %{
 3309   constraint(ALLOC_IN_RC(int_rcx_reg));
 3310   match(RegI);
 3311   match(rRegI);
 3312 
 3313   format %{ &quot;RCX&quot; %}
 3314   interface(REG_INTER);
 3315 %}
 3316 
 3317 operand rdx_RegI()
 3318 %{
 3319   constraint(ALLOC_IN_RC(int_rdx_reg));
 3320   match(RegI);
 3321   match(rRegI);
 3322 
 3323   format %{ &quot;RDX&quot; %}
 3324   interface(REG_INTER);
 3325 %}
 3326 
 3327 operand rdi_RegI()
 3328 %{
 3329   constraint(ALLOC_IN_RC(int_rdi_reg));
 3330   match(RegI);
 3331   match(rRegI);
 3332 
 3333   format %{ &quot;RDI&quot; %}
 3334   interface(REG_INTER);
 3335 %}
 3336 
 3337 operand no_rcx_RegI()
 3338 %{
 3339   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3340   match(RegI);
 3341   match(rax_RegI);
 3342   match(rbx_RegI);
 3343   match(rdx_RegI);
 3344   match(rdi_RegI);
 3345 
 3346   format %{ %}
 3347   interface(REG_INTER);
 3348 %}
 3349 
 3350 operand no_rax_rdx_RegI()
 3351 %{
 3352   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3353   match(RegI);
 3354   match(rbx_RegI);
 3355   match(rcx_RegI);
 3356   match(rdi_RegI);
 3357 
 3358   format %{ %}
 3359   interface(REG_INTER);
 3360 %}
 3361 
 3362 // Pointer Register
 3363 operand any_RegP()
 3364 %{
 3365   constraint(ALLOC_IN_RC(any_reg));
 3366   match(RegP);
 3367   match(rax_RegP);
 3368   match(rbx_RegP);
 3369   match(rdi_RegP);
 3370   match(rsi_RegP);
 3371   match(rbp_RegP);
 3372   match(r15_RegP);
 3373   match(rRegP);
 3374 
 3375   format %{ %}
 3376   interface(REG_INTER);
 3377 %}
 3378 
 3379 operand rRegP()
 3380 %{
 3381   constraint(ALLOC_IN_RC(ptr_reg));
 3382   match(RegP);
 3383   match(rax_RegP);
 3384   match(rbx_RegP);
 3385   match(rdi_RegP);
 3386   match(rsi_RegP);
 3387   match(rbp_RegP);  // See Q&amp;A below about
 3388   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3389 
 3390   format %{ %}
 3391   interface(REG_INTER);
 3392 %}
 3393 
 3394 operand rRegN() %{
 3395   constraint(ALLOC_IN_RC(int_reg));
 3396   match(RegN);
 3397 
 3398   format %{ %}
 3399   interface(REG_INTER);
 3400 %}
 3401 
 3402 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3403 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3404 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3405 // The output of an instruction is controlled by the allocator, which respects
 3406 // register class masks, not match rules.  Unless an instruction mentions
 3407 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3408 // by the allocator as an input.
 3409 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3410 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3411 // result, RBP is not included in the output of the instruction either.
 3412 
 3413 operand no_rax_RegP()
 3414 %{
 3415   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3416   match(RegP);
 3417   match(rbx_RegP);
 3418   match(rsi_RegP);
 3419   match(rdi_RegP);
 3420 
 3421   format %{ %}
 3422   interface(REG_INTER);
 3423 %}
 3424 
 3425 // This operand is not allowed to use RBP even if
 3426 // RBP is not used to hold the frame pointer.
 3427 operand no_rbp_RegP()
 3428 %{
 3429   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3430   match(RegP);
 3431   match(rbx_RegP);
 3432   match(rsi_RegP);
 3433   match(rdi_RegP);
 3434 
 3435   format %{ %}
 3436   interface(REG_INTER);
 3437 %}
 3438 
 3439 operand no_rax_rbx_RegP()
 3440 %{
 3441   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3442   match(RegP);
 3443   match(rsi_RegP);
 3444   match(rdi_RegP);
 3445 
 3446   format %{ %}
 3447   interface(REG_INTER);
 3448 %}
 3449 
 3450 // Special Registers
 3451 // Return a pointer value
 3452 operand rax_RegP()
 3453 %{
 3454   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3455   match(RegP);
 3456   match(rRegP);
 3457 
 3458   format %{ %}
 3459   interface(REG_INTER);
 3460 %}
 3461 
 3462 // Special Registers
 3463 // Return a compressed pointer value
 3464 operand rax_RegN()
 3465 %{
 3466   constraint(ALLOC_IN_RC(int_rax_reg));
 3467   match(RegN);
 3468   match(rRegN);
 3469 
 3470   format %{ %}
 3471   interface(REG_INTER);
 3472 %}
 3473 
 3474 // Used in AtomicAdd
 3475 operand rbx_RegP()
 3476 %{
 3477   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3478   match(RegP);
 3479   match(rRegP);
 3480 
 3481   format %{ %}
 3482   interface(REG_INTER);
 3483 %}
 3484 
 3485 operand rsi_RegP()
 3486 %{
 3487   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3488   match(RegP);
 3489   match(rRegP);
 3490 
 3491   format %{ %}
 3492   interface(REG_INTER);
 3493 %}
 3494 
 3495 operand rbp_RegP()
 3496 %{
 3497   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3498   match(RegP);
 3499   match(rRegP);
 3500 
 3501   format %{ %}
 3502   interface(REG_INTER);
 3503 %}
 3504 
 3505 // Used in rep stosq
 3506 operand rdi_RegP()
 3507 %{
 3508   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3509   match(RegP);
 3510   match(rRegP);
 3511 
 3512   format %{ %}
 3513   interface(REG_INTER);
 3514 %}
 3515 
 3516 operand r15_RegP()
 3517 %{
 3518   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3519   match(RegP);
 3520   match(rRegP);
 3521 
 3522   format %{ %}
 3523   interface(REG_INTER);
 3524 %}
 3525 
 3526 operand rRegL()
 3527 %{
 3528   constraint(ALLOC_IN_RC(long_reg));
 3529   match(RegL);
 3530   match(rax_RegL);
 3531   match(rdx_RegL);
 3532 
 3533   format %{ %}
 3534   interface(REG_INTER);
 3535 %}
 3536 
 3537 // Special Registers
 3538 operand no_rax_rdx_RegL()
 3539 %{
 3540   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3541   match(RegL);
 3542   match(rRegL);
 3543 
 3544   format %{ %}
 3545   interface(REG_INTER);
 3546 %}
 3547 
 3548 operand no_rax_RegL()
 3549 %{
 3550   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3551   match(RegL);
 3552   match(rRegL);
 3553   match(rdx_RegL);
 3554 
 3555   format %{ %}
 3556   interface(REG_INTER);
 3557 %}
 3558 
 3559 operand no_rcx_RegL()
 3560 %{
 3561   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3562   match(RegL);
 3563   match(rRegL);
 3564 
 3565   format %{ %}
 3566   interface(REG_INTER);
 3567 %}
 3568 
 3569 operand rax_RegL()
 3570 %{
 3571   constraint(ALLOC_IN_RC(long_rax_reg));
 3572   match(RegL);
 3573   match(rRegL);
 3574 
 3575   format %{ &quot;RAX&quot; %}
 3576   interface(REG_INTER);
 3577 %}
 3578 
 3579 operand rcx_RegL()
 3580 %{
 3581   constraint(ALLOC_IN_RC(long_rcx_reg));
 3582   match(RegL);
 3583   match(rRegL);
 3584 
 3585   format %{ %}
 3586   interface(REG_INTER);
 3587 %}
 3588 
 3589 operand rdx_RegL()
 3590 %{
 3591   constraint(ALLOC_IN_RC(long_rdx_reg));
 3592   match(RegL);
 3593   match(rRegL);
 3594 
 3595   format %{ %}
 3596   interface(REG_INTER);
 3597 %}
 3598 
 3599 // Flags register, used as output of compare instructions
 3600 operand rFlagsReg()
 3601 %{
 3602   constraint(ALLOC_IN_RC(int_flags));
 3603   match(RegFlags);
 3604 
 3605   format %{ &quot;RFLAGS&quot; %}
 3606   interface(REG_INTER);
 3607 %}
 3608 
 3609 // Flags register, used as output of FLOATING POINT compare instructions
 3610 operand rFlagsRegU()
 3611 %{
 3612   constraint(ALLOC_IN_RC(int_flags));
 3613   match(RegFlags);
 3614 
 3615   format %{ &quot;RFLAGS_U&quot; %}
 3616   interface(REG_INTER);
 3617 %}
 3618 
 3619 operand rFlagsRegUCF() %{
 3620   constraint(ALLOC_IN_RC(int_flags));
 3621   match(RegFlags);
 3622   predicate(false);
 3623 
 3624   format %{ &quot;RFLAGS_U_CF&quot; %}
 3625   interface(REG_INTER);
 3626 %}
 3627 
 3628 // Float register operands
 3629 operand regF() %{
 3630    constraint(ALLOC_IN_RC(float_reg));
 3631    match(RegF);
 3632 
 3633    format %{ %}
 3634    interface(REG_INTER);
 3635 %}
 3636 
 3637 // Float register operands
 3638 operand legRegF() %{
 3639    constraint(ALLOC_IN_RC(float_reg_legacy));
 3640    match(RegF);
 3641 
 3642    format %{ %}
 3643    interface(REG_INTER);
 3644 %}
 3645 
 3646 // Float register operands
 3647 operand vlRegF() %{
 3648    constraint(ALLOC_IN_RC(float_reg_vl));
 3649    match(RegF);
 3650 
 3651    format %{ %}
 3652    interface(REG_INTER);
 3653 %}
 3654 
 3655 // Double register operands
 3656 operand regD() %{
 3657    constraint(ALLOC_IN_RC(double_reg));
 3658    match(RegD);
 3659 
 3660    format %{ %}
 3661    interface(REG_INTER);
 3662 %}
 3663 
 3664 // Double register operands
 3665 operand legRegD() %{
 3666    constraint(ALLOC_IN_RC(double_reg_legacy));
 3667    match(RegD);
 3668 
 3669    format %{ %}
 3670    interface(REG_INTER);
 3671 %}
 3672 
 3673 // Double register operands
 3674 operand vlRegD() %{
 3675    constraint(ALLOC_IN_RC(double_reg_vl));
 3676    match(RegD);
 3677 
 3678    format %{ %}
 3679    interface(REG_INTER);
 3680 %}
 3681 
 3682 //----------Memory Operands----------------------------------------------------
 3683 // Direct Memory Operand
 3684 // operand direct(immP addr)
 3685 // %{
 3686 //   match(addr);
 3687 
 3688 //   format %{ &quot;[$addr]&quot; %}
 3689 //   interface(MEMORY_INTER) %{
 3690 //     base(0xFFFFFFFF);
 3691 //     index(0x4);
 3692 //     scale(0x0);
 3693 //     disp($addr);
 3694 //   %}
 3695 // %}
 3696 
 3697 // Indirect Memory Operand
 3698 operand indirect(any_RegP reg)
 3699 %{
 3700   constraint(ALLOC_IN_RC(ptr_reg));
 3701   match(reg);
 3702 
 3703   format %{ &quot;[$reg]&quot; %}
 3704   interface(MEMORY_INTER) %{
 3705     base($reg);
 3706     index(0x4);
 3707     scale(0x0);
 3708     disp(0x0);
 3709   %}
 3710 %}
 3711 
 3712 // Indirect Memory Plus Short Offset Operand
 3713 operand indOffset8(any_RegP reg, immL8 off)
 3714 %{
 3715   constraint(ALLOC_IN_RC(ptr_reg));
 3716   match(AddP reg off);
 3717 
 3718   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3719   interface(MEMORY_INTER) %{
 3720     base($reg);
 3721     index(0x4);
 3722     scale(0x0);
 3723     disp($off);
 3724   %}
 3725 %}
 3726 
 3727 // Indirect Memory Plus Long Offset Operand
 3728 operand indOffset32(any_RegP reg, immL32 off)
 3729 %{
 3730   constraint(ALLOC_IN_RC(ptr_reg));
 3731   match(AddP reg off);
 3732 
 3733   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3734   interface(MEMORY_INTER) %{
 3735     base($reg);
 3736     index(0x4);
 3737     scale(0x0);
 3738     disp($off);
 3739   %}
 3740 %}
 3741 
 3742 // Indirect Memory Plus Index Register Plus Offset Operand
 3743 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3744 %{
 3745   constraint(ALLOC_IN_RC(ptr_reg));
 3746   match(AddP (AddP reg lreg) off);
 3747 
 3748   op_cost(10);
 3749   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3750   interface(MEMORY_INTER) %{
 3751     base($reg);
 3752     index($lreg);
 3753     scale(0x0);
 3754     disp($off);
 3755   %}
 3756 %}
 3757 
 3758 // Indirect Memory Plus Index Register Plus Offset Operand
 3759 operand indIndex(any_RegP reg, rRegL lreg)
 3760 %{
 3761   constraint(ALLOC_IN_RC(ptr_reg));
 3762   match(AddP reg lreg);
 3763 
 3764   op_cost(10);
 3765   format %{&quot;[$reg + $lreg]&quot; %}
 3766   interface(MEMORY_INTER) %{
 3767     base($reg);
 3768     index($lreg);
 3769     scale(0x0);
 3770     disp(0x0);
 3771   %}
 3772 %}
 3773 
 3774 // Indirect Memory Times Scale Plus Index Register
 3775 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3776 %{
 3777   constraint(ALLOC_IN_RC(ptr_reg));
 3778   match(AddP reg (LShiftL lreg scale));
 3779 
 3780   op_cost(10);
 3781   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3782   interface(MEMORY_INTER) %{
 3783     base($reg);
 3784     index($lreg);
 3785     scale($scale);
 3786     disp(0x0);
 3787   %}
 3788 %}
 3789 
 3790 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3791 %{
 3792   constraint(ALLOC_IN_RC(ptr_reg));
 3793   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3794   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3795 
 3796   op_cost(10);
 3797   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3798   interface(MEMORY_INTER) %{
 3799     base($reg);
 3800     index($idx);
 3801     scale($scale);
 3802     disp(0x0);
 3803   %}
 3804 %}
 3805 
 3806 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3807 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3808 %{
 3809   constraint(ALLOC_IN_RC(ptr_reg));
 3810   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3811 
 3812   op_cost(10);
 3813   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3814   interface(MEMORY_INTER) %{
 3815     base($reg);
 3816     index($lreg);
 3817     scale($scale);
 3818     disp($off);
 3819   %}
 3820 %}
 3821 
 3822 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3823 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3824 %{
 3825   constraint(ALLOC_IN_RC(ptr_reg));
 3826   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3827   match(AddP (AddP reg (ConvI2L idx)) off);
 3828 
 3829   op_cost(10);
 3830   format %{&quot;[$reg + $off + $idx]&quot; %}
 3831   interface(MEMORY_INTER) %{
 3832     base($reg);
 3833     index($idx);
 3834     scale(0x0);
 3835     disp($off);
 3836   %}
 3837 %}
 3838 
 3839 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3840 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3841 %{
 3842   constraint(ALLOC_IN_RC(ptr_reg));
 3843   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3844   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3845 
 3846   op_cost(10);
 3847   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3848   interface(MEMORY_INTER) %{
 3849     base($reg);
 3850     index($idx);
 3851     scale($scale);
 3852     disp($off);
 3853   %}
 3854 %}
 3855 
 3856 // Indirect Narrow Oop Operand
 3857 operand indCompressedOop(rRegN reg) %{
 3858   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3859   constraint(ALLOC_IN_RC(ptr_reg));
 3860   match(DecodeN reg);
 3861 
 3862   op_cost(10);
 3863   format %{&quot;[R12 + $reg &lt;&lt; 3] (compressed oop addressing)&quot; %}
 3864   interface(MEMORY_INTER) %{
 3865     base(0xc); // R12
 3866     index($reg);
 3867     scale(0x3);
 3868     disp(0x0);
 3869   %}
 3870 %}
 3871 
 3872 // Indirect Narrow Oop Plus Offset Operand
 3873 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3874 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3875 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3876   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3877   constraint(ALLOC_IN_RC(ptr_reg));
 3878   match(AddP (DecodeN reg) off);
 3879 
 3880   op_cost(10);
 3881   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3882   interface(MEMORY_INTER) %{
 3883     base(0xc); // R12
 3884     index($reg);
 3885     scale(0x3);
 3886     disp($off);
 3887   %}
 3888 %}
 3889 
 3890 // Indirect Memory Operand
 3891 operand indirectNarrow(rRegN reg)
 3892 %{
 3893   predicate(CompressedOops::shift() == 0);
 3894   constraint(ALLOC_IN_RC(ptr_reg));
 3895   match(DecodeN reg);
 3896 
 3897   format %{ &quot;[$reg]&quot; %}
 3898   interface(MEMORY_INTER) %{
 3899     base($reg);
 3900     index(0x4);
 3901     scale(0x0);
 3902     disp(0x0);
 3903   %}
 3904 %}
 3905 
 3906 // Indirect Memory Plus Short Offset Operand
 3907 operand indOffset8Narrow(rRegN reg, immL8 off)
 3908 %{
 3909   predicate(CompressedOops::shift() == 0);
 3910   constraint(ALLOC_IN_RC(ptr_reg));
 3911   match(AddP (DecodeN reg) off);
 3912 
 3913   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3914   interface(MEMORY_INTER) %{
 3915     base($reg);
 3916     index(0x4);
 3917     scale(0x0);
 3918     disp($off);
 3919   %}
 3920 %}
 3921 
 3922 // Indirect Memory Plus Long Offset Operand
 3923 operand indOffset32Narrow(rRegN reg, immL32 off)
 3924 %{
 3925   predicate(CompressedOops::shift() == 0);
 3926   constraint(ALLOC_IN_RC(ptr_reg));
 3927   match(AddP (DecodeN reg) off);
 3928 
 3929   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3930   interface(MEMORY_INTER) %{
 3931     base($reg);
 3932     index(0x4);
 3933     scale(0x0);
 3934     disp($off);
 3935   %}
 3936 %}
 3937 
 3938 // Indirect Memory Plus Index Register Plus Offset Operand
 3939 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3940 %{
 3941   predicate(CompressedOops::shift() == 0);
 3942   constraint(ALLOC_IN_RC(ptr_reg));
 3943   match(AddP (AddP (DecodeN reg) lreg) off);
 3944 
 3945   op_cost(10);
 3946   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3947   interface(MEMORY_INTER) %{
 3948     base($reg);
 3949     index($lreg);
 3950     scale(0x0);
 3951     disp($off);
 3952   %}
 3953 %}
 3954 
 3955 // Indirect Memory Plus Index Register Plus Offset Operand
 3956 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3957 %{
 3958   predicate(CompressedOops::shift() == 0);
 3959   constraint(ALLOC_IN_RC(ptr_reg));
 3960   match(AddP (DecodeN reg) lreg);
 3961 
 3962   op_cost(10);
 3963   format %{&quot;[$reg + $lreg]&quot; %}
 3964   interface(MEMORY_INTER) %{
 3965     base($reg);
 3966     index($lreg);
 3967     scale(0x0);
 3968     disp(0x0);
 3969   %}
 3970 %}
 3971 
 3972 // Indirect Memory Times Scale Plus Index Register
 3973 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 3974 %{
 3975   predicate(CompressedOops::shift() == 0);
 3976   constraint(ALLOC_IN_RC(ptr_reg));
 3977   match(AddP (DecodeN reg) (LShiftL lreg scale));
 3978 
 3979   op_cost(10);
 3980   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3981   interface(MEMORY_INTER) %{
 3982     base($reg);
 3983     index($lreg);
 3984     scale($scale);
 3985     disp(0x0);
 3986   %}
 3987 %}
 3988 
 3989 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3990 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 3991 %{
 3992   predicate(CompressedOops::shift() == 0);
 3993   constraint(ALLOC_IN_RC(ptr_reg));
 3994   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 3995 
 3996   op_cost(10);
 3997   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3998   interface(MEMORY_INTER) %{
 3999     base($reg);
 4000     index($lreg);
 4001     scale($scale);
 4002     disp($off);
 4003   %}
 4004 %}
 4005 
 4006 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4007 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4008 %{
 4009   constraint(ALLOC_IN_RC(ptr_reg));
 4010   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4011   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4012 
 4013   op_cost(10);
 4014   format %{&quot;[$reg + $off + $idx]&quot; %}
 4015   interface(MEMORY_INTER) %{
 4016     base($reg);
 4017     index($idx);
 4018     scale(0x0);
 4019     disp($off);
 4020   %}
 4021 %}
 4022 
 4023 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4024 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4025 %{
 4026   constraint(ALLOC_IN_RC(ptr_reg));
 4027   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4028   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4029 
 4030   op_cost(10);
 4031   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4032   interface(MEMORY_INTER) %{
 4033     base($reg);
 4034     index($idx);
 4035     scale($scale);
 4036     disp($off);
 4037   %}
 4038 %}
 4039 
 4040 //----------Special Memory Operands--------------------------------------------
 4041 // Stack Slot Operand - This operand is used for loading and storing temporary
 4042 //                      values on the stack where a match requires a value to
 4043 //                      flow through memory.
 4044 operand stackSlotP(sRegP reg)
 4045 %{
 4046   constraint(ALLOC_IN_RC(stack_slots));
 4047   // No match rule because this operand is only generated in matching
 4048 
 4049   format %{ &quot;[$reg]&quot; %}
 4050   interface(MEMORY_INTER) %{
 4051     base(0x4);   // RSP
 4052     index(0x4);  // No Index
 4053     scale(0x0);  // No Scale
 4054     disp($reg);  // Stack Offset
 4055   %}
 4056 %}
 4057 
 4058 operand stackSlotI(sRegI reg)
 4059 %{
 4060   constraint(ALLOC_IN_RC(stack_slots));
 4061   // No match rule because this operand is only generated in matching
 4062 
 4063   format %{ &quot;[$reg]&quot; %}
 4064   interface(MEMORY_INTER) %{
 4065     base(0x4);   // RSP
 4066     index(0x4);  // No Index
 4067     scale(0x0);  // No Scale
 4068     disp($reg);  // Stack Offset
 4069   %}
 4070 %}
 4071 
 4072 operand stackSlotF(sRegF reg)
 4073 %{
 4074   constraint(ALLOC_IN_RC(stack_slots));
 4075   // No match rule because this operand is only generated in matching
 4076 
 4077   format %{ &quot;[$reg]&quot; %}
 4078   interface(MEMORY_INTER) %{
 4079     base(0x4);   // RSP
 4080     index(0x4);  // No Index
 4081     scale(0x0);  // No Scale
 4082     disp($reg);  // Stack Offset
 4083   %}
 4084 %}
 4085 
 4086 operand stackSlotD(sRegD reg)
 4087 %{
 4088   constraint(ALLOC_IN_RC(stack_slots));
 4089   // No match rule because this operand is only generated in matching
 4090 
 4091   format %{ &quot;[$reg]&quot; %}
 4092   interface(MEMORY_INTER) %{
 4093     base(0x4);   // RSP
 4094     index(0x4);  // No Index
 4095     scale(0x0);  // No Scale
 4096     disp($reg);  // Stack Offset
 4097   %}
 4098 %}
 4099 operand stackSlotL(sRegL reg)
 4100 %{
 4101   constraint(ALLOC_IN_RC(stack_slots));
 4102   // No match rule because this operand is only generated in matching
 4103 
 4104   format %{ &quot;[$reg]&quot; %}
 4105   interface(MEMORY_INTER) %{
 4106     base(0x4);   // RSP
 4107     index(0x4);  // No Index
 4108     scale(0x0);  // No Scale
 4109     disp($reg);  // Stack Offset
 4110   %}
 4111 %}
 4112 
 4113 //----------Conditional Branch Operands----------------------------------------
 4114 // Comparison Op  - This is the operation of the comparison, and is limited to
 4115 //                  the following set of codes:
 4116 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4117 //
 4118 // Other attributes of the comparison, such as unsignedness, are specified
 4119 // by the comparison instruction that sets a condition code flags register.
 4120 // That result is represented by a flags operand whose subtype is appropriate
 4121 // to the unsignedness (etc.) of the comparison.
 4122 //
 4123 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4124 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4125 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4126 
 4127 // Comparision Code
 4128 operand cmpOp()
 4129 %{
 4130   match(Bool);
 4131 
 4132   format %{ &quot;&quot; %}
 4133   interface(COND_INTER) %{
 4134     equal(0x4, &quot;e&quot;);
 4135     not_equal(0x5, &quot;ne&quot;);
 4136     less(0xC, &quot;l&quot;);
 4137     greater_equal(0xD, &quot;ge&quot;);
 4138     less_equal(0xE, &quot;le&quot;);
 4139     greater(0xF, &quot;g&quot;);
 4140     overflow(0x0, &quot;o&quot;);
 4141     no_overflow(0x1, &quot;no&quot;);
 4142   %}
 4143 %}
 4144 
 4145 // Comparison Code, unsigned compare.  Used by FP also, with
 4146 // C2 (unordered) turned into GT or LT already.  The other bits
 4147 // C0 and C3 are turned into Carry &amp; Zero flags.
 4148 operand cmpOpU()
 4149 %{
 4150   match(Bool);
 4151 
 4152   format %{ &quot;&quot; %}
 4153   interface(COND_INTER) %{
 4154     equal(0x4, &quot;e&quot;);
 4155     not_equal(0x5, &quot;ne&quot;);
 4156     less(0x2, &quot;b&quot;);
 4157     greater_equal(0x3, &quot;nb&quot;);
 4158     less_equal(0x6, &quot;be&quot;);
 4159     greater(0x7, &quot;nbe&quot;);
 4160     overflow(0x0, &quot;o&quot;);
 4161     no_overflow(0x1, &quot;no&quot;);
 4162   %}
 4163 %}
 4164 
 4165 
 4166 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4167 operand cmpOpUCF() %{
 4168   match(Bool);
 4169   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4170             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4171             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4172             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4173   format %{ &quot;&quot; %}
 4174   interface(COND_INTER) %{
 4175     equal(0x4, &quot;e&quot;);
 4176     not_equal(0x5, &quot;ne&quot;);
 4177     less(0x2, &quot;b&quot;);
 4178     greater_equal(0x3, &quot;nb&quot;);
 4179     less_equal(0x6, &quot;be&quot;);
 4180     greater(0x7, &quot;nbe&quot;);
 4181     overflow(0x0, &quot;o&quot;);
 4182     no_overflow(0x1, &quot;no&quot;);
 4183   %}
 4184 %}
 4185 
 4186 
 4187 // Floating comparisons that can be fixed up with extra conditional jumps
 4188 operand cmpOpUCF2() %{
 4189   match(Bool);
 4190   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4191             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4192   format %{ &quot;&quot; %}
 4193   interface(COND_INTER) %{
 4194     equal(0x4, &quot;e&quot;);
 4195     not_equal(0x5, &quot;ne&quot;);
 4196     less(0x2, &quot;b&quot;);
 4197     greater_equal(0x3, &quot;nb&quot;);
 4198     less_equal(0x6, &quot;be&quot;);
 4199     greater(0x7, &quot;nbe&quot;);
 4200     overflow(0x0, &quot;o&quot;);
 4201     no_overflow(0x1, &quot;no&quot;);
 4202   %}
 4203 %}
 4204 
 4205 //----------OPERAND CLASSES----------------------------------------------------
 4206 // Operand Classes are groups of operands that are used as to simplify
 4207 // instruction definitions by not requiring the AD writer to specify separate
 4208 // instructions for every form of operand when the instruction accepts
 4209 // multiple operand types with the same basic encoding and format.  The classic
 4210 // case of this is memory operands.
 4211 
 4212 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4213                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4214                indCompressedOop, indCompressedOopOffset,
 4215                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4216                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4217                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4218 
 4219 //----------PIPELINE-----------------------------------------------------------
 4220 // Rules which define the behavior of the target architectures pipeline.
 4221 pipeline %{
 4222 
 4223 //----------ATTRIBUTES---------------------------------------------------------
 4224 attributes %{
 4225   variable_size_instructions;        // Fixed size instructions
 4226   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4227   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4228   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4229   instruction_fetch_units = 1;       // of 16 bytes
 4230 
 4231   // List of nop instructions
 4232   nops( MachNop );
 4233 %}
 4234 
 4235 //----------RESOURCES----------------------------------------------------------
 4236 // Resources are the functional units available to the machine
 4237 
 4238 // Generic P2/P3 pipeline
 4239 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4240 // 3 instructions decoded per cycle.
 4241 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4242 // 3 ALU op, only ALU0 handles mul instructions.
 4243 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4244            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4245            BR, FPU,
 4246            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4247 
 4248 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4249 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4250 
 4251 // Generic P2/P3 pipeline
 4252 pipe_desc(S0, S1, S2, S3, S4, S5);
 4253 
 4254 //----------PIPELINE CLASSES---------------------------------------------------
 4255 // Pipeline Classes describe the stages in which input and output are
 4256 // referenced by the hardware pipeline.
 4257 
 4258 // Naming convention: ialu or fpu
 4259 // Then: _reg
 4260 // Then: _reg if there is a 2nd register
 4261 // Then: _long if it&#39;s a pair of instructions implementing a long
 4262 // Then: _fat if it requires the big decoder
 4263 //   Or: _mem if it requires the big decoder and a memory unit.
 4264 
 4265 // Integer ALU reg operation
 4266 pipe_class ialu_reg(rRegI dst)
 4267 %{
 4268     single_instruction;
 4269     dst    : S4(write);
 4270     dst    : S3(read);
 4271     DECODE : S0;        // any decoder
 4272     ALU    : S3;        // any alu
 4273 %}
 4274 
 4275 // Long ALU reg operation
 4276 pipe_class ialu_reg_long(rRegL dst)
 4277 %{
 4278     instruction_count(2);
 4279     dst    : S4(write);
 4280     dst    : S3(read);
 4281     DECODE : S0(2);     // any 2 decoders
 4282     ALU    : S3(2);     // both alus
 4283 %}
 4284 
 4285 // Integer ALU reg operation using big decoder
 4286 pipe_class ialu_reg_fat(rRegI dst)
 4287 %{
 4288     single_instruction;
 4289     dst    : S4(write);
 4290     dst    : S3(read);
 4291     D0     : S0;        // big decoder only
 4292     ALU    : S3;        // any alu
 4293 %}
 4294 
 4295 // Long ALU reg operation using big decoder
 4296 pipe_class ialu_reg_long_fat(rRegL dst)
 4297 %{
 4298     instruction_count(2);
 4299     dst    : S4(write);
 4300     dst    : S3(read);
 4301     D0     : S0(2);     // big decoder only; twice
 4302     ALU    : S3(2);     // any 2 alus
 4303 %}
 4304 
 4305 // Integer ALU reg-reg operation
 4306 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4307 %{
 4308     single_instruction;
 4309     dst    : S4(write);
 4310     src    : S3(read);
 4311     DECODE : S0;        // any decoder
 4312     ALU    : S3;        // any alu
 4313 %}
 4314 
 4315 // Long ALU reg-reg operation
 4316 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4317 %{
 4318     instruction_count(2);
 4319     dst    : S4(write);
 4320     src    : S3(read);
 4321     DECODE : S0(2);     // any 2 decoders
 4322     ALU    : S3(2);     // both alus
 4323 %}
 4324 
 4325 // Integer ALU reg-reg operation
 4326 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4327 %{
 4328     single_instruction;
 4329     dst    : S4(write);
 4330     src    : S3(read);
 4331     D0     : S0;        // big decoder only
 4332     ALU    : S3;        // any alu
 4333 %}
 4334 
 4335 // Long ALU reg-reg operation
 4336 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4337 %{
 4338     instruction_count(2);
 4339     dst    : S4(write);
 4340     src    : S3(read);
 4341     D0     : S0(2);     // big decoder only; twice
 4342     ALU    : S3(2);     // both alus
 4343 %}
 4344 
 4345 // Integer ALU reg-mem operation
 4346 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4347 %{
 4348     single_instruction;
 4349     dst    : S5(write);
 4350     mem    : S3(read);
 4351     D0     : S0;        // big decoder only
 4352     ALU    : S4;        // any alu
 4353     MEM    : S3;        // any mem
 4354 %}
 4355 
 4356 // Integer mem operation (prefetch)
 4357 pipe_class ialu_mem(memory mem)
 4358 %{
 4359     single_instruction;
 4360     mem    : S3(read);
 4361     D0     : S0;        // big decoder only
 4362     MEM    : S3;        // any mem
 4363 %}
 4364 
 4365 // Integer Store to Memory
 4366 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4367 %{
 4368     single_instruction;
 4369     mem    : S3(read);
 4370     src    : S5(read);
 4371     D0     : S0;        // big decoder only
 4372     ALU    : S4;        // any alu
 4373     MEM    : S3;
 4374 %}
 4375 
 4376 // // Long Store to Memory
 4377 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4378 // %{
 4379 //     instruction_count(2);
 4380 //     mem    : S3(read);
 4381 //     src    : S5(read);
 4382 //     D0     : S0(2);          // big decoder only; twice
 4383 //     ALU    : S4(2);     // any 2 alus
 4384 //     MEM    : S3(2);  // Both mems
 4385 // %}
 4386 
 4387 // Integer Store to Memory
 4388 pipe_class ialu_mem_imm(memory mem)
 4389 %{
 4390     single_instruction;
 4391     mem    : S3(read);
 4392     D0     : S0;        // big decoder only
 4393     ALU    : S4;        // any alu
 4394     MEM    : S3;
 4395 %}
 4396 
 4397 // Integer ALU0 reg-reg operation
 4398 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4399 %{
 4400     single_instruction;
 4401     dst    : S4(write);
 4402     src    : S3(read);
 4403     D0     : S0;        // Big decoder only
 4404     ALU0   : S3;        // only alu0
 4405 %}
 4406 
 4407 // Integer ALU0 reg-mem operation
 4408 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4409 %{
 4410     single_instruction;
 4411     dst    : S5(write);
 4412     mem    : S3(read);
 4413     D0     : S0;        // big decoder only
 4414     ALU0   : S4;        // ALU0 only
 4415     MEM    : S3;        // any mem
 4416 %}
 4417 
 4418 // Integer ALU reg-reg operation
 4419 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4420 %{
 4421     single_instruction;
 4422     cr     : S4(write);
 4423     src1   : S3(read);
 4424     src2   : S3(read);
 4425     DECODE : S0;        // any decoder
 4426     ALU    : S3;        // any alu
 4427 %}
 4428 
 4429 // Integer ALU reg-imm operation
 4430 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4431 %{
 4432     single_instruction;
 4433     cr     : S4(write);
 4434     src1   : S3(read);
 4435     DECODE : S0;        // any decoder
 4436     ALU    : S3;        // any alu
 4437 %}
 4438 
 4439 // Integer ALU reg-mem operation
 4440 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4441 %{
 4442     single_instruction;
 4443     cr     : S4(write);
 4444     src1   : S3(read);
 4445     src2   : S3(read);
 4446     D0     : S0;        // big decoder only
 4447     ALU    : S4;        // any alu
 4448     MEM    : S3;
 4449 %}
 4450 
 4451 // Conditional move reg-reg
 4452 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4453 %{
 4454     instruction_count(4);
 4455     y      : S4(read);
 4456     q      : S3(read);
 4457     p      : S3(read);
 4458     DECODE : S0(4);     // any decoder
 4459 %}
 4460 
 4461 // Conditional move reg-reg
 4462 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4463 %{
 4464     single_instruction;
 4465     dst    : S4(write);
 4466     src    : S3(read);
 4467     cr     : S3(read);
 4468     DECODE : S0;        // any decoder
 4469 %}
 4470 
 4471 // Conditional move reg-mem
 4472 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4473 %{
 4474     single_instruction;
 4475     dst    : S4(write);
 4476     src    : S3(read);
 4477     cr     : S3(read);
 4478     DECODE : S0;        // any decoder
 4479     MEM    : S3;
 4480 %}
 4481 
 4482 // Conditional move reg-reg long
 4483 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4484 %{
 4485     single_instruction;
 4486     dst    : S4(write);
 4487     src    : S3(read);
 4488     cr     : S3(read);
 4489     DECODE : S0(2);     // any 2 decoders
 4490 %}
 4491 
 4492 // XXX
 4493 // // Conditional move double reg-reg
 4494 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4495 // %{
 4496 //     single_instruction;
 4497 //     dst    : S4(write);
 4498 //     src    : S3(read);
 4499 //     cr     : S3(read);
 4500 //     DECODE : S0;     // any decoder
 4501 // %}
 4502 
 4503 // Float reg-reg operation
 4504 pipe_class fpu_reg(regD dst)
 4505 %{
 4506     instruction_count(2);
 4507     dst    : S3(read);
 4508     DECODE : S0(2);     // any 2 decoders
 4509     FPU    : S3;
 4510 %}
 4511 
 4512 // Float reg-reg operation
 4513 pipe_class fpu_reg_reg(regD dst, regD src)
 4514 %{
 4515     instruction_count(2);
 4516     dst    : S4(write);
 4517     src    : S3(read);
 4518     DECODE : S0(2);     // any 2 decoders
 4519     FPU    : S3;
 4520 %}
 4521 
 4522 // Float reg-reg operation
 4523 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4524 %{
 4525     instruction_count(3);
 4526     dst    : S4(write);
 4527     src1   : S3(read);
 4528     src2   : S3(read);
 4529     DECODE : S0(3);     // any 3 decoders
 4530     FPU    : S3(2);
 4531 %}
 4532 
 4533 // Float reg-reg operation
 4534 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4535 %{
 4536     instruction_count(4);
 4537     dst    : S4(write);
 4538     src1   : S3(read);
 4539     src2   : S3(read);
 4540     src3   : S3(read);
 4541     DECODE : S0(4);     // any 3 decoders
 4542     FPU    : S3(2);
 4543 %}
 4544 
 4545 // Float reg-reg operation
 4546 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4547 %{
 4548     instruction_count(4);
 4549     dst    : S4(write);
 4550     src1   : S3(read);
 4551     src2   : S3(read);
 4552     src3   : S3(read);
 4553     DECODE : S1(3);     // any 3 decoders
 4554     D0     : S0;        // Big decoder only
 4555     FPU    : S3(2);
 4556     MEM    : S3;
 4557 %}
 4558 
 4559 // Float reg-mem operation
 4560 pipe_class fpu_reg_mem(regD dst, memory mem)
 4561 %{
 4562     instruction_count(2);
 4563     dst    : S5(write);
 4564     mem    : S3(read);
 4565     D0     : S0;        // big decoder only
 4566     DECODE : S1;        // any decoder for FPU POP
 4567     FPU    : S4;
 4568     MEM    : S3;        // any mem
 4569 %}
 4570 
 4571 // Float reg-mem operation
 4572 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4573 %{
 4574     instruction_count(3);
 4575     dst    : S5(write);
 4576     src1   : S3(read);
 4577     mem    : S3(read);
 4578     D0     : S0;        // big decoder only
 4579     DECODE : S1(2);     // any decoder for FPU POP
 4580     FPU    : S4;
 4581     MEM    : S3;        // any mem
 4582 %}
 4583 
 4584 // Float mem-reg operation
 4585 pipe_class fpu_mem_reg(memory mem, regD src)
 4586 %{
 4587     instruction_count(2);
 4588     src    : S5(read);
 4589     mem    : S3(read);
 4590     DECODE : S0;        // any decoder for FPU PUSH
 4591     D0     : S1;        // big decoder only
 4592     FPU    : S4;
 4593     MEM    : S3;        // any mem
 4594 %}
 4595 
 4596 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4597 %{
 4598     instruction_count(3);
 4599     src1   : S3(read);
 4600     src2   : S3(read);
 4601     mem    : S3(read);
 4602     DECODE : S0(2);     // any decoder for FPU PUSH
 4603     D0     : S1;        // big decoder only
 4604     FPU    : S4;
 4605     MEM    : S3;        // any mem
 4606 %}
 4607 
 4608 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4609 %{
 4610     instruction_count(3);
 4611     src1   : S3(read);
 4612     src2   : S3(read);
 4613     mem    : S4(read);
 4614     DECODE : S0;        // any decoder for FPU PUSH
 4615     D0     : S0(2);     // big decoder only
 4616     FPU    : S4;
 4617     MEM    : S3(2);     // any mem
 4618 %}
 4619 
 4620 pipe_class fpu_mem_mem(memory dst, memory src1)
 4621 %{
 4622     instruction_count(2);
 4623     src1   : S3(read);
 4624     dst    : S4(read);
 4625     D0     : S0(2);     // big decoder only
 4626     MEM    : S3(2);     // any mem
 4627 %}
 4628 
 4629 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4630 %{
 4631     instruction_count(3);
 4632     src1   : S3(read);
 4633     src2   : S3(read);
 4634     dst    : S4(read);
 4635     D0     : S0(3);     // big decoder only
 4636     FPU    : S4;
 4637     MEM    : S3(3);     // any mem
 4638 %}
 4639 
 4640 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4641 %{
 4642     instruction_count(3);
 4643     src1   : S4(read);
 4644     mem    : S4(read);
 4645     DECODE : S0;        // any decoder for FPU PUSH
 4646     D0     : S0(2);     // big decoder only
 4647     FPU    : S4;
 4648     MEM    : S3(2);     // any mem
 4649 %}
 4650 
 4651 // Float load constant
 4652 pipe_class fpu_reg_con(regD dst)
 4653 %{
 4654     instruction_count(2);
 4655     dst    : S5(write);
 4656     D0     : S0;        // big decoder only for the load
 4657     DECODE : S1;        // any decoder for FPU POP
 4658     FPU    : S4;
 4659     MEM    : S3;        // any mem
 4660 %}
 4661 
 4662 // Float load constant
 4663 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4664 %{
 4665     instruction_count(3);
 4666     dst    : S5(write);
 4667     src    : S3(read);
 4668     D0     : S0;        // big decoder only for the load
 4669     DECODE : S1(2);     // any decoder for FPU POP
 4670     FPU    : S4;
 4671     MEM    : S3;        // any mem
 4672 %}
 4673 
 4674 // UnConditional branch
 4675 pipe_class pipe_jmp(label labl)
 4676 %{
 4677     single_instruction;
 4678     BR   : S3;
 4679 %}
 4680 
 4681 // Conditional branch
 4682 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4683 %{
 4684     single_instruction;
 4685     cr    : S1(read);
 4686     BR    : S3;
 4687 %}
 4688 
 4689 // Allocation idiom
 4690 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4691 %{
 4692     instruction_count(1); force_serialization;
 4693     fixed_latency(6);
 4694     heap_ptr : S3(read);
 4695     DECODE   : S0(3);
 4696     D0       : S2;
 4697     MEM      : S3;
 4698     ALU      : S3(2);
 4699     dst      : S5(write);
 4700     BR       : S5;
 4701 %}
 4702 
 4703 // Generic big/slow expanded idiom
 4704 pipe_class pipe_slow()
 4705 %{
 4706     instruction_count(10); multiple_bundles; force_serialization;
 4707     fixed_latency(100);
 4708     D0  : S0(2);
 4709     MEM : S3(2);
 4710 %}
 4711 
 4712 // The real do-nothing guy
 4713 pipe_class empty()
 4714 %{
 4715     instruction_count(0);
 4716 %}
 4717 
 4718 // Define the class for the Nop node
 4719 define
 4720 %{
 4721    MachNop = empty;
 4722 %}
 4723 
 4724 %}
 4725 
 4726 //----------INSTRUCTIONS-------------------------------------------------------
 4727 //
 4728 // match      -- States which machine-independent subtree may be replaced
 4729 //               by this instruction.
 4730 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4731 //               selection to identify a minimum cost tree of machine
 4732 //               instructions that matches a tree of machine-independent
 4733 //               instructions.
 4734 // format     -- A string providing the disassembly for this instruction.
 4735 //               The value of an instruction&#39;s operand may be inserted
 4736 //               by referring to it with a &#39;$&#39; prefix.
 4737 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4738 //               to within an encode class as $primary, $secondary, and $tertiary
 4739 //               rrspectively.  The primary opcode is commonly used to
 4740 //               indicate the type of machine instruction, while secondary
 4741 //               and tertiary are often used for prefix options or addressing
 4742 //               modes.
 4743 // ins_encode -- A list of encode classes with parameters. The encode class
 4744 //               name must have been defined in an &#39;enc_class&#39; specification
 4745 //               in the encode section of the architecture description.
 4746 
 4747 
 4748 //----------Load/Store/Move Instructions---------------------------------------
 4749 //----------Load Instructions--------------------------------------------------
 4750 
 4751 // Load Byte (8 bit signed)
 4752 instruct loadB(rRegI dst, memory mem)
 4753 %{
 4754   match(Set dst (LoadB mem));
 4755 
 4756   ins_cost(125);
 4757   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4758 
 4759   ins_encode %{
 4760     __ movsbl($dst$$Register, $mem$$Address);
 4761   %}
 4762 
 4763   ins_pipe(ialu_reg_mem);
 4764 %}
 4765 
 4766 // Load Byte (8 bit signed) into Long Register
 4767 instruct loadB2L(rRegL dst, memory mem)
 4768 %{
 4769   match(Set dst (ConvI2L (LoadB mem)));
 4770 
 4771   ins_cost(125);
 4772   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4773 
 4774   ins_encode %{
 4775     __ movsbq($dst$$Register, $mem$$Address);
 4776   %}
 4777 
 4778   ins_pipe(ialu_reg_mem);
 4779 %}
 4780 
 4781 // Load Unsigned Byte (8 bit UNsigned)
 4782 instruct loadUB(rRegI dst, memory mem)
 4783 %{
 4784   match(Set dst (LoadUB mem));
 4785 
 4786   ins_cost(125);
 4787   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4788 
 4789   ins_encode %{
 4790     __ movzbl($dst$$Register, $mem$$Address);
 4791   %}
 4792 
 4793   ins_pipe(ialu_reg_mem);
 4794 %}
 4795 
 4796 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4797 instruct loadUB2L(rRegL dst, memory mem)
 4798 %{
 4799   match(Set dst (ConvI2L (LoadUB mem)));
 4800 
 4801   ins_cost(125);
 4802   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4803 
 4804   ins_encode %{
 4805     __ movzbq($dst$$Register, $mem$$Address);
 4806   %}
 4807 
 4808   ins_pipe(ialu_reg_mem);
 4809 %}
 4810 
 4811 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4812 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4813   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4814   effect(KILL cr);
 4815 
 4816   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4817             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4818   ins_encode %{
 4819     Register Rdst = $dst$$Register;
 4820     __ movzbq(Rdst, $mem$$Address);
 4821     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4822   %}
 4823   ins_pipe(ialu_reg_mem);
 4824 %}
 4825 
 4826 // Load Short (16 bit signed)
 4827 instruct loadS(rRegI dst, memory mem)
 4828 %{
 4829   match(Set dst (LoadS mem));
 4830 
 4831   ins_cost(125);
 4832   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4833 
 4834   ins_encode %{
 4835     __ movswl($dst$$Register, $mem$$Address);
 4836   %}
 4837 
 4838   ins_pipe(ialu_reg_mem);
 4839 %}
 4840 
 4841 // Load Short (16 bit signed) to Byte (8 bit signed)
 4842 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4843   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4844 
 4845   ins_cost(125);
 4846   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4847   ins_encode %{
 4848     __ movsbl($dst$$Register, $mem$$Address);
 4849   %}
 4850   ins_pipe(ialu_reg_mem);
 4851 %}
 4852 
 4853 // Load Short (16 bit signed) into Long Register
 4854 instruct loadS2L(rRegL dst, memory mem)
 4855 %{
 4856   match(Set dst (ConvI2L (LoadS mem)));
 4857 
 4858   ins_cost(125);
 4859   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4860 
 4861   ins_encode %{
 4862     __ movswq($dst$$Register, $mem$$Address);
 4863   %}
 4864 
 4865   ins_pipe(ialu_reg_mem);
 4866 %}
 4867 
 4868 // Load Unsigned Short/Char (16 bit UNsigned)
 4869 instruct loadUS(rRegI dst, memory mem)
 4870 %{
 4871   match(Set dst (LoadUS mem));
 4872 
 4873   ins_cost(125);
 4874   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4875 
 4876   ins_encode %{
 4877     __ movzwl($dst$$Register, $mem$$Address);
 4878   %}
 4879 
 4880   ins_pipe(ialu_reg_mem);
 4881 %}
 4882 
 4883 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4884 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4885   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4886 
 4887   ins_cost(125);
 4888   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4889   ins_encode %{
 4890     __ movsbl($dst$$Register, $mem$$Address);
 4891   %}
 4892   ins_pipe(ialu_reg_mem);
 4893 %}
 4894 
 4895 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4896 instruct loadUS2L(rRegL dst, memory mem)
 4897 %{
 4898   match(Set dst (ConvI2L (LoadUS mem)));
 4899 
 4900   ins_cost(125);
 4901   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4902 
 4903   ins_encode %{
 4904     __ movzwq($dst$$Register, $mem$$Address);
 4905   %}
 4906 
 4907   ins_pipe(ialu_reg_mem);
 4908 %}
 4909 
 4910 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4911 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4912   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4913 
 4914   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4915   ins_encode %{
 4916     __ movzbq($dst$$Register, $mem$$Address);
 4917   %}
 4918   ins_pipe(ialu_reg_mem);
 4919 %}
 4920 
 4921 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4922 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4923   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4924   effect(KILL cr);
 4925 
 4926   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4927             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4928   ins_encode %{
 4929     Register Rdst = $dst$$Register;
 4930     __ movzwq(Rdst, $mem$$Address);
 4931     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4932   %}
 4933   ins_pipe(ialu_reg_mem);
 4934 %}
 4935 
 4936 // Load Integer
 4937 instruct loadI(rRegI dst, memory mem)
 4938 %{
 4939   match(Set dst (LoadI mem));
 4940 
 4941   ins_cost(125);
 4942   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4943 
 4944   ins_encode %{
 4945     __ movl($dst$$Register, $mem$$Address);
 4946   %}
 4947 
 4948   ins_pipe(ialu_reg_mem);
 4949 %}
 4950 
 4951 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4952 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4953   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4954 
 4955   ins_cost(125);
 4956   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4957   ins_encode %{
 4958     __ movsbl($dst$$Register, $mem$$Address);
 4959   %}
 4960   ins_pipe(ialu_reg_mem);
 4961 %}
 4962 
 4963 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4964 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4965   match(Set dst (AndI (LoadI mem) mask));
 4966 
 4967   ins_cost(125);
 4968   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 4969   ins_encode %{
 4970     __ movzbl($dst$$Register, $mem$$Address);
 4971   %}
 4972   ins_pipe(ialu_reg_mem);
 4973 %}
 4974 
 4975 // Load Integer (32 bit signed) to Short (16 bit signed)
 4976 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 4977   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 4978 
 4979   ins_cost(125);
 4980   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 4981   ins_encode %{
 4982     __ movswl($dst$$Register, $mem$$Address);
 4983   %}
 4984   ins_pipe(ialu_reg_mem);
 4985 %}
 4986 
 4987 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 4988 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 4989   match(Set dst (AndI (LoadI mem) mask));
 4990 
 4991   ins_cost(125);
 4992   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 4993   ins_encode %{
 4994     __ movzwl($dst$$Register, $mem$$Address);
 4995   %}
 4996   ins_pipe(ialu_reg_mem);
 4997 %}
 4998 
 4999 // Load Integer into Long Register
 5000 instruct loadI2L(rRegL dst, memory mem)
 5001 %{
 5002   match(Set dst (ConvI2L (LoadI mem)));
 5003 
 5004   ins_cost(125);
 5005   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 5006 
 5007   ins_encode %{
 5008     __ movslq($dst$$Register, $mem$$Address);
 5009   %}
 5010 
 5011   ins_pipe(ialu_reg_mem);
 5012 %}
 5013 
 5014 // Load Integer with mask 0xFF into Long Register
 5015 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5016   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5017 
 5018   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5019   ins_encode %{
 5020     __ movzbq($dst$$Register, $mem$$Address);
 5021   %}
 5022   ins_pipe(ialu_reg_mem);
 5023 %}
 5024 
 5025 // Load Integer with mask 0xFFFF into Long Register
 5026 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5027   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5028 
 5029   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5030   ins_encode %{
 5031     __ movzwq($dst$$Register, $mem$$Address);
 5032   %}
 5033   ins_pipe(ialu_reg_mem);
 5034 %}
 5035 
 5036 // Load Integer with a 31-bit mask into Long Register
 5037 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5038   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5039   effect(KILL cr);
 5040 
 5041   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5042             &quot;andl    $dst, $mask&quot; %}
 5043   ins_encode %{
 5044     Register Rdst = $dst$$Register;
 5045     __ movl(Rdst, $mem$$Address);
 5046     __ andl(Rdst, $mask$$constant);
 5047   %}
 5048   ins_pipe(ialu_reg_mem);
 5049 %}
 5050 
 5051 // Load Unsigned Integer into Long Register
 5052 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5053 %{
 5054   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5055 
 5056   ins_cost(125);
 5057   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5058 
 5059   ins_encode %{
 5060     __ movl($dst$$Register, $mem$$Address);
 5061   %}
 5062 
 5063   ins_pipe(ialu_reg_mem);
 5064 %}
 5065 
 5066 // Load Long
 5067 instruct loadL(rRegL dst, memory mem)
 5068 %{
 5069   match(Set dst (LoadL mem));
 5070 
 5071   ins_cost(125);
 5072   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5073 
 5074   ins_encode %{
 5075     __ movq($dst$$Register, $mem$$Address);
 5076   %}
 5077 
 5078   ins_pipe(ialu_reg_mem); // XXX
 5079 %}
 5080 
 5081 // Load Range
 5082 instruct loadRange(rRegI dst, memory mem)
 5083 %{
 5084   match(Set dst (LoadRange mem));
 5085 
 5086   ins_cost(125); // XXX
 5087   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5088   opcode(0x8B);
 5089   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5090   ins_pipe(ialu_reg_mem);
 5091 %}
 5092 
 5093 // Load Pointer
 5094 instruct loadP(rRegP dst, memory mem)
 5095 %{
 5096   match(Set dst (LoadP mem));
 5097   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5098 
 5099   ins_cost(125); // XXX
 5100   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5101   opcode(0x8B);
 5102   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5103   ins_pipe(ialu_reg_mem); // XXX
 5104 %}
 5105 
 5106 // Load Compressed Pointer
 5107 instruct loadN(rRegN dst, memory mem)
 5108 %{
 5109    match(Set dst (LoadN mem));
 5110 
 5111    ins_cost(125); // XXX
 5112    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5113    ins_encode %{
 5114      __ movl($dst$$Register, $mem$$Address);
 5115    %}
 5116    ins_pipe(ialu_reg_mem); // XXX
 5117 %}
 5118 
 5119 
 5120 // Load Klass Pointer
 5121 instruct loadKlass(rRegP dst, memory mem)
 5122 %{
 5123   match(Set dst (LoadKlass mem));
 5124 
 5125   ins_cost(125); // XXX
 5126   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5127   opcode(0x8B);
 5128   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5129   ins_pipe(ialu_reg_mem); // XXX
 5130 %}
 5131 
 5132 // Load narrow Klass Pointer
 5133 instruct loadNKlass(rRegN dst, memory mem)
 5134 %{
 5135   match(Set dst (LoadNKlass mem));
 5136 
 5137   ins_cost(125); // XXX
 5138   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5139   ins_encode %{
 5140     __ movl($dst$$Register, $mem$$Address);
 5141   %}
 5142   ins_pipe(ialu_reg_mem); // XXX
 5143 %}
 5144 
 5145 // Load Float
 5146 instruct loadF(regF dst, memory mem)
 5147 %{
 5148   match(Set dst (LoadF mem));
 5149 
 5150   ins_cost(145); // XXX
 5151   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5152   ins_encode %{
 5153     __ movflt($dst$$XMMRegister, $mem$$Address);
 5154   %}
 5155   ins_pipe(pipe_slow); // XXX
 5156 %}
 5157 
 5158 // Load Float
 5159 instruct MoveF2VL(vlRegF dst, regF src) %{
 5160   match(Set dst src);
 5161   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5162   ins_encode %{
 5163     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5164   %}
 5165   ins_pipe( fpu_reg_reg );
 5166 %}
 5167 
 5168 // Load Float
 5169 instruct MoveF2LEG(legRegF dst, regF src) %{
 5170   match(Set dst src);
 5171   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5172   ins_encode %{
 5173     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5174   %}
 5175   ins_pipe( fpu_reg_reg );
 5176 %}
 5177 
 5178 // Load Float
 5179 instruct MoveVL2F(regF dst, vlRegF src) %{
 5180   match(Set dst src);
 5181   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5182   ins_encode %{
 5183     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5184   %}
 5185   ins_pipe( fpu_reg_reg );
 5186 %}
 5187 
 5188 // Load Float
 5189 instruct MoveLEG2F(regF dst, legRegF src) %{
 5190   match(Set dst src);
 5191   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5192   ins_encode %{
 5193     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5194   %}
 5195   ins_pipe( fpu_reg_reg );
 5196 %}
 5197 
 5198 // Load Double
 5199 instruct loadD_partial(regD dst, memory mem)
 5200 %{
 5201   predicate(!UseXmmLoadAndClearUpper);
 5202   match(Set dst (LoadD mem));
 5203 
 5204   ins_cost(145); // XXX
 5205   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5206   ins_encode %{
 5207     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5208   %}
 5209   ins_pipe(pipe_slow); // XXX
 5210 %}
 5211 
 5212 instruct loadD(regD dst, memory mem)
 5213 %{
 5214   predicate(UseXmmLoadAndClearUpper);
 5215   match(Set dst (LoadD mem));
 5216 
 5217   ins_cost(145); // XXX
 5218   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5219   ins_encode %{
 5220     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5221   %}
 5222   ins_pipe(pipe_slow); // XXX
 5223 %}
 5224 
 5225 // Load Double
 5226 instruct MoveD2VL(vlRegD dst, regD src) %{
 5227   match(Set dst src);
 5228   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5229   ins_encode %{
 5230     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5231   %}
 5232   ins_pipe( fpu_reg_reg );
 5233 %}
 5234 
 5235 // Load Double
 5236 instruct MoveD2LEG(legRegD dst, regD src) %{
 5237   match(Set dst src);
 5238   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5239   ins_encode %{
 5240     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5241   %}
 5242   ins_pipe( fpu_reg_reg );
 5243 %}
 5244 
 5245 // Load Double
 5246 instruct MoveVL2D(regD dst, vlRegD src) %{
 5247   match(Set dst src);
 5248   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5249   ins_encode %{
 5250     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5251   %}
 5252   ins_pipe( fpu_reg_reg );
 5253 %}
 5254 
 5255 // Load Double
 5256 instruct MoveLEG2D(regD dst, legRegD src) %{
 5257   match(Set dst src);
 5258   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5259   ins_encode %{
 5260     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5261   %}
 5262   ins_pipe( fpu_reg_reg );
 5263 %}
 5264 
 5265 // Following pseudo code describes the algorithm for max[FD]:
 5266 // Min algorithm is on similar lines
 5267 //  btmp = (b &lt; +0.0) ? a : b
 5268 //  atmp = (b &lt; +0.0) ? b : a
 5269 //  Tmp  = Max_Float(atmp , btmp)
 5270 //  Res  = (atmp == NaN) ? atmp : Tmp
 5271 
 5272 // max = java.lang.Math.max(float a, float b)
 5273 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5274   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5275   match(Set dst (MaxF a b));
 5276   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5277   format %{
 5278      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5279      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5280      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5281      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5282      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5283   %}
 5284   ins_encode %{
 5285     int vector_len = Assembler::AVX_128bit;
 5286     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5287     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5288     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5289     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5290     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5291  %}
 5292   ins_pipe( pipe_slow );
 5293 %}
 5294 
 5295 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5296   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5297   match(Set dst (MaxF a b));
 5298   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5299 
 5300   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5301   ins_encode %{
 5302     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5303                     false /*min*/, true /*single*/);
 5304   %}
 5305   ins_pipe( pipe_slow );
 5306 %}
 5307 
 5308 // max = java.lang.Math.max(double a, double b)
 5309 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5310   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5311   match(Set dst (MaxD a b));
 5312   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5313   format %{
 5314      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5315      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5316      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5317      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5318      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5319   %}
 5320   ins_encode %{
 5321     int vector_len = Assembler::AVX_128bit;
 5322     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5323     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5324     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5325     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5326     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5327   %}
 5328   ins_pipe( pipe_slow );
 5329 %}
 5330 
 5331 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5332   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5333   match(Set dst (MaxD a b));
 5334   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5335 
 5336   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5337   ins_encode %{
 5338     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5339                     false /*min*/, false /*single*/);
 5340   %}
 5341   ins_pipe( pipe_slow );
 5342 %}
 5343 
 5344 // min = java.lang.Math.min(float a, float b)
 5345 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5346   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5347   match(Set dst (MinF a b));
 5348   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5349   format %{
 5350      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5351      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5352      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5353      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5354      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5355   %}
 5356   ins_encode %{
 5357     int vector_len = Assembler::AVX_128bit;
 5358     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5359     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5360     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5361     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5362     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5363   %}
 5364   ins_pipe( pipe_slow );
 5365 %}
 5366 
 5367 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5368   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5369   match(Set dst (MinF a b));
 5370   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5371 
 5372   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5373   ins_encode %{
 5374     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5375                     true /*min*/, true /*single*/);
 5376   %}
 5377   ins_pipe( pipe_slow );
 5378 %}
 5379 
 5380 // min = java.lang.Math.min(double a, double b)
 5381 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5382   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5383   match(Set dst (MinD a b));
 5384   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5385   format %{
 5386      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5387      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5388      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5389      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5390      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5391   %}
 5392   ins_encode %{
 5393     int vector_len = Assembler::AVX_128bit;
 5394     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5395     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5396     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5397     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5398     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5399   %}
 5400   ins_pipe( pipe_slow );
 5401 %}
 5402 
 5403 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5404   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5405   match(Set dst (MinD a b));
 5406   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5407 
 5408   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5409   ins_encode %{
 5410     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5411                     true /*min*/, false /*single*/);
 5412   %}
 5413   ins_pipe( pipe_slow );
 5414 %}
 5415 
 5416 // Load Effective Address
 5417 instruct leaP8(rRegP dst, indOffset8 mem)
 5418 %{
 5419   match(Set dst mem);
 5420 
 5421   ins_cost(110); // XXX
 5422   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5423   opcode(0x8D);
 5424   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5425   ins_pipe(ialu_reg_reg_fat);
 5426 %}
 5427 
 5428 instruct leaP32(rRegP dst, indOffset32 mem)
 5429 %{
 5430   match(Set dst mem);
 5431 
 5432   ins_cost(110);
 5433   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5434   opcode(0x8D);
 5435   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5436   ins_pipe(ialu_reg_reg_fat);
 5437 %}
 5438 
 5439 // instruct leaPIdx(rRegP dst, indIndex mem)
 5440 // %{
 5441 //   match(Set dst mem);
 5442 
 5443 //   ins_cost(110);
 5444 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5445 //   opcode(0x8D);
 5446 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5447 //   ins_pipe(ialu_reg_reg_fat);
 5448 // %}
 5449 
 5450 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5451 %{
 5452   match(Set dst mem);
 5453 
 5454   ins_cost(110);
 5455   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5456   opcode(0x8D);
 5457   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5458   ins_pipe(ialu_reg_reg_fat);
 5459 %}
 5460 
 5461 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5462 %{
 5463   match(Set dst mem);
 5464 
 5465   ins_cost(110);
 5466   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5467   opcode(0x8D);
 5468   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5469   ins_pipe(ialu_reg_reg_fat);
 5470 %}
 5471 
 5472 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5473 %{
 5474   match(Set dst mem);
 5475 
 5476   ins_cost(110);
 5477   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5478   opcode(0x8D);
 5479   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5480   ins_pipe(ialu_reg_reg_fat);
 5481 %}
 5482 
 5483 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5484 %{
 5485   match(Set dst mem);
 5486 
 5487   ins_cost(110);
 5488   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5489   opcode(0x8D);
 5490   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5491   ins_pipe(ialu_reg_reg_fat);
 5492 %}
 5493 
 5494 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5495 %{
 5496   match(Set dst mem);
 5497 
 5498   ins_cost(110);
 5499   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5500   opcode(0x8D);
 5501   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5502   ins_pipe(ialu_reg_reg_fat);
 5503 %}
 5504 
 5505 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5506 %{
 5507   match(Set dst mem);
 5508 
 5509   ins_cost(110);
 5510   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5511   opcode(0x8D);
 5512   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5513   ins_pipe(ialu_reg_reg_fat);
 5514 %}
 5515 
 5516 // Load Effective Address which uses Narrow (32-bits) oop
 5517 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5518 %{
 5519   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5520   match(Set dst mem);
 5521 
 5522   ins_cost(110);
 5523   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5524   opcode(0x8D);
 5525   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5526   ins_pipe(ialu_reg_reg_fat);
 5527 %}
 5528 
 5529 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5530 %{
 5531   predicate(CompressedOops::shift() == 0);
 5532   match(Set dst mem);
 5533 
 5534   ins_cost(110); // XXX
 5535   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5536   opcode(0x8D);
 5537   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5538   ins_pipe(ialu_reg_reg_fat);
 5539 %}
 5540 
 5541 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5542 %{
 5543   predicate(CompressedOops::shift() == 0);
 5544   match(Set dst mem);
 5545 
 5546   ins_cost(110);
 5547   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5548   opcode(0x8D);
 5549   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5550   ins_pipe(ialu_reg_reg_fat);
 5551 %}
 5552 
 5553 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5554 %{
 5555   predicate(CompressedOops::shift() == 0);
 5556   match(Set dst mem);
 5557 
 5558   ins_cost(110);
 5559   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5560   opcode(0x8D);
 5561   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5562   ins_pipe(ialu_reg_reg_fat);
 5563 %}
 5564 
 5565 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5566 %{
 5567   predicate(CompressedOops::shift() == 0);
 5568   match(Set dst mem);
 5569 
 5570   ins_cost(110);
 5571   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5572   opcode(0x8D);
 5573   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5574   ins_pipe(ialu_reg_reg_fat);
 5575 %}
 5576 
 5577 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5578 %{
 5579   predicate(CompressedOops::shift() == 0);
 5580   match(Set dst mem);
 5581 
 5582   ins_cost(110);
 5583   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5584   opcode(0x8D);
 5585   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5586   ins_pipe(ialu_reg_reg_fat);
 5587 %}
 5588 
 5589 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5590 %{
 5591   predicate(CompressedOops::shift() == 0);
 5592   match(Set dst mem);
 5593 
 5594   ins_cost(110);
 5595   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5596   opcode(0x8D);
 5597   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5598   ins_pipe(ialu_reg_reg_fat);
 5599 %}
 5600 
 5601 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5602 %{
 5603   predicate(CompressedOops::shift() == 0);
 5604   match(Set dst mem);
 5605 
 5606   ins_cost(110);
 5607   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5608   opcode(0x8D);
 5609   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5610   ins_pipe(ialu_reg_reg_fat);
 5611 %}
 5612 
 5613 instruct loadConI(rRegI dst, immI src)
 5614 %{
 5615   match(Set dst src);
 5616 
 5617   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5618   ins_encode(load_immI(dst, src));
 5619   ins_pipe(ialu_reg_fat); // XXX
 5620 %}
 5621 
 5622 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5623 %{
 5624   match(Set dst src);
 5625   effect(KILL cr);
 5626 
 5627   ins_cost(50);
 5628   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5629   opcode(0x33); /* + rd */
 5630   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5631   ins_pipe(ialu_reg);
 5632 %}
 5633 
 5634 instruct loadConL(rRegL dst, immL src)
 5635 %{
 5636   match(Set dst src);
 5637 
 5638   ins_cost(150);
 5639   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5640   ins_encode(load_immL(dst, src));
 5641   ins_pipe(ialu_reg);
 5642 %}
 5643 
 5644 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5645 %{
 5646   match(Set dst src);
 5647   effect(KILL cr);
 5648 
 5649   ins_cost(50);
 5650   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5651   opcode(0x33); /* + rd */
 5652   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5653   ins_pipe(ialu_reg); // XXX
 5654 %}
 5655 
 5656 instruct loadConUL32(rRegL dst, immUL32 src)
 5657 %{
 5658   match(Set dst src);
 5659 
 5660   ins_cost(60);
 5661   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5662   ins_encode(load_immUL32(dst, src));
 5663   ins_pipe(ialu_reg);
 5664 %}
 5665 
 5666 instruct loadConL32(rRegL dst, immL32 src)
 5667 %{
 5668   match(Set dst src);
 5669 
 5670   ins_cost(70);
 5671   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5672   ins_encode(load_immL32(dst, src));
 5673   ins_pipe(ialu_reg);
 5674 %}
 5675 
 5676 instruct loadConP(rRegP dst, immP con) %{
 5677   match(Set dst con);
 5678 
 5679   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5680   ins_encode(load_immP(dst, con));
 5681   ins_pipe(ialu_reg_fat); // XXX
 5682 %}
 5683 
 5684 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5685 %{
 5686   match(Set dst src);
 5687   effect(KILL cr);
 5688 
 5689   ins_cost(50);
 5690   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5691   opcode(0x33); /* + rd */
 5692   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5693   ins_pipe(ialu_reg);
 5694 %}
 5695 
 5696 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5697 %{
 5698   match(Set dst src);
 5699   effect(KILL cr);
 5700 
 5701   ins_cost(60);
 5702   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5703   ins_encode(load_immP31(dst, src));
 5704   ins_pipe(ialu_reg);
 5705 %}
 5706 
 5707 instruct loadConF(regF dst, immF con) %{
 5708   match(Set dst con);
 5709   ins_cost(125);
 5710   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5711   ins_encode %{
 5712     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5713   %}
 5714   ins_pipe(pipe_slow);
 5715 %}
 5716 
 5717 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5718   match(Set dst src);
 5719   effect(KILL cr);
 5720   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5721   ins_encode %{
 5722     __ xorq($dst$$Register, $dst$$Register);
 5723   %}
 5724   ins_pipe(ialu_reg);
 5725 %}
 5726 
 5727 instruct loadConN(rRegN dst, immN src) %{
 5728   match(Set dst src);
 5729 
 5730   ins_cost(125);
 5731   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5732   ins_encode %{
 5733     address con = (address)$src$$constant;
 5734     if (con == NULL) {
 5735       ShouldNotReachHere();
 5736     } else {
 5737       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5738     }
 5739   %}
 5740   ins_pipe(ialu_reg_fat); // XXX
 5741 %}
 5742 
 5743 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5744   match(Set dst src);
 5745 
 5746   ins_cost(125);
 5747   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5748   ins_encode %{
 5749     address con = (address)$src$$constant;
 5750     if (con == NULL) {
 5751       ShouldNotReachHere();
 5752     } else {
 5753       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5754     }
 5755   %}
 5756   ins_pipe(ialu_reg_fat); // XXX
 5757 %}
 5758 
 5759 instruct loadConF0(regF dst, immF0 src)
 5760 %{
 5761   match(Set dst src);
 5762   ins_cost(100);
 5763 
 5764   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5765   ins_encode %{
 5766     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5767   %}
 5768   ins_pipe(pipe_slow);
 5769 %}
 5770 
 5771 // Use the same format since predicate() can not be used here.
 5772 instruct loadConD(regD dst, immD con) %{
 5773   match(Set dst con);
 5774   ins_cost(125);
 5775   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5776   ins_encode %{
 5777     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5778   %}
 5779   ins_pipe(pipe_slow);
 5780 %}
 5781 
 5782 instruct loadConD0(regD dst, immD0 src)
 5783 %{
 5784   match(Set dst src);
 5785   ins_cost(100);
 5786 
 5787   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5788   ins_encode %{
 5789     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5790   %}
 5791   ins_pipe(pipe_slow);
 5792 %}
 5793 
 5794 instruct loadSSI(rRegI dst, stackSlotI src)
 5795 %{
 5796   match(Set dst src);
 5797 
 5798   ins_cost(125);
 5799   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5800   opcode(0x8B);
 5801   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5802   ins_pipe(ialu_reg_mem);
 5803 %}
 5804 
 5805 instruct loadSSL(rRegL dst, stackSlotL src)
 5806 %{
 5807   match(Set dst src);
 5808 
 5809   ins_cost(125);
 5810   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5811   opcode(0x8B);
 5812   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5813   ins_pipe(ialu_reg_mem);
 5814 %}
 5815 
 5816 instruct loadSSP(rRegP dst, stackSlotP src)
 5817 %{
 5818   match(Set dst src);
 5819 
 5820   ins_cost(125);
 5821   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5822   opcode(0x8B);
 5823   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5824   ins_pipe(ialu_reg_mem);
 5825 %}
 5826 
 5827 instruct loadSSF(regF dst, stackSlotF src)
 5828 %{
 5829   match(Set dst src);
 5830 
 5831   ins_cost(125);
 5832   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5833   ins_encode %{
 5834     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5835   %}
 5836   ins_pipe(pipe_slow); // XXX
 5837 %}
 5838 
 5839 // Use the same format since predicate() can not be used here.
 5840 instruct loadSSD(regD dst, stackSlotD src)
 5841 %{
 5842   match(Set dst src);
 5843 
 5844   ins_cost(125);
 5845   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5846   ins_encode  %{
 5847     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5848   %}
 5849   ins_pipe(pipe_slow); // XXX
 5850 %}
 5851 
 5852 // Prefetch instructions for allocation.
 5853 // Must be safe to execute with invalid address (cannot fault).
 5854 
 5855 instruct prefetchAlloc( memory mem ) %{
 5856   predicate(AllocatePrefetchInstr==3);
 5857   match(PrefetchAllocation mem);
 5858   ins_cost(125);
 5859 
 5860   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5861   ins_encode %{
 5862     __ prefetchw($mem$$Address);
 5863   %}
 5864   ins_pipe(ialu_mem);
 5865 %}
 5866 
 5867 instruct prefetchAllocNTA( memory mem ) %{
 5868   predicate(AllocatePrefetchInstr==0);
 5869   match(PrefetchAllocation mem);
 5870   ins_cost(125);
 5871 
 5872   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5873   ins_encode %{
 5874     __ prefetchnta($mem$$Address);
 5875   %}
 5876   ins_pipe(ialu_mem);
 5877 %}
 5878 
 5879 instruct prefetchAllocT0( memory mem ) %{
 5880   predicate(AllocatePrefetchInstr==1);
 5881   match(PrefetchAllocation mem);
 5882   ins_cost(125);
 5883 
 5884   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5885   ins_encode %{
 5886     __ prefetcht0($mem$$Address);
 5887   %}
 5888   ins_pipe(ialu_mem);
 5889 %}
 5890 
 5891 instruct prefetchAllocT2( memory mem ) %{
 5892   predicate(AllocatePrefetchInstr==2);
 5893   match(PrefetchAllocation mem);
 5894   ins_cost(125);
 5895 
 5896   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5897   ins_encode %{
 5898     __ prefetcht2($mem$$Address);
 5899   %}
 5900   ins_pipe(ialu_mem);
 5901 %}
 5902 
 5903 //----------Store Instructions-------------------------------------------------
 5904 
 5905 // Store Byte
 5906 instruct storeB(memory mem, rRegI src)
 5907 %{
 5908   match(Set mem (StoreB mem src));
 5909 
 5910   ins_cost(125); // XXX
 5911   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5912   opcode(0x88);
 5913   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5914   ins_pipe(ialu_mem_reg);
 5915 %}
 5916 
 5917 // Store Char/Short
 5918 instruct storeC(memory mem, rRegI src)
 5919 %{
 5920   match(Set mem (StoreC mem src));
 5921 
 5922   ins_cost(125); // XXX
 5923   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5924   opcode(0x89);
 5925   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5926   ins_pipe(ialu_mem_reg);
 5927 %}
 5928 
 5929 // Store Integer
 5930 instruct storeI(memory mem, rRegI src)
 5931 %{
 5932   match(Set mem (StoreI mem src));
 5933 
 5934   ins_cost(125); // XXX
 5935   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5936   opcode(0x89);
 5937   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5938   ins_pipe(ialu_mem_reg);
 5939 %}
 5940 
 5941 // Store Long
 5942 instruct storeL(memory mem, rRegL src)
 5943 %{
 5944   match(Set mem (StoreL mem src));
 5945 
 5946   ins_cost(125); // XXX
 5947   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5948   opcode(0x89);
 5949   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5950   ins_pipe(ialu_mem_reg); // XXX
 5951 %}
 5952 
 5953 // Store Pointer
 5954 instruct storeP(memory mem, any_RegP src)
 5955 %{
 5956   match(Set mem (StoreP mem src));
 5957 
 5958   ins_cost(125); // XXX
 5959   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5960   opcode(0x89);
 5961   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5962   ins_pipe(ialu_mem_reg);
 5963 %}
 5964 
 5965 instruct storeImmP0(memory mem, immP0 zero)
 5966 %{
 5967   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 5968   match(Set mem (StoreP mem zero));
 5969 
 5970   ins_cost(125); // XXX
 5971   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5972   ins_encode %{
 5973     __ movq($mem$$Address, r12);
 5974   %}
 5975   ins_pipe(ialu_mem_reg);
 5976 %}
 5977 
 5978 // Store NULL Pointer, mark word, or other simple pointer constant.
 5979 instruct storeImmP(memory mem, immP31 src)
 5980 %{
 5981   match(Set mem (StoreP mem src));
 5982 
 5983   ins_cost(150); // XXX
 5984   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5985   opcode(0xC7); /* C7 /0 */
 5986   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5987   ins_pipe(ialu_mem_imm);
 5988 %}
 5989 
 5990 // Store Compressed Pointer
 5991 instruct storeN(memory mem, rRegN src)
 5992 %{
 5993   match(Set mem (StoreN mem src));
 5994 
 5995   ins_cost(125); // XXX
 5996   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 5997   ins_encode %{
 5998     __ movl($mem$$Address, $src$$Register);
 5999   %}
 6000   ins_pipe(ialu_mem_reg);
 6001 %}
 6002 
 6003 instruct storeNKlass(memory mem, rRegN src)
 6004 %{
 6005   match(Set mem (StoreNKlass mem src));
 6006 
 6007   ins_cost(125); // XXX
 6008   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6009   ins_encode %{
 6010     __ movl($mem$$Address, $src$$Register);
 6011   %}
 6012   ins_pipe(ialu_mem_reg);
 6013 %}
 6014 
 6015 instruct storeImmN0(memory mem, immN0 zero)
 6016 %{
 6017   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);
 6018   match(Set mem (StoreN mem zero));
 6019 
 6020   ins_cost(125); // XXX
 6021   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6022   ins_encode %{
 6023     __ movl($mem$$Address, r12);
 6024   %}
 6025   ins_pipe(ialu_mem_reg);
 6026 %}
 6027 
 6028 instruct storeImmN(memory mem, immN src)
 6029 %{
 6030   match(Set mem (StoreN mem src));
 6031 
 6032   ins_cost(150); // XXX
 6033   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6034   ins_encode %{
 6035     address con = (address)$src$$constant;
 6036     if (con == NULL) {
 6037       __ movl($mem$$Address, (int32_t)0);
 6038     } else {
 6039       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6040     }
 6041   %}
 6042   ins_pipe(ialu_mem_imm);
 6043 %}
 6044 
 6045 instruct storeImmNKlass(memory mem, immNKlass src)
 6046 %{
 6047   match(Set mem (StoreNKlass mem src));
 6048 
 6049   ins_cost(150); // XXX
 6050   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6051   ins_encode %{
 6052     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6053   %}
 6054   ins_pipe(ialu_mem_imm);
 6055 %}
 6056 
 6057 // Store Integer Immediate
 6058 instruct storeImmI0(memory mem, immI0 zero)
 6059 %{
 6060   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6061   match(Set mem (StoreI mem zero));
 6062 
 6063   ins_cost(125); // XXX
 6064   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6065   ins_encode %{
 6066     __ movl($mem$$Address, r12);
 6067   %}
 6068   ins_pipe(ialu_mem_reg);
 6069 %}
 6070 
 6071 instruct storeImmI(memory mem, immI src)
 6072 %{
 6073   match(Set mem (StoreI mem src));
 6074 
 6075   ins_cost(150);
 6076   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6077   opcode(0xC7); /* C7 /0 */
 6078   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6079   ins_pipe(ialu_mem_imm);
 6080 %}
 6081 
 6082 // Store Long Immediate
 6083 instruct storeImmL0(memory mem, immL0 zero)
 6084 %{
 6085   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6086   match(Set mem (StoreL mem zero));
 6087 
 6088   ins_cost(125); // XXX
 6089   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6090   ins_encode %{
 6091     __ movq($mem$$Address, r12);
 6092   %}
 6093   ins_pipe(ialu_mem_reg);
 6094 %}
 6095 
 6096 instruct storeImmL(memory mem, immL32 src)
 6097 %{
 6098   match(Set mem (StoreL mem src));
 6099 
 6100   ins_cost(150);
 6101   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6102   opcode(0xC7); /* C7 /0 */
 6103   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6104   ins_pipe(ialu_mem_imm);
 6105 %}
 6106 
 6107 // Store Short/Char Immediate
 6108 instruct storeImmC0(memory mem, immI0 zero)
 6109 %{
 6110   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6111   match(Set mem (StoreC mem zero));
 6112 
 6113   ins_cost(125); // XXX
 6114   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6115   ins_encode %{
 6116     __ movw($mem$$Address, r12);
 6117   %}
 6118   ins_pipe(ialu_mem_reg);
 6119 %}
 6120 
 6121 instruct storeImmI16(memory mem, immI16 src)
 6122 %{
 6123   predicate(UseStoreImmI16);
 6124   match(Set mem (StoreC mem src));
 6125 
 6126   ins_cost(150);
 6127   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6128   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6129   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6130   ins_pipe(ialu_mem_imm);
 6131 %}
 6132 
 6133 // Store Byte Immediate
 6134 instruct storeImmB0(memory mem, immI0 zero)
 6135 %{
 6136   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6137   match(Set mem (StoreB mem zero));
 6138 
 6139   ins_cost(125); // XXX
 6140   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6141   ins_encode %{
 6142     __ movb($mem$$Address, r12);
 6143   %}
 6144   ins_pipe(ialu_mem_reg);
 6145 %}
 6146 
 6147 instruct storeImmB(memory mem, immI8 src)
 6148 %{
 6149   match(Set mem (StoreB mem src));
 6150 
 6151   ins_cost(150); // XXX
 6152   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6153   opcode(0xC6); /* C6 /0 */
 6154   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6155   ins_pipe(ialu_mem_imm);
 6156 %}
 6157 
 6158 // Store CMS card-mark Immediate
 6159 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6160 %{
 6161   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6162   match(Set mem (StoreCM mem zero));
 6163 
 6164   ins_cost(125); // XXX
 6165   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6166   ins_encode %{
 6167     __ movb($mem$$Address, r12);
 6168   %}
 6169   ins_pipe(ialu_mem_reg);
 6170 %}
 6171 
 6172 instruct storeImmCM0(memory mem, immI0 src)
 6173 %{
 6174   match(Set mem (StoreCM mem src));
 6175 
 6176   ins_cost(150); // XXX
 6177   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6178   opcode(0xC6); /* C6 /0 */
 6179   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6180   ins_pipe(ialu_mem_imm);
 6181 %}
 6182 
 6183 // Store Float
 6184 instruct storeF(memory mem, regF src)
 6185 %{
 6186   match(Set mem (StoreF mem src));
 6187 
 6188   ins_cost(95); // XXX
 6189   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6190   ins_encode %{
 6191     __ movflt($mem$$Address, $src$$XMMRegister);
 6192   %}
 6193   ins_pipe(pipe_slow); // XXX
 6194 %}
 6195 
 6196 // Store immediate Float value (it is faster than store from XMM register)
 6197 instruct storeF0(memory mem, immF0 zero)
 6198 %{
 6199   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6200   match(Set mem (StoreF mem zero));
 6201 
 6202   ins_cost(25); // XXX
 6203   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6204   ins_encode %{
 6205     __ movl($mem$$Address, r12);
 6206   %}
 6207   ins_pipe(ialu_mem_reg);
 6208 %}
 6209 
 6210 instruct storeF_imm(memory mem, immF src)
 6211 %{
 6212   match(Set mem (StoreF mem src));
 6213 
 6214   ins_cost(50);
 6215   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6216   opcode(0xC7); /* C7 /0 */
 6217   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6218   ins_pipe(ialu_mem_imm);
 6219 %}
 6220 
 6221 // Store Double
 6222 instruct storeD(memory mem, regD src)
 6223 %{
 6224   match(Set mem (StoreD mem src));
 6225 
 6226   ins_cost(95); // XXX
 6227   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6228   ins_encode %{
 6229     __ movdbl($mem$$Address, $src$$XMMRegister);
 6230   %}
 6231   ins_pipe(pipe_slow); // XXX
 6232 %}
 6233 
 6234 // Store immediate double 0.0 (it is faster than store from XMM register)
 6235 instruct storeD0_imm(memory mem, immD0 src)
 6236 %{
 6237   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6238   match(Set mem (StoreD mem src));
 6239 
 6240   ins_cost(50);
 6241   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6242   opcode(0xC7); /* C7 /0 */
 6243   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6244   ins_pipe(ialu_mem_imm);
 6245 %}
 6246 
 6247 instruct storeD0(memory mem, immD0 zero)
 6248 %{
 6249   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6250   match(Set mem (StoreD mem zero));
 6251 
 6252   ins_cost(25); // XXX
 6253   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6254   ins_encode %{
 6255     __ movq($mem$$Address, r12);
 6256   %}
 6257   ins_pipe(ialu_mem_reg);
 6258 %}
 6259 
 6260 instruct storeSSI(stackSlotI dst, rRegI src)
 6261 %{
 6262   match(Set dst src);
 6263 
 6264   ins_cost(100);
 6265   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6266   opcode(0x89);
 6267   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6268   ins_pipe( ialu_mem_reg );
 6269 %}
 6270 
 6271 instruct storeSSL(stackSlotL dst, rRegL src)
 6272 %{
 6273   match(Set dst src);
 6274 
 6275   ins_cost(100);
 6276   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6277   opcode(0x89);
 6278   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6279   ins_pipe(ialu_mem_reg);
 6280 %}
 6281 
 6282 instruct storeSSP(stackSlotP dst, rRegP src)
 6283 %{
 6284   match(Set dst src);
 6285 
 6286   ins_cost(100);
 6287   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6288   opcode(0x89);
 6289   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6290   ins_pipe(ialu_mem_reg);
 6291 %}
 6292 
 6293 instruct storeSSF(stackSlotF dst, regF src)
 6294 %{
 6295   match(Set dst src);
 6296 
 6297   ins_cost(95); // XXX
 6298   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6299   ins_encode %{
 6300     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6301   %}
 6302   ins_pipe(pipe_slow); // XXX
 6303 %}
 6304 
 6305 instruct storeSSD(stackSlotD dst, regD src)
 6306 %{
 6307   match(Set dst src);
 6308 
 6309   ins_cost(95); // XXX
 6310   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6311   ins_encode %{
 6312     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6313   %}
 6314   ins_pipe(pipe_slow); // XXX
 6315 %}
 6316 
 6317 instruct cacheWB(indirect addr)
 6318 %{
 6319   predicate(VM_Version::supports_data_cache_line_flush());
 6320   match(CacheWB addr);
 6321 
 6322   ins_cost(100);
 6323   format %{&quot;cache wb $addr&quot; %}
 6324   ins_encode %{
 6325     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6326     assert($addr$$disp == 0, &quot;should be&quot;);
 6327     __ cache_wb(Address($addr$$base$$Register, 0));
 6328   %}
 6329   ins_pipe(pipe_slow); // XXX
 6330 %}
 6331 
 6332 instruct cacheWBPreSync()
 6333 %{
 6334   predicate(VM_Version::supports_data_cache_line_flush());
 6335   match(CacheWBPreSync);
 6336 
 6337   ins_cost(100);
 6338   format %{&quot;cache wb presync&quot; %}
 6339   ins_encode %{
 6340     __ cache_wbsync(true);
 6341   %}
 6342   ins_pipe(pipe_slow); // XXX
 6343 %}
 6344 
 6345 instruct cacheWBPostSync()
 6346 %{
 6347   predicate(VM_Version::supports_data_cache_line_flush());
 6348   match(CacheWBPostSync);
 6349 
 6350   ins_cost(100);
 6351   format %{&quot;cache wb postsync&quot; %}
 6352   ins_encode %{
 6353     __ cache_wbsync(false);
 6354   %}
 6355   ins_pipe(pipe_slow); // XXX
 6356 %}
 6357 
 6358 //----------BSWAP Instructions-------------------------------------------------
 6359 instruct bytes_reverse_int(rRegI dst) %{
 6360   match(Set dst (ReverseBytesI dst));
 6361 
 6362   format %{ &quot;bswapl  $dst&quot; %}
 6363   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6364   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6365   ins_pipe( ialu_reg );
 6366 %}
 6367 
 6368 instruct bytes_reverse_long(rRegL dst) %{
 6369   match(Set dst (ReverseBytesL dst));
 6370 
 6371   format %{ &quot;bswapq  $dst&quot; %}
 6372   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6373   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6374   ins_pipe( ialu_reg);
 6375 %}
 6376 
 6377 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6378   match(Set dst (ReverseBytesUS dst));
 6379   effect(KILL cr);
 6380 
 6381   format %{ &quot;bswapl  $dst\n\t&quot;
 6382             &quot;shrl    $dst,16\n\t&quot; %}
 6383   ins_encode %{
 6384     __ bswapl($dst$$Register);
 6385     __ shrl($dst$$Register, 16);
 6386   %}
 6387   ins_pipe( ialu_reg );
 6388 %}
 6389 
 6390 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6391   match(Set dst (ReverseBytesS dst));
 6392   effect(KILL cr);
 6393 
 6394   format %{ &quot;bswapl  $dst\n\t&quot;
 6395             &quot;sar     $dst,16\n\t&quot; %}
 6396   ins_encode %{
 6397     __ bswapl($dst$$Register);
 6398     __ sarl($dst$$Register, 16);
 6399   %}
 6400   ins_pipe( ialu_reg );
 6401 %}
 6402 
 6403 //---------- Zeros Count Instructions ------------------------------------------
 6404 
 6405 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6406   predicate(UseCountLeadingZerosInstruction);
 6407   match(Set dst (CountLeadingZerosI src));
 6408   effect(KILL cr);
 6409 
 6410   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6411   ins_encode %{
 6412     __ lzcntl($dst$$Register, $src$$Register);
 6413   %}
 6414   ins_pipe(ialu_reg);
 6415 %}
 6416 
 6417 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6418   predicate(!UseCountLeadingZerosInstruction);
 6419   match(Set dst (CountLeadingZerosI src));
 6420   effect(KILL cr);
 6421 
 6422   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6423             &quot;jnz     skip\n\t&quot;
 6424             &quot;movl    $dst, -1\n&quot;
 6425       &quot;skip:\n\t&quot;
 6426             &quot;negl    $dst\n\t&quot;
 6427             &quot;addl    $dst, 31&quot; %}
 6428   ins_encode %{
 6429     Register Rdst = $dst$$Register;
 6430     Register Rsrc = $src$$Register;
 6431     Label skip;
 6432     __ bsrl(Rdst, Rsrc);
 6433     __ jccb(Assembler::notZero, skip);
 6434     __ movl(Rdst, -1);
 6435     __ bind(skip);
 6436     __ negl(Rdst);
 6437     __ addl(Rdst, BitsPerInt - 1);
 6438   %}
 6439   ins_pipe(ialu_reg);
 6440 %}
 6441 
 6442 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6443   predicate(UseCountLeadingZerosInstruction);
 6444   match(Set dst (CountLeadingZerosL src));
 6445   effect(KILL cr);
 6446 
 6447   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6448   ins_encode %{
 6449     __ lzcntq($dst$$Register, $src$$Register);
 6450   %}
 6451   ins_pipe(ialu_reg);
 6452 %}
 6453 
 6454 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6455   predicate(!UseCountLeadingZerosInstruction);
 6456   match(Set dst (CountLeadingZerosL src));
 6457   effect(KILL cr);
 6458 
 6459   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6460             &quot;jnz     skip\n\t&quot;
 6461             &quot;movl    $dst, -1\n&quot;
 6462       &quot;skip:\n\t&quot;
 6463             &quot;negl    $dst\n\t&quot;
 6464             &quot;addl    $dst, 63&quot; %}
 6465   ins_encode %{
 6466     Register Rdst = $dst$$Register;
 6467     Register Rsrc = $src$$Register;
 6468     Label skip;
 6469     __ bsrq(Rdst, Rsrc);
 6470     __ jccb(Assembler::notZero, skip);
 6471     __ movl(Rdst, -1);
 6472     __ bind(skip);
 6473     __ negl(Rdst);
 6474     __ addl(Rdst, BitsPerLong - 1);
 6475   %}
 6476   ins_pipe(ialu_reg);
 6477 %}
 6478 
 6479 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6480   predicate(UseCountTrailingZerosInstruction);
 6481   match(Set dst (CountTrailingZerosI src));
 6482   effect(KILL cr);
 6483 
 6484   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6485   ins_encode %{
 6486     __ tzcntl($dst$$Register, $src$$Register);
 6487   %}
 6488   ins_pipe(ialu_reg);
 6489 %}
 6490 
 6491 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6492   predicate(!UseCountTrailingZerosInstruction);
 6493   match(Set dst (CountTrailingZerosI src));
 6494   effect(KILL cr);
 6495 
 6496   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6497             &quot;jnz     done\n\t&quot;
 6498             &quot;movl    $dst, 32\n&quot;
 6499       &quot;done:&quot; %}
 6500   ins_encode %{
 6501     Register Rdst = $dst$$Register;
 6502     Label done;
 6503     __ bsfl(Rdst, $src$$Register);
 6504     __ jccb(Assembler::notZero, done);
 6505     __ movl(Rdst, BitsPerInt);
 6506     __ bind(done);
 6507   %}
 6508   ins_pipe(ialu_reg);
 6509 %}
 6510 
 6511 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6512   predicate(UseCountTrailingZerosInstruction);
 6513   match(Set dst (CountTrailingZerosL src));
 6514   effect(KILL cr);
 6515 
 6516   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6517   ins_encode %{
 6518     __ tzcntq($dst$$Register, $src$$Register);
 6519   %}
 6520   ins_pipe(ialu_reg);
 6521 %}
 6522 
 6523 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6524   predicate(!UseCountTrailingZerosInstruction);
 6525   match(Set dst (CountTrailingZerosL src));
 6526   effect(KILL cr);
 6527 
 6528   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6529             &quot;jnz     done\n\t&quot;
 6530             &quot;movl    $dst, 64\n&quot;
 6531       &quot;done:&quot; %}
 6532   ins_encode %{
 6533     Register Rdst = $dst$$Register;
 6534     Label done;
 6535     __ bsfq(Rdst, $src$$Register);
 6536     __ jccb(Assembler::notZero, done);
 6537     __ movl(Rdst, BitsPerLong);
 6538     __ bind(done);
 6539   %}
 6540   ins_pipe(ialu_reg);
 6541 %}
 6542 
 6543 
 6544 //---------- Population Count Instructions -------------------------------------
 6545 
 6546 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6547   predicate(UsePopCountInstruction);
 6548   match(Set dst (PopCountI src));
 6549   effect(KILL cr);
 6550 
 6551   format %{ &quot;popcnt  $dst, $src&quot; %}
 6552   ins_encode %{
 6553     __ popcntl($dst$$Register, $src$$Register);
 6554   %}
 6555   ins_pipe(ialu_reg);
 6556 %}
 6557 
 6558 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6559   predicate(UsePopCountInstruction);
 6560   match(Set dst (PopCountI (LoadI mem)));
 6561   effect(KILL cr);
 6562 
 6563   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6564   ins_encode %{
 6565     __ popcntl($dst$$Register, $mem$$Address);
 6566   %}
 6567   ins_pipe(ialu_reg);
 6568 %}
 6569 
 6570 // Note: Long.bitCount(long) returns an int.
 6571 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6572   predicate(UsePopCountInstruction);
 6573   match(Set dst (PopCountL src));
 6574   effect(KILL cr);
 6575 
 6576   format %{ &quot;popcnt  $dst, $src&quot; %}
 6577   ins_encode %{
 6578     __ popcntq($dst$$Register, $src$$Register);
 6579   %}
 6580   ins_pipe(ialu_reg);
 6581 %}
 6582 
 6583 // Note: Long.bitCount(long) returns an int.
 6584 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6585   predicate(UsePopCountInstruction);
 6586   match(Set dst (PopCountL (LoadL mem)));
 6587   effect(KILL cr);
 6588 
 6589   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6590   ins_encode %{
 6591     __ popcntq($dst$$Register, $mem$$Address);
 6592   %}
 6593   ins_pipe(ialu_reg);
 6594 %}
 6595 
 6596 
 6597 //----------MemBar Instructions-----------------------------------------------
 6598 // Memory barrier flavors
 6599 
 6600 instruct membar_acquire()
 6601 %{
 6602   match(MemBarAcquire);
 6603   match(LoadFence);
 6604   ins_cost(0);
 6605 
 6606   size(0);
 6607   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6608   ins_encode();
 6609   ins_pipe(empty);
 6610 %}
 6611 
 6612 instruct membar_acquire_lock()
 6613 %{
 6614   match(MemBarAcquireLock);
 6615   ins_cost(0);
 6616 
 6617   size(0);
 6618   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6619   ins_encode();
 6620   ins_pipe(empty);
 6621 %}
 6622 
 6623 instruct membar_release()
 6624 %{
 6625   match(MemBarRelease);
 6626   match(StoreFence);
 6627   ins_cost(0);
 6628 
 6629   size(0);
 6630   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6631   ins_encode();
 6632   ins_pipe(empty);
 6633 %}
 6634 
 6635 instruct membar_release_lock()
 6636 %{
 6637   match(MemBarReleaseLock);
 6638   ins_cost(0);
 6639 
 6640   size(0);
 6641   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6642   ins_encode();
 6643   ins_pipe(empty);
 6644 %}
 6645 
 6646 instruct membar_volatile(rFlagsReg cr) %{
 6647   match(MemBarVolatile);
 6648   effect(KILL cr);
 6649   ins_cost(400);
 6650 
 6651   format %{
 6652     $$template
 6653     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6654   %}
 6655   ins_encode %{
 6656     __ membar(Assembler::StoreLoad);
 6657   %}
 6658   ins_pipe(pipe_slow);
 6659 %}
 6660 
 6661 instruct unnecessary_membar_volatile()
 6662 %{
 6663   match(MemBarVolatile);
 6664   predicate(Matcher::post_store_load_barrier(n));
 6665   ins_cost(0);
 6666 
 6667   size(0);
 6668   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6669   ins_encode();
 6670   ins_pipe(empty);
 6671 %}
 6672 
 6673 instruct membar_storestore() %{
 6674   match(MemBarStoreStore);
 6675   ins_cost(0);
 6676 
 6677   size(0);
 6678   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6679   ins_encode( );
 6680   ins_pipe(empty);
 6681 %}
 6682 
 6683 //----------Move Instructions--------------------------------------------------
 6684 
 6685 instruct castX2P(rRegP dst, rRegL src)
 6686 %{
 6687   match(Set dst (CastX2P src));
 6688 
 6689   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6690   ins_encode %{
 6691     if ($dst$$reg != $src$$reg) {
 6692       __ movptr($dst$$Register, $src$$Register);
 6693     }
 6694   %}
 6695   ins_pipe(ialu_reg_reg); // XXX
 6696 %}
 6697 
 6698 instruct castN2X(rRegL dst, rRegN src)
 6699 %{
 6700   match(Set dst (CastP2X src));
 6701 
 6702   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6703   ins_encode %{
 6704     if ($dst$$reg != $src$$reg) {
 6705       __ movptr($dst$$Register, $src$$Register);
 6706     }
 6707   %}
 6708   ins_pipe(ialu_reg_reg); // XXX
 6709 %}
 6710 
 6711 instruct castP2X(rRegL dst, rRegP src)
 6712 %{
 6713   match(Set dst (CastP2X src));
 6714 
 6715   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6716   ins_encode %{
 6717     if ($dst$$reg != $src$$reg) {
 6718       __ movptr($dst$$Register, $src$$Register);
 6719     }
 6720   %}
 6721   ins_pipe(ialu_reg_reg); // XXX
 6722 %}
 6723 
 6724 instruct castN2I(rRegI dst, rRegN src)
 6725 %{
 6726   match(Set dst (CastN2I src));
 6727 
 6728   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6729   ins_encode %{
 6730     if ($dst$$reg != $src$$reg) {
 6731       __ movl($dst$$Register, $src$$Register);
 6732     }
 6733   %}
 6734   ins_pipe(ialu_reg_reg); // XXX
 6735 %}
 6736 
 6737 instruct castI2N(rRegN dst, rRegI src)
 6738 %{
 6739   match(Set dst (CastI2N src));
 6740 
 6741   format %{ &quot;movl    $dst, $src\t# int -&gt; compressed ptr&quot; %}
 6742   ins_encode %{
 6743     if ($dst$$reg != $src$$reg) {
 6744       __ movl($dst$$Register, $src$$Register);
 6745     }
 6746   %}
 6747   ins_pipe(ialu_reg_reg); // XXX
 6748 %}
 6749 
 6750 
 6751 // Convert oop into int for vectors alignment masking
 6752 instruct convP2I(rRegI dst, rRegP src)
 6753 %{
 6754   match(Set dst (ConvL2I (CastP2X src)));
 6755 
 6756   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6757   ins_encode %{
 6758     __ movl($dst$$Register, $src$$Register);
 6759   %}
 6760   ins_pipe(ialu_reg_reg); // XXX
 6761 %}
 6762 
 6763 // Convert compressed oop into int for vectors alignment masking
 6764 // in case of 32bit oops (heap &lt; 4Gb).
 6765 instruct convN2I(rRegI dst, rRegN src)
 6766 %{
 6767   predicate(CompressedOops::shift() == 0);
 6768   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6769 
 6770   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6771   ins_encode %{
 6772     __ movl($dst$$Register, $src$$Register);
 6773   %}
 6774   ins_pipe(ialu_reg_reg); // XXX
 6775 %}
 6776 
 6777 // Convert oop pointer into compressed form
 6778 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6779   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6780   match(Set dst (EncodeP src));
 6781   effect(KILL cr);
 6782   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6783   ins_encode %{
 6784     Register s = $src$$Register;
 6785     Register d = $dst$$Register;
 6786     if (s != d) {
 6787       __ movq(d, s);
 6788     }
 6789     __ encode_heap_oop(d);
 6790   %}
 6791   ins_pipe(ialu_reg_long);
 6792 %}
 6793 
 6794 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6795   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6796   match(Set dst (EncodeP src));
 6797   effect(KILL cr);
 6798   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6799   ins_encode %{
 6800     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6801   %}
 6802   ins_pipe(ialu_reg_long);
 6803 %}
 6804 
 6805 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6806   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6807             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6808   match(Set dst (DecodeN src));
 6809   effect(KILL cr);
 6810   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6811   ins_encode %{
 6812     Register s = $src$$Register;
 6813     Register d = $dst$$Register;
 6814     if (s != d) {
 6815       __ movq(d, s);
 6816     }
 6817     __ decode_heap_oop(d);
 6818   %}
 6819   ins_pipe(ialu_reg_long);
 6820 %}
 6821 
 6822 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6823   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6824             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6825   match(Set dst (DecodeN src));
 6826   effect(KILL cr);
 6827   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6828   ins_encode %{
 6829     Register s = $src$$Register;
 6830     Register d = $dst$$Register;
 6831     if (s != d) {
 6832       __ decode_heap_oop_not_null(d, s);
 6833     } else {
 6834       __ decode_heap_oop_not_null(d);
 6835     }
 6836   %}
 6837   ins_pipe(ialu_reg_long);
 6838 %}
 6839 
 6840 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6841   match(Set dst (EncodePKlass src));
 6842   effect(KILL cr);
 6843   format %{ &quot;encode_klass_not_null $dst,$src&quot; %}
 6844   ins_encode %{
 6845     __ encode_klass_not_null($dst$$Register, $src$$Register);
 6846   %}
 6847   ins_pipe(ialu_reg_long);
 6848 %}
 6849 
 6850 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6851   match(Set dst (DecodeNKlass src));
 6852   effect(KILL cr);
 6853   format %{ &quot;decode_klass_not_null $dst,$src&quot; %}
 6854   ins_encode %{
 6855     Register s = $src$$Register;
 6856     Register d = $dst$$Register;
 6857     if (s != d) {
 6858       __ decode_klass_not_null(d, s);
 6859     } else {
 6860       __ decode_klass_not_null(d);
 6861     }
 6862   %}
 6863   ins_pipe(ialu_reg_long);
 6864 %}
 6865 
 6866 
 6867 //----------Conditional Move---------------------------------------------------
 6868 // Jump
 6869 // dummy instruction for generating temp registers
 6870 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6871   match(Jump (LShiftL switch_val shift));
 6872   ins_cost(350);
 6873   predicate(false);
 6874   effect(TEMP dest);
 6875 
 6876   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6877             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6878   ins_encode %{
 6879     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6880     // to do that and the compiler is using that register as one it can allocate.
 6881     // So we build it all by hand.
 6882     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6883     // ArrayAddress dispatch(table, index);
 6884     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6885     __ lea($dest$$Register, $constantaddress);
 6886     __ jmp(dispatch);
 6887   %}
 6888   ins_pipe(pipe_jmp);
 6889 %}
 6890 
 6891 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6892   match(Jump (AddL (LShiftL switch_val shift) offset));
 6893   ins_cost(350);
 6894   effect(TEMP dest);
 6895 
 6896   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6897             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6898   ins_encode %{
 6899     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6900     // to do that and the compiler is using that register as one it can allocate.
 6901     // So we build it all by hand.
 6902     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6903     // ArrayAddress dispatch(table, index);
 6904     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6905     __ lea($dest$$Register, $constantaddress);
 6906     __ jmp(dispatch);
 6907   %}
 6908   ins_pipe(pipe_jmp);
 6909 %}
 6910 
 6911 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6912   match(Jump switch_val);
 6913   ins_cost(350);
 6914   effect(TEMP dest);
 6915 
 6916   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6917             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6918   ins_encode %{
 6919     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6920     // to do that and the compiler is using that register as one it can allocate.
 6921     // So we build it all by hand.
 6922     // Address index(noreg, switch_reg, Address::times_1);
 6923     // ArrayAddress dispatch(table, index);
 6924     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6925     __ lea($dest$$Register, $constantaddress);
 6926     __ jmp(dispatch);
 6927   %}
 6928   ins_pipe(pipe_jmp);
 6929 %}
 6930 
 6931 // Conditional move
 6932 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6933 %{
 6934   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6935 
 6936   ins_cost(200); // XXX
 6937   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6938   opcode(0x0F, 0x40);
 6939   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6940   ins_pipe(pipe_cmov_reg);
 6941 %}
 6942 
 6943 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6944   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6945 
 6946   ins_cost(200); // XXX
 6947   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6948   opcode(0x0F, 0x40);
 6949   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6950   ins_pipe(pipe_cmov_reg);
 6951 %}
 6952 
 6953 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6954   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6955   ins_cost(200);
 6956   expand %{
 6957     cmovI_regU(cop, cr, dst, src);
 6958   %}
 6959 %}
 6960 
 6961 // Conditional move
 6962 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6963   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6964 
 6965   ins_cost(250); // XXX
 6966   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6967   opcode(0x0F, 0x40);
 6968   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6969   ins_pipe(pipe_cmov_mem);
 6970 %}
 6971 
 6972 // Conditional move
 6973 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 6974 %{
 6975   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6976 
 6977   ins_cost(250); // XXX
 6978   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6979   opcode(0x0F, 0x40);
 6980   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6981   ins_pipe(pipe_cmov_mem);
 6982 %}
 6983 
 6984 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 6985   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6986   ins_cost(250);
 6987   expand %{
 6988     cmovI_memU(cop, cr, dst, src);
 6989   %}
 6990 %}
 6991 
 6992 // Conditional move
 6993 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 6994 %{
 6995   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6996 
 6997   ins_cost(200); // XXX
 6998   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 6999   opcode(0x0F, 0x40);
 7000   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7001   ins_pipe(pipe_cmov_reg);
 7002 %}
 7003 
 7004 // Conditional move
 7005 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 7006 %{
 7007   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7008 
 7009   ins_cost(200); // XXX
 7010   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 7011   opcode(0x0F, 0x40);
 7012   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7013   ins_pipe(pipe_cmov_reg);
 7014 %}
 7015 
 7016 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 7017   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7018   ins_cost(200);
 7019   expand %{
 7020     cmovN_regU(cop, cr, dst, src);
 7021   %}
 7022 %}
 7023 
 7024 // Conditional move
 7025 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 7026 %{
 7027   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7028 
 7029   ins_cost(200); // XXX
 7030   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 7031   opcode(0x0F, 0x40);
 7032   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7033   ins_pipe(pipe_cmov_reg);  // XXX
 7034 %}
 7035 
 7036 // Conditional move
 7037 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 7038 %{
 7039   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7040 
 7041   ins_cost(200); // XXX
 7042   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 7043   opcode(0x0F, 0x40);
 7044   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7045   ins_pipe(pipe_cmov_reg); // XXX
 7046 %}
 7047 
 7048 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 7049   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7050   ins_cost(200);
 7051   expand %{
 7052     cmovP_regU(cop, cr, dst, src);
 7053   %}
 7054 %}
 7055 
 7056 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7057 // correctly meets the two pointer arguments; one is an incoming
 7058 // register but the other is a memory operand.  ALSO appears to
 7059 // be buggy with implicit null checks.
 7060 //
 7061 //// Conditional move
 7062 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7063 //%{
 7064 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7065 //  ins_cost(250);
 7066 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7067 //  opcode(0x0F,0x40);
 7068 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7069 //  ins_pipe( pipe_cmov_mem );
 7070 //%}
 7071 //
 7072 //// Conditional move
 7073 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7074 //%{
 7075 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7076 //  ins_cost(250);
 7077 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7078 //  opcode(0x0F,0x40);
 7079 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7080 //  ins_pipe( pipe_cmov_mem );
 7081 //%}
 7082 
 7083 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7084 %{
 7085   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7086 
 7087   ins_cost(200); // XXX
 7088   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7089   opcode(0x0F, 0x40);
 7090   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7091   ins_pipe(pipe_cmov_reg);  // XXX
 7092 %}
 7093 
 7094 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7095 %{
 7096   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7097 
 7098   ins_cost(200); // XXX
 7099   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7100   opcode(0x0F, 0x40);
 7101   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7102   ins_pipe(pipe_cmov_mem);  // XXX
 7103 %}
 7104 
 7105 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7106 %{
 7107   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7108 
 7109   ins_cost(200); // XXX
 7110   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7111   opcode(0x0F, 0x40);
 7112   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7113   ins_pipe(pipe_cmov_reg); // XXX
 7114 %}
 7115 
 7116 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7117   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7118   ins_cost(200);
 7119   expand %{
 7120     cmovL_regU(cop, cr, dst, src);
 7121   %}
 7122 %}
 7123 
 7124 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7125 %{
 7126   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7127 
 7128   ins_cost(200); // XXX
 7129   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7130   opcode(0x0F, 0x40);
 7131   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7132   ins_pipe(pipe_cmov_mem); // XXX
 7133 %}
 7134 
 7135 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7136   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7137   ins_cost(200);
 7138   expand %{
 7139     cmovL_memU(cop, cr, dst, src);
 7140   %}
 7141 %}
 7142 
 7143 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7144 %{
 7145   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7146 
 7147   ins_cost(200); // XXX
 7148   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7149             &quot;movss     $dst, $src\n&quot;
 7150     &quot;skip:&quot; %}
 7151   ins_encode %{
 7152     Label Lskip;
 7153     // Invert sense of branch from sense of CMOV
 7154     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7155     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7156     __ bind(Lskip);
 7157   %}
 7158   ins_pipe(pipe_slow);
 7159 %}
 7160 
 7161 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7162 // %{
 7163 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7164 
 7165 //   ins_cost(200); // XXX
 7166 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7167 //             &quot;movss     $dst, $src\n&quot;
 7168 //     &quot;skip:&quot; %}
 7169 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7170 //   ins_pipe(pipe_slow);
 7171 // %}
 7172 
 7173 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7174 %{
 7175   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7176 
 7177   ins_cost(200); // XXX
 7178   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7179             &quot;movss     $dst, $src\n&quot;
 7180     &quot;skip:&quot; %}
 7181   ins_encode %{
 7182     Label Lskip;
 7183     // Invert sense of branch from sense of CMOV
 7184     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7185     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7186     __ bind(Lskip);
 7187   %}
 7188   ins_pipe(pipe_slow);
 7189 %}
 7190 
 7191 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7192   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7193   ins_cost(200);
 7194   expand %{
 7195     cmovF_regU(cop, cr, dst, src);
 7196   %}
 7197 %}
 7198 
 7199 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7200 %{
 7201   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7202 
 7203   ins_cost(200); // XXX
 7204   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7205             &quot;movsd     $dst, $src\n&quot;
 7206     &quot;skip:&quot; %}
 7207   ins_encode %{
 7208     Label Lskip;
 7209     // Invert sense of branch from sense of CMOV
 7210     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7211     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7212     __ bind(Lskip);
 7213   %}
 7214   ins_pipe(pipe_slow);
 7215 %}
 7216 
 7217 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7218 %{
 7219   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7220 
 7221   ins_cost(200); // XXX
 7222   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7223             &quot;movsd     $dst, $src\n&quot;
 7224     &quot;skip:&quot; %}
 7225   ins_encode %{
 7226     Label Lskip;
 7227     // Invert sense of branch from sense of CMOV
 7228     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7229     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7230     __ bind(Lskip);
 7231   %}
 7232   ins_pipe(pipe_slow);
 7233 %}
 7234 
 7235 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7236   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7237   ins_cost(200);
 7238   expand %{
 7239     cmovD_regU(cop, cr, dst, src);
 7240   %}
 7241 %}
 7242 
 7243 //----------Arithmetic Instructions--------------------------------------------
 7244 //----------Addition Instructions----------------------------------------------
 7245 
 7246 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7247 %{
 7248   match(Set dst (AddI dst src));
 7249   effect(KILL cr);
 7250 
 7251   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7252   opcode(0x03);
 7253   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7254   ins_pipe(ialu_reg_reg);
 7255 %}
 7256 
 7257 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7258 %{
 7259   match(Set dst (AddI dst src));
 7260   effect(KILL cr);
 7261 
 7262   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7263   opcode(0x81, 0x00); /* /0 id */
 7264   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7265   ins_pipe( ialu_reg );
 7266 %}
 7267 
 7268 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7269 %{
 7270   match(Set dst (AddI dst (LoadI src)));
 7271   effect(KILL cr);
 7272 
 7273   ins_cost(125); // XXX
 7274   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7275   opcode(0x03);
 7276   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7277   ins_pipe(ialu_reg_mem);
 7278 %}
 7279 
 7280 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7281 %{
 7282   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7283   effect(KILL cr);
 7284 
 7285   ins_cost(150); // XXX
 7286   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7287   opcode(0x01); /* Opcode 01 /r */
 7288   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7289   ins_pipe(ialu_mem_reg);
 7290 %}
 7291 
 7292 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7293 %{
 7294   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7295   effect(KILL cr);
 7296 
 7297   ins_cost(125); // XXX
 7298   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7299   opcode(0x81); /* Opcode 81 /0 id */
 7300   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7301   ins_pipe(ialu_mem_imm);
 7302 %}
 7303 
 7304 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7305 %{
 7306   predicate(UseIncDec);
 7307   match(Set dst (AddI dst src));
 7308   effect(KILL cr);
 7309 
 7310   format %{ &quot;incl    $dst\t# int&quot; %}
 7311   opcode(0xFF, 0x00); // FF /0
 7312   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7313   ins_pipe(ialu_reg);
 7314 %}
 7315 
 7316 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7317 %{
 7318   predicate(UseIncDec);
 7319   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7320   effect(KILL cr);
 7321 
 7322   ins_cost(125); // XXX
 7323   format %{ &quot;incl    $dst\t# int&quot; %}
 7324   opcode(0xFF); /* Opcode FF /0 */
 7325   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7326   ins_pipe(ialu_mem_imm);
 7327 %}
 7328 
 7329 // XXX why does that use AddI
 7330 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7331 %{
 7332   predicate(UseIncDec);
 7333   match(Set dst (AddI dst src));
 7334   effect(KILL cr);
 7335 
 7336   format %{ &quot;decl    $dst\t# int&quot; %}
 7337   opcode(0xFF, 0x01); // FF /1
 7338   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7339   ins_pipe(ialu_reg);
 7340 %}
 7341 
 7342 // XXX why does that use AddI
 7343 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7344 %{
 7345   predicate(UseIncDec);
 7346   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7347   effect(KILL cr);
 7348 
 7349   ins_cost(125); // XXX
 7350   format %{ &quot;decl    $dst\t# int&quot; %}
 7351   opcode(0xFF); /* Opcode FF /1 */
 7352   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7353   ins_pipe(ialu_mem_imm);
 7354 %}
 7355 
 7356 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7357 %{
 7358   match(Set dst (AddI src0 src1));
 7359 
 7360   ins_cost(110);
 7361   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7362   opcode(0x8D); /* 0x8D /r */
 7363   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7364   ins_pipe(ialu_reg_reg);
 7365 %}
 7366 
 7367 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7368 %{
 7369   match(Set dst (AddL dst src));
 7370   effect(KILL cr);
 7371 
 7372   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7373   opcode(0x03);
 7374   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7375   ins_pipe(ialu_reg_reg);
 7376 %}
 7377 
 7378 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7379 %{
 7380   match(Set dst (AddL dst src));
 7381   effect(KILL cr);
 7382 
 7383   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7384   opcode(0x81, 0x00); /* /0 id */
 7385   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7386   ins_pipe( ialu_reg );
 7387 %}
 7388 
 7389 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7390 %{
 7391   match(Set dst (AddL dst (LoadL src)));
 7392   effect(KILL cr);
 7393 
 7394   ins_cost(125); // XXX
 7395   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7396   opcode(0x03);
 7397   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7398   ins_pipe(ialu_reg_mem);
 7399 %}
 7400 
 7401 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7402 %{
 7403   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7404   effect(KILL cr);
 7405 
 7406   ins_cost(150); // XXX
 7407   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7408   opcode(0x01); /* Opcode 01 /r */
 7409   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7410   ins_pipe(ialu_mem_reg);
 7411 %}
 7412 
 7413 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7414 %{
 7415   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7416   effect(KILL cr);
 7417 
 7418   ins_cost(125); // XXX
 7419   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7420   opcode(0x81); /* Opcode 81 /0 id */
 7421   ins_encode(REX_mem_wide(dst),
 7422              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7423   ins_pipe(ialu_mem_imm);
 7424 %}
 7425 
 7426 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7427 %{
 7428   predicate(UseIncDec);
 7429   match(Set dst (AddL dst src));
 7430   effect(KILL cr);
 7431 
 7432   format %{ &quot;incq    $dst\t# long&quot; %}
 7433   opcode(0xFF, 0x00); // FF /0
 7434   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7435   ins_pipe(ialu_reg);
 7436 %}
 7437 
 7438 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7439 %{
 7440   predicate(UseIncDec);
 7441   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7442   effect(KILL cr);
 7443 
 7444   ins_cost(125); // XXX
 7445   format %{ &quot;incq    $dst\t# long&quot; %}
 7446   opcode(0xFF); /* Opcode FF /0 */
 7447   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7448   ins_pipe(ialu_mem_imm);
 7449 %}
 7450 
 7451 // XXX why does that use AddL
 7452 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7453 %{
 7454   predicate(UseIncDec);
 7455   match(Set dst (AddL dst src));
 7456   effect(KILL cr);
 7457 
 7458   format %{ &quot;decq    $dst\t# long&quot; %}
 7459   opcode(0xFF, 0x01); // FF /1
 7460   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7461   ins_pipe(ialu_reg);
 7462 %}
 7463 
 7464 // XXX why does that use AddL
 7465 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7466 %{
 7467   predicate(UseIncDec);
 7468   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7469   effect(KILL cr);
 7470 
 7471   ins_cost(125); // XXX
 7472   format %{ &quot;decq    $dst\t# long&quot; %}
 7473   opcode(0xFF); /* Opcode FF /1 */
 7474   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7475   ins_pipe(ialu_mem_imm);
 7476 %}
 7477 
 7478 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7479 %{
 7480   match(Set dst (AddL src0 src1));
 7481 
 7482   ins_cost(110);
 7483   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7484   opcode(0x8D); /* 0x8D /r */
 7485   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7486   ins_pipe(ialu_reg_reg);
 7487 %}
 7488 
 7489 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7490 %{
 7491   match(Set dst (AddP dst src));
 7492   effect(KILL cr);
 7493 
 7494   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7495   opcode(0x03);
 7496   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7497   ins_pipe(ialu_reg_reg);
 7498 %}
 7499 
 7500 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7501 %{
 7502   match(Set dst (AddP dst src));
 7503   effect(KILL cr);
 7504 
 7505   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7506   opcode(0x81, 0x00); /* /0 id */
 7507   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7508   ins_pipe( ialu_reg );
 7509 %}
 7510 
 7511 // XXX addP mem ops ????
 7512 
 7513 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7514 %{
 7515   match(Set dst (AddP src0 src1));
 7516 
 7517   ins_cost(110);
 7518   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7519   opcode(0x8D); /* 0x8D /r */
 7520   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7521   ins_pipe(ialu_reg_reg);
 7522 %}
 7523 
 7524 instruct checkCastPP(rRegP dst)
 7525 %{
 7526   match(Set dst (CheckCastPP dst));
 7527 
 7528   size(0);
 7529   format %{ &quot;# checkcastPP of $dst&quot; %}
 7530   ins_encode(/* empty encoding */);
 7531   ins_pipe(empty);
 7532 %}
 7533 
 7534 instruct castPP(rRegP dst)
 7535 %{
 7536   match(Set dst (CastPP dst));
 7537 
 7538   size(0);
 7539   format %{ &quot;# castPP of $dst&quot; %}
 7540   ins_encode(/* empty encoding */);
 7541   ins_pipe(empty);
 7542 %}
 7543 
 7544 instruct castII(rRegI dst)
 7545 %{
 7546   match(Set dst (CastII dst));
 7547 
 7548   size(0);
 7549   format %{ &quot;# castII of $dst&quot; %}
 7550   ins_encode(/* empty encoding */);
 7551   ins_cost(0);
 7552   ins_pipe(empty);
 7553 %}
 7554 
 7555 // LoadP-locked same as a regular LoadP when used with compare-swap
 7556 instruct loadPLocked(rRegP dst, memory mem)
 7557 %{
 7558   match(Set dst (LoadPLocked mem));
 7559 
 7560   ins_cost(125); // XXX
 7561   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7562   opcode(0x8B);
 7563   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7564   ins_pipe(ialu_reg_mem); // XXX
 7565 %}
 7566 
 7567 // Conditional-store of the updated heap-top.
 7568 // Used during allocation of the shared heap.
 7569 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7570 
 7571 instruct storePConditional(memory heap_top_ptr,
 7572                            rax_RegP oldval, rRegP newval,
 7573                            rFlagsReg cr)
 7574 %{
 7575   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7576   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7577 
 7578   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7579             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7580   opcode(0x0F, 0xB1);
 7581   ins_encode(lock_prefix,
 7582              REX_reg_mem_wide(newval, heap_top_ptr),
 7583              OpcP, OpcS,
 7584              reg_mem(newval, heap_top_ptr));
 7585   ins_pipe(pipe_cmpxchg);
 7586 %}
 7587 
 7588 // Conditional-store of an int value.
 7589 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7590 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7591 %{
 7592   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7593   effect(KILL oldval);
 7594 
 7595   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7596   opcode(0x0F, 0xB1);
 7597   ins_encode(lock_prefix,
 7598              REX_reg_mem(newval, mem),
 7599              OpcP, OpcS,
 7600              reg_mem(newval, mem));
 7601   ins_pipe(pipe_cmpxchg);
 7602 %}
 7603 
 7604 // Conditional-store of a long value.
 7605 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7606 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7607 %{
 7608   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7609   effect(KILL oldval);
 7610 
 7611   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7612   opcode(0x0F, 0xB1);
 7613   ins_encode(lock_prefix,
 7614              REX_reg_mem_wide(newval, mem),
 7615              OpcP, OpcS,
 7616              reg_mem(newval, mem));
 7617   ins_pipe(pipe_cmpxchg);
 7618 %}
 7619 
 7620 
 7621 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7622 instruct compareAndSwapP(rRegI res,
 7623                          memory mem_ptr,
 7624                          rax_RegP oldval, rRegP newval,
 7625                          rFlagsReg cr)
 7626 %{
 7627   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7628   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7629   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7630   effect(KILL cr, KILL oldval);
 7631 
 7632   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7633             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7634             &quot;sete    $res\n\t&quot;
 7635             &quot;movzbl  $res, $res&quot; %}
 7636   opcode(0x0F, 0xB1);
 7637   ins_encode(lock_prefix,
 7638              REX_reg_mem_wide(newval, mem_ptr),
 7639              OpcP, OpcS,
 7640              reg_mem(newval, mem_ptr),
 7641              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7642              REX_reg_breg(res, res), // movzbl
 7643              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7644   ins_pipe( pipe_cmpxchg );
 7645 %}
 7646 
 7647 instruct compareAndSwapL(rRegI res,
 7648                          memory mem_ptr,
 7649                          rax_RegL oldval, rRegL newval,
 7650                          rFlagsReg cr)
 7651 %{
 7652   predicate(VM_Version::supports_cx8());
 7653   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7654   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7655   effect(KILL cr, KILL oldval);
 7656 
 7657   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7658             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7659             &quot;sete    $res\n\t&quot;
 7660             &quot;movzbl  $res, $res&quot; %}
 7661   opcode(0x0F, 0xB1);
 7662   ins_encode(lock_prefix,
 7663              REX_reg_mem_wide(newval, mem_ptr),
 7664              OpcP, OpcS,
 7665              reg_mem(newval, mem_ptr),
 7666              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7667              REX_reg_breg(res, res), // movzbl
 7668              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7669   ins_pipe( pipe_cmpxchg );
 7670 %}
 7671 
 7672 instruct compareAndSwapI(rRegI res,
 7673                          memory mem_ptr,
 7674                          rax_RegI oldval, rRegI newval,
 7675                          rFlagsReg cr)
 7676 %{
 7677   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7678   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7679   effect(KILL cr, KILL oldval);
 7680 
 7681   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7682             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7683             &quot;sete    $res\n\t&quot;
 7684             &quot;movzbl  $res, $res&quot; %}
 7685   opcode(0x0F, 0xB1);
 7686   ins_encode(lock_prefix,
 7687              REX_reg_mem(newval, mem_ptr),
 7688              OpcP, OpcS,
 7689              reg_mem(newval, mem_ptr),
 7690              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7691              REX_reg_breg(res, res), // movzbl
 7692              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7693   ins_pipe( pipe_cmpxchg );
 7694 %}
 7695 
 7696 instruct compareAndSwapB(rRegI res,
 7697                          memory mem_ptr,
 7698                          rax_RegI oldval, rRegI newval,
 7699                          rFlagsReg cr)
 7700 %{
 7701   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7702   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7703   effect(KILL cr, KILL oldval);
 7704 
 7705   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7706             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7707             &quot;sete    $res\n\t&quot;
 7708             &quot;movzbl  $res, $res&quot; %}
 7709   opcode(0x0F, 0xB0);
 7710   ins_encode(lock_prefix,
 7711              REX_breg_mem(newval, mem_ptr),
 7712              OpcP, OpcS,
 7713              reg_mem(newval, mem_ptr),
 7714              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7715              REX_reg_breg(res, res), // movzbl
 7716              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7717   ins_pipe( pipe_cmpxchg );
 7718 %}
 7719 
 7720 instruct compareAndSwapS(rRegI res,
 7721                          memory mem_ptr,
 7722                          rax_RegI oldval, rRegI newval,
 7723                          rFlagsReg cr)
 7724 %{
 7725   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7726   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7727   effect(KILL cr, KILL oldval);
 7728 
 7729   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7730             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7731             &quot;sete    $res\n\t&quot;
 7732             &quot;movzbl  $res, $res&quot; %}
 7733   opcode(0x0F, 0xB1);
 7734   ins_encode(lock_prefix,
 7735              SizePrefix,
 7736              REX_reg_mem(newval, mem_ptr),
 7737              OpcP, OpcS,
 7738              reg_mem(newval, mem_ptr),
 7739              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7740              REX_reg_breg(res, res), // movzbl
 7741              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7742   ins_pipe( pipe_cmpxchg );
 7743 %}
 7744 
 7745 instruct compareAndSwapN(rRegI res,
 7746                           memory mem_ptr,
 7747                           rax_RegN oldval, rRegN newval,
 7748                           rFlagsReg cr) %{
 7749   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7750   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7751   effect(KILL cr, KILL oldval);
 7752 
 7753   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7754             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7755             &quot;sete    $res\n\t&quot;
 7756             &quot;movzbl  $res, $res&quot; %}
 7757   opcode(0x0F, 0xB1);
 7758   ins_encode(lock_prefix,
 7759              REX_reg_mem(newval, mem_ptr),
 7760              OpcP, OpcS,
 7761              reg_mem(newval, mem_ptr),
 7762              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7763              REX_reg_breg(res, res), // movzbl
 7764              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7765   ins_pipe( pipe_cmpxchg );
 7766 %}
 7767 
 7768 instruct compareAndExchangeB(
 7769                          memory mem_ptr,
 7770                          rax_RegI oldval, rRegI newval,
 7771                          rFlagsReg cr)
 7772 %{
 7773   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7774   effect(KILL cr);
 7775 
 7776   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7777             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7778   opcode(0x0F, 0xB0);
 7779   ins_encode(lock_prefix,
 7780              REX_breg_mem(newval, mem_ptr),
 7781              OpcP, OpcS,
 7782              reg_mem(newval, mem_ptr) // lock cmpxchg
 7783              );
 7784   ins_pipe( pipe_cmpxchg );
 7785 %}
 7786 
 7787 instruct compareAndExchangeS(
 7788                          memory mem_ptr,
 7789                          rax_RegI oldval, rRegI newval,
 7790                          rFlagsReg cr)
 7791 %{
 7792   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7793   effect(KILL cr);
 7794 
 7795   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7796             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7797   opcode(0x0F, 0xB1);
 7798   ins_encode(lock_prefix,
 7799              SizePrefix,
 7800              REX_reg_mem(newval, mem_ptr),
 7801              OpcP, OpcS,
 7802              reg_mem(newval, mem_ptr) // lock cmpxchg
 7803              );
 7804   ins_pipe( pipe_cmpxchg );
 7805 %}
 7806 
 7807 instruct compareAndExchangeI(
 7808                          memory mem_ptr,
 7809                          rax_RegI oldval, rRegI newval,
 7810                          rFlagsReg cr)
 7811 %{
 7812   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7813   effect(KILL cr);
 7814 
 7815   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7816             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7817   opcode(0x0F, 0xB1);
 7818   ins_encode(lock_prefix,
 7819              REX_reg_mem(newval, mem_ptr),
 7820              OpcP, OpcS,
 7821              reg_mem(newval, mem_ptr) // lock cmpxchg
 7822              );
 7823   ins_pipe( pipe_cmpxchg );
 7824 %}
 7825 
 7826 instruct compareAndExchangeL(
 7827                          memory mem_ptr,
 7828                          rax_RegL oldval, rRegL newval,
 7829                          rFlagsReg cr)
 7830 %{
 7831   predicate(VM_Version::supports_cx8());
 7832   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7833   effect(KILL cr);
 7834 
 7835   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7836             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7837   opcode(0x0F, 0xB1);
 7838   ins_encode(lock_prefix,
 7839              REX_reg_mem_wide(newval, mem_ptr),
 7840              OpcP, OpcS,
 7841              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7842             );
 7843   ins_pipe( pipe_cmpxchg );
 7844 %}
 7845 
 7846 instruct compareAndExchangeN(
 7847                           memory mem_ptr,
 7848                           rax_RegN oldval, rRegN newval,
 7849                           rFlagsReg cr) %{
 7850   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7851   effect(KILL cr);
 7852 
 7853   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7854             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7855   opcode(0x0F, 0xB1);
 7856   ins_encode(lock_prefix,
 7857              REX_reg_mem(newval, mem_ptr),
 7858              OpcP, OpcS,
 7859              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7860           );
 7861   ins_pipe( pipe_cmpxchg );
 7862 %}
 7863 
 7864 instruct compareAndExchangeP(
 7865                          memory mem_ptr,
 7866                          rax_RegP oldval, rRegP newval,
 7867                          rFlagsReg cr)
 7868 %{
 7869   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7870   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7871   effect(KILL cr);
 7872 
 7873   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7874             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7875   opcode(0x0F, 0xB1);
 7876   ins_encode(lock_prefix,
 7877              REX_reg_mem_wide(newval, mem_ptr),
 7878              OpcP, OpcS,
 7879              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7880           );
 7881   ins_pipe( pipe_cmpxchg );
 7882 %}
 7883 
 7884 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7885   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7886   match(Set dummy (GetAndAddB mem add));
 7887   effect(KILL cr);
 7888   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7889   ins_encode %{
 7890     __ lock();
 7891     __ addb($mem$$Address, $add$$constant);
 7892   %}
 7893   ins_pipe( pipe_cmpxchg );
 7894 %}
 7895 
 7896 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7897   match(Set newval (GetAndAddB mem newval));
 7898   effect(KILL cr);
 7899   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7900   ins_encode %{
 7901     __ lock();
 7902     __ xaddb($mem$$Address, $newval$$Register);
 7903   %}
 7904   ins_pipe( pipe_cmpxchg );
 7905 %}
 7906 
 7907 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7908   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7909   match(Set dummy (GetAndAddS mem add));
 7910   effect(KILL cr);
 7911   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7912   ins_encode %{
 7913     __ lock();
 7914     __ addw($mem$$Address, $add$$constant);
 7915   %}
 7916   ins_pipe( pipe_cmpxchg );
 7917 %}
 7918 
 7919 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7920   match(Set newval (GetAndAddS mem newval));
 7921   effect(KILL cr);
 7922   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7923   ins_encode %{
 7924     __ lock();
 7925     __ xaddw($mem$$Address, $newval$$Register);
 7926   %}
 7927   ins_pipe( pipe_cmpxchg );
 7928 %}
 7929 
 7930 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7931   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7932   match(Set dummy (GetAndAddI mem add));
 7933   effect(KILL cr);
 7934   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7935   ins_encode %{
 7936     __ lock();
 7937     __ addl($mem$$Address, $add$$constant);
 7938   %}
 7939   ins_pipe( pipe_cmpxchg );
 7940 %}
 7941 
 7942 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7943   match(Set newval (GetAndAddI mem newval));
 7944   effect(KILL cr);
 7945   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7946   ins_encode %{
 7947     __ lock();
 7948     __ xaddl($mem$$Address, $newval$$Register);
 7949   %}
 7950   ins_pipe( pipe_cmpxchg );
 7951 %}
 7952 
 7953 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7954   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7955   match(Set dummy (GetAndAddL mem add));
 7956   effect(KILL cr);
 7957   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 7958   ins_encode %{
 7959     __ lock();
 7960     __ addq($mem$$Address, $add$$constant);
 7961   %}
 7962   ins_pipe( pipe_cmpxchg );
 7963 %}
 7964 
 7965 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 7966   match(Set newval (GetAndAddL mem newval));
 7967   effect(KILL cr);
 7968   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 7969   ins_encode %{
 7970     __ lock();
 7971     __ xaddq($mem$$Address, $newval$$Register);
 7972   %}
 7973   ins_pipe( pipe_cmpxchg );
 7974 %}
 7975 
 7976 instruct xchgB( memory mem, rRegI newval) %{
 7977   match(Set newval (GetAndSetB mem newval));
 7978   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7979   ins_encode %{
 7980     __ xchgb($newval$$Register, $mem$$Address);
 7981   %}
 7982   ins_pipe( pipe_cmpxchg );
 7983 %}
 7984 
 7985 instruct xchgS( memory mem, rRegI newval) %{
 7986   match(Set newval (GetAndSetS mem newval));
 7987   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7988   ins_encode %{
 7989     __ xchgw($newval$$Register, $mem$$Address);
 7990   %}
 7991   ins_pipe( pipe_cmpxchg );
 7992 %}
 7993 
 7994 instruct xchgI( memory mem, rRegI newval) %{
 7995   match(Set newval (GetAndSetI mem newval));
 7996   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7997   ins_encode %{
 7998     __ xchgl($newval$$Register, $mem$$Address);
 7999   %}
 8000   ins_pipe( pipe_cmpxchg );
 8001 %}
 8002 
 8003 instruct xchgL( memory mem, rRegL newval) %{
 8004   match(Set newval (GetAndSetL mem newval));
 8005   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8006   ins_encode %{
 8007     __ xchgq($newval$$Register, $mem$$Address);
 8008   %}
 8009   ins_pipe( pipe_cmpxchg );
 8010 %}
 8011 
 8012 instruct xchgP( memory mem, rRegP newval) %{
 8013   match(Set newval (GetAndSetP mem newval));
 8014   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 8015   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 8016   ins_encode %{
 8017     __ xchgq($newval$$Register, $mem$$Address);
 8018   %}
 8019   ins_pipe( pipe_cmpxchg );
 8020 %}
 8021 
 8022 instruct xchgN( memory mem, rRegN newval) %{
 8023   match(Set newval (GetAndSetN mem newval));
 8024   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 8025   ins_encode %{
 8026     __ xchgl($newval$$Register, $mem$$Address);
 8027   %}
 8028   ins_pipe( pipe_cmpxchg );
 8029 %}
 8030 
 8031 //----------Abs Instructions-------------------------------------------
 8032 
 8033 // Integer Absolute Instructions
 8034 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 8035 %{
 8036   match(Set dst (AbsI src));
 8037   effect(TEMP dst, TEMP tmp, KILL cr);
 8038   format %{ &quot;movl $tmp, $src\n\t&quot;
 8039             &quot;sarl $tmp, 31\n\t&quot;
 8040             &quot;movl $dst, $src\n\t&quot;
 8041             &quot;xorl $dst, $tmp\n\t&quot;
 8042             &quot;subl $dst, $tmp\n&quot;
 8043           %}
 8044   ins_encode %{
 8045     __ movl($tmp$$Register, $src$$Register);
 8046     __ sarl($tmp$$Register, 31);
 8047     __ movl($dst$$Register, $src$$Register);
 8048     __ xorl($dst$$Register, $tmp$$Register);
 8049     __ subl($dst$$Register, $tmp$$Register);
 8050   %}
 8051 
 8052   ins_pipe(ialu_reg_reg);
 8053 %}
 8054 
 8055 // Long Absolute Instructions
 8056 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8057 %{
 8058   match(Set dst (AbsL src));
 8059   effect(TEMP dst, TEMP tmp, KILL cr);
 8060   format %{ &quot;movq $tmp, $src\n\t&quot;
 8061             &quot;sarq $tmp, 63\n\t&quot;
 8062             &quot;movq $dst, $src\n\t&quot;
 8063             &quot;xorq $dst, $tmp\n\t&quot;
 8064             &quot;subq $dst, $tmp\n&quot;
 8065           %}
 8066   ins_encode %{
 8067     __ movq($tmp$$Register, $src$$Register);
 8068     __ sarq($tmp$$Register, 63);
 8069     __ movq($dst$$Register, $src$$Register);
 8070     __ xorq($dst$$Register, $tmp$$Register);
 8071     __ subq($dst$$Register, $tmp$$Register);
 8072   %}
 8073 
 8074   ins_pipe(ialu_reg_reg);
 8075 %}
 8076 
 8077 //----------Subtraction Instructions-------------------------------------------
 8078 
 8079 // Integer Subtraction Instructions
 8080 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8081 %{
 8082   match(Set dst (SubI dst src));
 8083   effect(KILL cr);
 8084 
 8085   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8086   opcode(0x2B);
 8087   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8088   ins_pipe(ialu_reg_reg);
 8089 %}
 8090 
 8091 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8092 %{
 8093   match(Set dst (SubI dst src));
 8094   effect(KILL cr);
 8095 
 8096   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8097   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8098   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8099   ins_pipe(ialu_reg);
 8100 %}
 8101 
 8102 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8103 %{
 8104   match(Set dst (SubI dst (LoadI src)));
 8105   effect(KILL cr);
 8106 
 8107   ins_cost(125);
 8108   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8109   opcode(0x2B);
 8110   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8111   ins_pipe(ialu_reg_mem);
 8112 %}
 8113 
 8114 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8115 %{
 8116   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8117   effect(KILL cr);
 8118 
 8119   ins_cost(150);
 8120   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8121   opcode(0x29); /* Opcode 29 /r */
 8122   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8123   ins_pipe(ialu_mem_reg);
 8124 %}
 8125 
 8126 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8127 %{
 8128   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8129   effect(KILL cr);
 8130 
 8131   ins_cost(125); // XXX
 8132   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8133   opcode(0x81); /* Opcode 81 /5 id */
 8134   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8135   ins_pipe(ialu_mem_imm);
 8136 %}
 8137 
 8138 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8139 %{
 8140   match(Set dst (SubL dst src));
 8141   effect(KILL cr);
 8142 
 8143   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8144   opcode(0x2B);
 8145   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8146   ins_pipe(ialu_reg_reg);
 8147 %}
 8148 
 8149 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8150 %{
 8151   match(Set dst (SubL dst src));
 8152   effect(KILL cr);
 8153 
 8154   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8155   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8156   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8157   ins_pipe(ialu_reg);
 8158 %}
 8159 
 8160 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8161 %{
 8162   match(Set dst (SubL dst (LoadL src)));
 8163   effect(KILL cr);
 8164 
 8165   ins_cost(125);
 8166   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8167   opcode(0x2B);
 8168   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8169   ins_pipe(ialu_reg_mem);
 8170 %}
 8171 
 8172 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8173 %{
 8174   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8175   effect(KILL cr);
 8176 
 8177   ins_cost(150);
 8178   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8179   opcode(0x29); /* Opcode 29 /r */
 8180   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8181   ins_pipe(ialu_mem_reg);
 8182 %}
 8183 
 8184 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8185 %{
 8186   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8187   effect(KILL cr);
 8188 
 8189   ins_cost(125); // XXX
 8190   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8191   opcode(0x81); /* Opcode 81 /5 id */
 8192   ins_encode(REX_mem_wide(dst),
 8193              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8194   ins_pipe(ialu_mem_imm);
 8195 %}
 8196 
 8197 // Subtract from a pointer
 8198 // XXX hmpf???
 8199 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8200 %{
 8201   match(Set dst (AddP dst (SubI zero src)));
 8202   effect(KILL cr);
 8203 
 8204   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8205   opcode(0x2B);
 8206   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8207   ins_pipe(ialu_reg_reg);
 8208 %}
 8209 
 8210 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8211 %{
 8212   match(Set dst (SubI zero dst));
 8213   effect(KILL cr);
 8214 
 8215   format %{ &quot;negl    $dst\t# int&quot; %}
 8216   opcode(0xF7, 0x03);  // Opcode F7 /3
 8217   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8218   ins_pipe(ialu_reg);
 8219 %}
 8220 
 8221 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8222 %{
 8223   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8224   effect(KILL cr);
 8225 
 8226   format %{ &quot;negl    $dst\t# int&quot; %}
 8227   opcode(0xF7, 0x03);  // Opcode F7 /3
 8228   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8229   ins_pipe(ialu_reg);
 8230 %}
 8231 
 8232 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8233 %{
 8234   match(Set dst (SubL zero dst));
 8235   effect(KILL cr);
 8236 
 8237   format %{ &quot;negq    $dst\t# long&quot; %}
 8238   opcode(0xF7, 0x03);  // Opcode F7 /3
 8239   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8240   ins_pipe(ialu_reg);
 8241 %}
 8242 
 8243 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8244 %{
 8245   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8246   effect(KILL cr);
 8247 
 8248   format %{ &quot;negq    $dst\t# long&quot; %}
 8249   opcode(0xF7, 0x03);  // Opcode F7 /3
 8250   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8251   ins_pipe(ialu_reg);
 8252 %}
 8253 
 8254 //----------Multiplication/Division Instructions-------------------------------
 8255 // Integer Multiplication Instructions
 8256 // Multiply Register
 8257 
 8258 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8259 %{
 8260   match(Set dst (MulI dst src));
 8261   effect(KILL cr);
 8262 
 8263   ins_cost(300);
 8264   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8265   opcode(0x0F, 0xAF);
 8266   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8267   ins_pipe(ialu_reg_reg_alu0);
 8268 %}
 8269 
 8270 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8271 %{
 8272   match(Set dst (MulI src imm));
 8273   effect(KILL cr);
 8274 
 8275   ins_cost(300);
 8276   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8277   opcode(0x69); /* 69 /r id */
 8278   ins_encode(REX_reg_reg(dst, src),
 8279              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8280   ins_pipe(ialu_reg_reg_alu0);
 8281 %}
 8282 
 8283 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8284 %{
 8285   match(Set dst (MulI dst (LoadI src)));
 8286   effect(KILL cr);
 8287 
 8288   ins_cost(350);
 8289   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8290   opcode(0x0F, 0xAF);
 8291   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8292   ins_pipe(ialu_reg_mem_alu0);
 8293 %}
 8294 
 8295 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8296 %{
 8297   match(Set dst (MulI (LoadI src) imm));
 8298   effect(KILL cr);
 8299 
 8300   ins_cost(300);
 8301   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8302   opcode(0x69); /* 69 /r id */
 8303   ins_encode(REX_reg_mem(dst, src),
 8304              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8305   ins_pipe(ialu_reg_mem_alu0);
 8306 %}
 8307 
 8308 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8309 %{
 8310   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8311   effect(KILL cr, KILL src2);
 8312 
 8313   expand %{ mulI_rReg(dst, src1, cr);
 8314            mulI_rReg(src2, src3, cr);
 8315            addI_rReg(dst, src2, cr); %}
 8316 %}
 8317 
 8318 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8319 %{
 8320   match(Set dst (MulL dst src));
 8321   effect(KILL cr);
 8322 
 8323   ins_cost(300);
 8324   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8325   opcode(0x0F, 0xAF);
 8326   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8327   ins_pipe(ialu_reg_reg_alu0);
 8328 %}
 8329 
 8330 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8331 %{
 8332   match(Set dst (MulL src imm));
 8333   effect(KILL cr);
 8334 
 8335   ins_cost(300);
 8336   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8337   opcode(0x69); /* 69 /r id */
 8338   ins_encode(REX_reg_reg_wide(dst, src),
 8339              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8340   ins_pipe(ialu_reg_reg_alu0);
 8341 %}
 8342 
 8343 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8344 %{
 8345   match(Set dst (MulL dst (LoadL src)));
 8346   effect(KILL cr);
 8347 
 8348   ins_cost(350);
 8349   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8350   opcode(0x0F, 0xAF);
 8351   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8352   ins_pipe(ialu_reg_mem_alu0);
 8353 %}
 8354 
 8355 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8356 %{
 8357   match(Set dst (MulL (LoadL src) imm));
 8358   effect(KILL cr);
 8359 
 8360   ins_cost(300);
 8361   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8362   opcode(0x69); /* 69 /r id */
 8363   ins_encode(REX_reg_mem_wide(dst, src),
 8364              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8365   ins_pipe(ialu_reg_mem_alu0);
 8366 %}
 8367 
 8368 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8369 %{
 8370   match(Set dst (MulHiL src rax));
 8371   effect(USE_KILL rax, KILL cr);
 8372 
 8373   ins_cost(300);
 8374   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8375   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8376   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8377   ins_pipe(ialu_reg_reg_alu0);
 8378 %}
 8379 
 8380 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8381                    rFlagsReg cr)
 8382 %{
 8383   match(Set rax (DivI rax div));
 8384   effect(KILL rdx, KILL cr);
 8385 
 8386   ins_cost(30*100+10*100); // XXX
 8387   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8388             &quot;jne,s   normal\n\t&quot;
 8389             &quot;xorl    rdx, rdx\n\t&quot;
 8390             &quot;cmpl    $div, -1\n\t&quot;
 8391             &quot;je,s    done\n&quot;
 8392     &quot;normal: cdql\n\t&quot;
 8393             &quot;idivl   $div\n&quot;
 8394     &quot;done:&quot;        %}
 8395   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8396   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8397   ins_pipe(ialu_reg_reg_alu0);
 8398 %}
 8399 
 8400 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8401                    rFlagsReg cr)
 8402 %{
 8403   match(Set rax (DivL rax div));
 8404   effect(KILL rdx, KILL cr);
 8405 
 8406   ins_cost(30*100+10*100); // XXX
 8407   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8408             &quot;cmpq    rax, rdx\n\t&quot;
 8409             &quot;jne,s   normal\n\t&quot;
 8410             &quot;xorl    rdx, rdx\n\t&quot;
 8411             &quot;cmpq    $div, -1\n\t&quot;
 8412             &quot;je,s    done\n&quot;
 8413     &quot;normal: cdqq\n\t&quot;
 8414             &quot;idivq   $div\n&quot;
 8415     &quot;done:&quot;        %}
 8416   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8417   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8418   ins_pipe(ialu_reg_reg_alu0);
 8419 %}
 8420 
 8421 // Integer DIVMOD with Register, both quotient and mod results
 8422 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8423                              rFlagsReg cr)
 8424 %{
 8425   match(DivModI rax div);
 8426   effect(KILL cr);
 8427 
 8428   ins_cost(30*100+10*100); // XXX
 8429   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8430             &quot;jne,s   normal\n\t&quot;
 8431             &quot;xorl    rdx, rdx\n\t&quot;
 8432             &quot;cmpl    $div, -1\n\t&quot;
 8433             &quot;je,s    done\n&quot;
 8434     &quot;normal: cdql\n\t&quot;
 8435             &quot;idivl   $div\n&quot;
 8436     &quot;done:&quot;        %}
 8437   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8438   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8439   ins_pipe(pipe_slow);
 8440 %}
 8441 
 8442 // Long DIVMOD with Register, both quotient and mod results
 8443 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8444                              rFlagsReg cr)
 8445 %{
 8446   match(DivModL rax div);
 8447   effect(KILL cr);
 8448 
 8449   ins_cost(30*100+10*100); // XXX
 8450   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8451             &quot;cmpq    rax, rdx\n\t&quot;
 8452             &quot;jne,s   normal\n\t&quot;
 8453             &quot;xorl    rdx, rdx\n\t&quot;
 8454             &quot;cmpq    $div, -1\n\t&quot;
 8455             &quot;je,s    done\n&quot;
 8456     &quot;normal: cdqq\n\t&quot;
 8457             &quot;idivq   $div\n&quot;
 8458     &quot;done:&quot;        %}
 8459   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8460   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8461   ins_pipe(pipe_slow);
 8462 %}
 8463 
 8464 //----------- DivL-By-Constant-Expansions--------------------------------------
 8465 // DivI cases are handled by the compiler
 8466 
 8467 // Magic constant, reciprocal of 10
 8468 instruct loadConL_0x6666666666666667(rRegL dst)
 8469 %{
 8470   effect(DEF dst);
 8471 
 8472   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8473   ins_encode(load_immL(dst, 0x6666666666666667));
 8474   ins_pipe(ialu_reg);
 8475 %}
 8476 
 8477 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8478 %{
 8479   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8480 
 8481   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8482   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8483   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8484   ins_pipe(ialu_reg_reg_alu0);
 8485 %}
 8486 
 8487 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8488 %{
 8489   effect(USE_DEF dst, KILL cr);
 8490 
 8491   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8492   opcode(0xC1, 0x7); /* C1 /7 ib */
 8493   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8494   ins_pipe(ialu_reg);
 8495 %}
 8496 
 8497 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8498 %{
 8499   effect(USE_DEF dst, KILL cr);
 8500 
 8501   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8502   opcode(0xC1, 0x7); /* C1 /7 ib */
 8503   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8504   ins_pipe(ialu_reg);
 8505 %}
 8506 
 8507 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8508 %{
 8509   match(Set dst (DivL src div));
 8510 
 8511   ins_cost((5+8)*100);
 8512   expand %{
 8513     rax_RegL rax;                     // Killed temp
 8514     rFlagsReg cr;                     // Killed
 8515     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8516     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8517     sarL_rReg_63(src, cr);            // sarq  src, 63
 8518     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8519     subL_rReg(dst, src, cr);          // subl  rdx, src
 8520   %}
 8521 %}
 8522 
 8523 //-----------------------------------------------------------------------------
 8524 
 8525 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8526                    rFlagsReg cr)
 8527 %{
 8528   match(Set rdx (ModI rax div));
 8529   effect(KILL rax, KILL cr);
 8530 
 8531   ins_cost(300); // XXX
 8532   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8533             &quot;jne,s   normal\n\t&quot;
 8534             &quot;xorl    rdx, rdx\n\t&quot;
 8535             &quot;cmpl    $div, -1\n\t&quot;
 8536             &quot;je,s    done\n&quot;
 8537     &quot;normal: cdql\n\t&quot;
 8538             &quot;idivl   $div\n&quot;
 8539     &quot;done:&quot;        %}
 8540   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8541   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8542   ins_pipe(ialu_reg_reg_alu0);
 8543 %}
 8544 
 8545 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8546                    rFlagsReg cr)
 8547 %{
 8548   match(Set rdx (ModL rax div));
 8549   effect(KILL rax, KILL cr);
 8550 
 8551   ins_cost(300); // XXX
 8552   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8553             &quot;cmpq    rax, rdx\n\t&quot;
 8554             &quot;jne,s   normal\n\t&quot;
 8555             &quot;xorl    rdx, rdx\n\t&quot;
 8556             &quot;cmpq    $div, -1\n\t&quot;
 8557             &quot;je,s    done\n&quot;
 8558     &quot;normal: cdqq\n\t&quot;
 8559             &quot;idivq   $div\n&quot;
 8560     &quot;done:&quot;        %}
 8561   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8562   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8563   ins_pipe(ialu_reg_reg_alu0);
 8564 %}
 8565 
 8566 // Integer Shift Instructions
 8567 // Shift Left by one
 8568 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8569 %{
 8570   match(Set dst (LShiftI dst shift));
 8571   effect(KILL cr);
 8572 
 8573   format %{ &quot;sall    $dst, $shift&quot; %}
 8574   opcode(0xD1, 0x4); /* D1 /4 */
 8575   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8576   ins_pipe(ialu_reg);
 8577 %}
 8578 
 8579 // Shift Left by one
 8580 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8581 %{
 8582   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8583   effect(KILL cr);
 8584 
 8585   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8586   opcode(0xD1, 0x4); /* D1 /4 */
 8587   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8588   ins_pipe(ialu_mem_imm);
 8589 %}
 8590 
 8591 // Shift Left by 8-bit immediate
 8592 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8593 %{
 8594   match(Set dst (LShiftI dst shift));
 8595   effect(KILL cr);
 8596 
 8597   format %{ &quot;sall    $dst, $shift&quot; %}
 8598   opcode(0xC1, 0x4); /* C1 /4 ib */
 8599   ins_encode(reg_opc_imm(dst, shift));
 8600   ins_pipe(ialu_reg);
 8601 %}
 8602 
 8603 // Shift Left by 8-bit immediate
 8604 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8605 %{
 8606   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8607   effect(KILL cr);
 8608 
 8609   format %{ &quot;sall    $dst, $shift&quot; %}
 8610   opcode(0xC1, 0x4); /* C1 /4 ib */
 8611   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8612   ins_pipe(ialu_mem_imm);
 8613 %}
 8614 
 8615 // Shift Left by variable
 8616 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8617 %{
 8618   match(Set dst (LShiftI dst shift));
 8619   effect(KILL cr);
 8620 
 8621   format %{ &quot;sall    $dst, $shift&quot; %}
 8622   opcode(0xD3, 0x4); /* D3 /4 */
 8623   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8624   ins_pipe(ialu_reg_reg);
 8625 %}
 8626 
 8627 // Shift Left by variable
 8628 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8629 %{
 8630   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8631   effect(KILL cr);
 8632 
 8633   format %{ &quot;sall    $dst, $shift&quot; %}
 8634   opcode(0xD3, 0x4); /* D3 /4 */
 8635   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8636   ins_pipe(ialu_mem_reg);
 8637 %}
 8638 
 8639 // Arithmetic shift right by one
 8640 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8641 %{
 8642   match(Set dst (RShiftI dst shift));
 8643   effect(KILL cr);
 8644 
 8645   format %{ &quot;sarl    $dst, $shift&quot; %}
 8646   opcode(0xD1, 0x7); /* D1 /7 */
 8647   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8648   ins_pipe(ialu_reg);
 8649 %}
 8650 
 8651 // Arithmetic shift right by one
 8652 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8653 %{
 8654   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8655   effect(KILL cr);
 8656 
 8657   format %{ &quot;sarl    $dst, $shift&quot; %}
 8658   opcode(0xD1, 0x7); /* D1 /7 */
 8659   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8660   ins_pipe(ialu_mem_imm);
 8661 %}
 8662 
 8663 // Arithmetic Shift Right by 8-bit immediate
 8664 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8665 %{
 8666   match(Set dst (RShiftI dst shift));
 8667   effect(KILL cr);
 8668 
 8669   format %{ &quot;sarl    $dst, $shift&quot; %}
 8670   opcode(0xC1, 0x7); /* C1 /7 ib */
 8671   ins_encode(reg_opc_imm(dst, shift));
 8672   ins_pipe(ialu_mem_imm);
 8673 %}
 8674 
 8675 // Arithmetic Shift Right by 8-bit immediate
 8676 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8677 %{
 8678   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8679   effect(KILL cr);
 8680 
 8681   format %{ &quot;sarl    $dst, $shift&quot; %}
 8682   opcode(0xC1, 0x7); /* C1 /7 ib */
 8683   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8684   ins_pipe(ialu_mem_imm);
 8685 %}
 8686 
 8687 // Arithmetic Shift Right by variable
 8688 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8689 %{
 8690   match(Set dst (RShiftI dst shift));
 8691   effect(KILL cr);
 8692 
 8693   format %{ &quot;sarl    $dst, $shift&quot; %}
 8694   opcode(0xD3, 0x7); /* D3 /7 */
 8695   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8696   ins_pipe(ialu_reg_reg);
 8697 %}
 8698 
 8699 // Arithmetic Shift Right by variable
 8700 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8701 %{
 8702   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8703   effect(KILL cr);
 8704 
 8705   format %{ &quot;sarl    $dst, $shift&quot; %}
 8706   opcode(0xD3, 0x7); /* D3 /7 */
 8707   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8708   ins_pipe(ialu_mem_reg);
 8709 %}
 8710 
 8711 // Logical shift right by one
 8712 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8713 %{
 8714   match(Set dst (URShiftI dst shift));
 8715   effect(KILL cr);
 8716 
 8717   format %{ &quot;shrl    $dst, $shift&quot; %}
 8718   opcode(0xD1, 0x5); /* D1 /5 */
 8719   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8720   ins_pipe(ialu_reg);
 8721 %}
 8722 
 8723 // Logical shift right by one
 8724 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8725 %{
 8726   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8727   effect(KILL cr);
 8728 
 8729   format %{ &quot;shrl    $dst, $shift&quot; %}
 8730   opcode(0xD1, 0x5); /* D1 /5 */
 8731   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8732   ins_pipe(ialu_mem_imm);
 8733 %}
 8734 
 8735 // Logical Shift Right by 8-bit immediate
 8736 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8737 %{
 8738   match(Set dst (URShiftI dst shift));
 8739   effect(KILL cr);
 8740 
 8741   format %{ &quot;shrl    $dst, $shift&quot; %}
 8742   opcode(0xC1, 0x5); /* C1 /5 ib */
 8743   ins_encode(reg_opc_imm(dst, shift));
 8744   ins_pipe(ialu_reg);
 8745 %}
 8746 
 8747 // Logical Shift Right by 8-bit immediate
 8748 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8749 %{
 8750   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8751   effect(KILL cr);
 8752 
 8753   format %{ &quot;shrl    $dst, $shift&quot; %}
 8754   opcode(0xC1, 0x5); /* C1 /5 ib */
 8755   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8756   ins_pipe(ialu_mem_imm);
 8757 %}
 8758 
 8759 // Logical Shift Right by variable
 8760 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8761 %{
 8762   match(Set dst (URShiftI dst shift));
 8763   effect(KILL cr);
 8764 
 8765   format %{ &quot;shrl    $dst, $shift&quot; %}
 8766   opcode(0xD3, 0x5); /* D3 /5 */
 8767   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8768   ins_pipe(ialu_reg_reg);
 8769 %}
 8770 
 8771 // Logical Shift Right by variable
 8772 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8773 %{
 8774   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8775   effect(KILL cr);
 8776 
 8777   format %{ &quot;shrl    $dst, $shift&quot; %}
 8778   opcode(0xD3, 0x5); /* D3 /5 */
 8779   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8780   ins_pipe(ialu_mem_reg);
 8781 %}
 8782 
 8783 // Long Shift Instructions
 8784 // Shift Left by one
 8785 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8786 %{
 8787   match(Set dst (LShiftL dst shift));
 8788   effect(KILL cr);
 8789 
 8790   format %{ &quot;salq    $dst, $shift&quot; %}
 8791   opcode(0xD1, 0x4); /* D1 /4 */
 8792   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8793   ins_pipe(ialu_reg);
 8794 %}
 8795 
 8796 // Shift Left by one
 8797 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8798 %{
 8799   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8800   effect(KILL cr);
 8801 
 8802   format %{ &quot;salq    $dst, $shift&quot; %}
 8803   opcode(0xD1, 0x4); /* D1 /4 */
 8804   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8805   ins_pipe(ialu_mem_imm);
 8806 %}
 8807 
 8808 // Shift Left by 8-bit immediate
 8809 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8810 %{
 8811   match(Set dst (LShiftL dst shift));
 8812   effect(KILL cr);
 8813 
 8814   format %{ &quot;salq    $dst, $shift&quot; %}
 8815   opcode(0xC1, 0x4); /* C1 /4 ib */
 8816   ins_encode(reg_opc_imm_wide(dst, shift));
 8817   ins_pipe(ialu_reg);
 8818 %}
 8819 
 8820 // Shift Left by 8-bit immediate
 8821 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8822 %{
 8823   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8824   effect(KILL cr);
 8825 
 8826   format %{ &quot;salq    $dst, $shift&quot; %}
 8827   opcode(0xC1, 0x4); /* C1 /4 ib */
 8828   ins_encode(REX_mem_wide(dst), OpcP,
 8829              RM_opc_mem(secondary, dst), Con8or32(shift));
 8830   ins_pipe(ialu_mem_imm);
 8831 %}
 8832 
 8833 // Shift Left by variable
 8834 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8835 %{
 8836   match(Set dst (LShiftL dst shift));
 8837   effect(KILL cr);
 8838 
 8839   format %{ &quot;salq    $dst, $shift&quot; %}
 8840   opcode(0xD3, 0x4); /* D3 /4 */
 8841   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8842   ins_pipe(ialu_reg_reg);
 8843 %}
 8844 
 8845 // Shift Left by variable
 8846 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8847 %{
 8848   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8849   effect(KILL cr);
 8850 
 8851   format %{ &quot;salq    $dst, $shift&quot; %}
 8852   opcode(0xD3, 0x4); /* D3 /4 */
 8853   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8854   ins_pipe(ialu_mem_reg);
 8855 %}
 8856 
 8857 // Arithmetic shift right by one
 8858 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8859 %{
 8860   match(Set dst (RShiftL dst shift));
 8861   effect(KILL cr);
 8862 
 8863   format %{ &quot;sarq    $dst, $shift&quot; %}
 8864   opcode(0xD1, 0x7); /* D1 /7 */
 8865   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8866   ins_pipe(ialu_reg);
 8867 %}
 8868 
 8869 // Arithmetic shift right by one
 8870 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8871 %{
 8872   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8873   effect(KILL cr);
 8874 
 8875   format %{ &quot;sarq    $dst, $shift&quot; %}
 8876   opcode(0xD1, 0x7); /* D1 /7 */
 8877   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8878   ins_pipe(ialu_mem_imm);
 8879 %}
 8880 
 8881 // Arithmetic Shift Right by 8-bit immediate
 8882 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8883 %{
 8884   match(Set dst (RShiftL dst shift));
 8885   effect(KILL cr);
 8886 
 8887   format %{ &quot;sarq    $dst, $shift&quot; %}
 8888   opcode(0xC1, 0x7); /* C1 /7 ib */
 8889   ins_encode(reg_opc_imm_wide(dst, shift));
 8890   ins_pipe(ialu_mem_imm);
 8891 %}
 8892 
 8893 // Arithmetic Shift Right by 8-bit immediate
 8894 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8895 %{
 8896   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8897   effect(KILL cr);
 8898 
 8899   format %{ &quot;sarq    $dst, $shift&quot; %}
 8900   opcode(0xC1, 0x7); /* C1 /7 ib */
 8901   ins_encode(REX_mem_wide(dst), OpcP,
 8902              RM_opc_mem(secondary, dst), Con8or32(shift));
 8903   ins_pipe(ialu_mem_imm);
 8904 %}
 8905 
 8906 // Arithmetic Shift Right by variable
 8907 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8908 %{
 8909   match(Set dst (RShiftL dst shift));
 8910   effect(KILL cr);
 8911 
 8912   format %{ &quot;sarq    $dst, $shift&quot; %}
 8913   opcode(0xD3, 0x7); /* D3 /7 */
 8914   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8915   ins_pipe(ialu_reg_reg);
 8916 %}
 8917 
 8918 // Arithmetic Shift Right by variable
 8919 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8920 %{
 8921   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8922   effect(KILL cr);
 8923 
 8924   format %{ &quot;sarq    $dst, $shift&quot; %}
 8925   opcode(0xD3, 0x7); /* D3 /7 */
 8926   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8927   ins_pipe(ialu_mem_reg);
 8928 %}
 8929 
 8930 // Logical shift right by one
 8931 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8932 %{
 8933   match(Set dst (URShiftL dst shift));
 8934   effect(KILL cr);
 8935 
 8936   format %{ &quot;shrq    $dst, $shift&quot; %}
 8937   opcode(0xD1, 0x5); /* D1 /5 */
 8938   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8939   ins_pipe(ialu_reg);
 8940 %}
 8941 
 8942 // Logical shift right by one
 8943 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8944 %{
 8945   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8946   effect(KILL cr);
 8947 
 8948   format %{ &quot;shrq    $dst, $shift&quot; %}
 8949   opcode(0xD1, 0x5); /* D1 /5 */
 8950   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8951   ins_pipe(ialu_mem_imm);
 8952 %}
 8953 
 8954 // Logical Shift Right by 8-bit immediate
 8955 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8956 %{
 8957   match(Set dst (URShiftL dst shift));
 8958   effect(KILL cr);
 8959 
 8960   format %{ &quot;shrq    $dst, $shift&quot; %}
 8961   opcode(0xC1, 0x5); /* C1 /5 ib */
 8962   ins_encode(reg_opc_imm_wide(dst, shift));
 8963   ins_pipe(ialu_reg);
 8964 %}
 8965 
 8966 
 8967 // Logical Shift Right by 8-bit immediate
 8968 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8969 %{
 8970   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8971   effect(KILL cr);
 8972 
 8973   format %{ &quot;shrq    $dst, $shift&quot; %}
 8974   opcode(0xC1, 0x5); /* C1 /5 ib */
 8975   ins_encode(REX_mem_wide(dst), OpcP,
 8976              RM_opc_mem(secondary, dst), Con8or32(shift));
 8977   ins_pipe(ialu_mem_imm);
 8978 %}
 8979 
 8980 // Logical Shift Right by variable
 8981 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8982 %{
 8983   match(Set dst (URShiftL dst shift));
 8984   effect(KILL cr);
 8985 
 8986   format %{ &quot;shrq    $dst, $shift&quot; %}
 8987   opcode(0xD3, 0x5); /* D3 /5 */
 8988   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8989   ins_pipe(ialu_reg_reg);
 8990 %}
 8991 
 8992 // Logical Shift Right by variable
 8993 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8994 %{
 8995   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8996   effect(KILL cr);
 8997 
 8998   format %{ &quot;shrq    $dst, $shift&quot; %}
 8999   opcode(0xD3, 0x5); /* D3 /5 */
 9000   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 9001   ins_pipe(ialu_mem_reg);
 9002 %}
 9003 
 9004 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 9005 // This idiom is used by the compiler for the i2b bytecode.
 9006 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 9007 %{
 9008   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 9009 
 9010   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 9011   opcode(0x0F, 0xBE);
 9012   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9013   ins_pipe(ialu_reg_reg);
 9014 %}
 9015 
 9016 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 9017 // This idiom is used by the compiler the i2s bytecode.
 9018 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 9019 %{
 9020   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 9021 
 9022   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 9023   opcode(0x0F, 0xBF);
 9024   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9025   ins_pipe(ialu_reg_reg);
 9026 %}
 9027 
 9028 // ROL/ROR instructions
 9029 
 9030 // ROL expand
 9031 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 9032   effect(KILL cr, USE_DEF dst);
 9033 
 9034   format %{ &quot;roll    $dst&quot; %}
 9035   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9036   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9037   ins_pipe(ialu_reg);
 9038 %}
 9039 
 9040 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 9041   effect(USE_DEF dst, USE shift, KILL cr);
 9042 
 9043   format %{ &quot;roll    $dst, $shift&quot; %}
 9044   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9045   ins_encode( reg_opc_imm(dst, shift) );
 9046   ins_pipe(ialu_reg);
 9047 %}
 9048 
 9049 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9050 %{
 9051   effect(USE_DEF dst, USE shift, KILL cr);
 9052 
 9053   format %{ &quot;roll    $dst, $shift&quot; %}
 9054   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9055   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9056   ins_pipe(ialu_reg_reg);
 9057 %}
 9058 // end of ROL expand
 9059 
 9060 // Rotate Left by one
 9061 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9062 %{
 9063   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9064 
 9065   expand %{
 9066     rolI_rReg_imm1(dst, cr);
 9067   %}
 9068 %}
 9069 
 9070 // Rotate Left by 8-bit immediate
 9071 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9072 %{
 9073   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9074   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9075 
 9076   expand %{
 9077     rolI_rReg_imm8(dst, lshift, cr);
 9078   %}
 9079 %}
 9080 
 9081 // Rotate Left by variable
 9082 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9083 %{
 9084   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9085 
 9086   expand %{
 9087     rolI_rReg_CL(dst, shift, cr);
 9088   %}
 9089 %}
 9090 
 9091 // Rotate Left by variable
 9092 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9093 %{
 9094   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9095 
 9096   expand %{
 9097     rolI_rReg_CL(dst, shift, cr);
 9098   %}
 9099 %}
 9100 
 9101 // ROR expand
 9102 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9103 %{
 9104   effect(USE_DEF dst, KILL cr);
 9105 
 9106   format %{ &quot;rorl    $dst&quot; %}
 9107   opcode(0xD1, 0x1); /* D1 /1 */
 9108   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9109   ins_pipe(ialu_reg);
 9110 %}
 9111 
 9112 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9113 %{
 9114   effect(USE_DEF dst, USE shift, KILL cr);
 9115 
 9116   format %{ &quot;rorl    $dst, $shift&quot; %}
 9117   opcode(0xC1, 0x1); /* C1 /1 ib */
 9118   ins_encode(reg_opc_imm(dst, shift));
 9119   ins_pipe(ialu_reg);
 9120 %}
 9121 
 9122 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9123 %{
 9124   effect(USE_DEF dst, USE shift, KILL cr);
 9125 
 9126   format %{ &quot;rorl    $dst, $shift&quot; %}
 9127   opcode(0xD3, 0x1); /* D3 /1 */
 9128   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9129   ins_pipe(ialu_reg_reg);
 9130 %}
 9131 // end of ROR expand
 9132 
 9133 // Rotate Right by one
 9134 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9135 %{
 9136   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9137 
 9138   expand %{
 9139     rorI_rReg_imm1(dst, cr);
 9140   %}
 9141 %}
 9142 
 9143 // Rotate Right by 8-bit immediate
 9144 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9145 %{
 9146   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9147   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9148 
 9149   expand %{
 9150     rorI_rReg_imm8(dst, rshift, cr);
 9151   %}
 9152 %}
 9153 
 9154 // Rotate Right by variable
 9155 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9156 %{
 9157   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9158 
 9159   expand %{
 9160     rorI_rReg_CL(dst, shift, cr);
 9161   %}
 9162 %}
 9163 
 9164 // Rotate Right by variable
 9165 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9166 %{
 9167   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9168 
 9169   expand %{
 9170     rorI_rReg_CL(dst, shift, cr);
 9171   %}
 9172 %}
 9173 
 9174 // for long rotate
 9175 // ROL expand
 9176 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9177   effect(USE_DEF dst, KILL cr);
 9178 
 9179   format %{ &quot;rolq    $dst&quot; %}
 9180   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9181   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9182   ins_pipe(ialu_reg);
 9183 %}
 9184 
 9185 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9186   effect(USE_DEF dst, USE shift, KILL cr);
 9187 
 9188   format %{ &quot;rolq    $dst, $shift&quot; %}
 9189   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9190   ins_encode( reg_opc_imm_wide(dst, shift) );
 9191   ins_pipe(ialu_reg);
 9192 %}
 9193 
 9194 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9195 %{
 9196   effect(USE_DEF dst, USE shift, KILL cr);
 9197 
 9198   format %{ &quot;rolq    $dst, $shift&quot; %}
 9199   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9200   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9201   ins_pipe(ialu_reg_reg);
 9202 %}
 9203 // end of ROL expand
 9204 
 9205 // Rotate Left by one
 9206 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9207 %{
 9208   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9209 
 9210   expand %{
 9211     rolL_rReg_imm1(dst, cr);
 9212   %}
 9213 %}
 9214 
 9215 // Rotate Left by 8-bit immediate
 9216 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9217 %{
 9218   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9219   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9220 
 9221   expand %{
 9222     rolL_rReg_imm8(dst, lshift, cr);
 9223   %}
 9224 %}
 9225 
 9226 // Rotate Left by variable
 9227 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9228 %{
 9229   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9230 
 9231   expand %{
 9232     rolL_rReg_CL(dst, shift, cr);
 9233   %}
 9234 %}
 9235 
 9236 // Rotate Left by variable
 9237 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9238 %{
 9239   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9240 
 9241   expand %{
 9242     rolL_rReg_CL(dst, shift, cr);
 9243   %}
 9244 %}
 9245 
 9246 // ROR expand
 9247 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9248 %{
 9249   effect(USE_DEF dst, KILL cr);
 9250 
 9251   format %{ &quot;rorq    $dst&quot; %}
 9252   opcode(0xD1, 0x1); /* D1 /1 */
 9253   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9254   ins_pipe(ialu_reg);
 9255 %}
 9256 
 9257 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9258 %{
 9259   effect(USE_DEF dst, USE shift, KILL cr);
 9260 
 9261   format %{ &quot;rorq    $dst, $shift&quot; %}
 9262   opcode(0xC1, 0x1); /* C1 /1 ib */
 9263   ins_encode(reg_opc_imm_wide(dst, shift));
 9264   ins_pipe(ialu_reg);
 9265 %}
 9266 
 9267 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9268 %{
 9269   effect(USE_DEF dst, USE shift, KILL cr);
 9270 
 9271   format %{ &quot;rorq    $dst, $shift&quot; %}
 9272   opcode(0xD3, 0x1); /* D3 /1 */
 9273   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9274   ins_pipe(ialu_reg_reg);
 9275 %}
 9276 // end of ROR expand
 9277 
 9278 // Rotate Right by one
 9279 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9280 %{
 9281   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9282 
 9283   expand %{
 9284     rorL_rReg_imm1(dst, cr);
 9285   %}
 9286 %}
 9287 
 9288 // Rotate Right by 8-bit immediate
 9289 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9290 %{
 9291   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9292   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9293 
 9294   expand %{
 9295     rorL_rReg_imm8(dst, rshift, cr);
 9296   %}
 9297 %}
 9298 
 9299 // Rotate Right by variable
 9300 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9301 %{
 9302   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9303 
 9304   expand %{
 9305     rorL_rReg_CL(dst, shift, cr);
 9306   %}
 9307 %}
 9308 
 9309 // Rotate Right by variable
 9310 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9311 %{
 9312   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9313 
 9314   expand %{
 9315     rorL_rReg_CL(dst, shift, cr);
 9316   %}
 9317 %}
 9318 
 9319 // Logical Instructions
 9320 
 9321 // Integer Logical Instructions
 9322 
 9323 // And Instructions
 9324 // And Register with Register
 9325 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9326 %{
 9327   match(Set dst (AndI dst src));
 9328   effect(KILL cr);
 9329 
 9330   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9331   opcode(0x23);
 9332   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9333   ins_pipe(ialu_reg_reg);
 9334 %}
 9335 
 9336 // And Register with Immediate 255
 9337 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9338 %{
 9339   match(Set dst (AndI dst src));
 9340 
 9341   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9342   opcode(0x0F, 0xB6);
 9343   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9344   ins_pipe(ialu_reg);
 9345 %}
 9346 
 9347 // And Register with Immediate 255 and promote to long
 9348 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9349 %{
 9350   match(Set dst (ConvI2L (AndI src mask)));
 9351 
 9352   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9353   opcode(0x0F, 0xB6);
 9354   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9355   ins_pipe(ialu_reg);
 9356 %}
 9357 
 9358 // And Register with Immediate 65535
 9359 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9360 %{
 9361   match(Set dst (AndI dst src));
 9362 
 9363   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9364   opcode(0x0F, 0xB7);
 9365   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9366   ins_pipe(ialu_reg);
 9367 %}
 9368 
 9369 // And Register with Immediate 65535 and promote to long
 9370 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9371 %{
 9372   match(Set dst (ConvI2L (AndI src mask)));
 9373 
 9374   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9375   opcode(0x0F, 0xB7);
 9376   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9377   ins_pipe(ialu_reg);
 9378 %}
 9379 
 9380 // And Register with Immediate
 9381 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9382 %{
 9383   match(Set dst (AndI dst src));
 9384   effect(KILL cr);
 9385 
 9386   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9387   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9388   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9389   ins_pipe(ialu_reg);
 9390 %}
 9391 
 9392 // And Register with Memory
 9393 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9394 %{
 9395   match(Set dst (AndI dst (LoadI src)));
 9396   effect(KILL cr);
 9397 
 9398   ins_cost(125);
 9399   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9400   opcode(0x23);
 9401   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9402   ins_pipe(ialu_reg_mem);
 9403 %}
 9404 
 9405 // And Memory with Register
 9406 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9407 %{
 9408   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9409   effect(KILL cr);
 9410 
 9411   ins_cost(150);
 9412   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9413   opcode(0x20);
 9414   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9415   ins_pipe(ialu_mem_reg);
 9416 %}
 9417 
 9418 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9419 %{
 9420   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9421   effect(KILL cr);
 9422 
 9423   ins_cost(150);
 9424   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9425   opcode(0x21); /* Opcode 21 /r */
 9426   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9427   ins_pipe(ialu_mem_reg);
 9428 %}
 9429 
 9430 // And Memory with Immediate
 9431 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9432 %{
 9433   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9434   effect(KILL cr);
 9435 
 9436   ins_cost(125);
 9437   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9438   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9439   ins_encode(REX_mem(dst), OpcSE(src),
 9440              RM_opc_mem(secondary, dst), Con8or32(src));
 9441   ins_pipe(ialu_mem_imm);
 9442 %}
 9443 
 9444 // BMI1 instructions
 9445 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9446   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9447   predicate(UseBMI1Instructions);
 9448   effect(KILL cr);
 9449 
 9450   ins_cost(125);
 9451   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9452 
 9453   ins_encode %{
 9454     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9455   %}
 9456   ins_pipe(ialu_reg_mem);
 9457 %}
 9458 
 9459 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9460   match(Set dst (AndI (XorI src1 minus_1) src2));
 9461   predicate(UseBMI1Instructions);
 9462   effect(KILL cr);
 9463 
 9464   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9465 
 9466   ins_encode %{
 9467     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9468   %}
 9469   ins_pipe(ialu_reg);
 9470 %}
 9471 
 9472 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9473   match(Set dst (AndI (SubI imm_zero src) src));
 9474   predicate(UseBMI1Instructions);
 9475   effect(KILL cr);
 9476 
 9477   format %{ &quot;blsil  $dst, $src&quot; %}
 9478 
 9479   ins_encode %{
 9480     __ blsil($dst$$Register, $src$$Register);
 9481   %}
 9482   ins_pipe(ialu_reg);
 9483 %}
 9484 
 9485 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9486   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9487   predicate(UseBMI1Instructions);
 9488   effect(KILL cr);
 9489 
 9490   ins_cost(125);
 9491   format %{ &quot;blsil  $dst, $src&quot; %}
 9492 
 9493   ins_encode %{
 9494     __ blsil($dst$$Register, $src$$Address);
 9495   %}
 9496   ins_pipe(ialu_reg_mem);
 9497 %}
 9498 
 9499 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9500 %{
 9501   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9502   predicate(UseBMI1Instructions);
 9503   effect(KILL cr);
 9504 
 9505   ins_cost(125);
 9506   format %{ &quot;blsmskl $dst, $src&quot; %}
 9507 
 9508   ins_encode %{
 9509     __ blsmskl($dst$$Register, $src$$Address);
 9510   %}
 9511   ins_pipe(ialu_reg_mem);
 9512 %}
 9513 
 9514 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9515 %{
 9516   match(Set dst (XorI (AddI src minus_1) src));
 9517   predicate(UseBMI1Instructions);
 9518   effect(KILL cr);
 9519 
 9520   format %{ &quot;blsmskl $dst, $src&quot; %}
 9521 
 9522   ins_encode %{
 9523     __ blsmskl($dst$$Register, $src$$Register);
 9524   %}
 9525 
 9526   ins_pipe(ialu_reg);
 9527 %}
 9528 
 9529 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9530 %{
 9531   match(Set dst (AndI (AddI src minus_1) src) );
 9532   predicate(UseBMI1Instructions);
 9533   effect(KILL cr);
 9534 
 9535   format %{ &quot;blsrl  $dst, $src&quot; %}
 9536 
 9537   ins_encode %{
 9538     __ blsrl($dst$$Register, $src$$Register);
 9539   %}
 9540 
 9541   ins_pipe(ialu_reg_mem);
 9542 %}
 9543 
 9544 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9545 %{
 9546   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9547   predicate(UseBMI1Instructions);
 9548   effect(KILL cr);
 9549 
 9550   ins_cost(125);
 9551   format %{ &quot;blsrl  $dst, $src&quot; %}
 9552 
 9553   ins_encode %{
 9554     __ blsrl($dst$$Register, $src$$Address);
 9555   %}
 9556 
 9557   ins_pipe(ialu_reg);
 9558 %}
 9559 
 9560 // Or Instructions
 9561 // Or Register with Register
 9562 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9563 %{
 9564   match(Set dst (OrI dst src));
 9565   effect(KILL cr);
 9566 
 9567   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9568   opcode(0x0B);
 9569   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9570   ins_pipe(ialu_reg_reg);
 9571 %}
 9572 
 9573 // Or Register with Immediate
 9574 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9575 %{
 9576   match(Set dst (OrI dst src));
 9577   effect(KILL cr);
 9578 
 9579   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9580   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9581   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9582   ins_pipe(ialu_reg);
 9583 %}
 9584 
 9585 // Or Register with Memory
 9586 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9587 %{
 9588   match(Set dst (OrI dst (LoadI src)));
 9589   effect(KILL cr);
 9590 
 9591   ins_cost(125);
 9592   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9593   opcode(0x0B);
 9594   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9595   ins_pipe(ialu_reg_mem);
 9596 %}
 9597 
 9598 // Or Memory with Register
 9599 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9600 %{
 9601   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9602   effect(KILL cr);
 9603 
 9604   ins_cost(150);
 9605   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9606   opcode(0x08);
 9607   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9608   ins_pipe(ialu_mem_reg);
 9609 %}
 9610 
 9611 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9612 %{
 9613   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9614   effect(KILL cr);
 9615 
 9616   ins_cost(150);
 9617   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9618   opcode(0x09); /* Opcode 09 /r */
 9619   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9620   ins_pipe(ialu_mem_reg);
 9621 %}
 9622 
 9623 // Or Memory with Immediate
 9624 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9625 %{
 9626   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9627   effect(KILL cr);
 9628 
 9629   ins_cost(125);
 9630   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9631   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9632   ins_encode(REX_mem(dst), OpcSE(src),
 9633              RM_opc_mem(secondary, dst), Con8or32(src));
 9634   ins_pipe(ialu_mem_imm);
 9635 %}
 9636 
 9637 // Xor Instructions
 9638 // Xor Register with Register
 9639 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9640 %{
 9641   match(Set dst (XorI dst src));
 9642   effect(KILL cr);
 9643 
 9644   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9645   opcode(0x33);
 9646   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9647   ins_pipe(ialu_reg_reg);
 9648 %}
 9649 
 9650 // Xor Register with Immediate -1
 9651 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9652   match(Set dst (XorI dst imm));
 9653 
 9654   format %{ &quot;not    $dst&quot; %}
 9655   ins_encode %{
 9656      __ notl($dst$$Register);
 9657   %}
 9658   ins_pipe(ialu_reg);
 9659 %}
 9660 
 9661 // Xor Register with Immediate
 9662 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9663 %{
 9664   match(Set dst (XorI dst src));
 9665   effect(KILL cr);
 9666 
 9667   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9668   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9669   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9670   ins_pipe(ialu_reg);
 9671 %}
 9672 
 9673 // Xor Register with Memory
 9674 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9675 %{
 9676   match(Set dst (XorI dst (LoadI src)));
 9677   effect(KILL cr);
 9678 
 9679   ins_cost(125);
 9680   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9681   opcode(0x33);
 9682   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9683   ins_pipe(ialu_reg_mem);
 9684 %}
 9685 
 9686 // Xor Memory with Register
 9687 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9688 %{
 9689   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9690   effect(KILL cr);
 9691 
 9692   ins_cost(150);
 9693   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9694   opcode(0x30);
 9695   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9696   ins_pipe(ialu_mem_reg);
 9697 %}
 9698 
 9699 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9700 %{
 9701   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9702   effect(KILL cr);
 9703 
 9704   ins_cost(150);
 9705   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9706   opcode(0x31); /* Opcode 31 /r */
 9707   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9708   ins_pipe(ialu_mem_reg);
 9709 %}
 9710 
 9711 // Xor Memory with Immediate
 9712 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9713 %{
 9714   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9715   effect(KILL cr);
 9716 
 9717   ins_cost(125);
 9718   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9719   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9720   ins_encode(REX_mem(dst), OpcSE(src),
 9721              RM_opc_mem(secondary, dst), Con8or32(src));
 9722   ins_pipe(ialu_mem_imm);
 9723 %}
 9724 
 9725 
 9726 // Long Logical Instructions
 9727 
 9728 // And Instructions
 9729 // And Register with Register
 9730 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9731 %{
 9732   match(Set dst (AndL dst src));
 9733   effect(KILL cr);
 9734 
 9735   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9736   opcode(0x23);
 9737   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9738   ins_pipe(ialu_reg_reg);
 9739 %}
 9740 
 9741 // And Register with Immediate 255
 9742 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9743 %{
 9744   match(Set dst (AndL dst src));
 9745 
 9746   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9747   opcode(0x0F, 0xB6);
 9748   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9749   ins_pipe(ialu_reg);
 9750 %}
 9751 
 9752 // And Register with Immediate 65535
 9753 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9754 %{
 9755   match(Set dst (AndL dst src));
 9756 
 9757   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9758   opcode(0x0F, 0xB7);
 9759   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9760   ins_pipe(ialu_reg);
 9761 %}
 9762 
 9763 // And Register with Immediate
 9764 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9765 %{
 9766   match(Set dst (AndL dst src));
 9767   effect(KILL cr);
 9768 
 9769   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9770   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9771   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9772   ins_pipe(ialu_reg);
 9773 %}
 9774 
 9775 // And Register with Memory
 9776 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9777 %{
 9778   match(Set dst (AndL dst (LoadL src)));
 9779   effect(KILL cr);
 9780 
 9781   ins_cost(125);
 9782   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9783   opcode(0x23);
 9784   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9785   ins_pipe(ialu_reg_mem);
 9786 %}
 9787 
 9788 // And Memory with Register
 9789 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9790 %{
 9791   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9792   effect(KILL cr);
 9793 
 9794   ins_cost(150);
 9795   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9796   opcode(0x21); /* Opcode 21 /r */
 9797   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9798   ins_pipe(ialu_mem_reg);
 9799 %}
 9800 
 9801 // And Memory with Immediate
 9802 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9803 %{
 9804   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9805   effect(KILL cr);
 9806 
 9807   ins_cost(125);
 9808   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9809   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9810   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9811              RM_opc_mem(secondary, dst), Con8or32(src));
 9812   ins_pipe(ialu_mem_imm);
 9813 %}
 9814 
 9815 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9816 %{
 9817   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9818   // because AND/OR works well enough for 8/32-bit values.
 9819   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9820 
 9821   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9822   effect(KILL cr);
 9823 
 9824   ins_cost(125);
 9825   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9826   ins_encode %{
 9827     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9828   %}
 9829   ins_pipe(ialu_mem_imm);
 9830 %}
 9831 
 9832 // BMI1 instructions
 9833 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9834   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9835   predicate(UseBMI1Instructions);
 9836   effect(KILL cr);
 9837 
 9838   ins_cost(125);
 9839   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9840 
 9841   ins_encode %{
 9842     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9843   %}
 9844   ins_pipe(ialu_reg_mem);
 9845 %}
 9846 
 9847 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9848   match(Set dst (AndL (XorL src1 minus_1) src2));
 9849   predicate(UseBMI1Instructions);
 9850   effect(KILL cr);
 9851 
 9852   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9853 
 9854   ins_encode %{
 9855   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9856   %}
 9857   ins_pipe(ialu_reg_mem);
 9858 %}
 9859 
 9860 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9861   match(Set dst (AndL (SubL imm_zero src) src));
 9862   predicate(UseBMI1Instructions);
 9863   effect(KILL cr);
 9864 
 9865   format %{ &quot;blsiq  $dst, $src&quot; %}
 9866 
 9867   ins_encode %{
 9868     __ blsiq($dst$$Register, $src$$Register);
 9869   %}
 9870   ins_pipe(ialu_reg);
 9871 %}
 9872 
 9873 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9874   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9875   predicate(UseBMI1Instructions);
 9876   effect(KILL cr);
 9877 
 9878   ins_cost(125);
 9879   format %{ &quot;blsiq  $dst, $src&quot; %}
 9880 
 9881   ins_encode %{
 9882     __ blsiq($dst$$Register, $src$$Address);
 9883   %}
 9884   ins_pipe(ialu_reg_mem);
 9885 %}
 9886 
 9887 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9888 %{
 9889   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9890   predicate(UseBMI1Instructions);
 9891   effect(KILL cr);
 9892 
 9893   ins_cost(125);
 9894   format %{ &quot;blsmskq $dst, $src&quot; %}
 9895 
 9896   ins_encode %{
 9897     __ blsmskq($dst$$Register, $src$$Address);
 9898   %}
 9899   ins_pipe(ialu_reg_mem);
 9900 %}
 9901 
 9902 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9903 %{
 9904   match(Set dst (XorL (AddL src minus_1) src));
 9905   predicate(UseBMI1Instructions);
 9906   effect(KILL cr);
 9907 
 9908   format %{ &quot;blsmskq $dst, $src&quot; %}
 9909 
 9910   ins_encode %{
 9911     __ blsmskq($dst$$Register, $src$$Register);
 9912   %}
 9913 
 9914   ins_pipe(ialu_reg);
 9915 %}
 9916 
 9917 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9918 %{
 9919   match(Set dst (AndL (AddL src minus_1) src) );
 9920   predicate(UseBMI1Instructions);
 9921   effect(KILL cr);
 9922 
 9923   format %{ &quot;blsrq  $dst, $src&quot; %}
 9924 
 9925   ins_encode %{
 9926     __ blsrq($dst$$Register, $src$$Register);
 9927   %}
 9928 
 9929   ins_pipe(ialu_reg);
 9930 %}
 9931 
 9932 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9933 %{
 9934   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9935   predicate(UseBMI1Instructions);
 9936   effect(KILL cr);
 9937 
 9938   ins_cost(125);
 9939   format %{ &quot;blsrq  $dst, $src&quot; %}
 9940 
 9941   ins_encode %{
 9942     __ blsrq($dst$$Register, $src$$Address);
 9943   %}
 9944 
 9945   ins_pipe(ialu_reg);
 9946 %}
 9947 
 9948 // Or Instructions
 9949 // Or Register with Register
 9950 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9951 %{
 9952   match(Set dst (OrL dst src));
 9953   effect(KILL cr);
 9954 
 9955   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9956   opcode(0x0B);
 9957   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9958   ins_pipe(ialu_reg_reg);
 9959 %}
 9960 
 9961 // Use any_RegP to match R15 (TLS register) without spilling.
 9962 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
 9963   match(Set dst (OrL dst (CastP2X src)));
 9964   effect(KILL cr);
 9965 
 9966   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9967   opcode(0x0B);
 9968   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9969   ins_pipe(ialu_reg_reg);
 9970 %}
 9971 
 9972 
 9973 // Or Register with Immediate
 9974 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9975 %{
 9976   match(Set dst (OrL dst src));
 9977   effect(KILL cr);
 9978 
 9979   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9980   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9981   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9982   ins_pipe(ialu_reg);
 9983 %}
 9984 
 9985 // Or Register with Memory
 9986 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9987 %{
 9988   match(Set dst (OrL dst (LoadL src)));
 9989   effect(KILL cr);
 9990 
 9991   ins_cost(125);
 9992   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9993   opcode(0x0B);
 9994   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9995   ins_pipe(ialu_reg_mem);
 9996 %}
 9997 
 9998 // Or Memory with Register
 9999 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10000 %{
10001   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10002   effect(KILL cr);
10003 
10004   ins_cost(150);
10005   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10006   opcode(0x09); /* Opcode 09 /r */
10007   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10008   ins_pipe(ialu_mem_reg);
10009 %}
10010 
10011 // Or Memory with Immediate
10012 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10013 %{
10014   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10015   effect(KILL cr);
10016 
10017   ins_cost(125);
10018   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10019   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10020   ins_encode(REX_mem_wide(dst), OpcSE(src),
10021              RM_opc_mem(secondary, dst), Con8or32(src));
10022   ins_pipe(ialu_mem_imm);
10023 %}
10024 
10025 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
10026 %{
10027   // con should be a pure 64-bit power of 2 immediate
10028   // because AND/OR works well enough for 8/32-bit values.
10029   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
10030 
10031   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
10032   effect(KILL cr);
10033 
10034   ins_cost(125);
10035   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
10036   ins_encode %{
10037     __ btsq($dst$$Address, log2_long((julong)$con$$constant));
10038   %}
10039   ins_pipe(ialu_mem_imm);
10040 %}
10041 
10042 // Xor Instructions
10043 // Xor Register with Register
10044 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10045 %{
10046   match(Set dst (XorL dst src));
10047   effect(KILL cr);
10048 
10049   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10050   opcode(0x33);
10051   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10052   ins_pipe(ialu_reg_reg);
10053 %}
10054 
10055 // Xor Register with Immediate -1
10056 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10057   match(Set dst (XorL dst imm));
10058 
10059   format %{ &quot;notq   $dst&quot; %}
10060   ins_encode %{
10061      __ notq($dst$$Register);
10062   %}
10063   ins_pipe(ialu_reg);
10064 %}
10065 
10066 // Xor Register with Immediate
10067 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10068 %{
10069   match(Set dst (XorL dst src));
10070   effect(KILL cr);
10071 
10072   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10073   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10074   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10075   ins_pipe(ialu_reg);
10076 %}
10077 
10078 // Xor Register with Memory
10079 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10080 %{
10081   match(Set dst (XorL dst (LoadL src)));
10082   effect(KILL cr);
10083 
10084   ins_cost(125);
10085   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10086   opcode(0x33);
10087   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10088   ins_pipe(ialu_reg_mem);
10089 %}
10090 
10091 // Xor Memory with Register
10092 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10093 %{
10094   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10095   effect(KILL cr);
10096 
10097   ins_cost(150);
10098   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10099   opcode(0x31); /* Opcode 31 /r */
10100   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10101   ins_pipe(ialu_mem_reg);
10102 %}
10103 
10104 // Xor Memory with Immediate
10105 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10106 %{
10107   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10108   effect(KILL cr);
10109 
10110   ins_cost(125);
10111   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10112   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10113   ins_encode(REX_mem_wide(dst), OpcSE(src),
10114              RM_opc_mem(secondary, dst), Con8or32(src));
10115   ins_pipe(ialu_mem_imm);
10116 %}
10117 
10118 // Convert Int to Boolean
10119 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10120 %{
10121   match(Set dst (Conv2B src));
10122   effect(KILL cr);
10123 
10124   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10125             &quot;setnz   $dst\n\t&quot;
10126             &quot;movzbl  $dst, $dst&quot; %}
10127   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10128              setNZ_reg(dst),
10129              REX_reg_breg(dst, dst), // movzbl
10130              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10131   ins_pipe(pipe_slow); // XXX
10132 %}
10133 
10134 // Convert Pointer to Boolean
10135 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10136 %{
10137   match(Set dst (Conv2B src));
10138   effect(KILL cr);
10139 
10140   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10141             &quot;setnz   $dst\n\t&quot;
10142             &quot;movzbl  $dst, $dst&quot; %}
10143   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10144              setNZ_reg(dst),
10145              REX_reg_breg(dst, dst), // movzbl
10146              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10147   ins_pipe(pipe_slow); // XXX
10148 %}
10149 
10150 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10151 %{
10152   match(Set dst (CmpLTMask p q));
10153   effect(KILL cr);
10154 
10155   ins_cost(400);
10156   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10157             &quot;setlt   $dst\n\t&quot;
10158             &quot;movzbl  $dst, $dst\n\t&quot;
10159             &quot;negl    $dst&quot; %}
10160   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10161              setLT_reg(dst),
10162              REX_reg_breg(dst, dst), // movzbl
10163              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10164              neg_reg(dst));
10165   ins_pipe(pipe_slow);
10166 %}
10167 
10168 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10169 %{
10170   match(Set dst (CmpLTMask dst zero));
10171   effect(KILL cr);
10172 
10173   ins_cost(100);
10174   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10175   ins_encode %{
10176   __ sarl($dst$$Register, 31);
10177   %}
10178   ins_pipe(ialu_reg);
10179 %}
10180 
10181 /* Better to save a register than avoid a branch */
10182 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10183 %{
10184   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10185   effect(KILL cr);
10186   ins_cost(300);
10187   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10188             &quot;jge     done\n\t&quot;
10189             &quot;addl    $p,$y\n&quot;
10190             &quot;done:   &quot; %}
10191   ins_encode %{
10192     Register Rp = $p$$Register;
10193     Register Rq = $q$$Register;
10194     Register Ry = $y$$Register;
10195     Label done;
10196     __ subl(Rp, Rq);
10197     __ jccb(Assembler::greaterEqual, done);
10198     __ addl(Rp, Ry);
10199     __ bind(done);
10200   %}
10201   ins_pipe(pipe_cmplt);
10202 %}
10203 
10204 /* Better to save a register than avoid a branch */
10205 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10206 %{
10207   match(Set y (AndI (CmpLTMask p q) y));
10208   effect(KILL cr);
10209 
10210   ins_cost(300);
10211 
10212   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10213             &quot;jlt     done\n\t&quot;
10214             &quot;xorl    $y, $y\n&quot;
10215             &quot;done:   &quot; %}
10216   ins_encode %{
10217     Register Rp = $p$$Register;
10218     Register Rq = $q$$Register;
10219     Register Ry = $y$$Register;
10220     Label done;
10221     __ cmpl(Rp, Rq);
10222     __ jccb(Assembler::less, done);
10223     __ xorl(Ry, Ry);
10224     __ bind(done);
10225   %}
10226   ins_pipe(pipe_cmplt);
10227 %}
10228 
10229 
10230 //---------- FP Instructions------------------------------------------------
10231 
10232 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10233 %{
10234   match(Set cr (CmpF src1 src2));
10235 
10236   ins_cost(145);
10237   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10238             &quot;jnp,s   exit\n\t&quot;
10239             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10240             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10241             &quot;popfq\n&quot;
10242     &quot;exit:&quot; %}
10243   ins_encode %{
10244     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10245     emit_cmpfp_fixup(_masm);
10246   %}
10247   ins_pipe(pipe_slow);
10248 %}
10249 
10250 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10251   match(Set cr (CmpF src1 src2));
10252 
10253   ins_cost(100);
10254   format %{ &quot;ucomiss $src1, $src2&quot; %}
10255   ins_encode %{
10256     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10257   %}
10258   ins_pipe(pipe_slow);
10259 %}
10260 
10261 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10262 %{
10263   match(Set cr (CmpF src1 (LoadF src2)));
10264 
10265   ins_cost(145);
10266   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10267             &quot;jnp,s   exit\n\t&quot;
10268             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10269             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10270             &quot;popfq\n&quot;
10271     &quot;exit:&quot; %}
10272   ins_encode %{
10273     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10274     emit_cmpfp_fixup(_masm);
10275   %}
10276   ins_pipe(pipe_slow);
10277 %}
10278 
10279 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10280   match(Set cr (CmpF src1 (LoadF src2)));
10281 
10282   ins_cost(100);
10283   format %{ &quot;ucomiss $src1, $src2&quot; %}
10284   ins_encode %{
10285     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10286   %}
10287   ins_pipe(pipe_slow);
10288 %}
10289 
10290 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10291   match(Set cr (CmpF src con));
10292 
10293   ins_cost(145);
10294   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10295             &quot;jnp,s   exit\n\t&quot;
10296             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10297             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10298             &quot;popfq\n&quot;
10299     &quot;exit:&quot; %}
10300   ins_encode %{
10301     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10302     emit_cmpfp_fixup(_masm);
10303   %}
10304   ins_pipe(pipe_slow);
10305 %}
10306 
10307 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10308   match(Set cr (CmpF src con));
10309   ins_cost(100);
10310   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10311   ins_encode %{
10312     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10313   %}
10314   ins_pipe(pipe_slow);
10315 %}
10316 
10317 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10318 %{
10319   match(Set cr (CmpD src1 src2));
10320 
10321   ins_cost(145);
10322   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10323             &quot;jnp,s   exit\n\t&quot;
10324             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10325             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10326             &quot;popfq\n&quot;
10327     &quot;exit:&quot; %}
10328   ins_encode %{
10329     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10330     emit_cmpfp_fixup(_masm);
10331   %}
10332   ins_pipe(pipe_slow);
10333 %}
10334 
10335 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10336   match(Set cr (CmpD src1 src2));
10337 
10338   ins_cost(100);
10339   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10340   ins_encode %{
10341     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10342   %}
10343   ins_pipe(pipe_slow);
10344 %}
10345 
10346 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10347 %{
10348   match(Set cr (CmpD src1 (LoadD src2)));
10349 
10350   ins_cost(145);
10351   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10352             &quot;jnp,s   exit\n\t&quot;
10353             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10354             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10355             &quot;popfq\n&quot;
10356     &quot;exit:&quot; %}
10357   ins_encode %{
10358     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10359     emit_cmpfp_fixup(_masm);
10360   %}
10361   ins_pipe(pipe_slow);
10362 %}
10363 
10364 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10365   match(Set cr (CmpD src1 (LoadD src2)));
10366 
10367   ins_cost(100);
10368   format %{ &quot;ucomisd $src1, $src2&quot; %}
10369   ins_encode %{
10370     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10371   %}
10372   ins_pipe(pipe_slow);
10373 %}
10374 
10375 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10376   match(Set cr (CmpD src con));
10377 
10378   ins_cost(145);
10379   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10380             &quot;jnp,s   exit\n\t&quot;
10381             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10382             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10383             &quot;popfq\n&quot;
10384     &quot;exit:&quot; %}
10385   ins_encode %{
10386     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10387     emit_cmpfp_fixup(_masm);
10388   %}
10389   ins_pipe(pipe_slow);
10390 %}
10391 
10392 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10393   match(Set cr (CmpD src con));
10394   ins_cost(100);
10395   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10396   ins_encode %{
10397     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10398   %}
10399   ins_pipe(pipe_slow);
10400 %}
10401 
10402 // Compare into -1,0,1
10403 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10404 %{
10405   match(Set dst (CmpF3 src1 src2));
10406   effect(KILL cr);
10407 
10408   ins_cost(275);
10409   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10410             &quot;movl    $dst, #-1\n\t&quot;
10411             &quot;jp,s    done\n\t&quot;
10412             &quot;jb,s    done\n\t&quot;
10413             &quot;setne   $dst\n\t&quot;
10414             &quot;movzbl  $dst, $dst\n&quot;
10415     &quot;done:&quot; %}
10416   ins_encode %{
10417     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10418     emit_cmpfp3(_masm, $dst$$Register);
10419   %}
10420   ins_pipe(pipe_slow);
10421 %}
10422 
10423 // Compare into -1,0,1
10424 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10425 %{
10426   match(Set dst (CmpF3 src1 (LoadF src2)));
10427   effect(KILL cr);
10428 
10429   ins_cost(275);
10430   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10431             &quot;movl    $dst, #-1\n\t&quot;
10432             &quot;jp,s    done\n\t&quot;
10433             &quot;jb,s    done\n\t&quot;
10434             &quot;setne   $dst\n\t&quot;
10435             &quot;movzbl  $dst, $dst\n&quot;
10436     &quot;done:&quot; %}
10437   ins_encode %{
10438     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10439     emit_cmpfp3(_masm, $dst$$Register);
10440   %}
10441   ins_pipe(pipe_slow);
10442 %}
10443 
10444 // Compare into -1,0,1
10445 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10446   match(Set dst (CmpF3 src con));
10447   effect(KILL cr);
10448 
10449   ins_cost(275);
10450   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10451             &quot;movl    $dst, #-1\n\t&quot;
10452             &quot;jp,s    done\n\t&quot;
10453             &quot;jb,s    done\n\t&quot;
10454             &quot;setne   $dst\n\t&quot;
10455             &quot;movzbl  $dst, $dst\n&quot;
10456     &quot;done:&quot; %}
10457   ins_encode %{
10458     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10459     emit_cmpfp3(_masm, $dst$$Register);
10460   %}
10461   ins_pipe(pipe_slow);
10462 %}
10463 
10464 // Compare into -1,0,1
10465 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10466 %{
10467   match(Set dst (CmpD3 src1 src2));
10468   effect(KILL cr);
10469 
10470   ins_cost(275);
10471   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10472             &quot;movl    $dst, #-1\n\t&quot;
10473             &quot;jp,s    done\n\t&quot;
10474             &quot;jb,s    done\n\t&quot;
10475             &quot;setne   $dst\n\t&quot;
10476             &quot;movzbl  $dst, $dst\n&quot;
10477     &quot;done:&quot; %}
10478   ins_encode %{
10479     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10480     emit_cmpfp3(_masm, $dst$$Register);
10481   %}
10482   ins_pipe(pipe_slow);
10483 %}
10484 
10485 // Compare into -1,0,1
10486 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10487 %{
10488   match(Set dst (CmpD3 src1 (LoadD src2)));
10489   effect(KILL cr);
10490 
10491   ins_cost(275);
10492   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10493             &quot;movl    $dst, #-1\n\t&quot;
10494             &quot;jp,s    done\n\t&quot;
10495             &quot;jb,s    done\n\t&quot;
10496             &quot;setne   $dst\n\t&quot;
10497             &quot;movzbl  $dst, $dst\n&quot;
10498     &quot;done:&quot; %}
10499   ins_encode %{
10500     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10501     emit_cmpfp3(_masm, $dst$$Register);
10502   %}
10503   ins_pipe(pipe_slow);
10504 %}
10505 
10506 // Compare into -1,0,1
10507 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10508   match(Set dst (CmpD3 src con));
10509   effect(KILL cr);
10510 
10511   ins_cost(275);
10512   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10513             &quot;movl    $dst, #-1\n\t&quot;
10514             &quot;jp,s    done\n\t&quot;
10515             &quot;jb,s    done\n\t&quot;
10516             &quot;setne   $dst\n\t&quot;
10517             &quot;movzbl  $dst, $dst\n&quot;
10518     &quot;done:&quot; %}
10519   ins_encode %{
10520     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10521     emit_cmpfp3(_masm, $dst$$Register);
10522   %}
10523   ins_pipe(pipe_slow);
10524 %}
10525 
10526 //----------Arithmetic Conversion Instructions---------------------------------
10527 
10528 instruct convF2D_reg_reg(regD dst, regF src)
10529 %{
10530   match(Set dst (ConvF2D src));
10531 
10532   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10533   ins_encode %{
10534     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10535   %}
10536   ins_pipe(pipe_slow); // XXX
10537 %}
10538 
10539 instruct convF2D_reg_mem(regD dst, memory src)
10540 %{
10541   match(Set dst (ConvF2D (LoadF src)));
10542 
10543   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10544   ins_encode %{
10545     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10546   %}
10547   ins_pipe(pipe_slow); // XXX
10548 %}
10549 
10550 instruct convD2F_reg_reg(regF dst, regD src)
10551 %{
10552   match(Set dst (ConvD2F src));
10553 
10554   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10555   ins_encode %{
10556     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10557   %}
10558   ins_pipe(pipe_slow); // XXX
10559 %}
10560 
10561 instruct convD2F_reg_mem(regF dst, memory src)
10562 %{
10563   match(Set dst (ConvD2F (LoadD src)));
10564 
10565   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10566   ins_encode %{
10567     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10568   %}
10569   ins_pipe(pipe_slow); // XXX
10570 %}
10571 
10572 // XXX do mem variants
10573 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10574 %{
10575   match(Set dst (ConvF2I src));
10576   effect(KILL cr);
10577   format %{ &quot;convert_f2i $dst,$src&quot; %}
10578   ins_encode %{
10579     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10580   %}
10581   ins_pipe(pipe_slow);
10582 %}
10583 
10584 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10585 %{
10586   match(Set dst (ConvF2L src));
10587   effect(KILL cr);
10588   format %{ &quot;convert_f2l $dst,$src&quot;%}
10589   ins_encode %{
10590     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10591   %}
10592   ins_pipe(pipe_slow);
10593 %}
10594 
10595 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10596 %{
10597   match(Set dst (ConvD2I src));
10598   effect(KILL cr);
10599   format %{ &quot;convert_d2i $dst,$src&quot;%}
10600   ins_encode %{
10601     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10602   %}
10603   ins_pipe(pipe_slow);
10604 %}
10605 
10606 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10607 %{
10608   match(Set dst (ConvD2L src));
10609   effect(KILL cr);
10610   format %{ &quot;convert_d2l $dst,$src&quot;%}
10611   ins_encode %{
10612     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10613   %}
10614   ins_pipe(pipe_slow);
10615 %}
10616 
10617 instruct convI2F_reg_reg(regF dst, rRegI src)
10618 %{
10619   predicate(!UseXmmI2F);
10620   match(Set dst (ConvI2F src));
10621 
10622   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10623   ins_encode %{
10624     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10625   %}
10626   ins_pipe(pipe_slow); // XXX
10627 %}
10628 
10629 instruct convI2F_reg_mem(regF dst, memory src)
10630 %{
10631   match(Set dst (ConvI2F (LoadI src)));
10632 
10633   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10634   ins_encode %{
10635     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10636   %}
10637   ins_pipe(pipe_slow); // XXX
10638 %}
10639 
10640 instruct convI2D_reg_reg(regD dst, rRegI src)
10641 %{
10642   predicate(!UseXmmI2D);
10643   match(Set dst (ConvI2D src));
10644 
10645   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10646   ins_encode %{
10647     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10648   %}
10649   ins_pipe(pipe_slow); // XXX
10650 %}
10651 
10652 instruct convI2D_reg_mem(regD dst, memory src)
10653 %{
10654   match(Set dst (ConvI2D (LoadI src)));
10655 
10656   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10657   ins_encode %{
10658     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10659   %}
10660   ins_pipe(pipe_slow); // XXX
10661 %}
10662 
10663 instruct convXI2F_reg(regF dst, rRegI src)
10664 %{
10665   predicate(UseXmmI2F);
10666   match(Set dst (ConvI2F src));
10667 
10668   format %{ &quot;movdl $dst, $src\n\t&quot;
10669             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10670   ins_encode %{
10671     __ movdl($dst$$XMMRegister, $src$$Register);
10672     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10673   %}
10674   ins_pipe(pipe_slow); // XXX
10675 %}
10676 
10677 instruct convXI2D_reg(regD dst, rRegI src)
10678 %{
10679   predicate(UseXmmI2D);
10680   match(Set dst (ConvI2D src));
10681 
10682   format %{ &quot;movdl $dst, $src\n\t&quot;
10683             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10684   ins_encode %{
10685     __ movdl($dst$$XMMRegister, $src$$Register);
10686     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10687   %}
10688   ins_pipe(pipe_slow); // XXX
10689 %}
10690 
10691 instruct convL2F_reg_reg(regF dst, rRegL src)
10692 %{
10693   match(Set dst (ConvL2F src));
10694 
10695   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10696   ins_encode %{
10697     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10698   %}
10699   ins_pipe(pipe_slow); // XXX
10700 %}
10701 
10702 instruct convL2F_reg_mem(regF dst, memory src)
10703 %{
10704   match(Set dst (ConvL2F (LoadL src)));
10705 
10706   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10707   ins_encode %{
10708     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10709   %}
10710   ins_pipe(pipe_slow); // XXX
10711 %}
10712 
10713 instruct convL2D_reg_reg(regD dst, rRegL src)
10714 %{
10715   match(Set dst (ConvL2D src));
10716 
10717   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10718   ins_encode %{
10719     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10720   %}
10721   ins_pipe(pipe_slow); // XXX
10722 %}
10723 
10724 instruct convL2D_reg_mem(regD dst, memory src)
10725 %{
10726   match(Set dst (ConvL2D (LoadL src)));
10727 
10728   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10729   ins_encode %{
10730     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10731   %}
10732   ins_pipe(pipe_slow); // XXX
10733 %}
10734 
10735 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10736 %{
10737   match(Set dst (ConvI2L src));
10738 
10739   ins_cost(125);
10740   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10741   ins_encode %{
10742     __ movslq($dst$$Register, $src$$Register);
10743   %}
10744   ins_pipe(ialu_reg_reg);
10745 %}
10746 
10747 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10748 // %{
10749 //   match(Set dst (ConvI2L src));
10750 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10751 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10752 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10753 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10754 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10755 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10756 
10757 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10758 //   ins_encode(enc_copy(dst, src));
10759 // //   opcode(0x63); // needs REX.W
10760 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10761 //   ins_pipe(ialu_reg_reg);
10762 // %}
10763 
10764 // Zero-extend convert int to long
10765 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10766 %{
10767   match(Set dst (AndL (ConvI2L src) mask));
10768 
10769   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10770   ins_encode %{
10771     if ($dst$$reg != $src$$reg) {
10772       __ movl($dst$$Register, $src$$Register);
10773     }
10774   %}
10775   ins_pipe(ialu_reg_reg);
10776 %}
10777 
10778 // Zero-extend convert int to long
10779 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10780 %{
10781   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10782 
10783   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10784   ins_encode %{
10785     __ movl($dst$$Register, $src$$Address);
10786   %}
10787   ins_pipe(ialu_reg_mem);
10788 %}
10789 
10790 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10791 %{
10792   match(Set dst (AndL src mask));
10793 
10794   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10795   ins_encode %{
10796     __ movl($dst$$Register, $src$$Register);
10797   %}
10798   ins_pipe(ialu_reg_reg);
10799 %}
10800 
10801 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10802 %{
10803   match(Set dst (ConvL2I src));
10804 
10805   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10806   ins_encode %{
10807     __ movl($dst$$Register, $src$$Register);
10808   %}
10809   ins_pipe(ialu_reg_reg);
10810 %}
10811 
10812 
10813 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10814   match(Set dst (MoveF2I src));
10815   effect(DEF dst, USE src);
10816 
10817   ins_cost(125);
10818   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10819   ins_encode %{
10820     __ movl($dst$$Register, Address(rsp, $src$$disp));
10821   %}
10822   ins_pipe(ialu_reg_mem);
10823 %}
10824 
10825 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10826   match(Set dst (MoveI2F src));
10827   effect(DEF dst, USE src);
10828 
10829   ins_cost(125);
10830   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10831   ins_encode %{
10832     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10833   %}
10834   ins_pipe(pipe_slow);
10835 %}
10836 
10837 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10838   match(Set dst (MoveD2L src));
10839   effect(DEF dst, USE src);
10840 
10841   ins_cost(125);
10842   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10843   ins_encode %{
10844     __ movq($dst$$Register, Address(rsp, $src$$disp));
10845   %}
10846   ins_pipe(ialu_reg_mem);
10847 %}
10848 
10849 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10850   predicate(!UseXmmLoadAndClearUpper);
10851   match(Set dst (MoveL2D src));
10852   effect(DEF dst, USE src);
10853 
10854   ins_cost(125);
10855   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10856   ins_encode %{
10857     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10858   %}
10859   ins_pipe(pipe_slow);
10860 %}
10861 
10862 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10863   predicate(UseXmmLoadAndClearUpper);
10864   match(Set dst (MoveL2D src));
10865   effect(DEF dst, USE src);
10866 
10867   ins_cost(125);
10868   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10869   ins_encode %{
10870     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10871   %}
10872   ins_pipe(pipe_slow);
10873 %}
10874 
10875 
10876 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10877   match(Set dst (MoveF2I src));
10878   effect(DEF dst, USE src);
10879 
10880   ins_cost(95); // XXX
10881   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10882   ins_encode %{
10883     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10884   %}
10885   ins_pipe(pipe_slow);
10886 %}
10887 
10888 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10889   match(Set dst (MoveI2F src));
10890   effect(DEF dst, USE src);
10891 
10892   ins_cost(100);
10893   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10894   ins_encode %{
10895     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10896   %}
10897   ins_pipe( ialu_mem_reg );
10898 %}
10899 
10900 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10901   match(Set dst (MoveD2L src));
10902   effect(DEF dst, USE src);
10903 
10904   ins_cost(95); // XXX
10905   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10906   ins_encode %{
10907     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10908   %}
10909   ins_pipe(pipe_slow);
10910 %}
10911 
10912 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10913   match(Set dst (MoveL2D src));
10914   effect(DEF dst, USE src);
10915 
10916   ins_cost(100);
10917   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10918   ins_encode %{
10919     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10920   %}
10921   ins_pipe(ialu_mem_reg);
10922 %}
10923 
10924 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10925   match(Set dst (MoveF2I src));
10926   effect(DEF dst, USE src);
10927   ins_cost(85);
10928   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10929   ins_encode %{
10930     __ movdl($dst$$Register, $src$$XMMRegister);
10931   %}
10932   ins_pipe( pipe_slow );
10933 %}
10934 
10935 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10936   match(Set dst (MoveD2L src));
10937   effect(DEF dst, USE src);
10938   ins_cost(85);
10939   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10940   ins_encode %{
10941     __ movdq($dst$$Register, $src$$XMMRegister);
10942   %}
10943   ins_pipe( pipe_slow );
10944 %}
10945 
10946 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10947   match(Set dst (MoveI2F src));
10948   effect(DEF dst, USE src);
10949   ins_cost(100);
10950   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10951   ins_encode %{
10952     __ movdl($dst$$XMMRegister, $src$$Register);
10953   %}
10954   ins_pipe( pipe_slow );
10955 %}
10956 
10957 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10958   match(Set dst (MoveL2D src));
10959   effect(DEF dst, USE src);
10960   ins_cost(100);
10961   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10962   ins_encode %{
10963      __ movdq($dst$$XMMRegister, $src$$Register);
10964   %}
10965   ins_pipe( pipe_slow );
10966 %}
10967 
10968 
10969 // =======================================================================
10970 // fast clearing of an array
10971 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
10972                   Universe dummy, rFlagsReg cr)
10973 %{
10974   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());
10975   match(Set dummy (ClearArray (Binary cnt base) val));
10976   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
10977 
10978   format %{ $$template
10979     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10980     $$emit$$&quot;jg      LARGE\n\t&quot;
10981     $$emit$$&quot;dec     rcx\n\t&quot;
10982     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10983     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10984     $$emit$$&quot;dec     rcx\n\t&quot;
10985     $$emit$$&quot;jge     LOOP\n\t&quot;
10986     $$emit$$&quot;jmp     DONE\n\t&quot;
10987     $$emit$$&quot;# LARGE:\n\t&quot;
10988     if (UseFastStosb) {
10989        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10990        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10991     } else if (UseXMMForObjInit) {
10992        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
10993        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
10994        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
10995        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10996        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10997        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
10998        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
10999        $$emit$$&quot;add     0x40,rax\n\t&quot;
11000        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11001        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11002        $$emit$$&quot;jge     L_loop\n\t&quot;
11003        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11004        $$emit$$&quot;jl      L_tail\n\t&quot;
11005        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11006        $$emit$$&quot;add     0x20,rax\n\t&quot;
11007        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11008        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11009        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11010        $$emit$$&quot;jle     L_end\n\t&quot;
11011        $$emit$$&quot;dec     rcx\n\t&quot;
11012        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11013        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11014        $$emit$$&quot;add     0x8,rax\n\t&quot;
11015        $$emit$$&quot;dec     rcx\n\t&quot;
11016        $$emit$$&quot;jge     L_sloop\n\t&quot;
11017        $$emit$$&quot;# L_end:\n\t&quot;
11018     } else {
11019        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11020     }
11021     $$emit$$&quot;# DONE&quot;
11022   %}
11023   ins_encode %{
11024     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11025                  $tmp$$XMMRegister, false, false);
11026   %}
11027   ins_pipe(pipe_slow);
11028 %}
11029 
11030 instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11031                   Universe dummy, rFlagsReg cr)
11032 %{
11033   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());
11034   match(Set dummy (ClearArray (Binary cnt base) val));
11035   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11036 
11037   format %{ $$template
11038     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
11039     $$emit$$&quot;jg      LARGE\n\t&quot;
11040     $$emit$$&quot;dec     rcx\n\t&quot;
11041     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
11042     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
11043     $$emit$$&quot;dec     rcx\n\t&quot;
11044     $$emit$$&quot;jge     LOOP\n\t&quot;
11045     $$emit$$&quot;jmp     DONE\n\t&quot;
11046     $$emit$$&quot;# LARGE:\n\t&quot;
11047     if (UseXMMForObjInit) {
11048        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11049        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11050        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11051        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11052        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11053        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11054        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11055        $$emit$$&quot;add     0x40,rax\n\t&quot;
11056        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11057        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11058        $$emit$$&quot;jge     L_loop\n\t&quot;
11059        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11060        $$emit$$&quot;jl      L_tail\n\t&quot;
11061        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11062        $$emit$$&quot;add     0x20,rax\n\t&quot;
11063        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11064        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11065        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11066        $$emit$$&quot;jle     L_end\n\t&quot;
11067        $$emit$$&quot;dec     rcx\n\t&quot;
11068        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11069        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11070        $$emit$$&quot;add     0x8,rax\n\t&quot;
11071        $$emit$$&quot;dec     rcx\n\t&quot;
11072        $$emit$$&quot;jge     L_sloop\n\t&quot;
11073        $$emit$$&quot;# L_end:\n\t&quot;
11074     } else {
11075        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11076     }
11077     $$emit$$&quot;# DONE&quot;
11078   %}
11079   ins_encode %{
11080     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11081                  $tmp$$XMMRegister, false, true);
11082   %}
11083   ins_pipe(pipe_slow);
11084 %}
11085 
11086 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11087                         Universe dummy, rFlagsReg cr)
11088 %{
11089   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());
11090   match(Set dummy (ClearArray (Binary cnt base) val));
11091   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11092 
11093   format %{ $$template
11094     if (UseFastStosb) {
11095        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11096        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11097     } else if (UseXMMForObjInit) {
11098        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11099        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11100        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11101        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11102        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11103        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11104        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11105        $$emit$$&quot;add     0x40,rax\n\t&quot;
11106        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11107        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11108        $$emit$$&quot;jge     L_loop\n\t&quot;
11109        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11110        $$emit$$&quot;jl      L_tail\n\t&quot;
11111        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11112        $$emit$$&quot;add     0x20,rax\n\t&quot;
11113        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11114        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11115        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11116        $$emit$$&quot;jle     L_end\n\t&quot;
11117        $$emit$$&quot;dec     rcx\n\t&quot;
11118        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11119        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11120        $$emit$$&quot;add     0x8,rax\n\t&quot;
11121        $$emit$$&quot;dec     rcx\n\t&quot;
11122        $$emit$$&quot;jge     L_sloop\n\t&quot;
11123        $$emit$$&quot;# L_end:\n\t&quot;
11124     } else {
11125        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11126     }
11127   %}
11128   ins_encode %{
11129     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11130                  $tmp$$XMMRegister, true, false);
11131   %}
11132   ins_pipe(pipe_slow);
11133 %}
11134 
11135 instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val, 
11136                         Universe dummy, rFlagsReg cr)
11137 %{
11138   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());
11139   match(Set dummy (ClearArray (Binary cnt base) val));
11140   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11141 
11142   format %{ $$template
11143     if (UseXMMForObjInit) {
11144        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11145        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11146        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11147        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11148        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11149        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11150        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11151        $$emit$$&quot;add     0x40,rax\n\t&quot;
11152        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11153        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11154        $$emit$$&quot;jge     L_loop\n\t&quot;
11155        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11156        $$emit$$&quot;jl      L_tail\n\t&quot;
11157        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11158        $$emit$$&quot;add     0x20,rax\n\t&quot;
11159        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11160        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11161        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11162        $$emit$$&quot;jle     L_end\n\t&quot;
11163        $$emit$$&quot;dec     rcx\n\t&quot;
11164        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11165        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11166        $$emit$$&quot;add     0x8,rax\n\t&quot;
11167        $$emit$$&quot;dec     rcx\n\t&quot;
11168        $$emit$$&quot;jge     L_sloop\n\t&quot;
11169        $$emit$$&quot;# L_end:\n\t&quot;
11170     } else {
11171        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11172     }
11173   %}
11174   ins_encode %{
11175     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register, 
11176                  $tmp$$XMMRegister, true, true);
11177   %}
11178   ins_pipe(pipe_slow);
11179 %}
11180 
11181 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11182                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11183 %{
11184   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11185   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11186   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11187 
11188   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11189   ins_encode %{
11190     __ string_compare($str1$$Register, $str2$$Register,
11191                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11192                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11193   %}
11194   ins_pipe( pipe_slow );
11195 %}
11196 
11197 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11198                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11199 %{
11200   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11201   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11202   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11203 
11204   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11205   ins_encode %{
11206     __ string_compare($str1$$Register, $str2$$Register,
11207                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11208                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11209   %}
11210   ins_pipe( pipe_slow );
11211 %}
11212 
11213 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11214                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11215 %{
11216   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11217   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11218   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11219 
11220   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11221   ins_encode %{
11222     __ string_compare($str1$$Register, $str2$$Register,
11223                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11224                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11225   %}
11226   ins_pipe( pipe_slow );
11227 %}
11228 
11229 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11230                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11231 %{
11232   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11233   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11234   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11235 
11236   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11237   ins_encode %{
11238     __ string_compare($str2$$Register, $str1$$Register,
11239                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11240                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11241   %}
11242   ins_pipe( pipe_slow );
11243 %}
11244 
11245 // fast search of substring with known size.
11246 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11247                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11248 %{
11249   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11250   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11251   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11252 
11253   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11254   ins_encode %{
11255     int icnt2 = (int)$int_cnt2$$constant;
11256     if (icnt2 &gt;= 16) {
11257       // IndexOf for constant substrings with size &gt;= 16 elements
11258       // which don&#39;t need to be loaded through stack.
11259       __ string_indexofC8($str1$$Register, $str2$$Register,
11260                           $cnt1$$Register, $cnt2$$Register,
11261                           icnt2, $result$$Register,
11262                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11263     } else {
11264       // Small strings are loaded through stack if they cross page boundary.
11265       __ string_indexof($str1$$Register, $str2$$Register,
11266                         $cnt1$$Register, $cnt2$$Register,
11267                         icnt2, $result$$Register,
11268                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11269     }
11270   %}
11271   ins_pipe( pipe_slow );
11272 %}
11273 
11274 // fast search of substring with known size.
11275 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11276                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11277 %{
11278   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11279   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11280   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11281 
11282   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11283   ins_encode %{
11284     int icnt2 = (int)$int_cnt2$$constant;
11285     if (icnt2 &gt;= 8) {
11286       // IndexOf for constant substrings with size &gt;= 8 elements
11287       // which don&#39;t need to be loaded through stack.
11288       __ string_indexofC8($str1$$Register, $str2$$Register,
11289                           $cnt1$$Register, $cnt2$$Register,
11290                           icnt2, $result$$Register,
11291                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11292     } else {
11293       // Small strings are loaded through stack if they cross page boundary.
11294       __ string_indexof($str1$$Register, $str2$$Register,
11295                         $cnt1$$Register, $cnt2$$Register,
11296                         icnt2, $result$$Register,
11297                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11298     }
11299   %}
11300   ins_pipe( pipe_slow );
11301 %}
11302 
11303 // fast search of substring with known size.
11304 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11305                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11306 %{
11307   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11308   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11309   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11310 
11311   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11312   ins_encode %{
11313     int icnt2 = (int)$int_cnt2$$constant;
11314     if (icnt2 &gt;= 8) {
11315       // IndexOf for constant substrings with size &gt;= 8 elements
11316       // which don&#39;t need to be loaded through stack.
11317       __ string_indexofC8($str1$$Register, $str2$$Register,
11318                           $cnt1$$Register, $cnt2$$Register,
11319                           icnt2, $result$$Register,
11320                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11321     } else {
11322       // Small strings are loaded through stack if they cross page boundary.
11323       __ string_indexof($str1$$Register, $str2$$Register,
11324                         $cnt1$$Register, $cnt2$$Register,
11325                         icnt2, $result$$Register,
11326                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11327     }
11328   %}
11329   ins_pipe( pipe_slow );
11330 %}
11331 
11332 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11333                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11334 %{
11335   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11336   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11337   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11338 
11339   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11340   ins_encode %{
11341     __ string_indexof($str1$$Register, $str2$$Register,
11342                       $cnt1$$Register, $cnt2$$Register,
11343                       (-1), $result$$Register,
11344                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11345   %}
11346   ins_pipe( pipe_slow );
11347 %}
11348 
11349 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11350                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11351 %{
11352   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11353   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11354   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11355 
11356   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11357   ins_encode %{
11358     __ string_indexof($str1$$Register, $str2$$Register,
11359                       $cnt1$$Register, $cnt2$$Register,
11360                       (-1), $result$$Register,
11361                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11362   %}
11363   ins_pipe( pipe_slow );
11364 %}
11365 
11366 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11367                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11368 %{
11369   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11370   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11371   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11372 
11373   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11374   ins_encode %{
11375     __ string_indexof($str1$$Register, $str2$$Register,
11376                       $cnt1$$Register, $cnt2$$Register,
11377                       (-1), $result$$Register,
11378                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11379   %}
11380   ins_pipe( pipe_slow );
11381 %}
11382 
11383 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11384                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11385 %{
11386   predicate(UseSSE42Intrinsics);
11387   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11388   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11389   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11390   ins_encode %{
11391     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11392                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11393   %}
11394   ins_pipe( pipe_slow );
11395 %}
11396 
11397 // fast string equals
11398 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11399                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11400 %{
11401   match(Set result (StrEquals (Binary str1 str2) cnt));
11402   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11403 
11404   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11405   ins_encode %{
11406     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11407                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11408                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11409   %}
11410   ins_pipe( pipe_slow );
11411 %}
11412 
11413 // fast array equals
11414 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11415                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11416 %{
11417   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11418   match(Set result (AryEq ary1 ary2));
11419   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11420 
11421   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11422   ins_encode %{
11423     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11424                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11425                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11426   %}
11427   ins_pipe( pipe_slow );
11428 %}
11429 
11430 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11431                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11432 %{
11433   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11434   match(Set result (AryEq ary1 ary2));
11435   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11436 
11437   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11438   ins_encode %{
11439     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11440                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11441                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11442   %}
11443   ins_pipe( pipe_slow );
11444 %}
11445 
11446 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11447                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11448 %{
11449   match(Set result (HasNegatives ary1 len));
11450   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11451 
11452   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11453   ins_encode %{
11454     __ has_negatives($ary1$$Register, $len$$Register,
11455                      $result$$Register, $tmp3$$Register,
11456                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11457   %}
11458   ins_pipe( pipe_slow );
11459 %}
11460 
11461 // fast char[] to byte[] compression
11462 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11463                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11464   match(Set result (StrCompressedCopy src (Binary dst len)));
11465   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11466 
11467   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11468   ins_encode %{
11469     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11470                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11471                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11472   %}
11473   ins_pipe( pipe_slow );
11474 %}
11475 
11476 // fast byte[] to char[] inflation
11477 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11478                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11479   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11480   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11481 
11482   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11483   ins_encode %{
11484     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11485                           $tmp1$$XMMRegister, $tmp2$$Register);
11486   %}
11487   ins_pipe( pipe_slow );
11488 %}
11489 
11490 // encode char[] to byte[] in ISO_8859_1
11491 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11492                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11493                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11494   match(Set result (EncodeISOArray src (Binary dst len)));
11495   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11496 
11497   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11498   ins_encode %{
11499     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11500                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11501                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11502   %}
11503   ins_pipe( pipe_slow );
11504 %}
11505 
11506 //----------Overflow Math Instructions-----------------------------------------
11507 
11508 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11509 %{
11510   match(Set cr (OverflowAddI op1 op2));
11511   effect(DEF cr, USE_KILL op1, USE op2);
11512 
11513   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11514 
11515   ins_encode %{
11516     __ addl($op1$$Register, $op2$$Register);
11517   %}
11518   ins_pipe(ialu_reg_reg);
11519 %}
11520 
11521 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11522 %{
11523   match(Set cr (OverflowAddI op1 op2));
11524   effect(DEF cr, USE_KILL op1, USE op2);
11525 
11526   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11527 
11528   ins_encode %{
11529     __ addl($op1$$Register, $op2$$constant);
11530   %}
11531   ins_pipe(ialu_reg_reg);
11532 %}
11533 
11534 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11535 %{
11536   match(Set cr (OverflowAddL op1 op2));
11537   effect(DEF cr, USE_KILL op1, USE op2);
11538 
11539   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11540   ins_encode %{
11541     __ addq($op1$$Register, $op2$$Register);
11542   %}
11543   ins_pipe(ialu_reg_reg);
11544 %}
11545 
11546 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11547 %{
11548   match(Set cr (OverflowAddL op1 op2));
11549   effect(DEF cr, USE_KILL op1, USE op2);
11550 
11551   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11552   ins_encode %{
11553     __ addq($op1$$Register, $op2$$constant);
11554   %}
11555   ins_pipe(ialu_reg_reg);
11556 %}
11557 
11558 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11559 %{
11560   match(Set cr (OverflowSubI op1 op2));
11561 
11562   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11563   ins_encode %{
11564     __ cmpl($op1$$Register, $op2$$Register);
11565   %}
11566   ins_pipe(ialu_reg_reg);
11567 %}
11568 
11569 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11570 %{
11571   match(Set cr (OverflowSubI op1 op2));
11572 
11573   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11574   ins_encode %{
11575     __ cmpl($op1$$Register, $op2$$constant);
11576   %}
11577   ins_pipe(ialu_reg_reg);
11578 %}
11579 
11580 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11581 %{
11582   match(Set cr (OverflowSubL op1 op2));
11583 
11584   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11585   ins_encode %{
11586     __ cmpq($op1$$Register, $op2$$Register);
11587   %}
11588   ins_pipe(ialu_reg_reg);
11589 %}
11590 
11591 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11592 %{
11593   match(Set cr (OverflowSubL op1 op2));
11594 
11595   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11596   ins_encode %{
11597     __ cmpq($op1$$Register, $op2$$constant);
11598   %}
11599   ins_pipe(ialu_reg_reg);
11600 %}
11601 
11602 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11603 %{
11604   match(Set cr (OverflowSubI zero op2));
11605   effect(DEF cr, USE_KILL op2);
11606 
11607   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11608   ins_encode %{
11609     __ negl($op2$$Register);
11610   %}
11611   ins_pipe(ialu_reg_reg);
11612 %}
11613 
11614 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11615 %{
11616   match(Set cr (OverflowSubL zero op2));
11617   effect(DEF cr, USE_KILL op2);
11618 
11619   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11620   ins_encode %{
11621     __ negq($op2$$Register);
11622   %}
11623   ins_pipe(ialu_reg_reg);
11624 %}
11625 
11626 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11627 %{
11628   match(Set cr (OverflowMulI op1 op2));
11629   effect(DEF cr, USE_KILL op1, USE op2);
11630 
11631   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11632   ins_encode %{
11633     __ imull($op1$$Register, $op2$$Register);
11634   %}
11635   ins_pipe(ialu_reg_reg_alu0);
11636 %}
11637 
11638 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11639 %{
11640   match(Set cr (OverflowMulI op1 op2));
11641   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11642 
11643   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11644   ins_encode %{
11645     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11646   %}
11647   ins_pipe(ialu_reg_reg_alu0);
11648 %}
11649 
11650 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11651 %{
11652   match(Set cr (OverflowMulL op1 op2));
11653   effect(DEF cr, USE_KILL op1, USE op2);
11654 
11655   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11656   ins_encode %{
11657     __ imulq($op1$$Register, $op2$$Register);
11658   %}
11659   ins_pipe(ialu_reg_reg_alu0);
11660 %}
11661 
11662 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11663 %{
11664   match(Set cr (OverflowMulL op1 op2));
11665   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11666 
11667   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11668   ins_encode %{
11669     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11670   %}
11671   ins_pipe(ialu_reg_reg_alu0);
11672 %}
11673 
11674 
11675 //----------Control Flow Instructions------------------------------------------
11676 // Signed compare Instructions
11677 
11678 // XXX more variants!!
11679 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11680 %{
11681   match(Set cr (CmpI op1 op2));
11682   effect(DEF cr, USE op1, USE op2);
11683 
11684   format %{ &quot;cmpl    $op1, $op2&quot; %}
11685   opcode(0x3B);  /* Opcode 3B /r */
11686   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11687   ins_pipe(ialu_cr_reg_reg);
11688 %}
11689 
11690 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11691 %{
11692   match(Set cr (CmpI op1 op2));
11693 
11694   format %{ &quot;cmpl    $op1, $op2&quot; %}
11695   opcode(0x81, 0x07); /* Opcode 81 /7 */
11696   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11697   ins_pipe(ialu_cr_reg_imm);
11698 %}
11699 
11700 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11701 %{
11702   match(Set cr (CmpI op1 (LoadI op2)));
11703 
11704   ins_cost(500); // XXX
11705   format %{ &quot;cmpl    $op1, $op2&quot; %}
11706   opcode(0x3B); /* Opcode 3B /r */
11707   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11708   ins_pipe(ialu_cr_reg_mem);
11709 %}
11710 
11711 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11712 %{
11713   match(Set cr (CmpI src zero));
11714 
11715   format %{ &quot;testl   $src, $src&quot; %}
11716   opcode(0x85);
11717   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11718   ins_pipe(ialu_cr_reg_imm);
11719 %}
11720 
11721 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11722 %{
11723   match(Set cr (CmpI (AndI src con) zero));
11724 
11725   format %{ &quot;testl   $src, $con&quot; %}
11726   opcode(0xF7, 0x00);
11727   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11728   ins_pipe(ialu_cr_reg_imm);
11729 %}
11730 
11731 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11732 %{
11733   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11734 
11735   format %{ &quot;testl   $src, $mem&quot; %}
11736   opcode(0x85);
11737   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11738   ins_pipe(ialu_cr_reg_mem);
11739 %}
11740 
11741 // Fold array properties check
11742 instruct testI_mem_imm(rFlagsReg cr, memory mem, immI con, immI0 zero)
11743 %{
11744   match(Set cr (CmpI (AndI (CastN2I (LoadNKlass mem)) con) zero));
11745 
11746   format %{ &quot;testl   $mem, $con&quot; %}
11747   opcode(0xF7, 0x00);
11748   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(con));
11749   ins_pipe(ialu_mem_imm);
11750 %}
11751 
11752 // Unsigned compare Instructions; really, same as signed except they
11753 // produce an rFlagsRegU instead of rFlagsReg.
11754 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11755 %{
11756   match(Set cr (CmpU op1 op2));
11757 
11758   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11759   opcode(0x3B); /* Opcode 3B /r */
11760   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11761   ins_pipe(ialu_cr_reg_reg);
11762 %}
11763 
11764 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11765 %{
11766   match(Set cr (CmpU op1 op2));
11767 
11768   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11769   opcode(0x81,0x07); /* Opcode 81 /7 */
11770   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11771   ins_pipe(ialu_cr_reg_imm);
11772 %}
11773 
11774 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11775 %{
11776   match(Set cr (CmpU op1 (LoadI op2)));
11777 
11778   ins_cost(500); // XXX
11779   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11780   opcode(0x3B); /* Opcode 3B /r */
11781   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11782   ins_pipe(ialu_cr_reg_mem);
11783 %}
11784 
11785 // // // Cisc-spilled version of cmpU_rReg
11786 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11787 // //%{
11788 // //  match(Set cr (CmpU (LoadI op1) op2));
11789 // //
11790 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11791 // //  ins_cost(500);
11792 // //  opcode(0x39);  /* Opcode 39 /r */
11793 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11794 // //%}
11795 
11796 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11797 %{
11798   match(Set cr (CmpU src zero));
11799 
11800   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11801   opcode(0x85);
11802   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11803   ins_pipe(ialu_cr_reg_imm);
11804 %}
11805 
11806 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11807 %{
11808   match(Set cr (CmpP op1 op2));
11809 
11810   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11811   opcode(0x3B); /* Opcode 3B /r */
11812   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11813   ins_pipe(ialu_cr_reg_reg);
11814 %}
11815 
11816 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11817 %{
11818   match(Set cr (CmpP op1 (LoadP op2)));
11819   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11820 
11821   ins_cost(500); // XXX
11822   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11823   opcode(0x3B); /* Opcode 3B /r */
11824   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11825   ins_pipe(ialu_cr_reg_mem);
11826 %}
11827 
11828 // // // Cisc-spilled version of cmpP_rReg
11829 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11830 // //%{
11831 // //  match(Set cr (CmpP (LoadP op1) op2));
11832 // //
11833 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11834 // //  ins_cost(500);
11835 // //  opcode(0x39);  /* Opcode 39 /r */
11836 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11837 // //%}
11838 
11839 // XXX this is generalized by compP_rReg_mem???
11840 // Compare raw pointer (used in out-of-heap check).
11841 // Only works because non-oop pointers must be raw pointers
11842 // and raw pointers have no anti-dependencies.
11843 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11844 %{
11845   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11846             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11847   match(Set cr (CmpP op1 (LoadP op2)));
11848 
11849   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11850   opcode(0x3B); /* Opcode 3B /r */
11851   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11852   ins_pipe(ialu_cr_reg_mem);
11853 %}
11854 
11855 // This will generate a signed flags result. This should be OK since
11856 // any compare to a zero should be eq/neq.
11857 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11858 %{
11859   match(Set cr (CmpP src zero));
11860 
11861   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11862   opcode(0x85);
11863   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11864   ins_pipe(ialu_cr_reg_imm);
11865 %}
11866 
11867 // This will generate a signed flags result. This should be OK since
11868 // any compare to a zero should be eq/neq.
11869 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11870 %{
11871   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11872             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11873   match(Set cr (CmpP (LoadP op) zero));
11874 
11875   ins_cost(500); // XXX
11876   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11877   opcode(0xF7); /* Opcode F7 /0 */
11878   ins_encode(REX_mem_wide(op),
11879              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11880   ins_pipe(ialu_cr_reg_imm);
11881 %}
11882 
11883 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11884 %{
11885   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
11886             (CompressedKlassPointers::base() == NULL) &amp;&amp;
11887             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11888   match(Set cr (CmpP (LoadP mem) zero));
11889 
11890   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11891   ins_encode %{
11892     __ cmpq(r12, $mem$$Address);
11893   %}
11894   ins_pipe(ialu_cr_reg_mem);
11895 %}
11896 
11897 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11898 %{
11899   match(Set cr (CmpN op1 op2));
11900 
11901   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11902   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11903   ins_pipe(ialu_cr_reg_reg);
11904 %}
11905 
11906 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11907 %{
11908   match(Set cr (CmpN src (LoadN mem)));
11909 
11910   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11911   ins_encode %{
11912     __ cmpl($src$$Register, $mem$$Address);
11913   %}
11914   ins_pipe(ialu_cr_reg_mem);
11915 %}
11916 
11917 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11918   match(Set cr (CmpN op1 op2));
11919 
11920   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11921   ins_encode %{
11922     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11923   %}
11924   ins_pipe(ialu_cr_reg_imm);
11925 %}
11926 
11927 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11928 %{
11929   match(Set cr (CmpN src (LoadN mem)));
11930 
11931   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11932   ins_encode %{
11933     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11934   %}
11935   ins_pipe(ialu_cr_reg_mem);
11936 %}
11937 
11938 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11939   match(Set cr (CmpN op1 op2));
11940 
11941   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11942   ins_encode %{
11943     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11944   %}
11945   ins_pipe(ialu_cr_reg_imm);
11946 %}
11947 
11948 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11949 %{
11950   match(Set cr (CmpN src (LoadNKlass mem)));
11951 
11952   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11953   ins_encode %{
11954     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11955   %}
11956   ins_pipe(ialu_cr_reg_mem);
11957 %}
11958 
11959 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11960   match(Set cr (CmpN src zero));
11961 
11962   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11963   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11964   ins_pipe(ialu_cr_reg_imm);
11965 %}
11966 
11967 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11968 %{
11969   predicate(CompressedOops::base() != NULL);
11970   match(Set cr (CmpN (LoadN mem) zero));
11971 
11972   ins_cost(500); // XXX
11973   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11974   ins_encode %{
11975     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11976   %}
11977   ins_pipe(ialu_cr_reg_mem);
11978 %}
11979 
11980 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11981 %{
11982   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));
11983   match(Set cr (CmpN (LoadN mem) zero));
11984 
11985   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11986   ins_encode %{
11987     __ cmpl(r12, $mem$$Address);
11988   %}
11989   ins_pipe(ialu_cr_reg_mem);
11990 %}
11991 
11992 // Yanked all unsigned pointer compare operations.
11993 // Pointer compares are done with CmpP which is already unsigned.
11994 
11995 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11996 %{
11997   match(Set cr (CmpL op1 op2));
11998 
11999   format %{ &quot;cmpq    $op1, $op2&quot; %}
12000   opcode(0x3B);  /* Opcode 3B /r */
12001   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12002   ins_pipe(ialu_cr_reg_reg);
12003 %}
12004 
12005 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
12006 %{
12007   match(Set cr (CmpL op1 op2));
12008 
12009   format %{ &quot;cmpq    $op1, $op2&quot; %}
12010   opcode(0x81, 0x07); /* Opcode 81 /7 */
12011   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12012   ins_pipe(ialu_cr_reg_imm);
12013 %}
12014 
12015 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
12016 %{
12017   match(Set cr (CmpL op1 (LoadL op2)));
12018 
12019   format %{ &quot;cmpq    $op1, $op2&quot; %}
12020   opcode(0x3B); /* Opcode 3B /r */
12021   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12022   ins_pipe(ialu_cr_reg_mem);
12023 %}
12024 
12025 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
12026 %{
12027   match(Set cr (CmpL src zero));
12028 
12029   format %{ &quot;testq   $src, $src&quot; %}
12030   opcode(0x85);
12031   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12032   ins_pipe(ialu_cr_reg_imm);
12033 %}
12034 
12035 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
12036 %{
12037   match(Set cr (CmpL (AndL src con) zero));
12038 
12039   format %{ &quot;testq   $src, $con\t# long&quot; %}
12040   opcode(0xF7, 0x00);
12041   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
12042   ins_pipe(ialu_cr_reg_imm);
12043 %}
12044 
12045 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
12046 %{
12047   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
12048 
12049   format %{ &quot;testq   $src, $mem&quot; %}
12050   opcode(0x85);
12051   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12052   ins_pipe(ialu_cr_reg_mem);
12053 %}
12054 
12055 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
12056 %{
12057   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
12058 
12059   format %{ &quot;testq   $src, $mem&quot; %}
12060   opcode(0x85);
12061   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12062   ins_pipe(ialu_cr_reg_mem);
12063 %}
12064 
12065 // Fold array properties check
12066 instruct testL_reg_mem3(rFlagsReg cr, memory mem, rRegL src, immL0 zero)
12067 %{
12068   match(Set cr (CmpL (AndL (CastP2X (LoadKlass mem)) src) zero));
12069 
12070   format %{ &quot;testq   $src, $mem\t# test array properties&quot; %}
12071   opcode(0x85);
12072   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12073   ins_pipe(ialu_cr_reg_mem);
12074 %}
12075 
12076 // Manifest a CmpL result in an integer register.  Very painful.
12077 // This is the test to avoid.
12078 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
12079 %{
12080   match(Set dst (CmpL3 src1 src2));
12081   effect(KILL flags);
12082 
12083   ins_cost(275); // XXX
12084   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
12085             &quot;movl    $dst, -1\n\t&quot;
12086             &quot;jl,s    done\n\t&quot;
12087             &quot;setne   $dst\n\t&quot;
12088             &quot;movzbl  $dst, $dst\n\t&quot;
12089     &quot;done:&quot; %}
12090   ins_encode(cmpl3_flag(src1, src2, dst));
12091   ins_pipe(pipe_slow);
12092 %}
12093 
12094 // Unsigned long compare Instructions; really, same as signed long except they
12095 // produce an rFlagsRegU instead of rFlagsReg.
12096 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
12097 %{
12098   match(Set cr (CmpUL op1 op2));
12099 
12100   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12101   opcode(0x3B);  /* Opcode 3B /r */
12102   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12103   ins_pipe(ialu_cr_reg_reg);
12104 %}
12105 
12106 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
12107 %{
12108   match(Set cr (CmpUL op1 op2));
12109 
12110   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12111   opcode(0x81, 0x07); /* Opcode 81 /7 */
12112   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12113   ins_pipe(ialu_cr_reg_imm);
12114 %}
12115 
12116 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
12117 %{
12118   match(Set cr (CmpUL op1 (LoadL op2)));
12119 
12120   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12121   opcode(0x3B); /* Opcode 3B /r */
12122   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12123   ins_pipe(ialu_cr_reg_mem);
12124 %}
12125 
12126 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
12127 %{
12128   match(Set cr (CmpUL src zero));
12129 
12130   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
12131   opcode(0x85);
12132   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12133   ins_pipe(ialu_cr_reg_imm);
12134 %}
12135 
12136 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
12137 %{
12138   match(Set cr (CmpI (LoadB mem) imm));
12139 
12140   ins_cost(125);
12141   format %{ &quot;cmpb    $mem, $imm&quot; %}
12142   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
12143   ins_pipe(ialu_cr_reg_mem);
12144 %}
12145 
12146 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
12147 %{
12148   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
12149 
12150   ins_cost(125);
12151   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
12152   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12153   ins_pipe(ialu_cr_reg_mem);
12154 %}
12155 
12156 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
12157 %{
12158   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
12159 
12160   ins_cost(125);
12161   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
12162   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12163   ins_pipe(ialu_cr_reg_mem);
12164 %}
12165 
12166 //----------Max and Min--------------------------------------------------------
12167 // Min Instructions
12168 
12169 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
12170 %{
12171   effect(USE_DEF dst, USE src, USE cr);
12172 
12173   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
12174   opcode(0x0F, 0x4F);
12175   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12176   ins_pipe(pipe_cmov_reg);
12177 %}
12178 
12179 
12180 instruct minI_rReg(rRegI dst, rRegI src)
12181 %{
12182   match(Set dst (MinI dst src));
12183 
12184   ins_cost(200);
12185   expand %{
12186     rFlagsReg cr;
12187     compI_rReg(cr, dst, src);
12188     cmovI_reg_g(dst, src, cr);
12189   %}
12190 %}
12191 
12192 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12193 %{
12194   effect(USE_DEF dst, USE src, USE cr);
12195 
12196   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12197   opcode(0x0F, 0x4C);
12198   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12199   ins_pipe(pipe_cmov_reg);
12200 %}
12201 
12202 
12203 instruct maxI_rReg(rRegI dst, rRegI src)
12204 %{
12205   match(Set dst (MaxI dst src));
12206 
12207   ins_cost(200);
12208   expand %{
12209     rFlagsReg cr;
12210     compI_rReg(cr, dst, src);
12211     cmovI_reg_l(dst, src, cr);
12212   %}
12213 %}
12214 
12215 // ============================================================================
12216 // Branch Instructions
12217 
12218 // Jump Direct - Label defines a relative address from JMP+1
12219 instruct jmpDir(label labl)
12220 %{
12221   match(Goto);
12222   effect(USE labl);
12223 
12224   ins_cost(300);
12225   format %{ &quot;jmp     $labl&quot; %}
12226   size(5);
12227   ins_encode %{
12228     Label* L = $labl$$label;
12229     __ jmp(*L, false); // Always long jump
12230   %}
12231   ins_pipe(pipe_jmp);
12232 %}
12233 
12234 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12235 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12236 %{
12237   match(If cop cr);
12238   effect(USE labl);
12239 
12240   ins_cost(300);
12241   format %{ &quot;j$cop     $labl&quot; %}
12242   size(6);
12243   ins_encode %{
12244     Label* L = $labl$$label;
12245     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12246   %}
12247   ins_pipe(pipe_jcc);
12248 %}
12249 
12250 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12251 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12252 %{
12253   predicate(!n-&gt;has_vector_mask_set());
12254   match(CountedLoopEnd cop cr);
12255   effect(USE labl);
12256 
12257   ins_cost(300);
12258   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12259   size(6);
12260   ins_encode %{
12261     Label* L = $labl$$label;
12262     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12263   %}
12264   ins_pipe(pipe_jcc);
12265 %}
12266 
12267 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12268 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12269   predicate(!n-&gt;has_vector_mask_set());
12270   match(CountedLoopEnd cop cmp);
12271   effect(USE labl);
12272 
12273   ins_cost(300);
12274   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12275   size(6);
12276   ins_encode %{
12277     Label* L = $labl$$label;
12278     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12279   %}
12280   ins_pipe(pipe_jcc);
12281 %}
12282 
12283 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12284   predicate(!n-&gt;has_vector_mask_set());
12285   match(CountedLoopEnd cop cmp);
12286   effect(USE labl);
12287 
12288   ins_cost(200);
12289   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12290   size(6);
12291   ins_encode %{
12292     Label* L = $labl$$label;
12293     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12294   %}
12295   ins_pipe(pipe_jcc);
12296 %}
12297 
12298 // mask version
12299 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12300 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12301 %{
12302   predicate(n-&gt;has_vector_mask_set());
12303   match(CountedLoopEnd cop cr);
12304   effect(USE labl);
12305 
12306   ins_cost(400);
12307   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12308             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12309   size(10);
12310   ins_encode %{
12311     Label* L = $labl$$label;
12312     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12313     __ restorevectmask();
12314   %}
12315   ins_pipe(pipe_jcc);
12316 %}
12317 
12318 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12319 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12320   predicate(n-&gt;has_vector_mask_set());
12321   match(CountedLoopEnd cop cmp);
12322   effect(USE labl);
12323 
12324   ins_cost(400);
12325   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12326             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12327   size(10);
12328   ins_encode %{
12329     Label* L = $labl$$label;
12330     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12331     __ restorevectmask();
12332   %}
12333   ins_pipe(pipe_jcc);
12334 %}
12335 
12336 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12337   predicate(n-&gt;has_vector_mask_set());
12338   match(CountedLoopEnd cop cmp);
12339   effect(USE labl);
12340 
12341   ins_cost(300);
12342   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12343             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12344   size(10);
12345   ins_encode %{
12346     Label* L = $labl$$label;
12347     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12348     __ restorevectmask();
12349   %}
12350   ins_pipe(pipe_jcc);
12351 %}
12352 
12353 // Jump Direct Conditional - using unsigned comparison
12354 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12355   match(If cop cmp);
12356   effect(USE labl);
12357 
12358   ins_cost(300);
12359   format %{ &quot;j$cop,u   $labl&quot; %}
12360   size(6);
12361   ins_encode %{
12362     Label* L = $labl$$label;
12363     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12364   %}
12365   ins_pipe(pipe_jcc);
12366 %}
12367 
12368 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12369   match(If cop cmp);
12370   effect(USE labl);
12371 
12372   ins_cost(200);
12373   format %{ &quot;j$cop,u   $labl&quot; %}
12374   size(6);
12375   ins_encode %{
12376     Label* L = $labl$$label;
12377     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12378   %}
12379   ins_pipe(pipe_jcc);
12380 %}
12381 
12382 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12383   match(If cop cmp);
12384   effect(USE labl);
12385 
12386   ins_cost(200);
12387   format %{ $$template
12388     if ($cop$$cmpcode == Assembler::notEqual) {
12389       $$emit$$&quot;jp,u    $labl\n\t&quot;
12390       $$emit$$&quot;j$cop,u   $labl&quot;
12391     } else {
12392       $$emit$$&quot;jp,u    done\n\t&quot;
12393       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12394       $$emit$$&quot;done:&quot;
12395     }
12396   %}
12397   ins_encode %{
12398     Label* l = $labl$$label;
12399     if ($cop$$cmpcode == Assembler::notEqual) {
12400       __ jcc(Assembler::parity, *l, false);
12401       __ jcc(Assembler::notEqual, *l, false);
12402     } else if ($cop$$cmpcode == Assembler::equal) {
12403       Label done;
12404       __ jccb(Assembler::parity, done);
12405       __ jcc(Assembler::equal, *l, false);
12406       __ bind(done);
12407     } else {
12408        ShouldNotReachHere();
12409     }
12410   %}
12411   ins_pipe(pipe_jcc);
12412 %}
12413 
12414 // ============================================================================
12415 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12416 // superklass array for an instance of the superklass.  Set a hidden
12417 // internal cache on a hit (cache is checked with exposed code in
12418 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12419 // encoding ALSO sets flags.
12420 
12421 instruct partialSubtypeCheck(rdi_RegP result,
12422                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12423                              rFlagsReg cr)
12424 %{
12425   match(Set result (PartialSubtypeCheck sub super));
12426   effect(KILL rcx, KILL cr);
12427 
12428   ins_cost(1100);  // slightly larger than the next version
12429   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12430             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12431             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12432             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12433             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12434             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12435             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12436     &quot;miss:\t&quot; %}
12437 
12438   opcode(0x1); // Force a XOR of RDI
12439   ins_encode(enc_PartialSubtypeCheck());
12440   ins_pipe(pipe_slow);
12441 %}
12442 
12443 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12444                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12445                                      immP0 zero,
12446                                      rdi_RegP result)
12447 %{
12448   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12449   effect(KILL rcx, KILL result);
12450 
12451   ins_cost(1000);
12452   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12453             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12454             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12455             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12456             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12457             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12458     &quot;miss:\t&quot; %}
12459 
12460   opcode(0x0); // No need to XOR RDI
12461   ins_encode(enc_PartialSubtypeCheck());
12462   ins_pipe(pipe_slow);
12463 %}
12464 
12465 // ============================================================================
12466 // Branch Instructions -- short offset versions
12467 //
12468 // These instructions are used to replace jumps of a long offset (the default
12469 // match) with jumps of a shorter offset.  These instructions are all tagged
12470 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12471 // match rules in general matching.  Instead, the ADLC generates a conversion
12472 // method in the MachNode which can be used to do in-place replacement of the
12473 // long variant with the shorter variant.  The compiler will determine if a
12474 // branch can be taken by the is_short_branch_offset() predicate in the machine
12475 // specific code section of the file.
12476 
12477 // Jump Direct - Label defines a relative address from JMP+1
12478 instruct jmpDir_short(label labl) %{
12479   match(Goto);
12480   effect(USE labl);
12481 
12482   ins_cost(300);
12483   format %{ &quot;jmp,s   $labl&quot; %}
12484   size(2);
12485   ins_encode %{
12486     Label* L = $labl$$label;
12487     __ jmpb(*L);
12488   %}
12489   ins_pipe(pipe_jmp);
12490   ins_short_branch(1);
12491 %}
12492 
12493 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12494 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12495   match(If cop cr);
12496   effect(USE labl);
12497 
12498   ins_cost(300);
12499   format %{ &quot;j$cop,s   $labl&quot; %}
12500   size(2);
12501   ins_encode %{
12502     Label* L = $labl$$label;
12503     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12504   %}
12505   ins_pipe(pipe_jcc);
12506   ins_short_branch(1);
12507 %}
12508 
12509 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12510 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12511   match(CountedLoopEnd cop cr);
12512   effect(USE labl);
12513 
12514   ins_cost(300);
12515   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12516   size(2);
12517   ins_encode %{
12518     Label* L = $labl$$label;
12519     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12520   %}
12521   ins_pipe(pipe_jcc);
12522   ins_short_branch(1);
12523 %}
12524 
12525 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12526 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12527   match(CountedLoopEnd cop cmp);
12528   effect(USE labl);
12529 
12530   ins_cost(300);
12531   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12532   size(2);
12533   ins_encode %{
12534     Label* L = $labl$$label;
12535     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12536   %}
12537   ins_pipe(pipe_jcc);
12538   ins_short_branch(1);
12539 %}
12540 
12541 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12542   match(CountedLoopEnd cop cmp);
12543   effect(USE labl);
12544 
12545   ins_cost(300);
12546   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12547   size(2);
12548   ins_encode %{
12549     Label* L = $labl$$label;
12550     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12551   %}
12552   ins_pipe(pipe_jcc);
12553   ins_short_branch(1);
12554 %}
12555 
12556 // Jump Direct Conditional - using unsigned comparison
12557 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12558   match(If cop cmp);
12559   effect(USE labl);
12560 
12561   ins_cost(300);
12562   format %{ &quot;j$cop,us  $labl&quot; %}
12563   size(2);
12564   ins_encode %{
12565     Label* L = $labl$$label;
12566     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12567   %}
12568   ins_pipe(pipe_jcc);
12569   ins_short_branch(1);
12570 %}
12571 
12572 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12573   match(If cop cmp);
12574   effect(USE labl);
12575 
12576   ins_cost(300);
12577   format %{ &quot;j$cop,us  $labl&quot; %}
12578   size(2);
12579   ins_encode %{
12580     Label* L = $labl$$label;
12581     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12582   %}
12583   ins_pipe(pipe_jcc);
12584   ins_short_branch(1);
12585 %}
12586 
12587 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12588   match(If cop cmp);
12589   effect(USE labl);
12590 
12591   ins_cost(300);
12592   format %{ $$template
12593     if ($cop$$cmpcode == Assembler::notEqual) {
12594       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12595       $$emit$$&quot;j$cop,u,s  $labl&quot;
12596     } else {
12597       $$emit$$&quot;jp,u,s  done\n\t&quot;
12598       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12599       $$emit$$&quot;done:&quot;
12600     }
12601   %}
12602   size(4);
12603   ins_encode %{
12604     Label* l = $labl$$label;
12605     if ($cop$$cmpcode == Assembler::notEqual) {
12606       __ jccb(Assembler::parity, *l);
12607       __ jccb(Assembler::notEqual, *l);
12608     } else if ($cop$$cmpcode == Assembler::equal) {
12609       Label done;
12610       __ jccb(Assembler::parity, done);
12611       __ jccb(Assembler::equal, *l);
12612       __ bind(done);
12613     } else {
12614        ShouldNotReachHere();
12615     }
12616   %}
12617   ins_pipe(pipe_jcc);
12618   ins_short_branch(1);
12619 %}
12620 
12621 // ============================================================================
12622 // inlined locking and unlocking
12623 
12624 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12625   predicate(Compile::current()-&gt;use_rtm());
12626   match(Set cr (FastLock object box));
12627   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12628   ins_cost(300);
12629   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12630   ins_encode %{
12631     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12632                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12633                  _counters, _rtm_counters, _stack_rtm_counters,
12634                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12635                  true, ra_-&gt;C-&gt;profile_rtm());
12636   %}
12637   ins_pipe(pipe_slow);
12638 %}
12639 
12640 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
12641   predicate(!Compile::current()-&gt;use_rtm());
12642   match(Set cr (FastLock object box));
12643   effect(TEMP tmp, TEMP scr, USE_KILL box);
12644   ins_cost(300);
12645   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12646   ins_encode %{
12647     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12648                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
12649   %}
12650   ins_pipe(pipe_slow);
12651 %}
12652 
12653 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12654   match(Set cr (FastUnlock object box));
12655   effect(TEMP tmp, USE_KILL box);
12656   ins_cost(300);
12657   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12658   ins_encode %{
12659     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12660   %}
12661   ins_pipe(pipe_slow);
12662 %}
12663 
12664 
12665 // ============================================================================
12666 // Safepoint Instructions
12667 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12668 %{
12669   match(SafePoint poll);
12670   effect(KILL cr, USE poll);
12671 
12672   format %{ &quot;testl   rax, [$poll]\t&quot;
12673             &quot;# Safepoint: poll for GC&quot; %}
12674   ins_cost(125);
12675   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12676   ins_encode %{
12677     __ relocate(relocInfo::poll_type);
12678     address pre_pc = __ pc();
12679     __ testl(rax, Address($poll$$Register, 0));
12680     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12681   %}
12682   ins_pipe(ialu_reg_mem);
12683 %}
12684 
12685 // ============================================================================
12686 // Procedure Call/Return Instructions
12687 // Call Java Static Instruction
12688 // Note: If this code changes, the corresponding ret_addr_offset() and
12689 //       compute_padding() functions will have to be adjusted.
12690 instruct CallStaticJavaDirect(method meth) %{
12691   match(CallStaticJava);
12692   effect(USE meth);
12693 
12694   ins_cost(300);
12695   format %{ &quot;call,static &quot; %}
12696   opcode(0xE8); /* E8 cd */
12697   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12698   ins_pipe(pipe_slow);
12699   ins_alignment(4);
12700 %}
12701 
12702 // Call Java Dynamic Instruction
12703 // Note: If this code changes, the corresponding ret_addr_offset() and
12704 //       compute_padding() functions will have to be adjusted.
12705 instruct CallDynamicJavaDirect(method meth)
12706 %{
12707   match(CallDynamicJava);
12708   effect(USE meth);
12709 
12710   ins_cost(300);
12711   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12712             &quot;call,dynamic &quot; %}
12713   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12714   ins_pipe(pipe_slow);
12715   ins_alignment(4);
12716 %}
12717 
12718 // Call Runtime Instruction
12719 instruct CallRuntimeDirect(method meth)
12720 %{
12721   match(CallRuntime);
12722   effect(USE meth);
12723 
12724   ins_cost(300);
12725   format %{ &quot;call,runtime &quot; %}
12726   ins_encode(clear_avx, Java_To_Runtime(meth));
12727   ins_pipe(pipe_slow);
12728 %}
12729 
12730 // Call runtime without safepoint
12731 instruct CallLeafDirect(method meth)
12732 %{
12733   match(CallLeaf);
12734   effect(USE meth);
12735 
12736   ins_cost(300);
12737   format %{ &quot;call_leaf,runtime &quot; %}
12738   ins_encode(clear_avx, Java_To_Runtime(meth));
12739   ins_pipe(pipe_slow);
12740 %}
12741 
12742 // Call runtime without safepoint
12743 // entry point is null, target holds the address to call
12744 instruct CallLeafNoFPInDirect(rRegP target)
12745 %{
12746   predicate(n-&gt;as_Call()-&gt;entry_point() == NULL);
12747   match(CallLeafNoFP target);
12748 
12749   ins_cost(300);
12750   format %{ &quot;call_leaf_nofp,runtime indirect &quot; %}
12751   ins_encode %{
12752      __ call($target$$Register);
12753   %}
12754 
12755   ins_pipe(pipe_slow);
12756 %}
12757 
12758 instruct CallLeafNoFPDirect(method meth)
12759 %{
12760   predicate(n-&gt;as_Call()-&gt;entry_point() != NULL);
12761   match(CallLeafNoFP);
12762   effect(USE meth);
12763 
12764   ins_cost(300);
12765   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12766   ins_encode(clear_avx, Java_To_Runtime(meth));
12767   ins_pipe(pipe_slow);
12768 %}
12769 
12770 // Return Instruction
12771 // Remove the return address &amp; jump to it.
12772 // Notice: We always emit a nop after a ret to make sure there is room
12773 // for safepoint patching
12774 instruct Ret()
12775 %{
12776   match(Return);
12777 
12778   format %{ &quot;ret&quot; %}
12779   opcode(0xC3);
12780   ins_encode(OpcP);
12781   ins_pipe(pipe_jmp);
12782 %}
12783 
12784 // Tail Call; Jump from runtime stub to Java code.
12785 // Also known as an &#39;interprocedural jump&#39;.
12786 // Target of jump will eventually return to caller.
12787 // TailJump below removes the return address.
12788 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12789 %{
12790   match(TailCall jump_target method_oop);
12791 
12792   ins_cost(300);
12793   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12794   opcode(0xFF, 0x4); /* Opcode FF /4 */
12795   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12796   ins_pipe(pipe_jmp);
12797 %}
12798 
12799 // Tail Jump; remove the return address; jump to target.
12800 // TailCall above leaves the return address around.
12801 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12802 %{
12803   match(TailJump jump_target ex_oop);
12804 
12805   ins_cost(300);
12806   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12807             &quot;jmp     $jump_target&quot; %}
12808   opcode(0xFF, 0x4); /* Opcode FF /4 */
12809   ins_encode(Opcode(0x5a), // popq rdx
12810              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12811   ins_pipe(pipe_jmp);
12812 %}
12813 
12814 // Create exception oop: created by stack-crawling runtime code.
12815 // Created exception is now available to this handler, and is setup
12816 // just prior to jumping to this handler.  No code emitted.
12817 instruct CreateException(rax_RegP ex_oop)
12818 %{
12819   match(Set ex_oop (CreateEx));
12820 
12821   size(0);
12822   // use the following format syntax
12823   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12824   ins_encode();
12825   ins_pipe(empty);
12826 %}
12827 
12828 // Rethrow exception:
12829 // The exception oop will come in the first argument position.
12830 // Then JUMP (not call) to the rethrow stub code.
12831 instruct RethrowException()
12832 %{
12833   match(Rethrow);
12834 
12835   // use the following format syntax
12836   format %{ &quot;jmp     rethrow_stub&quot; %}
12837   ins_encode(enc_rethrow);
12838   ins_pipe(pipe_jmp);
12839 %}
12840 
12841 // ============================================================================
12842 // This name is KNOWN by the ADLC and cannot be changed.
12843 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12844 // for this guy.
12845 instruct tlsLoadP(r15_RegP dst) %{
12846   match(Set dst (ThreadLocal));
12847   effect(DEF dst);
12848 
12849   size(0);
12850   format %{ &quot;# TLS is in R15&quot; %}
12851   ins_encode( /*empty encoding*/ );
12852   ins_pipe(ialu_reg_reg);
12853 %}
12854 
12855 
12856 //----------PEEPHOLE RULES-----------------------------------------------------
12857 // These must follow all instruction definitions as they use the names
12858 // defined in the instructions definitions.
12859 //
12860 // peepmatch ( root_instr_name [preceding_instruction]* );
12861 //
12862 // peepconstraint %{
12863 // (instruction_number.operand_name relational_op instruction_number.operand_name
12864 //  [, ...] );
12865 // // instruction numbers are zero-based using left to right order in peepmatch
12866 //
12867 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12868 // // provide an instruction_number.operand_name for each operand that appears
12869 // // in the replacement instruction&#39;s match rule
12870 //
12871 // ---------VM FLAGS---------------------------------------------------------
12872 //
12873 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12874 //
12875 // Each peephole rule is given an identifying number starting with zero and
12876 // increasing by one in the order seen by the parser.  An individual peephole
12877 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12878 // on the command-line.
12879 //
12880 // ---------CURRENT LIMITATIONS----------------------------------------------
12881 //
12882 // Only match adjacent instructions in same basic block
12883 // Only equality constraints
12884 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12885 // Only one replacement instruction
12886 //
12887 // ---------EXAMPLE----------------------------------------------------------
12888 //
12889 // // pertinent parts of existing instructions in architecture description
12890 // instruct movI(rRegI dst, rRegI src)
12891 // %{
12892 //   match(Set dst (CopyI src));
12893 // %}
12894 //
12895 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12896 // %{
12897 //   match(Set dst (AddI dst src));
12898 //   effect(KILL cr);
12899 // %}
12900 //
12901 // // Change (inc mov) to lea
12902 // peephole %{
12903 //   // increment preceeded by register-register move
12904 //   peepmatch ( incI_rReg movI );
12905 //   // require that the destination register of the increment
12906 //   // match the destination register of the move
12907 //   peepconstraint ( 0.dst == 1.dst );
12908 //   // construct a replacement instruction that sets
12909 //   // the destination to ( move&#39;s source register + one )
12910 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12911 // %}
12912 //
12913 
12914 // Implementation no longer uses movX instructions since
12915 // machine-independent system no longer uses CopyX nodes.
12916 //
12917 // peephole
12918 // %{
12919 //   peepmatch (incI_rReg movI);
12920 //   peepconstraint (0.dst == 1.dst);
12921 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12922 // %}
12923 
12924 // peephole
12925 // %{
12926 //   peepmatch (decI_rReg movI);
12927 //   peepconstraint (0.dst == 1.dst);
12928 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12929 // %}
12930 
12931 // peephole
12932 // %{
12933 //   peepmatch (addI_rReg_imm movI);
12934 //   peepconstraint (0.dst == 1.dst);
12935 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12936 // %}
12937 
12938 // peephole
12939 // %{
12940 //   peepmatch (incL_rReg movL);
12941 //   peepconstraint (0.dst == 1.dst);
12942 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12943 // %}
12944 
12945 // peephole
12946 // %{
12947 //   peepmatch (decL_rReg movL);
12948 //   peepconstraint (0.dst == 1.dst);
12949 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12950 // %}
12951 
12952 // peephole
12953 // %{
12954 //   peepmatch (addL_rReg_imm movL);
12955 //   peepconstraint (0.dst == 1.dst);
12956 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12957 // %}
12958 
12959 // peephole
12960 // %{
12961 //   peepmatch (addP_rReg_imm movP);
12962 //   peepconstraint (0.dst == 1.dst);
12963 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
12964 // %}
12965 
12966 // // Change load of spilled value to only a spill
12967 // instruct storeI(memory mem, rRegI src)
12968 // %{
12969 //   match(Set mem (StoreI mem src));
12970 // %}
12971 //
12972 // instruct loadI(rRegI dst, memory mem)
12973 // %{
12974 //   match(Set dst (LoadI mem));
12975 // %}
12976 //
12977 
12978 peephole
12979 %{
12980   peepmatch (loadI storeI);
12981   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12982   peepreplace (storeI(1.mem 1.mem 1.src));
12983 %}
12984 
12985 peephole
12986 %{
12987   peepmatch (loadL storeL);
12988   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12989   peepreplace (storeL(1.mem 1.mem 1.src));
12990 %}
12991 
12992 //----------SMARTSPILL RULES---------------------------------------------------
12993 // These must follow all instruction definitions as they use the names
12994 // defined in the instructions definitions.
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubGenerator_x86_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs_x86_64.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/templateTable_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -31,10 +31,11 @@</span>
  #include &quot;interpreter/templateTable.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/valueKlass.hpp&quot;</span>
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152,11 +153,11 @@</span>
  static void do_oop_store(InterpreterMacroAssembler* _masm,
                           Address dst,
                           Register val,
                           DecoratorSet decorators = 0) {
    assert(val == noreg || val == rax, &quot;parameter is just for looks&quot;);
<span class="udiff-line-modified-removed">-   __ store_heap_oop(dst, val, rdx, rbx, decorators);</span>
<span class="udiff-line-modified-added">+   __ store_heap_oop(dst, val, rdx, rbx, noreg, decorators);</span>
  }
  
  static void do_oop_load(InterpreterMacroAssembler* _masm,
                          Address src,
                          Register dst,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -175,10 +176,11 @@</span>
                                     int byte_no) {
    if (!RewriteBytecodes)  return;
    Label L_patch_done;
  
    switch (bc) {
<span class="udiff-line-added">+   case Bytecodes::_fast_qputfield:</span>
    case Bytecodes::_fast_aputfield:
    case Bytecodes::_fast_bputfield:
    case Bytecodes::_fast_zputfield:
    case Bytecodes::_fast_cputfield:
    case Bytecodes::_fast_dputfield:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -367,10 +369,11 @@</span>
    const int base_offset = ConstantPool::header_size() * wordSize;
    const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
  
    // get type
    __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));
<span class="udiff-line-added">+   __ andl(rdx, ~JVM_CONSTANT_QDescBit);</span>
  
    // unresolved class - get the resolved class
    __ cmpl(rdx, JVM_CONSTANT_UnresolvedClass);
    __ jccb(Assembler::equal, call_ldc);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -817,19 +820,37 @@</span>
                      noreg, noreg);
  }
  
  void TemplateTable::aaload() {
    transition(itos, atos);
<span class="udiff-line-modified-removed">-   // rax: index</span>
<span class="udiff-line-modified-removed">-   // rdx: array</span>
<span class="udiff-line-modified-removed">-   index_check(rdx, rax); // kills rbx</span>
<span class="udiff-line-modified-removed">-   do_oop_load(_masm,</span>
<span class="udiff-line-modified-removed">-               Address(rdx, rax,</span>
<span class="udiff-line-modified-removed">-                       UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="udiff-line-modified-removed">-                       arrayOopDesc::base_offset_in_bytes(T_OBJECT)),</span>
<span class="udiff-line-modified-removed">-               rax,</span>
<span class="udiff-line-modified-removed">-               IS_ARRAY);</span>
<span class="udiff-line-modified-added">+   Register array = rdx;</span>
<span class="udiff-line-modified-added">+   Register index = rax;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   index_check(array, index); // kills rbx</span>
<span class="udiff-line-modified-added">+   __ profile_array(rbx, array, rcx);</span>
<span class="udiff-line-modified-added">+   if (ValueArrayFlatten) {</span>
<span class="udiff-line-modified-added">+     Label is_flat_array, done;</span>
<span class="udiff-line-modified-added">+     __ test_flattened_array_oop(array, rbx, is_flat_array);</span>
<span class="udiff-line-modified-added">+     do_oop_load(_masm,</span>
<span class="udiff-line-added">+                 Address(array, index,</span>
<span class="udiff-line-added">+                         UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="udiff-line-added">+                         arrayOopDesc::base_offset_in_bytes(T_OBJECT)),</span>
<span class="udiff-line-added">+                 rax,</span>
<span class="udiff-line-added">+                 IS_ARRAY);</span>
<span class="udiff-line-added">+     __ jmp(done);</span>
<span class="udiff-line-added">+     __ bind(is_flat_array);</span>
<span class="udiff-line-added">+     __ read_flattened_element(array, index, rbx, rcx, rax);</span>
<span class="udiff-line-added">+     __ bind(done);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     do_oop_load(_masm,</span>
<span class="udiff-line-added">+                 Address(array, index,</span>
<span class="udiff-line-added">+                         UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="udiff-line-added">+                         arrayOopDesc::base_offset_in_bytes(T_OBJECT)),</span>
<span class="udiff-line-added">+                 rax,</span>
<span class="udiff-line-added">+                 IS_ARRAY);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   __ profile_element(rbx, rax, rcx);</span>
  }
  
  void TemplateTable::baload() {
    transition(itos, itos);
    // rax: index
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1111,11 +1132,11 @@</span>
                               arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
                       noreg /* dtos */, noreg, noreg);
  }
  
  void TemplateTable::aastore() {
<span class="udiff-line-modified-removed">-   Label is_null, ok_is_subtype, done;</span>
<span class="udiff-line-modified-added">+   Label is_null, is_flat_array, ok_is_subtype, done;</span>
    transition(vtos, vtos);
    // stack: ..., array, index, value
    __ movptr(rax, at_tos());    // value
    __ movl(rcx, at_tos_p1()); // index
    __ movptr(rdx, at_tos_p2()); // array
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1123,24 +1144,35 @@</span>
    Address element_address(rdx, rcx,
                            UseCompressedOops? Address::times_4 : Address::times_ptr,
                            arrayOopDesc::base_offset_in_bytes(T_OBJECT));
  
    index_check_without_pop(rdx, rcx);     // kills rbx
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ profile_array(rdi, rdx, rbx);</span>
<span class="udiff-line-added">+   __ profile_element(rdi, rax, rbx);</span>
<span class="udiff-line-added">+ </span>
    __ testptr(rax, rax);
    __ jcc(Assembler::zero, is_null);
  
<span class="udiff-line-added">+   // Move array class to rdi</span>
    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
<span class="udiff-line-added">+   __ load_klass(rdi, rdx, tmp_load_klass);</span>
<span class="udiff-line-added">+   if (ValueArrayFlatten) {</span>
<span class="udiff-line-added">+     __ movl(rbx, Address(rdi, Klass::layout_helper_offset()));</span>
<span class="udiff-line-added">+     __ test_flattened_array_layout(rbx, is_flat_array);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Move subklass into rbx
    __ load_klass(rbx, rax, tmp_load_klass);
<span class="udiff-line-modified-removed">-   // Move superklass into rax</span>
<span class="udiff-line-modified-removed">-   __ load_klass(rax, rdx, tmp_load_klass);</span>
<span class="udiff-line-removed">-   __ movptr(rax, Address(rax,</span>
<span class="udiff-line-modified-added">+   // Move array element superklass into rax</span>
<span class="udiff-line-modified-added">+   __ movptr(rax, Address(rdi,</span>
                           ObjArrayKlass::element_klass_offset()));
  
    // Generate subtype check.  Blows rcx, rdi
    // Superklass in rax.  Subklass in rbx.
<span class="udiff-line-modified-removed">-   __ gen_subtype_check(rbx, ok_is_subtype);</span>
<span class="udiff-line-modified-added">+   // is &quot;rbx &lt;: rax&quot; ? (value subclass &lt;: array element superclass)</span>
<span class="udiff-line-added">+   __ gen_subtype_check(rbx, ok_is_subtype, false);</span>
  
    // Come here on failure
    // object is at TOS
    __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1154,15 +1186,59 @@</span>
    do_oop_store(_masm, element_address, rax, IS_ARRAY);
    __ jmp(done);
  
    // Have a NULL in rax, rdx=array, ecx=index.  Store NULL at ary[idx]
    __ bind(is_null);
<span class="udiff-line-modified-removed">-   __ profile_null_seen(rbx);</span>
<span class="udiff-line-modified-added">+   if (EnableValhalla) {</span>
<span class="udiff-line-added">+     Label is_null_into_value_array_npe, store_null;</span>
  
<span class="udiff-line-added">+     // No way to store null in null-free array</span>
<span class="udiff-line-added">+     __ test_null_free_array_oop(rdx, rbx, is_null_into_value_array_npe);</span>
<span class="udiff-line-added">+     __ jmp(store_null);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ bind(is_null_into_value_array_npe);</span>
<span class="udiff-line-added">+     __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ bind(store_null);</span>
<span class="udiff-line-added">+   }</span>
    // Store a NULL
    do_oop_store(_masm, element_address, noreg, IS_ARRAY);
<span class="udiff-line-added">+   __ jmp(done);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (EnableValhalla) {</span>
<span class="udiff-line-added">+     Label is_type_ok;</span>
<span class="udiff-line-added">+     __ bind(is_flat_array); // Store non-null value to flat</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Simplistic type check...</span>
  
<span class="udiff-line-added">+     // Profile the not-null value&#39;s klass.</span>
<span class="udiff-line-added">+     __ load_klass(rbx, rax, tmp_load_klass);</span>
<span class="udiff-line-added">+     // Move element klass into rax</span>
<span class="udiff-line-added">+     __ movptr(rax, Address(rdi, ArrayKlass::element_klass_offset()));</span>
<span class="udiff-line-added">+     // flat value array needs exact type match</span>
<span class="udiff-line-added">+     // is &quot;rax == rbx&quot; (value subclass == array element superclass)</span>
<span class="udiff-line-added">+     __ cmpptr(rax, rbx);</span>
<span class="udiff-line-added">+     __ jccb(Assembler::equal, is_type_ok);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ bind(is_type_ok);</span>
<span class="udiff-line-added">+     // rbx: value&#39;s klass</span>
<span class="udiff-line-added">+     // rdx: array</span>
<span class="udiff-line-added">+     // rdi: array klass</span>
<span class="udiff-line-added">+     __ test_klass_is_empty_value(rbx, rax, done);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // calc dst for copy</span>
<span class="udiff-line-added">+     __ movl(rax, at_tos_p1()); // index</span>
<span class="udiff-line-added">+     __ data_for_value_array_index(rdx, rdi, rax, rax);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // ...and src for copy</span>
<span class="udiff-line-added">+     __ movptr(rcx, at_tos());  // value</span>
<span class="udiff-line-added">+     __ data_for_oop(rcx, rcx, rbx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ access_value_copy(IN_HEAP, rcx, rax, rbx);</span>
<span class="udiff-line-added">+   }</span>
    // Pop stack arguments
    __ bind(done);
    __ addptr(rsp, 3 * Interpreter::stackElementSize);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2405,19 +2481,65 @@</span>
  }
  
  void TemplateTable::if_acmp(Condition cc) {
    transition(atos, vtos);
    // assume branch is more often taken than not (loops use backward branches)
<span class="udiff-line-modified-removed">-   Label not_taken;</span>
<span class="udiff-line-modified-added">+   Label taken, not_taken;</span>
    __ pop_ptr(rdx);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const int is_value_mask = markWord::always_locked_pattern;</span>
<span class="udiff-line-added">+   if (EnableValhalla) {</span>
<span class="udiff-line-added">+     __ cmpoop(rdx, rax);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::equal, (cc == equal) ? taken : not_taken);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // might be substitutable, test if either rax or rdx is null</span>
<span class="udiff-line-added">+     __ movptr(rbx, rdx);</span>
<span class="udiff-line-added">+     __ andptr(rbx, rax);</span>
<span class="udiff-line-added">+     __ testptr(rbx, rbx);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::zero, (cc == equal) ? not_taken : taken);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // and both are values ?</span>
<span class="udiff-line-added">+     __ movptr(rbx, Address(rdx, oopDesc::mark_offset_in_bytes()));</span>
<span class="udiff-line-added">+     __ andptr(rbx, is_value_mask);</span>
<span class="udiff-line-added">+     __ movptr(rcx, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="udiff-line-added">+     __ andptr(rbx, is_value_mask);</span>
<span class="udiff-line-added">+     __ andptr(rbx, rcx);</span>
<span class="udiff-line-added">+     __ cmpl(rbx, is_value_mask);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // same value klass ?</span>
<span class="udiff-line-added">+     __ load_metadata(rbx, rdx);</span>
<span class="udiff-line-added">+     __ load_metadata(rcx, rax);</span>
<span class="udiff-line-added">+     __ cmpptr(rbx, rcx);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Know both are the same type, let&#39;s test for substitutability...</span>
<span class="udiff-line-added">+     if (cc == equal) {</span>
<span class="udiff-line-added">+       invoke_is_substitutable(rax, rdx, taken, not_taken);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       invoke_is_substitutable(rax, rdx, not_taken, taken);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     __ stop(&quot;Not reachable&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    __ cmpoop(rdx, rax);
    __ jcc(j_not(cc), not_taken);
<span class="udiff-line-added">+   __ bind(taken);</span>
    branch(false, false);
    __ bind(not_taken);
    __ profile_not_taken_branch(rax);
  }
  
<span class="udiff-line-added">+ void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,</span>
<span class="udiff-line-added">+                                             Label&amp; is_subst, Label&amp; not_subst) {</span>
<span class="udiff-line-added">+   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);</span>
<span class="udiff-line-added">+   // Restored...rax answer, jmp to outcome...</span>
<span class="udiff-line-added">+   __ testl(rax, rax);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::zero, not_subst);</span>
<span class="udiff-line-added">+   __ jmp(is_subst);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void TemplateTable::ret() {
    transition(vtos, vtos);
    locals_index(rbx);
    LP64_ONLY(__ movslq(rbx, iaddress(rbx))); // get return bci, compute return bcp
    NOT_LP64(__ movptr(rbx, iaddress(rbx)));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2680,11 +2802,12 @@</span>
    // Need to narrow in the return bytecode rather than in generate_return_entry
    // since compiled code callers expect the result to already be narrowed.
    if (state == itos) {
      __ narrow(rax);
    }
<span class="udiff-line-modified-removed">-   __ remove_activation(state, rbcp);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   __ remove_activation(state, rbcp, true, true, true);</span>
  
    __ jmp(rbcp);
  }
  
  // ----------------------------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2878,41 +3001,50 @@</span>
    const Register index = rdx;
    const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
    const Register off   = rbx;
    const Register flags = rax;
    const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // uses same reg as obj, so don&#39;t mix them
<span class="udiff-line-added">+   const Register flags2 = rdx;</span>
  
    resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
    jvmti_post_field_access(cache, index, is_static, false);
    load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
  
<span class="udiff-line-removed">-   if (!is_static) pop_and_check_object(obj);</span>
<span class="udiff-line-removed">- </span>
    const Address field(obj, off, Address::times_1, 0*wordSize);
  
<span class="udiff-line-modified-removed">-   Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj;</span>
<span class="udiff-line-modified-added">+   Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj, notValueType;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!is_static) {</span>
<span class="udiff-line-added">+     __ movptr(rcx, Address(cache, index, Address::times_ptr,</span>
<span class="udiff-line-added">+                            in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="udiff-line-added">+                                     ConstantPoolCacheEntry::f1_offset())));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ movl(flags2, flags);</span>
  
    __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
    // Make sure we don&#39;t need to mask edx after the above shift
    assert(btos == 0, &quot;change code, btos != 0&quot;);
  
    __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
  
    __ jcc(Assembler::notZero, notByte);
    // btos
<span class="udiff-line-added">+   if (!is_static) pop_and_check_object(obj);</span>
    __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
    __ push(btos);
    // Rewrite bytecode to be faster
    if (!is_static &amp;&amp; rc == may_rewrite) {
      patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
    }
    __ jmp(Done);
  
    __ bind(notByte);
<span class="udiff-line-added">+ </span>
    __ cmpl(flags, ztos);
    __ jcc(Assembler::notEqual, notBool);
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+    if (!is_static) pop_and_check_object(obj);</span>
    // ztos (same code as btos)
    __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg, noreg);
    __ push(ztos);
    // Rewrite bytecode to be faster
    if (!is_static &amp;&amp; rc == may_rewrite) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2923,18 +3055,97 @@</span>
  
    __ bind(notBool);
    __ cmpl(flags, atos);
    __ jcc(Assembler::notEqual, notObj);
    // atos
<span class="udiff-line-modified-removed">-   do_oop_load(_masm, field, rax);</span>
<span class="udiff-line-modified-removed">-   __ push(atos);</span>
<span class="udiff-line-modified-removed">-   if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="udiff-line-modified-removed">-     patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);</span>
<span class="udiff-line-modified-added">+   if (!EnableValhalla) {</span>
<span class="udiff-line-modified-added">+     if (!is_static) pop_and_check_object(obj);</span>
<span class="udiff-line-modified-added">+     do_oop_load(_masm, field, rax);</span>
<span class="udiff-line-modified-added">+     __ push(atos);</span>
<span class="udiff-line-added">+     if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="udiff-line-added">+       patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     __ jmp(Done);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     if (is_static) {</span>
<span class="udiff-line-added">+       __ load_heap_oop(rax, field);</span>
<span class="udiff-line-added">+       Label isFlattenable, uninitialized;</span>
<span class="udiff-line-added">+       // Issue below if the static field has not been initialized yet</span>
<span class="udiff-line-added">+       __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="udiff-line-added">+         // Not flattenable case</span>
<span class="udiff-line-added">+         __ push(atos);</span>
<span class="udiff-line-added">+         __ jmp(Done);</span>
<span class="udiff-line-added">+       // Flattenable case, must not return null even if uninitialized</span>
<span class="udiff-line-added">+       __ bind(isFlattenable);</span>
<span class="udiff-line-added">+         __ testptr(rax, rax);</span>
<span class="udiff-line-added">+         __ jcc(Assembler::zero, uninitialized);</span>
<span class="udiff-line-added">+           __ push(atos);</span>
<span class="udiff-line-added">+           __ jmp(Done);</span>
<span class="udiff-line-added">+         __ bind(uninitialized);</span>
<span class="udiff-line-added">+           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+           Label slow_case, finish;</span>
<span class="udiff-line-added">+           __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);</span>
<span class="udiff-line-added">+           __ jcc(Assembler::notEqual, slow_case);</span>
<span class="udiff-line-added">+         __ get_default_value_oop(rcx, off, rax);</span>
<span class="udiff-line-added">+         __ jmp(finish);</span>
<span class="udiff-line-added">+         __ bind(slow_case);</span>
<span class="udiff-line-added">+ #endif // LP64</span>
<span class="udiff-line-added">+           __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_value_field),</span>
<span class="udiff-line-added">+                  obj, flags2);</span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+           __ bind(finish);</span>
<span class="udiff-line-added">+ #endif // _LP64</span>
<span class="udiff-line-added">+           __ verify_oop(rax);</span>
<span class="udiff-line-added">+           __ push(atos);</span>
<span class="udiff-line-added">+           __ jmp(Done);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       Label isFlattened, nonnull, isFlattenable, rewriteFlattenable;</span>
<span class="udiff-line-added">+       __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="udiff-line-added">+         // Non-flattenable field case, also covers the object case</span>
<span class="udiff-line-added">+         pop_and_check_object(obj);</span>
<span class="udiff-line-added">+         __ load_heap_oop(rax, field);</span>
<span class="udiff-line-added">+         __ push(atos);</span>
<span class="udiff-line-added">+         if (rc == may_rewrite) {</span>
<span class="udiff-line-added">+           patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         __ jmp(Done);</span>
<span class="udiff-line-added">+       __ bind(isFlattenable);</span>
<span class="udiff-line-added">+         __ test_field_is_flattened(flags2, rscratch1, isFlattened);</span>
<span class="udiff-line-added">+           // Non-flattened field case</span>
<span class="udiff-line-added">+           __ movptr(rax, rcx);  // small dance required to preserve the klass_holder somewhere</span>
<span class="udiff-line-added">+           pop_and_check_object(obj);</span>
<span class="udiff-line-added">+           __ push(rax);</span>
<span class="udiff-line-added">+           __ load_heap_oop(rax, field);</span>
<span class="udiff-line-added">+           __ pop(rcx);</span>
<span class="udiff-line-added">+           __ testptr(rax, rax);</span>
<span class="udiff-line-added">+           __ jcc(Assembler::notZero, nonnull);</span>
<span class="udiff-line-added">+             __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="udiff-line-added">+             __ get_value_field_klass(rcx, flags2, rbx);</span>
<span class="udiff-line-added">+             __ get_default_value_oop(rbx, rcx, rax);</span>
<span class="udiff-line-added">+           __ bind(nonnull);</span>
<span class="udiff-line-added">+           __ verify_oop(rax);</span>
<span class="udiff-line-added">+           __ push(atos);</span>
<span class="udiff-line-added">+           __ jmp(rewriteFlattenable);</span>
<span class="udiff-line-added">+         __ bind(isFlattened);</span>
<span class="udiff-line-added">+           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="udiff-line-added">+           pop_and_check_object(rax);</span>
<span class="udiff-line-added">+           __ read_flattened_field(rcx, flags2, rbx, rax);</span>
<span class="udiff-line-added">+           __ verify_oop(rax);</span>
<span class="udiff-line-added">+           __ push(atos);</span>
<span class="udiff-line-added">+       __ bind(rewriteFlattenable);</span>
<span class="udiff-line-added">+       if (rc == may_rewrite) {</span>
<span class="udiff-line-added">+         patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       __ jmp(Done);</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-removed">-   __ jmp(Done);</span>
  
    __ bind(notObj);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!is_static) pop_and_check_object(obj);</span>
<span class="udiff-line-added">+ </span>
    __ cmpl(flags, itos);
    __ jcc(Assembler::notEqual, notInt);
    // itos
    __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
    __ push(itos);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3030,10 +3241,25 @@</span>
  
  void TemplateTable::getstatic(int byte_no) {
    getfield_or_static(byte_no, true);
  }
  
<span class="udiff-line-added">+ void TemplateTable::withfield() {</span>
<span class="udiff-line-added">+   transition(vtos, atos);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Register cache = LP64_ONLY(c_rarg1) NOT_LP64(rcx);</span>
<span class="udiff-line-added">+   Register index = LP64_ONLY(c_rarg2) NOT_LP64(rdx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   resolve_cache_and_index(f2_byte, cache, index, sizeof(u2));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cache);</span>
<span class="udiff-line-added">+   // new value type is returned in rbx</span>
<span class="udiff-line-added">+   // stack adjustement is returned in rax</span>
<span class="udiff-line-added">+   __ verify_oop(rbx);</span>
<span class="udiff-line-added">+   __ addptr(rsp, rax);</span>
<span class="udiff-line-added">+   __ movptr(rax, rbx);</span>
<span class="udiff-line-added">+ }</span>
  
  // The registers cache and index expected to be set before call.
  // The function may destroy various registers, just not the cache and index registers.
  void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3125,10 +3351,11 @@</span>
    const Register cache = rcx;
    const Register index = rdx;
    const Register obj   = rcx;
    const Register off   = rbx;
    const Register flags = rax;
<span class="udiff-line-added">+   const Register flags2 = rdx;</span>
  
    resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
    jvmti_post_field_mod(cache, index, is_static);
    load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3141,32 +3368,33 @@</span>
    __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
    __ andl(rdx, 0x1);
  
    // Check for volatile store
    __ testl(rdx, rdx);
<span class="udiff-line-added">+   __ movl(flags2, flags);</span>
    __ jcc(Assembler::zero, notVolatile);
  
<span class="udiff-line-modified-removed">-   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);</span>
<span class="udiff-line-modified-added">+   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);</span>
    volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
                                                 Assembler::StoreStore));
    __ jmp(Done);
    __ bind(notVolatile);
  
<span class="udiff-line-modified-removed">-   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);</span>
<span class="udiff-line-modified-added">+   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);</span>
  
    __ bind(Done);
  }
  
  void TemplateTable::putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
<span class="udiff-line-modified-removed">-                                               Register obj, Register off, Register flags) {</span>
<span class="udiff-line-modified-added">+                                               Register obj, Register off, Register flags, Register flags2) {</span>
  
    // field addresses
    const Address field(obj, off, Address::times_1, 0*wordSize);
    NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)
  
    Label notByte, notBool, notInt, notShort, notChar,
<span class="udiff-line-modified-removed">-         notLong, notFloat, notObj;</span>
<span class="udiff-line-modified-added">+         notLong, notFloat, notObj, notValueType;</span>
    Label Done;
  
    const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
  
    __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3205,18 +3433,63 @@</span>
    __ cmpl(flags, atos);
    __ jcc(Assembler::notEqual, notObj);
  
    // atos
    {
<span class="udiff-line-modified-removed">-     __ pop(atos);</span>
<span class="udiff-line-modified-removed">-     if (!is_static) pop_and_check_object(obj);</span>
<span class="udiff-line-modified-removed">-     // Store into the field</span>
<span class="udiff-line-modified-removed">-     do_oop_store(_masm, field, rax);</span>
<span class="udiff-line-modified-removed">-     if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="udiff-line-modified-removed">-       patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);</span>
<span class="udiff-line-modified-added">+     if (!EnableValhalla) {</span>
<span class="udiff-line-modified-added">+       __ pop(atos);</span>
<span class="udiff-line-modified-added">+       if (!is_static) pop_and_check_object(obj);</span>
<span class="udiff-line-modified-added">+       // Store into the field</span>
<span class="udiff-line-modified-added">+       do_oop_store(_masm, field, rax);</span>
<span class="udiff-line-modified-added">+       if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="udiff-line-added">+         patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       __ jmp(Done);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       __ pop(atos);</span>
<span class="udiff-line-added">+       if (is_static) {</span>
<span class="udiff-line-added">+         Label notFlattenable, notBuffered;</span>
<span class="udiff-line-added">+         __ test_field_is_not_flattenable(flags2, rscratch1, notFlattenable);</span>
<span class="udiff-line-added">+         __ null_check(rax);</span>
<span class="udiff-line-added">+         __ bind(notFlattenable);</span>
<span class="udiff-line-added">+         do_oop_store(_masm, field, rax);</span>
<span class="udiff-line-added">+         __ jmp(Done);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         Label isFlattenable, isFlattened, notBuffered, notBuffered2, rewriteNotFlattenable, rewriteFlattenable;</span>
<span class="udiff-line-added">+         __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="udiff-line-added">+         // Not flattenable case, covers not flattenable values and objects</span>
<span class="udiff-line-added">+         pop_and_check_object(obj);</span>
<span class="udiff-line-added">+         // Store into the field</span>
<span class="udiff-line-added">+         do_oop_store(_masm, field, rax);</span>
<span class="udiff-line-added">+         __ bind(rewriteNotFlattenable);</span>
<span class="udiff-line-added">+         if (rc == may_rewrite) {</span>
<span class="udiff-line-added">+           patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         __ jmp(Done);</span>
<span class="udiff-line-added">+         // Implementation of the flattenable semantic</span>
<span class="udiff-line-added">+         __ bind(isFlattenable);</span>
<span class="udiff-line-added">+         __ null_check(rax);</span>
<span class="udiff-line-added">+         __ test_field_is_flattened(flags2, rscratch1, isFlattened);</span>
<span class="udiff-line-added">+         // Not flattened case</span>
<span class="udiff-line-added">+         pop_and_check_object(obj);</span>
<span class="udiff-line-added">+         // Store into the field</span>
<span class="udiff-line-added">+         do_oop_store(_masm, field, rax);</span>
<span class="udiff-line-added">+         __ jmp(rewriteFlattenable);</span>
<span class="udiff-line-added">+         __ bind(isFlattened);</span>
<span class="udiff-line-added">+         pop_and_check_object(obj);</span>
<span class="udiff-line-added">+         assert_different_registers(rax, rdx, obj, off);</span>
<span class="udiff-line-added">+         __ load_klass(rdx, rax, rscratch1);</span>
<span class="udiff-line-added">+         __ data_for_oop(rax, rax, rdx);</span>
<span class="udiff-line-added">+         __ addptr(obj, off);</span>
<span class="udiff-line-added">+         __ access_value_copy(IN_HEAP, rax, obj, rdx);</span>
<span class="udiff-line-added">+         __ bind(rewriteFlattenable);</span>
<span class="udiff-line-added">+         if (rc == may_rewrite) {</span>
<span class="udiff-line-added">+           patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         __ jmp(Done);</span>
<span class="udiff-line-added">+       }</span>
      }
<span class="udiff-line-removed">-     __ jmp(Done);</span>
    }
  
    __ bind(notObj);
    __ cmpl(flags, itos);
    __ jcc(Assembler::notEqual, notInt);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3351,10 +3624,11 @@</span>
      __ push_ptr(rbx);                 // put the object pointer back on tos
      // Save tos values before call_VM() clobbers them. Since we have
      // to do it for every data type, we use the saved values as the
      // jvalue object.
      switch (bytecode()) {          // load values into the jvalue object
<span class="udiff-line-added">+     case Bytecodes::_fast_qputfield: //fall through</span>
      case Bytecodes::_fast_aputfield: __ push_ptr(rax); break;
      case Bytecodes::_fast_bputfield: // fall through
      case Bytecodes::_fast_zputfield: // fall through
      case Bytecodes::_fast_sputfield: // fall through
      case Bytecodes::_fast_cputfield: // fall through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3376,10 +3650,11 @@</span>
      // c_rarg3: jvalue object on the stack
      LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3));
      NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, rax, rcx));
  
      switch (bytecode()) {             // restore tos values
<span class="udiff-line-added">+     case Bytecodes::_fast_qputfield: // fall through</span>
      case Bytecodes::_fast_aputfield: __ pop_ptr(rax); break;
      case Bytecodes::_fast_bputfield: // fall through
      case Bytecodes::_fast_zputfield: // fall through
      case Bytecodes::_fast_sputfield: // fall through
      case Bytecodes::_fast_cputfield: // fall through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3415,10 +3690,14 @@</span>
    // [jk] not needed currently
    // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
    //                                              Assembler::StoreStore));
  
    Label notVolatile, Done;
<span class="udiff-line-added">+   if (bytecode() == Bytecodes::_fast_qputfield) {</span>
<span class="udiff-line-added">+     __ movl(rscratch2, rdx);  // saving flags for isFlattened test</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
    __ andl(rdx, 0x1);
  
    // Get object from stack
    pop_and_check_object(rcx);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3428,27 +3707,52 @@</span>
  
    // Check for volatile store
    __ testl(rdx, rdx);
    __ jcc(Assembler::zero, notVolatile);
  
<span class="udiff-line-modified-removed">-   fast_storefield_helper(field, rax);</span>
<span class="udiff-line-modified-added">+   if (bytecode() == Bytecodes::_fast_qputfield) {</span>
<span class="udiff-line-added">+     __ movl(rdx, rscratch2);  // restoring flags for isFlattened test</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   fast_storefield_helper(field, rax, rdx);</span>
    volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
                                                 Assembler::StoreStore));
    __ jmp(Done);
    __ bind(notVolatile);
  
<span class="udiff-line-modified-removed">-   fast_storefield_helper(field, rax);</span>
<span class="udiff-line-modified-added">+   if (bytecode() == Bytecodes::_fast_qputfield) {</span>
<span class="udiff-line-added">+     __ movl(rdx, rscratch2);  // restoring flags for isFlattened test</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   fast_storefield_helper(field, rax, rdx);</span>
  
    __ bind(Done);
  }
  
<span class="udiff-line-modified-removed">- void TemplateTable::fast_storefield_helper(Address field, Register rax) {</span>
<span class="udiff-line-modified-added">+ void TemplateTable::fast_storefield_helper(Address field, Register rax, Register flags) {</span>
  
    // access field
    switch (bytecode()) {
<span class="udiff-line-added">+   case Bytecodes::_fast_qputfield:</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       Label isFlattened, done;</span>
<span class="udiff-line-added">+       __ null_check(rax);</span>
<span class="udiff-line-added">+       __ test_field_is_flattened(flags, rscratch1, isFlattened);</span>
<span class="udiff-line-added">+       // No Flattened case</span>
<span class="udiff-line-added">+       do_oop_store(_masm, field, rax);</span>
<span class="udiff-line-added">+       __ jmp(done);</span>
<span class="udiff-line-added">+       __ bind(isFlattened);</span>
<span class="udiff-line-added">+       // Flattened case</span>
<span class="udiff-line-added">+       __ load_klass(rdx, rax, rscratch1);</span>
<span class="udiff-line-added">+       __ data_for_oop(rax, rax, rdx);</span>
<span class="udiff-line-added">+       __ lea(rcx, field);</span>
<span class="udiff-line-added">+       __ access_value_copy(IN_HEAP, rax, rcx, rdx);</span>
<span class="udiff-line-added">+       __ bind(done);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     break;</span>
    case Bytecodes::_fast_aputfield:
<span class="udiff-line-modified-removed">-     do_oop_store(_masm, field, rax);</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-added">+       do_oop_store(_masm, field, rax);</span>
<span class="udiff-line-added">+     }</span>
      break;
    case Bytecodes::_fast_lputfield:
  #ifdef _LP64
      __ access_store_at(T_LONG, IN_HEAP, field, noreg /* ltos */, noreg, noreg);
  #else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3514,21 +3818,59 @@</span>
    //                      in_bytes(ConstantPoolCache::base_offset() +
    //                               ConstantPoolCacheEntry::flags_offset())));
    // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
    // __ andl(rdx, 0x1);
    //
<span class="udiff-line-modified-removed">-   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="udiff-line-modified-added">+   __ movptr(rdx, Address(rcx, rbx, Address::times_ptr,</span>
                           in_bytes(ConstantPoolCache::base_offset() +
                                    ConstantPoolCacheEntry::f2_offset())));
  
    // rax: object
    __ verify_oop(rax);
    __ null_check(rax);
<span class="udiff-line-modified-removed">-   Address field(rax, rbx, Address::times_1);</span>
<span class="udiff-line-modified-added">+   Address field(rax, rdx, Address::times_1);</span>
  
    // access field
    switch (bytecode()) {
<span class="udiff-line-added">+   case Bytecodes::_fast_qgetfield:</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       Label isFlattened, nonnull, Done;</span>
<span class="udiff-line-added">+       __ movptr(rscratch1, Address(rcx, rbx, Address::times_ptr,</span>
<span class="udiff-line-added">+                                    in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="udiff-line-added">+                                             ConstantPoolCacheEntry::flags_offset())));</span>
<span class="udiff-line-added">+       __ test_field_is_flattened(rscratch1, rscratch2, isFlattened);</span>
<span class="udiff-line-added">+         // Non-flattened field case</span>
<span class="udiff-line-added">+         __ load_heap_oop(rax, field);</span>
<span class="udiff-line-added">+         __ testptr(rax, rax);</span>
<span class="udiff-line-added">+         __ jcc(Assembler::notZero, nonnull);</span>
<span class="udiff-line-added">+           __ movl(rdx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="udiff-line-added">+                              in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="udiff-line-added">+                                       ConstantPoolCacheEntry::flags_offset())));</span>
<span class="udiff-line-added">+           __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="udiff-line-added">+           __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="udiff-line-added">+                                        in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="udiff-line-added">+                                                 ConstantPoolCacheEntry::f1_offset())));</span>
<span class="udiff-line-added">+           __ get_value_field_klass(rcx, rdx, rbx);</span>
<span class="udiff-line-added">+           __ get_default_value_oop(rbx, rcx, rax);</span>
<span class="udiff-line-added">+         __ bind(nonnull);</span>
<span class="udiff-line-added">+         __ verify_oop(rax);</span>
<span class="udiff-line-added">+         __ jmp(Done);</span>
<span class="udiff-line-added">+       __ bind(isFlattened);</span>
<span class="udiff-line-added">+         __ push(rdx); // save offset</span>
<span class="udiff-line-added">+         __ movl(rdx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="udiff-line-added">+                            in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="udiff-line-added">+                                     ConstantPoolCacheEntry::flags_offset())));</span>
<span class="udiff-line-added">+         __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="udiff-line-added">+         __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="udiff-line-added">+                                      in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="udiff-line-added">+                                               ConstantPoolCacheEntry::f1_offset())));</span>
<span class="udiff-line-added">+         __ pop(rbx); // restore offset</span>
<span class="udiff-line-added">+         __ read_flattened_field(rcx, rdx, rbx, rax);</span>
<span class="udiff-line-added">+       __ bind(Done);</span>
<span class="udiff-line-added">+       __ verify_oop(rax);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     break;</span>
    case Bytecodes::_fast_agetfield:
      do_oop_load(_masm, field, rax);
      __ verify_oop(rax);
      break;
    case Bytecodes::_fast_lgetfield:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3998,157 +4340,102 @@</span>
  
  void TemplateTable::_new() {
    transition(vtos, atos);
    __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
    Label slow_case;
<span class="udiff-line-modified-removed">-   Label slow_case_no_pop;</span>
<span class="udiff-line-removed">-   Label done;</span>
<span class="udiff-line-removed">-   Label initialize_header;</span>
<span class="udiff-line-modified-added">+   Label done;</span>
    Label is_not_value;
  
    __ get_cpool_and_tags(rcx, rax);
  
    // Make sure the class we&#39;re about to instantiate has been resolved.
    // This is done before loading InstanceKlass to be consistent with the order
    // how Constant Pool is updated (see ConstantPool::klass_at_put)
    const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
    __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);
<span class="udiff-line-modified-removed">-   __ jcc(Assembler::notEqual, slow_case_no_pop);</span>
<span class="udiff-line-modified-added">+   __ jcc(Assembler::notEqual, slow_case);</span>
  
    // get InstanceKlass
    __ load_resolved_klass_at_index(rcx, rcx, rdx);
<span class="udiff-line-modified-removed">-   __ push(rcx);  // save the contexts of klass for initializing the header</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InstanceKlass::_kind_inline_type);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::notEqual, is_not_value);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ bind(is_not_value);</span>
  
    // make sure klass is initialized &amp; doesn&#39;t have finalizer
<span class="udiff-line-removed">-   // make sure klass is fully initialized</span>
    __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
    __ jcc(Assembler::notEqual, slow_case);
  
<span class="udiff-line-modified-removed">-   // get instance_size in InstanceKlass (scaled to a count of bytes)</span>
<span class="udiff-line-modified-removed">-   __ movl(rdx, Address(rcx, Klass::layout_helper_offset()));</span>
<span class="udiff-line-removed">-   // test to see if it has a finalizer or is malformed in some way</span>
<span class="udiff-line-removed">-   __ testl(rdx, Klass::_lh_instance_slow_path_bit);</span>
<span class="udiff-line-removed">-   __ jcc(Assembler::notZero, slow_case);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Allocate the instance:</span>
<span class="udiff-line-removed">-   //  If TLAB is enabled:</span>
<span class="udiff-line-removed">-   //    Try to allocate in the TLAB.</span>
<span class="udiff-line-removed">-   //    If fails, go to the slow path.</span>
<span class="udiff-line-removed">-   //  Else If inline contiguous allocations are enabled:</span>
<span class="udiff-line-removed">-   //    Try to allocate in eden.</span>
<span class="udiff-line-removed">-   //    If fails due to heap end, go to slow path.</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   //  If TLAB is enabled OR inline contiguous is enabled:</span>
<span class="udiff-line-removed">-   //    Initialize the allocation.</span>
<span class="udiff-line-removed">-   //    Exit.</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   //  Go to slow path.</span>
<span class="udiff-line-modified-added">+   __ allocate_instance(rcx, rax, rdx, rbx, true, slow_case);</span>
<span class="udiff-line-modified-added">+   __ jmp(done);</span>
  
<span class="udiff-line-modified-removed">-   const bool allow_shared_alloc =</span>
<span class="udiff-line-modified-removed">-     Universe::heap()-&gt;supports_inline_contig_alloc();</span>
<span class="udiff-line-modified-added">+   // slow case</span>
<span class="udiff-line-modified-added">+   __ bind(slow_case);</span>
  
<span class="udiff-line-modified-removed">-   const Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);</span>
<span class="udiff-line-modified-removed">- #ifndef _LP64</span>
<span class="udiff-line-removed">-   if (UseTLAB || allow_shared_alloc) {</span>
<span class="udiff-line-removed">-     __ get_thread(thread);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif // _LP64</span>
<span class="udiff-line-modified-added">+   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);</span>
<span class="udiff-line-modified-added">+   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);</span>
  
<span class="udiff-line-modified-removed">-   if (UseTLAB) {</span>
<span class="udiff-line-modified-removed">-     __ tlab_allocate(thread, rax, rdx, 0, rcx, rbx, slow_case);</span>
<span class="udiff-line-modified-removed">-     if (ZeroTLAB) {</span>
<span class="udiff-line-modified-removed">-       // the fields have been already cleared</span>
<span class="udiff-line-removed">-       __ jmp(initialize_header);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       // initialize both the header and fields</span>
<span class="udiff-line-removed">-       __ jmp(initialize_object);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // Allocation in the shared Eden, if allowed.</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     // rdx: instance size in bytes</span>
<span class="udiff-line-removed">-     __ eden_allocate(thread, rax, rdx, 0, rbx, slow_case);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   __ get_constant_pool(rarg1);</span>
<span class="udiff-line-modified-added">+   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);</span>
<span class="udiff-line-modified-added">+   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);</span>
<span class="udiff-line-modified-added">+    __ verify_oop(rax);</span>
  
<span class="udiff-line-modified-removed">-   // If UseTLAB or allow_shared_alloc are true, the object is created above and</span>
<span class="udiff-line-modified-removed">-   // there is an initialize need. Otherwise, skip and go to the slow path.</span>
<span class="udiff-line-modified-removed">-   if (UseTLAB || allow_shared_alloc) {</span>
<span class="udiff-line-removed">-     // The object is initialized before the header.  If the object size is</span>
<span class="udiff-line-removed">-     // zero, go directly to the header initialization.</span>
<span class="udiff-line-removed">-     __ bind(initialize_object);</span>
<span class="udiff-line-removed">-     __ decrement(rdx, sizeof(oopDesc));</span>
<span class="udiff-line-removed">-     __ jcc(Assembler::zero, initialize_header);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Initialize topmost object field, divide rdx by 8, check if odd and</span>
<span class="udiff-line-removed">-     // test if zero.</span>
<span class="udiff-line-removed">-     __ xorl(rcx, rcx);    // use zero reg to clear memory (shorter code)</span>
<span class="udiff-line-removed">-     __ shrl(rdx, LogBytesPerLong); // divide by 2*oopSize and set carry flag if odd</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // rdx must have been multiple of 8</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-     // make sure rdx was multiple of 8</span>
<span class="udiff-line-removed">-     Label L;</span>
<span class="udiff-line-removed">-     // Ignore partial flag stall after shrl() since it is debug VM</span>
<span class="udiff-line-removed">-     __ jcc(Assembler::carryClear, L);</span>
<span class="udiff-line-removed">-     __ stop(&quot;object size is not multiple of 2 - adjust this code&quot;);</span>
<span class="udiff-line-removed">-     __ bind(L);</span>
<span class="udiff-line-removed">-     // rdx must be &gt; 0, no extra check needed here</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   // continue</span>
<span class="udiff-line-modified-added">+   __ bind(done);</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     // initialize remaining object fields: rdx was a multiple of 8</span>
<span class="udiff-line-modified-removed">-     { Label loop;</span>
<span class="udiff-line-removed">-     __ bind(loop);</span>
<span class="udiff-line-removed">-     __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);</span>
<span class="udiff-line-removed">-     NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));</span>
<span class="udiff-line-removed">-     __ decrement(rdx);</span>
<span class="udiff-line-removed">-     __ jcc(Assembler::notZero, loop);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+ void TemplateTable::defaultvalue() {</span>
<span class="udiff-line-modified-added">+   transition(vtos, atos);</span>
  
<span class="udiff-line-modified-removed">-     // initialize object header only.</span>
<span class="udiff-line-modified-removed">-     __ bind(initialize_header);</span>
<span class="udiff-line-modified-removed">-     if (UseBiasedLocking) {</span>
<span class="udiff-line-removed">-       __ pop(rcx);   // get saved klass back in the register.</span>
<span class="udiff-line-removed">-       __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));</span>
<span class="udiff-line-removed">-       __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()),</span>
<span class="udiff-line-removed">-                 (intptr_t)markWord::prototype().value()); // header</span>
<span class="udiff-line-removed">-       __ pop(rcx);   // get saved klass back in the register.</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #ifdef _LP64</span>
<span class="udiff-line-removed">-     __ xorl(rsi, rsi); // use zero reg to clear memory (shorter code)</span>
<span class="udiff-line-removed">-     __ store_klass_gap(rax, rsi);  // zero klass gap for compressed oops</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="udiff-line-removed">-     __ store_klass(rax, rcx, tmp_store_klass);  // klass</span>
<span class="udiff-line-modified-added">+   Label slow_case;</span>
<span class="udiff-line-modified-added">+   Label done;</span>
<span class="udiff-line-modified-added">+   Label is_value;</span>
  
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       SkipIfEqual skip_if(_masm, &amp;DTraceAllocProbes, 0);</span>
<span class="udiff-line-removed">-       // Trigger dtrace event for fastpath</span>
<span class="udiff-line-removed">-       __ push(atos);</span>
<span class="udiff-line-removed">-       __ call_VM_leaf(</span>
<span class="udiff-line-removed">-            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), rax);</span>
<span class="udiff-line-removed">-       __ pop(atos);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);</span>
<span class="udiff-line-modified-added">+   __ get_cpool_and_tags(rcx, rax);</span>
  
<span class="udiff-line-modified-removed">-     __ jmp(done);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+   // Make sure the class we&#39;re about to instantiate has been resolved.</span>
<span class="udiff-line-modified-added">+   // This is done before loading InstanceKlass to be consistent with the order</span>
<span class="udiff-line-added">+   // how Constant Pool is updated (see ConstantPool::klass_at_put)</span>
<span class="udiff-line-added">+   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();</span>
<span class="udiff-line-added">+   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::notEqual, slow_case);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // get InstanceKlass</span>
<span class="udiff-line-added">+   __ load_resolved_klass_at_index(rcx, rcx, rdx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InstanceKlass::_kind_inline_type);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::equal, is_value);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // in the future, defaultvalue will just return null instead of throwing an exception</span>
<span class="udiff-line-added">+   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeError));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ bind(is_value);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // make sure klass is fully initialized</span>
<span class="udiff-line-added">+   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::notEqual, slow_case);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // have a resolved ValueKlass in rcx, return the default value oop from it</span>
<span class="udiff-line-added">+   __ get_default_value_oop(rcx, rdx, rax);</span>
<span class="udiff-line-added">+   __ jmp(done);</span>
  
<span class="udiff-line-modified-removed">-   // slow case</span>
<span class="udiff-line-removed">-   __ bind(slow_case);</span>
<span class="udiff-line-removed">-   __ pop(rcx);   // restore stack pointer to what it was when we came in.</span>
<span class="udiff-line-removed">-   __ bind(slow_case_no_pop);</span>
<span class="udiff-line-modified-added">+   __ bind(slow_case);</span>
  
    Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
    Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
  
<span class="udiff-line-modified-removed">-   __ get_constant_pool(rarg1);</span>
<span class="udiff-line-modified-removed">-   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);</span>
<span class="udiff-line-modified-removed">-   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);</span>
<span class="udiff-line-modified-added">+   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);</span>
<span class="udiff-line-modified-added">+   __ get_constant_pool(rarg1);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::defaultvalue),</span>
        rarg1, rarg2);
  
<span class="udiff-line-modified-removed">-   // continue</span>
<span class="udiff-line-modified-added">+   __ bind(done);</span>
    __ verify_oop(rax);
  }
  
  void TemplateTable::newarray() {
    transition(itos, atos);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4184,14 +4471,15 @@</span>
  
    // Get cpool &amp; tags index
    __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
    __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
    // See if bytecode has already been quicked
<span class="udiff-line-modified-removed">-   __ cmpb(Address(rdx, rbx,</span>
<span class="udiff-line-modified-removed">-                   Address::times_1,</span>
<span class="udiff-line-modified-removed">-                   Array&lt;u1&gt;::base_offset_in_bytes()),</span>
<span class="udiff-line-modified-removed">-           JVM_CONSTANT_Class);</span>
<span class="udiff-line-modified-added">+   __ movzbl(rdx, Address(rdx, rbx,</span>
<span class="udiff-line-modified-added">+       Address::times_1,</span>
<span class="udiff-line-modified-added">+       Array&lt;u1&gt;::base_offset_in_bytes()));</span>
<span class="udiff-line-modified-added">+   __ andl (rdx, ~JVM_CONSTANT_QDescBit);</span>
<span class="udiff-line-added">+   __ cmpl(rdx, JVM_CONSTANT_Class);</span>
    __ jcc(Assembler::equal, quicked);
    __ push(atos); // save receiver for result, and for GC
    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
  
    // vm_result_2 has metadata result
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4226,17 +4514,31 @@</span>
    __ jump(ExternalAddress(Interpreter::_throw_ClassCastException_entry));
  
    // Come here on success
    __ bind(ok_is_subtype);
    __ mov(rax, rdx); // Restore object in rdx
<span class="udiff-line-added">+   __ jmp(done);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ bind(is_null);</span>
  
    // Collect counts on whether this check-cast sees NULLs a lot or not.
    if (ProfileInterpreter) {
<span class="udiff-line-modified-removed">-     __ jmp(done);</span>
<span class="udiff-line-modified-removed">-     __ bind(is_null);</span>
<span class="udiff-line-modified-removed">-     __ profile_null_seen(rcx);</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-added">+     __ profile_null_seen(rcx);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (EnableValhalla) {</span>
<span class="udiff-line-added">+     // Get cpool &amp; tags index</span>
<span class="udiff-line-added">+     __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array</span>
<span class="udiff-line-added">+     __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index</span>
<span class="udiff-line-added">+     // See if CP entry is a Q-descriptor</span>
<span class="udiff-line-added">+     __ movzbl(rcx, Address(rdx, rbx,</span>
<span class="udiff-line-added">+         Address::times_1,</span>
<span class="udiff-line-added">+         Array&lt;u1&gt;::base_offset_in_bytes()));</span>
<span class="udiff-line-added">+     __ andl (rcx, JVM_CONSTANT_QDescBit);</span>
<span class="udiff-line-added">+     __ cmpl(rcx, JVM_CONSTANT_QDescBit);</span>
<span class="udiff-line-added">+     __ jcc(Assembler::notEqual, done);</span>
<span class="udiff-line-added">+     __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));</span>
    }
  
    __ bind(done);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4248,14 +4550,15 @@</span>
  
    // Get cpool &amp; tags index
    __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
    __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
    // See if bytecode has already been quicked
<span class="udiff-line-modified-removed">-   __ cmpb(Address(rdx, rbx,</span>
<span class="udiff-line-modified-removed">-                   Address::times_1,</span>
<span class="udiff-line-modified-removed">-                   Array&lt;u1&gt;::base_offset_in_bytes()),</span>
<span class="udiff-line-modified-removed">-           JVM_CONSTANT_Class);</span>
<span class="udiff-line-modified-added">+   __ movzbl(rdx, Address(rdx, rbx,</span>
<span class="udiff-line-modified-added">+         Address::times_1,</span>
<span class="udiff-line-modified-added">+         Array&lt;u1&gt;::base_offset_in_bytes()));</span>
<span class="udiff-line-modified-added">+   __ andl (rdx, ~JVM_CONSTANT_QDescBit);</span>
<span class="udiff-line-added">+   __ cmpl(rdx, JVM_CONSTANT_Class);</span>
    __ jcc(Assembler::equal, quicked);
  
    __ push(atos); // save receiver for result, and for GC
    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
    // vm_result_2 has metadata result
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4304,11 +4607,10 @@</span>
    __ bind(done);
    // rax = 0: obj == NULL or  obj is not an instanceof the specified klass
    // rax = 1: obj != NULL and obj is     an instanceof the specified klass
  }
  
<span class="udiff-line-removed">- </span>
  //----------------------------------------------------------------------------------------------------
  // Breakpoints
  void TemplateTable::_breakpoint() {
    // Note: We get here even if we are single stepping..
    // jbug insists on setting breakpoints at every bytecode
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4368,10 +4670,21 @@</span>
    // check for NULL object
    __ null_check(rax);
  
    __ resolve(IS_NOT_NULL, rax);
  
<span class="udiff-line-added">+   const int is_value_mask = markWord::always_locked_pattern;</span>
<span class="udiff-line-added">+   Label has_identity;</span>
<span class="udiff-line-added">+   __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="udiff-line-added">+   __ andptr(rbx, is_value_mask);</span>
<span class="udiff-line-added">+   __ cmpl(rbx, is_value_mask);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::notEqual, has_identity);</span>
<span class="udiff-line-added">+   __ call_VM(noreg, CAST_FROM_FN_PTR(address,</span>
<span class="udiff-line-added">+                      InterpreterRuntime::throw_illegal_monitor_state_exception));</span>
<span class="udiff-line-added">+   __ should_not_reach_here();</span>
<span class="udiff-line-added">+   __ bind(has_identity);</span>
<span class="udiff-line-added">+ </span>
    const Address monitor_block_top(
          rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
    const Address monitor_block_bot(
          rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
    const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4467,10 +4780,21 @@</span>
    // check for NULL object
    __ null_check(rax);
  
    __ resolve(IS_NOT_NULL, rax);
  
<span class="udiff-line-added">+   const int is_value_mask = markWord::always_locked_pattern;</span>
<span class="udiff-line-added">+   Label has_identity;</span>
<span class="udiff-line-added">+   __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="udiff-line-added">+   __ andptr(rbx, is_value_mask);</span>
<span class="udiff-line-added">+   __ cmpl(rbx, is_value_mask);</span>
<span class="udiff-line-added">+   __ jcc(Assembler::notEqual, has_identity);</span>
<span class="udiff-line-added">+   __ call_VM(noreg, CAST_FROM_FN_PTR(address,</span>
<span class="udiff-line-added">+                      InterpreterRuntime::throw_illegal_monitor_state_exception));</span>
<span class="udiff-line-added">+   __ should_not_reach_here();</span>
<span class="udiff-line-added">+   __ bind(has_identity);</span>
<span class="udiff-line-added">+ </span>
    const Address monitor_block_top(
          rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
    const Address monitor_block_bot(
          rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
    const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
</pre>
<center><a href="stubGenerator_x86_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs_x86_64.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
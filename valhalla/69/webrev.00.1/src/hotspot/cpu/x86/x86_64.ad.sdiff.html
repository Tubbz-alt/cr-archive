<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vtableStubs_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_Runtime1.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 
<span class="line-removed">  870   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-removed">  871   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-removed">  872 </span>
  873   if (C-&gt;clinit_barrier_on_entry()) {
  874     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  875     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  876 
  877     Label L_skip_barrier;
  878     Register klass = rscratch1;
  879 
  880     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  881     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  882 
  883     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  884 
  885     __ bind(L_skip_barrier);
  886   }
  887 
<span class="line-modified">  888   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);</span>






  889 
  890   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  891 
  892   if (C-&gt;has_mach_constant_base_node()) {
  893     // NOTE: We set the table base offset here because users might be
  894     // emitted before MachConstantBaseNode.
  895     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  896     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  897   }
  898 }
  899 
<span class="line-removed">  900 uint MachPrologNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed">  901 {</span>
<span class="line-removed">  902   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed">  903                               // the hard way</span>
<span class="line-removed">  904 }</span>
<span class="line-removed">  905 </span>
  906 int MachPrologNode::reloc() const
  907 {
  908   return 0; // a large enough number
  909 }
  910 
  911 //=============================================================================
  912 #ifndef PRODUCT
  913 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  914 {
  915   Compile* C = ra_-&gt;C;
  916   if (generate_vzeroupper(C)) {
  917     st-&gt;print(&quot;vzeroupper&quot;);
  918     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  919   }
  920 
  921   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  922   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  923   // Remove word for return adr already pushed
  924   // and RBP
  925   framesize -= 2*wordSize;
</pre>
<hr />
<pre>
  933   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  934     st-&gt;print(&quot;\t&quot;);
  935     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  936                  &quot;testl   rax, [rscratch1]\t&quot;
  937                  &quot;# Safepoint: poll for GC&quot;);
  938   }
  939 }
  940 #endif
  941 
  942 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  943 {
  944   Compile* C = ra_-&gt;C;
  945   MacroAssembler _masm(&amp;cbuf);
  946 
  947   if (generate_vzeroupper(C)) {
  948     // Clear upper bits of YMM registers when current compiled code uses
  949     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  950     __ vzeroupper();
  951   }
  952 
<span class="line-modified">  953   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  954   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);</span>
<span class="line-modified">  955   // Remove word for return adr already pushed</span>
<span class="line-removed">  956   // and RBP</span>
<span class="line-removed">  957   framesize -= 2*wordSize;</span>
<span class="line-removed">  958 </span>
<span class="line-removed">  959   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here</span>
<span class="line-removed">  960 </span>
<span class="line-removed">  961   if (framesize) {</span>
<span class="line-removed">  962     emit_opcode(cbuf, Assembler::REX_W);</span>
<span class="line-removed">  963     if (framesize &lt; 0x80) {</span>
<span class="line-removed">  964       emit_opcode(cbuf, 0x83); // addq rsp, #framesize</span>
<span class="line-removed">  965       emit_rm(cbuf, 0x3, 0x00, RSP_enc);</span>
<span class="line-removed">  966       emit_d8(cbuf, framesize);</span>
<span class="line-removed">  967     } else {</span>
<span class="line-removed">  968       emit_opcode(cbuf, 0x81); // addq rsp, #framesize</span>
<span class="line-removed">  969       emit_rm(cbuf, 0x3, 0x00, RSP_enc);</span>
<span class="line-removed">  970       emit_d32(cbuf, framesize);</span>
<span class="line-removed">  971     }</span>
<span class="line-removed">  972   }</span>
<span class="line-removed">  973 </span>
<span class="line-removed">  974   // popq rbp</span>
<span class="line-removed">  975   emit_opcode(cbuf, 0x58 | RBP_enc);</span>
  976 
  977   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  978     __ reserved_stack_check();
  979   }
  980 
  981   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  982     MacroAssembler _masm(&amp;cbuf);
  983     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  984     __ relocate(relocInfo::poll_return_type);
  985     __ testl(rax, Address(rscratch1, 0));
  986   }
  987 }
  988 
<span class="line-removed">  989 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed">  990 {</span>
<span class="line-removed">  991   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed">  992                               // the hard way</span>
<span class="line-removed">  993 }</span>
<span class="line-removed">  994 </span>
  995 int MachEpilogNode::reloc() const
  996 {
  997   return 2; // a large enough number
  998 }
  999 
 1000 const Pipeline* MachEpilogNode::pipeline() const
 1001 {
 1002   return MachNode::pipeline_class();
 1003 }
 1004 
 1005 //=============================================================================
 1006 
 1007 enum RC {
 1008   rc_bad,
 1009   rc_int,
 1010   rc_float,
 1011   rc_stack
 1012 };
 1013 
 1014 static enum RC rc_class(OptoReg::Name reg)
</pre>
<hr />
<pre>
 1510     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1511     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1512     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1513     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1514     emit_d32(cbuf, offset);
 1515   } else {
 1516     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1517     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1518     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1519     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1520     emit_d8(cbuf, offset);
 1521   }
 1522 }
 1523 
 1524 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1525 {
 1526   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1527   return (offset &lt; 0x80) ? 5 : 8; // REX
 1528 }
 1529 




























 1530 //=============================================================================
 1531 #ifndef PRODUCT
 1532 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1533 {
 1534   if (UseCompressedClassPointers) {
 1535     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1536     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1537     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1538   } else {
 1539     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1540                  &quot;# Inline cache check&quot;);
 1541   }
 1542   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1543   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1544 }
 1545 #endif
 1546 
 1547 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1548 {
 1549   MacroAssembler masm(&amp;cbuf);
</pre>
<hr />
<pre>
 1552     masm.load_klass(rscratch1, j_rarg0, rscratch2);
 1553     masm.cmpptr(rax, rscratch1);
 1554   } else {
 1555     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1556   }
 1557 
 1558   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1559 
 1560   /* WARNING these NOPs are critical so that verified entry point is properly
 1561      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1562   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1563   if (OptoBreakpoint) {
 1564     // Leave space for int3
 1565     nops_cnt -= 1;
 1566   }
 1567   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1568   if (nops_cnt &gt; 0)
 1569     masm.nop(nops_cnt);
 1570 }
 1571 
<span class="line-removed"> 1572 uint MachUEPNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed"> 1573 {</span>
<span class="line-removed"> 1574   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed"> 1575                               // the hard way</span>
<span class="line-removed"> 1576 }</span>
<span class="line-removed"> 1577 </span>
<span class="line-removed"> 1578 </span>
 1579 //=============================================================================
 1580 
 1581 int Matcher::regnum_to_fpu_offset(int regnum)
 1582 {
 1583   return regnum - 32; // The FP registers are in the second chunk
 1584 }
 1585 
 1586 // This is UltraSparc specific, true just means we have fast l2f conversion
 1587 const bool Matcher::convL2FSupported(void) {
 1588   return true;
 1589 }
 1590 
 1591 // Is this branch offset short enough that a short branch can be used?
 1592 //
 1593 // NOTE: If the platform does not provide any short branch variants, then
 1594 //       this method should return false for offset 0.
 1595 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1596   // The passed offset is relative to address of the branch.
 1597   // On 86 a branch displacement is calculated relative to address
 1598   // of a next instruction.
</pre>
<hr />
<pre>
 3844   %}
 3845 %}
 3846 
 3847 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3848 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3849 %{
 3850   constraint(ALLOC_IN_RC(ptr_reg));
 3851   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3852   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3853 
 3854   op_cost(10);
 3855   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3856   interface(MEMORY_INTER) %{
 3857     base($reg);
 3858     index($idx);
 3859     scale($scale);
 3860     disp($off);
 3861   %}
 3862 %}
 3863 
















 3864 // Indirect Narrow Oop Plus Offset Operand
 3865 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3866 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3867 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3868   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3869   constraint(ALLOC_IN_RC(ptr_reg));
 3870   match(AddP (DecodeN reg) off);
 3871 
 3872   op_cost(10);
 3873   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3874   interface(MEMORY_INTER) %{
 3875     base(0xc); // R12
 3876     index($reg);
 3877     scale(0x3);
 3878     disp($off);
 3879   %}
 3880 %}
 3881 
 3882 // Indirect Memory Operand
 3883 operand indirectNarrow(rRegN reg)
</pre>
<hr />
<pre>
 4186     equal(0x4, &quot;e&quot;);
 4187     not_equal(0x5, &quot;ne&quot;);
 4188     less(0x2, &quot;b&quot;);
 4189     greater_equal(0x3, &quot;nb&quot;);
 4190     less_equal(0x6, &quot;be&quot;);
 4191     greater(0x7, &quot;nbe&quot;);
 4192     overflow(0x0, &quot;o&quot;);
 4193     no_overflow(0x1, &quot;no&quot;);
 4194   %}
 4195 %}
 4196 
 4197 //----------OPERAND CLASSES----------------------------------------------------
 4198 // Operand Classes are groups of operands that are used as to simplify
 4199 // instruction definitions by not requiring the AD writer to specify separate
 4200 // instructions for every form of operand when the instruction accepts
 4201 // multiple operand types with the same basic encoding and format.  The classic
 4202 // case of this is memory operands.
 4203 
 4204 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4205                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
<span class="line-modified"> 4206                indCompressedOopOffset,</span>
 4207                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4208                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4209                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4210 
 4211 //----------PIPELINE-----------------------------------------------------------
 4212 // Rules which define the behavior of the target architectures pipeline.
 4213 pipeline %{
 4214 
 4215 //----------ATTRIBUTES---------------------------------------------------------
 4216 attributes %{
 4217   variable_size_instructions;        // Fixed size instructions
 4218   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4219   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4220   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4221   instruction_fetch_units = 1;       // of 16 bytes
 4222 
 4223   // List of nop instructions
 4224   nops( MachNop );
 4225 %}
 4226 
</pre>
<hr />
<pre>
 6670   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6671   ins_encode( );
 6672   ins_pipe(empty);
 6673 %}
 6674 
 6675 //----------Move Instructions--------------------------------------------------
 6676 
 6677 instruct castX2P(rRegP dst, rRegL src)
 6678 %{
 6679   match(Set dst (CastX2P src));
 6680 
 6681   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6682   ins_encode %{
 6683     if ($dst$$reg != $src$$reg) {
 6684       __ movptr($dst$$Register, $src$$Register);
 6685     }
 6686   %}
 6687   ins_pipe(ialu_reg_reg); // XXX
 6688 %}
 6689 













 6690 instruct castP2X(rRegL dst, rRegP src)
 6691 %{
 6692   match(Set dst (CastP2X src));
 6693 
 6694   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6695   ins_encode %{
 6696     if ($dst$$reg != $src$$reg) {
 6697       __ movptr($dst$$Register, $src$$Register);
 6698     }
 6699   %}
 6700   ins_pipe(ialu_reg_reg); // XXX
 6701 %}
 6702 



























 6703 // Convert oop into int for vectors alignment masking
 6704 instruct convP2I(rRegI dst, rRegP src)
 6705 %{
 6706   match(Set dst (ConvL2I (CastP2X src)));
 6707 
 6708   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6709   ins_encode %{
 6710     __ movl($dst$$Register, $src$$Register);
 6711   %}
 6712   ins_pipe(ialu_reg_reg); // XXX
 6713 %}
 6714 
 6715 // Convert compressed oop into int for vectors alignment masking
 6716 // in case of 32bit oops (heap &lt; 4Gb).
 6717 instruct convN2I(rRegI dst, rRegN src)
 6718 %{
 6719   predicate(CompressedOops::shift() == 0);
 6720   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6721 
 6722   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
</pre>
<hr />
<pre>
10896   ins_encode %{
10897     __ movdl($dst$$XMMRegister, $src$$Register);
10898   %}
10899   ins_pipe( pipe_slow );
10900 %}
10901 
10902 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10903   match(Set dst (MoveL2D src));
10904   effect(DEF dst, USE src);
10905   ins_cost(100);
10906   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10907   ins_encode %{
10908      __ movdq($dst$$XMMRegister, $src$$Register);
10909   %}
10910   ins_pipe( pipe_slow );
10911 %}
10912 
10913 
10914 // =======================================================================
10915 // fast clearing of an array
<span class="line-modified">10916 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,</span>
10917                   Universe dummy, rFlagsReg cr)
10918 %{
<span class="line-modified">10919   predicate(!((ClearArrayNode*)n)-&gt;is_large());</span>
<span class="line-modified">10920   match(Set dummy (ClearArray cnt base));</span>
<span class="line-modified">10921   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);</span>
10922 
10923   format %{ $$template
<span class="line-removed">10924     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
10925     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10926     $$emit$$&quot;jg      LARGE\n\t&quot;
10927     $$emit$$&quot;dec     rcx\n\t&quot;
10928     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10929     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10930     $$emit$$&quot;dec     rcx\n\t&quot;
10931     $$emit$$&quot;jge     LOOP\n\t&quot;
10932     $$emit$$&quot;jmp     DONE\n\t&quot;
10933     $$emit$$&quot;# LARGE:\n\t&quot;
10934     if (UseFastStosb) {
10935        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10936        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10937     } else if (UseXMMForObjInit) {
<span class="line-modified">10938        $$emit$$&quot;mov     rdi,rax\n\t&quot;</span>
<span class="line-modified">10939        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;</span>

10940        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10941        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">10942        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
<span class="line-modified">10943        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;</span>
10944        $$emit$$&quot;add     0x40,rax\n\t&quot;
10945        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10946        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10947        $$emit$$&quot;jge     L_loop\n\t&quot;
10948        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10949        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">10950        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
10951        $$emit$$&quot;add     0x20,rax\n\t&quot;
10952        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
10953        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
10954        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10955        $$emit$$&quot;jle     L_end\n\t&quot;
10956        $$emit$$&quot;dec     rcx\n\t&quot;
10957        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
10958        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
10959        $$emit$$&quot;add     0x8,rax\n\t&quot;
10960        $$emit$$&quot;dec     rcx\n\t&quot;
10961        $$emit$$&quot;jge     L_sloop\n\t&quot;
10962        $$emit$$&quot;# L_end:\n\t&quot;
10963     } else {
10964        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
10965     }
10966     $$emit$$&quot;# DONE&quot;
10967   %}
10968   ins_encode %{
<span class="line-modified">10969     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,</span>
<span class="line-modified">10970                  $tmp$$XMMRegister, false);</span>
10971   %}
10972   ins_pipe(pipe_slow);
10973 %}
10974 
<span class="line-modified">10975 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,</span>
























































10976                         Universe dummy, rFlagsReg cr)
10977 %{
<span class="line-modified">10978   predicate(((ClearArrayNode*)n)-&gt;is_large());</span>
<span class="line-modified">10979   match(Set dummy (ClearArray cnt base));</span>
<span class="line-modified">10980   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);</span>
10981 
10982   format %{ $$template
10983     if (UseFastStosb) {
<span class="line-removed">10984        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
10985        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10986        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
10987     } else if (UseXMMForObjInit) {
<span class="line-modified">10988        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;</span>
<span class="line-modified">10989        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;</span>

10990        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10991        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">10992        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
<span class="line-modified">10993        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;</span>
10994        $$emit$$&quot;add     0x40,rax\n\t&quot;
10995        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10996        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10997        $$emit$$&quot;jge     L_loop\n\t&quot;
10998        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10999        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">11000        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
11001        $$emit$$&quot;add     0x20,rax\n\t&quot;
11002        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11003        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11004        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11005        $$emit$$&quot;jle     L_end\n\t&quot;
11006        $$emit$$&quot;dec     rcx\n\t&quot;
11007        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11008        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11009        $$emit$$&quot;add     0x8,rax\n\t&quot;
11010        $$emit$$&quot;dec     rcx\n\t&quot;
11011        $$emit$$&quot;jge     L_sloop\n\t&quot;
11012        $$emit$$&quot;# L_end:\n\t&quot;
11013     } else {
<span class="line-removed">11014        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
11015        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11016     }
11017   %}
11018   ins_encode %{
<span class="line-modified">11019     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,</span>
<span class="line-modified">11020                  $tmp$$XMMRegister, true);</span>














































11021   %}
11022   ins_pipe(pipe_slow);
11023 %}
11024 
11025 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11026                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11027 %{
11028   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11029   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11030   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11031 
11032   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11033   ins_encode %{
11034     __ string_compare($str1$$Register, $str2$$Register,
11035                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11036                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11037   %}
11038   ins_pipe( pipe_slow );
11039 %}
11040 
</pre>
<hr />
<pre>
11565 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11566 %{
11567   match(Set cr (CmpI (AndI src con) zero));
11568 
11569   format %{ &quot;testl   $src, $con&quot; %}
11570   opcode(0xF7, 0x00);
11571   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11572   ins_pipe(ialu_cr_reg_imm);
11573 %}
11574 
11575 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11576 %{
11577   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11578 
11579   format %{ &quot;testl   $src, $mem&quot; %}
11580   opcode(0x85);
11581   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11582   ins_pipe(ialu_cr_reg_mem);
11583 %}
11584 











11585 // Unsigned compare Instructions; really, same as signed except they
11586 // produce an rFlagsRegU instead of rFlagsReg.
11587 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11588 %{
11589   match(Set cr (CmpU op1 op2));
11590 
11591   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11592   opcode(0x3B); /* Opcode 3B /r */
11593   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11594   ins_pipe(ialu_cr_reg_reg);
11595 %}
11596 
11597 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11598 %{
11599   match(Set cr (CmpU op1 op2));
11600 
11601   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11602   opcode(0x81,0x07); /* Opcode 81 /7 */
11603   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11604   ins_pipe(ialu_cr_reg_imm);
</pre>
<hr />
<pre>
11877 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11878 %{
11879   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11880 
11881   format %{ &quot;testq   $src, $mem&quot; %}
11882   opcode(0x85);
11883   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11884   ins_pipe(ialu_cr_reg_mem);
11885 %}
11886 
11887 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
11888 %{
11889   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
11890 
11891   format %{ &quot;testq   $src, $mem&quot; %}
11892   opcode(0x85);
11893   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11894   ins_pipe(ialu_cr_reg_mem);
11895 %}
11896 











11897 // Manifest a CmpL result in an integer register.  Very painful.
11898 // This is the test to avoid.
11899 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11900 %{
11901   match(Set dst (CmpL3 src1 src2));
11902   effect(KILL flags);
11903 
11904   ins_cost(275); // XXX
11905   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
11906             &quot;movl    $dst, -1\n\t&quot;
11907             &quot;jl,s    done\n\t&quot;
11908             &quot;setne   $dst\n\t&quot;
11909             &quot;movzbl  $dst, $dst\n\t&quot;
11910     &quot;done:&quot; %}
11911   ins_encode(cmpl3_flag(src1, src2, dst));
11912   ins_pipe(pipe_slow);
11913 %}
11914 
11915 // Unsigned long compare Instructions; really, same as signed long except they
11916 // produce an rFlagsRegU instead of rFlagsReg.
</pre>
<hr />
<pre>
12544 
12545   ins_cost(300);
12546   format %{ &quot;call,runtime &quot; %}
12547   ins_encode(clear_avx, Java_To_Runtime(meth));
12548   ins_pipe(pipe_slow);
12549 %}
12550 
12551 // Call runtime without safepoint
12552 instruct CallLeafDirect(method meth)
12553 %{
12554   match(CallLeaf);
12555   effect(USE meth);
12556 
12557   ins_cost(300);
12558   format %{ &quot;call_leaf,runtime &quot; %}
12559   ins_encode(clear_avx, Java_To_Runtime(meth));
12560   ins_pipe(pipe_slow);
12561 %}
12562 
12563 // Call runtime without safepoint















12564 instruct CallLeafNoFPDirect(method meth)
12565 %{

12566   match(CallLeafNoFP);
12567   effect(USE meth);
12568 
12569   ins_cost(300);
12570   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12571   ins_encode(clear_avx, Java_To_Runtime(meth));
12572   ins_pipe(pipe_slow);
12573 %}
12574 
12575 // Return Instruction
12576 // Remove the return address &amp; jump to it.
12577 // Notice: We always emit a nop after a ret to make sure there is room
12578 // for safepoint patching
12579 instruct Ret()
12580 %{
12581   match(Return);
12582 
12583   format %{ &quot;ret&quot; %}
12584   opcode(0xC3);
12585   ins_encode(OpcP);
</pre>
</td>
<td>
<hr />
<pre>
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 



  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  872     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  873 
  874     Label L_skip_barrier;
  875     Register klass = rscratch1;
  876 
  877     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  879 
  880     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  881 
  882     __ bind(L_skip_barrier);
  883   }
  884 
<span class="line-modified">  885   __ verified_entry(C);</span>
<span class="line-added">  886   __ bind(*_verified_entry);</span>
<span class="line-added">  887 </span>
<span class="line-added">  888   if (C-&gt;stub_function() == NULL) {</span>
<span class="line-added">  889     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added">  890     bs-&gt;nmethod_entry_barrier(&amp;_masm);</span>
<span class="line-added">  891   }</span>
  892 
  893   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  894 
  895   if (C-&gt;has_mach_constant_base_node()) {
  896     // NOTE: We set the table base offset here because users might be
  897     // emitted before MachConstantBaseNode.
  898     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  899     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  900   }
  901 }
  902 






  903 int MachPrologNode::reloc() const
  904 {
  905   return 0; // a large enough number
  906 }
  907 
  908 //=============================================================================
  909 #ifndef PRODUCT
  910 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  911 {
  912   Compile* C = ra_-&gt;C;
  913   if (generate_vzeroupper(C)) {
  914     st-&gt;print(&quot;vzeroupper&quot;);
  915     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  916   }
  917 
  918   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  919   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  920   // Remove word for return adr already pushed
  921   // and RBP
  922   framesize -= 2*wordSize;
</pre>
<hr />
<pre>
  930   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  931     st-&gt;print(&quot;\t&quot;);
  932     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  933                  &quot;testl   rax, [rscratch1]\t&quot;
  934                  &quot;# Safepoint: poll for GC&quot;);
  935   }
  936 }
  937 #endif
  938 
  939 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  940 {
  941   Compile* C = ra_-&gt;C;
  942   MacroAssembler _masm(&amp;cbuf);
  943 
  944   if (generate_vzeroupper(C)) {
  945     // Clear upper bits of YMM registers when current compiled code uses
  946     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  947     __ vzeroupper();
  948   }
  949 
<span class="line-modified">  950   // Subtract two words to account for return address and rbp</span>
<span class="line-modified">  951   int initial_framesize = C-&gt;output()-&gt;frame_size_in_bytes() - 2*wordSize;</span>
<span class="line-modified">  952   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;output()-&gt;sp_inc_offset());</span>




















  953 
  954   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  955     __ reserved_stack_check();
  956   }
  957 
  958   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  959     MacroAssembler _masm(&amp;cbuf);
  960     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  961     __ relocate(relocInfo::poll_return_type);
  962     __ testl(rax, Address(rscratch1, 0));
  963   }
  964 }
  965 






  966 int MachEpilogNode::reloc() const
  967 {
  968   return 2; // a large enough number
  969 }
  970 
  971 const Pipeline* MachEpilogNode::pipeline() const
  972 {
  973   return MachNode::pipeline_class();
  974 }
  975 
  976 //=============================================================================
  977 
  978 enum RC {
  979   rc_bad,
  980   rc_int,
  981   rc_float,
  982   rc_stack
  983 };
  984 
  985 static enum RC rc_class(OptoReg::Name reg)
</pre>
<hr />
<pre>
 1481     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1482     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1483     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1484     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1485     emit_d32(cbuf, offset);
 1486   } else {
 1487     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1488     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1489     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1490     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1491     emit_d8(cbuf, offset);
 1492   }
 1493 }
 1494 
 1495 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1496 {
 1497   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1498   return (offset &lt; 0x80) ? 5 : 8; // REX
 1499 }
 1500 
<span class="line-added"> 1501 //=============================================================================</span>
<span class="line-added"> 1502 #ifndef PRODUCT</span>
<span class="line-added"> 1503 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const</span>
<span class="line-added"> 1504 {</span>
<span class="line-added"> 1505   st-&gt;print_cr(&quot;MachVEPNode&quot;);</span>
<span class="line-added"> 1506 }</span>
<span class="line-added"> 1507 #endif</span>
<span class="line-added"> 1508 </span>
<span class="line-added"> 1509 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const</span>
<span class="line-added"> 1510 {</span>
<span class="line-added"> 1511   MacroAssembler masm(&amp;cbuf);</span>
<span class="line-added"> 1512   if (!_verified) {  </span>
<span class="line-added"> 1513     uint insts_size = cbuf.insts_size();</span>
<span class="line-added"> 1514     if (UseCompressedClassPointers) {</span>
<span class="line-added"> 1515       masm.load_klass(rscratch1, j_rarg0, rscratch2);</span>
<span class="line-added"> 1516       masm.cmpptr(rax, rscratch1);</span>
<span class="line-added"> 1517     } else {</span>
<span class="line-added"> 1518       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));</span>
<span class="line-added"> 1519     }</span>
<span class="line-added"> 1520     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));</span>
<span class="line-added"> 1521   } else {</span>
<span class="line-added"> 1522     // Unpack value type args passed as oop and then jump to</span>
<span class="line-added"> 1523     // the verified entry point (skipping the unverified entry).</span>
<span class="line-added"> 1524     masm.unpack_value_args(ra_-&gt;C, _receiver_only);</span>
<span class="line-added"> 1525     masm.jmp(*_verified_entry);</span>
<span class="line-added"> 1526   }</span>
<span class="line-added"> 1527 }</span>
<span class="line-added"> 1528 </span>
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1532 {
 1533   if (UseCompressedClassPointers) {
 1534     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1535     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1536     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1537   } else {
 1538     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1539                  &quot;# Inline cache check&quot;);
 1540   }
 1541   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1542   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1543 }
 1544 #endif
 1545 
 1546 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1547 {
 1548   MacroAssembler masm(&amp;cbuf);
</pre>
<hr />
<pre>
 1551     masm.load_klass(rscratch1, j_rarg0, rscratch2);
 1552     masm.cmpptr(rax, rscratch1);
 1553   } else {
 1554     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1555   }
 1556 
 1557   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1558 
 1559   /* WARNING these NOPs are critical so that verified entry point is properly
 1560      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1561   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1562   if (OptoBreakpoint) {
 1563     // Leave space for int3
 1564     nops_cnt -= 1;
 1565   }
 1566   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1567   if (nops_cnt &gt; 0)
 1568     masm.nop(nops_cnt);
 1569 }
 1570 







 1571 //=============================================================================
 1572 
 1573 int Matcher::regnum_to_fpu_offset(int regnum)
 1574 {
 1575   return regnum - 32; // The FP registers are in the second chunk
 1576 }
 1577 
 1578 // This is UltraSparc specific, true just means we have fast l2f conversion
 1579 const bool Matcher::convL2FSupported(void) {
 1580   return true;
 1581 }
 1582 
 1583 // Is this branch offset short enough that a short branch can be used?
 1584 //
 1585 // NOTE: If the platform does not provide any short branch variants, then
 1586 //       this method should return false for offset 0.
 1587 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1588   // The passed offset is relative to address of the branch.
 1589   // On 86 a branch displacement is calculated relative to address
 1590   // of a next instruction.
</pre>
<hr />
<pre>
 3836   %}
 3837 %}
 3838 
 3839 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3840 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3841 %{
 3842   constraint(ALLOC_IN_RC(ptr_reg));
 3843   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3844   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3845 
 3846   op_cost(10);
 3847   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3848   interface(MEMORY_INTER) %{
 3849     base($reg);
 3850     index($idx);
 3851     scale($scale);
 3852     disp($off);
 3853   %}
 3854 %}
 3855 
<span class="line-added"> 3856 // Indirect Narrow Oop Operand</span>
<span class="line-added"> 3857 operand indCompressedOop(rRegN reg) %{</span>
<span class="line-added"> 3858   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));</span>
<span class="line-added"> 3859   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="line-added"> 3860   match(DecodeN reg);</span>
<span class="line-added"> 3861 </span>
<span class="line-added"> 3862   op_cost(10);</span>
<span class="line-added"> 3863   format %{&quot;[R12 + $reg &lt;&lt; 3] (compressed oop addressing)&quot; %}</span>
<span class="line-added"> 3864   interface(MEMORY_INTER) %{</span>
<span class="line-added"> 3865     base(0xc); // R12</span>
<span class="line-added"> 3866     index($reg);</span>
<span class="line-added"> 3867     scale(0x3);</span>
<span class="line-added"> 3868     disp(0x0);</span>
<span class="line-added"> 3869   %}</span>
<span class="line-added"> 3870 %}</span>
<span class="line-added"> 3871 </span>
 3872 // Indirect Narrow Oop Plus Offset Operand
 3873 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3874 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3875 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3876   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3877   constraint(ALLOC_IN_RC(ptr_reg));
 3878   match(AddP (DecodeN reg) off);
 3879 
 3880   op_cost(10);
 3881   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3882   interface(MEMORY_INTER) %{
 3883     base(0xc); // R12
 3884     index($reg);
 3885     scale(0x3);
 3886     disp($off);
 3887   %}
 3888 %}
 3889 
 3890 // Indirect Memory Operand
 3891 operand indirectNarrow(rRegN reg)
</pre>
<hr />
<pre>
 4194     equal(0x4, &quot;e&quot;);
 4195     not_equal(0x5, &quot;ne&quot;);
 4196     less(0x2, &quot;b&quot;);
 4197     greater_equal(0x3, &quot;nb&quot;);
 4198     less_equal(0x6, &quot;be&quot;);
 4199     greater(0x7, &quot;nbe&quot;);
 4200     overflow(0x0, &quot;o&quot;);
 4201     no_overflow(0x1, &quot;no&quot;);
 4202   %}
 4203 %}
 4204 
 4205 //----------OPERAND CLASSES----------------------------------------------------
 4206 // Operand Classes are groups of operands that are used as to simplify
 4207 // instruction definitions by not requiring the AD writer to specify separate
 4208 // instructions for every form of operand when the instruction accepts
 4209 // multiple operand types with the same basic encoding and format.  The classic
 4210 // case of this is memory operands.
 4211 
 4212 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4213                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
<span class="line-modified"> 4214                indCompressedOop, indCompressedOopOffset,</span>
 4215                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4216                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4217                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4218 
 4219 //----------PIPELINE-----------------------------------------------------------
 4220 // Rules which define the behavior of the target architectures pipeline.
 4221 pipeline %{
 4222 
 4223 //----------ATTRIBUTES---------------------------------------------------------
 4224 attributes %{
 4225   variable_size_instructions;        // Fixed size instructions
 4226   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4227   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4228   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4229   instruction_fetch_units = 1;       // of 16 bytes
 4230 
 4231   // List of nop instructions
 4232   nops( MachNop );
 4233 %}
 4234 
</pre>
<hr />
<pre>
 6678   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6679   ins_encode( );
 6680   ins_pipe(empty);
 6681 %}
 6682 
 6683 //----------Move Instructions--------------------------------------------------
 6684 
 6685 instruct castX2P(rRegP dst, rRegL src)
 6686 %{
 6687   match(Set dst (CastX2P src));
 6688 
 6689   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6690   ins_encode %{
 6691     if ($dst$$reg != $src$$reg) {
 6692       __ movptr($dst$$Register, $src$$Register);
 6693     }
 6694   %}
 6695   ins_pipe(ialu_reg_reg); // XXX
 6696 %}
 6697 
<span class="line-added"> 6698 instruct castN2X(rRegL dst, rRegN src)</span>
<span class="line-added"> 6699 %{</span>
<span class="line-added"> 6700   match(Set dst (CastP2X src));</span>
<span class="line-added"> 6701 </span>
<span class="line-added"> 6702   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}</span>
<span class="line-added"> 6703   ins_encode %{</span>
<span class="line-added"> 6704     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6705       __ movptr($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6706     }</span>
<span class="line-added"> 6707   %}</span>
<span class="line-added"> 6708   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6709 %}</span>
<span class="line-added"> 6710 </span>
 6711 instruct castP2X(rRegL dst, rRegP src)
 6712 %{
 6713   match(Set dst (CastP2X src));
 6714 
 6715   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6716   ins_encode %{
 6717     if ($dst$$reg != $src$$reg) {
 6718       __ movptr($dst$$Register, $src$$Register);
 6719     }
 6720   %}
 6721   ins_pipe(ialu_reg_reg); // XXX
 6722 %}
 6723 
<span class="line-added"> 6724 instruct castN2I(rRegI dst, rRegN src)</span>
<span class="line-added"> 6725 %{</span>
<span class="line-added"> 6726   match(Set dst (CastN2I src));</span>
<span class="line-added"> 6727 </span>
<span class="line-added"> 6728   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}</span>
<span class="line-added"> 6729   ins_encode %{</span>
<span class="line-added"> 6730     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6731       __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6732     }</span>
<span class="line-added"> 6733   %}</span>
<span class="line-added"> 6734   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6735 %}</span>
<span class="line-added"> 6736 </span>
<span class="line-added"> 6737 instruct castI2N(rRegN dst, rRegI src)</span>
<span class="line-added"> 6738 %{</span>
<span class="line-added"> 6739   match(Set dst (CastI2N src));</span>
<span class="line-added"> 6740 </span>
<span class="line-added"> 6741   format %{ &quot;movl    $dst, $src\t# int -&gt; compressed ptr&quot; %}</span>
<span class="line-added"> 6742   ins_encode %{</span>
<span class="line-added"> 6743     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6744       __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6745     }</span>
<span class="line-added"> 6746   %}</span>
<span class="line-added"> 6747   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6748 %}</span>
<span class="line-added"> 6749 </span>
<span class="line-added"> 6750 </span>
 6751 // Convert oop into int for vectors alignment masking
 6752 instruct convP2I(rRegI dst, rRegP src)
 6753 %{
 6754   match(Set dst (ConvL2I (CastP2X src)));
 6755 
 6756   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6757   ins_encode %{
 6758     __ movl($dst$$Register, $src$$Register);
 6759   %}
 6760   ins_pipe(ialu_reg_reg); // XXX
 6761 %}
 6762 
 6763 // Convert compressed oop into int for vectors alignment masking
 6764 // in case of 32bit oops (heap &lt; 4Gb).
 6765 instruct convN2I(rRegI dst, rRegN src)
 6766 %{
 6767   predicate(CompressedOops::shift() == 0);
 6768   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6769 
 6770   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
</pre>
<hr />
<pre>
10944   ins_encode %{
10945     __ movdl($dst$$XMMRegister, $src$$Register);
10946   %}
10947   ins_pipe( pipe_slow );
10948 %}
10949 
10950 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10951   match(Set dst (MoveL2D src));
10952   effect(DEF dst, USE src);
10953   ins_cost(100);
10954   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10955   ins_encode %{
10956      __ movdq($dst$$XMMRegister, $src$$Register);
10957   %}
10958   ins_pipe( pipe_slow );
10959 %}
10960 
10961 
10962 // =======================================================================
10963 // fast clearing of an array
<span class="line-modified">10964 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
10965                   Universe dummy, rFlagsReg cr)
10966 %{
<span class="line-modified">10967   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-modified">10968   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-modified">10969   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
10970 
10971   format %{ $$template

10972     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10973     $$emit$$&quot;jg      LARGE\n\t&quot;
10974     $$emit$$&quot;dec     rcx\n\t&quot;
10975     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10976     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10977     $$emit$$&quot;dec     rcx\n\t&quot;
10978     $$emit$$&quot;jge     LOOP\n\t&quot;
10979     $$emit$$&quot;jmp     DONE\n\t&quot;
10980     $$emit$$&quot;# LARGE:\n\t&quot;
10981     if (UseFastStosb) {
10982        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10983        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10984     } else if (UseXMMForObjInit) {
<span class="line-modified">10985        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-modified">10986        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">10987        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
10988        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10989        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">10990        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-modified">10991        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
10992        $$emit$$&quot;add     0x40,rax\n\t&quot;
10993        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10994        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10995        $$emit$$&quot;jge     L_loop\n\t&quot;
10996        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10997        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">10998        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
10999        $$emit$$&quot;add     0x20,rax\n\t&quot;
11000        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11001        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11002        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11003        $$emit$$&quot;jle     L_end\n\t&quot;
11004        $$emit$$&quot;dec     rcx\n\t&quot;
11005        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11006        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11007        $$emit$$&quot;add     0x8,rax\n\t&quot;
11008        $$emit$$&quot;dec     rcx\n\t&quot;
11009        $$emit$$&quot;jge     L_sloop\n\t&quot;
11010        $$emit$$&quot;# L_end:\n\t&quot;
11011     } else {
11012        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11013     }
11014     $$emit$$&quot;# DONE&quot;
11015   %}
11016   ins_encode %{
<span class="line-modified">11017     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-modified">11018                  $tmp$$XMMRegister, false, false);</span>
11019   %}
11020   ins_pipe(pipe_slow);
11021 %}
11022 
<span class="line-modified">11023 instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
<span class="line-added">11024                   Universe dummy, rFlagsReg cr)</span>
<span class="line-added">11025 %{</span>
<span class="line-added">11026   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-added">11027   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-added">11028   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
<span class="line-added">11029 </span>
<span class="line-added">11030   format %{ $$template</span>
<span class="line-added">11031     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;</span>
<span class="line-added">11032     $$emit$$&quot;jg      LARGE\n\t&quot;</span>
<span class="line-added">11033     $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11034     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;</span>
<span class="line-added">11035     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;</span>
<span class="line-added">11036     $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11037     $$emit$$&quot;jge     LOOP\n\t&quot;</span>
<span class="line-added">11038     $$emit$$&quot;jmp     DONE\n\t&quot;</span>
<span class="line-added">11039     $$emit$$&quot;# LARGE:\n\t&quot;</span>
<span class="line-added">11040     if (UseXMMForObjInit) {</span>
<span class="line-added">11041        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-added">11042        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11043        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11044        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;</span>
<span class="line-added">11045        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;</span>
<span class="line-added">11046        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11047        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
<span class="line-added">11048        $$emit$$&quot;add     0x40,rax\n\t&quot;</span>
<span class="line-added">11049        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;</span>
<span class="line-added">11050        $$emit$$&quot;sub     0x8,rcx\n\t&quot;</span>
<span class="line-added">11051        $$emit$$&quot;jge     L_loop\n\t&quot;</span>
<span class="line-added">11052        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11053        $$emit$$&quot;jl      L_tail\n\t&quot;</span>
<span class="line-added">11054        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11055        $$emit$$&quot;add     0x20,rax\n\t&quot;</span>
<span class="line-added">11056        $$emit$$&quot;sub     0x4,rcx\n\t&quot;</span>
<span class="line-added">11057        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;</span>
<span class="line-added">11058        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11059        $$emit$$&quot;jle     L_end\n\t&quot;</span>
<span class="line-added">11060        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11061        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;</span>
<span class="line-added">11062        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;</span>
<span class="line-added">11063        $$emit$$&quot;add     0x8,rax\n\t&quot;</span>
<span class="line-added">11064        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11065        $$emit$$&quot;jge     L_sloop\n\t&quot;</span>
<span class="line-added">11066        $$emit$$&quot;# L_end:\n\t&quot;</span>
<span class="line-added">11067     } else {</span>
<span class="line-added">11068        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;</span>
<span class="line-added">11069     }</span>
<span class="line-added">11070     $$emit$$&quot;# DONE&quot;</span>
<span class="line-added">11071   %}</span>
<span class="line-added">11072   ins_encode %{</span>
<span class="line-added">11073     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-added">11074                  $tmp$$XMMRegister, false, true);</span>
<span class="line-added">11075   %}</span>
<span class="line-added">11076   ins_pipe(pipe_slow);</span>
<span class="line-added">11077 %}</span>
<span class="line-added">11078 </span>
<span class="line-added">11079 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
11080                         Universe dummy, rFlagsReg cr)
11081 %{
<span class="line-modified">11082   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-modified">11083   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-modified">11084   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
11085 
11086   format %{ $$template
11087     if (UseFastStosb) {

11088        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11089        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11090     } else if (UseXMMForObjInit) {
<span class="line-modified">11091        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-modified">11092        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11093        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
11094        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11095        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">11096        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-modified">11097        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
11098        $$emit$$&quot;add     0x40,rax\n\t&quot;
11099        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11100        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11101        $$emit$$&quot;jge     L_loop\n\t&quot;
11102        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11103        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">11104        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
11105        $$emit$$&quot;add     0x20,rax\n\t&quot;
11106        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11107        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11108        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11109        $$emit$$&quot;jle     L_end\n\t&quot;
11110        $$emit$$&quot;dec     rcx\n\t&quot;
11111        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11112        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11113        $$emit$$&quot;add     0x8,rax\n\t&quot;
11114        $$emit$$&quot;dec     rcx\n\t&quot;
11115        $$emit$$&quot;jge     L_sloop\n\t&quot;
11116        $$emit$$&quot;# L_end:\n\t&quot;
11117     } else {

11118        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11119     }
11120   %}
11121   ins_encode %{
<span class="line-modified">11122     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-modified">11123                  $tmp$$XMMRegister, true, false);</span>
<span class="line-added">11124   %}</span>
<span class="line-added">11125   ins_pipe(pipe_slow);</span>
<span class="line-added">11126 %}</span>
<span class="line-added">11127 </span>
<span class="line-added">11128 instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val, </span>
<span class="line-added">11129                         Universe dummy, rFlagsReg cr)</span>
<span class="line-added">11130 %{</span>
<span class="line-added">11131   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-added">11132   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-added">11133   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
<span class="line-added">11134 </span>
<span class="line-added">11135   format %{ $$template</span>
<span class="line-added">11136     if (UseXMMForObjInit) {</span>
<span class="line-added">11137        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-added">11138        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11139        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11140        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;</span>
<span class="line-added">11141        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;</span>
<span class="line-added">11142        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11143        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
<span class="line-added">11144        $$emit$$&quot;add     0x40,rax\n\t&quot;</span>
<span class="line-added">11145        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;</span>
<span class="line-added">11146        $$emit$$&quot;sub     0x8,rcx\n\t&quot;</span>
<span class="line-added">11147        $$emit$$&quot;jge     L_loop\n\t&quot;</span>
<span class="line-added">11148        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11149        $$emit$$&quot;jl      L_tail\n\t&quot;</span>
<span class="line-added">11150        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11151        $$emit$$&quot;add     0x20,rax\n\t&quot;</span>
<span class="line-added">11152        $$emit$$&quot;sub     0x4,rcx\n\t&quot;</span>
<span class="line-added">11153        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;</span>
<span class="line-added">11154        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11155        $$emit$$&quot;jle     L_end\n\t&quot;</span>
<span class="line-added">11156        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11157        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;</span>
<span class="line-added">11158        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;</span>
<span class="line-added">11159        $$emit$$&quot;add     0x8,rax\n\t&quot;</span>
<span class="line-added">11160        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11161        $$emit$$&quot;jge     L_sloop\n\t&quot;</span>
<span class="line-added">11162        $$emit$$&quot;# L_end:\n\t&quot;</span>
<span class="line-added">11163     } else {</span>
<span class="line-added">11164        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;</span>
<span class="line-added">11165     }</span>
<span class="line-added">11166   %}</span>
<span class="line-added">11167   ins_encode %{</span>
<span class="line-added">11168     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register, </span>
<span class="line-added">11169                  $tmp$$XMMRegister, true, true);</span>
11170   %}
11171   ins_pipe(pipe_slow);
11172 %}
11173 
11174 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11175                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11176 %{
11177   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11178   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11179   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11180 
11181   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11182   ins_encode %{
11183     __ string_compare($str1$$Register, $str2$$Register,
11184                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11185                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11186   %}
11187   ins_pipe( pipe_slow );
11188 %}
11189 
</pre>
<hr />
<pre>
11714 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11715 %{
11716   match(Set cr (CmpI (AndI src con) zero));
11717 
11718   format %{ &quot;testl   $src, $con&quot; %}
11719   opcode(0xF7, 0x00);
11720   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11721   ins_pipe(ialu_cr_reg_imm);
11722 %}
11723 
11724 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11725 %{
11726   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11727 
11728   format %{ &quot;testl   $src, $mem&quot; %}
11729   opcode(0x85);
11730   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11731   ins_pipe(ialu_cr_reg_mem);
11732 %}
11733 
<span class="line-added">11734 // Fold array properties check</span>
<span class="line-added">11735 instruct testI_mem_imm(rFlagsReg cr, memory mem, immI con, immI0 zero)</span>
<span class="line-added">11736 %{</span>
<span class="line-added">11737   match(Set cr (CmpI (AndI (CastN2I (LoadNKlass mem)) con) zero));</span>
<span class="line-added">11738 </span>
<span class="line-added">11739   format %{ &quot;testl   $mem, $con&quot; %}</span>
<span class="line-added">11740   opcode(0xF7, 0x00);</span>
<span class="line-added">11741   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(con));</span>
<span class="line-added">11742   ins_pipe(ialu_mem_imm);</span>
<span class="line-added">11743 %}</span>
<span class="line-added">11744 </span>
11745 // Unsigned compare Instructions; really, same as signed except they
11746 // produce an rFlagsRegU instead of rFlagsReg.
11747 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11748 %{
11749   match(Set cr (CmpU op1 op2));
11750 
11751   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11752   opcode(0x3B); /* Opcode 3B /r */
11753   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11754   ins_pipe(ialu_cr_reg_reg);
11755 %}
11756 
11757 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11758 %{
11759   match(Set cr (CmpU op1 op2));
11760 
11761   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11762   opcode(0x81,0x07); /* Opcode 81 /7 */
11763   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11764   ins_pipe(ialu_cr_reg_imm);
</pre>
<hr />
<pre>
12037 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
12038 %{
12039   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
12040 
12041   format %{ &quot;testq   $src, $mem&quot; %}
12042   opcode(0x85);
12043   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12044   ins_pipe(ialu_cr_reg_mem);
12045 %}
12046 
12047 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
12048 %{
12049   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
12050 
12051   format %{ &quot;testq   $src, $mem&quot; %}
12052   opcode(0x85);
12053   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12054   ins_pipe(ialu_cr_reg_mem);
12055 %}
12056 
<span class="line-added">12057 // Fold array properties check</span>
<span class="line-added">12058 instruct testL_reg_mem3(rFlagsReg cr, memory mem, rRegL src, immL0 zero)</span>
<span class="line-added">12059 %{</span>
<span class="line-added">12060   match(Set cr (CmpL (AndL (CastP2X (LoadKlass mem)) src) zero));</span>
<span class="line-added">12061 </span>
<span class="line-added">12062   format %{ &quot;testq   $src, $mem\t# test array properties&quot; %}</span>
<span class="line-added">12063   opcode(0x85);</span>
<span class="line-added">12064   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));</span>
<span class="line-added">12065   ins_pipe(ialu_cr_reg_mem);</span>
<span class="line-added">12066 %}</span>
<span class="line-added">12067 </span>
12068 // Manifest a CmpL result in an integer register.  Very painful.
12069 // This is the test to avoid.
12070 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
12071 %{
12072   match(Set dst (CmpL3 src1 src2));
12073   effect(KILL flags);
12074 
12075   ins_cost(275); // XXX
12076   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
12077             &quot;movl    $dst, -1\n\t&quot;
12078             &quot;jl,s    done\n\t&quot;
12079             &quot;setne   $dst\n\t&quot;
12080             &quot;movzbl  $dst, $dst\n\t&quot;
12081     &quot;done:&quot; %}
12082   ins_encode(cmpl3_flag(src1, src2, dst));
12083   ins_pipe(pipe_slow);
12084 %}
12085 
12086 // Unsigned long compare Instructions; really, same as signed long except they
12087 // produce an rFlagsRegU instead of rFlagsReg.
</pre>
<hr />
<pre>
12715 
12716   ins_cost(300);
12717   format %{ &quot;call,runtime &quot; %}
12718   ins_encode(clear_avx, Java_To_Runtime(meth));
12719   ins_pipe(pipe_slow);
12720 %}
12721 
12722 // Call runtime without safepoint
12723 instruct CallLeafDirect(method meth)
12724 %{
12725   match(CallLeaf);
12726   effect(USE meth);
12727 
12728   ins_cost(300);
12729   format %{ &quot;call_leaf,runtime &quot; %}
12730   ins_encode(clear_avx, Java_To_Runtime(meth));
12731   ins_pipe(pipe_slow);
12732 %}
12733 
12734 // Call runtime without safepoint
<span class="line-added">12735 // entry point is null, target holds the address to call</span>
<span class="line-added">12736 instruct CallLeafNoFPInDirect(rRegP target)</span>
<span class="line-added">12737 %{</span>
<span class="line-added">12738   predicate(n-&gt;as_Call()-&gt;entry_point() == NULL);</span>
<span class="line-added">12739   match(CallLeafNoFP target);</span>
<span class="line-added">12740 </span>
<span class="line-added">12741   ins_cost(300);</span>
<span class="line-added">12742   format %{ &quot;call_leaf_nofp,runtime indirect &quot; %}</span>
<span class="line-added">12743   ins_encode %{</span>
<span class="line-added">12744      __ call($target$$Register);</span>
<span class="line-added">12745   %}</span>
<span class="line-added">12746 </span>
<span class="line-added">12747   ins_pipe(pipe_slow);</span>
<span class="line-added">12748 %}</span>
<span class="line-added">12749 </span>
12750 instruct CallLeafNoFPDirect(method meth)
12751 %{
<span class="line-added">12752   predicate(n-&gt;as_Call()-&gt;entry_point() != NULL);</span>
12753   match(CallLeafNoFP);
12754   effect(USE meth);
12755 
12756   ins_cost(300);
12757   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12758   ins_encode(clear_avx, Java_To_Runtime(meth));
12759   ins_pipe(pipe_slow);
12760 %}
12761 
12762 // Return Instruction
12763 // Remove the return address &amp; jump to it.
12764 // Notice: We always emit a nop after a ret to make sure there is room
12765 // for safepoint patching
12766 instruct Ret()
12767 %{
12768   match(Return);
12769 
12770   format %{ &quot;ret&quot; %}
12771   opcode(0xC3);
12772   ins_encode(OpcP);
</pre>
</td>
</tr>
</table>
<center><a href="vtableStubs_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_Runtime1.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
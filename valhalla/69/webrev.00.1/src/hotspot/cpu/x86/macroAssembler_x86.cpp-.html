<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/accessDecorators.hpp&quot;
  37 #include &quot;oops/compressedOops.inline.hpp&quot;
  38 #include &quot;oops/klass.inline.hpp&quot;
  39 #include &quot;prims/methodHandles.hpp&quot;
  40 #include &quot;runtime/biasedLocking.hpp&quot;
  41 #include &quot;runtime/flags/flagSetting.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/stubRoutines.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 #include &quot;crc32c.h&quot;
  52 
  53 #ifdef PRODUCT
  54 #define BLOCK_COMMENT(str) /* nothing */
  55 #define STOP(error) stop(error)
  56 #else
  57 #define BLOCK_COMMENT(str) block_comment(str)
  58 #define STOP(error) block_comment(error); stop(error)
  59 #endif
  60 
  61 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  62 
  63 #ifdef ASSERT
  64 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
  65 #endif
  66 
  67 static Assembler::Condition reverse[] = {
  68     Assembler::noOverflow     /* overflow      = 0x0 */ ,
  69     Assembler::overflow       /* noOverflow    = 0x1 */ ,
  70     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
  71     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
  72     Assembler::notZero        /* zero          = 0x4, equal         = 0x4 */ ,
  73     Assembler::zero           /* notZero       = 0x5, notEqual      = 0x5 */ ,
  74     Assembler::above          /* belowEqual    = 0x6 */ ,
  75     Assembler::belowEqual     /* above         = 0x7 */ ,
  76     Assembler::positive       /* negative      = 0x8 */ ,
  77     Assembler::negative       /* positive      = 0x9 */ ,
  78     Assembler::noParity       /* parity        = 0xa */ ,
  79     Assembler::parity         /* noParity      = 0xb */ ,
  80     Assembler::greaterEqual   /* less          = 0xc */ ,
  81     Assembler::less           /* greaterEqual  = 0xd */ ,
  82     Assembler::greater        /* lessEqual     = 0xe */ ,
  83     Assembler::lessEqual      /* greater       = 0xf, */
  84 
  85 };
  86 
  87 
  88 // Implementation of MacroAssembler
  89 
  90 // First all the versions that have distinct versions depending on 32/64 bit
  91 // Unless the difference is trivial (1 line or so).
  92 
  93 #ifndef _LP64
  94 
  95 // 32bit versions
  96 
  97 Address MacroAssembler::as_Address(AddressLiteral adr) {
  98   return Address(adr.target(), adr.rspec());
  99 }
 100 
 101 Address MacroAssembler::as_Address(ArrayAddress adr) {
 102   return Address::make_array(adr);
 103 }
 104 
 105 void MacroAssembler::call_VM_leaf_base(address entry_point,
 106                                        int number_of_arguments) {
 107   call(RuntimeAddress(entry_point));
 108   increment(rsp, number_of_arguments * wordSize);
 109 }
 110 
 111 void MacroAssembler::cmpklass(Address src1, Metadata* obj) {
 112   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 113 }
 114 
 115 void MacroAssembler::cmpklass(Register src1, Metadata* obj) {
 116   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 117 }
 118 
 119 void MacroAssembler::cmpoop_raw(Address src1, jobject obj) {
 120   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 121 }
 122 
 123 void MacroAssembler::cmpoop_raw(Register src1, jobject obj) {
 124   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 125 }
 126 
 127 void MacroAssembler::cmpoop(Address src1, jobject obj) {
 128   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 129   bs-&gt;obj_equals(this, src1, obj);
 130 }
 131 
 132 void MacroAssembler::cmpoop(Register src1, jobject obj) {
 133   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 134   bs-&gt;obj_equals(this, src1, obj);
 135 }
 136 
 137 void MacroAssembler::extend_sign(Register hi, Register lo) {
 138   // According to Intel Doc. AP-526, &quot;Integer Divide&quot;, p.18.
 139   if (VM_Version::is_P6() &amp;&amp; hi == rdx &amp;&amp; lo == rax) {
 140     cdql();
 141   } else {
 142     movl(hi, lo);
 143     sarl(hi, 31);
 144   }
 145 }
 146 
 147 void MacroAssembler::jC2(Register tmp, Label&amp; L) {
 148   // set parity bit if FPU flag C2 is set (via rax)
 149   save_rax(tmp);
 150   fwait(); fnstsw_ax();
 151   sahf();
 152   restore_rax(tmp);
 153   // branch
 154   jcc(Assembler::parity, L);
 155 }
 156 
 157 void MacroAssembler::jnC2(Register tmp, Label&amp; L) {
 158   // set parity bit if FPU flag C2 is set (via rax)
 159   save_rax(tmp);
 160   fwait(); fnstsw_ax();
 161   sahf();
 162   restore_rax(tmp);
 163   // branch
 164   jcc(Assembler::noParity, L);
 165 }
 166 
 167 // 32bit can do a case table jump in one instruction but we no longer allow the base
 168 // to be installed in the Address class
 169 void MacroAssembler::jump(ArrayAddress entry) {
 170   jmp(as_Address(entry));
 171 }
 172 
 173 // Note: y_lo will be destroyed
 174 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 175   // Long compare for Java (semantics as described in JVM spec.)
 176   Label high, low, done;
 177 
 178   cmpl(x_hi, y_hi);
 179   jcc(Assembler::less, low);
 180   jcc(Assembler::greater, high);
 181   // x_hi is the return register
 182   xorl(x_hi, x_hi);
 183   cmpl(x_lo, y_lo);
 184   jcc(Assembler::below, low);
 185   jcc(Assembler::equal, done);
 186 
 187   bind(high);
 188   xorl(x_hi, x_hi);
 189   increment(x_hi);
 190   jmp(done);
 191 
 192   bind(low);
 193   xorl(x_hi, x_hi);
 194   decrementl(x_hi);
 195 
 196   bind(done);
 197 }
 198 
 199 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 200     mov_literal32(dst, (int32_t)src.target(), src.rspec());
 201 }
 202 
 203 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 204   // leal(dst, as_Address(adr));
 205   // see note in movl as to why we must use a move
 206   mov_literal32(dst, (int32_t) adr.target(), adr.rspec());
 207 }
 208 
 209 void MacroAssembler::leave() {
 210   mov(rsp, rbp);
 211   pop(rbp);
 212 }
 213 
 214 void MacroAssembler::lmul(int x_rsp_offset, int y_rsp_offset) {
 215   // Multiplication of two Java long values stored on the stack
 216   // as illustrated below. Result is in rdx:rax.
 217   //
 218   // rsp ---&gt; [  ??  ] \               \
 219   //            ....    | y_rsp_offset  |
 220   //          [ y_lo ] /  (in bytes)    | x_rsp_offset
 221   //          [ y_hi ]                  | (in bytes)
 222   //            ....                    |
 223   //          [ x_lo ]                 /
 224   //          [ x_hi ]
 225   //            ....
 226   //
 227   // Basic idea: lo(result) = lo(x_lo * y_lo)
 228   //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 229   Address x_hi(rsp, x_rsp_offset + wordSize); Address x_lo(rsp, x_rsp_offset);
 230   Address y_hi(rsp, y_rsp_offset + wordSize); Address y_lo(rsp, y_rsp_offset);
 231   Label quick;
 232   // load x_hi, y_hi and check if quick
 233   // multiplication is possible
 234   movl(rbx, x_hi);
 235   movl(rcx, y_hi);
 236   movl(rax, rbx);
 237   orl(rbx, rcx);                                 // rbx, = 0 &lt;=&gt; x_hi = 0 and y_hi = 0
 238   jcc(Assembler::zero, quick);                   // if rbx, = 0 do quick multiply
 239   // do full multiplication
 240   // 1st step
 241   mull(y_lo);                                    // x_hi * y_lo
 242   movl(rbx, rax);                                // save lo(x_hi * y_lo) in rbx,
 243   // 2nd step
 244   movl(rax, x_lo);
 245   mull(rcx);                                     // x_lo * y_hi
 246   addl(rbx, rax);                                // add lo(x_lo * y_hi) to rbx,
 247   // 3rd step
 248   bind(quick);                                   // note: rbx, = 0 if quick multiply!
 249   movl(rax, x_lo);
 250   mull(y_lo);                                    // x_lo * y_lo
 251   addl(rdx, rbx);                                // correct hi(x_lo * y_lo)
 252 }
 253 
 254 void MacroAssembler::lneg(Register hi, Register lo) {
 255   negl(lo);
 256   adcl(hi, 0);
 257   negl(hi);
 258 }
 259 
 260 void MacroAssembler::lshl(Register hi, Register lo) {
 261   // Java shift left long support (semantics as described in JVM spec., p.305)
 262   // (basic idea for shift counts s &gt;= n: x &lt;&lt; s == (x &lt;&lt; n) &lt;&lt; (s - n))
 263   // shift value is in rcx !
 264   assert(hi != rcx, &quot;must not use rcx&quot;);
 265   assert(lo != rcx, &quot;must not use rcx&quot;);
 266   const Register s = rcx;                        // shift count
 267   const int      n = BitsPerWord;
 268   Label L;
 269   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 270   cmpl(s, n);                                    // if (s &lt; n)
 271   jcc(Assembler::less, L);                       // else (s &gt;= n)
 272   movl(hi, lo);                                  // x := x &lt;&lt; n
 273   xorl(lo, lo);
 274   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 275   bind(L);                                       // s (mod n) &lt; n
 276   shldl(hi, lo);                                 // x := x &lt;&lt; s
 277   shll(lo);
 278 }
 279 
 280 
 281 void MacroAssembler::lshr(Register hi, Register lo, bool sign_extension) {
 282   // Java shift right long support (semantics as described in JVM spec., p.306 &amp; p.310)
 283   // (basic idea for shift counts s &gt;= n: x &gt;&gt; s == (x &gt;&gt; n) &gt;&gt; (s - n))
 284   assert(hi != rcx, &quot;must not use rcx&quot;);
 285   assert(lo != rcx, &quot;must not use rcx&quot;);
 286   const Register s = rcx;                        // shift count
 287   const int      n = BitsPerWord;
 288   Label L;
 289   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 290   cmpl(s, n);                                    // if (s &lt; n)
 291   jcc(Assembler::less, L);                       // else (s &gt;= n)
 292   movl(lo, hi);                                  // x := x &gt;&gt; n
 293   if (sign_extension) sarl(hi, 31);
 294   else                xorl(hi, hi);
 295   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 296   bind(L);                                       // s (mod n) &lt; n
 297   shrdl(lo, hi);                                 // x := x &gt;&gt; s
 298   if (sign_extension) sarl(hi);
 299   else                shrl(hi);
 300 }
 301 
 302 void MacroAssembler::movoop(Register dst, jobject obj) {
 303   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 304 }
 305 
 306 void MacroAssembler::movoop(Address dst, jobject obj) {
 307   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 308 }
 309 
 310 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 311   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 312 }
 313 
 314 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 315   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 316 }
 317 
 318 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 319   // scratch register is not used,
 320   // it is defined to match parameters of 64-bit version of this method.
 321   if (src.is_lval()) {
 322     mov_literal32(dst, (intptr_t)src.target(), src.rspec());
 323   } else {
 324     movl(dst, as_Address(src));
 325   }
 326 }
 327 
 328 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 329   movl(as_Address(dst), src);
 330 }
 331 
 332 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 333   movl(dst, as_Address(src));
 334 }
 335 
 336 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 337 void MacroAssembler::movptr(Address dst, intptr_t src) {
 338   movl(dst, src);
 339 }
 340 
 341 
 342 void MacroAssembler::pop_callee_saved_registers() {
 343   pop(rcx);
 344   pop(rdx);
 345   pop(rdi);
 346   pop(rsi);
 347 }
 348 
 349 void MacroAssembler::push_callee_saved_registers() {
 350   push(rsi);
 351   push(rdi);
 352   push(rdx);
 353   push(rcx);
 354 }
 355 
 356 void MacroAssembler::pushoop(jobject obj) {
 357   push_literal32((int32_t)obj, oop_Relocation::spec_for_immediate());
 358 }
 359 
 360 void MacroAssembler::pushklass(Metadata* obj) {
 361   push_literal32((int32_t)obj, metadata_Relocation::spec_for_immediate());
 362 }
 363 
 364 void MacroAssembler::pushptr(AddressLiteral src) {
 365   if (src.is_lval()) {
 366     push_literal32((int32_t)src.target(), src.rspec());
 367   } else {
 368     pushl(as_Address(src));
 369   }
 370 }
 371 
 372 void MacroAssembler::set_word_if_not_zero(Register dst) {
 373   xorl(dst, dst);
 374   set_byte_if_not_zero(dst);
 375 }
 376 
 377 static void pass_arg0(MacroAssembler* masm, Register arg) {
 378   masm-&gt;push(arg);
 379 }
 380 
 381 static void pass_arg1(MacroAssembler* masm, Register arg) {
 382   masm-&gt;push(arg);
 383 }
 384 
 385 static void pass_arg2(MacroAssembler* masm, Register arg) {
 386   masm-&gt;push(arg);
 387 }
 388 
 389 static void pass_arg3(MacroAssembler* masm, Register arg) {
 390   masm-&gt;push(arg);
 391 }
 392 
 393 #ifndef PRODUCT
 394 extern &quot;C&quot; void findpc(intptr_t x);
 395 #endif
 396 
 397 void MacroAssembler::debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg) {
 398   // In order to get locks to work, we need to fake a in_VM state
 399   JavaThread* thread = JavaThread::current();
 400   JavaThreadState saved_state = thread-&gt;thread_state();
 401   thread-&gt;set_thread_state(_thread_in_vm);
 402   if (ShowMessageBoxOnError) {
 403     JavaThread* thread = JavaThread::current();
 404     JavaThreadState saved_state = thread-&gt;thread_state();
 405     thread-&gt;set_thread_state(_thread_in_vm);
 406     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 407       ttyLocker ttyl;
 408       BytecodeCounter::print();
 409     }
 410     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 411     // This is the value of eip which points to where verify_oop will return.
 412     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 413       print_state32(rdi, rsi, rbp, rsp, rbx, rdx, rcx, rax, eip);
 414       BREAKPOINT;
 415     }
 416   }
 417   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 418 }
 419 
 420 void MacroAssembler::print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip) {
 421   ttyLocker ttyl;
 422   FlagSetting fs(Debugging, true);
 423   tty-&gt;print_cr(&quot;eip = 0x%08x&quot;, eip);
 424 #ifndef PRODUCT
 425   if ((WizardMode || Verbose) &amp;&amp; PrintMiscellaneous) {
 426     tty-&gt;cr();
 427     findpc(eip);
 428     tty-&gt;cr();
 429   }
 430 #endif
 431 #define PRINT_REG(rax) \
 432   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, rax); }
 433   PRINT_REG(rax);
 434   PRINT_REG(rbx);
 435   PRINT_REG(rcx);
 436   PRINT_REG(rdx);
 437   PRINT_REG(rdi);
 438   PRINT_REG(rsi);
 439   PRINT_REG(rbp);
 440   PRINT_REG(rsp);
 441 #undef PRINT_REG
 442   // Print some words near top of staack.
 443   int* dump_sp = (int*) rsp;
 444   for (int col1 = 0; col1 &lt; 8; col1++) {
 445     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 446     os::print_location(tty, *dump_sp++);
 447   }
 448   for (int row = 0; row &lt; 16; row++) {
 449     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 450     for (int col = 0; col &lt; 8; col++) {
 451       tty-&gt;print(&quot; 0x%08x&quot;, *dump_sp++);
 452     }
 453     tty-&gt;cr();
 454   }
 455   // Print some instructions around pc:
 456   Disassembler::decode((address)eip-64, (address)eip);
 457   tty-&gt;print_cr(&quot;--------&quot;);
 458   Disassembler::decode((address)eip, (address)eip+32);
 459 }
 460 
 461 void MacroAssembler::stop(const char* msg) {
 462   ExternalAddress message((address)msg);
 463   // push address of message
 464   pushptr(message.addr());
 465   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 466   pusha();                                            // push registers
 467   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
 468   hlt();
 469 }
 470 
 471 void MacroAssembler::warn(const char* msg) {
 472   push_CPU_state();
 473 
 474   ExternalAddress message((address) msg);
 475   // push address of message
 476   pushptr(message.addr());
 477 
 478   call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));
 479   addl(rsp, wordSize);       // discard argument
 480   pop_CPU_state();
 481 }
 482 
 483 void MacroAssembler::print_state() {
 484   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 485   pusha();                                            // push registers
 486 
 487   push_CPU_state();
 488   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::print_state32)));
 489   pop_CPU_state();
 490 
 491   popa();
 492   addl(rsp, wordSize);
 493 }
 494 
 495 #else // _LP64
 496 
 497 // 64 bit versions
 498 
 499 Address MacroAssembler::as_Address(AddressLiteral adr) {
 500   // amd64 always does this as a pc-rel
 501   // we can be absolute or disp based on the instruction type
 502   // jmp/call are displacements others are absolute
 503   assert(!adr.is_lval(), &quot;must be rval&quot;);
 504   assert(reachable(adr), &quot;must be&quot;);
 505   return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());
 506 
 507 }
 508 
 509 Address MacroAssembler::as_Address(ArrayAddress adr) {
 510   AddressLiteral base = adr.base();
 511   lea(rscratch1, base);
 512   Address index = adr.index();
 513   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
 514   Address array(rscratch1, index._index, index._scale, index._disp);
 515   return array;
 516 }
 517 
 518 void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) {
 519   Label L, E;
 520 
 521 #ifdef _WIN64
 522   // Windows always allocates space for it&#39;s register args
 523   assert(num_args &lt;= 4, &quot;only register arguments supported&quot;);
 524   subq(rsp,  frame::arg_reg_save_area_bytes);
 525 #endif
 526 
 527   // Align stack if necessary
 528   testl(rsp, 15);
 529   jcc(Assembler::zero, L);
 530 
 531   subq(rsp, 8);
 532   {
 533     call(RuntimeAddress(entry_point));
 534   }
 535   addq(rsp, 8);
 536   jmp(E);
 537 
 538   bind(L);
 539   {
 540     call(RuntimeAddress(entry_point));
 541   }
 542 
 543   bind(E);
 544 
 545 #ifdef _WIN64
 546   // restore stack pointer
 547   addq(rsp, frame::arg_reg_save_area_bytes);
 548 #endif
 549 
 550 }
 551 
 552 void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {
 553   assert(!src2.is_lval(), &quot;should use cmpptr&quot;);
 554 
 555   if (reachable(src2)) {
 556     cmpq(src1, as_Address(src2));
 557   } else {
 558     lea(rscratch1, src2);
 559     Assembler::cmpq(src1, Address(rscratch1, 0));
 560   }
 561 }
 562 
 563 int MacroAssembler::corrected_idivq(Register reg) {
 564   // Full implementation of Java ldiv and lrem; checks for special
 565   // case as described in JVM spec., p.243 &amp; p.271.  The function
 566   // returns the (pc) offset of the idivl instruction - may be needed
 567   // for implicit exceptions.
 568   //
 569   //         normal case                           special case
 570   //
 571   // input : rax: dividend                         min_long
 572   //         reg: divisor   (may not be eax/edx)   -1
 573   //
 574   // output: rax: quotient  (= rax idiv reg)       min_long
 575   //         rdx: remainder (= rax irem reg)       0
 576   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax or rdx register&quot;);
 577   static const int64_t min_long = 0x8000000000000000;
 578   Label normal_case, special_case;
 579 
 580   // check for special case
 581   cmp64(rax, ExternalAddress((address) &amp;min_long));
 582   jcc(Assembler::notEqual, normal_case);
 583   xorl(rdx, rdx); // prepare rdx for possible special case (where
 584                   // remainder = 0)
 585   cmpq(reg, -1);
 586   jcc(Assembler::equal, special_case);
 587 
 588   // handle normal case
 589   bind(normal_case);
 590   cdqq();
 591   int idivq_offset = offset();
 592   idivq(reg);
 593 
 594   // normal and special case exit
 595   bind(special_case);
 596 
 597   return idivq_offset;
 598 }
 599 
 600 void MacroAssembler::decrementq(Register reg, int value) {
 601   if (value == min_jint) { subq(reg, value); return; }
 602   if (value &lt;  0) { incrementq(reg, -value); return; }
 603   if (value == 0) {                        ; return; }
 604   if (value == 1 &amp;&amp; UseIncDec) { decq(reg) ; return; }
 605   /* else */      { subq(reg, value)       ; return; }
 606 }
 607 
 608 void MacroAssembler::decrementq(Address dst, int value) {
 609   if (value == min_jint) { subq(dst, value); return; }
 610   if (value &lt;  0) { incrementq(dst, -value); return; }
 611   if (value == 0) {                        ; return; }
 612   if (value == 1 &amp;&amp; UseIncDec) { decq(dst) ; return; }
 613   /* else */      { subq(dst, value)       ; return; }
 614 }
 615 
 616 void MacroAssembler::incrementq(AddressLiteral dst) {
 617   if (reachable(dst)) {
 618     incrementq(as_Address(dst));
 619   } else {
 620     lea(rscratch1, dst);
 621     incrementq(Address(rscratch1, 0));
 622   }
 623 }
 624 
 625 void MacroAssembler::incrementq(Register reg, int value) {
 626   if (value == min_jint) { addq(reg, value); return; }
 627   if (value &lt;  0) { decrementq(reg, -value); return; }
 628   if (value == 0) {                        ; return; }
 629   if (value == 1 &amp;&amp; UseIncDec) { incq(reg) ; return; }
 630   /* else */      { addq(reg, value)       ; return; }
 631 }
 632 
 633 void MacroAssembler::incrementq(Address dst, int value) {
 634   if (value == min_jint) { addq(dst, value); return; }
 635   if (value &lt;  0) { decrementq(dst, -value); return; }
 636   if (value == 0) {                        ; return; }
 637   if (value == 1 &amp;&amp; UseIncDec) { incq(dst) ; return; }
 638   /* else */      { addq(dst, value)       ; return; }
 639 }
 640 
 641 // 32bit can do a case table jump in one instruction but we no longer allow the base
 642 // to be installed in the Address class
 643 void MacroAssembler::jump(ArrayAddress entry) {
 644   lea(rscratch1, entry.base());
 645   Address dispatch = entry.index();
 646   assert(dispatch._base == noreg, &quot;must be&quot;);
 647   dispatch._base = rscratch1;
 648   jmp(dispatch);
 649 }
 650 
 651 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 652   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 653   cmpq(x_lo, y_lo);
 654 }
 655 
 656 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 657     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 658 }
 659 
 660 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 661   mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());
 662   movptr(dst, rscratch1);
 663 }
 664 
 665 void MacroAssembler::leave() {
 666   // %%% is this really better? Why not on 32bit too?
 667   emit_int8((unsigned char)0xC9); // LEAVE
 668 }
 669 
 670 void MacroAssembler::lneg(Register hi, Register lo) {
 671   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 672   negq(lo);
 673 }
 674 
 675 void MacroAssembler::movoop(Register dst, jobject obj) {
 676   mov_literal64(dst, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 677 }
 678 
 679 void MacroAssembler::movoop(Address dst, jobject obj) {
 680   mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 681   movq(dst, rscratch1);
 682 }
 683 
 684 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 685   mov_literal64(dst, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 686 }
 687 
 688 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 689   mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 690   movq(dst, rscratch1);
 691 }
 692 
 693 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 694   if (src.is_lval()) {
 695     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 696   } else {
 697     if (reachable(src)) {
 698       movq(dst, as_Address(src));
 699     } else {
 700       lea(scratch, src);
 701       movq(dst, Address(scratch, 0));
 702     }
 703   }
 704 }
 705 
 706 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 707   movq(as_Address(dst), src);
 708 }
 709 
 710 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 711   movq(dst, as_Address(src));
 712 }
 713 
 714 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 715 void MacroAssembler::movptr(Address dst, intptr_t src) {
 716   mov64(rscratch1, src);
 717   movq(dst, rscratch1);
 718 }
 719 
 720 // These are mostly for initializing NULL
 721 void MacroAssembler::movptr(Address dst, int32_t src) {
 722   movslq(dst, src);
 723 }
 724 
 725 void MacroAssembler::movptr(Register dst, int32_t src) {
 726   mov64(dst, (intptr_t)src);
 727 }
 728 
 729 void MacroAssembler::pushoop(jobject obj) {
 730   movoop(rscratch1, obj);
 731   push(rscratch1);
 732 }
 733 
 734 void MacroAssembler::pushklass(Metadata* obj) {
 735   mov_metadata(rscratch1, obj);
 736   push(rscratch1);
 737 }
 738 
 739 void MacroAssembler::pushptr(AddressLiteral src) {
 740   lea(rscratch1, src);
 741   if (src.is_lval()) {
 742     push(rscratch1);
 743   } else {
 744     pushq(Address(rscratch1, 0));
 745   }
 746 }
 747 
 748 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 749   // we must set sp to zero to clear frame
 750   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
 751   // must clear fp, so that compiled frames are not confused; it is
 752   // possible that we need it only for debugging
 753   if (clear_fp) {
 754     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
 755   }
 756 
 757   // Always clear the pc because it could have been set by make_walkable()
 758   movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
 759   vzeroupper();
 760 }
 761 
 762 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 763                                          Register last_java_fp,
 764                                          address  last_java_pc) {
 765   vzeroupper();
 766   // determine last_java_sp register
 767   if (!last_java_sp-&gt;is_valid()) {
 768     last_java_sp = rsp;
 769   }
 770 
 771   // last_java_fp is optional
 772   if (last_java_fp-&gt;is_valid()) {
 773     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),
 774            last_java_fp);
 775   }
 776 
 777   // last_java_pc is optional
 778   if (last_java_pc != NULL) {
 779     Address java_pc(r15_thread,
 780                     JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 781     lea(rscratch1, InternalAddress(last_java_pc));
 782     movptr(java_pc, rscratch1);
 783   }
 784 
 785   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
 786 }
 787 
 788 static void pass_arg0(MacroAssembler* masm, Register arg) {
 789   if (c_rarg0 != arg ) {
 790     masm-&gt;mov(c_rarg0, arg);
 791   }
 792 }
 793 
 794 static void pass_arg1(MacroAssembler* masm, Register arg) {
 795   if (c_rarg1 != arg ) {
 796     masm-&gt;mov(c_rarg1, arg);
 797   }
 798 }
 799 
 800 static void pass_arg2(MacroAssembler* masm, Register arg) {
 801   if (c_rarg2 != arg ) {
 802     masm-&gt;mov(c_rarg2, arg);
 803   }
 804 }
 805 
 806 static void pass_arg3(MacroAssembler* masm, Register arg) {
 807   if (c_rarg3 != arg ) {
 808     masm-&gt;mov(c_rarg3, arg);
 809   }
 810 }
 811 
 812 void MacroAssembler::stop(const char* msg) {
 813   if (ShowMessageBoxOnError) {
 814     address rip = pc();
 815     pusha(); // get regs on stack
 816     lea(c_rarg1, InternalAddress(rip));
 817     movq(c_rarg2, rsp); // pass pointer to regs array
 818   }
 819   lea(c_rarg0, ExternalAddress((address) msg));
 820   andq(rsp, -16); // align stack as required by ABI
 821   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
 822   hlt();
 823 }
 824 
 825 void MacroAssembler::warn(const char* msg) {
 826   push(rbp);
 827   movq(rbp, rsp);
 828   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 829   push_CPU_state();   // keeps alignment at 16 bytes
 830   lea(c_rarg0, ExternalAddress((address) msg));
 831   lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));
 832   call(rax);
 833   pop_CPU_state();
 834   mov(rsp, rbp);
 835   pop(rbp);
 836 }
 837 
 838 void MacroAssembler::print_state() {
 839   address rip = pc();
 840   pusha();            // get regs on stack
 841   push(rbp);
 842   movq(rbp, rsp);
 843   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 844   push_CPU_state();   // keeps alignment at 16 bytes
 845 
 846   lea(c_rarg0, InternalAddress(rip));
 847   lea(c_rarg1, Address(rbp, wordSize)); // pass pointer to regs array
 848   call_VM_leaf(CAST_FROM_FN_PTR(address, MacroAssembler::print_state64), c_rarg0, c_rarg1);
 849 
 850   pop_CPU_state();
 851   mov(rsp, rbp);
 852   pop(rbp);
 853   popa();
 854 }
 855 
 856 #ifndef PRODUCT
 857 extern &quot;C&quot; void findpc(intptr_t x);
 858 #endif
 859 
 860 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[]) {
 861   // In order to get locks to work, we need to fake a in_VM state
 862   if (ShowMessageBoxOnError) {
 863     JavaThread* thread = JavaThread::current();
 864     JavaThreadState saved_state = thread-&gt;thread_state();
 865     thread-&gt;set_thread_state(_thread_in_vm);
 866 #ifndef PRODUCT
 867     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 868       ttyLocker ttyl;
 869       BytecodeCounter::print();
 870     }
 871 #endif
 872     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 873     // XXX correct this offset for amd64
 874     // This is the value of eip which points to where verify_oop will return.
 875     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 876       print_state64(pc, regs);
 877       BREAKPOINT;
 878     }
 879   }
 880   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 881 }
 882 
 883 void MacroAssembler::print_state64(int64_t pc, int64_t regs[]) {
 884   ttyLocker ttyl;
 885   FlagSetting fs(Debugging, true);
 886   tty-&gt;print_cr(&quot;rip = 0x%016lx&quot;, (intptr_t)pc);
 887 #ifndef PRODUCT
 888   tty-&gt;cr();
 889   findpc(pc);
 890   tty-&gt;cr();
 891 #endif
 892 #define PRINT_REG(rax, value) \
 893   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, value); }
 894   PRINT_REG(rax, regs[15]);
 895   PRINT_REG(rbx, regs[12]);
 896   PRINT_REG(rcx, regs[14]);
 897   PRINT_REG(rdx, regs[13]);
 898   PRINT_REG(rdi, regs[8]);
 899   PRINT_REG(rsi, regs[9]);
 900   PRINT_REG(rbp, regs[10]);
 901   PRINT_REG(rsp, regs[11]);
 902   PRINT_REG(r8 , regs[7]);
 903   PRINT_REG(r9 , regs[6]);
 904   PRINT_REG(r10, regs[5]);
 905   PRINT_REG(r11, regs[4]);
 906   PRINT_REG(r12, regs[3]);
 907   PRINT_REG(r13, regs[2]);
 908   PRINT_REG(r14, regs[1]);
 909   PRINT_REG(r15, regs[0]);
 910 #undef PRINT_REG
 911   // Print some words near top of staack.
 912   int64_t* rsp = (int64_t*) regs[11];
 913   int64_t* dump_sp = rsp;
 914   for (int col1 = 0; col1 &lt; 8; col1++) {
 915     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 916     os::print_location(tty, *dump_sp++);
 917   }
 918   for (int row = 0; row &lt; 25; row++) {
 919     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 920     for (int col = 0; col &lt; 4; col++) {
 921       tty-&gt;print(&quot; 0x%016lx&quot;, (intptr_t)*dump_sp++);
 922     }
 923     tty-&gt;cr();
 924   }
 925   // Print some instructions around pc:
 926   Disassembler::decode((address)pc-64, (address)pc);
 927   tty-&gt;print_cr(&quot;--------&quot;);
 928   Disassembler::decode((address)pc, (address)pc+32);
 929 }
 930 
 931 #endif // _LP64
 932 
 933 // Now versions that are common to 32/64 bit
 934 
 935 void MacroAssembler::addptr(Register dst, int32_t imm32) {
 936   LP64_ONLY(addq(dst, imm32)) NOT_LP64(addl(dst, imm32));
 937 }
 938 
 939 void MacroAssembler::addptr(Register dst, Register src) {
 940   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 941 }
 942 
 943 void MacroAssembler::addptr(Address dst, Register src) {
 944   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 945 }
 946 
 947 void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {
 948   if (reachable(src)) {
 949     Assembler::addsd(dst, as_Address(src));
 950   } else {
 951     lea(rscratch1, src);
 952     Assembler::addsd(dst, Address(rscratch1, 0));
 953   }
 954 }
 955 
 956 void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {
 957   if (reachable(src)) {
 958     addss(dst, as_Address(src));
 959   } else {
 960     lea(rscratch1, src);
 961     addss(dst, Address(rscratch1, 0));
 962   }
 963 }
 964 
 965 void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {
 966   if (reachable(src)) {
 967     Assembler::addpd(dst, as_Address(src));
 968   } else {
 969     lea(rscratch1, src);
 970     Assembler::addpd(dst, Address(rscratch1, 0));
 971   }
 972 }
 973 
 974 void MacroAssembler::align(int modulus) {
 975   align(modulus, offset());
 976 }
 977 
 978 void MacroAssembler::align(int modulus, int target) {
 979   if (target % modulus != 0) {
 980     nop(modulus - (target % modulus));
 981   }
 982 }
 983 
 984 void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 985   // Used in sign-masking with aligned address.
 986   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 987   if (reachable(src)) {
 988     Assembler::andpd(dst, as_Address(src));
 989   } else {
 990     lea(scratch_reg, src);
 991     Assembler::andpd(dst, Address(scratch_reg, 0));
 992   }
 993 }
 994 
 995 void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 996   // Used in sign-masking with aligned address.
 997   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 998   if (reachable(src)) {
 999     Assembler::andps(dst, as_Address(src));
1000   } else {
1001     lea(scratch_reg, src);
1002     Assembler::andps(dst, Address(scratch_reg, 0));
1003   }
1004 }
1005 
1006 void MacroAssembler::andptr(Register dst, int32_t imm32) {
1007   LP64_ONLY(andq(dst, imm32)) NOT_LP64(andl(dst, imm32));
1008 }
1009 
1010 void MacroAssembler::atomic_incl(Address counter_addr) {
1011   lock();
1012   incrementl(counter_addr);
1013 }
1014 
1015 void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {
1016   if (reachable(counter_addr)) {
1017     atomic_incl(as_Address(counter_addr));
1018   } else {
1019     lea(scr, counter_addr);
1020     atomic_incl(Address(scr, 0));
1021   }
1022 }
1023 
1024 #ifdef _LP64
1025 void MacroAssembler::atomic_incq(Address counter_addr) {
1026   lock();
1027   incrementq(counter_addr);
1028 }
1029 
1030 void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {
1031   if (reachable(counter_addr)) {
1032     atomic_incq(as_Address(counter_addr));
1033   } else {
1034     lea(scr, counter_addr);
1035     atomic_incq(Address(scr, 0));
1036   }
1037 }
1038 #endif
1039 
1040 // Writes to stack successive pages until offset reached to check for
1041 // stack overflow + shadow pages.  This clobbers tmp.
1042 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
1043   movptr(tmp, rsp);
1044   // Bang stack for total size given plus shadow page size.
1045   // Bang one page at a time because large size can bang beyond yellow and
1046   // red zones.
1047   Label loop;
1048   bind(loop);
1049   movl(Address(tmp, (-os::vm_page_size())), size );
1050   subptr(tmp, os::vm_page_size());
1051   subl(size, os::vm_page_size());
1052   jcc(Assembler::greater, loop);
1053 
1054   // Bang down shadow pages too.
1055   // At this point, (tmp-0) is the last address touched, so don&#39;t
1056   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
1057   // was post-decremented.)  Skip this address by starting at i=1, and
1058   // touch a few more pages below.  N.B.  It is important to touch all
1059   // the way down including all pages in the shadow zone.
1060   for (int i = 1; i &lt; ((int)JavaThread::stack_shadow_zone_size() / os::vm_page_size()); i++) {
1061     // this could be any sized move but this is can be a debugging crumb
1062     // so the bigger the better.
1063     movptr(Address(tmp, (-i*os::vm_page_size())), size );
1064   }
1065 }
1066 
1067 void MacroAssembler::reserved_stack_check() {
1068     // testing if reserved zone needs to be enabled
1069     Label no_reserved_zone_enabling;
1070     Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
1071     NOT_LP64(get_thread(rsi);)
1072 
1073     cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));
1074     jcc(Assembler::below, no_reserved_zone_enabling);
1075 
1076     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);
1077     jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
1078     should_not_reach_here();
1079 
1080     bind(no_reserved_zone_enabling);
1081 }
1082 
1083 int MacroAssembler::biased_locking_enter(Register lock_reg,
1084                                          Register obj_reg,
1085                                          Register swap_reg,
1086                                          Register tmp_reg,
1087                                          Register tmp_reg2,
1088                                          bool swap_reg_contains_mark,
1089                                          Label&amp; done,
1090                                          Label* slow_case,
1091                                          BiasedLockingCounters* counters) {
1092   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1093   assert(swap_reg == rax, &quot;swap_reg must be rax for cmpxchgq&quot;);
1094   assert(tmp_reg != noreg, &quot;tmp_reg must be supplied&quot;);
1095   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);
1096   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
1097   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
1098   NOT_LP64( Address saved_mark_addr(lock_reg, 0); )
1099 
1100   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL) {
1101     counters = BiasedLocking::counters();
1102   }
1103   // Biased locking
1104   // See whether the lock is currently biased toward our thread and
1105   // whether the epoch is still valid
1106   // Note that the runtime guarantees sufficient alignment of JavaThread
1107   // pointers to allow age to be placed into low bits
1108   // First check to see whether biasing is even enabled for this object
1109   Label cas_label;
1110   int null_check_offset = -1;
1111   if (!swap_reg_contains_mark) {
1112     null_check_offset = offset();
1113     movptr(swap_reg, mark_addr);
1114   }
1115   movptr(tmp_reg, swap_reg);
1116   andptr(tmp_reg, markWord::biased_lock_mask_in_place);
1117   cmpptr(tmp_reg, markWord::biased_lock_pattern);
1118   jcc(Assembler::notEqual, cas_label);
1119   // The bias pattern is present in the object&#39;s header. Need to check
1120   // whether the bias owner and the epoch are both still current.
1121 #ifndef _LP64
1122   // Note that because there is no current thread register on x86_32 we
1123   // need to store off the mark word we read out of the object to
1124   // avoid reloading it and needing to recheck invariants below. This
1125   // store is unfortunate but it makes the overall code shorter and
1126   // simpler.
1127   movptr(saved_mark_addr, swap_reg);
1128 #endif
1129   if (swap_reg_contains_mark) {
1130     null_check_offset = offset();
1131   }
1132   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1133 #ifdef _LP64
1134   orptr(tmp_reg, r15_thread);
1135   xorptr(tmp_reg, swap_reg);
1136   Register header_reg = tmp_reg;
1137 #else
1138   xorptr(tmp_reg, swap_reg);
1139   get_thread(swap_reg);
1140   xorptr(swap_reg, tmp_reg);
1141   Register header_reg = swap_reg;
1142 #endif
1143   andptr(header_reg, ~((int) markWord::age_mask_in_place));
1144   if (counters != NULL) {
1145     cond_inc32(Assembler::zero,
1146                ExternalAddress((address) counters-&gt;biased_lock_entry_count_addr()));
1147   }
1148   jcc(Assembler::equal, done);
1149 
1150   Label try_revoke_bias;
1151   Label try_rebias;
1152 
1153   // At this point we know that the header has the bias pattern and
1154   // that we are not the bias owner in the current epoch. We need to
1155   // figure out more details about the state of the header in order to
1156   // know what operations can be legally performed on the object&#39;s
1157   // header.
1158 
1159   // If the low three bits in the xor result aren&#39;t clear, that means
1160   // the prototype header is no longer biased and we have to revoke
1161   // the bias on this object.
1162   testptr(header_reg, markWord::biased_lock_mask_in_place);
1163   jccb(Assembler::notZero, try_revoke_bias);
1164 
1165   // Biasing is still enabled for this data type. See whether the
1166   // epoch of the current bias is still valid, meaning that the epoch
1167   // bits of the mark word are equal to the epoch bits of the
1168   // prototype header. (Note that the prototype header&#39;s epoch bits
1169   // only change at a safepoint.) If not, attempt to rebias the object
1170   // toward the current thread. Note that we must be absolutely sure
1171   // that the current epoch is invalid in order to do this because
1172   // otherwise the manipulations it performs on the mark word are
1173   // illegal.
1174   testptr(header_reg, markWord::epoch_mask_in_place);
1175   jccb(Assembler::notZero, try_rebias);
1176 
1177   // The epoch of the current bias is still valid but we know nothing
1178   // about the owner; it might be set or it might be clear. Try to
1179   // acquire the bias of the object using an atomic operation. If this
1180   // fails we will go in to the runtime to revoke the object&#39;s bias.
1181   // Note that we first construct the presumed unbiased header so we
1182   // don&#39;t accidentally blow away another thread&#39;s valid bias.
1183   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1184   andptr(swap_reg,
1185          markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
1186 #ifdef _LP64
1187   movptr(tmp_reg, swap_reg);
1188   orptr(tmp_reg, r15_thread);
1189 #else
1190   get_thread(tmp_reg);
1191   orptr(tmp_reg, swap_reg);
1192 #endif
1193   lock();
1194   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1195   // If the biasing toward our thread failed, this means that
1196   // another thread succeeded in biasing it toward itself and we
1197   // need to revoke that bias. The revocation will occur in the
1198   // interpreter runtime in the slow case.
1199   if (counters != NULL) {
1200     cond_inc32(Assembler::zero,
1201                ExternalAddress((address) counters-&gt;anonymously_biased_lock_entry_count_addr()));
1202   }
1203   if (slow_case != NULL) {
1204     jcc(Assembler::notZero, *slow_case);
1205   }
1206   jmp(done);
1207 
1208   bind(try_rebias);
1209   // At this point we know the epoch has expired, meaning that the
1210   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
1211   // circumstances _only_, we are allowed to use the current header&#39;s
1212   // value as the comparison value when doing the cas to acquire the
1213   // bias in the current epoch. In other words, we allow transfer of
1214   // the bias from one thread to another directly in this situation.
1215   //
1216   // FIXME: due to a lack of registers we currently blow away the age
1217   // bits in this situation. Should attempt to preserve them.
1218   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1219 #ifdef _LP64
1220   orptr(tmp_reg, r15_thread);
1221 #else
1222   get_thread(swap_reg);
1223   orptr(tmp_reg, swap_reg);
1224   movptr(swap_reg, saved_mark_addr);
1225 #endif
1226   lock();
1227   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1228   // If the biasing toward our thread failed, then another thread
1229   // succeeded in biasing it toward itself and we need to revoke that
1230   // bias. The revocation will occur in the runtime in the slow case.
1231   if (counters != NULL) {
1232     cond_inc32(Assembler::zero,
1233                ExternalAddress((address) counters-&gt;rebiased_lock_entry_count_addr()));
1234   }
1235   if (slow_case != NULL) {
1236     jcc(Assembler::notZero, *slow_case);
1237   }
1238   jmp(done);
1239 
1240   bind(try_revoke_bias);
1241   // The prototype mark in the klass doesn&#39;t have the bias bit set any
1242   // more, indicating that objects of this data type are not supposed
1243   // to be biased any more. We are going to try to reset the mark of
1244   // this object to the prototype value and fall through to the
1245   // CAS-based locking scheme. Note that if our CAS fails, it means
1246   // that another thread raced us for the privilege of revoking the
1247   // bias of this particular object, so it&#39;s okay to continue in the
1248   // normal locking code.
1249   //
1250   // FIXME: due to a lack of registers we currently blow away the age
1251   // bits in this situation. Should attempt to preserve them.
1252   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1253   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1254   lock();
1255   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1256   // Fall through to the normal CAS-based lock, because no matter what
1257   // the result of the above CAS, some thread must have succeeded in
1258   // removing the bias bit from the object&#39;s header.
1259   if (counters != NULL) {
1260     cond_inc32(Assembler::zero,
1261                ExternalAddress((address) counters-&gt;revoked_lock_entry_count_addr()));
1262   }
1263 
1264   bind(cas_label);
1265 
1266   return null_check_offset;
1267 }
1268 
1269 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
1270   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1271 
1272   // Check for biased locking unlock case, which is a no-op
1273   // Note: we do not have to check the thread ID for two reasons.
1274   // First, the interpreter checks for IllegalMonitorStateException at
1275   // a higher level. Second, if the bias was revoked while we held the
1276   // lock, the object could not be rebiased toward another thread, so
1277   // the bias bit would be clear.
1278   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1279   andptr(temp_reg, markWord::biased_lock_mask_in_place);
1280   cmpptr(temp_reg, markWord::biased_lock_pattern);
1281   jcc(Assembler::equal, done);
1282 }
1283 
1284 void MacroAssembler::c2bool(Register x) {
1285   // implements x == 0 ? 0 : 1
1286   // note: must only look at least-significant byte of x
1287   //       since C-style booleans are stored in one byte
1288   //       only! (was bug)
1289   andl(x, 0xFF);
1290   setb(Assembler::notZero, x);
1291 }
1292 
1293 // Wouldn&#39;t need if AddressLiteral version had new name
1294 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
1295   Assembler::call(L, rtype);
1296 }
1297 
1298 void MacroAssembler::call(Register entry) {
1299   Assembler::call(entry);
1300 }
1301 
1302 void MacroAssembler::call(AddressLiteral entry) {
1303   if (reachable(entry)) {
1304     Assembler::call_literal(entry.target(), entry.rspec());
1305   } else {
1306     lea(rscratch1, entry);
1307     Assembler::call(rscratch1);
1308   }
1309 }
1310 
1311 void MacroAssembler::ic_call(address entry, jint method_index) {
1312   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
1313   movptr(rax, (intptr_t)Universe::non_oop_word());
1314   call(AddressLiteral(entry, rh));
1315 }
1316 
1317 // Implementation of call_VM versions
1318 
1319 void MacroAssembler::call_VM(Register oop_result,
1320                              address entry_point,
1321                              bool check_exceptions) {
1322   Label C, E;
1323   call(C, relocInfo::none);
1324   jmp(E);
1325 
1326   bind(C);
1327   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
1328   ret(0);
1329 
1330   bind(E);
1331 }
1332 
1333 void MacroAssembler::call_VM(Register oop_result,
1334                              address entry_point,
1335                              Register arg_1,
1336                              bool check_exceptions) {
1337   Label C, E;
1338   call(C, relocInfo::none);
1339   jmp(E);
1340 
1341   bind(C);
1342   pass_arg1(this, arg_1);
1343   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
1344   ret(0);
1345 
1346   bind(E);
1347 }
1348 
1349 void MacroAssembler::call_VM(Register oop_result,
1350                              address entry_point,
1351                              Register arg_1,
1352                              Register arg_2,
1353                              bool check_exceptions) {
1354   Label C, E;
1355   call(C, relocInfo::none);
1356   jmp(E);
1357 
1358   bind(C);
1359 
1360   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1361 
1362   pass_arg2(this, arg_2);
1363   pass_arg1(this, arg_1);
1364   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
1365   ret(0);
1366 
1367   bind(E);
1368 }
1369 
1370 void MacroAssembler::call_VM(Register oop_result,
1371                              address entry_point,
1372                              Register arg_1,
1373                              Register arg_2,
1374                              Register arg_3,
1375                              bool check_exceptions) {
1376   Label C, E;
1377   call(C, relocInfo::none);
1378   jmp(E);
1379 
1380   bind(C);
1381 
1382   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1383   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1384   pass_arg3(this, arg_3);
1385 
1386   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1387   pass_arg2(this, arg_2);
1388 
1389   pass_arg1(this, arg_1);
1390   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
1391   ret(0);
1392 
1393   bind(E);
1394 }
1395 
1396 void MacroAssembler::call_VM(Register oop_result,
1397                              Register last_java_sp,
1398                              address entry_point,
1399                              int number_of_arguments,
1400                              bool check_exceptions) {
1401   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1402   call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1403 }
1404 
1405 void MacroAssembler::call_VM(Register oop_result,
1406                              Register last_java_sp,
1407                              address entry_point,
1408                              Register arg_1,
1409                              bool check_exceptions) {
1410   pass_arg1(this, arg_1);
1411   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1412 }
1413 
1414 void MacroAssembler::call_VM(Register oop_result,
1415                              Register last_java_sp,
1416                              address entry_point,
1417                              Register arg_1,
1418                              Register arg_2,
1419                              bool check_exceptions) {
1420 
1421   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1422   pass_arg2(this, arg_2);
1423   pass_arg1(this, arg_1);
1424   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1425 }
1426 
1427 void MacroAssembler::call_VM(Register oop_result,
1428                              Register last_java_sp,
1429                              address entry_point,
1430                              Register arg_1,
1431                              Register arg_2,
1432                              Register arg_3,
1433                              bool check_exceptions) {
1434   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1435   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1436   pass_arg3(this, arg_3);
1437   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1438   pass_arg2(this, arg_2);
1439   pass_arg1(this, arg_1);
1440   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1441 }
1442 
1443 void MacroAssembler::super_call_VM(Register oop_result,
1444                                    Register last_java_sp,
1445                                    address entry_point,
1446                                    int number_of_arguments,
1447                                    bool check_exceptions) {
1448   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1449   MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1450 }
1451 
1452 void MacroAssembler::super_call_VM(Register oop_result,
1453                                    Register last_java_sp,
1454                                    address entry_point,
1455                                    Register arg_1,
1456                                    bool check_exceptions) {
1457   pass_arg1(this, arg_1);
1458   super_call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1459 }
1460 
1461 void MacroAssembler::super_call_VM(Register oop_result,
1462                                    Register last_java_sp,
1463                                    address entry_point,
1464                                    Register arg_1,
1465                                    Register arg_2,
1466                                    bool check_exceptions) {
1467 
1468   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1469   pass_arg2(this, arg_2);
1470   pass_arg1(this, arg_1);
1471   super_call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1472 }
1473 
1474 void MacroAssembler::super_call_VM(Register oop_result,
1475                                    Register last_java_sp,
1476                                    address entry_point,
1477                                    Register arg_1,
1478                                    Register arg_2,
1479                                    Register arg_3,
1480                                    bool check_exceptions) {
1481   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1482   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1483   pass_arg3(this, arg_3);
1484   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1485   pass_arg2(this, arg_2);
1486   pass_arg1(this, arg_1);
1487   super_call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1488 }
1489 
1490 void MacroAssembler::call_VM_base(Register oop_result,
1491                                   Register java_thread,
1492                                   Register last_java_sp,
1493                                   address  entry_point,
1494                                   int      number_of_arguments,
1495                                   bool     check_exceptions) {
1496   // determine java_thread register
1497   if (!java_thread-&gt;is_valid()) {
1498 #ifdef _LP64
1499     java_thread = r15_thread;
1500 #else
1501     java_thread = rdi;
1502     get_thread(java_thread);
1503 #endif // LP64
1504   }
1505   // determine last_java_sp register
1506   if (!last_java_sp-&gt;is_valid()) {
1507     last_java_sp = rsp;
1508   }
1509   // debugging support
1510   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
1511   LP64_ONLY(assert(java_thread == r15_thread, &quot;unexpected register&quot;));
1512 #ifdef ASSERT
1513   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
1514   // r12 is the heapbase.
1515   LP64_ONLY(if (UseCompressedOops &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);)
1516 #endif // ASSERT
1517 
1518   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
1519   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
1520 
1521   // push java thread (becomes first argument of C function)
1522 
1523   NOT_LP64(push(java_thread); number_of_arguments++);
1524   LP64_ONLY(mov(c_rarg0, r15_thread));
1525 
1526   // set last Java frame before call
1527   assert(last_java_sp != rbp, &quot;can&#39;t use ebp/rbp&quot;);
1528 
1529   // Only interpreter should have to set fp
1530   set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);
1531 
1532   // do the call, remove parameters
1533   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments);
1534 
1535   // restore the thread (cannot use the pushed argument since arguments
1536   // may be overwritten by C code generated by an optimizing compiler);
1537   // however can use the register value directly if it is callee saved.
1538   if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {
1539     // rdi &amp; rsi (also r15) are callee saved -&gt; nothing to do
1540 #ifdef ASSERT
1541     guarantee(java_thread != rax, &quot;change this code&quot;);
1542     push(rax);
1543     { Label L;
1544       get_thread(rax);
1545       cmpptr(java_thread, rax);
1546       jcc(Assembler::equal, L);
1547       STOP(&quot;MacroAssembler::call_VM_base: rdi not callee saved?&quot;);
1548       bind(L);
1549     }
1550     pop(rax);
1551 #endif
1552   } else {
1553     get_thread(java_thread);
1554   }
1555   // reset last Java frame
1556   // Only interpreter should have to clear fp
1557   reset_last_Java_frame(java_thread, true);
1558 
1559    // C++ interp handles this in the interpreter
1560   check_and_handle_popframe(java_thread);
1561   check_and_handle_earlyret(java_thread);
1562 
1563   if (check_exceptions) {
1564     // check for pending exceptions (java_thread is set upon return)
1565     cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
1566 #ifndef _LP64
1567     jump_cc(Assembler::notEqual,
1568             RuntimeAddress(StubRoutines::forward_exception_entry()));
1569 #else
1570     // This used to conditionally jump to forward_exception however it is
1571     // possible if we relocate that the branch will not reach. So we must jump
1572     // around so we can always reach
1573 
1574     Label ok;
1575     jcc(Assembler::equal, ok);
1576     jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
1577     bind(ok);
1578 #endif // LP64
1579   }
1580 
1581   // get oop result if there is one and reset the value in the thread
1582   if (oop_result-&gt;is_valid()) {
1583     get_vm_result(oop_result, java_thread);
1584   }
1585 }
1586 
1587 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
1588 
1589   // Calculate the value for last_Java_sp
1590   // somewhat subtle. call_VM does an intermediate call
1591   // which places a return address on the stack just under the
1592   // stack pointer as the user finsihed with it. This allows
1593   // use to retrieve last_Java_pc from last_Java_sp[-1].
1594   // On 32bit we then have to push additional args on the stack to accomplish
1595   // the actual requested call. On 64bit call_VM only can use register args
1596   // so the only extra space is the return address that call_VM created.
1597   // This hopefully explains the calculations here.
1598 
1599 #ifdef _LP64
1600   // We&#39;ve pushed one address, correct last_Java_sp
1601   lea(rax, Address(rsp, wordSize));
1602 #else
1603   lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));
1604 #endif // LP64
1605 
1606   call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);
1607 
1608 }
1609 
1610 // Use this method when MacroAssembler version of call_VM_leaf_base() should be called from Interpreter.
1611 void MacroAssembler::call_VM_leaf0(address entry_point) {
1612   MacroAssembler::call_VM_leaf_base(entry_point, 0);
1613 }
1614 
1615 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1616   call_VM_leaf_base(entry_point, number_of_arguments);
1617 }
1618 
1619 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1620   pass_arg0(this, arg_0);
1621   call_VM_leaf(entry_point, 1);
1622 }
1623 
1624 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1625 
1626   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1627   pass_arg1(this, arg_1);
1628   pass_arg0(this, arg_0);
1629   call_VM_leaf(entry_point, 2);
1630 }
1631 
1632 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1633   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1634   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1635   pass_arg2(this, arg_2);
1636   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1637   pass_arg1(this, arg_1);
1638   pass_arg0(this, arg_0);
1639   call_VM_leaf(entry_point, 3);
1640 }
1641 
1642 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1643   pass_arg0(this, arg_0);
1644   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1645 }
1646 
1647 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1648 
1649   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1650   pass_arg1(this, arg_1);
1651   pass_arg0(this, arg_0);
1652   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1653 }
1654 
1655 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1656   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1657   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1658   pass_arg2(this, arg_2);
1659   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1660   pass_arg1(this, arg_1);
1661   pass_arg0(this, arg_0);
1662   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1663 }
1664 
1665 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1666   LP64_ONLY(assert(arg_0 != c_rarg3, &quot;smashed arg&quot;));
1667   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1668   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1669   pass_arg3(this, arg_3);
1670   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1671   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1672   pass_arg2(this, arg_2);
1673   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1674   pass_arg1(this, arg_1);
1675   pass_arg0(this, arg_0);
1676   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1677 }
1678 
1679 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
1680   movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
1681   movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);
1682   verify_oop_msg(oop_result, &quot;broken oop in call_VM_base&quot;);
1683 }
1684 
1685 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
1686   movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
1687   movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);
1688 }
1689 
1690 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
1691 }
1692 
1693 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
1694 }
1695 
1696 void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {
1697   if (reachable(src1)) {
1698     cmpl(as_Address(src1), imm);
1699   } else {
1700     lea(rscratch1, src1);
1701     cmpl(Address(rscratch1, 0), imm);
1702   }
1703 }
1704 
1705 void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {
1706   assert(!src2.is_lval(), &quot;use cmpptr&quot;);
1707   if (reachable(src2)) {
1708     cmpl(src1, as_Address(src2));
1709   } else {
1710     lea(rscratch1, src2);
1711     cmpl(src1, Address(rscratch1, 0));
1712   }
1713 }
1714 
1715 void MacroAssembler::cmp32(Register src1, int32_t imm) {
1716   Assembler::cmpl(src1, imm);
1717 }
1718 
1719 void MacroAssembler::cmp32(Register src1, Address src2) {
1720   Assembler::cmpl(src1, src2);
1721 }
1722 
1723 void MacroAssembler::cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1724   ucomisd(opr1, opr2);
1725 
1726   Label L;
1727   if (unordered_is_less) {
1728     movl(dst, -1);
1729     jcc(Assembler::parity, L);
1730     jcc(Assembler::below , L);
1731     movl(dst, 0);
1732     jcc(Assembler::equal , L);
1733     increment(dst);
1734   } else { // unordered is greater
1735     movl(dst, 1);
1736     jcc(Assembler::parity, L);
1737     jcc(Assembler::above , L);
1738     movl(dst, 0);
1739     jcc(Assembler::equal , L);
1740     decrementl(dst);
1741   }
1742   bind(L);
1743 }
1744 
1745 void MacroAssembler::cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1746   ucomiss(opr1, opr2);
1747 
1748   Label L;
1749   if (unordered_is_less) {
1750     movl(dst, -1);
1751     jcc(Assembler::parity, L);
1752     jcc(Assembler::below , L);
1753     movl(dst, 0);
1754     jcc(Assembler::equal , L);
1755     increment(dst);
1756   } else { // unordered is greater
1757     movl(dst, 1);
1758     jcc(Assembler::parity, L);
1759     jcc(Assembler::above , L);
1760     movl(dst, 0);
1761     jcc(Assembler::equal , L);
1762     decrementl(dst);
1763   }
1764   bind(L);
1765 }
1766 
1767 
1768 void MacroAssembler::cmp8(AddressLiteral src1, int imm) {
1769   if (reachable(src1)) {
1770     cmpb(as_Address(src1), imm);
1771   } else {
1772     lea(rscratch1, src1);
1773     cmpb(Address(rscratch1, 0), imm);
1774   }
1775 }
1776 
1777 void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {
1778 #ifdef _LP64
1779   if (src2.is_lval()) {
1780     movptr(rscratch1, src2);
1781     Assembler::cmpq(src1, rscratch1);
1782   } else if (reachable(src2)) {
1783     cmpq(src1, as_Address(src2));
1784   } else {
1785     lea(rscratch1, src2);
1786     Assembler::cmpq(src1, Address(rscratch1, 0));
1787   }
1788 #else
1789   if (src2.is_lval()) {
1790     cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1791   } else {
1792     cmpl(src1, as_Address(src2));
1793   }
1794 #endif // _LP64
1795 }
1796 
1797 void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {
1798   assert(src2.is_lval(), &quot;not a mem-mem compare&quot;);
1799 #ifdef _LP64
1800   // moves src2&#39;s literal address
1801   movptr(rscratch1, src2);
1802   Assembler::cmpq(src1, rscratch1);
1803 #else
1804   cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1805 #endif // _LP64
1806 }
1807 
1808 void MacroAssembler::cmpoop(Register src1, Register src2) {
1809   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1810   bs-&gt;obj_equals(this, src1, src2);
1811 }
1812 
1813 void MacroAssembler::cmpoop(Register src1, Address src2) {
1814   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1815   bs-&gt;obj_equals(this, src1, src2);
1816 }
1817 
1818 #ifdef _LP64
1819 void MacroAssembler::cmpoop(Register src1, jobject src2) {
1820   movoop(rscratch1, src2);
1821   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1822   bs-&gt;obj_equals(this, src1, rscratch1);
1823 }
1824 #endif
1825 
1826 void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {
1827   if (reachable(adr)) {
1828     lock();
1829     cmpxchgptr(reg, as_Address(adr));
1830   } else {
1831     lea(rscratch1, adr);
1832     lock();
1833     cmpxchgptr(reg, Address(rscratch1, 0));
1834   }
1835 }
1836 
1837 void MacroAssembler::cmpxchgptr(Register reg, Address adr) {
1838   LP64_ONLY(cmpxchgq(reg, adr)) NOT_LP64(cmpxchgl(reg, adr));
1839 }
1840 
1841 void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {
1842   if (reachable(src)) {
1843     Assembler::comisd(dst, as_Address(src));
1844   } else {
1845     lea(rscratch1, src);
1846     Assembler::comisd(dst, Address(rscratch1, 0));
1847   }
1848 }
1849 
1850 void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {
1851   if (reachable(src)) {
1852     Assembler::comiss(dst, as_Address(src));
1853   } else {
1854     lea(rscratch1, src);
1855     Assembler::comiss(dst, Address(rscratch1, 0));
1856   }
1857 }
1858 
1859 
1860 void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {
1861   Condition negated_cond = negate_condition(cond);
1862   Label L;
1863   jcc(negated_cond, L);
1864   pushf(); // Preserve flags
1865   atomic_incl(counter_addr);
1866   popf();
1867   bind(L);
1868 }
1869 
1870 int MacroAssembler::corrected_idivl(Register reg) {
1871   // Full implementation of Java idiv and irem; checks for
1872   // special case as described in JVM spec., p.243 &amp; p.271.
1873   // The function returns the (pc) offset of the idivl
1874   // instruction - may be needed for implicit exceptions.
1875   //
1876   //         normal case                           special case
1877   //
1878   // input : rax,: dividend                         min_int
1879   //         reg: divisor   (may not be rax,/rdx)   -1
1880   //
1881   // output: rax,: quotient  (= rax, idiv reg)       min_int
1882   //         rdx: remainder (= rax, irem reg)       0
1883   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax, or rdx register&quot;);
1884   const int min_int = 0x80000000;
1885   Label normal_case, special_case;
1886 
1887   // check for special case
1888   cmpl(rax, min_int);
1889   jcc(Assembler::notEqual, normal_case);
1890   xorl(rdx, rdx); // prepare rdx for possible special case (where remainder = 0)
1891   cmpl(reg, -1);
1892   jcc(Assembler::equal, special_case);
1893 
1894   // handle normal case
1895   bind(normal_case);
1896   cdql();
1897   int idivl_offset = offset();
1898   idivl(reg);
1899 
1900   // normal and special case exit
1901   bind(special_case);
1902 
1903   return idivl_offset;
1904 }
1905 
1906 
1907 
1908 void MacroAssembler::decrementl(Register reg, int value) {
1909   if (value == min_jint) {subl(reg, value) ; return; }
1910   if (value &lt;  0) { incrementl(reg, -value); return; }
1911   if (value == 0) {                        ; return; }
1912   if (value == 1 &amp;&amp; UseIncDec) { decl(reg) ; return; }
1913   /* else */      { subl(reg, value)       ; return; }
1914 }
1915 
1916 void MacroAssembler::decrementl(Address dst, int value) {
1917   if (value == min_jint) {subl(dst, value) ; return; }
1918   if (value &lt;  0) { incrementl(dst, -value); return; }
1919   if (value == 0) {                        ; return; }
1920   if (value == 1 &amp;&amp; UseIncDec) { decl(dst) ; return; }
1921   /* else */      { subl(dst, value)       ; return; }
1922 }
1923 
1924 void MacroAssembler::division_with_shift (Register reg, int shift_value) {
1925   assert (shift_value &gt; 0, &quot;illegal shift value&quot;);
1926   Label _is_positive;
1927   testl (reg, reg);
1928   jcc (Assembler::positive, _is_positive);
1929   int offset = (1 &lt;&lt; shift_value) - 1 ;
1930 
1931   if (offset == 1) {
1932     incrementl(reg);
1933   } else {
1934     addl(reg, offset);
1935   }
1936 
1937   bind (_is_positive);
1938   sarl(reg, shift_value);
1939 }
1940 
1941 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
1942   if (reachable(src)) {
1943     Assembler::divsd(dst, as_Address(src));
1944   } else {
1945     lea(rscratch1, src);
1946     Assembler::divsd(dst, Address(rscratch1, 0));
1947   }
1948 }
1949 
1950 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
1951   if (reachable(src)) {
1952     Assembler::divss(dst, as_Address(src));
1953   } else {
1954     lea(rscratch1, src);
1955     Assembler::divss(dst, Address(rscratch1, 0));
1956   }
1957 }
1958 
1959 void MacroAssembler::enter() {
1960   push(rbp);
1961   mov(rbp, rsp);
1962 }
1963 
1964 // A 5 byte nop that is safe for patching (see patch_verified_entry)
1965 void MacroAssembler::fat_nop() {
1966   if (UseAddressNop) {
1967     addr_nop_5();
1968   } else {
1969     emit_int8(0x26); // es:
1970     emit_int8(0x2e); // cs:
1971     emit_int8(0x64); // fs:
1972     emit_int8(0x65); // gs:
1973     emit_int8((unsigned char)0x90);
1974   }
1975 }
1976 
1977 #ifndef _LP64
1978 void MacroAssembler::fcmp(Register tmp) {
1979   fcmp(tmp, 1, true, true);
1980 }
1981 
1982 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
1983   assert(!pop_right || pop_left, &quot;usage error&quot;);
1984   if (VM_Version::supports_cmov()) {
1985     assert(tmp == noreg, &quot;unneeded temp&quot;);
1986     if (pop_left) {
1987       fucomip(index);
1988     } else {
1989       fucomi(index);
1990     }
1991     if (pop_right) {
1992       fpop();
1993     }
1994   } else {
1995     assert(tmp != noreg, &quot;need temp&quot;);
1996     if (pop_left) {
1997       if (pop_right) {
1998         fcompp();
1999       } else {
2000         fcomp(index);
2001       }
2002     } else {
2003       fcom(index);
2004     }
2005     // convert FPU condition into eflags condition via rax,
2006     save_rax(tmp);
2007     fwait(); fnstsw_ax();
2008     sahf();
2009     restore_rax(tmp);
2010   }
2011   // condition codes set as follows:
2012   //
2013   // CF (corresponds to C0) if x &lt; y
2014   // PF (corresponds to C2) if unordered
2015   // ZF (corresponds to C3) if x = y
2016 }
2017 
2018 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {
2019   fcmp2int(dst, unordered_is_less, 1, true, true);
2020 }
2021 
2022 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {
2023   fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);
2024   Label L;
2025   if (unordered_is_less) {
2026     movl(dst, -1);
2027     jcc(Assembler::parity, L);
2028     jcc(Assembler::below , L);
2029     movl(dst, 0);
2030     jcc(Assembler::equal , L);
2031     increment(dst);
2032   } else { // unordered is greater
2033     movl(dst, 1);
2034     jcc(Assembler::parity, L);
2035     jcc(Assembler::above , L);
2036     movl(dst, 0);
2037     jcc(Assembler::equal , L);
2038     decrementl(dst);
2039   }
2040   bind(L);
2041 }
2042 
2043 void MacroAssembler::fld_d(AddressLiteral src) {
2044   fld_d(as_Address(src));
2045 }
2046 
2047 void MacroAssembler::fld_s(AddressLiteral src) {
2048   fld_s(as_Address(src));
2049 }
2050 
2051 void MacroAssembler::fld_x(AddressLiteral src) {
2052   Assembler::fld_x(as_Address(src));
2053 }
2054 
2055 void MacroAssembler::fldcw(AddressLiteral src) {
2056   Assembler::fldcw(as_Address(src));
2057 }
2058 
2059 void MacroAssembler::fpop() {
2060   ffree();
2061   fincstp();
2062 }
2063 
2064 void MacroAssembler::fremr(Register tmp) {
2065   save_rax(tmp);
2066   { Label L;
2067     bind(L);
2068     fprem();
2069     fwait(); fnstsw_ax();
2070     sahf();
2071     jcc(Assembler::parity, L);
2072   }
2073   restore_rax(tmp);
2074   // Result is in ST0.
2075   // Note: fxch &amp; fpop to get rid of ST1
2076   // (otherwise FPU stack could overflow eventually)
2077   fxch(1);
2078   fpop();
2079 }
2080 
2081 void MacroAssembler::empty_FPU_stack() {
2082   if (VM_Version::supports_mmx()) {
2083     emms();
2084   } else {
2085     for (int i = 8; i-- &gt; 0; ) ffree(i);
2086   }
2087 }
2088 #endif // !LP64
2089 
2090 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
2091   if (reachable(src)) {
2092     Assembler::mulpd(dst, as_Address(src));
2093   } else {
2094     lea(rscratch1, src);
2095     Assembler::mulpd(dst, Address(rscratch1, 0));
2096   }
2097 }
2098 
2099 void MacroAssembler::load_float(Address src) {
2100 #ifdef _LP64
2101   movflt(xmm0, src);
2102 #else
2103   if (UseSSE &gt;= 1) {
2104     movflt(xmm0, src);
2105   } else {
2106     fld_s(src);
2107   }
2108 #endif // LP64
2109 }
2110 
2111 void MacroAssembler::store_float(Address dst) {
2112 #ifdef _LP64
2113   movflt(dst, xmm0);
2114 #else
2115   if (UseSSE &gt;= 1) {
2116     movflt(dst, xmm0);
2117   } else {
2118     fstp_s(dst);
2119   }
2120 #endif // LP64
2121 }
2122 
2123 void MacroAssembler::load_double(Address src) {
2124 #ifdef _LP64
2125   movdbl(xmm0, src);
2126 #else
2127   if (UseSSE &gt;= 2) {
2128     movdbl(xmm0, src);
2129   } else {
2130     fld_d(src);
2131   }
2132 #endif // LP64
2133 }
2134 
2135 void MacroAssembler::store_double(Address dst) {
2136 #ifdef _LP64
2137   movdbl(dst, xmm0);
2138 #else
2139   if (UseSSE &gt;= 2) {
2140     movdbl(dst, xmm0);
2141   } else {
2142     fstp_d(dst);
2143   }
2144 #endif // LP64
2145 }
2146 
2147 // dst = c = a * b + c
2148 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2149   Assembler::vfmadd231sd(c, a, b);
2150   if (dst != c) {
2151     movdbl(dst, c);
2152   }
2153 }
2154 
2155 // dst = c = a * b + c
2156 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2157   Assembler::vfmadd231ss(c, a, b);
2158   if (dst != c) {
2159     movflt(dst, c);
2160   }
2161 }
2162 
2163 // dst = c = a * b + c
2164 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2165   Assembler::vfmadd231pd(c, a, b, vector_len);
2166   if (dst != c) {
2167     vmovdqu(dst, c);
2168   }
2169 }
2170 
2171 // dst = c = a * b + c
2172 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2173   Assembler::vfmadd231ps(c, a, b, vector_len);
2174   if (dst != c) {
2175     vmovdqu(dst, c);
2176   }
2177 }
2178 
2179 // dst = c = a * b + c
2180 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2181   Assembler::vfmadd231pd(c, a, b, vector_len);
2182   if (dst != c) {
2183     vmovdqu(dst, c);
2184   }
2185 }
2186 
2187 // dst = c = a * b + c
2188 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2189   Assembler::vfmadd231ps(c, a, b, vector_len);
2190   if (dst != c) {
2191     vmovdqu(dst, c);
2192   }
2193 }
2194 
2195 void MacroAssembler::incrementl(AddressLiteral dst) {
2196   if (reachable(dst)) {
2197     incrementl(as_Address(dst));
2198   } else {
2199     lea(rscratch1, dst);
2200     incrementl(Address(rscratch1, 0));
2201   }
2202 }
2203 
2204 void MacroAssembler::incrementl(ArrayAddress dst) {
2205   incrementl(as_Address(dst));
2206 }
2207 
2208 void MacroAssembler::incrementl(Register reg, int value) {
2209   if (value == min_jint) {addl(reg, value) ; return; }
2210   if (value &lt;  0) { decrementl(reg, -value); return; }
2211   if (value == 0) {                        ; return; }
2212   if (value == 1 &amp;&amp; UseIncDec) { incl(reg) ; return; }
2213   /* else */      { addl(reg, value)       ; return; }
2214 }
2215 
2216 void MacroAssembler::incrementl(Address dst, int value) {
2217   if (value == min_jint) {addl(dst, value) ; return; }
2218   if (value &lt;  0) { decrementl(dst, -value); return; }
2219   if (value == 0) {                        ; return; }
2220   if (value == 1 &amp;&amp; UseIncDec) { incl(dst) ; return; }
2221   /* else */      { addl(dst, value)       ; return; }
2222 }
2223 
2224 void MacroAssembler::jump(AddressLiteral dst) {
2225   if (reachable(dst)) {
2226     jmp_literal(dst.target(), dst.rspec());
2227   } else {
2228     lea(rscratch1, dst);
2229     jmp(rscratch1);
2230   }
2231 }
2232 
2233 void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {
2234   if (reachable(dst)) {
2235     InstructionMark im(this);
2236     relocate(dst.reloc());
2237     const int short_size = 2;
2238     const int long_size = 6;
2239     int offs = (intptr_t)dst.target() - ((intptr_t)pc());
2240     if (dst.reloc() == relocInfo::none &amp;&amp; is8bit(offs - short_size)) {
2241       // 0111 tttn #8-bit disp
2242       emit_int8(0x70 | cc);
2243       emit_int8((offs - short_size) &amp; 0xFF);
2244     } else {
2245       // 0000 1111 1000 tttn #32-bit disp
2246       emit_int8(0x0F);
2247       emit_int8((unsigned char)(0x80 | cc));
2248       emit_int32(offs - long_size);
2249     }
2250   } else {
2251 #ifdef ASSERT
2252     warning(&quot;reversing conditional branch&quot;);
2253 #endif /* ASSERT */
2254     Label skip;
2255     jccb(reverse[cc], skip);
2256     lea(rscratch1, dst);
2257     Assembler::jmp(rscratch1);
2258     bind(skip);
2259   }
2260 }
2261 
2262 void MacroAssembler::ldmxcsr(AddressLiteral src) {
2263   if (reachable(src)) {
2264     Assembler::ldmxcsr(as_Address(src));
2265   } else {
2266     lea(rscratch1, src);
2267     Assembler::ldmxcsr(Address(rscratch1, 0));
2268   }
2269 }
2270 
2271 int MacroAssembler::load_signed_byte(Register dst, Address src) {
2272   int off;
2273   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2274     off = offset();
2275     movsbl(dst, src); // movsxb
2276   } else {
2277     off = load_unsigned_byte(dst, src);
2278     shll(dst, 24);
2279     sarl(dst, 24);
2280   }
2281   return off;
2282 }
2283 
2284 // Note: load_signed_short used to be called load_signed_word.
2285 // Although the &#39;w&#39; in x86 opcodes refers to the term &quot;word&quot; in the assembler
2286 // manual, which means 16 bits, that usage is found nowhere in HotSpot code.
2287 // The term &quot;word&quot; in HotSpot means a 32- or 64-bit machine word.
2288 int MacroAssembler::load_signed_short(Register dst, Address src) {
2289   int off;
2290   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2291     // This is dubious to me since it seems safe to do a signed 16 =&gt; 64 bit
2292     // version but this is what 64bit has always done. This seems to imply
2293     // that users are only using 32bits worth.
2294     off = offset();
2295     movswl(dst, src); // movsxw
2296   } else {
2297     off = load_unsigned_short(dst, src);
2298     shll(dst, 16);
2299     sarl(dst, 16);
2300   }
2301   return off;
2302 }
2303 
2304 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
2305   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2306   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2307   int off;
2308   if (LP64_ONLY(true || ) VM_Version::is_P6() || src.uses(dst)) {
2309     off = offset();
2310     movzbl(dst, src); // movzxb
2311   } else {
2312     xorl(dst, dst);
2313     off = offset();
2314     movb(dst, src);
2315   }
2316   return off;
2317 }
2318 
2319 // Note: load_unsigned_short used to be called load_unsigned_word.
2320 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
2321   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2322   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2323   int off;
2324   if (LP64_ONLY(true ||) VM_Version::is_P6() || src.uses(dst)) {
2325     off = offset();
2326     movzwl(dst, src); // movzxw
2327   } else {
2328     xorl(dst, dst);
2329     off = offset();
2330     movw(dst, src);
2331   }
2332   return off;
2333 }
2334 
2335 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
2336   switch (size_in_bytes) {
2337 #ifndef _LP64
2338   case  8:
2339     assert(dst2 != noreg, &quot;second dest register required&quot;);
2340     movl(dst,  src);
2341     movl(dst2, src.plus_disp(BytesPerInt));
2342     break;
2343 #else
2344   case  8:  movq(dst, src); break;
2345 #endif
2346   case  4:  movl(dst, src); break;
2347   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
2348   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
2349   default:  ShouldNotReachHere();
2350   }
2351 }
2352 
2353 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
2354   switch (size_in_bytes) {
2355 #ifndef _LP64
2356   case  8:
2357     assert(src2 != noreg, &quot;second source register required&quot;);
2358     movl(dst,                        src);
2359     movl(dst.plus_disp(BytesPerInt), src2);
2360     break;
2361 #else
2362   case  8:  movq(dst, src); break;
2363 #endif
2364   case  4:  movl(dst, src); break;
2365   case  2:  movw(dst, src); break;
2366   case  1:  movb(dst, src); break;
2367   default:  ShouldNotReachHere();
2368   }
2369 }
2370 
2371 void MacroAssembler::mov32(AddressLiteral dst, Register src) {
2372   if (reachable(dst)) {
2373     movl(as_Address(dst), src);
2374   } else {
2375     lea(rscratch1, dst);
2376     movl(Address(rscratch1, 0), src);
2377   }
2378 }
2379 
2380 void MacroAssembler::mov32(Register dst, AddressLiteral src) {
2381   if (reachable(src)) {
2382     movl(dst, as_Address(src));
2383   } else {
2384     lea(rscratch1, src);
2385     movl(dst, Address(rscratch1, 0));
2386   }
2387 }
2388 
2389 // C++ bool manipulation
2390 
2391 void MacroAssembler::movbool(Register dst, Address src) {
2392   if(sizeof(bool) == 1)
2393     movb(dst, src);
2394   else if(sizeof(bool) == 2)
2395     movw(dst, src);
2396   else if(sizeof(bool) == 4)
2397     movl(dst, src);
2398   else
2399     // unsupported
2400     ShouldNotReachHere();
2401 }
2402 
2403 void MacroAssembler::movbool(Address dst, bool boolconst) {
2404   if(sizeof(bool) == 1)
2405     movb(dst, (int) boolconst);
2406   else if(sizeof(bool) == 2)
2407     movw(dst, (int) boolconst);
2408   else if(sizeof(bool) == 4)
2409     movl(dst, (int) boolconst);
2410   else
2411     // unsupported
2412     ShouldNotReachHere();
2413 }
2414 
2415 void MacroAssembler::movbool(Address dst, Register src) {
2416   if(sizeof(bool) == 1)
2417     movb(dst, src);
2418   else if(sizeof(bool) == 2)
2419     movw(dst, src);
2420   else if(sizeof(bool) == 4)
2421     movl(dst, src);
2422   else
2423     // unsupported
2424     ShouldNotReachHere();
2425 }
2426 
2427 void MacroAssembler::movbyte(ArrayAddress dst, int src) {
2428   movb(as_Address(dst), src);
2429 }
2430 
2431 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
2432   if (reachable(src)) {
2433     movdl(dst, as_Address(src));
2434   } else {
2435     lea(rscratch1, src);
2436     movdl(dst, Address(rscratch1, 0));
2437   }
2438 }
2439 
2440 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
2441   if (reachable(src)) {
2442     movq(dst, as_Address(src));
2443   } else {
2444     lea(rscratch1, src);
2445     movq(dst, Address(rscratch1, 0));
2446   }
2447 }
2448 
2449 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
2450   if (reachable(src)) {
2451     if (UseXmmLoadAndClearUpper) {
2452       movsd (dst, as_Address(src));
2453     } else {
2454       movlpd(dst, as_Address(src));
2455     }
2456   } else {
2457     lea(rscratch1, src);
2458     if (UseXmmLoadAndClearUpper) {
2459       movsd (dst, Address(rscratch1, 0));
2460     } else {
2461       movlpd(dst, Address(rscratch1, 0));
2462     }
2463   }
2464 }
2465 
2466 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
2467   if (reachable(src)) {
2468     movss(dst, as_Address(src));
2469   } else {
2470     lea(rscratch1, src);
2471     movss(dst, Address(rscratch1, 0));
2472   }
2473 }
2474 
2475 void MacroAssembler::movptr(Register dst, Register src) {
2476   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2477 }
2478 
2479 void MacroAssembler::movptr(Register dst, Address src) {
2480   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2481 }
2482 
2483 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
2484 void MacroAssembler::movptr(Register dst, intptr_t src) {
2485   LP64_ONLY(mov64(dst, src)) NOT_LP64(movl(dst, src));
2486 }
2487 
2488 void MacroAssembler::movptr(Address dst, Register src) {
2489   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2490 }
2491 
2492 void MacroAssembler::movdqu(Address dst, XMMRegister src) {
2493     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2494     Assembler::movdqu(dst, src);
2495 }
2496 
2497 void MacroAssembler::movdqu(XMMRegister dst, Address src) {
2498     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2499     Assembler::movdqu(dst, src);
2500 }
2501 
2502 void MacroAssembler::movdqu(XMMRegister dst, XMMRegister src) {
2503     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2504     Assembler::movdqu(dst, src);
2505 }
2506 
2507 void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {
2508   if (reachable(src)) {
2509     movdqu(dst, as_Address(src));
2510   } else {
2511     lea(scratchReg, src);
2512     movdqu(dst, Address(scratchReg, 0));
2513   }
2514 }
2515 
2516 void MacroAssembler::vmovdqu(Address dst, XMMRegister src) {
2517     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2518     Assembler::vmovdqu(dst, src);
2519 }
2520 
2521 void MacroAssembler::vmovdqu(XMMRegister dst, Address src) {
2522     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2523     Assembler::vmovdqu(dst, src);
2524 }
2525 
2526 void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2527     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2528     Assembler::vmovdqu(dst, src);
2529 }
2530 
2531 void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2532   if (reachable(src)) {
2533     vmovdqu(dst, as_Address(src));
2534   }
2535   else {
2536     lea(scratch_reg, src);
2537     vmovdqu(dst, Address(scratch_reg, 0));
2538   }
2539 }
2540 
2541 void MacroAssembler::evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {
2542   if (reachable(src)) {
2543     Assembler::evmovdquq(dst, as_Address(src), vector_len);
2544   } else {
2545     lea(rscratch, src);
2546     Assembler::evmovdquq(dst, Address(rscratch, 0), vector_len);
2547   }
2548 }
2549 
2550 void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {
2551   if (reachable(src)) {
2552     Assembler::movdqa(dst, as_Address(src));
2553   } else {
2554     lea(rscratch1, src);
2555     Assembler::movdqa(dst, Address(rscratch1, 0));
2556   }
2557 }
2558 
2559 void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {
2560   if (reachable(src)) {
2561     Assembler::movsd(dst, as_Address(src));
2562   } else {
2563     lea(rscratch1, src);
2564     Assembler::movsd(dst, Address(rscratch1, 0));
2565   }
2566 }
2567 
2568 void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {
2569   if (reachable(src)) {
2570     Assembler::movss(dst, as_Address(src));
2571   } else {
2572     lea(rscratch1, src);
2573     Assembler::movss(dst, Address(rscratch1, 0));
2574   }
2575 }
2576 
2577 void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {
2578   if (reachable(src)) {
2579     Assembler::mulsd(dst, as_Address(src));
2580   } else {
2581     lea(rscratch1, src);
2582     Assembler::mulsd(dst, Address(rscratch1, 0));
2583   }
2584 }
2585 
2586 void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {
2587   if (reachable(src)) {
2588     Assembler::mulss(dst, as_Address(src));
2589   } else {
2590     lea(rscratch1, src);
2591     Assembler::mulss(dst, Address(rscratch1, 0));
2592   }
2593 }
2594 
2595 void MacroAssembler::null_check(Register reg, int offset) {
2596   if (needs_explicit_null_check(offset)) {
2597     // provoke OS NULL exception if reg = NULL by
2598     // accessing M[reg] w/o changing any (non-CC) registers
2599     // NOTE: cmpl is plenty here to provoke a segv
2600     cmpptr(rax, Address(reg, 0));
2601     // Note: should probably use testl(rax, Address(reg, 0));
2602     //       may be shorter code (however, this version of
2603     //       testl needs to be implemented first)
2604   } else {
2605     // nothing to do, (later) access of M[reg + offset]
2606     // will provoke OS NULL exception if reg = NULL
2607   }
2608 }
2609 
2610 void MacroAssembler::os_breakpoint() {
2611   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
2612   // (e.g., MSVC can&#39;t call ps() otherwise)
2613   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
2614 }
2615 
2616 void MacroAssembler::unimplemented(const char* what) {
2617   const char* buf = NULL;
2618   {
2619     ResourceMark rm;
2620     stringStream ss;
2621     ss.print(&quot;unimplemented: %s&quot;, what);
2622     buf = code_string(ss.as_string());
2623   }
2624   stop(buf);
2625 }
2626 
2627 #ifdef _LP64
2628 #define XSTATE_BV 0x200
2629 #endif
2630 
2631 void MacroAssembler::pop_CPU_state() {
2632   pop_FPU_state();
2633   pop_IU_state();
2634 }
2635 
2636 void MacroAssembler::pop_FPU_state() {
2637 #ifndef _LP64
2638   frstor(Address(rsp, 0));
2639 #else
2640   fxrstor(Address(rsp, 0));
2641 #endif
2642   addptr(rsp, FPUStateSizeInWords * wordSize);
2643 }
2644 
2645 void MacroAssembler::pop_IU_state() {
2646   popa();
2647   LP64_ONLY(addq(rsp, 8));
2648   popf();
2649 }
2650 
2651 // Save Integer and Float state
2652 // Warning: Stack must be 16 byte aligned (64bit)
2653 void MacroAssembler::push_CPU_state() {
2654   push_IU_state();
2655   push_FPU_state();
2656 }
2657 
2658 void MacroAssembler::push_FPU_state() {
2659   subptr(rsp, FPUStateSizeInWords * wordSize);
2660 #ifndef _LP64
2661   fnsave(Address(rsp, 0));
2662   fwait();
2663 #else
2664   fxsave(Address(rsp, 0));
2665 #endif // LP64
2666 }
2667 
2668 void MacroAssembler::push_IU_state() {
2669   // Push flags first because pusha kills them
2670   pushf();
2671   // Make sure rsp stays 16-byte aligned
2672   LP64_ONLY(subq(rsp, 8));
2673   pusha();
2674 }
2675 
2676 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
2677   if (!java_thread-&gt;is_valid()) {
2678     java_thread = rdi;
2679     get_thread(java_thread);
2680   }
2681   // we must set sp to zero to clear frame
2682   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
2683   if (clear_fp) {
2684     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
2685   }
2686 
2687   // Always clear the pc because it could have been set by make_walkable()
2688   movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
2689 
2690   vzeroupper();
2691 }
2692 
2693 void MacroAssembler::restore_rax(Register tmp) {
2694   if (tmp == noreg) pop(rax);
2695   else if (tmp != rax) mov(rax, tmp);
2696 }
2697 
2698 void MacroAssembler::round_to(Register reg, int modulus) {
2699   addptr(reg, modulus - 1);
2700   andptr(reg, -modulus);
2701 }
2702 
2703 void MacroAssembler::save_rax(Register tmp) {
2704   if (tmp == noreg) push(rax);
2705   else if (tmp != rax) mov(tmp, rax);
2706 }
2707 
2708 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
2709 #ifdef _LP64
2710   assert(thread_reg == r15_thread, &quot;should be&quot;);
2711 #else
2712   if (thread_reg == noreg) {
2713     thread_reg = temp_reg;
2714     get_thread(thread_reg);
2715   }
2716 #endif
2717   testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2718   jcc(Assembler::notZero, slow_path); // handshake bit set implies poll
2719 }
2720 
2721 // Calls to C land
2722 //
2723 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
2724 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
2725 // has to be reset to 0. This is required to allow proper stack traversal.
2726 void MacroAssembler::set_last_Java_frame(Register java_thread,
2727                                          Register last_java_sp,
2728                                          Register last_java_fp,
2729                                          address  last_java_pc) {
2730   vzeroupper();
2731   // determine java_thread register
2732   if (!java_thread-&gt;is_valid()) {
2733     java_thread = rdi;
2734     get_thread(java_thread);
2735   }
2736   // determine last_java_sp register
2737   if (!last_java_sp-&gt;is_valid()) {
2738     last_java_sp = rsp;
2739   }
2740 
2741   // last_java_fp is optional
2742 
2743   if (last_java_fp-&gt;is_valid()) {
2744     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);
2745   }
2746 
2747   // last_java_pc is optional
2748 
2749   if (last_java_pc != NULL) {
2750     lea(Address(java_thread,
2751                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),
2752         InternalAddress(last_java_pc));
2753 
2754   }
2755   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
2756 }
2757 
2758 void MacroAssembler::shlptr(Register dst, int imm8) {
2759   LP64_ONLY(shlq(dst, imm8)) NOT_LP64(shll(dst, imm8));
2760 }
2761 
2762 void MacroAssembler::shrptr(Register dst, int imm8) {
2763   LP64_ONLY(shrq(dst, imm8)) NOT_LP64(shrl(dst, imm8));
2764 }
2765 
2766 void MacroAssembler::sign_extend_byte(Register reg) {
2767   if (LP64_ONLY(true ||) (VM_Version::is_P6() &amp;&amp; reg-&gt;has_byte_register())) {
2768     movsbl(reg, reg); // movsxb
2769   } else {
2770     shll(reg, 24);
2771     sarl(reg, 24);
2772   }
2773 }
2774 
2775 void MacroAssembler::sign_extend_short(Register reg) {
2776   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2777     movswl(reg, reg); // movsxw
2778   } else {
2779     shll(reg, 16);
2780     sarl(reg, 16);
2781   }
2782 }
2783 
2784 void MacroAssembler::testl(Register dst, AddressLiteral src) {
2785   assert(reachable(src), &quot;Address should be reachable&quot;);
2786   testl(dst, as_Address(src));
2787 }
2788 
2789 void MacroAssembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
2790   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2791   Assembler::pcmpeqb(dst, src);
2792 }
2793 
2794 void MacroAssembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
2795   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2796   Assembler::pcmpeqw(dst, src);
2797 }
2798 
2799 void MacroAssembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
2800   assert((dst-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2801   Assembler::pcmpestri(dst, src, imm8);
2802 }
2803 
2804 void MacroAssembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
2805   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2806   Assembler::pcmpestri(dst, src, imm8);
2807 }
2808 
2809 void MacroAssembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
2810   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2811   Assembler::pmovzxbw(dst, src);
2812 }
2813 
2814 void MacroAssembler::pmovzxbw(XMMRegister dst, Address src) {
2815   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2816   Assembler::pmovzxbw(dst, src);
2817 }
2818 
2819 void MacroAssembler::pmovmskb(Register dst, XMMRegister src) {
2820   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2821   Assembler::pmovmskb(dst, src);
2822 }
2823 
2824 void MacroAssembler::ptest(XMMRegister dst, XMMRegister src) {
2825   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2826   Assembler::ptest(dst, src);
2827 }
2828 
2829 void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {
2830   if (reachable(src)) {
2831     Assembler::sqrtsd(dst, as_Address(src));
2832   } else {
2833     lea(rscratch1, src);
2834     Assembler::sqrtsd(dst, Address(rscratch1, 0));
2835   }
2836 }
2837 
2838 void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {
2839   if (reachable(src)) {
2840     Assembler::sqrtss(dst, as_Address(src));
2841   } else {
2842     lea(rscratch1, src);
2843     Assembler::sqrtss(dst, Address(rscratch1, 0));
2844   }
2845 }
2846 
2847 void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {
2848   if (reachable(src)) {
2849     Assembler::subsd(dst, as_Address(src));
2850   } else {
2851     lea(rscratch1, src);
2852     Assembler::subsd(dst, Address(rscratch1, 0));
2853   }
2854 }
2855 
2856 void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {
2857   if (reachable(src)) {
2858     Assembler::roundsd(dst, as_Address(src), rmode);
2859   } else {
2860     lea(scratch_reg, src);
2861     Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);
2862   }
2863 }
2864 
2865 void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {
2866   if (reachable(src)) {
2867     Assembler::subss(dst, as_Address(src));
2868   } else {
2869     lea(rscratch1, src);
2870     Assembler::subss(dst, Address(rscratch1, 0));
2871   }
2872 }
2873 
2874 void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {
2875   if (reachable(src)) {
2876     Assembler::ucomisd(dst, as_Address(src));
2877   } else {
2878     lea(rscratch1, src);
2879     Assembler::ucomisd(dst, Address(rscratch1, 0));
2880   }
2881 }
2882 
2883 void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {
2884   if (reachable(src)) {
2885     Assembler::ucomiss(dst, as_Address(src));
2886   } else {
2887     lea(rscratch1, src);
2888     Assembler::ucomiss(dst, Address(rscratch1, 0));
2889   }
2890 }
2891 
2892 void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2893   // Used in sign-bit flipping with aligned address.
2894   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2895   if (reachable(src)) {
2896     Assembler::xorpd(dst, as_Address(src));
2897   } else {
2898     lea(scratch_reg, src);
2899     Assembler::xorpd(dst, Address(scratch_reg, 0));
2900   }
2901 }
2902 
2903 void MacroAssembler::xorpd(XMMRegister dst, XMMRegister src) {
2904   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
2905     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
2906   }
2907   else {
2908     Assembler::xorpd(dst, src);
2909   }
2910 }
2911 
2912 void MacroAssembler::xorps(XMMRegister dst, XMMRegister src) {
2913   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
2914     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
2915   } else {
2916     Assembler::xorps(dst, src);
2917   }
2918 }
2919 
2920 void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2921   // Used in sign-bit flipping with aligned address.
2922   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2923   if (reachable(src)) {
2924     Assembler::xorps(dst, as_Address(src));
2925   } else {
2926     lea(scratch_reg, src);
2927     Assembler::xorps(dst, Address(scratch_reg, 0));
2928   }
2929 }
2930 
2931 void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {
2932   // Used in sign-bit flipping with aligned address.
2933   bool aligned_adr = (((intptr_t)src.target() &amp; 15) == 0);
2934   assert((UseAVX &gt; 0) || aligned_adr, &quot;SSE mode requires address alignment 16 bytes&quot;);
2935   if (reachable(src)) {
2936     Assembler::pshufb(dst, as_Address(src));
2937   } else {
2938     lea(rscratch1, src);
2939     Assembler::pshufb(dst, Address(rscratch1, 0));
2940   }
2941 }
2942 
2943 // AVX 3-operands instructions
2944 
2945 void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
2946   if (reachable(src)) {
2947     vaddsd(dst, nds, as_Address(src));
2948   } else {
2949     lea(rscratch1, src);
2950     vaddsd(dst, nds, Address(rscratch1, 0));
2951   }
2952 }
2953 
2954 void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
2955   if (reachable(src)) {
2956     vaddss(dst, nds, as_Address(src));
2957   } else {
2958     lea(rscratch1, src);
2959     vaddss(dst, nds, Address(rscratch1, 0));
2960   }
2961 }
2962 
2963 void MacroAssembler::vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {
2964   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
2965   if (reachable(src)) {
2966     Assembler::vpaddd(dst, nds, as_Address(src), vector_len);
2967   } else {
2968     lea(rscratch, src);
2969     Assembler::vpaddd(dst, nds, Address(rscratch, 0), vector_len);
2970   }
2971 }
2972 
2973 void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
2974   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
2975   vandps(dst, nds, negate_field, vector_len);
2976 }
2977 
2978 void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
2979   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
2980   vandpd(dst, nds, negate_field, vector_len);
2981 }
2982 
2983 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
2984   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2985   Assembler::vpaddb(dst, nds, src, vector_len);
2986 }
2987 
2988 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
2989   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2990   Assembler::vpaddb(dst, nds, src, vector_len);
2991 }
2992 
2993 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
2994   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2995   Assembler::vpaddw(dst, nds, src, vector_len);
2996 }
2997 
2998 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
2999   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3000   Assembler::vpaddw(dst, nds, src, vector_len);
3001 }
3002 
3003 void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3004   if (reachable(src)) {
3005     Assembler::vpand(dst, nds, as_Address(src), vector_len);
3006   } else {
3007     lea(scratch_reg, src);
3008     Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);
3009   }
3010 }
3011 
3012 void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
3013   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3014   Assembler::vpbroadcastw(dst, src, vector_len);
3015 }
3016 
3017 void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3018   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3019   Assembler::vpcmpeqb(dst, nds, src, vector_len);
3020 }
3021 
3022 void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3023   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3024   Assembler::vpcmpeqw(dst, nds, src, vector_len);
3025 }
3026 
3027 void MacroAssembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3028   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3029   Assembler::vpmovzxbw(dst, src, vector_len);
3030 }
3031 
3032 void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {
3033   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3034   Assembler::vpmovmskb(dst, src);
3035 }
3036 
3037 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3038   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3039   Assembler::vpmullw(dst, nds, src, vector_len);
3040 }
3041 
3042 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3043   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3044   Assembler::vpmullw(dst, nds, src, vector_len);
3045 }
3046 
3047 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3048   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3049   Assembler::vpsubb(dst, nds, src, vector_len);
3050 }
3051 
3052 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3053   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3054   Assembler::vpsubb(dst, nds, src, vector_len);
3055 }
3056 
3057 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3058   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3059   Assembler::vpsubw(dst, nds, src, vector_len);
3060 }
3061 
3062 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3063   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3064   Assembler::vpsubw(dst, nds, src, vector_len);
3065 }
3066 
3067 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3068   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3069   Assembler::vpsraw(dst, nds, shift, vector_len);
3070 }
3071 
3072 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3073   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3074   Assembler::vpsraw(dst, nds, shift, vector_len);
3075 }
3076 
3077 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3078   assert(UseAVX &gt; 2,&quot;&quot;);
3079   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3080      vector_len = 2;
3081   }
3082   Assembler::evpsraq(dst, nds, shift, vector_len);
3083 }
3084 
3085 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3086   assert(UseAVX &gt; 2,&quot;&quot;);
3087   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3088      vector_len = 2;
3089   }
3090   Assembler::evpsraq(dst, nds, shift, vector_len);
3091 }
3092 
3093 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3094   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3095   Assembler::vpsrlw(dst, nds, shift, vector_len);
3096 }
3097 
3098 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3099   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3100   Assembler::vpsrlw(dst, nds, shift, vector_len);
3101 }
3102 
3103 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3104   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3105   Assembler::vpsllw(dst, nds, shift, vector_len);
3106 }
3107 
3108 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3109   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3110   Assembler::vpsllw(dst, nds, shift, vector_len);
3111 }
3112 
3113 void MacroAssembler::vptest(XMMRegister dst, XMMRegister src) {
3114   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3115   Assembler::vptest(dst, src);
3116 }
3117 
3118 void MacroAssembler::punpcklbw(XMMRegister dst, XMMRegister src) {
3119   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3120   Assembler::punpcklbw(dst, src);
3121 }
3122 
3123 void MacroAssembler::pshufd(XMMRegister dst, Address src, int mode) {
3124   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
3125   Assembler::pshufd(dst, src, mode);
3126 }
3127 
3128 void MacroAssembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
3129   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3130   Assembler::pshuflw(dst, src, mode);
3131 }
3132 
3133 void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3134   if (reachable(src)) {
3135     vandpd(dst, nds, as_Address(src), vector_len);
3136   } else {
3137     lea(scratch_reg, src);
3138     vandpd(dst, nds, Address(scratch_reg, 0), vector_len);
3139   }
3140 }
3141 
3142 void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3143   if (reachable(src)) {
3144     vandps(dst, nds, as_Address(src), vector_len);
3145   } else {
3146     lea(scratch_reg, src);
3147     vandps(dst, nds, Address(scratch_reg, 0), vector_len);
3148   }
3149 }
3150 
3151 void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3152   if (reachable(src)) {
3153     vdivsd(dst, nds, as_Address(src));
3154   } else {
3155     lea(rscratch1, src);
3156     vdivsd(dst, nds, Address(rscratch1, 0));
3157   }
3158 }
3159 
3160 void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3161   if (reachable(src)) {
3162     vdivss(dst, nds, as_Address(src));
3163   } else {
3164     lea(rscratch1, src);
3165     vdivss(dst, nds, Address(rscratch1, 0));
3166   }
3167 }
3168 
3169 void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3170   if (reachable(src)) {
3171     vmulsd(dst, nds, as_Address(src));
3172   } else {
3173     lea(rscratch1, src);
3174     vmulsd(dst, nds, Address(rscratch1, 0));
3175   }
3176 }
3177 
3178 void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3179   if (reachable(src)) {
3180     vmulss(dst, nds, as_Address(src));
3181   } else {
3182     lea(rscratch1, src);
3183     vmulss(dst, nds, Address(rscratch1, 0));
3184   }
3185 }
3186 
3187 void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3188   if (reachable(src)) {
3189     vsubsd(dst, nds, as_Address(src));
3190   } else {
3191     lea(rscratch1, src);
3192     vsubsd(dst, nds, Address(rscratch1, 0));
3193   }
3194 }
3195 
3196 void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3197   if (reachable(src)) {
3198     vsubss(dst, nds, as_Address(src));
3199   } else {
3200     lea(rscratch1, src);
3201     vsubss(dst, nds, Address(rscratch1, 0));
3202   }
3203 }
3204 
3205 void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3206   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3207   vxorps(dst, nds, src, Assembler::AVX_128bit);
3208 }
3209 
3210 void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3211   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3212   vxorpd(dst, nds, src, Assembler::AVX_128bit);
3213 }
3214 
3215 void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3216   if (reachable(src)) {
3217     vxorpd(dst, nds, as_Address(src), vector_len);
3218   } else {
3219     lea(scratch_reg, src);
3220     vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);
3221   }
3222 }
3223 
3224 void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3225   if (reachable(src)) {
3226     vxorps(dst, nds, as_Address(src), vector_len);
3227   } else {
3228     lea(scratch_reg, src);
3229     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
3230   }
3231 }
3232 
3233 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3234   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
3235     if (reachable(src)) {
3236       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
3237     } else {
3238       lea(scratch_reg, src);
3239       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
3240     }
3241   }
3242   else {
3243     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
3244   }
3245 }
3246 
3247 //-------------------------------------------------------------------------------------------
3248 
3249 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
3250   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
3251   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
3252   // The inverted mask is sign-extended
3253   andptr(possibly_jweak, inverted_jweak_mask);
3254 }
3255 
3256 void MacroAssembler::resolve_jobject(Register value,
3257                                      Register thread,
3258                                      Register tmp) {
3259   assert_different_registers(value, thread, tmp);
3260   Label done, not_weak;
3261   testptr(value, value);
3262   jcc(Assembler::zero, done);                // Use NULL as-is.
3263   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
3264   jcc(Assembler::zero, not_weak);
3265   // Resolve jweak.
3266   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3267                  value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);
3268   verify_oop(value);
3269   jmp(done);
3270   bind(not_weak);
3271   // Resolve (untagged) jobject.
3272   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
3273   verify_oop(value);
3274   bind(done);
3275 }
3276 
3277 void MacroAssembler::subptr(Register dst, int32_t imm32) {
3278   LP64_ONLY(subq(dst, imm32)) NOT_LP64(subl(dst, imm32));
3279 }
3280 
3281 // Force generation of a 4 byte immediate value even if it fits into 8bit
3282 void MacroAssembler::subptr_imm32(Register dst, int32_t imm32) {
3283   LP64_ONLY(subq_imm32(dst, imm32)) NOT_LP64(subl_imm32(dst, imm32));
3284 }
3285 
3286 void MacroAssembler::subptr(Register dst, Register src) {
3287   LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src));
3288 }
3289 
3290 // C++ bool manipulation
3291 void MacroAssembler::testbool(Register dst) {
3292   if(sizeof(bool) == 1)
3293     testb(dst, 0xff);
3294   else if(sizeof(bool) == 2) {
3295     // testw implementation needed for two byte bools
3296     ShouldNotReachHere();
3297   } else if(sizeof(bool) == 4)
3298     testl(dst, dst);
3299   else
3300     // unsupported
3301     ShouldNotReachHere();
3302 }
3303 
3304 void MacroAssembler::testptr(Register dst, Register src) {
3305   LP64_ONLY(testq(dst, src)) NOT_LP64(testl(dst, src));
3306 }
3307 
3308 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
3309 void MacroAssembler::tlab_allocate(Register thread, Register obj,
3310                                    Register var_size_in_bytes,
3311                                    int con_size_in_bytes,
3312                                    Register t1,
3313                                    Register t2,
3314                                    Label&amp; slow_case) {
3315   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3316   bs-&gt;tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
3317 }
3318 
3319 // Defines obj, preserves var_size_in_bytes
3320 void MacroAssembler::eden_allocate(Register thread, Register obj,
3321                                    Register var_size_in_bytes,
3322                                    int con_size_in_bytes,
3323                                    Register t1,
3324                                    Label&amp; slow_case) {
3325   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3326   bs-&gt;eden_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
3327 }
3328 
3329 // Preserves the contents of address, destroys the contents length_in_bytes and temp.
3330 void MacroAssembler::zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp) {
3331   assert(address != length_in_bytes &amp;&amp; address != temp &amp;&amp; temp != length_in_bytes, &quot;registers must be different&quot;);
3332   assert((offset_in_bytes &amp; (BytesPerWord - 1)) == 0, &quot;offset must be a multiple of BytesPerWord&quot;);
3333   Label done;
3334 
3335   testptr(length_in_bytes, length_in_bytes);
3336   jcc(Assembler::zero, done);
3337 
3338   // initialize topmost word, divide index by 2, check if odd and test if zero
3339   // note: for the remaining code to work, index must be a multiple of BytesPerWord
3340 #ifdef ASSERT
3341   {
3342     Label L;
3343     testptr(length_in_bytes, BytesPerWord - 1);
3344     jcc(Assembler::zero, L);
3345     stop(&quot;length must be a multiple of BytesPerWord&quot;);
3346     bind(L);
3347   }
3348 #endif
3349   Register index = length_in_bytes;
3350   xorptr(temp, temp);    // use _zero reg to clear memory (shorter code)
3351   if (UseIncDec) {
3352     shrptr(index, 3);  // divide by 8/16 and set carry flag if bit 2 was set
3353   } else {
3354     shrptr(index, 2);  // use 2 instructions to avoid partial flag stall
3355     shrptr(index, 1);
3356   }
3357 #ifndef _LP64
3358   // index could have not been a multiple of 8 (i.e., bit 2 was set)
3359   {
3360     Label even;
3361     // note: if index was a multiple of 8, then it cannot
3362     //       be 0 now otherwise it must have been 0 before
3363     //       =&gt; if it is even, we don&#39;t need to check for 0 again
3364     jcc(Assembler::carryClear, even);
3365     // clear topmost word (no jump would be needed if conditional assignment worked here)
3366     movptr(Address(address, index, Address::times_8, offset_in_bytes - 0*BytesPerWord), temp);
3367     // index could be 0 now, must check again
3368     jcc(Assembler::zero, done);
3369     bind(even);
3370   }
3371 #endif // !_LP64
3372   // initialize remaining object fields: index is a multiple of 2 now
3373   {
3374     Label loop;
3375     bind(loop);
3376     movptr(Address(address, index, Address::times_8, offset_in_bytes - 1*BytesPerWord), temp);
3377     NOT_LP64(movptr(Address(address, index, Address::times_8, offset_in_bytes - 2*BytesPerWord), temp);)
3378     decrement(index);
3379     jcc(Assembler::notZero, loop);
3380   }
3381 
3382   bind(done);
3383 }
3384 
3385 // Look up the method for a megamorphic invokeinterface call.
3386 // The target method is determined by &lt;intf_klass, itable_index&gt;.
3387 // The receiver klass is in recv_klass.
3388 // On success, the result will be in method_result, and execution falls through.
3389 // On failure, execution transfers to the given label.
3390 void MacroAssembler::lookup_interface_method(Register recv_klass,
3391                                              Register intf_klass,
3392                                              RegisterOrConstant itable_index,
3393                                              Register method_result,
3394                                              Register scan_temp,
3395                                              Label&amp; L_no_such_interface,
3396                                              bool return_method) {
3397   assert_different_registers(recv_klass, intf_klass, scan_temp);
3398   assert_different_registers(method_result, intf_klass, scan_temp);
3399   assert(recv_klass != method_result || !return_method,
3400          &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
3401 
3402   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
3403          &quot;caller must use same register for non-constant itable index as for method&quot;);
3404 
3405   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
3406   int vtable_base = in_bytes(Klass::vtable_start_offset());
3407   int itentry_off = itableMethodEntry::method_offset_in_bytes();
3408   int scan_step   = itableOffsetEntry::size() * wordSize;
3409   int vte_size    = vtableEntry::size_in_bytes();
3410   Address::ScaleFactor times_vte_scale = Address::times_ptr;
3411   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
3412 
3413   movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
3414 
3415   // %%% Could store the aligned, prescaled offset in the klassoop.
3416   lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
3417 
3418   if (return_method) {
3419     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
3420     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
3421     lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
3422   }
3423 
3424   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
3425   //   if (scan-&gt;interface() == intf) {
3426   //     result = (klass + scan-&gt;offset() + itable_index);
3427   //   }
3428   // }
3429   Label search, found_method;
3430 
3431   for (int peel = 1; peel &gt;= 0; peel--) {
3432     movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
3433     cmpptr(intf_klass, method_result);
3434 
3435     if (peel) {
3436       jccb(Assembler::equal, found_method);
3437     } else {
3438       jccb(Assembler::notEqual, search);
3439       // (invert the test to fall through to found_method...)
3440     }
3441 
3442     if (!peel)  break;
3443 
3444     bind(search);
3445 
3446     // Check that the previous entry is non-null.  A null entry means that
3447     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
3448     // same as when the caller was compiled.
3449     testptr(method_result, method_result);
3450     jcc(Assembler::zero, L_no_such_interface);
3451     addptr(scan_temp, scan_step);
3452   }
3453 
3454   bind(found_method);
3455 
3456   if (return_method) {
3457     // Got a hit.
3458     movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
3459     movptr(method_result, Address(recv_klass, scan_temp, Address::times_1));
3460   }
3461 }
3462 
3463 
3464 // virtual method calling
3465 void MacroAssembler::lookup_virtual_method(Register recv_klass,
3466                                            RegisterOrConstant vtable_index,
3467                                            Register method_result) {
3468   const int base = in_bytes(Klass::vtable_start_offset());
3469   assert(vtableEntry::size() * wordSize == wordSize, &quot;else adjust the scaling in the code below&quot;);
3470   Address vtable_entry_addr(recv_klass,
3471                             vtable_index, Address::times_ptr,
3472                             base + vtableEntry::method_offset_in_bytes());
3473   movptr(method_result, vtable_entry_addr);
3474 }
3475 
3476 
3477 void MacroAssembler::check_klass_subtype(Register sub_klass,
3478                            Register super_klass,
3479                            Register temp_reg,
3480                            Label&amp; L_success) {
3481   Label L_failure;
3482   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
3483   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
3484   bind(L_failure);
3485 }
3486 
3487 
3488 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
3489                                                    Register super_klass,
3490                                                    Register temp_reg,
3491                                                    Label* L_success,
3492                                                    Label* L_failure,
3493                                                    Label* L_slow_path,
3494                                         RegisterOrConstant super_check_offset) {
3495   assert_different_registers(sub_klass, super_klass, temp_reg);
3496   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
3497   if (super_check_offset.is_register()) {
3498     assert_different_registers(sub_klass, super_klass,
3499                                super_check_offset.as_register());
3500   } else if (must_load_sco) {
3501     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
3502   }
3503 
3504   Label L_fallthrough;
3505   int label_nulls = 0;
3506   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3507   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3508   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
3509   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3510 
3511   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3512   int sco_offset = in_bytes(Klass::super_check_offset_offset());
3513   Address super_check_offset_addr(super_klass, sco_offset);
3514 
3515   // Hacked jcc, which &quot;knows&quot; that L_fallthrough, at least, is in
3516   // range of a jccb.  If this routine grows larger, reconsider at
3517   // least some of these.
3518 #define local_jcc(assembler_cond, label)                                \
3519   if (&amp;(label) == &amp;L_fallthrough)  jccb(assembler_cond, label);         \
3520   else                             jcc( assembler_cond, label) /*omit semi*/
3521 
3522   // Hacked jmp, which may only be used just before L_fallthrough.
3523 #define final_jmp(label)                                                \
3524   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3525   else                            jmp(label)                /*omit semi*/
3526 
3527   // If the pointers are equal, we are done (e.g., String[] elements).
3528   // This self-check enables sharing of secondary supertype arrays among
3529   // non-primary types such as array-of-interface.  Otherwise, each such
3530   // type would need its own customized SSA.
3531   // We move this check to the front of the fast path because many
3532   // type checks are in fact trivially successful in this manner,
3533   // so we get a nicely predicted branch right at the start of the check.
3534   cmpptr(sub_klass, super_klass);
3535   local_jcc(Assembler::equal, *L_success);
3536 
3537   // Check the supertype display:
3538   if (must_load_sco) {
3539     // Positive movl does right thing on LP64.
3540     movl(temp_reg, super_check_offset_addr);
3541     super_check_offset = RegisterOrConstant(temp_reg);
3542   }
3543   Address super_check_addr(sub_klass, super_check_offset, Address::times_1, 0);
3544   cmpptr(super_klass, super_check_addr); // load displayed supertype
3545 
3546   // This check has worked decisively for primary supers.
3547   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
3548   // (Secondary supers are interfaces and very deeply nested subtypes.)
3549   // This works in the same check above because of a tricky aliasing
3550   // between the super_cache and the primary super display elements.
3551   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3552   // Note that the cache is updated below if it does not help us find
3553   // what we need immediately.
3554   // So if it was a primary super, we can just fail immediately.
3555   // Otherwise, it&#39;s the slow path for us (no success at this point).
3556 
3557   if (super_check_offset.is_register()) {
3558     local_jcc(Assembler::equal, *L_success);
3559     cmpl(super_check_offset.as_register(), sc_offset);
3560     if (L_failure == &amp;L_fallthrough) {
3561       local_jcc(Assembler::equal, *L_slow_path);
3562     } else {
3563       local_jcc(Assembler::notEqual, *L_failure);
3564       final_jmp(*L_slow_path);
3565     }
3566   } else if (super_check_offset.as_constant() == sc_offset) {
3567     // Need a slow path; fast failure is impossible.
3568     if (L_slow_path == &amp;L_fallthrough) {
3569       local_jcc(Assembler::equal, *L_success);
3570     } else {
3571       local_jcc(Assembler::notEqual, *L_slow_path);
3572       final_jmp(*L_success);
3573     }
3574   } else {
3575     // No slow path; it&#39;s a fast decision.
3576     if (L_failure == &amp;L_fallthrough) {
3577       local_jcc(Assembler::equal, *L_success);
3578     } else {
3579       local_jcc(Assembler::notEqual, *L_failure);
3580       final_jmp(*L_success);
3581     }
3582   }
3583 
3584   bind(L_fallthrough);
3585 
3586 #undef local_jcc
3587 #undef final_jmp
3588 }
3589 
3590 
3591 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
3592                                                    Register super_klass,
3593                                                    Register temp_reg,
3594                                                    Register temp2_reg,
3595                                                    Label* L_success,
3596                                                    Label* L_failure,
3597                                                    bool set_cond_codes) {
3598   assert_different_registers(sub_klass, super_klass, temp_reg);
3599   if (temp2_reg != noreg)
3600     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg);
3601 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
3602 
3603   Label L_fallthrough;
3604   int label_nulls = 0;
3605   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3606   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3607   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3608 
3609   // a couple of useful fields in sub_klass:
3610   int ss_offset = in_bytes(Klass::secondary_supers_offset());
3611   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3612   Address secondary_supers_addr(sub_klass, ss_offset);
3613   Address super_cache_addr(     sub_klass, sc_offset);
3614 
3615   // Do a linear scan of the secondary super-klass chain.
3616   // This code is rarely used, so simplicity is a virtue here.
3617   // The repne_scan instruction uses fixed registers, which we must spill.
3618   // Don&#39;t worry too much about pre-existing connections with the input regs.
3619 
3620   assert(sub_klass != rax, &quot;killed reg&quot;); // killed by mov(rax, super)
3621   assert(sub_klass != rcx, &quot;killed reg&quot;); // killed by lea(rcx, &amp;pst_counter)
3622 
3623   // Get super_klass value into rax (even if it was in rdi or rcx).
3624   bool pushed_rax = false, pushed_rcx = false, pushed_rdi = false;
3625   if (super_klass != rax || UseCompressedOops) {
3626     if (!IS_A_TEMP(rax)) { push(rax); pushed_rax = true; }
3627     mov(rax, super_klass);
3628   }
3629   if (!IS_A_TEMP(rcx)) { push(rcx); pushed_rcx = true; }
3630   if (!IS_A_TEMP(rdi)) { push(rdi); pushed_rdi = true; }
3631 
3632 #ifndef PRODUCT
3633   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
3634   ExternalAddress pst_counter_addr((address) pst_counter);
3635   NOT_LP64(  incrementl(pst_counter_addr) );
3636   LP64_ONLY( lea(rcx, pst_counter_addr) );
3637   LP64_ONLY( incrementl(Address(rcx, 0)) );
3638 #endif //PRODUCT
3639 
3640   // We will consult the secondary-super array.
3641   movptr(rdi, secondary_supers_addr);
3642   // Load the array length.  (Positive movl does right thing on LP64.)
3643   movl(rcx, Address(rdi, Array&lt;Klass*&gt;::length_offset_in_bytes()));
3644   // Skip to start of data.
3645   addptr(rdi, Array&lt;Klass*&gt;::base_offset_in_bytes());
3646 
3647   // Scan RCX words at [RDI] for an occurrence of RAX.
3648   // Set NZ/Z based on last compare.
3649   // Z flag value will not be set by &#39;repne&#39; if RCX == 0 since &#39;repne&#39; does
3650   // not change flags (only scas instruction which is repeated sets flags).
3651   // Set Z = 0 (not equal) before &#39;repne&#39; to indicate that class was not found.
3652 
3653     testptr(rax,rax); // Set Z = 0
3654     repne_scan();
3655 
3656   // Unspill the temp. registers:
3657   if (pushed_rdi)  pop(rdi);
3658   if (pushed_rcx)  pop(rcx);
3659   if (pushed_rax)  pop(rax);
3660 
3661   if (set_cond_codes) {
3662     // Special hack for the AD files:  rdi is guaranteed non-zero.
3663     assert(!pushed_rdi, &quot;rdi must be left non-NULL&quot;);
3664     // Also, the condition codes are properly set Z/NZ on succeed/failure.
3665   }
3666 
3667   if (L_failure == &amp;L_fallthrough)
3668         jccb(Assembler::notEqual, *L_failure);
3669   else  jcc(Assembler::notEqual, *L_failure);
3670 
3671   // Success.  Cache the super we found and proceed in triumph.
3672   movptr(super_cache_addr, super_klass);
3673 
3674   if (L_success != &amp;L_fallthrough) {
3675     jmp(*L_success);
3676   }
3677 
3678 #undef IS_A_TEMP
3679 
3680   bind(L_fallthrough);
3681 }
3682 
3683 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
3684   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
3685 
3686   Label L_fallthrough;
3687   if (L_fast_path == NULL) {
3688     L_fast_path = &amp;L_fallthrough;
3689   } else if (L_slow_path == NULL) {
3690     L_slow_path = &amp;L_fallthrough;
3691   }
3692 
3693   // Fast path check: class is fully initialized
3694   cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3695   jcc(Assembler::equal, *L_fast_path);
3696 
3697   // Fast path check: current thread is initializer thread
3698   cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));
3699   if (L_slow_path == &amp;L_fallthrough) {
3700     jcc(Assembler::equal, *L_fast_path);
3701     bind(*L_slow_path);
3702   } else if (L_fast_path == &amp;L_fallthrough) {
3703     jcc(Assembler::notEqual, *L_slow_path);
3704     bind(*L_fast_path);
3705   } else {
3706     Unimplemented();
3707   }
3708 }
3709 
3710 void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
3711   if (VM_Version::supports_cmov()) {
3712     cmovl(cc, dst, src);
3713   } else {
3714     Label L;
3715     jccb(negate_condition(cc), L);
3716     movl(dst, src);
3717     bind(L);
3718   }
3719 }
3720 
3721 void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
3722   if (VM_Version::supports_cmov()) {
3723     cmovl(cc, dst, src);
3724   } else {
3725     Label L;
3726     jccb(negate_condition(cc), L);
3727     movl(dst, src);
3728     bind(L);
3729   }
3730 }
3731 
3732 void MacroAssembler::_verify_oop(Register reg, const char* s, const char* file, int line) {
3733   if (!VerifyOops) return;
3734 
3735   // Pass register number to verify_oop_subroutine
3736   const char* b = NULL;
3737   {
3738     ResourceMark rm;
3739     stringStream ss;
3740     ss.print(&quot;verify_oop: %s: %s (%s:%d)&quot;, reg-&gt;name(), s, file, line);
3741     b = code_string(ss.as_string());
3742   }
3743   BLOCK_COMMENT(&quot;verify_oop {&quot;);
3744 #ifdef _LP64
3745   push(rscratch1);                    // save r10, trashed by movptr()
3746 #endif
3747   push(rax);                          // save rax,
3748   push(reg);                          // pass register argument
3749   ExternalAddress buffer((address) b);
3750   // avoid using pushptr, as it modifies scratch registers
3751   // and our contract is not to modify anything
3752   movptr(rax, buffer.addr());
3753   push(rax);
3754   // call indirectly to solve generation ordering problem
3755   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
3756   call(rax);
3757   // Caller pops the arguments (oop, message) and restores rax, r10
3758   BLOCK_COMMENT(&quot;} verify_oop&quot;);
3759 }
3760 
3761 void MacroAssembler::vallones(XMMRegister dst, int vector_len) {
3762   if (UseAVX &gt; 2 &amp;&amp; (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl())) {
3763     vpternlogd(dst, 0xFF, dst, dst, vector_len);
3764   } else {
3765     assert(UseAVX &gt; 0, &quot;&quot;);
3766     vpcmpeqb(dst, dst, dst, vector_len);
3767   }
3768 }
3769 
3770 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
3771                                                       Register tmp,
3772                                                       int offset) {
3773   intptr_t value = *delayed_value_addr;
3774   if (value != 0)
3775     return RegisterOrConstant(value + offset);
3776 
3777   // load indirectly to solve generation ordering problem
3778   movptr(tmp, ExternalAddress((address) delayed_value_addr));
3779 
3780 #ifdef ASSERT
3781   { Label L;
3782     testptr(tmp, tmp);
3783     if (WizardMode) {
3784       const char* buf = NULL;
3785       {
3786         ResourceMark rm;
3787         stringStream ss;
3788         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
3789         buf = code_string(ss.as_string());
3790       }
3791       jcc(Assembler::notZero, L);
3792       STOP(buf);
3793     } else {
3794       jccb(Assembler::notZero, L);
3795       hlt();
3796     }
3797     bind(L);
3798   }
3799 #endif
3800 
3801   if (offset != 0)
3802     addptr(tmp, offset);
3803 
3804   return RegisterOrConstant(tmp);
3805 }
3806 
3807 
3808 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
3809                                          int extra_slot_offset) {
3810   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
3811   int stackElementSize = Interpreter::stackElementSize;
3812   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
3813 #ifdef ASSERT
3814   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
3815   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
3816 #endif
3817   Register             scale_reg    = noreg;
3818   Address::ScaleFactor scale_factor = Address::no_scale;
3819   if (arg_slot.is_constant()) {
3820     offset += arg_slot.as_constant() * stackElementSize;
3821   } else {
3822     scale_reg    = arg_slot.as_register();
3823     scale_factor = Address::times(stackElementSize);
3824   }
3825   offset += wordSize;           // return PC is on stack
3826   return Address(rsp, scale_reg, scale_factor, offset);
3827 }
3828 
3829 
3830 void MacroAssembler::_verify_oop_addr(Address addr, const char* s, const char* file, int line) {
3831   if (!VerifyOops) return;
3832 
3833   // Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);
3834   // Pass register number to verify_oop_subroutine
3835   const char* b = NULL;
3836   {
3837     ResourceMark rm;
3838     stringStream ss;
3839     ss.print(&quot;verify_oop_addr: %s (%s:%d)&quot;, s, file, line);
3840     b = code_string(ss.as_string());
3841   }
3842 #ifdef _LP64
3843   push(rscratch1);                    // save r10, trashed by movptr()
3844 #endif
3845   push(rax);                          // save rax,
3846   // addr may contain rsp so we will have to adjust it based on the push
3847   // we just did (and on 64 bit we do two pushes)
3848   // NOTE: 64bit seemed to have had a bug in that it did movq(addr, rax); which
3849   // stores rax into addr which is backwards of what was intended.
3850   if (addr.uses(rsp)) {
3851     lea(rax, addr);
3852     pushptr(Address(rax, LP64_ONLY(2 *) BytesPerWord));
3853   } else {
3854     pushptr(addr);
3855   }
3856 
3857   ExternalAddress buffer((address) b);
3858   // pass msg argument
3859   // avoid using pushptr, as it modifies scratch registers
3860   // and our contract is not to modify anything
3861   movptr(rax, buffer.addr());
3862   push(rax);
3863 
3864   // call indirectly to solve generation ordering problem
3865   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
3866   call(rax);
3867   // Caller pops the arguments (addr, message) and restores rax, r10.
3868 }
3869 
3870 void MacroAssembler::verify_tlab() {
3871 #ifdef ASSERT
3872   if (UseTLAB &amp;&amp; VerifyOops) {
3873     Label next, ok;
3874     Register t1 = rsi;
3875     Register thread_reg = NOT_LP64(rbx) LP64_ONLY(r15_thread);
3876 
3877     push(t1);
3878     NOT_LP64(push(thread_reg));
3879     NOT_LP64(get_thread(thread_reg));
3880 
3881     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
3882     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_start_offset())));
3883     jcc(Assembler::aboveEqual, next);
3884     STOP(&quot;assert(top &gt;= start)&quot;);
3885     should_not_reach_here();
3886 
3887     bind(next);
3888     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_end_offset())));
3889     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
3890     jcc(Assembler::aboveEqual, ok);
3891     STOP(&quot;assert(top &lt;= end)&quot;);
3892     should_not_reach_here();
3893 
3894     bind(ok);
3895     NOT_LP64(pop(thread_reg));
3896     pop(t1);
3897   }
3898 #endif
3899 }
3900 
3901 class ControlWord {
3902  public:
3903   int32_t _value;
3904 
3905   int  rounding_control() const        { return  (_value &gt;&gt; 10) &amp; 3      ; }
3906   int  precision_control() const       { return  (_value &gt;&gt;  8) &amp; 3      ; }
3907   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
3908   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
3909   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
3910   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
3911   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
3912   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
3913 
3914   void print() const {
3915     // rounding control
3916     const char* rc;
3917     switch (rounding_control()) {
3918       case 0: rc = &quot;round near&quot;; break;
3919       case 1: rc = &quot;round down&quot;; break;
3920       case 2: rc = &quot;round up  &quot;; break;
3921       case 3: rc = &quot;chop      &quot;; break;
3922     };
3923     // precision control
3924     const char* pc;
3925     switch (precision_control()) {
3926       case 0: pc = &quot;24 bits &quot;; break;
3927       case 1: pc = &quot;reserved&quot;; break;
3928       case 2: pc = &quot;53 bits &quot;; break;
3929       case 3: pc = &quot;64 bits &quot;; break;
3930     };
3931     // flags
3932     char f[9];
3933     f[0] = &#39; &#39;;
3934     f[1] = &#39; &#39;;
3935     f[2] = (precision   ()) ? &#39;P&#39; : &#39;p&#39;;
3936     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;u&#39;;
3937     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;o&#39;;
3938     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;z&#39;;
3939     f[6] = (denormalized()) ? &#39;D&#39; : &#39;d&#39;;
3940     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;i&#39;;
3941     f[8] = &#39;\x0&#39;;
3942     // output
3943     printf(&quot;%04x  masks = %s, %s, %s&quot;, _value &amp; 0xFFFF, f, rc, pc);
3944   }
3945 
3946 };
3947 
3948 class StatusWord {
3949  public:
3950   int32_t _value;
3951 
3952   bool busy() const                    { return ((_value &gt;&gt; 15) &amp; 1) != 0; }
3953   bool C3() const                      { return ((_value &gt;&gt; 14) &amp; 1) != 0; }
3954   bool C2() const                      { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
3955   bool C1() const                      { return ((_value &gt;&gt;  9) &amp; 1) != 0; }
3956   bool C0() const                      { return ((_value &gt;&gt;  8) &amp; 1) != 0; }
3957   int  top() const                     { return  (_value &gt;&gt; 11) &amp; 7      ; }
3958   bool error_status() const            { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
3959   bool stack_fault() const             { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
3960   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
3961   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
3962   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
3963   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
3964   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
3965   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
3966 
3967   void print() const {
3968     // condition codes
3969     char c[5];
3970     c[0] = (C3()) ? &#39;3&#39; : &#39;-&#39;;
3971     c[1] = (C2()) ? &#39;2&#39; : &#39;-&#39;;
3972     c[2] = (C1()) ? &#39;1&#39; : &#39;-&#39;;
3973     c[3] = (C0()) ? &#39;0&#39; : &#39;-&#39;;
3974     c[4] = &#39;\x0&#39;;
3975     // flags
3976     char f[9];
3977     f[0] = (error_status()) ? &#39;E&#39; : &#39;-&#39;;
3978     f[1] = (stack_fault ()) ? &#39;S&#39; : &#39;-&#39;;
3979     f[2] = (precision   ()) ? &#39;P&#39; : &#39;-&#39;;
3980     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;-&#39;;
3981     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;-&#39;;
3982     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;-&#39;;
3983     f[6] = (denormalized()) ? &#39;D&#39; : &#39;-&#39;;
3984     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;-&#39;;
3985     f[8] = &#39;\x0&#39;;
3986     // output
3987     printf(&quot;%04x  flags = %s, cc =  %s, top = %d&quot;, _value &amp; 0xFFFF, f, c, top());
3988   }
3989 
3990 };
3991 
3992 class TagWord {
3993  public:
3994   int32_t _value;
3995 
3996   int tag_at(int i) const              { return (_value &gt;&gt; (i*2)) &amp; 3; }
3997 
3998   void print() const {
3999     printf(&quot;%04x&quot;, _value &amp; 0xFFFF);
4000   }
4001 
4002 };
4003 
4004 class FPU_Register {
4005  public:
4006   int32_t _m0;
4007   int32_t _m1;
4008   int16_t _ex;
4009 
4010   bool is_indefinite() const           {
4011     return _ex == -1 &amp;&amp; _m1 == (int32_t)0xC0000000 &amp;&amp; _m0 == 0;
4012   }
4013 
4014   void print() const {
4015     char  sign = (_ex &lt; 0) ? &#39;-&#39; : &#39;+&#39;;
4016     const char* kind = (_ex == 0x7FFF || _ex == (int16_t)-1) ? &quot;NaN&quot; : &quot;   &quot;;
4017     printf(&quot;%c%04hx.%08x%08x  %s&quot;, sign, _ex, _m1, _m0, kind);
4018   };
4019 
4020 };
4021 
4022 class FPU_State {
4023  public:
4024   enum {
4025     register_size       = 10,
4026     number_of_registers =  8,
4027     register_mask       =  7
4028   };
4029 
4030   ControlWord  _control_word;
4031   StatusWord   _status_word;
4032   TagWord      _tag_word;
4033   int32_t      _error_offset;
4034   int32_t      _error_selector;
4035   int32_t      _data_offset;
4036   int32_t      _data_selector;
4037   int8_t       _register[register_size * number_of_registers];
4038 
4039   int tag_for_st(int i) const          { return _tag_word.tag_at((_status_word.top() + i) &amp; register_mask); }
4040   FPU_Register* st(int i) const        { return (FPU_Register*)&amp;_register[register_size * i]; }
4041 
4042   const char* tag_as_string(int tag) const {
4043     switch (tag) {
4044       case 0: return &quot;valid&quot;;
4045       case 1: return &quot;zero&quot;;
4046       case 2: return &quot;special&quot;;
4047       case 3: return &quot;empty&quot;;
4048     }
4049     ShouldNotReachHere();
4050     return NULL;
4051   }
4052 
4053   void print() const {
4054     // print computation registers
4055     { int t = _status_word.top();
4056       for (int i = 0; i &lt; number_of_registers; i++) {
4057         int j = (i - t) &amp; register_mask;
4058         printf(&quot;%c r%d = ST%d = &quot;, (j == 0 ? &#39;*&#39; : &#39; &#39;), i, j);
4059         st(j)-&gt;print();
4060         printf(&quot; %s\n&quot;, tag_as_string(_tag_word.tag_at(i)));
4061       }
4062     }
4063     printf(&quot;\n&quot;);
4064     // print control registers
4065     printf(&quot;ctrl = &quot;); _control_word.print(); printf(&quot;\n&quot;);
4066     printf(&quot;stat = &quot;); _status_word .print(); printf(&quot;\n&quot;);
4067     printf(&quot;tags = &quot;); _tag_word    .print(); printf(&quot;\n&quot;);
4068   }
4069 
4070 };
4071 
4072 class Flag_Register {
4073  public:
4074   int32_t _value;
4075 
4076   bool overflow() const                { return ((_value &gt;&gt; 11) &amp; 1) != 0; }
4077   bool direction() const               { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4078   bool sign() const                    { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4079   bool zero() const                    { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4080   bool auxiliary_carry() const         { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4081   bool parity() const                  { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4082   bool carry() const                   { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4083 
4084   void print() const {
4085     // flags
4086     char f[8];
4087     f[0] = (overflow       ()) ? &#39;O&#39; : &#39;-&#39;;
4088     f[1] = (direction      ()) ? &#39;D&#39; : &#39;-&#39;;
4089     f[2] = (sign           ()) ? &#39;S&#39; : &#39;-&#39;;
4090     f[3] = (zero           ()) ? &#39;Z&#39; : &#39;-&#39;;
4091     f[4] = (auxiliary_carry()) ? &#39;A&#39; : &#39;-&#39;;
4092     f[5] = (parity         ()) ? &#39;P&#39; : &#39;-&#39;;
4093     f[6] = (carry          ()) ? &#39;C&#39; : &#39;-&#39;;
4094     f[7] = &#39;\x0&#39;;
4095     // output
4096     printf(&quot;%08x  flags = %s&quot;, _value, f);
4097   }
4098 
4099 };
4100 
4101 class IU_Register {
4102  public:
4103   int32_t _value;
4104 
4105   void print() const {
4106     printf(&quot;%08x  %11d&quot;, _value, _value);
4107   }
4108 
4109 };
4110 
4111 class IU_State {
4112  public:
4113   Flag_Register _eflags;
4114   IU_Register   _rdi;
4115   IU_Register   _rsi;
4116   IU_Register   _rbp;
4117   IU_Register   _rsp;
4118   IU_Register   _rbx;
4119   IU_Register   _rdx;
4120   IU_Register   _rcx;
4121   IU_Register   _rax;
4122 
4123   void print() const {
4124     // computation registers
4125     printf(&quot;rax,  = &quot;); _rax.print(); printf(&quot;\n&quot;);
4126     printf(&quot;rbx,  = &quot;); _rbx.print(); printf(&quot;\n&quot;);
4127     printf(&quot;rcx  = &quot;); _rcx.print(); printf(&quot;\n&quot;);
4128     printf(&quot;rdx  = &quot;); _rdx.print(); printf(&quot;\n&quot;);
4129     printf(&quot;rdi  = &quot;); _rdi.print(); printf(&quot;\n&quot;);
4130     printf(&quot;rsi  = &quot;); _rsi.print(); printf(&quot;\n&quot;);
4131     printf(&quot;rbp,  = &quot;); _rbp.print(); printf(&quot;\n&quot;);
4132     printf(&quot;rsp  = &quot;); _rsp.print(); printf(&quot;\n&quot;);
4133     printf(&quot;\n&quot;);
4134     // control registers
4135     printf(&quot;flgs = &quot;); _eflags.print(); printf(&quot;\n&quot;);
4136   }
4137 };
4138 
4139 
4140 class CPU_State {
4141  public:
4142   FPU_State _fpu_state;
4143   IU_State  _iu_state;
4144 
4145   void print() const {
4146     printf(&quot;--------------------------------------------------\n&quot;);
4147     _iu_state .print();
4148     printf(&quot;\n&quot;);
4149     _fpu_state.print();
4150     printf(&quot;--------------------------------------------------\n&quot;);
4151   }
4152 
4153 };
4154 
4155 
4156 static void _print_CPU_state(CPU_State* state) {
4157   state-&gt;print();
4158 };
4159 
4160 
4161 void MacroAssembler::print_CPU_state() {
4162   push_CPU_state();
4163   push(rsp);                // pass CPU state
4164   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _print_CPU_state)));
4165   addptr(rsp, wordSize);       // discard argument
4166   pop_CPU_state();
4167 }
4168 
4169 
4170 #ifndef _LP64
4171 static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {
4172   static int counter = 0;
4173   FPU_State* fs = &amp;state-&gt;_fpu_state;
4174   counter++;
4175   // For leaf calls, only verify that the top few elements remain empty.
4176   // We only need 1 empty at the top for C2 code.
4177   if( stack_depth &lt; 0 ) {
4178     if( fs-&gt;tag_for_st(7) != 3 ) {
4179       printf(&quot;FPR7 not empty\n&quot;);
4180       state-&gt;print();
4181       assert(false, &quot;error&quot;);
4182       return false;
4183     }
4184     return true;                // All other stack states do not matter
4185   }
4186 
4187   assert((fs-&gt;_control_word._value &amp; 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,
4188          &quot;bad FPU control word&quot;);
4189 
4190   // compute stack depth
4191   int i = 0;
4192   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i)  &lt; 3) i++;
4193   int d = i;
4194   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i) == 3) i++;
4195   // verify findings
4196   if (i != FPU_State::number_of_registers) {
4197     // stack not contiguous
4198     printf(&quot;%s: stack not contiguous at ST%d\n&quot;, s, i);
4199     state-&gt;print();
4200     assert(false, &quot;error&quot;);
4201     return false;
4202   }
4203   // check if computed stack depth corresponds to expected stack depth
4204   if (stack_depth &lt; 0) {
4205     // expected stack depth is -stack_depth or less
4206     if (d &gt; -stack_depth) {
4207       // too many elements on the stack
4208       printf(&quot;%s: &lt;= %d stack elements expected but found %d\n&quot;, s, -stack_depth, d);
4209       state-&gt;print();
4210       assert(false, &quot;error&quot;);
4211       return false;
4212     }
4213   } else {
4214     // expected stack depth is stack_depth
4215     if (d != stack_depth) {
4216       // wrong stack depth
4217       printf(&quot;%s: %d stack elements expected but found %d\n&quot;, s, stack_depth, d);
4218       state-&gt;print();
4219       assert(false, &quot;error&quot;);
4220       return false;
4221     }
4222   }
4223   // everything is cool
4224   return true;
4225 }
4226 
4227 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {
4228   if (!VerifyFPU) return;
4229   push_CPU_state();
4230   push(rsp);                // pass CPU state
4231   ExternalAddress msg((address) s);
4232   // pass message string s
4233   pushptr(msg.addr());
4234   push(stack_depth);        // pass stack depth
4235   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));
4236   addptr(rsp, 3 * wordSize);   // discard arguments
4237   // check for error
4238   { Label L;
4239     testl(rax, rax);
4240     jcc(Assembler::notZero, L);
4241     int3();                  // break if error condition
4242     bind(L);
4243   }
4244   pop_CPU_state();
4245 }
4246 #endif // _LP64
4247 
4248 void MacroAssembler::restore_cpu_control_state_after_jni() {
4249   // Either restore the MXCSR register after returning from the JNI Call
4250   // or verify that it wasn&#39;t changed (with -Xcheck:jni flag).
4251   if (VM_Version::supports_sse()) {
4252     if (RestoreMXCSROnJNICalls) {
4253       ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));
4254     } else if (CheckJNICalls) {
4255       call(RuntimeAddress(StubRoutines::x86::verify_mxcsr_entry()));
4256     }
4257   }
4258   // Clear upper bits of YMM registers to avoid SSE &lt;-&gt; AVX transition penalty.
4259   vzeroupper();
4260   // Reset k1 to 0xffff.
4261 
4262 #ifdef COMPILER2
4263   if (PostLoopMultiversioning &amp;&amp; VM_Version::supports_evex()) {
4264     push(rcx);
4265     movl(rcx, 0xffff);
4266     kmovwl(k1, rcx);
4267     pop(rcx);
4268   }
4269 #endif // COMPILER2
4270 
4271 #ifndef _LP64
4272   // Either restore the x87 floating pointer control word after returning
4273   // from the JNI call or verify that it wasn&#39;t changed.
4274   if (CheckJNICalls) {
4275     call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));
4276   }
4277 #endif // _LP64
4278 }
4279 
4280 // ((OopHandle)result).resolve();
4281 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
4282   assert_different_registers(result, tmp);
4283 
4284   // Only 64 bit platforms support GCs that require a tmp register
4285   // Only IN_HEAP loads require a thread_tmp register
4286   // OopHandle::resolve is an indirection like jobject.
4287   access_load_at(T_OBJECT, IN_NATIVE,
4288                  result, Address(result, 0), tmp, /*tmp_thread*/noreg);
4289 }
4290 
4291 // ((WeakHandle)result).resolve();
4292 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
4293   assert_different_registers(rresult, rtmp);
4294   Label resolved;
4295 
4296   // A null weak handle resolves to null.
4297   cmpptr(rresult, 0);
4298   jcc(Assembler::equal, resolved);
4299 
4300   // Only 64 bit platforms support GCs that require a tmp register
4301   // Only IN_HEAP loads require a thread_tmp register
4302   // WeakHandle::resolve is an indirection like jweak.
4303   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
4304                  rresult, Address(rresult, 0), rtmp, /*tmp_thread*/noreg);
4305   bind(resolved);
4306 }
4307 
4308 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
4309   // get mirror
4310   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
4311   load_method_holder(mirror, method);
4312   movptr(mirror, Address(mirror, mirror_offset));
4313   resolve_oop_handle(mirror, tmp);
4314 }
4315 
4316 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
4317   load_method_holder(rresult, rmethod);
4318   movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
4319 }
4320 
4321 void MacroAssembler::load_method_holder(Register holder, Register method) {
4322   movptr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
4323   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
4324   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
4325 }
4326 
4327 void MacroAssembler::load_klass(Register dst, Register src, Register tmp) {
4328   assert_different_registers(src, tmp);
4329   assert_different_registers(dst, tmp);
4330 #ifdef _LP64
4331   if (UseCompressedClassPointers) {
4332     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4333     decode_klass_not_null(dst, tmp);
4334   } else
4335 #endif
4336     movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4337 }
4338 
4339 void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {
4340   load_klass(dst, src, tmp);
4341   movptr(dst, Address(dst, Klass::prototype_header_offset()));
4342 }
4343 
4344 void MacroAssembler::store_klass(Register dst, Register src, Register tmp) {
4345   assert_different_registers(src, tmp);
4346   assert_different_registers(dst, tmp);
4347 #ifdef _LP64
4348   if (UseCompressedClassPointers) {
4349     encode_klass_not_null(src, tmp);
4350     movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4351   } else
4352 #endif
4353     movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4354 }
4355 
4356 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
4357                                     Register tmp1, Register thread_tmp) {
4358   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4359   decorators = AccessInternal::decorator_fixup(decorators);
4360   bool as_raw = (decorators &amp; AS_RAW) != 0;
4361   if (as_raw) {
4362     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4363   } else {
4364     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4365   }
4366 }
4367 
4368 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
4369                                      Register tmp1, Register tmp2) {
4370   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4371   decorators = AccessInternal::decorator_fixup(decorators);
4372   bool as_raw = (decorators &amp; AS_RAW) != 0;
4373   if (as_raw) {
4374     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2);
4375   } else {
4376     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, tmp2);
4377   }
4378 }
4379 
4380 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4381   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4382   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4383     decorators |= ACCESS_READ | ACCESS_WRITE;
4384   }
4385   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4386   return bs-&gt;resolve(this, decorators, obj);
4387 }
4388 
4389 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4390                                    Register thread_tmp, DecoratorSet decorators) {
4391   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4392 }
4393 
4394 // Doesn&#39;t do verfication, generates fixed size code
4395 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4396                                             Register thread_tmp, DecoratorSet decorators) {
4397   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4398 }
4399 
4400 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4401                                     Register tmp2, DecoratorSet decorators) {
4402   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2);
4403 }
4404 
4405 // Used for storing NULLs.
4406 void MacroAssembler::store_heap_oop_null(Address dst) {
4407   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);
4408 }
4409 
4410 #ifdef _LP64
4411 void MacroAssembler::store_klass_gap(Register dst, Register src) {
4412   if (UseCompressedClassPointers) {
4413     // Store to klass gap in destination
4414     movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
4415   }
4416 }
4417 
4418 #ifdef ASSERT
4419 void MacroAssembler::verify_heapbase(const char* msg) {
4420   assert (UseCompressedOops, &quot;should be compressed&quot;);
4421   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4422   if (CheckCompressedOops) {
4423     Label ok;
4424     push(rscratch1); // cmpptr trashes rscratch1
4425     cmpptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4426     jcc(Assembler::equal, ok);
4427     STOP(msg);
4428     bind(ok);
4429     pop(rscratch1);
4430   }
4431 }
4432 #endif
4433 
4434 // Algorithm must match oop.inline.hpp encode_heap_oop.
4435 void MacroAssembler::encode_heap_oop(Register r) {
4436 #ifdef ASSERT
4437   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
4438 #endif
4439   verify_oop_msg(r, &quot;broken oop in encode_heap_oop&quot;);
4440   if (CompressedOops::base() == NULL) {
4441     if (CompressedOops::shift() != 0) {
4442       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4443       shrq(r, LogMinObjAlignmentInBytes);
4444     }
4445     return;
4446   }
4447   testq(r, r);
4448   cmovq(Assembler::equal, r, r12_heapbase);
4449   subq(r, r12_heapbase);
4450   shrq(r, LogMinObjAlignmentInBytes);
4451 }
4452 
4453 void MacroAssembler::encode_heap_oop_not_null(Register r) {
4454 #ifdef ASSERT
4455   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
4456   if (CheckCompressedOops) {
4457     Label ok;
4458     testq(r, r);
4459     jcc(Assembler::notEqual, ok);
4460     STOP(&quot;null oop passed to encode_heap_oop_not_null&quot;);
4461     bind(ok);
4462   }
4463 #endif
4464   verify_oop_msg(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
4465   if (CompressedOops::base() != NULL) {
4466     subq(r, r12_heapbase);
4467   }
4468   if (CompressedOops::shift() != 0) {
4469     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4470     shrq(r, LogMinObjAlignmentInBytes);
4471   }
4472 }
4473 
4474 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
4475 #ifdef ASSERT
4476   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
4477   if (CheckCompressedOops) {
4478     Label ok;
4479     testq(src, src);
4480     jcc(Assembler::notEqual, ok);
4481     STOP(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
4482     bind(ok);
4483   }
4484 #endif
4485   verify_oop_msg(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
4486   if (dst != src) {
4487     movq(dst, src);
4488   }
4489   if (CompressedOops::base() != NULL) {
4490     subq(dst, r12_heapbase);
4491   }
4492   if (CompressedOops::shift() != 0) {
4493     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4494     shrq(dst, LogMinObjAlignmentInBytes);
4495   }
4496 }
4497 
4498 void  MacroAssembler::decode_heap_oop(Register r) {
4499 #ifdef ASSERT
4500   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
4501 #endif
4502   if (CompressedOops::base() == NULL) {
4503     if (CompressedOops::shift() != 0) {
4504       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4505       shlq(r, LogMinObjAlignmentInBytes);
4506     }
4507   } else {
4508     Label done;
4509     shlq(r, LogMinObjAlignmentInBytes);
4510     jccb(Assembler::equal, done);
4511     addq(r, r12_heapbase);
4512     bind(done);
4513   }
4514   verify_oop_msg(r, &quot;broken oop in decode_heap_oop&quot;);
4515 }
4516 
4517 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
4518   // Note: it will change flags
4519   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4520   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4521   // Cannot assert, unverified entry point counts instructions (see .ad file)
4522   // vtableStubs also counts instructions in pd_code_size_limit.
4523   // Also do not verify_oop as this is called by verify_oop.
4524   if (CompressedOops::shift() != 0) {
4525     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4526     shlq(r, LogMinObjAlignmentInBytes);
4527     if (CompressedOops::base() != NULL) {
4528       addq(r, r12_heapbase);
4529     }
4530   } else {
4531     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4532   }
4533 }
4534 
4535 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
4536   // Note: it will change flags
4537   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4538   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4539   // Cannot assert, unverified entry point counts instructions (see .ad file)
4540   // vtableStubs also counts instructions in pd_code_size_limit.
4541   // Also do not verify_oop as this is called by verify_oop.
4542   if (CompressedOops::shift() != 0) {
4543     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4544     if (LogMinObjAlignmentInBytes == Address::times_8) {
4545       leaq(dst, Address(r12_heapbase, src, Address::times_8, 0));
4546     } else {
4547       if (dst != src) {
4548         movq(dst, src);
4549       }
4550       shlq(dst, LogMinObjAlignmentInBytes);
4551       if (CompressedOops::base() != NULL) {
4552         addq(dst, r12_heapbase);
4553       }
4554     }
4555   } else {
4556     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4557     if (dst != src) {
4558       movq(dst, src);
4559     }
4560   }
4561 }
4562 
4563 void MacroAssembler::encode_klass_not_null(Register r, Register tmp) {
4564   assert_different_registers(r, tmp);
4565   if (CompressedKlassPointers::base() != NULL) {
4566     mov64(tmp, (int64_t)CompressedKlassPointers::base());
4567     subq(r, tmp);
4568   }
4569   if (CompressedKlassPointers::shift() != 0) {
4570     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4571     shrq(r, LogKlassAlignmentInBytes);
4572   }
4573 }
4574 
4575 void MacroAssembler::encode_and_move_klass_not_null(Register dst, Register src) {
4576   assert_different_registers(src, dst);
4577   if (CompressedKlassPointers::base() != NULL) {
4578     mov64(dst, -(int64_t)CompressedKlassPointers::base());
4579     addq(dst, src);
4580   } else {
4581     movptr(dst, src);
4582   }
4583   if (CompressedKlassPointers::shift() != 0) {
4584     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4585     shrq(dst, LogKlassAlignmentInBytes);
4586   }
4587 }
4588 
4589 // !!! If the instructions that get generated here change then function
4590 // instr_size_for_decode_klass_not_null() needs to get updated.
4591 void  MacroAssembler::decode_klass_not_null(Register r, Register tmp) {
4592   assert_different_registers(r, tmp);
4593   // Note: it will change flags
4594   assert(UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4595   // Cannot assert, unverified entry point counts instructions (see .ad file)
4596   // vtableStubs also counts instructions in pd_code_size_limit.
4597   // Also do not verify_oop as this is called by verify_oop.
4598   if (CompressedKlassPointers::shift() != 0) {
4599     assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4600     shlq(r, LogKlassAlignmentInBytes);
4601   }
4602   if (CompressedKlassPointers::base() != NULL) {
4603     mov64(tmp, (int64_t)CompressedKlassPointers::base());
4604     addq(r, tmp);
4605   }
4606 }
4607 
4608 void  MacroAssembler::decode_and_move_klass_not_null(Register dst, Register src) {
4609   assert_different_registers(src, dst);
4610   // Note: it will change flags
4611   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4612   // Cannot assert, unverified entry point counts instructions (see .ad file)
4613   // vtableStubs also counts instructions in pd_code_size_limit.
4614   // Also do not verify_oop as this is called by verify_oop.
4615 
4616   if (CompressedKlassPointers::base() == NULL &amp;&amp;
4617       CompressedKlassPointers::shift() == 0) {
4618     // The best case scenario is that there is no base or shift. Then it is already
4619     // a pointer that needs nothing but a register rename.
4620     movl(dst, src);
4621   } else {
4622     if (CompressedKlassPointers::base() != NULL) {
4623       mov64(dst, (int64_t)CompressedKlassPointers::base());
4624     } else {
4625       xorq(dst, dst);
4626     }
4627     if (CompressedKlassPointers::shift() != 0) {
4628       assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4629       assert(LogKlassAlignmentInBytes == Address::times_8, &quot;klass not aligned on 64bits?&quot;);
4630       leaq(dst, Address(dst, src, Address::times_8, 0));
4631     } else {
4632       addq(dst, src);
4633     }
4634   }
4635 }
4636 
4637 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4638   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4639   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4640   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4641   int oop_index = oop_recorder()-&gt;find_index(obj);
4642   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4643   mov_narrow_oop(dst, oop_index, rspec);
4644 }
4645 
4646 void  MacroAssembler::set_narrow_oop(Address dst, jobject obj) {
4647   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4648   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4649   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4650   int oop_index = oop_recorder()-&gt;find_index(obj);
4651   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4652   mov_narrow_oop(dst, oop_index, rspec);
4653 }
4654 
4655 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4656   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4657   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4658   int klass_index = oop_recorder()-&gt;find_index(k);
4659   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4660   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4661 }
4662 
4663 void  MacroAssembler::set_narrow_klass(Address dst, Klass* k) {
4664   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4665   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4666   int klass_index = oop_recorder()-&gt;find_index(k);
4667   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4668   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4669 }
4670 
4671 void  MacroAssembler::cmp_narrow_oop(Register dst, jobject obj) {
4672   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4673   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4674   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4675   int oop_index = oop_recorder()-&gt;find_index(obj);
4676   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4677   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
4678 }
4679 
4680 void  MacroAssembler::cmp_narrow_oop(Address dst, jobject obj) {
4681   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4682   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4683   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4684   int oop_index = oop_recorder()-&gt;find_index(obj);
4685   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4686   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
4687 }
4688 
4689 void  MacroAssembler::cmp_narrow_klass(Register dst, Klass* k) {
4690   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4691   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4692   int klass_index = oop_recorder()-&gt;find_index(k);
4693   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4694   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4695 }
4696 
4697 void  MacroAssembler::cmp_narrow_klass(Address dst, Klass* k) {
4698   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4699   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4700   int klass_index = oop_recorder()-&gt;find_index(k);
4701   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4702   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
4703 }
4704 
4705 void MacroAssembler::reinit_heapbase() {
4706   if (UseCompressedOops) {
4707     if (Universe::heap() != NULL) {
4708       if (CompressedOops::base() == NULL) {
4709         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
4710       } else {
4711         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
4712       }
4713     } else {
4714       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4715     }
4716   }
4717 }
4718 
4719 #endif // _LP64
4720 
4721 // C2 compiled method&#39;s prolog code.
4722 void MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {
4723 
4724   // WARNING: Initial instruction MUST be 5 bytes or longer so that
4725   // NativeJump::patch_verified_entry will be able to patch out the entry
4726   // code safely. The push to verify stack depth is ok at 5 bytes,
4727   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
4728   // stack bang then we must use the 6 byte frame allocation even if
4729   // we have no frame. :-(
4730   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
4731 
4732   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
4733   // Remove word for return addr
4734   framesize -= wordSize;
4735   stack_bang_size -= wordSize;
4736 
4737   // Calls to C2R adapters often do not accept exceptional returns.
4738   // We require that their callers must bang for them.  But be careful, because
4739   // some VM calls (such as call site linkage) can use several kilobytes of
4740   // stack.  But the stack safety zone should account for that.
4741   // See bugs 4446381, 4468289, 4497237.
4742   if (stack_bang_size &gt; 0) {
4743     generate_stack_overflow_check(stack_bang_size);
4744 
4745     // We always push rbp, so that on return to interpreter rbp, will be
4746     // restored correctly and we can correct the stack.
4747     push(rbp);
4748     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
4749     if (PreserveFramePointer) {
4750       mov(rbp, rsp);
4751     }
4752     // Remove word for ebp
4753     framesize -= wordSize;
4754 
4755     // Create frame
4756     if (framesize) {
4757       subptr(rsp, framesize);
4758     }
4759   } else {
4760     // Create frame (force generation of a 4 byte immediate value)
4761     subptr_imm32(rsp, framesize);
4762 
4763     // Save RBP register now.
4764     framesize -= wordSize;
4765     movptr(Address(rsp, framesize), rbp);
4766     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
4767     if (PreserveFramePointer) {
4768       movptr(rbp, rsp);
4769       if (framesize &gt; 0) {
4770         addptr(rbp, framesize);
4771       }
4772     }
4773   }
4774 
4775   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
4776     framesize -= wordSize;
4777     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
4778   }
4779 
4780 #ifndef _LP64
4781   // If method sets FPU control word do it now
4782   if (fp_mode_24b) {
4783     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
4784   }
4785   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
4786     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
4787   }
4788 #endif
4789 
4790 #ifdef ASSERT
4791   if (VerifyStackAtCalls) {
4792     Label L;
4793     push(rax);
4794     mov(rax, rsp);
4795     andptr(rax, StackAlignmentInBytes-1);
4796     cmpptr(rax, StackAlignmentInBytes-wordSize);
4797     pop(rax);
4798     jcc(Assembler::equal, L);
4799     STOP(&quot;Stack is not properly aligned!&quot;);
4800     bind(L);
4801   }
4802 #endif
4803 
4804   if (!is_stub) {
4805     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4806     bs-&gt;nmethod_entry_barrier(this);
4807   }
4808 }
4809 
4810 // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
4811 void MacroAssembler::xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp) {
4812   // cnt - number of qwords (8-byte words).
4813   // base - start address, qword aligned.
4814   Label L_zero_64_bytes, L_loop, L_sloop, L_tail, L_end;
4815   if (UseAVX &gt;= 2) {
4816     vpxor(xtmp, xtmp, xtmp, AVX_256bit);
4817   } else {
4818     pxor(xtmp, xtmp);
4819   }
4820   jmp(L_zero_64_bytes);
4821 
4822   BIND(L_loop);
4823   if (UseAVX &gt;= 2) {
4824     vmovdqu(Address(base,  0), xtmp);
4825     vmovdqu(Address(base, 32), xtmp);
4826   } else {
4827     movdqu(Address(base,  0), xtmp);
4828     movdqu(Address(base, 16), xtmp);
4829     movdqu(Address(base, 32), xtmp);
4830     movdqu(Address(base, 48), xtmp);
4831   }
4832   addptr(base, 64);
4833 
4834   BIND(L_zero_64_bytes);
4835   subptr(cnt, 8);
4836   jccb(Assembler::greaterEqual, L_loop);
4837   addptr(cnt, 4);
4838   jccb(Assembler::less, L_tail);
4839   // Copy trailing 32 bytes
4840   if (UseAVX &gt;= 2) {
4841     vmovdqu(Address(base, 0), xtmp);
4842   } else {
4843     movdqu(Address(base,  0), xtmp);
4844     movdqu(Address(base, 16), xtmp);
4845   }
4846   addptr(base, 32);
4847   subptr(cnt, 4);
4848 
4849   BIND(L_tail);
4850   addptr(cnt, 4);
4851   jccb(Assembler::lessEqual, L_end);
4852   decrement(cnt);
4853 
4854   BIND(L_sloop);
4855   movq(Address(base, 0), xtmp);
4856   addptr(base, 8);
4857   decrement(cnt);
4858   jccb(Assembler::greaterEqual, L_sloop);
4859   BIND(L_end);
4860 }
4861 
4862 void MacroAssembler::clear_mem(Register base, Register cnt, Register tmp, XMMRegister xtmp, bool is_large) {
4863   // cnt - number of qwords (8-byte words).
4864   // base - start address, qword aligned.
4865   // is_large - if optimizers know cnt is larger than InitArrayShortSize
4866   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
4867   assert(tmp==rax,   &quot;tmp register must be eax for rep stos&quot;);
4868   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
4869   assert(InitArrayShortSize % BytesPerLong == 0,
4870     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
4871 
4872   Label DONE;
4873 
4874   if (!is_large || !UseXMMForObjInit) {
4875     xorptr(tmp, tmp);
4876   }
4877 
4878   if (!is_large) {
4879     Label LOOP, LONG;
4880     cmpptr(cnt, InitArrayShortSize/BytesPerLong);
4881     jccb(Assembler::greater, LONG);
4882 
4883     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
4884 
4885     decrement(cnt);
4886     jccb(Assembler::negative, DONE); // Zero length
4887 
4888     // Use individual pointer-sized stores for small counts:
4889     BIND(LOOP);
4890     movptr(Address(base, cnt, Address::times_ptr), tmp);
4891     decrement(cnt);
4892     jccb(Assembler::greaterEqual, LOOP);
4893     jmpb(DONE);
4894 
4895     BIND(LONG);
4896   }
4897 
4898   // Use longer rep-prefixed ops for non-small counts:
4899   if (UseFastStosb) {
4900     shlptr(cnt, 3); // convert to number of bytes
4901     rep_stosb();
4902   } else if (UseXMMForObjInit) {
4903     movptr(tmp, base);
4904     xmm_clear_mem(tmp, cnt, xtmp);
4905   } else {
4906     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
4907     rep_stos();
4908   }
4909 
4910   BIND(DONE);
4911 }
4912 
4913 void MacroAssembler::generate_fill(BasicType t, bool aligned,
4914                                    Register to, Register value, Register count,
4915                                    Register rtmp, XMMRegister xtmp) {
4916   ShortBranchVerifier sbv(this);
4917   assert_different_registers(to, value, count, rtmp);
4918   Label L_exit;
4919   Label L_fill_2_bytes, L_fill_4_bytes;
4920 
4921   int shift = -1;
4922   switch (t) {
4923     case T_BYTE:
4924       shift = 2;
4925       break;
4926     case T_SHORT:
4927       shift = 1;
4928       break;
4929     case T_INT:
4930       shift = 0;
4931       break;
4932     default: ShouldNotReachHere();
4933   }
4934 
4935   if (t == T_BYTE) {
4936     andl(value, 0xff);
4937     movl(rtmp, value);
4938     shll(rtmp, 8);
4939     orl(value, rtmp);
4940   }
4941   if (t == T_SHORT) {
4942     andl(value, 0xffff);
4943   }
4944   if (t == T_BYTE || t == T_SHORT) {
4945     movl(rtmp, value);
4946     shll(rtmp, 16);
4947     orl(value, rtmp);
4948   }
4949 
4950   cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) fill by element
4951   jcc(Assembler::below, L_fill_4_bytes); // use unsigned cmp
4952   if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {
4953     Label L_skip_align2;
4954     // align source address at 4 bytes address boundary
4955     if (t == T_BYTE) {
4956       Label L_skip_align1;
4957       // One byte misalignment happens only for byte arrays
4958       testptr(to, 1);
4959       jccb(Assembler::zero, L_skip_align1);
4960       movb(Address(to, 0), value);
4961       increment(to);
4962       decrement(count);
4963       BIND(L_skip_align1);
4964     }
4965     // Two bytes misalignment happens only for byte and short (char) arrays
4966     testptr(to, 2);
4967     jccb(Assembler::zero, L_skip_align2);
4968     movw(Address(to, 0), value);
4969     addptr(to, 2);
4970     subl(count, 1&lt;&lt;(shift-1));
4971     BIND(L_skip_align2);
4972   }
4973   if (UseSSE &lt; 2) {
4974     Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
4975     // Fill 32-byte chunks
4976     subl(count, 8 &lt;&lt; shift);
4977     jcc(Assembler::less, L_check_fill_8_bytes);
4978     align(16);
4979 
4980     BIND(L_fill_32_bytes_loop);
4981 
4982     for (int i = 0; i &lt; 32; i += 4) {
4983       movl(Address(to, i), value);
4984     }
4985 
4986     addptr(to, 32);
4987     subl(count, 8 &lt;&lt; shift);
4988     jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
4989     BIND(L_check_fill_8_bytes);
4990     addl(count, 8 &lt;&lt; shift);
4991     jccb(Assembler::zero, L_exit);
4992     jmpb(L_fill_8_bytes);
4993 
4994     //
4995     // length is too short, just fill qwords
4996     //
4997     BIND(L_fill_8_bytes_loop);
4998     movl(Address(to, 0), value);
4999     movl(Address(to, 4), value);
5000     addptr(to, 8);
5001     BIND(L_fill_8_bytes);
5002     subl(count, 1 &lt;&lt; (shift + 1));
5003     jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5004     // fall through to fill 4 bytes
5005   } else {
5006     Label L_fill_32_bytes;
5007     if (!UseUnalignedLoadStores) {
5008       // align to 8 bytes, we know we are 4 byte aligned to start
5009       testptr(to, 4);
5010       jccb(Assembler::zero, L_fill_32_bytes);
5011       movl(Address(to, 0), value);
5012       addptr(to, 4);
5013       subl(count, 1&lt;&lt;shift);
5014     }
5015     BIND(L_fill_32_bytes);
5016     {
5017       assert( UseSSE &gt;= 2, &quot;supported cpu only&quot; );
5018       Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5019       movdl(xtmp, value);
5020       if (UseAVX &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
5021         Label L_check_fill_32_bytes;
5022         if (UseAVX &gt; 2) {
5023           // Fill 64-byte chunks
5024           Label L_fill_64_bytes_loop_avx3, L_check_fill_64_bytes_avx2;
5025 
5026           // If number of bytes to fill &lt; AVX3Threshold, perform fill using AVX2
5027           cmpl(count, AVX3Threshold);
5028           jccb(Assembler::below, L_check_fill_64_bytes_avx2);
5029 
5030           vpbroadcastd(xtmp, xtmp, Assembler::AVX_512bit);
5031 
5032           subl(count, 16 &lt;&lt; shift);
5033           jccb(Assembler::less, L_check_fill_32_bytes);
5034           align(16);
5035 
5036           BIND(L_fill_64_bytes_loop_avx3);
5037           evmovdqul(Address(to, 0), xtmp, Assembler::AVX_512bit);
5038           addptr(to, 64);
5039           subl(count, 16 &lt;&lt; shift);
5040           jcc(Assembler::greaterEqual, L_fill_64_bytes_loop_avx3);
5041           jmpb(L_check_fill_32_bytes);
5042 
5043           BIND(L_check_fill_64_bytes_avx2);
5044         }
5045         // Fill 64-byte chunks
5046         Label L_fill_64_bytes_loop;
5047         vpbroadcastd(xtmp, xtmp, Assembler::AVX_256bit);
5048 
5049         subl(count, 16 &lt;&lt; shift);
5050         jcc(Assembler::less, L_check_fill_32_bytes);
5051         align(16);
5052 
5053         BIND(L_fill_64_bytes_loop);
5054         vmovdqu(Address(to, 0), xtmp);
5055         vmovdqu(Address(to, 32), xtmp);
5056         addptr(to, 64);
5057         subl(count, 16 &lt;&lt; shift);
5058         jcc(Assembler::greaterEqual, L_fill_64_bytes_loop);
5059 
5060         BIND(L_check_fill_32_bytes);
5061         addl(count, 8 &lt;&lt; shift);
5062         jccb(Assembler::less, L_check_fill_8_bytes);
5063         vmovdqu(Address(to, 0), xtmp);
5064         addptr(to, 32);
5065         subl(count, 8 &lt;&lt; shift);
5066 
5067         BIND(L_check_fill_8_bytes);
5068         // clean upper bits of YMM registers
5069         movdl(xtmp, value);
5070         pshufd(xtmp, xtmp, 0);
5071       } else {
5072         // Fill 32-byte chunks
5073         pshufd(xtmp, xtmp, 0);
5074 
5075         subl(count, 8 &lt;&lt; shift);
5076         jcc(Assembler::less, L_check_fill_8_bytes);
5077         align(16);
5078 
5079         BIND(L_fill_32_bytes_loop);
5080 
5081         if (UseUnalignedLoadStores) {
5082           movdqu(Address(to, 0), xtmp);
5083           movdqu(Address(to, 16), xtmp);
5084         } else {
5085           movq(Address(to, 0), xtmp);
5086           movq(Address(to, 8), xtmp);
5087           movq(Address(to, 16), xtmp);
5088           movq(Address(to, 24), xtmp);
5089         }
5090 
5091         addptr(to, 32);
5092         subl(count, 8 &lt;&lt; shift);
5093         jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5094 
5095         BIND(L_check_fill_8_bytes);
5096       }
5097       addl(count, 8 &lt;&lt; shift);
5098       jccb(Assembler::zero, L_exit);
5099       jmpb(L_fill_8_bytes);
5100 
5101       //
5102       // length is too short, just fill qwords
5103       //
5104       BIND(L_fill_8_bytes_loop);
5105       movq(Address(to, 0), xtmp);
5106       addptr(to, 8);
5107       BIND(L_fill_8_bytes);
5108       subl(count, 1 &lt;&lt; (shift + 1));
5109       jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5110     }
5111   }
5112   // fill trailing 4 bytes
5113   BIND(L_fill_4_bytes);
5114   testl(count, 1&lt;&lt;shift);
5115   jccb(Assembler::zero, L_fill_2_bytes);
5116   movl(Address(to, 0), value);
5117   if (t == T_BYTE || t == T_SHORT) {
5118     Label L_fill_byte;
5119     addptr(to, 4);
5120     BIND(L_fill_2_bytes);
5121     // fill trailing 2 bytes
5122     testl(count, 1&lt;&lt;(shift-1));
5123     jccb(Assembler::zero, L_fill_byte);
5124     movw(Address(to, 0), value);
5125     if (t == T_BYTE) {
5126       addptr(to, 2);
5127       BIND(L_fill_byte);
5128       // fill trailing byte
5129       testl(count, 1);
5130       jccb(Assembler::zero, L_exit);
5131       movb(Address(to, 0), value);
5132     } else {
5133       BIND(L_fill_byte);
5134     }
5135   } else {
5136     BIND(L_fill_2_bytes);
5137   }
5138   BIND(L_exit);
5139 }
5140 
5141 // encode char[] to byte[] in ISO_8859_1
5142    //@HotSpotIntrinsicCandidate
5143    //private static int implEncodeISOArray(byte[] sa, int sp,
5144    //byte[] da, int dp, int len) {
5145    //  int i = 0;
5146    //  for (; i &lt; len; i++) {
5147    //    char c = StringUTF16.getChar(sa, sp++);
5148    //    if (c &gt; &#39;\u00FF&#39;)
5149    //      break;
5150    //    da[dp++] = (byte)c;
5151    //  }
5152    //  return i;
5153    //}
5154 void MacroAssembler::encode_iso_array(Register src, Register dst, Register len,
5155   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
5156   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
5157   Register tmp5, Register result) {
5158 
5159   // rsi: src
5160   // rdi: dst
5161   // rdx: len
5162   // rcx: tmp5
5163   // rax: result
5164   ShortBranchVerifier sbv(this);
5165   assert_different_registers(src, dst, len, tmp5, result);
5166   Label L_done, L_copy_1_char, L_copy_1_char_exit;
5167 
5168   // set result
5169   xorl(result, result);
5170   // check for zero length
5171   testl(len, len);
5172   jcc(Assembler::zero, L_done);
5173 
5174   movl(result, len);
5175 
5176   // Setup pointers
5177   lea(src, Address(src, len, Address::times_2)); // char[]
5178   lea(dst, Address(dst, len, Address::times_1)); // byte[]
5179   negptr(len);
5180 
5181   if (UseSSE42Intrinsics || UseAVX &gt;= 2) {
5182     Label L_copy_8_chars, L_copy_8_chars_exit;
5183     Label L_chars_16_check, L_copy_16_chars, L_copy_16_chars_exit;
5184 
5185     if (UseAVX &gt;= 2) {
5186       Label L_chars_32_check, L_copy_32_chars, L_copy_32_chars_exit;
5187       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5188       movdl(tmp1Reg, tmp5);
5189       vpbroadcastd(tmp1Reg, tmp1Reg, Assembler::AVX_256bit);
5190       jmp(L_chars_32_check);
5191 
5192       bind(L_copy_32_chars);
5193       vmovdqu(tmp3Reg, Address(src, len, Address::times_2, -64));
5194       vmovdqu(tmp4Reg, Address(src, len, Address::times_2, -32));
5195       vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5196       vptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5197       jccb(Assembler::notZero, L_copy_32_chars_exit);
5198       vpackuswb(tmp3Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5199       vpermq(tmp4Reg, tmp3Reg, 0xD8, /* vector_len */ 1);
5200       vmovdqu(Address(dst, len, Address::times_1, -32), tmp4Reg);
5201 
5202       bind(L_chars_32_check);
5203       addptr(len, 32);
5204       jcc(Assembler::lessEqual, L_copy_32_chars);
5205 
5206       bind(L_copy_32_chars_exit);
5207       subptr(len, 16);
5208       jccb(Assembler::greater, L_copy_16_chars_exit);
5209 
5210     } else if (UseSSE42Intrinsics) {
5211       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5212       movdl(tmp1Reg, tmp5);
5213       pshufd(tmp1Reg, tmp1Reg, 0);
5214       jmpb(L_chars_16_check);
5215     }
5216 
5217     bind(L_copy_16_chars);
5218     if (UseAVX &gt;= 2) {
5219       vmovdqu(tmp2Reg, Address(src, len, Address::times_2, -32));
5220       vptest(tmp2Reg, tmp1Reg);
5221       jcc(Assembler::notZero, L_copy_16_chars_exit);
5222       vpackuswb(tmp2Reg, tmp2Reg, tmp1Reg, /* vector_len */ 1);
5223       vpermq(tmp3Reg, tmp2Reg, 0xD8, /* vector_len */ 1);
5224     } else {
5225       if (UseAVX &gt; 0) {
5226         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5227         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5228         vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 0);
5229       } else {
5230         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5231         por(tmp2Reg, tmp3Reg);
5232         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5233         por(tmp2Reg, tmp4Reg);
5234       }
5235       ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5236       jccb(Assembler::notZero, L_copy_16_chars_exit);
5237       packuswb(tmp3Reg, tmp4Reg);
5238     }
5239     movdqu(Address(dst, len, Address::times_1, -16), tmp3Reg);
5240 
5241     bind(L_chars_16_check);
5242     addptr(len, 16);
5243     jcc(Assembler::lessEqual, L_copy_16_chars);
5244 
5245     bind(L_copy_16_chars_exit);
5246     if (UseAVX &gt;= 2) {
5247       // clean upper bits of YMM registers
5248       vpxor(tmp2Reg, tmp2Reg);
5249       vpxor(tmp3Reg, tmp3Reg);
5250       vpxor(tmp4Reg, tmp4Reg);
5251       movdl(tmp1Reg, tmp5);
5252       pshufd(tmp1Reg, tmp1Reg, 0);
5253     }
5254     subptr(len, 8);
5255     jccb(Assembler::greater, L_copy_8_chars_exit);
5256 
5257     bind(L_copy_8_chars);
5258     movdqu(tmp3Reg, Address(src, len, Address::times_2, -16));
5259     ptest(tmp3Reg, tmp1Reg);
5260     jccb(Assembler::notZero, L_copy_8_chars_exit);
5261     packuswb(tmp3Reg, tmp1Reg);
5262     movq(Address(dst, len, Address::times_1, -8), tmp3Reg);
5263     addptr(len, 8);
5264     jccb(Assembler::lessEqual, L_copy_8_chars);
5265 
5266     bind(L_copy_8_chars_exit);
5267     subptr(len, 8);
5268     jccb(Assembler::zero, L_done);
5269   }
5270 
5271   bind(L_copy_1_char);
5272   load_unsigned_short(tmp5, Address(src, len, Address::times_2, 0));
5273   testl(tmp5, 0xff00);      // check if Unicode char
5274   jccb(Assembler::notZero, L_copy_1_char_exit);
5275   movb(Address(dst, len, Address::times_1, 0), tmp5);
5276   addptr(len, 1);
5277   jccb(Assembler::less, L_copy_1_char);
5278 
5279   bind(L_copy_1_char_exit);
5280   addptr(result, len); // len is negative count of not processed elements
5281 
5282   bind(L_done);
5283 }
5284 
5285 #ifdef _LP64
5286 /**
5287  * Helper for multiply_to_len().
5288  */
5289 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
5290   addq(dest_lo, src1);
5291   adcq(dest_hi, 0);
5292   addq(dest_lo, src2);
5293   adcq(dest_hi, 0);
5294 }
5295 
5296 /**
5297  * Multiply 64 bit by 64 bit first loop.
5298  */
5299 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
5300                                            Register y, Register y_idx, Register z,
5301                                            Register carry, Register product,
5302                                            Register idx, Register kdx) {
5303   //
5304   //  jlong carry, x[], y[], z[];
5305   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
5306   //    huge_128 product = y[idx] * x[xstart] + carry;
5307   //    z[kdx] = (jlong)product;
5308   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
5309   //  }
5310   //  z[xstart] = carry;
5311   //
5312 
5313   Label L_first_loop, L_first_loop_exit;
5314   Label L_one_x, L_one_y, L_multiply;
5315 
5316   decrementl(xstart);
5317   jcc(Assembler::negative, L_one_x);
5318 
5319   movq(x_xstart, Address(x, xstart, Address::times_4,  0));
5320   rorq(x_xstart, 32); // convert big-endian to little-endian
5321 
5322   bind(L_first_loop);
5323   decrementl(idx);
5324   jcc(Assembler::negative, L_first_loop_exit);
5325   decrementl(idx);
5326   jcc(Assembler::negative, L_one_y);
5327   movq(y_idx, Address(y, idx, Address::times_4,  0));
5328   rorq(y_idx, 32); // convert big-endian to little-endian
5329   bind(L_multiply);
5330   movq(product, x_xstart);
5331   mulq(y_idx); // product(rax) * y_idx -&gt; rdx:rax
5332   addq(product, carry);
5333   adcq(rdx, 0);
5334   subl(kdx, 2);
5335   movl(Address(z, kdx, Address::times_4,  4), product);
5336   shrq(product, 32);
5337   movl(Address(z, kdx, Address::times_4,  0), product);
5338   movq(carry, rdx);
5339   jmp(L_first_loop);
5340 
5341   bind(L_one_y);
5342   movl(y_idx, Address(y,  0));
5343   jmp(L_multiply);
5344 
5345   bind(L_one_x);
5346   movl(x_xstart, Address(x,  0));
5347   jmp(L_first_loop);
5348 
5349   bind(L_first_loop_exit);
5350 }
5351 
5352 /**
5353  * Multiply 64 bit by 64 bit and add 128 bit.
5354  */
5355 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y, Register z,
5356                                             Register yz_idx, Register idx,
5357                                             Register carry, Register product, int offset) {
5358   //     huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
5359   //     z[kdx] = (jlong)product;
5360 
5361   movq(yz_idx, Address(y, idx, Address::times_4,  offset));
5362   rorq(yz_idx, 32); // convert big-endian to little-endian
5363   movq(product, x_xstart);
5364   mulq(yz_idx);     // product(rax) * yz_idx -&gt; rdx:product(rax)
5365   movq(yz_idx, Address(z, idx, Address::times_4,  offset));
5366   rorq(yz_idx, 32); // convert big-endian to little-endian
5367 
5368   add2_with_carry(rdx, product, carry, yz_idx);
5369 
5370   movl(Address(z, idx, Address::times_4,  offset+4), product);
5371   shrq(product, 32);
5372   movl(Address(z, idx, Address::times_4,  offset), product);
5373 
5374 }
5375 
5376 /**
5377  * Multiply 128 bit by 128 bit. Unrolled inner loop.
5378  */
5379 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
5380                                              Register yz_idx, Register idx, Register jdx,
5381                                              Register carry, Register product,
5382                                              Register carry2) {
5383   //   jlong carry, x[], y[], z[];
5384   //   int kdx = ystart+1;
5385   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
5386   //     huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
5387   //     z[kdx+idx+1] = (jlong)product;
5388   //     jlong carry2  = (jlong)(product &gt;&gt;&gt; 64);
5389   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
5390   //     z[kdx+idx] = (jlong)product;
5391   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
5392   //   }
5393   //   idx += 2;
5394   //   if (idx &gt; 0) {
5395   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
5396   //     z[kdx+idx] = (jlong)product;
5397   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
5398   //   }
5399   //
5400 
5401   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
5402 
5403   movl(jdx, idx);
5404   andl(jdx, 0xFFFFFFFC);
5405   shrl(jdx, 2);
5406 
5407   bind(L_third_loop);
5408   subl(jdx, 1);
5409   jcc(Assembler::negative, L_third_loop_exit);
5410   subl(idx, 4);
5411 
5412   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
5413   movq(carry2, rdx);
5414 
5415   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
5416   movq(carry, rdx);
5417   jmp(L_third_loop);
5418 
5419   bind (L_third_loop_exit);
5420 
5421   andl (idx, 0x3);
5422   jcc(Assembler::zero, L_post_third_loop_done);
5423 
5424   Label L_check_1;
5425   subl(idx, 2);
5426   jcc(Assembler::negative, L_check_1);
5427 
5428   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
5429   movq(carry, rdx);
5430 
5431   bind (L_check_1);
5432   addl (idx, 0x2);
5433   andl (idx, 0x1);
5434   subl(idx, 1);
5435   jcc(Assembler::negative, L_post_third_loop_done);
5436 
5437   movl(yz_idx, Address(y, idx, Address::times_4,  0));
5438   movq(product, x_xstart);
5439   mulq(yz_idx); // product(rax) * yz_idx -&gt; rdx:product(rax)
5440   movl(yz_idx, Address(z, idx, Address::times_4,  0));
5441 
5442   add2_with_carry(rdx, product, yz_idx, carry);
5443 
5444   movl(Address(z, idx, Address::times_4,  0), product);
5445   shrq(product, 32);
5446 
5447   shlq(rdx, 32);
5448   orq(product, rdx);
5449   movq(carry, product);
5450 
5451   bind(L_post_third_loop_done);
5452 }
5453 
5454 /**
5455  * Multiply 128 bit by 128 bit using BMI2. Unrolled inner loop.
5456  *
5457  */
5458 void MacroAssembler::multiply_128_x_128_bmi2_loop(Register y, Register z,
5459                                                   Register carry, Register carry2,
5460                                                   Register idx, Register jdx,
5461                                                   Register yz_idx1, Register yz_idx2,
5462                                                   Register tmp, Register tmp3, Register tmp4) {
5463   assert(UseBMI2Instructions, &quot;should be used only when BMI2 is available&quot;);
5464 
5465   //   jlong carry, x[], y[], z[];
5466   //   int kdx = ystart+1;
5467   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
5468   //     huge_128 tmp3 = (y[idx+1] * rdx) + z[kdx+idx+1] + carry;
5469   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
5470   //     huge_128 tmp4 = (y[idx]   * rdx) + z[kdx+idx] + carry2;
5471   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
5472   //     z[kdx+idx+1] = (jlong)tmp3;
5473   //     z[kdx+idx] = (jlong)tmp4;
5474   //   }
5475   //   idx += 2;
5476   //   if (idx &gt; 0) {
5477   //     yz_idx1 = (y[idx] * rdx) + z[kdx+idx] + carry;
5478   //     z[kdx+idx] = (jlong)yz_idx1;
5479   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
5480   //   }
5481   //
5482 
5483   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
5484 
5485   movl(jdx, idx);
5486   andl(jdx, 0xFFFFFFFC);
5487   shrl(jdx, 2);
5488 
5489   bind(L_third_loop);
5490   subl(jdx, 1);
5491   jcc(Assembler::negative, L_third_loop_exit);
5492   subl(idx, 4);
5493 
5494   movq(yz_idx1,  Address(y, idx, Address::times_4,  8));
5495   rorxq(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
5496   movq(yz_idx2, Address(y, idx, Address::times_4,  0));
5497   rorxq(yz_idx2, yz_idx2, 32);
5498 
5499   mulxq(tmp4, tmp3, yz_idx1);  //  yz_idx1 * rdx -&gt; tmp4:tmp3
5500   mulxq(carry2, tmp, yz_idx2); //  yz_idx2 * rdx -&gt; carry2:tmp
5501 
5502   movq(yz_idx1,  Address(z, idx, Address::times_4,  8));
5503   rorxq(yz_idx1, yz_idx1, 32);
5504   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
5505   rorxq(yz_idx2, yz_idx2, 32);
5506 
5507   if (VM_Version::supports_adx()) {
5508     adcxq(tmp3, carry);
5509     adoxq(tmp3, yz_idx1);
5510 
5511     adcxq(tmp4, tmp);
5512     adoxq(tmp4, yz_idx2);
5513 
5514     movl(carry, 0); // does not affect flags
5515     adcxq(carry2, carry);
5516     adoxq(carry2, carry);
5517   } else {
5518     add2_with_carry(tmp4, tmp3, carry, yz_idx1);
5519     add2_with_carry(carry2, tmp4, tmp, yz_idx2);
5520   }
5521   movq(carry, carry2);
5522 
5523   movl(Address(z, idx, Address::times_4, 12), tmp3);
5524   shrq(tmp3, 32);
5525   movl(Address(z, idx, Address::times_4,  8), tmp3);
5526 
5527   movl(Address(z, idx, Address::times_4,  4), tmp4);
5528   shrq(tmp4, 32);
5529   movl(Address(z, idx, Address::times_4,  0), tmp4);
5530 
5531   jmp(L_third_loop);
5532 
5533   bind (L_third_loop_exit);
5534 
5535   andl (idx, 0x3);
5536   jcc(Assembler::zero, L_post_third_loop_done);
5537 
5538   Label L_check_1;
5539   subl(idx, 2);
5540   jcc(Assembler::negative, L_check_1);
5541 
5542   movq(yz_idx1, Address(y, idx, Address::times_4,  0));
5543   rorxq(yz_idx1, yz_idx1, 32);
5544   mulxq(tmp4, tmp3, yz_idx1); //  yz_idx1 * rdx -&gt; tmp4:tmp3
5545   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
5546   rorxq(yz_idx2, yz_idx2, 32);
5547 
5548   add2_with_carry(tmp4, tmp3, carry, yz_idx2);
5549 
5550   movl(Address(z, idx, Address::times_4,  4), tmp3);
5551   shrq(tmp3, 32);
5552   movl(Address(z, idx, Address::times_4,  0), tmp3);
5553   movq(carry, tmp4);
5554 
5555   bind (L_check_1);
5556   addl (idx, 0x2);
5557   andl (idx, 0x1);
5558   subl(idx, 1);
5559   jcc(Assembler::negative, L_post_third_loop_done);
5560   movl(tmp4, Address(y, idx, Address::times_4,  0));
5561   mulxq(carry2, tmp3, tmp4);  //  tmp4 * rdx -&gt; carry2:tmp3
5562   movl(tmp4, Address(z, idx, Address::times_4,  0));
5563 
5564   add2_with_carry(carry2, tmp3, tmp4, carry);
5565 
5566   movl(Address(z, idx, Address::times_4,  0), tmp3);
5567   shrq(tmp3, 32);
5568 
5569   shlq(carry2, 32);
5570   orq(tmp3, carry2);
5571   movq(carry, tmp3);
5572 
5573   bind(L_post_third_loop_done);
5574 }
5575 
5576 /**
5577  * Code for BigInteger::multiplyToLen() instrinsic.
5578  *
5579  * rdi: x
5580  * rax: xlen
5581  * rsi: y
5582  * rcx: ylen
5583  * r8:  z
5584  * r11: zlen
5585  * r12: tmp1
5586  * r13: tmp2
5587  * r14: tmp3
5588  * r15: tmp4
5589  * rbx: tmp5
5590  *
5591  */
5592 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
5593                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {
5594   ShortBranchVerifier sbv(this);
5595   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);
5596 
5597   push(tmp1);
5598   push(tmp2);
5599   push(tmp3);
5600   push(tmp4);
5601   push(tmp5);
5602 
5603   push(xlen);
5604   push(zlen);
5605 
5606   const Register idx = tmp1;
5607   const Register kdx = tmp2;
5608   const Register xstart = tmp3;
5609 
5610   const Register y_idx = tmp4;
5611   const Register carry = tmp5;
5612   const Register product  = xlen;
5613   const Register x_xstart = zlen;  // reuse register
5614 
5615   // First Loop.
5616   //
5617   //  final static long LONG_MASK = 0xffffffffL;
5618   //  int xstart = xlen - 1;
5619   //  int ystart = ylen - 1;
5620   //  long carry = 0;
5621   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
5622   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
5623   //    z[kdx] = (int)product;
5624   //    carry = product &gt;&gt;&gt; 32;
5625   //  }
5626   //  z[xstart] = (int)carry;
5627   //
5628 
5629   movl(idx, ylen);      // idx = ylen;
5630   movl(kdx, zlen);      // kdx = xlen+ylen;
5631   xorq(carry, carry);   // carry = 0;
5632 
5633   Label L_done;
5634 
5635   movl(xstart, xlen);
5636   decrementl(xstart);
5637   jcc(Assembler::negative, L_done);
5638 
5639   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
5640 
5641   Label L_second_loop;
5642   testl(kdx, kdx);
5643   jcc(Assembler::zero, L_second_loop);
5644 
5645   Label L_carry;
5646   subl(kdx, 1);
5647   jcc(Assembler::zero, L_carry);
5648 
5649   movl(Address(z, kdx, Address::times_4,  0), carry);
5650   shrq(carry, 32);
5651   subl(kdx, 1);
5652 
5653   bind(L_carry);
5654   movl(Address(z, kdx, Address::times_4,  0), carry);
5655 
5656   // Second and third (nested) loops.
5657   //
5658   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
5659   //   carry = 0;
5660   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
5661   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
5662   //                    (z[k] &amp; LONG_MASK) + carry;
5663   //     z[k] = (int)product;
5664   //     carry = product &gt;&gt;&gt; 32;
5665   //   }
5666   //   z[i] = (int)carry;
5667   // }
5668   //
5669   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
5670 
5671   const Register jdx = tmp1;
5672 
5673   bind(L_second_loop);
5674   xorl(carry, carry);    // carry = 0;
5675   movl(jdx, ylen);       // j = ystart+1
5676 
5677   subl(xstart, 1);       // i = xstart-1;
5678   jcc(Assembler::negative, L_done);
5679 
5680   push (z);
5681 
5682   Label L_last_x;
5683   lea(z, Address(z, xstart, Address::times_4, 4)); // z = z + k - j
5684   subl(xstart, 1);       // i = xstart-1;
5685   jcc(Assembler::negative, L_last_x);
5686 
5687   if (UseBMI2Instructions) {
5688     movq(rdx,  Address(x, xstart, Address::times_4,  0));
5689     rorxq(rdx, rdx, 32); // convert big-endian to little-endian
5690   } else {
5691     movq(x_xstart, Address(x, xstart, Address::times_4,  0));
5692     rorq(x_xstart, 32);  // convert big-endian to little-endian
5693   }
5694 
5695   Label L_third_loop_prologue;
5696   bind(L_third_loop_prologue);
5697 
5698   push (x);
5699   push (xstart);
5700   push (ylen);
5701 
5702 
5703   if (UseBMI2Instructions) {
5704     multiply_128_x_128_bmi2_loop(y, z, carry, x, jdx, ylen, product, tmp2, x_xstart, tmp3, tmp4);
5705   } else { // !UseBMI2Instructions
5706     multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
5707   }
5708 
5709   pop(ylen);
5710   pop(xlen);
5711   pop(x);
5712   pop(z);
5713 
5714   movl(tmp3, xlen);
5715   addl(tmp3, 1);
5716   movl(Address(z, tmp3, Address::times_4,  0), carry);
5717   subl(tmp3, 1);
5718   jccb(Assembler::negative, L_done);
5719 
5720   shrq(carry, 32);
5721   movl(Address(z, tmp3, Address::times_4,  0), carry);
5722   jmp(L_second_loop);
5723 
5724   // Next infrequent code is moved outside loops.
5725   bind(L_last_x);
5726   if (UseBMI2Instructions) {
5727     movl(rdx, Address(x,  0));
5728   } else {
5729     movl(x_xstart, Address(x,  0));
5730   }
5731   jmp(L_third_loop_prologue);
5732 
5733   bind(L_done);
5734 
5735   pop(zlen);
5736   pop(xlen);
5737 
5738   pop(tmp5);
5739   pop(tmp4);
5740   pop(tmp3);
5741   pop(tmp2);
5742   pop(tmp1);
5743 }
5744 
5745 void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
5746   Register result, Register tmp1, Register tmp2, XMMRegister rymm0, XMMRegister rymm1, XMMRegister rymm2){
5747   assert(UseSSE42Intrinsics, &quot;SSE4.2 must be enabled.&quot;);
5748   Label VECTOR16_LOOP, VECTOR8_LOOP, VECTOR4_LOOP;
5749   Label VECTOR8_TAIL, VECTOR4_TAIL;
5750   Label VECTOR32_NOT_EQUAL, VECTOR16_NOT_EQUAL, VECTOR8_NOT_EQUAL, VECTOR4_NOT_EQUAL;
5751   Label SAME_TILL_END, DONE;
5752   Label BYTES_LOOP, BYTES_TAIL, BYTES_NOT_EQUAL;
5753 
5754   //scale is in rcx in both Win64 and Unix
5755   ShortBranchVerifier sbv(this);
5756 
5757   shlq(length);
5758   xorq(result, result);
5759 
5760   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp;
5761       VM_Version::supports_avx512vlbw()) {
5762     Label VECTOR64_LOOP, VECTOR64_NOT_EQUAL, VECTOR32_TAIL;
5763 
5764     cmpq(length, 64);
5765     jcc(Assembler::less, VECTOR32_TAIL);
5766 
5767     movq(tmp1, length);
5768     andq(tmp1, 0x3F);      // tail count
5769     andq(length, ~(0x3F)); //vector count
5770 
5771     bind(VECTOR64_LOOP);
5772     // AVX512 code to compare 64 byte vectors.
5773     evmovdqub(rymm0, Address(obja, result), Assembler::AVX_512bit);
5774     evpcmpeqb(k7, rymm0, Address(objb, result), Assembler::AVX_512bit);
5775     kortestql(k7, k7);
5776     jcc(Assembler::aboveEqual, VECTOR64_NOT_EQUAL);     // mismatch
5777     addq(result, 64);
5778     subq(length, 64);
5779     jccb(Assembler::notZero, VECTOR64_LOOP);
5780 
5781     //bind(VECTOR64_TAIL);
5782     testq(tmp1, tmp1);
5783     jcc(Assembler::zero, SAME_TILL_END);
5784 
5785     //bind(VECTOR64_TAIL);
5786     // AVX512 code to compare upto 63 byte vectors.
5787     mov64(tmp2, 0xFFFFFFFFFFFFFFFF);
5788     shlxq(tmp2, tmp2, tmp1);
5789     notq(tmp2);
5790     kmovql(k3, tmp2);
5791 
5792     evmovdqub(rymm0, k3, Address(obja, result), Assembler::AVX_512bit);
5793     evpcmpeqb(k7, k3, rymm0, Address(objb, result), Assembler::AVX_512bit);
5794 
5795     ktestql(k7, k3);
5796     jcc(Assembler::below, SAME_TILL_END);     // not mismatch
5797 
5798     bind(VECTOR64_NOT_EQUAL);
5799     kmovql(tmp1, k7);
5800     notq(tmp1);
5801     tzcntq(tmp1, tmp1);
5802     addq(result, tmp1);
5803     shrq(result);
5804     jmp(DONE);
5805     bind(VECTOR32_TAIL);
5806   }
5807 
5808   cmpq(length, 8);
5809   jcc(Assembler::equal, VECTOR8_LOOP);
5810   jcc(Assembler::less, VECTOR4_TAIL);
5811 
5812   if (UseAVX &gt;= 2) {
5813     Label VECTOR16_TAIL, VECTOR32_LOOP;
5814 
5815     cmpq(length, 16);
5816     jcc(Assembler::equal, VECTOR16_LOOP);
5817     jcc(Assembler::less, VECTOR8_LOOP);
5818 
5819     cmpq(length, 32);
5820     jccb(Assembler::less, VECTOR16_TAIL);
5821 
5822     subq(length, 32);
5823     bind(VECTOR32_LOOP);
5824     vmovdqu(rymm0, Address(obja, result));
5825     vmovdqu(rymm1, Address(objb, result));
5826     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_256bit);
5827     vptest(rymm2, rymm2);
5828     jcc(Assembler::notZero, VECTOR32_NOT_EQUAL);//mismatch found
5829     addq(result, 32);
5830     subq(length, 32);
5831     jcc(Assembler::greaterEqual, VECTOR32_LOOP);
5832     addq(length, 32);
5833     jcc(Assembler::equal, SAME_TILL_END);
5834     //falling through if less than 32 bytes left //close the branch here.
5835 
5836     bind(VECTOR16_TAIL);
5837     cmpq(length, 16);
5838     jccb(Assembler::less, VECTOR8_TAIL);
5839     bind(VECTOR16_LOOP);
5840     movdqu(rymm0, Address(obja, result));
5841     movdqu(rymm1, Address(objb, result));
5842     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_128bit);
5843     ptest(rymm2, rymm2);
5844     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
5845     addq(result, 16);
5846     subq(length, 16);
5847     jcc(Assembler::equal, SAME_TILL_END);
5848     //falling through if less than 16 bytes left
5849   } else {//regular intrinsics
5850 
5851     cmpq(length, 16);
5852     jccb(Assembler::less, VECTOR8_TAIL);
5853 
5854     subq(length, 16);
5855     bind(VECTOR16_LOOP);
5856     movdqu(rymm0, Address(obja, result));
5857     movdqu(rymm1, Address(objb, result));
5858     pxor(rymm0, rymm1);
5859     ptest(rymm0, rymm0);
5860     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
5861     addq(result, 16);
5862     subq(length, 16);
5863     jccb(Assembler::greaterEqual, VECTOR16_LOOP);
5864     addq(length, 16);
5865     jcc(Assembler::equal, SAME_TILL_END);
5866     //falling through if less than 16 bytes left
5867   }
5868 
5869   bind(VECTOR8_TAIL);
5870   cmpq(length, 8);
5871   jccb(Assembler::less, VECTOR4_TAIL);
5872   bind(VECTOR8_LOOP);
5873   movq(tmp1, Address(obja, result));
5874   movq(tmp2, Address(objb, result));
5875   xorq(tmp1, tmp2);
5876   testq(tmp1, tmp1);
5877   jcc(Assembler::notZero, VECTOR8_NOT_EQUAL);//mismatch found
5878   addq(result, 8);
5879   subq(length, 8);
5880   jcc(Assembler::equal, SAME_TILL_END);
5881   //falling through if less than 8 bytes left
5882 
5883   bind(VECTOR4_TAIL);
5884   cmpq(length, 4);
5885   jccb(Assembler::less, BYTES_TAIL);
5886   bind(VECTOR4_LOOP);
5887   movl(tmp1, Address(obja, result));
5888   xorl(tmp1, Address(objb, result));
5889   testl(tmp1, tmp1);
5890   jcc(Assembler::notZero, VECTOR4_NOT_EQUAL);//mismatch found
5891   addq(result, 4);
5892   subq(length, 4);
5893   jcc(Assembler::equal, SAME_TILL_END);
5894   //falling through if less than 4 bytes left
5895 
5896   bind(BYTES_TAIL);
5897   bind(BYTES_LOOP);
5898   load_unsigned_byte(tmp1, Address(obja, result));
5899   load_unsigned_byte(tmp2, Address(objb, result));
5900   xorl(tmp1, tmp2);
5901   testl(tmp1, tmp1);
5902   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5903   decq(length);
5904   jcc(Assembler::zero, SAME_TILL_END);
5905   incq(result);
5906   load_unsigned_byte(tmp1, Address(obja, result));
5907   load_unsigned_byte(tmp2, Address(objb, result));
5908   xorl(tmp1, tmp2);
5909   testl(tmp1, tmp1);
5910   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5911   decq(length);
5912   jcc(Assembler::zero, SAME_TILL_END);
5913   incq(result);
5914   load_unsigned_byte(tmp1, Address(obja, result));
5915   load_unsigned_byte(tmp2, Address(objb, result));
5916   xorl(tmp1, tmp2);
5917   testl(tmp1, tmp1);
5918   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
5919   jmp(SAME_TILL_END);
5920 
5921   if (UseAVX &gt;= 2) {
5922     bind(VECTOR32_NOT_EQUAL);
5923     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_256bit);
5924     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_256bit);
5925     vpxor(rymm0, rymm0, rymm2, Assembler::AVX_256bit);
5926     vpmovmskb(tmp1, rymm0);
5927     bsfq(tmp1, tmp1);
5928     addq(result, tmp1);
5929     shrq(result);
5930     jmp(DONE);
5931   }
5932 
5933   bind(VECTOR16_NOT_EQUAL);
5934   if (UseAVX &gt;= 2) {
5935     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_128bit);
5936     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_128bit);
5937     pxor(rymm0, rymm2);
5938   } else {
5939     pcmpeqb(rymm2, rymm2);
5940     pxor(rymm0, rymm1);
5941     pcmpeqb(rymm0, rymm1);
5942     pxor(rymm0, rymm2);
5943   }
5944   pmovmskb(tmp1, rymm0);
5945   bsfq(tmp1, tmp1);
5946   addq(result, tmp1);
5947   shrq(result);
5948   jmpb(DONE);
5949 
5950   bind(VECTOR8_NOT_EQUAL);
5951   bind(VECTOR4_NOT_EQUAL);
5952   bsfq(tmp1, tmp1);
5953   shrq(tmp1, 3);
5954   addq(result, tmp1);
5955   bind(BYTES_NOT_EQUAL);
5956   shrq(result);
5957   jmpb(DONE);
5958 
5959   bind(SAME_TILL_END);
5960   mov64(result, -1);
5961 
5962   bind(DONE);
5963 }
5964 
5965 //Helper functions for square_to_len()
5966 
5967 /**
5968  * Store the squares of x[], right shifted one bit (divided by 2) into z[]
5969  * Preserves x and z and modifies rest of the registers.
5970  */
5971 void MacroAssembler::square_rshift(Register x, Register xlen, Register z, Register tmp1, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
5972   // Perform square and right shift by 1
5973   // Handle odd xlen case first, then for even xlen do the following
5974   // jlong carry = 0;
5975   // for (int j=0, i=0; j &lt; xlen; j+=2, i+=4) {
5976   //     huge_128 product = x[j:j+1] * x[j:j+1];
5977   //     z[i:i+1] = (carry &lt;&lt; 63) | (jlong)(product &gt;&gt;&gt; 65);
5978   //     z[i+2:i+3] = (jlong)(product &gt;&gt;&gt; 1);
5979   //     carry = (jlong)product;
5980   // }
5981 
5982   xorq(tmp5, tmp5);     // carry
5983   xorq(rdxReg, rdxReg);
5984   xorl(tmp1, tmp1);     // index for x
5985   xorl(tmp4, tmp4);     // index for z
5986 
5987   Label L_first_loop, L_first_loop_exit;
5988 
5989   testl(xlen, 1);
5990   jccb(Assembler::zero, L_first_loop); //jump if xlen is even
5991 
5992   // Square and right shift by 1 the odd element using 32 bit multiply
5993   movl(raxReg, Address(x, tmp1, Address::times_4, 0));
5994   imulq(raxReg, raxReg);
5995   shrq(raxReg, 1);
5996   adcq(tmp5, 0);
5997   movq(Address(z, tmp4, Address::times_4, 0), raxReg);
5998   incrementl(tmp1);
5999   addl(tmp4, 2);
6000 
6001   // Square and  right shift by 1 the rest using 64 bit multiply
6002   bind(L_first_loop);
6003   cmpptr(tmp1, xlen);
6004   jccb(Assembler::equal, L_first_loop_exit);
6005 
6006   // Square
6007   movq(raxReg, Address(x, tmp1, Address::times_4,  0));
6008   rorq(raxReg, 32);    // convert big-endian to little-endian
6009   mulq(raxReg);        // 64-bit multiply rax * rax -&gt; rdx:rax
6010 
6011   // Right shift by 1 and save carry
6012   shrq(tmp5, 1);       // rdx:rax:tmp5 = (tmp5:rdx:rax) &gt;&gt;&gt; 1
6013   rcrq(rdxReg, 1);
6014   rcrq(raxReg, 1);
6015   adcq(tmp5, 0);
6016 
6017   // Store result in z
6018   movq(Address(z, tmp4, Address::times_4, 0), rdxReg);
6019   movq(Address(z, tmp4, Address::times_4, 8), raxReg);
6020 
6021   // Update indices for x and z
6022   addl(tmp1, 2);
6023   addl(tmp4, 4);
6024   jmp(L_first_loop);
6025 
6026   bind(L_first_loop_exit);
6027 }
6028 
6029 
6030 /**
6031  * Perform the following multiply add operation using BMI2 instructions
6032  * carry:sum = sum + op1*op2 + carry
6033  * op2 should be in rdx
6034  * op2 is preserved, all other registers are modified
6035  */
6036 void MacroAssembler::multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry, Register tmp2) {
6037   // assert op2 is rdx
6038   mulxq(tmp2, op1, op1);  //  op1 * op2 -&gt; tmp2:op1
6039   addq(sum, carry);
6040   adcq(tmp2, 0);
6041   addq(sum, op1);
6042   adcq(tmp2, 0);
6043   movq(carry, tmp2);
6044 }
6045 
6046 /**
6047  * Perform the following multiply add operation:
6048  * carry:sum = sum + op1*op2 + carry
6049  * Preserves op1, op2 and modifies rest of registers
6050  */
6051 void MacroAssembler::multiply_add_64(Register sum, Register op1, Register op2, Register carry, Register rdxReg, Register raxReg) {
6052   // rdx:rax = op1 * op2
6053   movq(raxReg, op2);
6054   mulq(op1);
6055 
6056   //  rdx:rax = sum + carry + rdx:rax
6057   addq(sum, carry);
6058   adcq(rdxReg, 0);
6059   addq(sum, raxReg);
6060   adcq(rdxReg, 0);
6061 
6062   // carry:sum = rdx:sum
6063   movq(carry, rdxReg);
6064 }
6065 
6066 /**
6067  * Add 64 bit long carry into z[] with carry propogation.
6068  * Preserves z and carry register values and modifies rest of registers.
6069  *
6070  */
6071 void MacroAssembler::add_one_64(Register z, Register zlen, Register carry, Register tmp1) {
6072   Label L_fourth_loop, L_fourth_loop_exit;
6073 
6074   movl(tmp1, 1);
6075   subl(zlen, 2);
6076   addq(Address(z, zlen, Address::times_4, 0), carry);
6077 
6078   bind(L_fourth_loop);
6079   jccb(Assembler::carryClear, L_fourth_loop_exit);
6080   subl(zlen, 2);
6081   jccb(Assembler::negative, L_fourth_loop_exit);
6082   addq(Address(z, zlen, Address::times_4, 0), tmp1);
6083   jmp(L_fourth_loop);
6084   bind(L_fourth_loop_exit);
6085 }
6086 
6087 /**
6088  * Shift z[] left by 1 bit.
6089  * Preserves x, len, z and zlen registers and modifies rest of the registers.
6090  *
6091  */
6092 void MacroAssembler::lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {
6093 
6094   Label L_fifth_loop, L_fifth_loop_exit;
6095 
6096   // Fifth loop
6097   // Perform primitiveLeftShift(z, zlen, 1)
6098 
6099   const Register prev_carry = tmp1;
6100   const Register new_carry = tmp4;
6101   const Register value = tmp2;
6102   const Register zidx = tmp3;
6103 
6104   // int zidx, carry;
6105   // long value;
6106   // carry = 0;
6107   // for (zidx = zlen-2; zidx &gt;=0; zidx -= 2) {
6108   //    (carry:value)  = (z[i] &lt;&lt; 1) | carry ;
6109   //    z[i] = value;
6110   // }
6111 
6112   movl(zidx, zlen);
6113   xorl(prev_carry, prev_carry); // clear carry flag and prev_carry register
6114 
6115   bind(L_fifth_loop);
6116   decl(zidx);  // Use decl to preserve carry flag
6117   decl(zidx);
6118   jccb(Assembler::negative, L_fifth_loop_exit);
6119 
6120   if (UseBMI2Instructions) {
6121      movq(value, Address(z, zidx, Address::times_4, 0));
6122      rclq(value, 1);
6123      rorxq(value, value, 32);
6124      movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6125   }
6126   else {
6127     // clear new_carry
6128     xorl(new_carry, new_carry);
6129 
6130     // Shift z[i] by 1, or in previous carry and save new carry
6131     movq(value, Address(z, zidx, Address::times_4, 0));
6132     shlq(value, 1);
6133     adcl(new_carry, 0);
6134 
6135     orq(value, prev_carry);
6136     rorq(value, 0x20);
6137     movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6138 
6139     // Set previous carry = new carry
6140     movl(prev_carry, new_carry);
6141   }
6142   jmp(L_fifth_loop);
6143 
6144   bind(L_fifth_loop_exit);
6145 }
6146 
6147 
6148 /**
6149  * Code for BigInteger::squareToLen() intrinsic
6150  *
6151  * rdi: x
6152  * rsi: len
6153  * r8:  z
6154  * rcx: zlen
6155  * r12: tmp1
6156  * r13: tmp2
6157  * r14: tmp3
6158  * r15: tmp4
6159  * rbx: tmp5
6160  *
6161  */
6162 void MacroAssembler::square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6163 
6164   Label L_second_loop, L_second_loop_exit, L_third_loop, L_third_loop_exit, L_last_x, L_multiply;
6165   push(tmp1);
6166   push(tmp2);
6167   push(tmp3);
6168   push(tmp4);
6169   push(tmp5);
6170 
6171   // First loop
6172   // Store the squares, right shifted one bit (i.e., divided by 2).
6173   square_rshift(x, len, z, tmp1, tmp3, tmp4, tmp5, rdxReg, raxReg);
6174 
6175   // Add in off-diagonal sums.
6176   //
6177   // Second, third (nested) and fourth loops.
6178   // zlen +=2;
6179   // for (int xidx=len-2,zidx=zlen-4; xidx &gt; 0; xidx-=2,zidx-=4) {
6180   //    carry = 0;
6181   //    long op2 = x[xidx:xidx+1];
6182   //    for (int j=xidx-2,k=zidx; j &gt;= 0; j-=2) {
6183   //       k -= 2;
6184   //       long op1 = x[j:j+1];
6185   //       long sum = z[k:k+1];
6186   //       carry:sum = multiply_add_64(sum, op1, op2, carry, tmp_regs);
6187   //       z[k:k+1] = sum;
6188   //    }
6189   //    add_one_64(z, k, carry, tmp_regs);
6190   // }
6191 
6192   const Register carry = tmp5;
6193   const Register sum = tmp3;
6194   const Register op1 = tmp4;
6195   Register op2 = tmp2;
6196 
6197   push(zlen);
6198   push(len);
6199   addl(zlen,2);
6200   bind(L_second_loop);
6201   xorq(carry, carry);
6202   subl(zlen, 4);
6203   subl(len, 2);
6204   push(zlen);
6205   push(len);
6206   cmpl(len, 0);
6207   jccb(Assembler::lessEqual, L_second_loop_exit);
6208 
6209   // Multiply an array by one 64 bit long.
6210   if (UseBMI2Instructions) {
6211     op2 = rdxReg;
6212     movq(op2, Address(x, len, Address::times_4,  0));
6213     rorxq(op2, op2, 32);
6214   }
6215   else {
6216     movq(op2, Address(x, len, Address::times_4,  0));
6217     rorq(op2, 32);
6218   }
6219 
6220   bind(L_third_loop);
6221   decrementl(len);
6222   jccb(Assembler::negative, L_third_loop_exit);
6223   decrementl(len);
6224   jccb(Assembler::negative, L_last_x);
6225 
6226   movq(op1, Address(x, len, Address::times_4,  0));
6227   rorq(op1, 32);
6228 
6229   bind(L_multiply);
6230   subl(zlen, 2);
6231   movq(sum, Address(z, zlen, Address::times_4,  0));
6232 
6233   // Multiply 64 bit by 64 bit and add 64 bits lower half and upper 64 bits as carry.
6234   if (UseBMI2Instructions) {
6235     multiply_add_64_bmi2(sum, op1, op2, carry, tmp2);
6236   }
6237   else {
6238     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6239   }
6240 
6241   movq(Address(z, zlen, Address::times_4, 0), sum);
6242 
6243   jmp(L_third_loop);
6244   bind(L_third_loop_exit);
6245 
6246   // Fourth loop
6247   // Add 64 bit long carry into z with carry propogation.
6248   // Uses offsetted zlen.
6249   add_one_64(z, zlen, carry, tmp1);
6250 
6251   pop(len);
6252   pop(zlen);
6253   jmp(L_second_loop);
6254 
6255   // Next infrequent code is moved outside loops.
6256   bind(L_last_x);
6257   movl(op1, Address(x, 0));
6258   jmp(L_multiply);
6259 
6260   bind(L_second_loop_exit);
6261   pop(len);
6262   pop(zlen);
6263   pop(len);
6264   pop(zlen);
6265 
6266   // Fifth loop
6267   // Shift z left 1 bit.
6268   lshift_by_1(x, len, z, zlen, tmp1, tmp2, tmp3, tmp4);
6269 
6270   // z[zlen-1] |= x[len-1] &amp; 1;
6271   movl(tmp3, Address(x, len, Address::times_4, -4));
6272   andl(tmp3, 1);
6273   orl(Address(z, zlen, Address::times_4,  -4), tmp3);
6274 
6275   pop(tmp5);
6276   pop(tmp4);
6277   pop(tmp3);
6278   pop(tmp2);
6279   pop(tmp1);
6280 }
6281 
6282 /**
6283  * Helper function for mul_add()
6284  * Multiply the in[] by int k and add to out[] starting at offset offs using
6285  * 128 bit by 32 bit multiply and return the carry in tmp5.
6286  * Only quad int aligned length of in[] is operated on in this function.
6287  * k is in rdxReg for BMI2Instructions, for others it is in tmp2.
6288  * This function preserves out, in and k registers.
6289  * len and offset point to the appropriate index in &quot;in&quot; &amp; &quot;out&quot; correspondingly
6290  * tmp5 has the carry.
6291  * other registers are temporary and are modified.
6292  *
6293  */
6294 void MacroAssembler::mul_add_128_x_32_loop(Register out, Register in,
6295   Register offset, Register len, Register tmp1, Register tmp2, Register tmp3,
6296   Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6297 
6298   Label L_first_loop, L_first_loop_exit;
6299 
6300   movl(tmp1, len);
6301   shrl(tmp1, 2);
6302 
6303   bind(L_first_loop);
6304   subl(tmp1, 1);
6305   jccb(Assembler::negative, L_first_loop_exit);
6306 
6307   subl(len, 4);
6308   subl(offset, 4);
6309 
6310   Register op2 = tmp2;
6311   const Register sum = tmp3;
6312   const Register op1 = tmp4;
6313   const Register carry = tmp5;
6314 
6315   if (UseBMI2Instructions) {
6316     op2 = rdxReg;
6317   }
6318 
6319   movq(op1, Address(in, len, Address::times_4,  8));
6320   rorq(op1, 32);
6321   movq(sum, Address(out, offset, Address::times_4,  8));
6322   rorq(sum, 32);
6323   if (UseBMI2Instructions) {
6324     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6325   }
6326   else {
6327     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6328   }
6329   // Store back in big endian from little endian
6330   rorq(sum, 0x20);
6331   movq(Address(out, offset, Address::times_4,  8), sum);
6332 
6333   movq(op1, Address(in, len, Address::times_4,  0));
6334   rorq(op1, 32);
6335   movq(sum, Address(out, offset, Address::times_4,  0));
6336   rorq(sum, 32);
6337   if (UseBMI2Instructions) {
6338     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6339   }
6340   else {
6341     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6342   }
6343   // Store back in big endian from little endian
6344   rorq(sum, 0x20);
6345   movq(Address(out, offset, Address::times_4,  0), sum);
6346 
6347   jmp(L_first_loop);
6348   bind(L_first_loop_exit);
6349 }
6350 
6351 /**
6352  * Code for BigInteger::mulAdd() intrinsic
6353  *
6354  * rdi: out
6355  * rsi: in
6356  * r11: offs (out.length - offset)
6357  * rcx: len
6358  * r8:  k
6359  * r12: tmp1
6360  * r13: tmp2
6361  * r14: tmp3
6362  * r15: tmp4
6363  * rbx: tmp5
6364  * Multiply the in[] by word k and add to out[], return the carry in rax
6365  */
6366 void MacroAssembler::mul_add(Register out, Register in, Register offs,
6367    Register len, Register k, Register tmp1, Register tmp2, Register tmp3,
6368    Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6369 
6370   Label L_carry, L_last_in, L_done;
6371 
6372 // carry = 0;
6373 // for (int j=len-1; j &gt;= 0; j--) {
6374 //    long product = (in[j] &amp; LONG_MASK) * kLong +
6375 //                   (out[offs] &amp; LONG_MASK) + carry;
6376 //    out[offs--] = (int)product;
6377 //    carry = product &gt;&gt;&gt; 32;
6378 // }
6379 //
6380   push(tmp1);
6381   push(tmp2);
6382   push(tmp3);
6383   push(tmp4);
6384   push(tmp5);
6385 
6386   Register op2 = tmp2;
6387   const Register sum = tmp3;
6388   const Register op1 = tmp4;
6389   const Register carry =  tmp5;
6390 
6391   if (UseBMI2Instructions) {
6392     op2 = rdxReg;
6393     movl(op2, k);
6394   }
6395   else {
6396     movl(op2, k);
6397   }
6398 
6399   xorq(carry, carry);
6400 
6401   //First loop
6402 
6403   //Multiply in[] by k in a 4 way unrolled loop using 128 bit by 32 bit multiply
6404   //The carry is in tmp5
6405   mul_add_128_x_32_loop(out, in, offs, len, tmp1, tmp2, tmp3, tmp4, tmp5, rdxReg, raxReg);
6406 
6407   //Multiply the trailing in[] entry using 64 bit by 32 bit, if any
6408   decrementl(len);
6409   jccb(Assembler::negative, L_carry);
6410   decrementl(len);
6411   jccb(Assembler::negative, L_last_in);
6412 
6413   movq(op1, Address(in, len, Address::times_4,  0));
6414   rorq(op1, 32);
6415 
6416   subl(offs, 2);
6417   movq(sum, Address(out, offs, Address::times_4,  0));
6418   rorq(sum, 32);
6419 
6420   if (UseBMI2Instructions) {
6421     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
6422   }
6423   else {
6424     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6425   }
6426 
6427   // Store back in big endian from little endian
6428   rorq(sum, 0x20);
6429   movq(Address(out, offs, Address::times_4,  0), sum);
6430 
6431   testl(len, len);
6432   jccb(Assembler::zero, L_carry);
6433 
6434   //Multiply the last in[] entry, if any
6435   bind(L_last_in);
6436   movl(op1, Address(in, 0));
6437   movl(sum, Address(out, offs, Address::times_4,  -4));
6438 
6439   movl(raxReg, k);
6440   mull(op1); //tmp4 * eax -&gt; edx:eax
6441   addl(sum, carry);
6442   adcl(rdxReg, 0);
6443   addl(sum, raxReg);
6444   adcl(rdxReg, 0);
6445   movl(carry, rdxReg);
6446 
6447   movl(Address(out, offs, Address::times_4,  -4), sum);
6448 
6449   bind(L_carry);
6450   //return tmp5/carry as carry in rax
6451   movl(rax, carry);
6452 
6453   bind(L_done);
6454   pop(tmp5);
6455   pop(tmp4);
6456   pop(tmp3);
6457   pop(tmp2);
6458   pop(tmp1);
6459 }
6460 #endif
6461 
6462 /**
6463  * Emits code to update CRC-32 with a byte value according to constants in table
6464  *
6465  * @param [in,out]crc   Register containing the crc.
6466  * @param [in]val       Register containing the byte to fold into the CRC.
6467  * @param [in]table     Register containing the table of crc constants.
6468  *
6469  * uint32_t crc;
6470  * val = crc_table[(val ^ crc) &amp; 0xFF];
6471  * crc = val ^ (crc &gt;&gt; 8);
6472  *
6473  */
6474 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
6475   xorl(val, crc);
6476   andl(val, 0xFF);
6477   shrl(crc, 8); // unsigned shift
6478   xorl(crc, Address(table, val, Address::times_4, 0));
6479 }
6480 
6481 /**
6482 * Fold four 128-bit data chunks
6483 */
6484 void MacroAssembler::fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
6485   evpclmulhdq(xtmp, xK, xcrc, Assembler::AVX_512bit); // [123:64]
6486   evpclmulldq(xcrc, xK, xcrc, Assembler::AVX_512bit); // [63:0]
6487   evpxorq(xcrc, xcrc, Address(buf, offset), Assembler::AVX_512bit /* vector_len */);
6488   evpxorq(xcrc, xcrc, xtmp, Assembler::AVX_512bit /* vector_len */);
6489 }
6490 
6491 /**
6492  * Fold 128-bit data chunk
6493  */
6494 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
6495   if (UseAVX &gt; 0) {
6496     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
6497     vpclmulldq(xcrc, xK, xcrc); // [63:0]
6498     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
6499     pxor(xcrc, xtmp);
6500   } else {
6501     movdqa(xtmp, xcrc);
6502     pclmulhdq(xtmp, xK);   // [123:64]
6503     pclmulldq(xcrc, xK);   // [63:0]
6504     pxor(xcrc, xtmp);
6505     movdqu(xtmp, Address(buf, offset));
6506     pxor(xcrc, xtmp);
6507   }
6508 }
6509 
6510 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
6511   if (UseAVX &gt; 0) {
6512     vpclmulhdq(xtmp, xK, xcrc);
6513     vpclmulldq(xcrc, xK, xcrc);
6514     pxor(xcrc, xbuf);
6515     pxor(xcrc, xtmp);
6516   } else {
6517     movdqa(xtmp, xcrc);
6518     pclmulhdq(xtmp, xK);
6519     pclmulldq(xcrc, xK);
6520     pxor(xcrc, xbuf);
6521     pxor(xcrc, xtmp);
6522   }
6523 }
6524 
6525 /**
6526  * 8-bit folds to compute 32-bit CRC
6527  *
6528  * uint64_t xcrc;
6529  * timesXtoThe32[xcrc &amp; 0xFF] ^ (xcrc &gt;&gt; 8);
6530  */
6531 void MacroAssembler::fold_8bit_crc32(XMMRegister xcrc, Register table, XMMRegister xtmp, Register tmp) {
6532   movdl(tmp, xcrc);
6533   andl(tmp, 0xFF);
6534   movdl(xtmp, Address(table, tmp, Address::times_4, 0));
6535   psrldq(xcrc, 1); // unsigned shift one byte
6536   pxor(xcrc, xtmp);
6537 }
6538 
6539 /**
6540  * uint32_t crc;
6541  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
6542  */
6543 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
6544   movl(tmp, crc);
6545   andl(tmp, 0xFF);
6546   shrl(crc, 8);
6547   xorl(crc, Address(table, tmp, Address::times_4, 0));
6548 }
6549 
6550 /**
6551  * @param crc   register containing existing CRC (32-bit)
6552  * @param buf   register pointing to input byte buffer (byte*)
6553  * @param len   register containing number of bytes
6554  * @param table register that will contain address of CRC table
6555  * @param tmp   scratch register
6556  */
6557 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp) {
6558   assert_different_registers(crc, buf, len, table, tmp, rax);
6559 
6560   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
6561   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
6562 
6563   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
6564   // context for the registers used, where all instructions below are using 128-bit mode
6565   // On EVEX without VL and BW, these instructions will all be AVX.
6566   lea(table, ExternalAddress(StubRoutines::crc_table_addr()));
6567   notl(crc); // ~crc
6568   cmpl(len, 16);
6569   jcc(Assembler::less, L_tail);
6570 
6571   // Align buffer to 16 bytes
6572   movl(tmp, buf);
6573   andl(tmp, 0xF);
6574   jccb(Assembler::zero, L_aligned);
6575   subl(tmp,  16);
6576   addl(len, tmp);
6577 
6578   align(4);
6579   BIND(L_align_loop);
6580   movsbl(rax, Address(buf, 0)); // load byte with sign extension
6581   update_byte_crc32(crc, rax, table);
6582   increment(buf);
6583   incrementl(tmp);
6584   jccb(Assembler::less, L_align_loop);
6585 
6586   BIND(L_aligned);
6587   movl(tmp, len); // save
6588   shrl(len, 4);
6589   jcc(Assembler::zero, L_tail_restore);
6590 
6591   // Fold crc into first bytes of vector
6592   movdqa(xmm1, Address(buf, 0));
6593   movdl(rax, xmm1);
6594   xorl(crc, rax);
6595   if (VM_Version::supports_sse4_1()) {
6596     pinsrd(xmm1, crc, 0);
6597   } else {
6598     pinsrw(xmm1, crc, 0);
6599     shrl(crc, 16);
6600     pinsrw(xmm1, crc, 1);
6601   }
6602   addptr(buf, 16);
6603   subl(len, 4); // len &gt; 0
6604   jcc(Assembler::less, L_fold_tail);
6605 
6606   movdqa(xmm2, Address(buf,  0));
6607   movdqa(xmm3, Address(buf, 16));
6608   movdqa(xmm4, Address(buf, 32));
6609   addptr(buf, 48);
6610   subl(len, 3);
6611   jcc(Assembler::lessEqual, L_fold_512b);
6612 
6613   // Fold total 512 bits of polynomial on each iteration,
6614   // 128 bits per each of 4 parallel streams.
6615   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));
6616 
6617   align(32);
6618   BIND(L_fold_512b_loop);
6619   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
6620   fold_128bit_crc32(xmm2, xmm0, xmm5, buf, 16);
6621   fold_128bit_crc32(xmm3, xmm0, xmm5, buf, 32);
6622   fold_128bit_crc32(xmm4, xmm0, xmm5, buf, 48);
6623   addptr(buf, 64);
6624   subl(len, 4);
6625   jcc(Assembler::greater, L_fold_512b_loop);
6626 
6627   // Fold 512 bits to 128 bits.
6628   BIND(L_fold_512b);
6629   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
6630   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm2);
6631   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm3);
6632   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm4);
6633 
6634   // Fold the rest of 128 bits data chunks
6635   BIND(L_fold_tail);
6636   addl(len, 3);
6637   jccb(Assembler::lessEqual, L_fold_128b);
6638   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
6639 
6640   BIND(L_fold_tail_loop);
6641   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
6642   addptr(buf, 16);
6643   decrementl(len);
6644   jccb(Assembler::greater, L_fold_tail_loop);
6645 
6646   // Fold 128 bits in xmm1 down into 32 bits in crc register.
6647   BIND(L_fold_128b);
6648   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));
6649   if (UseAVX &gt; 0) {
6650     vpclmulqdq(xmm2, xmm0, xmm1, 0x1);
6651     vpand(xmm3, xmm0, xmm2, 0 /* vector_len */);
6652     vpclmulqdq(xmm0, xmm0, xmm3, 0x1);
6653   } else {
6654     movdqa(xmm2, xmm0);
6655     pclmulqdq(xmm2, xmm1, 0x1);
6656     movdqa(xmm3, xmm0);
6657     pand(xmm3, xmm2);
6658     pclmulqdq(xmm0, xmm3, 0x1);
6659   }
6660   psrldq(xmm1, 8);
6661   psrldq(xmm2, 4);
6662   pxor(xmm0, xmm1);
6663   pxor(xmm0, xmm2);
6664 
6665   // 8 8-bit folds to compute 32-bit CRC.
6666   for (int j = 0; j &lt; 4; j++) {
6667     fold_8bit_crc32(xmm0, table, xmm1, rax);
6668   }
6669   movdl(crc, xmm0); // mov 32 bits to general register
6670   for (int j = 0; j &lt; 4; j++) {
6671     fold_8bit_crc32(crc, table, rax);
6672   }
6673 
6674   BIND(L_tail_restore);
6675   movl(len, tmp); // restore
6676   BIND(L_tail);
6677   andl(len, 0xf);
6678   jccb(Assembler::zero, L_exit);
6679 
6680   // Fold the rest of bytes
6681   align(4);
6682   BIND(L_tail_loop);
6683   movsbl(rax, Address(buf, 0)); // load byte with sign extension
6684   update_byte_crc32(crc, rax, table);
6685   increment(buf);
6686   decrementl(len);
6687   jccb(Assembler::greater, L_tail_loop);
6688 
6689   BIND(L_exit);
6690   notl(crc); // ~c
6691 }
6692 
6693 #ifdef _LP64
6694 // S. Gueron / Information Processing Letters 112 (2012) 184
6695 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
6696 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
6697 // Output: the 64-bit carry-less product of B * CONST
6698 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
6699                                      Register tmp1, Register tmp2, Register tmp3) {
6700   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
6701   if (n &gt; 0) {
6702     addq(tmp3, n * 256 * 8);
6703   }
6704   //    Q1 = TABLEExt[n][B &amp; 0xFF];
6705   movl(tmp1, in);
6706   andl(tmp1, 0x000000FF);
6707   shll(tmp1, 3);
6708   addq(tmp1, tmp3);
6709   movq(tmp1, Address(tmp1, 0));
6710 
6711   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
6712   movl(tmp2, in);
6713   shrl(tmp2, 8);
6714   andl(tmp2, 0x000000FF);
6715   shll(tmp2, 3);
6716   addq(tmp2, tmp3);
6717   movq(tmp2, Address(tmp2, 0));
6718 
6719   shlq(tmp2, 8);
6720   xorq(tmp1, tmp2);
6721 
6722   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
6723   movl(tmp2, in);
6724   shrl(tmp2, 16);
6725   andl(tmp2, 0x000000FF);
6726   shll(tmp2, 3);
6727   addq(tmp2, tmp3);
6728   movq(tmp2, Address(tmp2, 0));
6729 
6730   shlq(tmp2, 16);
6731   xorq(tmp1, tmp2);
6732 
6733   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
6734   shrl(in, 24);
6735   andl(in, 0x000000FF);
6736   shll(in, 3);
6737   addq(in, tmp3);
6738   movq(in, Address(in, 0));
6739 
6740   shlq(in, 24);
6741   xorq(in, tmp1);
6742   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
6743 }
6744 
6745 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
6746                                       Register in_out,
6747                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
6748                                       XMMRegister w_xtmp2,
6749                                       Register tmp1,
6750                                       Register n_tmp2, Register n_tmp3) {
6751   if (is_pclmulqdq_supported) {
6752     movdl(w_xtmp1, in_out); // modified blindly
6753 
6754     movl(tmp1, const_or_pre_comp_const_index);
6755     movdl(w_xtmp2, tmp1);
6756     pclmulqdq(w_xtmp1, w_xtmp2, 0);
6757 
6758     movdq(in_out, w_xtmp1);
6759   } else {
6760     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3);
6761   }
6762 }
6763 
6764 // Recombination Alternative 2: No bit-reflections
6765 // T1 = (CRC_A * U1) &lt;&lt; 1
6766 // T2 = (CRC_B * U2) &lt;&lt; 1
6767 // C1 = T1 &gt;&gt; 32
6768 // C2 = T2 &gt;&gt; 32
6769 // T1 = T1 &amp; 0xFFFFFFFF
6770 // T2 = T2 &amp; 0xFFFFFFFF
6771 // T1 = CRC32(0, T1)
6772 // T2 = CRC32(0, T2)
6773 // C1 = C1 ^ T1
6774 // C2 = C2 ^ T2
6775 // CRC = C1 ^ C2 ^ CRC_C
6776 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
6777                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
6778                                      Register tmp1, Register tmp2,
6779                                      Register n_tmp3) {
6780   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
6781   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
6782   shlq(in_out, 1);
6783   movl(tmp1, in_out);
6784   shrq(in_out, 32);
6785   xorl(tmp2, tmp2);
6786   crc32(tmp2, tmp1, 4);
6787   xorl(in_out, tmp2); // we don&#39;t care about upper 32 bit contents here
6788   shlq(in1, 1);
6789   movl(tmp1, in1);
6790   shrq(in1, 32);
6791   xorl(tmp2, tmp2);
6792   crc32(tmp2, tmp1, 4);
6793   xorl(in1, tmp2);
6794   xorl(in_out, in1);
6795   xorl(in_out, in2);
6796 }
6797 
6798 // Set N to predefined value
6799 // Subtract from a lenght of a buffer
6800 // execute in a loop:
6801 // CRC_A = 0xFFFFFFFF, CRC_B = 0, CRC_C = 0
6802 // for i = 1 to N do
6803 //  CRC_A = CRC32(CRC_A, A[i])
6804 //  CRC_B = CRC32(CRC_B, B[i])
6805 //  CRC_C = CRC32(CRC_C, C[i])
6806 // end for
6807 // Recombine
6808 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
6809                                        Register in_out1, Register in_out2, Register in_out3,
6810                                        Register tmp1, Register tmp2, Register tmp3,
6811                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
6812                                        Register tmp4, Register tmp5,
6813                                        Register n_tmp6) {
6814   Label L_processPartitions;
6815   Label L_processPartition;
6816   Label L_exit;
6817 
6818   bind(L_processPartitions);
6819   cmpl(in_out1, 3 * size);
6820   jcc(Assembler::less, L_exit);
6821     xorl(tmp1, tmp1);
6822     xorl(tmp2, tmp2);
6823     movq(tmp3, in_out2);
6824     addq(tmp3, size);
6825 
6826     bind(L_processPartition);
6827       crc32(in_out3, Address(in_out2, 0), 8);
6828       crc32(tmp1, Address(in_out2, size), 8);
6829       crc32(tmp2, Address(in_out2, size * 2), 8);
6830       addq(in_out2, 8);
6831       cmpq(in_out2, tmp3);
6832       jcc(Assembler::less, L_processPartition);
6833     crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
6834             w_xtmp1, w_xtmp2, w_xtmp3,
6835             tmp4, tmp5,
6836             n_tmp6);
6837     addq(in_out2, 2 * size);
6838     subl(in_out1, 3 * size);
6839     jmp(L_processPartitions);
6840 
6841   bind(L_exit);
6842 }
6843 #else
6844 void MacroAssembler::crc32c_ipl_alg4(Register in_out, uint32_t n,
6845                                      Register tmp1, Register tmp2, Register tmp3,
6846                                      XMMRegister xtmp1, XMMRegister xtmp2) {
6847   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
6848   if (n &gt; 0) {
6849     addl(tmp3, n * 256 * 8);
6850   }
6851   //    Q1 = TABLEExt[n][B &amp; 0xFF];
6852   movl(tmp1, in_out);
6853   andl(tmp1, 0x000000FF);
6854   shll(tmp1, 3);
6855   addl(tmp1, tmp3);
6856   movq(xtmp1, Address(tmp1, 0));
6857 
6858   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
6859   movl(tmp2, in_out);
6860   shrl(tmp2, 8);
6861   andl(tmp2, 0x000000FF);
6862   shll(tmp2, 3);
6863   addl(tmp2, tmp3);
6864   movq(xtmp2, Address(tmp2, 0));
6865 
6866   psllq(xtmp2, 8);
6867   pxor(xtmp1, xtmp2);
6868 
6869   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
6870   movl(tmp2, in_out);
6871   shrl(tmp2, 16);
6872   andl(tmp2, 0x000000FF);
6873   shll(tmp2, 3);
6874   addl(tmp2, tmp3);
6875   movq(xtmp2, Address(tmp2, 0));
6876 
6877   psllq(xtmp2, 16);
6878   pxor(xtmp1, xtmp2);
6879 
6880   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
6881   shrl(in_out, 24);
6882   andl(in_out, 0x000000FF);
6883   shll(in_out, 3);
6884   addl(in_out, tmp3);
6885   movq(xtmp2, Address(in_out, 0));
6886 
6887   psllq(xtmp2, 24);
6888   pxor(xtmp1, xtmp2); // Result in CXMM
6889   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
6890 }
6891 
6892 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
6893                                       Register in_out,
6894                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
6895                                       XMMRegister w_xtmp2,
6896                                       Register tmp1,
6897                                       Register n_tmp2, Register n_tmp3) {
6898   if (is_pclmulqdq_supported) {
6899     movdl(w_xtmp1, in_out);
6900 
6901     movl(tmp1, const_or_pre_comp_const_index);
6902     movdl(w_xtmp2, tmp1);
6903     pclmulqdq(w_xtmp1, w_xtmp2, 0);
6904     // Keep result in XMM since GPR is 32 bit in length
6905   } else {
6906     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3, w_xtmp1, w_xtmp2);
6907   }
6908 }
6909 
6910 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
6911                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
6912                                      Register tmp1, Register tmp2,
6913                                      Register n_tmp3) {
6914   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
6915   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
6916 
6917   psllq(w_xtmp1, 1);
6918   movdl(tmp1, w_xtmp1);
6919   psrlq(w_xtmp1, 32);
6920   movdl(in_out, w_xtmp1);
6921 
6922   xorl(tmp2, tmp2);
6923   crc32(tmp2, tmp1, 4);
6924   xorl(in_out, tmp2);
6925 
6926   psllq(w_xtmp2, 1);
6927   movdl(tmp1, w_xtmp2);
6928   psrlq(w_xtmp2, 32);
6929   movdl(in1, w_xtmp2);
6930 
6931   xorl(tmp2, tmp2);
6932   crc32(tmp2, tmp1, 4);
6933   xorl(in1, tmp2);
6934   xorl(in_out, in1);
6935   xorl(in_out, in2);
6936 }
6937 
6938 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
6939                                        Register in_out1, Register in_out2, Register in_out3,
6940                                        Register tmp1, Register tmp2, Register tmp3,
6941                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
6942                                        Register tmp4, Register tmp5,
6943                                        Register n_tmp6) {
6944   Label L_processPartitions;
6945   Label L_processPartition;
6946   Label L_exit;
6947 
6948   bind(L_processPartitions);
6949   cmpl(in_out1, 3 * size);
6950   jcc(Assembler::less, L_exit);
6951     xorl(tmp1, tmp1);
6952     xorl(tmp2, tmp2);
6953     movl(tmp3, in_out2);
6954     addl(tmp3, size);
6955 
6956     bind(L_processPartition);
6957       crc32(in_out3, Address(in_out2, 0), 4);
6958       crc32(tmp1, Address(in_out2, size), 4);
6959       crc32(tmp2, Address(in_out2, size*2), 4);
6960       crc32(in_out3, Address(in_out2, 0+4), 4);
6961       crc32(tmp1, Address(in_out2, size+4), 4);
6962       crc32(tmp2, Address(in_out2, size*2+4), 4);
6963       addl(in_out2, 8);
6964       cmpl(in_out2, tmp3);
6965       jcc(Assembler::less, L_processPartition);
6966 
6967         push(tmp3);
6968         push(in_out1);
6969         push(in_out2);
6970         tmp4 = tmp3;
6971         tmp5 = in_out1;
6972         n_tmp6 = in_out2;
6973 
6974       crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
6975             w_xtmp1, w_xtmp2, w_xtmp3,
6976             tmp4, tmp5,
6977             n_tmp6);
6978 
6979         pop(in_out2);
6980         pop(in_out1);
6981         pop(tmp3);
6982 
6983     addl(in_out2, 2 * size);
6984     subl(in_out1, 3 * size);
6985     jmp(L_processPartitions);
6986 
6987   bind(L_exit);
6988 }
6989 #endif //LP64
6990 
6991 #ifdef _LP64
6992 // Algorithm 2: Pipelined usage of the CRC32 instruction.
6993 // Input: A buffer I of L bytes.
6994 // Output: the CRC32C value of the buffer.
6995 // Notations:
6996 // Write L = 24N + r, with N = floor (L/24).
6997 // r = L mod 24 (0 &lt;= r &lt; 24).
6998 // Consider I as the concatenation of A|B|C|R, where A, B, C, each,
6999 // N quadwords, and R consists of r bytes.
7000 // A[j] = I [8j+7:8j], j= 0, 1, ..., N-1
7001 // B[j] = I [N + 8j+7:N + 8j], j= 0, 1, ..., N-1
7002 // C[j] = I [2N + 8j+7:2N + 8j], j= 0, 1, ..., N-1
7003 // if r &gt; 0 R[j] = I [3N +j], j= 0, 1, ...,r-1
7004 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7005                                           Register tmp1, Register tmp2, Register tmp3,
7006                                           Register tmp4, Register tmp5, Register tmp6,
7007                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7008                                           bool is_pclmulqdq_supported) {
7009   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7010   Label L_wordByWord;
7011   Label L_byteByByteProlog;
7012   Label L_byteByByte;
7013   Label L_exit;
7014 
7015   if (is_pclmulqdq_supported ) {
7016     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7017     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);
7018 
7019     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7020     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7021 
7022     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7023     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7024     assert((CRC32C_NUM_PRECOMPUTED_CONSTANTS - 1 ) == 5, &quot;Checking whether you declared all of the constants based on the number of \&quot;chunks\&quot;&quot;);
7025   } else {
7026     const_or_pre_comp_const_index[0] = 1;
7027     const_or_pre_comp_const_index[1] = 0;
7028 
7029     const_or_pre_comp_const_index[2] = 3;
7030     const_or_pre_comp_const_index[3] = 2;
7031 
7032     const_or_pre_comp_const_index[4] = 5;
7033     const_or_pre_comp_const_index[5] = 4;
7034    }
7035   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7036                     in2, in1, in_out,
7037                     tmp1, tmp2, tmp3,
7038                     w_xtmp1, w_xtmp2, w_xtmp3,
7039                     tmp4, tmp5,
7040                     tmp6);
7041   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7042                     in2, in1, in_out,
7043                     tmp1, tmp2, tmp3,
7044                     w_xtmp1, w_xtmp2, w_xtmp3,
7045                     tmp4, tmp5,
7046                     tmp6);
7047   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7048                     in2, in1, in_out,
7049                     tmp1, tmp2, tmp3,
7050                     w_xtmp1, w_xtmp2, w_xtmp3,
7051                     tmp4, tmp5,
7052                     tmp6);
7053   movl(tmp1, in2);
7054   andl(tmp1, 0x00000007);
7055   negl(tmp1);
7056   addl(tmp1, in2);
7057   addq(tmp1, in1);
7058 
7059   BIND(L_wordByWord);
7060   cmpq(in1, tmp1);
7061   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7062     crc32(in_out, Address(in1, 0), 4);
7063     addq(in1, 4);
7064     jmp(L_wordByWord);
7065 
7066   BIND(L_byteByByteProlog);
7067   andl(in2, 0x00000007);
7068   movl(tmp2, 1);
7069 
7070   BIND(L_byteByByte);
7071   cmpl(tmp2, in2);
7072   jccb(Assembler::greater, L_exit);
7073     crc32(in_out, Address(in1, 0), 1);
7074     incq(in1);
7075     incl(tmp2);
7076     jmp(L_byteByByte);
7077 
7078   BIND(L_exit);
7079 }
7080 #else
7081 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
7082                                           Register tmp1, Register  tmp2, Register tmp3,
7083                                           Register tmp4, Register  tmp5, Register tmp6,
7084                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7085                                           bool is_pclmulqdq_supported) {
7086   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
7087   Label L_wordByWord;
7088   Label L_byteByByteProlog;
7089   Label L_byteByByte;
7090   Label L_exit;
7091 
7092   if (is_pclmulqdq_supported) {
7093     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
7094     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);
7095 
7096     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
7097     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
7098 
7099     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
7100     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
7101   } else {
7102     const_or_pre_comp_const_index[0] = 1;
7103     const_or_pre_comp_const_index[1] = 0;
7104 
7105     const_or_pre_comp_const_index[2] = 3;
7106     const_or_pre_comp_const_index[3] = 2;
7107 
7108     const_or_pre_comp_const_index[4] = 5;
7109     const_or_pre_comp_const_index[5] = 4;
7110   }
7111   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
7112                     in2, in1, in_out,
7113                     tmp1, tmp2, tmp3,
7114                     w_xtmp1, w_xtmp2, w_xtmp3,
7115                     tmp4, tmp5,
7116                     tmp6);
7117   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
7118                     in2, in1, in_out,
7119                     tmp1, tmp2, tmp3,
7120                     w_xtmp1, w_xtmp2, w_xtmp3,
7121                     tmp4, tmp5,
7122                     tmp6);
7123   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
7124                     in2, in1, in_out,
7125                     tmp1, tmp2, tmp3,
7126                     w_xtmp1, w_xtmp2, w_xtmp3,
7127                     tmp4, tmp5,
7128                     tmp6);
7129   movl(tmp1, in2);
7130   andl(tmp1, 0x00000007);
7131   negl(tmp1);
7132   addl(tmp1, in2);
7133   addl(tmp1, in1);
7134 
7135   BIND(L_wordByWord);
7136   cmpl(in1, tmp1);
7137   jcc(Assembler::greaterEqual, L_byteByByteProlog);
7138     crc32(in_out, Address(in1,0), 4);
7139     addl(in1, 4);
7140     jmp(L_wordByWord);
7141 
7142   BIND(L_byteByByteProlog);
7143   andl(in2, 0x00000007);
7144   movl(tmp2, 1);
7145 
7146   BIND(L_byteByByte);
7147   cmpl(tmp2, in2);
7148   jccb(Assembler::greater, L_exit);
7149     movb(tmp1, Address(in1, 0));
7150     crc32(in_out, tmp1, 1);
7151     incl(in1);
7152     incl(tmp2);
7153     jmp(L_byteByByte);
7154 
7155   BIND(L_exit);
7156 }
7157 #endif // LP64
7158 #undef BIND
7159 #undef BLOCK_COMMENT
7160 
7161 // Compress char[] array to byte[].
7162 //   ..\jdk\src\java.base\share\classes\java\lang\StringUTF16.java
7163 //   @HotSpotIntrinsicCandidate
7164 //   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
7165 //     for (int i = 0; i &lt; len; i++) {
7166 //       int c = src[srcOff++];
7167 //       if (c &gt;&gt;&gt; 8 != 0) {
7168 //         return 0;
7169 //       }
7170 //       dst[dstOff++] = (byte)c;
7171 //     }
7172 //     return len;
7173 //   }
7174 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
7175   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
7176   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
7177   Register tmp5, Register result) {
7178   Label copy_chars_loop, return_length, return_zero, done;
7179 
7180   // rsi: src
7181   // rdi: dst
7182   // rdx: len
7183   // rcx: tmp5
7184   // rax: result
7185 
7186   // rsi holds start addr of source char[] to be compressed
7187   // rdi holds start addr of destination byte[]
7188   // rdx holds length
7189 
7190   assert(len != result, &quot;&quot;);
7191 
7192   // save length for return
7193   push(len);
7194 
7195   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
7196     VM_Version::supports_avx512vlbw() &amp;&amp;
7197     VM_Version::supports_bmi2()) {
7198 
7199     Label copy_32_loop, copy_loop_tail, below_threshold;
7200 
7201     // alignment
7202     Label post_alignment;
7203 
7204     // if length of the string is less than 16, handle it in an old fashioned way
7205     testl(len, -32);
7206     jcc(Assembler::zero, below_threshold);
7207 
7208     // First check whether a character is compressable ( &lt;= 0xFF).
7209     // Create mask to test for Unicode chars inside zmm vector
7210     movl(result, 0x00FF);
7211     evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);
7212 
7213     testl(len, -64);
7214     jcc(Assembler::zero, post_alignment);
7215 
7216     movl(tmp5, dst);
7217     andl(tmp5, (32 - 1));
7218     negl(tmp5);
7219     andl(tmp5, (32 - 1));
7220 
7221     // bail out when there is nothing to be done
7222     testl(tmp5, 0xFFFFFFFF);
7223     jcc(Assembler::zero, post_alignment);
7224 
7225     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7226     movl(result, 0xFFFFFFFF);
7227     shlxl(result, result, tmp5);
7228     notl(result);
7229     kmovdl(k3, result);
7230 
7231     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7232     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7233     ktestd(k2, k3);
7234     jcc(Assembler::carryClear, return_zero);
7235 
7236     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7237 
7238     addptr(src, tmp5);
7239     addptr(src, tmp5);
7240     addptr(dst, tmp5);
7241     subl(len, tmp5);
7242 
7243     bind(post_alignment);
7244     // end of alignment
7245 
7246     movl(tmp5, len);
7247     andl(tmp5, (32 - 1));    // tail count (in chars)
7248     andl(len, ~(32 - 1));    // vector count (in chars)
7249     jcc(Assembler::zero, copy_loop_tail);
7250 
7251     lea(src, Address(src, len, Address::times_2));
7252     lea(dst, Address(dst, len, Address::times_1));
7253     negptr(len);
7254 
7255     bind(copy_32_loop);
7256     evmovdquw(tmp1Reg, Address(src, len, Address::times_2), Assembler::AVX_512bit);
7257     evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7258     kortestdl(k2, k2);
7259     jcc(Assembler::carryClear, return_zero);
7260 
7261     // All elements in current processed chunk are valid candidates for
7262     // compression. Write a truncated byte elements to the memory.
7263     evpmovwb(Address(dst, len, Address::times_1), tmp1Reg, Assembler::AVX_512bit);
7264     addptr(len, 32);
7265     jcc(Assembler::notZero, copy_32_loop);
7266 
7267     bind(copy_loop_tail);
7268     // bail out when there is nothing to be done
7269     testl(tmp5, 0xFFFFFFFF);
7270     jcc(Assembler::zero, return_length);
7271 
7272     movl(len, tmp5);
7273 
7274     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
7275     movl(result, 0xFFFFFFFF);
7276     shlxl(result, result, len);
7277     notl(result);
7278 
7279     kmovdl(k3, result);
7280 
7281     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
7282     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
7283     ktestd(k2, k3);
7284     jcc(Assembler::carryClear, return_zero);
7285 
7286     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
7287     jmp(return_length);
7288 
7289     bind(below_threshold);
7290   }
7291 
7292   if (UseSSE42Intrinsics) {
7293     Label copy_32_loop, copy_16, copy_tail;
7294 
7295     movl(result, len);
7296 
7297     movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vectors
7298 
7299     // vectored compression
7300     andl(len, 0xfffffff0);    // vector count (in chars)
7301     andl(result, 0x0000000f);    // tail count (in chars)
7302     testl(len, len);
7303     jcc(Assembler::zero, copy_16);
7304 
7305     // compress 16 chars per iter
7306     movdl(tmp1Reg, tmp5);
7307     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
7308     pxor(tmp4Reg, tmp4Reg);
7309 
7310     lea(src, Address(src, len, Address::times_2));
7311     lea(dst, Address(dst, len, Address::times_1));
7312     negptr(len);
7313 
7314     bind(copy_32_loop);
7315     movdqu(tmp2Reg, Address(src, len, Address::times_2));     // load 1st 8 characters
7316     por(tmp4Reg, tmp2Reg);
7317     movdqu(tmp3Reg, Address(src, len, Address::times_2, 16)); // load next 8 characters
7318     por(tmp4Reg, tmp3Reg);
7319     ptest(tmp4Reg, tmp1Reg);       // check for Unicode chars in next vector
7320     jcc(Assembler::notZero, return_zero);
7321     packuswb(tmp2Reg, tmp3Reg);    // only ASCII chars; compress each to 1 byte
7322     movdqu(Address(dst, len, Address::times_1), tmp2Reg);
7323     addptr(len, 16);
7324     jcc(Assembler::notZero, copy_32_loop);
7325 
7326     // compress next vector of 8 chars (if any)
7327     bind(copy_16);
7328     movl(len, result);
7329     andl(len, 0xfffffff8);    // vector count (in chars)
7330     andl(result, 0x00000007);    // tail count (in chars)
7331     testl(len, len);
7332     jccb(Assembler::zero, copy_tail);
7333 
7334     movdl(tmp1Reg, tmp5);
7335     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
7336     pxor(tmp3Reg, tmp3Reg);
7337 
7338     movdqu(tmp2Reg, Address(src, 0));
7339     ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in vector
7340     jccb(Assembler::notZero, return_zero);
7341     packuswb(tmp2Reg, tmp3Reg);    // only LATIN1 chars; compress each to 1 byte
7342     movq(Address(dst, 0), tmp2Reg);
7343     addptr(src, 16);
7344     addptr(dst, 8);
7345 
7346     bind(copy_tail);
7347     movl(len, result);
7348   }
7349   // compress 1 char per iter
7350   testl(len, len);
7351   jccb(Assembler::zero, return_length);
7352   lea(src, Address(src, len, Address::times_2));
7353   lea(dst, Address(dst, len, Address::times_1));
7354   negptr(len);
7355 
7356   bind(copy_chars_loop);
7357   load_unsigned_short(result, Address(src, len, Address::times_2));
7358   testl(result, 0xff00);      // check if Unicode char
7359   jccb(Assembler::notZero, return_zero);
7360   movb(Address(dst, len, Address::times_1), result);  // ASCII char; compress to 1 byte
7361   increment(len);
7362   jcc(Assembler::notZero, copy_chars_loop);
7363 
7364   // if compression succeeded, return length
7365   bind(return_length);
7366   pop(result);
7367   jmpb(done);
7368 
7369   // if compression failed, return 0
7370   bind(return_zero);
7371   xorl(result, result);
7372   addptr(rsp, wordSize);
7373 
7374   bind(done);
7375 }
7376 
7377 // Inflate byte[] array to char[].
7378 //   ..\jdk\src\java.base\share\classes\java\lang\StringLatin1.java
7379 //   @HotSpotIntrinsicCandidate
7380 //   private static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
7381 //     for (int i = 0; i &lt; len; i++) {
7382 //       dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
7383 //     }
7384 //   }
7385 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
7386   XMMRegister tmp1, Register tmp2) {
7387   Label copy_chars_loop, done, below_threshold, avx3_threshold;
7388   // rsi: src
7389   // rdi: dst
7390   // rdx: len
7391   // rcx: tmp2
7392 
7393   // rsi holds start addr of source byte[] to be inflated
7394   // rdi holds start addr of destination char[]
7395   // rdx holds length
7396   assert_different_registers(src, dst, len, tmp2);
7397   movl(tmp2, len);
7398   if ((UseAVX &gt; 2) &amp;&amp; // AVX512
7399     VM_Version::supports_avx512vlbw() &amp;&amp;
7400     VM_Version::supports_bmi2()) {
7401 
7402     Label copy_32_loop, copy_tail;
7403     Register tmp3_aliased = len;
7404 
7405     // if length of the string is less than 16, handle it in an old fashioned way
7406     testl(len, -16);
7407     jcc(Assembler::zero, below_threshold);
7408 
7409     testl(len, -1 * AVX3Threshold);
7410     jcc(Assembler::zero, avx3_threshold);
7411 
7412     // In order to use only one arithmetic operation for the main loop we use
7413     // this pre-calculation
7414     andl(tmp2, (32 - 1)); // tail count (in chars), 32 element wide loop
7415     andl(len, -32);     // vector count
7416     jccb(Assembler::zero, copy_tail);
7417 
7418     lea(src, Address(src, len, Address::times_1));
7419     lea(dst, Address(dst, len, Address::times_2));
7420     negptr(len);
7421 
7422 
7423     // inflate 32 chars per iter
7424     bind(copy_32_loop);
7425     vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_512bit);
7426     evmovdquw(Address(dst, len, Address::times_2), tmp1, Assembler::AVX_512bit);
7427     addptr(len, 32);
7428     jcc(Assembler::notZero, copy_32_loop);
7429 
7430     bind(copy_tail);
7431     // bail out when there is nothing to be done
7432     testl(tmp2, -1); // we don&#39;t destroy the contents of tmp2 here
7433     jcc(Assembler::zero, done);
7434 
7435     // ~(~0 &lt;&lt; length), where length is the # of remaining elements to process
7436     movl(tmp3_aliased, -1);
7437     shlxl(tmp3_aliased, tmp3_aliased, tmp2);
7438     notl(tmp3_aliased);
7439     kmovdl(k2, tmp3_aliased);
7440     evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);
7441     evmovdquw(Address(dst, 0), k2, tmp1, Assembler::AVX_512bit);
7442 
7443     jmp(done);
7444     bind(avx3_threshold);
7445   }
7446   if (UseSSE42Intrinsics) {
7447     Label copy_16_loop, copy_8_loop, copy_bytes, copy_new_tail, copy_tail;
7448 
7449     if (UseAVX &gt; 1) {
7450       andl(tmp2, (16 - 1));
7451       andl(len, -16);
7452       jccb(Assembler::zero, copy_new_tail);
7453     } else {
7454       andl(tmp2, 0x00000007);   // tail count (in chars)
7455       andl(len, 0xfffffff8);    // vector count (in chars)
7456       jccb(Assembler::zero, copy_tail);
7457     }
7458 
7459     // vectored inflation
7460     lea(src, Address(src, len, Address::times_1));
7461     lea(dst, Address(dst, len, Address::times_2));
7462     negptr(len);
7463 
7464     if (UseAVX &gt; 1) {
7465       bind(copy_16_loop);
7466       vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_256bit);
7467       vmovdqu(Address(dst, len, Address::times_2), tmp1);
7468       addptr(len, 16);
7469       jcc(Assembler::notZero, copy_16_loop);
7470 
7471       bind(below_threshold);
7472       bind(copy_new_tail);
7473       movl(len, tmp2);
7474       andl(tmp2, 0x00000007);
7475       andl(len, 0xFFFFFFF8);
7476       jccb(Assembler::zero, copy_tail);
7477 
7478       pmovzxbw(tmp1, Address(src, 0));
7479       movdqu(Address(dst, 0), tmp1);
7480       addptr(src, 8);
7481       addptr(dst, 2 * 8);
7482 
7483       jmp(copy_tail, true);
7484     }
7485 
7486     // inflate 8 chars per iter
7487     bind(copy_8_loop);
7488     pmovzxbw(tmp1, Address(src, len, Address::times_1));  // unpack to 8 words
7489     movdqu(Address(dst, len, Address::times_2), tmp1);
7490     addptr(len, 8);
7491     jcc(Assembler::notZero, copy_8_loop);
7492 
7493     bind(copy_tail);
7494     movl(len, tmp2);
7495 
7496     cmpl(len, 4);
7497     jccb(Assembler::less, copy_bytes);
7498 
7499     movdl(tmp1, Address(src, 0));  // load 4 byte chars
7500     pmovzxbw(tmp1, tmp1);
7501     movq(Address(dst, 0), tmp1);
7502     subptr(len, 4);
7503     addptr(src, 4);
7504     addptr(dst, 8);
7505 
7506     bind(copy_bytes);
7507   } else {
7508     bind(below_threshold);
7509   }
7510 
7511   testl(len, len);
7512   jccb(Assembler::zero, done);
7513   lea(src, Address(src, len, Address::times_1));
7514   lea(dst, Address(dst, len, Address::times_2));
7515   negptr(len);
7516 
7517   // inflate 1 char per iter
7518   bind(copy_chars_loop);
7519   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
7520   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
7521   increment(len);
7522   jcc(Assembler::notZero, copy_chars_loop);
7523 
7524   bind(done);
7525 }
7526 
7527 #ifdef _LP64
7528 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
7529   Label done;
7530   cvttss2sil(dst, src);
7531   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7532   cmpl(dst, 0x80000000); // float_sign_flip
7533   jccb(Assembler::notEqual, done);
7534   subptr(rsp, 8);
7535   movflt(Address(rsp, 0), src);
7536   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
7537   pop(dst);
7538   bind(done);
7539 }
7540 
7541 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
7542   Label done;
7543   cvttsd2sil(dst, src);
7544   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7545   cmpl(dst, 0x80000000); // float_sign_flip
7546   jccb(Assembler::notEqual, done);
7547   subptr(rsp, 8);
7548   movdbl(Address(rsp, 0), src);
7549   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
7550   pop(dst);
7551   bind(done);
7552 }
7553 
7554 void MacroAssembler::convert_f2l(Register dst, XMMRegister src) {
7555   Label done;
7556   cvttss2siq(dst, src);
7557   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
7558   jccb(Assembler::notEqual, done);
7559   subptr(rsp, 8);
7560   movflt(Address(rsp, 0), src);
7561   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
7562   pop(dst);
7563   bind(done);
7564 }
7565 
7566 void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {
7567   Label done;
7568   cvttsd2siq(dst, src);
7569   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
7570   jccb(Assembler::notEqual, done);
7571   subptr(rsp, 8);
7572   movdbl(Address(rsp, 0), src);
7573   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
7574   pop(dst);
7575   bind(done);
7576 }
7577 
7578 void MacroAssembler::cache_wb(Address line)
7579 {
7580   // 64 bit cpus always support clflush
7581   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
7582   bool optimized = VM_Version::supports_clflushopt();
7583   bool no_evict = VM_Version::supports_clwb();
7584 
7585   // prefer clwb (writeback without evict) otherwise
7586   // prefer clflushopt (potentially parallel writeback with evict)
7587   // otherwise fallback on clflush (serial writeback with evict)
7588 
7589   if (optimized) {
7590     if (no_evict) {
7591       clwb(line);
7592     } else {
7593       clflushopt(line);
7594     }
7595   } else {
7596     // no need for fence when using CLFLUSH
7597     clflush(line);
7598   }
7599 }
7600 
7601 void MacroAssembler::cache_wbsync(bool is_pre)
7602 {
7603   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
7604   bool optimized = VM_Version::supports_clflushopt();
7605   bool no_evict = VM_Version::supports_clwb();
7606 
7607   // pick the correct implementation
7608 
7609   if (!is_pre &amp;&amp; (optimized || no_evict)) {
7610     // need an sfence for post flush when using clflushopt or clwb
7611     // otherwise no no need for any synchroniaztion
7612 
7613     sfence();
7614   }
7615 }
7616 #endif // _LP64
7617 
7618 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
7619   switch (cond) {
7620     // Note some conditions are synonyms for others
7621     case Assembler::zero:         return Assembler::notZero;
7622     case Assembler::notZero:      return Assembler::zero;
7623     case Assembler::less:         return Assembler::greaterEqual;
7624     case Assembler::lessEqual:    return Assembler::greater;
7625     case Assembler::greater:      return Assembler::lessEqual;
7626     case Assembler::greaterEqual: return Assembler::less;
7627     case Assembler::below:        return Assembler::aboveEqual;
7628     case Assembler::belowEqual:   return Assembler::above;
7629     case Assembler::above:        return Assembler::belowEqual;
7630     case Assembler::aboveEqual:   return Assembler::below;
7631     case Assembler::overflow:     return Assembler::noOverflow;
7632     case Assembler::noOverflow:   return Assembler::overflow;
7633     case Assembler::negative:     return Assembler::positive;
7634     case Assembler::positive:     return Assembler::negative;
7635     case Assembler::parity:       return Assembler::noParity;
7636     case Assembler::noParity:     return Assembler::parity;
7637   }
7638   ShouldNotReachHere(); return Assembler::overflow;
7639 }
7640 
7641 SkipIfEqual::SkipIfEqual(
7642     MacroAssembler* masm, const bool* flag_addr, bool value) {
7643   _masm = masm;
7644   _masm-&gt;cmp8(ExternalAddress((address)flag_addr), value);
7645   _masm-&gt;jcc(Assembler::equal, _label);
7646 }
7647 
7648 SkipIfEqual::~SkipIfEqual() {
7649   _masm-&gt;bind(_label);
7650 }
7651 
7652 // 32-bit Windows has its own fast-path implementation
7653 // of get_thread
7654 #if !defined(WIN32) || defined(_LP64)
7655 
7656 // This is simply a call to Thread::current()
7657 void MacroAssembler::get_thread(Register thread) {
7658   if (thread != rax) {
7659     push(rax);
7660   }
7661   LP64_ONLY(push(rdi);)
7662   LP64_ONLY(push(rsi);)
7663   push(rdx);
7664   push(rcx);
7665 #ifdef _LP64
7666   push(r8);
7667   push(r9);
7668   push(r10);
7669   push(r11);
7670 #endif
7671 
7672   MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, Thread::current), 0);
7673 
7674 #ifdef _LP64
7675   pop(r11);
7676   pop(r10);
7677   pop(r9);
7678   pop(r8);
7679 #endif
7680   pop(rcx);
7681   pop(rdx);
7682   LP64_ONLY(pop(rsi);)
7683   LP64_ONLY(pop(rdi);)
7684   if (thread != rax) {
7685     mov(thread, rax);
7686     pop(rax);
7687   }
7688 }
7689 
7690 #endif // !WIN32 || _LP64
    </pre>
  </body>
</html>